<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/105034">
    <body>
      <group id="105034">
        <trans-unit id="68960fcc7ae0d6fd78f4a201eeb38fa8bb9a0ecf" translate="yes" xml:space="preserve">
          <source>&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</source>
          <target state="translated">&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</target>
        </trans-unit>
        <trans-unit id="a032d777f177ebd6e92855f3bce4c9d3de29d561" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;On jsbin&lt;/a&gt; if you want to test it.</source>
          <target state="translated">如果要测试，请&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;在jsbin&lt;/a&gt;上进行。</target>
        </trans-unit>
        <trans-unit id="54853102ac5288d10305ee4fe284f5676c8b3049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="518c3687d473e405f713a2e4202e1617f257a7bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="7de15d516266250876bf7df115f60af51b87ba40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a4bfa8acce2c58437408c5567e16ba754efc3619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be advised:&lt;/strong&gt; my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.</source>
          <target state="translated">&lt;strong&gt;忠告：&lt;/strong&gt;我的主要目标是展示和教授潜在的优化策略。 其他答案涵盖重要主题，例如冲突和真正的随机数，这对于生成良好的UUID至关重要。</target>
        </trans-unit>
        <trans-unit id="a8558249d3c59db88fd2392888164f8297752e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, can we get speed &lt;em&gt;and&lt;/em&gt; RFC compliance?  I say, YES!&lt;/strong&gt;  Can we maintain readability?  Well...  Not really, but it's easy if you follow along.</source>
          <target state="translated">&lt;strong&gt;但是，我们可以获得速度&lt;em&gt;和&lt;/em&gt; RFC合规性吗？&lt;/strong&gt; &lt;strong&gt;我说是！&lt;/strong&gt; 我们可以保持可读性吗？ 好吧...并非如此，但是如果您继续这样做很容易。</target>
        </trans-unit>
        <trans-unit id="0aa9a4872e5871a2d50503b7555d5a560abc60db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b79b40ec4e7164794f3d15d07d564b8ad8717468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit :&lt;/strong&gt;  I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;wikipedia article&lt;/a&gt;).  There is always a chance of collisions.  A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;我认为值得指出的是，没有GUID生成器可以保证唯一键（请参阅&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;Wikipedia文章&lt;/a&gt; ）。 总是有碰撞的机会。 GUID只是提供了足够大的键范围，以将冲突的变化减少到几乎为零。</target>
        </trans-unit>
        <trans-unit id="7015ec1e0155111b63b36ee572b6bff0228a4302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enjoy! :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请享用！&lt;/strong&gt; &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274339a4ddbe260b6a97172504035c73b5738ea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Features Generates RFC 4122 compliant UUIDs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;功能生成符合RFC 4122的UUID。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d77806e165bb48692701ad0de9af22b7850fba31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.empty&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.empty&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b0671d2fe50cfe5c11475ae51a2760cbcda6baf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cf7a599e78acfd69a7e284fa3d3b67982dccad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Install Using NPM:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用NPM安装：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf75b8ebe887aa6577cd720281924cbc349c929" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or Using uuid via browser:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;或通过浏览器使用uuid：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35889b4f21085883cbaa19da2a6b14684bd0aada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The algorithm:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;算法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b1935958bb975920d8012409acce290de08a28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The assembly:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;组装：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c002957f28f184ef81e532a83ab90120a2e876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UUID.js The RFC-compliant UUID generator for JavaScript.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UUID.js JavaScript的RFC兼容UUID生成器。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469336e52af17d529352df89c21d2a5435257e12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-06-02&lt;/strong&gt;:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses &lt;code&gt;Math.random()&lt;/code&gt; for brevity, however &lt;code&gt;Math.random()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to be a high-quality RNG.  See Adam Hyland's &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;excellent writeup on Math.random()&lt;/a&gt; for details.  For a more robust solution, consider something like &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;the uuid module&lt;/a&gt; (disclaimer: I, @broofa, am the author), which uses higher quality RNG APIs where available.</source>
          <target state="translated">&lt;strong&gt;更新，2015-06-02&lt;/strong&gt; ：请注意，UUID的唯一性在很大程度上取决于基础随机数生成器（RNG）。 为了简洁起见，以上解决方案使用 &lt;code&gt;Math.random()&lt;/code&gt; ，但是&lt;em&gt;不能&lt;/em&gt;保证 &lt;code&gt;Math.random()&lt;/code&gt; 是高质量的RNG。 有关详细信息，请参见Adam Hyland &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;在Math.random（）上&lt;/a&gt;的出色文章 。 要获得更强大的解决方案，请考虑&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;使用uuid模块&lt;/a&gt; （免责声明：我，@ broofa，作者）之类的东西， 该模块会在可用时使用更高质量的RNG API。</target>
        </trans-unit>
        <trans-unit id="be0809af7361460fb45bdf84889bab84728f5e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-08-26&lt;/strong&gt;: As a side-note, this &lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;gist&lt;/a&gt; describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10&lt;sup&gt;15&lt;/sup&gt; version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.</source>
          <target state="translated">&lt;strong&gt;更新，2015-08-26&lt;/strong&gt; ：作为一个旁注，本&lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;要点&lt;/a&gt;描述了如何确定在达到一定的碰撞概率之前可以生成多少个ID。 例如，使用3.26x10 &lt;sup&gt;15&lt;/sup&gt;版本4 RFC4122 UUID，您有百万分之一的碰撞机会。</target>
        </trans-unit>
        <trans-unit id="8fd4ff892cec4b2ce586409848ac995315f7db82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2017-06-28&lt;/strong&gt;: A &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;good article from Chrome developers&lt;/a&gt; discussing the state of Math.random PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it's &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here's an updated version of the above solution that uses ES6, the &lt;code&gt;crypto&lt;/code&gt; API, and &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;a bit of JS wizardry I can't take credit for&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;更新，2017-06-28&lt;/strong&gt; ： &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;Chrome开发人员的一篇好文章，&lt;/a&gt;讨论了Chrome，Firefox和Safari中Math.random PRNG的质量状态。 tl; dr-截至2015年末，它的&amp;ldquo;相当好&amp;rdquo;，但没有加密质量。 为了解决该问题，这是上述解决方案的更新版本，该解决方案使用ES6， &lt;code&gt;crypto&lt;/code&gt; API和&lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;一些JS向导，我对此不以为然&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="1395f19d7608f025cb58cb5b03b266e650d27c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2020-01-06&lt;/strong&gt;: There is a &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;proposal in the works&lt;/a&gt; for a standard &lt;code&gt;uuid&lt;/code&gt; module as part of the JS language</source>
          <target state="translated">&lt;strong&gt;2020年1月6日更新&lt;/strong&gt; ：工作中有一项&lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;建议，建议&lt;/a&gt;将标准 &lt;code&gt;uuid&lt;/code&gt; 模块作为JS语言的一部分</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="782117c6d143f47d437449ef980ce5c3b76b9beb" translate="yes" xml:space="preserve">
          <source>A popular Open Source tool for working with UUIDs in JavaScript is &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;是一种流行的用于在JavaScript中使用UUID的开源工具。</target>
        </trans-unit>
        <trans-unit id="ba3de79909c92e381cfcb7d2ad3bb6d12b74b04d" translate="yes" xml:space="preserve">
          <source>A version based on Briguy37's answer and some bitwise operators to extract nibble sized windows from the buffer.</source>
          <target state="translated">基于Briguy37的答案和一些位运算符的版本,从缓冲区中提取nibble大小的窗口。</target>
        </trans-unit>
        <trans-unit id="8b32b76d7d98de48b1c8d4fca55b71b36e586c91" translate="yes" xml:space="preserve">
          <source>A web service would be useful.</source>
          <target state="translated">一个网络服务将是有用的。</target>
        </trans-unit>
        <trans-unit id="efe0742dcba00224262ee5b679bb64e2dd8254ac" translate="yes" xml:space="preserve">
          <source>Adjusted my own UUID/GUID generator with some extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">调整了我自己的UUID / GUID生成器，并&lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;在此处添加&lt;/a&gt;了一些其他功能。</target>
        </trans-unit>
        <trans-unit id="12c755e3c27b17c5f8c8e0155d60eabe76a0405a" translate="yes" xml:space="preserve">
          <source>An UUID must have this format:</source>
          <target state="translated">一个UUUID必须有这种格式。</target>
        </trans-unit>
        <trans-unit id="12c696bae1749afdd4c10d3071dc3d49e8ee7766" translate="yes" xml:space="preserve">
          <source>Basically, the same inner logic, except we check for &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, and using a while loop (instead of &lt;code&gt;replace()&lt;/code&gt; callbacks) gets us an almost 3X improvement!</source>
          <target state="translated">基本上，除了检查 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;4&lt;/code&gt; 之外 ，和使用while循环（而不是 &lt;code&gt;replace()&lt;/code&gt; 回调），相同的内部逻辑使我们几乎提高了3倍！</target>
        </trans-unit>
        <trans-unit id="99bc098eb1d1be9a1e4498d4108a52905669d15e" translate="yes" xml:space="preserve">
          <source>Below is my script with the Mash and Kybos methods from baagoe.com excluded.</source>
          <target state="translated">以下是我的脚本,排除了baagoe.com的Mash和Kybos的方法。</target>
        </trans-unit>
        <trans-unit id="c650c2cdd89b69f5f213fde542a728fd50fc0983" translate="yes" xml:space="preserve">
          <source>But first, my results, compared to broofa, &lt;code&gt;guid&lt;/code&gt; (the accepted answer), and the non-rfc-compliant &lt;code&gt;generateQuickGuid&lt;/code&gt;:</source>
          <target state="translated">但是首先，与broofa， &lt;code&gt;guid&lt;/code&gt; （公认的答案）和不符合rfc的 &lt;code&gt;generateQuickGuid&lt;/code&gt; 相比，我的结果是 ：</target>
        </trans-unit>
        <trans-unit id="b3ef02731ee702db53ed68d0ba455be85ab88617" translate="yes" xml:space="preserve">
          <source>But if you're looking at that regular expression, those many &lt;code&gt;replace()&lt;/code&gt; callbacks, &lt;code&gt;toString()&lt;/code&gt;'s and &lt;code&gt;Math.random()&lt;/code&gt; function calls (where he's only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with &lt;code&gt;generateQuickGUID&lt;/code&gt;.</source>
          <target state="translated">但是，如果您正在查看该正则表达式，那么多的 &lt;code&gt;replace()&lt;/code&gt; 回调， &lt;code&gt;toString()&lt;/code&gt; 和 &lt;code&gt;Math.random()&lt;/code&gt; 函数调用（其中他仅使用结果的4位，而浪费了其余部分），则可以开始想知道性能。 确实，joelpt甚至决定通过 &lt;code&gt;generateQuickGUID&lt;/code&gt; 放弃RFC以获得通用GUID速度。</target>
        </trans-unit>
        <trans-unit id="717ee0beb1305a91a9a0535e4961247e24e32fc5" translate="yes" xml:space="preserve">
          <source>Can't vouch for this implementation, but SOMEONE must publish a bonafide GUID generator.</source>
          <target state="translated">不能为这个实现做担保,但必须有人发布一个真正的guid生成器。</target>
        </trans-unit>
        <trans-unit id="01536fdf7462153cb5b1d4174a32db140aec25c2" translate="yes" xml:space="preserve">
          <source>Create GUID / UUID in JavaScript</source>
          <target state="translated">用JavaScript创建GUID UUID</target>
        </trans-unit>
        <trans-unit id="95e6f920efe4af2e79e605edcc5e28ed1b15c6c5" translate="yes" xml:space="preserve">
          <source>Cryptographically strong random # generation on supporting platforms.</source>
          <target state="translated">支持平台上的加密强随机#生成。</target>
        </trans-unit>
        <trans-unit id="0ed439a6611cd1800f10c6bd949b76b487cd2b75" translate="yes" xml:space="preserve">
          <source>Download Raw File (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt;
Download Raw File (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&lt;/a&gt;</source>
          <target state="translated">下载原始文件（uuid v1）： &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https&lt;/a&gt; : //raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js下载原始文件（uuid v4）： &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https&lt;/a&gt; : //raw.githubusercontent.com/kelektiv/node -uuid / master / v4.js</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="ed293f503837b9994324552ef62fd849b6ccd846" translate="yes" xml:space="preserve">
          <source>ES6 sample</source>
          <target state="translated">ES6样本</target>
        </trans-unit>
        <trans-unit id="d7ddd41483a929219e6c64489e8d0eca72b29277" translate="yes" xml:space="preserve">
          <source>Edit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it's a few random digits short. (Add more random digits if you need it) The upside is that this it's really fast :)
You can &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;test validity of your GUID here&lt;/a&gt;</source>
          <target state="translated">编辑：上面的代码遵循意图，但不是RFC的字母。 除其他差异外，还有一些随机数短。 （如果需要，可以添加更多随机数字）好处是，它的速度非常快：）您可以&lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;在此处测试GUID的有效性&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d3d52832b1fac459c9b6a3703887d6cc457b232" translate="yes" xml:space="preserve">
          <source>Eventually we build the GUID with the following chaining: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt;, and return it.</source>
          <target state="translated">最终，我们使用以下链接构建了GUID： &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt; ，然后将其返回。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="ce2e69b5373a12bdf9ca27da533c517da11f6e58" translate="yes" xml:space="preserve">
          <source>Fastest GUID like string generator method in the format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;. This does not generate standard-compliant GUID.</source>
          <target state="translated">最快的类似于GUID的字符串生成器方法，格式为 &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; 。 这不会生成符合标准的GUID。</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="19967ecebb03ba38cc744454a4a0af16a7d1a8e8" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:</source>
          <target state="translated">对于符合&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt;版本4的解决方案，此一站式解决方案是我能想到的最紧凑的解决方案：</target>
        </trans-unit>
        <trans-unit id="0fa53fa9049ab50aea42e7e785eb43daf3f7b3eb" translate="yes" xml:space="preserve">
          <source>For an explanation, let's start with broofa's code:</source>
          <target state="translated">为了解释一下,我们先从broofa的代码开始。</target>
        </trans-unit>
        <trans-unit id="ab095b33ae4fc9f4c67064d2613f861fa360db4f" translate="yes" xml:space="preserve">
          <source>For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):</source>
          <target state="translated">对于那些想要一个符合 rfc4122 版本 4 的解决方案,并考虑到速度问题(很少调用 Math.random())。</target>
        </trans-unit>
        <trans-unit id="27fd956c4f1ae3c3c9ea49a4371ca211e7952e8e" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy's technical blog&lt;/a&gt;:</source>
          <target state="translated">来自&lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy的技术博客&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c23b6b59226a5a1d9cd6f8d8dedd94737c6ed311" translate="yes" xml:space="preserve">
          <source>Generate RFC4122 version 1 or version 4 UUIDs</source>
          <target state="translated">生成RFC4122版本1或版本4的UUUID。</target>
        </trans-unit>
        <trans-unit id="4557d9f04a62ecf6d45c63f669d4d3c5969dbed7" translate="yes" xml:space="preserve">
          <source>Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.</source>
          <target state="translated">生成26个[a-z0-9]字符,生成的UID比符合RFC标准的GUID更短、更独特。如果人类的可读性问题,破折号可以简单地添加。</target>
        </trans-unit>
        <trans-unit id="c37e10249fd54645ca14d4f8396558ccf7ed72d1" translate="yes" xml:space="preserve">
          <source>Here are usage examples and timings for this function and several of this question's other answers. The timing was performed under Chrome m25, 10 million iterations each.</source>
          <target state="translated">下面是这个函数的使用实例和定时,以及这个问题的其他几个答案。定时是在Chrome m25下进行的,每次迭代1000万次。</target>
        </trans-unit>
        <trans-unit id="2c247f731cda829ae025095a8672be34b63c5632" translate="yes" xml:space="preserve">
          <source>Here is a combination of the &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;top voted answer&lt;/a&gt;, with a workaround for &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome's collisions&lt;/a&gt;:</source>
          <target state="translated">以下是&lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;最受好评的答案&lt;/a&gt;的组合，以及针对&lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome浏览器冲突&lt;/a&gt;的解决方法：</target>
        </trans-unit>
        <trans-unit id="2ecd98e5e9126eb4bab9ba9ad9ac22335c8bce41" translate="yes" xml:space="preserve">
          <source>Here is a sample of the UUIDs generated :</source>
          <target state="translated">以下是生成的UUUID的示例。</target>
        </trans-unit>
        <trans-unit id="8261ebf8b6de8850d44b04f0d061fad3a19b0b3b" translate="yes" xml:space="preserve">
          <source>Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.</source>
          <target state="translated">这里有一个完全不符合要求但性能非常好的实现,可以生成一个类似于ASCII安全的GUID的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="503ff0a7dc77de993388c1e8009b02daf56b5134" translate="yes" xml:space="preserve">
          <source>Here is the timing code.</source>
          <target state="translated">这里是计时码。</target>
        </trans-unit>
        <trans-unit id="8117e866b4a966496f20af5f99e7bfccef4d04fa" translate="yes" xml:space="preserve">
          <source>Here's a fiddle to test.</source>
          <target state="translated">这里有一个小精灵来测试一下。</target>
        </trans-unit>
        <trans-unit id="60ff7b70fc22b138ecf074493ca83ac61514a43a" translate="yes" xml:space="preserve">
          <source>Here's a similar &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if &lt;code&gt;Math.random&lt;/code&gt; is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:</source>
          <target state="translated">这是一个类似的符合&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt;版本4的解决方案，它通过将时间戳记的十六进制部分偏移前13个十六进制数字，以及自页面加载以来一次偏移了微秒的十六进制部分来解决该问题。 这样，即使 &lt;code&gt;Math.random&lt;/code&gt; 位于同一种子上，两个客户端也必须生成自页面加载以来完全相同的微秒数（如果支持高性能时间）并且以完全相同的毫秒数（或10,000+年）生成UUID稍后）以获取相同的UUID：</target>
        </trans-unit>
        <trans-unit id="4e21d976cadf293249dcfa48c33d29b6a5e06a86" translate="yes" xml:space="preserve">
          <source>Here's a solution dated Oct. 9, 2011 from a comment by user &lt;em&gt;jed&lt;/em&gt; at &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt;:</source>
          <target state="translated">这是日期为2011年10月9日的解决方案，来自用户&lt;em&gt;jed&lt;/em&gt;在&lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt;的评论：</target>
        </trans-unit>
        <trans-unit id="b18abaaddfcfe54404b43a907e463bef2f7d1c8b" translate="yes" xml:space="preserve">
          <source>Here's some code based on &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).</source>
          <target state="translated">这是一些基于&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;第4.4节（从真正随机数或伪随机数创建UUID的算法）的代码。</target>
        </trans-unit>
        <trans-unit id="79fadeaf6225db3316856bec94555fdca94516bd" translate="yes" xml:space="preserve">
          <source>I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): &lt;code&gt;XXXXXXXX&lt;/code&gt; and &lt;code&gt;-XXXX-XXXX&lt;/code&gt;.</source>
          <target state="translated">我将GUID分为4部分，每部分分为2种类型（或格式）： &lt;code&gt;XXXXXXXX&lt;/code&gt; 和 &lt;code&gt;-XXXX-XXXX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a293bf864a92ae3bdd88eece8abb78a30146eb51" translate="yes" xml:space="preserve">
          <source>I hope my logic is correct -- it's very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!</source>
          <target state="translated">我希望我的逻辑是正确的 ----在这种繁琐的工作中很容易出错。但我觉得输出的效果很好。希望你喜欢这段疯狂的代码优化之旅!</target>
        </trans-unit>
        <trans-unit id="25720d68a9e1e89c7d65f4d275b178f61def9e81" translate="yes" xml:space="preserve">
          <source>I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt;) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:</source>
          <target state="translated">我知道，这是一个古老的问题。 仅出于完整性考虑，如果您的环境是SharePoint，则有一个名为 &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; （ &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt; ）的实用程序功能，它会创建一个新的guid。 此函数在sp.init.js文件中。 如果您重写此函数（以从其他私有函数中删除一些其他依赖项），则看起来像这样：</target>
        </trans-unit>
        <trans-unit id="177c45f419a9b6ef3b4867a7b50e33c9277b2464" translate="yes" xml:space="preserve">
          <source>I really like how clean &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa's answer&lt;/a&gt; is, but it's unfortunate that &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;poor implementations of &lt;code&gt;Math.random&lt;/code&gt;&lt;/a&gt; leave the chance for collision.</source>
          <target state="translated">我真的很喜欢&lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa的答案&lt;/a&gt;有多干净，但是不幸的是&lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt; &lt;code&gt;Math.random&lt;/code&gt; 的糟糕实现&lt;/a&gt;留下了碰撞的机会。</target>
        </trans-unit>
        <trans-unit id="96f12778c6d1c9cb9e9f724becdd6f22ca538716" translate="yes" xml:space="preserve">
          <source>I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.</source>
          <target state="translated">我尝试了一个每次处理16位的e6(),仍然使用256元素的LUT,结果显示优化后的回报率越来越低。虽然它的迭代次数较少,但内部逻辑因为处理量的增加而变得复杂,在桌面上表现一样,而在移动端只快了~10%。</target>
        </trans-unit>
        <trans-unit id="94aaabbae44f4bbe89bcd126762f2426e665aaa1" translate="yes" xml:space="preserve">
          <source>I wanted to understand broofa's answer, so I expanded it and added comments:</source>
          <target state="translated">我想了解一下broofa的回答,所以我把它展开了,并补充了评论。</target>
        </trans-unit>
        <trans-unit id="25657ae09cdf1fab859fd8ed647641b977c468b2" translate="yes" xml:space="preserve">
          <source>I'm sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:</source>
          <target state="translated">我相信大多数人都能理解我在那里做了什么,但也许至少有一个人需要解释一下。</target>
        </trans-unit>
        <trans-unit id="07563a60a63f4a9f390f1d6b7207d34d1b6c8994" translate="yes" xml:space="preserve">
          <source>I'm trying to create globally-unique identifiers in JavaScript.  I'm not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc..</source>
          <target state="translated">我正在尝试在JavaScript中创建全局唯一标识符。我不知道所有的浏览器都有哪些例程,内置的随机数生成器的 &quot;随机性 &quot;和种子化程度如何,等等。</target>
        </trans-unit>
        <trans-unit id="edc7a41e1c3907cce12f657d31fbd8e2e62aef40" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;the following Kybos&lt;/a&gt; random number generator to be a bit more cryptographically sound.</source>
          <target state="translated">我正在使用&lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;以下Kybos&lt;/a&gt;随机数生成器，使其在密码学上更加合理。</target>
        </trans-unit>
        <trans-unit id="24039edb982143cd91d9ef8c02193697aea634ab" translate="yes" xml:space="preserve">
          <source>If ID's are generated more than 1 millisecond apart, they are 100% unique.</source>
          <target state="translated">如果ID的生成时间相隔超过1毫秒,那么它们就是100%的唯一性。</target>
        </trans-unit>
        <trans-unit id="ac405bebd06ff78ed2b4d8ddea9b5fb92065b420" translate="yes" xml:space="preserve">
          <source>If anyone is still interested, here's my solution.</source>
          <target state="translated">如果有人还感兴趣的话,这是我的解决办法。</target>
        </trans-unit>
        <trans-unit id="48bbc7c26eab6650d1c206af8ed5fc119de549fd" translate="yes" xml:space="preserve">
          <source>If two ID's are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID's that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)</source>
          <target state="translated">如果以较短的时间间隔生成两个ID,假设随机方法真的是随机的,这样生成的ID有99.9999999999999999%的概率是全局唯一的(10^15中的1次碰撞</target>
        </trans-unit>
        <trans-unit id="da9dc85e7b0b0b4506b983c73c54454686b58e25" translate="yes" xml:space="preserve">
          <source>If you just need a random 128 bit string in no particular format you can use:</source>
          <target state="translated">如果你只需要一个没有特定格式的128位随机字符串,你可以使用。</target>
        </trans-unit>
        <trans-unit id="f6f68a22918e41434d843ee9ec535c8561aadbdf" translate="yes" xml:space="preserve">
          <source>Interested in how?  I've put the full source on &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; and on &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</source>
          <target state="translated">有兴趣如何？ 我已将完整的源代码放在&lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt;和&lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4上&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67bc45c70d80a1bf17613bc8bbbc170612956cf6" translate="yes" xml:space="preserve">
          <source>It's just a simple AJAX call...</source>
          <target state="translated">这只是一个简单的AJAX调用.....</target>
        </trans-unit>
        <trans-unit id="0bad48021176f9dcc3cc0a91ab6055920051d3c7" translate="yes" xml:space="preserve">
          <source>JavaScript project on GitHub - &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</source>
          <target state="translated">GitHub上的JavaScript项目-https: &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;//github.com/LiosK/UUID.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac95cb4089b08b71444e4ad4f7144f620d5f30d" translate="yes" xml:space="preserve">
          <source>Link to this post on my blog</source>
          <target state="translated">链接到我的博客上的这个帖子</target>
        </trans-unit>
        <trans-unit id="c6d383d13425b9e72d4d3cd3c6a68dcf8a621c40" translate="yes" xml:space="preserve">
          <source>Low timestamp resolution of JavaScript is compensated by random
  numbers.</source>
          <target state="translated">JavaScript的时间戳分辨率低,通过随机数来补偿。</target>
        </trans-unit>
        <trans-unit id="2a2f909c05dbaf7e4ed33d417a4c2eea6fe81f80" translate="yes" xml:space="preserve">
          <source>Minimized:</source>
          <target state="translated">Minimized:</target>
        </trans-unit>
        <trans-unit id="9ac71edf2df3b6f23bf1480bc49e05ce8b2772d8" translate="yes" xml:space="preserve">
          <source>Modualized:  &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</source>
          <target state="translated">模块化： &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http&lt;/a&gt; : &lt;code&gt;UUID.generate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a267ce45e411c0a01408b105e2778acfc528266" translate="yes" xml:space="preserve">
          <source>Note that just randomly generating the identifiers byte by byte, or character by character, will not give you the same guarantees as a conforming implementation. Also, very important, systems working with compliant UUIDs may choose not to accept randomly generated ones, and many open source validators will actually check for a valid structure.</source>
          <target state="translated">请注意,仅仅是逐个字节随机生成标识符,或者是逐个字符随机生成标识符,并不能给你提供与合规实现相同的保证。另外,非常重要的一点是,使用合规的UUUID的系统可能会选择不接受随机生成的UUUID,而许多开放源码验证器实际上会检查一个有效的结构。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="301ff6a51953eb41837bc511f9e5c3ae53d3ae1d" translate="yes" xml:space="preserve">
          <source>Now I'm building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: &lt;code&gt;XXXXXXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;XXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">现在，我正在使用这两种类型来构建GUID，以用调用4件组装GUID，如下所示： &lt;code&gt;XXXXXXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;XXXXXXXX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="541286569013fbf7b101171547520eb0173e2a80" translate="yes" xml:space="preserve">
          <source>On the client side:</source>
          <target state="translated">在客户方面。</target>
        </trans-unit>
        <trans-unit id="a0f15b429784204142403c3e89a6f960dcf0f9c0" translate="yes" xml:space="preserve">
          <source>On the server side:</source>
          <target state="translated">在服务器端。</target>
        </trans-unit>
        <trans-unit id="13545970e3244692419e21474fdc76bde2632c4f" translate="yes" xml:space="preserve">
          <source>Only uses 8 for &quot;y&quot; because that simplifies code readability (y is allowed to be 8, 9, A or B).</source>
          <target state="translated">只用8表示 &quot;y&quot;,因为这样可以简化代码的可读性(y可以是8、9、A或B)。</target>
        </trans-unit>
        <trans-unit id="ba3badc82ce48554f2991852eda7f8ec170df9ae" translate="yes" xml:space="preserve">
          <source>Optimised for code readability not speed, so suitable for say a few hundred uuid's per second. Generates about 10000 uuid() per second in Chromium on my laptop using &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; to measure performance.</source>
          <target state="translated">针对代码可读性而不是速度进行了优化，因此适合说每秒几百个uuid。 使用&lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt;来在笔记本电脑上的Chromium中每秒生成约10000 uuid（）来衡量性能。</target>
        </trans-unit>
        <trans-unit id="60ed329b871109f2e80c6d1ae06b4ed0b9f7192e" translate="yes" xml:space="preserve">
          <source>Quick Google found: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</source>
          <target state="translated">快速的Google发现： &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http&lt;/a&gt; : //www.hoskinson.net/GuidGenerator/</target>
        </trans-unit>
        <trans-unit id="141a92f11e1b6d5986e38858b9d1b5190206712a" translate="yes" xml:space="preserve">
          <source>Retrns Guid. Sets Guid to user specified Guid, if invalid, returns an empty guid.</source>
          <target state="translated">Retrns Guid。将 Guid 设置为用户指定的 Guid,如果无效,则返回空的 Guid。</target>
        </trans-unit>
        <trans-unit id="1feb3a46dd04e5b57054f2f7163b3ede19e7d05f" translate="yes" xml:space="preserve">
          <source>Returns a new Guid and sets it's value internally.</source>
          <target state="translated">返回一个新的 Guid,并在内部设置它的值。</target>
        </trans-unit>
        <trans-unit id="f7190b2a5a80dd9efe0cd084caf578d575e92a30" translate="yes" xml:space="preserve">
          <source>Returns an empty Guid 00000000-0000-0000-0000-000000000000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f0d77427c53b8fe9bdbe24d18a9cda7a1fd73bb" translate="yes" xml:space="preserve">
          <source>Returns boolean. True if empty/undefined/blank/null.</source>
          <target state="translated">返回boolean。如果空undefinedblanknull,则返回true。</target>
        </trans-unit>
        <trans-unit id="0b9548497aeb94cb100a89d540f35d747703f2da" translate="yes" xml:space="preserve">
          <source>Returns boolean. True valid guid, false if not.</source>
          <target state="translated">返回boolean。True有效,如果无效,则返回false。</target>
        </trans-unit>
        <trans-unit id="dc5fcb0d1e7fddd4555389a6d2e329c75a93e257" translate="yes" xml:space="preserve">
          <source>Returns value of internal Guid. If no guid has been specified, returns a new one (value is then stored internally).</source>
          <target state="translated">返回内部指南的值。如果没有指定 Guid,则返回一个新的 Guid(值在内部存储)。</target>
        </trans-unit>
        <trans-unit id="c26904e72aae0a0460d96b4406f82c33e9c9d7d4" translate="yes" xml:space="preserve">
          <source>Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.</source>
          <target state="translated">重新审视了我的项目,使用这个功能,不喜欢动词性。-但需要适当的随机性。</target>
        </trans-unit>
        <trans-unit id="a18caf389c3dfec80f9377a36c83ae5bd04e9610" translate="yes" xml:space="preserve">
          <source>Runs in node.js and browsers.</source>
          <target state="translated">在node.js和浏览器中运行。</target>
        </trans-unit>
        <trans-unit id="150bfcc434ccf43658e52e7f89fa0b96084559fc" translate="yes" xml:space="preserve">
          <source>See RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;.</source>
          <target state="translated">参见RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c898c8e028af83d42d23112d9bc7bc8ef781c67c" translate="yes" xml:space="preserve">
          <source>Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java's UUID.</source>
          <target state="translated">应该遵守RFC的4类(随机)模式,因为我上次用Java的UUUID解析不合规的UUUID有问题。</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="86a518bbca39591be11f3fd5fe07b57a8ca8b92a" translate="yes" xml:space="preserve">
          <source>Simple JavaScript module as a combination of best answers in this thread.</source>
          <target state="translated">简单的JavaScript模块作为本线程中的最佳答案组合。</target>
        </trans-unit>
        <trans-unit id="1659b110855243bf98e76cae362ba745d3973d56" translate="yes" xml:space="preserve">
          <source>Simple code that uses &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; on &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;supported browsers&lt;/a&gt; (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using &lt;code&gt;Math.random()&lt;/code&gt; because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt;).</source>
          <target state="translated">在&lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;支持的浏览器&lt;/a&gt; （IE11 +，iOS7 +，FF21 +，Chrome，Android Chrome）上使用 &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; 的简单代码。 避免使用 &lt;code&gt;Math.random()&lt;/code&gt; ,因为这可能导致冲突（例如，Muxa在实际情况下对4000个生成的uuid发生20次冲突）。</target>
        </trans-unit>
        <trans-unit id="f7eba97181912e78f6a57cfff39d6bcad00f38f4" translate="yes" xml:space="preserve">
          <source>Simple, fast generation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</source>
          <target state="translated">简单，快速生成&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS。</target>
        </trans-unit>
        <trans-unit id="ef07d769a203f544d121bb303d711abf57a3bd8d" translate="yes" xml:space="preserve">
          <source>Small footprint (Want something smaller? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Check this out!&lt;/a&gt;)</source>
          <target state="translated">占地面积小（想要更小的东西吗？ &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;检查一下！&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="8f5a810efa3353e6f2f014c15bc590ece9b55f4c" translate="yes" xml:space="preserve">
          <source>So by my 6th iteration of optimizations, I beat the most popular answer by over &lt;strong&gt;12X&lt;/strong&gt;, the accepted answer by over &lt;strong&gt;9X&lt;/strong&gt;, and the fast-non-compliant answer by &lt;strong&gt;2-3X&lt;/strong&gt;.  And I'm still rfc4122 compliant.</source>
          <target state="translated">因此，通过我的第六次优化迭代，我击败了最受欢迎的答案超过12 &lt;strong&gt;倍&lt;/strong&gt; ，接受的答案超过9 &lt;strong&gt;倍&lt;/strong&gt; ，快速不合规的答案击败&lt;strong&gt;2-3倍&lt;/strong&gt; 。 而且我仍然符合RFC4122。</target>
        </trans-unit>
        <trans-unit id="9494e936f74439fc11e4574afbc044b327ffb0e1" translate="yes" xml:space="preserve">
          <source>So it replaces &lt;code&gt;x&lt;/code&gt; with any random hex digit, &lt;code&gt;y&lt;/code&gt; with random data (except forcing the top 2 bits to &lt;code&gt;10&lt;/code&gt; per the RFC spec), and the regex doesn't match the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; characters, so he doesn't have to deal with them.  Very, very slick.</source>
          <target state="translated">因此，它将 &lt;code&gt;x&lt;/code&gt; 替换为任意随机的十六进制数字，将 &lt;code&gt;y&lt;/code&gt; 替换为随机数据（根据RFC规范将前2位强制为 &lt;code&gt;10&lt;/code&gt; ），并且正则表达式与 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;4&lt;/code&gt; 个字符不匹配，因此他不必处理跟他们。 非常非常光滑</target>
        </trans-unit>
        <trans-unit id="72d265bb2510b83e6b57e5485d72d6bdb674bd84" translate="yes" xml:space="preserve">
          <source>Sometimes the &lt;code&gt;Math.random()&lt;/code&gt; function will return
shorter number (for example &lt;code&gt;0.4363&lt;/code&gt;), due to zeros at the end (from the example above, actually the number is &lt;code&gt;0.4363000000000000&lt;/code&gt;). That's why I'm appending to this string &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (a string with nine zeros) and then cutting it off with &lt;code&gt;substr()&lt;/code&gt; function to make it nine characters exactly (filling zeros to the right).</source>
          <target state="translated">有时，由于末尾为零， &lt;code&gt;Math.random()&lt;/code&gt; 函数将返回较短的数字（例如 &lt;code&gt;0.4363&lt;/code&gt; ）（从上面的示例中，实际上是 &lt;code&gt;0.4363000000000000&lt;/code&gt; ）。 这就是为什么我要将此字符串追加到 &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; （具有九个零的字符串），然后使用 &lt;code&gt;substr()&lt;/code&gt; 函数将其截断以使其完全成为九个字符（在右侧填充零）的原因。</target>
        </trans-unit>
        <trans-unit id="2b6553806f7c0f446906395a9393b4c8aa630b83" translate="yes" xml:space="preserve">
          <source>Ten million executions of this implementation take just 32.5 seconds, which is the fastest I've ever seen in a browser (the only solution without loops/iterations).</source>
          <target state="translated">一千万次执行这个实现只需要32.5秒,这是我在浏览器中见过的最快的解决方案(唯一一个没有循环迭代的解决方案)。</target>
        </trans-unit>
        <trans-unit id="863a161fb9b85e54a7fd55bdfa890d777c3ecfdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math.random()&lt;/code&gt; function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for
example &lt;code&gt;0.4363923368509859&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Math.random()&lt;/code&gt; 函数返回一个介于0和1之间的十进制数字，该数字在小数点后是16位（例如 &lt;code&gt;0.4363923368509859&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="acf4bc33ac4b01c7fa998c17fe2ab66beb9bb5bc" translate="yes" xml:space="preserve">
          <source>The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.</source>
          <target state="translated">GUID UUID应至少为32个字符,并应保持在ASCII范围内,以避免传递时出现问题。</target>
        </trans-unit>
        <trans-unit id="8d751df4e468da72f5959abfc1549c743c1e3ef6" translate="yes" xml:space="preserve">
          <source>The GUID is in the following format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">GUID的格式如下 &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2541cbe64e15ab5d69eb08799c64ce9b1235e066" translate="yes" xml:space="preserve">
          <source>The above function should have a decent balance between speed and randomness.</source>
          <target state="translated">上述功能应该在速度和随机性之间有一个得体的平衡。</target>
        </trans-unit>
        <trans-unit id="ee47e6da31b267bf2647229a714a454ce65b3891" translate="yes" xml:space="preserve">
          <source>The best way to generate them, is to follow implementation instructions in the said RFC, use one of the many community vetted open source implementations.</source>
          <target state="translated">生成它们的最好方法是按照上述RFC中的实现说明,使用许多经过社区审核的开源实现之一。</target>
        </trans-unit>
        <trans-unit id="66063bdfe4ff5bb41650a2179c29b0ae5581986f" translate="yes" xml:space="preserve">
          <source>The better way:</source>
          <target state="translated">更好的方法。</target>
        </trans-unit>
        <trans-unit id="c6b5d62b3d2700a480f847f1f5fc03de421dbca1" translate="yes" xml:space="preserve">
          <source>The final optimization technique to apply - unroll the loop.  Since we're looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:</source>
          <target state="translated">最后要应用的优化技术--解压循环。由于我们在循环的次数是固定的,所以技术上我们可以用手写出这一切。我试过一次,用一个随机变量r,不断地重新分配,结果性能下降了。但如果在前面给四个变量分配了随机数据,然后使用查找表,并应用适当的RFC位,这个版本就能把它们都干掉。</target>
        </trans-unit>
        <trans-unit id="27e5e746f56f3da4623926ba36af11cf24511a47" translate="yes" xml:space="preserve">
          <source>The first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:</source>
          <target state="translated">迈向性能的第一步是消除RegEx及其回调函数，而使用简单的循环。 这意味着我们必须处理 &lt;code&gt;-&lt;/code&gt; 和 &lt;code&gt;4&lt;/code&gt; 个字符，而broofa则不需要。 另外，请注意，我们可以使用字符串数组索引来保持其光滑的String模板体系结构：</target>
        </trans-unit>
        <trans-unit id="1f91cea12f7bb764e0dde68e533cd0001d9f6c9a" translate="yes" xml:space="preserve">
          <source>The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).</source>
          <target state="translated">首先要知道,函数的调用是很费钱的,正则表达式也是如此(虽然他只用了1,但它有32个回调,每个匹配都有一个,在这32个回调中,它分别调用Math.random()和v.toString(16))。</target>
        </trans-unit>
        <trans-unit id="5efd11cea6dbb2ca7d3856a6504baae9880ab778" translate="yes" xml:space="preserve">
          <source>The function is as simple as:</source>
          <target state="translated">该功能简单来说就是:</target>
        </trans-unit>
        <trans-unit id="237b687de13a23a564832cfd020006932e2b7094" translate="yes" xml:space="preserve">
          <source>The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it's most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.</source>
          <target state="translated">有趣的是,生成16个字节的随机数据是最容易的部分。整个诀窍就是用符合RFC的String格式表达,用16个字节的随机数据、一个未滚动的循环和查找表来完成,这是最严密的。</target>
        </trans-unit>
        <trans-unit id="5fe390d75a55e87b91e0f2c344ccf52b0f992757" translate="yes" xml:space="preserve">
          <source>The next optimization is another classic.  Since we're only handling 4-bits of output in each loop iteration, let's cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it's not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.</source>
          <target state="translated">接下来的优化是另一个经典的优化。由于我们每次循环迭代只处理4位的输出,所以让我们将循环次数减少一半,每次迭代处理8位。这很棘手,因为我们仍然要处理符合RFC的位数位置,但并不难。然后我们必须做一个更大的查找表(16x16,或256)来存储0x00-0xff,我们只在e5()函数外构建一次。</target>
        </trans-unit>
        <trans-unit id="2c2a678ccb7c402e8bfa66c3bb0b047a01880eeb" translate="yes" xml:space="preserve">
          <source>The next step is a small one on the desktop but makes a decent difference on mobile.  Let's make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let's also move that template definition out of the loop, just in case it helps:</source>
          <target state="translated">接下来的步骤在桌面上是一个小步骤,但在移动端却有很大的不同。让我们做更少的Math.random()调用,并利用所有的随机位,而不是把87%的随机位扔掉,每次迭代时都会被移出一个随机缓冲区。让我们也把那个模板定义从循环中移出,以防万一有帮助。</target>
        </trans-unit>
        <trans-unit id="475810532e8a0fcebdd7c79eff23716432a61245" translate="yes" xml:space="preserve">
          <source>The reason for adding exactly nine zeros is because of the worse case scenario, which is when the &lt;code&gt;Math.random()&lt;/code&gt; function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That's why we needed to add nine zeros to it (&lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; or &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt;), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.</source>
          <target state="translated">之所以要精确添加9个零是因为情况更糟，这是 &lt;code&gt;Math.random()&lt;/code&gt; 函数将恰好返回0或1（其中每个概率为1/10 ^ 16）的情况。 这就是为什么我们需要向其添加九个零（ &lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt; ），然后从长度为八个字符的第二个索引（第三个字符）处将其切掉。 在其他情况下，加零不会损害结果，因为无论如何它都会切断结果。</target>
        </trans-unit>
        <trans-unit id="c79498301c475af77620127310a64ed51077604c" translate="yes" xml:space="preserve">
          <source>Then we cut off the &lt;code&gt;0.&lt;/code&gt; prefix (&lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt;
&lt;code&gt;6fb7687f&lt;/code&gt;) and get a string with eight hexadecimal
characters long.</source>
          <target state="translated">然后，我们截断 &lt;code&gt;0.&lt;/code&gt; 前缀（ &lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt; &lt;code&gt;6fb7687f&lt;/code&gt; ），并得到一个长度为八个十六进制字符的字符串。</target>
        </trans-unit>
        <trans-unit id="9c8cde2548b6605f69b7f5277aa0db7d69ca4dbc" translate="yes" xml:space="preserve">
          <source>Then we take this number and convert
it to a string with base 16 (from the example above we'll get
&lt;code&gt;0.6fb7687f&lt;/code&gt;).</source>
          <target state="translated">然后，我们将这个数字转换为以16为底的字符串（从上面的示例中我们将得到 &lt;code&gt;0.6fb7687f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f896659fdb57404f3ca1c0dd540b6ea7e7493cc7" translate="yes" xml:space="preserve">
          <source>There are other methods that involve using an ActiveX control, but stay away from these!</source>
          <target state="translated">还有其他的方法涉及到使用ActiveX控件,但要远离这些方法!</target>
        </trans-unit>
        <trans-unit id="b6f314cd5d1632bbd12fce8c34bf0331b26c9531" translate="yes" xml:space="preserve">
          <source>There is a jQuery plugin that handles Guid's nicely @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</source>
          <target state="translated">有一个jQuery插件可以很好地处理Guid @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a114b1049ab77d7bb9cf82e5902a2fc8f9522f5b" translate="yes" xml:space="preserve">
          <source>This accomplishes the same goal as the &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;current highest-rated answer&lt;/a&gt;, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here's the annotated form of an older version of the function:</source>
          <target state="translated">这可以实现与&lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;当前最高评分答案&lt;/a&gt;相同的目标，但是通过利用强制，递归和指数表示法，可以减少50个字节以内。 对于那些好奇它如何工作的人，下面是该函数较旧版本的带注释形式：</target>
        </trans-unit>
        <trans-unit id="c054a07bc3de1a2f3d45f3aab21e9af1ebf626bf" translate="yes" xml:space="preserve">
          <source>This create version 4 UUID (created from pseudo random numbers) :</source>
          <target state="translated">这个创建版本4的UUID(由伪随机数创建)。</target>
        </trans-unit>
        <trans-unit id="58ce504b9f25064cbcb7de092b962c9e2dda22c0" translate="yes" xml:space="preserve">
          <source>This one is based on date, and add a random suffix to &quot;ensure&quot; uniqueness.
Works well for css identifiers.
It always returns something like and is easy to hack:</source>
          <target state="translated">这个是基于日期,并添加一个随机后缀来 &quot;确保 &quot;唯一性。对于css标识符也很好用。它总是返回类似的东西,而且很容易黑掉。</target>
        </trans-unit>
        <trans-unit id="c7a27f8c65115f387fec4d67fe32dab189f55a09" translate="yes" xml:space="preserve">
          <source>This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:</source>
          <target state="translated">这样一来,根据平台的不同,我们可以节省10-30%。还不错。但下一个重要的步骤是用一个经典的优化方法--查找表,完全摆脱了toString函数的调用。一个简单的16元素查询表可以在更短的时间内完成toString(16)的工作。</target>
        </trans-unit>
        <trans-unit id="3e8bb274abfb2de0a2c13afefa3450f9f50f8d6e" translate="yes" xml:space="preserve">
          <source>To differ between these two types, I added a flag parameter to a pair creator function &lt;code&gt;_p8(s)&lt;/code&gt;, the &lt;code&gt;s&lt;/code&gt; parameter tells the function whether to add dashes or not.</source>
          <target state="translated">为了 &lt;code&gt;_p8(s)&lt;/code&gt; 这两种类型，我在对创建器函数_p8（s）中添加了一个flag参数， &lt;code&gt;s&lt;/code&gt; 参数告诉该函数是否添加破折号。</target>
        </trans-unit>
        <trans-unit id="1c7c150202fdddceb6b1c221a05cdb4e4c1ce115" translate="yes" xml:space="preserve">
          <source>To test the performance, you can run this code:</source>
          <target state="translated">为了测试性能,你可以运行这段代码。</target>
        </trans-unit>
        <trans-unit id="fe1c1c9e7da2bc289fcd3379642172b845c1989a" translate="yes" xml:space="preserve">
          <source>UUID object allows a variety of access to the UUID including access to
  the UUID fields.</source>
          <target state="translated">UUID对象允许对UUUID进行各种访问,包括对UUID字段的访问。</target>
        </trans-unit>
        <trans-unit id="a3b6d33b0517d8c2933196e2f509432ec47c7b44" translate="yes" xml:space="preserve">
          <source>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, are identifiers with a certain uniqueness guarantee.</source>
          <target state="translated">根据&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; ，UUID（通用唯一IDentifier）也称为GUID（全局唯一IDentifier）是具有一定唯一性保证的标识符。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="670720d3ce8655613fb8e5107bd150a04eb2bb3d" translate="yes" xml:space="preserve">
          <source>Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs
  (time-based UUIDs) are available.</source>
          <target state="translated">4版本的UUUID(来自随机数的UUUID)和1版本的UUUID(基于时间的UUUID)。</target>
        </trans-unit>
        <trans-unit id="3ebdce3a7ac7e93ecd1c5e84caaea7c1835d5f49" translate="yes" xml:space="preserve">
          <source>Want even smaller? Check this out: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</source>
          <target state="translated">想要更小？ 看看这个： &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https&lt;/a&gt; : //gist.github.com/jed/982883</target>
        </trans-unit>
        <trans-unit id="a55040507e6337ca3e32ec7d20777fced2a290d7" translate="yes" xml:space="preserve">
          <source>Well, this has a bunch of answers already, but unfortunately there's not a &quot;true&quot; random in the bunch. The version below is an adaptation of broofa's answer, but updated to include a &quot;true&quot; random function that uses crypto libraries where available, and the Alea() function as a fallback.</source>
          <target state="translated">好吧,这个问题已经有一堆答案了,但遗憾的是这堆答案中没有一个 &quot;真 &quot;随机。下面的版本是对 broofa 的答案的改编,但更新了一个 &quot;真 &quot;随机函数,在可用的情况下使用加密库,并使用 Alea()函数作为备用函数。</target>
        </trans-unit>
        <trans-unit id="7dad31345c220d2cbe299045c03a52e22b20d937" translate="yes" xml:space="preserve">
          <source>Where the &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; positions may only have certain values. At this time, the only valid values for M are 1, 2, 3, 4 and 5, so randomly generating that position would make most results unacceptable.</source>
          <target state="translated">其中&lt;em&gt;M&lt;/em&gt;和&lt;em&gt;N&lt;/em&gt;位置可能只有某些值。 此时，M的唯一有效值为1、2、3、4和5，因此随机生成该位置将使大多数结果不可接受。</target>
        </trans-unit>
        <trans-unit id="0b33ee51f78c94d3fa3e3d46126b5b2de5f92677" translate="yes" xml:space="preserve">
          <source>Which will return something like &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt;.</source>
          <target state="translated">它将返回类似 &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt; 的内容 。</target>
        </trans-unit>
        <trans-unit id="00947a234207676f6b4f448ed89af28aa686b86c" translate="yes" xml:space="preserve">
          <source>With such a web service, you could develop a REST web interface that consumes the GUID web service, and serves it through AJAX to javascript in a browser.</source>
          <target state="translated">有了这样一个Web服务,你可以开发一个REST Web界面,它可以消耗GUID的Web服务,并通过AJAX向浏览器中的javascript提供服务。</target>
        </trans-unit>
        <trans-unit id="d4fb620aaed70bd0d3e4873af0570771d0ed649d" translate="yes" xml:space="preserve">
          <source>You can increase this number by adding more digits, but to generate 100% unique ID's you will need to use a global counter.</source>
          <target state="translated">你可以通过添加更多的数字来增加这个数字,但是要想生成100%的唯一ID,你需要使用全局计数器。</target>
        </trans-unit>
        <trans-unit id="ba59cf2f4053a03ebc1856c70811cb75b72d66b4" translate="yes" xml:space="preserve">
          <source>You can use node-uuid (&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt;)</source>
          <target state="translated">您可以使用node-uuid（ &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="da5cce2c829e18ada2502aedf48c415870558171" translate="yes" xml:space="preserve">
          <source>broofa's answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!</source>
          <target state="translated">broofa的答案确实很巧妙,确实是很聪明,真的......rfc4122兼容,有点可读性,而且结构紧凑。真棒!</target>
        </trans-unit>
        <trans-unit id="5f37ba236f9a0c5e9361a753b0b9f82646c7f35a" translate="yes" xml:space="preserve">
          <source>if you need RFC compatibility, this formatting will pass as a valid version 4 GUID:</source>
          <target state="translated">如果你需要RFC兼容性,这个格式化将作为有效的版本4 GUID通过。</target>
        </trans-unit>
        <trans-unit id="b32441e1af6b6c4e0de9080307ccfb43a3ea08b5" translate="yes" xml:space="preserve">
          <source>uid-139410573297741</source>
          <target state="translated">uid-139410573297741</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
