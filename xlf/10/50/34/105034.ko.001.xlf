<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/105034">
    <body>
      <group id="105034">
        <trans-unit id="68960fcc7ae0d6fd78f4a201eeb38fa8bb9a0ecf" translate="yes" xml:space="preserve">
          <source>&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</source>
          <target state="translated">&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</target>
        </trans-unit>
        <trans-unit id="a032d777f177ebd6e92855f3bce4c9d3de29d561" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;On jsbin&lt;/a&gt; if you want to test it.</source>
          <target state="translated">테스트하려는 경우 &lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;jsbin에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54853102ac5288d10305ee4fe284f5676c8b3049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="518c3687d473e405f713a2e4202e1617f257a7bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="7de15d516266250876bf7df115f60af51b87ba40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a4bfa8acce2c58437408c5567e16ba754efc3619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be advised:&lt;/strong&gt; my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.</source>
          <target state="translated">&lt;strong&gt;조언 :&lt;/strong&gt; 나의 주요 목표는 잠재적 인 최적화 전략을 보여주고 가르치는 것이 었습니다. 다른 답변은 좋은 UUID를 생성하는 데 중요한 충돌 및 진정한 난수와 같은 중요한 주제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="a8558249d3c59db88fd2392888164f8297752e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, can we get speed &lt;em&gt;and&lt;/em&gt; RFC compliance?  I say, YES!&lt;/strong&gt;  Can we maintain readability?  Well...  Not really, but it's easy if you follow along.</source>
          <target state="translated">&lt;strong&gt;그러나 속도 &lt;em&gt;와&lt;/em&gt; RFC 준수를 얻을 수 있습니까?&lt;/strong&gt; &lt;strong&gt;나는 찬성!&lt;/strong&gt; 가독성을 유지할 수 있습니까? 글쎄 ... 실제로는 아니지만 따라 가면 쉽다.</target>
        </trans-unit>
        <trans-unit id="0aa9a4872e5871a2d50503b7555d5a560abc60db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b79b40ec4e7164794f3d15d07d564b8ad8717468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit :&lt;/strong&gt;  I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;wikipedia article&lt;/a&gt;).  There is always a chance of collisions.  A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; GUID 생성기가 고유 키를 보장 할 수 없다는 것을 지적 할 가치가 있다고 생각했습니다 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;wikipedia 기사&lt;/a&gt; 확인). 충돌 가능성이 항상 있습니다. GUID는 단순히 충돌의 변화를 거의 없앨 수 있도록 충분히 큰 키 공간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7015ec1e0155111b63b36ee572b6bff0228a4302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enjoy! :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;즐겨!&lt;/strong&gt; &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274339a4ddbe260b6a97172504035c73b5738ea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Features Generates RFC 4122 compliant UUIDs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기능 RFC 4122 호환 UUID를 생성합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d77806e165bb48692701ad0de9af22b7850fba31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.empty&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.empty&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b0671d2fe50cfe5c11475ae51a2760cbcda6baf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cf7a599e78acfd69a7e284fa3d3b67982dccad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Install Using NPM:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NPM을 사용하여 설치 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf75b8ebe887aa6577cd720281924cbc349c929" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or Using uuid via browser:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또는 브라우저를 통한 UUID 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35889b4f21085883cbaa19da2a6b14684bd0aada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The algorithm:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알고리즘 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b1935958bb975920d8012409acce290de08a28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The assembly:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어셈블리 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c002957f28f184ef81e532a83ab90120a2e876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UUID.js The RFC-compliant UUID generator for JavaScript.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UUID.js JavaScript를위한 RFC 호환 UUID 생성기.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469336e52af17d529352df89c21d2a5435257e12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-06-02&lt;/strong&gt;:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses &lt;code&gt;Math.random()&lt;/code&gt; for brevity, however &lt;code&gt;Math.random()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to be a high-quality RNG.  See Adam Hyland's &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;excellent writeup on Math.random()&lt;/a&gt; for details.  For a more robust solution, consider something like &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;the uuid module&lt;/a&gt; (disclaimer: I, @broofa, am the author), which uses higher quality RNG APIs where available.</source>
          <target state="translated">&lt;strong&gt;2015-06-02 업데이트&lt;/strong&gt; : UUID 고유성은 기본 난수 생성기 (RNG)에 크게 의존합니다. 위의 솔루션은 간결성을 위해 &lt;code&gt;Math.random()&lt;/code&gt; 을 사용하지만 &lt;code&gt;Math.random()&lt;/code&gt; 은 고품질 RNG임을 보장 &lt;em&gt;하지 않습니다&lt;/em&gt; . 자세한 내용은 Adam Hyland의 &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;Math.random ()에&lt;/a&gt; 대한 훌륭한 글 을 참조하십시오. 보다 강력한 솔루션을 위해, 가능한 경우 고품질 RNG API를 사용 &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;하는 uuid 모듈&lt;/a&gt; (면책 조항 : I, @broofa, 저자입니다)과 같은 것을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="be0809af7361460fb45bdf84889bab84728f5e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-08-26&lt;/strong&gt;: As a side-note, this &lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;gist&lt;/a&gt; describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10&lt;sup&gt;15&lt;/sup&gt; version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.</source>
          <target state="translated">&lt;strong&gt;업데이트, 2015-08-26&lt;/strong&gt; :이 참고 사항은 특정 충돌 확률에 도달하기 전에 생성 할 수있는 ID 수를 결정하는 방법을 설명합니다. 예를 들어 3.26x10 &lt;sup&gt;15&lt;/sup&gt; 버전 4 RFC4122 UUID를 사용하면 1 백만 분의 1의 충돌 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd4ff892cec4b2ce586409848ac995315f7db82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2017-06-28&lt;/strong&gt;: A &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;good article from Chrome developers&lt;/a&gt; discussing the state of Math.random PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it's &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here's an updated version of the above solution that uses ES6, the &lt;code&gt;crypto&lt;/code&gt; API, and &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;a bit of JS wizardry I can't take credit for&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;2017-06-28 업데이트&lt;/strong&gt; : &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;Chrome 개발자&lt;/a&gt; 가 Chrome, Firefox 및 Safari의 Math.random PRNG 품질 상태를 논의한 좋은 기사입니다 . tl; dr-2015 년 말 기준으로 &quot;아주 훌륭&quot;하지만 암호화 품질은 아닙니다. 이 문제를 해결하기 위해 ES6, &lt;code&gt;crypto&lt;/code&gt; API 및 &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;JS 마법사&lt;/a&gt; 를 사용하는 위 솔루션의 업데이트 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1395f19d7608f025cb58cb5b03b266e650d27c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2020-01-06&lt;/strong&gt;: There is a &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;proposal in the works&lt;/a&gt; for a standard &lt;code&gt;uuid&lt;/code&gt; module as part of the JS language</source>
          <target state="translated">&lt;strong&gt;2020-01-06 업데이트&lt;/strong&gt; : JS 언어의 일부로 표준 &lt;code&gt;uuid&lt;/code&gt; 모듈에 대한 &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;제안이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="782117c6d143f47d437449ef980ce5c3b76b9beb" translate="yes" xml:space="preserve">
          <source>A popular Open Source tool for working with UUIDs in JavaScript is &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</source>
          <target state="translated">JavaScript에서 UUID로 작업하기 위해 널리 사용되는 오픈 소스 도구는 &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba3de79909c92e381cfcb7d2ad3bb6d12b74b04d" translate="yes" xml:space="preserve">
          <source>A version based on Briguy37's answer and some bitwise operators to extract nibble sized windows from the buffer.</source>
          <target state="translated">버퍼에서 니블 크기의 창을 추출하는 Briguy37의 답변과 일부 비트 연산자를 기반으로 한 버전입니다.</target>
        </trans-unit>
        <trans-unit id="8b32b76d7d98de48b1c8d4fca55b71b36e586c91" translate="yes" xml:space="preserve">
          <source>A web service would be useful.</source>
          <target state="translated">웹 서비스가 유용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="efe0742dcba00224262ee5b679bb64e2dd8254ac" translate="yes" xml:space="preserve">
          <source>Adjusted my own UUID/GUID generator with some extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;여기에&lt;/a&gt; 추가로 내 자신의 UUID / GUID 생성기를 조정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="12c755e3c27b17c5f8c8e0155d60eabe76a0405a" translate="yes" xml:space="preserve">
          <source>An UUID must have this format:</source>
          <target state="translated">UUID는 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="12c696bae1749afdd4c10d3071dc3d49e8ee7766" translate="yes" xml:space="preserve">
          <source>Basically, the same inner logic, except we check for &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, and using a while loop (instead of &lt;code&gt;replace()&lt;/code&gt; callbacks) gets us an almost 3X improvement!</source>
          <target state="translated">기본적으로 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;4&lt;/code&gt; 를 확인하고 &lt;code&gt;replace()&lt;/code&gt; 콜백 대신 while 루프를 사용하는 것을 제외하고는 동일한 내부 논리가 거의 3 배 향상되었습니다!</target>
        </trans-unit>
        <trans-unit id="99bc098eb1d1be9a1e4498d4108a52905669d15e" translate="yes" xml:space="preserve">
          <source>Below is my script with the Mash and Kybos methods from baagoe.com excluded.</source>
          <target state="translated">아래는 baagoe.com의 Mash 및 Kybos 메소드가 제외 된 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c650c2cdd89b69f5f213fde542a728fd50fc0983" translate="yes" xml:space="preserve">
          <source>But first, my results, compared to broofa, &lt;code&gt;guid&lt;/code&gt; (the accepted answer), and the non-rfc-compliant &lt;code&gt;generateQuickGuid&lt;/code&gt;:</source>
          <target state="translated">그러나 먼저 내 결과는 broofa, &lt;code&gt;guid&lt;/code&gt; (허용 된 답변) 및 rfc 호환이 아닌 generateQuickGuid와 비교되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3ef02731ee702db53ed68d0ba455be85ab88617" translate="yes" xml:space="preserve">
          <source>But if you're looking at that regular expression, those many &lt;code&gt;replace()&lt;/code&gt; callbacks, &lt;code&gt;toString()&lt;/code&gt;'s and &lt;code&gt;Math.random()&lt;/code&gt; function calls (where he's only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with &lt;code&gt;generateQuickGUID&lt;/code&gt;.</source>
          <target state="translated">그러나 정규 표현식, 많은 &lt;code&gt;replace()&lt;/code&gt; 콜백, &lt;code&gt;toString()&lt;/code&gt; 및 &lt;code&gt;Math.random()&lt;/code&gt; 함수 호출 (4 비트의 결과 만 사용하고 나머지는 낭비하는 경우)을 보면 시작할 수 있습니다 성능에 대해 궁금합니다. 실제로 joelpt는 generateQuickGUID로 일반 GUID 속도를 위해 RFC를 포기하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="717ee0beb1305a91a9a0535e4961247e24e32fc5" translate="yes" xml:space="preserve">
          <source>Can't vouch for this implementation, but SOMEONE must publish a bonafide GUID generator.</source>
          <target state="translated">이 구현을 보증 할 수는 없지만 SOMEONE은 Bonafide GUID 생성기를 게시해야합니다.</target>
        </trans-unit>
        <trans-unit id="01536fdf7462153cb5b1d4174a32db140aec25c2" translate="yes" xml:space="preserve">
          <source>Create GUID / UUID in JavaScript</source>
          <target state="translated">JavaScript로 GUID / UUID 만들기</target>
        </trans-unit>
        <trans-unit id="95e6f920efe4af2e79e605edcc5e28ed1b15c6c5" translate="yes" xml:space="preserve">
          <source>Cryptographically strong random # generation on supporting platforms.</source>
          <target state="translated">지원 플랫폼에서 암호화 적으로 강력한 랜덤 # 생성.</target>
        </trans-unit>
        <trans-unit id="0ed439a6611cd1800f10c6bd949b76b487cd2b75" translate="yes" xml:space="preserve">
          <source>Download Raw File (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt;
Download Raw File (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&lt;/a&gt;</source>
          <target state="translated">원시 파일 다운로드 (uuid v1) : &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt; 원시 파일 다운로드 (uuid v4) : &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node -uuid / master / v4.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="ed293f503837b9994324552ef62fd849b6ccd846" translate="yes" xml:space="preserve">
          <source>ES6 sample</source>
          <target state="translated">ES6 샘플</target>
        </trans-unit>
        <trans-unit id="d7ddd41483a929219e6c64489e8d0eca72b29277" translate="yes" xml:space="preserve">
          <source>Edit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it's a few random digits short. (Add more random digits if you need it) The upside is that this it's really fast :)
You can &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;test validity of your GUID here&lt;/a&gt;</source>
          <target state="translated">편집 : 위의 코드는 의도를 따르지 만 RFC의 글자는 아닙니다. 다른 불일치 중에는 임의의 숫자가 짧습니다. (필요한 경우 임의의 숫자를 더 추가하십시오.) 거꾸로하면 이것이 정말 빠릅니다. &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;GUID의 유효성을 테스트&lt;/a&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d3d52832b1fac459c9b6a3703887d6cc457b232" translate="yes" xml:space="preserve">
          <source>Eventually we build the GUID with the following chaining: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt;, and return it.</source>
          <target state="translated">결국 우리는 &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt; 체인을 사용하여 GUID를 빌드하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="ce2e69b5373a12bdf9ca27da533c517da11f6e58" translate="yes" xml:space="preserve">
          <source>Fastest GUID like string generator method in the format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;. This does not generate standard-compliant GUID.</source>
          <target state="translated">&lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; 형식의 문자열 생성기 방식과 같은 가장 빠른 GUID. 표준 호환 GUID는 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="19967ecebb03ba38cc744454a4a0af16a7d1a8e8" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:</source>
          <target state="translated">&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; 버전 4 호환 솔루션의 경우이 단일 솔루션 (ish) 솔루션은 다음과 같은 가장 컴팩트 한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="0fa53fa9049ab50aea42e7e785eb43daf3f7b3eb" translate="yes" xml:space="preserve">
          <source>For an explanation, let's start with broofa's code:</source>
          <target state="translated">설명을 위해, broofa의 코드로 시작해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="ab095b33ae4fc9f4c67064d2613f861fa360db4f" translate="yes" xml:space="preserve">
          <source>For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):</source>
          <target state="translated">속도를 고려한 rfc4122 버전 4 호환 솔루션을 원하는 경우 (Math.random ()을 거의 호출하지 않음) :</target>
        </trans-unit>
        <trans-unit id="27fd956c4f1ae3c3c9ea49a4371ca211e7952e8e" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy's technical blog&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy의 기술 블로그에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c23b6b59226a5a1d9cd6f8d8dedd94737c6ed311" translate="yes" xml:space="preserve">
          <source>Generate RFC4122 version 1 or version 4 UUIDs</source>
          <target state="translated">RFC4122 버전 1 또는 버전 4 UUID 생성</target>
        </trans-unit>
        <trans-unit id="4557d9f04a62ecf6d45c63f669d4d3c5969dbed7" translate="yes" xml:space="preserve">
          <source>Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.</source>
          <target state="translated">RFC 호환 GUID보다 짧고 고유 한 UID를 생성하는 26 개의 [a-z0-9] 문자를 생성합니다. 사람의 가독성이 중요한 경우 대시를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c37e10249fd54645ca14d4f8396558ccf7ed72d1" translate="yes" xml:space="preserve">
          <source>Here are usage examples and timings for this function and several of this question's other answers. The timing was performed under Chrome m25, 10 million iterations each.</source>
          <target state="translated">다음은이 함수의 사용법 예제와 타이밍 및이 질문의 다른 답변 중 일부입니다. 타이밍은 Chrome m25에서 각각 천만 번 반복하여 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="2c247f731cda829ae025095a8672be34b63c5632" translate="yes" xml:space="preserve">
          <source>Here is a combination of the &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;top voted answer&lt;/a&gt;, with a workaround for &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome's collisions&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome의 충돌에&lt;/a&gt; 대한 해결 방법과 함께 &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;가장 많이 투표 된 답변&lt;/a&gt; 의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="2ecd98e5e9126eb4bab9ba9ad9ac22335c8bce41" translate="yes" xml:space="preserve">
          <source>Here is a sample of the UUIDs generated :</source>
          <target state="translated">다음은 생성 된 UUID 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="8261ebf8b6de8850d44b04f0d061fad3a19b0b3b" translate="yes" xml:space="preserve">
          <source>Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.</source>
          <target state="translated">다음은 ASCII 안전 GUID와 같은 고유 식별자를 생성하기위한 완전히 호환되지 않지만 성능이 뛰어난 구현입니다.</target>
        </trans-unit>
        <trans-unit id="503ff0a7dc77de993388c1e8009b02daf56b5134" translate="yes" xml:space="preserve">
          <source>Here is the timing code.</source>
          <target state="translated">타이밍 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8117e866b4a966496f20af5f99e7bfccef4d04fa" translate="yes" xml:space="preserve">
          <source>Here's a fiddle to test.</source>
          <target state="translated">테스트 할 바이올린이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60ff7b70fc22b138ecf074493ca83ac61514a43a" translate="yes" xml:space="preserve">
          <source>Here's a similar &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if &lt;code&gt;Math.random&lt;/code&gt; is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:</source>
          <target state="translated">다음은 타임 스탬프의 16 진 부분으로 처음 13 개의 16 진수를 오프셋하고 페이지로드 이후 마이크로 초의 16 진 부분으로 오프셋을 고갈 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;시켜서이&lt;/a&gt; 문제를 해결하는 유사한 RFC4122 버전 4 호환 솔루션입니다. 이렇게하면 &lt;code&gt;Math.random&lt;/code&gt; 이 동일한 시드에 있더라도 두 클라이언트 모두 페이지로드 이후 (고성능 시간이 지원되는 경우) 정확한 밀리 초 (또는 10,000+ 년) 이후 UUID를 정확히 동일한 마이크로 초 수로 생성해야합니다. 나중에) 같은 UUID를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="4e21d976cadf293249dcfa48c33d29b6a5e06a86" translate="yes" xml:space="preserve">
          <source>Here's a solution dated Oct. 9, 2011 from a comment by user &lt;em&gt;jed&lt;/em&gt; at &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883의&lt;/a&gt; 사용자 &lt;em&gt;jed&lt;/em&gt; 가 작성한 주석의 2011 년 10 월 9 일자 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="b18abaaddfcfe54404b43a907e463bef2f7d1c8b" translate="yes" xml:space="preserve">
          <source>Here's some code based on &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).</source>
          <target state="translated">다음은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; , 섹션 4.4 (정확히 임의 또는 의사 난수에서 UUID를 생성하기위한 알고리즘)를 기반으로하는 일부 코드입니다.</target>
        </trans-unit>
        <trans-unit id="79fadeaf6225db3316856bec94555fdca94516bd" translate="yes" xml:space="preserve">
          <source>I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): &lt;code&gt;XXXXXXXX&lt;/code&gt; and &lt;code&gt;-XXXX-XXXX&lt;/code&gt;.</source>
          <target state="translated">GUID를 4 조각으로 나누었고 각 조각은 &lt;code&gt;XXXXXXXX&lt;/code&gt; 및 &lt;code&gt;-XXXX-XXXX&lt;/code&gt; 의 두 가지 유형 (또는 형식)으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="a293bf864a92ae3bdd88eece8abb78a30146eb51" translate="yes" xml:space="preserve">
          <source>I hope my logic is correct -- it's very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!</source>
          <target state="translated">나는 나의 논리가 정확하기를 바란다. 이런 종류의 지루한 비트 작업에서 실수를 저지르는 것은 매우 쉽다. 그러나 출력은 나에게 좋아 보인다. 코드 최적화를 통해이 미친 듯이 즐거운 시간을 보내시기 바랍니다.</target>
        </trans-unit>
        <trans-unit id="25720d68a9e1e89c7d65f4d275b178f61def9e81" translate="yes" xml:space="preserve">
          <source>I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt;) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:</source>
          <target state="translated">나는 오래된 질문입니다. 완벽 함을 위해 환경이 SharePoint 인 경우 새 guid를 생성하는 &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; ( &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt; )라는 유틸리티 기능이 있습니다. 이 기능은 sp.init.js 파일에 있습니다. 이 함수를 다시 작성하면 (다른 개인 함수에서 다른 종속성을 제거하기 위해) 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="177c45f419a9b6ef3b4867a7b50e33c9277b2464" translate="yes" xml:space="preserve">
          <source>I really like how clean &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa's answer&lt;/a&gt; is, but it's unfortunate that &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;poor implementations of &lt;code&gt;Math.random&lt;/code&gt;&lt;/a&gt; leave the chance for collision.</source>
          <target state="translated">나는 &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa의 대답&lt;/a&gt; 이 얼마나 깨끗한 지 정말로 좋아하지만 불행한 &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt; &lt;code&gt;Math.random&lt;/code&gt; 구현으로&lt;/a&gt; 충돌의 기회를 남기는 것은 불행한 일입니다.</target>
        </trans-unit>
        <trans-unit id="96f12778c6d1c9cb9e9f724becdd6f22ca538716" translate="yes" xml:space="preserve">
          <source>I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.</source>
          <target state="translated">나는 여전히 256 요소 LUT를 사용하여 한 번에 16 비트를 처리하는 e6 ()을 시도했으며 최적화의 감소 수익을 보여주었습니다. 반복 횟수는 적었지만 내부 논리는 처리 증가로 인해 복잡해졌으며 데스크톱에서도 동일하게 수행되었으며 모바일에서는 ~ 10 % 더 빨랐습니다.</target>
        </trans-unit>
        <trans-unit id="94aaabbae44f4bbe89bcd126762f2426e665aaa1" translate="yes" xml:space="preserve">
          <source>I wanted to understand broofa's answer, so I expanded it and added comments:</source>
          <target state="translated">나는 broofa의 답변을 이해하고 싶었으므로 그것을 확장하고 의견을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="25657ae09cdf1fab859fd8ed647641b977c468b2" translate="yes" xml:space="preserve">
          <source>I'm sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:</source>
          <target state="translated">나는 당신의 대부분이 내가 한 일을 이해할 것이라고 확신하지만, 설명이 필요한 사람이 적어도 한 명있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="07563a60a63f4a9f390f1d6b7207d34d1b6c8994" translate="yes" xml:space="preserve">
          <source>I'm trying to create globally-unique identifiers in JavaScript.  I'm not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc..</source>
          <target state="translated">JavaScript로 전역 고유 식별자를 만들려고합니다. 모든 브라우저에서 어떤 루틴을 사용할 수 있는지, 내장 난수 생성기가 어떻게 &quot;랜덤&quot;되고 시드되었는지 잘 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="edc7a41e1c3907cce12f657d31fbd8e2e62aef40" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;the following Kybos&lt;/a&gt; random number generator to be a bit more cryptographically sound.</source>
          <target state="translated">&lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;다음 Kybos&lt;/a&gt; 난수 생성기를 사용하여 좀 더 암호로 소리를냅니다.</target>
        </trans-unit>
        <trans-unit id="24039edb982143cd91d9ef8c02193697aea634ab" translate="yes" xml:space="preserve">
          <source>If ID's are generated more than 1 millisecond apart, they are 100% unique.</source>
          <target state="translated">ID가 1 밀리 초 이상 생성되면 100 % 고유합니다.</target>
        </trans-unit>
        <trans-unit id="ac405bebd06ff78ed2b4d8ddea9b5fb92065b420" translate="yes" xml:space="preserve">
          <source>If anyone is still interested, here's my solution.</source>
          <target state="translated">누구든지 여전히 관심이 있다면 내 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bbc7c26eab6650d1c206af8ed5fc119de549fd" translate="yes" xml:space="preserve">
          <source>If two ID's are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID's that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)</source>
          <target state="translated">짧은 간격으로 두 개의 ID가 생성되고 임의 방법이 실제로 무작위라고 가정하면 전 세계적으로 고유 할 가능성이있는 99.99999999999999 % 인 ID를 생성합니다 (10 ^ 15 중 1의 충돌).</target>
        </trans-unit>
        <trans-unit id="da9dc85e7b0b0b4506b983c73c54454686b58e25" translate="yes" xml:space="preserve">
          <source>If you just need a random 128 bit string in no particular format you can use:</source>
          <target state="translated">특정 형식이 아닌 임의의 128 비트 문자열이 필요한 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f68a22918e41434d843ee9ec535c8561aadbdf" translate="yes" xml:space="preserve">
          <source>Interested in how?  I've put the full source on &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; and on &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</source>
          <target state="translated">방법에 관심이 있습니까? &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; 및 &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt; 에 전체 소스를 넣었습니다.</target>
        </trans-unit>
        <trans-unit id="67bc45c70d80a1bf17613bc8bbbc170612956cf6" translate="yes" xml:space="preserve">
          <source>It's just a simple AJAX call...</source>
          <target state="translated">간단한 AJAX 호출입니다 ...</target>
        </trans-unit>
        <trans-unit id="0bad48021176f9dcc3cc0a91ab6055920051d3c7" translate="yes" xml:space="preserve">
          <source>JavaScript project on GitHub - &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</source>
          <target state="translated">GitHub의 JavaScript 프로젝트-https: &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;//github.com/LiosK/UUID.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac95cb4089b08b71444e4ad4f7144f620d5f30d" translate="yes" xml:space="preserve">
          <source>Link to this post on my blog</source>
          <target state="translated">내 블로그에서이 게시물에 링크</target>
        </trans-unit>
        <trans-unit id="c6d383d13425b9e72d4d3cd3c6a68dcf8a621c40" translate="yes" xml:space="preserve">
          <source>Low timestamp resolution of JavaScript is compensated by random
  numbers.</source>
          <target state="translated">JavaScript의 낮은 타임 스탬프 해상도는 난수로 보상됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2f909c05dbaf7e4ed33d417a4c2eea6fe81f80" translate="yes" xml:space="preserve">
          <source>Minimized:</source>
          <target state="translated">Minimized:</target>
        </trans-unit>
        <trans-unit id="9ac71edf2df3b6f23bf1480bc49e05ce8b2772d8" translate="yes" xml:space="preserve">
          <source>Modualized:  &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</source>
          <target state="translated">수정 : &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js-UUID.generate&lt;/a&gt; &lt;code&gt;UUID.generate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a267ce45e411c0a01408b105e2778acfc528266" translate="yes" xml:space="preserve">
          <source>Note that just randomly generating the identifiers byte by byte, or character by character, will not give you the same guarantees as a conforming implementation. Also, very important, systems working with compliant UUIDs may choose not to accept randomly generated ones, and many open source validators will actually check for a valid structure.</source>
          <target state="translated">바이트 단위 또는 문자 단위로 식별자를 무작위로 생성하는 것만으로는 적합한 구현과 동일한 보장을 제공하지 않습니다. 또한 매우 중요한 것은 호환 UUID를 사용하는 시스템에서 임의로 생성 된 시스템을 허용하지 않기로 선택할 수 있으며 많은 오픈 소스 유효성 검사기에서 실제로 유효한 구조를 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="301ff6a51953eb41837bc511f9e5c3ae53d3ae1d" translate="yes" xml:space="preserve">
          <source>Now I'm building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: &lt;code&gt;XXXXXXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;XXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;XXXXXXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;XXXXXXXX&lt;/code&gt; 와 같이이 두 가지 유형을 사용하여 GUID를 호출하여 4 조각으로 GUID를 조립하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="541286569013fbf7b101171547520eb0173e2a80" translate="yes" xml:space="preserve">
          <source>On the client side:</source>
          <target state="translated">클라이언트 측에서 :</target>
        </trans-unit>
        <trans-unit id="a0f15b429784204142403c3e89a6f960dcf0f9c0" translate="yes" xml:space="preserve">
          <source>On the server side:</source>
          <target state="translated">서버 측에서 :</target>
        </trans-unit>
        <trans-unit id="13545970e3244692419e21474fdc76bde2632c4f" translate="yes" xml:space="preserve">
          <source>Only uses 8 for &quot;y&quot; because that simplifies code readability (y is allowed to be 8, 9, A or B).</source>
          <target state="translated">코드 가독성을 단순화하기 때문에 &quot;y&quot;에 8 만 사용합니다 (y는 8, 9, A 또는 B 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="ba3badc82ce48554f2991852eda7f8ec170df9ae" translate="yes" xml:space="preserve">
          <source>Optimised for code readability not speed, so suitable for say a few hundred uuid's per second. Generates about 10000 uuid() per second in Chromium on my laptop using &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; to measure performance.</source>
          <target state="translated">속도가 아닌 코드 가독성을 위해 최적화되어 초당 수백 uuid에 적합합니다. &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; 을 사용하여 랩톱의 Chromium에서 초당 약 10000 uuid ()를 생성하여 성능을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="60ed329b871109f2e80c6d1ae06b4ed0b9f7192e" translate="yes" xml:space="preserve">
          <source>Quick Google found: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</source>
          <target state="translated">빠른 Google 검색 : &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141a92f11e1b6d5986e38858b9d1b5190206712a" translate="yes" xml:space="preserve">
          <source>Retrns Guid. Sets Guid to user specified Guid, if invalid, returns an empty guid.</source>
          <target state="translated">레 트론 길드 Guid를 사용자 지정 Guid로 설정합니다. 유효하지 않은 경우 빈 guid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1feb3a46dd04e5b57054f2f7163b3ede19e7d05f" translate="yes" xml:space="preserve">
          <source>Returns a new Guid and sets it's value internally.</source>
          <target state="translated">새로운 Guid를 반환하고 내부적으로 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f7190b2a5a80dd9efe0cd084caf578d575e92a30" translate="yes" xml:space="preserve">
          <source>Returns an empty Guid 00000000-0000-0000-0000-000000000000.</source>
          <target state="translated">빈 Guid 00000000-0000-0000-0000-000000000000을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f0d77427c53b8fe9bdbe24d18a9cda7a1fd73bb" translate="yes" xml:space="preserve">
          <source>Returns boolean. True if empty/undefined/blank/null.</source>
          <target state="translated">부울을 반환합니다. 비어 있거나 정의되지 않았거나 비어 있거나 비어 있으면 true입니다.</target>
        </trans-unit>
        <trans-unit id="0b9548497aeb94cb100a89d540f35d747703f2da" translate="yes" xml:space="preserve">
          <source>Returns boolean. True valid guid, false if not.</source>
          <target state="translated">부울을 반환합니다. 유효한 유효한 guid, 그렇지 않으면 false</target>
        </trans-unit>
        <trans-unit id="dc5fcb0d1e7fddd4555389a6d2e329c75a93e257" translate="yes" xml:space="preserve">
          <source>Returns value of internal Guid. If no guid has been specified, returns a new one (value is then stored internally).</source>
          <target state="translated">내부 Guid의 값을 반환합니다. guid가 지정되지 않은 경우 새 guid를 반환합니다 (값은 내부에 저장 됨).</target>
        </trans-unit>
        <trans-unit id="c26904e72aae0a0460d96b4406f82c33e9c9d7d4" translate="yes" xml:space="preserve">
          <source>Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.</source>
          <target state="translated">이 기능을 사용하고있는 프로젝트를 다시 방문하여 자세한 정보를 싫어했습니다. 그러나 적절한 무작위성이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="a18caf389c3dfec80f9377a36c83ae5bd04e9610" translate="yes" xml:space="preserve">
          <source>Runs in node.js and browsers.</source>
          <target state="translated">node.js 및 브라우저에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="150bfcc434ccf43658e52e7f89fa0b96084559fc" translate="yes" xml:space="preserve">
          <source>See RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;.</source>
          <target state="translated">RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c898c8e028af83d42d23112d9bc7bc8ef781c67c" translate="yes" xml:space="preserve">
          <source>Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java's UUID.</source>
          <target state="translated">Java UUID로 비 규격 UUID를 구문 분석하는 데 문제가 있었으므로 RFC 유형 4 (임의) 스키마를 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="86a518bbca39591be11f3fd5fe07b57a8ca8b92a" translate="yes" xml:space="preserve">
          <source>Simple JavaScript module as a combination of best answers in this thread.</source>
          <target state="translated">이 글타래에서 최고의 답변을 조합 한 간단한 자바 스크립트 모듈.</target>
        </trans-unit>
        <trans-unit id="1659b110855243bf98e76cae362ba745d3973d56" translate="yes" xml:space="preserve">
          <source>Simple code that uses &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; on &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;supported browsers&lt;/a&gt; (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using &lt;code&gt;Math.random()&lt;/code&gt; because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;지원되는 브라우저&lt;/a&gt; (IE11 +, iOS7 +, FF21 +, Chrome, Android Chrome)에서 &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; 를 사용하는 간단한 코드입니다. &lt;code&gt;Math.random()&lt;/code&gt; 사용을 피하면 충돌이 발생할 수 있습니다 (예 : &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt; 의 실제 상황에서 4000 개의 생성 된 uuid 에 대한 20 개의 충돌).</target>
        </trans-unit>
        <trans-unit id="f7eba97181912e78f6a57cfff39d6bcad00f38f4" translate="yes" xml:space="preserve">
          <source>Simple, fast generation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS의 단순하고 빠른 생성</target>
        </trans-unit>
        <trans-unit id="ef07d769a203f544d121bb303d711abf57a3bd8d" translate="yes" xml:space="preserve">
          <source>Small footprint (Want something smaller? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Check this out!&lt;/a&gt;)</source>
          <target state="translated">작은 발자국 (작은 것을 원하십니까? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;이것을 확인하십시오!&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8f5a810efa3353e6f2f014c15bc590ece9b55f4c" translate="yes" xml:space="preserve">
          <source>So by my 6th iteration of optimizations, I beat the most popular answer by over &lt;strong&gt;12X&lt;/strong&gt;, the accepted answer by over &lt;strong&gt;9X&lt;/strong&gt;, and the fast-non-compliant answer by &lt;strong&gt;2-3X&lt;/strong&gt;.  And I'm still rfc4122 compliant.</source>
          <target state="translated">따라서 6 번의 최적화 반복으로 &lt;strong&gt;12X&lt;/strong&gt; 이상으로 가장 인기있는 답변, &lt;strong&gt;9X&lt;/strong&gt; 이상으로 허용되는 답변 및 &lt;strong&gt;2-3X로&lt;/strong&gt; 빠른 비준수 답변을 &lt;strong&gt;이겼습니다&lt;/strong&gt; . 그리고 나는 여전히 rfc4122를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="9494e936f74439fc11e4574afbc044b327ffb0e1" translate="yes" xml:space="preserve">
          <source>So it replaces &lt;code&gt;x&lt;/code&gt; with any random hex digit, &lt;code&gt;y&lt;/code&gt; with random data (except forcing the top 2 bits to &lt;code&gt;10&lt;/code&gt; per the RFC spec), and the regex doesn't match the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; characters, so he doesn't have to deal with them.  Very, very slick.</source>
          <target state="translated">따라서 &lt;code&gt;x&lt;/code&gt; 를 임의의 16 진수로 바꾸고 &lt;code&gt;y&lt;/code&gt; 를 임의의 데이터로 바꿉니다 (RFC 사양에 따라 상위 2 비트를 &lt;code&gt;10&lt;/code&gt; 으로 강제하는 것을 제외하고). 그들과 함께. 매우 매끄 럽습니다.</target>
        </trans-unit>
        <trans-unit id="72d265bb2510b83e6b57e5485d72d6bdb674bd84" translate="yes" xml:space="preserve">
          <source>Sometimes the &lt;code&gt;Math.random()&lt;/code&gt; function will return
shorter number (for example &lt;code&gt;0.4363&lt;/code&gt;), due to zeros at the end (from the example above, actually the number is &lt;code&gt;0.4363000000000000&lt;/code&gt;). That's why I'm appending to this string &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (a string with nine zeros) and then cutting it off with &lt;code&gt;substr()&lt;/code&gt; function to make it nine characters exactly (filling zeros to the right).</source>
          <target state="translated">때때로 &lt;code&gt;Math.random()&lt;/code&gt; 함수는 끝에서 0으로 인해 짧은 숫자 (예 : &lt;code&gt;0.4363&lt;/code&gt; )를 반환합니다 (위의 예에서 실제로 숫자는 &lt;code&gt;0.4363000000000000&lt;/code&gt; ). 그렇기 때문에이 문자열 &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (0이 9 인 문자열)에 추가 한 다음 &lt;code&gt;substr()&lt;/code&gt; 함수로 잘라내어 9 개의 문자를 정확하게 만들어서 오른쪽으로 0을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="2b6553806f7c0f446906395a9393b4c8aa630b83" translate="yes" xml:space="preserve">
          <source>Ten million executions of this implementation take just 32.5 seconds, which is the fastest I've ever seen in a browser (the only solution without loops/iterations).</source>
          <target state="translated">이 구현의 천만 번의 실행은 32.5 초 밖에 걸리지 않습니다. 이는 브라우저에서 본 것 중 가장 빠릅니다 (루프 / 반복이없는 유일한 솔루션).</target>
        </trans-unit>
        <trans-unit id="863a161fb9b85e54a7fd55bdfa890d777c3ecfdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math.random()&lt;/code&gt; function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for
example &lt;code&gt;0.4363923368509859&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Math.random()&lt;/code&gt; 함수는 소수점 이하 자릿수 뒤에 16 자리가있는 0과 1 사이의 10 진수를 반환합니다 (예 : &lt;code&gt;0.4363923368509859&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="acf4bc33ac4b01c7fa998c17fe2ab66beb9bb5bc" translate="yes" xml:space="preserve">
          <source>The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.</source>
          <target state="translated">GUID / UUID는 32 자 이상이어야하며 ASCII 범위를 유지하여 전달할 때 문제가 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d751df4e468da72f5959abfc1549c743c1e3ef6" translate="yes" xml:space="preserve">
          <source>The GUID is in the following format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">GUID는 &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; 형식으로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2541cbe64e15ab5d69eb08799c64ce9b1235e066" translate="yes" xml:space="preserve">
          <source>The above function should have a decent balance between speed and randomness.</source>
          <target state="translated">위의 기능은 속도와 임의성 사이의 균형이 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="ee47e6da31b267bf2647229a714a454ce65b3891" translate="yes" xml:space="preserve">
          <source>The best way to generate them, is to follow implementation instructions in the said RFC, use one of the many community vetted open source implementations.</source>
          <target state="translated">이를 생성하는 가장 좋은 방법은 RFC의 구현 지침을 따르는 것입니다. 커뮤니티에서 검증 된 많은 오픈 소스 구현 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66063bdfe4ff5bb41650a2179c29b0ae5581986f" translate="yes" xml:space="preserve">
          <source>The better way:</source>
          <target state="translated">더 좋은 방법 :</target>
        </trans-unit>
        <trans-unit id="c6b5d62b3d2700a480f847f1f5fc03de421dbca1" translate="yes" xml:space="preserve">
          <source>The final optimization technique to apply - unroll the loop.  Since we're looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:</source>
          <target state="translated">적용 할 최종 최적화 기술-루프를 전개하십시오. 우리는 고정 된 횟수로 반복하기 때문에 기술적으로 이것을 모두 손으로 작성할 수 있습니다. 나는 다시 할당하고 성능을 향상시키는 단일 무작위 변수 r로 이것을 한 번 시도했다. 그러나 4 개의 변수에 임의의 데이터를 미리 할당 한 다음 조회 테이블을 사용하고 적절한 RFC 비트를 적용하면이 버전이 모두 담배를 피 웁니다.</target>
        </trans-unit>
        <trans-unit id="27e5e746f56f3da4623926ba36af11cf24511a47" translate="yes" xml:space="preserve">
          <source>The first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:</source>
          <target state="translated">성능을 향한 첫 단계는 RegEx와 콜백 함수를 제거하고 대신 간단한 루프를 사용하는 것입니다. 이것은 broofa가 아닌 &lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;4&lt;/code&gt; 자를 처리해야 함을 의미합니다. 또한 String Array 인덱싱을 사용하여 매끄러운 String 템플릿 아키텍처를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f91cea12f7bb764e0dde68e533cd0001d9f6c9a" translate="yes" xml:space="preserve">
          <source>The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).</source>
          <target state="translated">가장 먼저 알아야 할 것은 정규 표현식처럼 함수 호출이 비싸다는 것입니다 (1을 사용하지만 각 일치에 대해 하나씩 32 개의 콜백이 있으며 각 32 개의 콜백에서 Math.random () 및 v를 호출합니다. toString (16)).</target>
        </trans-unit>
        <trans-unit id="5efd11cea6dbb2ca7d3856a6504baae9880ab778" translate="yes" xml:space="preserve">
          <source>The function is as simple as:</source>
          <target state="translated">이 기능은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="237b687de13a23a564832cfd020006932e2b7094" translate="yes" xml:space="preserve">
          <source>The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it's most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.</source>
          <target state="translated">재미있는 점은 16 바이트의 임의 데이터를 생성하는 것이 쉽다는 것입니다. 전체 트릭은 RFC 준수를 사용하여 문자열 형식으로 표현하며 16 바이트의 임의 데이터, 롤링되지 않은 루프 및 조회 테이블을 사용하여 가장 엄격하게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5fe390d75a55e87b91e0f2c344ccf52b0f992757" translate="yes" xml:space="preserve">
          <source>The next optimization is another classic.  Since we're only handling 4-bits of output in each loop iteration, let's cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it's not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.</source>
          <target state="translated">다음 최적화는 또 다른 고전입니다. 각 루프 반복에서 4 비트의 출력 만 처리하므로 루프 수를 반으로 줄이고 각 반복마다 8 비트를 처리하겠습니다. 우리는 여전히 RFC 호환 비트 위치를 처리해야하기 때문에 까다 롭지 만 그렇게 어렵지는 않습니다. 그런 다음 0x00-0xff를 저장하기 위해 더 큰 조회 테이블 (16x16 또는 256)을 만들어야하며 e5 () 함수 외부에서 한 번만 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2c2a678ccb7c402e8bfa66c3bb0b047a01880eeb" translate="yes" xml:space="preserve">
          <source>The next step is a small one on the desktop but makes a decent difference on mobile.  Let's make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let's also move that template definition out of the loop, just in case it helps:</source>
          <target state="translated">다음 단계는 데스크톱에서는 작은 단계이지만 모바일에서는 상당한 차이가 있습니다. 더 적은 Math.random () 호출을 만들고 각 반복마다 시프트되는 임의 버퍼로 87 %를 버리지 않고 모든 임의의 비트를 활용합시다. 다음과 같은 경우를 대비하여 해당 템플릿 정의를 루프 밖으로 옮기십시오.</target>
        </trans-unit>
        <trans-unit id="475810532e8a0fcebdd7c79eff23716432a61245" translate="yes" xml:space="preserve">
          <source>The reason for adding exactly nine zeros is because of the worse case scenario, which is when the &lt;code&gt;Math.random()&lt;/code&gt; function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That's why we needed to add nine zeros to it (&lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; or &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt;), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.</source>
          <target state="translated">정확히 9 개의 0을 추가하는 이유는 &lt;code&gt;Math.random()&lt;/code&gt; 함수가 정확히 0 또는 1 (각각 1 / 10 ^ 16의 확률 ) 을 반환하는 더 나쁜 경우 시나리오 때문입니다. 그렇기 때문에 9 개의 0을 추가하고 ( &lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt; ) 길이가 8자인 두 번째 색인 (3 번째 문자)에서 잘라냅니다. 나머지 경우에는 0을 추가해도 결과가 잘 리므로 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c79498301c475af77620127310a64ed51077604c" translate="yes" xml:space="preserve">
          <source>Then we cut off the &lt;code&gt;0.&lt;/code&gt; prefix (&lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt;
&lt;code&gt;6fb7687f&lt;/code&gt;) and get a string with eight hexadecimal
characters long.</source>
          <target state="translated">그런 다음 &lt;code&gt;0.&lt;/code&gt; 접두사 ( &lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt; &lt;code&gt;6fb7687f&lt;/code&gt; )를 잘라내어 8 개의 16 진 문자로 된 문자열을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9c8cde2548b6605f69b7f5277aa0db7d69ca4dbc" translate="yes" xml:space="preserve">
          <source>Then we take this number and convert
it to a string with base 16 (from the example above we'll get
&lt;code&gt;0.6fb7687f&lt;/code&gt;).</source>
          <target state="translated">그런 다음이 숫자를 가져 와서 밑 수가 16 인 문자열로 변환하십시오 (위의 예에서 &lt;code&gt;0.6fb7687f&lt;/code&gt; 가됩니다 ).</target>
        </trans-unit>
        <trans-unit id="f896659fdb57404f3ca1c0dd540b6ea7e7493cc7" translate="yes" xml:space="preserve">
          <source>There are other methods that involve using an ActiveX control, but stay away from these!</source>
          <target state="translated">ActiveX 컨트롤을 사용하는 다른 방법이 있지만 이러한 방법을 피하십시오!</target>
        </trans-unit>
        <trans-unit id="b6f314cd5d1632bbd12fce8c34bf0331b26c9531" translate="yes" xml:space="preserve">
          <source>There is a jQuery plugin that handles Guid's nicely @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</source>
          <target state="translated">Guid의 @ @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper를&lt;/a&gt; 잘 처리하는 jQuery 플러그인이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a114b1049ab77d7bb9cf82e5902a2fc8f9522f5b" translate="yes" xml:space="preserve">
          <source>This accomplishes the same goal as the &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;current highest-rated answer&lt;/a&gt;, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here's the annotated form of an older version of the function:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;현재 최고 등급의 답변&lt;/a&gt; 과 동일한 목표를 달성하지만, 강제, 재귀 및 지수 표기법을 활용하여 바이트 수가 50 바이트 이상 줄어 듭니다. 어떻게 작동하는지 궁금한 사람들을 위해 이전 버전의 함수에 주석이 달린 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c054a07bc3de1a2f3d45f3aab21e9af1ebf626bf" translate="yes" xml:space="preserve">
          <source>This create version 4 UUID (created from pseudo random numbers) :</source>
          <target state="translated">이것은 의사 난수로 만든 버전 4 UUID를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="58ce504b9f25064cbcb7de092b962c9e2dda22c0" translate="yes" xml:space="preserve">
          <source>This one is based on date, and add a random suffix to &quot;ensure&quot; uniqueness.
Works well for css identifiers.
It always returns something like and is easy to hack:</source>
          <target state="translated">이것은 날짜를 기준으로하며 고유성을 &quot;확보&quot;하기 위해 임의 접미사를 추가합니다. CSS 식별자에 적합합니다. 항상 같은 것을 반환하고 해킹하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c7a27f8c65115f387fec4d67fe32dab189f55a09" translate="yes" xml:space="preserve">
          <source>This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:</source>
          <target state="translated">이는 플랫폼에 따라 10-30 %를 절약합니다. 나쁘지 않다. 그러나 다음 큰 단계는 최적화 테이블 인 조회 테이블과 함께 toString 함수 호출을 완전히 제거합니다. 간단한 16 요소 룩업 테이블은 훨씬 짧은 시간에 toString (16) 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3e8bb274abfb2de0a2c13afefa3450f9f50f8d6e" translate="yes" xml:space="preserve">
          <source>To differ between these two types, I added a flag parameter to a pair creator function &lt;code&gt;_p8(s)&lt;/code&gt;, the &lt;code&gt;s&lt;/code&gt; parameter tells the function whether to add dashes or not.</source>
          <target state="translated">이 두 유형을 &lt;code&gt;_p8(s)&lt;/code&gt; 하기 위해 페어 생성자 함수 _p8 (s)에 플래그 매개 변수를 추가했습니다 .s 매개 변수는 대시를 추가할지 여부를 함수에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="1c7c150202fdddceb6b1c221a05cdb4e4c1ce115" translate="yes" xml:space="preserve">
          <source>To test the performance, you can run this code:</source>
          <target state="translated">성능을 테스트하기 위해 다음 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1c1c9e7da2bc289fcd3379642172b845c1989a" translate="yes" xml:space="preserve">
          <source>UUID object allows a variety of access to the UUID including access to
  the UUID fields.</source>
          <target state="translated">UUID 객체는 UUID 필드에 대한 액세스를 포함하여 UUID에 대한 다양한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a3b6d33b0517d8c2933196e2f509432ec47c7b44" translate="yes" xml:space="preserve">
          <source>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, are identifiers with a certain uniqueness guarantee.</source>
          <target state="translated">&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; 에 따르면 GUID (Globally Unique IDentifier)라고도하는 UUID (Universally Unique IDentifier)는 특정 고유성을 보장하는 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="670720d3ce8655613fb8e5107bd150a04eb2bb3d" translate="yes" xml:space="preserve">
          <source>Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs
  (time-based UUIDs) are available.</source>
          <target state="translated">버전 4 UUID (임의의 UUID) 및 버전 1 UUID (시간 기반 UUID)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebdce3a7ac7e93ecd1c5e84caaea7c1835d5f49" translate="yes" xml:space="preserve">
          <source>Want even smaller? Check this out: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</source>
          <target state="translated">더 작은 것을 원하십니까? 이것을 확인하십시오 : &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a55040507e6337ca3e32ec7d20777fced2a290d7" translate="yes" xml:space="preserve">
          <source>Well, this has a bunch of answers already, but unfortunately there's not a &quot;true&quot; random in the bunch. The version below is an adaptation of broofa's answer, but updated to include a &quot;true&quot; random function that uses crypto libraries where available, and the Alea() function as a fallback.</source>
          <target state="translated">글쎄, 이것은 이미 많은 대답을 가지고 있지만 불행히도 무리에 &quot;진정한&quot;임의가 없습니다. 아래 버전은 broofa의 답변을 수정 한 것이지만, 가능한 경우 암호화 라이브러리를 사용하는 &quot;진정한&quot;임의 함수와 대체로 Alea () 함수를 포함하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="7dad31345c220d2cbe299045c03a52e22b20d937" translate="yes" xml:space="preserve">
          <source>Where the &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; positions may only have certain values. At this time, the only valid values for M are 1, 2, 3, 4 and 5, so randomly generating that position would make most results unacceptable.</source>
          <target state="translated">&lt;em&gt;M&lt;/em&gt; 및 &lt;em&gt;N&lt;/em&gt; 위치는 특정 값만 가질 수 있습니다. 현재 M에 유효한 값은 1, 2, 3, 4 및 5 뿐이므로 해당 위치를 임의로 생성하면 대부분의 결과를 받아 들일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b33ee51f78c94d3fa3e3d46126b5b2de5f92677" translate="yes" xml:space="preserve">
          <source>Which will return something like &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt; 과 같은 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00947a234207676f6b4f448ed89af28aa686b86c" translate="yes" xml:space="preserve">
          <source>With such a web service, you could develop a REST web interface that consumes the GUID web service, and serves it through AJAX to javascript in a browser.</source>
          <target state="translated">이러한 웹 서비스를 사용하면 GUID 웹 서비스를 사용하고 AJAX를 통해 브라우저에서 JavaScript로 제공하는 REST 웹 인터페이스를 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fb620aaed70bd0d3e4873af0570771d0ed649d" translate="yes" xml:space="preserve">
          <source>You can increase this number by adding more digits, but to generate 100% unique ID's you will need to use a global counter.</source>
          <target state="translated">더 많은 자릿수를 추가하여이 수를 늘릴 수 있지만 100 % 고유 ID를 생성하려면 글로벌 카운터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba59cf2f4053a03ebc1856c70811cb75b72d66b4" translate="yes" xml:space="preserve">
          <source>You can use node-uuid (&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt;)</source>
          <target state="translated">node-uuid ( &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt; )를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="da5cce2c829e18ada2502aedf48c415870558171" translate="yes" xml:space="preserve">
          <source>broofa's answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!</source>
          <target state="translated">broofa의 대답은 실제로 매끄럽고 매끄 럽습니다 .rfc4122 호환, 다소 읽기 쉽고 컴팩트합니다. 대박!</target>
        </trans-unit>
        <trans-unit id="5f37ba236f9a0c5e9361a753b0b9f82646c7f35a" translate="yes" xml:space="preserve">
          <source>if you need RFC compatibility, this formatting will pass as a valid version 4 GUID:</source>
          <target state="translated">RFC 호환성이 필요한 경우이 형식은 유효한 버전 4 GUID로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b32441e1af6b6c4e0de9080307ccfb43a3ea08b5" translate="yes" xml:space="preserve">
          <source>uid-139410573297741</source>
          <target state="translated">uid-139410573297741</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
