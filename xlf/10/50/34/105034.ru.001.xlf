<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/105034">
    <body>
      <group id="105034">
        <trans-unit id="68960fcc7ae0d6fd78f4a201eeb38fa8bb9a0ecf" translate="yes" xml:space="preserve">
          <source>&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</source>
          <target state="translated">&quot;c6c2d12f-d76b-5739-e551-07e6de5b0807&quot;</target>
        </trans-unit>
        <trans-unit id="a032d777f177ebd6e92855f3bce4c9d3de29d561" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;On jsbin&lt;/a&gt; if you want to test it.</source>
          <target state="translated">&lt;a href=&quot;http://jsbin.com/uqives/3&quot;&gt;На jsbin,&lt;/a&gt; если вы хотите проверить это.</target>
        </trans-unit>
        <trans-unit id="54853102ac5288d10305ee4fe284f5676c8b3049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(Math.random().toString(16).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="518c3687d473e405f713a2e4202e1617f257a7bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)+&quot;000000000&quot;).substr(2,8)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="7de15d516266250876bf7df115f60af51b87ba40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random().toString(16)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a4bfa8acce2c58437408c5567e16ba754efc3619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be advised:&lt;/strong&gt; my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.</source>
          <target state="translated">&lt;strong&gt;Имейте в виду:&lt;/strong&gt; моей главной целью было показать и научить потенциальных стратегий оптимизации. Другие ответы охватывают важные темы, такие как столкновения и действительно случайные числа, которые важны для создания хороших UUID.</target>
        </trans-unit>
        <trans-unit id="a8558249d3c59db88fd2392888164f8297752e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But, can we get speed &lt;em&gt;and&lt;/em&gt; RFC compliance?  I say, YES!&lt;/strong&gt;  Can we maintain readability?  Well...  Not really, but it's easy if you follow along.</source>
          <target state="translated">&lt;strong&gt;Но можем ли мы получить скорость &lt;em&gt;и&lt;/em&gt; соответствие RFC?&lt;/strong&gt; &lt;strong&gt;Я сказал да!&lt;/strong&gt; Можем ли мы поддерживать читабельность? Ну ... Не совсем, но это легко, если вы будете следовать.</target>
        </trans-unit>
        <trans-unit id="0aa9a4872e5871a2d50503b7555d5a560abc60db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b79b40ec4e7164794f3d15d07d564b8ad8717468" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit :&lt;/strong&gt;  I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;wikipedia article&lt;/a&gt;).  There is always a chance of collisions.  A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.</source>
          <target state="translated">&lt;strong&gt;Изменить:&lt;/strong&gt; Я думал, что стоит отметить, что никакой генератор GUID не может гарантировать уникальные ключи (см. &lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_Unique_Identifier&quot;&gt;Статью&lt;/a&gt; в Википедии ). Всегда есть вероятность столкновения. GUID просто предлагает достаточно большой набор ключей, чтобы уменьшить количество столкновений почти до нуля.</target>
        </trans-unit>
        <trans-unit id="7015ec1e0155111b63b36ee572b6bff0228a4302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enjoy! :-)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Наслаждайтесь!&lt;/strong&gt; &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="274339a4ddbe260b6a97172504035c73b5738ea9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Features Generates RFC 4122 compliant UUIDs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Особенности Генерирует UUID, соответствующие RFC 4122.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d77806e165bb48692701ad0de9af22b7850fba31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.empty&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.empty&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b0671d2fe50cfe5c11475ae51a2760cbcda6baf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guid.newGuid()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4cf7a599e78acfd69a7e284fa3d3b67982dccad6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Install Using NPM:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Установите используя NPM:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf75b8ebe887aa6577cd720281924cbc349c929" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Or Using uuid via browser:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Или используя uuid через браузер:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35889b4f21085883cbaa19da2a6b14684bd0aada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The algorithm:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Алгоритм:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25b1935958bb975920d8012409acce290de08a28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The assembly:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ассамблея:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c002957f28f184ef81e532a83ab90120a2e876b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UUID.js The RFC-compliant UUID generator for JavaScript.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UUID.js RFC-совместимый генератор UUID для JavaScript.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469336e52af17d529352df89c21d2a5435257e12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-06-02&lt;/strong&gt;:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses &lt;code&gt;Math.random()&lt;/code&gt; for brevity, however &lt;code&gt;Math.random()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; guaranteed to be a high-quality RNG.  See Adam Hyland's &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;excellent writeup on Math.random()&lt;/a&gt; for details.  For a more robust solution, consider something like &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;the uuid module&lt;/a&gt; (disclaimer: I, @broofa, am the author), which uses higher quality RNG APIs where available.</source>
          <target state="translated">&lt;strong&gt;Обновление, 2015-06-02&lt;/strong&gt; : Учтите, что уникальность UUID в значительной степени зависит от базового генератора случайных чисел (RNG). В приведенном выше &lt;code&gt;Math.random()&lt;/code&gt; для краткости используется Math.random () , однако &lt;code&gt;Math.random()&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; обязательно является высококачественным ГСЧ. Посмотрите &lt;a href=&quot;http://bocoup.com/weblog/random-numbers/&quot;&gt;отличную рецензию&lt;/a&gt; Адама Хайленда на Math.random () для подробностей. Для более надежного решения рассмотрим что-то вроде &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;модуля uuid&lt;/a&gt; (заявление об отказе: я, @broofa, я автор), который использует API RNG более высокого качества, где это возможно.</target>
        </trans-unit>
        <trans-unit id="be0809af7361460fb45bdf84889bab84728f5e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2015-08-26&lt;/strong&gt;: As a side-note, this &lt;a href=&quot;https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0&quot;&gt;gist&lt;/a&gt; describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10&lt;sup&gt;15&lt;/sup&gt; version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.</source>
          <target state="translated">&lt;strong&gt;Обновление, 2015-08-26&lt;/strong&gt; : В качестве дополнительного примечания в этой части описывается, как определить, сколько идентификаторов может быть сгенерировано до достижения определенной вероятности столкновения. Например, с 3,26x10 &lt;sup&gt;15&lt;/sup&gt; UUID RFC4122 версии 4 у вас есть вероятность столкновения 1 на миллион.</target>
        </trans-unit>
        <trans-unit id="8fd4ff892cec4b2ce586409848ac995315f7db82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2017-06-28&lt;/strong&gt;: A &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;good article from Chrome developers&lt;/a&gt; discussing the state of Math.random PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it's &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here's an updated version of the above solution that uses ES6, the &lt;code&gt;crypto&lt;/code&gt; API, and &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;a bit of JS wizardry I can't take credit for&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Обновление, 2017-06-28&lt;/strong&gt; : &lt;a href=&quot;https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html&quot;&gt;Хорошая статья от разработчиков Chrome, в которой&lt;/a&gt; обсуждается состояние качества PRNG в Math.random в Chrome, Firefox и Safari. tl; dr - По состоянию на конец 2015 года это &quot;довольно хорошо&quot;, но не криптографическое качество. Чтобы решить эту проблему, вот обновленная версия вышеупомянутого решения, которая использует ES6, &lt;code&gt;crypto&lt;/code&gt; API и &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;немного волшебства JS, за которое я не могу взять кредит&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1395f19d7608f025cb58cb5b03b266e650d27c84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update, 2020-01-06&lt;/strong&gt;: There is a &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;proposal in the works&lt;/a&gt; for a standard &lt;code&gt;uuid&lt;/code&gt; module as part of the JS language</source>
          <target state="translated">&lt;strong&gt;Обновление, 2020-01-06&lt;/strong&gt; : в работе есть &lt;a href=&quot;https://github.com/tc39/proposal-uuid&quot;&gt;предложение&lt;/a&gt; для стандартного модуля &lt;code&gt;uuid&lt;/code&gt; как части языка JS</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="782117c6d143f47d437449ef980ce5c3b76b9beb" translate="yes" xml:space="preserve">
          <source>A popular Open Source tool for working with UUIDs in JavaScript is &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</source>
          <target state="translated">Популярный инструмент с открытым исходным кодом для работы с UUID в JavaScript - это &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;node-uuid&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba3de79909c92e381cfcb7d2ad3bb6d12b74b04d" translate="yes" xml:space="preserve">
          <source>A version based on Briguy37's answer and some bitwise operators to extract nibble sized windows from the buffer.</source>
          <target state="translated">Версия,основанная на ответе Briguy37 и некоторых битовых операторах для извлечения из буфера окон размером с клёв.</target>
        </trans-unit>
        <trans-unit id="8b32b76d7d98de48b1c8d4fca55b71b36e586c91" translate="yes" xml:space="preserve">
          <source>A web service would be useful.</source>
          <target state="translated">Было бы полезно воспользоваться веб-сервисом.</target>
        </trans-unit>
        <trans-unit id="efe0742dcba00224262ee5b679bb64e2dd8254ac" translate="yes" xml:space="preserve">
          <source>Adjusted my own UUID/GUID generator with some extras &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Настроил мой собственный генератор UUID / GUID с некоторыми дополнениями &lt;a href=&quot;http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12c755e3c27b17c5f8c8e0155d60eabe76a0405a" translate="yes" xml:space="preserve">
          <source>An UUID must have this format:</source>
          <target state="translated">UUID должен иметь такой формат:</target>
        </trans-unit>
        <trans-unit id="12c696bae1749afdd4c10d3071dc3d49e8ee7766" translate="yes" xml:space="preserve">
          <source>Basically, the same inner logic, except we check for &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, and using a while loop (instead of &lt;code&gt;replace()&lt;/code&gt; callbacks) gets us an almost 3X improvement!</source>
          <target state="translated">По сути, та же самая внутренняя логика, за исключением того, что мы проверяем на &lt;code&gt;-&lt;/code&gt; или &lt;code&gt;4&lt;/code&gt; , и использование цикла while (вместо &lt;code&gt;replace()&lt;/code&gt; ) дает нам почти трехкратное улучшение!</target>
        </trans-unit>
        <trans-unit id="99bc098eb1d1be9a1e4498d4108a52905669d15e" translate="yes" xml:space="preserve">
          <source>Below is my script with the Mash and Kybos methods from baagoe.com excluded.</source>
          <target state="translated">Ниже приведен мой скрипт,исключающий методы Mash и Kybos с baagoe.com.</target>
        </trans-unit>
        <trans-unit id="c650c2cdd89b69f5f213fde542a728fd50fc0983" translate="yes" xml:space="preserve">
          <source>But first, my results, compared to broofa, &lt;code&gt;guid&lt;/code&gt; (the accepted answer), and the non-rfc-compliant &lt;code&gt;generateQuickGuid&lt;/code&gt;:</source>
          <target state="translated">Но сначала мои результаты по сравнению с broof, guid (принятый ответ) и не соответствующим rfc &lt;code&gt;generateQuickGuid&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3ef02731ee702db53ed68d0ba455be85ab88617" translate="yes" xml:space="preserve">
          <source>But if you're looking at that regular expression, those many &lt;code&gt;replace()&lt;/code&gt; callbacks, &lt;code&gt;toString()&lt;/code&gt;'s and &lt;code&gt;Math.random()&lt;/code&gt; function calls (where he's only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with &lt;code&gt;generateQuickGUID&lt;/code&gt;.</source>
          <target state="translated">Но если вы посмотрите на это регулярное выражение, эти многочисленные обратные вызовы &lt;code&gt;Math.random()&lt;/code&gt; вызовы функций &lt;code&gt;toString()&lt;/code&gt; и Math.random () (где он использует только 4 бита результата и тратит впустую остальное), вы можете начать задуматься о производительности. Действительно, joelpt даже решил отказаться от RFC для общей скорости GUID с &lt;code&gt;generateQuickGUID&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="717ee0beb1305a91a9a0535e4961247e24e32fc5" translate="yes" xml:space="preserve">
          <source>Can't vouch for this implementation, but SOMEONE must publish a bonafide GUID generator.</source>
          <target state="translated">Не могу поручиться за эту реализацию,но SOMEONE должен опубликовать бонафидный генератор GUID.</target>
        </trans-unit>
        <trans-unit id="01536fdf7462153cb5b1d4174a32db140aec25c2" translate="yes" xml:space="preserve">
          <source>Create GUID / UUID in JavaScript</source>
          <target state="translated">Создать GUID UUID в JavaScript</target>
        </trans-unit>
        <trans-unit id="95e6f920efe4af2e79e605edcc5e28ed1b15c6c5" translate="yes" xml:space="preserve">
          <source>Cryptographically strong random # generation on supporting platforms.</source>
          <target state="translated">Криптографически сильная случайная#генерация на поддерживающих платформах.</target>
        </trans-unit>
        <trans-unit id="0ed439a6611cd1800f10c6bd949b76b487cd2b75" translate="yes" xml:space="preserve">
          <source>Download Raw File (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt;
Download Raw File (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&lt;/a&gt;</source>
          <target state="translated">Загрузить файл Raw (uuid v1): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js&lt;/a&gt; Загрузить файл Raw (uuid v4): &lt;a href=&quot;https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js&quot;&gt;https://raw.githubusercontent.com/kelektiv/node -uuid / мастер / v4.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="ed293f503837b9994324552ef62fd849b6ccd846" translate="yes" xml:space="preserve">
          <source>ES6 sample</source>
          <target state="translated">образец ES6</target>
        </trans-unit>
        <trans-unit id="d7ddd41483a929219e6c64489e8d0eca72b29277" translate="yes" xml:space="preserve">
          <source>Edit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it's a few random digits short. (Add more random digits if you need it) The upside is that this it's really fast :)
You can &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;test validity of your GUID here&lt;/a&gt;</source>
          <target state="translated">Изменить: приведенный выше код следуют намерению, но не букве RFC. Среди других несоответствий это несколько случайных цифр. (Добавьте больше случайных цифр, если вам это нужно) Плюс в том, что это действительно быстро :) Вы можете &lt;a href=&quot;https://www.freecodeformat.com/validate-uuid-guid.php&quot;&gt;проверить правильность вашего GUID здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d3d52832b1fac459c9b6a3703887d6cc457b232" translate="yes" xml:space="preserve">
          <source>Eventually we build the GUID with the following chaining: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt;, and return it.</source>
          <target state="translated">В конце концов мы создаем GUID со следующей цепочкой: &lt;code&gt;_p8() + _p8(true) + _p8(true) + _p8()&lt;/code&gt; и возвращаем его.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="ce2e69b5373a12bdf9ca27da533c517da11f6e58" translate="yes" xml:space="preserve">
          <source>Fastest GUID like string generator method in the format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;. This does not generate standard-compliant GUID.</source>
          <target state="translated">Самый быстрый GUID, как метод строкового генератора в формате &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; . Это не генерирует стандартный GUID.</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="19967ecebb03ba38cc744454a4a0af16a7d1a8e8" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:</source>
          <target state="translated">Для решения, совместимого с &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; версии 4, это однострочное (ish) решение является самым компактным из всех, что я мог придумать:</target>
        </trans-unit>
        <trans-unit id="0fa53fa9049ab50aea42e7e785eb43daf3f7b3eb" translate="yes" xml:space="preserve">
          <source>For an explanation, let's start with broofa's code:</source>
          <target state="translated">Для объяснения,давайте начнем с кода Бруфы:</target>
        </trans-unit>
        <trans-unit id="ab095b33ae4fc9f4c67064d2613f861fa360db4f" translate="yes" xml:space="preserve">
          <source>For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):</source>
          <target state="translated">Для тех,кто хочет получить решение,совместимое с rfc4122 версии 4,с учетом скорости (несколько вызовов Math.random()):</target>
        </trans-unit>
        <trans-unit id="27fd956c4f1ae3c3c9ea49a4371ca211e7952e8e" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;sagi shkedy's technical blog&lt;/a&gt;:</source>
          <target state="translated">Из &lt;a href=&quot;http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html&quot;&gt;технического блога Саги Шкеди&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c23b6b59226a5a1d9cd6f8d8dedd94737c6ed311" translate="yes" xml:space="preserve">
          <source>Generate RFC4122 version 1 or version 4 UUIDs</source>
          <target state="translated">Сгенерировать UUID RFC4122 версии 1 или версии 4</target>
        </trans-unit>
        <trans-unit id="4557d9f04a62ecf6d45c63f669d4d3c5969dbed7" translate="yes" xml:space="preserve">
          <source>Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.</source>
          <target state="translated">Генерирует 26 [a-z0-9]символов,что дает UID,который одновременно короче и уникальнее,чем RFC-совместимые GUID.Дэши могут быть тривиально добавлены,если важна человеческая читабельность.</target>
        </trans-unit>
        <trans-unit id="c37e10249fd54645ca14d4f8396558ccf7ed72d1" translate="yes" xml:space="preserve">
          <source>Here are usage examples and timings for this function and several of this question's other answers. The timing was performed under Chrome m25, 10 million iterations each.</source>
          <target state="translated">Ниже приведены примеры использования и тайминги этой функции,а также несколько других ответов на этот вопрос.Тайминг был выполнен под Chrome m25,по 10 миллионов итераций каждая.</target>
        </trans-unit>
        <trans-unit id="2c247f731cda829ae025095a8672be34b63c5632" translate="yes" xml:space="preserve">
          <source>Here is a combination of the &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;top voted answer&lt;/a&gt;, with a workaround for &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Chrome's collisions&lt;/a&gt;:</source>
          <target state="translated">Вот комбинация &lt;a href=&quot;https://stackoverflow.com/a/2117523/11236&quot;&gt;ответа&lt;/a&gt; с наибольшим количеством голосов и обходного пути для &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;столкновений Chrome&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2ecd98e5e9126eb4bab9ba9ad9ac22335c8bce41" translate="yes" xml:space="preserve">
          <source>Here is a sample of the UUIDs generated :</source>
          <target state="translated">Вот пример сгенерированных UUID :</target>
        </trans-unit>
        <trans-unit id="8261ebf8b6de8850d44b04f0d061fad3a19b0b3b" translate="yes" xml:space="preserve">
          <source>Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.</source>
          <target state="translated">Здесь представлена полностью несоответствующая,но очень производительная реализация для генерации ASCII-безопасного GUID-подобного уникального идентификатора.</target>
        </trans-unit>
        <trans-unit id="503ff0a7dc77de993388c1e8009b02daf56b5134" translate="yes" xml:space="preserve">
          <source>Here is the timing code.</source>
          <target state="translated">Вот временной код.</target>
        </trans-unit>
        <trans-unit id="8117e866b4a966496f20af5f99e7bfccef4d04fa" translate="yes" xml:space="preserve">
          <source>Here's a fiddle to test.</source>
          <target state="translated">Вот скрипка для проверки.</target>
        </trans-unit>
        <trans-unit id="60ff7b70fc22b138ecf074493ca83ac61514a43a" translate="yes" xml:space="preserve">
          <source>Here's a similar &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if &lt;code&gt;Math.random&lt;/code&gt; is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:</source>
          <target state="translated">Вот аналогичное &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;решение,&lt;/a&gt; соответствующее RFC4122 версии 4, которое решает эту проблему путем смещения первых 13 шестнадцатеричных чисел на шестнадцатеричную часть временной метки и однократного смещения на шестнадцатеричную часть микросекунд с момента загрузки страницы. Таким образом, даже если &lt;code&gt;Math.random&lt;/code&gt; находится на одном и том же начальном этапе, оба клиента должны будут генерировать UUID с одинаковым количеством микросекунд с момента загрузки страницы (если поддерживается время высокой производительности) И в ту же миллисекунду (или более 10 000 лет). позже) чтобы получить тот же UUID:</target>
        </trans-unit>
        <trans-unit id="4e21d976cadf293249dcfa48c33d29b6a5e06a86" translate="yes" xml:space="preserve">
          <source>Here's a solution dated Oct. 9, 2011 from a comment by user &lt;em&gt;jed&lt;/em&gt; at &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt;:</source>
          <target state="translated">Вот решение от 9 октября 2011 года из комментария пользователя &lt;em&gt;jed&lt;/em&gt; на &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;https://gist.github.com/982883&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b18abaaddfcfe54404b43a907e463bef2f7d1c8b" translate="yes" xml:space="preserve">
          <source>Here's some code based on &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).</source>
          <target state="translated">Вот некоторый код, основанный на &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; , раздел 4.4 (Алгоритмы для создания UUID из действительно случайного или псевдослучайного числа).</target>
        </trans-unit>
        <trans-unit id="79fadeaf6225db3316856bec94555fdca94516bd" translate="yes" xml:space="preserve">
          <source>I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): &lt;code&gt;XXXXXXXX&lt;/code&gt; and &lt;code&gt;-XXXX-XXXX&lt;/code&gt;.</source>
          <target state="translated">Я разделил GUID на 4 части, каждая из которых разделена на 2 типа (или форматы): &lt;code&gt;XXXXXXXX&lt;/code&gt; и &lt;code&gt;-XXXX-XXXX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a293bf864a92ae3bdd88eece8abb78a30146eb51" translate="yes" xml:space="preserve">
          <source>I hope my logic is correct -- it's very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!</source>
          <target state="translated">Надеюсь,моя логика верна-очень легко ошибиться в такой утомительной работе.Но результаты выглядят неплохо.Надеюсь,вам понравилась эта сумасшедшая поездка по оптимизации кода!</target>
        </trans-unit>
        <trans-unit id="25720d68a9e1e89c7d65f4d275b178f61def9e81" translate="yes" xml:space="preserve">
          <source>I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;msdn link&lt;/a&gt;) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:</source>
          <target state="translated">Я знаю, это старый вопрос. Просто для полноты, если ваша среда SharePoint, есть служебная функция &lt;code&gt;SP.Guid.newGuid&lt;/code&gt; ( &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx&quot;&gt;ссылка&lt;/a&gt; msdn ), которая создает новый guid. Эта функция находится внутри файла sp.init.js. Если вы переписываете эту функцию (чтобы удалить некоторые другие зависимости от других закрытых функций), она выглядит так:</target>
        </trans-unit>
        <trans-unit id="177c45f419a9b6ef3b4867a7b50e33c9277b2464" translate="yes" xml:space="preserve">
          <source>I really like how clean &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;Broofa's answer&lt;/a&gt; is, but it's unfortunate that &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;poor implementations of &lt;code&gt;Math.random&lt;/code&gt;&lt;/a&gt; leave the chance for collision.</source>
          <target state="translated">Мне действительно нравится, насколько чист &lt;a href=&quot;https://stackoverflow.com/a/2117523/508537&quot;&gt;ответ Бруфы&lt;/a&gt; , но, к сожалению, &lt;a href=&quot;https://stackoverflow.com/q/6906916/508537&quot;&gt;плохие реализации &lt;code&gt;Math.random&lt;/code&gt; &lt;/a&gt; оставляют возможность для столкновения.</target>
        </trans-unit>
        <trans-unit id="96f12778c6d1c9cb9e9f724becdd6f22ca538716" translate="yes" xml:space="preserve">
          <source>I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.</source>
          <target state="translated">Я попробовал e6(),которая одновременно обрабатывает 16 бит,все еще используя 256-элементный LUT,и она показала уменьшающуюся отдачу от оптимизации.Несмотря на то,что в ней было меньше итераций,внутренняя логика была усложнена за счет увеличенной обработки,и она выполнялась так же на рабочем столе,и только на ~10% быстрее на мобильном.</target>
        </trans-unit>
        <trans-unit id="94aaabbae44f4bbe89bcd126762f2426e665aaa1" translate="yes" xml:space="preserve">
          <source>I wanted to understand broofa's answer, so I expanded it and added comments:</source>
          <target state="translated">Мне хотелось понять ответ Брофы,поэтому я расширил его и добавил комментарии:</target>
        </trans-unit>
        <trans-unit id="25657ae09cdf1fab859fd8ed647641b977c468b2" translate="yes" xml:space="preserve">
          <source>I'm sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:</source>
          <target state="translated">Я уверен,что большинство из вас поймут,что я там сделал,но,возможно,есть хотя бы один человек,которому нужны объяснения:</target>
        </trans-unit>
        <trans-unit id="07563a60a63f4a9f390f1d6b7207d34d1b6c8994" translate="yes" xml:space="preserve">
          <source>I'm trying to create globally-unique identifiers in JavaScript.  I'm not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc..</source>
          <target state="translated">Я пытаюсь создать глобально унифицированные идентификаторы в JavaScript.Я не уверен,какие рутины доступны во всех браузерах,как &quot;случайные&quot; и посеял встроенный генератор случайных чисел,и т.д..</target>
        </trans-unit>
        <trans-unit id="edc7a41e1c3907cce12f657d31fbd8e2e62aef40" translate="yes" xml:space="preserve">
          <source>I'm using &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;the following Kybos&lt;/a&gt; random number generator to be a bit more cryptographically sound.</source>
          <target state="translated">Я использую &lt;a href=&quot;http://baagoe.com/en/RandomMusings/javascript/&quot;&gt;следующий генератор&lt;/a&gt; случайных чисел Kybos, чтобы быть немного более криптографически обоснованным.</target>
        </trans-unit>
        <trans-unit id="24039edb982143cd91d9ef8c02193697aea634ab" translate="yes" xml:space="preserve">
          <source>If ID's are generated more than 1 millisecond apart, they are 100% unique.</source>
          <target state="translated">Если идентификаторы генерируются с интервалом более 1 миллисекунды,то они на 100% уникальны.</target>
        </trans-unit>
        <trans-unit id="ac405bebd06ff78ed2b4d8ddea9b5fb92065b420" translate="yes" xml:space="preserve">
          <source>If anyone is still interested, here's my solution.</source>
          <target state="translated">Если кто-то все еще заинтересован,вот мое решение.</target>
        </trans-unit>
        <trans-unit id="48bbc7c26eab6650d1c206af8ed5fc119de549fd" translate="yes" xml:space="preserve">
          <source>If two ID's are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID's that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)</source>
          <target state="translated">Если через более короткие промежутки времени генерируются два ID,и если предположить,что случайный метод действительно случайный,то он генерирует ID,которые составляют 99,999999999999%,которые,вероятно,будут глобально уникальными (столкновение в 1 из 10^15).</target>
        </trans-unit>
        <trans-unit id="da9dc85e7b0b0b4506b983c73c54454686b58e25" translate="yes" xml:space="preserve">
          <source>If you just need a random 128 bit string in no particular format you can use:</source>
          <target state="translated">Если вам просто нужна случайная 128-битная строка ни в каком конкретном формате вы не можете ее использовать:</target>
        </trans-unit>
        <trans-unit id="f6f68a22918e41434d843ee9ec535c8561aadbdf" translate="yes" xml:space="preserve">
          <source>Interested in how?  I've put the full source on &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; and on &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</source>
          <target state="translated">Заинтересованы в том, как? Я разместил полный исходный код на &lt;a href=&quot;http://jsfiddle.net/jcward/7hyaC/3/&quot;&gt;http://jsfiddle.net/jcward/7hyaC/3/&lt;/a&gt; и на &lt;a href=&quot;http://jsperf.com/uuid-generator-opt/4&quot;&gt;http://jsperf.com/uuid-generator-opt/4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67bc45c70d80a1bf17613bc8bbbc170612956cf6" translate="yes" xml:space="preserve">
          <source>It's just a simple AJAX call...</source>
          <target state="translated">Это простой AJAX-звонок...</target>
        </trans-unit>
        <trans-unit id="0bad48021176f9dcc3cc0a91ab6055920051d3c7" translate="yes" xml:space="preserve">
          <source>JavaScript project on GitHub - &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</source>
          <target state="translated">Проект JavaScript на GitHub - &lt;a href=&quot;https://github.com/LiosK/UUID.js&quot;&gt;https://github.com/LiosK/UUID.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac95cb4089b08b71444e4ad4f7144f620d5f30d" translate="yes" xml:space="preserve">
          <source>Link to this post on my blog</source>
          <target state="translated">Ссылка на этот пост в моем блоге</target>
        </trans-unit>
        <trans-unit id="c6d383d13425b9e72d4d3cd3c6a68dcf8a621c40" translate="yes" xml:space="preserve">
          <source>Low timestamp resolution of JavaScript is compensated by random
  numbers.</source>
          <target state="translated">Низкое разрешение JavaScript компенсируется случайными числами.</target>
        </trans-unit>
        <trans-unit id="2a2f909c05dbaf7e4ed33d417a4c2eea6fe81f80" translate="yes" xml:space="preserve">
          <source>Minimized:</source>
          <target state="translated">Minimized:</target>
        </trans-unit>
        <trans-unit id="9ac71edf2df3b6f23bf1480bc49e05ce8b2772d8" translate="yes" xml:space="preserve">
          <source>Modualized:  &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</source>
          <target state="translated">Модулированный: &lt;a href=&quot;http://jcward.com/UUID.js&quot;&gt;http://jcward.com/UUID.js&lt;/a&gt; - &lt;code&gt;UUID.generate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a267ce45e411c0a01408b105e2778acfc528266" translate="yes" xml:space="preserve">
          <source>Note that just randomly generating the identifiers byte by byte, or character by character, will not give you the same guarantees as a conforming implementation. Also, very important, systems working with compliant UUIDs may choose not to accept randomly generated ones, and many open source validators will actually check for a valid structure.</source>
          <target state="translated">Обратите внимание,что просто случайное генерирование идентификаторов байт за байтом,или символ за символом,не даст вам тех же гарантий,что и соответствующая реализация.Также,очень важно,что системы,работающие с совместимыми UUID,могут не принимать случайно сгенерированные идентификаторы,и многие валидаторы с открытым исходным кодом будут на самом деле проверять правильность структуры.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="301ff6a51953eb41837bc511f9e5c3ae53d3ae1d" translate="yes" xml:space="preserve">
          <source>Now I'm building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: &lt;code&gt;XXXXXXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;-XXXX-XXXX&lt;/code&gt;&lt;code&gt;XXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">Сейчас я создаю GUID, используя эти 2 типа для сборки GUID с помощью вызова из 4 частей, как &lt;code&gt;-XXXX-XXXX&lt;/code&gt; ниже: &lt;code&gt;XXXXXXXX&lt;/code&gt; -XXXX-XXXX &lt;code&gt;-XXXX-XXXX&lt;/code&gt; &lt;code&gt;XXXXXXXX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="541286569013fbf7b101171547520eb0173e2a80" translate="yes" xml:space="preserve">
          <source>On the client side:</source>
          <target state="translated">На стороне клиента:</target>
        </trans-unit>
        <trans-unit id="a0f15b429784204142403c3e89a6f960dcf0f9c0" translate="yes" xml:space="preserve">
          <source>On the server side:</source>
          <target state="translated">На стороне сервера:</target>
        </trans-unit>
        <trans-unit id="13545970e3244692419e21474fdc76bde2632c4f" translate="yes" xml:space="preserve">
          <source>Only uses 8 for &quot;y&quot; because that simplifies code readability (y is allowed to be 8, 9, A or B).</source>
          <target state="translated">Для &quot;y&quot; используется только 8,потому что это упрощает чтение кода (y может быть 8,9,A или B).</target>
        </trans-unit>
        <trans-unit id="ba3badc82ce48554f2991852eda7f8ec170df9ae" translate="yes" xml:space="preserve">
          <source>Optimised for code readability not speed, so suitable for say a few hundred uuid's per second. Generates about 10000 uuid() per second in Chromium on my laptop using &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; to measure performance.</source>
          <target state="translated">Оптимизирован для удобства чтения кода, а не для скорости, поэтому подходит, например, для нескольких сотен единиц в секунду. Генерирует около 10000 uuid () в секунду в Chromium на моем ноутбуке, используя &lt;a href=&quot;http://jsbin.com/fuwigo/1&quot;&gt;http://jsbin.com/fuwigo/1&lt;/a&gt; для измерения производительности.</target>
        </trans-unit>
        <trans-unit id="60ed329b871109f2e80c6d1ae06b4ed0b9f7192e" translate="yes" xml:space="preserve">
          <source>Quick Google found: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</source>
          <target state="translated">Быстрый Google нашел: &lt;a href=&quot;http://www.hoskinson.net/GuidGenerator/&quot;&gt;http://www.hoskinson.net/GuidGenerator/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141a92f11e1b6d5986e38858b9d1b5190206712a" translate="yes" xml:space="preserve">
          <source>Retrns Guid. Sets Guid to user specified Guid, if invalid, returns an empty guid.</source>
          <target state="translated">Retrns Guid.Устанавливает руководство в указанное пользователем Руководство,если оно недействительно,возвращает пустую направляющую.</target>
        </trans-unit>
        <trans-unit id="1feb3a46dd04e5b57054f2f7163b3ede19e7d05f" translate="yes" xml:space="preserve">
          <source>Returns a new Guid and sets it's value internally.</source>
          <target state="translated">Возвращает новое руководство и устанавливает его ценность внутри себя.</target>
        </trans-unit>
        <trans-unit id="f7190b2a5a80dd9efe0cd084caf578d575e92a30" translate="yes" xml:space="preserve">
          <source>Returns an empty Guid 00000000-0000-0000-0000-000000000000.</source>
          <target state="translated">Возвращает пустой путеводитель 00000000-0000-000000-00000000.</target>
        </trans-unit>
        <trans-unit id="9f0d77427c53b8fe9bdbe24d18a9cda7a1fd73bb" translate="yes" xml:space="preserve">
          <source>Returns boolean. True if empty/undefined/blank/null.</source>
          <target state="translated">Возвращает булевую.Правда,если пустое неопределенное пятно.</target>
        </trans-unit>
        <trans-unit id="0b9548497aeb94cb100a89d540f35d747703f2da" translate="yes" xml:space="preserve">
          <source>Returns boolean. True valid guid, false if not.</source>
          <target state="translated">Возвращает булевую.Истинный действительный путеводитель,ложный,если нет.</target>
        </trans-unit>
        <trans-unit id="dc5fcb0d1e7fddd4555389a6d2e329c75a93e257" translate="yes" xml:space="preserve">
          <source>Returns value of internal Guid. If no guid has been specified, returns a new one (value is then stored internally).</source>
          <target state="translated">Возвращает значение внутреннего руководства.Если направляющая не была указана,возвращает новую (значение хранится внутри).</target>
        </trans-unit>
        <trans-unit id="c26904e72aae0a0460d96b4406f82c33e9c9d7d4" translate="yes" xml:space="preserve">
          <source>Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.</source>
          <target state="translated">Пересмотрел мой проект,в котором использовалась эта функция,и не любил глаголов.-Но нуждался в правильной случайности.</target>
        </trans-unit>
        <trans-unit id="a18caf389c3dfec80f9377a36c83ae5bd04e9610" translate="yes" xml:space="preserve">
          <source>Runs in node.js and browsers.</source>
          <target state="translated">Работает в node.js и браузерах.</target>
        </trans-unit>
        <trans-unit id="150bfcc434ccf43658e52e7f89fa0b96084559fc" translate="yes" xml:space="preserve">
          <source>See RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;.</source>
          <target state="translated">См. RFC 4122 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;http://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c898c8e028af83d42d23112d9bc7bc8ef781c67c" translate="yes" xml:space="preserve">
          <source>Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java's UUID.</source>
          <target state="translated">Должен придерживаться схемы RFC Type 4 (случайной),так как в прошлый раз у меня были проблемы при разборе несоответствующих UUID Java.</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Показать фрагмент кода</target>
        </trans-unit>
        <trans-unit id="86a518bbca39591be11f3fd5fe07b57a8ca8b92a" translate="yes" xml:space="preserve">
          <source>Simple JavaScript module as a combination of best answers in this thread.</source>
          <target state="translated">Простой модуль JavaScript как сочетание лучших ответов в этом потоке.</target>
        </trans-unit>
        <trans-unit id="1659b110855243bf98e76cae362ba745d3973d56" translate="yes" xml:space="preserve">
          <source>Simple code that uses &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; on &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;supported browsers&lt;/a&gt; (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using &lt;code&gt;Math.random()&lt;/code&gt; because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt;).</source>
          <target state="translated">Простой код, который использует &lt;code&gt;crypto.getRandomValues(a)&lt;/code&gt; в &lt;a href=&quot;http://caniuse.com/#search=getRandomValues&quot;&gt;поддерживаемых браузерах&lt;/a&gt; (IE11 +, iOS7 +, FF21 +, Chrome, Android Chrome). Избегает использования &lt;code&gt;Math.random()&lt;/code&gt; потому что это может вызвать коллизии (например, 20 коллизий для 4000 сгенерированных uuids в реальной ситуации &lt;a href=&quot;https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript&quot;&gt;Muxa&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f7eba97181912e78f6a57cfff39d6bcad00f38f4" translate="yes" xml:space="preserve">
          <source>Simple, fast generation of &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</source>
          <target state="translated">Простое, быстрое поколение &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC4122&lt;/a&gt; UUIDS.</target>
        </trans-unit>
        <trans-unit id="ef07d769a203f544d121bb303d711abf57a3bd8d" translate="yes" xml:space="preserve">
          <source>Small footprint (Want something smaller? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Check this out!&lt;/a&gt;)</source>
          <target state="translated">Маленький след (Хотите что-нибудь поменьше? &lt;a href=&quot;https://gist.github.com/982883&quot;&gt;Проверьте это!&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8f5a810efa3353e6f2f014c15bc590ece9b55f4c" translate="yes" xml:space="preserve">
          <source>So by my 6th iteration of optimizations, I beat the most popular answer by over &lt;strong&gt;12X&lt;/strong&gt;, the accepted answer by over &lt;strong&gt;9X&lt;/strong&gt;, and the fast-non-compliant answer by &lt;strong&gt;2-3X&lt;/strong&gt;.  And I'm still rfc4122 compliant.</source>
          <target state="translated">Таким образом, благодаря шестой итерации оптимизаций, я опередил самый популярный ответ более чем в 12 раз, принятый ответ более чем в &lt;strong&gt;9 раз&lt;/strong&gt; , а быстрый несоответствующий ответ - в &lt;strong&gt;2-3 раза&lt;/strong&gt; . И я все еще совместим с rfc4122.</target>
        </trans-unit>
        <trans-unit id="9494e936f74439fc11e4574afbc044b327ffb0e1" translate="yes" xml:space="preserve">
          <source>So it replaces &lt;code&gt;x&lt;/code&gt; with any random hex digit, &lt;code&gt;y&lt;/code&gt; with random data (except forcing the top 2 bits to &lt;code&gt;10&lt;/code&gt; per the RFC spec), and the regex doesn't match the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt; characters, so he doesn't have to deal with them.  Very, very slick.</source>
          <target state="translated">Таким образом, он заменяет &lt;code&gt;x&lt;/code&gt; на любую случайную шестнадцатеричную цифру, &lt;code&gt;y&lt;/code&gt; - на случайные данные (за исключением того, что старшие 2 бита равны &lt;code&gt;10&lt;/code&gt; в спецификации RFC), и регулярное выражение не соответствует &lt;code&gt;-&lt;/code&gt; или &lt;code&gt;4&lt;/code&gt; символам, поэтому ему не нужно иметь дело с с ними. Очень, очень гладко.</target>
        </trans-unit>
        <trans-unit id="72d265bb2510b83e6b57e5485d72d6bdb674bd84" translate="yes" xml:space="preserve">
          <source>Sometimes the &lt;code&gt;Math.random()&lt;/code&gt; function will return
shorter number (for example &lt;code&gt;0.4363&lt;/code&gt;), due to zeros at the end (from the example above, actually the number is &lt;code&gt;0.4363000000000000&lt;/code&gt;). That's why I'm appending to this string &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (a string with nine zeros) and then cutting it off with &lt;code&gt;substr()&lt;/code&gt; function to make it nine characters exactly (filling zeros to the right).</source>
          <target state="translated">Иногда &lt;code&gt;Math.random()&lt;/code&gt; возвращает более короткое число (например, &lt;code&gt;0.4363&lt;/code&gt; ) из-за нулей в конце (из приведенного выше примера на самом деле это значение равно &lt;code&gt;0.4363000000000000&lt;/code&gt; ). Вот почему я добавляю к этой строке &lt;code&gt;&quot;000000000&quot;&lt;/code&gt; (строку с девятью нулями), а затем обрезаю ее с помощью функции &lt;code&gt;substr()&lt;/code&gt; чтобы сделать ее точно равной девяти символам (заполняя нули справа).</target>
        </trans-unit>
        <trans-unit id="2b6553806f7c0f446906395a9393b4c8aa630b83" translate="yes" xml:space="preserve">
          <source>Ten million executions of this implementation take just 32.5 seconds, which is the fastest I've ever seen in a browser (the only solution without loops/iterations).</source>
          <target state="translated">Десять миллионов исполнений этой реализации занимают всего 32.5 секунды,что является самым быстрым из всех,что я когда-либо видел в браузере (единственное решение без циклов).</target>
        </trans-unit>
        <trans-unit id="863a161fb9b85e54a7fd55bdfa890d777c3ecfdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math.random()&lt;/code&gt; function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for
example &lt;code&gt;0.4363923368509859&lt;/code&gt;).</source>
          <target state="translated">Функция &lt;code&gt;Math.random()&lt;/code&gt; возвращает десятичное число от 0 до 1 с 16 цифрами после запятой после запятой (например, &lt;code&gt;0.4363923368509859&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="acf4bc33ac4b01c7fa998c17fe2ab66beb9bb5bc" translate="yes" xml:space="preserve">
          <source>The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.</source>
          <target state="translated">GUID UUID должен быть не менее 32 символов и должен оставаться в диапазоне ASCII,чтобы избежать проблем при их передаче.</target>
        </trans-unit>
        <trans-unit id="8d751df4e468da72f5959abfc1549c743c1e3ef6" translate="yes" xml:space="preserve">
          <source>The GUID is in the following format &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt;.</source>
          <target state="translated">GUID имеет следующий формат &lt;code&gt;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2541cbe64e15ab5d69eb08799c64ce9b1235e066" translate="yes" xml:space="preserve">
          <source>The above function should have a decent balance between speed and randomness.</source>
          <target state="translated">Вышеуказанная функция должна иметь приличный баланс между скоростью и случайностью.</target>
        </trans-unit>
        <trans-unit id="ee47e6da31b267bf2647229a714a454ce65b3891" translate="yes" xml:space="preserve">
          <source>The best way to generate them, is to follow implementation instructions in the said RFC, use one of the many community vetted open source implementations.</source>
          <target state="translated">Лучший способ сгенерировать их,это следовать инструкциям по реализации в упомянутом RFC,использовать одну из многих проверенных сообществом реализаций с открытым исходным кодом.</target>
        </trans-unit>
        <trans-unit id="66063bdfe4ff5bb41650a2179c29b0ae5581986f" translate="yes" xml:space="preserve">
          <source>The better way:</source>
          <target state="translated">Тем лучше:</target>
        </trans-unit>
        <trans-unit id="c6b5d62b3d2700a480f847f1f5fc03de421dbca1" translate="yes" xml:space="preserve">
          <source>The final optimization technique to apply - unroll the loop.  Since we're looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:</source>
          <target state="translated">Окончательная техника оптимизации-разворачивание цикла.Так как мы прокручиваем цикл фиксированное количество раз,мы можем технически все это выписать вручную.Однажды я попробовал это сделать с помощью одной случайной переменной r,которую я продолжал переприсваивать,и производительность упала.Но с четырьмя переменными,присваивающими случайные данные вперед,затем используя таблицу поиска и применяя соответствующие RFC-биты,эта версия курит их все:</target>
        </trans-unit>
        <trans-unit id="27e5e746f56f3da4623926ba36af11cf24511a47" translate="yes" xml:space="preserve">
          <source>The first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt; characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:</source>
          <target state="translated">Первый шаг к повышению производительности - исключить RegEx и его функции обратного вызова и использовать вместо этого простой цикл. Это означает, что мы должны иметь дело с символами &lt;code&gt;-&lt;/code&gt; и &lt;code&gt;4&lt;/code&gt; , тогда как брофа - нет. Также обратите внимание, что мы можем использовать индексирование String Array, чтобы сохранить его архитектуру шаблона String:</target>
        </trans-unit>
        <trans-unit id="1f91cea12f7bb764e0dde68e533cd0001d9f6c9a" translate="yes" xml:space="preserve">
          <source>The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).</source>
          <target state="translated">Первое,что нужно знать,это то,что вызовы функций стоят дорого,как и регулярные выражения (хотя он использует только 1,он имеет 32 обратных вызова,по одному на каждое совпадение,и в каждом из 32 обратных вызовов он вызывает Math.random()и v.toString(16)).</target>
        </trans-unit>
        <trans-unit id="5efd11cea6dbb2ca7d3856a6504baae9880ab778" translate="yes" xml:space="preserve">
          <source>The function is as simple as:</source>
          <target state="translated">Функция так же проста:</target>
        </trans-unit>
        <trans-unit id="237b687de13a23a564832cfd020006932e2b7094" translate="yes" xml:space="preserve">
          <source>The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it's most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.</source>
          <target state="translated">Забавно то,что генерация 16 байт случайных данных-это простая часть.Вся хитрость заключается в том,чтобы выразить это в формате String с соблюдением RFC,и это наиболее плотно выполняется с 16 байтами случайных данных,разворачивающимся циклом и поисковой таблицей.</target>
        </trans-unit>
        <trans-unit id="5fe390d75a55e87b91e0f2c344ccf52b0f992757" translate="yes" xml:space="preserve">
          <source>The next optimization is another classic.  Since we're only handling 4-bits of output in each loop iteration, let's cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it's not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.</source>
          <target state="translated">Следующая оптимизация-еще одна классика.Поскольку мы обрабатываем только 4 бита вывода в каждой итерации цикла,то сократим количество циклов пополам и будем обрабатывать по 8 бит в каждой итерации.Это сложно,так как нам все еще приходится обрабатывать битовые позиции,соответствующие RFC,но это не слишком сложно.Затем нам придется сделать большую таблицу поиска (16x16 или 256),чтобы хранить 0x00-0xff,и строить ее только один раз,вне функции e5().</target>
        </trans-unit>
        <trans-unit id="2c2a678ccb7c402e8bfa66c3bb0b047a01880eeb" translate="yes" xml:space="preserve">
          <source>The next step is a small one on the desktop but makes a decent difference on mobile.  Let's make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let's also move that template definition out of the loop, just in case it helps:</source>
          <target state="translated">Следующий шаг-маленький на рабочем столе,но приличный-на мобильном.Давайте сделаем меньше вызовов Math.random()и будем использовать все эти случайные биты вместо того,чтобы выбрасывать 87% из них со случайным буфером,который сдвигается при каждой итерации.Также перенесем определение шаблона из цикла,на всякий случай,если это поможет:</target>
        </trans-unit>
        <trans-unit id="475810532e8a0fcebdd7c79eff23716432a61245" translate="yes" xml:space="preserve">
          <source>The reason for adding exactly nine zeros is because of the worse case scenario, which is when the &lt;code&gt;Math.random()&lt;/code&gt; function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That's why we needed to add nine zeros to it (&lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; or &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt;), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.</source>
          <target state="translated">Причина добавления ровно девяти нулей кроется в худшем сценарии, когда &lt;code&gt;Math.random()&lt;/code&gt; будет возвращать ровно 0 или 1 (вероятность 1/10 ^ 16 для каждого из них). Вот почему нам нужно было добавить к нему девять нулей ( &lt;code&gt;&quot;0&quot;+&quot;000000000&quot;&lt;/code&gt; или &lt;code&gt;&quot;1&quot;+&quot;000000000&quot;&lt;/code&gt; ), а затем отрезать его от второго индекса (3-го символа) длиной восемь символов. В остальных случаях добавление нулей не повредит результату, потому что он все равно обрезает его.</target>
        </trans-unit>
        <trans-unit id="c79498301c475af77620127310a64ed51077604c" translate="yes" xml:space="preserve">
          <source>Then we cut off the &lt;code&gt;0.&lt;/code&gt; prefix (&lt;code&gt;0.6fb7687f&lt;/code&gt; =&amp;gt;
&lt;code&gt;6fb7687f&lt;/code&gt;) and get a string with eight hexadecimal
characters long.</source>
          <target state="translated">Затем мы &lt;code&gt;0.6fb7687f&lt;/code&gt; префикс &lt;code&gt;0.&lt;/code&gt; ( 0.6fb7687f =&amp;gt; &lt;code&gt;6fb7687f&lt;/code&gt; ) и получаем строку длиной восемь шестнадцатеричных символов.</target>
        </trans-unit>
        <trans-unit id="9c8cde2548b6605f69b7f5277aa0db7d69ca4dbc" translate="yes" xml:space="preserve">
          <source>Then we take this number and convert
it to a string with base 16 (from the example above we'll get
&lt;code&gt;0.6fb7687f&lt;/code&gt;).</source>
          <target state="translated">Затем мы берем это число и конвертируем его в строку с основанием 16 (из приведенного выше примера мы получим &lt;code&gt;0.6fb7687f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f896659fdb57404f3ca1c0dd540b6ea7e7493cc7" translate="yes" xml:space="preserve">
          <source>There are other methods that involve using an ActiveX control, but stay away from these!</source>
          <target state="translated">Существуют и другие методы,предполагающие использование ActiveX-контроля,но держитесь от них подальше!</target>
        </trans-unit>
        <trans-unit id="b6f314cd5d1632bbd12fce8c34bf0331b26c9531" translate="yes" xml:space="preserve">
          <source>There is a jQuery plugin that handles Guid's nicely @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</source>
          <target state="translated">Существует плагин jQuery, который прекрасно обрабатывает Guid @ &lt;a href=&quot;http://plugins.jquery.com/project/GUID_Helper&quot;&gt;http://plugins.jquery.com/project/GUID_Helper&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a114b1049ab77d7bb9cf82e5902a2fc8f9522f5b" translate="yes" xml:space="preserve">
          <source>This accomplishes the same goal as the &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;current highest-rated answer&lt;/a&gt;, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here's the annotated form of an older version of the function:</source>
          <target state="translated">Это позволяет достичь той же цели, что и &lt;a href=&quot;https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523&quot;&gt;текущий ответ с самым высоким рейтингом&lt;/a&gt; , но на 50+ меньше байтов, используя принуждение, рекурсию и экспоненциальную запись. Для тех, кому интересно, как это работает, вот аннотированная форма старой версии функции:</target>
        </trans-unit>
        <trans-unit id="c054a07bc3de1a2f3d45f3aab21e9af1ebf626bf" translate="yes" xml:space="preserve">
          <source>This create version 4 UUID (created from pseudo random numbers) :</source>
          <target state="translated">Это создает версию 4 UUID (созданную из псевдо-случайных чисел):</target>
        </trans-unit>
        <trans-unit id="58ce504b9f25064cbcb7de092b962c9e2dda22c0" translate="yes" xml:space="preserve">
          <source>This one is based on date, and add a random suffix to &quot;ensure&quot; uniqueness.
Works well for css identifiers.
It always returns something like and is easy to hack:</source>
          <target state="translated">Этот суффикс основан на дате и добавляет случайный суффикс для &quot;обеспечения&quot; уникальности.Хорошо работает для css-идентификаторов.Всегда возвращает что-то подобное и легко взламывается:</target>
        </trans-unit>
        <trans-unit id="c7a27f8c65115f387fec4d67fe32dab189f55a09" translate="yes" xml:space="preserve">
          <source>This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:</source>
          <target state="translated">Это экономит нам 10-30% в зависимости от платформы.Неплохо.Но следующий большой шаг избавляет от вызовов функции toString вместе с классической оптимизацией-таблицей поиска.Простая 16-элементная таблица поиска выполнит работу toString(16)за гораздо меньшее время:</target>
        </trans-unit>
        <trans-unit id="3e8bb274abfb2de0a2c13afefa3450f9f50f8d6e" translate="yes" xml:space="preserve">
          <source>To differ between these two types, I added a flag parameter to a pair creator function &lt;code&gt;_p8(s)&lt;/code&gt;, the &lt;code&gt;s&lt;/code&gt; parameter tells the function whether to add dashes or not.</source>
          <target state="translated">Чтобы различать эти два типа, я добавил параметр флага в функцию &lt;code&gt;_p8(s)&lt;/code&gt; пар _p8 (s) , &lt;code&gt;s&lt;/code&gt; параметр s сообщает функции, добавлять ли тире или нет.</target>
        </trans-unit>
        <trans-unit id="1c7c150202fdddceb6b1c221a05cdb4e4c1ce115" translate="yes" xml:space="preserve">
          <source>To test the performance, you can run this code:</source>
          <target state="translated">Чтобы проверить производительность,можно запустить этот код:</target>
        </trans-unit>
        <trans-unit id="fe1c1c9e7da2bc289fcd3379642172b845c1989a" translate="yes" xml:space="preserve">
          <source>UUID object allows a variety of access to the UUID including access to
  the UUID fields.</source>
          <target state="translated">Объект UUID обеспечивает разнообразный доступ к UUID,включая доступ к полям UUID.</target>
        </trans-unit>
        <trans-unit id="a3b6d33b0517d8c2933196e2f509432ec47c7b44" translate="yes" xml:space="preserve">
          <source>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt;, are identifiers with a certain uniqueness guarantee.</source>
          <target state="translated">UUID (универсальный уникальный идентификатор), также известный как GUID (глобальный уникальный идентификатор), согласно &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;RFC 4122&lt;/a&gt; , являются идентификаторами с определенной гарантией уникальности.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="670720d3ce8655613fb8e5107bd150a04eb2bb3d" translate="yes" xml:space="preserve">
          <source>Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs
  (time-based UUIDs) are available.</source>
          <target state="translated">Доступны UUID версии 4 (UUID от случайных чисел)и UUID версии 1 (UUID с привязкой к времени).</target>
        </trans-unit>
        <trans-unit id="3ebdce3a7ac7e93ecd1c5e84caaea7c1835d5f49" translate="yes" xml:space="preserve">
          <source>Want even smaller? Check this out: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</source>
          <target state="translated">Хотите еще меньше? Проверьте это: &lt;a href=&quot;https://gist.github.com/jed/982883&quot;&gt;https://gist.github.com/jed/982883&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a55040507e6337ca3e32ec7d20777fced2a290d7" translate="yes" xml:space="preserve">
          <source>Well, this has a bunch of answers already, but unfortunately there's not a &quot;true&quot; random in the bunch. The version below is an adaptation of broofa's answer, but updated to include a &quot;true&quot; random function that uses crypto libraries where available, and the Alea() function as a fallback.</source>
          <target state="translated">Ну,в этом уже есть куча ответов,но,к сожалению,в этой куче нет &quot;истинной&quot; случайности.Версия ниже является адаптацией ответа Брофы,но обновлена для включения &quot;истинной&quot; случайной функции,которая использует крипто-библиотеки там,где это доступно,и функции Alea()как запасной вариант.</target>
        </trans-unit>
        <trans-unit id="7dad31345c220d2cbe299045c03a52e22b20d937" translate="yes" xml:space="preserve">
          <source>Where the &lt;em&gt;M&lt;/em&gt; and &lt;em&gt;N&lt;/em&gt; positions may only have certain values. At this time, the only valid values for M are 1, 2, 3, 4 and 5, so randomly generating that position would make most results unacceptable.</source>
          <target state="translated">Где позиции &lt;em&gt;M&lt;/em&gt; и &lt;em&gt;N&lt;/em&gt; могут иметь только определенные значения. В настоящее время единственными допустимыми значениями для M являются 1, 2, 3, 4 и 5, поэтому случайная генерация этой позиции сделает большинство результатов неприемлемыми.</target>
        </trans-unit>
        <trans-unit id="0b33ee51f78c94d3fa3e3d46126b5b2de5f92677" translate="yes" xml:space="preserve">
          <source>Which will return something like &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt;.</source>
          <target state="translated">Который вернет что-то вроде &lt;code&gt;2350143528-4164020887-938913176-2513998651&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00947a234207676f6b4f448ed89af28aa686b86c" translate="yes" xml:space="preserve">
          <source>With such a web service, you could develop a REST web interface that consumes the GUID web service, and serves it through AJAX to javascript in a browser.</source>
          <target state="translated">С таким веб-сервисом можно было бы разработать REST веб-интерфейс,который потребляет GUID веб-сервис и обслуживает его через AJAX на javascript в браузере.</target>
        </trans-unit>
        <trans-unit id="d4fb620aaed70bd0d3e4873af0570771d0ed649d" translate="yes" xml:space="preserve">
          <source>You can increase this number by adding more digits, but to generate 100% unique ID's you will need to use a global counter.</source>
          <target state="translated">Вы можете увеличить это число,добавив больше цифр,но для генерации 100% уникальных идентификаторов вам потребуется использовать глобальный счетчик.</target>
        </trans-unit>
        <trans-unit id="ba59cf2f4053a03ebc1856c70811cb75b72d66b4" translate="yes" xml:space="preserve">
          <source>You can use node-uuid (&lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt;)</source>
          <target state="translated">Вы можете использовать node-uuid ( &lt;a href=&quot;https://github.com/kelektiv/node-uuid&quot;&gt;https://github.com/kelektiv/node-uuid&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="da5cce2c829e18ada2502aedf48c415870558171" translate="yes" xml:space="preserve">
          <source>broofa's answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!</source>
          <target state="translated">Ответ Брофы довольно хитрый,действительно-впечатляюще умный,действительно...rfc4122 совместимый,несколько читабельный и компактный.Потрясающе!</target>
        </trans-unit>
        <trans-unit id="5f37ba236f9a0c5e9361a753b0b9f82646c7f35a" translate="yes" xml:space="preserve">
          <source>if you need RFC compatibility, this formatting will pass as a valid version 4 GUID:</source>
          <target state="translated">если вам нужна RFC совместимость,это форматирование будет передано как действительный GUID версии 4:</target>
        </trans-unit>
        <trans-unit id="b32441e1af6b6c4e0de9080307ccfb43a3ea08b5" translate="yes" xml:space="preserve">
          <source>uid-139410573297741</source>
          <target state="translated">uid-139410573297741</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
