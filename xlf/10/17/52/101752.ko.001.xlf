<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/101752">
    <body>
      <group id="101752">
        <trans-unit id="02bf2147f49be0f82a17ad0a0d80e87267a2f579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MERGE_HEAD&lt;/code&gt; is present when a merge is in progress.</source>
          <target state="translated">병합이 진행 중일 때 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ecef8f87034314627bd1cbff708e130c1a7f2c8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git merge --abort&lt;/code&gt; is equivalent to &lt;code&gt;git reset --merge&lt;/code&gt; when
  &lt;code&gt;MERGE_HEAD&lt;/code&gt; is present.</source>
          <target state="translated">&lt;code&gt;git merge --abort&lt;/code&gt; 는 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 가있을 때 &lt;code&gt;git reset --merge&lt;/code&gt; --merge 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="284a0f707b5508c1419922a42fe50638c69c623b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset&lt;/code&gt; should do the equivalent of &lt;code&gt;svn revert&lt;/code&gt;, that is, discard your unwanted changes.</source>
          <target state="translated">&lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;svn revert&lt;/code&gt; 와 동등한 작업을 수행해야합니다. 즉, 원하지 않는 변경 사항은 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="e87048bc0d037c41ab6ae1f0375a015d0a6a963c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;.git\index.lock&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;.git\index.lock&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59156d56f3ee2cf8fe10ef54186e17dc320e3df2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sourcetree&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sourcetree&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df0f0090a24082d1353e139667cbd879cef89ee9" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct
  the pre-merge state.</source>
          <target state="translated">현재 충돌 해결 프로세스를 중단하고 병합 전 상태를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8c30b0197f322ac327dc1621d7ad9f56aaca47e9" translate="yes" xml:space="preserve">
          <source>After a failed merge, when there is no &lt;code&gt;MERGE_HEAD&lt;/code&gt;, the failed merge can be undone with &lt;code&gt;git reset --merge&lt;/code&gt;, but not necessarily with &lt;code&gt;git merge --abort&lt;/code&gt;. &lt;strong&gt;They are not only old and new syntax for the same thing&lt;/strong&gt;.</source>
          <target state="translated">실패한 병합 후 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 가 없으면 &lt;code&gt;git reset --merge&lt;/code&gt; --merge 를 사용하여 실패한 병합을 취소 할 수 있지만 반드시 &lt;code&gt;git merge --abort&lt;/code&gt; 를 사용 하지 않아도됩니다. &lt;strong&gt;그것들은 같은 것에 대한 구 구문과 새로운 구문 만이 아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="791fb8b21d51a3802fba1fa40b7239e498e590ab" translate="yes" xml:space="preserve">
          <source>Also, as @Michael Johnson mentions, if your git version is &amp;gt;= 1.7.4, you can also use &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">또한 @Michael Johnson이 언급했듯이 git 버전이&amp;gt; = 1.7.4이면 &lt;code&gt;git merge --abort&lt;/code&gt; 를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="10e3f9dc1bfd1fe88ec5ffb63ae62a9e25199a5b" translate="yes" xml:space="preserve">
          <source>Also, regarding uncommitted changes when starting a merge:</source>
          <target state="translated">또한 병합을 시작할 때 커밋되지 않은 변경 사항과 관련하여 :</target>
        </trans-unit>
        <trans-unit id="21d475caf7346dfbafa92d4d7ff7e6c3e0b21f4a" translate="yes" xml:space="preserve">
          <source>An alternative, which preserves the state of the working copy is:</source>
          <target state="translated">작업 복사본의 상태를 유지하는 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="712e1ef96c2bd52e8daeabd348d4d40e752f9cf3" translate="yes" xml:space="preserve">
          <source>As always, make sure you have no uncommitted changes before you start a merge.</source>
          <target state="translated">항상 그렇듯이 병합을 시작하기 전에 커밋되지 않은 변경 사항이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="517132e5238a7bbb5ebb8b3aecd7b22187b1e124" translate="yes" xml:space="preserve">
          <source>Because you not commit your merge, then just double click on another branch (which mean checkout it) and when sourcetree ask you about discarding all changes then agree :)</source>
          <target state="translated">병합을 커밋하지 않기 때문에 다른 브랜치를 두 번 클릭하면됩니다 (체크 아웃을 의미 함). 소스 트리에서 모든 변경 사항을 취소하는 것에 대해 묻는다면 동의하십시오.)</target>
        </trans-unit>
        <trans-unit id="6856177af5d074efd83139576b4a743e3354e6e3" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;git revert&lt;/code&gt; means something very different to, say, &lt;code&gt;svn revert&lt;/code&gt; - in Subversion the revert will discard your (uncommitted) changes, returning the file to the current version from the repository, whereas &lt;code&gt;git revert&lt;/code&gt; &quot;undoes&quot; a commit.</source>
          <target state="translated">&lt;code&gt;git revert&lt;/code&gt; 는 &lt;code&gt;svn revert&lt;/code&gt; 와 매우 다른 것을 의미합니다. Subversion에서 revert는 (커밋되지 않은) 변경 사항을 버리고 저장소에서 현재 버전으로 파일을 반환하는 반면 &lt;code&gt;git revert&lt;/code&gt; 는 커밋을 &quot;실행 취소&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="9d718f64dd39792294a0b1602f30d3f419b0db66" translate="yes" xml:space="preserve">
          <source>But this has since been removed, as explained in &lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;this message by Junio Hamano&lt;/a&gt; (the Git maintainer).  As noted in &lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;the link&lt;/a&gt;, instead you would do this:</source>
          <target state="translated">그러나 &lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;Junio ​​Hamano&lt;/a&gt; (Git 관리자) 가이 메시지 에서 설명한 대로이 기능 은 삭제되었습니다. &lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;링크&lt;/a&gt; 에서 언급했듯이 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8af8b6481056400c3f47cfe5e1b7e48a179e5514" translate="yes" xml:space="preserve">
          <source>Comments suggest that &lt;code&gt;git reset --merge&lt;/code&gt; is an alias for &lt;code&gt;git merge --abort&lt;/code&gt;. It is worth noticing that &lt;code&gt;git merge --abort&lt;/code&gt; is only equivalent to &lt;code&gt;git reset --merge&lt;/code&gt; given that a &lt;code&gt;MERGE_HEAD&lt;/code&gt; is present. This can be read in the git help for merge command.</source>
          <target state="translated">주석은 &lt;code&gt;git reset --merge&lt;/code&gt; &lt;code&gt;git merge --abort&lt;/code&gt; 가 git merge --abort 의 별칭이라고 제안합니다. &lt;code&gt;git merge --abort&lt;/code&gt; 는 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 가 존재하는 경우 &lt;code&gt;git reset --merge&lt;/code&gt; --merge 와 동일하다는 점에 주목할 가치 가 있습니다. 이것은 git help for merge 명령에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e9035b2a397e9705bd18a9bbd63a789d1459e36" translate="yes" xml:space="preserve">
          <source>File [cut paste to some other location in case of recovery] and then enter any of below command depending on which version you want.</source>
          <target state="translated">[복구시 다른 위치에 붙여 넣기 잘라 내기]를 선택한 다음 원하는 버전에 따라 아래 명령 중 하나를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="6162a78e6a90b00b5719d7e90b8593b6f0fe7353" translate="yes" xml:space="preserve">
          <source>For an unmerged file in a conflict git makes available the common base, local and remote versions of the file in the index. (This is where they are read from for use in a 3-way diff tool by &lt;code&gt;git mergetool&lt;/code&gt;.) You can use &lt;code&gt;git show&lt;/code&gt; to view them.</source>
          <target state="translated">충돌에서 병합되지 않은 파일의 경우 git은 색인에서 파일의 공통 기본, 로컬 및 원격 버전을 사용할 수있게합니다. &lt;code&gt;git mergetool&lt;/code&gt; 에 의해 3-way diff 도구에서 사용하기 위해 읽은 곳입니다. &lt;code&gt;git show&lt;/code&gt; 를 사용하여 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c30d0ff4f890495962cdea5521d118b0d1c16e" translate="yes" xml:space="preserve">
          <source>For scenario like, I did &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt;, then realized that upstream branch was not master branch, which resulted in unwanted conflicts.</source>
          <target state="translated">같은 시나리오에서 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 을 수행 한 다음 업스트림 브랜치가 마스터 브랜치가 아니므로 원치 않는 충돌이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="152d61ea299f8a95ffd8c070d5fd1ebe6ec651a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;git merge man page&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;git merge 맨 페이지에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fe4e4175fe2e48f2a0198f83b0274ede8a6bc38f" translate="yes" xml:space="preserve">
          <source>Git itself shows you the solution when you are in this type of trouble and run the git status command.</source>
          <target state="translated">Git 자체는 이러한 유형의 문제가 발생했을 때 솔루션을 보여주고 git status 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d24f776256db00dcd3875bf4049b55a993429d31" translate="yes" xml:space="preserve">
          <source>Hope that helps!!!</source>
          <target state="translated">희망이 도움이됩니다 !!!</target>
        </trans-unit>
        <trans-unit id="d19245bcbed4cfa8a6542877bf6c4347e22a9ebf" translate="yes" xml:space="preserve">
          <source>Hope this will help people.</source>
          <target state="translated">이것이 사람들을 도울 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="140247c3e0474069eaa356bb3b86594837cb4f0b" translate="yes" xml:space="preserve">
          <source>I found the following worked for me (revert a single file to pre-merge state):</source>
          <target state="translated">다음이 저에게 효과적이라는 것을 알았습니다 (단일 파일을 사전 병합 상태로 되돌리기).</target>
        </trans-unit>
        <trans-unit id="51de8ea84ac791d95b2ba99ea72abc343085651d" translate="yes" xml:space="preserve">
          <source>I generally advise against this, because it is effectively like merging in Subversion as it throws away the branch relationships in the following commit.</source>
          <target state="translated">필자는 일반적으로 다음 커밋에서 브랜치 관계를 버릴 때 Subversion에서 병합하는 것과 비슷하기 때문에 이것을 반대합니다.</target>
        </trans-unit>
        <trans-unit id="9174b79d94c70dc57d9e2d4ae0932fe7c0e37483" translate="yes" xml:space="preserve">
          <source>I know that the other version of the file is good and that mine is bad so all my changes should be abandoned. How can I do this?</source>
          <target state="translated">나는 파일의 다른 버전이 좋고 내 것이 나쁘다는 것을 알고 모든 변경 사항을 버려야합니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="1588f966e4811a83f9bedfeb0fceb34e605ba7d7" translate="yes" xml:space="preserve">
          <source>I ran into a merge conflict. How can I abort the merge</source>
          <target state="translated">병합 충돌이 발생했습니다. 병합을 중단하는 방법</target>
        </trans-unit>
        <trans-unit id="c825979616374dd915934597924a0aaa5f5637f7" translate="yes" xml:space="preserve">
          <source>I think it's &lt;code&gt;git reset&lt;/code&gt; you need.</source>
          <target state="translated">나는 그것이 &lt;code&gt;git reset&lt;/code&gt; 이라고 생각한다.</target>
        </trans-unit>
        <trans-unit id="61df000cfdc04e4a9db7b39a7bce3514385a9c8e" translate="yes" xml:space="preserve">
          <source>I used &lt;code&gt;git pull&lt;/code&gt; and had a merge conflict:</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 을 사용하고 병합 충돌이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="df726c65ada3d8014e213aa4ceb535292539e815" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge
  started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to
  reconstruct these changes. It is therefore recommended to always
  commit or stash your changes before running git merge.</source>
          <target state="translated">병합이 시작될 때 커밋되지 않은 작업 트리 변경이있는 경우 &lt;code&gt;git merge --abort&lt;/code&gt; 는 이러한 변경을 재구성 할 수없는 경우가 있습니다. 따라서 git merge를 실행하기 전에 항상 변경 사항을 커밋하거나 숨기는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="709ed61ed3d36eeac04045a5085be3e024e9706c" translate="yes" xml:space="preserve">
          <source>If you end up with merge conflict and doesn't have anything to commit, but still a merge error is being displayed. After applying all the below mentioned commands,</source>
          <target state="translated">병합 충돌로 끝나고 커밋 할 것이 없지만 여전히 병합 오류가 표시됩니다. 아래 언급 된 모든 명령을 적용한 후</target>
        </trans-unit>
        <trans-unit id="4e7c2ea3e42b3ee2935f64e0268799a6c6084059" translate="yes" xml:space="preserve">
          <source>If you have changes you don't want to commit before starting a merge, just &lt;code&gt;git stash&lt;/code&gt; them  before the merge and &lt;code&gt;git stash pop&lt;/code&gt; after finishing the merge or aborting it.</source>
          <target state="translated">병합을 시작하기 전에 커밋하지 않으려는 변경 사항이있는 경우 병합을 마치거나 중단 한 후 병합 및 &lt;code&gt;git stash pop&lt;/code&gt; 전에 변경 사항을 git stash 하십시오.</target>
        </trans-unit>
        <trans-unit id="4538bb07a0823cf18e35dba0b2a42e38d6e8137c" translate="yes" xml:space="preserve">
          <source>If your git version is &amp;gt;= 1.6.1, you can use &lt;code&gt;git reset --merge&lt;/code&gt;.</source>
          <target state="translated">git 버전이&amp;gt; = 1.6.1이면 &lt;code&gt;git reset --merge&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff60ef513e21845e9f61b33db2c5db7d630cc27" translate="yes" xml:space="preserve">
          <source>In this particular use case, you don't really want to abort the merge, just resolve the conflict in a particular way.</source>
          <target state="translated">이 특정 유스 케이스에서는 병합을 중단하고 싶지 않고 특정 방식으로 충돌을 해결하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a7b1165a98d22b34e8577ac1da1faa418a6971" translate="yes" xml:space="preserve">
          <source>Its so simple.</source>
          <target state="translated">너무 간단합니다.</target>
        </trans-unit>
        <trans-unit id="ad24a9cbfde531af2a5bab0a12512b5fb9520cf8" translate="yes" xml:space="preserve">
          <source>Older versions of git allowed you to use the &quot;theirs&quot; merge strategy:</source>
          <target state="translated">이전 버전의 git에서는 &quot;그들의&quot;병합 전략을 사용할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="506b2f062b32ae7c597d33e1474db6ab8de30b56" translate="yes" xml:space="preserve">
          <source>Or, with git &amp;gt;= 1.6.1:</source>
          <target state="translated">또는 git&amp;gt; = 1.6.1 인 경우 :</target>
        </trans-unit>
        <trans-unit id="e5693d1039874e81ca26a165144490fc9c80bb23" translate="yes" xml:space="preserve">
          <source>Personally, I find &lt;code&gt;git reset --merge&lt;/code&gt; much more powerful for scenarios similar to the described one, and failed merges in general.</source>
          <target state="translated">개인적으로, &lt;code&gt;git reset --merge&lt;/code&gt; 설명 된 것과 비슷한 시나리오에서 병합이 훨씬 강력하고 일반적으로 병합에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="1985998030bf657d21706a20543a7b89c6583a70" translate="yes" xml:space="preserve">
          <source>Please remove</source>
          <target state="translated">제거하십시오</target>
        </trans-unit>
        <trans-unit id="4b86fdbba1b8eda0d918103e45ed8516c5a7bcdc" translate="yes" xml:space="preserve">
          <source>Since Git 1.6.1.3 &lt;a href=&quot;http://git-scm.com/docs/git-checkout&quot;&gt;&lt;code&gt;git checkout&lt;/code&gt;&lt;/a&gt; has been able to checkout from either side of a merge:</source>
          <target state="translated">Git 1.6.1.3부터 &lt;a href=&quot;http://git-scm.com/docs/git-checkout&quot;&gt; &lt;code&gt;git checkout&lt;/code&gt; &lt;/a&gt; 은 병합의 어느 쪽에서 나 체크 아웃 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="0590754c25162153993addb51d2d41624a9b3617" translate="yes" xml:space="preserve">
          <source>Since your &lt;code&gt;pull&lt;/code&gt; was unsuccessful then &lt;code&gt;HEAD&lt;/code&gt; (not &lt;code&gt;HEAD^&lt;/code&gt;) is the last &quot;valid&quot; commit on your branch:</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 실패했기 때문에 HEAD ( &lt;code&gt;HEAD^&lt;/code&gt; 아님)는 브랜치에서 마지막으로 &quot;유효한&quot;커밋입니다.</target>
        </trans-unit>
        <trans-unit id="e023525efe3b907ee6060ad13ad488f7f489541f" translate="yes" xml:space="preserve">
          <source>The other piece you want is to let their changes over-ride your changes.</source>
          <target state="translated">원하는 다른 것은 변경 사항이 변경 사항보다 우선하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36acba7173a71b452ad5b6cb475a79fab96d3e5a" translate="yes" xml:space="preserve">
          <source>The simplest way to resolve the conflict to use the remote version verbatim is:</source>
          <target state="translated">원격 버전을 그대로 사용하기 위해 충돌을 해결하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47ca8db790a0d74e76056cd45b2f85f55c9394c8" translate="yes" xml:space="preserve">
          <source>There is no particular need to reset and perform a merge with a different strategy, either. The conflicts have been correctly highlighted by git and the requirement to accept the other sides changes is only for this one file.</source>
          <target state="translated">다른 전략으로 병합을 재설정하고 수행 할 필요가 없습니다. 충돌은 git에 의해 올바르게 강조 표시되었으며 다른 측면 변경 사항을 수락 해야하는 요구 사항은이 파일에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="26625700ba33f98c435e1e5283ad998c9e568291" translate="yes" xml:space="preserve">
          <source>This reverted back without resetting my local changes.</source>
          <target state="translated">로컬 변경 사항을 재설정하지 않고 되돌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="52c5a965d0a6ef20f8231b4355c016a7d4ac2374" translate="yes" xml:space="preserve">
          <source>git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present.</source>
          <target state="translated">git merge --abort는 MERGE_HEAD가있을 때 git reset --merge와 같습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
