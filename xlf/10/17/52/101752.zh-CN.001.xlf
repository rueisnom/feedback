<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/101752">
    <body>
      <group id="101752">
        <trans-unit id="02bf2147f49be0f82a17ad0a0d80e87267a2f579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MERGE_HEAD&lt;/code&gt; is present when a merge is in progress.</source>
          <target state="translated">合并正在进行时，出现 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecef8f87034314627bd1cbff708e130c1a7f2c8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git merge --abort&lt;/code&gt; is equivalent to &lt;code&gt;git reset --merge&lt;/code&gt; when
  &lt;code&gt;MERGE_HEAD&lt;/code&gt; is present.</source>
          <target state="translated">当存在 &lt;code&gt;git reset --merge&lt;/code&gt; 时， &lt;code&gt;git merge --abort&lt;/code&gt; 等效于git reset --merge 。</target>
        </trans-unit>
        <trans-unit id="284a0f707b5508c1419922a42fe50638c69c623b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset&lt;/code&gt; should do the equivalent of &lt;code&gt;svn revert&lt;/code&gt;, that is, discard your unwanted changes.</source>
          <target state="translated">&lt;code&gt;git reset&lt;/code&gt; 应该等效于 &lt;code&gt;svn revert&lt;/code&gt; ，也就是说，丢弃不需要的更改。</target>
        </trans-unit>
        <trans-unit id="e87048bc0d037c41ab6ae1f0375a015d0a6a963c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;.git\index.lock&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;.git\index.lock&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59156d56f3ee2cf8fe10ef54186e17dc320e3df2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sourcetree&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sourcetree&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df0f0090a24082d1353e139667cbd879cef89ee9" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct
  the pre-merge state.</source>
          <target state="translated">中止当前的冲突解决进程,并尝试重构合并前的状态。</target>
        </trans-unit>
        <trans-unit id="8c30b0197f322ac327dc1621d7ad9f56aaca47e9" translate="yes" xml:space="preserve">
          <source>After a failed merge, when there is no &lt;code&gt;MERGE_HEAD&lt;/code&gt;, the failed merge can be undone with &lt;code&gt;git reset --merge&lt;/code&gt;, but not necessarily with &lt;code&gt;git merge --abort&lt;/code&gt;. &lt;strong&gt;They are not only old and new syntax for the same thing&lt;/strong&gt;.</source>
          <target state="translated">合并失败后，如果没有 &lt;code&gt;MERGE_HEAD&lt;/code&gt; ，则可以使用 &lt;code&gt;git reset --merge&lt;/code&gt; 撤消失败的合并，但不一定要使用 &lt;code&gt;git merge --abort&lt;/code&gt; 撤消 。 &lt;strong&gt;它们不仅是同一事物的新旧语法&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="791fb8b21d51a3802fba1fa40b7239e498e590ab" translate="yes" xml:space="preserve">
          <source>Also, as @Michael Johnson mentions, if your git version is &amp;gt;= 1.7.4, you can also use &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">另外，就像@Michael Johnson提到的那样，如果您的git版本&amp;gt; = 1.7.4，您还可以使用 &lt;code&gt;git merge --abort&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10e3f9dc1bfd1fe88ec5ffb63ae62a9e25199a5b" translate="yes" xml:space="preserve">
          <source>Also, regarding uncommitted changes when starting a merge:</source>
          <target state="translated">另外,关于开始合并时的非承诺变更。</target>
        </trans-unit>
        <trans-unit id="21d475caf7346dfbafa92d4d7ff7e6c3e0b21f4a" translate="yes" xml:space="preserve">
          <source>An alternative, which preserves the state of the working copy is:</source>
          <target state="translated">保留工作副本状态的另一种方法是:</target>
        </trans-unit>
        <trans-unit id="712e1ef96c2bd52e8daeabd348d4d40e752f9cf3" translate="yes" xml:space="preserve">
          <source>As always, make sure you have no uncommitted changes before you start a merge.</source>
          <target state="translated">一如既往,在你开始合并之前,确保你没有未承诺的改动。</target>
        </trans-unit>
        <trans-unit id="517132e5238a7bbb5ebb8b3aecd7b22187b1e124" translate="yes" xml:space="preserve">
          <source>Because you not commit your merge, then just double click on another branch (which mean checkout it) and when sourcetree ask you about discarding all changes then agree :)</source>
          <target state="translated">因为你不提交你的合并,那么你只需双击另一个分支(这意味着选中它),当sourcetree问你是否要丢弃所有的修改,然后同意:)</target>
        </trans-unit>
        <trans-unit id="6856177af5d074efd83139576b4a743e3354e6e3" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;git revert&lt;/code&gt; means something very different to, say, &lt;code&gt;svn revert&lt;/code&gt; - in Subversion the revert will discard your (uncommitted) changes, returning the file to the current version from the repository, whereas &lt;code&gt;git revert&lt;/code&gt; &quot;undoes&quot; a commit.</source>
          <target state="translated">注意 &lt;code&gt;git revert&lt;/code&gt; 与 &lt;code&gt;svn revert&lt;/code&gt; revert的含义非常不同-在Subversion中，revert将丢弃您（未提交的）更改，将文件从存储库返回到当前版本，而 &lt;code&gt;git revert&lt;/code&gt; &amp;ldquo;撤消&amp;rdquo;提交。</target>
        </trans-unit>
        <trans-unit id="9d718f64dd39792294a0b1602f30d3f419b0db66" translate="yes" xml:space="preserve">
          <source>But this has since been removed, as explained in &lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;this message by Junio Hamano&lt;/a&gt; (the Git maintainer).  As noted in &lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;the link&lt;/a&gt;, instead you would do this:</source>
          <target state="translated">但这已被删除，正如&lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;Junio Hamano&lt;/a&gt; （Git维护者）在此消息中所解释的。 如&lt;a href=&quot;http://marc.info/?l=git&amp;amp;m=121637513604413&amp;amp;w=2&quot;&gt;链接&lt;/a&gt;中所述 ，您可以这样做：</target>
        </trans-unit>
        <trans-unit id="8af8b6481056400c3f47cfe5e1b7e48a179e5514" translate="yes" xml:space="preserve">
          <source>Comments suggest that &lt;code&gt;git reset --merge&lt;/code&gt; is an alias for &lt;code&gt;git merge --abort&lt;/code&gt;. It is worth noticing that &lt;code&gt;git merge --abort&lt;/code&gt; is only equivalent to &lt;code&gt;git reset --merge&lt;/code&gt; given that a &lt;code&gt;MERGE_HEAD&lt;/code&gt; is present. This can be read in the git help for merge command.</source>
          <target state="translated">注释建议 &lt;code&gt;git reset --merge&lt;/code&gt; 是 &lt;code&gt;git merge --abort&lt;/code&gt; 的别名。 值得注意的是，由于存在 &lt;code&gt;git merge --abort&lt;/code&gt; ，因此git merge --abort仅等效于 &lt;code&gt;git reset --merge&lt;/code&gt; 。 可以在git help for merge命令中阅读。</target>
        </trans-unit>
        <trans-unit id="1e9035b2a397e9705bd18a9bbd63a789d1459e36" translate="yes" xml:space="preserve">
          <source>File [cut paste to some other location in case of recovery] and then enter any of below command depending on which version you want.</source>
          <target state="translated">文件[在恢复的情况下剪切粘贴到其他位置],然后根据你想要的版本,输入以下任何一个命令。</target>
        </trans-unit>
        <trans-unit id="6162a78e6a90b00b5719d7e90b8593b6f0fe7353" translate="yes" xml:space="preserve">
          <source>For an unmerged file in a conflict git makes available the common base, local and remote versions of the file in the index. (This is where they are read from for use in a 3-way diff tool by &lt;code&gt;git mergetool&lt;/code&gt;.) You can use &lt;code&gt;git show&lt;/code&gt; to view them.</source>
          <target state="translated">对于冲突中的未合并文件，git会在索引中提供文件的通用基本版本，本地版本和远程版本。 （这是 &lt;code&gt;git mergetool&lt;/code&gt; 从三向差异工具中读取它们的地方。）您可以使用 &lt;code&gt;git show&lt;/code&gt; 来查看它们。</target>
        </trans-unit>
        <trans-unit id="70c30d0ff4f890495962cdea5521d118b0d1c16e" translate="yes" xml:space="preserve">
          <source>For scenario like, I did &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt;, then realized that upstream branch was not master branch, which resulted in unwanted conflicts.</source>
          <target state="translated">对于类似的情况，我做了 &lt;code&gt;git fetch&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; ，然后意识到上游分支不是master分支，这导致了不必要的冲突。</target>
        </trans-unit>
        <trans-unit id="152d61ea299f8a95ffd8c070d5fd1ebe6ec651a5" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;git merge man page&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-merge.html&quot;&gt;git merge手册页&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fe4e4175fe2e48f2a0198f83b0274ede8a6bc38f" translate="yes" xml:space="preserve">
          <source>Git itself shows you the solution when you are in this type of trouble and run the git status command.</source>
          <target state="translated">当你遇到这类问题时,运行git状态命令,Git本身就会告诉你解决方案。</target>
        </trans-unit>
        <trans-unit id="d24f776256db00dcd3875bf4049b55a993429d31" translate="yes" xml:space="preserve">
          <source>Hope that helps!!!</source>
          <target state="translated">希望对你有帮助!</target>
        </trans-unit>
        <trans-unit id="d19245bcbed4cfa8a6542877bf6c4347e22a9ebf" translate="yes" xml:space="preserve">
          <source>Hope this will help people.</source>
          <target state="translated">希望对大家有所帮助。</target>
        </trans-unit>
        <trans-unit id="140247c3e0474069eaa356bb3b86594837cb4f0b" translate="yes" xml:space="preserve">
          <source>I found the following worked for me (revert a single file to pre-merge state):</source>
          <target state="translated">我发现下面的方法对我有效(将单个文件恢复到合并前的状态)。</target>
        </trans-unit>
        <trans-unit id="51de8ea84ac791d95b2ba99ea72abc343085651d" translate="yes" xml:space="preserve">
          <source>I generally advise against this, because it is effectively like merging in Subversion as it throws away the branch relationships in the following commit.</source>
          <target state="translated">我一般建议不要这样做,因为这实际上就像Subversion中的合并一样,因为它把下面的提交中的分支关系扔掉了。</target>
        </trans-unit>
        <trans-unit id="9174b79d94c70dc57d9e2d4ae0932fe7c0e37483" translate="yes" xml:space="preserve">
          <source>I know that the other version of the file is good and that mine is bad so all my changes should be abandoned. How can I do this?</source>
          <target state="translated">我知道其他版本的文件是好的,我的是坏的,所以我所有的修改都应该放弃。我该怎么做呢?</target>
        </trans-unit>
        <trans-unit id="1588f966e4811a83f9bedfeb0fceb34e605ba7d7" translate="yes" xml:space="preserve">
          <source>I ran into a merge conflict. How can I abort the merge</source>
          <target state="translated">我遇到了一个合并冲突。我如何才能中止合并?</target>
        </trans-unit>
        <trans-unit id="c825979616374dd915934597924a0aaa5f5637f7" translate="yes" xml:space="preserve">
          <source>I think it's &lt;code&gt;git reset&lt;/code&gt; you need.</source>
          <target state="translated">我认为这是您需要的 &lt;code&gt;git reset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61df000cfdc04e4a9db7b39a7bce3514385a9c8e" translate="yes" xml:space="preserve">
          <source>I used &lt;code&gt;git pull&lt;/code&gt; and had a merge conflict:</source>
          <target state="translated">我使用 &lt;code&gt;git pull&lt;/code&gt; 并发生合并冲突：</target>
        </trans-unit>
        <trans-unit id="df726c65ada3d8014e213aa4ceb535292539e815" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge
  started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to
  reconstruct these changes. It is therefore recommended to always
  commit or stash your changes before running git merge.</source>
          <target state="translated">如果合并开始时存在未提交的工作树更改，则 &lt;code&gt;git merge --abort&lt;/code&gt; 在某些情况下将无法重构这些更改。 因此，建议始终在运行git merge之前提交或存储更改。</target>
        </trans-unit>
        <trans-unit id="709ed61ed3d36eeac04045a5085be3e024e9706c" translate="yes" xml:space="preserve">
          <source>If you end up with merge conflict and doesn't have anything to commit, but still a merge error is being displayed. After applying all the below mentioned commands,</source>
          <target state="translated">如果最终合并冲突,并没有什么要提交的东西,但仍然显示合并错误。在应用了下面提到的所有命令后。</target>
        </trans-unit>
        <trans-unit id="4e7c2ea3e42b3ee2935f64e0268799a6c6084059" translate="yes" xml:space="preserve">
          <source>If you have changes you don't want to commit before starting a merge, just &lt;code&gt;git stash&lt;/code&gt; them  before the merge and &lt;code&gt;git stash pop&lt;/code&gt; after finishing the merge or aborting it.</source>
          <target state="translated">如果您有更改，不想在开始合并之前提交，只需在合并之前 &lt;code&gt;git stash&lt;/code&gt; 它们，在合并或中止之后 &lt;code&gt;git stash pop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4538bb07a0823cf18e35dba0b2a42e38d6e8137c" translate="yes" xml:space="preserve">
          <source>If your git version is &amp;gt;= 1.6.1, you can use &lt;code&gt;git reset --merge&lt;/code&gt;.</source>
          <target state="translated">如果您的git版本&amp;gt; = 1.6.1，则可以使用 &lt;code&gt;git reset --merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ff60ef513e21845e9f61b33db2c5db7d630cc27" translate="yes" xml:space="preserve">
          <source>In this particular use case, you don't really want to abort the merge, just resolve the conflict in a particular way.</source>
          <target state="translated">在这个特殊的用例中,你并不是真的想中止合并,只是以特定的方式解决冲突。</target>
        </trans-unit>
        <trans-unit id="f5a7b1165a98d22b34e8577ac1da1faa418a6971" translate="yes" xml:space="preserve">
          <source>Its so simple.</source>
          <target state="translated">它是如此的简单。</target>
        </trans-unit>
        <trans-unit id="ad24a9cbfde531af2a5bab0a12512b5fb9520cf8" translate="yes" xml:space="preserve">
          <source>Older versions of git allowed you to use the &quot;theirs&quot; merge strategy:</source>
          <target state="translated">旧版本的git允许你使用 &quot;他们的 &quot;合并策略。</target>
        </trans-unit>
        <trans-unit id="506b2f062b32ae7c597d33e1474db6ab8de30b56" translate="yes" xml:space="preserve">
          <source>Or, with git &amp;gt;= 1.6.1:</source>
          <target state="translated">或者，使用git&amp;gt; = 1.6.1：</target>
        </trans-unit>
        <trans-unit id="e5693d1039874e81ca26a165144490fc9c80bb23" translate="yes" xml:space="preserve">
          <source>Personally, I find &lt;code&gt;git reset --merge&lt;/code&gt; much more powerful for scenarios similar to the described one, and failed merges in general.</source>
          <target state="translated">就个人而言，我发现 &lt;code&gt;git reset --merge&lt;/code&gt; 在与上述情况类似的情况下合并功能更为强大，而且合并通常会失败。</target>
        </trans-unit>
        <trans-unit id="1985998030bf657d21706a20543a7b89c6583a70" translate="yes" xml:space="preserve">
          <source>Please remove</source>
          <target state="translated">请删除</target>
        </trans-unit>
        <trans-unit id="4b86fdbba1b8eda0d918103e45ed8516c5a7bcdc" translate="yes" xml:space="preserve">
          <source>Since Git 1.6.1.3 &lt;a href=&quot;http://git-scm.com/docs/git-checkout&quot;&gt;&lt;code&gt;git checkout&lt;/code&gt;&lt;/a&gt; has been able to checkout from either side of a merge:</source>
          <target state="translated">从Git 1.6.1.3开始， &lt;a href=&quot;http://git-scm.com/docs/git-checkout&quot;&gt; &lt;code&gt;git checkout&lt;/code&gt; &lt;/a&gt;可以从合并的任何一侧进行检出：</target>
        </trans-unit>
        <trans-unit id="0590754c25162153993addb51d2d41624a9b3617" translate="yes" xml:space="preserve">
          <source>Since your &lt;code&gt;pull&lt;/code&gt; was unsuccessful then &lt;code&gt;HEAD&lt;/code&gt; (not &lt;code&gt;HEAD^&lt;/code&gt;) is the last &quot;valid&quot; commit on your branch:</source>
          <target state="translated">由于您的 &lt;code&gt;pull&lt;/code&gt; 失败，所以 &lt;code&gt;HEAD&lt;/code&gt; （不是 &lt;code&gt;HEAD^&lt;/code&gt; ）是分支上的最后一个&amp;ldquo;有效&amp;rdquo;提交：</target>
        </trans-unit>
        <trans-unit id="e023525efe3b907ee6060ad13ad488f7f489541f" translate="yes" xml:space="preserve">
          <source>The other piece you want is to let their changes over-ride your changes.</source>
          <target state="translated">你想要的另一块,就是让他们的变化凌驾于你的变化之上。</target>
        </trans-unit>
        <trans-unit id="36acba7173a71b452ad5b6cb475a79fab96d3e5a" translate="yes" xml:space="preserve">
          <source>The simplest way to resolve the conflict to use the remote version verbatim is:</source>
          <target state="translated">解决冲突的最简单的方法是,使用远程版逐字记录。</target>
        </trans-unit>
        <trans-unit id="47ca8db790a0d74e76056cd45b2f85f55c9394c8" translate="yes" xml:space="preserve">
          <source>There is no particular need to reset and perform a merge with a different strategy, either. The conflicts have been correctly highlighted by git and the requirement to accept the other sides changes is only for this one file.</source>
          <target state="translated">也没有特别需要重新设置,用不同的策略进行合并。git已经正确地强调了冲突,并且要求接受对方的修改只针对这一个文件。</target>
        </trans-unit>
        <trans-unit id="26625700ba33f98c435e1e5283ad998c9e568291" translate="yes" xml:space="preserve">
          <source>This reverted back without resetting my local changes.</source>
          <target state="translated">这在没有重置我的本地更改的情况下就恢复了。</target>
        </trans-unit>
        <trans-unit id="52c5a965d0a6ef20f8231b4355c016a7d4ac2374" translate="yes" xml:space="preserve">
          <source>git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present.</source>
          <target state="translated">git merge ---abort相当于git reset --merge_HEAD存在时,git merge。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
