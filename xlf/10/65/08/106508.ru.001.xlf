<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/106508">
    <body>
      <group id="106508">
        <trans-unit id="af2e8e09e40e9f539ab8da751affb13a10ba4eec" translate="yes" xml:space="preserve">
          <source>... the pointer shouldn't actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.</source>
          <target state="translated">...указатель не должен на самом деле владеть данными,т.е.когда вы просто используете данные,но хотите,чтобы он выжил в той функции,в которой вы на него ссылаетесь.</target>
        </trans-unit>
        <trans-unit id="c4744e75c09f437c395d9d10e5ca53018fc22030" translate="yes" xml:space="preserve">
          <source>... the smart pointer isn't itself going to be destroyed at some point. You don't want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won't be explicitly deleted).</source>
          <target state="translated">...умная указка сама по себе в какой-то момент не будет уничтожена.Вы же не хотите,чтобы он сидел в памяти,которая никогда не будет уничтожена (например,в объекте,который динамически выделяется,но не будет явно удален).</target>
        </trans-unit>
        <trans-unit id="7abe7f7009507b420472f008cf135a3361a38a02" translate="yes" xml:space="preserve">
          <source>... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counting&lt;/a&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... два умных указателя могут указывать на одни и те же данные. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Есть, однако, даже более умные указатели, которые справятся с этим ... это называется &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;подсчетом ссылок&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b3456d375c6b7456d5c4bc19041b1f3e7159035" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Raw pointers&lt;/strong&gt; :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сырые указатели&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c05ec50cd607baeca2e3d1f218f43eaa3fe20dc" translate="yes" xml:space="preserve">
          <source>3) &lt;strong&gt;Smart Pointers&lt;/strong&gt; : { &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; }</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Умные указатели&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : { &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; }&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5a0658a851943e0a2cbffdefa181eb111a1072c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;garbage collection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сборка мусора&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4b51566876fb4532e007f30a397e20ccf5f7b334" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;Resource Acquisition Is Initialization&lt;/a&gt; (This is frequently used for exception-safe resource management in C++)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Получение ресурсов - это инициализация&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (это часто используется для безопасного управления ресурсами в C ++)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29e3f25d900a39e1908f817e7b69b107c13bb24c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;Smart pointer&lt;/a&gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Интеллектуальный указатель&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это тип, похожий на указатель, с некоторыми дополнительными функциями, например, автоматическое освобождение памяти, подсчет ссылок и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f616381ac60ee4dc0c8941b5d68506530ee64337" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;This stack overflow question&lt;/a&gt; regarding data ownership</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот вопрос переполнения стека&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; относительно владения данными&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1867be1ad1af5dc650167a8cf0efa432ce165e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is another reference counting pointer. It provides better performance than &lt;code&gt;shared_ptr&lt;/code&gt;, but requires the type &lt;code&gt;T&lt;/code&gt; to provide its own reference counting mechanism.</source>
          <target state="translated">&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - еще один указатель подсчета ссылок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он обеспечивает лучшую производительность, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но требует, чтобы тип &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предоставил свой собственный механизм подсчета ссылок.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0d5f87331c2eecb842ccaae6c19f1a55d8ea413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;scoped_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; подобен &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scoped_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но для массивов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4022aeb6f81b4906c6ab25a8ce758c7901bdd9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.</source>
          <target state="translated">&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - указатель, автоматически удаляемый, когда он выходит из области видимости. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Назначение невозможно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b3ae49c2084013ca2cd8045ab6949f88e0a1056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;shared_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; подобен &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но для массивов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70c670daab27ba020ed4b3008ffa5f7e50646ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer to &lt;code&gt;T&lt;/code&gt; using a reference count to determine when the object is no longer needed.</source>
          <target state="translated">&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - указатель на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; использующий счетчик ссылок, чтобы определить, когда объект больше не нужен.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85b44869045deedea760f2af227ba51e6ab34649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&lt;/code&gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be &quot;passed across DLL boundaries&quot; (the common nightmare case if different &lt;code&gt;libc&lt;/code&gt;s are used between your code and the DLLs).</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; очень универсален и имеет дело с большим разнообразием сценариев утилизации, включая случаи, когда объекты должны быть &amp;laquo;переданы через границы DLL&amp;raquo; (распространенный кошмарный случай, если &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;между вашим кодом и DLL используются &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;разные &lt;/font&gt;&lt;/font&gt; &lt;code&gt;libc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aaed4c81152732868d9d49d18694435ce025dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; s полезны, когда вы хотите связать время жизни объекта с конкретным блоком кода или если вы встраивали его как данные члена в другой объект, время жизни этого другого объекта. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Объект существует до тех пор, пока не будет завершен содержащий блок кода или пока сам содержащий объект не будет уничтожен.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35295afc323a8764cefd17b5bdc018ac29b84a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a weak pointer, working in conjunction with &lt;code&gt;shared_ptr&lt;/code&gt; to avoid circular references.</source>
          <target state="translated">&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - слабый указатель, работающий совместно с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы избежать циклических ссылок.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef33adbf278b78fced043861257bfe060e159b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But which smart pointer should I use in which of those cases?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но какой умный указатель я должен использовать в каких случаях?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e761a3027e25048706976b6db69a52b4e01b467d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey, I didn't ask which one to use!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эй, я не спрашивал, какой использовать!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bfc5096d48f06748da1555aa92cde89f2a6341c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It was deprecated in C++11 and removed in C++17&lt;/strong&gt;, so you shouldn't use it.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это устарело в C ++ 11 и удалено в C ++ 17&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , поэтому вы не должны его использовать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05d6ce56a57f8c848f648042c5448f4a8a610d89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OLD ANSWER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;СТАРЫЙ ОТВЕТ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d1e940c49d65579e31f8af44e892beff4f142c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shared Pointer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Общий указатель&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="005e906d718b91c7b79edf678d3c0fc87b1f5349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So when should I use regular pointers then?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так когда же мне использовать обычные указатели?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971abf8af0ed9ddec060bfca3124cf49cd8504de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique Pointer :&lt;/strong&gt; 
    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Уникальный указатель:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; легкий вес умный указатель с исключительным владением. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используется, когда указатель указывает на уникальные объекты, не разделяя объекты между указателями.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46c311c3b22afb68eb5ae8c85ce8bb5d73bc761f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Weak Pointer :&lt;/strong&gt; 
    Helps deal with cyclic reference which arises when using Shared Pointer
    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Weak Pointer:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Помогает справиться с циклической ссылкой, которая возникает при использовании Shared Pointer. Если у вас есть два объекта, на которые указывают два общих указателя, и есть внутренний общий указатель, указывающий на общий указатель каждого другого, тогда будет циклическая ссылка, и объект не будет быть удаленным, когда общие указатели выходят из области видимости. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы решить эту проблему, измените внутренний член с shared_ptr на weak_ptr. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание. Чтобы получить доступ к элементу, на который указывает слабый указатель, используйте lock (), это возвращает слабый_птр.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3b0f949d4345488039e4183458ea4810d7099f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a smart pointer?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что такое умный указатель?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6468525fccb4ecf5e47ed8487dee96a37bf52f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should I use one?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда я должен использовать один?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="660849bfef63c2647882bdc5da8447c8dc6b51e5" translate="yes" xml:space="preserve">
          <source>A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; will not work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Постоянный указатель на постоянный тип данных T. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что вы не можете ни переместить указатель, ни изменить указатель типа данных на указатель. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то есть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не будет работать&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="408b455a6c631e6b53e0f1209d0361f9b950a58c" translate="yes" xml:space="preserve">
          <source>A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie &lt;code&gt;*ptr2 = 19&lt;/code&gt; will work but &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; etc will not work. Read backwards : const pointer to a type T</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Постоянный указатель на тип данных T. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что вы не можете перемещать указатель, но вы можете изменить значение, на которое указывает указатель. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то есть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr2 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет работать, но &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; т.д. не будут работать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Читайте в обратном направлении: постоянный указатель на тип T&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0895997fb22fe8c3fbe3470dd02611de7817af76" translate="yes" xml:space="preserve">
          <source>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last &quot;reference&quot; to the object is destroyed, the object is deleted. This policy is implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Более сложная политика интеллектуальных указателей включает подсчет ссылок указателя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это позволяет копировать указатель. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда последняя &amp;laquo;ссылка&amp;raquo; на объект уничтожается, объект удаляется. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта политика реализуется с помощью &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85cc9f1d1b7b72b303b1a6932cad97df1a8bf8af" translate="yes" xml:space="preserve">
          <source>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</source>
          <target state="translated">Умный указатель путем сравнения определяет политику относительно того,когда объект будет уничтожен.Вам все равно придется создавать объект,но больше не нужно беспокоиться об его уничтожении.</target>
        </trans-unit>
        <trans-unit id="5a8ed7f449dc88e468a305cb01873d71c0dda80a" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</source>
          <target state="translated">Умный указатель-это класс,который обёртывает указатель 'raw' (или 'bare')C++,чтобы управлять временем жизни указываемого объекта.Единого умного типа указателя нет,но все они пытаются абстрагироваться от сырого указателя практическим способом.</target>
        </trans-unit>
        <trans-unit id="c2cc5504b9d575fdc1765bc51e43e4e44d93de47" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart point&amp;rsquo;s life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Умный указатель - это класс, оболочка обычного указателя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В отличие от обычных указателей, жизненный цикл интеллектуальной точки основан на подсчете ссылок (сколько раз назначается объект интеллектуального указателя). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому, когда умный указатель назначается другому, счетчик внутренних ссылок плюс плюс. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И всякий раз, когда объект выходит из области видимости, счетчик ссылок минус минус.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9356d827d5b266f397c77242a36f9ee76af46143" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.</source>
          <target state="translated">Умный указатель-это объект,который действует как указатель,но дополнительно обеспечивает контроль над строительством,разрушением,копированием,перемещением и разыменованием.</target>
        </trans-unit>
        <trans-unit id="150ff3c7e30d567459ce409ef2d43cf92945b361" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don't respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.</source>
          <target state="translated">Умный указатель-это объект,который действует,выглядит и чувствует себя как обычный указатель,но предлагает больше функциональности.В С++умные указатели реализованы в виде шаблонных классов,которые инкапсулируют указатель и переопределяют стандартные операторы указателей.Они имеют ряд преимуществ перед обычными указателями.Они гарантированно инициализируются либо как нулевой указатель,либо как указатель на объект кучи.Проверяется инициализация через нулевой указатель.Удаление никогда не требуется.Объекты автоматически освобождаются,когда исчезает последний указатель на них.Одна из существенных проблем с этими умными указателями заключается в том,что в отличие от обычных указателей,они не уважают наследование.Умные указатели непривлекательны для полиморфного кода.Ниже приведен пример реализации умных указателей.</target>
        </trans-unit>
        <trans-unit id="b68b6f3a8975f96f1b6b93c4634bedb35aff4ddb" translate="yes" xml:space="preserve">
          <source>A smart pointer is like a regular (typed) pointer, like &quot;char*&quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using &quot;-&amp;gt;&quot;, but not if you need an actual pointer to the data. For that, you can use &quot;&amp;amp;*ptr&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Интеллектуальный указатель похож на обычный (типизированный) указатель, например &amp;laquo;char *&amp;raquo;, за исключением случаев, когда сам указатель выходит из области видимости, тогда то, на что он указывает, также удаляется. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать его, как обычный указатель, используя &amp;laquo;-&amp;gt;&amp;raquo;, но не тогда, когда вам нужен фактический указатель на данные. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для этого вы можете использовать &amp;laquo;&amp;amp; * ptr&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1471a71c5e4eb0de52fc485e12e309fb87dc2eee" translate="yes" xml:space="preserve">
          <source>Additionally, the C++ standard library provides three smart pointers; &lt;code&gt;std::unique_ptr&lt;/code&gt; for unique ownership, &lt;code&gt;std::shared_ptr&lt;/code&gt; for shared ownership and &lt;code&gt;std::weak_ptr&lt;/code&gt;. &lt;code&gt;std::auto_ptr&lt;/code&gt; existed in C++03 but is now deprecated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, стандартная библиотека C ++ предоставляет три умных указателя; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для уникального владельца, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для общего владения и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; существовал в C ++ 03, но теперь устарел.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f173ba927487f1d4cb291eff83de845b351faeb8" translate="yes" xml:space="preserve">
          <source>Ah, but you really wanted to, admit it.</source>
          <target state="translated">Ах,но ты действительно хотел,признай это.</target>
        </trans-unit>
        <trans-unit id="fe19f580daa87cc25b870e1baa16fab7e5c59b15" translate="yes" xml:space="preserve">
          <source>Among other things (explained well in other answers) using a smart pointer is a possible solution to &lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;How do we use a abstract class as a function return type?&lt;/a&gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is &quot;what do you really mean?&quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;boost pointer container library&lt;/a&gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don't give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a &lt;em&gt;value&lt;/em&gt; to some form of &lt;em&gt;reference&lt;/em&gt;. If you really needed copy you may need to add more boilerplate &quot;idiom&quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like &lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;Adobe Poly&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;Boost.TypeErasure&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Среди прочего (хорошо объяснено в других ответах) использование умного указателя является возможным решением вопроса. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как использовать абстрактный класс в качестве возвращаемого типа функции?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который был отмечен как дубликат этого вопроса. Тем не менее, первый вопрос, который нужно задать, если возникает желание указать абстрактный (или фактически любой) базовый класс в качестве возвращаемого типа в C ++, это &amp;laquo;что вы на самом деле имеете в виду?&amp;raquo;. В документации &lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;библиотеки контейнера указателей надстроек&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; есть хорошее обсуждение (с дальнейшими ссылками) идиоматического объектно-ориентированного программирования на C ++ (и как оно отличается от других языков).&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, в C ++ вы должны думать о собственности. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Какие умные указатели помогают вам, но не являются единственным решением или всегда полным решением (они не дают вам полиморфную копию) и не всегда являются решением, которое вы хотите показать в своем интерфейсе (а возвращаемая функция звучит ужасно очень похоже на интерфейс). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, может быть достаточно вернуть ссылку. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но во всех этих случаях (умный указатель, контейнер указателя или просто возвращение ссылки) вы изменили возвращаемое &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;значение&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с какой-либо формы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ссылки&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вам действительно нужна копия, вам может потребоваться добавить больше шаблонной &amp;laquo;идиомы&amp;raquo; или перейти от идиоматического (или иного) ООП в C ++ к более общему полиморфизму с использованием таких библиотек, как &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adobe Poly&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost.TypeErasure.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78ca5dca4761808a7b5e7382ebf5f698b2cd2fd" translate="yes" xml:space="preserve">
          <source>Another convenient type is &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другим удобным типом является &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который реализует подсчет ссылок и автоматически освобождает память, когда не остается ссылок на объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это помогает избежать утечек памяти и прост в использовании для реализации &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RAII&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf3a668061d4ad283ac2fa86679b6f3b0791cf93" translate="yes" xml:space="preserve">
          <source>Another possibility is creating circular references:</source>
          <target state="translated">Другая возможность-создание круговых ссылок:</target>
        </trans-unit>
        <trans-unit id="64f289d2f4648dd5b3726612c027f5c92f4a2aaa" translate="yes" xml:space="preserve">
          <source>Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).</source>
          <target state="translated">Автоматическая указка,хотя и выглядит похоже,полностью отличается от умной указки.Это удобный класс,который занимается распределением ресурса всякий раз,когда объект автоматического указателя выходит из области видимости переменной.В какой-то степени он заставляет указатель (на динамически выделяемую память)работать подобно переменной стека (статически выделяемой во время компиляции).</target>
        </trans-unit>
        <trans-unit id="0a8c0f929f31db86af22e061262a8478f89bf858" translate="yes" xml:space="preserve">
          <source>Concurrent Counter Access</source>
          <target state="translated">Одновременный доступ к счетчику</target>
        </trans-unit>
        <trans-unit id="e6bf77b4e6823d55153852cfedb73269bb8fdd72" translate="yes" xml:space="preserve">
          <source>Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).</source>
          <target state="translated">Данные членов классов,так что при удалении объекта удаляются и все данные,находящиеся в его собственности,без какого-либо специального кода в деструкторе (нужно быть уверенным,что деструктор виртуальный,что почти всегда хорошо).</target>
        </trans-unit>
        <trans-unit id="d315ffe38f74e2bbd3649007ed92bd0fcb339294" translate="yes" xml:space="preserve">
          <source>Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:
A smart pointer is simply a class that overloads the &lt;code&gt;-&amp;gt;&lt;/code&gt;  and &lt;code&gt;*&lt;/code&gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.
&lt;code&gt;shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Определения, предоставленные Крисом, Сергдевом и Ллёдом, верны. Я предпочитаю более простое определение, просто чтобы сохранить мою жизнь простой: умный указатель - это просто класс, который перегружает &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;операторы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Это означает, что ваш объект семантически выглядит как указатель, но вы можете сделать так, чтобы он делал более крутые вещи, в том числе подсчет ссылок, автоматическое уничтожение и т. Д. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в большинстве случаев достаточны, но приходят со своим собственным набором небольших идиосинкразий.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17a6e952cfd054bf86a0bff2ef3758ccb138822a" translate="yes" xml:space="preserve">
          <source>Destruction and Deallocation</source>
          <target state="translated">Уничтожение и смещение</target>
        </trans-unit>
        <trans-unit id="62c819d637d29a2f4f19cf04f89b693e7e7a7ca3" translate="yes" xml:space="preserve">
          <source>Don't use the &lt;code&gt;boost::&lt;/code&gt; smart pointers or &lt;code&gt;std::auto_ptr&lt;/code&gt; except in special cases which you can read up on if you must.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не используйте &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;указатели &lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; smart или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; за исключением особых случаев, о которых вы можете прочитать, если нужно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f3d3aad5c807bb24d88407fd715dd4bcadc4a87" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; provides the following smart pointer implementations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предоставляет следующие реализации интеллектуальных указателей:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6213441eda5b33d29bac7b15eafcedc34217804c" translate="yes" xml:space="preserve">
          <source>Here is the Link for similar answers : &lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот ссылка для похожих ответов: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="235448e1559e2c6a2d98c037e982857e78ec5708" translate="yes" xml:space="preserve">
          <source>Here's a simple answer for these days of modern C++:</source>
          <target state="translated">Вот простой ответ на современный С++:</target>
        </trans-unit>
        <trans-unit id="8a930b4fb10a4df4e7af642f22172143cf9dfa25" translate="yes" xml:space="preserve">
          <source>Holder Limitations</source>
          <target state="translated">Ограничения держателя</target>
        </trans-unit>
        <trans-unit id="db3373933d2b26d58bd3267b9cb9ff92de1de43a" translate="yes" xml:space="preserve">
          <source>Holders, (note, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt; is implementation of such type of smart pointer)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Holders, (заметьте, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: auto_ptr&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - реализация такого типа умного указателя)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8efc2fcb0e64352073d01410371f9b29588ff6a8" translate="yes" xml:space="preserve">
          <source>Implemented using reference counting to keep track of how many &quot; things &quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. 
This gets rid of the headache of having to delete objects which you have allocated using new.</source>
          <target state="translated">Реализовано с помощью подсчета ссылок,чтобы отслеживать,сколько &quot;вещей&quot; указывают на объект,на который указывает указатель.Когда этот подсчет становится равным 0,объект автоматически удаляется,т.е.объект удаляется,когда весь share_ptr,на который указывает на объект,выходит за пределы области видимости.Это избавляет от головной боли,связанной с необходимостью удалять объекты,которые вы выделили,используя new.</target>
        </trans-unit>
        <trans-unit id="c1d841b0ff2602990af565bd1846dd9e8eba0720" translate="yes" xml:space="preserve">
          <source>In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.</source>
          <target state="translated">В коде,который подразумевает отслеживание права собственности на фрагмент памяти,выделение или деблокирование,умный указатель часто избавляет вас от необходимости делать эти вещи явно.</target>
        </trans-unit>
        <trans-unit id="8d2ab2c7ea1b9e3dd5c0238fa3501e1a6f018af5" translate="yes" xml:space="preserve">
          <source>In computer science, a smart pointer
  is an abstract data type that
  simulates a pointer while providing
  additional features, such as automatic
  garbage collection or bounds checking.
  These additional features are intended
  to reduce bugs caused by the misuse of
  pointers while retaining efficiency.
  Smart pointers typically keep track of
  the objects that point to them for the
  purpose of memory management. The
  misuse of pointers is a major source
  of bugs: the constant allocation,
  deallocation and referencing that must
  be performed by a program written
  using pointers makes it very likely
  that some memory leaks will occur.
  Smart pointers try to prevent memory
  leaks by making the resource
  deallocation automatic: when the
  pointer to an object (or the last in a
  series of pointers) is destroyed, for
  example because it goes out of scope,
  the pointed object is destroyed too.</source>
          <target state="translated">В компьютерной науке &quot;умный указатель&quot;-это абстрактный тип данных,который симулирует указатель,обеспечивая при этом дополнительные возможности,такие как автоматический сбор мусора или проверка границ.Эти дополнительные функции предназначены для уменьшения количества ошибок,вызванных неправильным использованием указателей,при сохранении эффективности.Умные указатели обычно отслеживают объекты,которые на них указывают,в целях управления памятью.Неправильное использование указателей является основным источником ошибок:постоянное выделение,распределение и ссылки,которые должны выполняться программой,написанной с использованием указателей,делают весьма вероятным возникновение утечек памяти.Умные указатели пытаются предотвратить утечку памяти,делая автоматическое перераспределение ресурсов:когда указатель на объект (или последний из серии указателей)уничтожается,например,из-за того,что он выходит за рамки видимости,то и указанный объект тоже уничтожается.</target>
        </trans-unit>
        <trans-unit id="b470b0b9a364b2fa432c27c2e23748d4f2eeebfb" translate="yes" xml:space="preserve">
          <source>It is useful for:</source>
          <target state="translated">Это полезно:</target>
        </trans-unit>
        <trans-unit id="269dd3751517ddfbd50cdb4301abe2ab83b607fc" translate="yes" xml:space="preserve">
          <source>It's a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also &lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;the more detailed definition on Wikipedia&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это тип, значения которого могут использоваться как указатели, но который предоставляет дополнительную функцию автоматического управления памятью: когда интеллектуальный указатель больше не используется, память, на которую он указывает, освобождается (см. Также &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;более подробное определение в Википедии&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1508c0dbd75f276250ef468cde22c1eb920a2bdb" translate="yes" xml:space="preserve">
          <source>Let T be a class in this tutorial 
Pointers in C++ can be divided into 3 types :</source>
          <target state="translated">Пусть T будет классом в этом учебнике Указатели в C++можно разделить на 3 типа :</target>
        </trans-unit>
        <trans-unit id="b792a21ee56ff623795e7a57d358d84ec527459b" translate="yes" xml:space="preserve">
          <source>Like other overloaded operators, p will behave like a regular pointer,</source>
          <target state="translated">Как и другие перегруженные операторы,p будет вести себя как обычный указатель,</target>
        </trans-unit>
        <trans-unit id="455cc282d56455c6f5333fab2462998a571616cc" translate="yes" xml:space="preserve">
          <source>Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.</source>
          <target state="translated">Большинство видов умных указателей управляют утилизацией указателя на объект для вас.Это очень удобно,потому что вам больше не нужно думать о том,чтобы избавиться от объектов вручную.</target>
        </trans-unit>
        <trans-unit id="7314c02622627b7ccb9b4f584bc913fff6ad6735" translate="yes" xml:space="preserve">
          <source>Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.</source>
          <target state="translated">В основном в коде,забывающем о владении памятью.Как правило,это происходит в функциях,которые получают указатель откуда-то еще,не выделяют и не выделяют,а также не хранят копию указателя,которая длится дольше их исполнения.</target>
        </trans-unit>
        <trans-unit id="26e6d181ff99160909b595478121f08dd076edb4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::unique_ptr&lt;/code&gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;экземпляры &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не могут быть скопированы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это предотвращает многократное удаление указателя (неправильно). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако вы можете передавать ссылки на него другим функциям, которые вы вызываете.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc55faaac98b84550c0f52f207b38f5a9b210b5d" translate="yes" xml:space="preserve">
          <source>Objects that must be allocated with new, but that you'd like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.</source>
          <target state="translated">Объекты,которые должны быть распределены с новыми,но которые вы хотели бы иметь такую же продолжительность жизни,как и что-то в этом стеке.Если объект назначен &quot;умному&quot; указателю,то они будут удалены при выходе программы из этого функционального блока.</target>
        </trans-unit>
        <trans-unit id="f751c9fbb24aa2c23e6e65e987bb3d5bb9f738ce" translate="yes" xml:space="preserve">
          <source>One can implement one's own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.</source>
          <target state="translated">Можно реализовать свой собственный &quot;умный&quot; указатель,но многие библиотеки также предоставляют реализации &quot;умных&quot; указателей,каждая из которых имеет свои преимущества и недостатки.</target>
        </trans-unit>
        <trans-unit id="87b543505cd555c6851c754dbaa29544fec9d8de" translate="yes" xml:space="preserve">
          <source>One of the simple smart-pointer type is &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt; (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Одним из простых типов интеллектуальных указателей является &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (глава 20.4.5 стандарта C ++), который позволяет автоматически освобождать память, когда она выходит из области видимости, и является более надежным, чем использование простого указателя при возникновении исключений, хотя и менее гибкий.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deac6c8d86314111051ac297a8e90d729d2fc59e" translate="yes" xml:space="preserve">
          <source>Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie &lt;code&gt;*ptr1 = 19&lt;/code&gt; ; will not work. But you can move the pointer. ie &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; ;  etc will work.
Read backwards : pointer to type T which is const</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Указатель на тип данных T, который является константой. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что вы не можете изменить тип данных с помощью указателя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;т.е. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr1 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не будет работать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но вы можете перемещать указатель. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то есть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и т. д. будет работать. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Читать назад: указатель на тип T, который является постоянным&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5091a6ac607a66d605572c2f1f01fdeddfb5810" translate="yes" xml:space="preserve">
          <source>Pointers with const data or address { Read backwards }</source>
          <target state="translated">Указатели с константными данными или адресом{Чтение в обратном направлении }</target>
        </trans-unit>
        <trans-unit id="3c274408a7815b4769a808e5cd01a86c5b3930d3" translate="yes" xml:space="preserve">
          <source>Protecting Against Exceptions</source>
          <target state="translated">Защита от исключений</target>
        </trans-unit>
        <trans-unit id="cc6e672ee6612bec71630926ee21e523510d4fc4" translate="yes" xml:space="preserve">
          <source>Reference : 
&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/a&gt; 
Thanks to Andre for pointing out this question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылка: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Спасибо Андре за то, что он указал на этот вопрос.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4d88eed28dd1376cc40fd170b9bfe77d1d02da0" translate="yes" xml:space="preserve">
          <source>Reference Counting</source>
          <target state="translated">Справочный подсчет</target>
        </trans-unit>
        <trans-unit id="7fd5474cfc1ade935cc5c546e88ea9b67e4d64c6" translate="yes" xml:space="preserve">
          <source>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</source>
          <target state="translated">Счетчики ссылок очень полезны,когда время жизни вашего объекта намного сложнее и не привязано непосредственно к конкретному участку кода или к другому объекту.</target>
        </trans-unit>
        <trans-unit id="08784d3c2d27ac259ff9d07cfc06917a9d5a0f38" translate="yes" xml:space="preserve">
          <source>References : 
    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.</source>
          <target state="translated">Ссылки:В сущности,они могут рассматриваться как указатели const,т.е.как указатель,который является const и не может быть перемещен с лучшим синтаксисом.</target>
        </trans-unit>
        <trans-unit id="4bed4ff02087a38f1b95579b7416fac0a1027a61" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;When is std::weak_ptr useful?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смотрите: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда полезен std :: weak_ptr?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5251271034126a1a5c2548bc2290d5d6cd1e15d8" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;What are the differences between a pointer variable and a reference variable in C++?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смотрите: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каковы различия между переменной-указателем и ссылочной переменной в C ++?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="06b60eabd9ac929a849b1c545034616a52874ae8" translate="yes" xml:space="preserve">
          <source>Small intro is available on page &lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;Smart Pointers - What, Why, Which?&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Небольшое вступление доступно на странице &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Smart Pointers - Что, Почему, Что? &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eddd0ee6c00b8b7b07f4aa1533cf74d53674f39b" translate="yes" xml:space="preserve">
          <source>Smart Pointers are those where you don't have to worry about Memory De-Allocation, Resource Sharing and Transfer.</source>
          <target state="translated">Умные указатели-это те,где вам не нужно беспокоиться о де-локации памяти,совместном использовании и переносе ресурсов.</target>
        </trans-unit>
        <trans-unit id="04467054ec546b1c0315c4cfac233385593e4375" translate="yes" xml:space="preserve">
          <source>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you &lt;em&gt;really&lt;/em&gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Умные указатели должны быть предпочтительнее сырых указателей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы чувствуете, что вам нужно использовать указатели (сначала подумайте, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;действительно&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ли вы &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; делаете), вы, как правило, захотите использовать умный указатель, поскольку это может облегчить многие проблемы с необработанными указателями, в основном забывая удалить объект и потеряв память.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e25c6c59bcb6d66abe3c35be9cc4fddb4b2b9bca" translate="yes" xml:space="preserve">
          <source>Subject is covered in depth in book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&quot;C++ Templates: The Complete Guide&quot; by David Vandevoorde, Nicolai M. Josuttis&lt;/a&gt;, chapter Chapter 20. Smart Pointers.
Some topics covered:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тема подробно освещена в книге &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Дэвида Вандевурда &amp;laquo;Шаблоны C ++: Полное руководство&amp;raquo;, Николая М. Хосуттиса&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , глава 20 &amp;laquo;Умные указатели&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Некоторые темы:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1de633672e7627dbf70739243d0b87a6dc17bb" translate="yes" xml:space="preserve">
          <source>The existing answers are good but don't cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.</source>
          <target state="translated">Существующие ответы хороши,но не охватывают того,что делать,когда умный указатель не является (полным)ответом на проблему,которую вы пытаетесь решить.</target>
        </trans-unit>
        <trans-unit id="b06ceb1cd65ed156e62d8ecd9eab78c66e613029" translate="yes" xml:space="preserve">
          <source>The most commonly-used smart pointers are &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; (or &lt;code&gt;boost::shared_ptr&lt;/code&gt;), and, less commonly, &lt;code&gt;std::auto_ptr&lt;/code&gt;. I recommend regular use of &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Наиболее часто используемые интеллектуальные указатели - это &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) и, реже, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я рекомендую регулярное использование &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97b533d7bfbeb88b5d7616af5826194991855a7f" translate="yes" xml:space="preserve">
          <source>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt;&lt;code&gt;boost::scoped_ptr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Простейшая используемая политика включает в себя область действия объекта-оболочки интеллектуального указателя, например, реализованную с помощью &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt; &lt;code&gt;boost::scoped_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d47eb61584acb71b110726e0b95e16a13f3cc6" translate="yes" xml:space="preserve">
          <source>There is one drawback to reference counted pointers &amp;mdash; the possibility of creating a dangling reference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У указателей с подсчетом ссылок есть один недостаток - возможность создания зависшей ссылки:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7cf9d335ee541a055c37f36657dc1e6a480c449d" translate="yes" xml:space="preserve">
          <source>There was also &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt;. It was very much like a scoped pointer, except that it also had the &quot;special&quot; dangerous ability to be copied &amp;mdash; which also unexpectedly transfers ownership.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Был также &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это было очень похоже на указатель в области видимости, за исключением того, что он также имел &amp;laquo;особую&amp;raquo; опасную способность для копирования, которая также неожиданно передает право собственности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10dc26ca1fd5731e91d37edb3bbff8ef030a4f4" translate="yes" xml:space="preserve">
          <source>These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.</source>
          <target state="translated">Это всего лишь одно линейное описание каждого из них и может быть использовано по мере необходимости,для более подробной информации и примеров можно посмотреть в документации Boost.</target>
        </trans-unit>
        <trans-unit id="074f5297a4fba1ef7bfeb2429c1ef13d61bea37b" translate="yes" xml:space="preserve">
          <source>They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track.</source>
          <target state="translated">Они хранят адрес памяти в ячейке в памяти.Используйте их с осторожностью,так как программы становятся сложными для отслеживания.</target>
        </trans-unit>
        <trans-unit id="9432b51535de91f29d61abdc8f193678d301d5bc" translate="yes" xml:space="preserve">
          <source>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот ответ довольно старый, и поэтому описывает то, что было &amp;laquo;хорошо&amp;raquo; в то время, то есть умные указатели, предоставляемые библиотекой Boost. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Начиная с C ++ 11, стандартная библиотека предоставляла достаточное количество умных указателей типов, поэтому вы должны отдавать предпочтение использованию &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3fd31e33e7e71dba6afa758f5ddaa23fd6413cc" translate="yes" xml:space="preserve">
          <source>This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:</source>
          <target state="translated">Данный класс реализует умный указатель на объект типа X.Сам объект расположен на куче.Вот как его использовать:</target>
        </trans-unit>
        <trans-unit id="c3acb92908f60dd2ddfb231908946d7977340ae6" translate="yes" xml:space="preserve">
          <source>To change the object pointed to by the unique ptr , use move semantics</source>
          <target state="translated">Чтобы изменить объект,на который указывает уникальный ptr,используйте семантику перемещения</target>
        </trans-unit>
        <trans-unit id="80ec759771be05f92f85c7d934d53b16a77673fa" translate="yes" xml:space="preserve">
          <source>To work around this problem, both Boost and C++11 have defined a &lt;code&gt;weak_ptr&lt;/code&gt; to define a weak (uncounted) reference to a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы обойти эту проблему, и Boost, и C ++ 11 определили &lt;/font&gt;&lt;/font&gt; &lt;code&gt;weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для определения слабой (несчетной) ссылки на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18f22cb2e33fe36506262132cc985d5cd594ea3d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда вы хотите ссылаться на ваш объект из нескольких мест - и не хотите, чтобы ваш объект был перераспределен, пока все эти ссылки сами не исчезнут.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d62e1c7ca9f6bac0498ed49f33b2dd9b90497ae4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt; when you don't intend to hold multiple references to the same object. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если вы не собираетесь хранить несколько ссылок на один и тот же объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, используйте его для указателя на память, которая выделяется при входе в какую-либо область и освобождается при выходе из области.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89b90755704062fcad6a5106c9e29a719bef4c5e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate (so they'll just note the object is gone when you try to dereference).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда вы хотите обратиться к своему объекту из нескольких мест - для тех ссылок, для которых нормально игнорировать и освобождать (так что они просто заметят, что объект пропал при попытке разыменования).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bb07c28eb795708a8cc90a338886a7431582ee9" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one</source>
          <target state="translated">Что такое умная указка,и когда я должен ее использовать.</target>
        </trans-unit>
        <trans-unit id="8d779c02f29f56174f222fe34fb2a12b36815ca5" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one?</source>
          <target state="translated">Что такое умный указатель и когда его использовать?</target>
        </trans-unit>
        <trans-unit id="72dca932f0f35f4b1af9967ff79dc06b4b558df6" translate="yes" xml:space="preserve">
          <source>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</source>
          <target state="translated">При использовании сырых указателей,программист вынужден явно уничтожать объект,когда он перестает быть полезным.</target>
        </trans-unit>
        <trans-unit id="7c8bd33fd1a098972b52263748dc1191e62414cf" translate="yes" xml:space="preserve">
          <source>You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.</source>
          <target state="translated">Вы можете очень хорошо использовать эти указатели так же,как любое распределение работает на Java.В java мусорщик делает трюк,в то время как в Smart Pointers трюк выполняется Деструкторами.</target>
        </trans-unit>
        <trans-unit id="a60c5ae076041d7c822b45b7033064048db8f570" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;not&lt;/em&gt; want to use a smart pointer when:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; использовать умный указатель, когда:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
