<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/106508">
    <body>
      <group id="106508">
        <trans-unit id="af2e8e09e40e9f539ab8da751affb13a10ba4eec" translate="yes" xml:space="preserve">
          <source>... the pointer shouldn't actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.</source>
          <target state="translated">...el puntero no debería ser el dueño de los datos......es decir,cuando sólo estás usando los datos,pero quieres que sobrevivan a la función donde los estás referenciando.</target>
        </trans-unit>
        <trans-unit id="c4744e75c09f437c395d9d10e5ca53018fc22030" translate="yes" xml:space="preserve">
          <source>... the smart pointer isn't itself going to be destroyed at some point. You don't want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won't be explicitly deleted).</source>
          <target state="translated">...el puntero inteligente no se va a destruir en algún momento.No quieres que se quede en la memoria que nunca se destruye (como en un objeto que se asigna dinámicamente pero que no se borrará explícitamente).</target>
        </trans-unit>
        <trans-unit id="7abe7f7009507b420472f008cf135a3361a38a02" translate="yes" xml:space="preserve">
          <source>... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counting&lt;/a&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... dos punteros inteligentes pueden apuntar a los mismos datos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Sin embargo, hay punteros incluso m&amp;aacute;s inteligentes que manejar&amp;aacute;n eso ... eso se llama &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;conteo de referencias&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b3456d375c6b7456d5c4bc19041b1f3e7159035" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Raw pointers&lt;/strong&gt; :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Punteros crudos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c05ec50cd607baeca2e3d1f218f43eaa3fe20dc" translate="yes" xml:space="preserve">
          <source>3) &lt;strong&gt;Smart Pointers&lt;/strong&gt; : { &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; }</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Punteros inteligentes&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : { &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; }&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5a0658a851943e0a2cbffdefa181eb111a1072c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;garbage collection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la recolecci&amp;oacute;n de basura&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4b51566876fb4532e007f30a397e20ccf5f7b334" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;Resource Acquisition Is Initialization&lt;/a&gt; (This is frequently used for exception-safe resource management in C++)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La adquisici&amp;oacute;n de recursos es la inicializaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (esto se usa con frecuencia para la administraci&amp;oacute;n de recursos segura con excepci&amp;oacute;n en C ++)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29e3f25d900a39e1908f817e7b69b107c13bb24c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;Smart pointer&lt;/a&gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El puntero inteligente&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un tipo de puntero con alguna funcionalidad adicional, por ejemplo, desasignaci&amp;oacute;n autom&amp;aacute;tica de memoria, recuento de referencias, etc.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f616381ac60ee4dc0c8941b5d68506530ee64337" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;This stack overflow question&lt;/a&gt; regarding data ownership</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta pregunta de desbordamiento de pila con&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; respecto a la propiedad de datos&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1867be1ad1af5dc650167a8cf0efa432ce165e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is another reference counting pointer. It provides better performance than &lt;code&gt;shared_ptr&lt;/code&gt;, but requires the type &lt;code&gt;T&lt;/code&gt; to provide its own reference counting mechanism.</source>
          <target state="translated">&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es otro puntero de recuento de referencias. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Proporciona un mejor rendimiento que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero requiere que el tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; proporcione su propio mecanismo de recuento de referencias.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0d5f87331c2eecb842ccaae6c19f1a55d8ea413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;scoped_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scoped_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero para las matrices de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4022aeb6f81b4906c6ab25a8ce758c7901bdd9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.</source>
          <target state="translated">&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un puntero que se elimina autom&amp;aacute;ticamente cuando sale del alcance. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ninguna asignaci&amp;oacute;n es posible.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b3ae49c2084013ca2cd8045ab6949f88e0a1056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;shared_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero para las matrices de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70c670daab27ba020ed4b3008ffa5f7e50646ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer to &lt;code&gt;T&lt;/code&gt; using a reference count to determine when the object is no longer needed.</source>
          <target state="translated">&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un puntero a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; que&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; utiliza un recuento de referencia para determinar cu&amp;aacute;ndo ya no se necesita el objeto.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85b44869045deedea760f2af227ba51e6ab34649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&lt;/code&gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be &quot;passed across DLL boundaries&quot; (the common nightmare case if different &lt;code&gt;libc&lt;/code&gt;s are used between your code and the DLLs).</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es muy vers&amp;aacute;til y se ocupa de una gran variedad de escenarios de eliminaci&amp;oacute;n, incluidos los casos en los que los objetos deben &quot;pasar a trav&amp;eacute;s de los l&amp;iacute;mites de la DLL&quot; (el caso com&amp;uacute;n de pesadilla si &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se utilizan &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;diferentes &lt;/font&gt;&lt;/font&gt; &lt;code&gt;libc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; entre su c&amp;oacute;digo y las DLL).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aaed4c81152732868d9d49d18694435ce025dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; s son &amp;uacute;tiles cuando desea vincular la vida &amp;uacute;til del objeto a un bloque de c&amp;oacute;digo en particular, o si lo incrusta como datos miembro dentro de otro objeto, la vida &amp;uacute;til de ese otro objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El objeto existe hasta que se sale del bloque de c&amp;oacute;digo que lo contiene, o hasta que el objeto que lo contiene se destruye.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35295afc323a8764cefd17b5bdc018ac29b84a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a weak pointer, working in conjunction with &lt;code&gt;shared_ptr&lt;/code&gt; to avoid circular references.</source>
          <target state="translated">&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un puntero d&amp;eacute;bil, que funciona junto con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para evitar referencias circulares.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef33adbf278b78fced043861257bfe060e159b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But which smart pointer should I use in which of those cases?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero, &amp;iquest;qu&amp;eacute; puntero inteligente debo usar en cu&amp;aacute;l de esos casos?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e761a3027e25048706976b6db69a52b4e01b467d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey, I didn't ask which one to use!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl;Hey, no pregunt&amp;eacute; cu&amp;aacute;l usar!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bfc5096d48f06748da1555aa92cde89f2a6341c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It was deprecated in C++11 and removed in C++17&lt;/strong&gt;, so you shouldn't use it.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fue desaprobado en C ++ 11 y eliminado en C ++ 17&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo que no debe usarlo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05d6ce56a57f8c848f648042c5448f4a8a610d89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OLD ANSWER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ANTIGUA RESPUESTA&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d1e940c49d65579e31f8af44e892beff4f142c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shared Pointer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puntero compartido&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="005e906d718b91c7b79edf678d3c0fc87b1f5349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So when should I use regular pointers then?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, &amp;iquest;cu&amp;aacute;ndo debo usar punteros regulares?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971abf8af0ed9ddec060bfca3124cf49cd8504de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique Pointer :&lt;/strong&gt; 
    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puntero &amp;uacute;nico:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puntero inteligente ligero con propiedad exclusiva. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se usa cuando el puntero apunta a objetos &amp;uacute;nicos sin compartir los objetos entre los punteros.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46c311c3b22afb68eb5ae8c85ce8bb5d73bc761f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Weak Pointer :&lt;/strong&gt; 
    Helps deal with cyclic reference which arises when using Shared Pointer
    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puntero d&amp;eacute;bil:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ayuda a lidiar con la referencia c&amp;iacute;clica que surge cuando se utiliza el puntero compartido. se eliminar&amp;aacute; cuando los punteros compartidos est&amp;eacute;n fuera de alcance. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para resolver esto, cambie el miembro interno de shared_ptr a weak_ptr. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nota: Para acceder al elemento se&amp;ntilde;alado por un puntero d&amp;eacute;bil, use lock (), esto devuelve un d&amp;eacute;bil_ptr.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3b0f949d4345488039e4183458ea4810d7099f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a smart pointer?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; es un puntero inteligente?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6468525fccb4ecf5e47ed8487dee96a37bf52f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should I use one?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Cu&amp;aacute;ndo debo usar uno?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="660849bfef63c2647882bdc5da8447c8dc6b51e5" translate="yes" xml:space="preserve">
          <source>A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; will not work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un puntero constante a un tipo de datos constante T. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que significa que no puede mover el puntero ni cambiar el puntero del tipo de datos para que sea el puntero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no trabajar&amp;aacute;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="408b455a6c631e6b53e0f1209d0361f9b950a58c" translate="yes" xml:space="preserve">
          <source>A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie &lt;code&gt;*ptr2 = 19&lt;/code&gt; will work but &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; etc will not work. Read backwards : const pointer to a type T</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un puntero constante a un tipo de datos T. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que significa que no puede mover el puntero, pero puede cambiar el valor se&amp;ntilde;alado por el puntero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr2 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; funcionar&amp;aacute; pero &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; etc. no funcionar&amp;aacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Leer al rev&amp;eacute;s: puntero constante a un tipo T&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0895997fb22fe8c3fbe3470dd02611de7817af76" translate="yes" xml:space="preserve">
          <source>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last &quot;reference&quot; to the object is destroyed, the object is deleted. This policy is implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una pol&amp;iacute;tica de puntero inteligente m&amp;aacute;s compleja implica el recuento de referencias del puntero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto permite copiar el puntero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando se destruye la &amp;uacute;ltima &quot;referencia&quot; al objeto, se elimina el objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta pol&amp;iacute;tica es implementada por &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85cc9f1d1b7b72b303b1a6932cad97df1a8bf8af" translate="yes" xml:space="preserve">
          <source>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</source>
          <target state="translated">Un puntero inteligente en comparación define una política en cuanto a cuándo se destruye el objeto.Todavía tienes que crear el objeto,pero ya no tienes que preocuparte por destruirlo.</target>
        </trans-unit>
        <trans-unit id="5a8ed7f449dc88e468a305cb01873d71c0dda80a" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</source>
          <target state="translated">Un puntero inteligente es una clase que envuelve un puntero &quot;crudo&quot; (o &quot;desnudo&quot;)de C++,para manejar la vida útil del objeto al que se apunta.No hay un solo tipo de puntero inteligente,pero todos ellos tratan de abstraer un puntero crudo de una manera práctica.</target>
        </trans-unit>
        <trans-unit id="c2cc5504b9d575fdc1765bc51e43e4e44d93de47" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart point&amp;rsquo;s life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un puntero inteligente es una clase, un contenedor de un puntero normal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A diferencia de los punteros normales, el c&amp;iacute;rculo de vida del punto inteligente se basa en un recuento de referencia (cu&amp;aacute;ntas veces se asigna el objeto puntero inteligente). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, cada vez que se asigna un puntero inteligente a otro, el recuento de referencia interna m&amp;aacute;s m&amp;aacute;s. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y cada vez que el objeto sale del alcance, la referencia cuenta menos menos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9356d827d5b266f397c77242a36f9ee76af46143" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.</source>
          <target state="translated">Un puntero inteligente es un objeto que actúa como un puntero,pero además proporciona control sobre la construcción,la destrucción,la copia,el movimiento y la derivación.</target>
        </trans-unit>
        <trans-unit id="150ff3c7e30d567459ce409ef2d43cf92945b361" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don't respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.</source>
          <target state="translated">Un puntero inteligente es un objeto que actúa,se ve y se siente como un puntero normal pero ofrece más funcionalidad.En C++,los punteros inteligentes se implementan como clases de plantilla que encapsulan un puntero y anulan los operadores de punteros estándar.Tienen una serie de ventajas sobre los punteros normales.Están garantizados para ser inicializados como punteros nulos o punteros a un objeto montón.Se comprueba la indirección a través de un puntero nulo.No es necesario borrarlos.Los objetos se liberan automáticamente cuando el último puntero hacia ellos ha desaparecido.Un problema significativo con estos punteros inteligentes es que,a diferencia de los punteros regulares,no respetan la herencia.Los punteros inteligentes no son atractivos para el código polimórfico.A continuación se da un ejemplo de la implementación de los punteros inteligentes.</target>
        </trans-unit>
        <trans-unit id="b68b6f3a8975f96f1b6b93c4634bedb35aff4ddb" translate="yes" xml:space="preserve">
          <source>A smart pointer is like a regular (typed) pointer, like &quot;char*&quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using &quot;-&amp;gt;&quot;, but not if you need an actual pointer to the data. For that, you can use &quot;&amp;amp;*ptr&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un puntero inteligente es como un puntero normal (mecanografiado), como &quot;char *&quot;, excepto cuando el puntero se sale del alcance y lo que se&amp;ntilde;ala tambi&amp;eacute;n se elimina. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede usarlo como lo har&amp;iacute;a con un puntero normal, usando &quot;-&amp;gt;&quot;, pero no si necesita un puntero real a los datos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para eso, puede usar &quot;&amp;amp; * ptr&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1471a71c5e4eb0de52fc485e12e309fb87dc2eee" translate="yes" xml:space="preserve">
          <source>Additionally, the C++ standard library provides three smart pointers; &lt;code&gt;std::unique_ptr&lt;/code&gt; for unique ownership, &lt;code&gt;std::shared_ptr&lt;/code&gt; for shared ownership and &lt;code&gt;std::weak_ptr&lt;/code&gt;. &lt;code&gt;std::auto_ptr&lt;/code&gt; existed in C++03 but is now deprecated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, la biblioteca est&amp;aacute;ndar de C ++ proporciona tres punteros inteligentes; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para propiedad &amp;uacute;nica, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para propiedad compartida y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; exist&amp;iacute;a en C ++ 03 pero ahora est&amp;aacute; en desuso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f173ba927487f1d4cb291eff83de845b351faeb8" translate="yes" xml:space="preserve">
          <source>Ah, but you really wanted to, admit it.</source>
          <target state="translated">Ah,pero realmente querías hacerlo,admítelo.</target>
        </trans-unit>
        <trans-unit id="fe19f580daa87cc25b870e1baa16fab7e5c59b15" translate="yes" xml:space="preserve">
          <source>Among other things (explained well in other answers) using a smart pointer is a possible solution to &lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;How do we use a abstract class as a function return type?&lt;/a&gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is &quot;what do you really mean?&quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;boost pointer container library&lt;/a&gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don't give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a &lt;em&gt;value&lt;/em&gt; to some form of &lt;em&gt;reference&lt;/em&gt;. If you really needed copy you may need to add more boilerplate &quot;idiom&quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like &lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;Adobe Poly&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;Boost.TypeErasure&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entre otras cosas (explicado bien en otras respuestas), usar un puntero inteligente es una posible soluci&amp;oacute;n para &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo usamos una clase abstracta como un tipo de retorno de funci&amp;oacute;n?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que ha sido marcado como un duplicado de esta pregunta. Sin embargo, la primera pregunta que debe hacerse si est&amp;aacute; tentado a especificar una clase base abstracta (o de hecho, cualquiera) como tipo de retorno en C ++ es &quot;&amp;iquest;qu&amp;eacute; quiere decir realmente?&quot;. Hay una buena discusi&amp;oacute;n (con m&amp;aacute;s referencias) de la programaci&amp;oacute;n idiom&amp;aacute;tica orientada a objetos en C ++ (y c&amp;oacute;mo esto es diferente a otros lenguajes) en la documentaci&amp;oacute;n de la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;biblioteca del contenedor de puntero de impulso&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En resumen, en C ++ tienes que pensar en la propiedad. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Con qu&amp;eacute; punteros inteligentes puede ayudar, pero no son la &amp;uacute;nica soluci&amp;oacute;n, o siempre son una soluci&amp;oacute;n completa (no le dan una copia polim&amp;oacute;rfica) y no siempre son una soluci&amp;oacute;n que desea exponer en su interfaz (y un retorno de funci&amp;oacute;n suena horrible mucho como una interfaz). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede ser suficiente devolver una referencia, por ejemplo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero en todos estos casos (puntero inteligente, contenedor de puntero o simplemente devolver una referencia) ha cambiado el retorno de un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a alguna forma de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;referencia&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si realmente necesita una copia, es posible que deba agregar m&amp;aacute;s &quot;modismos&quot; repetitivos o ir m&amp;aacute;s all&amp;aacute; de la OOP idiom&amp;aacute;tica (o de otro modo) en C ++ a un polimorfismo m&amp;aacute;s gen&amp;eacute;rico utilizando bibliotecas como &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adobe Poly&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78ca5dca4761808a7b5e7382ebf5f698b2cd2fd" translate="yes" xml:space="preserve">
          <source>Another convenient type is &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro tipo conveniente es &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que implementa el recuento de referencias y desasigna autom&amp;aacute;ticamente la memoria cuando no quedan referencias al objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto ayuda a evitar p&amp;eacute;rdidas de memoria y es f&amp;aacute;cil de usar para implementar &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RAII&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf3a668061d4ad283ac2fa86679b6f3b0791cf93" translate="yes" xml:space="preserve">
          <source>Another possibility is creating circular references:</source>
          <target state="translated">Otra posibilidad es crear referencias circulares:</target>
        </trans-unit>
        <trans-unit id="64f289d2f4648dd5b3726612c027f5c92f4a2aaa" translate="yes" xml:space="preserve">
          <source>Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).</source>
          <target state="translated">El puntero automático,aunque se ve similar,es totalmente diferente del puntero inteligente.Es una clase conveniente que reparte el recurso cuando un objeto con puntero automático sale de un ámbito variable.Hasta cierto punto,hace que un puntero (a la memoria asignada dinámicamente)funcione de forma similar a una variable de pila (asignada estáticamente en tiempo de compilación).</target>
        </trans-unit>
        <trans-unit id="0a8c0f929f31db86af22e061262a8478f89bf858" translate="yes" xml:space="preserve">
          <source>Concurrent Counter Access</source>
          <target state="translated">Acceso concurrente al contador</target>
        </trans-unit>
        <trans-unit id="e6bf77b4e6823d55153852cfedb73269bb8fdd72" translate="yes" xml:space="preserve">
          <source>Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).</source>
          <target state="translated">datos miembros de las clases,de modo que cuando se borra el objeto se eliminan también todos los datos que le pertenecen,sin ningún código especial en el destructor (tendrá que estar seguro de que el destructor es virtual,lo que casi siempre es algo bueno).</target>
        </trans-unit>
        <trans-unit id="d315ffe38f74e2bbd3649007ed92bd0fcb339294" translate="yes" xml:space="preserve">
          <source>Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:
A smart pointer is simply a class that overloads the &lt;code&gt;-&amp;gt;&lt;/code&gt;  and &lt;code&gt;*&lt;/code&gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.
&lt;code&gt;shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las definiciones proporcionadas por Chris, Sergdev y Llyod son correctas. Sin embargo, prefiero una definici&amp;oacute;n m&amp;aacute;s simple, solo para simplificar mi vida: un puntero inteligente es simplemente una clase que sobrecarga los &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;operadores &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Lo que significa que su objeto se parece sem&amp;aacute;nticamente a un puntero, pero puede hacer que haga cosas m&amp;aacute;s &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , incluido el recuento de referencias, la destrucci&amp;oacute;n autom&amp;aacute;tica, etc. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;shared_ptr&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; son suficientes en la mayor&amp;iacute;a de los casos, pero vienen con su propio conjunto de peque&amp;ntilde;as idiosincrasias.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17a6e952cfd054bf86a0bff2ef3758ccb138822a" translate="yes" xml:space="preserve">
          <source>Destruction and Deallocation</source>
          <target state="translated">Destrucción y distribución</target>
        </trans-unit>
        <trans-unit id="62c819d637d29a2f4f19cf04f89b693e7e7a7ca3" translate="yes" xml:space="preserve">
          <source>Don't use the &lt;code&gt;boost::&lt;/code&gt; smart pointers or &lt;code&gt;std::auto_ptr&lt;/code&gt; except in special cases which you can read up on if you must.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No use los &lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; inteligentes &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;::&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; punteros o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; excepto en casos especiales en los que pueda leer si es necesario.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f3d3aad5c807bb24d88407fd715dd4bcadc4a87" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; provides the following smart pointer implementations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; proporciona las siguientes implementaciones de puntero inteligente:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6213441eda5b33d29bac7b15eafcedc34217804c" translate="yes" xml:space="preserve">
          <source>Here is the Link for similar answers : &lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute; el enlace para respuestas similares: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="235448e1559e2c6a2d98c037e982857e78ec5708" translate="yes" xml:space="preserve">
          <source>Here's a simple answer for these days of modern C++:</source>
          <target state="translated">Aquí hay una respuesta simple para estos días de C++moderno:</target>
        </trans-unit>
        <trans-unit id="8a930b4fb10a4df4e7af642f22172143cf9dfa25" translate="yes" xml:space="preserve">
          <source>Holder Limitations</source>
          <target state="translated">Limitaciones del titular</target>
        </trans-unit>
        <trans-unit id="db3373933d2b26d58bd3267b9cb9ff92de1de43a" translate="yes" xml:space="preserve">
          <source>Holders, (note, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt; is implementation of such type of smart pointer)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Titulares, (nota, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: auto_ptr&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es la implementaci&amp;oacute;n de este tipo de puntero inteligente)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8efc2fcb0e64352073d01410371f9b29588ff6a8" translate="yes" xml:space="preserve">
          <source>Implemented using reference counting to keep track of how many &quot; things &quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. 
This gets rid of the headache of having to delete objects which you have allocated using new.</source>
          <target state="translated">Se implementó usando el conteo de referencias para llevar la cuenta de cuántas &quot;cosas&quot; apuntan al objeto señalado por el puntero.Cuando este conteo llega a 0,el objeto se elimina automáticamente,es decir,el objeto se elimina cuando todo el share_ptr que apunta al objeto se sale del alcance.Esto elimina el dolor de cabeza de tener que borrar los objetos que has asignado usando new.</target>
        </trans-unit>
        <trans-unit id="c1d841b0ff2602990af565bd1846dd9e8eba0720" translate="yes" xml:space="preserve">
          <source>In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.</source>
          <target state="translated">En el código que implica el seguimiento de la propiedad de un trozo de memoria,asignando o des-asignando;el puntero inteligente a menudo te ahorra la necesidad de hacer estas cosas explícitamente.</target>
        </trans-unit>
        <trans-unit id="8d2ab2c7ea1b9e3dd5c0238fa3501e1a6f018af5" translate="yes" xml:space="preserve">
          <source>In computer science, a smart pointer
  is an abstract data type that
  simulates a pointer while providing
  additional features, such as automatic
  garbage collection or bounds checking.
  These additional features are intended
  to reduce bugs caused by the misuse of
  pointers while retaining efficiency.
  Smart pointers typically keep track of
  the objects that point to them for the
  purpose of memory management. The
  misuse of pointers is a major source
  of bugs: the constant allocation,
  deallocation and referencing that must
  be performed by a program written
  using pointers makes it very likely
  that some memory leaks will occur.
  Smart pointers try to prevent memory
  leaks by making the resource
  deallocation automatic: when the
  pointer to an object (or the last in a
  series of pointers) is destroyed, for
  example because it goes out of scope,
  the pointed object is destroyed too.</source>
          <target state="translated">En la informática,un puntero inteligente es un tipo de datos abstractos que simula un puntero y proporciona características adicionales,como la recogida automática de basura o la comprobación de límites.Estas características adicionales tienen por objeto reducir los errores causados por el mal uso de los punteros,manteniendo al mismo tiempo la eficiencia.Los punteros inteligentes suelen hacer un seguimiento de los objetos que apuntan a ellos con el fin de administrar la memoria.El mal uso de los punteros es una fuente importante de errores:la constante asignación,distribución y referenciación que debe realizar un programa escrito con punteros hace muy probable que se produzcan algunas fugas de memoria.Los punteros inteligentes intentan evitar las fugas de memoria haciendo que la asignación de recursos sea automática:cuando se destruye el puntero de un objeto (o el último de una serie de punteros),por ejemplo porque se sale del ámbito de aplicación,el objeto puntero también se destruye.</target>
        </trans-unit>
        <trans-unit id="b470b0b9a364b2fa432c27c2e23748d4f2eeebfb" translate="yes" xml:space="preserve">
          <source>It is useful for:</source>
          <target state="translated">Es útil para..:</target>
        </trans-unit>
        <trans-unit id="269dd3751517ddfbd50cdb4301abe2ab83b607fc" translate="yes" xml:space="preserve">
          <source>It's a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also &lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;the more detailed definition on Wikipedia&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es un tipo cuyos valores se pueden usar como punteros, pero que proporciona la caracter&amp;iacute;stica adicional de administraci&amp;oacute;n autom&amp;aacute;tica de memoria: cuando un puntero inteligente ya no est&amp;aacute; en uso, la memoria a la que apunta se desasigna (consulte tambi&amp;eacute;n &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la definici&amp;oacute;n m&amp;aacute;s detallada en Wikipedia&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1508c0dbd75f276250ef468cde22c1eb920a2bdb" translate="yes" xml:space="preserve">
          <source>Let T be a class in this tutorial 
Pointers in C++ can be divided into 3 types :</source>
          <target state="translated">Dejemos que T sea una clase en este tutorial Los punteros en C++pueden ser divididos en 3 tipos :</target>
        </trans-unit>
        <trans-unit id="b792a21ee56ff623795e7a57d358d84ec527459b" translate="yes" xml:space="preserve">
          <source>Like other overloaded operators, p will behave like a regular pointer,</source>
          <target state="translated">Como otros operadores sobrecargados,P se comportará como un puntero normal,</target>
        </trans-unit>
        <trans-unit id="455cc282d56455c6f5333fab2462998a571616cc" translate="yes" xml:space="preserve">
          <source>Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.</source>
          <target state="translated">La mayoría de los tipos de punteros inteligentes se encargan de deshacerse del puntero-al objeto por ti.Es muy útil porque ya no tienes que pensar en deshacerte de los objetos manualmente.</target>
        </trans-unit>
        <trans-unit id="7314c02622627b7ccb9b4f584bc913fff6ad6735" translate="yes" xml:space="preserve">
          <source>Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.</source>
          <target state="translated">La mayoría en un código que no tiene en cuenta la propiedad de la memoria.Esto sería típicamente en funciones que obtienen un puntero de otro lugar y no asignan ni des-asignan,y no almacenan una copia del puntero que dura más que su ejecución.</target>
        </trans-unit>
        <trans-unit id="26e6d181ff99160909b595478121f08dd076edb4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::unique_ptr&lt;/code&gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que las &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;instancias &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no se pueden copiar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto evita que el puntero se elimine varias veces (incorrectamente). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, puede pasar referencias a otras funciones que llame.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc55faaac98b84550c0f52f207b38f5a9b210b5d" translate="yes" xml:space="preserve">
          <source>Objects that must be allocated with new, but that you'd like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.</source>
          <target state="translated">Objetos que deben ser asignados con nuevo,pero que le gustaría tener la misma vida útil que algo en esa pila.Si el objeto está asignado a un puntero inteligente,entonces se borrarán cuando el programa salga de ese bloque de funciones.</target>
        </trans-unit>
        <trans-unit id="f751c9fbb24aa2c23e6e65e987bb3d5bb9f738ce" translate="yes" xml:space="preserve">
          <source>One can implement one's own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.</source>
          <target state="translated">Uno puede implementar su propio puntero inteligente,pero muchas bibliotecas también ofrecen implementaciones de punteros inteligentes,cada una con diferentes ventajas e inconvenientes.</target>
        </trans-unit>
        <trans-unit id="87b543505cd555c6851c754dbaa29544fec9d8de" translate="yes" xml:space="preserve">
          <source>One of the simple smart-pointer type is &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt; (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Uno de los tipos simples de puntero inteligente es &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (cap&amp;iacute;tulo 20.4.5 del est&amp;aacute;ndar C ++), que permite desasignar memoria autom&amp;aacute;ticamente cuando est&amp;aacute; fuera de alcance y que es m&amp;aacute;s robusto que el uso simple de puntero cuando se lanzan excepciones, aunque menos flexible.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deac6c8d86314111051ac297a8e90d729d2fc59e" translate="yes" xml:space="preserve">
          <source>Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie &lt;code&gt;*ptr1 = 19&lt;/code&gt; ; will not work. But you can move the pointer. ie &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; ;  etc will work.
Read backwards : pointer to type T which is const</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puntero a un tipo de datos T que es una constante. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que significa que no puede cambiar el tipo de datos con el puntero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr1 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no trabajar&amp;aacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero puedes mover el puntero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;etc funcionar&amp;aacute; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Leer al rev&amp;eacute;s: puntero para escribir T, que es constante&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5091a6ac607a66d605572c2f1f01fdeddfb5810" translate="yes" xml:space="preserve">
          <source>Pointers with const data or address { Read backwards }</source>
          <target state="translated">Indicadores con datos constantes o dirección{Leído al revés }</target>
        </trans-unit>
        <trans-unit id="3c274408a7815b4769a808e5cd01a86c5b3930d3" translate="yes" xml:space="preserve">
          <source>Protecting Against Exceptions</source>
          <target state="translated">Protección contra las excepciones</target>
        </trans-unit>
        <trans-unit id="cc6e672ee6612bec71630926ee21e523510d4fc4" translate="yes" xml:space="preserve">
          <source>Reference : 
&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/a&gt; 
Thanks to Andre for pointing out this question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Referencia: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Gracias a Andre por se&amp;ntilde;alar esta pregunta.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4d88eed28dd1376cc40fd170b9bfe77d1d02da0" translate="yes" xml:space="preserve">
          <source>Reference Counting</source>
          <target state="translated">Recuento de referencia</target>
        </trans-unit>
        <trans-unit id="7fd5474cfc1ade935cc5c546e88ea9b67e4d64c6" translate="yes" xml:space="preserve">
          <source>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</source>
          <target state="translated">Los punteros contados de referencia son muy útiles cuando la vida útil de su objeto es mucho más complicada,y no está ligada directamente a una sección particular del código o a otro objeto.</target>
        </trans-unit>
        <trans-unit id="08784d3c2d27ac259ff9d07cfc06917a9d5a0f38" translate="yes" xml:space="preserve">
          <source>References : 
    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.</source>
          <target state="translated">Referencias:Pueden ser considerados esencialmente como punteros const,es decir,un puntero que es const y no puede ser movido con una mejor sintaxis.</target>
        </trans-unit>
        <trans-unit id="4bed4ff02087a38f1b95579b7416fac0a1027a61" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;When is std::weak_ptr useful?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ver: &amp;iquest; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cu&amp;aacute;ndo es &amp;uacute;til std :: weak_ptr?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5251271034126a1a5c2548bc2290d5d6cd1e15d8" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;What are the differences between a pointer variable and a reference variable in C++?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ver: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Cu&amp;aacute;les son las diferencias entre una variable de puntero y una variable de referencia en C ++?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">Ver también:</target>
        </trans-unit>
        <trans-unit id="06b60eabd9ac929a849b1c545034616a52874ae8" translate="yes" xml:space="preserve">
          <source>Small intro is available on page &lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;Smart Pointers - What, Why, Which?&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay una peque&amp;ntilde;a introducci&amp;oacute;n disponible en la p&amp;aacute;gina &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Punteros inteligentes: &amp;iquest;qu&amp;eacute;, por qu&amp;eacute; y cu&amp;aacute;l? &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eddd0ee6c00b8b7b07f4aa1533cf74d53674f39b" translate="yes" xml:space="preserve">
          <source>Smart Pointers are those where you don't have to worry about Memory De-Allocation, Resource Sharing and Transfer.</source>
          <target state="translated">Los punteros inteligentes son aquellos en los que no tienes que preocuparte por la des-asignación de memoria,compartir y transferir recursos.</target>
        </trans-unit>
        <trans-unit id="04467054ec546b1c0315c4cfac233385593e4375" translate="yes" xml:space="preserve">
          <source>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you &lt;em&gt;really&lt;/em&gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se deben preferir los punteros inteligentes a los punteros en bruto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si siente que necesita usar punteros (primero considere si &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;realmente lo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hace), normalmente querr&amp;aacute; usar un puntero inteligente, ya que esto puede aliviar muchos de los problemas con punteros sin procesar, principalmente olvidando eliminar el objeto y la p&amp;eacute;rdida de memoria.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e25c6c59bcb6d66abe3c35be9cc4fddb4b2b9bca" translate="yes" xml:space="preserve">
          <source>Subject is covered in depth in book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&quot;C++ Templates: The Complete Guide&quot; by David Vandevoorde, Nicolai M. Josuttis&lt;/a&gt;, chapter Chapter 20. Smart Pointers.
Some topics covered:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El tema se trata en profundidad en el libro &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Plantillas C ++: La gu&amp;iacute;a completa&quot; de David Vandevoorde, Nicolai M. Josuttis&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , cap&amp;iacute;tulo Cap&amp;iacute;tulo 20. Punteros inteligentes. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algunos temas cubiertos:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1de633672e7627dbf70739243d0b87a6dc17bb" translate="yes" xml:space="preserve">
          <source>The existing answers are good but don't cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.</source>
          <target state="translated">Las respuestas existentes son buenas,pero no cubren lo que hay que hacer cuando un puntero inteligente no es la respuesta (completa)al problema que se intenta resolver.</target>
        </trans-unit>
        <trans-unit id="b06ceb1cd65ed156e62d8ecd9eab78c66e613029" translate="yes" xml:space="preserve">
          <source>The most commonly-used smart pointers are &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; (or &lt;code&gt;boost::shared_ptr&lt;/code&gt;), and, less commonly, &lt;code&gt;std::auto_ptr&lt;/code&gt;. I recommend regular use of &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los punteros inteligentes m&amp;aacute;s utilizados son &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) y, con menos frecuencia, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Recomiendo el uso regular de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97b533d7bfbeb88b5d7616af5826194991855a7f" translate="yes" xml:space="preserve">
          <source>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt;&lt;code&gt;boost::scoped_ptr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La pol&amp;iacute;tica m&amp;aacute;s simple en uso implica el alcance del objeto contenedor de puntero inteligente, como el implementado por &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt; &lt;code&gt;boost::scoped_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d47eb61584acb71b110726e0b95e16a13f3cc6" translate="yes" xml:space="preserve">
          <source>There is one drawback to reference counted pointers &amp;mdash; the possibility of creating a dangling reference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay un inconveniente para hacer referencia a los punteros contados: la posibilidad de crear una referencia colgante:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7cf9d335ee541a055c37f36657dc1e6a480c449d" translate="yes" xml:space="preserve">
          <source>There was also &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt;. It was very much like a scoped pointer, except that it also had the &quot;special&quot; dangerous ability to be copied &amp;mdash; which also unexpectedly transfers ownership.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n hab&amp;iacute;a &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Era muy parecido a un puntero de alcance, excepto que tambi&amp;eacute;n ten&amp;iacute;a la habilidad peligrosa &quot;especial&quot; de ser copiada, lo que tambi&amp;eacute;n transfiere inesperadamente la propiedad.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10dc26ca1fd5731e91d37edb3bbff8ef030a4f4" translate="yes" xml:space="preserve">
          <source>These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.</source>
          <target state="translated">Estas son sólo una descripción lineal de cada uno y pueden ser utilizadas según las necesidades,para más detalles y ejemplos se puede mirar la documentación de Boost.</target>
        </trans-unit>
        <trans-unit id="074f5297a4fba1ef7bfeb2429c1ef13d61bea37b" translate="yes" xml:space="preserve">
          <source>They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track.</source>
          <target state="translated">Tienen una dirección de memoria a una ubicación en la memoria.Úselos con precaución,ya que los programas se vuelven complejos y difíciles de rastrear.</target>
        </trans-unit>
        <trans-unit id="9432b51535de91f29d61abdc8f193678d301d5bc" translate="yes" xml:space="preserve">
          <source>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta respuesta es bastante antigua, por lo que describe lo que era &quot;bueno&quot; en ese momento, que eran los punteros inteligentes proporcionados por la biblioteca Boost. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde C ++ 11, la biblioteca est&amp;aacute;ndar ha proporcionado suficientes tipos de punteros inteligentes, por lo que debe favorecer el uso de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3fd31e33e7e71dba6afa758f5ddaa23fd6413cc" translate="yes" xml:space="preserve">
          <source>This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:</source>
          <target state="translated">Esta clase implementa un puntero inteligente a un objeto de tipo X.El objeto en sí se encuentra en el montón.Aquí está cómo usarlo:</target>
        </trans-unit>
        <trans-unit id="c3acb92908f60dd2ddfb231908946d7977340ae6" translate="yes" xml:space="preserve">
          <source>To change the object pointed to by the unique ptr , use move semantics</source>
          <target state="translated">Para cambiar el objeto al que apunta el ptr único,usa la semántica del movimiento.</target>
        </trans-unit>
        <trans-unit id="80ec759771be05f92f85c7d934d53b16a77673fa" translate="yes" xml:space="preserve">
          <source>To work around this problem, both Boost and C++11 have defined a &lt;code&gt;weak_ptr&lt;/code&gt; to define a weak (uncounted) reference to a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para evitar este problema, tanto Boost como C ++ 11 han definido un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para definir una referencia d&amp;eacute;bil (sin contar) a un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18f22cb2e33fe36506262132cc985d5cd594ea3d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Use &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando desee hacer referencia a su objeto desde varios lugares, y no quiera que su objeto sea desasignado hasta que todas estas referencias hayan desaparecido.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d62e1c7ca9f6bac0498ed49f33b2dd9b90497ae4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt; when you don't intend to hold multiple references to the same object. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Use &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando no tenga la intenci&amp;oacute;n de mantener m&amp;uacute;ltiples referencias al mismo objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, &amp;uacute;selo para un puntero a la memoria que se asigna al ingresar alg&amp;uacute;n alcance y se desasigna al salir del alcance.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89b90755704062fcad6a5106c9e29a719bef4c5e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate (so they'll just note the object is gone when you try to dereference).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Use &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando desee hacer referencia a su objeto desde varios lugares, para aquellas referencias para las cuales est&amp;aacute; bien ignorar y desasignar (para que solo noten que el objeto se ha ido cuando intenta desreferenciar).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bb07c28eb795708a8cc90a338886a7431582ee9" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one</source>
          <target state="translated">¿Qué es un puntero inteligente y cuándo debo usar uno?</target>
        </trans-unit>
        <trans-unit id="8d779c02f29f56174f222fe34fb2a12b36815ca5" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one?</source>
          <target state="translated">¿Qué es un puntero inteligente y cuándo debo usar uno?</target>
        </trans-unit>
        <trans-unit id="72dca932f0f35f4b1af9967ff79dc06b4b558df6" translate="yes" xml:space="preserve">
          <source>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</source>
          <target state="translated">Con los punteros en bruto,el programador tiene que destruir explícitamente el objeto cuando ya no es útil.</target>
        </trans-unit>
        <trans-unit id="7c8bd33fd1a098972b52263748dc1191e62414cf" translate="yes" xml:space="preserve">
          <source>You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.</source>
          <target state="translated">Puedes usar estos punteros de la misma manera que cualquier asignación funciona en Java.En Java el Colector de Basura hace el truco,mientras que en los Punteros Inteligentes,el truco lo hace Destructores.</target>
        </trans-unit>
        <trans-unit id="a60c5ae076041d7c822b45b7033064048db8f570" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;not&lt;/em&gt; want to use a smart pointer when:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es posible que &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; desee utilizar un puntero inteligente cuando:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
