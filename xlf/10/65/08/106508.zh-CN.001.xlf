<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/106508">
    <body>
      <group id="106508">
        <trans-unit id="af2e8e09e40e9f539ab8da751affb13a10ba4eec" translate="yes" xml:space="preserve">
          <source>... the pointer shouldn't actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.</source>
          <target state="translated">....指针不应该实际拥有数据...........也就是说,当你只是在使用数据,但你希望它能在你引用它的函数中存活下来。</target>
        </trans-unit>
        <trans-unit id="c4744e75c09f437c395d9d10e5ca53018fc22030" translate="yes" xml:space="preserve">
          <source>... the smart pointer isn't itself going to be destroyed at some point. You don't want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won't be explicitly deleted).</source>
          <target state="translated">...智能指针本身不会在某个时候被销毁。你不希望它坐在永远不会被销毁的内存中(例如在一个动态分配但不会被明确删除的对象中)。</target>
        </trans-unit>
        <trans-unit id="7abe7f7009507b420472f008cf135a3361a38a02" translate="yes" xml:space="preserve">
          <source>... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counting&lt;/a&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;...两个智能指针可能指向同一数据。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（但是，还有更聪明的指针可以处理该问题&amp;hellip;&amp;hellip;这称为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用计数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b3456d375c6b7456d5c4bc19041b1f3e7159035" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Raw pointers&lt;/strong&gt; :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1）&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原始指针&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c05ec50cd607baeca2e3d1f218f43eaa3fe20dc" translate="yes" xml:space="preserve">
          <source>3) &lt;strong&gt;Smart Pointers&lt;/strong&gt; : { &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; }</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3）&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：{ &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; }&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5a0658a851943e0a2cbffdefa181eb111a1072c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;garbage collection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;垃圾收集&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4b51566876fb4532e007f30a397e20ccf5f7b334" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;Resource Acquisition Is Initialization&lt;/a&gt; (This is frequently used for exception-safe resource management in C++)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;资源获取即初始化&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（在C ++中经常用于异常安全的资源管理）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29e3f25d900a39e1908f817e7b69b107c13bb24c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;Smart pointer&lt;/a&gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一种类似指针的类型，具有一些其他功能，例如自动内存释放，引用计数等。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f616381ac60ee4dc0c8941b5d68506530ee64337" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;This stack overflow question&lt;/a&gt; regarding data ownership</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关数据所有权的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此堆栈溢出问题&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1867be1ad1af5dc650167a8cf0efa432ce165e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is another reference counting pointer. It provides better performance than &lt;code&gt;shared_ptr&lt;/code&gt;, but requires the type &lt;code&gt;T&lt;/code&gt; to provide its own reference counting mechanism.</source>
          <target state="translated">&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是另一个引用计数指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它提供了比&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更好的性能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是要求类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供自己的引用计数机制。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0d5f87331c2eecb842ccaae6c19f1a55d8ea413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;scoped_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scoped_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类似&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4022aeb6f81b4906c6ab25a8ce758c7901bdd9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.</source>
          <target state="translated">&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个指针，当它超出范围时会自动删除。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无法分配。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b3ae49c2084013ca2cd8045ab6949f88e0a1056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;shared_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类似于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70c670daab27ba020ed4b3008ffa5f7e50646ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer to &lt;code&gt;T&lt;/code&gt; using a reference count to determine when the object is no longer needed.</source>
          <target state="translated">&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是指向&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的指针，它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用引用计数来确定何时不再需要该对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85b44869045deedea760f2af227ba51e6ab34649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&lt;/code&gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be &quot;passed across DLL boundaries&quot; (the common nightmare case if different &lt;code&gt;libc&lt;/code&gt;s are used between your code and the DLLs).</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是非常通用的，并且处理各种各样的处置方案，包括需要&amp;ldquo;跨越DLL边界传递对象&amp;rdquo;的情况（如果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在代码和DLL之间使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不同的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;libc&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则通常是噩梦&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aaed4c81152732868d9d49d18694435ce025dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要将对象的生存期绑定到特定代码块，或者如果将其作为成员数据嵌入另一个对象的生存期，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: unique_ptr&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很有用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该对象将一直存在，直到退出包含代码块，或者直到包含对象本身被销毁为止。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35295afc323a8764cefd17b5bdc018ac29b84a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a weak pointer, working in conjunction with &lt;code&gt;shared_ptr&lt;/code&gt; to avoid circular references.</source>
          <target state="translated">&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是弱指针，与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;配合使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可避免循环引用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef33adbf278b78fced043861257bfe060e159b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But which smart pointer should I use in which of those cases?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是在那些情况下，我应该使用哪个智能指针？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e761a3027e25048706976b6db69a52b4e01b467d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey, I didn't ask which one to use!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;嘿，我没问要用哪一个！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bfc5096d48f06748da1555aa92cde89f2a6341c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It was deprecated in C++11 and removed in C++17&lt;/strong&gt;, so you shouldn't use it.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它在C ++ 11中已弃用，在C ++ 17中已删除&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此您不应该使用它。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05d6ce56a57f8c848f648042c5448f4a8a610d89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OLD ANSWER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;老答案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d1e940c49d65579e31f8af44e892beff4f142c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shared Pointer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;共享指针&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="005e906d718b91c7b79edf678d3c0fc87b1f5349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So when should I use regular pointers then?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么，什么时候应该使用常规指针呢？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971abf8af0ed9ddec060bfca3124cf49cd8504de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique Pointer :&lt;/strong&gt; 
    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一指针：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 具有专有权的轻巧智能指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当指针指向唯一对象而不在指针之间共享对象时使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46c311c3b22afb68eb5ae8c85ce8bb5d73bc761f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Weak Pointer :&lt;/strong&gt; 
    Helps deal with cyclic reference which arises when using Shared Pointer
    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;弱指针：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 帮助处理使用共享指针时出现的循环引用如果您有两个共享指针指向的两个对象，并且有一个内部共享指针指向彼此共享的指针，则将有一个循环引用，而该对象不会当共享指针超出范围时被删除。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要解决此问题，请将内部成员从shared_ptr更改为weak_ptr。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：要使用弱指针指向的元素，请使用lock（），这将返回weak_ptr。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3b0f949d4345488039e4183458ea4810d7099f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a smart pointer?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么是智能指针？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6468525fccb4ecf5e47ed8487dee96a37bf52f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should I use one?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我什么时候应该使用？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="660849bfef63c2647882bdc5da8447c8dc6b51e5" translate="yes" xml:space="preserve">
          <source>A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; will not work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向const数据类型T的const指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着您既不能移动指针，也不能将数据类型指针更改为指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不管用&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="408b455a6c631e6b53e0f1209d0361f9b950a58c" translate="yes" xml:space="preserve">
          <source>A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie &lt;code&gt;*ptr2 = 19&lt;/code&gt; will work but &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; etc will not work. Read backwards : const pointer to a type T</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向数据类型T的const指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着您不能移动指针，但是可以更改指针指向的值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr2 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将起作用，但&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等将不起作用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;向后读取：指向类型T的const指针&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0895997fb22fe8c3fbe3470dd02611de7817af76" translate="yes" xml:space="preserve">
          <source>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last &quot;reference&quot; to the object is destroyed, the object is deleted. This policy is implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更复杂的智能指针策略涉及对指针进行引用计数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这确实允许复制指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当该对象的最后一个&amp;ldquo;引用&amp;rdquo;被销毁时，该对象将被删除。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该策略由&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85cc9f1d1b7b72b303b1a6932cad97df1a8bf8af" translate="yes" xml:space="preserve">
          <source>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</source>
          <target state="translated">相比之下,智能指针定义了对象何时销毁的策略。你仍然需要创建对象,但你不再需要担心销毁对象。</target>
        </trans-unit>
        <trans-unit id="5a8ed7f449dc88e468a305cb01873d71c0dda80a" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</source>
          <target state="translated">智能指针是一个包裹 &quot;原始&quot;(或 &quot;裸&quot;)C++指针的类,用来管理被指向对象的生命周期。没有单一的智能指针类型,但所有的智能指针都试图以实用的方式抽象出一个原始指针。</target>
        </trans-unit>
        <trans-unit id="c2cc5504b9d575fdc1765bc51e43e4e44d93de47" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart point&amp;rsquo;s life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针是一个类，是普通指针的包装。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与普通指针不同，智能点的生命周期基于参考计数（智能指针对象被分配多少次）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，每当将智能指针分配给另一个指针时，内部引用计数就会加上加号。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每当对象超出范围时，引用计数就为负号。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9356d827d5b266f397c77242a36f9ee76af46143" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.</source>
          <target state="translated">智能指针是一个类似于指针的对象,它的作用类似于指针,但同时也提供了对构建、销毁、复制、移动和取消引用的控制。</target>
        </trans-unit>
        <trans-unit id="150ff3c7e30d567459ce409ef2d43cf92945b361" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don't respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.</source>
          <target state="translated">智能指针是一个对象,它的行为、外观和感觉与普通指针相似,但提供了更多的功能。在C++中,智能指针是以模板类的形式实现的,它封装了一个指针并覆盖了标准的指针操作符。与普通指针相比,它们有许多优点。它们可以保证被初始化为null指针或指向堆对象的指针。通过空指针的指向性被检查。不需要删除。当最后一个指针消失后,对象会被自动释放。这些智能指针的一个显著问题是,与普通指针不同,它们不尊重继承。智能指针对于多态代码来说是没有吸引力的。下面给出了一个实现智能指针的例子。</target>
        </trans-unit>
        <trans-unit id="b68b6f3a8975f96f1b6b93c4634bedb35aff4ddb" translate="yes" xml:space="preserve">
          <source>A smart pointer is like a regular (typed) pointer, like &quot;char*&quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using &quot;-&amp;gt;&quot;, but not if you need an actual pointer to the data. For that, you can use &quot;&amp;amp;*ptr&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针就像常规的（类型化的）指针，如&amp;ldquo; char *&amp;rdquo;一样，除了当指针本身超出范围时，它所指向的内容也会被删除。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以像使用常规指针一样使用&amp;ldquo;-&amp;gt;&amp;rdquo;来使用它，但是如果您需要实际的数据指针则不需要。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为此，您可以使用&amp;ldquo;＆* ptr&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1471a71c5e4eb0de52fc485e12e309fb87dc2eee" translate="yes" xml:space="preserve">
          <source>Additionally, the C++ standard library provides three smart pointers; &lt;code&gt;std::unique_ptr&lt;/code&gt; for unique ownership, &lt;code&gt;std::shared_ptr&lt;/code&gt; for shared ownership and &lt;code&gt;std::weak_ptr&lt;/code&gt;. &lt;code&gt;std::auto_ptr&lt;/code&gt; existed in C++03 but is now deprecated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此外，C ++标准库提供了三个智能指针。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示唯一所有权，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示共享所有权，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存在于C ++ 03中，但现在已弃用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f173ba927487f1d4cb291eff83de845b351faeb8" translate="yes" xml:space="preserve">
          <source>Ah, but you really wanted to, admit it.</source>
          <target state="translated">啊,但你真的想,承认吧。</target>
        </trans-unit>
        <trans-unit id="fe19f580daa87cc25b870e1baa16fab7e5c59b15" translate="yes" xml:space="preserve">
          <source>Among other things (explained well in other answers) using a smart pointer is a possible solution to &lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;How do we use a abstract class as a function return type?&lt;/a&gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is &quot;what do you really mean?&quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;boost pointer container library&lt;/a&gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don't give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a &lt;em&gt;value&lt;/em&gt; to some form of &lt;em&gt;reference&lt;/em&gt;. If you really needed copy you may need to add more boilerplate &quot;idiom&quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like &lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;Adobe Poly&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;Boost.TypeErasure&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除其他外（在其他答案中也有很好的解释），使用智能指针是解决&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何将抽象类用作函数返回类型的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一种可能的解决方案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已被标记为该问题的重复项。但是，第一个询问是否试图将抽象（或实际上任何）基类指定为C ++中的返回类型的问题是&amp;ldquo;您的真正意思是什么？&amp;rdquo;。在&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;boost指针容器库&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的文档中对C ++中的惯用的面向对象编程进行了很好的讨论（以及进一步的参考）（以及这与其他语言有何不同）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总而言之，在C ++中，您必须考虑所有权。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哪些智能指针可以为您提供帮助，但不是唯一的解决方案，也不总是一个完整的解决方案（它们不会为您提供多态副本），也不总是您想要在界面中公开的解决方案（函数返回听起来很糟糕）非常像一个界面）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，返回引用可能就足够了。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是在所有这些情况下（智能指针，指针容器或简单地返回引用），您已将返回&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更改&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为某种形式的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您确实需要复制，则可能需要使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adobe Poly&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost.TypeErasure之&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的库添加更多样板&amp;ldquo;成语&amp;rdquo;，或从C ++中的惯用（或其他）OOP转移到更通用的多态性。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78ca5dca4761808a7b5e7382ebf5f698b2cd2fd" translate="yes" xml:space="preserve">
          <source>Another convenient type is &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一种方便的类型是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它实现引用计数并在没有剩余对对象的引用时自动释放内存。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这有助于避免内存泄漏，并且易于使用来实现&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RAII&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf3a668061d4ad283ac2fa86679b6f3b0791cf93" translate="yes" xml:space="preserve">
          <source>Another possibility is creating circular references:</source>
          <target state="translated">另一种可能是创建循环引用。</target>
        </trans-unit>
        <trans-unit id="64f289d2f4648dd5b3726612c027f5c92f4a2aaa" translate="yes" xml:space="preserve">
          <source>Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).</source>
          <target state="translated">自动指针虽然看起来差不多,但和智能指针完全不同。它是一个方便的类,每当自动指针对象超出变量范围时,它就会对资源进行dealocate。在某种程度上,它使指针(动态分配内存)的工作原理类似于堆栈变量(在编译时静态分配)。</target>
        </trans-unit>
        <trans-unit id="0a8c0f929f31db86af22e061262a8478f89bf858" translate="yes" xml:space="preserve">
          <source>Concurrent Counter Access</source>
          <target state="translated">并行计数器访问</target>
        </trans-unit>
        <trans-unit id="e6bf77b4e6823d55153852cfedb73269bb8fdd72" translate="yes" xml:space="preserve">
          <source>Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).</source>
          <target state="translated">类的数据成员,这样,当对象被删除时,所有拥有的数据也会被删除,而不需要在destructor中加入任何特殊的代码(你需要确定destructor是虚拟的,这几乎是一个很好的办法)。</target>
        </trans-unit>
        <trans-unit id="d315ffe38f74e2bbd3649007ed92bd0fcb339294" translate="yes" xml:space="preserve">
          <source>Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:
A smart pointer is simply a class that overloads the &lt;code&gt;-&amp;gt;&lt;/code&gt;  and &lt;code&gt;*&lt;/code&gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.
&lt;code&gt;shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Chris，Sergdev和Llyod提供的定义是正确的。不过，我更喜欢一个简单的定义，只是为了使我的生活更简单：智能指针只是一个重载&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符的类。这意味着您的对象在语义上看起来像一个指针，但是您可以使它做一些更酷的事情，包括引用计数，自动销毁等 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在大多数情况下就足够了，但是带有它们自己的一组小特质。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17a6e952cfd054bf86a0bff2ef3758ccb138822a" translate="yes" xml:space="preserve">
          <source>Destruction and Deallocation</source>
          <target state="translated">销毁和重新分配</target>
        </trans-unit>
        <trans-unit id="62c819d637d29a2f4f19cf04f89b693e7e7a7ca3" translate="yes" xml:space="preserve">
          <source>Don't use the &lt;code&gt;boost::&lt;/code&gt; smart pointers or &lt;code&gt;std::auto_ptr&lt;/code&gt; except in special cases which you can read up on if you must.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除非在特殊情况下可以使用，否则请&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f3d3aad5c807bb24d88407fd715dd4bcadc4a87" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; provides the following smart pointer implementations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供以下智能指针实现：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6213441eda5b33d29bac7b15eafcedc34217804c" translate="yes" xml:space="preserve">
          <source>Here is the Link for similar answers : &lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是类似答案的链接：&lt;/font&gt;&lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="235448e1559e2c6a2d98c037e982857e78ec5708" translate="yes" xml:space="preserve">
          <source>Here's a simple answer for these days of modern C++:</source>
          <target state="translated">下面就为这几天的现代C++简单解答一下。</target>
        </trans-unit>
        <trans-unit id="8a930b4fb10a4df4e7af642f22172143cf9dfa25" translate="yes" xml:space="preserve">
          <source>Holder Limitations</source>
          <target state="translated">持有者的限制</target>
        </trans-unit>
        <trans-unit id="db3373933d2b26d58bd3267b9cb9ff92de1de43a" translate="yes" xml:space="preserve">
          <source>Holders, (note, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt; is implementation of such type of smart pointer)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;持有人，（请注意，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: auto_ptr&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是此类智能指针的实现）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8efc2fcb0e64352073d01410371f9b29588ff6a8" translate="yes" xml:space="preserve">
          <source>Implemented using reference counting to keep track of how many &quot; things &quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. 
This gets rid of the headache of having to delete objects which you have allocated using new.</source>
          <target state="translated">使用引用计数来跟踪有多少个 &quot;东西 &quot;指向指针所指向的对象。当这个计数为0时,对象会被自动删除,也就是说,当所有指向对象的share_ptr超出范围时,对象会被删除。这样可以避免了使用new来删除已经分配的对象的头痛问题。</target>
        </trans-unit>
        <trans-unit id="c1d841b0ff2602990af565bd1846dd9e8eba0720" translate="yes" xml:space="preserve">
          <source>In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.</source>
          <target state="translated">在涉及到跟踪一段内存的所有权、分配或取消分配的代码中,智能指针通常会让你省去显式操作这些事情。</target>
        </trans-unit>
        <trans-unit id="8d2ab2c7ea1b9e3dd5c0238fa3501e1a6f018af5" translate="yes" xml:space="preserve">
          <source>In computer science, a smart pointer
  is an abstract data type that
  simulates a pointer while providing
  additional features, such as automatic
  garbage collection or bounds checking.
  These additional features are intended
  to reduce bugs caused by the misuse of
  pointers while retaining efficiency.
  Smart pointers typically keep track of
  the objects that point to them for the
  purpose of memory management. The
  misuse of pointers is a major source
  of bugs: the constant allocation,
  deallocation and referencing that must
  be performed by a program written
  using pointers makes it very likely
  that some memory leaks will occur.
  Smart pointers try to prevent memory
  leaks by making the resource
  deallocation automatic: when the
  pointer to an object (or the last in a
  series of pointers) is destroyed, for
  example because it goes out of scope,
  the pointed object is destroyed too.</source>
          <target state="translated">在计算机科学中,智能指针是一种抽象的数据类型,它模拟了一个指针,同时提供了额外的特性,如自动垃圾回收或边界检查等。这些附加功能的目的是为了在保留效率的前提下,减少因误用指针造成的BUG。智能指针通常会跟踪指向它们的对象,以达到内存管理的目的。滥用指针是一个主要的bug来源:使用指针编写的程序必须不断地进行分配、去分配和引用,这使得一些内存泄漏的情况很可能发生。智能指针试图通过使资源dealocation自动分配来防止内存泄漏:当一个对象的指针(或一系列指针中的最后一个指针)被破坏时,例如因为它超出了作用域,被指向的对象也会被破坏。</target>
        </trans-unit>
        <trans-unit id="b470b0b9a364b2fa432c27c2e23748d4f2eeebfb" translate="yes" xml:space="preserve">
          <source>It is useful for:</source>
          <target state="translated">它的作用是:</target>
        </trans-unit>
        <trans-unit id="269dd3751517ddfbd50cdb4301abe2ab83b607fc" translate="yes" xml:space="preserve">
          <source>It's a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also &lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;the more detailed definition on Wikipedia&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种类型的值可以像指针一样使用，但是提供了自动内存管理的附加功能：当不再使用智能指针时，它所指向的内存将被释放（另请参阅&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia上的更详细的定义&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1508c0dbd75f276250ef468cde22c1eb920a2bdb" translate="yes" xml:space="preserve">
          <source>Let T be a class in this tutorial 
Pointers in C++ can be divided into 3 types :</source>
          <target state="translated">让T是本教程中的类,在C++中指针可分为3种类型。</target>
        </trans-unit>
        <trans-unit id="b792a21ee56ff623795e7a57d358d84ec527459b" translate="yes" xml:space="preserve">
          <source>Like other overloaded operators, p will behave like a regular pointer,</source>
          <target state="translated">像其他超载运算符一样,p会像普通的指针一样。</target>
        </trans-unit>
        <trans-unit id="455cc282d56455c6f5333fab2462998a571616cc" translate="yes" xml:space="preserve">
          <source>Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.</source>
          <target state="translated">大多数类型的智能指针为你处理处置指针到对象。它非常方便,因为你不用再考虑手动处理对象了。</target>
        </trans-unit>
        <trans-unit id="7314c02622627b7ccb9b4f584bc913fff6ad6735" translate="yes" xml:space="preserve">
          <source>Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.</source>
          <target state="translated">大多数情况下,在忽略了内存所有权的代码中。这通常出现在函数中,这些函数从其他地方获取一个指针,不分配也不去分配,也不存储超过其执行时间的指针副本。</target>
        </trans-unit>
        <trans-unit id="26e6d181ff99160909b595478121f08dd076edb4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::unique_ptr&lt;/code&gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无法复制&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样可以防止多次（不正确）删除指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，您可以将对其的引用传递给您调用的其他函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc55faaac98b84550c0f52f207b38f5a9b210b5d" translate="yes" xml:space="preserve">
          <source>Objects that must be allocated with new, but that you'd like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.</source>
          <target state="translated">必须用new分配的对象,但你希望该对象的寿命与该堆栈上的东西相同。如果对象被分配给了一个智能指针,那么当程序退出该函数块时,它们将被删除。</target>
        </trans-unit>
        <trans-unit id="f751c9fbb24aa2c23e6e65e987bb3d5bb9f738ce" translate="yes" xml:space="preserve">
          <source>One can implement one's own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.</source>
          <target state="translated">一个人可以实现自己的智能指针,但很多库也提供了智能指针的实现,各有各的优点和缺点。</target>
        </trans-unit>
        <trans-unit id="87b543505cd555c6851c754dbaa29544fec9d8de" translate="yes" xml:space="preserve">
          <source>One of the simple smart-pointer type is &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt; (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一种简单的智能指针类型是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（C ++标准的20.4.5章），它允许在超出范围时自动释放内存，并且比引发异常时的简单指针使用更可靠，尽管这种情况较少灵活。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deac6c8d86314111051ac297a8e90d729d2fc59e" translate="yes" xml:space="preserve">
          <source>Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie &lt;code&gt;*ptr1 = 19&lt;/code&gt; ; will not work. But you can move the pointer. ie &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; ;  etc will work.
Read backwards : pointer to type T which is const</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向数据类型T的指针，该数据类型为const。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着您不能使用指针更改数据类型。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr1 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不管用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是您可以移动指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等会工作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;向后读：指向T的指针，它是const&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5091a6ac607a66d605572c2f1f01fdeddfb5810" translate="yes" xml:space="preserve">
          <source>Pointers with const data or address { Read backwards }</source>
          <target state="translated">带有常量数据或地址的指针{向后读 }</target>
        </trans-unit>
        <trans-unit id="3c274408a7815b4769a808e5cd01a86c5b3930d3" translate="yes" xml:space="preserve">
          <source>Protecting Against Exceptions</source>
          <target state="translated">防范例外情况</target>
        </trans-unit>
        <trans-unit id="cc6e672ee6612bec71630926ee21e523510d4fc4" translate="yes" xml:space="preserve">
          <source>Reference : 
&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/a&gt; 
Thanks to Andre for pointing out this question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参考：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 感谢Andre指出了这个问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4d88eed28dd1376cc40fd170b9bfe77d1d02da0" translate="yes" xml:space="preserve">
          <source>Reference Counting</source>
          <target state="translated">参考资料计算</target>
        </trans-unit>
        <trans-unit id="7fd5474cfc1ade935cc5c546e88ea9b67e4d64c6" translate="yes" xml:space="preserve">
          <source>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</source>
          <target state="translated">当你的对象的生命周期要复杂得多,并且不直接与某一段代码或另一个对象绑定在一起时,参考计数指针就非常有用。</target>
        </trans-unit>
        <trans-unit id="08784d3c2d27ac259ff9d07cfc06917a9d5a0f38" translate="yes" xml:space="preserve">
          <source>References : 
    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.</source>
          <target state="translated">引用。它们基本上可以被看作是 const 指针,即一个指针,它是 const 的,不能用更好的语法移动。</target>
        </trans-unit>
        <trans-unit id="4bed4ff02087a38f1b95579b7416fac0a1027a61" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;When is std::weak_ptr useful?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参见：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: weak_ptr什么时候有用？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5251271034126a1a5c2548bc2290d5d6cd1e15d8" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;What are the differences between a pointer variable and a reference variable in C++?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++中的指针变量和引用变量之间有什么区别？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="06b60eabd9ac929a849b1c545034616a52874ae8" translate="yes" xml:space="preserve">
          <source>Small intro is available on page &lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;Smart Pointers - What, Why, Which?&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可在&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针-什么，为什么，哪个&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;页面上找到小型介绍&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eddd0ee6c00b8b7b07f4aa1533cf74d53674f39b" translate="yes" xml:space="preserve">
          <source>Smart Pointers are those where you don't have to worry about Memory De-Allocation, Resource Sharing and Transfer.</source>
          <target state="translated">智能指针是指那些你不用担心内存去分配、资源共享和转移的问题。</target>
        </trans-unit>
        <trans-unit id="04467054ec546b1c0315c4cfac233385593e4375" translate="yes" xml:space="preserve">
          <source>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you &lt;em&gt;really&lt;/em&gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;智能指针应优于原始指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您觉得需要使用指针（首先考虑是否&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确实&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要使用指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），则通常希望使用智能指针，因为这可以缓解原始指针的许多问题，主要是忘记删除对象和泄漏内存。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e25c6c59bcb6d66abe3c35be9cc4fddb4b2b9bca" translate="yes" xml:space="preserve">
          <source>Subject is covered in depth in book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&quot;C++ Templates: The Complete Guide&quot; by David Vandevoorde, Nicolai M. Josuttis&lt;/a&gt;, chapter Chapter 20. Smart Pointers.
Some topics covered:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;David Vandevoorde的《 C ++模板：完整指南》&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一书在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nicolai M. Josuttis的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第20章&amp;ldquo;智能指针&amp;rdquo;中进行了详细介绍。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;涵盖了一些主题：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1de633672e7627dbf70739243d0b87a6dc17bb" translate="yes" xml:space="preserve">
          <source>The existing answers are good but don't cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.</source>
          <target state="translated">现有的答案很好,但没有涵盖当智能指针不是你所要解决的问题的(完整的)答案时该怎么做。</target>
        </trans-unit>
        <trans-unit id="b06ceb1cd65ed156e62d8ecd9eab78c66e613029" translate="yes" xml:space="preserve">
          <source>The most commonly-used smart pointers are &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; (or &lt;code&gt;boost::shared_ptr&lt;/code&gt;), and, less commonly, &lt;code&gt;std::auto_ptr&lt;/code&gt;. I recommend regular use of &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最常用的智能指针是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），以及&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我建议定期使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97b533d7bfbeb88b5d7616af5826194991855a7f" translate="yes" xml:space="preserve">
          <source>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt;&lt;code&gt;boost::scoped_ptr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用中最简单的策略涉及智能指针包装器对象的范围，例如通过&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt; &lt;code&gt;boost::scoped_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d47eb61584acb71b110726e0b95e16a13f3cc6" translate="yes" xml:space="preserve">
          <source>There is one drawback to reference counted pointers &amp;mdash; the possibility of creating a dangling reference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用计数的指针有一个缺点-可能创建悬挂的引用：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7cf9d335ee541a055c37f36657dc1e6a480c449d" translate="yes" xml:space="preserve">
          <source>There was also &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt;. It was very much like a scoped pointer, except that it also had the &quot;special&quot; dangerous ability to be copied &amp;mdash; which also unexpectedly transfers ownership.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它非常像作用域指针，不同之处在于它还具有&amp;ldquo;特殊&amp;rdquo;的危险能力，可被复制-还会意外地转移所有权。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10dc26ca1fd5731e91d37edb3bbff8ef030a4f4" translate="yes" xml:space="preserve">
          <source>These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.</source>
          <target state="translated">这些只是一个个的线性描述,可以根据需要使用,更多的细节和例子可以看Boost的文档。</target>
        </trans-unit>
        <trans-unit id="074f5297a4fba1ef7bfeb2429c1ef13d61bea37b" translate="yes" xml:space="preserve">
          <source>They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track.</source>
          <target state="translated">它们保存着内存地址到内存中的一个位置。使用时要谨慎,因为程序变得复杂,难以跟踪。</target>
        </trans-unit>
        <trans-unit id="9432b51535de91f29d61abdc8f193678d301d5bc" translate="yes" xml:space="preserve">
          <source>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个答案很旧，因此描述了当时的&amp;ldquo;好&amp;rdquo;，这是Boost库提供的智能指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从C ++ 11开始，标准库提供了足够的智能指针类型，因此您应该赞成使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3fd31e33e7e71dba6afa758f5ddaa23fd6413cc" translate="yes" xml:space="preserve">
          <source>This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:</source>
          <target state="translated">该类实现了一个指向X类型对象的智能指针,该对象本身位于堆上。下面是如何使用它。</target>
        </trans-unit>
        <trans-unit id="c3acb92908f60dd2ddfb231908946d7977340ae6" translate="yes" xml:space="preserve">
          <source>To change the object pointed to by the unique ptr , use move semantics</source>
          <target state="translated">要改变由唯一的ptr所指向的对象,请使用移动语义。</target>
        </trans-unit>
        <trans-unit id="80ec759771be05f92f85c7d934d53b16a77673fa" translate="yes" xml:space="preserve">
          <source>To work around this problem, both Boost and C++11 have defined a &lt;code&gt;weak_ptr&lt;/code&gt; to define a weak (uncounted) reference to a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要变通解决此问题，Boost和C ++ 11都定义了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来定义对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的弱（未计数）引用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18f22cb2e33fe36506262132cc985d5cd594ea3d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您想从多个位置引用对象时，请&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且在所有这些引用都消失之前，不希望对象被取消分配。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d62e1c7ca9f6bac0498ed49f33b2dd9b90497ae4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt; when you don't intend to hold multiple references to the same object. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您不想保留对同一对象的多个引用时，请&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，将其用作指向内存的指针，该内存在进入某些范围时被分配，而在退出范围时被取消分配。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89b90755704062fcad6a5106c9e29a719bef4c5e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate (so they'll just note the object is gone when you try to dereference).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您确实想从多个位置引用对象时，请&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;－对于可以忽略和取消分配的引用，这些引用可以忽略并取消分配（因此，它们仅表示在尝试取消引用时该对象已消失）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bb07c28eb795708a8cc90a338886a7431582ee9" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one</source>
          <target state="translated">什么是智能指针,我应该在什么时候使用智能指针?</target>
        </trans-unit>
        <trans-unit id="8d779c02f29f56174f222fe34fb2a12b36815ca5" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one?</source>
          <target state="translated">什么是智能指针,我应该在什么时候使用智能指针?</target>
        </trans-unit>
        <trans-unit id="72dca932f0f35f4b1af9967ff79dc06b4b558df6" translate="yes" xml:space="preserve">
          <source>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</source>
          <target state="translated">使用原始指针,当对象不再有用时,程序员必须明确地销毁该对象。</target>
        </trans-unit>
        <trans-unit id="7c8bd33fd1a098972b52263748dc1191e62414cf" translate="yes" xml:space="preserve">
          <source>You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.</source>
          <target state="translated">你可以很好地使用这些指针,就像Java中的任何分配方式一样。在java中,Garbage Collector就能完成这个任务,而在智能指针中,这个任务是由Destructors完成的。</target>
        </trans-unit>
        <trans-unit id="a60c5ae076041d7c822b45b7033064048db8f570" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;not&lt;/em&gt; want to use a smart pointer when:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你可能&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;希望使用智能指针时：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
