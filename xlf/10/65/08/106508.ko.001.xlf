<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/106508">
    <body>
      <group id="106508">
        <trans-unit id="af2e8e09e40e9f539ab8da751affb13a10ba4eec" translate="yes" xml:space="preserve">
          <source>... the pointer shouldn't actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 포인터는 실제로 데이터를 소유해서는 안됩니다. 즉, 데이터를 사용하고있을 때 참조하는 기능에서 살아남기를 원합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4744e75c09f437c395d9d10e5ca53018fc22030" translate="yes" xml:space="preserve">
          <source>... the smart pointer isn't itself going to be destroyed at some point. You don't want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won't be explicitly deleted).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 스마트 포인터 자체가 어느 시점에서 파괴되지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동적으로 할당되었지만 명시 적으로 삭제되지 않는 객체와 같이 절대로 파괴되지 않는 메모리에 저장하고 싶지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7abe7f7009507b420472f008cf135a3361a38a02" translate="yes" xml:space="preserve">
          <source>... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counting&lt;/a&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 두 스마트 포인터가 같은 데이터를 가리킬 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(그러나 그것을 처리 할 똑똑한 포인터조차 있습니다 ... &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 카운트&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b3456d375c6b7456d5c4bc19041b1f3e7159035" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Raw pointers&lt;/strong&gt; :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원시 포인터&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c05ec50cd607baeca2e3d1f218f43eaa3fe20dc" translate="yes" xml:space="preserve">
          <source>3) &lt;strong&gt;Smart Pointers&lt;/strong&gt; : { &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; }</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : { &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; }&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5a0658a851943e0a2cbffdefa181eb111a1072c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;garbage collection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가비지 수집&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4b51566876fb4532e007f30a397e20ccf5f7b334" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;Resource Acquisition Is Initialization&lt;/a&gt; (This is frequently used for exception-safe resource management in C++)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자원 획득이 초기화 됨&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (C ++에서 예외 안전 자원 관리에 자주 사용됨)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29e3f25d900a39e1908f817e7b69b107c13bb24c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;Smart pointer&lt;/a&gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 자동 메모리 할당 해제, 참조 횟수 등과 같은 몇 가지 추가 기능이있는 포인터와 같은 유형입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f616381ac60ee4dc0c8941b5d68506530ee64337" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;This stack overflow question&lt;/a&gt; regarding data ownership</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 소유권에 관한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 스택 오버 플로우 질문&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1867be1ad1af5dc650167a8cf0efa432ce165e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is another reference counting pointer. It provides better performance than &lt;code&gt;shared_ptr&lt;/code&gt;, but requires the type &lt;code&gt;T&lt;/code&gt; to provide its own reference counting mechanism.</source>
          <target state="translated">&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 다른 참조 카운팅 포인터입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보다 나은 성능 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을 제공하지만 자체 참조 계산 메커니즘을 제공 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하려면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 유형이 필요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0d5f87331c2eecb842ccaae6c19f1a55d8ea413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;scoped_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scoped_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 비슷하지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 배열의 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4022aeb6f81b4906c6ab25a8ce758c7901bdd9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.</source>
          <target state="translated">&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 범위를 벗어날 때 자동으로 삭제되는 포인터입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할당이 불가능합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b3ae49c2084013ca2cd8045ab6949f88e0a1056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;shared_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 비슷하지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 배열의 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70c670daab27ba020ed4b3008ffa5f7e50646ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer to &lt;code&gt;T&lt;/code&gt; using a reference count to determine when the object is no longer needed.</source>
          <target state="translated">&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체가 더 이상 필요하지 않은 시점을 결정하기 위해 참조 횟수를 사용하는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; 에&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 포인터 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85b44869045deedea760f2af227ba51e6ab34649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&lt;/code&gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be &quot;passed across DLL boundaries&quot; (the common nightmare case if different &lt;code&gt;libc&lt;/code&gt;s are used between your code and the DLLs).</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; 의는&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 매우 다양하고 객체가 &quot;DLL 경계를 넘어 전달&quot;해야하는 경우를 포함 처리 시나리오의 큰 다양성, (다른 경우 일반적인 악몽 케이스와 거래 인 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;libc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의이 코드 및 DLL을 사이에 사용된다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aaed4c81152732868d9d49d18694435ce025dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 객체의 수명을 특정 코드 블록에 묶거나 다른 객체 내에 멤버 데이터로 포함한 경우 다른 객체의 수명에 유용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체는 포함하는 코드 블록이 종료 될 때까지 또는 포함하는 객체 자체가 파괴 될 때까지 존재합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35295afc323a8764cefd17b5bdc018ac29b84a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a weak pointer, working in conjunction with &lt;code&gt;shared_ptr&lt;/code&gt; to avoid circular references.</source>
          <target state="translated">&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;순환 참조를 피하기 위해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 함께 작동하는 약한 포인터 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef33adbf278b78fced043861257bfe060e159b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But which smart pointer should I use in which of those cases?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 어떤 경우에 어떤 스마트 포인터를 사용해야합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e761a3027e25048706976b6db69a52b4e01b467d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey, I didn't ask which one to use!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이봐 요, 어느 쪽을 사용할 것인지 묻지 않았습니다!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bfc5096d48f06748da1555aa92cde89f2a6341c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It was deprecated in C++11 and removed in C++17&lt;/strong&gt;, so you shouldn't use it.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11에서는 더 이상 사용되지 않으며 C ++ 17&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서는 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;제거되었으므로&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용해서는 안됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05d6ce56a57f8c848f648042c5448f4a8a610d89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OLD ANSWER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오래된 답변&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d1e940c49d65579e31f8af44e892beff4f142c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shared Pointer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공유 포인터&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="005e906d718b91c7b79edf678d3c0fc87b1f5349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So when should I use regular pointers then?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇다면 언제 정규 포인터를 사용해야합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971abf8af0ed9ddec060bfca3124cf49cd8504de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique Pointer :&lt;/strong&gt; 
    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Unique Pointer :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 독점 소유권이있는 가벼운 스마트 포인터. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터가 객체를 공유하지 않고 포인터가 고유 한 객체를 가리킬 때 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46c311c3b22afb68eb5ae8c85ce8bb5d73bc761f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Weak Pointer :&lt;/strong&gt; 
    Helps deal with cyclic reference which arises when using Shared Pointer
    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;약한 포인터 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 공유 포인터를 사용할 때 발생하는 순환 참조 처리 도움 두 개의 공유 포인터로 가리키는 두 개의 객체가 있고 서로 공유 포인터를 가리키는 내부 공유 포인터가 있으면 순환 참조가 있고 객체는 그렇지 않습니다. 공유 포인터가 범위를 벗어나면 삭제됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 해결하려면 내부 멤버를 shared_ptr에서 weak_ptr로 변경하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주 : 약한 포인터가 가리키는 요소에 액세스하려면 lock ()을 사용하여 weak_ptr을 리턴합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3b0f949d4345488039e4183458ea4810d7099f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a smart pointer?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터 란 무엇입니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6468525fccb4ecf5e47ed8487dee96a37bf52f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should I use one?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언제 사용해야합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="660849bfef63c2647882bdc5da8447c8dc6b51e5" translate="yes" xml:space="preserve">
          <source>A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; will not work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;const 데이터 유형 T에 대한 const 포인터 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 포인터를 이동할 수 없으며 데이터 유형 포인터를 포인터로 변경할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작동 안 할 것이다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="408b455a6c631e6b53e0f1209d0361f9b950a58c" translate="yes" xml:space="preserve">
          <source>A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie &lt;code&gt;*ptr2 = 19&lt;/code&gt; will work but &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; etc will not work. Read backwards : const pointer to a type T</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 유형 T에 대한 const 포인터 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의미는 포인터를 이동할 수 없지만 포인터가 가리키는 값을 변경할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr2 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 작동하지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 작동합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ptr2--&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 등이 작동하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뒤로 읽기 : 유형 T에 대한 const 포인터&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0895997fb22fe8c3fbe3470dd02611de7817af76" translate="yes" xml:space="preserve">
          <source>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last &quot;reference&quot; to the object is destroyed, the object is deleted. This policy is implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보다 복잡한 스마트 포인터 정책에는 포인터를 참조하는 참조가 포함됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터를 복사 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체에 대한 마지막 &quot;참조&quot;가 삭제되면 객체가 삭제됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 정책은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의해 구현됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85cc9f1d1b7b72b303b1a6932cad97df1a8bf8af" translate="yes" xml:space="preserve">
          <source>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비교에 의한 스마트 포인터는 객체가 파괴 될 때의 정책을 정의합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여전히 객체를 생성해야하지만 더 이상 객체를 파괴 할 염려가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a8ed7f449dc88e468a305cb01873d71c0dda80a" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 가리키는 객체의 수명을 관리하기 위해 '원시'(또는 '베어') C ++ 포인터를 래핑하는 클래스입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 스마트 포인터 유형은 없지만 실제 포인터를 모두 원시 포인터로 추상화하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c2cc5504b9d575fdc1765bc51e43e4e44d93de47" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart point&amp;rsquo;s life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 클래스, 일반 포인터의 래퍼입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반 포인터와 달리 스마트 포인트의 수명은 기준 카운트 (스마트 포인터 개체가 몇 번 할당되었는지)를 기준으로합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 스마트 포인터가 다른 포인터에 할당 될 때마다 내부 참조 수에 플러스가 더해집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 객체가 범위를 벗어날 때마다 참조 카운트에서 마이너스를 뺍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9356d827d5b266f397c77242a36f9ee76af46143" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 포인터처럼 작동하는 객체이지만 구성, 파괴, 복사, 이동 및 역 참조에 대한 제어 기능을 추가로 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="150ff3c7e30d567459ce409ef2d43cf92945b361" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don't respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 일반 포인터처럼 작동하고 모양과 느낌이 있지만 더 많은 기능을 제공하는 개체입니다. C ++에서 스마트 포인터는 포인터를 캡슐화하고 표준 포인터 연산자를 재정의하는 템플릿 클래스로 구현됩니다. 일반 포인터보다 많은 장점이 있습니다. 그것들은 널 포인터 또는 힙 객체에 대한 포인터로 초기화되도록 보장됩니다. 널 포인터를 통한 간접 점검이 점검됩니다. 삭제할 필요가 없습니다. 객체에 대한 마지막 포인터가 사라지면 객체가 자동으로 해제됩니다. 이 스마트 포인터의 중요한 문제 중 하나는 일반 포인터와 달리 상속을 존중하지 않는다는 것입니다. 스마트 포인터는 다형성 코드에 매력적이지 않습니다. 아래는 스마트 포인터 구현에 대한 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b68b6f3a8975f96f1b6b93c4634bedb35aff4ddb" translate="yes" xml:space="preserve">
          <source>A smart pointer is like a regular (typed) pointer, like &quot;char*&quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using &quot;-&amp;gt;&quot;, but not if you need an actual pointer to the data. For that, you can use &quot;&amp;amp;*ptr&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 포인터 자체가 범위를 벗어날 때를 가리키는 점을 제외하고 &quot;char *&quot;와 같은 일반 (유형) 포인터와 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;-&amp;gt;&quot;를 사용하여 일반 포인터처럼 사용할 수 있지만 데이터에 대한 실제 포인터가 필요한 경우에는 사용할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 위해 &quot;&amp;amp; * ptr&quot;을 사용할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1471a71c5e4eb0de52fc485e12e309fb87dc2eee" translate="yes" xml:space="preserve">
          <source>Additionally, the C++ standard library provides three smart pointers; &lt;code&gt;std::unique_ptr&lt;/code&gt; for unique ownership, &lt;code&gt;std::shared_ptr&lt;/code&gt; for shared ownership and &lt;code&gt;std::weak_ptr&lt;/code&gt;. &lt;code&gt;std::auto_ptr&lt;/code&gt; existed in C++03 but is now deprecated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 C ++ 표준 라이브러리는 세 가지 스마트 포인터를 제공합니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 고유의 소유권, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 공유 소유권에 대한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 C ++ 03에 존재하지만 더 이상 사용되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f173ba927487f1d4cb291eff83de845b351faeb8" translate="yes" xml:space="preserve">
          <source>Ah, but you really wanted to, admit it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아, 그러나 당신은 정말로 그것을 인정하고 싶었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe19f580daa87cc25b870e1baa16fab7e5c59b15" translate="yes" xml:space="preserve">
          <source>Among other things (explained well in other answers) using a smart pointer is a possible solution to &lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;How do we use a abstract class as a function return type?&lt;/a&gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is &quot;what do you really mean?&quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;boost pointer container library&lt;/a&gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don't give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a &lt;em&gt;value&lt;/em&gt; to some form of &lt;em&gt;reference&lt;/em&gt;. If you really needed copy you may need to add more boilerplate &quot;idiom&quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like &lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;Adobe Poly&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;Boost.TypeErasure&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터를 사용하는 다른 것들 (다른 답변에서 잘 설명되어 있음) 중에서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추상 클래스를 함수 반환 유형으로 어떻게 사용합니까?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 질문의 복제본으로 표시되었습니다. 그러나 C ++에서 추상 (또는 실제로는) 기본 클래스를 반환 유형으로 지정하려는 유혹을받는 첫 번째 질문은 &quot;정말 무엇을 의미합니까?&quot;입니다. &lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부스트 포인터 컨테이너 라이브러리&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 문서에서 C ++의 관용적 객체 지향 프로그래밍 (및 다른 언어와 다른 점)에 대한 좋은 논의가 있습니다 (추가 참조).&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요약하면 C ++에서는 소유권에 대해 생각해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떤 스마트 포인터가 도움이 되나 유일한 솔루션은 아니거나 항상 완전한 솔루션 (다형성 사본을 제공하지는 않음)이며 항상 인터페이스에 노출하려는 솔루션이 아닙니다 (함수 리턴은 끔찍하게 들립니다) 인터페이스처럼). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 참조를 반환하는 것으로 충분할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나이 모든 경우 (스마트 포인터, 포인터 컨테이너 또는 단순히 참조 반환) 반환 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 어떤 형태의 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조로 변경했습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 복사가 필요한 경우 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adobe Poly&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 라이브러리를 사용하여 상용구 &quot;이디엄&quot;을 더 추가하거나 C ++의 관용적 OOP를 넘어보다 일반적인 다형성으로 이동해야 할 수도 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78ca5dca4761808a7b5e7382ebf5f698b2cd2fd" translate="yes" xml:space="preserve">
          <source>Another convenient type is &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 편리한 유형은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 참조 카운트를 구현하고 객체에 대한 참조가 남아 있지 않을 때 메모리를 자동으로 할당 해제합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 통해 메모리 누수를 방지하고 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RAII&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 구현하는 데 쉽게 사용할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf3a668061d4ad283ac2fa86679b6f3b0791cf93" translate="yes" xml:space="preserve">
          <source>Another possibility is creating circular references:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 가능성은 순환 참조를 작성하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64f289d2f4648dd5b3726612c027f5c92f4a2aaa" translate="yes" xml:space="preserve">
          <source>Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동 포인터는 비슷해 보이지만 스마트 포인터와 완전히 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동 포인터 객체가 변수 범위를 벗어날 때마다 리소스를 할당 해제하는 편리한 클래스입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어느 정도까지는 (동적으로 할당 된 메모리에 대한) 포인터가 스택 변수 (컴파일 시간에 정적으로 할당 됨)와 유사하게 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0a8c0f929f31db86af22e061262a8478f89bf858" translate="yes" xml:space="preserve">
          <source>Concurrent Counter Access</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동시 카운터 액세스&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e6bf77b4e6823d55153852cfedb73269bb8fdd72" translate="yes" xml:space="preserve">
          <source>Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체가 삭제되면 소멸자에 특별한 코드없이 소유 한 모든 데이터도 삭제됩니다 (소멸자가 가상이어야합니다. 거의 항상 좋은 일입니다) .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d315ffe38f74e2bbd3649007ed92bd0fcb339294" translate="yes" xml:space="preserve">
          <source>Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:
A smart pointer is simply a class that overloads the &lt;code&gt;-&amp;gt;&lt;/code&gt;  and &lt;code&gt;*&lt;/code&gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.
&lt;code&gt;shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Chris, Sergdev 및 Llyod가 제공 한 정의가 정확합니다. 나는 인생을 단순하게 유지하기 위해 더 단순한 정의를 선호합니다. 스마트 포인터는 단순히 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 오버로드하는 클래스입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이는 객체가 의미 적으로 포인터처럼 보이지만 참조 횟수 계산, 자동 소멸 등을 포함하여 더 멋진 작업을 수행 할 수 있음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이면 충분하지만 자체 고유 한 작은 특성이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17a6e952cfd054bf86a0bff2ef3758ccb138822a" translate="yes" xml:space="preserve">
          <source>Destruction and Deallocation</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파기 및 할당 해제&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62c819d637d29a2f4f19cf04f89b693e7e7a7ca3" translate="yes" xml:space="preserve">
          <source>Don't use the &lt;code&gt;boost::&lt;/code&gt; smart pointers or &lt;code&gt;std::auto_ptr&lt;/code&gt; except in special cases which you can read up on if you must.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특별한 경우를 제외하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; smart pointers 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하지 마십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f3d3aad5c807bb24d88407fd715dd4bcadc4a87" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; provides the following smart pointer implementations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 다음과 같은 스마트 포인터 구현을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6213441eda5b33d29bac7b15eafcedc34217804c" translate="yes" xml:space="preserve">
          <source>Here is the Link for similar answers : &lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비슷한 답변에 대한 링크는 다음과 같습니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="235448e1559e2c6a2d98c037e982857e78ec5708" translate="yes" xml:space="preserve">
          <source>Here's a simple answer for these days of modern C++:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요즘 현대 C ++에 대한 간단한 대답은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8a930b4fb10a4df4e7af642f22172143cf9dfa25" translate="yes" xml:space="preserve">
          <source>Holder Limitations</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;홀더 제한&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db3373933d2b26d58bd3267b9cb9ff92de1de43a" translate="yes" xml:space="preserve">
          <source>Holders, (note, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt; is implementation of such type of smart pointer)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;홀더 (참고 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: auto_ptr&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 이러한 유형의 스마트 포인터 구현입니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8efc2fcb0e64352073d01410371f9b29588ff6a8" translate="yes" xml:space="preserve">
          <source>Implemented using reference counting to keep track of how many &quot; things &quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. 
This gets rid of the headache of having to delete objects which you have allocated using new.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터로 가리키는 객체를 가리키는 &quot;사물&quot;수를 추적하기 위해 참조 횟수를 사용하여 구현되었습니다. 이 수가 0이되면 객체는 자동으로 삭제됩니다. 즉, 객체를 가리키는 모든 share_ptr이 범위를 벗어나면 객체가 삭제됩니다. 이것은 new를 사용하여 할당 한 객체를 삭제 해야하는 두통을 없애줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1d841b0ff2602990af565bd1846dd9e8eba0720" translate="yes" xml:space="preserve">
          <source>In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 조각의 소유권을 추적하고 할당 또는 할당 해제하는 코드; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 종종 이러한 작업을 명시 적으로 수행 할 필요성을 줄여줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d2ab2c7ea1b9e3dd5c0238fa3501e1a6f018af5" translate="yes" xml:space="preserve">
          <source>In computer science, a smart pointer
  is an abstract data type that
  simulates a pointer while providing
  additional features, such as automatic
  garbage collection or bounds checking.
  These additional features are intended
  to reduce bugs caused by the misuse of
  pointers while retaining efficiency.
  Smart pointers typically keep track of
  the objects that point to them for the
  purpose of memory management. The
  misuse of pointers is a major source
  of bugs: the constant allocation,
  deallocation and referencing that must
  be performed by a program written
  using pointers makes it very likely
  that some memory leaks will occur.
  Smart pointers try to prevent memory
  leaks by making the resource
  deallocation automatic: when the
  pointer to an object (or the last in a
  series of pointers) is destroyed, for
  example because it goes out of scope,
  the pointed object is destroyed too.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴퓨터 과학에서 스마트 포인터는 자동 가비지 수집 또는 범위 검사와 같은 추가 기능을 제공하면서 포인터를 시뮬레이션하는 추상 데이터 형식입니다. 이러한 추가 기능은 포인터의 오용으로 인한 버그를 줄이고 효율성을 유지하기위한 것입니다. 스마트 포인터는 일반적으로 메모리 관리를 위해 개체를 가리키는 개체를 추적합니다. 포인터의 오용은 버그의 주요 원인입니다. 포인터를 사용하여 작성된 프로그램이 수행해야하는 지속적인 할당, 할당 해제 및 참조는 일부 메모리 누수가 발생할 가능성이 높습니다. 스마트 포인터는 리소스 할당을 자동으로 만들어 메모리 누수를 방지하려고합니다. 개체에 대한 포인터 (또는 일련의 포인터에서 마지막)가 파괴되면,예를 들어, 범위를 벗어나기 때문에 뾰족한 물체도 파괴됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b470b0b9a364b2fa432c27c2e23748d4f2eeebfb" translate="yes" xml:space="preserve">
          <source>It is useful for:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음에 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="269dd3751517ddfbd50cdb4301abe2ab83b607fc" translate="yes" xml:space="preserve">
          <source>It's a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also &lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;the more detailed definition on Wikipedia&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터처럼 값을 사용할 수 있지만 자동 메모리 관리의 추가 기능을 제공하는 유형입니다. 스마트 포인터를 더 이상 사용하지 않으면 가리키는 메모리가 할당 해제됩니다 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia에 대한 자세한 정의&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 참조 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1508c0dbd75f276250ef468cde22c1eb920a2bdb" translate="yes" xml:space="preserve">
          <source>Let T be a class in this tutorial 
Pointers in C++ can be divided into 3 types :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 튜토리얼에서 T를 클래스로 사용하자 C ++의 포인터는 3 가지 유형으로 나눌 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b792a21ee56ff623795e7a57d358d84ec527459b" translate="yes" xml:space="preserve">
          <source>Like other overloaded operators, p will behave like a regular pointer,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 오버로드 연산자와 마찬가지로 p는 일반 포인터처럼 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="455cc282d56455c6f5333fab2462998a571616cc" translate="yes" xml:space="preserve">
          <source>Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 스마트 포인터는 포인터 대 객체의 처리를 처리합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 이상 수동으로 객체를 폐기 할 필요가 없기 때문에 매우 편리합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7314c02622627b7ccb9b4f584bc913fff6ad6735" translate="yes" xml:space="preserve">
          <source>Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분 메모리 소유권을 모르는 코드입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 일반적으로 다른 곳에서 포인터를 가져오고 할당하거나 할당을 해제하지 않고 실행보다 오래 포인터 포인터를 저장하지 않는 함수에 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26e6d181ff99160909b595478121f08dd076edb4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::unique_ptr&lt;/code&gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인스턴스를 복사 할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 포인터가 여러 번 잘못 삭제되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 호출하는 다른 함수에 대한 참조를 전달할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc55faaac98b84550c0f52f207b38f5a9b210b5d" translate="yes" xml:space="preserve">
          <source>Objects that must be allocated with new, but that you'd like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새 객체로 할당해야하지만 해당 스택의 객체와 동일한 수명을 유지하려는 객체. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체가 스마트 포인터에 할당 된 경우 프로그램이 해당 기능 / 블록을 종료하면 삭제됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f751c9fbb24aa2c23e6e65e987bb3d5bb9f738ce" translate="yes" xml:space="preserve">
          <source>One can implement one's own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하나는 자신의 스마트 포인터를 구현할 수 있지만 많은 라이브러리는 각각 다른 장점과 단점이있는 스마트 포인터 구현을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="87b543505cd555c6851c754dbaa29544fec9d8de" translate="yes" xml:space="preserve">
          <source>One of the simple smart-pointer type is &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt; (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단한 스마트 포인터 유형 중 하나는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (C ++ 표준의 20.4.5 장)이며, 메모리가 범위를 벗어날 때 자동으로 할당을 해제하고 예외가 발생할 때 간단한 포인터 사용보다 더 강력합니다. 융통성 있는.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deac6c8d86314111051ac297a8e90d729d2fc59e" translate="yes" xml:space="preserve">
          <source>Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie &lt;code&gt;*ptr1 = 19&lt;/code&gt; ; will not work. But you can move the pointer. ie &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; ;  etc will work.
Read backwards : pointer to type T which is const</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;const 인 데이터 형식 T를 가리키는 포인터. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터를 사용하여 데이터 유형을 변경할 수 없음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr1 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작동 안 할 것이다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 포인터를 움직일 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;등이 작동합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뒤로 읽으십시오 : const 인 타입 T에 대한 포인터&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5091a6ac607a66d605572c2f1f01fdeddfb5810" translate="yes" xml:space="preserve">
          <source>Pointers with const data or address { Read backwards }</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;const 데이터 또는 주소를 가진 포인터 {뒤로 읽기}&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3c274408a7815b4769a808e5cd01a86c5b3930d3" translate="yes" xml:space="preserve">
          <source>Protecting Against Exceptions</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예외로부터 보호&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc6e672ee6612bec71630926ee21e523510d4fc4" translate="yes" xml:space="preserve">
          <source>Reference : 
&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/a&gt; 
Thanks to Andre for pointing out this question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 질문을 지적 해 주신 Andre에게 감사드립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4d88eed28dd1376cc40fd170b9bfe77d1d02da0" translate="yes" xml:space="preserve">
          <source>Reference Counting</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 카운팅&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7fd5474cfc1ade935cc5c546e88ea9b67e4d64c6" translate="yes" xml:space="preserve">
          <source>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 카운트 포인터는 객체의 수명이 훨씬 더 복잡하고 특정 코드 섹션이나 다른 객체에 직접 연결되지 않은 경우에 매우 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="08784d3c2d27ac259ff9d07cfc06917a9d5a0f38" translate="yes" xml:space="preserve">
          <source>References : 
    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 : 본질적으로 const 포인터, 즉 const이고 더 나은 구문으로 이동할 수없는 포인터와 같을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bed4ff02087a38f1b95579b7416fac0a1027a61" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;When is std::weak_ptr useful?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: weak_ptr은 언제 유용합니까?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5251271034126a1a5c2548bc2290d5d6cd1e15d8" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;What are the differences between a pointer variable and a reference variable in C++?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에서 포인터 변수와 참조 변수의 차이점은 무엇입니까?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="06b60eabd9ac929a849b1c545034616a52874ae8" translate="yes" xml:space="preserve">
          <source>Small intro is available on page &lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;Smart Pointers - What, Why, Which?&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터-무엇, 왜, 어느 쪽에서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 작은 소개를 사용할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eddd0ee6c00b8b7b07f4aa1533cf74d53674f39b" translate="yes" xml:space="preserve">
          <source>Smart Pointers are those where you don't have to worry about Memory De-Allocation, Resource Sharing and Transfer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 메모리 할당 해제, 리소스 공유 및 전송에 대해 걱정할 필요가없는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04467054ec546b1c0315c4cfac233385593e4375" translate="yes" xml:space="preserve">
          <source>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you &lt;em&gt;really&lt;/em&gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터는 원시 포인터보다 선호되어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포인터를 사용해야한다고 생각한다면 ( &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 먼저 고려하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 일반적으로 스마트 포인터를 사용하면 원시 포인터의 많은 문제를 해결할 수 있습니다. 주로 객체 삭제 및 메모리 누수를 잊어 버립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e25c6c59bcb6d66abe3c35be9cc4fddb4b2b9bca" translate="yes" xml:space="preserve">
          <source>Subject is covered in depth in book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&quot;C++ Templates: The Complete Guide&quot; by David Vandevoorde, Nicolai M. Josuttis&lt;/a&gt;, chapter Chapter 20. Smart Pointers.
Some topics covered:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주제는 책 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;C ++ 템플릿 : 완전한 안내서&quot;, David Vandevoorde, Nicolai M. Josuttis&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , Chapter 20. Smart Pointers &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 자세히 다루고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다루는 주제들 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1de633672e7627dbf70739243d0b87a6dc17bb" translate="yes" xml:space="preserve">
          <source>The existing answers are good but don't cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기존 답변은 훌륭하지만 스마트 포인터가 해결하려는 문제에 대한 (완전한) 답변이 아닌 경우 수행 할 작업은 다루지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b06ceb1cd65ed156e62d8ecd9eab78c66e613029" translate="yes" xml:space="preserve">
          <source>The most commonly-used smart pointers are &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; (or &lt;code&gt;boost::shared_ptr&lt;/code&gt;), and, less commonly, &lt;code&gt;std::auto_ptr&lt;/code&gt;. I recommend regular use of &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 일반적으로 사용되는 스마트 포인터는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )이며 덜 일반적으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 정기적으로 사용하는 것이 좋습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97b533d7bfbeb88b5d7616af5826194991855a7f" translate="yes" xml:space="preserve">
          <source>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt;&lt;code&gt;boost::scoped_ptr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용되는 가장 간단한 정책은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt; &lt;code&gt;boost::scoped_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의해 구현되는 스마트 포인터 래퍼 객체의 범위와 관련됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d47eb61584acb71b110726e0b95e16a13f3cc6" translate="yes" xml:space="preserve">
          <source>There is one drawback to reference counted pointers &amp;mdash; the possibility of creating a dangling reference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계산 된 포인터를 참조하는 데는 한 가지 단점이 있습니다. 매달려있는 참조를 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7cf9d335ee541a055c37f36657dc1e6a480c449d" translate="yes" xml:space="preserve">
          <source>There was also &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt;. It was very much like a scoped pointer, except that it also had the &quot;special&quot; dangerous ability to be copied &amp;mdash; which also unexpectedly transfers ownership.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 도있었습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 &quot;특별한&quot;위험한 복사 기능을 가지고 있다는 점을 제외하고는 범위가 지정된 포인터와 매우 유사했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10dc26ca1fd5731e91d37edb3bbff8ef030a4f4" translate="yes" xml:space="preserve">
          <source>These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것들은 각각 하나의 선형 설명이며 필요에 따라 사용할 수 있습니다. 자세한 내용과 예를 들어 Boost 문서를 볼 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="074f5297a4fba1ef7bfeb2429c1ef13d61bea37b" translate="yes" xml:space="preserve">
          <source>They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 주소를 메모리 위치에 저장합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램을 추적하기가 복잡해 지므로주의해서 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9432b51535de91f29d61abdc8f193678d301d5bc" translate="yes" xml:space="preserve">
          <source>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 답변은 다소 오래되어 부스트 라이브러리에서 제공하는 현명한 포인터 인 당시의 '좋은 것'에 대해 설명합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11부터 표준 라이브러리는 충분한 스마트 포인터 유형을 제공하므로 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용을 선호해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3fd31e33e7e71dba6afa758f5ddaa23fd6413cc" translate="yes" xml:space="preserve">
          <source>This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 클래스는 X 유형의 객체에 대한 스마트 포인터를 구현합니다. 객체 자체는 힙에 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 방법은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3acb92908f60dd2ddfb231908946d7977340ae6" translate="yes" xml:space="preserve">
          <source>To change the object pointed to by the unique ptr , use move semantics</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고유 한 ptr이 가리키는 오브젝트를 변경하려면 move semantics를 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80ec759771be05f92f85c7d934d53b16a77673fa" translate="yes" xml:space="preserve">
          <source>To work around this problem, both Boost and C++11 have defined a &lt;code&gt;weak_ptr&lt;/code&gt; to define a weak (uncounted) reference to a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제를 해결하기 위해 Boost와 C ++ 11은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 정의하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; 에&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 약한 (계산되지 않은) 참조를 정의했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18f22cb2e33fe36506262132cc985d5cd594ea3d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 위치에서 객체를 참조하고 싶을 때 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오. 이러한 모든 참조가 사라질 때까지 객체를 할당 해제하지 마십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d62e1c7ca9f6bac0498ed49f33b2dd9b90497ae4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt; when you don't intend to hold multiple references to the same object. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한 객체에 대한 여러 참조를 보유하지 않으려면 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 일부 범위를 입력 할 때 할당되고 범위를 종료 할 때 할당이 해제되는 메모리에 대한 포인터에이를 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89b90755704062fcad6a5106c9e29a719bef4c5e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate (so they'll just note the object is gone when you try to dereference).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 장소에서 객체를 참조 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하려면 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bb07c28eb795708a8cc90a338886a7431582ee9" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터 란 무엇이며 언제 사용해야합니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d779c02f29f56174f222fe34fb2a12b36815ca5" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스마트 포인터 란 무엇이며 언제 사용해야합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="72dca932f0f35f4b1af9967ff79dc06b4b558df6" translate="yes" xml:space="preserve">
          <source>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원시 포인터를 사용하면 프로그래머는 더 이상 유용하지 않은 객체를 명시 적으로 파괴해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c8bd33fd1a098972b52263748dc1191e62414cf" translate="yes" xml:space="preserve">
          <source>You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java에서 할당이 작동하는 것과 유사한 방식으로 이러한 포인터를 매우 잘 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java Garbage Collector에서는 트릭을 수행하지만 Smart Pointers에서는 소멸자가 트릭을 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a60c5ae076041d7c822b45b7033064048db8f570" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;not&lt;/em&gt; want to use a smart pointer when:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 경우 스마트 포인터를 사용 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
