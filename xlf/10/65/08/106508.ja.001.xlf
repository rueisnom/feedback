<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/106508">
    <body>
      <group id="106508">
        <trans-unit id="af2e8e09e40e9f539ab8da751affb13a10ba4eec" translate="yes" xml:space="preserve">
          <source>... the pointer shouldn't actually own the data... i.e., when you are just using the data, but you want it to survive the function where you are referencing it.</source>
          <target state="translated">...ポインタは実際にはデータを所有するべきではありません...つまり、データを使用しているだけで、それを参照している関数を存続させたい場合です。</target>
        </trans-unit>
        <trans-unit id="c4744e75c09f437c395d9d10e5ca53018fc22030" translate="yes" xml:space="preserve">
          <source>... the smart pointer isn't itself going to be destroyed at some point. You don't want it to sit in memory that never gets destroyed (such as in an object that is dynamically allocated but won't be explicitly deleted).</source>
          <target state="translated">...スマートポインタは、それ自体がある時点で破棄されることはありません。破壊されることのないメモリの中に置かれることを望まないでしょう (例えば、動的に割り当てられているが明示的に削除されることのないオブジェクトのように)。</target>
        </trans-unit>
        <trans-unit id="7abe7f7009507b420472f008cf135a3361a38a02" translate="yes" xml:space="preserve">
          <source>... two smart pointers might point to the same data. (There are, however, even smarter pointers that will handle that... that is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counting&lt;/a&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 2つのスマートポインタが同じデータを指す場合があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（ただし、それを処理するよりスマートなポインターがあります...これは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照カウント&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と呼ばれ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b3456d375c6b7456d5c4bc19041b1f3e7159035" translate="yes" xml:space="preserve">
          <source>1) &lt;strong&gt;Raw pointers&lt;/strong&gt; :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1）&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生のポインタ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c05ec50cd607baeca2e3d1f218f43eaa3fe20dc" translate="yes" xml:space="preserve">
          <source>3) &lt;strong&gt;Smart Pointers&lt;/strong&gt; : { &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; }</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3）&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインター&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：{ &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#include &amp;lt;memory&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; }&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5a0658a851943e0a2cbffdefa181eb111a1072c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;garbage collection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ガベージコレクション&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4b51566876fb4532e007f30a397e20ccf5f7b334" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;Resource Acquisition Is Initialization&lt;/a&gt; (This is frequently used for exception-safe resource management in C++)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リソース取得は初期化です&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（これは、C ++での例外安全なリソース管理によく使用されます）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29e3f25d900a39e1908f817e7b69b107c13bb24c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;Smart pointer&lt;/a&gt; is a pointer-like type with some additional functionality, e.g. automatic memory deallocation, reference counting etc.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインター&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、自動メモリー割り当て解除、参照カウントなどのいくつかの追加機能を備えたポインターのようなタイプです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f616381ac60ee4dc0c8941b5d68506530ee64337" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;This stack overflow question&lt;/a&gt; regarding data ownership</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/94227/smart-pointers-or-who-owns-you-baby&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データの所有権に関する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このスタックオーバーフローの質問&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1867be1ad1af5dc650167a8cf0efa432ce165e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is another reference counting pointer. It provides better performance than &lt;code&gt;shared_ptr&lt;/code&gt;, but requires the type &lt;code&gt;T&lt;/code&gt; to provide its own reference counting mechanism.</source>
          <target state="translated">&lt;code&gt;intrusive_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、別の参照カウントポインターです。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;よりも優れたパフォーマンス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を提供しますが、独自の参照カウントメカニズムを提供するには&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;型が必要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0d5f87331c2eecb842ccaae6c19f1a55d8ea413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;scoped_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scoped_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のようである&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scoped_ptr&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、しかしのアレイの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4022aeb6f81b4906c6ab25a8ce758c7901bdd9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer automatically deleted when it goes out of scope. No assignment is possible.</source>
          <target state="translated">&lt;code&gt;scoped_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、スコープ外になると自動的に削除されるポインターです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;割り当てはできません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b3ae49c2084013ca2cd8045ab6949f88e0a1056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;shared_ptr&lt;/code&gt;, but for arrays of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_array&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;似&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ていますが、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;配列用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70c670daab27ba020ed4b3008ffa5f7e50646ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a pointer to &lt;code&gt;T&lt;/code&gt; using a reference count to determine when the object is no longer needed.</source>
          <target state="translated">&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;へのポインタである&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトが不要になった時を決定しないように参照カウントを使用して。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85b44869045deedea760f2af227ba51e6ab34649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_ptr&lt;/code&gt; is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be &quot;passed across DLL boundaries&quot; (the common nightmare case if different &lt;code&gt;libc&lt;/code&gt;s are used between your code and the DLLs).</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は非常に用途が広く、オブジェクトを「DLLの境界を越えて渡す」必要がある場合（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コードとDLLの間で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;異なる&lt;/font&gt;&lt;/font&gt; &lt;code&gt;libc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が使用される&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合の一般的な悪夢のような場合）を含む、さまざまな廃棄シナリオを扱い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aaed4c81152732868d9d49d18694435ce025dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt;s are useful when you want to tie the lifetime of the object to a particular block of code, or if you embedded it as member data inside another object, the lifetime of that other object. The object exists until the containing block of code is exited, or until the containing object is itself destroyed.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sは、オブジェクトの有効期間を特定のコードブロックに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関連付け&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たい場合、または別のオブジェクト内のメンバーデータとして埋め込んだ場合は、その他のオブジェクトの有効期間に役立ちます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトは、コードの包含ブロックが終了するまで、または包含オブジェクト自体が破棄されるまで存在します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35295afc323a8764cefd17b5bdc018ac29b84a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is a weak pointer, working in conjunction with &lt;code&gt;shared_ptr&lt;/code&gt; to avoid circular references.</source>
          <target state="translated">&lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は弱いポインタであり、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;循環参照を回避するために&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と連携して機能し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef33adbf278b78fced043861257bfe060e159b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But which smart pointer should I use in which of those cases?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、どの場合にどのスマートポインターを使用すればよいでしょうか。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e761a3027e25048706976b6db69a52b4e01b467d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hey, I didn't ask which one to use!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ねえ、どちらを使うべきか聞いてみませんでした！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bfc5096d48f06748da1555aa92cde89f2a6341c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It was deprecated in C++11 and removed in C++17&lt;/strong&gt;, so you shouldn't use it.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11で非推奨になり、C ++ 17&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;削除された&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、使用しないでください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05d6ce56a57f8c848f648042c5448f4a8a610d89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OLD ANSWER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;古い答え&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d1e940c49d65579e31f8af44e892beff4f142c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shared Pointer&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;共有ポインター&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="005e906d718b91c7b79edf678d3c0fc87b1f5349" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So when should I use regular pointers then?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;では、いつ通常のポインタを使用すればよいですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971abf8af0ed9ddec060bfca3124cf49cd8504de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unique Pointer :&lt;/strong&gt; 
    Light weight smart pointer with exclusive ownership. Use when pointer points to unique objects without sharing the objects between the pointers.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ユニークポインター：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 独占的な所有権を持つ軽量スマートポインター。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ポインター間でオブジェクトを共有せずに、ポインターが一意のオブジェクトを指す場合に使用します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46c311c3b22afb68eb5ae8c85ce8bb5d73bc761f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Weak Pointer :&lt;/strong&gt; 
    Helps deal with cyclic reference which arises when using Shared Pointer
    If you have two objects pointed to by two shared pointers and there is an internal shared pointer pointing to each others shared pointer then there will be a cyclic reference and the object will not be deleted when shared pointers go out of scope. To solve this , change the internal member from a shared_ptr to weak_ptr. Note : To access the element pointed to by a weak pointer use lock() , this returns a weak_ptr.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;弱いポインタ：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 共有ポインタを使用するときに発生する循環参照の処理に役立ちます。2つの共有ポインタが指す2つのオブジェクトがあり、相互に共有ポインタを指す内部共有ポインタがある場合、循環参照があり、オブジェクトはありません。共有ポインタが範囲外になったときに削除されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これを解決するには、内部メンバーをshared_ptrからweak_ptrに変更します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注：ウィークポインターが指す要素にアクセスするには、lock（）を使用して、weak_ptrを返します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3b0f949d4345488039e4183458ea4810d7099f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a smart pointer?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインターとは&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6468525fccb4ecf5e47ed8487dee96a37bf52f5b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should I use one?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いつ使用すべきですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="660849bfef63c2647882bdc5da8447c8dc6b51e5" translate="yes" xml:space="preserve">
          <source>A const pointer to a const data type T . Meaning you cannot either move the pointer nor can you change the data type pointer to be the pointer. ie . &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; will not work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constデータ型Tへのconstポインター。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、ポインターを移動することも、データ型ポインターをポインターに変更することもできません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すなわち。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr3-- ; ptr3++ ; *ptr3 = 19;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作しないでしょう&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="408b455a6c631e6b53e0f1209d0361f9b950a58c" translate="yes" xml:space="preserve">
          <source>A const pointer to a data type T . Meaning you cannot move the pointer but you can change the value pointed to by the pointer. ie &lt;code&gt;*ptr2 = 19&lt;/code&gt; will work but &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; etc will not work. Read backwards : const pointer to a type T</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データ型Tへのconstポインター。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、ポインターを移動することはできませんが、ポインターが指す値を変更することはできます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr2 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は機能しますが、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr2++ ; ptr2--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などは機能しません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;逆方向に読む：型Tへのconstポインター&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0895997fb22fe8c3fbe3470dd02611de7817af76" translate="yes" xml:space="preserve">
          <source>A more complex smart pointer policy involves reference counting the pointer. This does allow the pointer to be copied. When the last &quot;reference&quot; to the object is destroyed, the object is deleted. This policy is implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より複雑なスマートポインターポリシーには、ポインターの参照カウントが含まれます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、ポインタをコピーできます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトへの最後の「参照」が破棄されると、オブジェクトは削除されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このポリシーは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって実装され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85cc9f1d1b7b72b303b1a6932cad97df1a8bf8af" translate="yes" xml:space="preserve">
          <source>A smart pointer by comparison defines a policy as to when the object is destroyed. You still have to create the object, but you no longer have to worry about destroying it.</source>
          <target state="translated">それに比べてスマートポインタは、オブジェクトがいつ破壊されるかについてのポリシーを定義します。オブジェクトを作成する必要はありますが、破壊することを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="5a8ed7f449dc88e468a305cb01873d71c0dda80a" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class that wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object being pointed to. There is no single smart pointer type, but all of them try to abstract a raw pointer in a practical way.</source>
          <target state="translated">スマートポインタは、「生の」(または「むき出しの」)C++ポインタをラップして、指し示されたオブジェクトの寿命を管理するクラスです。スマート ポインタの型は単一ではありませんが、いずれも実用的な方法で生ポインタを抽象化しようとしています。</target>
        </trans-unit>
        <trans-unit id="c2cc5504b9d575fdc1765bc51e43e4e44d93de47" translate="yes" xml:space="preserve">
          <source>A smart pointer is a class, a wrapper of a normal pointer. Unlike normal pointers, smart point&amp;rsquo;s life circle is based on a reference count (how many time the smart pointer object is assigned). So whenever a smart pointer is assigned to another one, the internal reference count plus plus. And whenever the object goes out of scope, the reference count minus minus.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインタは、通常のポインタのラッパーであるクラスです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常のポインターとは異なり、スマートポイントのライフサークルは参照カウント（スマートポインターオブジェクトが割り当てられた回数）に基づいています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため、スマートポインタが別のスマートポインタに割り当てられると、内部参照カウントがプラスになります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、オブジェクトがスコープから外れると、参照カウントからマイナスが引かれます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9356d827d5b266f397c77242a36f9ee76af46143" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts like a pointer, but additionally provides control on construction, destruction, copying, moving and dereferencing.</source>
          <target state="translated">スマートポインタは、ポインタのように動作し、さらに構築、破壊、コピー、移動、参照解除の制御を提供するオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="150ff3c7e30d567459ce409ef2d43cf92945b361" translate="yes" xml:space="preserve">
          <source>A smart pointer is an object that acts, looks and feels like a normal pointer but offers more functionality. In C++, smart pointers are implemented as template classes that encapsulate a pointer and override standard pointer operators. They have a number of advantages over regular pointers. They are guaranteed to be initialized as either null pointers or pointers to a heap object. Indirection through a null pointer is checked. No delete is ever necessary. Objects are automatically freed when the last pointer to them has gone away. One significant problem with these smart pointers is that unlike regular pointers, they don't respect inheritance. Smart pointers are unattractive for polymorphic code. Given below is an example for the implementation of smart pointers.</source>
          <target state="translated">スマート ポインターとは、通常のポインタと同じように動作し、見た目も感じますが、より多くの機能を提供するオブジェクトです。C++では、スマート ポインタは、ポインタをカプセル化し、標準のポインタ演算子をオーバーライドするテンプレート クラスとして実装されています。スマート ポインタには、通常のポインタよりも多くの利点があります。スマート ポインタは、NULL ポインタまたはヒープ オブジェクトへのポインタとして初期化されることが保証されています。NULL ポインタを経由した方向性がチェックされます。削除は必要ありません。オブジェクトへの最後のポインタがなくなると、オブジェクトは自動的に解放されます。これらのスマートポインタの重大な問題点は、通常のポインタとは異なり、継承を考慮していないことです。スマートポインタはポリモーフィックなコードには魅力的ではありません。以下にスマートポインタの実装例を示します。</target>
        </trans-unit>
        <trans-unit id="b68b6f3a8975f96f1b6b93c4634bedb35aff4ddb" translate="yes" xml:space="preserve">
          <source>A smart pointer is like a regular (typed) pointer, like &quot;char*&quot;, except when the pointer itself goes out of scope then what it points to is deleted as well. You can use it like you would a regular pointer, by using &quot;-&amp;gt;&quot;, but not if you need an actual pointer to the data. For that, you can use &quot;&amp;amp;*ptr&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインターは、「char *」のような通常の（型付き）ポインターに似ていますが、ポインター自体がスコープから外れた場合、ポインターが指しているものも削除されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;-&amp;gt;&quot;を使用することで、通常のポインターと同じように使用できますが、データへの実際のポインターが必要な場合は使用できません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのためには、「＆* ptr」を使用できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1471a71c5e4eb0de52fc485e12e309fb87dc2eee" translate="yes" xml:space="preserve">
          <source>Additionally, the C++ standard library provides three smart pointers; &lt;code&gt;std::unique_ptr&lt;/code&gt; for unique ownership, &lt;code&gt;std::shared_ptr&lt;/code&gt; for shared ownership and &lt;code&gt;std::weak_ptr&lt;/code&gt;. &lt;code&gt;std::auto_ptr&lt;/code&gt; existed in C++03 but is now deprecated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さらに、C ++標準ライブラリは3つのスマートポインターを提供します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;固有の所有権の場合は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;共有の所有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;権の場合は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はC ++ 03に存在しましたが、現在は非推奨です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f173ba927487f1d4cb291eff83de845b351faeb8" translate="yes" xml:space="preserve">
          <source>Ah, but you really wanted to, admit it.</source>
          <target state="translated">ああ、でも本当にそうしたかったんだな、認めろよ。</target>
        </trans-unit>
        <trans-unit id="fe19f580daa87cc25b870e1baa16fab7e5c59b15" translate="yes" xml:space="preserve">
          <source>Among other things (explained well in other answers) using a smart pointer is a possible solution to &lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;How do we use a abstract class as a function return type?&lt;/a&gt; which has been marked as a duplicate of this question. However, the first question to ask if tempted to specify an abstract (or in fact, any) base class as a return type in C++ is &quot;what do you really mean?&quot;. There is a good discussion (with further references) of idiomatic object oriented programming in C++ (and how this is different to other languages) in the documentation of the &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;boost pointer container library&lt;/a&gt;. In summary, in C++ you have to think about ownership. Which smart pointers help you with, but are not the only solution, or always a complete solution (they don't give you polymorphic copy) and are not always a solution you want to expose in your interface (and a function return sounds an awful lot like an interface). It might be sufficient to return a reference, for example. But in all of these cases (smart pointer, pointer container or simply returning a reference) you have changed the return from a &lt;em&gt;value&lt;/em&gt; to some form of &lt;em&gt;reference&lt;/em&gt;. If you really needed copy you may need to add more boilerplate &quot;idiom&quot; or move beyond idiomatic (or otherwise) OOP in C++ to more generic polymorphism using libraries like &lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;Adobe Poly&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;Boost.TypeErasure&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とりわけ、（他の回答でよく説明されている）スマートポインターの&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48454208/how-do-we-use-a-abstract-class-as-a-function-return-type&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用は、抽象クラスを関数の戻り値の型としてどのように使用するか&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対する可能な解決策&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはこの質問の複製としてマークされています。ただし、C ++で戻り値の型として抽象（または実際には任意の）基本クラスを指定したいかどうかを尋ねる最初の質問は、「本当にどういう意味ですか？」です。&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/ptr_container/doc/guidelines.html#recommended-practice-for-object-oriented-programming&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブーストポインターコンテナーライブラリの&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ドキュメントに、C ++での慣用的なオブジェクト指向プログラミング（および他の言語との違い）に関するよい議論があり&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要約すると、C ++では所有権について考える必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どのスマートポインターが役立ちますが、唯一の解決策ではないか、常に完全な解決策（ポリモーフィックコピーを提供しない）であり、常にインターフェイスで公開する解決策ではありません（関数の戻りがひどいように聞こえます）インターフェースによく似ています）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、参照を返すだけで十分な場合があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、これらすべてのケース（スマートポインター、ポインターコンテナー、または単に参照を返す）では、戻り&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から何らかの形式の&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照に変更しました&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コピーが本当に必要な場合は、ボイラープレートの「イディオム」を追加するか、C ++の慣用的な（またはその他の）OOPを超えて、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://stlab.adobe.com/group__poly__related.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adobe Poly&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;や&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/doc/html/boost_typeerasure.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost.TypeErasure&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などのライブラリを使用して、より一般的なポリモーフィズムに移動する必要があります。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a78ca5dca4761808a7b5e7382ebf5f698b2cd2fd" translate="yes" xml:space="preserve">
          <source>Another convenient type is &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt;&lt;code&gt;boost::shared_ptr&lt;/code&gt;&lt;/a&gt; which implements reference counting and automatically deallocates memory when no references to object remains. This helps avoiding memory leaks and is easy to use to implement &lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;RAII&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の便利なタイプは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm&quot;&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは参照カウントを実装し、オブジェクトへの参照が残っていないときに自動的にメモリの割り当てを解除します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはメモリリークの回避に役立ち、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RAIIの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装に簡単に使用でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf3a668061d4ad283ac2fa86679b6f3b0791cf93" translate="yes" xml:space="preserve">
          <source>Another possibility is creating circular references:</source>
          <target state="translated">もう一つの可能性は、循環参照を作成することです。</target>
        </trans-unit>
        <trans-unit id="64f289d2f4648dd5b3726612c027f5c92f4a2aaa" translate="yes" xml:space="preserve">
          <source>Automatic pointer, though looks similar, is totally different from smart pointer. It is a convenient class that deallocates the resource whenever an automatic pointer object goes out of variable scope. To some extent, it makes a pointer (to dynamically allocated memory) works similar to a stack variable (statically allocated in compiling time).</source>
          <target state="translated">自動ポインタは、見た目は似ていますが、スマートポインタとは全く違います。自動ポインタオブジェクトが変数のスコープから外れたときにリソースを解放する便利なクラスです。ある程度、ポインタ(動的に割り当てられたメモリへの)がスタック変数(コンパイル時に静的に割り当てられる)と似たような働きをするようにしています。</target>
        </trans-unit>
        <trans-unit id="0a8c0f929f31db86af22e061262a8478f89bf858" translate="yes" xml:space="preserve">
          <source>Concurrent Counter Access</source>
          <target state="translated">コンカレントカウンターアクセス</target>
        </trans-unit>
        <trans-unit id="e6bf77b4e6823d55153852cfedb73269bb8fdd72" translate="yes" xml:space="preserve">
          <source>Data members of classes, so that when the object is deleted all the owned data is deleted as well, without any special code in the destructor (you will need to be sure the destructor is virtual, which is almost always a good thing to do).</source>
          <target state="translated">クラスのデータメンバで、オブジェクトが削除されたときに、デストラクタ内の特別なコードなしで、所有するすべてのデータが削除されます (デストラクタがバーチャルであることを確認する必要がありますが、これはほとんど常に良いことです)。</target>
        </trans-unit>
        <trans-unit id="d315ffe38f74e2bbd3649007ed92bd0fcb339294" translate="yes" xml:space="preserve">
          <source>Definitions provided by Chris, Sergdev and Llyod are correct. I prefer a simpler definition though, just to keep my life simple:
A smart pointer is simply a class that overloads the &lt;code&gt;-&amp;gt;&lt;/code&gt;  and &lt;code&gt;*&lt;/code&gt; operators. Which means that your object semantically looks like a pointer but you can make it do way cooler things, including reference counting, automatic destruction etc.
&lt;code&gt;shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; are sufficient in most cases, but come along with their own set of small idiosyncrasies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Chris、Sergdev、およびLlyodによって提供された定義は正しいです。ただし、私の人生を単純に保つために、より単純な定義を好みます。スマートポインターは、単に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演算子&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をオーバーロードするクラスです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。つまり、オブジェクトは意味的にはポインタのように見えますが、参照カウントや自動破棄など、よりクールな方法でオブジェクトを作成できます。 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ほとんどの場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で十分ですが、独自の小さな特異性のセットが付属しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="17a6e952cfd054bf86a0bff2ef3758ccb138822a" translate="yes" xml:space="preserve">
          <source>Destruction and Deallocation</source>
          <target state="translated">破壊と配置転換</target>
        </trans-unit>
        <trans-unit id="62c819d637d29a2f4f19cf04f89b693e7e7a7ca3" translate="yes" xml:space="preserve">
          <source>Don't use the &lt;code&gt;boost::&lt;/code&gt; smart pointers or &lt;code&gt;std::auto_ptr&lt;/code&gt; except in special cases which you can read up on if you must.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;boost::&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインターや&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、必要に応じて読み込める特別な場合を除いて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用しないでください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f3d3aad5c807bb24d88407fd715dd4bcadc4a87" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; provides the following smart pointer implementations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Boost&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は次のスマートポインター実装を提供します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6213441eda5b33d29bac7b15eafcedc34217804c" translate="yes" xml:space="preserve">
          <source>Here is the Link for similar answers : &lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同様の回答のリンクは次のとおりです&lt;/font&gt;&lt;a href=&quot;http://sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//sickprogrammersarea.blogspot.in/2014/03/technical-interview-questions-on-c_6.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="235448e1559e2c6a2d98c037e982857e78ec5708" translate="yes" xml:space="preserve">
          <source>Here's a simple answer for these days of modern C++:</source>
          <target state="translated">これが最近のC++のシンプルな答えです。</target>
        </trans-unit>
        <trans-unit id="8a930b4fb10a4df4e7af642f22172143cf9dfa25" translate="yes" xml:space="preserve">
          <source>Holder Limitations</source>
          <target state="translated">ホルダーの制限</target>
        </trans-unit>
        <trans-unit id="db3373933d2b26d58bd3267b9cb9ff92de1de43a" translate="yes" xml:space="preserve">
          <source>Holders, (note, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt; is implementation of such type of smart pointer)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ホルダー（注意：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: auto_ptr&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、そのようなタイプのスマートポインターの実装です）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8efc2fcb0e64352073d01410371f9b29588ff6a8" translate="yes" xml:space="preserve">
          <source>Implemented using reference counting to keep track of how many &quot; things &quot; point to the object pointed to by the pointer. When this count goes to 0 , the object is automatically deleted , ie objected is deleted when all the share_ptr pointing to the object goes out of scope. 
This gets rid of the headache of having to delete objects which you have allocated using new.</source>
          <target state="translated">ポインタが指すオブジェクトを指す「もの」の数を追跡するために、参照カウントを使用して実装されています。このカウントが 0 になると、オブジェクトは自動的に削除されます。これにより、newを使って確保したオブジェクトを削除しなければならないという頭痛の種から解放されます。</target>
        </trans-unit>
        <trans-unit id="c1d841b0ff2602990af565bd1846dd9e8eba0720" translate="yes" xml:space="preserve">
          <source>In code which involves tracking the ownership of a piece of memory, allocating or de-allocating; the smart pointer often saves you the need to do these things explicitly.</source>
          <target state="translated">メモリの一部の所有権を追跡したり、割り当てや割り当て解除を行うコードでは、スマートポインタを使用することで、これらのことを明示的に行う必要性を省くことができます。</target>
        </trans-unit>
        <trans-unit id="8d2ab2c7ea1b9e3dd5c0238fa3501e1a6f018af5" translate="yes" xml:space="preserve">
          <source>In computer science, a smart pointer
  is an abstract data type that
  simulates a pointer while providing
  additional features, such as automatic
  garbage collection or bounds checking.
  These additional features are intended
  to reduce bugs caused by the misuse of
  pointers while retaining efficiency.
  Smart pointers typically keep track of
  the objects that point to them for the
  purpose of memory management. The
  misuse of pointers is a major source
  of bugs: the constant allocation,
  deallocation and referencing that must
  be performed by a program written
  using pointers makes it very likely
  that some memory leaks will occur.
  Smart pointers try to prevent memory
  leaks by making the resource
  deallocation automatic: when the
  pointer to an object (or the last in a
  series of pointers) is destroyed, for
  example because it goes out of scope,
  the pointed object is destroyed too.</source>
          <target state="translated">コンピュータサイエンスでは、スマートポインタは、自動ガベージコレクションや境界チェックなどの追加機能を提供しながらポインタをシミュレートする抽象的なデータ型です。これらの追加機能は、効率性を維持しつつ、ポインタの誤用によるバグを減らすことを目的としています。スマートポインタは通常、メモリ管理の目的でポインタを指すオブジェクトを追跡します。ポインタの誤用はバグの主な原因となっています。 ポインタを使って書かれたプログラムでは、常に割り当て、解放、参照を行わなければならないため、 メモリリークが発生する可能性が非常に高くなります。スマートポインタは、リソースの解放を自動的に行うことでメモリリークを防ごうとしています:例えば、オブジェクトへのポインタ(または一連のポインタの最後のポインタ)がスコープ外になるなどして破棄された場合、そのポインタのオブジェクトも破棄されます。</target>
        </trans-unit>
        <trans-unit id="b470b0b9a364b2fa432c27c2e23748d4f2eeebfb" translate="yes" xml:space="preserve">
          <source>It is useful for:</source>
          <target state="translated">に便利です。</target>
        </trans-unit>
        <trans-unit id="269dd3751517ddfbd50cdb4301abe2ab83b607fc" translate="yes" xml:space="preserve">
          <source>It's a type whose values can be used like pointers, but which provides the additional feature of automatic memory management: When a smart pointer is no longer in use, the memory it points to is deallocated (see also &lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;the more detailed definition on Wikipedia&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、ポインタのように値を使用できるタイプですが、自動メモリ管理の追加機能を提供します。スマートポインタが使用されなくなると、それが指すメモリの割り当てが解除されます（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Smart_pointer&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipediaの詳細な定義&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;も参照&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1508c0dbd75f276250ef468cde22c1eb920a2bdb" translate="yes" xml:space="preserve">
          <source>Let T be a class in this tutorial 
Pointers in C++ can be divided into 3 types :</source>
          <target state="translated">このチュートリアルでは、Tをクラスとします C++のポインタは3つのタイプに分けることができます .</target>
        </trans-unit>
        <trans-unit id="b792a21ee56ff623795e7a57d358d84ec527459b" translate="yes" xml:space="preserve">
          <source>Like other overloaded operators, p will behave like a regular pointer,</source>
          <target state="translated">他のオーバーロードされた演算子と同様に、p は通常のポインタのように振る舞います。</target>
        </trans-unit>
        <trans-unit id="455cc282d56455c6f5333fab2462998a571616cc" translate="yes" xml:space="preserve">
          <source>Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.</source>
          <target state="translated">ほとんどの種類のスマートポインターは、ポインタからオブジェクトへのポインタを処理してくれます。もう手動でオブジェクトを処分することを考える必要がないので、非常に便利です。</target>
        </trans-unit>
        <trans-unit id="7314c02622627b7ccb9b4f584bc913fff6ad6735" translate="yes" xml:space="preserve">
          <source>Mostly in code that is oblivious to memory ownership. This would typically be in functions which get a pointer from someplace else and do not allocate nor de-allocate, and do not store a copy of the pointer which outlasts their execution.</source>
          <target state="translated">主に、メモリの所有権に気づかないようなコードの中にあります。これは一般的に、どこか他の場所からポインタを取得して、 割り当てや割り当て解除を行わず、実行時間を超えたポインタのコピーを保存しない関数の中にあるでしょう。</target>
        </trans-unit>
        <trans-unit id="26e6d181ff99160909b595478121f08dd076edb4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::unique_ptr&lt;/code&gt; instances cannot be copied. This prevents the pointer from being deleted multiple times (incorrectly). You can, however, pass references to it around to other functions you call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インスタンスはコピーできないことに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、ポインターが複数回（誤って）削除されるのを防ぎます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、それへの参照を、呼び出す他の関数に渡すことができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc55faaac98b84550c0f52f207b38f5a9b210b5d" translate="yes" xml:space="preserve">
          <source>Objects that must be allocated with new, but that you'd like to have the same lifetime as something on that stack. If the object is assigned to a smart pointer, then they will be deleted when the program exits that function/block.</source>
          <target state="translated">new で割り当てなければならないが、そのスタック上の何かと同じライフタイムを持ちたいオブジェクト。そのオブジェクトがスマートポインタに割り当てられている場合、プログラムがそのファンクションブロックを終了するときにそれらは削除されます。</target>
        </trans-unit>
        <trans-unit id="f751c9fbb24aa2c23e6e65e987bb3d5bb9f738ce" translate="yes" xml:space="preserve">
          <source>One can implement one's own smart pointer, but many libraries also provide smart pointer implementations each with different advantages and drawbacks.</source>
          <target state="translated">独自のスマートポインタを実装することができますが、多くのライブラリがスマートポインタの実装を提供しており、それぞれに異なる利点と欠点があります。</target>
        </trans-unit>
        <trans-unit id="87b543505cd555c6851c754dbaa29544fec9d8de" translate="yes" xml:space="preserve">
          <source>One of the simple smart-pointer type is &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt; (chapter 20.4.5 of C++ standard), which allows to deallocate memory automatically when it out of scope and which is more robust than simple pointer usage when exceptions are thrown, although less flexible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;単純なスマートポインター型の1つは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（C ++標準のチャプター20.4.5）です。これにより、スコープ外にあるときに自動的にメモリの割り当てを解除でき、例外はスローされますが、単純なポインターの使用よりも堅牢です。フレキシブル。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deac6c8d86314111051ac297a8e90d729d2fc59e" translate="yes" xml:space="preserve">
          <source>Pointer to a data type T which is a const. Meaning you cannot change the data type using the pointer. ie &lt;code&gt;*ptr1 = 19&lt;/code&gt; ; will not work. But you can move the pointer. ie &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; ;  etc will work.
Read backwards : pointer to type T which is const</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;constであるデータ型Tへのポインター。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、ポインタを使用してデータ型を変更することはできません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すなわち&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*ptr1 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;動作しないでしょう。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、ポインタを移動することはできます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ptr1++ , ptr1--&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などは動作します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;逆方向に読む：constであるT型へのポインタ&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5091a6ac607a66d605572c2f1f01fdeddfb5810" translate="yes" xml:space="preserve">
          <source>Pointers with const data or address { Read backwards }</source>
          <target state="translated">const データまたはアドレスを持つポインタ{逆方向に読み出す }。</target>
        </trans-unit>
        <trans-unit id="3c274408a7815b4769a808e5cd01a86c5b3930d3" translate="yes" xml:space="preserve">
          <source>Protecting Against Exceptions</source>
          <target state="translated">例外からの保護</target>
        </trans-unit>
        <trans-unit id="cc6e672ee6612bec71630926ee21e523510d4fc4" translate="yes" xml:space="preserve">
          <source>Reference : 
&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/a&gt; 
Thanks to Andre for pointing out this question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; この質問を指摘してくれたAndreに感謝し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e4d88eed28dd1376cc40fd170b9bfe77d1d02da0" translate="yes" xml:space="preserve">
          <source>Reference Counting</source>
          <target state="translated">リファレンスカウント</target>
        </trans-unit>
        <trans-unit id="7fd5474cfc1ade935cc5c546e88ea9b67e4d64c6" translate="yes" xml:space="preserve">
          <source>Reference counted pointers are very useful when the lifetime of your object is much more complicated, and is not tied directly to a particular section of code or to another object.</source>
          <target state="translated">参照カウントされたポインタは、あなたのオブジェクトの寿命がはるかに複雑で、コードの特定のセクションや別のオブジェクトに直接縛られていない場合に非常に便利です。</target>
        </trans-unit>
        <trans-unit id="08784d3c2d27ac259ff9d07cfc06917a9d5a0f38" translate="yes" xml:space="preserve">
          <source>References : 
    They can essentially be though of as const pointers, ie a pointer which is const and cannot be moved with better syntax.</source>
          <target state="translated">参照.基本的には const ポインタ、つまり const であり、より良い構文では移動できないポインタと考えることができます。</target>
        </trans-unit>
        <trans-unit id="4bed4ff02087a38f1b95579b7416fac0a1027a61" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;When is std::weak_ptr useful?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: weak_ptrが役立つのはいつですか？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5251271034126a1a5c2548bc2290d5d6cd1e15d8" translate="yes" xml:space="preserve">
          <source>See : &lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;What are the differences between a pointer variable and a reference variable in C++?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参照：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++のポインター変数と参照変数の違いは何ですか？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="06b60eabd9ac929a849b1c545034616a52874ae8" translate="yes" xml:space="preserve">
          <source>Small intro is available on page &lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;Smart Pointers - What, Why, Which?&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小さなイントロページで提供されています&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://ootips.org/yonat/4dev/smart-pointers.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインタ-何を、なぜ、どのましたか？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eddd0ee6c00b8b7b07f4aa1533cf74d53674f39b" translate="yes" xml:space="preserve">
          <source>Smart Pointers are those where you don't have to worry about Memory De-Allocation, Resource Sharing and Transfer.</source>
          <target state="translated">スマートポインタは、メモリのデアロケート、リソースの共有、転送を気にする必要がないものです。</target>
        </trans-unit>
        <trans-unit id="04467054ec546b1c0315c4cfac233385593e4375" translate="yes" xml:space="preserve">
          <source>Smart pointers should be preferred over raw pointers. If you feel you need to use pointers (first consider if you &lt;em&gt;really&lt;/em&gt; do), you would normally want to use a smart pointer as this can alleviate many of the problems with raw pointers, mainly forgetting to delete the object and leaking memory.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スマートポインターは、生のポインターよりも優先する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ポインターを使用する必要があると思われる場合（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に使用するかどうかを最初に検討してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）、通常はスマートポインターを使用することをお勧めします。これにより、生のポインターに関する多くの問題が軽減されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e25c6c59bcb6d66abe3c35be9cc4fddb4b2b9bca" translate="yes" xml:space="preserve">
          <source>Subject is covered in depth in book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&quot;C++ Templates: The Complete Guide&quot; by David Vandevoorde, Nicolai M. Josuttis&lt;/a&gt;, chapter Chapter 20. Smart Pointers.
Some topics covered:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;サブジェクトは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201734842&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、David Vandevoorde、Nicolai M. Josuttis&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;著の章&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「C ++テンプレート：完全なガイド」の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第20章「スマートポインタ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で詳しく説明されてい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;カバーするいくつかのトピック：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd1de633672e7627dbf70739243d0b87a6dc17bb" translate="yes" xml:space="preserve">
          <source>The existing answers are good but don't cover what to do when a smart pointer is not the (complete) answer to the problem you are trying to solve.</source>
          <target state="translated">既存の回答は良いのですが、スマートポインタが解決しようとしている問題の(完全な)答えになっていない場合に何をすべきかをカバーしていません。</target>
        </trans-unit>
        <trans-unit id="b06ceb1cd65ed156e62d8ecd9eab78c66e613029" translate="yes" xml:space="preserve">
          <source>The most commonly-used smart pointers are &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; (or &lt;code&gt;boost::shared_ptr&lt;/code&gt;), and, less commonly, &lt;code&gt;std::auto_ptr&lt;/code&gt;. I recommend regular use of &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最も一般的に使用されるスマートポインターは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::tr1::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;boost::shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）であり、あまり一般的ではありませんが、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定期的に使用することをお勧めします&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97b533d7bfbeb88b5d7616af5826194991855a7f" translate="yes" xml:space="preserve">
          <source>The simplest policy in use involves the scope of the smart pointer wrapper object, such as implemented by &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt;&lt;code&gt;boost::scoped_ptr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用中の最も単純なポリシーには、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm&quot;&gt; &lt;code&gt;boost::scoped_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって実装されるような、スマートポインターラッパーオブジェクトのスコープが含まれます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d47eb61584acb71b110726e0b95e16a13f3cc6" translate="yes" xml:space="preserve">
          <source>There is one drawback to reference counted pointers &amp;mdash; the possibility of creating a dangling reference:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;カウントされたポインタを参照することには1つの欠点があります&amp;mdash;ぶら下がっている参照が作成される可能性があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7cf9d335ee541a055c37f36657dc1e6a480c449d" translate="yes" xml:space="preserve">
          <source>There was also &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;&lt;/a&gt;. It was very much like a scoped pointer, except that it also had the &quot;special&quot; dangerous ability to be copied &amp;mdash; which also unexpectedly transfers ownership.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/auto_ptr&quot;&gt; &lt;code&gt;std::auto_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もありました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはスコープ付きポインタに非常によく似ていましたが、コピーされる「特別な」危険な機能があり、それが予期せず所有権を移すこともありました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f10dc26ca1fd5731e91d37edb3bbff8ef030a4f4" translate="yes" xml:space="preserve">
          <source>These are just one linear descriptions of each and can be used as per need, for further detail and examples one can look at the documentation of Boost.</source>
          <target state="translated">これらは、それぞれの説明を直線的に記述したものであり、必要に応じて使い分けることができます。</target>
        </trans-unit>
        <trans-unit id="074f5297a4fba1ef7bfeb2429c1ef13d61bea37b" translate="yes" xml:space="preserve">
          <source>They hold a memory address to a location in memory. Use with caution , as programs become complex hard to keep track.</source>
          <target state="translated">彼らは、メモリ内の場所にメモリアドレスを保持します。注意して使用して、プログラムが複雑になると、トラックを維持するのは難しいです。</target>
        </trans-unit>
        <trans-unit id="9432b51535de91f29d61abdc8f193678d301d5bc" translate="yes" xml:space="preserve">
          <source>This answer is rather old, and so describes what was 'good' at the time, which was smart pointers provided by the Boost library. Since C++11, the standard library has provided sufficient smart pointers types, and so you should favour the use of &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この答えはかなり古いので、当時Boostライブラリによって提供されたスマートポインタであった「良い」ものを説明しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11以降、標準ライブラリは十分なスマートポインタ型を提供しているため、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、および&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の使用を優先する必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3fd31e33e7e71dba6afa758f5ddaa23fd6413cc" translate="yes" xml:space="preserve">
          <source>This class implement a smart pointer to an object of type X. The object itself is located on the heap. Here is how to use it:</source>
          <target state="translated">このクラスは X 型のオブジェクトへのスマートなポインタを実装しています。ここではその使い方を説明します。</target>
        </trans-unit>
        <trans-unit id="c3acb92908f60dd2ddfb231908946d7977340ae6" translate="yes" xml:space="preserve">
          <source>To change the object pointed to by the unique ptr , use move semantics</source>
          <target state="translated">一意の ptr が指すオブジェクトを変更するには、move セマンティクスを使用します。</target>
        </trans-unit>
        <trans-unit id="80ec759771be05f92f85c7d934d53b16a77673fa" translate="yes" xml:space="preserve">
          <source>To work around this problem, both Boost and C++11 have defined a &lt;code&gt;weak_ptr&lt;/code&gt; to define a weak (uncounted) reference to a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この問題を回避するために、BoostとC ++ 11の両方で&lt;/font&gt;&lt;/font&gt; &lt;code&gt;weak_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を定義して、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;shared_ptr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;への弱い（カウントされていない）参照を定義しています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18f22cb2e33fe36506262132cc985d5cd594ea3d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - and do not want your object to be de-allocated until all these references are themselves gone.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;複数の場所からオブジェクトを参照したい場合や、これらの参照がすべてなくなるまでオブジェクトの割り当てを&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr&quot;&gt; &lt;code&gt;std::shared_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したくない場合は、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: shared_ptrを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d62e1c7ca9f6bac0498ed49f33b2dd9b90497ae4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/a&gt; when you don't intend to hold multiple references to the same object. For example, use it for a pointer to memory which gets allocated on entering some scope and de-allocated on exiting the scope.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じオブジェクトへの複数の参照を保持する予定がない場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/unique_ptr&quot;&gt; &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、あるスコープに入るときに割り当てられ、スコープから出るときに割り当て解除されるメモリへのポインタにそれを使用します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89b90755704062fcad6a5106c9e29a719bef4c5e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt;&lt;/a&gt; when you do want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate (so they'll just note the object is gone when you try to dereference).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;複数の場所からオブジェクトを参照したい場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/weak_ptr&quot;&gt; &lt;code&gt;std::weak_ptr&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します-無視して割り当てを解除してもよい参照の場合（参照を解除しようとしたときにオブジェクトがなくなっていることに注意してください）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5bb07c28eb795708a8cc90a338886a7431582ee9" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one</source>
          <target state="translated">スマートポインタとは何か?</target>
        </trans-unit>
        <trans-unit id="8d779c02f29f56174f222fe34fb2a12b36815ca5" translate="yes" xml:space="preserve">
          <source>What is a smart pointer and when should I use one?</source>
          <target state="translated">スマートポインタとは何ですか?</target>
        </trans-unit>
        <trans-unit id="72dca932f0f35f4b1af9967ff79dc06b4b558df6" translate="yes" xml:space="preserve">
          <source>With raw pointers, the programmer has to explicitly destroy the object when it is no longer useful.</source>
          <target state="translated">生のポインタでは、プログラマーはオブジェクトが不要になったときに明示的に破棄しなければなりません。</target>
        </trans-unit>
        <trans-unit id="7c8bd33fd1a098972b52263748dc1191e62414cf" translate="yes" xml:space="preserve">
          <source>You can very well use these pointer in the similar way as any allocation works in Java. In java Garbage Collector does the trick, while in Smart Pointers, the trick is done by Destructors.</source>
          <target state="translated">これらのポインタは、Javaでのアロケーションと同様の方法で非常によく使用することができます。JavaではGarbage Collectorがトリックを行いますが、Smart Pointersではデストラクタがトリックを行います。</target>
        </trans-unit>
        <trans-unit id="a60c5ae076041d7c822b45b7033064048db8f570" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;not&lt;/em&gt; want to use a smart pointer when:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次のような場合&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、スマートポインタを使用したく&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ない&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合が&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
