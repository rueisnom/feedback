<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/10067266">
    <body>
      <group id="10067266">
        <trans-unit id="29fd3f854b887de70c267ec7c5f6d62874f253e1" translate="yes" xml:space="preserve">
          <source>(Of course, this also happens if the URL is in an unquoted variable.) For a static string, single quotes make the most sense, although any form of quoting or escaping works here.</source>
          <target state="translated">(当然,如果URL是在一个无引号的变量中,也会出现这种情况。)对于静态字符串来说,单引号是最合理的,尽管任何形式的引号或转义都可以在这里使用。</target>
        </trans-unit>
        <trans-unit id="e75e43676033b8825952394396f0bdb6b34f9132" translate="yes" xml:space="preserve">
          <source>(The loop is completely superfluous in the latter example; &lt;code&gt;printf&lt;/code&gt; specifically works fine with multiple arguments. &lt;code&gt;stat&lt;/code&gt; too.  But looping over a wildcard match is a common problem, and frequently done incorrectly.)</source>
          <target state="translated">（在后一个示例中，循环是完全多余的； &lt;code&gt;printf&lt;/code&gt; 特别适用于多个参数 &lt;code&gt;stat&lt;/code&gt; 也可以。但是循环使用通配符匹配是一个常见问题，并且经常做不正确。）</target>
        </trans-unit>
        <trans-unit id="b3b5b7a51be079d9e32c2b061011fd5033a272d3" translate="yes" xml:space="preserve">
          <source>(The loop only runs once, over the literal single-quoted string.)</source>
          <target state="translated">(这个循环只运行一次,在单引号字符串的字面意义上的循环)。</target>
        </trans-unit>
        <trans-unit id="a62e7a96f381e21c77f5f03189a31cb8761fb2d2" translate="yes" xml:space="preserve">
          <source>(The loop only runs once, over the single, quoted string.)</source>
          <target state="translated">(该循环只运行一次,在单引号字符串上运行一次)。</target>
        </trans-unit>
        <trans-unit id="e14130d7ea68f1fbe59aa0abc0d1fa4083bc5b1b" translate="yes" xml:space="preserve">
          <source>(There is no file named &lt;code&gt;$pattern&lt;/code&gt;, either!)</source>
          <target state="translated">（也没有名为 &lt;code&gt;$pattern&lt;/code&gt; 文件！）</target>
        </trans-unit>
        <trans-unit id="d675d362f86f01512076207502a183a15503624a" translate="yes" xml:space="preserve">
          <source>(There is no file named literally &lt;code&gt;file*.txt&lt;/code&gt;.)</source>
          <target state="translated">（没有文件名叫 &lt;code&gt;file*.txt&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="29898fff78243cab08dc3cc8940f533c439e0d0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$?&lt;/code&gt; doesn't need quotes since it's a numeric value. Whether &lt;code&gt;$URL&lt;/code&gt; needs it depends on what you allow in there and whether you still want an argument if it's empty.</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 因为它是数字值，所以不需要引号。 &lt;code&gt;$URL&lt;/code&gt; 是否需要它取决于您在其中允许的内容以及是否为空（如果为空）。</target>
        </trans-unit>
        <trans-unit id="27df154497c68d91d87683896cfc44fea7cea1e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Double quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;双引号&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c5864f833f59c5a8a0137c4d2afe109235f6656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;无引号&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b557581d58744e25e1f1ff2a2f625fe4c2d3b5ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Single quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;单引号&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c13ac318dfb25d9609eaabd5136933f8f64cd210" translate="yes" xml:space="preserve">
          <source>A variable containing a list of tokens to loop over or a wildcard to expand is less frequently seen, so we sometimes abbreviate to &quot;quote everything unless you know precisely what you are doing&quot;.</source>
          <target state="translated">含有要循环使用的令牌列表或通配符展开的变量比较少见,所以我们有时会缩写为 &quot;除非你精确地知道你在做什么,否则就把所有的东西都引过来&quot;。</target>
        </trans-unit>
        <trans-unit id="3222f0efe19396bc34dc4ae8d1cb67a63216d6c6" translate="yes" xml:space="preserve">
          <source>And if so, why?</source>
          <target state="translated">如果是,为什么?</target>
        </trans-unit>
        <trans-unit id="3785a2a188704d23953a5659e27c337b1d1de4b3" translate="yes" xml:space="preserve">
          <source>As an aside, scripts &lt;a href=&quot;http://mywiki.wooledge.org/ParsingLs&quot;&gt;should usually not use &lt;code&gt;ls&lt;/code&gt; for anything.&lt;/a&gt;  To expand a wildcard, just ... use it.</source>
          <target state="translated">顺便说一句，脚本&lt;a href=&quot;http://mywiki.wooledge.org/ParsingLs&quot;&gt;通常不应将 &lt;code&gt;ls&lt;/code&gt; 用于任何内容。&lt;/a&gt; 要扩展通配符，只需...使用它。</target>
        </trans-unit>
        <trans-unit id="0a3b82194ee5f88012f978f13a9f48b8293490ae" translate="yes" xml:space="preserve">
          <source>Bash parameter expansion (&lt;code&gt;&quot;${filename##*/}&quot;&lt;/code&gt;)</source>
          <target state="translated">Bash参数扩展（ &lt;code&gt;&quot;${filename##*/}&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="57758dc45638caa5df2bbed2cb6a9858858010c4" translate="yes" xml:space="preserve">
          <source>By contrast:</source>
          <target state="translated">相比之下。</target>
        </trans-unit>
        <trans-unit id="b04f4a7fc53a3b1cd276b55f41b73ecb06f580ea" translate="yes" xml:space="preserve">
          <source>Could someone tell me whether or not I should wrap quotes around variables in a shell script?</source>
          <target state="translated">谁能告诉我,我是否应该在shell脚本中用引号包住变量?</target>
        </trans-unit>
        <trans-unit id="62c11a34294e0f0be58f971653b654ab56174a59" translate="yes" xml:space="preserve">
          <source>Difference between single and double quotes in Bash</source>
          <target state="translated">Bash中单引号和双引号的区别</target>
        </trans-unit>
        <trans-unit id="d17352112f221c89ded84084a22cdb430e8a3ce0" translate="yes" xml:space="preserve">
          <source>Double quotes are suitable when variable interpolation is required.  With suitable adaptations, it is also a good workaround when you need single quotes in the string.  (There is no straightforward way to escape a single quote between single quotes, because there is no escape mechanism inside single quotes -- if there was, they would not quote completely verbatim.)</source>
          <target state="translated">双引号适用于需要变量插值时。在适当的调整下,当你需要在字符串中使用单引号时,它也是一个很好的变通方法。(没有直接的方法可以在单引号之间转义,因为单引号内部没有转义机制----如果有的话,它们就不会完全逐字逐句地引用。)</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c9cb1bd3a0f4351c0c8efb774a478ff510fec2bf" translate="yes" xml:space="preserve">
          <source>For example, is the following correct:</source>
          <target state="translated">例如,下列说法是否正确的是:</target>
        </trans-unit>
        <trans-unit id="151056fa0605d3905394b3928a4f6252ee33612c" translate="yes" xml:space="preserve">
          <source>For using the variables in the shell script use &quot; &quot; quoted variables as the quoted one means that the variable may contain spaces or special character which won't affect the execution of your shell script. Else if you are sure of not having any spaces or special character in your variable name then you may use them without &quot; &quot;.</source>
          <target state="translated">在shell脚本中使用变量时,请使用&quot;&quot; &quot;引号变量,因为引号意味着变量可能包含空格或特殊字符,这不会影响到shell脚本的执行。否则,如果你确定变量名中没有空格或特殊字符,那么你可以使用没有&quot;&quot;的变量。</target>
        </trans-unit>
        <trans-unit id="dad12a999af9dd77c56aef7ff53113954aad61e3" translate="yes" xml:space="preserve">
          <source>General rule: quote it if it can either be empty or contain spaces (or any whitespace really) or special characters (wildcards). Not quoting strings with spaces often leads to the shell breaking apart a single argument into many.</source>
          <target state="translated">一般规则:如果它可以是空的,或者包含空格(或任何空格)或特殊字符(通配符),那么就引用它。不引用带空格的字符串往往会导致shell将一个参数拆成很多个参数。</target>
        </trans-unit>
        <trans-unit id="f5a242201e6b18c260832b69054eb43c8fbc2aba" translate="yes" xml:space="preserve">
          <source>Here is a three-point formula for quotes in general:</source>
          <target state="translated">下面是一般的引号的三点公式。</target>
        </trans-unit>
        <trans-unit id="d089f893e07ab81bae1415dc085018dee0e09dbc" translate="yes" xml:space="preserve">
          <source>I do use &lt;code&gt;$var&lt;/code&gt; as a simple way to join lines:</source>
          <target state="translated">我确实使用 &lt;code&gt;$var&lt;/code&gt; 作为连接行的简单方法：</target>
        </trans-unit>
        <trans-unit id="d5e34758580d5c070bff9a648e9fdbe239ea46e4" translate="yes" xml:space="preserve">
          <source>I generally use quoted like &lt;code&gt;&quot;$var&quot;&lt;/code&gt; for safe, unless I am sure that &lt;code&gt;$var&lt;/code&gt; does not contain space.</source>
          <target state="translated">为了安全起见，我通常使用引号，例如 &lt;code&gt;&quot;$var&quot;&lt;/code&gt; ，除非我确定 &lt;code&gt;$var&lt;/code&gt; 不包含空间。</target>
        </trans-unit>
        <trans-unit id="06b17da92223ef3ce239ff6ab88770fe677ad1de" translate="yes" xml:space="preserve">
          <source>I tend to always quote strings just out of habit since it's safer that way.</source>
          <target state="translated">我总是习惯性的引用字符串,因为这样比较安全。</target>
        </trans-unit>
        <trans-unit id="ec439701c2466909be80a27184c5571e88afefb3" translate="yes" xml:space="preserve">
          <source>In contexts where we are absolutely sure that there are no word splitting or globbing issues or we &lt;em&gt;do want word splitting and globbing&lt;/em&gt;.</source>
          <target state="translated">在我们绝对确定没有分词或通配符问题的情况下，或者我们&lt;em&gt;确实希望分词和通配符&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b59209984bb16c283fcc6e7768175ac0fd17063" translate="yes" xml:space="preserve">
          <source>In contexts where we want to suppress word splitting and globbing. Also in contexts where we want the literal to be treated as a string, not a regex.</source>
          <target state="translated">在我们想要抑制拆分和globbing的情况下。也适用于我们希望将字面符号作为字符串,而不是regex处理的情况。</target>
        </trans-unit>
        <trans-unit id="f939321e88ed3abfa39a256aa72ba3960b7cb7a2" translate="yes" xml:space="preserve">
          <source>In more concrete terms, anything containing a filename should usually be quoted (because filenames can contain whitespace and other shell metacharacters).  Anything containing a URL should usually be quoted (because many URLs contain shell metacharacters like &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt;).  Anything containing a regex should usually be quoted (ditto ditto).  Anything containing significant whitespace other than single spaces between non-whitespace characters needs to be quoted (because otherwise, the shell will munge the whitespace into, effectively, single spaces, and trim any leading or trailing whitespace).</source>
          <target state="translated">用更具体的术语来说，任何包含文件名的内容通常都应加引号（因为文件名可以包含空格和其他shell元字符）。 包含URL的任何内容通常都应加引号（因为许多URL包含诸如 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 之类的shell元字符）。 包含正则表达式的任何内容通常都应加引号（同上同上）。 除非空格字符之间的单个空格外，任何包含有效空格的内容都必须加引号（否则，外壳程序会将空格有效地切为单个空格，并修剪所有前导或尾随空格）。</target>
        </trans-unit>
        <trans-unit id="59a3873fba3332922756bc32b3c13b44d0217b04" translate="yes" xml:space="preserve">
          <source>In short, quote everything where you do not require the shell to perform token splitting and wildcard expansion.</source>
          <target state="translated">简而言之,凡是不需要shell执行令牌分割和通配符扩展的地方都要引用。</target>
        </trans-unit>
        <trans-unit id="f4d6c9aa733db1b4d38cbcf25cc20311f87dd5bd" translate="yes" xml:space="preserve">
          <source>In string literals where we want to suppress interpolation and special treatment of backslashes. In other words, situations where using double quotes would be inappropriate.</source>
          <target state="translated">在我们希望抑制插值和反斜线的特殊处理的字符串字库中。换句话说,使用双引号是不合适的情况。</target>
        </trans-unit>
        <trans-unit id="84af93e8bce1ae5fb2260de3492df002a2a4f03c" translate="yes" xml:space="preserve">
          <source>No quotes are suitable when you specifically require the shell to perform token splitting and/or wildcard expansion.</source>
          <target state="translated">当你特别要求shell执行令牌分割和通配符扩展时,不需要引号。</target>
        </trans-unit>
        <trans-unit id="9fa884c8c5bdc62d4775d1d0d104d5d6c681dd89" translate="yes" xml:space="preserve">
          <source>Quotes and escaping - Bash Hackers' Wiki</source>
          <target state="translated">报价和逃跑-Bash黑客维基</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="bcabae38fbf5e1055fdfb65c2272617889d7c092" translate="yes" xml:space="preserve">
          <source>Single quotes protect the text between them verbatim.  It is the proper tool when you need to ensure that the shell does not touch the string at all.  Typically, it is the quoting mechanism of choice when you do not require variable interpolation.</source>
          <target state="translated">单引号可以保护它们之间的文本逐字逐句地保护。当你需要确保外壳完全不接触到字符串时,它是合适的工具。通常情况下,当你不需要变量插值时,它是首选的引号机制。</target>
        </trans-unit>
        <trans-unit id="2e161335e1f8eeaacb87546a6509dbdaab9d2fe2" translate="yes" xml:space="preserve">
          <source>The last example also suggests another useful concept, which I like to call &quot;seesaw quoting&quot;. If you need to mix single and double quotes, you can use them adjacent to each other. For example, the following quoted strings</source>
          <target state="translated">最后一个例子还提出了另一个有用的概念,我喜欢称之为 &quot;跷跷板引号&quot;。如果你需要混合单引号和双引号,你可以将它们相邻使用。例如,下面的引号字符串</target>
        </trans-unit>
        <trans-unit id="9e76dcfe4eb30da618b643dcc3d5d0d277cf14c1" translate="yes" xml:space="preserve">
          <source>This isn't awfully legible, but it's a common technique and thus good to know.</source>
          <target state="translated">这并不是很好辨认,但这是一种常见的技巧,因此很好理解。</target>
        </trans-unit>
        <trans-unit id="5572ec42cf62f2e7a9cd4ada274dc621586474d2" translate="yes" xml:space="preserve">
          <source>Token splitting;</source>
          <target state="translated">令牌拆分。</target>
        </trans-unit>
        <trans-unit id="b4e32ab8b1dec3cfd10f9a7c2386e171cf06f28b" translate="yes" xml:space="preserve">
          <source>Values which are not variables basically follow the same rules, though you could then also escape any metacharacters instead of quoting them. For a common example, a URL with a &lt;code&gt;&amp;amp;&lt;/code&gt; in it will be parsed by the shell as a background command unless the metacharacter is escaped or quoted:</source>
          <target state="translated">不是变量的值基本上遵循相同的规则，尽管您也可以转义任何元字符而不用引用它们。 对于一个常见的示例，shell中会将带有 &lt;code&gt;&amp;amp;&lt;/code&gt; 的URL解析为背景命令，除非对元字符进行转义或引用：</target>
        </trans-unit>
        <trans-unit id="d0a268b7f726857d85b69c3da170c0e07d632e94" translate="yes" xml:space="preserve">
          <source>What are the special dollar sign shell variables?</source>
          <target state="translated">有哪些特殊的元符号壳变量?</target>
        </trans-unit>
        <trans-unit id="f53c17e29d0f0b4bf9ec0df6f70ec391904d6877" translate="yes" xml:space="preserve">
          <source>When is double quoting necessary?</source>
          <target state="translated">什么时候需要重复引用?</target>
        </trans-unit>
        <trans-unit id="c2c0d9510460feeeeb5e7d81b6f01442f6bb1b61" translate="yes" xml:space="preserve">
          <source>When to wrap quotes around a shell variable</source>
          <target state="translated">何时在shell变量周围使用引号?</target>
        </trans-unit>
        <trans-unit id="aba4621454c4be08c79d5714683b0614786c9e85" translate="yes" xml:space="preserve">
          <source>When you know that a variable can only contain a value which contains no shell metacharacters, quoting is optional.  Thus, an unquoted &lt;code&gt;$?&lt;/code&gt; is basically fine, because this variable can only ever contain a single number.  However, &lt;code&gt;&quot;$?&quot;&lt;/code&gt; is also correct, and recommended for general consistency and correctness (though this is my personal recommendation, not a widely recognized policy).</source>
          <target state="translated">当您知道一个变量只能包含一个不包含外壳元字符的值时，引号是可选的。 因此，未 &lt;code&gt;$?&lt;/code&gt; 基本上没问题，因为此变量只能包含一个数字。 但是， &lt;code&gt;&quot;$?&quot;&lt;/code&gt; 也是正确的，因此推荐使用，以确保总体一致性和正确性（尽管这是我个人的建议，而不是公认的政策）。</target>
        </trans-unit>
        <trans-unit id="4fa8325b049d6a079d3e5f8128091f49749ffbd7" translate="yes" xml:space="preserve">
          <source>Wildcard expansion:</source>
          <target state="translated">通行证扩展。</target>
        </trans-unit>
        <trans-unit id="85ad4c94f8320e804977d9adc1bae6f86de1921a" translate="yes" xml:space="preserve">
          <source>around standard numeric variables (&lt;code&gt;$$&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, &lt;code&gt;$#&lt;/code&gt; etc.)</source>
          <target state="translated">围绕标准数值变量（ &lt;code&gt;$$&lt;/code&gt; ， &lt;code&gt;$?&lt;/code&gt; ， &lt;code&gt;$#&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="9348a580f1e89ae695aee7326f94273b8c218efc" translate="yes" xml:space="preserve">
          <source>can be pasted together back to back, forming a single long string after tokenization and quote removal.</source>
          <target state="translated">可以背对背地粘贴在一起,在去掉令牌和引号后形成一个长的字符串。</target>
        </trans-unit>
        <trans-unit id="7eca7cf51e8bce5bf586b8b2a42970e21dce9728" translate="yes" xml:space="preserve">
          <source>command names and arguments that have whitespace in them</source>
          <target state="translated">命令名和参数中带空格的命令名称和参数</target>
        </trans-unit>
        <trans-unit id="1c92a162d04b1909da4b43f55844bab9f286483e" translate="yes" xml:space="preserve">
          <source>command substitutions (&lt;code&gt;&quot;$(ls)&quot;&lt;/code&gt;, &lt;code&gt;&quot;`ls`&quot;&lt;/code&gt;)</source>
          <target state="translated">命令替换（ &lt;code&gt;&quot;$(ls)&quot;&lt;/code&gt; ， &lt;code&gt;&quot;`ls`&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="cc7c42e3356a925dec68daa8d37620f9445d8fc3" translate="yes" xml:space="preserve">
          <source>echo &quot;$url name&quot;  --  ( Cannot be used at such situations so take precaution before using it )</source>
          <target state="translated">echo &quot;$url name&quot; --(不能在这种情况下使用,所以在使用前要谨慎使用 )</target>
        </trans-unit>
        <trans-unit id="99b231f14cbc77242a56e3332e58018f67ab0832" translate="yes" xml:space="preserve">
          <source>echo &quot;$url name&quot;  -- ( Can be used at all times )</source>
          <target state="translated">echo &quot;$url name&quot; --(可随时使用 )</target>
        </trans-unit>
        <trans-unit id="4eb1a73b2bfdcb3cfef0c6c93b604815ec5303d7" translate="yes" xml:space="preserve">
          <source>globs where directory path or file name part includes spaces (&lt;code&gt;&quot;/my dir/&quot;*&lt;/code&gt;)</source>
          <target state="translated">目录路径或文件名部分包含空格（ &lt;code&gt;&quot;/my dir/&quot;*&lt;/code&gt; ）的问题</target>
        </trans-unit>
        <trans-unit id="431657c47eea42a005d52a4986263ae27098fba8" translate="yes" xml:space="preserve">
          <source>in arithmetic contexts like &lt;code&gt;((count++))&lt;/code&gt;, &lt;code&gt;&quot;${arr[idx]}&quot;&lt;/code&gt;, &lt;code&gt;&quot;${string:start:length}&quot;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;((count++))&lt;/code&gt; ， &lt;code&gt;&quot;${arr[idx]}&quot;&lt;/code&gt; ， &lt;code&gt;&quot;${string:start:length}&quot;&lt;/code&gt; 等算术上下文中</target>
        </trans-unit>
        <trans-unit id="00c8bf297bc8ae6bd9a198204ec1be2d51af7f94" translate="yes" xml:space="preserve">
          <source>inside &lt;code&gt;[[ ]]&lt;/code&gt; expression which is free from word splitting and globbing issues (this is a matter of style and opinions can vary widely)</source>
          <target state="translated">内部 &lt;code&gt;[[ ]]&lt;/code&gt; 表达式中没有分词和通配问题（这是样式问题，意见可能有很大不同）</target>
        </trans-unit>
        <trans-unit id="c4d6e9627c34eb58a1eea6d1992d6b74937dfd97" translate="yes" xml:space="preserve">
          <source>literal strings that need interpolation to be suppressed ( &lt;code&gt;'Really costs $$!'&lt;/code&gt;, &lt;code&gt;'just a backslash followed by a t: \t'&lt;/code&gt;)</source>
          <target state="translated">需要抑制插值的文字字符串（ &lt;code&gt;'Really costs $$!'&lt;/code&gt; ， &lt;code&gt;'just a backslash followed by a t: \t'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5acf883ec1db9dead0c49352f4358c26aeb815fe" translate="yes" xml:space="preserve">
          <source>literal strings with whitespace (&lt;code&gt;&quot;StackOverflow rocks!&quot;&lt;/code&gt;, &lt;code&gt;&quot;Steve's Apple&quot;&lt;/code&gt;)</source>
          <target state="translated">带空格的文字字符串（ &lt;code&gt;&quot;StackOverflow rocks!&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Steve's Apple&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1190a37ac3e7e62b6dc2927f0c581dd1b0cc2c4a" translate="yes" xml:space="preserve">
          <source>regex literals that need interpolation to be suppressed</source>
          <target state="translated">需要插值的字库</target>
        </trans-unit>
        <trans-unit id="7afcbc7133a9bfa9f7695cf3ed6ea8f923559126" translate="yes" xml:space="preserve">
          <source>to protect double quotes (&lt;code&gt;'The &quot;crux&quot;'&lt;/code&gt;)</source>
          <target state="translated">保护双引号（ &lt;code&gt;'The &quot;crux&quot;'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5a427cc565039cdb9848ceddca07212cb2ac6aa5" translate="yes" xml:space="preserve">
          <source>to protect single quotes (&lt;code&gt;&quot;single'quote'delimited'string&quot;&lt;/code&gt;)</source>
          <target state="translated">保护单引号（ &lt;code&gt;&quot;single'quote'delimited'string&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="88e68764b2cd68e45dbca11e7896feabad14a64e" translate="yes" xml:space="preserve">
          <source>use shell quoting for literals involving special characters (&lt;code&gt;$'\n\t'&lt;/code&gt;)</source>
          <target state="translated">对包含特殊字符（ &lt;code&gt;$'\n\t'&lt;/code&gt; ）的文字使用外壳引号</target>
        </trans-unit>
        <trans-unit id="054395cc1a9331195a21aa9529f181c98fef1dc2" translate="yes" xml:space="preserve">
          <source>use shell quoting where we need to protect several single and double quotes (&lt;code&gt;$'{&quot;table&quot;: &quot;users&quot;, &quot;where&quot;: &quot;first_name&quot;=\'Steve\'}'&lt;/code&gt;)</source>
          <target state="translated">在需要保护多个单引号和双引号的地方使用外壳引号（ &lt;code&gt;$'{&quot;table&quot;: &quot;users&quot;, &quot;where&quot;: &quot;first_name&quot;=\'Steve\'}'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="cef7889538529bccee6ed683f5e9ceaa3cc8a566" translate="yes" xml:space="preserve">
          <source>variable expansions (&lt;code&gt;&quot;$var&quot;&lt;/code&gt;, &lt;code&gt;&quot;${arr[@]}&quot;&lt;/code&gt;)</source>
          <target state="translated">变量扩展（ &lt;code&gt;&quot;$var&quot;&lt;/code&gt; ， &lt;code&gt;&quot;${arr[@]}&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="96f338e51dda580c323e3544dc476fee880b6a1a" translate="yes" xml:space="preserve">
          <source>where we want &lt;code&gt;~&lt;/code&gt; to be interpreted as &lt;code&gt;$HOME&lt;/code&gt; (&lt;code&gt;~/&quot;some dir&quot;&lt;/code&gt; but not &lt;code&gt;&quot;~/some dir&quot;&lt;/code&gt;)</source>
          <target state="translated">我们希望 &lt;code&gt;~&lt;/code&gt; 被解释为 &lt;code&gt;$HOME&lt;/code&gt; （ &lt;code&gt;~/&quot;some dir&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;~/some dir&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e8a753b52738ba5d0807eef6dbde281e8f3d225e" translate="yes" xml:space="preserve">
          <source>where we want globbing (&lt;code&gt;for txtfile in *.txt; do ...&lt;/code&gt;)</source>
          <target state="translated">我们想要浏览的位置（ &lt;code&gt;for txtfile in *.txt; do ...&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f673e3859c82d5187c762a06882bc0f49d37ddef" translate="yes" xml:space="preserve">
          <source>where we want word splitting (&lt;code&gt;for word in $words&lt;/code&gt;)</source>
          <target state="translated">我们要分词的地方（ &lt;code&gt;for word in $words&lt;/code&gt; ）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
