<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/10067266">
    <body>
      <group id="10067266">
        <trans-unit id="29fd3f854b887de70c267ec7c5f6d62874f253e1" translate="yes" xml:space="preserve">
          <source>(Of course, this also happens if the URL is in an unquoted variable.) For a static string, single quotes make the most sense, although any form of quoting or escaping works here.</source>
          <target state="translated">(물론, URL이 인용되지 않은 변수에있는 경우에도 발생합니다.) 정적 문자열의 경우 작은 따옴표가 가장 적합하지만 모든 인용 또는 이스케이프 형식이 여기에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e75e43676033b8825952394396f0bdb6b34f9132" translate="yes" xml:space="preserve">
          <source>(The loop is completely superfluous in the latter example; &lt;code&gt;printf&lt;/code&gt; specifically works fine with multiple arguments. &lt;code&gt;stat&lt;/code&gt; too.  But looping over a wildcard match is a common problem, and frequently done incorrectly.)</source>
          <target state="translated">(후자는 예제에서 루프가 완전히 불필요한 것입니다. &lt;code&gt;printf&lt;/code&gt; 는 특히 여러 개의 인수와 함께 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b3b5b7a51be079d9e32c2b061011fd5033a272d3" translate="yes" xml:space="preserve">
          <source>(The loop only runs once, over the literal single-quoted string.)</source>
          <target state="translated">(루프는 작은 따옴표로 묶인 문자열보다 한 번만 실행됩니다.)</target>
        </trans-unit>
        <trans-unit id="a62e7a96f381e21c77f5f03189a31cb8761fb2d2" translate="yes" xml:space="preserve">
          <source>(The loop only runs once, over the single, quoted string.)</source>
          <target state="translated">루프는 작은 따옴표로 묶인 문자열에 대해 한 번만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e14130d7ea68f1fbe59aa0abc0d1fa4083bc5b1b" translate="yes" xml:space="preserve">
          <source>(There is no file named &lt;code&gt;$pattern&lt;/code&gt;, either!)</source>
          <target state="translated">( &lt;code&gt;$pattern&lt;/code&gt; 이라는 파일도 없습니다!)</target>
        </trans-unit>
        <trans-unit id="d675d362f86f01512076207502a183a15503624a" translate="yes" xml:space="preserve">
          <source>(There is no file named literally &lt;code&gt;file*.txt&lt;/code&gt;.)</source>
          <target state="translated">(말 그대로 &lt;code&gt;file*.txt&lt;/code&gt; 라는 파일이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="29898fff78243cab08dc3cc8940f533c439e0d0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$?&lt;/code&gt; doesn't need quotes since it's a numeric value. Whether &lt;code&gt;$URL&lt;/code&gt; needs it depends on what you allow in there and whether you still want an argument if it's empty.</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 숫자 값이므로 따옴표가 필요하지 않습니다. &lt;code&gt;$URL&lt;/code&gt; 필요한지 여부는 허용 범위와 비어있는 경우 여전히 인수를 원하는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="27df154497c68d91d87683896cfc44fea7cea1e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Double quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;큰 따옴표&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c5864f833f59c5a8a0137c4d2afe109235f6656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;따옴표 없음&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b557581d58744e25e1f1ff2a2f625fe4c2d3b5ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Single quotes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작은 따옴표&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c13ac318dfb25d9609eaabd5136933f8f64cd210" translate="yes" xml:space="preserve">
          <source>A variable containing a list of tokens to loop over or a wildcard to expand is less frequently seen, so we sometimes abbreviate to &quot;quote everything unless you know precisely what you are doing&quot;.</source>
          <target state="translated">반복 할 토큰 목록 또는 확장 할 와일드 카드가 포함 된 변수는 자주 표시되지 않으므로 &quot;정확히 수행중인 작업을 정확히 알지 않는 한 모든 것을 인용&quot;하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3222f0efe19396bc34dc4ae8d1cb67a63216d6c6" translate="yes" xml:space="preserve">
          <source>And if so, why?</source>
          <target state="translated">그렇다면 왜 그렇습니까?</target>
        </trans-unit>
        <trans-unit id="3785a2a188704d23953a5659e27c337b1d1de4b3" translate="yes" xml:space="preserve">
          <source>As an aside, scripts &lt;a href=&quot;http://mywiki.wooledge.org/ParsingLs&quot;&gt;should usually not use &lt;code&gt;ls&lt;/code&gt; for anything.&lt;/a&gt;  To expand a wildcard, just ... use it.</source>
          <target state="translated">따로, 스크립트 &lt;a href=&quot;http://mywiki.wooledge.org/ParsingLs&quot;&gt;는 보통 &lt;code&gt;ls&lt;/code&gt; 를 사용해서는 안됩니다.&lt;/a&gt; 와일드 카드를 확장하려면 그냥 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a3b82194ee5f88012f978f13a9f48b8293490ae" translate="yes" xml:space="preserve">
          <source>Bash parameter expansion (&lt;code&gt;&quot;${filename##*/}&quot;&lt;/code&gt;)</source>
          <target state="translated">배시 매개 변수 확장 ( &lt;code&gt;&quot;${filename##*/}&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="57758dc45638caa5df2bbed2cb6a9858858010c4" translate="yes" xml:space="preserve">
          <source>By contrast:</source>
          <target state="translated">대조적으로 :</target>
        </trans-unit>
        <trans-unit id="b04f4a7fc53a3b1cd276b55f41b73ecb06f580ea" translate="yes" xml:space="preserve">
          <source>Could someone tell me whether or not I should wrap quotes around variables in a shell script?</source>
          <target state="translated">누군가 쉘 스크립트에서 변수 주위에 따옴표를 묶어야하는지 여부를 말해 줄 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="62c11a34294e0f0be58f971653b654ab56174a59" translate="yes" xml:space="preserve">
          <source>Difference between single and double quotes in Bash</source>
          <target state="translated">Bash에서 작은 따옴표와 큰 따옴표의 차이점</target>
        </trans-unit>
        <trans-unit id="d17352112f221c89ded84084a22cdb430e8a3ce0" translate="yes" xml:space="preserve">
          <source>Double quotes are suitable when variable interpolation is required.  With suitable adaptations, it is also a good workaround when you need single quotes in the string.  (There is no straightforward way to escape a single quote between single quotes, because there is no escape mechanism inside single quotes -- if there was, they would not quote completely verbatim.)</source>
          <target state="translated">가변 보간이 필요한 경우 큰 따옴표가 적합합니다. 적절한 조정을 사용하면 문자열에 작은 따옴표가 필요할 때도 좋은 해결 방법입니다. 작은 따옴표 안에는 이스케이프 메커니즘이 없기 때문에 작은 따옴표 사이에 작은 따옴표를 이스케이프하는 간단한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c9cb1bd3a0f4351c0c8efb774a478ff510fec2bf" translate="yes" xml:space="preserve">
          <source>For example, is the following correct:</source>
          <target state="translated">예를 들어 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="151056fa0605d3905394b3928a4f6252ee33612c" translate="yes" xml:space="preserve">
          <source>For using the variables in the shell script use &quot; &quot; quoted variables as the quoted one means that the variable may contain spaces or special character which won't affect the execution of your shell script. Else if you are sure of not having any spaces or special character in your variable name then you may use them without &quot; &quot;.</source>
          <target state="translated">쉘 스크립트에서 변수를 사용하려면 인용 된 변수로 &quot;&quot;인용 된 변수를 사용하십시오. 변수에 공백 또는 특수 문자가 포함되어 쉘 스크립트의 실행에 영향을 미치지 않을 수 있음을 의미합니다. 그렇지 않으면 변수 이름에 공백이나 특수 문자가없는 경우 &quot;&quot;없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dad12a999af9dd77c56aef7ff53113954aad61e3" translate="yes" xml:space="preserve">
          <source>General rule: quote it if it can either be empty or contain spaces (or any whitespace really) or special characters (wildcards). Not quoting strings with spaces often leads to the shell breaking apart a single argument into many.</source>
          <target state="translated">일반 규칙 : 비어 있거나 공백 (또는 실제로 공백) 또는 특수 문자 (와일드 카드)를 포함 할 수 있으면 인용하십시오. 공백으로 문자열을 인용하지 않으면 쉘이 단일 인수를 여러 개로 나누는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="f5a242201e6b18c260832b69054eb43c8fbc2aba" translate="yes" xml:space="preserve">
          <source>Here is a three-point formula for quotes in general:</source>
          <target state="translated">일반적으로 따옴표에 대한 3 점 공식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d089f893e07ab81bae1415dc085018dee0e09dbc" translate="yes" xml:space="preserve">
          <source>I do use &lt;code&gt;$var&lt;/code&gt; as a simple way to join lines:</source>
          <target state="translated">나는 라인을 결합하는 간단한 방법으로 &lt;code&gt;$var&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d5e34758580d5c070bff9a648e9fdbe239ea46e4" translate="yes" xml:space="preserve">
          <source>I generally use quoted like &lt;code&gt;&quot;$var&quot;&lt;/code&gt; for safe, unless I am sure that &lt;code&gt;$var&lt;/code&gt; does not contain space.</source>
          <target state="translated">&lt;code&gt;$var&lt;/code&gt; 공백이없는 것이 확실하지 않으면 일반적으로 안전을 위해 &lt;code&gt;&quot;$var&quot;&lt;/code&gt; 와 같이 따옴표를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06b17da92223ef3ce239ff6ab88770fe677ad1de" translate="yes" xml:space="preserve">
          <source>I tend to always quote strings just out of habit since it's safer that way.</source>
          <target state="translated">나는 문자열이 그렇게 안전하기 때문에 항상 습관에서 벗어나 인용하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec439701c2466909be80a27184c5571e88afefb3" translate="yes" xml:space="preserve">
          <source>In contexts where we are absolutely sure that there are no word splitting or globbing issues or we &lt;em&gt;do want word splitting and globbing&lt;/em&gt;.</source>
          <target state="translated">단어 분리 또는 글 로빙 문제가 전혀 없거나 단어 분리 및 글 로빙을 &lt;em&gt;원할 경우&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3b59209984bb16c283fcc6e7768175ac0fd17063" translate="yes" xml:space="preserve">
          <source>In contexts where we want to suppress word splitting and globbing. Also in contexts where we want the literal to be treated as a string, not a regex.</source>
          <target state="translated">단어 분리 및 글 로빙을 억제하려는 상황에서. 또한 리터럴이 정규식이 아닌 문자열로 처리되기를 원하는 컨텍스트에서.</target>
        </trans-unit>
        <trans-unit id="f939321e88ed3abfa39a256aa72ba3960b7cb7a2" translate="yes" xml:space="preserve">
          <source>In more concrete terms, anything containing a filename should usually be quoted (because filenames can contain whitespace and other shell metacharacters).  Anything containing a URL should usually be quoted (because many URLs contain shell metacharacters like &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt;).  Anything containing a regex should usually be quoted (ditto ditto).  Anything containing significant whitespace other than single spaces between non-whitespace characters needs to be quoted (because otherwise, the shell will munge the whitespace into, effectively, single spaces, and trim any leading or trailing whitespace).</source>
          <target state="translated">좀 더 구체적으로 말하면 파일 이름을 포함하는 모든 항목은 일반적으로 인용해야합니다 (파일 이름은 공백 및 기타 셸 메타 문자를 포함 할 수 있기 때문에). URL을 포함하는 것은 일반적으로 따옴표로 묶어야합니다 (많은 URL에 &lt;code&gt;?&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 셸 메타 문자가 포함되어 있기 때문에). 정규식을 포함하는 것은 일반적으로 인용해야합니다 (ditto ditto). 공백이 아닌 문자 사이에 단일 공백 ​​이외의 공백이 포함 된 것은 따옴표로 묶어야합니다 (그렇지 않으면 쉘은 공백을 효과적으로 단일 공백으로 축소하고 앞뒤 공백을 잘라냅니다).</target>
        </trans-unit>
        <trans-unit id="59a3873fba3332922756bc32b3c13b44d0217b04" translate="yes" xml:space="preserve">
          <source>In short, quote everything where you do not require the shell to perform token splitting and wildcard expansion.</source>
          <target state="translated">간단히 말해, 쉘이 토큰 분할 및 와일드 카드 확장을 수행하지 않아도되는 모든 것을 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4d6c9aa733db1b4d38cbcf25cc20311f87dd5bd" translate="yes" xml:space="preserve">
          <source>In string literals where we want to suppress interpolation and special treatment of backslashes. In other words, situations where using double quotes would be inappropriate.</source>
          <target state="translated">백 슬래시의 보간 및 특수 처리를 억제하려는 문자열 리터럴에서. 즉, 큰 따옴표를 사용하는 것이 부적절한 상황입니다.</target>
        </trans-unit>
        <trans-unit id="84af93e8bce1ae5fb2260de3492df002a2a4f03c" translate="yes" xml:space="preserve">
          <source>No quotes are suitable when you specifically require the shell to perform token splitting and/or wildcard expansion.</source>
          <target state="translated">쉘이 토큰 분할 및 / 또는 와일드 카드 확장을 수행하도록 특별히 요구할 때는 따옴표가 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fa884c8c5bdc62d4775d1d0d104d5d6c681dd89" translate="yes" xml:space="preserve">
          <source>Quotes and escaping - Bash Hackers' Wiki</source>
          <target state="translated">따옴표와 탈출-Bash Hackers 'Wiki</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="bcabae38fbf5e1055fdfb65c2272617889d7c092" translate="yes" xml:space="preserve">
          <source>Single quotes protect the text between them verbatim.  It is the proper tool when you need to ensure that the shell does not touch the string at all.  Typically, it is the quoting mechanism of choice when you do not require variable interpolation.</source>
          <target state="translated">작은 따옴표는 그 사이의 텍스트를 그대로 보호합니다. 쉘이 끈에 전혀 닿지 않도록해야 할 때 적절한 도구입니다. 일반적으로 변수 보간이 필요하지 않은 경우 인용 메커니즘이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="2e161335e1f8eeaacb87546a6509dbdaab9d2fe2" translate="yes" xml:space="preserve">
          <source>The last example also suggests another useful concept, which I like to call &quot;seesaw quoting&quot;. If you need to mix single and double quotes, you can use them adjacent to each other. For example, the following quoted strings</source>
          <target state="translated">마지막 예제는 또 다른 유용한 개념을 제안하는데, 이것을 &quot;시소 인용&quot;이라고 부릅니다. 작은 따옴표와 큰 따옴표를 혼합해야하는 경우 서로 인접한 따옴표를 사용할 수 있습니다. 예를 들어, 다음 인용 문자열</target>
        </trans-unit>
        <trans-unit id="9e76dcfe4eb30da618b643dcc3d5d0d277cf14c1" translate="yes" xml:space="preserve">
          <source>This isn't awfully legible, but it's a common technique and thus good to know.</source>
          <target state="translated">이것은 끔찍하게 읽을 수는 없지만 일반적인 기술이므로 알기에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5572ec42cf62f2e7a9cd4ada274dc621586474d2" translate="yes" xml:space="preserve">
          <source>Token splitting;</source>
          <target state="translated">토큰 분할;</target>
        </trans-unit>
        <trans-unit id="b4e32ab8b1dec3cfd10f9a7c2386e171cf06f28b" translate="yes" xml:space="preserve">
          <source>Values which are not variables basically follow the same rules, though you could then also escape any metacharacters instead of quoting them. For a common example, a URL with a &lt;code&gt;&amp;amp;&lt;/code&gt; in it will be parsed by the shell as a background command unless the metacharacter is escaped or quoted:</source>
          <target state="translated">변수가 아닌 값은 기본적으로 동일한 규칙을 따르지만 메타 문자를 인용하는 대신 이스케이프 처리 할 수도 있습니다. 일반적인 예를 들어, 메타 문자가 이스케이프되거나 인용되지 않는 한 쉘에 &lt;code&gt;&amp;amp;&lt;/code&gt; 가 포함 된 URL은 백그라운드 명령으로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a268b7f726857d85b69c3da170c0e07d632e94" translate="yes" xml:space="preserve">
          <source>What are the special dollar sign shell variables?</source>
          <target state="translated">특수 달러 기호 쉘 변수는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f53c17e29d0f0b4bf9ec0df6f70ec391904d6877" translate="yes" xml:space="preserve">
          <source>When is double quoting necessary?</source>
          <target state="translated">큰 따옴표는 언제 필요합니까?</target>
        </trans-unit>
        <trans-unit id="c2c0d9510460feeeeb5e7d81b6f01442f6bb1b61" translate="yes" xml:space="preserve">
          <source>When to wrap quotes around a shell variable</source>
          <target state="translated">쉘 변수를 따옴표로 묶을 때</target>
        </trans-unit>
        <trans-unit id="aba4621454c4be08c79d5714683b0614786c9e85" translate="yes" xml:space="preserve">
          <source>When you know that a variable can only contain a value which contains no shell metacharacters, quoting is optional.  Thus, an unquoted &lt;code&gt;$?&lt;/code&gt; is basically fine, because this variable can only ever contain a single number.  However, &lt;code&gt;&quot;$?&quot;&lt;/code&gt; is also correct, and recommended for general consistency and correctness (though this is my personal recommendation, not a widely recognized policy).</source>
          <target state="translated">변수에 쉘 메타 문자를 포함하지 않는 값만 포함 할 수 있다는 것을 알고 있으면 인용은 선택 사항입니다. 따라서 인용되지 않은 &lt;code&gt;$?&lt;/code&gt; 이 변수는 단일 숫자 만 포함 할 수 있기 때문에 기본적으로 좋습니다. 그러나 &lt;code&gt;&quot;$?&quot;&lt;/code&gt; 또한 정확하고 일반적인 일관성과 정확성을 위해 권장됩니다 (일반적으로 인정되는 정책이 아니라 개인적 권장 사항 임).</target>
        </trans-unit>
        <trans-unit id="4fa8325b049d6a079d3e5f8128091f49749ffbd7" translate="yes" xml:space="preserve">
          <source>Wildcard expansion:</source>
          <target state="translated">와일드 카드 확장 :</target>
        </trans-unit>
        <trans-unit id="85ad4c94f8320e804977d9adc1bae6f86de1921a" translate="yes" xml:space="preserve">
          <source>around standard numeric variables (&lt;code&gt;$$&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, &lt;code&gt;$#&lt;/code&gt; etc.)</source>
          <target state="translated">표준 숫자 변수 주위 ( &lt;code&gt;$$&lt;/code&gt; , &lt;code&gt;$?&lt;/code&gt; ?, &lt;code&gt;$#&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="9348a580f1e89ae695aee7326f94273b8c218efc" translate="yes" xml:space="preserve">
          <source>can be pasted together back to back, forming a single long string after tokenization and quote removal.</source>
          <target state="translated">토큰 화 및 따옴표 제거 후에 하나의 긴 문자열을 형성하여 연속적으로 붙여 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eca7cf51e8bce5bf586b8b2a42970e21dce9728" translate="yes" xml:space="preserve">
          <source>command names and arguments that have whitespace in them</source>
          <target state="translated">공백이있는 명령 이름 및 인수</target>
        </trans-unit>
        <trans-unit id="1c92a162d04b1909da4b43f55844bab9f286483e" translate="yes" xml:space="preserve">
          <source>command substitutions (&lt;code&gt;&quot;$(ls)&quot;&lt;/code&gt;, &lt;code&gt;&quot;`ls`&quot;&lt;/code&gt;)</source>
          <target state="translated">명령 대체 ( &lt;code&gt;&quot;$(ls)&quot;&lt;/code&gt; , &lt;code&gt;&quot;`ls`&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cc7c42e3356a925dec68daa8d37620f9445d8fc3" translate="yes" xml:space="preserve">
          <source>echo &quot;$url name&quot;  --  ( Cannot be used at such situations so take precaution before using it )</source>
          <target state="translated">echo &quot;$ url name&quot;-(이런 상황에서는 사용할 수 없으므로 사용하기 전에 예방 조치를 취하십시오)</target>
        </trans-unit>
        <trans-unit id="99b231f14cbc77242a56e3332e58018f67ab0832" translate="yes" xml:space="preserve">
          <source>echo &quot;$url name&quot;  -- ( Can be used at all times )</source>
          <target state="translated">echo &quot;$ url name&quot;-(항상 사용 가능)</target>
        </trans-unit>
        <trans-unit id="4eb1a73b2bfdcb3cfef0c6c93b604815ec5303d7" translate="yes" xml:space="preserve">
          <source>globs where directory path or file name part includes spaces (&lt;code&gt;&quot;/my dir/&quot;*&lt;/code&gt;)</source>
          <target state="translated">디렉토리 경로 또는 파일 이름 부분에 공백이 포함 된 곳 ( &lt;code&gt;&quot;/my dir/&quot;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="431657c47eea42a005d52a4986263ae27098fba8" translate="yes" xml:space="preserve">
          <source>in arithmetic contexts like &lt;code&gt;((count++))&lt;/code&gt;, &lt;code&gt;&quot;${arr[idx]}&quot;&lt;/code&gt;, &lt;code&gt;&quot;${string:start:length}&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;((count++))&lt;/code&gt; , &lt;code&gt;&quot;${arr[idx]}&quot;&lt;/code&gt; , &lt;code&gt;&quot;${string:start:length}&quot;&lt;/code&gt; 와 같은 산술 컨텍스트에서</target>
        </trans-unit>
        <trans-unit id="00c8bf297bc8ae6bd9a198204ec1be2d51af7f94" translate="yes" xml:space="preserve">
          <source>inside &lt;code&gt;[[ ]]&lt;/code&gt; expression which is free from word splitting and globbing issues (this is a matter of style and opinions can vary widely)</source>
          <target state="translated">내부의 &lt;code&gt;[[ ]]&lt;/code&gt; 표현은 단어 분리 및 글 로빙 문제가 없음 (스타일의 문제이며 의견은 다양 할 수 있음)</target>
        </trans-unit>
        <trans-unit id="c4d6e9627c34eb58a1eea6d1992d6b74937dfd97" translate="yes" xml:space="preserve">
          <source>literal strings that need interpolation to be suppressed ( &lt;code&gt;'Really costs $$!'&lt;/code&gt;, &lt;code&gt;'just a backslash followed by a t: \t'&lt;/code&gt;)</source>
          <target state="translated">보간을 억제해야하는 리터럴 문자열 ( &lt;code&gt;'Really costs $$!'&lt;/code&gt; , &lt;code&gt;'just a backslash followed by a t: \t'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5acf883ec1db9dead0c49352f4358c26aeb815fe" translate="yes" xml:space="preserve">
          <source>literal strings with whitespace (&lt;code&gt;&quot;StackOverflow rocks!&quot;&lt;/code&gt;, &lt;code&gt;&quot;Steve's Apple&quot;&lt;/code&gt;)</source>
          <target state="translated">공백이있는 리터럴 문자열 ( &lt;code&gt;&quot;StackOverflow rocks!&quot;&lt;/code&gt; , &lt;code&gt;&quot;Steve's Apple&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1190a37ac3e7e62b6dc2927f0c581dd1b0cc2c4a" translate="yes" xml:space="preserve">
          <source>regex literals that need interpolation to be suppressed</source>
          <target state="translated">보간을 억제해야하는 정규식 리터럴</target>
        </trans-unit>
        <trans-unit id="7afcbc7133a9bfa9f7695cf3ed6ea8f923559126" translate="yes" xml:space="preserve">
          <source>to protect double quotes (&lt;code&gt;'The &quot;crux&quot;'&lt;/code&gt;)</source>
          <target state="translated">큰 따옴표를 보호하기 위해 ( &lt;code&gt;'The &quot;crux&quot;'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5a427cc565039cdb9848ceddca07212cb2ac6aa5" translate="yes" xml:space="preserve">
          <source>to protect single quotes (&lt;code&gt;&quot;single'quote'delimited'string&quot;&lt;/code&gt;)</source>
          <target state="translated">작은 따옴표를 보호하기 위해 ( &lt;code&gt;&quot;single'quote'delimited'string&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="88e68764b2cd68e45dbca11e7896feabad14a64e" translate="yes" xml:space="preserve">
          <source>use shell quoting for literals involving special characters (&lt;code&gt;$'\n\t'&lt;/code&gt;)</source>
          <target state="translated">특수 문자 ( &lt;code&gt;$'\n\t'&lt;/code&gt; )와 관련된 리터럴에 쉘 인용 사용</target>
        </trans-unit>
        <trans-unit id="054395cc1a9331195a21aa9529f181c98fef1dc2" translate="yes" xml:space="preserve">
          <source>use shell quoting where we need to protect several single and double quotes (&lt;code&gt;$'{&quot;table&quot;: &quot;users&quot;, &quot;where&quot;: &quot;first_name&quot;=\'Steve\'}'&lt;/code&gt;)</source>
          <target state="translated">여러 개의 작은 따옴표와 큰 따옴표를 보호 해야하는 곳에 셸 따옴표를 사용하십시오 ( &lt;code&gt;$'{&quot;table&quot;: &quot;users&quot;, &quot;where&quot;: &quot;first_name&quot;=\'Steve\'}'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cef7889538529bccee6ed683f5e9ceaa3cc8a566" translate="yes" xml:space="preserve">
          <source>variable expansions (&lt;code&gt;&quot;$var&quot;&lt;/code&gt;, &lt;code&gt;&quot;${arr[@]}&quot;&lt;/code&gt;)</source>
          <target state="translated">변수 확장 ( &lt;code&gt;&quot;$var&quot;&lt;/code&gt; , &lt;code&gt;&quot;${arr[@]}&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="96f338e51dda580c323e3544dc476fee880b6a1a" translate="yes" xml:space="preserve">
          <source>where we want &lt;code&gt;~&lt;/code&gt; to be interpreted as &lt;code&gt;$HOME&lt;/code&gt; (&lt;code&gt;~/&quot;some dir&quot;&lt;/code&gt; but not &lt;code&gt;&quot;~/some dir&quot;&lt;/code&gt;)</source>
          <target state="translated">여기서 &lt;code&gt;~&lt;/code&gt; 는 &lt;code&gt;$HOME&lt;/code&gt; 으로 해석되기를 원합니다 ( &lt;code&gt;~/&quot;some dir&quot;&lt;/code&gt; 이지만 &lt;code&gt;&quot;~/some dir&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e8a753b52738ba5d0807eef6dbde281e8f3d225e" translate="yes" xml:space="preserve">
          <source>where we want globbing (&lt;code&gt;for txtfile in *.txt; do ...&lt;/code&gt;)</source>
          <target state="translated">우리가 globbing 할 곳 ( &lt;code&gt;for txtfile in *.txt; do ...&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f673e3859c82d5187c762a06882bc0f49d37ddef" translate="yes" xml:space="preserve">
          <source>where we want word splitting (&lt;code&gt;for word in $words&lt;/code&gt;)</source>
          <target state="translated">우리는 단어 분할을 원합니다 ( &lt;code&gt;for word in $words&lt;/code&gt; )</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
