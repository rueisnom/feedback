<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/4244896">
    <body>
      <group id="4244896">
        <trans-unit id="c25a232090a075394a2c0ea94d2f48e5b00f9443" translate="yes" xml:space="preserve">
          <source>...does get, and does set. It is what I use, the only downside is you got to know JQuery, but this is honestly one of the very many good reasons that every Javascript Developer should learn JQuery, it just makes life easy, and offers methods, like this one, which is not available with standard Javascript.
Hope this helps someone!!!</source>
          <target state="translated">...は取得、設定を行います。これは私が使っているもので、唯一の欠点はJQueryを知らなければならないことだが、これは正直言って、すべてのJavascript開発者がJQueryを学ぶべき非常に多くの良い理由の一つであり、人生を楽にし、標準的なJavascriptでは利用できないメソッドを提供している。この記事が誰かのお役に立てれば幸いです。</target>
        </trans-unit>
        <trans-unit id="9fac3d93857c0fb8f4bef5e89d7bbed95b49b5d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.w3schools.com/jsref/jsref_getcomputedstyle.asp&quot;&gt;W3Schools getComputedValue Doc&lt;/a&gt; This gives a good example, and lets you play with it, however, this link &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value&quot;&gt;Mozilla CSS getComputedValue doc&lt;/a&gt; talks about the getComputedValue function in detail, and should be read by any aspiring developer who isn't totally clear on this subject.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3schools.com/jsref/jsref_getcomputedstyle.asp&quot;&gt;W3Schools getComputedValue Doc&lt;/a&gt;これは良い例であり、 試してみることができますが、このリンク&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value&quot;&gt;Mozilla CSS getComputedValue Doc&lt;/a&gt;はgetComputedValue関数について詳しく説明しており、この主題について完全に明確ではない開発者は読む必要があります。</target>
        </trans-unit>
        <trans-unit id="972a33f942039a3a3949adc61004acb034b7b096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;&lt;em&gt;&lt;a href=&quot;https://jsfiddle.net/sb2ofndy/&quot;&gt;jsfiddle&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;&lt;em&gt;&lt;a href=&quot;https://jsfiddle.net/sb2ofndy/&quot;&gt;jsfiddle&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3e2ac84f369516b4679504380704ab691b46d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object destructuring&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オブジェクトの破壊&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e71c4b21183bc960b08fecf2f982d00528e1feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax: object[propery}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;構文：object [propery}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c643f909c24e9c6fe6ffe8f40faf79ddc5b79028" translate="yes" xml:space="preserve">
          <source>Accessing root properties in object is easily achieved with &lt;code&gt;obj[variable]&lt;/code&gt;, but getting nested complicates thing. Not to write already written code I suggest to use &lt;code&gt;lodash.get&lt;/code&gt;.</source>
          <target state="translated">オブジェクトのルートプロパティへのアクセスは、 &lt;code&gt;obj[variable]&lt;/code&gt; して簡単に実現できますが、入れ子にすると複雑になります。 すでに書かれたコードを書かないために、 &lt;code&gt;lodash.get&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2458e6a451d94dc8ed4928ae8f51181b5f7505c5" translate="yes" xml:space="preserve">
          <source>As a side note, the getComputedValue method only gets, it does not set. This, obviously is a major downside, however there is a method that gets from CSS style-sheets, as well as sets values, though it is not standard Javascript.
The JQuery method...</source>
          <target state="translated">余談ですが、getComputedValueメソッドは取得するだけで、設定はしません。これは明らかに大きな欠点ですが、標準的なJavascriptではありませんが、CSSスタイルシートから取得し、値を設定するメソッドがあります。JQueryメソッド...</target>
        </trans-unit>
        <trans-unit id="574fd35796c44aee0aa95b671e86d5bbf53e0e1c" translate="yes" xml:space="preserve">
          <source>Both dot and bracket notation also work as expected for nested objects:</source>
          <target state="translated">ドット表記もカッコ表記も、入れ子になったオブジェクトでは期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="100b7f9acafb0a410aae5ec157e6e2257f1c9a81" translate="yes" xml:space="preserve">
          <source>Bracket notation: &lt;code&gt;something['bar']&lt;/code&gt;</source>
          <target state="translated">ブラケット表記： &lt;code&gt;something['bar']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826d15187714c567527286ff90b53701b7812cc5" translate="yes" xml:space="preserve">
          <source>But only second case allows to access properties dynamically:</source>
          <target state="translated">しかし、2番目のケースでは、プロパティに動的にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="33224c361c9a7c3bd3d441c33da01cd6061e3422" translate="yes" xml:space="preserve">
          <source>Cheers!</source>
          <target state="translated">Cheers!</target>
        </trans-unit>
        <trans-unit id="176d2d27407b883b38dbc37b0ab15b4f40caea07" translate="yes" xml:space="preserve">
          <source>Dot notation: &lt;code&gt;something.bar&lt;/code&gt;</source>
          <target state="translated">ドット表記： &lt;code&gt;something.bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3531c1f73bb03f602e7bec16f4152d300db145e9" translate="yes" xml:space="preserve">
          <source>Dynamically access object property using variable</source>
          <target state="translated">変数を使ってオブジェクトのプロパティに動的にアクセスする</target>
        </trans-unit>
        <trans-unit id="72d2971f8b0dd52d0f70eb306db1f5b4576d457c" translate="yes" xml:space="preserve">
          <source>ES5 // Check Deeply Nested Variables</source>
          <target state="translated">ES5/深く入れ子になっている変数のチェック</target>
        </trans-unit>
        <trans-unit id="540d4bfb3f3963908155e7756b108079c9c3bb38" translate="yes" xml:space="preserve">
          <source>Ex. - a deeply nested array of objects:</source>
          <target state="translated">例-オブジェクトの深い入れ子になった配列。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="c7bcc52db88528b7b02efbf655be86ac20bfc285" translate="yes" xml:space="preserve">
          <source>Firstly I want to address that there are several ways to obtain the value of a property and store it in a dynamic Variable. The first most popular, and easiest way IMHO would be:</source>
          <target state="translated">まず最初に、プロパティの値を取得して動的変数に格納する方法がいくつかあることに触れておきたいと思います。最初の最もポピュラーで最も簡単な方法は、IMHOでは次のようになります。</target>
        </trans-unit>
        <trans-unit id="507a1593e5924a1a3698a78b330a2da5ef3ede16" translate="yes" xml:space="preserve">
          <source>Following is an ES6 example of how you can access the property of an object using a property name that has been dynamically generated by concatenating two strings.</source>
          <target state="translated">以下は、2 つの文字列を連結して動的に生成されたプロパティ名を使用して、オブジェクトのプロパティにアクセスする方法の ES6 の例です。</target>
        </trans-unit>
        <trans-unit id="3dd26891ee75d1677720219301e02753b66b0f1a" translate="yes" xml:space="preserve">
          <source>Henceforth the getComputedStyle() method!</source>
          <target state="translated">以降、getComputedStyle()メソッド!</target>
        </trans-unit>
        <trans-unit id="d33a241581123a82e44aa78976fb98d5f4d91667" translate="yes" xml:space="preserve">
          <source>Here's a sample of a language file object like the one I wanted data from:</source>
          <target state="translated">データが欲しかった言語ファイルオブジェクトのようなサンプルです。</target>
        </trans-unit>
        <trans-unit id="842a00338e4c2a3840c891596d991a493d750a4f" translate="yes" xml:space="preserve">
          <source>I asked a question that kinda duplicated on this topic a while back, and after excessive research, and seeing a lot of information missing that should be here, I feel I have something valuable to add to this older post.</source>
          <target state="translated">先日、このトピックに重複した質問をしたのですが、過剰な研究をした結果、ここにあるべき情報がたくさん不足しているのを見て、この古い投稿に何か価値のあるものがあると感じています。</target>
        </trans-unit>
        <trans-unit id="707897a43cb9f078387a72e4b8735143038542d7" translate="yes" xml:space="preserve">
          <source>I came across a case where &lt;em&gt;I thought&lt;/em&gt; I wanted to pass the &quot;address&quot; of an object property as data to another function and populate the object (with AJAX), do lookup from address array, and display in that other function. I couldn't use dot notation without doing string acrobatics so I thought an array might be nice to pass instead. I ended-up doing something different anyway, but seemed related to this post.</source>
          <target state="translated">オブジェクトプロパティの「アドレス」をデータとして別の関数に渡し、オブジェクトに（AJAXを使用して）データを入力し、アドレス配列からルックアップして、その別の関数に表示したい&lt;em&gt;と思っ&lt;/em&gt;た場合に遭遇しました。 文字列の曲芸を行わずにドット表記を使用することはできなかったので、代わりに配列を渡すとよいと思いました。 とにかく何か違うことをしてしまいましたが、この投稿に関連しているようです。</target>
        </trans-unit>
        <trans-unit id="0832814a494a22df1c2e0d3813af3745876c268d" translate="yes" xml:space="preserve">
          <source>I created this little function that looks-up the &quot;least specific&quot; (first) address parameter, and reassigns the returned object to itself. Then it is ready to look-up the next-most-specific address parameter if one exists.</source>
          <target state="translated">私はこの小さな関数を作成しました。この関数は、&quot;最下位の&quot;(最初の)アドレス・パラメータを検索し、返されたオブジェクトを自分自身に再割り当てします。そして、次に最も特異的なアドレスパラメータが存在する場合には、それを検索する準備ができています。</target>
        </trans-unit>
        <trans-unit id="c814bfa8149a71d74493da6c18ffa015799e9e51" translate="yes" xml:space="preserve">
          <source>I have take comments below into consideration and agreed. Eval is to be avoided.</source>
          <target state="translated">以下のコメントを参考にさせていただき、同意しました。評価は避けるべきです。</target>
        </trans-unit>
        <trans-unit id="4f8ffec12cb60d47e9343d75df82945036bc5214" translate="yes" xml:space="preserve">
          <source>I wanted to be able to pass an array such as: [&quot;audioPlayer&quot;, &quot;controls&quot;, &quot;stop&quot;] to access the language text, &quot;stop&quot; in this case.</source>
          <target state="translated">のような配列を渡すことができるようにしたかった。[&quot;audioPlayer&quot;,&quot;controls&quot;,&quot;stop&quot;]のような配列を渡して、言語テキスト、この場合は &quot;stop&quot; にアクセスできるようにしたかったのです。</target>
        </trans-unit>
        <trans-unit id="00e49bdf87fbd4149bdc18f10639c5d4640d4ead" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property of an object using a dynamic name. Is this possible?</source>
          <target state="translated">動的な名前を使ってオブジェクトのプロパティにアクセスしようとしています。これは可能でしょうか?</target>
        </trans-unit>
        <trans-unit id="91280a13680e9ef6d1d2b711ba922c7fbc22fc47" translate="yes" xml:space="preserve">
          <source>If you want to get nested value dynamically (e.g. by variable), your best option will be to use &lt;code&gt;lodash&lt;/code&gt;.</source>
          <target state="translated">ネストされた値を動的に（たとえば、変数によって）取得したい場合、最良のオプションは &lt;code&gt;lodash&lt;/code&gt; を使用することです 。</target>
        </trans-unit>
        <trans-unit id="8a03446a3c744bd4e20c6a63b0fe86ebbe6067ce" translate="yes" xml:space="preserve">
          <source>In javascript we can access with:</source>
          <target state="translated">ジャバスクリプトでは、私たちは一緒にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="bda969d76438f0f7004c442304e6649095ebaca3" translate="yes" xml:space="preserve">
          <source>Instead of :</source>
          <target state="translated">の代わりに</target>
        </trans-unit>
        <trans-unit id="6fabfc3a48599c0faf28da30b525172d6ce7e23b" translate="yes" xml:space="preserve">
          <source>It gets interesting when you have to pass parameters to this function as well.</source>
          <target state="translated">この関数にもパラメータを渡さなければならないとなると、面白くなってきます。</target>
        </trans-unit>
        <trans-unit id="a21b10f7a9259ba4e8d43093e46635c7d7476672" translate="yes" xml:space="preserve">
          <source>Lodash get can be used on different ways, here is link to the documentation &lt;a href=&quot;https://lodash.com/docs/4.16.2#get&quot;&gt;lodash.get&lt;/a&gt;</source>
          <target state="translated">Lodash getはさまざまな方法で使用できます。ここにドキュメント&lt;a href=&quot;https://lodash.com/docs/4.16.2#get&quot;&gt;lodash.get&lt;/a&gt;へのリンクがあります</target>
        </trans-unit>
        <trans-unit id="27c2f3a0a0cc2f77c7527ec178c49d6519499558" translate="yes" xml:space="preserve">
          <source>The bracket notation is specially powerful as it let's you access a property based on a variable:</source>
          <target state="translated">大括弧記法は、変数に基づいてプロパティにアクセスすることができるので、特に強力です。</target>
        </trans-unit>
        <trans-unit id="2ac263e4e24512071dd0712a0859ab9284fec838" translate="yes" xml:space="preserve">
          <source>The value between the brackets can be any expression. Therefore, if the property name is stored in a variable, you have to use bracket notation:</source>
          <target state="translated">括弧の間の値は、任意の式にすることができます。したがって、プロパティ名が変数に格納されている場合は、括弧表記を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="132f275aaeff40036a6f46cc811e3754f3401cde" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors&quot;&gt;two ways to access properties&lt;/a&gt; of an object:</source>
          <target state="translated">オブジェクトの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors&quot;&gt;プロパティにアクセスするに&lt;/a&gt;は2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="9c380f38332515f6914fc7eaa0cda268da4cb375" translate="yes" xml:space="preserve">
          <source>There is a few possibilities:</source>
          <target state="translated">いくつかの可能性があります。</target>
        </trans-unit>
        <trans-unit id="cb2803628217be24d3c0fe5bdbf6820128c20e16" translate="yes" xml:space="preserve">
          <source>This can be extended to looping over every property of an object. This can be seem redundant due to newer JavaScript constructs such as for ... of ..., but helps illustrate a use case:</source>
          <target state="translated">これは、オブジェクトのすべてのプロパティをループするように拡張することができます。これは for ...of ...のような新しい JavaScript の構造のために冗長に見えるかもしれませんが、ユースケースを説明するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="d5897b72f294fb8aa0d76e3c83990ba94218ede5" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property names&lt;/a&gt;</source>
          <target state="translated">これは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;計算されたプロパティ名&lt;/a&gt;と呼ばれます</target>
        </trans-unit>
        <trans-unit id="bb351f2719c894112e98defaee21c53d17baa96e" translate="yes" xml:space="preserve">
          <source>This is my solution:</source>
          <target state="translated">これが私の解決策です。</target>
        </trans-unit>
        <trans-unit id="d26fb6c93ce3e23f974697d5258ac71dfc64789b" translate="yes" xml:space="preserve">
          <source>This simple piece of code can check for deeply nested variable / value existence without having to check each variable along the way...</source>
          <target state="translated">このシンプルなコードは、途中で各変数をチェックすることなく、深く入れ子になった変数の値の存在をチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="47b23b39759a1908e680a0a3b5cb3c99d6de735e" translate="yes" xml:space="preserve">
          <source>UPDATED</source>
          <target state="translated">UPDATED</target>
        </trans-unit>
        <trans-unit id="173610cb31251b28e80fadc258036215d99d7128" translate="yes" xml:space="preserve">
          <source>Usage examples:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="a2f2e6eafdedf44c2e8588c6802550826e518631" translate="yes" xml:space="preserve">
          <source>Using the code example above; if the width property of the div element that was stored in the 'elem' variable was styled in a CSS style-sheet, and not styled inside of its HTML tag, you are without a doubt going to get a return value of undefined stored inside of the cssProp variable. The undefined value occurs because in-order to get the correct value, the code written inside a CSS Style-Sheet needs to be computed in-order to get the value, therefore; you must use a method that will compute the value of the property who's value lies within the style-sheet.</source>
          <target state="translated">上のコード例を使用して、'elem' 変数に格納されている div 要素の width プロパティが CSS スタイルシート内でスタイリングされ、その HTML タグ内でスタイリングされていない場合、間違いなく cssProp 変数内に格納されている undefined という戻り値を取得することになります。未定義値が発生するのは、正しい値を取得するためには、CSS スタイルシート内に書かれたコードが値を取得するために計算される必要があるためです。</target>
        </trans-unit>
        <trans-unit id="48e8ba76225406f888b41920a486bfe0a1201059" translate="yes" xml:space="preserve">
          <source>We can now :</source>
          <target state="translated">私たちは今すぐにでも...</target>
        </trans-unit>
        <trans-unit id="c99a6a3da67239a2e588104d2e10d14369e0b4e5" translate="yes" xml:space="preserve">
          <source>We could also consider object destructuring as a means to access a property in an object, but as follows:</source>
          <target state="translated">オブジェクトのプロパティにアクセスするための手段として、オブジェクトの破壊を考えることもできますが、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3905357ebf181c4b50e393bb69a3d74f87b025bd" translate="yes" xml:space="preserve">
          <source>Whenever you need to access property dynamically you have to use square bracket for accessing property not &quot;.&quot; operator</source>
          <target state="translated">プロパティに動的にアクセスする必要がある場合は、&quot;.&quot;演算子ではなく、プロパティにアクセスするために角括弧を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="8c2f72513c8502b8b436677eb1fd1a8286c418b5" translate="yes" xml:space="preserve">
          <source>You can achieve this in quite a few different ways.</source>
          <target state="translated">かなりの数の方法で実現できます。</target>
        </trans-unit>
        <trans-unit id="b7ecbd70c7f912bb6ec39411ca0b2d318f260940" translate="yes" xml:space="preserve">
          <source>You can do it like this using Lodash get</source>
          <target state="translated">ロダッシュゲットを使ってこんな風にしてみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="11904d98efc1e0b6e5d5f477b61a849dec2d5680" translate="yes" xml:space="preserve">
          <source>You should use &lt;code&gt;JSON.parse&lt;/code&gt;, take a look at &lt;a href=&quot;https://www.w3schools.com/js/js_json_parse.asp&quot;&gt;https://www.w3schools.com/js/js_json_parse.asp&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;JSON.parse&lt;/code&gt; を使用する必要があります。https：//www.w3schools.com/js/js_json_parse.aspを&lt;a href=&quot;https://www.w3schools.com/js/js_json_parse.asp&quot;&gt;ご覧ください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a3772e1dbfdf192051b80d4e269ce0fbdb1f2d7" translate="yes" xml:space="preserve">
          <source>dot notation     - &lt;code&gt;foo.bar&lt;/code&gt;</source>
          <target state="translated">ドット表記 &lt;code&gt;foo.bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7263c675a6d65b6436a45aadd91cf3f6db7ef15" translate="yes" xml:space="preserve">
          <source>however I rarely go this route because it doesn't work on property values assigned via style-sheets. To give you an example, I'll demonstrate with a bit of pseudo code.</source>
          <target state="translated">しかし、スタイルシートを介して割り当てられたプロパティ値では動作しないため、私はこのルートを使うことはほとんどありません。例を示すために、ちょっとした疑似コードを使ってデモをしてみましょう。</target>
        </trans-unit>
        <trans-unit id="19465118b87f9cbe4a18959dde3553907dae9e6b" translate="yes" xml:space="preserve">
          <source>square brackets  - &lt;code&gt;foo[someVar]&lt;/code&gt; or &lt;code&gt;foo[&quot;string&quot;]&lt;/code&gt;</source>
          <target state="translated">大括弧 &lt;code&gt;foo[someVar]&lt;/code&gt; または &lt;code&gt;foo[&quot;string&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
