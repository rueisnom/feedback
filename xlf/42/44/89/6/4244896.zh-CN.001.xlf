<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4244896">
    <body>
      <group id="4244896">
        <trans-unit id="c25a232090a075394a2c0ea94d2f48e5b00f9443" translate="yes" xml:space="preserve">
          <source>...does get, and does set. It is what I use, the only downside is you got to know JQuery, but this is honestly one of the very many good reasons that every Javascript Developer should learn JQuery, it just makes life easy, and offers methods, like this one, which is not available with standard Javascript.
Hope this helps someone!!!</source>
          <target state="translated">...确实可以得到,并且可以设置。这是我使用的,唯一的缺点是你必须了解JQuery,但说实话,这是每个Javascript开发者都应该学习JQuery的一个很好的理由,它让生活变得很简单,并且提供了一些方法,比如这个方法,这是标准的Javascript所不具备的。希望这篇文章能帮助到你!</target>
        </trans-unit>
        <trans-unit id="9fac3d93857c0fb8f4bef5e89d7bbed95b49b5d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.w3schools.com/jsref/jsref_getcomputedstyle.asp&quot;&gt;W3Schools getComputedValue Doc&lt;/a&gt; This gives a good example, and lets you play with it, however, this link &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value&quot;&gt;Mozilla CSS getComputedValue doc&lt;/a&gt; talks about the getComputedValue function in detail, and should be read by any aspiring developer who isn't totally clear on this subject.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3schools.com/jsref/jsref_getcomputedstyle.asp&quot;&gt;W3Schools getComputedValue Doc&lt;/a&gt;这是一个很好的示例，并且可以让您使用它。但是，此链接&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value&quot;&gt;Mozilla CSS getComputedValue doc详细&lt;/a&gt;讨论了getComputedValue函数，并且任何对此主题不太清楚的有抱负的开发人员都应阅读该链接。</target>
        </trans-unit>
        <trans-unit id="972a33f942039a3a3949adc61004acb034b7b096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;&lt;em&gt;&lt;a href=&quot;https://jsfiddle.net/sb2ofndy/&quot;&gt;jsfiddle&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;&lt;em&gt;&lt;a href=&quot;https://jsfiddle.net/sb2ofndy/&quot;&gt;jsfiddle&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3e2ac84f369516b4679504380704ab691b46d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object destructuring&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;对象解构&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e71c4b21183bc960b08fecf2f982d00528e1feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax: object[propery}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;语法：object [propery}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c643f909c24e9c6fe6ffe8f40faf79ddc5b79028" translate="yes" xml:space="preserve">
          <source>Accessing root properties in object is easily achieved with &lt;code&gt;obj[variable]&lt;/code&gt;, but getting nested complicates thing. Not to write already written code I suggest to use &lt;code&gt;lodash.get&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;obj[variable]&lt;/code&gt; 可以轻松实现访问对象的根属性，但是嵌套会使事情复杂化。 不要写已经写好的代码，我建议使用 &lt;code&gt;lodash.get&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2458e6a451d94dc8ed4928ae8f51181b5f7505c5" translate="yes" xml:space="preserve">
          <source>As a side note, the getComputedValue method only gets, it does not set. This, obviously is a major downside, however there is a method that gets from CSS style-sheets, as well as sets values, though it is not standard Javascript.
The JQuery method...</source>
          <target state="translated">作为一个侧面的说明,getComputedValue方法只能获取,不能设置。这显然是一个很大的缺点,但是有一个方法可以从CSS样式表中获取,也可以设置值,尽管它不是标准的Javascript。JQuery方法.....</target>
        </trans-unit>
        <trans-unit id="574fd35796c44aee0aa95b671e86d5bbf53e0e1c" translate="yes" xml:space="preserve">
          <source>Both dot and bracket notation also work as expected for nested objects:</source>
          <target state="translated">对于嵌套对象来说,点号和括号符号也能正常工作。</target>
        </trans-unit>
        <trans-unit id="100b7f9acafb0a410aae5ec157e6e2257f1c9a81" translate="yes" xml:space="preserve">
          <source>Bracket notation: &lt;code&gt;something['bar']&lt;/code&gt;</source>
          <target state="translated">方括号表示法： &lt;code&gt;something['bar']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826d15187714c567527286ff90b53701b7812cc5" translate="yes" xml:space="preserve">
          <source>But only second case allows to access properties dynamically:</source>
          <target state="translated">但只有第二种情况下才允许动态访问属性。</target>
        </trans-unit>
        <trans-unit id="33224c361c9a7c3bd3d441c33da01cd6061e3422" translate="yes" xml:space="preserve">
          <source>Cheers!</source>
          <target state="translated">Cheers!</target>
        </trans-unit>
        <trans-unit id="176d2d27407b883b38dbc37b0ab15b4f40caea07" translate="yes" xml:space="preserve">
          <source>Dot notation: &lt;code&gt;something.bar&lt;/code&gt;</source>
          <target state="translated">点表示法： &lt;code&gt;something.bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3531c1f73bb03f602e7bec16f4152d300db145e9" translate="yes" xml:space="preserve">
          <source>Dynamically access object property using variable</source>
          <target state="translated">使用变量动态访问对象属性</target>
        </trans-unit>
        <trans-unit id="72d2971f8b0dd52d0f70eb306db1f5b4576d457c" translate="yes" xml:space="preserve">
          <source>ES5 // Check Deeply Nested Variables</source>
          <target state="translated">ES5/检查深度嵌套变量</target>
        </trans-unit>
        <trans-unit id="540d4bfb3f3963908155e7756b108079c9c3bb38" translate="yes" xml:space="preserve">
          <source>Ex. - a deeply nested array of objects:</source>
          <target state="translated">例如-深度嵌套的对象阵列。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="c7bcc52db88528b7b02efbf655be86ac20bfc285" translate="yes" xml:space="preserve">
          <source>Firstly I want to address that there are several ways to obtain the value of a property and store it in a dynamic Variable. The first most popular, and easiest way IMHO would be:</source>
          <target state="translated">首先我想说的是,有几种方法可以获得一个属性的值并将其存储在动态变量中。第一种最流行也是最简单的方法,IMHO是:</target>
        </trans-unit>
        <trans-unit id="507a1593e5924a1a3698a78b330a2da5ef3ede16" translate="yes" xml:space="preserve">
          <source>Following is an ES6 example of how you can access the property of an object using a property name that has been dynamically generated by concatenating two strings.</source>
          <target state="translated">下面是一个ES6的例子,说明如何使用由两个字符串混合动态生成的属性名来访问对象的属性。</target>
        </trans-unit>
        <trans-unit id="3dd26891ee75d1677720219301e02753b66b0f1a" translate="yes" xml:space="preserve">
          <source>Henceforth the getComputedStyle() method!</source>
          <target state="translated">从此以后,getComputedStyle()方法!</target>
        </trans-unit>
        <trans-unit id="d33a241581123a82e44aa78976fb98d5f4d91667" translate="yes" xml:space="preserve">
          <source>Here's a sample of a language file object like the one I wanted data from:</source>
          <target state="translated">这里是一个语言文件对象的示例,就像我想要的数据来自于这个语言文件。</target>
        </trans-unit>
        <trans-unit id="842a00338e4c2a3840c891596d991a493d750a4f" translate="yes" xml:space="preserve">
          <source>I asked a question that kinda duplicated on this topic a while back, and after excessive research, and seeing a lot of information missing that should be here, I feel I have something valuable to add to this older post.</source>
          <target state="translated">前段时间我问了一个问题,这个问题有点重复,经过过度的研究,看到很多应该在这里的信息缺失,我觉得我有一些有价值的东西要补充到这个老帖子里。</target>
        </trans-unit>
        <trans-unit id="707897a43cb9f078387a72e4b8735143038542d7" translate="yes" xml:space="preserve">
          <source>I came across a case where &lt;em&gt;I thought&lt;/em&gt; I wanted to pass the &quot;address&quot; of an object property as data to another function and populate the object (with AJAX), do lookup from address array, and display in that other function. I couldn't use dot notation without doing string acrobatics so I thought an array might be nice to pass instead. I ended-up doing something different anyway, but seemed related to this post.</source>
          <target state="translated">我遇到了一种情况， &lt;em&gt;我以为&lt;/em&gt;我想将对象属性的&amp;ldquo;地址&amp;rdquo;作为数据传递给另一个函数，然后填充该对象（使用AJAX），从地址数组中进行查找，并在另一个函数中显示。 如果不进行字符串杂技，就不能使用点表示法，因此我认为可以通过数组来代替。 我最终还是做了一些不同的事情，但似乎与此职位有关。</target>
        </trans-unit>
        <trans-unit id="0832814a494a22df1c2e0d3813af3745876c268d" translate="yes" xml:space="preserve">
          <source>I created this little function that looks-up the &quot;least specific&quot; (first) address parameter, and reassigns the returned object to itself. Then it is ready to look-up the next-most-specific address parameter if one exists.</source>
          <target state="translated">我创建了这个小函数,它可以查找 &quot;最不特定&quot;(第一个)地址参数,然后将返回的对象重新分配给自己。然后,如果存在下一个最具体的地址参数,它就可以查询下一个最具体的地址参数。</target>
        </trans-unit>
        <trans-unit id="c814bfa8149a71d74493da6c18ffa015799e9e51" translate="yes" xml:space="preserve">
          <source>I have take comments below into consideration and agreed. Eval is to be avoided.</source>
          <target state="translated">我已考虑到以下意见,并同意。评价是要避免的。</target>
        </trans-unit>
        <trans-unit id="4f8ffec12cb60d47e9343d75df82945036bc5214" translate="yes" xml:space="preserve">
          <source>I wanted to be able to pass an array such as: [&quot;audioPlayer&quot;, &quot;controls&quot;, &quot;stop&quot;] to access the language text, &quot;stop&quot; in this case.</source>
          <target state="translated">我希望能够传递一个数组,例如:[&quot;audioPlayer&quot;,&quot;controls&quot;,&quot;stop&quot;]来访问语言文本,本例中的 &quot;stop&quot;。[&quot;audioPlayer&quot;,&quot;controls&quot;,&quot;stop&quot;]来访问语言文本,这里是 &quot;stop&quot;。</target>
        </trans-unit>
        <trans-unit id="00e49bdf87fbd4149bdc18f10639c5d4640d4ead" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property of an object using a dynamic name. Is this possible?</source>
          <target state="translated">我试图使用动态名称访问一个对象的属性。这可能吗?</target>
        </trans-unit>
        <trans-unit id="91280a13680e9ef6d1d2b711ba922c7fbc22fc47" translate="yes" xml:space="preserve">
          <source>If you want to get nested value dynamically (e.g. by variable), your best option will be to use &lt;code&gt;lodash&lt;/code&gt;.</source>
          <target state="translated">如果要动态获取嵌套值（例如，按变量），最好的选择是使用 &lt;code&gt;lodash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a03446a3c744bd4e20c6a63b0fe86ebbe6067ce" translate="yes" xml:space="preserve">
          <source>In javascript we can access with:</source>
          <target state="translated">在javascript中,我们可以通过以下方式访问。</target>
        </trans-unit>
        <trans-unit id="bda969d76438f0f7004c442304e6649095ebaca3" translate="yes" xml:space="preserve">
          <source>Instead of :</source>
          <target state="translated">而不是 :</target>
        </trans-unit>
        <trans-unit id="6fabfc3a48599c0faf28da30b525172d6ce7e23b" translate="yes" xml:space="preserve">
          <source>It gets interesting when you have to pass parameters to this function as well.</source>
          <target state="translated">当你必须将参数传递给这个函数时,它就变得有趣了。</target>
        </trans-unit>
        <trans-unit id="a21b10f7a9259ba4e8d43093e46635c7d7476672" translate="yes" xml:space="preserve">
          <source>Lodash get can be used on different ways, here is link to the documentation &lt;a href=&quot;https://lodash.com/docs/4.16.2#get&quot;&gt;lodash.get&lt;/a&gt;</source>
          <target state="translated">Lodash get可以以多种方式使用，这是指向&lt;a href=&quot;https://lodash.com/docs/4.16.2#get&quot;&gt;lodash.get&lt;/a&gt;文档的链接</target>
        </trans-unit>
        <trans-unit id="27c2f3a0a0cc2f77c7527ec178c49d6519499558" translate="yes" xml:space="preserve">
          <source>The bracket notation is specially powerful as it let's you access a property based on a variable:</source>
          <target state="translated">括号符号特别强大,因为它可以让你根据变量访问一个属性。</target>
        </trans-unit>
        <trans-unit id="2ac263e4e24512071dd0712a0859ab9284fec838" translate="yes" xml:space="preserve">
          <source>The value between the brackets can be any expression. Therefore, if the property name is stored in a variable, you have to use bracket notation:</source>
          <target state="translated">括号之间的值可以是任何表达式。因此,如果属性名存储在一个变量中,必须使用括号符号。</target>
        </trans-unit>
        <trans-unit id="132f275aaeff40036a6f46cc811e3754f3401cde" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors&quot;&gt;two ways to access properties&lt;/a&gt; of an object:</source>
          <target state="translated">有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors&quot;&gt;两种方法可以访问&lt;/a&gt;对象的属性 ：</target>
        </trans-unit>
        <trans-unit id="9c380f38332515f6914fc7eaa0cda268da4cb375" translate="yes" xml:space="preserve">
          <source>There is a few possibilities:</source>
          <target state="translated">有几种可能。</target>
        </trans-unit>
        <trans-unit id="cb2803628217be24d3c0fe5bdbf6820128c20e16" translate="yes" xml:space="preserve">
          <source>This can be extended to looping over every property of an object. This can be seem redundant due to newer JavaScript constructs such as for ... of ..., but helps illustrate a use case:</source>
          <target state="translated">这可以扩展到对一个对象的每个属性进行循环。由于较新的JavaScript构造,如for...的...的...的...,这看起来可能是多余的,但有助于说明一个用例。</target>
        </trans-unit>
        <trans-unit id="d5897b72f294fb8aa0d76e3c83990ba94218ede5" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property names&lt;/a&gt;</source>
          <target state="translated">这称为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;计算属性名称&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb351f2719c894112e98defaee21c53d17baa96e" translate="yes" xml:space="preserve">
          <source>This is my solution:</source>
          <target state="translated">这是我的解决方案。</target>
        </trans-unit>
        <trans-unit id="d26fb6c93ce3e23f974697d5258ac71dfc64789b" translate="yes" xml:space="preserve">
          <source>This simple piece of code can check for deeply nested variable / value existence without having to check each variable along the way...</source>
          <target state="translated">这段简单的代码可以检查深度嵌套的变量值是否存在,而不需要沿途检查每个变量.....</target>
        </trans-unit>
        <trans-unit id="47b23b39759a1908e680a0a3b5cb3c99d6de735e" translate="yes" xml:space="preserve">
          <source>UPDATED</source>
          <target state="translated">UPDATED</target>
        </trans-unit>
        <trans-unit id="173610cb31251b28e80fadc258036215d99d7128" translate="yes" xml:space="preserve">
          <source>Usage examples:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="a2f2e6eafdedf44c2e8588c6802550826e518631" translate="yes" xml:space="preserve">
          <source>Using the code example above; if the width property of the div element that was stored in the 'elem' variable was styled in a CSS style-sheet, and not styled inside of its HTML tag, you are without a doubt going to get a return value of undefined stored inside of the cssProp variable. The undefined value occurs because in-order to get the correct value, the code written inside a CSS Style-Sheet needs to be computed in-order to get the value, therefore; you must use a method that will compute the value of the property who's value lies within the style-sheet.</source>
          <target state="translated">使用上面的代码示例,如果存储在'elem'变量中的div元素的宽度属性是在CSS样式表中的样式,而不是在它的HTML标签中的样式,那么毫无疑问,你会得到一个存储在cssProp变量中的未定义的返回值。出现未定义的值是因为,为了得到正确的值,需要在CSS样式表内写的代码在命令中计算,因此,你必须使用一个方法来计算属性的值,而这个属性的值是在样式表内的。</target>
        </trans-unit>
        <trans-unit id="48e8ba76225406f888b41920a486bfe0a1201059" translate="yes" xml:space="preserve">
          <source>We can now :</source>
          <target state="translated">我们现在可以:</target>
        </trans-unit>
        <trans-unit id="c99a6a3da67239a2e588104d2e10d14369e0b4e5" translate="yes" xml:space="preserve">
          <source>We could also consider object destructuring as a means to access a property in an object, but as follows:</source>
          <target state="translated">我们也可以把对象分解作为访问对象中的属性的一种手段,但如下图所示。</target>
        </trans-unit>
        <trans-unit id="3905357ebf181c4b50e393bb69a3d74f87b025bd" translate="yes" xml:space="preserve">
          <source>Whenever you need to access property dynamically you have to use square bracket for accessing property not &quot;.&quot; operator</source>
          <target state="translated">每当你需要动态访问属性时,你必须使用方括号来访问属性,而不是使用&quot;.&quot;操作符。</target>
        </trans-unit>
        <trans-unit id="8c2f72513c8502b8b436677eb1fd1a8286c418b5" translate="yes" xml:space="preserve">
          <source>You can achieve this in quite a few different ways.</source>
          <target state="translated">你可以通过很多不同的方式来实现这个目标。</target>
        </trans-unit>
        <trans-unit id="b7ecbd70c7f912bb6ec39411ca0b2d318f260940" translate="yes" xml:space="preserve">
          <source>You can do it like this using Lodash get</source>
          <target state="translated">你可以这样做,使用Lodash get</target>
        </trans-unit>
        <trans-unit id="11904d98efc1e0b6e5d5f477b61a849dec2d5680" translate="yes" xml:space="preserve">
          <source>You should use &lt;code&gt;JSON.parse&lt;/code&gt;, take a look at &lt;a href=&quot;https://www.w3schools.com/js/js_json_parse.asp&quot;&gt;https://www.w3schools.com/js/js_json_parse.asp&lt;/a&gt;</source>
          <target state="translated">您应该使用 &lt;code&gt;JSON.parse&lt;/code&gt; ，看看&lt;a href=&quot;https://www.w3schools.com/js/js_json_parse.asp&quot;&gt;https://www.w3schools.com/js/js_json_parse.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a3772e1dbfdf192051b80d4e269ce0fbdb1f2d7" translate="yes" xml:space="preserve">
          <source>dot notation     - &lt;code&gt;foo.bar&lt;/code&gt;</source>
          <target state="translated">点符号 &lt;code&gt;foo.bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7263c675a6d65b6436a45aadd91cf3f6db7ef15" translate="yes" xml:space="preserve">
          <source>however I rarely go this route because it doesn't work on property values assigned via style-sheets. To give you an example, I'll demonstrate with a bit of pseudo code.</source>
          <target state="translated">但是我很少走这条路,因为它在通过样式表分配的属性值上不起作用。为了给你举个例子,我将用一些伪代码来演示。</target>
        </trans-unit>
        <trans-unit id="19465118b87f9cbe4a18959dde3553907dae9e6b" translate="yes" xml:space="preserve">
          <source>square brackets  - &lt;code&gt;foo[someVar]&lt;/code&gt; or &lt;code&gt;foo[&quot;string&quot;]&lt;/code&gt;</source>
          <target state="translated">方括号 &lt;code&gt;foo[someVar]&lt;/code&gt; 或 &lt;code&gt;foo[&quot;string&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
