<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4244896">
    <body>
      <group id="4244896">
        <trans-unit id="c25a232090a075394a2c0ea94d2f48e5b00f9443" translate="yes" xml:space="preserve">
          <source>...does get, and does set. It is what I use, the only downside is you got to know JQuery, but this is honestly one of the very many good reasons that every Javascript Developer should learn JQuery, it just makes life easy, and offers methods, like this one, which is not available with standard Javascript.
Hope this helps someone!!!</source>
          <target state="translated">... 얻고 설정합니다. 필자가 사용하는 유일한 단점은 JQuery를 알아야한다는 것입니다. 그러나 이것은 모든 Javascript 개발자가 JQuery를 배워야하는 매우 많은 좋은 이유 중 하나입니다. 표준 자바 스크립트에서는 사용할 수 없습니다. 이것이 누군가를 돕기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="9fac3d93857c0fb8f4bef5e89d7bbed95b49b5d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.w3schools.com/jsref/jsref_getcomputedstyle.asp&quot;&gt;W3Schools getComputedValue Doc&lt;/a&gt; This gives a good example, and lets you play with it, however, this link &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value&quot;&gt;Mozilla CSS getComputedValue doc&lt;/a&gt; talks about the getComputedValue function in detail, and should be read by any aspiring developer who isn't totally clear on this subject.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3schools.com/jsref/jsref_getcomputedstyle.asp&quot;&gt;W3Schools getComputedValue Doc&lt;/a&gt; 이 예제는 좋은 예제를 제공하지만이 링크를 사용하여 재생할 수 있습니다. 그러나이 링크 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value&quot;&gt;Mozilla CSS getComputedValue 문서&lt;/a&gt; 는 getComputedValue 함수에 대해 자세히 설명하며이 주제에 대해 완전히 명확하지 않은 야심 찬 개발자가 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="972a33f942039a3a3949adc61004acb034b7b096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;&lt;em&gt;&lt;a href=&quot;https://jsfiddle.net/sb2ofndy/&quot;&gt;jsfiddle&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;&lt;em&gt;&lt;a href=&quot;https://jsfiddle.net/sb2ofndy/&quot;&gt;jsfiddle&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3e2ac84f369516b4679504380704ab691b46d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object destructuring&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체 파괴&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e71c4b21183bc960b08fecf2f982d00528e1feb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax: object[propery}&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구문 : object [propery}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c643f909c24e9c6fe6ffe8f40faf79ddc5b79028" translate="yes" xml:space="preserve">
          <source>Accessing root properties in object is easily achieved with &lt;code&gt;obj[variable]&lt;/code&gt;, but getting nested complicates thing. Not to write already written code I suggest to use &lt;code&gt;lodash.get&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj[variable]&lt;/code&gt; 으로 객체의 루트 속성에 쉽게 액세스 할 수 있지만 중첩되는 것은 복잡합니다. 이미 작성된 코드를 작성하지 않으려면 &lt;code&gt;lodash.get&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2458e6a451d94dc8ed4928ae8f51181b5f7505c5" translate="yes" xml:space="preserve">
          <source>As a side note, the getComputedValue method only gets, it does not set. This, obviously is a major downside, however there is a method that gets from CSS style-sheets, as well as sets values, though it is not standard Javascript.
The JQuery method...</source>
          <target state="translated">참고로 getComputedValue 메소드는 설정 만하지 않고 가져옵니다. 이것은 명백한 주요 단점이지만, 표준 Javascript는 아니지만 CSS 스타일 시트에서 가져오고 값을 설정하는 방법이 있습니다. JQuery 메소드 ...</target>
        </trans-unit>
        <trans-unit id="574fd35796c44aee0aa95b671e86d5bbf53e0e1c" translate="yes" xml:space="preserve">
          <source>Both dot and bracket notation also work as expected for nested objects:</source>
          <target state="translated">도트와 괄호 표기법 모두 중첩 된 객체에 대해 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="100b7f9acafb0a410aae5ec157e6e2257f1c9a81" translate="yes" xml:space="preserve">
          <source>Bracket notation: &lt;code&gt;something['bar']&lt;/code&gt;</source>
          <target state="translated">대괄호 표기법 : &lt;code&gt;something['bar']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826d15187714c567527286ff90b53701b7812cc5" translate="yes" xml:space="preserve">
          <source>But only second case allows to access properties dynamically:</source>
          <target state="translated">그러나 두 번째 경우에만 속성에 동적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33224c361c9a7c3bd3d441c33da01cd6061e3422" translate="yes" xml:space="preserve">
          <source>Cheers!</source>
          <target state="translated">Cheers!</target>
        </trans-unit>
        <trans-unit id="176d2d27407b883b38dbc37b0ab15b4f40caea07" translate="yes" xml:space="preserve">
          <source>Dot notation: &lt;code&gt;something.bar&lt;/code&gt;</source>
          <target state="translated">점 표기법 : &lt;code&gt;something.bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3531c1f73bb03f602e7bec16f4152d300db145e9" translate="yes" xml:space="preserve">
          <source>Dynamically access object property using variable</source>
          <target state="translated">변수를 사용하여 객체 속성에 동적으로 액세스</target>
        </trans-unit>
        <trans-unit id="72d2971f8b0dd52d0f70eb306db1f5b4576d457c" translate="yes" xml:space="preserve">
          <source>ES5 // Check Deeply Nested Variables</source>
          <target state="translated">ES5 // 깊이 중첩 된 변수 확인</target>
        </trans-unit>
        <trans-unit id="540d4bfb3f3963908155e7756b108079c9c3bb38" translate="yes" xml:space="preserve">
          <source>Ex. - a deeply nested array of objects:</source>
          <target state="translated">전의. -깊이 중첩 된 객체 배열 :</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="c7bcc52db88528b7b02efbf655be86ac20bfc285" translate="yes" xml:space="preserve">
          <source>Firstly I want to address that there are several ways to obtain the value of a property and store it in a dynamic Variable. The first most popular, and easiest way IMHO would be:</source>
          <target state="translated">먼저 속성의 값을 가져 와서 동적 변수에 저장하는 몇 가지 방법이 있다고 설명하고 싶습니다. 가장 인기 있고 가장 쉬운 IMHO 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="507a1593e5924a1a3698a78b330a2da5ef3ede16" translate="yes" xml:space="preserve">
          <source>Following is an ES6 example of how you can access the property of an object using a property name that has been dynamically generated by concatenating two strings.</source>
          <target state="translated">다음은 두 문자열을 연결하여 동적으로 생성 된 속성 이름을 사용하여 객체의 속성에 액세스하는 방법의 ES6 예입니다.</target>
        </trans-unit>
        <trans-unit id="3dd26891ee75d1677720219301e02753b66b0f1a" translate="yes" xml:space="preserve">
          <source>Henceforth the getComputedStyle() method!</source>
          <target state="translated">이제 getComputedStyle () 메소드!</target>
        </trans-unit>
        <trans-unit id="d33a241581123a82e44aa78976fb98d5f4d91667" translate="yes" xml:space="preserve">
          <source>Here's a sample of a language file object like the one I wanted data from:</source>
          <target state="translated">다음은 데이터를 원하는 언어 파일 객체의 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="842a00338e4c2a3840c891596d991a493d750a4f" translate="yes" xml:space="preserve">
          <source>I asked a question that kinda duplicated on this topic a while back, and after excessive research, and seeing a lot of information missing that should be here, I feel I have something valuable to add to this older post.</source>
          <target state="translated">나는이 주제에 대해 잠시 동안 중복 된 질문을했고 과도한 연구를 한 후 여기에 있어야 할 많은 정보가 누락 된 것을 보았을 때이 오래된 게시물에 추가 할 가치가 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="707897a43cb9f078387a72e4b8735143038542d7" translate="yes" xml:space="preserve">
          <source>I came across a case where &lt;em&gt;I thought&lt;/em&gt; I wanted to pass the &quot;address&quot; of an object property as data to another function and populate the object (with AJAX), do lookup from address array, and display in that other function. I couldn't use dot notation without doing string acrobatics so I thought an array might be nice to pass instead. I ended-up doing something different anyway, but seemed related to this post.</source>
          <target state="translated">객체 속성의 &quot;주소&quot;를 데이터로 다른 함수에 전달하고 객체를 AJAX로 채우고 주소 배열에서 조회하고 다른 함수에 표시하려고 &lt;em&gt;한다고 생각한&lt;/em&gt; 사례를 발견했습니다. 문자열 곡예를 수행하지 않고 도트 표기법을 사용할 수 없으므로 배열을 대신 전달하는 것이 좋을 것이라고 생각했습니다. 어쨌든 다른 일을 끝내었지만이 게시물과 관련이있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="0832814a494a22df1c2e0d3813af3745876c268d" translate="yes" xml:space="preserve">
          <source>I created this little function that looks-up the &quot;least specific&quot; (first) address parameter, and reassigns the returned object to itself. Then it is ready to look-up the next-most-specific address parameter if one exists.</source>
          <target state="translated">&quot;최소 특정&quot;(첫 번째) 주소 매개 변수를 조회하고 반환 된 개체를 다시 할당하는이 작은 함수를 만들었습니다. 그런 다음 가장 구체적인 주소 매개 변수가있는 경우이를 찾을 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c814bfa8149a71d74493da6c18ffa015799e9e51" translate="yes" xml:space="preserve">
          <source>I have take comments below into consideration and agreed. Eval is to be avoided.</source>
          <target state="translated">아래 의견을 고려하여 동의했습니다. 평가는 피해야한다.</target>
        </trans-unit>
        <trans-unit id="4f8ffec12cb60d47e9343d75df82945036bc5214" translate="yes" xml:space="preserve">
          <source>I wanted to be able to pass an array such as: [&quot;audioPlayer&quot;, &quot;controls&quot;, &quot;stop&quot;] to access the language text, &quot;stop&quot; in this case.</source>
          <target state="translated">이 경우 언어 텍스트 &quot;stop&quot;에 액세스하기 위해 [ &quot;audioPlayer&quot;, &quot;controls&quot;, &quot;stop&quot;]과 같은 배열을 전달할 수 있기를 원했습니다.</target>
        </trans-unit>
        <trans-unit id="00e49bdf87fbd4149bdc18f10639c5d4640d4ead" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property of an object using a dynamic name. Is this possible?</source>
          <target state="translated">동적 이름을 사용하여 객체의 속성에 액세스하려고합니다. 이게 가능해?</target>
        </trans-unit>
        <trans-unit id="91280a13680e9ef6d1d2b711ba922c7fbc22fc47" translate="yes" xml:space="preserve">
          <source>If you want to get nested value dynamically (e.g. by variable), your best option will be to use &lt;code&gt;lodash&lt;/code&gt;.</source>
          <target state="translated">변수로 중첩 된 값을 동적으로 얻으려면 &lt;code&gt;lodash&lt;/code&gt; 를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a03446a3c744bd4e20c6a63b0fe86ebbe6067ce" translate="yes" xml:space="preserve">
          <source>In javascript we can access with:</source>
          <target state="translated">자바 스크립트에서 다음을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda969d76438f0f7004c442304e6649095ebaca3" translate="yes" xml:space="preserve">
          <source>Instead of :</source>
          <target state="translated">대신에 :</target>
        </trans-unit>
        <trans-unit id="6fabfc3a48599c0faf28da30b525172d6ce7e23b" translate="yes" xml:space="preserve">
          <source>It gets interesting when you have to pass parameters to this function as well.</source>
          <target state="translated">이 함수에 매개 변수를 전달해야 할 때도 흥미로워집니다.</target>
        </trans-unit>
        <trans-unit id="a21b10f7a9259ba4e8d43093e46635c7d7476672" translate="yes" xml:space="preserve">
          <source>Lodash get can be used on different ways, here is link to the documentation &lt;a href=&quot;https://lodash.com/docs/4.16.2#get&quot;&gt;lodash.get&lt;/a&gt;</source>
          <target state="translated">Lodash get은 다양한 방법으로 사용할 수 있습니다. 여기 &lt;a href=&quot;https://lodash.com/docs/4.16.2#get&quot;&gt;lodash.get&lt;/a&gt; 문서에 대한 링크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c2f3a0a0cc2f77c7527ec178c49d6519499558" translate="yes" xml:space="preserve">
          <source>The bracket notation is specially powerful as it let's you access a property based on a variable:</source>
          <target state="translated">대괄호 표기법은 변수를 기반으로 속성에 액세스 할 수 있도록하기 때문에 특히 강력합니다.</target>
        </trans-unit>
        <trans-unit id="2ac263e4e24512071dd0712a0859ab9284fec838" translate="yes" xml:space="preserve">
          <source>The value between the brackets can be any expression. Therefore, if the property name is stored in a variable, you have to use bracket notation:</source>
          <target state="translated">대괄호 사이의 값은 모든 표현식이 될 수 있습니다. 따라서 속성 이름이 변수에 저장된 경우 대괄호 표기법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="132f275aaeff40036a6f46cc811e3754f3401cde" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors&quot;&gt;two ways to access properties&lt;/a&gt; of an object:</source>
          <target state="translated">객체의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors&quot;&gt;속성&lt;/a&gt; 에 액세스하는 방법 에는 두 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c380f38332515f6914fc7eaa0cda268da4cb375" translate="yes" xml:space="preserve">
          <source>There is a few possibilities:</source>
          <target state="translated">몇 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2803628217be24d3c0fe5bdbf6820128c20e16" translate="yes" xml:space="preserve">
          <source>This can be extended to looping over every property of an object. This can be seem redundant due to newer JavaScript constructs such as for ... of ..., but helps illustrate a use case:</source>
          <target state="translated">이것은 객체의 모든 속성을 반복하도록 확장 될 수 있습니다. for ... of ...와 같은 최신 JavaScript 구문으로 인해 중복되는 것처럼 보일 수 있지만 사용 사례를 설명하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d5897b72f294fb8aa0d76e3c83990ba94218ede5" translate="yes" xml:space="preserve">
          <source>This is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property names&lt;/a&gt;</source>
          <target state="translated">이것을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;계산 된 속성 이름&lt;/a&gt; 이라고 합니다</target>
        </trans-unit>
        <trans-unit id="bb351f2719c894112e98defaee21c53d17baa96e" translate="yes" xml:space="preserve">
          <source>This is my solution:</source>
          <target state="translated">이것은 내 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="d26fb6c93ce3e23f974697d5258ac71dfc64789b" translate="yes" xml:space="preserve">
          <source>This simple piece of code can check for deeply nested variable / value existence without having to check each variable along the way...</source>
          <target state="translated">이 간단한 코드 조각은 길을 따라 각 변수를 확인하지 않고도 깊이 중첩 된 변수 / 값 존재를 확인할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="47b23b39759a1908e680a0a3b5cb3c99d6de735e" translate="yes" xml:space="preserve">
          <source>UPDATED</source>
          <target state="translated">UPDATED</target>
        </trans-unit>
        <trans-unit id="173610cb31251b28e80fadc258036215d99d7128" translate="yes" xml:space="preserve">
          <source>Usage examples:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="a2f2e6eafdedf44c2e8588c6802550826e518631" translate="yes" xml:space="preserve">
          <source>Using the code example above; if the width property of the div element that was stored in the 'elem' variable was styled in a CSS style-sheet, and not styled inside of its HTML tag, you are without a doubt going to get a return value of undefined stored inside of the cssProp variable. The undefined value occurs because in-order to get the correct value, the code written inside a CSS Style-Sheet needs to be computed in-order to get the value, therefore; you must use a method that will compute the value of the property who's value lies within the style-sheet.</source>
          <target state="translated">위의 코드 예제를 사용하십시오. 'elem'변수에 저장된 div 요소의 width 속성이 CSS 스타일 시트에서 스타일이 지정되고 HTML 태그 내부에서 스타일이 지정되지 않은 경우 undefined의 반환 값을 얻을 수 있습니다. cssProp 변수의 정의되지 않은 값은 올바른 값을 얻기 위해 순서대로 발생하기 때문에 CSS 스타일 시트 내에 작성된 코드는 순서대로 계산되어야합니다. 값이 스타일 시트 내에있는 속성 값을 계산하는 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="48e8ba76225406f888b41920a486bfe0a1201059" translate="yes" xml:space="preserve">
          <source>We can now :</source>
          <target state="translated">우리는 지금 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c99a6a3da67239a2e588104d2e10d14369e0b4e5" translate="yes" xml:space="preserve">
          <source>We could also consider object destructuring as a means to access a property in an object, but as follows:</source>
          <target state="translated">또한 객체 파괴는 객체의 속성에 액세스하는 수단으로 고려할 수 있지만 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3905357ebf181c4b50e393bb69a3d74f87b025bd" translate="yes" xml:space="preserve">
          <source>Whenever you need to access property dynamically you have to use square bracket for accessing property not &quot;.&quot; operator</source>
          <target state="translated">속성에 동적으로 액세스해야 할 때마다 &quot;.&quot;가 아닌 속성에 액세스하려면 대괄호를 사용해야합니다. 운영자</target>
        </trans-unit>
        <trans-unit id="8c2f72513c8502b8b436677eb1fd1a8286c418b5" translate="yes" xml:space="preserve">
          <source>You can achieve this in quite a few different ways.</source>
          <target state="translated">몇 가지 다른 방법으로이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ecbd70c7f912bb6ec39411ca0b2d318f260940" translate="yes" xml:space="preserve">
          <source>You can do it like this using Lodash get</source>
          <target state="translated">Lodash get을 사용하여 이와 같이 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="11904d98efc1e0b6e5d5f477b61a849dec2d5680" translate="yes" xml:space="preserve">
          <source>You should use &lt;code&gt;JSON.parse&lt;/code&gt;, take a look at &lt;a href=&quot;https://www.w3schools.com/js/js_json_parse.asp&quot;&gt;https://www.w3schools.com/js/js_json_parse.asp&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;JSON.parse&lt;/code&gt; 를 사용해야합니다. &lt;a href=&quot;https://www.w3schools.com/js/js_json_parse.asp&quot;&gt;https://www.w3schools.com/js/js_json_parse.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a3772e1dbfdf192051b80d4e269ce0fbdb1f2d7" translate="yes" xml:space="preserve">
          <source>dot notation     - &lt;code&gt;foo.bar&lt;/code&gt;</source>
          <target state="translated">점 표기법 &lt;code&gt;foo.bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7263c675a6d65b6436a45aadd91cf3f6db7ef15" translate="yes" xml:space="preserve">
          <source>however I rarely go this route because it doesn't work on property values assigned via style-sheets. To give you an example, I'll demonstrate with a bit of pseudo code.</source>
          <target state="translated">그러나 스타일 시트를 통해 할당 된 속성 값에서는 작동하지 않기 때문에이 경로를 거의 사용하지 않습니다. 예제를 제공하기 위해 약간의 의사 코드를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="19465118b87f9cbe4a18959dde3553907dae9e6b" translate="yes" xml:space="preserve">
          <source>square brackets  - &lt;code&gt;foo[someVar]&lt;/code&gt; or &lt;code&gt;foo[&quot;string&quot;]&lt;/code&gt;</source>
          <target state="translated">대괄호 &lt;code&gt;foo[someVar]&lt;/code&gt; 또는 &lt;code&gt;foo[&quot;string&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d99f66b852fef055214f1f6c4e0864afe932b13e" translate="yes" xml:space="preserve">
          <source>usage:</source>
          <target state="translated">usage:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
