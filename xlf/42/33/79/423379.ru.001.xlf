<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/423379">
    <body>
      <group id="423379">
        <trans-unit id="3a29a28d4e300f6b9d5792eb7d5f29058935330c" translate="yes" xml:space="preserve">
          <source>(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</source>
          <target state="translated">(Я считаю,что такое поведение возникло в основном за счет оптимизации локальных пространств имен-без такого поведения ВМ Python должна была бы выполнять как минимум три поиска имен каждый раз при назначении нового имени внутри функции (чтобы гарантировать,что имя уже не существовало на уровне модульной сборки),что значительно замедлило бы очень распространенную операцию).</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a48a084b773cbe5f5fb20cc6a9ca54adbc106d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/config.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/config.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf13aaa1958e161e4472d4ced8b48503adb7f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/runner.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/runner.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4f93d499dc80601179acd8f180b4012220ba4cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b3aabce7f8e6e2cd6cc1f730a4a92618cfe4c43" translate="yes" xml:space="preserve">
          <source>A follow on comment asks:</source>
          <target state="translated">Следуйте за комментариями:</target>
        </trans-unit>
        <trans-unit id="831c1deafff39dc2e0e4c47676f7c7651ee65397" translate="yes" xml:space="preserve">
          <source>A specific use of global-in-a-module is described here - &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;How do I share global variables across modules?&lt;/a&gt;, and for completeness the contents are shared here:</source>
          <target state="translated">Конкретное использование global-in-a-module описано здесь - &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;Как мне совместно использовать глобальные переменные между модулями?&lt;/a&gt; и для полноты содержания поделитесь здесь:</target>
        </trans-unit>
        <trans-unit id="382bf460fa9f0a13f62cf8265fd9b497087fbfdd" translate="yes" xml:space="preserve">
          <source>Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.</source>
          <target state="translated">Кроме того,глобальные переменные полезны,в отличие от некоторых фанатиков ООП,которые утверждают обратное-особенно для небольших скриптов,где ООП перегибает палку.</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">А теперь..:</target>
        </trans-unit>
        <trans-unit id="ea8235608bc286dd475d407c66ae4bc1edc30400" translate="yes" xml:space="preserve">
          <source>As follows:</source>
          <target state="translated">Вот как:</target>
        </trans-unit>
        <trans-unit id="b3f7a4454712d08571f98953114c6f37fade56b3" translate="yes" xml:space="preserve">
          <source>As it turns out the answer is always simple.</source>
          <target state="translated">Как оказалось,ответ всегда прост.</target>
        </trans-unit>
        <trans-unit id="e68fb89042177a22f85fcb29baf649f07687ea4e" translate="yes" xml:space="preserve">
          <source>Both give the same output.</source>
          <target state="translated">Оба дают один и тот же результат.</target>
        </trans-unit>
        <trans-unit id="d2a60791f237ebd0573c45e98b3bbe67a69974d9" translate="yes" xml:space="preserve">
          <source>But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use &lt;code&gt;self&lt;/code&gt; arguments here - these could be class methods (handy if mutating the class attribute from the usual &lt;code&gt;cls&lt;/code&gt; argument) or static methods (no &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;cls&lt;/code&gt;).</source>
          <target state="translated">Но я бы предложил вместо использования глобальных переменных использовать атрибуты класса, чтобы не загромождать пространство имен модуля. Также обратите внимание, что здесь мы не используем аргументы &lt;code&gt;self&lt;/code&gt; - это могут быть методы класса (это удобно, если мутировать атрибут класса из обычного аргумента &lt;code&gt;cls&lt;/code&gt; ) или статические методы (без &lt;code&gt;self&lt;/code&gt; или &lt;code&gt;cls&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e52db3daf0213206b9bd29001eb49db2ead367f" translate="yes" xml:space="preserve">
          <source>But the better way is to use the global variable like this:</source>
          <target state="translated">Но лучше использовать такую глобальную переменную:</target>
        </trans-unit>
        <trans-unit id="bbf8d1399bcb14f026be806f4fa8af8f8f28b92e" translate="yes" xml:space="preserve">
          <source>But using that misnamed local variable does not change the global variable:</source>
          <target state="translated">Но использование этой неправильно названной локальной переменной не изменяет глобальную переменную:</target>
        </trans-unit>
        <trans-unit id="21065925475664b639823498cf7afc05ae436197" translate="yes" xml:space="preserve">
          <source>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user&amp;rsquo;s global variables. On the other hand, if you know what you are doing you can touch a module&amp;rsquo;s global variables with the same notation used to refer to its functions, &lt;code&gt;modname.itemname&lt;/code&gt;.</source>
          <target state="translated">Каждый модуль имеет свою собственную таблицу символов, которая используется в качестве глобальной таблицы символов всеми функциями, определенными в модуле. Таким образом, автор модуля может использовать глобальные переменные в модуле, не беспокоясь о случайных столкновениях с глобальными переменными пользователя. С другой стороны, если вы знаете, что делаете, вы можете прикоснуться к глобальным переменным модуля в той же записи, что и для ссылки на его функции, &lt;code&gt;modname.itemname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d42c87f4a4cb2658756a338842b6e9caf5c4cb4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;getstocks.py&lt;/em&gt;:</source>
          <target state="translated">Файл &lt;em&gt;getstocks.py&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="0dcfee04bdce5c9c94e649b611fb6a026a77a9e4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;initval.py&lt;/em&gt;:</source>
          <target state="translated">Файл &lt;em&gt;initval.py&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="6dbcd6992db7e9840509e7cc35fa6c430c718e4e" translate="yes" xml:space="preserve">
          <source>File: config.py</source>
          <target state="translated">Файл:config.py</target>
        </trans-unit>
        <trans-unit id="828c739880e40a2ca36ab9ef0843c428e9f7ab58" translate="yes" xml:space="preserve">
          <source>File: main.py</source>
          <target state="translated">Файл:main.py</target>
        </trans-unit>
        <trans-unit id="dfb12898324c1f6fc1a0454806497d0482362334" translate="yes" xml:space="preserve">
          <source>File: mod.py</source>
          <target state="translated">Файл:mod.py</target>
        </trans-unit>
        <trans-unit id="bcc361b07598fb63cbd8411db8e5b2d66c808872" translate="yes" xml:space="preserve">
          <source>Following on and as an add on, use a file to contain all global variables all declared locally and then &lt;code&gt;import as&lt;/code&gt;:</source>
          <target state="translated">В качестве дополнения используйте файл, содержащий все глобальные переменные, объявленные локально, а затем &lt;code&gt;import as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="d6230aa52a35650b976c27208c9b41c6c4638672" translate="yes" xml:space="preserve">
          <source>Here I demonstrate we get the same behavior in methods as we do in regular functions:</source>
          <target state="translated">Здесь я демонстрирую,что в методах мы получаем то же самое поведение,что и в обычных функциях:</target>
        </trans-unit>
        <trans-unit id="ff2ef371dbac72e4f6add26d0dc913ad7cc66a86" translate="yes" xml:space="preserve">
          <source>Here is a small sample module with a simple way to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">Вот небольшой пример модуля с простым способом показать его в &lt;code&gt;main&lt;/code&gt; определении:</target>
        </trans-unit>
        <trans-unit id="4642e3e366e141920eafccce38fba209dfc45ccc" translate="yes" xml:space="preserve">
          <source>Here is how to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">Вот как это показать в &lt;code&gt;main&lt;/code&gt; определении:</target>
        </trans-unit>
        <trans-unit id="8991da6e4670d4c723a1a153a470485b70325de7" translate="yes" xml:space="preserve">
          <source>How can I create or use a global variable in a function?</source>
          <target state="translated">Как создать или использовать глобальную переменную в функции?</target>
        </trans-unit>
        <trans-unit id="95fdb4946a28aa2e7dfa96a14e1865723254e148" translate="yes" xml:space="preserve">
          <source>However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.</source>
          <target state="translated">Однако,если вы присваиваете новую переменную,не объявленную глобальной в функции,то она неявно объявляется локальной,и она может затмить любую существующую глобальную переменную с тем же именем.</target>
        </trans-unit>
        <trans-unit id="c1df67f2e32daa98e81e9c10062af50c8d22fc6e" translate="yes" xml:space="preserve">
          <source>I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the &lt;code&gt;global&lt;/code&gt; keyword.</source>
          <target state="translated">Я предполагаю, что причина в том, что, поскольку глобальные переменные настолько опасны, Python хочет убедиться, что вы действительно знаете, с чем вы играете, явно требуя ключевое слово &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd87132234042a627a085a0c1b2af889af0d848c" translate="yes" xml:space="preserve">
          <source>I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; function returns a mutable global symbol dictionary where you can &quot;magically&quot; make data available for the rest of your code. 
For example:</source>
          <target state="translated">Я добавляю это, поскольку я не видел это ни в одном из других ответов, и это может быть полезно для кого-то, борющегося с чем-то подобным. Функция &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; возвращает изменяемый словарь глобальных символов, где вы можете &amp;laquo;волшебным образом&amp;raquo; сделать данные доступными для остальной части вашего кода. Например:</target>
        </trans-unit>
        <trans-unit id="bf3ce99181155bb8d031a964f7e5313fc538f7e4" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that global variable in another function? Do I need to store the global variable in a local variable of the function which needs its access?</source>
          <target state="translated">Если я создаю глобальную переменную в одной функции,как я могу использовать эту глобальную переменную в другой функции? Нужно ли хранить глобальную переменную в локальной переменной функции,к которой необходим доступ?</target>
        </trans-unit>
        <trans-unit id="8a16d826c7c600e6adddd1b1b0f6795ec79959f6" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that variable in another function?</source>
          <target state="translated">Если я создаю глобальную переменную в одной функции,как я могу использовать эту переменную в другой?</target>
        </trans-unit>
        <trans-unit id="b8028c2e61a77dee86ccb01aa52f7a1e7a2d959a" translate="yes" xml:space="preserve">
          <source>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</source>
          <target state="translated">Если я правильно понимаю вашу ситуацию,то вы видите результат того,как Python обрабатывает локальное (функциональное)и глобальное (модульное)пространства имен.</target>
        </trans-unit>
        <trans-unit id="a6c2c29d467201cc494122ecc52c43bd4f8cf0cc" translate="yes" xml:space="preserve">
          <source>If you create a local variable with the same name, it will overshadow a global variable:</source>
          <target state="translated">Если вы создадите локальную переменную с таким же именем,она затмит глобальную переменную:</target>
        </trans-unit>
        <trans-unit id="526565a39b3a2f5141b90048b5bcd8783df3a491" translate="yes" xml:space="preserve">
          <source>If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases.</source>
          <target state="translated">Если бы вам не нужно было явно указывать,когда идентификатор должен ссылаться на предопределенный глобальный,то вы,вероятно,должны были бы явно указывать,когда идентификатор является новой локальной переменной (например,с помощью чего-то вроде команды 'var',видимой в JavaScript).Поскольку в любой серьёзной и нетривиальной системе локальные переменные встречаются чаще,чем глобальные,система Python в большинстве случаев имеет больший смысл.</target>
        </trans-unit>
        <trans-unit id="b40ade2a2372e7d63caa7d05e130870fc99946cf" translate="yes" xml:space="preserve">
          <source>If you want to refer to a global variable in a function, you can use the &lt;strong&gt;global&lt;/strong&gt; keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.</source>
          <target state="translated">Если вы хотите сослаться на глобальную переменную в функции, вы можете использовать ключевое слово &lt;strong&gt;global,&lt;/strong&gt; чтобы объявить, какие переменные являются глобальными. Вам не нужно использовать его во всех случаях (как здесь неправильно утверждают) - если имя, на которое есть ссылка в выражении, не может быть найдено в локальной области видимости или области действия в функциях, в которых определена эта функция, оно ищется среди глобальных переменные.</target>
        </trans-unit>
        <trans-unit id="753063fdb8ccba8abb2d018e4484738cdedc4ba0" translate="yes" xml:space="preserve">
          <source>In Python, variables that are only referenced inside a function are
  &lt;strong&gt;implicitly global&lt;/strong&gt;. If a variable is assigned a new value anywhere
  within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a &lt;strong&gt;local&lt;/strong&gt;. If a variable
  is ever assigned a new value inside the function, the variable is
  implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.</source>
          <target state="translated">В Python переменные, на которые ссылаются только внутри функции, &lt;strong&gt;неявно глобальны&lt;/strong&gt; . Если переменной в любом месте внутри тела функции назначено новое значение, она считается &lt;strong&gt;локальной&lt;/strong&gt; . Если переменной когда-либо назначается новое значение внутри функции, переменная неявно является локальной, и вам необходимо явно объявить ее как &amp;laquo;глобальную&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ae253629bb7e76f3c2eb67c025d8cad8dfe4347f" translate="yes" xml:space="preserve">
          <source>In addition to already existing answers and to make this more confusing:</source>
          <target state="translated">В дополнение к уже существующим ответам и сделать это более запутанным:</target>
        </trans-unit>
        <trans-unit id="366c68bf24874b885d4c0b04c646aa27826522c9" translate="yes" xml:space="preserve">
          <source>In case you have a local variable with the same name, you might want to use the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">Если у вас есть локальная переменная с тем же именем, вы можете использовать &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt;функцию &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="757725c834e63de261ff0fcf679ebe9f7da64387" translate="yes" xml:space="preserve">
          <source>In this example, runner is using &lt;strong&gt;max&lt;/strong&gt; from the file config. I want my test to change the value of &lt;strong&gt;max&lt;/strong&gt; when runner is using it.</source>
          <target state="translated">В этом примере бегун использует &lt;strong&gt;max&lt;/strong&gt; из файла config. Я хочу, чтобы мой тест изменил значение &lt;strong&gt;max,&lt;/strong&gt; когда бегун его использует.</target>
        </trans-unit>
        <trans-unit id="c2be3a39d7cd2238e86185235780e3d6bacd74bd" translate="yes" xml:space="preserve">
          <source>Local variables with the same name</source>
          <target state="translated">Локальные переменные с одинаковым именем</target>
        </trans-unit>
        <trans-unit id="adb2902dbe58db2b1c4e635820ac254599998269" translate="yes" xml:space="preserve">
          <source>Modification of the global variable from inside a function</source>
          <target state="translated">Модификация глобальной переменной изнутри функции</target>
        </trans-unit>
        <trans-unit id="f170cc8be722b1dc8f64cdb89f2437a052e0ddd3" translate="yes" xml:space="preserve">
          <source>Note that &quot;global&quot; in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.</source>
          <target state="translated">Обратите внимание,что &quot;глобальный&quot; на Python не является по-настоящему глобальным-он только на модульном уровне.Поэтому он доступен только для функций,написанных в модулях,в которых он является глобальным.Функции запоминают модуль,в котором они написаны,поэтому при экспорте в другие модули они продолжают искать глобальные переменные в модуле,в котором они были созданы.</target>
        </trans-unit>
        <trans-unit id="8c71357e59c34f569330bbf42118d099786d64bd" translate="yes" xml:space="preserve">
          <source>Note that after writing this function, the code actually changing it has still not run:</source>
          <target state="translated">Обратите внимание,что после написания этой функции код,фактически изменяющий ее,до сих пор не запущен:</target>
        </trans-unit>
        <trans-unit id="c89c18f4431fa00077e4850544b5784823792628" translate="yes" xml:space="preserve">
          <source>Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.</source>
          <target state="translated">Обратите внимание,что вам следует избегать использования локальных переменных с теми же именами,что и у глобусов,если только вы точно не знаете,что делаете,и не имеете на это очень веских оснований.Я еще не сталкивался с такой причиной.</target>
        </trans-unit>
        <trans-unit id="4d759e506cc87fd94eb228708ebf8d3af992fed6" translate="yes" xml:space="preserve">
          <source>Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.</source>
          <target state="translated">Python использует простой эвристический метод,чтобы решить,из какого диапазона он должен загружать переменную,между локальным и глобальным.Если имя переменной появляется в левой части присваивания,но не объявляется глобальной,то предполагается,что она является локальной.Если она не появляется в левой части присваивания,то считается,что она глобальная.</target>
        </trans-unit>
        <trans-unit id="82e7e92a83c2370747a78755bf7bd7f480cb211a" translate="yes" xml:space="preserve">
          <source>Reference the class namespace where you want the change to show up.</source>
          <target state="translated">Обратитесь к пространству имён классов,в котором вы хотите,чтобы изменения отображались.</target>
        </trans-unit>
        <trans-unit id="d51825ca829838501c1e4d45114169b59541a7aa" translate="yes" xml:space="preserve">
          <source>Say you've got a module like this:</source>
          <target state="translated">Скажи,что у тебя есть такой модуль:</target>
        </trans-unit>
        <trans-unit id="32f1e2eebe50a1762d5277748745d8fbe01fdb6d" translate="yes" xml:space="preserve">
          <source>See how baz, which appears on the left side of an assignment in &lt;code&gt;foo()&lt;/code&gt;, is the only &lt;code&gt;LOAD_FAST&lt;/code&gt; variable.</source>
          <target state="translated">Посмотрите, как baz, который появляется в левой части назначения в &lt;code&gt;foo()&lt;/code&gt; , является единственной переменной &lt;code&gt;LOAD_FAST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b70c1e0a06b68daff9b694d823872ede25884d46" translate="yes" xml:space="preserve">
          <source>See other answers if you want to share a global variable across modules.</source>
          <target state="translated">См.другие ответы,если вы хотите предоставить общий доступ к глобальной переменной между модулями.</target>
        </trans-unit>
        <trans-unit id="ca4cb42a3ea049813c0ec667fbcdf3509dcd2e15" translate="yes" xml:space="preserve">
          <source>So after calling the function:</source>
          <target state="translated">Итак,после вызова функции:</target>
        </trans-unit>
        <trans-unit id="841b2904cac2a4bc796bc658ba8ef34b26e05323" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;What are the rules for local and global variables in Python?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Источник: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;Каковы правила для локальных и глобальных переменных в Python?&lt;/a&gt;&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="553e5e7d40b28c7793e577cda926afd288ff4db1" translate="yes" xml:space="preserve">
          <source>The canonical way to share information across modules within a single program is to create a special configuration module (often called &lt;strong&gt;config&lt;/strong&gt; or &lt;strong&gt;cfg&lt;/strong&gt;). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</source>
          <target state="translated">Канонический способ обмена информацией между модулями в рамках одной программы - создать специальный модуль конфигурации (часто называемый &lt;strong&gt;config&lt;/strong&gt; или &lt;strong&gt;cfg&lt;/strong&gt; ). Просто импортируйте модуль конфигурации во все модули вашего приложения; модуль становится доступным как глобальное имя. Поскольку существует только один экземпляр каждого модуля, любые изменения, внесенные в объект модуля, отражаются повсеместно. Например:</target>
        </trans-unit>
        <trans-unit id="808008d2043d737b7ce2c0ff8be31b1727e98f20" translate="yes" xml:space="preserve">
          <source>This simple code works just like that, and it will execute. I hope it helps.</source>
          <target state="translated">Этот простой код работает именно так,и он будет выполняться.Надеюсь,он поможет.</target>
        </trans-unit>
        <trans-unit id="a778fa74f0b4bfd3ce58b5f0f686aebc59db57b4" translate="yes" xml:space="preserve">
          <source>Though a bit surprising at first, a moment&amp;rsquo;s consideration explains
  this. On one hand, requiring global for assigned variables provides a
  bar against unintended side-effects. On the other hand, if global was
  required for all global references, you&amp;rsquo;d be using global all the
  time. You&amp;rsquo;d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</source>
          <target state="translated">Хотя поначалу это немного удивляет, обдумывание этого объясняется моментом. С одной стороны, требование глобальных назначенных переменных обеспечивает защиту от непреднамеренных побочных эффектов. С другой стороны, если бы глобальный требовался для всех глобальных ссылок, вы бы использовали глобальный все время. Вы должны будете объявить как глобальную каждую ссылку на встроенную функцию или компонент импортируемого модуля. Этот беспорядок отрицает полезность глобальной декларации для выявления побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="400f17d44c6a3438a85b87775ed1333c75f30def" translate="yes" xml:space="preserve">
          <source>To point the global variable at a different object, you are required to use the global keyword again:</source>
          <target state="translated">Чтобы направить глобальную переменную на другой объект,необходимо снова использовать глобальное ключевое слово:</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">Попробуй это:</target>
        </trans-unit>
        <trans-unit id="32d247e27063921abab961801b76b443eb072388" translate="yes" xml:space="preserve">
          <source>Using global variables in a function</source>
          <target state="translated">Использование глобальных переменных в функции</target>
        </trans-unit>
        <trans-unit id="6a278e1e6dcb9a8315d8de0c331b9839a70f5f6f" translate="yes" xml:space="preserve">
          <source>Using globals without modification</source>
          <target state="translated">Использование глобусов без изменений</target>
        </trans-unit>
        <trans-unit id="1c8bbbb1a5b2ea68b84c72c7d588482b45639eee" translate="yes" xml:space="preserve">
          <source>We can create a global with the following function:</source>
          <target state="translated">Мы можем создать глобальный со следующей функцией:</target>
        </trans-unit>
        <trans-unit id="56ca4d0f3967908061048393e2bfd872827e2dc2" translate="yes" xml:space="preserve">
          <source>We get the same behavior in classes</source>
          <target state="translated">У нас одинаковое поведение на занятиях</target>
        </trans-unit>
        <trans-unit id="b4c19d3873d161e46c75ceec1be024497c5b2e3e" translate="yes" xml:space="preserve">
          <source>What you are saying is to use the method like this:</source>
          <target state="translated">Вы говорите о том,чтобы использовать такой метод:</target>
        </trans-unit>
        <trans-unit id="fcdf0bf377a132d036d9bbe6e09e1b12fb039c33" translate="yes" xml:space="preserve">
          <source>What's going on here is that Python assumes that any name that is &lt;em&gt;assigned to&lt;/em&gt;, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only &lt;em&gt;reading&lt;/em&gt; from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</source>
          <target state="translated">Здесь происходит то, что Python предполагает, что любое имя, которое &lt;em&gt;присваивается в&lt;/em&gt; любом месте функции, является локальным для этой функции, если явно не указано иное. Если это только &lt;em&gt;чтение&lt;/em&gt; из имени, а имя не существует локально, оно будет пытаться найти имя в любой содержащей области (например, в глобальной области видимости модуля).</target>
        </trans-unit>
        <trans-unit id="a3506340df03656042deb181b56e916a76306c18" translate="yes" xml:space="preserve">
          <source>When you assign 42 to the name &lt;code&gt;myGlobal&lt;/code&gt;, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;garbage-collected&lt;/a&gt; when &lt;code&gt;func1()&lt;/code&gt; returns; meanwhile, &lt;code&gt;func2()&lt;/code&gt; can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of &lt;code&gt;myGlobal&lt;/code&gt; inside &lt;code&gt;func1()&lt;/code&gt; before you assign to it, you'd get an &lt;code&gt;UnboundLocalError&lt;/code&gt;, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '&lt;code&gt;global&lt;/code&gt;' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</source>
          <target state="translated">Поэтому, когда вы присваиваете 42 имени &lt;code&gt;myGlobal&lt;/code&gt; , Python создает локальную переменную, которая скрывает глобальную переменную с тем же именем. Этот локальный &lt;code&gt;func1()&lt;/code&gt; выходит из области видимости и &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;собирается&lt;/a&gt; после возврата func1 () ; Между тем, &lt;code&gt;func2()&lt;/code&gt; никогда не увидит ничего, кроме (неизмененного) глобального имени. Обратите внимание, что это решение о пространстве имен происходит во время компиляции, а не во время выполнения - если бы вы прочитали значение &lt;code&gt;myGlobal&lt;/code&gt; внутри &lt;code&gt;func1()&lt;/code&gt; перед тем, как назначить его, вы получите &lt;code&gt;UnboundLocalError&lt;/code&gt; , потому что Python уже решил, что он должен быть локальная переменная, но она еще не имеет какого-либо значения, связанного с ней. Но, используя выражение &amp;laquo; &lt;code&gt;global&lt;/code&gt; &amp;raquo;, вы говорите Python, что он должен искать имя в другом месте, а не назначать его локально.</target>
        </trans-unit>
        <trans-unit id="946f5220d4c0ffd2002c5c5a98c6d48ae55240ed" translate="yes" xml:space="preserve">
          <source>Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only.</source>
          <target state="translated">Позволяет просто выгружать переменные из и в глобальное пространство имен.Супер удобно,без шума и суеты.Уверен,что это только Python 3.</target>
        </trans-unit>
        <trans-unit id="fe2ce5d5861f8377eecbb92498c26eb8c03d724d" translate="yes" xml:space="preserve">
          <source>With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:</source>
          <target state="translated">При параллельном выполнении глобальные переменные могут привести к неожиданным результатам,если вы не понимаете,что происходит.Приведем пример использования глобальной переменной при многопроцессорной обработке.Мы четко видим,что каждый процесс работает со своей собственной копией переменной:</target>
        </trans-unit>
        <trans-unit id="54e1cac78dddcbd65775350f737c72e93d2d798f" translate="yes" xml:space="preserve">
          <source>Writing a function does not actually run its code. So we call the &lt;code&gt;create_global_variable&lt;/code&gt; function:</source>
          <target state="translated">Написание функции фактически не запускает ее код. Поэтому мы вызываем функцию &lt;code&gt;create_global_variable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e03ad1c070e36b872b3333d095e7388731b22882" translate="yes" xml:space="preserve">
          <source>Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it &quot;wholesale&quot; does have that requirement:</source>
          <target state="translated">Запись в явные элементы глобального массива,очевидно,не нуждается в глобальном объявлении,хотя запись в него &quot;оптом&quot; имеет такое требование:</target>
        </trans-unit>
        <trans-unit id="cbecb723606740114452d22a28142d9af6613a55" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.</source>
          <target state="translated">У вас &lt;em&gt;может&lt;/em&gt; быть язык, который пытается угадать, используя глобальную переменную, если она существует, или создавая локальную переменную, если она не существует. Однако это было бы очень подвержено ошибкам. Например, импорт другого модуля может непреднамеренно ввести глобальную переменную с таким именем, что приведет к изменению поведения вашей программы.</target>
        </trans-unit>
        <trans-unit id="d42881afae3fc3861e64948e9774514253333db4" translate="yes" xml:space="preserve">
          <source>You can just use it, so long as you don't expect to change which object it points to:</source>
          <target state="translated">Вы можете просто использовать его,при условии,что не будете ожидать изменения того,на какой объект он указывает:</target>
        </trans-unit>
        <trans-unit id="b5500ef73857d114d1c398cb4242333b1ef82771" translate="yes" xml:space="preserve">
          <source>You can use a global variable in other functions by declaring it as &lt;code&gt;global&lt;/code&gt; in each function that assigns to it:</source>
          <target state="translated">Вы можете использовать глобальную переменную в других функциях, объявив ее как &lt;code&gt;global&lt;/code&gt; в каждой присваиваемой ей функции:</target>
        </trans-unit>
        <trans-unit id="bb853d6e0b691fc0b5ce5fb7fac2249a580747d1" translate="yes" xml:space="preserve">
          <source>You may want to explore the notion of &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;namespaces&lt;/a&gt;. In Python, the &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;module&lt;/a&gt; is the natural place for &lt;em&gt;global&lt;/em&gt; data:</source>
          <target state="translated">Вы можете исследовать понятие &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;пространств имен&lt;/a&gt; . В Python &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;модуль&lt;/a&gt; является естественным местом для &lt;em&gt;глобальных&lt;/em&gt; данных:</target>
        </trans-unit>
        <trans-unit id="59950ecb7d047f5218b8fa8c0b131c6862e9cb6a" translate="yes" xml:space="preserve">
          <source>You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a '&lt;code&gt;global&lt;/code&gt;' declaration to &lt;code&gt;func1()&lt;/code&gt;, then &lt;code&gt;func2()&lt;/code&gt; will print 42.</source>
          <target state="translated">Вы можете ожидать, что это напечатает 42, но вместо этого оно печатает 5. Как уже упоминалось, если вы добавите &amp;laquo; &lt;code&gt;global&lt;/code&gt; &amp;raquo; объявление к &lt;code&gt;func1()&lt;/code&gt; , то &lt;code&gt;func2()&lt;/code&gt; выведет 42.</target>
        </trans-unit>
        <trans-unit id="6f7e627d65ec53dbbbe98628a309293b7318508d" translate="yes" xml:space="preserve">
          <source>You need to reference the global variable in every function you want to use.</source>
          <target state="translated">Вы должны ссылаться на глобальную переменную в каждой функции,которую вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="20ae9a054da61b005011ec052d200d4d80ee4f67" translate="yes" xml:space="preserve">
          <source>You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.</source>
          <target state="translated">На самом деле вы не храните глобальную переменную в локальной,а просто создаете локальную ссылку на тот же объект,на который ссылается ваша оригинальная глобальная ссылка.Помните,что практически все на Python-это имя,ссылающееся на объект,и ничто не копируется в обычном режиме работы.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="fae82a086e49510dea6d0bfce87709497778fe3a" translate="yes" xml:space="preserve">
          <source>and now we can use the global variable:</source>
          <target state="translated">и теперь мы можем использовать глобальную переменную:</target>
        </trans-unit>
        <trans-unit id="451cb4f77137909fcb0b3a6aad84ab3e27589353" translate="yes" xml:space="preserve">
          <source>we can see that the global variable has been changed. The &lt;code&gt;global_variable&lt;/code&gt; name now points to &lt;code&gt;'Bar'&lt;/code&gt;:</source>
          <target state="translated">мы видим, что глобальная переменная была изменена. Имя &lt;code&gt;global_variable&lt;/code&gt; теперь указывает на &lt;code&gt;'Bar'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4745a5736422bf254160a52d8206da60d719e401" translate="yes" xml:space="preserve">
          <source>what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class?</source>
          <target state="translated">что делать,если я хочу создать глобальную переменную внутри функции внутри класса и хочу использовать эту переменную внутри другой функции внутри другого класса?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
