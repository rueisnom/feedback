<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/423379">
    <body>
      <group id="423379">
        <trans-unit id="3a29a28d4e300f6b9d5792eb7d5f29058935330c" translate="yes" xml:space="preserve">
          <source>(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</source>
          <target state="translated">(이 동작은 로컬 네임 스페이스의 최적화를 통해 주로 발생했다고 생각합니다.이 동작이 없으면 Python의 VM은 함수 내부에 새 이름이 할당 될 때마다 적어도 세 번의 이름 조회를 수행해야합니다 (이름이 ' t는 이미 모듈 / 내장 레벨에 존재하므로 매우 일반적인 작동 속도를 크게 저하시킵니다.)</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a48a084b773cbe5f5fb20cc6a9ca54adbc106d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/config.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/config.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf13aaa1958e161e4472d4ced8b48503adb7f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/runner.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/runner.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4f93d499dc80601179acd8f180b4012220ba4cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b3aabce7f8e6e2cd6cc1f730a4a92618cfe4c43" translate="yes" xml:space="preserve">
          <source>A follow on comment asks:</source>
          <target state="translated">의견에 따라 다음과 같이 묻습니다.</target>
        </trans-unit>
        <trans-unit id="831c1deafff39dc2e0e4c47676f7c7651ee65397" translate="yes" xml:space="preserve">
          <source>A specific use of global-in-a-module is described here - &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;How do I share global variables across modules?&lt;/a&gt;, and for completeness the contents are shared here:</source>
          <target state="translated">전역 모듈의 특정 사용법은 여기에 설명되어 있습니다- &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;모듈간에 전역 변수를 공유하는 방법은 무엇입니까?&lt;/a&gt; , 그리고 완전성을 위해 내용은 여기에 공유됩니다 :</target>
        </trans-unit>
        <trans-unit id="382bf460fa9f0a13f62cf8265fd9b497087fbfdd" translate="yes" xml:space="preserve">
          <source>Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.</source>
          <target state="translated">또한 전역 변수는 특히 OOP가 과도하게 사용되는 작은 스크립트의 경우 달리 주장하는 일부 OOP 열광 자와 달리 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">그리고 지금:</target>
        </trans-unit>
        <trans-unit id="ea8235608bc286dd475d407c66ae4bc1edc30400" translate="yes" xml:space="preserve">
          <source>As follows:</source>
          <target state="translated">다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="b3f7a4454712d08571f98953114c6f37fade56b3" translate="yes" xml:space="preserve">
          <source>As it turns out the answer is always simple.</source>
          <target state="translated">결과는 항상 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e68fb89042177a22f85fcb29baf649f07687ea4e" translate="yes" xml:space="preserve">
          <source>Both give the same output.</source>
          <target state="translated">둘 다 동일한 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d2a60791f237ebd0573c45e98b3bbe67a69974d9" translate="yes" xml:space="preserve">
          <source>But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use &lt;code&gt;self&lt;/code&gt; arguments here - these could be class methods (handy if mutating the class attribute from the usual &lt;code&gt;cls&lt;/code&gt; argument) or static methods (no &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;cls&lt;/code&gt;).</source>
          <target state="translated">그러나 전역 변수를 사용하는 대신 클래스 네임 스페이스를 사용하여 모듈 네임 스페이스를 어지럽히 지 않도록 제안합니다. 또한 &lt;code&gt;self&lt;/code&gt; 인수를 사용하지 않습니다. 여기에는 클래스 메소드 (일반 &lt;code&gt;cls&lt;/code&gt; 인수에서 클래스 속성을 변경하는 경우 유용) 또는 정적 메소드 ( &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;cls&lt;/code&gt; 아님)가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e52db3daf0213206b9bd29001eb49db2ead367f" translate="yes" xml:space="preserve">
          <source>But the better way is to use the global variable like this:</source>
          <target state="translated">그러나 더 좋은 방법은 다음과 같이 전역 변수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bbf8d1399bcb14f026be806f4fa8af8f8f28b92e" translate="yes" xml:space="preserve">
          <source>But using that misnamed local variable does not change the global variable:</source>
          <target state="translated">그러나 이름이 잘못 지정된 로컬 변수를 사용해도 전역 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21065925475664b639823498cf7afc05ae436197" translate="yes" xml:space="preserve">
          <source>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user&amp;rsquo;s global variables. On the other hand, if you know what you are doing you can touch a module&amp;rsquo;s global variables with the same notation used to refer to its functions, &lt;code&gt;modname.itemname&lt;/code&gt;.</source>
          <target state="translated">각 모듈에는 자체 개인 심볼 테이블이 있으며,이 모듈은 모듈에 정의 된 모든 기능에서 전역 심볼 테이블로 사용됩니다. 따라서 모듈 작성자는 실수로 사용자의 전역 변수와 충돌 할 염려없이 모듈에서 전역 변수를 사용할 수 있습니다. 반면에, 당신이 무엇을하고 있는지 아는 경우, 모듈의 전역 변수를 해당 기능을 지칭하는 데 사용 된 것과 같은 표기법으로 사용할 수 있습니다 ( &lt;code&gt;modname.itemname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d42c87f4a4cb2658756a338842b6e9caf5c4cb4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;getstocks.py&lt;/em&gt;:</source>
          <target state="translated">파일 &lt;em&gt;getstocks.py&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="0dcfee04bdce5c9c94e649b611fb6a026a77a9e4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;initval.py&lt;/em&gt;:</source>
          <target state="translated">파일 &lt;em&gt;initval.py&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="6dbcd6992db7e9840509e7cc35fa6c430c718e4e" translate="yes" xml:space="preserve">
          <source>File: config.py</source>
          <target state="translated">파일 : config.py</target>
        </trans-unit>
        <trans-unit id="828c739880e40a2ca36ab9ef0843c428e9f7ab58" translate="yes" xml:space="preserve">
          <source>File: main.py</source>
          <target state="translated">파일 : main.py</target>
        </trans-unit>
        <trans-unit id="dfb12898324c1f6fc1a0454806497d0482362334" translate="yes" xml:space="preserve">
          <source>File: mod.py</source>
          <target state="translated">파일 : mod.py</target>
        </trans-unit>
        <trans-unit id="bcc361b07598fb63cbd8411db8e5b2d66c808872" translate="yes" xml:space="preserve">
          <source>Following on and as an add on, use a file to contain all global variables all declared locally and then &lt;code&gt;import as&lt;/code&gt;:</source>
          <target state="translated">계속해서 추가 기능으로 파일을 사용하여 로컬로 선언 된 모든 전역 변수를 포함하고 다음으로 &lt;code&gt;import as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="d6230aa52a35650b976c27208c9b41c6c4638672" translate="yes" xml:space="preserve">
          <source>Here I demonstrate we get the same behavior in methods as we do in regular functions:</source>
          <target state="translated">다음은 정규 함수에서와 동일한 방식으로 메소드에서 동작하는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ff2ef371dbac72e4f6add26d0dc913ad7cc66a86" translate="yes" xml:space="preserve">
          <source>Here is a small sample module with a simple way to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">다음은 &lt;code&gt;main&lt;/code&gt; 정의에서 간단한 방법으로 보여주는 작은 샘플 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="4642e3e366e141920eafccce38fba209dfc45ccc" translate="yes" xml:space="preserve">
          <source>Here is how to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 정의로 표시하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8991da6e4670d4c723a1a153a470485b70325de7" translate="yes" xml:space="preserve">
          <source>How can I create or use a global variable in a function?</source>
          <target state="translated">함수에서 전역 변수를 작성하거나 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="95fdb4946a28aa2e7dfa96a14e1865723254e148" translate="yes" xml:space="preserve">
          <source>However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.</source>
          <target state="translated">그러나 함수에서 전역으로 선언되지 않은 새 변수를 할당하면 암시 적으로 로컬로 선언되며 같은 이름의 기존 전역 변수를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1df67f2e32daa98e81e9c10062af50c8d22fc6e" translate="yes" xml:space="preserve">
          <source>I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the &lt;code&gt;global&lt;/code&gt; keyword.</source>
          <target state="translated">그 이유는 전역 변수가 너무 위험하기 때문에 파이썬은 &lt;code&gt;global&lt;/code&gt; 키워드를 명시 적으로 요구하여 현재 가지고있는 것이 무엇인지 실제로 알고 싶어하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dd87132234042a627a085a0c1b2af889af0d848c" translate="yes" xml:space="preserve">
          <source>I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; function returns a mutable global symbol dictionary where you can &quot;magically&quot; make data available for the rest of your code. 
For example:</source>
          <target state="translated">다른 답변에서 보지 못했기 때문에 이것을 추가하고 있으며 비슷한 것으로 고군분투하는 사람에게 유용 할 수 있습니다. &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 함수는 변경 가능한 전역 기호 사전을 반환하며, 여기서 코드의 나머지 부분에서 &quot;마법으로&quot;데이터를 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf3ce99181155bb8d031a964f7e5313fc538f7e4" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that global variable in another function? Do I need to store the global variable in a local variable of the function which needs its access?</source>
          <target state="translated">한 함수에서 전역 변수를 만들면 다른 함수에서 해당 전역 변수를 어떻게 사용할 수 있습니까? 전역 변수를 액세스가 필요한 함수의 로컬 변수에 저장해야합니까?</target>
        </trans-unit>
        <trans-unit id="8a16d826c7c600e6adddd1b1b0f6795ec79959f6" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that variable in another function?</source>
          <target state="translated">한 함수에서 전역 변수를 만들면 다른 함수에서 해당 변수를 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b8028c2e61a77dee86ccb01aa52f7a1e7a2d959a" translate="yes" xml:space="preserve">
          <source>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</source>
          <target state="translated">상황을 올바르게 이해하고 있다면 파이썬이 로컬 (함수) 및 전역 (모듈) 네임 스페이스를 처리하는 방법의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="a6c2c29d467201cc494122ecc52c43bd4f8cf0cc" translate="yes" xml:space="preserve">
          <source>If you create a local variable with the same name, it will overshadow a global variable:</source>
          <target state="translated">이름이 같은 지역 변수를 만들면 전역 변수가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="526565a39b3a2f5141b90048b5bcd8783df3a491" translate="yes" xml:space="preserve">
          <source>If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases.</source>
          <target state="translated">식별자가 사전 정의 된 전역을 참조 할시기를 명시 적으로 지정할 필요가없는 경우, 식별자가 대신 새 로컬 변수 인 경우를 명시 적으로 지정해야합니다 (예 : 'var'명령과 같은 것). JavaScript에서 볼 수 있습니다). 로컬 변수는 심각하고 사소한 시스템에서 전역 변수보다 일반적이므로 Python 시스템은 대부분의 경우 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b40ade2a2372e7d63caa7d05e130870fc99946cf" translate="yes" xml:space="preserve">
          <source>If you want to refer to a global variable in a function, you can use the &lt;strong&gt;global&lt;/strong&gt; keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.</source>
          <target state="translated">함수에서 전역 변수를 참조하려면 &lt;strong&gt;global&lt;/strong&gt; 키워드를 사용하여 &lt;strong&gt;전역&lt;/strong&gt; 변수를 선언 할 수 있습니다. 모든 경우에이 이름을 사용할 필요는 없습니다 (여기서 누군가가 잘못 주장함). 표현식에서 참조 된 이름을이 함수가 정의 된 함수의 로컬 범위 나 범위에서 찾을 수없는 경우 전역에서 조회됩니다. 변수.</target>
        </trans-unit>
        <trans-unit id="753063fdb8ccba8abb2d018e4484738cdedc4ba0" translate="yes" xml:space="preserve">
          <source>In Python, variables that are only referenced inside a function are
  &lt;strong&gt;implicitly global&lt;/strong&gt;. If a variable is assigned a new value anywhere
  within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a &lt;strong&gt;local&lt;/strong&gt;. If a variable
  is ever assigned a new value inside the function, the variable is
  implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.</source>
          <target state="translated">파이썬에서 함수 내에서만 참조되는 변수는 &lt;strong&gt;암시 적으로 전역&lt;/strong&gt; 입니다. 함수 본문 내에서 변수에 새 값이 할당되면 &lt;strong&gt;local로&lt;/strong&gt; 간주됩니다. 함수 내에 변수에 새로운 값이 할당 된 경우 변수는 암시 적으로 로컬이므로 명시 적으로 'global'으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae253629bb7e76f3c2eb67c025d8cad8dfe4347f" translate="yes" xml:space="preserve">
          <source>In addition to already existing answers and to make this more confusing:</source>
          <target state="translated">이미 존재하는 답변 외에도 혼란 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="366c68bf24874b885d4c0b04c646aa27826522c9" translate="yes" xml:space="preserve">
          <source>In case you have a local variable with the same name, you might want to use the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">이름이 같은 로컬 변수가있는 경우 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; 함수&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="757725c834e63de261ff0fcf679ebe9f7da64387" translate="yes" xml:space="preserve">
          <source>In this example, runner is using &lt;strong&gt;max&lt;/strong&gt; from the file config. I want my test to change the value of &lt;strong&gt;max&lt;/strong&gt; when runner is using it.</source>
          <target state="translated">이 예제에서 러너는 파일 구성에서 &lt;strong&gt;max&lt;/strong&gt; 를 사용합니다. 러너가 사용할 때 테스트에서 &lt;strong&gt;max&lt;/strong&gt; 값을 변경하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="c2be3a39d7cd2238e86185235780e3d6bacd74bd" translate="yes" xml:space="preserve">
          <source>Local variables with the same name</source>
          <target state="translated">이름이 같은 지역 변수</target>
        </trans-unit>
        <trans-unit id="adb2902dbe58db2b1c4e635820ac254599998269" translate="yes" xml:space="preserve">
          <source>Modification of the global variable from inside a function</source>
          <target state="translated">함수 내부에서 전역 변수 수정</target>
        </trans-unit>
        <trans-unit id="f170cc8be722b1dc8f64cdb89f2437a052e0ddd3" translate="yes" xml:space="preserve">
          <source>Note that &quot;global&quot; in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.</source>
          <target state="translated">파이썬에서 &quot;글로벌&quot;은 진정한 글로벌이 아니며 모듈 수준에 대해서만 글로벌입니다. 따라서 전역적인 모듈로 작성된 기능에만 사용할 수 있습니다. 함수는 작성된 모듈을 기억하므로 다른 모듈로 내보낼 때 여전히 전역 변수를 찾기 위해 작성된 모듈을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8c71357e59c34f569330bbf42118d099786d64bd" translate="yes" xml:space="preserve">
          <source>Note that after writing this function, the code actually changing it has still not run:</source>
          <target state="translated">이 함수를 작성한 후에도 실제로 변경하는 코드는 여전히 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c89c18f4431fa00077e4850544b5784823792628" translate="yes" xml:space="preserve">
          <source>Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.</source>
          <target state="translated">정확히 무엇을하고 있는지 알지 못하는 경우를 제외하고는 전역 변수와 동일한 이름을 가진 지역 변수를 사용하지 마십시오. 나는 아직 그런 이유가 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4d759e506cc87fd94eb228708ebf8d3af992fed6" translate="yes" xml:space="preserve">
          <source>Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.</source>
          <target state="translated">파이썬은 간단한 휴리스틱을 사용하여 로컬과 글로벌 사이에서 변수를로드 해야하는 범위를 결정합니다. 변수 이름이 할당의 왼쪽에 나타나지만 전역으로 선언되지 않은 경우 로컬로 간주됩니다. 과제의 왼쪽에 표시되지 않으면 전체적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="82e7e92a83c2370747a78755bf7bd7f480cb211a" translate="yes" xml:space="preserve">
          <source>Reference the class namespace where you want the change to show up.</source>
          <target state="translated">변경 사항을 표시 할 클래스 네임 스페이스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d51825ca829838501c1e4d45114169b59541a7aa" translate="yes" xml:space="preserve">
          <source>Say you've got a module like this:</source>
          <target state="translated">다음과 같은 모듈이 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="32f1e2eebe50a1762d5277748745d8fbe01fdb6d" translate="yes" xml:space="preserve">
          <source>See how baz, which appears on the left side of an assignment in &lt;code&gt;foo()&lt;/code&gt;, is the only &lt;code&gt;LOAD_FAST&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 의 할당 왼쪽에 나타나는 baz가 유일한 &lt;code&gt;LOAD_FAST&lt;/code&gt; 변수 인 방법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b70c1e0a06b68daff9b694d823872ede25884d46" translate="yes" xml:space="preserve">
          <source>See other answers if you want to share a global variable across modules.</source>
          <target state="translated">모듈간에 전역 변수를 공유하려면 다른 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca4cb42a3ea049813c0ec667fbcdf3509dcd2e15" translate="yes" xml:space="preserve">
          <source>So after calling the function:</source>
          <target state="translated">따라서 함수를 호출 한 후 :</target>
        </trans-unit>
        <trans-unit id="841b2904cac2a4bc796bc658ba8ef34b26e05323" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;What are the rules for local and global variables in Python?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">출처 : &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;파이썬에서 지역 및 전역 변수에 대한 규칙은 무엇입니까?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="553e5e7d40b28c7793e577cda926afd288ff4db1" translate="yes" xml:space="preserve">
          <source>The canonical way to share information across modules within a single program is to create a special configuration module (often called &lt;strong&gt;config&lt;/strong&gt; or &lt;strong&gt;cfg&lt;/strong&gt;). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</source>
          <target state="translated">단일 프로그램 내에서 모듈간에 정보를 공유하는 일반적인 방법은 특수 구성 모듈 (종종 &lt;strong&gt;config&lt;/strong&gt; 또는 &lt;strong&gt;cfg&lt;/strong&gt; 라고 함)을 작성하는 것입니다. 응용 프로그램의 모든 모듈에서 구성 모듈을 가져 오기만하면됩니다. 그러면 모듈이 전역 이름으로 사용 가능해집니다. 각 모듈에는 하나의 인스턴스 만 있기 때문에 모듈 객체에 대한 변경 사항은 모든 곳에 반영됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="808008d2043d737b7ce2c0ff8be31b1727e98f20" translate="yes" xml:space="preserve">
          <source>This simple code works just like that, and it will execute. I hope it helps.</source>
          <target state="translated">이 간단한 코드는 그대로 작동하며 실행됩니다. 도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="a778fa74f0b4bfd3ce58b5f0f686aebc59db57b4" translate="yes" xml:space="preserve">
          <source>Though a bit surprising at first, a moment&amp;rsquo;s consideration explains
  this. On one hand, requiring global for assigned variables provides a
  bar against unintended side-effects. On the other hand, if global was
  required for all global references, you&amp;rsquo;d be using global all the
  time. You&amp;rsquo;d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</source>
          <target state="translated">처음에는 조금 놀랐지 만 잠시 생각해 보자. 한편으로, 할당 된 변수에 전역을 요구하면 의도하지 않은 부작용에 대비할 수 있습니다. 반면에 모든 전역 참조에 전역이 필요한 경우 항상 전역을 사용하게됩니다. 내장 함수 또는 가져온 모듈의 구성 요소에 대한 모든 참조를 전역으로 선언해야합니다. 이 혼란은 부작용을 식별하기위한 글로벌 선언의 유용성을 무너 뜨릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="400f17d44c6a3438a85b87775ed1333c75f30def" translate="yes" xml:space="preserve">
          <source>To point the global variable at a different object, you are required to use the global keyword again:</source>
          <target state="translated">전역 변수를 다른 객체를 가리 키려면 global 키워드를 다시 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">이 시도:</target>
        </trans-unit>
        <trans-unit id="32d247e27063921abab961801b76b443eb072388" translate="yes" xml:space="preserve">
          <source>Using global variables in a function</source>
          <target state="translated">함수에서 전역 변수 사용</target>
        </trans-unit>
        <trans-unit id="6a278e1e6dcb9a8315d8de0c331b9839a70f5f6f" translate="yes" xml:space="preserve">
          <source>Using globals without modification</source>
          <target state="translated">수정하지 않고 전역 사용</target>
        </trans-unit>
        <trans-unit id="1c8bbbb1a5b2ea68b84c72c7d588482b45639eee" translate="yes" xml:space="preserve">
          <source>We can create a global with the following function:</source>
          <target state="translated">다음 함수를 사용하여 전역을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56ca4d0f3967908061048393e2bfd872827e2dc2" translate="yes" xml:space="preserve">
          <source>We get the same behavior in classes</source>
          <target state="translated">우리는 수업에서 같은 행동을 얻습니다</target>
        </trans-unit>
        <trans-unit id="b4c19d3873d161e46c75ceec1be024497c5b2e3e" translate="yes" xml:space="preserve">
          <source>What you are saying is to use the method like this:</source>
          <target state="translated">당신이 말하는 것은 다음과 같은 방법을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcdf0bf377a132d036d9bbe6e09e1b12fb039c33" translate="yes" xml:space="preserve">
          <source>What's going on here is that Python assumes that any name that is &lt;em&gt;assigned to&lt;/em&gt;, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only &lt;em&gt;reading&lt;/em&gt; from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</source>
          <target state="translated">여기서 일어나고있는 것은 파이썬은 명시 적으로 달리 언급하지 않는 한 함수 내 어디서나에 &lt;em&gt;할당 된&lt;/em&gt; 이름이 해당 함수의 로컬 이름이라고 가정합니다. 이름 만 &lt;em&gt;읽고&lt;/em&gt; 있고 이름이 로컬에 존재하지 않으면 포함 범위 (예 : 모듈의 전역 범위)에서 이름을 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a3506340df03656042deb181b56e916a76306c18" translate="yes" xml:space="preserve">
          <source>When you assign 42 to the name &lt;code&gt;myGlobal&lt;/code&gt;, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;garbage-collected&lt;/a&gt; when &lt;code&gt;func1()&lt;/code&gt; returns; meanwhile, &lt;code&gt;func2()&lt;/code&gt; can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of &lt;code&gt;myGlobal&lt;/code&gt; inside &lt;code&gt;func1()&lt;/code&gt; before you assign to it, you'd get an &lt;code&gt;UnboundLocalError&lt;/code&gt;, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '&lt;code&gt;global&lt;/code&gt;' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</source>
          <target state="translated">따라서 &lt;code&gt;myGlobal&lt;/code&gt; 이라는 이름에 42를 할당하면 Python은 동일한 이름의 전역 변수를 가리는 지역 변수를 만듭니다. 해당 로컬은 범위를 벗어나 &lt;code&gt;func1()&lt;/code&gt; 반환 될 때 &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;가비지 수집&lt;/a&gt; 됩니다. 한편 &lt;code&gt;func2()&lt;/code&gt; 는 (수정되지 않은) 전역 이름 이외의 다른 것을 볼 수 없습니다. 이 네임 스페이스 결정은 런타임이 아닌 컴파일 타임에 발생합니다. &lt;code&gt;func1()&lt;/code&gt; 내에서 &lt;code&gt;myGlobal&lt;/code&gt; 값을 할당하기 전에 Python이 이미 결정해야하므로 &lt;code&gt;UnboundLocalError&lt;/code&gt; 가 발생합니다. 로컬 변수이지만 아직 연관된 값이 없습니다. 그러나 ' &lt;code&gt;global&lt;/code&gt; '문을 사용하면 Python에 로컬로 할당하는 대신 이름을 다른 곳에서 찾아야한다고 Python에 알립니다.</target>
        </trans-unit>
        <trans-unit id="946f5220d4c0ffd2002c5c5a98c6d48ae55240ed" translate="yes" xml:space="preserve">
          <source>Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only.</source>
          <target state="translated">전역 네임 스페이스에서 변수를 덤프 /로드 할 수 있습니다. 매우 편리하고, 무스, 소란이 없습니다. 파이썬 3 전용입니다.</target>
        </trans-unit>
        <trans-unit id="fe2ce5d5861f8377eecbb92498c26eb8c03d724d" translate="yes" xml:space="preserve">
          <source>With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:</source>
          <target state="translated">병렬 실행을 사용하면 발생하는 상황을 이해하지 못하면 전역 변수가 예기치 않은 결과를 초래할 수 있습니다. 다음은 다중 처리 내에서 전역 변수를 사용하는 예입니다. 각 프로세스가 고유 한 변수 사본으로 작동한다는 것을 분명히 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e1cac78dddcbd65775350f737c72e93d2d798f" translate="yes" xml:space="preserve">
          <source>Writing a function does not actually run its code. So we call the &lt;code&gt;create_global_variable&lt;/code&gt; function:</source>
          <target state="translated">함수 작성은 실제로 코드를 실행하지 않습니다. 따라서 &lt;code&gt;create_global_variable&lt;/code&gt; 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e03ad1c070e36b872b3333d095e7388731b22882" translate="yes" xml:space="preserve">
          <source>Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it &quot;wholesale&quot; does have that requirement:</source>
          <target state="translated">전역 배열의 명시 적 요소에 쓰려면 전역 선언이 필요하지 않지만 &quot;도매&quot;에 쓰려면 다음과 같은 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbecb723606740114452d22a28142d9af6613a55" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.</source>
          <target state="translated">전역 변수가 존재하는 경우이를 사용하거나 로컬 변수가없는 경우이를 작성하여 추측하려고하는 언어를 사용할 &lt;em&gt;수&lt;/em&gt; 있습니다. 그러나 오류가 발생하기 쉽습니다. 예를 들어, 다른 모듈을 가져 오면 실수로 해당 이름으로 전역 변수가 생겨 프로그램의 동작이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d42881afae3fc3861e64948e9774514253333db4" translate="yes" xml:space="preserve">
          <source>You can just use it, so long as you don't expect to change which object it points to:</source>
          <target state="translated">객체가 가리키는 객체를 변경하지 않으려는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5500ef73857d114d1c398cb4242333b1ef82771" translate="yes" xml:space="preserve">
          <source>You can use a global variable in other functions by declaring it as &lt;code&gt;global&lt;/code&gt; in each function that assigns to it:</source>
          <target state="translated">할당 된 각 함수에서 전역 변수를 선언하여 다른 함수에서 전역 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb853d6e0b691fc0b5ce5fb7fac2249a580747d1" translate="yes" xml:space="preserve">
          <source>You may want to explore the notion of &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;namespaces&lt;/a&gt;. In Python, the &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;module&lt;/a&gt; is the natural place for &lt;em&gt;global&lt;/em&gt; data:</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;네임 스페이스&lt;/a&gt; 개념을 탐색 할 수 있습니다. 파이썬에서이 &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;모듈&lt;/a&gt; 은 &lt;em&gt;글로벌&lt;/em&gt; 데이터를위한 자연스러운 장소입니다 :</target>
        </trans-unit>
        <trans-unit id="59950ecb7d047f5218b8fa8c0b131c6862e9cb6a" translate="yes" xml:space="preserve">
          <source>You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a '&lt;code&gt;global&lt;/code&gt;' declaration to &lt;code&gt;func1()&lt;/code&gt;, then &lt;code&gt;func2()&lt;/code&gt; will print 42.</source>
          <target state="translated">42를 인쇄 할 것으로 예상 할 수 있지만 대신 5를 인쇄합니다. 이미 언급했듯이 &lt;code&gt;func1()&lt;/code&gt; ' &lt;code&gt;global&lt;/code&gt; '선언을 추가하면 &lt;code&gt;func2()&lt;/code&gt; 가 42를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6f7e627d65ec53dbbbe98628a309293b7318508d" translate="yes" xml:space="preserve">
          <source>You need to reference the global variable in every function you want to use.</source>
          <target state="translated">사용하려는 모든 함수에서 전역 변수를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="20ae9a054da61b005011ec052d200d4d80ee4f67" translate="yes" xml:space="preserve">
          <source>You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.</source>
          <target state="translated">실제로 전역 변수를 로컬 변수에 저장하지 않고 원래 전역 참조가 참조하는 것과 동일한 객체에 대한 로컬 참조를 만듭니다. 파이썬의 거의 모든 것이 객체를 가리키는 이름이며 일반적인 작업에서 아무것도 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="fae82a086e49510dea6d0bfce87709497778fe3a" translate="yes" xml:space="preserve">
          <source>and now we can use the global variable:</source>
          <target state="translated">이제 전역 변수를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="451cb4f77137909fcb0b3a6aad84ab3e27589353" translate="yes" xml:space="preserve">
          <source>we can see that the global variable has been changed. The &lt;code&gt;global_variable&lt;/code&gt; name now points to &lt;code&gt;'Bar'&lt;/code&gt;:</source>
          <target state="translated">전역 변수가 변경되었음을 알 수 있습니다. &lt;code&gt;global_variable&lt;/code&gt; 이름은 이제 &lt;code&gt;'Bar'&lt;/code&gt; 를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4745a5736422bf254160a52d8206da60d719e401" translate="yes" xml:space="preserve">
          <source>what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class?</source>
          <target state="translated">클래스 내의 함수 내에 전역 변수를 만들고 다른 클래스 내의 다른 함수 내에서 해당 변수를 사용하려면 어떻게해야합니까?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
