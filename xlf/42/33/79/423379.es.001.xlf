<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/423379">
    <body>
      <group id="423379">
        <trans-unit id="3a29a28d4e300f6b9d5792eb7d5f29058935330c" translate="yes" xml:space="preserve">
          <source>(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</source>
          <target state="translated">(Creo que este comportamiento se originó en gran medida a través de una optimización de los espacios de nombres locales --sin este comportamiento,el VM de Python necesitaría realizar al menos tres búsquedas de nombres cada vez que se asigna un nuevo nombre dentro de una función (para asegurarse de que el nombre no existía ya a nivel de módulos),lo que ralentizaría significativamente una operación muy común).</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a48a084b773cbe5f5fb20cc6a9ca54adbc106d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/config.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/config.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf13aaa1958e161e4472d4ced8b48503adb7f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/runner.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/runner.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4f93d499dc80601179acd8f180b4012220ba4cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b3aabce7f8e6e2cd6cc1f730a4a92618cfe4c43" translate="yes" xml:space="preserve">
          <source>A follow on comment asks:</source>
          <target state="translated">Un comentario a continuación pregunta:</target>
        </trans-unit>
        <trans-unit id="831c1deafff39dc2e0e4c47676f7c7651ee65397" translate="yes" xml:space="preserve">
          <source>A specific use of global-in-a-module is described here - &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;How do I share global variables across modules?&lt;/a&gt;, and for completeness the contents are shared here:</source>
          <target state="translated">Aqu&amp;iacute; se describe un uso espec&amp;iacute;fico de global-in-a-module: &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;&amp;iquest;c&amp;oacute;mo comparto variables globales entre m&amp;oacute;dulos?&lt;/a&gt; , y para completar, los contenidos se comparten aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="382bf460fa9f0a13f62cf8265fd9b497087fbfdd" translate="yes" xml:space="preserve">
          <source>Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.</source>
          <target state="translated">Además,las variables globales son útiles,al contrario de lo que afirman algunos fanáticos de la OP que afirman lo contrario,especialmente en el caso de los guiones más pequeños,en los que la OP es exagerada.</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">Y ahora:</target>
        </trans-unit>
        <trans-unit id="ea8235608bc286dd475d407c66ae4bc1edc30400" translate="yes" xml:space="preserve">
          <source>As follows:</source>
          <target state="translated">Como sigue:</target>
        </trans-unit>
        <trans-unit id="b3f7a4454712d08571f98953114c6f37fade56b3" translate="yes" xml:space="preserve">
          <source>As it turns out the answer is always simple.</source>
          <target state="translated">Resulta que la respuesta es siempre simple.</target>
        </trans-unit>
        <trans-unit id="e68fb89042177a22f85fcb29baf649f07687ea4e" translate="yes" xml:space="preserve">
          <source>Both give the same output.</source>
          <target state="translated">Ambos dan la misma salida.</target>
        </trans-unit>
        <trans-unit id="d2a60791f237ebd0573c45e98b3bbe67a69974d9" translate="yes" xml:space="preserve">
          <source>But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use &lt;code&gt;self&lt;/code&gt; arguments here - these could be class methods (handy if mutating the class attribute from the usual &lt;code&gt;cls&lt;/code&gt; argument) or static methods (no &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;cls&lt;/code&gt;).</source>
          <target state="translated">Pero sugerir&amp;iacute;a que, en lugar de usar variables globales, use atributos de clase, para evitar saturar el espacio de nombres del m&amp;oacute;dulo. Tambi&amp;eacute;n tenga en cuenta que no usamos argumentos propios aqu&amp;iacute;; estos podr&amp;iacute;an ser m&amp;eacute;todos de clase (&amp;uacute;tiles si muta el atributo de clase del argumento &lt;code&gt;cls&lt;/code&gt; habitual) o m&amp;eacute;todos est&amp;aacute;ticos (no &lt;code&gt;self&lt;/code&gt; o &lt;code&gt;cls&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e52db3daf0213206b9bd29001eb49db2ead367f" translate="yes" xml:space="preserve">
          <source>But the better way is to use the global variable like this:</source>
          <target state="translated">Pero la mejor manera es usar la variable global de esta manera:</target>
        </trans-unit>
        <trans-unit id="bbf8d1399bcb14f026be806f4fa8af8f8f28b92e" translate="yes" xml:space="preserve">
          <source>But using that misnamed local variable does not change the global variable:</source>
          <target state="translated">Pero el uso de esa mal llamada variable local no cambia la variable global:</target>
        </trans-unit>
        <trans-unit id="21065925475664b639823498cf7afc05ae436197" translate="yes" xml:space="preserve">
          <source>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user&amp;rsquo;s global variables. On the other hand, if you know what you are doing you can touch a module&amp;rsquo;s global variables with the same notation used to refer to its functions, &lt;code&gt;modname.itemname&lt;/code&gt;.</source>
          <target state="translated">Cada m&amp;oacute;dulo tiene su propia tabla de s&amp;iacute;mbolos privada, que todas las funciones definidas en el m&amp;oacute;dulo utilizan como tabla de s&amp;iacute;mbolos global. Por lo tanto, el autor de un m&amp;oacute;dulo puede usar variables globales en el m&amp;oacute;dulo sin preocuparse por choques accidentales con las variables globales de un usuario. Por otro lado, si sabe lo que est&amp;aacute; haciendo, puede tocar las variables globales de un m&amp;oacute;dulo con la misma notaci&amp;oacute;n utilizada para referirse a sus funciones, &lt;code&gt;modname.itemname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d42c87f4a4cb2658756a338842b6e9caf5c4cb4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;getstocks.py&lt;/em&gt;:</source>
          <target state="translated">Archivo &lt;em&gt;getstocks.py&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="0dcfee04bdce5c9c94e649b611fb6a026a77a9e4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;initval.py&lt;/em&gt;:</source>
          <target state="translated">Archivo &lt;em&gt;initval.py&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="6dbcd6992db7e9840509e7cc35fa6c430c718e4e" translate="yes" xml:space="preserve">
          <source>File: config.py</source>
          <target state="translated">Archivo:config.py</target>
        </trans-unit>
        <trans-unit id="828c739880e40a2ca36ab9ef0843c428e9f7ab58" translate="yes" xml:space="preserve">
          <source>File: main.py</source>
          <target state="translated">Archivo:main.py</target>
        </trans-unit>
        <trans-unit id="dfb12898324c1f6fc1a0454806497d0482362334" translate="yes" xml:space="preserve">
          <source>File: mod.py</source>
          <target state="translated">Archivo:mod.py</target>
        </trans-unit>
        <trans-unit id="bcc361b07598fb63cbd8411db8e5b2d66c808872" translate="yes" xml:space="preserve">
          <source>Following on and as an add on, use a file to contain all global variables all declared locally and then &lt;code&gt;import as&lt;/code&gt;:</source>
          <target state="translated">Siguiendo y como complemento, use un archivo para contener todas las variables globales todas declaradas localmente y luego &lt;code&gt;import as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="d6230aa52a35650b976c27208c9b41c6c4638672" translate="yes" xml:space="preserve">
          <source>Here I demonstrate we get the same behavior in methods as we do in regular functions:</source>
          <target state="translated">Aquí demuestro que tenemos el mismo comportamiento en los métodos que en las funciones regulares:</target>
        </trans-unit>
        <trans-unit id="ff2ef371dbac72e4f6add26d0dc913ad7cc66a86" translate="yes" xml:space="preserve">
          <source>Here is a small sample module with a simple way to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">Aqu&amp;iacute; hay un peque&amp;ntilde;o m&amp;oacute;dulo de muestra con una forma simple de mostrarlo en una definici&amp;oacute;n &lt;code&gt;main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4642e3e366e141920eafccce38fba209dfc45ccc" translate="yes" xml:space="preserve">
          <source>Here is how to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; c&amp;oacute;mo mostrarlo en una definici&amp;oacute;n &lt;code&gt;main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8991da6e4670d4c723a1a153a470485b70325de7" translate="yes" xml:space="preserve">
          <source>How can I create or use a global variable in a function?</source>
          <target state="translated">¿Cómo puedo crear o utilizar una variable global en una función?</target>
        </trans-unit>
        <trans-unit id="95fdb4946a28aa2e7dfa96a14e1865723254e148" translate="yes" xml:space="preserve">
          <source>However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.</source>
          <target state="translated">Sin embargo,si se asigna a una nueva variable no declarada como global en la función,ésta se declara implícitamente como local,y puede eclipsar cualquier variable global existente con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="c1df67f2e32daa98e81e9c10062af50c8d22fc6e" translate="yes" xml:space="preserve">
          <source>I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the &lt;code&gt;global&lt;/code&gt; keyword.</source>
          <target state="translated">Me imagino que la raz&amp;oacute;n es que, dado que las variables globales son tan peligrosas, Python quiere asegurarse de que realmente sepas con qu&amp;eacute; est&amp;aacute;s jugando al requerir expl&amp;iacute;citamente la palabra clave &lt;code&gt;global&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd87132234042a627a085a0c1b2af889af0d848c" translate="yes" xml:space="preserve">
          <source>I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; function returns a mutable global symbol dictionary where you can &quot;magically&quot; make data available for the rest of your code. 
For example:</source>
          <target state="translated">Estoy agregando esto ya que no lo he visto en ninguna de las otras respuestas y podr&amp;iacute;a ser &amp;uacute;til para alguien que lucha con algo similar. La funci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; devuelve un diccionario de s&amp;iacute;mbolos global mutable donde puede &quot;m&amp;aacute;gicamente&quot; hacer que los datos est&amp;eacute;n disponibles para el resto de su c&amp;oacute;digo. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bf3ce99181155bb8d031a964f7e5313fc538f7e4" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that global variable in another function? Do I need to store the global variable in a local variable of the function which needs its access?</source>
          <target state="translated">Si creo una variable global en una función,¿cómo puedo usar esa variable global en otra función? ¿Necesito almacenar la variable global en una variable local de la función que necesita su acceso?</target>
        </trans-unit>
        <trans-unit id="8a16d826c7c600e6adddd1b1b0f6795ec79959f6" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that variable in another function?</source>
          <target state="translated">Si creo una variable global en una función,¿cómo puedo usar esa variable en otra función?</target>
        </trans-unit>
        <trans-unit id="b8028c2e61a77dee86ccb01aa52f7a1e7a2d959a" translate="yes" xml:space="preserve">
          <source>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</source>
          <target state="translated">Si entiendo correctamente su situación,lo que está viendo es el resultado de cómo Python maneja los espacios de nombres locales (función)y globales (módulo).</target>
        </trans-unit>
        <trans-unit id="a6c2c29d467201cc494122ecc52c43bd4f8cf0cc" translate="yes" xml:space="preserve">
          <source>If you create a local variable with the same name, it will overshadow a global variable:</source>
          <target state="translated">Si creas una variable local con el mismo nombre,eclipsará una variable global:</target>
        </trans-unit>
        <trans-unit id="526565a39b3a2f5141b90048b5bcd8783df3a491" translate="yes" xml:space="preserve">
          <source>If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases.</source>
          <target state="translated">Si no tuvieras que especificar explícitamente cuándo un identificador debe referirse a un global predefinido,entonces presumiblemente tendrías que especificar explícitamente cuándo un identificador es una nueva variable local en su lugar (por ejemplo,con algo como el comando 'var' visto en JavaScript).Dado que las variables locales son más comunes que las variables globales en cualquier sistema serio y no trivial,el sistema de Python tiene más sentido en la mayoría de los casos.</target>
        </trans-unit>
        <trans-unit id="b40ade2a2372e7d63caa7d05e130870fc99946cf" translate="yes" xml:space="preserve">
          <source>If you want to refer to a global variable in a function, you can use the &lt;strong&gt;global&lt;/strong&gt; keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.</source>
          <target state="translated">Si desea hacer referencia a una variable global en una funci&amp;oacute;n, puede usar la palabra clave &lt;strong&gt;global&lt;/strong&gt; para declarar qu&amp;eacute; variables son globales. No tiene que usarlo en todos los casos (como alguien aqu&amp;iacute; afirma incorrectamente): si el nombre al que se hace referencia en una expresi&amp;oacute;n no se puede encontrar en el &amp;aacute;mbito local o en los &amp;aacute;mbitos en las funciones en las que se define esta funci&amp;oacute;n, se busca entre variables</target>
        </trans-unit>
        <trans-unit id="753063fdb8ccba8abb2d018e4484738cdedc4ba0" translate="yes" xml:space="preserve">
          <source>In Python, variables that are only referenced inside a function are
  &lt;strong&gt;implicitly global&lt;/strong&gt;. If a variable is assigned a new value anywhere
  within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a &lt;strong&gt;local&lt;/strong&gt;. If a variable
  is ever assigned a new value inside the function, the variable is
  implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.</source>
          <target state="translated">En Python, las variables a las que solo se hace referencia dentro de una funci&amp;oacute;n son &lt;strong&gt;impl&amp;iacute;citamente globales&lt;/strong&gt; . Si a una variable se le asigna un nuevo valor en cualquier lugar dentro del cuerpo de la funci&amp;oacute;n, se supone que es un &lt;strong&gt;local&lt;/strong&gt; . Si a una variable se le asigna un nuevo valor dentro de la funci&amp;oacute;n, la variable es impl&amp;iacute;citamente local y debe declararla expl&amp;iacute;citamente como 'global'.</target>
        </trans-unit>
        <trans-unit id="ae253629bb7e76f3c2eb67c025d8cad8dfe4347f" translate="yes" xml:space="preserve">
          <source>In addition to already existing answers and to make this more confusing:</source>
          <target state="translated">Además de las respuestas ya existentes y para hacer esto más confuso:</target>
        </trans-unit>
        <trans-unit id="366c68bf24874b885d4c0b04c646aa27826522c9" translate="yes" xml:space="preserve">
          <source>In case you have a local variable with the same name, you might want to use the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">En caso de que tenga una variable local con el mismo nombre, es posible que desee utilizar la funci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="757725c834e63de261ff0fcf679ebe9f7da64387" translate="yes" xml:space="preserve">
          <source>In this example, runner is using &lt;strong&gt;max&lt;/strong&gt; from the file config. I want my test to change the value of &lt;strong&gt;max&lt;/strong&gt; when runner is using it.</source>
          <target state="translated">En este ejemplo, el corredor est&amp;aacute; usando &lt;strong&gt;max&lt;/strong&gt; de la configuraci&amp;oacute;n del archivo. Quiero que mi prueba cambie el valor de &lt;strong&gt;max&lt;/strong&gt; cuando el corredor la est&amp;eacute; usando.</target>
        </trans-unit>
        <trans-unit id="c2be3a39d7cd2238e86185235780e3d6bacd74bd" translate="yes" xml:space="preserve">
          <source>Local variables with the same name</source>
          <target state="translated">Las variables locales con el mismo nombre</target>
        </trans-unit>
        <trans-unit id="adb2902dbe58db2b1c4e635820ac254599998269" translate="yes" xml:space="preserve">
          <source>Modification of the global variable from inside a function</source>
          <target state="translated">Modificación de la variable global desde el interior de una función</target>
        </trans-unit>
        <trans-unit id="f170cc8be722b1dc8f64cdb89f2437a052e0ddd3" translate="yes" xml:space="preserve">
          <source>Note that &quot;global&quot; in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.</source>
          <target state="translated">Tengan en cuenta que &quot;global&quot; en Python no es realmente global,sólo es global a nivel de módulo.Así que sólo está disponible para las funciones escritas en los módulos en los que es global.Las funciones recuerdan el módulo en el que están escritas,por lo que cuando se exportan a otros módulos,siguen buscando en el módulo en el que fueron creadas para encontrar variables globales.</target>
        </trans-unit>
        <trans-unit id="8c71357e59c34f569330bbf42118d099786d64bd" translate="yes" xml:space="preserve">
          <source>Note that after writing this function, the code actually changing it has still not run:</source>
          <target state="translated">Note que después de escribir esta función,el código que realmente la cambia aún no se ha ejecutado:</target>
        </trans-unit>
        <trans-unit id="c89c18f4431fa00077e4850544b5784823792628" translate="yes" xml:space="preserve">
          <source>Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.</source>
          <target state="translated">Tenga en cuenta que debe evitar utilizar las variables locales con los mismos nombres que las globales a menos que sepa con precisión lo que está haciendo y tenga una muy buena razón para hacerlo.Aún no he encontrado tal razón.</target>
        </trans-unit>
        <trans-unit id="4d759e506cc87fd94eb228708ebf8d3af992fed6" translate="yes" xml:space="preserve">
          <source>Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.</source>
          <target state="translated">Python utiliza una simple heurística para decidir de qué ámbito debe cargar una variable,entre local y global.Si el nombre de una variable aparece a la izquierda de una asignación,pero no se declara global,se supone que es local.Si no aparece a la izquierda de una asignación,se supone que es global.</target>
        </trans-unit>
        <trans-unit id="82e7e92a83c2370747a78755bf7bd7f480cb211a" translate="yes" xml:space="preserve">
          <source>Reference the class namespace where you want the change to show up.</source>
          <target state="translated">Consulta el espacio de nombres de la clase en el que quieres que aparezca el cambio.</target>
        </trans-unit>
        <trans-unit id="d51825ca829838501c1e4d45114169b59541a7aa" translate="yes" xml:space="preserve">
          <source>Say you've got a module like this:</source>
          <target state="translated">Digamos que tienes un módulo como este:</target>
        </trans-unit>
        <trans-unit id="32f1e2eebe50a1762d5277748745d8fbe01fdb6d" translate="yes" xml:space="preserve">
          <source>See how baz, which appears on the left side of an assignment in &lt;code&gt;foo()&lt;/code&gt;, is the only &lt;code&gt;LOAD_FAST&lt;/code&gt; variable.</source>
          <target state="translated">Vea c&amp;oacute;mo baz, que aparece en el lado izquierdo de una asignaci&amp;oacute;n en &lt;code&gt;foo()&lt;/code&gt; , es la &amp;uacute;nica variable &lt;code&gt;LOAD_FAST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b70c1e0a06b68daff9b694d823872ede25884d46" translate="yes" xml:space="preserve">
          <source>See other answers if you want to share a global variable across modules.</source>
          <target state="translated">Vea otras respuestas si quiere compartir una variable global a través de los módulos.</target>
        </trans-unit>
        <trans-unit id="ca4cb42a3ea049813c0ec667fbcdf3509dcd2e15" translate="yes" xml:space="preserve">
          <source>So after calling the function:</source>
          <target state="translated">Así que después de llamar a la función:</target>
        </trans-unit>
        <trans-unit id="841b2904cac2a4bc796bc658ba8ef34b26e05323" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;What are the rules for local and global variables in Python?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Fuente: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;&amp;iquest;Cu&amp;aacute;les son las reglas para las variables locales y globales en Python?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="553e5e7d40b28c7793e577cda926afd288ff4db1" translate="yes" xml:space="preserve">
          <source>The canonical way to share information across modules within a single program is to create a special configuration module (often called &lt;strong&gt;config&lt;/strong&gt; or &lt;strong&gt;cfg&lt;/strong&gt;). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</source>
          <target state="translated">La forma can&amp;oacute;nica de compartir informaci&amp;oacute;n entre los m&amp;oacute;dulos dentro de un solo programa es crear un m&amp;oacute;dulo de configuraci&amp;oacute;n especial (a menudo llamado &lt;strong&gt;config&lt;/strong&gt; o &lt;strong&gt;cfg&lt;/strong&gt; ). Simplemente importe el m&amp;oacute;dulo de configuraci&amp;oacute;n en todos los m&amp;oacute;dulos de su aplicaci&amp;oacute;n; el m&amp;oacute;dulo estar&amp;aacute; disponible como nombre global. Como solo hay una instancia de cada m&amp;oacute;dulo, los cambios realizados en el objeto del m&amp;oacute;dulo se reflejan en todas partes. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="808008d2043d737b7ce2c0ff8be31b1727e98f20" translate="yes" xml:space="preserve">
          <source>This simple code works just like that, and it will execute. I hope it helps.</source>
          <target state="translated">Este simple código funciona así,y se ejecutará.Espero que ayude.</target>
        </trans-unit>
        <trans-unit id="a778fa74f0b4bfd3ce58b5f0f686aebc59db57b4" translate="yes" xml:space="preserve">
          <source>Though a bit surprising at first, a moment&amp;rsquo;s consideration explains
  this. On one hand, requiring global for assigned variables provides a
  bar against unintended side-effects. On the other hand, if global was
  required for all global references, you&amp;rsquo;d be using global all the
  time. You&amp;rsquo;d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</source>
          <target state="translated">Aunque un poco sorprendente al principio, un momento de consideraci&amp;oacute;n lo explica. Por un lado, requerir global para las variables asignadas proporciona una barra contra los efectos secundarios no deseados. Por otro lado, si se requiriera global para todas las referencias globales, estar&amp;iacute;a usando global todo el tiempo. Tendr&amp;iacute;a que declarar como global cada referencia a una funci&amp;oacute;n integrada o a un componente de un m&amp;oacute;dulo importado. Este desorden derrotar&amp;iacute;a la utilidad de la declaraci&amp;oacute;n global para identificar los efectos secundarios.</target>
        </trans-unit>
        <trans-unit id="400f17d44c6a3438a85b87775ed1333c75f30def" translate="yes" xml:space="preserve">
          <source>To point the global variable at a different object, you are required to use the global keyword again:</source>
          <target state="translated">Para apuntar la variable global a un objeto diferente,se requiere usar la palabra clave global de nuevo:</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">Pruebe esto:</target>
        </trans-unit>
        <trans-unit id="32d247e27063921abab961801b76b443eb072388" translate="yes" xml:space="preserve">
          <source>Using global variables in a function</source>
          <target state="translated">Usando variables globales en una función</target>
        </trans-unit>
        <trans-unit id="6a278e1e6dcb9a8315d8de0c331b9839a70f5f6f" translate="yes" xml:space="preserve">
          <source>Using globals without modification</source>
          <target state="translated">Uso de los globos sin modificación</target>
        </trans-unit>
        <trans-unit id="1c8bbbb1a5b2ea68b84c72c7d588482b45639eee" translate="yes" xml:space="preserve">
          <source>We can create a global with the following function:</source>
          <target state="translated">Podemos crear un global con la siguiente función:</target>
        </trans-unit>
        <trans-unit id="56ca4d0f3967908061048393e2bfd872827e2dc2" translate="yes" xml:space="preserve">
          <source>We get the same behavior in classes</source>
          <target state="translated">Tenemos el mismo comportamiento en las clases</target>
        </trans-unit>
        <trans-unit id="b4c19d3873d161e46c75ceec1be024497c5b2e3e" translate="yes" xml:space="preserve">
          <source>What you are saying is to use the method like this:</source>
          <target state="translated">Lo que está diciendo es que use el método de esta manera:</target>
        </trans-unit>
        <trans-unit id="fcdf0bf377a132d036d9bbe6e09e1b12fb039c33" translate="yes" xml:space="preserve">
          <source>What's going on here is that Python assumes that any name that is &lt;em&gt;assigned to&lt;/em&gt;, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only &lt;em&gt;reading&lt;/em&gt; from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</source>
          <target state="translated">Lo que est&amp;aacute; sucediendo aqu&amp;iacute; es que Python asume que cualquier nombre &lt;em&gt;asignado a&lt;/em&gt; , en cualquier lugar dentro de una funci&amp;oacute;n, es local a esa funci&amp;oacute;n a menos que se indique expl&amp;iacute;citamente lo contrario. Si solo est&amp;aacute; &lt;em&gt;leyendo&lt;/em&gt; un nombre, y el nombre no existe localmente, intentar&amp;aacute; buscar el nombre en cualquier &amp;aacute;mbito que contenga (por ejemplo, el alcance global del m&amp;oacute;dulo).</target>
        </trans-unit>
        <trans-unit id="a3506340df03656042deb181b56e916a76306c18" translate="yes" xml:space="preserve">
          <source>When you assign 42 to the name &lt;code&gt;myGlobal&lt;/code&gt;, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;garbage-collected&lt;/a&gt; when &lt;code&gt;func1()&lt;/code&gt; returns; meanwhile, &lt;code&gt;func2()&lt;/code&gt; can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of &lt;code&gt;myGlobal&lt;/code&gt; inside &lt;code&gt;func1()&lt;/code&gt; before you assign to it, you'd get an &lt;code&gt;UnboundLocalError&lt;/code&gt;, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '&lt;code&gt;global&lt;/code&gt;' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</source>
          <target state="translated">Cuando asigna 42 al nombre &lt;code&gt;myGlobal&lt;/code&gt; , por lo tanto, Python crea una variable local que sombrea la variable global del mismo nombre. Ese local queda fuera de alcance y se &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;recolecta&lt;/a&gt; cuando se &lt;code&gt;func1()&lt;/code&gt; ; Mientras tanto, &lt;code&gt;func2()&lt;/code&gt; nunca puede ver otra cosa que no sea el nombre global (sin modificar). Tenga en cuenta que esta decisi&amp;oacute;n de espacio de nombres ocurre en el momento de la compilaci&amp;oacute;n, no en tiempo de ejecuci&amp;oacute;n: si tuviera que leer el valor de &lt;code&gt;myGlobal&lt;/code&gt; dentro de &lt;code&gt;func1()&lt;/code&gt; antes de asignarlo, obtendr&amp;iacute;a un &lt;code&gt;UnboundLocalError&lt;/code&gt; , porque Python ya ha decidido que debe ser una variable local pero a&amp;uacute;n no ha tenido ning&amp;uacute;n valor asociado. Pero al usar la declaraci&amp;oacute;n ' &lt;code&gt;global&lt;/code&gt; ', le dice a Python que debe buscar el nombre en otro lugar en lugar de asignarlo localmente.</target>
        </trans-unit>
        <trans-unit id="946f5220d4c0ffd2002c5c5a98c6d48ae55240ed" translate="yes" xml:space="preserve">
          <source>Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only.</source>
          <target state="translated">te permitirá descargar variables fuera y dentro del espacio global de nombres.Súper conveniente,sin desorden,sin alboroto.Estoy seguro de que sólo es Python 3.</target>
        </trans-unit>
        <trans-unit id="fe2ce5d5861f8377eecbb92498c26eb8c03d724d" translate="yes" xml:space="preserve">
          <source>With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:</source>
          <target state="translated">Con la ejecución paralela,las variables globales pueden causar resultados inesperados si no se entiende lo que está sucediendo.Aquí hay un ejemplo de cómo usar una variable global dentro del multiprocesamiento.Podemos ver claramente que cada proceso trabaja con su propia copia de la variable:</target>
        </trans-unit>
        <trans-unit id="54e1cac78dddcbd65775350f737c72e93d2d798f" translate="yes" xml:space="preserve">
          <source>Writing a function does not actually run its code. So we call the &lt;code&gt;create_global_variable&lt;/code&gt; function:</source>
          <target state="translated">Escribir una funci&amp;oacute;n en realidad no ejecuta su c&amp;oacute;digo. Entonces llamamos a la funci&amp;oacute;n &lt;code&gt;create_global_variable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e03ad1c070e36b872b3333d095e7388731b22882" translate="yes" xml:space="preserve">
          <source>Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it &quot;wholesale&quot; does have that requirement:</source>
          <target state="translated">Escribir a elementos explícitos de un conjunto global no parece necesitar la declaración global,aunque escribirle &quot;al por mayor&quot; sí tiene ese requisito:</target>
        </trans-unit>
        <trans-unit id="cbecb723606740114452d22a28142d9af6613a55" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.</source>
          <target state="translated">&lt;em&gt;Podr&amp;iacute;a&lt;/em&gt; tener un lenguaje que intentara adivinar, utilizando una variable global si exist&amp;iacute;a o creando una variable local si no existiera. Sin embargo, eso ser&amp;iacute;a muy propenso a errores. Por ejemplo, importar otro m&amp;oacute;dulo podr&amp;iacute;a introducir inadvertidamente una variable global con ese nombre, cambiando el comportamiento de su programa.</target>
        </trans-unit>
        <trans-unit id="d42881afae3fc3861e64948e9774514253333db4" translate="yes" xml:space="preserve">
          <source>You can just use it, so long as you don't expect to change which object it points to:</source>
          <target state="translated">Puedes usarlo,siempre y cuando no esperes cambiar el objeto al que apunta:</target>
        </trans-unit>
        <trans-unit id="b5500ef73857d114d1c398cb4242333b1ef82771" translate="yes" xml:space="preserve">
          <source>You can use a global variable in other functions by declaring it as &lt;code&gt;global&lt;/code&gt; in each function that assigns to it:</source>
          <target state="translated">Puede usar una variable global en otras funciones declar&amp;aacute;ndola como &lt;code&gt;global&lt;/code&gt; en cada funci&amp;oacute;n que le asigne:</target>
        </trans-unit>
        <trans-unit id="bb853d6e0b691fc0b5ce5fb7fac2249a580747d1" translate="yes" xml:space="preserve">
          <source>You may want to explore the notion of &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;namespaces&lt;/a&gt;. In Python, the &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;module&lt;/a&gt; is the natural place for &lt;em&gt;global&lt;/em&gt; data:</source>
          <target state="translated">Es posible que desee explorar la noci&amp;oacute;n de &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;espacios&lt;/a&gt; de nombres . En Python, el &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; es el lugar natural para &lt;em&gt;los&lt;/em&gt; datos &lt;em&gt;globales&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="59950ecb7d047f5218b8fa8c0b131c6862e9cb6a" translate="yes" xml:space="preserve">
          <source>You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a '&lt;code&gt;global&lt;/code&gt;' declaration to &lt;code&gt;func1()&lt;/code&gt;, then &lt;code&gt;func2()&lt;/code&gt; will print 42.</source>
          <target state="translated">Es posible que espere que esto imprima 42, pero en su lugar imprime 5. Como ya se mencion&amp;oacute;, si agrega una declaraci&amp;oacute;n ' &lt;code&gt;global&lt;/code&gt; ' a &lt;code&gt;func1()&lt;/code&gt; , entonces &lt;code&gt;func2()&lt;/code&gt; imprimir&amp;aacute; 42.</target>
        </trans-unit>
        <trans-unit id="6f7e627d65ec53dbbbe98628a309293b7318508d" translate="yes" xml:space="preserve">
          <source>You need to reference the global variable in every function you want to use.</source>
          <target state="translated">Necesitas referirte a la variable global en cada función que quieras usar.</target>
        </trans-unit>
        <trans-unit id="20ae9a054da61b005011ec052d200d4d80ee4f67" translate="yes" xml:space="preserve">
          <source>You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.</source>
          <target state="translated">En realidad no estás almacenando el global en una variable local,sólo creando una referencia local al mismo objeto al que se refiere tu referencia global original.Recuerda que casi todo en Python es un nombre que se refiere a un objeto,y nada se copia en el funcionamiento habitual.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="fae82a086e49510dea6d0bfce87709497778fe3a" translate="yes" xml:space="preserve">
          <source>and now we can use the global variable:</source>
          <target state="translated">y ahora podemos usar la variable global:</target>
        </trans-unit>
        <trans-unit id="451cb4f77137909fcb0b3a6aad84ab3e27589353" translate="yes" xml:space="preserve">
          <source>we can see that the global variable has been changed. The &lt;code&gt;global_variable&lt;/code&gt; name now points to &lt;code&gt;'Bar'&lt;/code&gt;:</source>
          <target state="translated">Podemos ver que la variable global ha cambiado. El nombre &lt;code&gt;global_variable&lt;/code&gt; ahora apunta a &lt;code&gt;'Bar'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4745a5736422bf254160a52d8206da60d719e401" translate="yes" xml:space="preserve">
          <source>what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class?</source>
          <target state="translated">¿qué hacer si quiero crear una variable global dentro de una función dentro de una clase y quiero usar esa variable dentro de otra función dentro de otra clase?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
