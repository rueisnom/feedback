<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/423379">
    <body>
      <group id="423379">
        <trans-unit id="3a29a28d4e300f6b9d5792eb7d5f29058935330c" translate="yes" xml:space="preserve">
          <source>(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</source>
          <target state="translated">(私は、この動作は主にローカルの名前空間の最適化に由来すると考えています。この動作がなければ、PythonのVMは、関数内で新しい名前が割り当てられるたびに、少なくとも3つの名前の検索を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a48a084b773cbe5f5fb20cc6a9ca54adbc106d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/config.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/config.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf13aaa1958e161e4472d4ced8b48503adb7f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/runner.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/runner.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4f93d499dc80601179acd8f180b4012220ba4cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b3aabce7f8e6e2cd6cc1f730a4a92618cfe4c43" translate="yes" xml:space="preserve">
          <source>A follow on comment asks:</source>
          <target state="translated">フォローするコメントが問いかける。</target>
        </trans-unit>
        <trans-unit id="831c1deafff39dc2e0e4c47676f7c7651ee65397" translate="yes" xml:space="preserve">
          <source>A specific use of global-in-a-module is described here - &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;How do I share global variables across modules?&lt;/a&gt;, and for completeness the contents are shared here:</source>
          <target state="translated">モジュール内のグローバルの特定の使用法をここで説明します- &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;モジュール間でグローバル変数を共有するにはどうすればよいですか？&lt;/a&gt; 、そして完全を期すために、内容はここで共有されます：</target>
        </trans-unit>
        <trans-unit id="382bf460fa9f0a13f62cf8265fd9b497087fbfdd" translate="yes" xml:space="preserve">
          <source>Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.</source>
          <target state="translated">また、グローバル変数は有用ですが、そうでないと主張する一部のOOP狂信者に反して、特に小さなスクリプトではOOPがやりすぎだと言われています。</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">そして今。</target>
        </trans-unit>
        <trans-unit id="ea8235608bc286dd475d407c66ae4bc1edc30400" translate="yes" xml:space="preserve">
          <source>As follows:</source>
          <target state="translated">以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b3f7a4454712d08571f98953114c6f37fade56b3" translate="yes" xml:space="preserve">
          <source>As it turns out the answer is always simple.</source>
          <target state="translated">それが判明したように、答えは常に単純です。</target>
        </trans-unit>
        <trans-unit id="e68fb89042177a22f85fcb29baf649f07687ea4e" translate="yes" xml:space="preserve">
          <source>Both give the same output.</source>
          <target state="translated">どちらも同じ出力が得られます。</target>
        </trans-unit>
        <trans-unit id="d2a60791f237ebd0573c45e98b3bbe67a69974d9" translate="yes" xml:space="preserve">
          <source>But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use &lt;code&gt;self&lt;/code&gt; arguments here - these could be class methods (handy if mutating the class attribute from the usual &lt;code&gt;cls&lt;/code&gt; argument) or static methods (no &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;cls&lt;/code&gt;).</source>
          <target state="translated">ただし、モジュールの名前空間が混乱しないように、グローバル変数を使用する代わりにクラス属性を使用することをお勧めします。 また、ここでは &lt;code&gt;self&lt;/code&gt; 引数を使用しないことに注意してください。これらはクラスメソッド（通常の &lt;code&gt;cls&lt;/code&gt; 引数からクラス属性を変更する場合に便利）または静的メソッド（ &lt;code&gt;self&lt;/code&gt; または &lt;code&gt;cls&lt;/code&gt; なし ）である可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e52db3daf0213206b9bd29001eb49db2ead367f" translate="yes" xml:space="preserve">
          <source>But the better way is to use the global variable like this:</source>
          <target state="translated">しかし、より良い方法は、このようにグローバル変数を使用することです。</target>
        </trans-unit>
        <trans-unit id="bbf8d1399bcb14f026be806f4fa8af8f8f28b92e" translate="yes" xml:space="preserve">
          <source>But using that misnamed local variable does not change the global variable:</source>
          <target state="translated">しかし、その誤った名前のローカル変数を使っても、グローバル変数は変わりません。</target>
        </trans-unit>
        <trans-unit id="21065925475664b639823498cf7afc05ae436197" translate="yes" xml:space="preserve">
          <source>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user&amp;rsquo;s global variables. On the other hand, if you know what you are doing you can touch a module&amp;rsquo;s global variables with the same notation used to refer to its functions, &lt;code&gt;modname.itemname&lt;/code&gt;.</source>
          <target state="translated">各モジュールには独自のプライベートシンボルテーブルがあり、モジュールで定義されたすべての関数によってグローバルシンボルテーブルとして使用されます。 したがって、モジュールの作成者は、ユーザーのグローバル変数との偶発的な衝突を心配することなく、モジュール内のグローバル変数を使用できます。 一方、何をしているのかわかっている場合は、モジュールのグローバル変数を、その関数を参照するために使用するのと同じ表記法 &lt;code&gt;modname.itemname&lt;/code&gt; で操作できます。</target>
        </trans-unit>
        <trans-unit id="6d42c87f4a4cb2658756a338842b6e9caf5c4cb4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;getstocks.py&lt;/em&gt;:</source>
          <target state="translated">ファイル&lt;em&gt;getstocks.py&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="0dcfee04bdce5c9c94e649b611fb6a026a77a9e4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;initval.py&lt;/em&gt;:</source>
          <target state="translated">ファイル&lt;em&gt;initval.py&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="6dbcd6992db7e9840509e7cc35fa6c430c718e4e" translate="yes" xml:space="preserve">
          <source>File: config.py</source>
          <target state="translated">ファイル:config.py</target>
        </trans-unit>
        <trans-unit id="828c739880e40a2ca36ab9ef0843c428e9f7ab58" translate="yes" xml:space="preserve">
          <source>File: main.py</source>
          <target state="translated">ファイル:main.py</target>
        </trans-unit>
        <trans-unit id="dfb12898324c1f6fc1a0454806497d0482362334" translate="yes" xml:space="preserve">
          <source>File: mod.py</source>
          <target state="translated">ファイル:mod.py</target>
        </trans-unit>
        <trans-unit id="bcc361b07598fb63cbd8411db8e5b2d66c808872" translate="yes" xml:space="preserve">
          <source>Following on and as an add on, use a file to contain all global variables all declared locally and then &lt;code&gt;import as&lt;/code&gt;:</source>
          <target state="translated">続いて、アドオンとして、ファイルを使用して、すべてローカルで宣言されたすべてのグローバル変数を含め、次のように &lt;code&gt;import as&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="d6230aa52a35650b976c27208c9b41c6c4638672" translate="yes" xml:space="preserve">
          <source>Here I demonstrate we get the same behavior in methods as we do in regular functions:</source>
          <target state="translated">ここでは、メソッドでも正規関数と同じ動作が得られることを示します。</target>
        </trans-unit>
        <trans-unit id="ff2ef371dbac72e4f6add26d0dc913ad7cc66a86" translate="yes" xml:space="preserve">
          <source>Here is a small sample module with a simple way to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 定義でそれを示す簡単な方法を持つ小さなサンプルモジュールを次に示します。</target>
        </trans-unit>
        <trans-unit id="4642e3e366e141920eafccce38fba209dfc45ccc" translate="yes" xml:space="preserve">
          <source>Here is how to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">これを &lt;code&gt;main&lt;/code&gt; 定義で表示する方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8991da6e4670d4c723a1a153a470485b70325de7" translate="yes" xml:space="preserve">
          <source>How can I create or use a global variable in a function?</source>
          <target state="translated">関数内でグローバル変数を作成したり、使用したりするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="95fdb4946a28aa2e7dfa96a14e1865723254e148" translate="yes" xml:space="preserve">
          <source>However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.</source>
          <target state="translated">しかし、関数内でグローバルとして宣言されていない新しい変数に代入すると、暗黙のうちにローカルとして宣言され、同じ名前の既存のグローバル変数を上書きしてしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="c1df67f2e32daa98e81e9c10062af50c8d22fc6e" translate="yes" xml:space="preserve">
          <source>I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the &lt;code&gt;global&lt;/code&gt; keyword.</source>
          <target state="translated">その理由は、グローバル変数は非常に危険であるため、Pythonが &lt;code&gt;global&lt;/code&gt; キーワードを明示的に要求することによって、それが実際に操作していることを確実に確認したいためだと思います。</target>
        </trans-unit>
        <trans-unit id="dd87132234042a627a085a0c1b2af889af0d848c" translate="yes" xml:space="preserve">
          <source>I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; function returns a mutable global symbol dictionary where you can &quot;magically&quot; make data available for the rest of your code. 
For example:</source>
          <target state="translated">他のどの回答でも見たことがないので、これを追加します。似たような問題に苦しんでいる人には役立つかもしれません。 &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt;関数は、変更可能なグローバルシンボルディクショナリを返します。これにより、残りのコードでデータを「魔法のように」使用できるようになります。 例えば：</target>
        </trans-unit>
        <trans-unit id="bf3ce99181155bb8d031a964f7e5313fc538f7e4" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that global variable in another function? Do I need to store the global variable in a local variable of the function which needs its access?</source>
          <target state="translated">ある関数でグローバル変数を作成した場合、そのグローバル変数を別の関数で使用するにはどうすればいいですか?グローバル変数を、そのアクセスを必要とする関数のローカル変数に格納する必要がありますか?</target>
        </trans-unit>
        <trans-unit id="8a16d826c7c600e6adddd1b1b0f6795ec79959f6" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that variable in another function?</source>
          <target state="translated">ある関数でグローバル変数を作成した場合、その変数を別の関数で使用するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="b8028c2e61a77dee86ccb01aa52f7a1e7a2d959a" translate="yes" xml:space="preserve">
          <source>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</source>
          <target state="translated">私があなたの状況を正しく理解しているなら、あなたが見ているものは、Pythonがローカル(関数)とグローバル(モジュール)の名前空間をどのように扱うかの結果です。</target>
        </trans-unit>
        <trans-unit id="a6c2c29d467201cc494122ecc52c43bd4f8cf0cc" translate="yes" xml:space="preserve">
          <source>If you create a local variable with the same name, it will overshadow a global variable:</source>
          <target state="translated">同じ名前のローカル変数を作成した場合、グローバル変数に上書きされてしまいます。</target>
        </trans-unit>
        <trans-unit id="526565a39b3a2f5141b90048b5bcd8783df3a491" translate="yes" xml:space="preserve">
          <source>If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases.</source>
          <target state="translated">識別子が定義済みのグローバルを参照するときに明示的に指定する必要がないのであれば、識別子が新しいローカル変数を参照するときに明示的に指定する必要があるでしょう(例えば、JavaScriptで見られる'var'コマンドのようなもの)。ローカル変数はグローバル変数よりも一般的なものなので、ほとんどの場合、Pythonのシステムはより意味のあるものになります。</target>
        </trans-unit>
        <trans-unit id="b40ade2a2372e7d63caa7d05e130870fc99946cf" translate="yes" xml:space="preserve">
          <source>If you want to refer to a global variable in a function, you can use the &lt;strong&gt;global&lt;/strong&gt; keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.</source>
          <target state="translated">関数でグローバル変数を参照する場合は、 &lt;strong&gt;global&lt;/strong&gt;キーワードを使用して、どの変数がグローバルであるかを宣言できます。 すべてのケースでこれを使用する必要はありません（誰かがここで誤って主張しているように）-式で参照されている名前がローカルスコープまたはこの関数が定義されている関数のスコープで見つからない場合、グローバルから検索されます変数。</target>
        </trans-unit>
        <trans-unit id="753063fdb8ccba8abb2d018e4484738cdedc4ba0" translate="yes" xml:space="preserve">
          <source>In Python, variables that are only referenced inside a function are
  &lt;strong&gt;implicitly global&lt;/strong&gt;. If a variable is assigned a new value anywhere
  within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a &lt;strong&gt;local&lt;/strong&gt;. If a variable
  is ever assigned a new value inside the function, the variable is
  implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.</source>
          <target state="translated">Pythonでは、関数内でのみ参照される変数は&lt;strong&gt;暗黙的にグローバル&lt;/strong&gt;です。 変数に関数の本体内のどこかに新しい値が割り当てられている場合、その変数は&lt;strong&gt;ローカルである&lt;/strong&gt;と見なされます。 変数に関数内で新しい値が割り当てられる場合、変数は暗黙的にローカルであり、明示的に「グローバル」として宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae253629bb7e76f3c2eb67c025d8cad8dfe4347f" translate="yes" xml:space="preserve">
          <source>In addition to already existing answers and to make this more confusing:</source>
          <target state="translated">既にある回答に加えて、これをより分かりやすくするために</target>
        </trans-unit>
        <trans-unit id="366c68bf24874b885d4c0b04c646aa27826522c9" translate="yes" xml:space="preserve">
          <source>In case you have a local variable with the same name, you might want to use the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">同じ名前のローカル変数がある場合は、 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; 関数&lt;/a&gt;を使用できます 。</target>
        </trans-unit>
        <trans-unit id="757725c834e63de261ff0fcf679ebe9f7da64387" translate="yes" xml:space="preserve">
          <source>In this example, runner is using &lt;strong&gt;max&lt;/strong&gt; from the file config. I want my test to change the value of &lt;strong&gt;max&lt;/strong&gt; when runner is using it.</source>
          <target state="translated">この例では、ランナーはファイル構成の&lt;strong&gt;max&lt;/strong&gt;を使用しています。 ランナーが使用しているときにテストで&lt;strong&gt;max&lt;/strong&gt;の値を変更したい。</target>
        </trans-unit>
        <trans-unit id="c2be3a39d7cd2238e86185235780e3d6bacd74bd" translate="yes" xml:space="preserve">
          <source>Local variables with the same name</source>
          <target state="translated">同じ名前のローカル変数</target>
        </trans-unit>
        <trans-unit id="adb2902dbe58db2b1c4e635820ac254599998269" translate="yes" xml:space="preserve">
          <source>Modification of the global variable from inside a function</source>
          <target state="translated">関数内部からのグローバル変数の変更</target>
        </trans-unit>
        <trans-unit id="f170cc8be722b1dc8f64cdb89f2437a052e0ddd3" translate="yes" xml:space="preserve">
          <source>Note that &quot;global&quot; in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.</source>
          <target state="translated">Pythonの &quot;グローバル &quot;は本当の意味でのグローバルではなく、モジュールレベルでのグローバルであることに注意してください。つまり、グローバル化されているモジュールで書かれた関数だけが利用可能なのです。関数は書かれたモジュールを記憶しているので、他のモジュールにエクスポートされても、グローバル変数を探すために作成されたモジュールを探します。</target>
        </trans-unit>
        <trans-unit id="8c71357e59c34f569330bbf42118d099786d64bd" translate="yes" xml:space="preserve">
          <source>Note that after writing this function, the code actually changing it has still not run:</source>
          <target state="translated">この関数を書いた後、実際に変更するコードはまだ実行されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c89c18f4431fa00077e4850544b5784823792628" translate="yes" xml:space="preserve">
          <source>Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.</source>
          <target state="translated">何をしているのかを正確に把握していて、それを行う非常に正当な理由がない限り、ローカル変数をグローバルと同じ名前で使用することは避けるべきであることに注意してください。私はまだそのような理由に遭遇したことがありません。</target>
        </trans-unit>
        <trans-unit id="4d759e506cc87fd94eb228708ebf8d3af992fed6" translate="yes" xml:space="preserve">
          <source>Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.</source>
          <target state="translated">Pythonはローカルとグローバルの間で、どちらのスコープから変数をロードすべきかを決定するために単純なヒューリスティックを使用します。変数名が代入の左側に表示されていて、グローバルが宣言されていない場合は、ローカルとみなされます。代入の左側に変数名が表示されていない場合は、グローバルとみなされます。</target>
        </trans-unit>
        <trans-unit id="82e7e92a83c2370747a78755bf7bd7f480cb211a" translate="yes" xml:space="preserve">
          <source>Reference the class namespace where you want the change to show up.</source>
          <target state="translated">変更を表示するクラス名空間を参照します。</target>
        </trans-unit>
        <trans-unit id="d51825ca829838501c1e4d45114169b59541a7aa" translate="yes" xml:space="preserve">
          <source>Say you've got a module like this:</source>
          <target state="translated">こんなモジュールがあるとします。</target>
        </trans-unit>
        <trans-unit id="32f1e2eebe50a1762d5277748745d8fbe01fdb6d" translate="yes" xml:space="preserve">
          <source>See how baz, which appears on the left side of an assignment in &lt;code&gt;foo()&lt;/code&gt;, is the only &lt;code&gt;LOAD_FAST&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; の割り当ての左側に表示されるbazが唯一の &lt;code&gt;LOAD_FAST&lt;/code&gt; 変数であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="b70c1e0a06b68daff9b694d823872ede25884d46" translate="yes" xml:space="preserve">
          <source>See other answers if you want to share a global variable across modules.</source>
          <target state="translated">モジュール間でグローバル変数を共有したい場合は、他の回答を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca4cb42a3ea049813c0ec667fbcdf3509dcd2e15" translate="yes" xml:space="preserve">
          <source>So after calling the function:</source>
          <target state="translated">だから、関数を呼び出した後に</target>
        </trans-unit>
        <trans-unit id="841b2904cac2a4bc796bc658ba8ef34b26e05323" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;What are the rules for local and global variables in Python?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">出典： &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;Pythonのローカル変数とグローバル変数のルールは何ですか？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="553e5e7d40b28c7793e577cda926afd288ff4db1" translate="yes" xml:space="preserve">
          <source>The canonical way to share information across modules within a single program is to create a special configuration module (often called &lt;strong&gt;config&lt;/strong&gt; or &lt;strong&gt;cfg&lt;/strong&gt;). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</source>
          <target state="translated">単一のプログラム内のモジュール間で情報を共有する標準的な方法は、特別な構成モジュール（しばしば&lt;strong&gt;config&lt;/strong&gt;または&lt;strong&gt;cfg&lt;/strong&gt;と呼ばれる）を作成することです。 アプリケーションのすべてのモジュールに構成モジュールをインポートするだけです。 その後、モジュールはグローバル名として使用可能になります。 各モジュールのインスタンスは1つしかないため、モジュールオブジェクトに加えられた変更はどこにでも反映されます。 例えば：</target>
        </trans-unit>
        <trans-unit id="808008d2043d737b7ce2c0ff8be31b1727e98f20" translate="yes" xml:space="preserve">
          <source>This simple code works just like that, and it will execute. I hope it helps.</source>
          <target state="translated">このシンプルなコードは、それと同じように動作し、実行されます。お役に立てれば幸いです。</target>
        </trans-unit>
        <trans-unit id="a778fa74f0b4bfd3ce58b5f0f686aebc59db57b4" translate="yes" xml:space="preserve">
          <source>Though a bit surprising at first, a moment&amp;rsquo;s consideration explains
  this. On one hand, requiring global for assigned variables provides a
  bar against unintended side-effects. On the other hand, if global was
  required for all global references, you&amp;rsquo;d be using global all the
  time. You&amp;rsquo;d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</source>
          <target state="translated">最初は少し意外なことですが、これを説明するために少し考えてみます。 一方では、割り当てられた変数にグローバルを要求すると、意図しない副作用を防ぐことができます。 一方、すべてのグローバル参照にグローバルが必要な場合は、常にグローバルを使用します。 組み込み関数またはインポートされたモジュールのコンポーネントへのすべての参照をグローバルとして宣言する必要があります。 この混乱は、副作用を特定するためのグローバル宣言の有用性を無効にします。</target>
        </trans-unit>
        <trans-unit id="400f17d44c6a3438a85b87775ed1333c75f30def" translate="yes" xml:space="preserve">
          <source>To point the global variable at a different object, you are required to use the global keyword again:</source>
          <target state="translated">グローバル変数を別のオブジェクトに向けるには、再度グローバルキーワードを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">これを試してみてください。</target>
        </trans-unit>
        <trans-unit id="32d247e27063921abab961801b76b443eb072388" translate="yes" xml:space="preserve">
          <source>Using global variables in a function</source>
          <target state="translated">関数でのグローバル変数の使用</target>
        </trans-unit>
        <trans-unit id="6a278e1e6dcb9a8315d8de0c331b9839a70f5f6f" translate="yes" xml:space="preserve">
          <source>Using globals without modification</source>
          <target state="translated">変更せずにグローバルを使用する</target>
        </trans-unit>
        <trans-unit id="1c8bbbb1a5b2ea68b84c72c7d588482b45639eee" translate="yes" xml:space="preserve">
          <source>We can create a global with the following function:</source>
          <target state="translated">以下の関数でグローバルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="56ca4d0f3967908061048393e2bfd872827e2dc2" translate="yes" xml:space="preserve">
          <source>We get the same behavior in classes</source>
          <target state="translated">クラスでも同じ動作をします。</target>
        </trans-unit>
        <trans-unit id="b4c19d3873d161e46c75ceec1be024497c5b2e3e" translate="yes" xml:space="preserve">
          <source>What you are saying is to use the method like this:</source>
          <target state="translated">何を言っているのかというと、このような方法を使うことです。</target>
        </trans-unit>
        <trans-unit id="fcdf0bf377a132d036d9bbe6e09e1b12fb039c33" translate="yes" xml:space="preserve">
          <source>What's going on here is that Python assumes that any name that is &lt;em&gt;assigned to&lt;/em&gt;, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only &lt;em&gt;reading&lt;/em&gt; from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</source>
          <target state="translated">ここで起こっていることは、Pythonは、特に明記されていない限り、関数内の任意の場所でに&lt;em&gt;割り当てられた&lt;/em&gt;名前はその関数に対してローカルであると想定するということです。 名前を&lt;em&gt;読み取る&lt;/em&gt;だけで、その名前がローカルに存在しない場合は、含まれているスコープ（モジュールのグローバルスコープなど）で名前を検索しようとします。</target>
        </trans-unit>
        <trans-unit id="a3506340df03656042deb181b56e916a76306c18" translate="yes" xml:space="preserve">
          <source>When you assign 42 to the name &lt;code&gt;myGlobal&lt;/code&gt;, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;garbage-collected&lt;/a&gt; when &lt;code&gt;func1()&lt;/code&gt; returns; meanwhile, &lt;code&gt;func2()&lt;/code&gt; can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of &lt;code&gt;myGlobal&lt;/code&gt; inside &lt;code&gt;func1()&lt;/code&gt; before you assign to it, you'd get an &lt;code&gt;UnboundLocalError&lt;/code&gt;, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '&lt;code&gt;global&lt;/code&gt;' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</source>
          <target state="translated">したがって、 &lt;code&gt;myGlobal&lt;/code&gt; という名前に42を割り当てると、Pythonは同じ名前のグローバル変数をシャドウするローカル変数を作成します。 そのローカルはスコープ外になり、 &lt;code&gt;func1()&lt;/code&gt; が戻るときに&lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;ガベージコレクションされ&lt;/a&gt;ます。 一方、 &lt;code&gt;func2()&lt;/code&gt; は、（変更されていない）グローバル名以外は何も表示できません。 この名前空間の決定は、実行時ではなくコンパイル時に行われることに注意してください-割り当てる前に &lt;code&gt;func1()&lt;/code&gt; 内の &lt;code&gt;myGlobal&lt;/code&gt; の値を読み取ると、Pythonはすでにそうである必要があると判断しているため、 &lt;code&gt;UnboundLocalError&lt;/code&gt; を取得します。ローカル変数ですが、まだ値が関連付けられていません。 しかし、 ' &lt;code&gt;global&lt;/code&gt; 'ステートメントを使用することで、ローカルに割り当てるのではなく、別の場所で名前を探すようにPythonに指示します。</target>
        </trans-unit>
        <trans-unit id="946f5220d4c0ffd2002c5c5a98c6d48ae55240ed" translate="yes" xml:space="preserve">
          <source>Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only.</source>
          <target state="translated">変数をグローバル名前空間から出したり、グローバル名前空間にダンプロードできるようにしてくれます。超便利で、騒がず、騒がずに済みます。Python 3 のみであることは間違いない。</target>
        </trans-unit>
        <trans-unit id="fe2ce5d5861f8377eecbb92498c26eb8c03d724d" translate="yes" xml:space="preserve">
          <source>With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:</source>
          <target state="translated">並列実行では、グローバル変数は何が起こっているのかを理解していないと、予期せぬ結果を引き起こすことがあります。ここでは、マルチプロセシングでグローバル変数を使用した例を示します。各プロセスが変数の独自のコピーで動作していることがよくわかります。</target>
        </trans-unit>
        <trans-unit id="54e1cac78dddcbd65775350f737c72e93d2d798f" translate="yes" xml:space="preserve">
          <source>Writing a function does not actually run its code. So we call the &lt;code&gt;create_global_variable&lt;/code&gt; function:</source>
          <target state="translated">関数を作成しても、実際にはそのコードは実行されません。 したがって、 &lt;code&gt;create_global_variable&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="e03ad1c070e36b872b3333d095e7388731b22882" translate="yes" xml:space="preserve">
          <source>Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it &quot;wholesale&quot; does have that requirement:</source>
          <target state="translated">グローバル配列の明示的な要素への書き込みは、グローバル宣言を必要としないようです。</target>
        </trans-unit>
        <trans-unit id="cbecb723606740114452d22a28142d9af6613a55" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.</source>
          <target state="translated">存在する場合はグローバル変数を使用し、存在しない場合はローカル変数を作成して、推測しようとした言語を使用できます。 ただし、これは非常にエラーが発生しやすくなります。 たとえば、別のモジュールをインポートすると、その名前のグローバル変数が誤って導入され、プログラムの動作が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d42881afae3fc3861e64948e9774514253333db4" translate="yes" xml:space="preserve">
          <source>You can just use it, so long as you don't expect to change which object it points to:</source>
          <target state="translated">どのオブジェクトを指しているかを変更することを期待しない限り、それを使用することができます。</target>
        </trans-unit>
        <trans-unit id="b5500ef73857d114d1c398cb4242333b1ef82771" translate="yes" xml:space="preserve">
          <source>You can use a global variable in other functions by declaring it as &lt;code&gt;global&lt;/code&gt; in each function that assigns to it:</source>
          <target state="translated">他の関数でグローバル変数を使用するには、それに割り当てる各関数でグローバル変数を宣言します。</target>
        </trans-unit>
        <trans-unit id="bb853d6e0b691fc0b5ce5fb7fac2249a580747d1" translate="yes" xml:space="preserve">
          <source>You may want to explore the notion of &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;namespaces&lt;/a&gt;. In Python, the &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;module&lt;/a&gt; is the natural place for &lt;em&gt;global&lt;/em&gt; data:</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;名前空間&lt;/a&gt;の概念を調べてみてください。 Pythonでは、 &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;モジュール&lt;/a&gt;は&lt;em&gt;グローバル&lt;/em&gt;データの自然な場所です。</target>
        </trans-unit>
        <trans-unit id="59950ecb7d047f5218b8fa8c0b131c6862e9cb6a" translate="yes" xml:space="preserve">
          <source>You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a '&lt;code&gt;global&lt;/code&gt;' declaration to &lt;code&gt;func1()&lt;/code&gt;, then &lt;code&gt;func2()&lt;/code&gt; will print 42.</source>
          <target state="translated">これは42を出力することを期待するかもしれませんが、代わりに5を出力します。すでに述べたように、 &lt;code&gt;func1()&lt;/code&gt; に ' &lt;code&gt;global&lt;/code&gt; '宣言を追加すると、 &lt;code&gt;func2()&lt;/code&gt; は42を出力します。</target>
        </trans-unit>
        <trans-unit id="6f7e627d65ec53dbbbe98628a309293b7318508d" translate="yes" xml:space="preserve">
          <source>You need to reference the global variable in every function you want to use.</source>
          <target state="translated">使用したい関数ごとにグローバル変数を参照する必要があります。</target>
        </trans-unit>
        <trans-unit id="20ae9a054da61b005011ec052d200d4d80ee4f67" translate="yes" xml:space="preserve">
          <source>You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.</source>
          <target state="translated">実際にはグローバルをローカル変数に格納しているわけではなく、元のグローバル参照が参照しているのと同じオブジェクトへのローカル参照を作成しているだけです。Python のほとんどすべてのものはオブジェクトを参照する名前であり、通常の操作では何もコピーされないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="fae82a086e49510dea6d0bfce87709497778fe3a" translate="yes" xml:space="preserve">
          <source>and now we can use the global variable:</source>
          <target state="translated">で、グローバル変数を使うことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="451cb4f77137909fcb0b3a6aad84ab3e27589353" translate="yes" xml:space="preserve">
          <source>we can see that the global variable has been changed. The &lt;code&gt;global_variable&lt;/code&gt; name now points to &lt;code&gt;'Bar'&lt;/code&gt;:</source>
          <target state="translated">グローバル変数が変更されていることがわかります。 &lt;code&gt;global_variable&lt;/code&gt; 名が &lt;code&gt;'Bar'&lt;/code&gt; を指すようになりました。</target>
        </trans-unit>
        <trans-unit id="4745a5736422bf254160a52d8206da60d719e401" translate="yes" xml:space="preserve">
          <source>what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class?</source>
          <target state="translated">クラス内の関数内でグローバル変数を作成し、その変数を別のクラス内の別の関数内で使用したい場合はどうすればいいですか?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
