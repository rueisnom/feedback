<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/423379">
    <body>
      <group id="423379">
        <trans-unit id="3a29a28d4e300f6b9d5792eb7d5f29058935330c" translate="yes" xml:space="preserve">
          <source>(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</source>
          <target state="translated">(我相信这种行为主要是通过对本地命名空间的优化而产生的--如果没有这种行为,Python的虚拟机每次在函数内部分配一个新的名称时,至少需要执行三次名称查找(以确保该名称在modulebuiltin级别上不存在),这将大大降低了一个非常常见的操作速度。)</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a48a084b773cbe5f5fb20cc6a9ca54adbc106d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/config.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/config.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf13aaa1958e161e4472d4ced8b48503adb7f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main/runner.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;main/runner.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4f93d499dc80601179acd8f180b4012220ba4cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tests/runner_test.py&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b3aabce7f8e6e2cd6cc1f730a4a92618cfe4c43" translate="yes" xml:space="preserve">
          <source>A follow on comment asks:</source>
          <target state="translated">一个跟帖评论问道。</target>
        </trans-unit>
        <trans-unit id="831c1deafff39dc2e0e4c47676f7c7651ee65397" translate="yes" xml:space="preserve">
          <source>A specific use of global-in-a-module is described here - &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;How do I share global variables across modules?&lt;/a&gt;, and for completeness the contents are shared here:</source>
          <target state="translated">此处描述了模块中&lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm&quot;&gt;全局变量&lt;/a&gt;的特定用法- 如何在模块之间共享全局变量？ ，为了完整起见，这里共享内容：</target>
        </trans-unit>
        <trans-unit id="382bf460fa9f0a13f62cf8265fd9b497087fbfdd" translate="yes" xml:space="preserve">
          <source>Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.</source>
          <target state="translated">另外,全局变量是有用的,与一些OOP狂热者的说法相反,他们认为全局变量是有用的,尤其是对于较小的脚本来说,OOP是矫枉过正的。</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">而现在。</target>
        </trans-unit>
        <trans-unit id="ea8235608bc286dd475d407c66ae4bc1edc30400" translate="yes" xml:space="preserve">
          <source>As follows:</source>
          <target state="translated">如下图所示:</target>
        </trans-unit>
        <trans-unit id="b3f7a4454712d08571f98953114c6f37fade56b3" translate="yes" xml:space="preserve">
          <source>As it turns out the answer is always simple.</source>
          <target state="translated">事实证明,答案总是很简单。</target>
        </trans-unit>
        <trans-unit id="e68fb89042177a22f85fcb29baf649f07687ea4e" translate="yes" xml:space="preserve">
          <source>Both give the same output.</source>
          <target state="translated">两者的输出都是一样的。</target>
        </trans-unit>
        <trans-unit id="d2a60791f237ebd0573c45e98b3bbe67a69974d9" translate="yes" xml:space="preserve">
          <source>But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use &lt;code&gt;self&lt;/code&gt; arguments here - these could be class methods (handy if mutating the class attribute from the usual &lt;code&gt;cls&lt;/code&gt; argument) or static methods (no &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;cls&lt;/code&gt;).</source>
          <target state="translated">但是我建议不要使用全局变量，而应使用类属性，以避免使模块名称空间混乱。 还要注意，我们在这里不使用 &lt;code&gt;self&lt;/code&gt; 参数-这些可以是类方法（如果从通常的 &lt;code&gt;cls&lt;/code&gt; 参数中更改 class属性，则很方便）或静态方法（没有 &lt;code&gt;self&lt;/code&gt; 或 &lt;code&gt;cls&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5e52db3daf0213206b9bd29001eb49db2ead367f" translate="yes" xml:space="preserve">
          <source>But the better way is to use the global variable like this:</source>
          <target state="translated">但更好的方法是像这样使用全局变量。</target>
        </trans-unit>
        <trans-unit id="bbf8d1399bcb14f026be806f4fa8af8f8f28b92e" translate="yes" xml:space="preserve">
          <source>But using that misnamed local variable does not change the global variable:</source>
          <target state="translated">但是,使用那个叫错名字的局部变量并不能改变全局变量。</target>
        </trans-unit>
        <trans-unit id="21065925475664b639823498cf7afc05ae436197" translate="yes" xml:space="preserve">
          <source>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user&amp;rsquo;s global variables. On the other hand, if you know what you are doing you can touch a module&amp;rsquo;s global variables with the same notation used to refer to its functions, &lt;code&gt;modname.itemname&lt;/code&gt;.</source>
          <target state="translated">每个模块都有自己的专用符号表，模块中定义的所有功能都将其用作全局符号表。 因此，模块的作者可以在模块中使用全局变量，而不必担心与用户的全局变量的意外冲突。 另一方面，如果您知道自己在做什么，则可以使用与引用 &lt;code&gt;modname.itemname&lt;/code&gt; 功能相同的符号modname.itemname来触摸模块的全局变量。</target>
        </trans-unit>
        <trans-unit id="6d42c87f4a4cb2658756a338842b6e9caf5c4cb4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;getstocks.py&lt;/em&gt;:</source>
          <target state="translated">文件&lt;em&gt;getstocks.py&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="0dcfee04bdce5c9c94e649b611fb6a026a77a9e4" translate="yes" xml:space="preserve">
          <source>File &lt;em&gt;initval.py&lt;/em&gt;:</source>
          <target state="translated">文件&lt;em&gt;initval.py&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="6dbcd6992db7e9840509e7cc35fa6c430c718e4e" translate="yes" xml:space="preserve">
          <source>File: config.py</source>
          <target state="translated">文件:config.py</target>
        </trans-unit>
        <trans-unit id="828c739880e40a2ca36ab9ef0843c428e9f7ab58" translate="yes" xml:space="preserve">
          <source>File: main.py</source>
          <target state="translated">文件:main.py</target>
        </trans-unit>
        <trans-unit id="dfb12898324c1f6fc1a0454806497d0482362334" translate="yes" xml:space="preserve">
          <source>File: mod.py</source>
          <target state="translated">文件:mod.py</target>
        </trans-unit>
        <trans-unit id="bcc361b07598fb63cbd8411db8e5b2d66c808872" translate="yes" xml:space="preserve">
          <source>Following on and as an add on, use a file to contain all global variables all declared locally and then &lt;code&gt;import as&lt;/code&gt;:</source>
          <target state="translated">接下来，作为附加，使用文件包含所有在本地声明的所有全局变量，然后 &lt;code&gt;import as&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="d6230aa52a35650b976c27208c9b41c6c4638672" translate="yes" xml:space="preserve">
          <source>Here I demonstrate we get the same behavior in methods as we do in regular functions:</source>
          <target state="translated">在这里,我证明我们在方法中得到的行为和在正则函数中得到的行为是一样的。</target>
        </trans-unit>
        <trans-unit id="ff2ef371dbac72e4f6add26d0dc913ad7cc66a86" translate="yes" xml:space="preserve">
          <source>Here is a small sample module with a simple way to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">这是一个小样本模块，有一个简单的方法可以在 &lt;code&gt;main&lt;/code&gt; 定义中显示它：</target>
        </trans-unit>
        <trans-unit id="4642e3e366e141920eafccce38fba209dfc45ccc" translate="yes" xml:space="preserve">
          <source>Here is how to show it in a &lt;code&gt;main&lt;/code&gt; definition:</source>
          <target state="translated">这是在 &lt;code&gt;main&lt;/code&gt; 定义中显示它的方法：</target>
        </trans-unit>
        <trans-unit id="8991da6e4670d4c723a1a153a470485b70325de7" translate="yes" xml:space="preserve">
          <source>How can I create or use a global variable in a function?</source>
          <target state="translated">如何在函数中创建或使用全局变量?</target>
        </trans-unit>
        <trans-unit id="95fdb4946a28aa2e7dfa96a14e1865723254e148" translate="yes" xml:space="preserve">
          <source>However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.</source>
          <target state="translated">但是,如果你把一个新的变量赋值给一个没有在函数中声明为全局的变量,那么它就会被隐含地声明为本地变量,并且它可以遮盖任何具有相同名称的现有全局变量。</target>
        </trans-unit>
        <trans-unit id="c1df67f2e32daa98e81e9c10062af50c8d22fc6e" translate="yes" xml:space="preserve">
          <source>I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the &lt;code&gt;global&lt;/code&gt; keyword.</source>
          <target state="translated">我想这是因为全局变量是如此危险，Python希望通过显式要求使用 &lt;code&gt;global&lt;/code&gt; 关键字来确保您真正知道这就是要使用的内容。</target>
        </trans-unit>
        <trans-unit id="dd87132234042a627a085a0c1b2af889af0d848c" translate="yes" xml:space="preserve">
          <source>I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; function returns a mutable global symbol dictionary where you can &quot;magically&quot; make data available for the rest of your code. 
For example:</source>
          <target state="translated">我添加此内容是因为我在其他任何答案中都没有看到它，这对于那些在类似问题上苦苦挣扎的人可能很有用。 &lt;a href=&quot;https://docs.python.org/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt;函数返回一个可变的全局符号字典，您可以在其中&amp;ldquo;神奇地&amp;rdquo;使数据可用于其余代码。 例如：</target>
        </trans-unit>
        <trans-unit id="bf3ce99181155bb8d031a964f7e5313fc538f7e4" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that global variable in another function? Do I need to store the global variable in a local variable of the function which needs its access?</source>
          <target state="translated">如果我在一个函数中创建了一个全局变量,如何在另一个函数中使用这个全局变量?我是否需要将全局变量存储在需要访问它的函数的本地变量中?</target>
        </trans-unit>
        <trans-unit id="8a16d826c7c600e6adddd1b1b0f6795ec79959f6" translate="yes" xml:space="preserve">
          <source>If I create a global variable in one function, how can I use that variable in another function?</source>
          <target state="translated">如果我在一个函数中创建一个全局变量,如何在另一个函数中使用该变量?</target>
        </trans-unit>
        <trans-unit id="b8028c2e61a77dee86ccb01aa52f7a1e7a2d959a" translate="yes" xml:space="preserve">
          <source>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</source>
          <target state="translated">如果我没有理解错,你看到的是Python如何处理本地(函数)和全局(模块)命名空间的结果。</target>
        </trans-unit>
        <trans-unit id="a6c2c29d467201cc494122ecc52c43bd4f8cf0cc" translate="yes" xml:space="preserve">
          <source>If you create a local variable with the same name, it will overshadow a global variable:</source>
          <target state="translated">如果你创建了一个同名的本地变量,它将覆盖一个全局变量。</target>
        </trans-unit>
        <trans-unit id="526565a39b3a2f5141b90048b5bcd8783df3a491" translate="yes" xml:space="preserve">
          <source>If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases.</source>
          <target state="translated">如果你不需要显式地指定一个标识符何时引用一个预定义的全局,那么你大概需要显式地指定一个标识符何时是一个新的本地变量 (例如,用 JavaScript 中的 'var' 命令来代替)。由于在任何严肃的、非琐碎的系统中,本地变量比全局变量更常见,因此在大多数情况下,Python 的系统更有意义。</target>
        </trans-unit>
        <trans-unit id="b40ade2a2372e7d63caa7d05e130870fc99946cf" translate="yes" xml:space="preserve">
          <source>If you want to refer to a global variable in a function, you can use the &lt;strong&gt;global&lt;/strong&gt; keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.</source>
          <target state="translated">如果要在函数中引用全局变量，则可以使用&lt;strong&gt;global&lt;/strong&gt;关键字声明哪些变量是全局变量。 您不必在所有情况下都使用它（因为这里的人不正确地声称）-如果在本地作用域或定义此函数的函数的作用域中找不到表达式中引用的名称，则在全局范围内查找该名称变量。</target>
        </trans-unit>
        <trans-unit id="753063fdb8ccba8abb2d018e4484738cdedc4ba0" translate="yes" xml:space="preserve">
          <source>In Python, variables that are only referenced inside a function are
  &lt;strong&gt;implicitly global&lt;/strong&gt;. If a variable is assigned a new value anywhere
  within the function&amp;rsquo;s body, it&amp;rsquo;s assumed to be a &lt;strong&gt;local&lt;/strong&gt;. If a variable
  is ever assigned a new value inside the function, the variable is
  implicitly local, and you need to explicitly declare it as &amp;lsquo;global&amp;rsquo;.</source>
          <target state="translated">在Python中，仅在函数内部引用的变量是&lt;strong&gt;隐式全局的&lt;/strong&gt; 。 如果在函数体内的任何位置为变量分配了新值，则假定该变量为&lt;strong&gt;local&lt;/strong&gt; 。 如果在函数内部为变量分配了新值，则该变量是隐式局部变量，您需要将其显式声明为&amp;ldquo; global&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ae253629bb7e76f3c2eb67c025d8cad8dfe4347f" translate="yes" xml:space="preserve">
          <source>In addition to already existing answers and to make this more confusing:</source>
          <target state="translated">除了已经存在的答案之外,为了使其更具有迷惑性。</target>
        </trans-unit>
        <trans-unit id="366c68bf24874b885d4c0b04c646aa27826522c9" translate="yes" xml:space="preserve">
          <source>In case you have a local variable with the same name, you might want to use the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">如果您有一个具有相同名称的局部变量，则可能要使用&lt;a href=&quot;https://docs.python.org/3/library/functions.html#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; 函数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="757725c834e63de261ff0fcf679ebe9f7da64387" translate="yes" xml:space="preserve">
          <source>In this example, runner is using &lt;strong&gt;max&lt;/strong&gt; from the file config. I want my test to change the value of &lt;strong&gt;max&lt;/strong&gt; when runner is using it.</source>
          <target state="translated">在此示例中，Runner正在使用文件配置中的&lt;strong&gt;max&lt;/strong&gt; 。 我希望我的测试在跑步者使用它时更改&lt;strong&gt;max&lt;/strong&gt;的值。</target>
        </trans-unit>
        <trans-unit id="c2be3a39d7cd2238e86185235780e3d6bacd74bd" translate="yes" xml:space="preserve">
          <source>Local variables with the same name</source>
          <target state="translated">同名的本地变量</target>
        </trans-unit>
        <trans-unit id="adb2902dbe58db2b1c4e635820ac254599998269" translate="yes" xml:space="preserve">
          <source>Modification of the global variable from inside a function</source>
          <target state="translated">从函数内部修改全局变量</target>
        </trans-unit>
        <trans-unit id="f170cc8be722b1dc8f64cdb89f2437a052e0ddd3" translate="yes" xml:space="preserve">
          <source>Note that &quot;global&quot; in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.</source>
          <target state="translated">注意,Python 中的 &quot;全局 &quot;并不是真正的全局--它只是到模块级的全局。所以它只对在其全局的模块中编写的函数可用。函数记得它们在哪个模块中编写的函数,所以当它们被导出到其他模块中时,它们仍然会在创建时的模块中查找全局变量。</target>
        </trans-unit>
        <trans-unit id="8c71357e59c34f569330bbf42118d099786d64bd" translate="yes" xml:space="preserve">
          <source>Note that after writing this function, the code actually changing it has still not run:</source>
          <target state="translated">注意,写完这个函数后,实际改变它的代码仍然没有运行。</target>
        </trans-unit>
        <trans-unit id="c89c18f4431fa00077e4850544b5784823792628" translate="yes" xml:space="preserve">
          <source>Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.</source>
          <target state="translated">请注意,你应该避免使用与 globals 相同名称的本地变量,除非你确切地知道你在做什么,并且有非常好的理由。我还没有遇到过这样的理由。</target>
        </trans-unit>
        <trans-unit id="4d759e506cc87fd94eb228708ebf8d3af992fed6" translate="yes" xml:space="preserve">
          <source>Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.</source>
          <target state="translated">Python 使用一个简单的启发式来决定它应该从哪个作用域加载变量,在本地和全局之间。如果一个变量名出现在赋值的左侧,但没有声明为全局变量,则假定它是本地变量。如果一个变量名没有出现在赋值的左侧,则认为是全局变量。</target>
        </trans-unit>
        <trans-unit id="82e7e92a83c2370747a78755bf7bd7f480cb211a" translate="yes" xml:space="preserve">
          <source>Reference the class namespace where you want the change to show up.</source>
          <target state="translated">参考你想让更改显示的类名称空间。</target>
        </trans-unit>
        <trans-unit id="d51825ca829838501c1e4d45114169b59541a7aa" translate="yes" xml:space="preserve">
          <source>Say you've got a module like this:</source>
          <target state="translated">说你有一个这样的模块。</target>
        </trans-unit>
        <trans-unit id="32f1e2eebe50a1762d5277748745d8fbe01fdb6d" translate="yes" xml:space="preserve">
          <source>See how baz, which appears on the left side of an assignment in &lt;code&gt;foo()&lt;/code&gt;, is the only &lt;code&gt;LOAD_FAST&lt;/code&gt; variable.</source>
          <target state="translated">请参阅 &lt;code&gt;foo()&lt;/code&gt; 赋值左侧出现的baz如何是唯一的 &lt;code&gt;LOAD_FAST&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="b70c1e0a06b68daff9b694d823872ede25884d46" translate="yes" xml:space="preserve">
          <source>See other answers if you want to share a global variable across modules.</source>
          <target state="translated">如果你想跨模块共享一个全局变量,请看其他答案。</target>
        </trans-unit>
        <trans-unit id="ca4cb42a3ea049813c0ec667fbcdf3509dcd2e15" translate="yes" xml:space="preserve">
          <source>So after calling the function:</source>
          <target state="translated">所以在调用该函数后。</target>
        </trans-unit>
        <trans-unit id="841b2904cac2a4bc796bc658ba8ef34b26e05323" translate="yes" xml:space="preserve">
          <source>Source: &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;What are the rules for local and global variables in Python?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">资料来源： &lt;em&gt;&lt;a href=&quot;https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python&quot;&gt;Python中局部和全局变量的规则是什么？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="553e5e7d40b28c7793e577cda926afd288ff4db1" translate="yes" xml:space="preserve">
          <source>The canonical way to share information across modules within a single program is to create a special configuration module (often called &lt;strong&gt;config&lt;/strong&gt; or &lt;strong&gt;cfg&lt;/strong&gt;). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</source>
          <target state="translated">在单个程序中的各个模块之间共享信息的规范方法是创建一个特殊的配置模块（通常称为&lt;strong&gt;config&lt;/strong&gt;或&lt;strong&gt;cfg&lt;/strong&gt; ）。 只需将配置模块导入应用程序的所有模块中即可； 然后，该模块即可用作全局名称。 因为每个模块只有一个实例，所以对模块对象所做的任何更改都会在所有地方反映出来。 例如：</target>
        </trans-unit>
        <trans-unit id="808008d2043d737b7ce2c0ff8be31b1727e98f20" translate="yes" xml:space="preserve">
          <source>This simple code works just like that, and it will execute. I hope it helps.</source>
          <target state="translated">这个简单的代码就是这样,就能执行。希望对你有帮助。</target>
        </trans-unit>
        <trans-unit id="a778fa74f0b4bfd3ce58b5f0f686aebc59db57b4" translate="yes" xml:space="preserve">
          <source>Though a bit surprising at first, a moment&amp;rsquo;s consideration explains
  this. On one hand, requiring global for assigned variables provides a
  bar against unintended side-effects. On the other hand, if global was
  required for all global references, you&amp;rsquo;d be using global all the
  time. You&amp;rsquo;d have to declare as global every reference to a built-in
  function or to a component of an imported module. This clutter would
  defeat the usefulness of the global declaration for identifying
  side-effects.</source>
          <target state="translated">尽管起初有些令人惊讶，但片刻的考虑可以解释这一点。 一方面，要求全局分配变量可以防止意外副作用。 另一方面，如果所有全局引用都需要全局，那么您将一直使用全局。 您必须将对内置函数或导入模块的组件的每个引用声明为全局引用。 这种混乱将破坏全球宣言对确定副作用的有用性。</target>
        </trans-unit>
        <trans-unit id="400f17d44c6a3438a85b87775ed1333c75f30def" translate="yes" xml:space="preserve">
          <source>To point the global variable at a different object, you are required to use the global keyword again:</source>
          <target state="translated">要将全局变量指向不同的对象,需要再次使用全局关键字。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
        <trans-unit id="32d247e27063921abab961801b76b443eb072388" translate="yes" xml:space="preserve">
          <source>Using global variables in a function</source>
          <target state="translated">在函数中使用全局变量</target>
        </trans-unit>
        <trans-unit id="6a278e1e6dcb9a8315d8de0c331b9839a70f5f6f" translate="yes" xml:space="preserve">
          <source>Using globals without modification</source>
          <target state="translated">不加修改地使用 globals</target>
        </trans-unit>
        <trans-unit id="1c8bbbb1a5b2ea68b84c72c7d588482b45639eee" translate="yes" xml:space="preserve">
          <source>We can create a global with the following function:</source>
          <target state="translated">我们可以用下面的函数创建一个全局。</target>
        </trans-unit>
        <trans-unit id="56ca4d0f3967908061048393e2bfd872827e2dc2" translate="yes" xml:space="preserve">
          <source>We get the same behavior in classes</source>
          <target state="translated">我们在类中得到同样的行为</target>
        </trans-unit>
        <trans-unit id="b4c19d3873d161e46c75ceec1be024497c5b2e3e" translate="yes" xml:space="preserve">
          <source>What you are saying is to use the method like this:</source>
          <target state="translated">你说的是要用这样的方法。</target>
        </trans-unit>
        <trans-unit id="fcdf0bf377a132d036d9bbe6e09e1b12fb039c33" translate="yes" xml:space="preserve">
          <source>What's going on here is that Python assumes that any name that is &lt;em&gt;assigned to&lt;/em&gt;, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only &lt;em&gt;reading&lt;/em&gt; from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</source>
          <target state="translated">这里发生的事情是，Python假定在函数内任何位置&lt;em&gt;分配给的&lt;/em&gt;任何名称都是该函数的本地名称，除非另有明确说明。 如果仅从名称&lt;em&gt;读取&lt;/em&gt; ，并且该名称在本地不存在，它将尝试在任何包含的范围（例如，模块的全局范围）中查找该名称。</target>
        </trans-unit>
        <trans-unit id="a3506340df03656042deb181b56e916a76306c18" translate="yes" xml:space="preserve">
          <source>When you assign 42 to the name &lt;code&gt;myGlobal&lt;/code&gt;, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is &lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;garbage-collected&lt;/a&gt; when &lt;code&gt;func1()&lt;/code&gt; returns; meanwhile, &lt;code&gt;func2()&lt;/code&gt; can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of &lt;code&gt;myGlobal&lt;/code&gt; inside &lt;code&gt;func1()&lt;/code&gt; before you assign to it, you'd get an &lt;code&gt;UnboundLocalError&lt;/code&gt;, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '&lt;code&gt;global&lt;/code&gt;' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</source>
          <target state="translated">因此，当将42分配给名称 &lt;code&gt;myGlobal&lt;/code&gt; 时，Python将创建一个局部变量，该局部变量遮盖相同名称的全局变量。 该local超出范围，并在 &lt;code&gt;func1()&lt;/code&gt; 返回时被&lt;a href=&quot;http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection&quot;&gt;垃圾回收&lt;/a&gt; ； 同时， &lt;code&gt;func2()&lt;/code&gt; 只能看到（未修改的）全局名称。 请注意，此名称空间决定是在编译时发生的，而不是在运行时发生的-如果要在分配给 &lt;code&gt;func1()&lt;/code&gt; 之前读取 &lt;code&gt;myGlobal&lt;/code&gt; 的值， 则会得到 &lt;code&gt;UnboundLocalError&lt;/code&gt; ，因为Python已经决定必须局部变量，但尚未有任何关联的值。 但是通过使用' &lt;code&gt;global&lt;/code&gt; '语句，您告诉Python应该在其他地方查找该名称，而不是在本地分配它。</target>
        </trans-unit>
        <trans-unit id="946f5220d4c0ffd2002c5c5a98c6d48ae55240ed" translate="yes" xml:space="preserve">
          <source>Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only.</source>
          <target state="translated">只需让你把变量从全局命名空间中转载到全局命名空间。超级方便,不费吹灰之力,不费吹灰之力。很肯定它只适用于Python 3。</target>
        </trans-unit>
        <trans-unit id="fe2ce5d5861f8377eecbb92498c26eb8c03d724d" translate="yes" xml:space="preserve">
          <source>With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:</source>
          <target state="translated">在并行执行中,如果不了解发生了什么,全局变量可能会造成意想不到的结果。下面是一个在多进程中使用全局变量的例子。我们可以清楚地看到,每个进程都是用自己的变量副本来工作的。</target>
        </trans-unit>
        <trans-unit id="54e1cac78dddcbd65775350f737c72e93d2d798f" translate="yes" xml:space="preserve">
          <source>Writing a function does not actually run its code. So we call the &lt;code&gt;create_global_variable&lt;/code&gt; function:</source>
          <target state="translated">编写函数实际上不会运行其代码。 因此，我们调用 &lt;code&gt;create_global_variable&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="e03ad1c070e36b872b3333d095e7388731b22882" translate="yes" xml:space="preserve">
          <source>Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it &quot;wholesale&quot; does have that requirement:</source>
          <target state="translated">写到全局数组的显式元素显然不需要全局声明,虽然写到它的 &quot;批发 &quot;确实有这个要求。</target>
        </trans-unit>
        <trans-unit id="cbecb723606740114452d22a28142d9af6613a55" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.</source>
          <target state="translated">您&lt;em&gt;可能&lt;/em&gt;会尝试尝试使用一种语言进行猜测，如果存在则使用全局变量，如果不存在则创建一个本地变量。 但是，这很容易出错。 例如，导入另一个模块可能会无意中通过该名称引入全局变量，从而改变程序的行为。</target>
        </trans-unit>
        <trans-unit id="d42881afae3fc3861e64948e9774514253333db4" translate="yes" xml:space="preserve">
          <source>You can just use it, so long as you don't expect to change which object it points to:</source>
          <target state="translated">你可以直接使用它,只要你不指望改变它指向哪个对象就可以了。</target>
        </trans-unit>
        <trans-unit id="b5500ef73857d114d1c398cb4242333b1ef82771" translate="yes" xml:space="preserve">
          <source>You can use a global variable in other functions by declaring it as &lt;code&gt;global&lt;/code&gt; in each function that assigns to it:</source>
          <target state="translated">您可以在其他函数中使用全局变量，方法是在分配给它的每个函数中将其声明为全局变量：</target>
        </trans-unit>
        <trans-unit id="bb853d6e0b691fc0b5ce5fb7fac2249a580747d1" translate="yes" xml:space="preserve">
          <source>You may want to explore the notion of &lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;namespaces&lt;/a&gt;. In Python, the &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;module&lt;/a&gt; is the natural place for &lt;em&gt;global&lt;/em&gt; data:</source>
          <target state="translated">您可能想探索&lt;a href=&quot;http://docs.python.org/reference/datamodel.html&quot;&gt;名称空间&lt;/a&gt;的概念。 在Python中， &lt;a href=&quot;http://docs.python.org/tutorial/modules.html&quot;&gt;模块&lt;/a&gt;是自然数据的自然存放地：</target>
        </trans-unit>
        <trans-unit id="59950ecb7d047f5218b8fa8c0b131c6862e9cb6a" translate="yes" xml:space="preserve">
          <source>You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a '&lt;code&gt;global&lt;/code&gt;' declaration to &lt;code&gt;func1()&lt;/code&gt;, then &lt;code&gt;func2()&lt;/code&gt; will print 42.</source>
          <target state="translated">您可能希望它显示42，但相反它显示5。如前所述，如果向 &lt;code&gt;func1()&lt;/code&gt; 添加' &lt;code&gt;global&lt;/code&gt; '声明，则 &lt;code&gt;func2()&lt;/code&gt; 将显示42。</target>
        </trans-unit>
        <trans-unit id="6f7e627d65ec53dbbbe98628a309293b7318508d" translate="yes" xml:space="preserve">
          <source>You need to reference the global variable in every function you want to use.</source>
          <target state="translated">你需要在你要使用的每一个函数中引用全局变量。</target>
        </trans-unit>
        <trans-unit id="20ae9a054da61b005011ec052d200d4d80ee4f67" translate="yes" xml:space="preserve">
          <source>You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.</source>
          <target state="translated">你实际上并没有将全局存储在一个本地变量中,只是创建了一个本地引用到你原来的全局引用所引用的同一个对象。记住,在 Python 中几乎所有的东西都是引用对象的名称,在通常的操作中没有任何东西会被复制。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="fae82a086e49510dea6d0bfce87709497778fe3a" translate="yes" xml:space="preserve">
          <source>and now we can use the global variable:</source>
          <target state="translated">而现在我们可以使用全局变量。</target>
        </trans-unit>
        <trans-unit id="451cb4f77137909fcb0b3a6aad84ab3e27589353" translate="yes" xml:space="preserve">
          <source>we can see that the global variable has been changed. The &lt;code&gt;global_variable&lt;/code&gt; name now points to &lt;code&gt;'Bar'&lt;/code&gt;:</source>
          <target state="translated">我们可以看到全局变量已更改。 现在， &lt;code&gt;global_variable&lt;/code&gt; 名称指向 &lt;code&gt;'Bar'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4745a5736422bf254160a52d8206da60d719e401" translate="yes" xml:space="preserve">
          <source>what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class?</source>
          <target state="translated">如果我想在一个类内的函数内创建一个全局变量,并想在另一个类内的另一个函数内使用该变量,该怎么办?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
