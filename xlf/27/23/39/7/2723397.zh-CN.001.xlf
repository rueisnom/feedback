<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2723397">
    <body>
      <group id="2723397">
        <trans-unit id="94c9db480f47df47185040411f9c95616b012de7" translate="yes" xml:space="preserve">
          <source>(adding an answer because never enough examples with Generics wildcards)</source>
          <target state="translated">(增加一个答案,因为使用通用通配符的例子永远不够多)</target>
        </trans-unit>
        <trans-unit id="7fc5b1f2bc2aaa5e44ba1bb9dfd44f3cf5667ee7" translate="yes" xml:space="preserve">
          <source>*You will say: &quot;OK, but why can't I add HammerSkark in it since it is the smallest type?&quot;. 
Answer: It is the smallest &lt;strong&gt;you&lt;/strong&gt; know. But HammerSkark can be extended too by somebody else and you end up in the same scenario.</source>
          <target state="translated">*您会说：&amp;ldquo;好的，但是为什么我不能在其中添加HammerSkark，因为它是最小的类型？&amp;rdquo;。 答：这是&lt;strong&gt;您所&lt;/strong&gt;知道的最小的。 但是HammerSkark也可以由其他人扩展，您最终会遇到相同的情况。</target>
        </trans-unit>
        <trans-unit id="d0174c51c975963bb39f928cbb22a18dcd04a81e" translate="yes" xml:space="preserve">
          <source>...but it has no way to tell if at runtime, your B will be a subtype or supertype of the list type. At runtime the list type can be any of the types A, B, C. So you cannot end up adding HammerSkark (super type) in a list of DeadHammerShark for example.</source>
          <target state="translated">...但它没有办法判断在运行时,你的B是列表类型的子类型还是超类型。在运行时,列表类型可以是A、B、C中的任何类型,所以你不能在DeadHammerShark的列表中加入HammerSkark(超级类型)。</target>
        </trans-unit>
        <trans-unit id="f2e963c423df2749b3a7c70442dd69362bec49a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;generics&lt;/a&gt; and &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;examples&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;泛型&lt;/a&gt;和&lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;示例&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a315a9a5442ad1949ff38821a17a1ccc8db468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov substitution principle:&lt;/a&gt;  if S is a subtype of T, then objects of type T may be replaced with objects of type S.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov替换原则：&lt;/a&gt;如果S是T的子类型，则可以用S类型的对象替换T类型的对象。</target>
        </trans-unit>
        <trans-unit id="84afdf7541023e94eb834fb4d55ad29bc2f8f383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is for &lt;strong&gt;reading&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 用于&lt;strong&gt;阅读&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5269c2a29c00dc63fdea0178f0dba0903385693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is for &lt;strong&gt;writing&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 是&lt;strong&gt;写作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be8228553ab50b13c364c53f104054de7dff4551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1: You want to go through the collection and do things with each item.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;情况1：您想浏览集合并为每个项目做事。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9feea5d372acd0600581c2c069b1ae87f772a292" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2: You want to add things to the collection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;情况2：您想向集合中添加东西。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d73dcd91708bc65136ea3f9780de244628654" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contravariance&lt;/strong&gt;: accept supertypes</source>
          <target state="translated">&lt;strong&gt;矛盾&lt;/strong&gt; ：接受超类型</target>
        </trans-unit>
        <trans-unit id="db725287369ff6aa40b2dcc280781ca3c22c6f57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Covariance&lt;/strong&gt;: accept subtypes</source>
          <target state="translated">&lt;strong&gt;协方差&lt;/strong&gt; ：接受子类型</target>
        </trans-unit>
        <trans-unit id="b78afe21d6d96b64853927ebc88812cf92d46c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify CS - Consumer Super:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让我们澄清一下CS-超级消费者：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0faa25525aa950fc903ca54e1b7840a251fc29a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify PE - Producer Extends:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让我们澄清一下PE-生产者扩展：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="243adf487fa4310c42089cb92177f6f400bb37d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To sum up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;总结一下&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2a047cbdd36af0c85dd4fbc1928d9726e2003e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; to read objects of types equal or below T from list.&lt;/strong&gt; We cannot add element to it.</source>
          <target state="translated">&lt;strong&gt;我们用 &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;扩展T&amp;gt;以从列表中读取类型等于或小于T的对象。&lt;/strong&gt; 我们无法在其中添加元素。</target>
        </trans-unit>
        <trans-unit id="18d98376587fef5489dd624463bb41fcad1d3558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; to add objects of types equal or below T in list.&lt;/strong&gt; We cannot read from 
it.</source>
          <target state="translated">&lt;strong&gt;我们用 &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;超级T&amp;gt;在列表中添加类型等于或低于T的对象。&lt;/strong&gt; 我们无法阅读。</target>
        </trans-unit>
        <trans-unit id="b58638ffc0961485f562de00c7e06a30e7ab8e29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bounded&lt;/strong&gt;(i.e. heading toward somewhere) &lt;strong&gt;wildcard&lt;/strong&gt; : There are 3 different flavours of wildcards:</source>
          <target state="translated">&lt;strong&gt;有界&lt;/strong&gt; （即朝某个地方去） &lt;strong&gt;通配符&lt;/strong&gt; ：有3种不同的通配符类型：</target>
        </trans-unit>
        <trans-unit id="2b032ce66a5b0601c3c15a3a78fd9ab067544c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt; if it reverses this ordering;</source>
          <target state="translated">如果它颠倒了这个顺序，则相反；</target>
        </trans-unit>
        <trans-unit id="758f69c0fcc2f45b755ce9abafa6f6d34557b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt;: an Animal[] is a Cat[];</source>
          <target state="translated">&lt;strong&gt;相反&lt;/strong&gt; ：Animal []是Cat []；</target>
        </trans-unit>
        <trans-unit id="0ba67e84f7f5c2e136ea9fe008b4b827013fff1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt; if it preserves the ordering of types (&amp;le;), which orders types from more specific to more generic;</source>
          <target state="translated">如果&lt;strong&gt;协变量&lt;/strong&gt;保持类型（&amp;le;）的顺序，则该&lt;strong&gt;变量&lt;/strong&gt;将类型从更特定的类型归类为更通用的类型；</target>
        </trans-unit>
        <trans-unit id="57bdc8d44fd6963ecd54c43806d679399b0772cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt;: a Cat[] is an Animal[];</source>
          <target state="translated">&lt;strong&gt;协变&lt;/strong&gt; ：Cat []是动物[]；</target>
        </trans-unit>
        <trans-unit id="db42607b786d14f36a7aa526ea5fd510862b8086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt; or nonvariant if neither of these applies.</source>
          <target state="translated">&lt;strong&gt;不变&lt;/strong&gt;或&lt;strong&gt;不变&lt;/strong&gt; ，如果这两个都不适用。</target>
        </trans-unit>
        <trans-unit id="e3cb78147cdbf377c8068f9d2520c0f0105d61db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt;: an Animal[] is not a Cat[] and a Cat[] is not an Animal[].</source>
          <target state="translated">&lt;strong&gt;不变量&lt;/strong&gt; ：Animal []不是Cat []，Cat []不是Animal []。</target>
        </trans-unit>
        <trans-unit id="debcd99be47f67dd6104bc343fd159ad003d445b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt; &quot;PECS&quot; is from the collection's point of view. If you are &lt;em&gt;only&lt;/em&gt; pulling items from a generic collection, it is a producer and you should use &lt;code&gt;extends&lt;/code&gt;; if you are &lt;em&gt;only&lt;/em&gt; stuffing items in, it is a consumer and you should use &lt;code&gt;super&lt;/code&gt;. If you do both with the same collection, you shouldn't use either &lt;code&gt;extends&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;tl; dr：&lt;/strong&gt; &amp;ldquo; PECS&amp;rdquo;是从集合的角度来看的。 如果您&lt;em&gt;仅从&lt;/em&gt;通用集合中提取项目，则它是生产者，应使用 &lt;code&gt;extends&lt;/code&gt; ； 如果您&lt;em&gt;仅将&lt;/em&gt;物品塞入其中，则它是消费者，您应该使用 &lt;code&gt;super&lt;/code&gt; 。 如果您对同一个集合都进行了处理，则不应同时使用 &lt;code&gt;extends&lt;/code&gt; 或 &lt;code&gt;super&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2f7361433754602bbcf1d9a29aebba3745f665e" translate="yes" xml:space="preserve">
          <source>And don&amp;rsquo;t use a wildcard when you both get and put.</source>
          <target state="translated">而且，当您同时获得和放入时，请勿使用通配符。</target>
        </trans-unit>
        <trans-unit id="92a0466119e2bd899c57cd76250f866ef981b73e" translate="yes" xml:space="preserve">
          <source>As I explain in &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;my answer&lt;/a&gt; to another question, PECS is a mnemonic device  created by Josh Bloch to help remember &lt;strong&gt;P&lt;/strong&gt;roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt;, &lt;strong&gt;C&lt;/strong&gt;onsumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt;.</source>
          <target state="translated">正如我在&lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;回答&lt;/a&gt;另一个问题时所解释的那样，PECS是由乔希&amp;middot;布洛赫（Josh Bloch）创建的助记符设备，用于帮助记住产品，用户的记忆。</target>
        </trans-unit>
        <trans-unit id="ec62dde14f33254d37ae93dbc06b4a2bf234df91" translate="yes" xml:space="preserve">
          <source>At runtime, the type of list can be any type above A: X, Y, Z, ...
The compiler can compile your assignment statement (which seems correct) but, &lt;strong&gt;at runtime&lt;/strong&gt; the type of s (Animal) can be lower in hierarchy than the declared type of the list(which could be Creature, or higher). This is not allowed.</source>
          <target state="translated">在运行时，列表的类型可以是A之上的任何类型：X，Y，Z，...编译器可以编译您的赋值语句（看似正确），但是&lt;strong&gt;在运行时&lt;/strong&gt; ，s（动物）的类型可以较低。层次结构，而不是列表的声明类型（可以为Creature或更高）。 这是不允许的。</target>
        </trans-unit>
        <trans-unit id="e95abb9ccd0e4b2eb4af253d08491c29fdcf4d82" translate="yes" xml:space="preserve">
          <source>But why you cannot read from this list?
(I mean you can get an element out of it, but you cannot assign it to anything other than Object o):</source>
          <target state="translated">但是,为什么你不能从这个列表中读取?我的意思是,你可以从它中得到一个元素,但你不能把它分配给Object o以外的任何东西)。</target>
        </trans-unit>
        <trans-unit id="82addeeaa5366725e5ce90ab68c1203f16326988" translate="yes" xml:space="preserve">
          <source>Can someone explain to me how to use PECS to resolve confusion between &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;?</source>
          <target state="translated">有人可以向我解释如何使用PECS解决 &lt;code&gt;extends&lt;/code&gt; 和 &lt;code&gt;super&lt;/code&gt; 之间的混淆吗？</target>
        </trans-unit>
        <trans-unit id="0de8ffe33606ed73d285b04ba05219d8f320a620" translate="yes" xml:space="preserve">
          <source>Co-variance: &lt;code&gt;? extends T&lt;/code&gt; (the family of all types that are subtypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with an &lt;strong&gt;upper bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;upper&lt;/strong&gt;-most class in the inheritance hierarchy. Use an &lt;code&gt;extends&lt;/code&gt; wildcard when you only &lt;strong&gt;Get&lt;/strong&gt; values out of a structure.</source>
          <target state="translated">协方差： &lt;code&gt;? extends T&lt;/code&gt; （ T的所有类型的家庭）-一个具有&lt;strong&gt;上限&lt;/strong&gt;的通配符。 &lt;code&gt;T&lt;/code&gt; 是继承层次结构中最高级的类。 仅当从结构中&lt;strong&gt;获取&lt;/strong&gt;值时，请使用 &lt;code&gt;extends&lt;/code&gt; 通配符。</target>
        </trans-unit>
        <trans-unit id="792f14ec22afb7780c6d54fb0239c36e3364259f" translate="yes" xml:space="preserve">
          <source>Consumer eat &lt;strong&gt;supper&lt;/strong&gt;(super); Producer &lt;strong&gt;extends&lt;/strong&gt; his parent's factory</source>
          <target state="translated">消费者吃&lt;strong&gt;晚饭&lt;/strong&gt; （超级）； 制片人&lt;strong&gt;扩大&lt;/strong&gt;了父母的工厂</target>
        </trans-unit>
        <trans-unit id="7a39ab9613e3042c6e7e014af6f86ec9338cfe1d" translate="yes" xml:space="preserve">
          <source>Contra-variance: &lt;code&gt;? super T&lt;/code&gt; ( the family of all types that are supertypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with a &lt;strong&gt;lower bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;lower&lt;/strong&gt;-most class in the inheritance hierarchy. Use a &lt;code&gt;super&lt;/code&gt; wildcard when you only &lt;strong&gt;Put&lt;/strong&gt; values into a structure.</source>
          <target state="translated">反差： &lt;code&gt;? super T&lt;/code&gt; （所有类型的家族，它们都是 &lt;code&gt;T&lt;/code&gt; 的超类型）-具有&lt;strong&gt;下限&lt;/strong&gt;的通配符。 &lt;code&gt;T&lt;/code&gt; 是继承层次结构中最&lt;strong&gt;底层的&lt;/strong&gt;类。 仅在&lt;strong&gt;将&lt;/strong&gt;值放入结构中时使用 &lt;code&gt;super&lt;/code&gt; 通配符。</target>
        </trans-unit>
        <trans-unit id="bcb46a38670d5684e40032813ada60b8db782bdc" translate="yes" xml:space="preserve">
          <source>Contravariance: &lt;code&gt;? super MyClass&lt;/code&gt; and</source>
          <target state="translated">矛盾： &lt;code&gt;? super MyClass&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="d937c29e908b0405c909dea8c24ce90e0401dbab" translate="yes" xml:space="preserve">
          <source>Covariance and contravariance</source>
          <target state="translated">协方差和逆方差</target>
        </trans-unit>
        <trans-unit id="f9157e83e5e5e43a86a192add3cbb19c4a902ee5" translate="yes" xml:space="preserve">
          <source>Covariance: &lt;code&gt;? extends MyClass&lt;/code&gt;,</source>
          <target state="translated">协方差： &lt;code&gt;? extends MyClass&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="9d8ce266eaaf430dcb92d6a97b29a357c42b1c8b" translate="yes" xml:space="preserve">
          <source>Covariant types are read-only, while contravariant types are write-only.</source>
          <target state="translated">共变类型是只读的,而反变类型是只写的。</target>
        </trans-unit>
        <trans-unit id="5ff8d99ff85262bb80d9645e82b59d40aa10406d" translate="yes" xml:space="preserve">
          <source>Example in Java:</source>
          <target state="translated">Java中的例子。</target>
        </trans-unit>
        <trans-unit id="52aa4da8fd2e6a5eb9adc65a2a6d779862e9e0fd" translate="yes" xml:space="preserve">
          <source>I came across PECS (short for &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;&lt;/em&gt;) while reading up on generics.</source>
          <target state="translated">在阅读泛型时，我遇到了PECS（ &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; 和Consumer &lt;code&gt;super&lt;/code&gt; &lt;/em&gt;缩写）。</target>
        </trans-unit>
        <trans-unit id="1fa3cb34eb411ebc2ed2bb349bdcd1d434c52545" translate="yes" xml:space="preserve">
          <source>I find &quot;PECS&quot; to be a non-obvious way to think of things regarding who is the &quot;producer&quot; and who is the &quot;consumer&quot;. &quot;PECS&quot; is defined from the perspective of the &lt;em&gt;data collection itself&lt;/em&gt; &amp;ndash; the collection &quot;consumes&quot; if objects are being written &lt;em&gt;to&lt;/em&gt; it (it is consuming objects from calling code), and it &quot;produces&quot; if objects are being read &lt;em&gt;from&lt;/em&gt; it (it is producing objects to some calling code). This is counter to how everything else is named though. Standard Java APIs are named from the perspective of the calling code, not the collection itself. For example, a collection-centric view of &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; should have a method named &quot;receive()&quot; instead of &quot;add()&quot; &amp;ndash; after all, the calling code &lt;em&gt;adds&lt;/em&gt; the element, but the list itself &lt;em&gt;receives&lt;/em&gt; the element.</source>
          <target state="translated">我发现&amp;ldquo; PECS&amp;rdquo;是一种关于谁是&amp;ldquo;生产者&amp;rdquo;和谁是&amp;ldquo;消费者&amp;rdquo;的非显而易见的思考方式。 &amp;ldquo; PECS&amp;rdquo;是从&lt;em&gt;数据集合本身&lt;/em&gt;的角度定义的&amp;ndash;集合&amp;ldquo;消费&amp;rdquo;是否正在写入对象（它正在消耗调用代码中的对象），并且&amp;ldquo;产生&amp;rdquo;如果正在&lt;em&gt;从&lt;/em&gt;其中读取对象（它会&lt;em&gt;从&lt;/em&gt;对象中读取对象）正在产生一些调用代码的对象）。 这与其他所有内容的命名方式相反。 标准Java API是从调用代码的角度命名的，而不是集合本身的名称。 例如，以&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt;为中心的以集合为中心的视图应具有一个名为&amp;ldquo; receive（）&amp;rdquo;而不是&amp;ldquo; add（）&amp;rdquo;的方法&amp;ndash;毕竟，调用代码&lt;em&gt;添加&lt;/em&gt;了元素，但是列表本身&lt;em&gt;接收&lt;/em&gt;了该元素。</target>
        </trans-unit>
        <trans-unit id="f70dc69f10ef0e3707d0f1d782b90670c0277a95" translate="yes" xml:space="preserve">
          <source>I think it's more intuitive, natural and consistent to think of things from the perspective of the code that interacts with the collection &amp;ndash; does the code &quot;read from&quot; or &quot;write to&quot; the collection? Following that, any code &lt;em&gt;writing to&lt;/em&gt; the collection would be the &quot;producer&quot;, and any code &lt;em&gt;reading from&lt;/em&gt; the collection would be the &quot;consumer&quot;.</source>
          <target state="translated">我认为从与集合交互的代码的角度来思考事物是更直观，自然和一致的&amp;ndash;代码是&amp;ldquo;读取&amp;rdquo;还是&amp;ldquo;写入&amp;rdquo;集合？ 之后， &lt;em&gt;写入&lt;/em&gt;集合的任何代码都将成为&amp;ldquo;生产者&amp;rdquo;，而&lt;em&gt;从&lt;/em&gt;集合中&lt;em&gt;读取的&lt;/em&gt;任何代码都将成为&amp;ldquo;消费者&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a242e3017b6b235f2f1cad0170a3da1f29493ddf" translate="yes" xml:space="preserve">
          <source>If you need to satisfy both things, well, don&amp;rsquo;t use any wildcard. As
simple as that.</source>
          <target state="translated">如果您需要同时满足这两个条件，请不要使用任何通配符。 就如此容易。</target>
        </trans-unit>
        <trans-unit id="3ff73982c21deeffcbf3fabff242ab3939dc8f4a" translate="yes" xml:space="preserve">
          <source>Imagine a freight train with freight cars as analogy to a list.</source>
          <target state="translated">想象一下,用货运列车上的货运车厢比喻成清单。</target>
        </trans-unit>
        <trans-unit id="542e956f7c561ae14417ca5dec6f5c660bd4e428" translate="yes" xml:space="preserve">
          <source>In a nutshell, three easy rules to remember PECS:</source>
          <target state="translated">一言以蔽之,三个简单的规则,让你记住PECS。</target>
        </trans-unit>
        <trans-unit id="8a4881b5673370238cca2a8f7cfb01ce09b1a918" translate="yes" xml:space="preserve">
          <source>In practice, the compiler can indeed see at compiletime that you add a B:</source>
          <target state="translated">实际上,编译器在编译时确实可以看到你添加了B。</target>
        </trans-unit>
        <trans-unit id="9e3209315080c6adff01ef992fafde853681897d" translate="yes" xml:space="preserve">
          <source>In the same hierarchy we can try this:</source>
          <target state="translated">在相同的层次结构中,我们可以尝试这样做。</target>
        </trans-unit>
        <trans-unit id="a35991e8ae7b3cdefb743f69bd37997a82ef4165" translate="yes" xml:space="preserve">
          <source>In-variance/Non-variance: &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;? extends Object&lt;/code&gt; - &lt;strong&gt;Unbounded&lt;/strong&gt; Wildcard. It stands for the family of  all types. Use when you both get and put.</source>
          <target state="translated">不变/非不变： 还是 &lt;code&gt;? extends Object&lt;/code&gt; 扩展对象 - &lt;strong&gt;无界&lt;/strong&gt;通配符。 它代表所有类型的家庭。 当您得到和放置时使用。</target>
        </trans-unit>
        <trans-unit id="9f5131c1bce167871d0602aaf46100b50f44f018" translate="yes" xml:space="preserve">
          <source>Invariance/non-variance: &lt;code&gt;MyClass&lt;/code&gt;</source>
          <target state="translated">不变/不变： &lt;code&gt;MyClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34ec57577cc65d5dd83ffb987d46f94e6ba5fec" translate="yes" xml:space="preserve">
          <source>Java Examples:</source>
          <target state="translated">Java的例子。</target>
        </trans-unit>
        <trans-unit id="cdfd21f603272833177a3b5803055b8c4cd7ba10" translate="yes" xml:space="preserve">
          <source>Mutable data types which act as both sources and sinks should be &lt;strong&gt;invariant&lt;/strong&gt;.</source>
          <target state="translated">既充当源又充当宿的可变数据类型应该是&lt;strong&gt;不变的&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="833aacce639487ef510c515bcd37f1d614d40b8d" translate="yes" xml:space="preserve">
          <source>Note that generally you should only be using &lt;code&gt;? extends T&lt;/code&gt; and &lt;code&gt;? super T&lt;/code&gt; for the parameters of some method. Methods should just use &lt;code&gt;T&lt;/code&gt; as the type parameter on a generic return type.</source>
          <target state="translated">注意，通常只应使用 &lt;code&gt;? extends T&lt;/code&gt; 扩展T和 &lt;code&gt;? super T&lt;/code&gt; super T用于某些方法的参数。 方法应仅将 &lt;code&gt;T&lt;/code&gt; 用作通用返回类型的类型参数。</target>
        </trans-unit>
        <trans-unit id="da1cf385e1a0e937aefc400f70bb54b5a032605b" translate="yes" xml:space="preserve">
          <source>Note: wildcard &lt;code&gt;?&lt;/code&gt; means &lt;strong&gt;zero or one time&lt;/strong&gt;, represents an unknown type. The wildcard can be used as the type of a parameter, never used as a type argument for a generic method invocation, a generic class instance creation.(i.e. when used wildcard that reference not used in elsewhere in program like we use &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">注意：通配符 &lt;code&gt;?&lt;/code&gt; 表示&lt;strong&gt;零或一次&lt;/strong&gt; ，表示未知类型。 通配符可以用作参数的类型，而不能用作通用方法调用，通用类实例创建的类型参数。（即，使用通配符时，引用的引用未在程序的其他地方使用，例如我们使用 &lt;code&gt;T&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d60e74b767eba2f856bb3390209305abe069b490" translate="yes" xml:space="preserve">
          <source>PECS (Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;)</source>
          <target state="translated">PECS（生产者 &lt;code&gt;extends&lt;/code&gt; 和消费者 &lt;code&gt;super&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c43068ee8ac3bb66f51a56d8d5430ac6b0250806" translate="yes" xml:space="preserve">
          <source>Read-only data types (sources) can be &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant&lt;/a&gt;&lt;/strong&gt;;</source>
          <target state="translated">只读数据类型（源）可以是&lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;协变的&lt;/a&gt;&lt;/strong&gt; ；</target>
        </trans-unit>
        <trans-unit id="469b1b39e7e8f3f0037efadda112edbc369754e1" translate="yes" xml:space="preserve">
          <source>Remember this:</source>
          <target state="translated">记住这一点。</target>
        </trans-unit>
        <trans-unit id="7818c1bbe997fd084c4a2cfbbf415cbdcfe46a72" translate="yes" xml:space="preserve">
          <source>Since you have a list that can be of type A, B or C &lt;strong&gt;at runtime&lt;/strong&gt;, you cannot add any object of type A, B or C in it because you can end up with a combination that is not allowed in java.</source>
          <target state="translated">由于&lt;strong&gt;在运行时&lt;/strong&gt;您的列表的类型可能为A，B或C，因此您无法在其中添加任何类型为A，B或C的对象，因为最终可能会遇到Java不允许的组合。</target>
        </trans-unit>
        <trans-unit id="84fe0732dfcfb015eb1d8dee6237f1c112b6f071" translate="yes" xml:space="preserve">
          <source>Suppose you have a method that takes as its parameter a collection of things, but you want it to be more flexible than just accepting a &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">假设您有一个方法以事物的集合为参数，但是您希望它比仅接受 &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt; 更加灵活。</target>
        </trans-unit>
        <trans-unit id="155c1d5cc873d9cb3134648b29b4b7d445b4cafa" translate="yes" xml:space="preserve">
          <source>The picture below should explain the concept. Picture courtesy: &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</source>
          <target state="translated">下图应解释该概念。 图片提供： &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7de996a522beb1f3a3e9becda0f3a27d5119e4fb" translate="yes" xml:space="preserve">
          <source>The principles behind this in computer science is called</source>
          <target state="translated">在计算机科学中,这背后的原理被称为</target>
        </trans-unit>
        <trans-unit id="960f5c8f82ec1686cb5c7d0d4fd23d70586ca41e" translate="yes" xml:space="preserve">
          <source>The reasoning here is that unlike &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; can always hold a &lt;code&gt;Thing&lt;/code&gt; no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a &lt;code&gt;Thing&lt;/code&gt; to be added; this is what &lt;code&gt;? super Thing&lt;/code&gt; guarantees.</source>
          <target state="translated">这里的理由是，与 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; 不同 扩展Thing&amp;gt; ， &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; 无论实际的参数化类型是什么， super Thing&amp;gt;始终可以容纳 &lt;code&gt;Thing&lt;/code&gt; 。 在这里，您不必关心列表中已有的内容，只要它可以添加 &lt;code&gt;Thing&lt;/code&gt; 即可。 这是什么 &lt;code&gt;? super Thing&lt;/code&gt; 超级事物保证。</target>
        </trans-unit>
        <trans-unit id="3c3e7f2fd0031e22e8b85562f6b569e88a41d88f" translate="yes" xml:space="preserve">
          <source>The reasoning is that a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; could hold any subtype of &lt;code&gt;Thing&lt;/code&gt;, and thus each element will behave as a &lt;code&gt;Thing&lt;/code&gt; when you perform your operation. (You actually cannot add anything to a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, because you cannot know at runtime which &lt;em&gt;specific&lt;/em&gt; subtype of &lt;code&gt;Thing&lt;/code&gt; the collection holds.)</source>
          <target state="translated">原因是 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; extend Thing&amp;gt;可以包含 &lt;code&gt;Thing&lt;/code&gt; 的任何子类型，因此执行操作时每个元素都将像 &lt;code&gt;Thing&lt;/code&gt; 一样 。 （实际上，您无法将任何东西添加到 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; ，因为您在运行时无法知道该集合包含哪种&lt;em&gt;特定&lt;/em&gt;的 &lt;code&gt;Thing&lt;/code&gt; 子类型。）</target>
        </trans-unit>
        <trans-unit id="f9a08a5a59510bb09cbc96e347b2a0b74f30ce41" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;consumer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">那么列表是一个&lt;strong&gt;使用者&lt;/strong&gt; ，因此您应该使用 &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; 超级事物&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="09c93ca7e342b67eb8cfeb62e6e19e9309b3e92b" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;producer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">那么列表是一个&lt;strong&gt;生产者&lt;/strong&gt; ，因此您应该使用 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; 扩展Thing&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="548dc4b3108193f86c38e631e743ba31ff65b60e" translate="yes" xml:space="preserve">
          <source>This is the clearest, simplest way for me think of extends vs. super:</source>
          <target state="translated">这是对我来说最清晰、最简单的方式来思考extends vs super。</target>
        </trans-unit>
        <trans-unit id="bce949b55a9a429ae77eee6d672e98fa8a23bc02" translate="yes" xml:space="preserve">
          <source>This means that when a parameterized type being passed to a method will &lt;em&gt;produce&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be retrieved from it in some way), &lt;code&gt;? extends T&lt;/code&gt; should be used, since any instance of a subclass of &lt;code&gt;T&lt;/code&gt; is also a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">这意味着当将参数化类型传递给方法时，将&lt;em&gt;产生&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 的实例（它们将以某种方式从中检索） &lt;code&gt;? extends T&lt;/code&gt; 应该使用extends T ，因为 &lt;code&gt;T&lt;/code&gt; 的子类的任何实例也是 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3e9bebc1e518710bd72da25726f74ae21f007bf" translate="yes" xml:space="preserve">
          <source>This principle states that:</source>
          <target state="translated">这一原则规定:</target>
        </trans-unit>
        <trans-unit id="2d3a389d50b6f05444764cd8371ecba25e982422" translate="yes" xml:space="preserve">
          <source>To illustrate this general phenomenon, consider the array type. For the type Animal we can make the type Animal[]</source>
          <target state="translated">为了说明这个一般现象,我们可以考虑数组类型。对于Animal类型,我们可以把类型Animal[]</target>
        </trans-unit>
        <trans-unit id="a364d645d3f36c0aa43f84a2e9243fad90349b7d" translate="yes" xml:space="preserve">
          <source>Use a super wildcard when you only put values into a structure.</source>
          <target state="translated">当你只把值放到一个结构中时,使用超级通配符。</target>
        </trans-unit>
        <trans-unit id="bac4ad848c09d46df23cb670c0a8bb5f0b83f4e8" translate="yes" xml:space="preserve">
          <source>Use an extends wildcard when you only get values out of a structure.</source>
          <target state="translated">当你只从结构中获取值时,使用扩展通配符。</target>
        </trans-unit>
        <trans-unit id="51109f31442287d55f2d09a788b36cab1528d667" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; wildcard if you need to retrieve object of
type &lt;code&gt;T&lt;/code&gt; from a collection.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; 如果需要从集合中检索类型 &lt;code&gt;T&lt;/code&gt; 的对象，则扩展T&amp;gt;通配符。</target>
        </trans-unit>
        <trans-unit id="a9cddb419fff1ae43f081fb34719fbb3ee8a99b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; wildcard if you need to put objects of type &lt;code&gt;T&lt;/code&gt; in
a collection.</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; 如果需要将 &lt;code&gt;T&lt;/code&gt; 类型的对象放入集合中，请使用超级T&amp;gt;通配符。</target>
        </trans-unit>
        <trans-unit id="9fff184eaf718cb02db0d13177ddc1eedad31915" translate="yes" xml:space="preserve">
          <source>Using real life example (with some simplifications):</source>
          <target state="translated">用现实生活中的例子(稍加简化)。</target>
        </trans-unit>
        <trans-unit id="f332c1ae4b070a0a1127f653ab5ef4f751816e05" translate="yes" xml:space="preserve">
          <source>What and why you &lt;strong&gt;can&lt;/strong&gt; add to this list?</source>
          <target state="translated">什么以及为什么&lt;strong&gt;可以&lt;/strong&gt;添加到此列表？</target>
        </trans-unit>
        <trans-unit id="41c5d4cffd059abee38dc9ba81c94b883488b810" translate="yes" xml:space="preserve">
          <source>What is PECS (Producer Extends Consumer Super)</source>
          <target state="translated">什么是PECS(Producer Extends Consumer Super)?</target>
        </trans-unit>
        <trans-unit id="ea561a781fdf8bc0b8a203849b3201824311f82b" translate="yes" xml:space="preserve">
          <source>When a parameterized type being passed to a method will &lt;em&gt;consume&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be passed to it to do something), &lt;code&gt;? super T&lt;/code&gt; should be used because an instance of &lt;code&gt;T&lt;/code&gt; can legally be passed to any method that accepts some supertype of &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; could be used on a &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt;, for example. &lt;code&gt;? extends T&lt;/code&gt; would not work, because a &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; could not operate on a &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当将参数化类型传递给方法时，它将&lt;em&gt;使用&lt;/em&gt; &lt;code&gt;T&lt;/code&gt; 的实例（它们将被传递给它做某事）， 应该使用 &lt;code&gt;? super T&lt;/code&gt; 因为 &lt;code&gt;T&lt;/code&gt; 的实例可以合法地传递给任何接受 &lt;code&gt;T&lt;/code&gt; 的超类型的方法。 例如， &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; 可以用于 &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt; 。 &lt;code&gt;? extends T&lt;/code&gt; 扩展T将不起作用，因为 &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; 不能对 &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4a9baec8126cb0a0170c568b5aea0bc33af82ee" translate="yes" xml:space="preserve">
          <source>Why you cannot add objects that extend &quot;Shark&quot; in this list? like:</source>
          <target state="translated">为什么不能在这个列表中添加 &quot;鲨鱼 &quot;扩展的对象? 比如。</target>
        </trans-unit>
        <trans-unit id="aba9f040c34c97dc5cbd78b7650ba76466656090" translate="yes" xml:space="preserve">
          <source>Within the type system of a programming language, a typing rule</source>
          <target state="translated">在程序设计语言的类型系统中,类型化规则</target>
        </trans-unit>
        <trans-unit id="3fd437c172cae675972484db66485785fdb8066a" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;cannot&lt;/strong&gt; add types above Shark, because &lt;strong&gt;at runtime&lt;/strong&gt; the type of added object can be higher in hierarchy than the declared type of the list(X,Y,Z). This is not allowed.</source>
          <target state="translated">您&lt;strong&gt;不能&lt;/strong&gt;在Shark之​​上添加类型，因为&lt;strong&gt;在运行时&lt;/strong&gt; ，所添加对象的类型在层次结构上可能高于列表（X，Y，Z）的声明类型。 这是不允许的。</target>
        </trans-unit>
        <trans-unit id="bf7625e8d26c2b0876b7150314d221ce86efd5bf" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;put&lt;/strong&gt; a cargo in a freight car if the cargo has &lt;strong&gt;the same or smaller size&lt;/strong&gt; than the freight car = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">如果货物&lt;strong&gt;的大小&lt;/strong&gt;等于&lt;strong&gt;或小于&lt;/strong&gt;货车的&lt;strong&gt;大小，&lt;/strong&gt;您可以&lt;strong&gt;将&lt;/strong&gt;其&lt;strong&gt;放入&lt;/strong&gt;货车 &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt; 超级货运车尺寸&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27ab9c1a017fc3835a2ef84041c847cf90eccfdc" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;unload&lt;/strong&gt; a cargo from a freight car if you have &lt;strong&gt;enough place&lt;/strong&gt; (more than the size of the cargo) in your depot = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">如果您的仓库中有&lt;strong&gt;足够的地方&lt;/strong&gt; （大于货物的大小），您可以从货车上&lt;strong&gt;卸下&lt;/strong&gt;货物 &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt; 扩展DepotSize&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e0731813e0f463d46c84c89f3bedc307fd54c0b7" translate="yes" xml:space="preserve">
          <source>You can add the above types of objects because anything below shark(A,B,C) will always be subtypes of anything above shark (X,Y,Z). Easy to understand.</source>
          <target state="translated">你可以添加上面的对象类型,因为shark(A,B,C)下面的任何东西都将永远是shark(X,Y,Z)上面的东西的子类型。很容易理解。</target>
        </trans-unit>
        <trans-unit id="71c65a7b69693d68a6243f298f05b0b401c6eaa6" translate="yes" xml:space="preserve">
          <source>let's assume this hierarchy:</source>
          <target state="translated">让我们假设这个层次结构。</target>
        </trans-unit>
        <trans-unit id="8166089d4e5973d45afee9a2427f45940137e452" translate="yes" xml:space="preserve">
          <source>mnemonic &amp;rarr; Get and Put principle.</source>
          <target state="translated">助记符&amp;rarr;获取和放置原则。</target>
        </trans-unit>
        <trans-unit id="3fd49bc245a3f4fc5ae457330f6f619971d2fa99" translate="yes" xml:space="preserve">
          <source>more examples</source>
          <target state="translated">更多的例子</target>
        </trans-unit>
        <trans-unit id="9ea651794357473f0e72935b60c04eb349071726" translate="yes" xml:space="preserve">
          <source>write-only data types (sinks) can be &lt;strong&gt;contravariant&lt;/strong&gt;.</source>
          <target state="translated">只写数据类型（接收器）可以是&lt;strong&gt;逆向的&lt;/strong&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
