<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2723397">
    <body>
      <group id="2723397">
        <trans-unit id="94c9db480f47df47185040411f9c95616b012de7" translate="yes" xml:space="preserve">
          <source>(adding an answer because never enough examples with Generics wildcards)</source>
          <target state="translated">(agregando una respuesta porque nunca hay suficientes ejemplos con los comodines genéricos)</target>
        </trans-unit>
        <trans-unit id="7fc5b1f2bc2aaa5e44ba1bb9dfd44f3cf5667ee7" translate="yes" xml:space="preserve">
          <source>*You will say: &quot;OK, but why can't I add HammerSkark in it since it is the smallest type?&quot;. 
Answer: It is the smallest &lt;strong&gt;you&lt;/strong&gt; know. But HammerSkark can be extended too by somebody else and you end up in the same scenario.</source>
          <target state="translated">* Dir&amp;aacute;s: &quot;OK, pero &amp;iquest;por qu&amp;eacute; no puedo agregar HammerSkark ya que es el tipo m&amp;aacute;s peque&amp;ntilde;o?&quot;. Respuesta: es la m&amp;aacute;s peque&amp;ntilde;a &lt;strong&gt;que&lt;/strong&gt; conoces. Pero HammerSkark tambi&amp;eacute;n puede ser extendido por otra persona y terminas en el mismo escenario.</target>
        </trans-unit>
        <trans-unit id="d0174c51c975963bb39f928cbb22a18dcd04a81e" translate="yes" xml:space="preserve">
          <source>...but it has no way to tell if at runtime, your B will be a subtype or supertype of the list type. At runtime the list type can be any of the types A, B, C. So you cannot end up adding HammerSkark (super type) in a list of DeadHammerShark for example.</source>
          <target state="translated">...pero no tiene forma de saber si en tiempo de ejecución,su B será un subtipo o supertipo del tipo de lista.En tiempo de ejecución el tipo de lista puede ser cualquiera de los tipos A,B,C.Así que no puedes terminar agregando HammerSkark (supertipo)en una lista de DeadHammerShark por ejemplo.</target>
        </trans-unit>
        <trans-unit id="f2e963c423df2749b3a7c70442dd69362bec49a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;generics&lt;/a&gt; and &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;examples&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;gen&amp;eacute;ricos&lt;/a&gt; y &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;ejemplos&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a315a9a5442ad1949ff38821a17a1ccc8db468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov substitution principle:&lt;/a&gt;  if S is a subtype of T, then objects of type T may be replaced with objects of type S.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Principio de sustituci&amp;oacute;n de Liskov:&lt;/a&gt; si S es un subtipo de T, entonces los objetos de tipo T pueden reemplazarse por objetos de tipo S.</target>
        </trans-unit>
        <trans-unit id="84afdf7541023e94eb834fb4d55ad29bc2f8f383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is for &lt;strong&gt;reading&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; es para &lt;strong&gt;leer&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5269c2a29c00dc63fdea0178f0dba0903385693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is for &lt;strong&gt;writing&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; es para &lt;strong&gt;escribir&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be8228553ab50b13c364c53f104054de7dff4551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1: You want to go through the collection and do things with each item.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso 1: desea revisar la colecci&amp;oacute;n y hacer cosas con cada elemento.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9feea5d372acd0600581c2c069b1ae87f772a292" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2: You want to add things to the collection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso 2: desea agregar cosas a la colecci&amp;oacute;n.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d73dcd91708bc65136ea3f9780de244628654" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contravariance&lt;/strong&gt;: accept supertypes</source>
          <target state="translated">&lt;strong&gt;Contravarianza&lt;/strong&gt; : aceptar supertipos</target>
        </trans-unit>
        <trans-unit id="db725287369ff6aa40b2dcc280781ca3c22c6f57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Covariance&lt;/strong&gt;: accept subtypes</source>
          <target state="translated">&lt;strong&gt;Covarianza&lt;/strong&gt; : aceptar subtipos</target>
        </trans-unit>
        <trans-unit id="b78afe21d6d96b64853927ebc88812cf92d46c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify CS - Consumer Super:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Aclaremos CS - Consumer Super:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0faa25525aa950fc903ca54e1b7840a251fc29a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify PE - Producer Extends:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Aclaremos PE - El productor extiende:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="243adf487fa4310c42089cb92177f6f400bb37d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To sum up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Para resumir&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2a047cbdd36af0c85dd4fbc1928d9726e2003e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; to read objects of types equal or below T from list.&lt;/strong&gt; We cannot add element to it.</source>
          <target state="translated">&lt;strong&gt;Usamos &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;extiende T&amp;gt; para leer objetos de tipos iguales o inferiores a T de la lista.&lt;/strong&gt; No podemos agregarle elementos.</target>
        </trans-unit>
        <trans-unit id="18d98376587fef5489dd624463bb41fcad1d3558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; to add objects of types equal or below T in list.&lt;/strong&gt; We cannot read from 
it.</source>
          <target state="translated">&lt;strong&gt;Usamos &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;super T&amp;gt; para agregar objetos de tipos iguales o inferiores a T en la lista.&lt;/strong&gt; No podemos leerlo.</target>
        </trans-unit>
        <trans-unit id="b58638ffc0961485f562de00c7e06a30e7ab8e29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bounded&lt;/strong&gt;(i.e. heading toward somewhere) &lt;strong&gt;wildcard&lt;/strong&gt; : There are 3 different flavours of wildcards:</source>
          <target state="translated">&lt;strong&gt;comod&amp;iacute;n&lt;/strong&gt; &lt;strong&gt;delimitado&lt;/strong&gt; (es decir, hacia un lugar): hay 3 tipos diferentes de comodines:</target>
        </trans-unit>
        <trans-unit id="2b032ce66a5b0601c3c15a3a78fd9ab067544c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt; if it reverses this ordering;</source>
          <target state="translated">&lt;strong&gt;contravariante&lt;/strong&gt; si invierte este orden;</target>
        </trans-unit>
        <trans-unit id="758f69c0fcc2f45b755ce9abafa6f6d34557b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt;: an Animal[] is a Cat[];</source>
          <target state="translated">&lt;strong&gt;contravariante&lt;/strong&gt; : un animal [] es un gato [];</target>
        </trans-unit>
        <trans-unit id="0ba67e84f7f5c2e136ea9fe008b4b827013fff1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt; if it preserves the ordering of types (&amp;le;), which orders types from more specific to more generic;</source>
          <target state="translated">&lt;strong&gt;covariante&lt;/strong&gt; si conserva el orden de los tipos (&amp;le;), que ordena los tipos de m&amp;aacute;s espec&amp;iacute;ficos a m&amp;aacute;s gen&amp;eacute;ricos;</target>
        </trans-unit>
        <trans-unit id="57bdc8d44fd6963ecd54c43806d679399b0772cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt;: a Cat[] is an Animal[];</source>
          <target state="translated">&lt;strong&gt;covariante&lt;/strong&gt; : un gato [] es un animal [];</target>
        </trans-unit>
        <trans-unit id="db42607b786d14f36a7aa526ea5fd510862b8086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt; or nonvariant if neither of these applies.</source>
          <target state="translated">&lt;strong&gt;invariante&lt;/strong&gt; o no variable si ninguno de estos aplica.</target>
        </trans-unit>
        <trans-unit id="e3cb78147cdbf377c8068f9d2520c0f0105d61db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt;: an Animal[] is not a Cat[] and a Cat[] is not an Animal[].</source>
          <target state="translated">&lt;strong&gt;invariante&lt;/strong&gt; : un animal [] no es un gato [] y un gato [] no es un animal [].</target>
        </trans-unit>
        <trans-unit id="debcd99be47f67dd6104bc343fd159ad003d445b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt; &quot;PECS&quot; is from the collection's point of view. If you are &lt;em&gt;only&lt;/em&gt; pulling items from a generic collection, it is a producer and you should use &lt;code&gt;extends&lt;/code&gt;; if you are &lt;em&gt;only&lt;/em&gt; stuffing items in, it is a consumer and you should use &lt;code&gt;super&lt;/code&gt;. If you do both with the same collection, you shouldn't use either &lt;code&gt;extends&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;tl; dr:&lt;/strong&gt; &quot;PECS&quot; es desde el punto de vista de la colecci&amp;oacute;n. Si &lt;em&gt;solo&lt;/em&gt; est&amp;aacute; extrayendo elementos de una colecci&amp;oacute;n gen&amp;eacute;rica, es un productor y debe usar &lt;code&gt;extends&lt;/code&gt; ; si &lt;em&gt;solo&lt;/em&gt; est&amp;aacute; cargando art&amp;iacute;culos, es un consumidor y debe usar &lt;code&gt;super&lt;/code&gt; . Si haces ambas cosas con la misma colecci&amp;oacute;n, no deber&amp;iacute;as usar &lt;code&gt;extends&lt;/code&gt; o &lt;code&gt;super&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f7361433754602bbcf1d9a29aebba3745f665e" translate="yes" xml:space="preserve">
          <source>And don&amp;rsquo;t use a wildcard when you both get and put.</source>
          <target state="translated">Y no use un comod&amp;iacute;n cuando ambos se ponen y se ponen.</target>
        </trans-unit>
        <trans-unit id="92a0466119e2bd899c57cd76250f866ef981b73e" translate="yes" xml:space="preserve">
          <source>As I explain in &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;my answer&lt;/a&gt; to another question, PECS is a mnemonic device  created by Josh Bloch to help remember &lt;strong&gt;P&lt;/strong&gt;roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt;, &lt;strong&gt;C&lt;/strong&gt;onsumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt;.</source>
          <target state="translated">Como explico en &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;mi respuesta&lt;/a&gt; a otra pregunta, PECS es un dispositivo mnemot&amp;eacute;cnico creado por Josh Bloch para ayudar a recordar &lt;strong&gt;P&lt;/strong&gt; roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt; , &lt;strong&gt;C&lt;/strong&gt; consumidor &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec62dde14f33254d37ae93dbc06b4a2bf234df91" translate="yes" xml:space="preserve">
          <source>At runtime, the type of list can be any type above A: X, Y, Z, ...
The compiler can compile your assignment statement (which seems correct) but, &lt;strong&gt;at runtime&lt;/strong&gt; the type of s (Animal) can be lower in hierarchy than the declared type of the list(which could be Creature, or higher). This is not allowed.</source>
          <target state="translated">En tiempo de ejecuci&amp;oacute;n, el tipo de lista puede ser de cualquier tipo por encima de A: X, Y, Z, ... El compilador puede compilar su declaraci&amp;oacute;n de asignaci&amp;oacute;n (que parece correcta) pero, &lt;strong&gt;en tiempo de ejecuci&amp;oacute;n,&lt;/strong&gt; el tipo de s (Animal) puede ser menor en jerarqu&amp;iacute;a que el tipo declarado de la lista (que podr&amp;iacute;a ser Criatura o superior). Esto no esta permitido.</target>
        </trans-unit>
        <trans-unit id="e95abb9ccd0e4b2eb4af253d08491c29fdcf4d82" translate="yes" xml:space="preserve">
          <source>But why you cannot read from this list?
(I mean you can get an element out of it, but you cannot assign it to anything other than Object o):</source>
          <target state="translated">¿Pero por qué no puedes leer de esta lista? (Quiero decir que puedes sacar un elemento de ella,pero no puedes asignarlo a otra cosa que no sea el objeto o):</target>
        </trans-unit>
        <trans-unit id="82addeeaa5366725e5ce90ab68c1203f16326988" translate="yes" xml:space="preserve">
          <source>Can someone explain to me how to use PECS to resolve confusion between &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Alguien puede explicarme c&amp;oacute;mo usar PECS para resolver la confusi&amp;oacute;n entre &lt;code&gt;extends&lt;/code&gt; y &lt;code&gt;super&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="0de8ffe33606ed73d285b04ba05219d8f320a620" translate="yes" xml:space="preserve">
          <source>Co-variance: &lt;code&gt;? extends T&lt;/code&gt; (the family of all types that are subtypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with an &lt;strong&gt;upper bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;upper&lt;/strong&gt;-most class in the inheritance hierarchy. Use an &lt;code&gt;extends&lt;/code&gt; wildcard when you only &lt;strong&gt;Get&lt;/strong&gt; values out of a structure.</source>
          <target state="translated">Covarianza &lt;code&gt;? extends T&lt;/code&gt; extiende T (la familia de todos los tipos que son subtipos de &lt;code&gt;T&lt;/code&gt; ): un comod&amp;iacute;n con un &lt;strong&gt;l&amp;iacute;mite superior&lt;/strong&gt; . &lt;code&gt;T&lt;/code&gt; es la clase &lt;strong&gt;superior&lt;/strong&gt; en la jerarqu&amp;iacute;a de herencia. Use un comod&amp;iacute;n &lt;code&gt;extends&lt;/code&gt; cuando solo &lt;strong&gt;obtenga&lt;/strong&gt; valores de una estructura.</target>
        </trans-unit>
        <trans-unit id="792f14ec22afb7780c6d54fb0239c36e3364259f" translate="yes" xml:space="preserve">
          <source>Consumer eat &lt;strong&gt;supper&lt;/strong&gt;(super); Producer &lt;strong&gt;extends&lt;/strong&gt; his parent's factory</source>
          <target state="translated">El consumidor come la &lt;strong&gt;cena&lt;/strong&gt; (super); El productor &lt;strong&gt;extiende&lt;/strong&gt; la f&amp;aacute;brica de sus padres.</target>
        </trans-unit>
        <trans-unit id="7a39ab9613e3042c6e7e014af6f86ec9338cfe1d" translate="yes" xml:space="preserve">
          <source>Contra-variance: &lt;code&gt;? super T&lt;/code&gt; ( the family of all types that are supertypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with a &lt;strong&gt;lower bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;lower&lt;/strong&gt;-most class in the inheritance hierarchy. Use a &lt;code&gt;super&lt;/code&gt; wildcard when you only &lt;strong&gt;Put&lt;/strong&gt; values into a structure.</source>
          <target state="translated">Contra-varianza &lt;code&gt;? super T&lt;/code&gt; super T (la familia de todos los tipos que son supertipos de &lt;code&gt;T&lt;/code&gt; ): un comod&amp;iacute;n con un &lt;strong&gt;l&amp;iacute;mite inferior&lt;/strong&gt; . &lt;code&gt;T&lt;/code&gt; es la clase &lt;strong&gt;m&amp;aacute;s&lt;/strong&gt; baja en la jerarqu&amp;iacute;a de herencia. Use un &lt;code&gt;super&lt;/code&gt; comod&amp;iacute;n cuando solo &lt;strong&gt;ponga&lt;/strong&gt; valores en una estructura.</target>
        </trans-unit>
        <trans-unit id="bcb46a38670d5684e40032813ada60b8db782bdc" translate="yes" xml:space="preserve">
          <source>Contravariance: &lt;code&gt;? super MyClass&lt;/code&gt; and</source>
          <target state="translated">Contravarianza &lt;code&gt;? super MyClass&lt;/code&gt; Super MyClass y</target>
        </trans-unit>
        <trans-unit id="d937c29e908b0405c909dea8c24ce90e0401dbab" translate="yes" xml:space="preserve">
          <source>Covariance and contravariance</source>
          <target state="translated">Covarianza y contravarianza</target>
        </trans-unit>
        <trans-unit id="f9157e83e5e5e43a86a192add3cbb19c4a902ee5" translate="yes" xml:space="preserve">
          <source>Covariance: &lt;code&gt;? extends MyClass&lt;/code&gt;,</source>
          <target state="translated">Covarianza &lt;code&gt;? extends MyClass&lt;/code&gt; extiende MyClass ,</target>
        </trans-unit>
        <trans-unit id="9d8ce266eaaf430dcb92d6a97b29a357c42b1c8b" translate="yes" xml:space="preserve">
          <source>Covariant types are read-only, while contravariant types are write-only.</source>
          <target state="translated">Los tipos covariantes son de sólo lectura,mientras que los tipos contrarios son de sólo escritura.</target>
        </trans-unit>
        <trans-unit id="5ff8d99ff85262bb80d9645e82b59d40aa10406d" translate="yes" xml:space="preserve">
          <source>Example in Java:</source>
          <target state="translated">Ejemplo en Java:</target>
        </trans-unit>
        <trans-unit id="52aa4da8fd2e6a5eb9adc65a2a6d779862e9e0fd" translate="yes" xml:space="preserve">
          <source>I came across PECS (short for &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;&lt;/em&gt;) while reading up on generics.</source>
          <target state="translated">Me encontr&amp;eacute; con PECS (abreviatura de &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; y Consumer &lt;code&gt;super&lt;/code&gt; &lt;/em&gt; ) mientras le&amp;iacute;a sobre gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="1fa3cb34eb411ebc2ed2bb349bdcd1d434c52545" translate="yes" xml:space="preserve">
          <source>I find &quot;PECS&quot; to be a non-obvious way to think of things regarding who is the &quot;producer&quot; and who is the &quot;consumer&quot;. &quot;PECS&quot; is defined from the perspective of the &lt;em&gt;data collection itself&lt;/em&gt; &amp;ndash; the collection &quot;consumes&quot; if objects are being written &lt;em&gt;to&lt;/em&gt; it (it is consuming objects from calling code), and it &quot;produces&quot; if objects are being read &lt;em&gt;from&lt;/em&gt; it (it is producing objects to some calling code). This is counter to how everything else is named though. Standard Java APIs are named from the perspective of the calling code, not the collection itself. For example, a collection-centric view of &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; should have a method named &quot;receive()&quot; instead of &quot;add()&quot; &amp;ndash; after all, the calling code &lt;em&gt;adds&lt;/em&gt; the element, but the list itself &lt;em&gt;receives&lt;/em&gt; the element.</source>
          <target state="translated">Considero que &quot;PECS&quot; es una forma no obvia de pensar sobre qui&amp;eacute;n es el &quot;productor&quot; y qui&amp;eacute;n es el &quot;consumidor&quot;. &quot;PECS&quot; se define desde la perspectiva de la &lt;em&gt;recopilaci&amp;oacute;n de datos en s&amp;iacute; misma&lt;/em&gt; : la recopilaci&amp;oacute;n &quot;consume&quot; si se le escriben objetos (est&amp;aacute; consumiendo objetos del c&amp;oacute;digo de llamada) y &quot;produce&quot; si se le leen objetos (se est&amp;aacute; produciendo objetos para alg&amp;uacute;n c&amp;oacute;digo de llamada). Sin embargo, esto es contrario a c&amp;oacute;mo se nombra todo lo dem&amp;aacute;s. Las API Java est&amp;aacute;ndar se nombran desde la perspectiva del c&amp;oacute;digo de llamada, no desde la colecci&amp;oacute;n en s&amp;iacute;. Por ejemplo, una vista centrada en la colecci&amp;oacute;n de &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; deber&amp;iacute;a tener un m&amp;eacute;todo llamado &quot;recibir ()&quot; en lugar de &quot;agregar ()&quot; - despu&amp;eacute;s de todo, el c&amp;oacute;digo de llamada &lt;em&gt;agrega&lt;/em&gt; el elemento, pero la lista misma &lt;em&gt;recibe&lt;/em&gt; el elemento.</target>
        </trans-unit>
        <trans-unit id="f70dc69f10ef0e3707d0f1d782b90670c0277a95" translate="yes" xml:space="preserve">
          <source>I think it's more intuitive, natural and consistent to think of things from the perspective of the code that interacts with the collection &amp;ndash; does the code &quot;read from&quot; or &quot;write to&quot; the collection? Following that, any code &lt;em&gt;writing to&lt;/em&gt; the collection would be the &quot;producer&quot;, and any code &lt;em&gt;reading from&lt;/em&gt; the collection would be the &quot;consumer&quot;.</source>
          <target state="translated">Creo que es m&amp;aacute;s intuitivo, natural y coherente pensar en las cosas desde la perspectiva del c&amp;oacute;digo que interact&amp;uacute;a con la colecci&amp;oacute;n: &amp;iquest;el c&amp;oacute;digo &quot;lee&quot; o &quot;escribe en&quot; la colecci&amp;oacute;n? Despu&amp;eacute;s de eso, cualquier c&amp;oacute;digo &lt;em&gt;escrito en&lt;/em&gt; la colecci&amp;oacute;n ser&amp;iacute;a el &quot;productor&quot;, y cualquier &lt;em&gt;lectura de&lt;/em&gt; c&amp;oacute;digo &lt;em&gt;de&lt;/em&gt; la colecci&amp;oacute;n ser&amp;iacute;a el &quot;consumidor&quot;.</target>
        </trans-unit>
        <trans-unit id="a242e3017b6b235f2f1cad0170a3da1f29493ddf" translate="yes" xml:space="preserve">
          <source>If you need to satisfy both things, well, don&amp;rsquo;t use any wildcard. As
simple as that.</source>
          <target state="translated">Si necesita satisfacer ambas cosas, bueno, no use ning&amp;uacute;n comod&amp;iacute;n. Tan sencillo como eso.</target>
        </trans-unit>
        <trans-unit id="3ff73982c21deeffcbf3fabff242ab3939dc8f4a" translate="yes" xml:space="preserve">
          <source>Imagine a freight train with freight cars as analogy to a list.</source>
          <target state="translated">Imagina un tren de carga con vagones de carga como analogía a una lista.</target>
        </trans-unit>
        <trans-unit id="542e956f7c561ae14417ca5dec6f5c660bd4e428" translate="yes" xml:space="preserve">
          <source>In a nutshell, three easy rules to remember PECS:</source>
          <target state="translated">En resumen,tres reglas fáciles de recordar PECS:</target>
        </trans-unit>
        <trans-unit id="8a4881b5673370238cca2a8f7cfb01ce09b1a918" translate="yes" xml:space="preserve">
          <source>In practice, the compiler can indeed see at compiletime that you add a B:</source>
          <target state="translated">En la práctica,el compilador puede ver en tiempo de compilación que usted añade una B:</target>
        </trans-unit>
        <trans-unit id="9e3209315080c6adff01ef992fafde853681897d" translate="yes" xml:space="preserve">
          <source>In the same hierarchy we can try this:</source>
          <target state="translated">En la misma jerarquía podemos intentar esto:</target>
        </trans-unit>
        <trans-unit id="a35991e8ae7b3cdefb743f69bd37997a82ef4165" translate="yes" xml:space="preserve">
          <source>In-variance/Non-variance: &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;? extends Object&lt;/code&gt; - &lt;strong&gt;Unbounded&lt;/strong&gt; Wildcard. It stands for the family of  all types. Use when you both get and put.</source>
          <target state="translated">En varianza / no varianza &lt;code&gt;?&lt;/code&gt; o &lt;code&gt;? extends Object&lt;/code&gt; - Comod&amp;iacute;n &lt;strong&gt;ilimitado&lt;/strong&gt; . Es sin&amp;oacute;nimo de la familia de todo tipo. &amp;Uacute;selo cuando ambos consiguen y ponen.</target>
        </trans-unit>
        <trans-unit id="9f5131c1bce167871d0602aaf46100b50f44f018" translate="yes" xml:space="preserve">
          <source>Invariance/non-variance: &lt;code&gt;MyClass&lt;/code&gt;</source>
          <target state="translated">Invarianza / no varianza: &lt;code&gt;MyClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34ec57577cc65d5dd83ffb987d46f94e6ba5fec" translate="yes" xml:space="preserve">
          <source>Java Examples:</source>
          <target state="translated">Ejemplos de Java:</target>
        </trans-unit>
        <trans-unit id="cdfd21f603272833177a3b5803055b8c4cd7ba10" translate="yes" xml:space="preserve">
          <source>Mutable data types which act as both sources and sinks should be &lt;strong&gt;invariant&lt;/strong&gt;.</source>
          <target state="translated">Los tipos de datos mutables que act&amp;uacute;an como fuentes y sumideros deben ser &lt;strong&gt;invariables&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="833aacce639487ef510c515bcd37f1d614d40b8d" translate="yes" xml:space="preserve">
          <source>Note that generally you should only be using &lt;code&gt;? extends T&lt;/code&gt; and &lt;code&gt;? super T&lt;/code&gt; for the parameters of some method. Methods should just use &lt;code&gt;T&lt;/code&gt; as the type parameter on a generic return type.</source>
          <target state="translated">Tenga en cuenta que, en general, solo debe usar &lt;code&gt;? extends T&lt;/code&gt; extiende T y &lt;code&gt;? super T&lt;/code&gt; super T para los par&amp;aacute;metros de alg&amp;uacute;n m&amp;eacute;todo. Los m&amp;eacute;todos solo deben usar &lt;code&gt;T&lt;/code&gt; como par&amp;aacute;metro de tipo en un tipo de retorno gen&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="da1cf385e1a0e937aefc400f70bb54b5a032605b" translate="yes" xml:space="preserve">
          <source>Note: wildcard &lt;code&gt;?&lt;/code&gt; means &lt;strong&gt;zero or one time&lt;/strong&gt;, represents an unknown type. The wildcard can be used as the type of a parameter, never used as a type argument for a generic method invocation, a generic class instance creation.(i.e. when used wildcard that reference not used in elsewhere in program like we use &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">Nota: comod&amp;iacute;n &lt;code&gt;?&lt;/code&gt; significa &lt;strong&gt;cero o una vez&lt;/strong&gt; , representa un tipo desconocido. El comod&amp;iacute;n puede usarse como el tipo de un par&amp;aacute;metro, nunca usado como argumento de tipo para una invocaci&amp;oacute;n de m&amp;eacute;todo gen&amp;eacute;rico, una creaci&amp;oacute;n de instancia de clase gen&amp;eacute;rica (es decir, cuando se usa el comod&amp;iacute;n esa referencia que no se usa en otra parte del programa como usamos &lt;code&gt;T&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d60e74b767eba2f856bb3390209305abe069b490" translate="yes" xml:space="preserve">
          <source>PECS (Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;)</source>
          <target state="translated">PECS (productor se &lt;code&gt;extends&lt;/code&gt; y consumidor &lt;code&gt;super&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c43068ee8ac3bb66f51a56d8d5430ac6b0250806" translate="yes" xml:space="preserve">
          <source>Read-only data types (sources) can be &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant&lt;/a&gt;&lt;/strong&gt;;</source>
          <target state="translated">Los tipos de datos de solo lectura (or&amp;iacute;genes) pueden ser &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariantes&lt;/a&gt;&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="469b1b39e7e8f3f0037efadda112edbc369754e1" translate="yes" xml:space="preserve">
          <source>Remember this:</source>
          <target state="translated">Recuerda esto:</target>
        </trans-unit>
        <trans-unit id="7818c1bbe997fd084c4a2cfbbf415cbdcfe46a72" translate="yes" xml:space="preserve">
          <source>Since you have a list that can be of type A, B or C &lt;strong&gt;at runtime&lt;/strong&gt;, you cannot add any object of type A, B or C in it because you can end up with a combination that is not allowed in java.</source>
          <target state="translated">Dado que tiene una lista que puede ser de tipo A, B o C &lt;strong&gt;en tiempo de ejecuci&amp;oacute;n&lt;/strong&gt; , no puede agregar ning&amp;uacute;n objeto de tipo A, B o C porque puede terminar con una combinaci&amp;oacute;n que no est&amp;aacute; permitida en Java.</target>
        </trans-unit>
        <trans-unit id="84fe0732dfcfb015eb1d8dee6237f1c112b6f071" translate="yes" xml:space="preserve">
          <source>Suppose you have a method that takes as its parameter a collection of things, but you want it to be more flexible than just accepting a &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Supongamos que tiene un m&amp;eacute;todo que toma como par&amp;aacute;metro una colecci&amp;oacute;n de cosas, pero desea que sea m&amp;aacute;s flexible que simplemente aceptar una &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155c1d5cc873d9cb3134648b29b4b7d445b4cafa" translate="yes" xml:space="preserve">
          <source>The picture below should explain the concept. Picture courtesy: &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</source>
          <target state="translated">La siguiente imagen deber&amp;iacute;a explicar el concepto. Imagen cortes&amp;iacute;a: &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7de996a522beb1f3a3e9becda0f3a27d5119e4fb" translate="yes" xml:space="preserve">
          <source>The principles behind this in computer science is called</source>
          <target state="translated">Los principios detrás de esto en la informática se llaman</target>
        </trans-unit>
        <trans-unit id="960f5c8f82ec1686cb5c7d0d4fd23d70586ca41e" translate="yes" xml:space="preserve">
          <source>The reasoning here is that unlike &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; can always hold a &lt;code&gt;Thing&lt;/code&gt; no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a &lt;code&gt;Thing&lt;/code&gt; to be added; this is what &lt;code&gt;? super Thing&lt;/code&gt; guarantees.</source>
          <target state="translated">El razonamiento aqu&amp;iacute; es que, a diferencia de &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; extiende Cosa&amp;gt; , &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; super Thing&amp;gt; siempre puede contener un &lt;code&gt;Thing&lt;/code&gt; sin importar el tipo parametrizado real. Aqu&amp;iacute; no le importa lo que ya est&amp;aacute; en la lista, siempre y cuando permita que se agregue una &lt;code&gt;Thing&lt;/code&gt; ; esto es que &lt;code&gt;? super Thing&lt;/code&gt; Super Thing garantiza.</target>
        </trans-unit>
        <trans-unit id="3c3e7f2fd0031e22e8b85562f6b569e88a41d88f" translate="yes" xml:space="preserve">
          <source>The reasoning is that a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; could hold any subtype of &lt;code&gt;Thing&lt;/code&gt;, and thus each element will behave as a &lt;code&gt;Thing&lt;/code&gt; when you perform your operation. (You actually cannot add anything to a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, because you cannot know at runtime which &lt;em&gt;specific&lt;/em&gt; subtype of &lt;code&gt;Thing&lt;/code&gt; the collection holds.)</source>
          <target state="translated">El razonamiento es que una &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; Extiende Thing&amp;gt; podr&amp;iacute;a contener cualquier subtipo de &lt;code&gt;Thing&lt;/code&gt; y, por lo tanto, cada elemento se comportar&amp;aacute; como &lt;code&gt;Thing&lt;/code&gt; cuando realice su operaci&amp;oacute;n. (En realidad, no puede agregar nada a una &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; , porque no puede saber en tiempo de ejecuci&amp;oacute;n qu&amp;eacute; subtipo &lt;em&gt;espec&amp;iacute;fico&lt;/em&gt; de &lt;code&gt;Thing&lt;/code&gt; contiene la colecci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="f9a08a5a59510bb09cbc96e347b2a0b74f30ce41" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;consumer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Entonces la lista es un &lt;strong&gt;consumidor&lt;/strong&gt; , por lo que debe usar una &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; super cosa&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="09c93ca7e342b67eb8cfeb62e6e19e9309b3e92b" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;producer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Entonces la lista es un &lt;strong&gt;productor&lt;/strong&gt; , por lo que debe usar una &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; extiende Cosa&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="548dc4b3108193f86c38e631e743ba31ff65b60e" translate="yes" xml:space="preserve">
          <source>This is the clearest, simplest way for me think of extends vs. super:</source>
          <target state="translated">Esta es la forma más clara y simple para mí de pensar en &quot;extended&quot; vs.&quot;super&quot;:</target>
        </trans-unit>
        <trans-unit id="bce949b55a9a429ae77eee6d672e98fa8a23bc02" translate="yes" xml:space="preserve">
          <source>This means that when a parameterized type being passed to a method will &lt;em&gt;produce&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be retrieved from it in some way), &lt;code&gt;? extends T&lt;/code&gt; should be used, since any instance of a subclass of &lt;code&gt;T&lt;/code&gt; is also a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Esto significa que cuando un tipo parametrizado que se pasa a un m&amp;eacute;todo &lt;em&gt;producir&amp;aacute;&lt;/em&gt; instancias de &lt;code&gt;T&lt;/code&gt; (se recuperar&amp;aacute;n de alguna manera) &lt;code&gt;? extends T&lt;/code&gt; se debe usar T , ya que cualquier instancia de una subclase de &lt;code&gt;T&lt;/code&gt; tambi&amp;eacute;n es una &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3e9bebc1e518710bd72da25726f74ae21f007bf" translate="yes" xml:space="preserve">
          <source>This principle states that:</source>
          <target state="translated">Este principio establece que:</target>
        </trans-unit>
        <trans-unit id="2d3a389d50b6f05444764cd8371ecba25e982422" translate="yes" xml:space="preserve">
          <source>To illustrate this general phenomenon, consider the array type. For the type Animal we can make the type Animal[]</source>
          <target state="translated">Para ilustrar este fenómeno general,consideremos el tipo de matriz.Para el tipo Animal podemos hacer el tipo Animal[]</target>
        </trans-unit>
        <trans-unit id="a364d645d3f36c0aa43f84a2e9243fad90349b7d" translate="yes" xml:space="preserve">
          <source>Use a super wildcard when you only put values into a structure.</source>
          <target state="translated">Usa un súper comodín cuando sólo pones valores en una estructura.</target>
        </trans-unit>
        <trans-unit id="bac4ad848c09d46df23cb670c0a8bb5f0b83f4e8" translate="yes" xml:space="preserve">
          <source>Use an extends wildcard when you only get values out of a structure.</source>
          <target state="translated">Usar un comodín de extensión cuando sólo se obtienen valores de una estructura.</target>
        </trans-unit>
        <trans-unit id="51109f31442287d55f2d09a788b36cab1528d667" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; wildcard if you need to retrieve object of
type &lt;code&gt;T&lt;/code&gt; from a collection.</source>
          <target state="translated">Usa el &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; extiende el comod&amp;iacute;n T&amp;gt; si necesita recuperar un objeto de tipo &lt;code&gt;T&lt;/code&gt; de una colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a9cddb419fff1ae43f081fb34719fbb3ee8a99b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; wildcard if you need to put objects of type &lt;code&gt;T&lt;/code&gt; in
a collection.</source>
          <target state="translated">Usa el &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; super T&amp;gt; comod&amp;iacute;n si necesita poner objetos de tipo &lt;code&gt;T&lt;/code&gt; en una colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9fff184eaf718cb02db0d13177ddc1eedad31915" translate="yes" xml:space="preserve">
          <source>Using real life example (with some simplifications):</source>
          <target state="translated">Usando el ejemplo de la vida real (con algunas simplificaciones):</target>
        </trans-unit>
        <trans-unit id="f332c1ae4b070a0a1127f653ab5ef4f751816e05" translate="yes" xml:space="preserve">
          <source>What and why you &lt;strong&gt;can&lt;/strong&gt; add to this list?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; y por qu&amp;eacute; &lt;strong&gt;puedes&lt;/strong&gt; agregar a esta lista?</target>
        </trans-unit>
        <trans-unit id="41c5d4cffd059abee38dc9ba81c94b883488b810" translate="yes" xml:space="preserve">
          <source>What is PECS (Producer Extends Consumer Super)</source>
          <target state="translated">¿Qué es PECS (Producer Extends Consumer Super)</target>
        </trans-unit>
        <trans-unit id="ea561a781fdf8bc0b8a203849b3201824311f82b" translate="yes" xml:space="preserve">
          <source>When a parameterized type being passed to a method will &lt;em&gt;consume&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be passed to it to do something), &lt;code&gt;? super T&lt;/code&gt; should be used because an instance of &lt;code&gt;T&lt;/code&gt; can legally be passed to any method that accepts some supertype of &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; could be used on a &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt;, for example. &lt;code&gt;? extends T&lt;/code&gt; would not work, because a &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; could not operate on a &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando un tipo parametrizado que se pasa a un m&amp;eacute;todo &lt;em&gt;consumir&amp;aacute;&lt;/em&gt; instancias de &lt;code&gt;T&lt;/code&gt; (se pasar&amp;aacute; a &amp;eacute;l para hacer algo) &lt;code&gt;? super T&lt;/code&gt; se debe usar super T porque una instancia de &lt;code&gt;T&lt;/code&gt; puede pasar legalmente a cualquier m&amp;eacute;todo que acepte alg&amp;uacute;n supertipo de &lt;code&gt;T&lt;/code&gt; . Un &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; podr&amp;iacute;a usarse en una &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt; , por ejemplo. &lt;code&gt;? extends T&lt;/code&gt; extiende T no funcionar&amp;iacute;a, porque un &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; no podr&amp;iacute;a funcionar en una &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a9baec8126cb0a0170c568b5aea0bc33af82ee" translate="yes" xml:space="preserve">
          <source>Why you cannot add objects that extend &quot;Shark&quot; in this list? like:</source>
          <target state="translated">¿Por qué no puedes añadir objetos que extiendan &quot;Tiburón&quot; en esta lista? como:</target>
        </trans-unit>
        <trans-unit id="aba9f040c34c97dc5cbd78b7650ba76466656090" translate="yes" xml:space="preserve">
          <source>Within the type system of a programming language, a typing rule</source>
          <target state="translated">Dentro del sistema de tipos de un lenguaje de programación,una regla de mecanografía</target>
        </trans-unit>
        <trans-unit id="3fd437c172cae675972484db66485785fdb8066a" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;cannot&lt;/strong&gt; add types above Shark, because &lt;strong&gt;at runtime&lt;/strong&gt; the type of added object can be higher in hierarchy than the declared type of the list(X,Y,Z). This is not allowed.</source>
          <target state="translated">No &lt;strong&gt;puede&lt;/strong&gt; agregar tipos por encima de Shark, porque &lt;strong&gt;en tiempo de ejecuci&amp;oacute;n&lt;/strong&gt; el tipo de objeto agregado puede tener una jerarqu&amp;iacute;a m&amp;aacute;s alta que el tipo declarado de la lista (X, Y, Z). Esto no esta permitido.</target>
        </trans-unit>
        <trans-unit id="bf7625e8d26c2b0876b7150314d221ce86efd5bf" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;put&lt;/strong&gt; a cargo in a freight car if the cargo has &lt;strong&gt;the same or smaller size&lt;/strong&gt; than the freight car = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Puede &lt;strong&gt;poner&lt;/strong&gt; una carga en un vag&amp;oacute;n de carga si la carga tiene &lt;strong&gt;el mismo tama&amp;ntilde;o o menor&lt;/strong&gt; que el vag&amp;oacute;n de carga = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt; super FreightCarSize&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27ab9c1a017fc3835a2ef84041c847cf90eccfdc" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;unload&lt;/strong&gt; a cargo from a freight car if you have &lt;strong&gt;enough place&lt;/strong&gt; (more than the size of the cargo) in your depot = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Puede &lt;strong&gt;descargar&lt;/strong&gt; una carga de un vag&amp;oacute;n de carga si tiene &lt;strong&gt;suficiente lugar&lt;/strong&gt; (m&amp;aacute;s del tama&amp;ntilde;o de la carga) en su dep&amp;oacute;sito = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt; extiende DepotSize&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e0731813e0f463d46c84c89f3bedc307fd54c0b7" translate="yes" xml:space="preserve">
          <source>You can add the above types of objects because anything below shark(A,B,C) will always be subtypes of anything above shark (X,Y,Z). Easy to understand.</source>
          <target state="translated">Puedes añadir los tipos de objetos anteriores porque todo lo que esté por debajo de tiburón (A,B,C)siempre será un subtipo de todo lo que esté por encima de tiburón (X,Y,Z).Es fácil de entender.</target>
        </trans-unit>
        <trans-unit id="71c65a7b69693d68a6243f298f05b0b401c6eaa6" translate="yes" xml:space="preserve">
          <source>let's assume this hierarchy:</source>
          <target state="translated">asumamos esta jerarquía:</target>
        </trans-unit>
        <trans-unit id="8166089d4e5973d45afee9a2427f45940137e452" translate="yes" xml:space="preserve">
          <source>mnemonic &amp;rarr; Get and Put principle.</source>
          <target state="translated">mnem&amp;oacute;nico &amp;rarr; Obtener y poner principio.</target>
        </trans-unit>
        <trans-unit id="3fd49bc245a3f4fc5ae457330f6f619971d2fa99" translate="yes" xml:space="preserve">
          <source>more examples</source>
          <target state="translated">más ejemplos</target>
        </trans-unit>
        <trans-unit id="9ea651794357473f0e72935b60c04eb349071726" translate="yes" xml:space="preserve">
          <source>write-only data types (sinks) can be &lt;strong&gt;contravariant&lt;/strong&gt;.</source>
          <target state="translated">los tipos de datos de solo escritura (sumideros) pueden ser &lt;strong&gt;contravariantes&lt;/strong&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
