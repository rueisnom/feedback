<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2723397">
    <body>
      <group id="2723397">
        <trans-unit id="94c9db480f47df47185040411f9c95616b012de7" translate="yes" xml:space="preserve">
          <source>(adding an answer because never enough examples with Generics wildcards)</source>
          <target state="translated">(Generics 와일드 카드가 포함 된 예제가 충분하지 않기 때문에 답변 추가)</target>
        </trans-unit>
        <trans-unit id="7fc5b1f2bc2aaa5e44ba1bb9dfd44f3cf5667ee7" translate="yes" xml:space="preserve">
          <source>*You will say: &quot;OK, but why can't I add HammerSkark in it since it is the smallest type?&quot;. 
Answer: It is the smallest &lt;strong&gt;you&lt;/strong&gt; know. But HammerSkark can be extended too by somebody else and you end up in the same scenario.</source>
          <target state="translated">* 당신은 말할 것입니다 : &quot;하지만 가장 작은 타입이기 때문에 왜 HammerSkark를 추가 할 수 없습니까?&quot;. 답 : 아는 것이 가장 작습니다. 그러나 HammerSkark는 다른 사람에 의해 확장 될 수 있으며 같은 시나리오에서 끝납니다.</target>
        </trans-unit>
        <trans-unit id="d0174c51c975963bb39f928cbb22a18dcd04a81e" translate="yes" xml:space="preserve">
          <source>...but it has no way to tell if at runtime, your B will be a subtype or supertype of the list type. At runtime the list type can be any of the types A, B, C. So you cannot end up adding HammerSkark (super type) in a list of DeadHammerShark for example.</source>
          <target state="translated">...하지만 런타임에 B가 목록 유형의 하위 유형 또는 상위 유형인지 여부를 알 수있는 방법이 없습니다. 런타임시 목록 유형은 A, B, C 유형 중 하나 일 수 있습니다. 따라서 예를 들어 DeadHammerShark 목록에 HammerSkark (슈퍼 유형)를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2e963c423df2749b3a7c70442dd69362bec49a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;generics&lt;/a&gt; and &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;examples&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;제네릭&lt;/a&gt; 과 &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;예제&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a315a9a5442ad1949ff38821a17a1ccc8db468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov substitution principle:&lt;/a&gt;  if S is a subtype of T, then objects of type T may be replaced with objects of type S.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov 대체 원리 :&lt;/a&gt; S가 T의 하위 유형 인 경우 T 유형의 객체는 S 유형의 객체로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84afdf7541023e94eb834fb4d55ad29bc2f8f383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is for &lt;strong&gt;reading&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 은 &lt;strong&gt;읽기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5269c2a29c00dc63fdea0178f0dba0903385693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is for &lt;strong&gt;writing&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; &lt;strong&gt;쓰기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be8228553ab50b13c364c53f104054de7dff4551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1: You want to go through the collection and do things with each item.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사례 1 : 컬렉션을 살펴보고 각 항목으로 작업을 수행하려고합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9feea5d372acd0600581c2c069b1ae87f772a292" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2: You want to add things to the collection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사례 2 : 컬렉션에 항목을 추가하려고합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d73dcd91708bc65136ea3f9780de244628654" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contravariance&lt;/strong&gt;: accept supertypes</source>
          <target state="translated">&lt;strong&gt;불일치&lt;/strong&gt; : 수퍼 타입 ​​허용</target>
        </trans-unit>
        <trans-unit id="db725287369ff6aa40b2dcc280781ca3c22c6f57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Covariance&lt;/strong&gt;: accept subtypes</source>
          <target state="translated">&lt;strong&gt;공분산&lt;/strong&gt; : 하위 유형 허용</target>
        </trans-unit>
        <trans-unit id="b78afe21d6d96b64853927ebc88812cf92d46c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify CS - Consumer Super:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CS-Consumer Super를 명확히하자 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0faa25525aa950fc903ca54e1b7840a251fc29a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify PE - Producer Extends:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PE를 명확히합시다-생산자 확장 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="243adf487fa4310c42089cb92177f6f400bb37d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To sum up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;요약하자면&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2a047cbdd36af0c85dd4fbc1928d9726e2003e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; to read objects of types equal or below T from list.&lt;/strong&gt; We cannot add element to it.</source>
          <target state="translated">&lt;strong&gt;우리는 &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;T&amp;gt; 를 확장 하여 목록에서 T 이하의 유형의 객체를 읽습니다.&lt;/strong&gt; 요소를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="18d98376587fef5489dd624463bb41fcad1d3558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; to add objects of types equal or below T in list.&lt;/strong&gt; We cannot read from 
it.</source>
          <target state="translated">&lt;strong&gt;우리는 &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;super T&amp;gt; 를 사용하여 유형이 T 이하인 객체를 목록에 추가합니다.&lt;/strong&gt; 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b58638ffc0961485f562de00c7e06a30e7ab8e29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bounded&lt;/strong&gt;(i.e. heading toward somewhere) &lt;strong&gt;wildcard&lt;/strong&gt; : There are 3 different flavours of wildcards:</source>
          <target state="translated">&lt;strong&gt;경계&lt;/strong&gt; (즉, 어딘가로 향함) &lt;strong&gt;와일드 카드&lt;/strong&gt; : &lt;strong&gt;와일드 카드&lt;/strong&gt; 에는 세 가지 맛이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b032ce66a5b0601c3c15a3a78fd9ab067544c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt; if it reverses this ordering;</source>
          <target state="translated">이 순서를 &lt;strong&gt;바꾸면 반 변형&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="758f69c0fcc2f45b755ce9abafa6f6d34557b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt;: an Animal[] is a Cat[];</source>
          <target state="translated">&lt;strong&gt;반 변형&lt;/strong&gt; : 동물 []은 고양이 []입니다.</target>
        </trans-unit>
        <trans-unit id="0ba67e84f7f5c2e136ea9fe008b4b827013fff1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt; if it preserves the ordering of types (&amp;le;), which orders types from more specific to more generic;</source>
          <target state="translated">유형의 순서를 유지하는 경우 &lt;strong&gt;공변량&lt;/strong&gt; (&amp;le;), 유형을보다 구체적에서 일반으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="57bdc8d44fd6963ecd54c43806d679399b0772cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt;: a Cat[] is an Animal[];</source>
          <target state="translated">&lt;strong&gt;공변량&lt;/strong&gt; : 고양이 []는 동물 []입니다.</target>
        </trans-unit>
        <trans-unit id="db42607b786d14f36a7aa526ea5fd510862b8086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt; or nonvariant if neither of these applies.</source>
          <target state="translated">이들 중 어느 것도 적용되지 않으면 &lt;strong&gt;불변&lt;/strong&gt; 또는 비변이.</target>
        </trans-unit>
        <trans-unit id="e3cb78147cdbf377c8068f9d2520c0f0105d61db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt;: an Animal[] is not a Cat[] and a Cat[] is not an Animal[].</source>
          <target state="translated">&lt;strong&gt;불변&lt;/strong&gt; : 동물 []은 고양이 []가 아니며 고양이 []는 동물 []이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="debcd99be47f67dd6104bc343fd159ad003d445b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt; &quot;PECS&quot; is from the collection's point of view. If you are &lt;em&gt;only&lt;/em&gt; pulling items from a generic collection, it is a producer and you should use &lt;code&gt;extends&lt;/code&gt;; if you are &lt;em&gt;only&lt;/em&gt; stuffing items in, it is a consumer and you should use &lt;code&gt;super&lt;/code&gt;. If you do both with the same collection, you shouldn't use either &lt;code&gt;extends&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;tl; dr :&lt;/strong&gt; &quot;PECS&quot;는 컬렉션의 관점에서 나온 것입니다. 일반 컬렉션에서 항목 &lt;em&gt;만&lt;/em&gt; 가져 오는 경우 생산자이므로 &lt;code&gt;extends&lt;/code&gt; 를 사용해야합니다. 항목 &lt;em&gt;만&lt;/em&gt; 채우는 경우 소비자이며 &lt;code&gt;super&lt;/code&gt; 를 사용해야합니다. 동일한 콜렉션으로 둘 다 수행하는 경우 &lt;code&gt;extends&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt; 를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e2f7361433754602bbcf1d9a29aebba3745f665e" translate="yes" xml:space="preserve">
          <source>And don&amp;rsquo;t use a wildcard when you both get and put.</source>
          <target state="translated">그리고 둘 다 넣을 때 와일드 카드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="92a0466119e2bd899c57cd76250f866ef981b73e" translate="yes" xml:space="preserve">
          <source>As I explain in &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;my answer&lt;/a&gt; to another question, PECS is a mnemonic device  created by Josh Bloch to help remember &lt;strong&gt;P&lt;/strong&gt;roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt;, &lt;strong&gt;C&lt;/strong&gt;onsumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt;.</source>
          <target state="translated">다른 질문에 대한 &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;대답&lt;/a&gt; 에서 설명 하듯이 PECS는 Josh Bloch가 개발 한 니모닉 장치입니다.</target>
        </trans-unit>
        <trans-unit id="ec62dde14f33254d37ae93dbc06b4a2bf234df91" translate="yes" xml:space="preserve">
          <source>At runtime, the type of list can be any type above A: X, Y, Z, ...
The compiler can compile your assignment statement (which seems correct) but, &lt;strong&gt;at runtime&lt;/strong&gt; the type of s (Animal) can be lower in hierarchy than the declared type of the list(which could be Creature, or higher). This is not allowed.</source>
          <target state="translated">런타임시 목록 유형은 A : X, Y, Z 등의 모든 유형이 될 수 있습니다. 컴파일러는 할당 문을 컴파일 할 수 있지만 (올바른 것처럼 보이지만) &lt;strong&gt;런타임&lt;/strong&gt; 에는 s (동물) 유형이 더 낮을 수 있습니다. 목록의 선언 된 유형보다 계층 구조 (Creature 이상일 수 있음). 이것은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e95abb9ccd0e4b2eb4af253d08491c29fdcf4d82" translate="yes" xml:space="preserve">
          <source>But why you cannot read from this list?
(I mean you can get an element out of it, but you cannot assign it to anything other than Object o):</source>
          <target state="translated">그러나 왜이 목록에서 읽을 수 없습니까? (요소를 가져올 수는 있지만 Object o 이외의 다른 요소에는 할당 할 수 없습니다) :</target>
        </trans-unit>
        <trans-unit id="82addeeaa5366725e5ce90ab68c1203f16326988" translate="yes" xml:space="preserve">
          <source>Can someone explain to me how to use PECS to resolve confusion between &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;?</source>
          <target state="translated">누군가 PECS를 사용하여 &lt;code&gt;extends&lt;/code&gt; 와 &lt;code&gt;super&lt;/code&gt; 사이의 혼란을 해결하는 방법을 설명해 줄 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0de8ffe33606ed73d285b04ba05219d8f320a620" translate="yes" xml:space="preserve">
          <source>Co-variance: &lt;code&gt;? extends T&lt;/code&gt; (the family of all types that are subtypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with an &lt;strong&gt;upper bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;upper&lt;/strong&gt;-most class in the inheritance hierarchy. Use an &lt;code&gt;extends&lt;/code&gt; wildcard when you only &lt;strong&gt;Get&lt;/strong&gt; values out of a structure.</source>
          <target state="translated">공분산 : &lt;code&gt;? extends T&lt;/code&gt; T ( T의 하위 유형 인 모든 유형의 패밀리)- &lt;strong&gt;상한이&lt;/strong&gt; 있는 와일드 카드를 확장합니다. &lt;code&gt;T&lt;/code&gt; 는 상속 계층에서 &lt;strong&gt;최상위&lt;/strong&gt; 클래스입니다. 구조에서 값을 가져올 때만 &lt;code&gt;extends&lt;/code&gt; 와일드 카드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="792f14ec22afb7780c6d54fb0239c36e3364259f" translate="yes" xml:space="preserve">
          <source>Consumer eat &lt;strong&gt;supper&lt;/strong&gt;(super); Producer &lt;strong&gt;extends&lt;/strong&gt; his parent's factory</source>
          <target state="translated">소비자는 &lt;strong&gt;저녁을&lt;/strong&gt; 먹는다 (슈퍼); 프로듀서, 부모 공장 &lt;strong&gt;확장&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a39ab9613e3042c6e7e014af6f86ec9338cfe1d" translate="yes" xml:space="preserve">
          <source>Contra-variance: &lt;code&gt;? super T&lt;/code&gt; ( the family of all types that are supertypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with a &lt;strong&gt;lower bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;lower&lt;/strong&gt;-most class in the inheritance hierarchy. Use a &lt;code&gt;super&lt;/code&gt; wildcard when you only &lt;strong&gt;Put&lt;/strong&gt; values into a structure.</source>
          <target state="translated">대조-분산 : &lt;code&gt;? super T&lt;/code&gt; super T ( T의 수퍼 타입 인 모든 유형의 패밀리)- &lt;strong&gt;하한이&lt;/strong&gt; 있는 와일드 카드. &lt;code&gt;T&lt;/code&gt; 는 상속 계층에서 가장 &lt;strong&gt;낮은&lt;/strong&gt; 클래스입니다. 구조에 값을 입력 할 때에 만 &lt;code&gt;super&lt;/code&gt; 와일드 카드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bcb46a38670d5684e40032813ada60b8db782bdc" translate="yes" xml:space="preserve">
          <source>Contravariance: &lt;code&gt;? super MyClass&lt;/code&gt; and</source>
          <target state="translated">반공 분산 : &lt;code&gt;? super MyClass&lt;/code&gt; 슈퍼 MyClass 와</target>
        </trans-unit>
        <trans-unit id="d937c29e908b0405c909dea8c24ce90e0401dbab" translate="yes" xml:space="preserve">
          <source>Covariance and contravariance</source>
          <target state="translated">공분산 및 반공 분산</target>
        </trans-unit>
        <trans-unit id="f9157e83e5e5e43a86a192add3cbb19c4a902ee5" translate="yes" xml:space="preserve">
          <source>Covariance: &lt;code&gt;? extends MyClass&lt;/code&gt;,</source>
          <target state="translated">공분산 : &lt;code&gt;? extends MyClass&lt;/code&gt; MyClass 확장</target>
        </trans-unit>
        <trans-unit id="9d8ce266eaaf430dcb92d6a97b29a357c42b1c8b" translate="yes" xml:space="preserve">
          <source>Covariant types are read-only, while contravariant types are write-only.</source>
          <target state="translated">공변량 유형은 읽기 전용이며, 반 변형 유형은 쓰기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="5ff8d99ff85262bb80d9645e82b59d40aa10406d" translate="yes" xml:space="preserve">
          <source>Example in Java:</source>
          <target state="translated">자바 예제 :</target>
        </trans-unit>
        <trans-unit id="52aa4da8fd2e6a5eb9adc65a2a6d779862e9e0fd" translate="yes" xml:space="preserve">
          <source>I came across PECS (short for &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;&lt;/em&gt;) while reading up on generics.</source>
          <target state="translated">제네릭을 읽는 동안 PECS ( &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; 및 Consumer &lt;code&gt;super&lt;/code&gt; 의&lt;/em&gt; 줄임말)를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="1fa3cb34eb411ebc2ed2bb349bdcd1d434c52545" translate="yes" xml:space="preserve">
          <source>I find &quot;PECS&quot; to be a non-obvious way to think of things regarding who is the &quot;producer&quot; and who is the &quot;consumer&quot;. &quot;PECS&quot; is defined from the perspective of the &lt;em&gt;data collection itself&lt;/em&gt; &amp;ndash; the collection &quot;consumes&quot; if objects are being written &lt;em&gt;to&lt;/em&gt; it (it is consuming objects from calling code), and it &quot;produces&quot; if objects are being read &lt;em&gt;from&lt;/em&gt; it (it is producing objects to some calling code). This is counter to how everything else is named though. Standard Java APIs are named from the perspective of the calling code, not the collection itself. For example, a collection-centric view of &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; should have a method named &quot;receive()&quot; instead of &quot;add()&quot; &amp;ndash; after all, the calling code &lt;em&gt;adds&lt;/em&gt; the element, but the list itself &lt;em&gt;receives&lt;/em&gt; the element.</source>
          <target state="translated">&quot;PECS&quot;는 누가 &quot;생산자&quot;이고 누가 &quot;소비자&quot;인지에 대해 생각할 수있는 명백한 방법입니다. &quot;PECS&quot;는 &lt;em&gt;데이터 콜렉션 자체&lt;/em&gt; 의 관점에서 정의됩니다. 콜렉션은 오브젝트를 작성 &lt;em&gt;하는&lt;/em&gt; 경우 (소비 코드에서 오브젝트를 소비하는 경우) &quot;소비&quot;하고 오브젝트를 읽을 경우 &quot;생산&quot;합니다. 호출 코드에 객체를 생성하는 중). 이것은 다른 모든 것이 어떻게 명명되는지에 반합니다. 표준 Java API는 콜렉션 자체가 아니라 호출 코드의 관점에서 명명됩니다. 예를 들어, &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; 의 콜렉션 중심 뷰에는 &quot;add ()&quot;대신 &quot;receive ()&quot;라는 메소드 가 있어야합니다. 결국 호출 코드 &lt;em&gt;는&lt;/em&gt; 요소를 &lt;em&gt;추가&lt;/em&gt; 하지만 목록 자체 &lt;em&gt;는&lt;/em&gt; 요소를 &lt;em&gt;수신&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f70dc69f10ef0e3707d0f1d782b90670c0277a95" translate="yes" xml:space="preserve">
          <source>I think it's more intuitive, natural and consistent to think of things from the perspective of the code that interacts with the collection &amp;ndash; does the code &quot;read from&quot; or &quot;write to&quot; the collection? Following that, any code &lt;em&gt;writing to&lt;/em&gt; the collection would be the &quot;producer&quot;, and any code &lt;em&gt;reading from&lt;/em&gt; the collection would be the &quot;consumer&quot;.</source>
          <target state="translated">컬렉션과 상호 작용하는 코드의 관점에서 사물을 생각하는 것이 더 직관적이고 자연스럽고 일관성이 있다고 생각합니다. 코드가 컬렉션에서 &quot;읽기&quot;또는 &quot;쓰기&quot;됩니까? 그런 다음 컬렉션에 &lt;em&gt;쓰는&lt;/em&gt; 코드는 &quot;프로듀서&quot;가되고 컬렉션 &lt;em&gt;에서 읽는&lt;/em&gt; 코드는 &quot;소비자&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="a242e3017b6b235f2f1cad0170a3da1f29493ddf" translate="yes" xml:space="preserve">
          <source>If you need to satisfy both things, well, don&amp;rsquo;t use any wildcard. As
simple as that.</source>
          <target state="translated">두 가지를 모두 만족시켜야하는 경우에는 와일드 카드를 사용하지 마십시오. 저것과 같이 쉬운.</target>
        </trans-unit>
        <trans-unit id="3ff73982c21deeffcbf3fabff242ab3939dc8f4a" translate="yes" xml:space="preserve">
          <source>Imagine a freight train with freight cars as analogy to a list.</source>
          <target state="translated">화물 자동차가 목록과 유사한화물 열차를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="542e956f7c561ae14417ca5dec6f5c660bd4e428" translate="yes" xml:space="preserve">
          <source>In a nutshell, three easy rules to remember PECS:</source>
          <target state="translated">간단히 말해서 PECS를 기억하는 세 가지 쉬운 규칙 :</target>
        </trans-unit>
        <trans-unit id="8a4881b5673370238cca2a8f7cfb01ce09b1a918" translate="yes" xml:space="preserve">
          <source>In practice, the compiler can indeed see at compiletime that you add a B:</source>
          <target state="translated">실제로 컴파일러는 컴파일 타임에 B를 추가하는 것을 실제로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3209315080c6adff01ef992fafde853681897d" translate="yes" xml:space="preserve">
          <source>In the same hierarchy we can try this:</source>
          <target state="translated">동일한 계층에서 우리는 이것을 시도 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a35991e8ae7b3cdefb743f69bd37997a82ef4165" translate="yes" xml:space="preserve">
          <source>In-variance/Non-variance: &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;? extends Object&lt;/code&gt; - &lt;strong&gt;Unbounded&lt;/strong&gt; Wildcard. It stands for the family of  all types. Use when you both get and put.</source>
          <target state="translated">불일치 / 비 분산 : &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;? extends Object&lt;/code&gt; Object - &lt;strong&gt;Unbounded&lt;/strong&gt; Wildcard를 확장합니다 . 모든 유형의 가족을 나타냅니다. 둘 다 넣을 때 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f5131c1bce167871d0602aaf46100b50f44f018" translate="yes" xml:space="preserve">
          <source>Invariance/non-variance: &lt;code&gt;MyClass&lt;/code&gt;</source>
          <target state="translated">불변 / 비 변동 : &lt;code&gt;MyClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34ec57577cc65d5dd83ffb987d46f94e6ba5fec" translate="yes" xml:space="preserve">
          <source>Java Examples:</source>
          <target state="translated">자바 예제 :</target>
        </trans-unit>
        <trans-unit id="cdfd21f603272833177a3b5803055b8c4cd7ba10" translate="yes" xml:space="preserve">
          <source>Mutable data types which act as both sources and sinks should be &lt;strong&gt;invariant&lt;/strong&gt;.</source>
          <target state="translated">소스 및 싱크 역할을하는 가변 데이터 유형은 &lt;strong&gt;변하지&lt;/strong&gt; 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="833aacce639487ef510c515bcd37f1d614d40b8d" translate="yes" xml:space="preserve">
          <source>Note that generally you should only be using &lt;code&gt;? extends T&lt;/code&gt; and &lt;code&gt;? super T&lt;/code&gt; for the parameters of some method. Methods should just use &lt;code&gt;T&lt;/code&gt; as the type parameter on a generic return type.</source>
          <target state="translated">일반적으로 &lt;code&gt;? extends T&lt;/code&gt; 만 사용해야합니다 . T 와 &lt;code&gt;? super T&lt;/code&gt; 확장 일부 방법의 매개 변수는 super T 입니다. 메소드는 일반 리턴 유형에서 유형 매개 변수로 &lt;code&gt;T&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="da1cf385e1a0e937aefc400f70bb54b5a032605b" translate="yes" xml:space="preserve">
          <source>Note: wildcard &lt;code&gt;?&lt;/code&gt; means &lt;strong&gt;zero or one time&lt;/strong&gt;, represents an unknown type. The wildcard can be used as the type of a parameter, never used as a type argument for a generic method invocation, a generic class instance creation.(i.e. when used wildcard that reference not used in elsewhere in program like we use &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">참고 : 와일드 카드 &lt;code&gt;?&lt;/code&gt; 은 &lt;strong&gt;0 번 또는 1 번을&lt;/strong&gt; 의미하며 알 수없는 유형을 나타냅니다. 와일드 카드는 매개 변수의 유형으로 사용될 수 있으며, 일반 메소드 호출, 일반 클래스 인스턴스 작성에 대한 유형 인수로 사용되지 않습니다 (즉, &lt;code&gt;T&lt;/code&gt; 를 사용하는 것과 같이 프로그램의 다른 곳에서 참조되지 않는 와일드 카드를 사용하는 경우)</target>
        </trans-unit>
        <trans-unit id="d60e74b767eba2f856bb3390209305abe069b490" translate="yes" xml:space="preserve">
          <source>PECS (Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;)</source>
          <target state="translated">PECS (프로듀서 &lt;code&gt;extends&lt;/code&gt; 및 소비자 &lt;code&gt;super&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c43068ee8ac3bb66f51a56d8d5430ac6b0250806" translate="yes" xml:space="preserve">
          <source>Read-only data types (sources) can be &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant&lt;/a&gt;&lt;/strong&gt;;</source>
          <target state="translated">읽기 전용 데이터 유형 (소스)은 &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;공변량 일&lt;/a&gt;&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="469b1b39e7e8f3f0037efadda112edbc369754e1" translate="yes" xml:space="preserve">
          <source>Remember this:</source>
          <target state="translated">이것을 기억:</target>
        </trans-unit>
        <trans-unit id="7818c1bbe997fd084c4a2cfbbf415cbdcfe46a72" translate="yes" xml:space="preserve">
          <source>Since you have a list that can be of type A, B or C &lt;strong&gt;at runtime&lt;/strong&gt;, you cannot add any object of type A, B or C in it because you can end up with a combination that is not allowed in java.</source>
          <target state="translated">&lt;strong&gt;런타임에&lt;/strong&gt; A, B 또는 C 유형이 될 수있는 목록이 있으므로 Java에서 허용되지 않는 조합으로 끝날 수 있으므로 A, B 또는 C 유형의 오브젝트를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84fe0732dfcfb015eb1d8dee6237f1c112b6f071" translate="yes" xml:space="preserve">
          <source>Suppose you have a method that takes as its parameter a collection of things, but you want it to be more flexible than just accepting a &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">매개 변수로 사물 모음을 취하는 메소드가 있지만 &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt; 수락하는 것보다 더 유연하게 만들고 싶다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="155c1d5cc873d9cb3134648b29b4b7d445b4cafa" translate="yes" xml:space="preserve">
          <source>The picture below should explain the concept. Picture courtesy: &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</source>
          <target state="translated">아래 그림은 개념을 설명해야합니다. 사진 제공 : &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7de996a522beb1f3a3e9becda0f3a27d5119e4fb" translate="yes" xml:space="preserve">
          <source>The principles behind this in computer science is called</source>
          <target state="translated">컴퓨터 과학에서 이것의 배후 원리는</target>
        </trans-unit>
        <trans-unit id="960f5c8f82ec1686cb5c7d0d4fd23d70586ca41e" translate="yes" xml:space="preserve">
          <source>The reasoning here is that unlike &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; can always hold a &lt;code&gt;Thing&lt;/code&gt; no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a &lt;code&gt;Thing&lt;/code&gt; to be added; this is what &lt;code&gt;? super Thing&lt;/code&gt; guarantees.</source>
          <target state="translated">여기서 추론은 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; 과는 달리 &amp;lt;? Thing&amp;gt; , &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; super Thing&amp;gt; 은 실제 매개 변수화 된 유형이 무엇이든 항상 &lt;code&gt;Thing&lt;/code&gt; 을 유지할 수 있습니다. 여기에 &lt;code&gt;Thing&lt;/code&gt; 가 추가 될 수있는 한, 이미 목록에있는 것은 상관 없습니다. 이것은 무엇 &lt;code&gt;? super Thing&lt;/code&gt; 슈퍼 것은 보장합니다.</target>
        </trans-unit>
        <trans-unit id="3c3e7f2fd0031e22e8b85562f6b569e88a41d88f" translate="yes" xml:space="preserve">
          <source>The reasoning is that a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; could hold any subtype of &lt;code&gt;Thing&lt;/code&gt;, and thus each element will behave as a &lt;code&gt;Thing&lt;/code&gt; when you perform your operation. (You actually cannot add anything to a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, because you cannot know at runtime which &lt;em&gt;specific&lt;/em&gt; subtype of &lt;code&gt;Thing&lt;/code&gt; the collection holds.)</source>
          <target state="translated">추론은 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; extends Thing&amp;gt;은 Thing의 모든 하위 유형을 보유 할 수 있으므로 작업을 수행 할 때 각 요소가 &lt;code&gt;Thing&lt;/code&gt; 으로 작동합니다. (실제로는 콜렉션에 보유하는 &lt;code&gt;Thing&lt;/code&gt; 의 &lt;em&gt;특정&lt;/em&gt; 하위 유형을 알 수 없으므로 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; 에 아무것도 추가 할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="f9a08a5a59510bb09cbc96e347b2a0b74f30ce41" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;consumer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 목록은 &lt;strong&gt;consumer&lt;/strong&gt; 이므로 &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; 슈퍼 것&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="09c93ca7e342b67eb8cfeb62e6e19e9309b3e92b" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;producer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 목록은 &lt;strong&gt;생산자&lt;/strong&gt; 이므로 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; Thing&amp;gt;을 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="548dc4b3108193f86c38e631e743ba31ff65b60e" translate="yes" xml:space="preserve">
          <source>This is the clearest, simplest way for me think of extends vs. super:</source>
          <target state="translated">이것이 확장 대 슈퍼를 생각하는 가장 명확하고 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bce949b55a9a429ae77eee6d672e98fa8a23bc02" translate="yes" xml:space="preserve">
          <source>This means that when a parameterized type being passed to a method will &lt;em&gt;produce&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be retrieved from it in some way), &lt;code&gt;? extends T&lt;/code&gt; should be used, since any instance of a subclass of &lt;code&gt;T&lt;/code&gt; is also a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이것은 매개 변수화 된 유형이 메소드에 전달 될 때 &lt;code&gt;T&lt;/code&gt; 의 인스턴스를 &lt;em&gt;생성&lt;/em&gt; 할 때 (어떤 방식 으로든 검색 됨) &lt;code&gt;? extends T&lt;/code&gt; T 의 서브 클래스 인스턴스도 T 이므로 extends T를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3e9bebc1e518710bd72da25726f74ae21f007bf" translate="yes" xml:space="preserve">
          <source>This principle states that:</source>
          <target state="translated">이 원칙은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="2d3a389d50b6f05444764cd8371ecba25e982422" translate="yes" xml:space="preserve">
          <source>To illustrate this general phenomenon, consider the array type. For the type Animal we can make the type Animal[]</source>
          <target state="translated">이 일반적인 현상을 설명하기 위해 배열 유형을 고려하십시오. Animal 유형의 경우 Animal [] 유형을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a364d645d3f36c0aa43f84a2e9243fad90349b7d" translate="yes" xml:space="preserve">
          <source>Use a super wildcard when you only put values into a structure.</source>
          <target state="translated">구조에 값만 넣을 때는 수퍼 와일드 카드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bac4ad848c09d46df23cb670c0a8bb5f0b83f4e8" translate="yes" xml:space="preserve">
          <source>Use an extends wildcard when you only get values out of a structure.</source>
          <target state="translated">구조에서 값을 가져올 때만 확장 와일드 카드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="51109f31442287d55f2d09a788b36cab1528d667" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; wildcard if you need to retrieve object of
type &lt;code&gt;T&lt;/code&gt; from a collection.</source>
          <target state="translated">&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; 콜렉션에서 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 검색해야하는 경우 T&amp;gt; 와일드 카드를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="a9cddb419fff1ae43f081fb34719fbb3ee8a99b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; wildcard if you need to put objects of type &lt;code&gt;T&lt;/code&gt; in
a collection.</source>
          <target state="translated">&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; T 유형의 객체를 컬렉션에 넣어야하는 경우 super T&amp;gt; 와일드 카드</target>
        </trans-unit>
        <trans-unit id="9fff184eaf718cb02db0d13177ddc1eedad31915" translate="yes" xml:space="preserve">
          <source>Using real life example (with some simplifications):</source>
          <target state="translated">실제 예제 사용 (일부 단순화) :</target>
        </trans-unit>
        <trans-unit id="f332c1ae4b070a0a1127f653ab5ef4f751816e05" translate="yes" xml:space="preserve">
          <source>What and why you &lt;strong&gt;can&lt;/strong&gt; add to this list?</source>
          <target state="translated">이 목록에 무엇을 왜 추가 할 &lt;strong&gt;수&lt;/strong&gt; 있습니까?</target>
        </trans-unit>
        <trans-unit id="41c5d4cffd059abee38dc9ba81c94b883488b810" translate="yes" xml:space="preserve">
          <source>What is PECS (Producer Extends Consumer Super)</source>
          <target state="translated">PECS 란 무엇입니까 (프로듀서는 소비자 슈퍼를 확장합니다)</target>
        </trans-unit>
        <trans-unit id="ea561a781fdf8bc0b8a203849b3201824311f82b" translate="yes" xml:space="preserve">
          <source>When a parameterized type being passed to a method will &lt;em&gt;consume&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be passed to it to do something), &lt;code&gt;? super T&lt;/code&gt; should be used because an instance of &lt;code&gt;T&lt;/code&gt; can legally be passed to any method that accepts some supertype of &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; could be used on a &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt;, for example. &lt;code&gt;? extends T&lt;/code&gt; would not work, because a &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; could not operate on a &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">메소드에 전달되는 매개 변수화 된 유형이 &lt;code&gt;T&lt;/code&gt; 의 인스턴스를 &lt;em&gt;소비&lt;/em&gt; 할 때 (무슨 일이 전달되도록) 전달 &lt;code&gt;? super T&lt;/code&gt; T 의 인스턴스는 &lt;code&gt;T&lt;/code&gt; 의 일부 슈퍼 타입을 허용하는 모든 메소드에 합법적으로 전달 될 수 있으므로 super T를 사용해야합니다. 예를 들어 &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; 사용할 수 있습니다. &lt;code&gt;? extends T&lt;/code&gt; &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt; 에서 작동 할 수 없으므로 확장 T 가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4a9baec8126cb0a0170c568b5aea0bc33af82ee" translate="yes" xml:space="preserve">
          <source>Why you cannot add objects that extend &quot;Shark&quot; in this list? like:</source>
          <target state="translated">이 목록에서 &quot;상어&quot;를 확장하는 개체를 추가 할 수없는 이유는 무엇입니까? 처럼:</target>
        </trans-unit>
        <trans-unit id="aba9f040c34c97dc5cbd78b7650ba76466656090" translate="yes" xml:space="preserve">
          <source>Within the type system of a programming language, a typing rule</source>
          <target state="translated">프로그래밍 언어의 타이핑 시스템 내에서 타이핑 규칙</target>
        </trans-unit>
        <trans-unit id="3fd437c172cae675972484db66485785fdb8066a" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;cannot&lt;/strong&gt; add types above Shark, because &lt;strong&gt;at runtime&lt;/strong&gt; the type of added object can be higher in hierarchy than the declared type of the list(X,Y,Z). This is not allowed.</source>
          <target state="translated">&lt;strong&gt;런타임&lt;/strong&gt; 에 추가 된 객체의 유형이 목록의 선언 된 유형 (X, Y, Z)보다 계층 구조에서 높을 수 있으므로 Shark 위에 유형을 추가 할 수 없습니다. 이것은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf7625e8d26c2b0876b7150314d221ce86efd5bf" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;put&lt;/strong&gt; a cargo in a freight car if the cargo has &lt;strong&gt;the same or smaller size&lt;/strong&gt; than the freight car = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">화물이 화물차 &lt;strong&gt;와 같거나 작은 크기 인&lt;/strong&gt; 경우 화물차에화물을 &lt;strong&gt;넣을&lt;/strong&gt; 수 있습니다 &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt; 슈퍼 화물차 크기&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27ab9c1a017fc3835a2ef84041c847cf90eccfdc" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;unload&lt;/strong&gt; a cargo from a freight car if you have &lt;strong&gt;enough place&lt;/strong&gt; (more than the size of the cargo) in your depot = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">창고에 &lt;strong&gt;충분한 공간&lt;/strong&gt; 이 &lt;strong&gt;있으면&lt;/strong&gt; (화물의 크기보다 큰) 화물차에서화물을 &lt;strong&gt;내릴&lt;/strong&gt; 수 있습니다 = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt; DepotSize를 확장합니다.&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e0731813e0f463d46c84c89f3bedc307fd54c0b7" translate="yes" xml:space="preserve">
          <source>You can add the above types of objects because anything below shark(A,B,C) will always be subtypes of anything above shark (X,Y,Z). Easy to understand.</source>
          <target state="translated">상어 (A, B, C) 아래의 항목은 항상 상어 (X, Y, Z) 이상인 하위 유형이므로 위의 유형의 객체를 추가 할 수 있습니다. 이해하기 쉬운.</target>
        </trans-unit>
        <trans-unit id="71c65a7b69693d68a6243f298f05b0b401c6eaa6" translate="yes" xml:space="preserve">
          <source>let's assume this hierarchy:</source>
          <target state="translated">이 계층 구조를 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="8166089d4e5973d45afee9a2427f45940137e452" translate="yes" xml:space="preserve">
          <source>mnemonic &amp;rarr; Get and Put principle.</source>
          <target state="translated">니모닉 &amp;rarr; Get and Put 원칙.</target>
        </trans-unit>
        <trans-unit id="3fd49bc245a3f4fc5ae457330f6f619971d2fa99" translate="yes" xml:space="preserve">
          <source>more examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="9ea651794357473f0e72935b60c04eb349071726" translate="yes" xml:space="preserve">
          <source>write-only data types (sinks) can be &lt;strong&gt;contravariant&lt;/strong&gt;.</source>
          <target state="translated">쓰기 전용 데이터 형식 (싱크)은 &lt;strong&gt;반 변형 일&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
