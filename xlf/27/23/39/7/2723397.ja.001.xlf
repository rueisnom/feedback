<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2723397">
    <body>
      <group id="2723397">
        <trans-unit id="94c9db480f47df47185040411f9c95616b012de7" translate="yes" xml:space="preserve">
          <source>(adding an answer because never enough examples with Generics wildcards)</source>
          <target state="translated">(一般的なワイルドカードを使用した例は決して十分ではないので、答えを追加)</target>
        </trans-unit>
        <trans-unit id="7fc5b1f2bc2aaa5e44ba1bb9dfd44f3cf5667ee7" translate="yes" xml:space="preserve">
          <source>*You will say: &quot;OK, but why can't I add HammerSkark in it since it is the smallest type?&quot;. 
Answer: It is the smallest &lt;strong&gt;you&lt;/strong&gt; know. But HammerSkark can be extended too by somebody else and you end up in the same scenario.</source>
          <target state="translated">*「OKですが、HammerSkarkは最小タイプなので追加できないのはなぜですか？」と言うでしょう。 回答：それは&lt;strong&gt;あなたが&lt;/strong&gt;知っている最小のもの&lt;strong&gt;です&lt;/strong&gt; 。 しかし、HammerSkarkは他の誰かが拡張することもでき、同じシナリオになります。</target>
        </trans-unit>
        <trans-unit id="d0174c51c975963bb39f928cbb22a18dcd04a81e" translate="yes" xml:space="preserve">
          <source>...but it has no way to tell if at runtime, your B will be a subtype or supertype of the list type. At runtime the list type can be any of the types A, B, C. So you cannot end up adding HammerSkark (super type) in a list of DeadHammerShark for example.</source>
          <target state="translated">...しかし、実行時にBがリスト型のサブタイプになるのかスーパータイプになるのかを知る方法がありません。実行時にはリスト型はA,B,Cのいずれかの型になりますので、例えばDeadHammerSharkのリストにHammerSkark(スーパー型)を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="f2e963c423df2749b3a7c70442dd69362bec49a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;generics&lt;/a&gt; and &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;examples&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;ジェネリック&lt;/a&gt;と&lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;例&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a315a9a5442ad1949ff38821a17a1ccc8db468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov substitution principle:&lt;/a&gt;  if S is a subtype of T, then objects of type T may be replaced with objects of type S.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov置換の原則：&lt;/a&gt; SがTのサブタイプである場合、T型のオブジェクトはS型のオブジェクトに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="84afdf7541023e94eb834fb4d55ad29bc2f8f383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is for &lt;strong&gt;reading&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; は&lt;strong&gt;読書&lt;/strong&gt;用です</target>
        </trans-unit>
        <trans-unit id="5269c2a29c00dc63fdea0178f0dba0903385693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is for &lt;strong&gt;writing&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; は&lt;strong&gt;書き込み&lt;/strong&gt;用です</target>
        </trans-unit>
        <trans-unit id="be8228553ab50b13c364c53f104054de7dff4551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1: You want to go through the collection and do things with each item.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ケース1：コレクションを調べて、各アイテムで処理を行います。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9feea5d372acd0600581c2c069b1ae87f772a292" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2: You want to add things to the collection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ケース2：コレクションにアイテムを追加したい。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d73dcd91708bc65136ea3f9780de244628654" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contravariance&lt;/strong&gt;: accept supertypes</source>
          <target state="translated">&lt;strong&gt;反変&lt;/strong&gt; ：スーパータイプを受け入れる</target>
        </trans-unit>
        <trans-unit id="db725287369ff6aa40b2dcc280781ca3c22c6f57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Covariance&lt;/strong&gt;: accept subtypes</source>
          <target state="translated">&lt;strong&gt;共分散&lt;/strong&gt; ：サブタイプを受け入れる</target>
        </trans-unit>
        <trans-unit id="b78afe21d6d96b64853927ebc88812cf92d46c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify CS - Consumer Super:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CSを明確にしましょう-コンシューマースーパー：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0faa25525aa950fc903ca54e1b7840a251fc29a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify PE - Producer Extends:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PEを明確にしましょう-Producer Extends：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="243adf487fa4310c42089cb92177f6f400bb37d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To sum up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;総括する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2a047cbdd36af0c85dd4fbc1928d9726e2003e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; to read objects of types equal or below T from list.&lt;/strong&gt; We cannot add element to it.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;T&amp;gt;を拡張して 、リストからT以下のタイプのオブジェクトを読み取ります。&lt;/strong&gt; 要素を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="18d98376587fef5489dd624463bb41fcad1d3558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; to add objects of types equal or below T in list.&lt;/strong&gt; We cannot read from 
it.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;super T&amp;gt;は、リスト内のT以下のタイプのオブジェクトを追加します。&lt;/strong&gt; 読み込めません。</target>
        </trans-unit>
        <trans-unit id="b58638ffc0961485f562de00c7e06a30e7ab8e29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bounded&lt;/strong&gt;(i.e. heading toward somewhere) &lt;strong&gt;wildcard&lt;/strong&gt; : There are 3 different flavours of wildcards:</source>
          <target state="translated">&lt;strong&gt;境界付き&lt;/strong&gt; （つまり、どこかに向かっている） &lt;strong&gt;ワイルドカード&lt;/strong&gt; ： &lt;strong&gt;ワイルドカードに&lt;/strong&gt;は3つの異なる種類があります。</target>
        </trans-unit>
        <trans-unit id="2b032ce66a5b0601c3c15a3a78fd9ab067544c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt; if it reverses this ordering;</source>
          <target state="translated">この順序が逆の場合は&lt;strong&gt;反変&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="758f69c0fcc2f45b755ce9abafa6f6d34557b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt;: an Animal[] is a Cat[];</source>
          <target state="translated">&lt;strong&gt;反変&lt;/strong&gt; ：動物[]は猫[]です。</target>
        </trans-unit>
        <trans-unit id="0ba67e84f7f5c2e136ea9fe008b4b827013fff1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt; if it preserves the ordering of types (&amp;le;), which orders types from more specific to more generic;</source>
          <target state="translated">タイプの順序付けを維持する場合は&lt;strong&gt;共変&lt;/strong&gt; （&amp;le;）、タイプをより具体的なものからより一般的なものに順序付けます。</target>
        </trans-unit>
        <trans-unit id="57bdc8d44fd6963ecd54c43806d679399b0772cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt;: a Cat[] is an Animal[];</source>
          <target state="translated">&lt;strong&gt;共変&lt;/strong&gt; ：猫[]は動物[]です。</target>
        </trans-unit>
        <trans-unit id="db42607b786d14f36a7aa526ea5fd510862b8086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt; or nonvariant if neither of these applies.</source>
          <target state="translated">これらのいずれも該当しない場合は、 &lt;strong&gt;不変&lt;/strong&gt;または非&lt;strong&gt;変量&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3cb78147cdbf377c8068f9d2520c0f0105d61db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt;: an Animal[] is not a Cat[] and a Cat[] is not an Animal[].</source>
          <target state="translated">&lt;strong&gt;invariant&lt;/strong&gt; ：動物[]は猫[]ではなく、猫[]は動物[]ではありません。</target>
        </trans-unit>
        <trans-unit id="debcd99be47f67dd6104bc343fd159ad003d445b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt; &quot;PECS&quot; is from the collection's point of view. If you are &lt;em&gt;only&lt;/em&gt; pulling items from a generic collection, it is a producer and you should use &lt;code&gt;extends&lt;/code&gt;; if you are &lt;em&gt;only&lt;/em&gt; stuffing items in, it is a consumer and you should use &lt;code&gt;super&lt;/code&gt;. If you do both with the same collection, you shouldn't use either &lt;code&gt;extends&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;tl; dr：&lt;/strong&gt; 「PECS」はコレクションの観点からのものです。 ジェネリックコレクションからアイテムをプルする&lt;em&gt;だけの&lt;/em&gt;場合、それはプロデューサーであり、 &lt;code&gt;extends&lt;/code&gt; を使用する必要があります。 アイテムを詰め込む&lt;em&gt;だけの&lt;/em&gt;場合、それは消費者であり、 &lt;code&gt;super&lt;/code&gt; を使用する必要があります。 同じコレクションで両方を行う場合は、 &lt;code&gt;extends&lt;/code&gt; または &lt;code&gt;super&lt;/code&gt; を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="e2f7361433754602bbcf1d9a29aebba3745f665e" translate="yes" xml:space="preserve">
          <source>And don&amp;rsquo;t use a wildcard when you both get and put.</source>
          <target state="translated">また、取得と配置の両方でワイルドカードを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="92a0466119e2bd899c57cd76250f866ef981b73e" translate="yes" xml:space="preserve">
          <source>As I explain in &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;my answer&lt;/a&gt; to another question, PECS is a mnemonic device  created by Josh Bloch to help remember &lt;strong&gt;P&lt;/strong&gt;roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt;, &lt;strong&gt;C&lt;/strong&gt;onsumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt;.</source>
          <target state="translated">別の質問への&lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;私の回答で&lt;/a&gt;説明するように、PECSは、ジョシュブロッホが&lt;strong&gt;P&lt;/strong&gt; roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt; 、 &lt;strong&gt;C&lt;/strong&gt; onsumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt; を思い出すのに役立つニーモニックデバイスです。</target>
        </trans-unit>
        <trans-unit id="ec62dde14f33254d37ae93dbc06b4a2bf234df91" translate="yes" xml:space="preserve">
          <source>At runtime, the type of list can be any type above A: X, Y, Z, ...
The compiler can compile your assignment statement (which seems correct) but, &lt;strong&gt;at runtime&lt;/strong&gt; the type of s (Animal) can be lower in hierarchy than the declared type of the list(which could be Creature, or higher). This is not allowed.</source>
          <target state="translated">実行時に、リストのタイプはAを超える任意のタイプにすることができます：X、Y、Z、...コンパイラは割り当てステートメントをコンパイルできます（これは正しいようです）が、 &lt;strong&gt;実行時&lt;/strong&gt;にs（動物）のタイプはリストの宣言されたタイプ（Creatureまたはそれ以上である可能性があります）よりも階層。 これは許可されていません。</target>
        </trans-unit>
        <trans-unit id="e95abb9ccd0e4b2eb4af253d08491c29fdcf4d82" translate="yes" xml:space="preserve">
          <source>But why you cannot read from this list?
(I mean you can get an element out of it, but you cannot assign it to anything other than Object o):</source>
          <target state="translated">しかし、なぜこのリストから読み取れないのか?(つまり、要素を取り出すことはできますが、Object o以外のものには代入できません)。</target>
        </trans-unit>
        <trans-unit id="82addeeaa5366725e5ce90ab68c1203f16326988" translate="yes" xml:space="preserve">
          <source>Can someone explain to me how to use PECS to resolve confusion between &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;?</source>
          <target state="translated">PECSを使用して &lt;code&gt;extends&lt;/code&gt; と &lt;code&gt;super&lt;/code&gt; 間の混乱を解決する方法を誰かに説明できますか？</target>
        </trans-unit>
        <trans-unit id="0de8ffe33606ed73d285b04ba05219d8f320a620" translate="yes" xml:space="preserve">
          <source>Co-variance: &lt;code&gt;? extends T&lt;/code&gt; (the family of all types that are subtypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with an &lt;strong&gt;upper bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;upper&lt;/strong&gt;-most class in the inheritance hierarchy. Use an &lt;code&gt;extends&lt;/code&gt; wildcard when you only &lt;strong&gt;Get&lt;/strong&gt; values out of a structure.</source>
          <target state="translated">共分散： &lt;code&gt;? extends T&lt;/code&gt; T （ Tのサブタイプであるすべてのタイプのファミリー）- &lt;strong&gt;上限&lt;/strong&gt;付きのワイルドカードを拡張します。 &lt;code&gt;T&lt;/code&gt; は、継承階層の最&lt;strong&gt;上位の&lt;/strong&gt;クラスです。 構造体から値のみを&lt;strong&gt;取得&lt;/strong&gt;する場合は、 &lt;code&gt;extends&lt;/code&gt; ワイルドカードを使用します。</target>
        </trans-unit>
        <trans-unit id="792f14ec22afb7780c6d54fb0239c36e3364259f" translate="yes" xml:space="preserve">
          <source>Consumer eat &lt;strong&gt;supper&lt;/strong&gt;(super); Producer &lt;strong&gt;extends&lt;/strong&gt; his parent's factory</source>
          <target state="translated">消費者は&lt;strong&gt;夕食を&lt;/strong&gt;食べます（スーパー）。 プロデューサー&lt;strong&gt;が&lt;/strong&gt;両親の工場を&lt;strong&gt;拡張&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a39ab9613e3042c6e7e014af6f86ec9338cfe1d" translate="yes" xml:space="preserve">
          <source>Contra-variance: &lt;code&gt;? super T&lt;/code&gt; ( the family of all types that are supertypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with a &lt;strong&gt;lower bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;lower&lt;/strong&gt;-most class in the inheritance hierarchy. Use a &lt;code&gt;super&lt;/code&gt; wildcard when you only &lt;strong&gt;Put&lt;/strong&gt; values into a structure.</source>
          <target state="translated">逆分散： &lt;code&gt;? super T&lt;/code&gt; super T （ Tのスーパータイプであるすべてのタイプのファミリー）- &lt;strong&gt;下限の&lt;/strong&gt;あるワイルドカード。 &lt;code&gt;T&lt;/code&gt; は、継承階層の最下位のクラスです。 値を構造体にのみ&lt;strong&gt;入れる&lt;/strong&gt;場合は、 &lt;code&gt;super&lt;/code&gt; ワイルドカードを使用します。</target>
        </trans-unit>
        <trans-unit id="bcb46a38670d5684e40032813ada60b8db782bdc" translate="yes" xml:space="preserve">
          <source>Contravariance: &lt;code&gt;? super MyClass&lt;/code&gt; and</source>
          <target state="translated">逆分散： &lt;code&gt;? super MyClass&lt;/code&gt; スーパーMyClassと</target>
        </trans-unit>
        <trans-unit id="d937c29e908b0405c909dea8c24ce90e0401dbab" translate="yes" xml:space="preserve">
          <source>Covariance and contravariance</source>
          <target state="translated">共分散と逆分散</target>
        </trans-unit>
        <trans-unit id="f9157e83e5e5e43a86a192add3cbb19c4a902ee5" translate="yes" xml:space="preserve">
          <source>Covariance: &lt;code&gt;? extends MyClass&lt;/code&gt;,</source>
          <target state="translated">共分散： &lt;code&gt;? extends MyClass&lt;/code&gt; MyClassを拡張し 、</target>
        </trans-unit>
        <trans-unit id="9d8ce266eaaf430dcb92d6a97b29a357c42b1c8b" translate="yes" xml:space="preserve">
          <source>Covariant types are read-only, while contravariant types are write-only.</source>
          <target state="translated">共変型は読み取り専用ですが、対照型は書き込み専用です。</target>
        </trans-unit>
        <trans-unit id="5ff8d99ff85262bb80d9645e82b59d40aa10406d" translate="yes" xml:space="preserve">
          <source>Example in Java:</source>
          <target state="translated">Javaでの例。</target>
        </trans-unit>
        <trans-unit id="52aa4da8fd2e6a5eb9adc65a2a6d779862e9e0fd" translate="yes" xml:space="preserve">
          <source>I came across PECS (short for &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;&lt;/em&gt;) while reading up on generics.</source>
          <target state="translated">ジェネリックを読んでいるときにPECS（ &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; およびConsumer &lt;code&gt;super&lt;/code&gt; の&lt;/em&gt;略）に出会いました。</target>
        </trans-unit>
        <trans-unit id="1fa3cb34eb411ebc2ed2bb349bdcd1d434c52545" translate="yes" xml:space="preserve">
          <source>I find &quot;PECS&quot; to be a non-obvious way to think of things regarding who is the &quot;producer&quot; and who is the &quot;consumer&quot;. &quot;PECS&quot; is defined from the perspective of the &lt;em&gt;data collection itself&lt;/em&gt; &amp;ndash; the collection &quot;consumes&quot; if objects are being written &lt;em&gt;to&lt;/em&gt; it (it is consuming objects from calling code), and it &quot;produces&quot; if objects are being read &lt;em&gt;from&lt;/em&gt; it (it is producing objects to some calling code). This is counter to how everything else is named though. Standard Java APIs are named from the perspective of the calling code, not the collection itself. For example, a collection-centric view of &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; should have a method named &quot;receive()&quot; instead of &quot;add()&quot; &amp;ndash; after all, the calling code &lt;em&gt;adds&lt;/em&gt; the element, but the list itself &lt;em&gt;receives&lt;/em&gt; the element.</source>
          <target state="translated">私は「PECS」は誰が「プロデューサー」で誰が「コンシューマー」であるかについて物事を考えるための自明ではない方法だと思います。 「PECS」は、 &lt;em&gt;データコレクション自体の&lt;/em&gt;観点から定義され&lt;em&gt;ます。コレクション&lt;/em&gt;は、オブジェクトがそこに書き込まれ&lt;em&gt;て&lt;/em&gt;いる場合に「消費」し（コードの呼び出しからオブジェクトを消費しています）、オブジェクトが&lt;em&gt;そこから&lt;/em&gt;読み取ら&lt;em&gt;れ&lt;/em&gt;ている場合に「生成」します（それはいくつかの呼び出しコードに対してオブジェクトを生成しています）。 これは、他のすべての名前の付け方に反しています。 標準のJava APIは、コレクション自体ではなく、呼び出しコードの観点から命名されます。 たとえば、 &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.Listの&lt;/a&gt;コレクション中心のビューには、「add（）」ではなく「receive（）」という名前のメソッドが必要です。結局のところ、呼び出しコード&lt;em&gt;は&lt;/em&gt;要素を&lt;em&gt;追加&lt;/em&gt;しますが、リスト自体&lt;em&gt;は&lt;/em&gt;要素&lt;em&gt;を受け取り&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f70dc69f10ef0e3707d0f1d782b90670c0277a95" translate="yes" xml:space="preserve">
          <source>I think it's more intuitive, natural and consistent to think of things from the perspective of the code that interacts with the collection &amp;ndash; does the code &quot;read from&quot; or &quot;write to&quot; the collection? Following that, any code &lt;em&gt;writing to&lt;/em&gt; the collection would be the &quot;producer&quot;, and any code &lt;em&gt;reading from&lt;/em&gt; the collection would be the &quot;consumer&quot;.</source>
          <target state="translated">コレクションとやり取りするコードの観点から物事を考える方が、より直感的で自然で一貫性があると思います。コードはコレクションから「読み取り」または「書き込み」しますか？ その後、コレクションに&lt;em&gt;書き込む&lt;/em&gt;コードは「プロデューサー」になり、コレクション&lt;em&gt;から読み取る&lt;/em&gt;コードは「コンシューマー」になります。</target>
        </trans-unit>
        <trans-unit id="a242e3017b6b235f2f1cad0170a3da1f29493ddf" translate="yes" xml:space="preserve">
          <source>If you need to satisfy both things, well, don&amp;rsquo;t use any wildcard. As
simple as that.</source>
          <target state="translated">両方を満たす必要がある場合は、ワイルドカードを使用しないでください。 それと同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="3ff73982c21deeffcbf3fabff242ab3939dc8f4a" translate="yes" xml:space="preserve">
          <source>Imagine a freight train with freight cars as analogy to a list.</source>
          <target state="translated">貨車をリストに例えて、貨物列車を想像してみてください。</target>
        </trans-unit>
        <trans-unit id="542e956f7c561ae14417ca5dec6f5c660bd4e428" translate="yes" xml:space="preserve">
          <source>In a nutshell, three easy rules to remember PECS:</source>
          <target state="translated">一言で言えば、PECSを覚えるための簡単な3つのルール。</target>
        </trans-unit>
        <trans-unit id="8a4881b5673370238cca2a8f7cfb01ce09b1a918" translate="yes" xml:space="preserve">
          <source>In practice, the compiler can indeed see at compiletime that you add a B:</source>
          <target state="translated">実際には、コンパイラはコンパイル時にBを追加したことを確認することができます。</target>
        </trans-unit>
        <trans-unit id="9e3209315080c6adff01ef992fafde853681897d" translate="yes" xml:space="preserve">
          <source>In the same hierarchy we can try this:</source>
          <target state="translated">同じ階層では、このように試すことができます。</target>
        </trans-unit>
        <trans-unit id="a35991e8ae7b3cdefb743f69bd37997a82ef4165" translate="yes" xml:space="preserve">
          <source>In-variance/Non-variance: &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;? extends Object&lt;/code&gt; - &lt;strong&gt;Unbounded&lt;/strong&gt; Wildcard. It stands for the family of  all types. Use when you both get and put.</source>
          <target state="translated">分散/非分散： &lt;code&gt;?&lt;/code&gt; または &lt;code&gt;? extends Object&lt;/code&gt; オブジェクト - &lt;strong&gt;境界のない&lt;/strong&gt;ワイルドカードを拡張します。 それはすべてのタイプの家族を表しています。 取得と配置の両方で使用します。</target>
        </trans-unit>
        <trans-unit id="9f5131c1bce167871d0602aaf46100b50f44f018" translate="yes" xml:space="preserve">
          <source>Invariance/non-variance: &lt;code&gt;MyClass&lt;/code&gt;</source>
          <target state="translated">不変性/非変動： &lt;code&gt;MyClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34ec57577cc65d5dd83ffb987d46f94e6ba5fec" translate="yes" xml:space="preserve">
          <source>Java Examples:</source>
          <target state="translated">Javaの例。</target>
        </trans-unit>
        <trans-unit id="cdfd21f603272833177a3b5803055b8c4cd7ba10" translate="yes" xml:space="preserve">
          <source>Mutable data types which act as both sources and sinks should be &lt;strong&gt;invariant&lt;/strong&gt;.</source>
          <target state="translated">ソースとシンクの両方として機能する可変データ型は&lt;strong&gt;不変である&lt;/strong&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="833aacce639487ef510c515bcd37f1d614d40b8d" translate="yes" xml:space="preserve">
          <source>Note that generally you should only be using &lt;code&gt;? extends T&lt;/code&gt; and &lt;code&gt;? super T&lt;/code&gt; for the parameters of some method. Methods should just use &lt;code&gt;T&lt;/code&gt; as the type parameter on a generic return type.</source>
          <target state="translated">通常、使用するのは &lt;code&gt;? extends T&lt;/code&gt; Tと &lt;code&gt;? super T&lt;/code&gt; いくつかのメソッドのパラメータのスーパーT。 メソッドは、ジェネリック戻り値型の型パラメーターとして &lt;code&gt;T&lt;/code&gt; を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="da1cf385e1a0e937aefc400f70bb54b5a032605b" translate="yes" xml:space="preserve">
          <source>Note: wildcard &lt;code&gt;?&lt;/code&gt; means &lt;strong&gt;zero or one time&lt;/strong&gt;, represents an unknown type. The wildcard can be used as the type of a parameter, never used as a type argument for a generic method invocation, a generic class instance creation.(i.e. when used wildcard that reference not used in elsewhere in program like we use &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">注：ワイルドカード &lt;code&gt;?&lt;/code&gt; &lt;strong&gt;ゼロまたは1回を&lt;/strong&gt;意味し、不明なタイプを表します。 ワイルドカードは、パラメーターの型として使用できますが、ジェネリックメソッドの呼び出し、ジェネリッククラスインスタンスの作成の型引数として使用することはできません（つまり、 &lt;code&gt;T&lt;/code&gt; を使用するようなプログラムの他の場所で使用されていない参照をワイルドカードとして使用した場合）。</target>
        </trans-unit>
        <trans-unit id="d60e74b767eba2f856bb3390209305abe069b490" translate="yes" xml:space="preserve">
          <source>PECS (Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;)</source>
          <target state="translated">PECS（プロデューサー &lt;code&gt;extends&lt;/code&gt; およびコンシューマー &lt;code&gt;super&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c43068ee8ac3bb66f51a56d8d5430ac6b0250806" translate="yes" xml:space="preserve">
          <source>Read-only data types (sources) can be &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant&lt;/a&gt;&lt;/strong&gt;;</source>
          <target state="translated">読み取り専用データ型（ソース）は&lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;共変に&lt;/a&gt;&lt;/strong&gt;することができます。</target>
        </trans-unit>
        <trans-unit id="469b1b39e7e8f3f0037efadda112edbc369754e1" translate="yes" xml:space="preserve">
          <source>Remember this:</source>
          <target state="translated">これを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="7818c1bbe997fd084c4a2cfbbf415cbdcfe46a72" translate="yes" xml:space="preserve">
          <source>Since you have a list that can be of type A, B or C &lt;strong&gt;at runtime&lt;/strong&gt;, you cannot add any object of type A, B or C in it because you can end up with a combination that is not allowed in java.</source>
          <target state="translated">&lt;strong&gt;実行時&lt;/strong&gt;にタイプA、B、またはCになる可能性のあるリストがあるため、Javaで許可されていない組み合わせになる可能性があるため、タイプA、B、またはCのオブジェクトをリストに追加することはできません。</target>
        </trans-unit>
        <trans-unit id="84fe0732dfcfb015eb1d8dee6237f1c112b6f071" translate="yes" xml:space="preserve">
          <source>Suppose you have a method that takes as its parameter a collection of things, but you want it to be more flexible than just accepting a &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">もののコレクションをパラメーターとして受け取るメソッドがあるが、単に &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt; 受け入れるよりも柔軟にしたいとします。</target>
        </trans-unit>
        <trans-unit id="155c1d5cc873d9cb3134648b29b4b7d445b4cafa" translate="yes" xml:space="preserve">
          <source>The picture below should explain the concept. Picture courtesy: &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</source>
          <target state="translated">下の写真はその概念を説明しているはずです。 写真提供： &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7de996a522beb1f3a3e9becda0f3a27d5119e4fb" translate="yes" xml:space="preserve">
          <source>The principles behind this in computer science is called</source>
          <target state="translated">コンピュータサイエンスでは、その背後にある原理を</target>
        </trans-unit>
        <trans-unit id="960f5c8f82ec1686cb5c7d0d4fd23d70586ca41e" translate="yes" xml:space="preserve">
          <source>The reasoning here is that unlike &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; can always hold a &lt;code&gt;Thing&lt;/code&gt; no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a &lt;code&gt;Thing&lt;/code&gt; to be added; this is what &lt;code&gt;? super Thing&lt;/code&gt; guarantees.</source>
          <target state="translated">ここでの推論は、 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; とは異なります&amp;lt;？ Thing&amp;gt; 、 &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; super Thing&amp;gt;は、実際のパラメーター化された型に関係なく、常にThingを保持できます。 ここでは、 &lt;code&gt;Thing&lt;/code&gt; 追加を許可する限り、リストにすでに何が含まれているかは気にしません。 これは何 &lt;code&gt;? super Thing&lt;/code&gt; スーパーもの保証。</target>
        </trans-unit>
        <trans-unit id="3c3e7f2fd0031e22e8b85562f6b569e88a41d88f" translate="yes" xml:space="preserve">
          <source>The reasoning is that a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; could hold any subtype of &lt;code&gt;Thing&lt;/code&gt;, and thus each element will behave as a &lt;code&gt;Thing&lt;/code&gt; when you perform your operation. (You actually cannot add anything to a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, because you cannot know at runtime which &lt;em&gt;specific&lt;/em&gt; subtype of &lt;code&gt;Thing&lt;/code&gt; the collection holds.)</source>
          <target state="translated">その理由は、その &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; extends Thing&amp;gt;はThingの任意のサブタイプを保持できるため、各要素は操作を実行するときに &lt;code&gt;Thing&lt;/code&gt; として動作します。 （実際には、 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; 何かを追加することはできません&amp;lt;？extends Thing&amp;gt;。実行時に、コレクションが保持する &lt;code&gt;Thing&lt;/code&gt; の&lt;em&gt;特定の&lt;/em&gt;サブタイプを知ることができないためです。）</target>
        </trans-unit>
        <trans-unit id="f9a08a5a59510bb09cbc96e347b2a0b74f30ce41" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;consumer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">次に、リストは&lt;strong&gt;コンシューマ&lt;/strong&gt;であるため、 &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; を使用する必要があります&amp;lt;？ スーパーシング&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="09c93ca7e342b67eb8cfeb62e6e19e9309b3e92b" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;producer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">次に、リストは&lt;strong&gt;プロデューサーな&lt;/strong&gt;ので、 &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; を使用する必要があります&amp;lt;？ Thing&amp;gt;を拡張します。</target>
        </trans-unit>
        <trans-unit id="548dc4b3108193f86c38e631e743ba31ff65b60e" translate="yes" xml:space="preserve">
          <source>This is the clearest, simplest way for me think of extends vs. super:</source>
          <target state="translated">これが一番わかりやすく、シンプルにextends vs superを考えている私にとっては、これが一番わかりやすい方法です。</target>
        </trans-unit>
        <trans-unit id="bce949b55a9a429ae77eee6d672e98fa8a23bc02" translate="yes" xml:space="preserve">
          <source>This means that when a parameterized type being passed to a method will &lt;em&gt;produce&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be retrieved from it in some way), &lt;code&gt;? extends T&lt;/code&gt; should be used, since any instance of a subclass of &lt;code&gt;T&lt;/code&gt; is also a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">これは、メソッドに渡されるパラメーター化された型が &lt;code&gt;T&lt;/code&gt; のインスタンスを&lt;em&gt;生成する&lt;/em&gt;場合（それらは何らかの方法でTから取得される） &lt;code&gt;? extends T&lt;/code&gt; TのサブクラスのインスタンスもTであるため、 extends Tを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3e9bebc1e518710bd72da25726f74ae21f007bf" translate="yes" xml:space="preserve">
          <source>This principle states that:</source>
          <target state="translated">この原則は次のように述べています。</target>
        </trans-unit>
        <trans-unit id="2d3a389d50b6f05444764cd8371ecba25e982422" translate="yes" xml:space="preserve">
          <source>To illustrate this general phenomenon, consider the array type. For the type Animal we can make the type Animal[]</source>
          <target state="translated">この一般的な現象を説明するために,配列の型を考えてみましょう.Animal型に対しては,Animal[]型を作ることができます.</target>
        </trans-unit>
        <trans-unit id="a364d645d3f36c0aa43f84a2e9243fad90349b7d" translate="yes" xml:space="preserve">
          <source>Use a super wildcard when you only put values into a structure.</source>
          <target state="translated">構造体に値を入れるだけの場合はスーパーワイルドカードを使用します。</target>
        </trans-unit>
        <trans-unit id="bac4ad848c09d46df23cb670c0a8bb5f0b83f4e8" translate="yes" xml:space="preserve">
          <source>Use an extends wildcard when you only get values out of a structure.</source>
          <target state="translated">構造体から値だけを取り出す場合は、extendsワイルドカードを使用します。</target>
        </trans-unit>
        <trans-unit id="51109f31442287d55f2d09a788b36cab1528d667" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; wildcard if you need to retrieve object of
type &lt;code&gt;T&lt;/code&gt; from a collection.</source>
          <target state="translated">&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; コレクションから &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを取得する必要がある場合は、T&amp;gt;ワイルドカードを拡張します。</target>
        </trans-unit>
        <trans-unit id="a9cddb419fff1ae43f081fb34719fbb3ee8a99b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; wildcard if you need to put objects of type &lt;code&gt;T&lt;/code&gt; in
a collection.</source>
          <target state="translated">&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトをコレクションに入れる必要がある場合は、 super T&amp;gt;ワイルドカード。</target>
        </trans-unit>
        <trans-unit id="9fff184eaf718cb02db0d13177ddc1eedad31915" translate="yes" xml:space="preserve">
          <source>Using real life example (with some simplifications):</source>
          <target state="translated">実生活の例を使って(少し簡略化して)。</target>
        </trans-unit>
        <trans-unit id="f332c1ae4b070a0a1127f653ab5ef4f751816e05" translate="yes" xml:space="preserve">
          <source>What and why you &lt;strong&gt;can&lt;/strong&gt; add to this list?</source>
          <target state="translated">このリストに何を追加&lt;strong&gt;できるの&lt;/strong&gt;ですか？</target>
        </trans-unit>
        <trans-unit id="41c5d4cffd059abee38dc9ba81c94b883488b810" translate="yes" xml:space="preserve">
          <source>What is PECS (Producer Extends Consumer Super)</source>
          <target state="translated">PECS(Producer Extends Consumer Super)とは</target>
        </trans-unit>
        <trans-unit id="ea561a781fdf8bc0b8a203849b3201824311f82b" translate="yes" xml:space="preserve">
          <source>When a parameterized type being passed to a method will &lt;em&gt;consume&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be passed to it to do something), &lt;code&gt;? super T&lt;/code&gt; should be used because an instance of &lt;code&gt;T&lt;/code&gt; can legally be passed to any method that accepts some supertype of &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; could be used on a &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt;, for example. &lt;code&gt;? extends T&lt;/code&gt; would not work, because a &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; could not operate on a &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">メソッドに渡されるパラメーター化された型が &lt;code&gt;T&lt;/code&gt; のインスタンスを&lt;em&gt;消費する&lt;/em&gt;場合（それらは何かを行うためにそれに渡されます） &lt;code&gt;? super T&lt;/code&gt; Tのインスタンスは、 &lt;code&gt;T&lt;/code&gt; のスーパータイプを受け入れる任意のメソッドに合法的に渡すことができるため、 super Tを使用する必要があります。 たとえば、 &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; は &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt; で使用できます。 &lt;code&gt;? extends T&lt;/code&gt; &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; が &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt; 操作できなかったため、 extends Tは機能しません。</target>
        </trans-unit>
        <trans-unit id="f4a9baec8126cb0a0170c568b5aea0bc33af82ee" translate="yes" xml:space="preserve">
          <source>Why you cannot add objects that extend &quot;Shark&quot; in this list? like:</source>
          <target state="translated">なぜこのリストに &quot;Shark &quot;を拡張したオブジェクトを追加できないのか? みたいな。</target>
        </trans-unit>
        <trans-unit id="aba9f040c34c97dc5cbd78b7650ba76466656090" translate="yes" xml:space="preserve">
          <source>Within the type system of a programming language, a typing rule</source>
          <target state="translated">プログラミング言語の型システムの中で、型付けルール</target>
        </trans-unit>
        <trans-unit id="3fd437c172cae675972484db66485785fdb8066a" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;cannot&lt;/strong&gt; add types above Shark, because &lt;strong&gt;at runtime&lt;/strong&gt; the type of added object can be higher in hierarchy than the declared type of the list(X,Y,Z). This is not allowed.</source>
          <target state="translated">&lt;strong&gt;実行時&lt;/strong&gt;に追加されたオブジェクトのタイプは、リストの宣言されたタイプ（X、Y、Z）よりも階層が高くなる可能性があるため&lt;strong&gt;、&lt;/strong&gt; Sharkの上にタイプを追加&lt;strong&gt;できません&lt;/strong&gt; 。 これは許可されていません。</target>
        </trans-unit>
        <trans-unit id="bf7625e8d26c2b0876b7150314d221ce86efd5bf" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;put&lt;/strong&gt; a cargo in a freight car if the cargo has &lt;strong&gt;the same or smaller size&lt;/strong&gt; than the freight car = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">貨物の&lt;strong&gt;サイズ&lt;/strong&gt;が貨物車&lt;strong&gt;と同じか小さい&lt;/strong&gt;場合、貨物を貨物車に&lt;strong&gt;入れる&lt;/strong&gt;ことができます= &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt; super FreightCarSize&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27ab9c1a017fc3835a2ef84041c847cf90eccfdc" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;unload&lt;/strong&gt; a cargo from a freight car if you have &lt;strong&gt;enough place&lt;/strong&gt; (more than the size of the cargo) in your depot = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">デポに&lt;strong&gt;十分な場所&lt;/strong&gt; （貨物のサイズ以上）がある場合は、貨物車から貨物を&lt;strong&gt;降ろす&lt;/strong&gt;ことができます= &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt; DepotSize&amp;gt;を拡張します</target>
        </trans-unit>
        <trans-unit id="e0731813e0f463d46c84c89f3bedc307fd54c0b7" translate="yes" xml:space="preserve">
          <source>You can add the above types of objects because anything below shark(A,B,C) will always be subtypes of anything above shark (X,Y,Z). Easy to understand.</source>
          <target state="translated">shark(A,B,C)以下のものは常にshark(X,Y,Z)以上のもののサブタイプになるので、上記のタイプのオブジェクトを追加することができます。わかりやすいですね。</target>
        </trans-unit>
        <trans-unit id="71c65a7b69693d68a6243f298f05b0b401c6eaa6" translate="yes" xml:space="preserve">
          <source>let's assume this hierarchy:</source>
          <target state="translated">この階層を想定してみましょう。</target>
        </trans-unit>
        <trans-unit id="8166089d4e5973d45afee9a2427f45940137e452" translate="yes" xml:space="preserve">
          <source>mnemonic &amp;rarr; Get and Put principle.</source>
          <target state="translated">ニーモニック&amp;rarr;Get and Put原則。</target>
        </trans-unit>
        <trans-unit id="3fd49bc245a3f4fc5ae457330f6f619971d2fa99" translate="yes" xml:space="preserve">
          <source>more examples</source>
          <target state="translated">さらなる例</target>
        </trans-unit>
        <trans-unit id="9ea651794357473f0e72935b60c04eb349071726" translate="yes" xml:space="preserve">
          <source>write-only data types (sinks) can be &lt;strong&gt;contravariant&lt;/strong&gt;.</source>
          <target state="translated">書き込み専用のデータ型（シンク）は&lt;strong&gt;反変である&lt;/strong&gt;可能性があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
