<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2723397">
    <body>
      <group id="2723397">
        <trans-unit id="94c9db480f47df47185040411f9c95616b012de7" translate="yes" xml:space="preserve">
          <source>(adding an answer because never enough examples with Generics wildcards)</source>
          <target state="translated">(добавляя ответ,потому что никогда не хватает примеров с подстановочными знаками Дженерикс).</target>
        </trans-unit>
        <trans-unit id="7fc5b1f2bc2aaa5e44ba1bb9dfd44f3cf5667ee7" translate="yes" xml:space="preserve">
          <source>*You will say: &quot;OK, but why can't I add HammerSkark in it since it is the smallest type?&quot;. 
Answer: It is the smallest &lt;strong&gt;you&lt;/strong&gt; know. But HammerSkark can be extended too by somebody else and you end up in the same scenario.</source>
          <target state="translated">* Вы скажете: &amp;laquo;Хорошо, но почему я не могу добавить в него HammerSkark, так как это самый маленький тип?&amp;raquo;. Ответ: это самое маленькое, что &lt;strong&gt;вы&lt;/strong&gt; знаете. Но HammerSkark может быть расширен кем-то другим, и вы в конечном итоге в том же сценарии.</target>
        </trans-unit>
        <trans-unit id="d0174c51c975963bb39f928cbb22a18dcd04a81e" translate="yes" xml:space="preserve">
          <source>...but it has no way to tell if at runtime, your B will be a subtype or supertype of the list type. At runtime the list type can be any of the types A, B, C. So you cannot end up adding HammerSkark (super type) in a list of DeadHammerShark for example.</source>
          <target state="translated">...но он не может сказать,будет ли во время выполнения ваша B подтипом или супертипом типа списка.Во время исполнения список может быть любого из типов A,B,C.Таким образом,вы не можете в конце концов добавить HammerSkark (супертип),например,в список DeadHammerShark.</target>
        </trans-unit>
        <trans-unit id="f2e963c423df2749b3a7c70442dd69362bec49a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;generics&lt;/a&gt; and &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;examples&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/FAQSections/TypeArguments.html&quot;&gt;дженерики&lt;/a&gt; и &lt;a href=&quot;http://www.codejava.net/java-core/collections/generics-with-extends-and-super-wildcards-and-the-get-and-put-principle&quot;&gt;примеры&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a315a9a5442ad1949ff38821a17a1ccc8db468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov substitution principle:&lt;/a&gt;  if S is a subtype of T, then objects of type T may be replaced with objects of type S.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Принцип подстановки Лискова:&lt;/a&gt; если S является подтипом T, то объекты типа T могут быть заменены объектами типа S.</target>
        </trans-unit>
        <trans-unit id="84afdf7541023e94eb834fb4d55ad29bc2f8f383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is for &lt;strong&gt;reading&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; для &lt;strong&gt;чтения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5269c2a29c00dc63fdea0178f0dba0903385693b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is for &lt;strong&gt;writing&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; для &lt;strong&gt;письма&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be8228553ab50b13c364c53f104054de7dff4551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1: You want to go through the collection and do things with each item.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Случай 1: Вы хотите просмотреть коллекцию и сделать что-то с каждым предметом.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9feea5d372acd0600581c2c069b1ae87f772a292" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2: You want to add things to the collection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Случай 2: Вы хотите добавить вещи в коллекцию.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2d73dcd91708bc65136ea3f9780de244628654" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contravariance&lt;/strong&gt;: accept supertypes</source>
          <target state="translated">&lt;strong&gt;Контравариантность&lt;/strong&gt; : принимать супертипы</target>
        </trans-unit>
        <trans-unit id="db725287369ff6aa40b2dcc280781ca3c22c6f57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Covariance&lt;/strong&gt;: accept subtypes</source>
          <target state="translated">&lt;strong&gt;Ковариация&lt;/strong&gt; : принимать подтипы</target>
        </trans-unit>
        <trans-unit id="b78afe21d6d96b64853927ebc88812cf92d46c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify CS - Consumer Super:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Давайте уточним CS - Consumer Super:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0faa25525aa950fc903ca54e1b7840a251fc29a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's clarify PE - Producer Extends:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Давайте уточним PE - Производитель расширяет:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="243adf487fa4310c42089cb92177f6f400bb37d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To sum up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подводить итоги&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2a047cbdd36af0c85dd4fbc1928d9726e2003e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; to read objects of types equal or below T from list.&lt;/strong&gt; We cannot add element to it.</source>
          <target state="translated">&lt;strong&gt;Мы используем &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;расширяет T&amp;gt;, чтобы читать объекты типов, равных или ниже T из списка.&lt;/strong&gt; Мы не можем добавить элемент к нему.</target>
        </trans-unit>
        <trans-unit id="18d98376587fef5489dd624463bb41fcad1d3558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We use &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; to add objects of types equal or below T in list.&lt;/strong&gt; We cannot read from 
it.</source>
          <target state="translated">&lt;strong&gt;Мы используем &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;super T&amp;gt; для добавления объектов типов, равных или ниже T, в список.&lt;/strong&gt; Мы не можем читать из этого.</target>
        </trans-unit>
        <trans-unit id="b58638ffc0961485f562de00c7e06a30e7ab8e29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;bounded&lt;/strong&gt;(i.e. heading toward somewhere) &lt;strong&gt;wildcard&lt;/strong&gt; : There are 3 different flavours of wildcards:</source>
          <target state="translated">&lt;strong&gt;ограниченный&lt;/strong&gt; (т.е. направленный куда-то) &lt;strong&gt;подстановочный знак&lt;/strong&gt; : есть 3 различных вида подстановочных знаков:</target>
        </trans-unit>
        <trans-unit id="2b032ce66a5b0601c3c15a3a78fd9ab067544c4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt; if it reverses this ordering;</source>
          <target state="translated">&lt;strong&gt;контравариантно,&lt;/strong&gt; если оно отменяет этот порядок;</target>
        </trans-unit>
        <trans-unit id="758f69c0fcc2f45b755ce9abafa6f6d34557b2e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;contravariant&lt;/strong&gt;: an Animal[] is a Cat[];</source>
          <target state="translated">&lt;strong&gt;контравариант&lt;/strong&gt; : животное [] - это кошка [];</target>
        </trans-unit>
        <trans-unit id="0ba67e84f7f5c2e136ea9fe008b4b827013fff1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt; if it preserves the ordering of types (&amp;le;), which orders types from more specific to more generic;</source>
          <target state="translated">&lt;strong&gt;ковариантный,&lt;/strong&gt; если он сохраняет порядок типов (&amp;le;), который упорядочивает типы от более специфических к более общим;</target>
        </trans-unit>
        <trans-unit id="57bdc8d44fd6963ecd54c43806d679399b0772cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;covariant&lt;/strong&gt;: a Cat[] is an Animal[];</source>
          <target state="translated">&lt;strong&gt;ковариант&lt;/strong&gt; : кот [] - это животное [];</target>
        </trans-unit>
        <trans-unit id="db42607b786d14f36a7aa526ea5fd510862b8086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt; or nonvariant if neither of these applies.</source>
          <target state="translated">&lt;strong&gt;инвариантный&lt;/strong&gt; или &lt;strong&gt;неизменный,&lt;/strong&gt; если ни один из них не применим.</target>
        </trans-unit>
        <trans-unit id="e3cb78147cdbf377c8068f9d2520c0f0105d61db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;invariant&lt;/strong&gt;: an Animal[] is not a Cat[] and a Cat[] is not an Animal[].</source>
          <target state="translated">&lt;strong&gt;инвариант&lt;/strong&gt; : животное [] не является котом [], а кот [] не является животным [].</target>
        </trans-unit>
        <trans-unit id="debcd99be47f67dd6104bc343fd159ad003d445b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt; &quot;PECS&quot; is from the collection's point of view. If you are &lt;em&gt;only&lt;/em&gt; pulling items from a generic collection, it is a producer and you should use &lt;code&gt;extends&lt;/code&gt;; if you are &lt;em&gt;only&lt;/em&gt; stuffing items in, it is a consumer and you should use &lt;code&gt;super&lt;/code&gt;. If you do both with the same collection, you shouldn't use either &lt;code&gt;extends&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;tl; dr:&lt;/strong&gt; &quot;PECS&quot; с точки зрения коллекции. Если вы берете вещи &lt;em&gt;только&lt;/em&gt; из общей коллекции, это производитель, и вам следует использовать &lt;code&gt;extends&lt;/code&gt; ; если вы &lt;em&gt;только&lt;/em&gt; набиваете предметы, это потребитель, и вы должны использовать &lt;code&gt;super&lt;/code&gt; . Если вы делаете оба с одной коллекцией, вы не должны использовать ни &lt;code&gt;extends&lt;/code&gt; , ни &lt;code&gt;super&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f7361433754602bbcf1d9a29aebba3745f665e" translate="yes" xml:space="preserve">
          <source>And don&amp;rsquo;t use a wildcard when you both get and put.</source>
          <target state="translated">И не используйте подстановочный знак, когда вы оба получаете и ставите.</target>
        </trans-unit>
        <trans-unit id="92a0466119e2bd899c57cd76250f866ef981b73e" translate="yes" xml:space="preserve">
          <source>As I explain in &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;my answer&lt;/a&gt; to another question, PECS is a mnemonic device  created by Josh Bloch to help remember &lt;strong&gt;P&lt;/strong&gt;roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt;, &lt;strong&gt;C&lt;/strong&gt;onsumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt;.</source>
          <target state="translated">Как я объясняю в &lt;a href=&quot;https://stackoverflow.com/questions/2248390/java-generics-collections-max-signature-and-comparator/2248503#2248503&quot;&gt;своем ответе&lt;/a&gt; на другой вопрос, PECS - это мнемоническое устройство, созданное Джошем Блохом, чтобы помочь вспомнить &lt;strong&gt;P&lt;/strong&gt; roducer &lt;code&gt;&lt;strong&gt;e&lt;/strong&gt;xtends&lt;/code&gt; , Csumer &lt;code&gt;&lt;strong&gt;s&lt;/strong&gt;uper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec62dde14f33254d37ae93dbc06b4a2bf234df91" translate="yes" xml:space="preserve">
          <source>At runtime, the type of list can be any type above A: X, Y, Z, ...
The compiler can compile your assignment statement (which seems correct) but, &lt;strong&gt;at runtime&lt;/strong&gt; the type of s (Animal) can be lower in hierarchy than the declared type of the list(which could be Creature, or higher). This is not allowed.</source>
          <target state="translated">Во время выполнения тип списка может быть любого типа выше A: X, Y, Z, ... Компилятор может скомпилировать ваш оператор присваивания (который кажется правильным), но &lt;strong&gt;во время выполнения&lt;/strong&gt; тип s (Animal) может быть ниже в иерархия, чем объявленный тип списка (который может быть Существо или выше). Это не разрешено</target>
        </trans-unit>
        <trans-unit id="e95abb9ccd0e4b2eb4af253d08491c29fdcf4d82" translate="yes" xml:space="preserve">
          <source>But why you cannot read from this list?
(I mean you can get an element out of it, but you cannot assign it to anything other than Object o):</source>
          <target state="translated">Но почему ты не можешь прочитать из этого списка? (Я имею в виду,что вы можете получить элемент из него,но вы не можете присвоить его ничему,кроме Объекта o):</target>
        </trans-unit>
        <trans-unit id="82addeeaa5366725e5ce90ab68c1203f16326988" translate="yes" xml:space="preserve">
          <source>Can someone explain to me how to use PECS to resolve confusion between &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;?</source>
          <target state="translated">Может кто-нибудь объяснить мне, как использовать PECS для разрешения путаницы между &lt;code&gt;extends&lt;/code&gt; и &lt;code&gt;super&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="0de8ffe33606ed73d285b04ba05219d8f320a620" translate="yes" xml:space="preserve">
          <source>Co-variance: &lt;code&gt;? extends T&lt;/code&gt; (the family of all types that are subtypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with an &lt;strong&gt;upper bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;upper&lt;/strong&gt;-most class in the inheritance hierarchy. Use an &lt;code&gt;extends&lt;/code&gt; wildcard when you only &lt;strong&gt;Get&lt;/strong&gt; values out of a structure.</source>
          <target state="translated">Совместная дисперсия: &lt;code&gt;? extends T&lt;/code&gt; (семейство всех типов, являющихся подтипами &lt;code&gt;T&lt;/code&gt; ) - подстановочный знак с &lt;strong&gt;верхней границей&lt;/strong&gt; . &lt;code&gt;T&lt;/code&gt; - самый &lt;strong&gt;верхний&lt;/strong&gt; класс в иерархии наследования. Используйте подстановочный знак &lt;code&gt;extends&lt;/code&gt; , когда вы &lt;strong&gt;получаете&lt;/strong&gt; только значения из структуры.</target>
        </trans-unit>
        <trans-unit id="792f14ec22afb7780c6d54fb0239c36e3364259f" translate="yes" xml:space="preserve">
          <source>Consumer eat &lt;strong&gt;supper&lt;/strong&gt;(super); Producer &lt;strong&gt;extends&lt;/strong&gt; his parent's factory</source>
          <target state="translated">Потребитель ест &lt;strong&gt;ужин&lt;/strong&gt; (супер); Продюсер &lt;strong&gt;расширяет&lt;/strong&gt; фабрику своих родителей</target>
        </trans-unit>
        <trans-unit id="7a39ab9613e3042c6e7e014af6f86ec9338cfe1d" translate="yes" xml:space="preserve">
          <source>Contra-variance: &lt;code&gt;? super T&lt;/code&gt; ( the family of all types that are supertypes of  &lt;code&gt;T&lt;/code&gt;)  - a wildcard with a &lt;strong&gt;lower bound&lt;/strong&gt;. &lt;code&gt;T&lt;/code&gt; is the &lt;strong&gt;lower&lt;/strong&gt;-most class in the inheritance hierarchy. Use a &lt;code&gt;super&lt;/code&gt; wildcard when you only &lt;strong&gt;Put&lt;/strong&gt; values into a structure.</source>
          <target state="translated">Контрастность:? &lt;code&gt;? super T&lt;/code&gt; (семейство всех типов, которые являются супертипами &lt;code&gt;T&lt;/code&gt; ) - подстановочный знак с &lt;strong&gt;нижней границей&lt;/strong&gt; . &lt;code&gt;T&lt;/code&gt; - самый &lt;strong&gt;нижний&lt;/strong&gt; класс в иерархии наследования. Используйте &lt;code&gt;super&lt;/code&gt; подстановочный знак, когда вы только &lt;strong&gt;помещаете&lt;/strong&gt; значения в структуру.</target>
        </trans-unit>
        <trans-unit id="bcb46a38670d5684e40032813ada60b8db782bdc" translate="yes" xml:space="preserve">
          <source>Contravariance: &lt;code&gt;? super MyClass&lt;/code&gt; and</source>
          <target state="translated">Контравариантность: &lt;code&gt;? super MyClass&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="d937c29e908b0405c909dea8c24ce90e0401dbab" translate="yes" xml:space="preserve">
          <source>Covariance and contravariance</source>
          <target state="translated">ковариативность и противоречивость</target>
        </trans-unit>
        <trans-unit id="f9157e83e5e5e43a86a192add3cbb19c4a902ee5" translate="yes" xml:space="preserve">
          <source>Covariance: &lt;code&gt;? extends MyClass&lt;/code&gt;,</source>
          <target state="translated">Ковариация: &lt;code&gt;? extends MyClass&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9d8ce266eaaf430dcb92d6a97b29a357c42b1c8b" translate="yes" xml:space="preserve">
          <source>Covariant types are read-only, while contravariant types are write-only.</source>
          <target state="translated">Типы ковариантов доступны только для чтения,в то время как противоположные типы доступны только для записи.</target>
        </trans-unit>
        <trans-unit id="5ff8d99ff85262bb80d9645e82b59d40aa10406d" translate="yes" xml:space="preserve">
          <source>Example in Java:</source>
          <target state="translated">Пример на Java:</target>
        </trans-unit>
        <trans-unit id="52aa4da8fd2e6a5eb9adc65a2a6d779862e9e0fd" translate="yes" xml:space="preserve">
          <source>I came across PECS (short for &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;&lt;/em&gt;) while reading up on generics.</source>
          <target state="translated">Я сталкивался с PECS (сокращение от &lt;em&gt;Producer &lt;code&gt;extends&lt;/code&gt; и Consumer &lt;code&gt;super&lt;/code&gt; &lt;/em&gt; ), когда я читал об обобщениях.</target>
        </trans-unit>
        <trans-unit id="1fa3cb34eb411ebc2ed2bb349bdcd1d434c52545" translate="yes" xml:space="preserve">
          <source>I find &quot;PECS&quot; to be a non-obvious way to think of things regarding who is the &quot;producer&quot; and who is the &quot;consumer&quot;. &quot;PECS&quot; is defined from the perspective of the &lt;em&gt;data collection itself&lt;/em&gt; &amp;ndash; the collection &quot;consumes&quot; if objects are being written &lt;em&gt;to&lt;/em&gt; it (it is consuming objects from calling code), and it &quot;produces&quot; if objects are being read &lt;em&gt;from&lt;/em&gt; it (it is producing objects to some calling code). This is counter to how everything else is named though. Standard Java APIs are named from the perspective of the calling code, not the collection itself. For example, a collection-centric view of &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List&lt;/a&gt; should have a method named &quot;receive()&quot; instead of &quot;add()&quot; &amp;ndash; after all, the calling code &lt;em&gt;adds&lt;/em&gt; the element, but the list itself &lt;em&gt;receives&lt;/em&gt; the element.</source>
          <target state="translated">Я считаю, что &amp;laquo;PECS&amp;raquo; - это неочевидный способ думать о том, кто является &amp;laquo;производителем&amp;raquo;, а кто &amp;laquo;потребителем&amp;raquo;. &amp;laquo;PECS&amp;raquo; определяется с точки зрения самого &lt;em&gt;сбора данных&lt;/em&gt; - коллекция &amp;laquo;потребляет&amp;raquo;, если &lt;em&gt;в&lt;/em&gt; нее записываются объекты (она потребляет объекты из вызывающего кода), и &amp;laquo;выдает&amp;raquo;, если объекты читаются &lt;em&gt;из&lt;/em&gt; нее (это создает объекты для некоторого вызывающего кода). Это противоречит тому, как все остальное названо, хотя. Стандартные API Java названы с точки зрения вызывающего кода, а не самой коллекции. Например, представление &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/List.html&quot;&gt;java.util.List,&lt;/a&gt; ориентированное на коллекцию, должно иметь метод с именем &amp;laquo;receive ()&amp;raquo; вместо &amp;laquo;add ()&amp;raquo; - в конце концов, вызывающий код &lt;em&gt;добавляет&lt;/em&gt; элемент, но сам список &lt;em&gt;получает&lt;/em&gt; этот элемент.</target>
        </trans-unit>
        <trans-unit id="f70dc69f10ef0e3707d0f1d782b90670c0277a95" translate="yes" xml:space="preserve">
          <source>I think it's more intuitive, natural and consistent to think of things from the perspective of the code that interacts with the collection &amp;ndash; does the code &quot;read from&quot; or &quot;write to&quot; the collection? Following that, any code &lt;em&gt;writing to&lt;/em&gt; the collection would be the &quot;producer&quot;, and any code &lt;em&gt;reading from&lt;/em&gt; the collection would be the &quot;consumer&quot;.</source>
          <target state="translated">Я думаю, что более интуитивно, естественно и непротиворечиво думать о вещах с точки зрения кода, который взаимодействует с коллекцией - код &amp;laquo;читает из&amp;raquo; или &amp;laquo;записывает&amp;raquo; в коллекцию? После этого любой код, &lt;em&gt;записывающий&lt;/em&gt; в коллекцию, будет &amp;laquo;производителем&amp;raquo;, а любой код, &lt;em&gt;читающий из&lt;/em&gt; коллекции, будет &amp;laquo;потребителем&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a242e3017b6b235f2f1cad0170a3da1f29493ddf" translate="yes" xml:space="preserve">
          <source>If you need to satisfy both things, well, don&amp;rsquo;t use any wildcard. As
simple as that.</source>
          <target state="translated">Если вам нужно удовлетворить обе вещи, не используйте подстановочные знаки. Так просто.</target>
        </trans-unit>
        <trans-unit id="3ff73982c21deeffcbf3fabff242ab3939dc8f4a" translate="yes" xml:space="preserve">
          <source>Imagine a freight train with freight cars as analogy to a list.</source>
          <target state="translated">Представьте себе грузовой поезд с грузовыми вагонами по аналогии со списком.</target>
        </trans-unit>
        <trans-unit id="542e956f7c561ae14417ca5dec6f5c660bd4e428" translate="yes" xml:space="preserve">
          <source>In a nutshell, three easy rules to remember PECS:</source>
          <target state="translated">В двух словах,три простых правила для запоминания PECS:</target>
        </trans-unit>
        <trans-unit id="8a4881b5673370238cca2a8f7cfb01ce09b1a918" translate="yes" xml:space="preserve">
          <source>In practice, the compiler can indeed see at compiletime that you add a B:</source>
          <target state="translated">На практике компилятор действительно видит во время компиляции,что вы добавляете B:</target>
        </trans-unit>
        <trans-unit id="9e3209315080c6adff01ef992fafde853681897d" translate="yes" xml:space="preserve">
          <source>In the same hierarchy we can try this:</source>
          <target state="translated">В той же иерархии мы можем попробовать это:</target>
        </trans-unit>
        <trans-unit id="a35991e8ae7b3cdefb743f69bd37997a82ef4165" translate="yes" xml:space="preserve">
          <source>In-variance/Non-variance: &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;? extends Object&lt;/code&gt; - &lt;strong&gt;Unbounded&lt;/strong&gt; Wildcard. It stands for the family of  all types. Use when you both get and put.</source>
          <target state="translated">In-дисперсия / Non-дисперсия:? или &lt;code&gt;? extends Object&lt;/code&gt; расширяет объект - &lt;strong&gt;неограниченный&lt;/strong&gt; символ. Это обозначает семью всех типов. Используйте, когда вы оба получите и положите.</target>
        </trans-unit>
        <trans-unit id="9f5131c1bce167871d0602aaf46100b50f44f018" translate="yes" xml:space="preserve">
          <source>Invariance/non-variance: &lt;code&gt;MyClass&lt;/code&gt;</source>
          <target state="translated">Инвариантность / не дисперсия: &lt;code&gt;MyClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b34ec57577cc65d5dd83ffb987d46f94e6ba5fec" translate="yes" xml:space="preserve">
          <source>Java Examples:</source>
          <target state="translated">Примеры Java:</target>
        </trans-unit>
        <trans-unit id="cdfd21f603272833177a3b5803055b8c4cd7ba10" translate="yes" xml:space="preserve">
          <source>Mutable data types which act as both sources and sinks should be &lt;strong&gt;invariant&lt;/strong&gt;.</source>
          <target state="translated">Изменяемые типы данных, которые действуют как источники и приемники, должны быть &lt;strong&gt;инвариантными&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="833aacce639487ef510c515bcd37f1d614d40b8d" translate="yes" xml:space="preserve">
          <source>Note that generally you should only be using &lt;code&gt;? extends T&lt;/code&gt; and &lt;code&gt;? super T&lt;/code&gt; for the parameters of some method. Methods should just use &lt;code&gt;T&lt;/code&gt; as the type parameter on a generic return type.</source>
          <target state="translated">Обратите внимание, что, как правило, вы должны использовать только &lt;code&gt;? extends T&lt;/code&gt; расширяет Т а &lt;code&gt;? super T&lt;/code&gt; супер T для параметров некоторого метода. Методы должны просто использовать &lt;code&gt;T&lt;/code&gt; в качестве параметра типа для общего возвращаемого типа.</target>
        </trans-unit>
        <trans-unit id="da1cf385e1a0e937aefc400f70bb54b5a032605b" translate="yes" xml:space="preserve">
          <source>Note: wildcard &lt;code&gt;?&lt;/code&gt; means &lt;strong&gt;zero or one time&lt;/strong&gt;, represents an unknown type. The wildcard can be used as the type of a parameter, never used as a type argument for a generic method invocation, a generic class instance creation.(i.e. when used wildcard that reference not used in elsewhere in program like we use &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">Примечание: подстановочный знак &lt;code&gt;?&lt;/code&gt; означает &lt;strong&gt;ноль или один раз&lt;/strong&gt; , представляет неизвестный тип. Подстановочный знак может использоваться как тип параметра, никогда не использоваться в качестве аргумента типа для вызова универсального метода, создания экземпляра универсального класса (т. Е. Когда используется подстановочный знак, ссылка на который не используется в других частях программы, как мы используем &lt;code&gt;T&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d60e74b767eba2f856bb3390209305abe069b490" translate="yes" xml:space="preserve">
          <source>PECS (Producer &lt;code&gt;extends&lt;/code&gt; and Consumer &lt;code&gt;super&lt;/code&gt;)</source>
          <target state="translated">PECS (продюсер &lt;code&gt;extends&lt;/code&gt; и потребительский &lt;code&gt;super&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c43068ee8ac3bb66f51a56d8d5430ac6b0250806" translate="yes" xml:space="preserve">
          <source>Read-only data types (sources) can be &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant&lt;/a&gt;&lt;/strong&gt;;</source>
          <target state="translated">Типы данных (источники) только для чтения могут быть &lt;strong&gt;&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Covariant_return_type&quot;&gt;ковариантными&lt;/a&gt;&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="469b1b39e7e8f3f0037efadda112edbc369754e1" translate="yes" xml:space="preserve">
          <source>Remember this:</source>
          <target state="translated">Запомни это:</target>
        </trans-unit>
        <trans-unit id="7818c1bbe997fd084c4a2cfbbf415cbdcfe46a72" translate="yes" xml:space="preserve">
          <source>Since you have a list that can be of type A, B or C &lt;strong&gt;at runtime&lt;/strong&gt;, you cannot add any object of type A, B or C in it because you can end up with a combination that is not allowed in java.</source>
          <target state="translated">Поскольку у вас есть список, который может иметь тип A, B или C &lt;strong&gt;во время выполнения&lt;/strong&gt; , вы не можете добавить в него любой объект типа A, B или C, потому что вы можете получить комбинацию, которая не разрешена в Java.</target>
        </trans-unit>
        <trans-unit id="84fe0732dfcfb015eb1d8dee6237f1c112b6f071" translate="yes" xml:space="preserve">
          <source>Suppose you have a method that takes as its parameter a collection of things, but you want it to be more flexible than just accepting a &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Предположим, у вас есть метод, который принимает в качестве параметра коллекцию вещей, но вы хотите, чтобы он был более гибким, чем просто принятие &lt;code&gt;Collection&amp;lt;Thing&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155c1d5cc873d9cb3134648b29b4b7d445b4cafa" translate="yes" xml:space="preserve">
          <source>The picture below should explain the concept. Picture courtesy: &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Andrey Tyukin&lt;/a&gt;</source>
          <target state="translated">Картинка ниже должна объяснить концепцию. Фото предоставлено &lt;a href=&quot;https://stackoverflow.com/users/2707792/andrey-tyukin&quot;&gt;Андреем Тюкиным&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7de996a522beb1f3a3e9becda0f3a27d5119e4fb" translate="yes" xml:space="preserve">
          <source>The principles behind this in computer science is called</source>
          <target state="translated">Принципы,лежащие в основе этого в компьютерной науке,называются</target>
        </trans-unit>
        <trans-unit id="960f5c8f82ec1686cb5c7d0d4fd23d70586ca41e" translate="yes" xml:space="preserve">
          <source>The reasoning here is that unlike &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; can always hold a &lt;code&gt;Thing&lt;/code&gt; no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a &lt;code&gt;Thing&lt;/code&gt; to be added; this is what &lt;code&gt;? super Thing&lt;/code&gt; guarantees.</source>
          <target state="translated">Причина в том, что в отличие от &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; расширяет Вещи&amp;gt; , &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; super Thing&amp;gt; всегда может содержать &lt;code&gt;Thing&lt;/code&gt; независимо от того, какой тип является параметризованным. Здесь вас не волнует, что уже есть в списке, если это позволит добавить &lt;code&gt;Thing&lt;/code&gt; ; это что &lt;code&gt;? super Thing&lt;/code&gt; Супер вещь гарантирует.</target>
        </trans-unit>
        <trans-unit id="3c3e7f2fd0031e22e8b85562f6b569e88a41d88f" translate="yes" xml:space="preserve">
          <source>The reasoning is that a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; could hold any subtype of &lt;code&gt;Thing&lt;/code&gt;, and thus each element will behave as a &lt;code&gt;Thing&lt;/code&gt; when you perform your operation. (You actually cannot add anything to a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;, because you cannot know at runtime which &lt;em&gt;specific&lt;/em&gt; subtype of &lt;code&gt;Thing&lt;/code&gt; the collection holds.)</source>
          <target state="translated">Причина в том, что &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; extends Thing&amp;gt; может содержать любой подтип &lt;code&gt;Thing&lt;/code&gt; , и, таким образом, каждый элемент будет вести себя как &lt;code&gt;Thing&lt;/code&gt; при выполнении вашей операции. (На самом деле вы ничего не можете добавить в &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; , потому что вы не можете знать во время выполнения, какой &lt;em&gt;конкретный&lt;/em&gt; подтип &lt;code&gt;Thing&lt;/code&gt; содержит коллекция.)</target>
        </trans-unit>
        <trans-unit id="f9a08a5a59510bb09cbc96e347b2a0b74f30ce41" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;consumer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Тогда список является &lt;strong&gt;потребителем&lt;/strong&gt; , поэтому вы должны использовать &lt;code&gt;Collection&amp;lt;? super Thing&amp;gt;&lt;/code&gt; супер вещь&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="09c93ca7e342b67eb8cfeb62e6e19e9309b3e92b" translate="yes" xml:space="preserve">
          <source>Then the list is a &lt;strong&gt;producer&lt;/strong&gt;, so you should use a &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Тогда список является &lt;strong&gt;производителем&lt;/strong&gt; , поэтому вы должны использовать &lt;code&gt;Collection&amp;lt;? extends Thing&amp;gt;&lt;/code&gt; Вещи расширяет</target>
        </trans-unit>
        <trans-unit id="548dc4b3108193f86c38e631e743ba31ff65b60e" translate="yes" xml:space="preserve">
          <source>This is the clearest, simplest way for me think of extends vs. super:</source>
          <target state="translated">Это самый ясный,простой способ для меня подумать о продлении против супер:</target>
        </trans-unit>
        <trans-unit id="bce949b55a9a429ae77eee6d672e98fa8a23bc02" translate="yes" xml:space="preserve">
          <source>This means that when a parameterized type being passed to a method will &lt;em&gt;produce&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be retrieved from it in some way), &lt;code&gt;? extends T&lt;/code&gt; should be used, since any instance of a subclass of &lt;code&gt;T&lt;/code&gt; is also a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Это означает, что когда параметризованный тип, передаваемый методу, будет &lt;em&gt;создавать&lt;/em&gt; экземпляры &lt;code&gt;T&lt;/code&gt; (они будут каким-то образом извлечены из него) &lt;code&gt;? extends T&lt;/code&gt; extends T следует использовать, поскольку любой экземпляр подкласса &lt;code&gt;T&lt;/code&gt; также является &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3e9bebc1e518710bd72da25726f74ae21f007bf" translate="yes" xml:space="preserve">
          <source>This principle states that:</source>
          <target state="translated">Этот принцип гласит:</target>
        </trans-unit>
        <trans-unit id="2d3a389d50b6f05444764cd8371ecba25e982422" translate="yes" xml:space="preserve">
          <source>To illustrate this general phenomenon, consider the array type. For the type Animal we can make the type Animal[]</source>
          <target state="translated">Чтобы проиллюстрировать это общее явление,рассмотрим тип массива.Для типа Animal можно сделать тип Animal[].</target>
        </trans-unit>
        <trans-unit id="a364d645d3f36c0aa43f84a2e9243fad90349b7d" translate="yes" xml:space="preserve">
          <source>Use a super wildcard when you only put values into a structure.</source>
          <target state="translated">Используйте супер-символ,когда вы вводите значения только в структуру.</target>
        </trans-unit>
        <trans-unit id="bac4ad848c09d46df23cb670c0a8bb5f0b83f4e8" translate="yes" xml:space="preserve">
          <source>Use an extends wildcard when you only get values out of a structure.</source>
          <target state="translated">Используйте спецсимвол расширения,когда вы получаете значения только из структуры.</target>
        </trans-unit>
        <trans-unit id="51109f31442287d55f2d09a788b36cab1528d667" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; wildcard if you need to retrieve object of
type &lt;code&gt;T&lt;/code&gt; from a collection.</source>
          <target state="translated">Используйте &lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; расширяет T&amp;gt; подстановочным знаком, если вам нужно извлечь объект типа &lt;code&gt;T&lt;/code&gt; из коллекции.</target>
        </trans-unit>
        <trans-unit id="a9cddb419fff1ae43f081fb34719fbb3ee8a99b0" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; wildcard if you need to put objects of type &lt;code&gt;T&lt;/code&gt; in
a collection.</source>
          <target state="translated">Используйте &lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; super T&amp;gt; Подстановочный знак, если вам нужно поместить объекты типа &lt;code&gt;T&lt;/code&gt; в коллекцию.</target>
        </trans-unit>
        <trans-unit id="9fff184eaf718cb02db0d13177ddc1eedad31915" translate="yes" xml:space="preserve">
          <source>Using real life example (with some simplifications):</source>
          <target state="translated">На примере из реальной жизни (с некоторыми упрощениями):</target>
        </trans-unit>
        <trans-unit id="f332c1ae4b070a0a1127f653ab5ef4f751816e05" translate="yes" xml:space="preserve">
          <source>What and why you &lt;strong&gt;can&lt;/strong&gt; add to this list?</source>
          <target state="translated">Что и почему вы &lt;strong&gt;можете&lt;/strong&gt; добавить в этот список?</target>
        </trans-unit>
        <trans-unit id="41c5d4cffd059abee38dc9ba81c94b883488b810" translate="yes" xml:space="preserve">
          <source>What is PECS (Producer Extends Consumer Super)</source>
          <target state="translated">Что такое PECS (Producer Extends Consumer Super-продлевает супер-потребителя)</target>
        </trans-unit>
        <trans-unit id="ea561a781fdf8bc0b8a203849b3201824311f82b" translate="yes" xml:space="preserve">
          <source>When a parameterized type being passed to a method will &lt;em&gt;consume&lt;/em&gt; instances of &lt;code&gt;T&lt;/code&gt; (they will be passed to it to do something), &lt;code&gt;? super T&lt;/code&gt; should be used because an instance of &lt;code&gt;T&lt;/code&gt; can legally be passed to any method that accepts some supertype of &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; could be used on a &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt;, for example. &lt;code&gt;? extends T&lt;/code&gt; would not work, because a &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; could not operate on a &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Когда параметризованный тип, передаваемый методу, будет &lt;em&gt;использовать&lt;/em&gt; экземпляры &lt;code&gt;T&lt;/code&gt; (они будут переданы ему для выполнения чего-либо) &lt;code&gt;? super T&lt;/code&gt; super T следует использовать, потому что экземпляр &lt;code&gt;T&lt;/code&gt; может быть юридически передан любому методу, который принимает некоторый супертип &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;Comparator&amp;lt;Number&amp;gt;&lt;/code&gt; может использоваться, например, в &lt;code&gt;Collection&amp;lt;Integer&amp;gt;&lt;/code&gt; . &lt;code&gt;? extends T&lt;/code&gt; Расширение T не будет работать, потому что &lt;code&gt;Comparator&amp;lt;Integer&amp;gt;&lt;/code&gt; не может работать с &lt;code&gt;Collection&amp;lt;Number&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a9baec8126cb0a0170c568b5aea0bc33af82ee" translate="yes" xml:space="preserve">
          <source>Why you cannot add objects that extend &quot;Shark&quot; in this list? like:</source>
          <target state="translated">Почему нельзя добавлять объекты,которые расширяют &quot;Акулу&quot; в этот список? Например:</target>
        </trans-unit>
        <trans-unit id="aba9f040c34c97dc5cbd78b7650ba76466656090" translate="yes" xml:space="preserve">
          <source>Within the type system of a programming language, a typing rule</source>
          <target state="translated">В рамках системы типов языка программирования правило набора текста</target>
        </trans-unit>
        <trans-unit id="3fd437c172cae675972484db66485785fdb8066a" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;cannot&lt;/strong&gt; add types above Shark, because &lt;strong&gt;at runtime&lt;/strong&gt; the type of added object can be higher in hierarchy than the declared type of the list(X,Y,Z). This is not allowed.</source>
          <target state="translated">Вы &lt;strong&gt;не можете&lt;/strong&gt; добавлять типы выше Shark, потому что &lt;strong&gt;во время выполнения&lt;/strong&gt; тип добавленного объекта может быть выше в иерархии, чем объявленный тип списка (X, Y, Z). Это не разрешено</target>
        </trans-unit>
        <trans-unit id="bf7625e8d26c2b0876b7150314d221ce86efd5bf" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;put&lt;/strong&gt; a cargo in a freight car if the cargo has &lt;strong&gt;the same or smaller size&lt;/strong&gt; than the freight car = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Вы можете &lt;strong&gt;поместить&lt;/strong&gt; груз в грузовой вагон, если груз имеет &lt;strong&gt;такой же или меньший размер,&lt;/strong&gt; чем грузовой вагон = &lt;code&gt;&amp;lt;? super FreightCarSize&amp;gt;&lt;/code&gt; супер FreightCarSize&amp;gt;</target>
        </trans-unit>
        <trans-unit id="27ab9c1a017fc3835a2ef84041c847cf90eccfdc" translate="yes" xml:space="preserve">
          <source>You can &lt;strong&gt;unload&lt;/strong&gt; a cargo from a freight car if you have &lt;strong&gt;enough place&lt;/strong&gt; (more than the size of the cargo) in your depot = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Вы можете &lt;strong&gt;выгрузить&lt;/strong&gt; груз из грузового вагона, если у вас &lt;strong&gt;достаточно места&lt;/strong&gt; (больше, чем размер груза) в вашем депо = &lt;code&gt;&amp;lt;? extends DepotSize&amp;gt;&lt;/code&gt; расширяет DepotSize&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e0731813e0f463d46c84c89f3bedc307fd54c0b7" translate="yes" xml:space="preserve">
          <source>You can add the above types of objects because anything below shark(A,B,C) will always be subtypes of anything above shark (X,Y,Z). Easy to understand.</source>
          <target state="translated">Вы можете добавить вышеуказанные типы объектов,потому что все,что находится ниже акулы(A,B,C),всегда будет подтипом всего,что находится выше акулы (X,Y,Z).Легко понять.</target>
        </trans-unit>
        <trans-unit id="71c65a7b69693d68a6243f298f05b0b401c6eaa6" translate="yes" xml:space="preserve">
          <source>let's assume this hierarchy:</source>
          <target state="translated">давайте предположим,что это иерархия:</target>
        </trans-unit>
        <trans-unit id="8166089d4e5973d45afee9a2427f45940137e452" translate="yes" xml:space="preserve">
          <source>mnemonic &amp;rarr; Get and Put principle.</source>
          <target state="translated">мнемоника &amp;rarr; принцип &amp;laquo;получи и положи&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3fd49bc245a3f4fc5ae457330f6f619971d2fa99" translate="yes" xml:space="preserve">
          <source>more examples</source>
          <target state="translated">дополнительные примеры</target>
        </trans-unit>
        <trans-unit id="9ea651794357473f0e72935b60c04eb349071726" translate="yes" xml:space="preserve">
          <source>write-only data types (sinks) can be &lt;strong&gt;contravariant&lt;/strong&gt;.</source>
          <target state="translated">Только для записи типы данных (приемники) могут быть &lt;strong&gt;контравариантными&lt;/strong&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
