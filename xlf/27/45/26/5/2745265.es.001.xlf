<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2745265">
    <body>
      <group id="2745265">
        <trans-unit id="90a10e20bd2c8e7f512a36f9986e6bd625a12b68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt; means their type information is fully available at runtime.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reificable&lt;/a&gt; significa que su informaci&amp;oacute;n de tipo est&amp;aacute; totalmente disponible en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d492a733adb02b8320864e88f8357ed772fc394d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; subclass of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;strong&gt;no&lt;/strong&gt; es &lt;strong&gt;una&lt;/strong&gt; subclase de &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b38d828fcef53ec9e2076c3fa73400ff6ed0737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; isn't-a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;&lt;strong&gt;in Java&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; no es una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; &lt;strong&gt;en Java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63014900394aa67a0cc9fc3284de4e4252474b9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Animal&lt;/strong&gt; (Parent)</source>
          <target state="translated">&lt;strong&gt;Animal&lt;/strong&gt; (padre)</target>
        </trans-unit>
        <trans-unit id="e0fe91def2724cfdeae839f5686512b73124e94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays are &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;reifiable&lt;/a&gt; and covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Las matrices son &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;reificables&lt;/a&gt; y covariantes&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4e328038c60dede3020d85585548cc6d876f670a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But&lt;/strong&gt;&lt;code&gt;Dog[]&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; subclass of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Pero&lt;/strong&gt; &lt;code&gt;Dog[]&lt;/code&gt; &lt;strong&gt;es una&lt;/strong&gt; subclase de &lt;code&gt;Animal[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3f40109f1f6807b64f388fb31fb0af45ca1e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dog&lt;/strong&gt; - &lt;strong&gt;Cat&lt;/strong&gt; (Children)</source>
          <target state="translated">&lt;strong&gt;Perro&lt;/strong&gt; - &lt;strong&gt;Gato&lt;/strong&gt; (Ni&amp;ntilde;os)</target>
        </trans-unit>
        <trans-unit id="304ec5ad8646d255b82e3edf25a0ad01d2c2de03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generics are &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;erased&lt;/a&gt; and invariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Los gen&amp;eacute;ricos son &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;borrados&lt;/a&gt; e invariables&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdca835127fee237411a140f68169f05cc675c3" translate="yes" xml:space="preserve">
          <source>A list of dogs is-a list of animals &lt;strong&gt;in English&lt;/strong&gt; (well, under a reasonable interpretation)</source>
          <target state="translated">Una lista de perros es una lista de animales &lt;strong&gt;en ingl&amp;eacute;s&lt;/strong&gt; (bueno, bajo una interpretaci&amp;oacute;n razonable)</target>
        </trans-unit>
        <trans-unit id="e3f7f1c5a95fabfdae274ff4f328ee3f1b9a462f" translate="yes" xml:space="preserve">
          <source>A point I think should be added to what &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;answers&lt;/a&gt; mention is that while</source>
          <target state="translated">Un punto que creo que deber&amp;iacute;a agregarse a lo que &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;otras&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;respuestas&lt;/a&gt; mencionan es que mientras</target>
        </trans-unit>
        <trans-unit id="6d7e1bb7645e004caf223707662fb2057339d98a" translate="yes" xml:space="preserve">
          <source>Actually you can use an interface to achieve what you want.</source>
          <target state="translated">En realidad puedes usar una interfaz para conseguir lo que quieras.</target>
        </trans-unit>
        <trans-unit id="344527118c80c2af2edf1e6d80bca72266b3175b" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt;, you cannot subsequently directly assign &lt;code&gt;animals&lt;/code&gt; to either &lt;code&gt;dogs&lt;/code&gt; or &lt;code&gt;cats&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de llamar a &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt; , posteriormente no puede asignar &lt;code&gt;animals&lt;/code&gt; directamente a &lt;code&gt;dogs&lt;/code&gt; o &lt;code&gt;cats&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e68eb3128cd4e3b375fed2af8ca940aea40c8999" translate="yes" xml:space="preserve">
          <source>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are &lt;code&gt;List&lt;/code&gt; instances. Specialising a &lt;code&gt;List&lt;/code&gt; by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</source>
          <target state="translated">Otro argumento por el que la covarianza no tiene sentido en el caso de las clases gen&amp;eacute;ricas es el hecho de que, en la base, todas las clases son iguales: son instancias de &lt;code&gt;List&lt;/code&gt; . La especializaci&amp;oacute;n de una &lt;code&gt;List&lt;/code&gt; a al completar el argumento gen&amp;eacute;rico no extiende la clase, solo hace que funcione para ese argumento gen&amp;eacute;rico en particular.</target>
        </trans-unit>
        <trans-unit id="7a959cb20c2a75f6a5e8944beb44f43926299f02" translate="yes" xml:space="preserve">
          <source>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</source>
          <target state="translated">Como ha dicho @Jon Skeet,este código es ilegal,porque de lo contrario violaría las restricciones de tipo al devolver un gato cuando un perro lo esperaba.</target>
        </trans-unit>
        <trans-unit id="9e0ea5bc85b2c61dce27b3c8ed31b0557f59af05" translate="yes" xml:space="preserve">
          <source>Assume the following hierarchy -</source>
          <target state="translated">Supongamos la siguiente jerarquía -</target>
        </trans-unit>
        <trans-unit id="381c0989adf609934d9987de7750f37d8d6422bb" translate="yes" xml:space="preserve">
          <source>At the deepest level, the problem here is that &lt;code&gt;dogs&lt;/code&gt; and &lt;code&gt;animals&lt;/code&gt; share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</source>
          <target state="translated">En el nivel m&amp;aacute;s profundo, el problema aqu&amp;iacute; es que los &lt;code&gt;dogs&lt;/code&gt; y los &lt;code&gt;animals&lt;/code&gt; comparten una referencia. Eso significa que una forma de hacer que esto funcione ser&amp;iacute;a copiar la lista completa, lo que romper&amp;iacute;a la igualdad de referencia:</target>
        </trans-unit>
        <trans-unit id="2eda859b24b9c57e6183b93096e9b63efeaee18e" translate="yes" xml:space="preserve">
          <source>E. g.,</source>
          <target state="translated">E.g.,</target>
        </trans-unit>
        <trans-unit id="204aa29f1c9a6ab4ac20c77ee47b170439787c52" translate="yes" xml:space="preserve">
          <source>For obvious reasons, that chose the first way.</source>
          <target state="translated">Por razones obvias,que eligió el primer camino.</target>
        </trans-unit>
        <trans-unit id="17d3a2e5b2ebbd18c169ee52622d864801d45a32" translate="yes" xml:space="preserve">
          <source>Further to the answer by Jon Skeet, which uses this example code:</source>
          <target state="translated">En relación con la respuesta de Jon Skeet,que utiliza este código de ejemplo:</target>
        </trans-unit>
        <trans-unit id="96f1150d546de158ef07e02fb89e723cc69163ca" translate="yes" xml:space="preserve">
          <source>I understand that this is Java's behavior. My question is &lt;em&gt;why&lt;/em&gt;? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</source>
          <target state="translated">Entiendo que este es el comportamiento de Java. Mi pregunta es &lt;em&gt;por qu&amp;eacute;&lt;/em&gt; &amp;iquest;Por qu&amp;eacute; el polimorfismo es generalmente impl&amp;iacute;cito, pero cuando se trata de gen&amp;eacute;ricos debe especificarse?</target>
        </trans-unit>
        <trans-unit id="fccd4d39d44d0871993dd57d00b01ed07c504c36" translate="yes" xml:space="preserve">
          <source>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</source>
          <target state="translated">Yo diría que el objetivo de los genéricos es que no permiten eso.Considere la situación con los arreglos,que sí permiten ese tipo de covarianza:</target>
        </trans-unit>
        <trans-unit id="01e70d4e3c86e0b7b2d3599eb15c5d79e5389855" translate="yes" xml:space="preserve">
          <source>I'm a bit confused about how Java generics handle inheritance / polymorphism.</source>
          <target state="translated">Estoy un poco confundido sobre cómo los genéricos de Java manejan el polimorfismo de la herencia.</target>
        </trans-unit>
        <trans-unit id="a2c736ed9244357382e64aceca74b1e587e71857" translate="yes" xml:space="preserve">
          <source>If you are sure that the list items are subclasses of that given super type you can cast the list using this approach:</source>
          <target state="translated">Si estás seguro de que los elementos de la lista son subclases de ese supertipo dado,puedes lanzar la lista usando este enfoque:</target>
        </trans-unit>
        <trans-unit id="604f0777accde51cdb9a2e95bba2b694a31efdec" translate="yes" xml:space="preserve">
          <source>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</source>
          <target state="translated">En conclusión,la seguridad en tiempo de ejecución no es posible para los tipos parametrizados,ya que el compilador sustituye cada tipo parametrizado por su borrado.Esto hace que los tipos parametrizados no sean más que azúcar sintáctico.</target>
        </trans-unit>
        <trans-unit id="c6df8c875d5596e81ece51df756bb5a6e3e44560" translate="yes" xml:space="preserve">
          <source>In most cases, we can use &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; rather then &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; to a &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, podemos usar &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; extiende T&amp;gt; en lugar de &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; y esa deber&amp;iacute;a ser la primera opci&amp;oacute;n. Sin embargo, estoy encontrando casos en los que no es f&amp;aacute;cil hacer eso. Est&amp;aacute; en debate si eso es siempre lo mejor que se puede hacer. Estoy presentando aqu&amp;iacute; una clase DownCastCollection que puede convertir una &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; extiende T&amp;gt; a una &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (podemos definir clases similares para List, Set, NavigableSet, ..) que se utilizar&amp;aacute;n cuando usar el enfoque est&amp;aacute;ndar es muy inconveniente. A continuaci&amp;oacute;n se muestra un ejemplo de c&amp;oacute;mo usarlo (tambi&amp;eacute;n podr&amp;iacute;amos usar &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; en este caso, pero lo mantengo simple para ilustrar usando DownCastCollection.</target>
        </trans-unit>
        <trans-unit id="1ffe7e463ad2cbcb1de6c5e2e33c9d5181c4568a" translate="yes" xml:space="preserve">
          <source>In the code below if generics were covariant it will be possible to make &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;heap pollution&lt;/a&gt; at line 3.</source>
          <target state="translated">En el siguiente c&amp;oacute;digo, si los gen&amp;eacute;ricos son covariantes, ser&amp;aacute; posible &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;generar contaminaci&amp;oacute;n por pilas&lt;/a&gt; en la l&amp;iacute;nea 3.</target>
        </trans-unit>
        <trans-unit id="db0d547b9a45e2cd6f0e18b37f983db0f182eec3" translate="yes" xml:space="preserve">
          <source>Instead of the above, we have to define relationships between the types we use.</source>
          <target state="translated">En lugar de lo anterior,tenemos que definir las relaciones entre los tipos que usamos.</target>
        </trans-unit>
        <trans-unit id="99aa3435dd6dd09d2f123ec6780ffb6b4b0e2c9e" translate="yes" xml:space="preserve">
          <source>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</source>
          <target state="translated">La subtipificación invariable asegura que no se violen las restricciones de tipo impuestas por Java.Considere el siguiente código dado por @Jon Skeet:</target>
        </trans-unit>
        <trans-unit id="29a4d80153ea7b51095ece74755bb5043916df2f" translate="yes" xml:space="preserve">
          <source>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic</source>
          <target state="translated">Es la lista &lt;dog&gt; una subclase de lista &lt;animal&gt; ? &amp;iquest;Por qu&amp;eacute; los gen&amp;eacute;ricos de Java no son polim&amp;oacute;rficos impl&amp;iacute;citamente? &lt;/animal&gt;&lt;/dog&gt;</target>
        </trans-unit>
        <trans-unit id="91db49b2b9e77ed757d10476e32752227a891692" translate="yes" xml:space="preserve">
          <source>It is instructive to compare the above to analogous code for arrays.</source>
          <target state="translated">Es instructivo comparar lo anterior con el código análogo de las matrices.</target>
        </trans-unit>
        <trans-unit id="3ed717cb0f96ab9f0d80c86ad25d852eb370af29" translate="yes" xml:space="preserve">
          <source>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the &lt;code&gt;? extends Foo&lt;/code&gt; in method declarations, but that does add additional complexity.</source>
          <target state="translated">Ser&amp;iacute;a &amp;uacute;til agregar sintaxis para permitir que los par&amp;aacute;metros de tipo se especifiquen como covariantes, lo que evita el &lt;code&gt;? extends Foo&lt;/code&gt; extiende Foo en las declaraciones de m&amp;eacute;todos, pero eso agrega complejidad adicional.</target>
        </trans-unit>
        <trans-unit id="e1b88103aa22a4125409bcc1ce1af145750f709c" translate="yes" xml:space="preserve">
          <source>It's vice versa for generics:</source>
          <target state="translated">Es viceversa para los genéricos:</target>
        </trans-unit>
        <trans-unit id="6d9e846d6c182c9be543e2edb9fad821781f6e1c" translate="yes" xml:space="preserve">
          <source>Lets take the example from JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;tutorial&lt;/a&gt;</source>
          <target state="translated">Tomemos el ejemplo del &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;tutorial de&lt;/a&gt; JavaSE</target>
        </trans-unit>
        <trans-unit id="db49ead253373ebf491e45d83a3eaede6658b135" translate="yes" xml:space="preserve">
          <source>More generally, &lt;strong&gt;OP's intuition lends itself towards a language in which operations on objects can change their type&lt;/strong&gt;, or rather, an object's type(s) is a (dynamic) function of its value.</source>
          <target state="translated">En t&amp;eacute;rminos m&amp;aacute;s generales, &lt;strong&gt;la intuici&amp;oacute;n de OP se presta hacia un lenguaje en el que las operaciones en los objetos pueden cambiar su tipo&lt;/strong&gt; , o m&amp;aacute;s bien, el tipo (s) de un objeto es una funci&amp;oacute;n (din&amp;aacute;mica) de su valor.</target>
        </trans-unit>
        <trans-unit id="59becb84eaea3240c06cacb7affabdb553d2b2d4" translate="yes" xml:space="preserve">
          <source>No, a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. Consider what you can do with a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - you can add &lt;em&gt;any&lt;/em&gt; animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</source>
          <target state="translated">No, una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; es una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; . Considere lo que puede hacer con una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; : puede agregarle &lt;em&gt;cualquier&lt;/em&gt; animal ... incluido un gato. Ahora, &amp;iquest;puedes agregar l&amp;oacute;gicamente un gato a una camada de cachorros? Absolutamente no.</target>
        </trans-unit>
        <trans-unit id="169a8aa30694368f01ec9a80e5d310b4a4fa72a0" translate="yes" xml:space="preserve">
          <source>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</source>
          <target state="translated">Ahora,si java permite al llamante añadir la lista de tipo Animal a este método,entonces puede que añada algo incorrecto en la colección y en tiempo de ejecución también se ejecutará debido al borrado de tipo.Mientras que en el caso de los arrays obtendrás una excepción en tiempo de ejecución para tales escenarios...</target>
        </trans-unit>
        <trans-unit id="b46664ca8654b90a0e162c4b3dff03b7d478ecda" translate="yes" xml:space="preserve">
          <source>Now the class:</source>
          <target state="translated">Ahora la clase:</target>
        </trans-unit>
        <trans-unit id="dc101928e56b106ed14a4a66b3e29f57d6fb1fc6" translate="yes" xml:space="preserve">
          <source>Now there are times where you need to be more flexible and that is what the &lt;code&gt;? super Class&lt;/code&gt; and &lt;code&gt;? extends Class&lt;/code&gt; are for. The former is when you need to insert into a type &lt;code&gt;Collection&lt;/code&gt; (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</source>
          <target state="translated">Ahora hay momentos en los que necesita ser m&amp;aacute;s flexible y eso es lo que &lt;code&gt;? super Class&lt;/code&gt; super clase y &lt;code&gt;? extends Class&lt;/code&gt; extiende la clase son para. La primera es cuando necesita insertar en una &lt;code&gt;Collection&lt;/code&gt; tipos (por ejemplo), y la segunda es cuando necesita leer de una manera segura. Pero la &amp;uacute;nica forma de hacer ambas cosas al mismo tiempo es tener un tipo espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="0fd32cdcc763728be3ed9548fd8cc6d813d21f84" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;can't&lt;/em&gt; add a &lt;code&gt;Cat&lt;/code&gt; to a &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; because you don't know it's a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;. You can retrieve a value and know that it will be an &lt;code&gt;Animal&lt;/code&gt;, but you can't add arbitrary animals. The reverse is true for &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; - in that case you can add an &lt;code&gt;Animal&lt;/code&gt; to it safely, but you don't know anything about what might be retrieved from it, because it could be a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Ahora, no &lt;em&gt;puede&lt;/em&gt; agregar un &lt;code&gt;Cat&lt;/code&gt; a una &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; extiende Animal&amp;gt; porque no sabes que es una &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; . Puede recuperar un valor y saber que ser&amp;aacute; un &lt;code&gt;Animal&lt;/code&gt; , pero no puede agregar animales arbitrarios. Lo contrario es cierto para la &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; super Animal&amp;gt; : en ese caso, puede agregarle un &lt;code&gt;Animal&lt;/code&gt; de forma segura, pero no sabe nada sobre lo que podr&amp;iacute;a recuperarse de &amp;eacute;l, porque podr&amp;iacute;a ser una &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8252d2eb721be021d186b1fa8f366cf90af2fe" translate="yes" xml:space="preserve">
          <source>OTOH, we could as well do</source>
          <target state="translated">OTOH,también podríamos hacer</target>
        </trans-unit>
        <trans-unit id="4f1b7d75431b202c7bc72bc61ee6387be8273957" translate="yes" xml:space="preserve">
          <source>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;erasure&lt;/a&gt;. This property is crucial meaning that it did not break backwards compatibility.</source>
          <target state="translated">Observe que el c&amp;oacute;digo traducido de los cuerpos de los m&amp;eacute;todos es id&amp;eacute;ntico. El compilador reemplaz&amp;oacute; cada tipo parametrizado por su &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;borrado&lt;/a&gt; . Esta propiedad es crucial, lo que significa que no rompi&amp;oacute; la compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="6f4ce7da4e6b06cef1e0b7c88880e970e5b28ba6" translate="yes" xml:space="preserve">
          <source>Obviously, this changes the semantics, since the lists &lt;code&gt;animals&lt;/code&gt; and &lt;code&gt;dogs&lt;/code&gt; are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a &lt;code&gt;Cat&lt;/code&gt; could be added to a list that is only supposed to contain &lt;code&gt;Dog&lt;/code&gt; objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</source>
          <target state="translated">Obviamente, esto cambia la sem&amp;aacute;ntica, ya que las listas de &lt;code&gt;animals&lt;/code&gt; y &lt;code&gt;dogs&lt;/code&gt; ya no se comparten, por lo que agregar a una lista no agrega a la otra (que es exactamente lo que desea, para evitar el problema de que un &lt;code&gt;Cat&lt;/code&gt; podr&amp;iacute;a agregarse a una lista). se supone que solo contiene objetos &lt;code&gt;Dog&lt;/code&gt; ). Adem&amp;aacute;s, copiar toda la lista puede ser ineficiente. Sin embargo, esto resuelve el problema de equivalencia de tipo, al romper la igualdad de referencia.</target>
        </trans-unit>
        <trans-unit id="5d8a48922072f2b11fdf281f658f9367702184e2" translate="yes" xml:space="preserve">
          <source>So Java &quot;architects&quot; had 2 options which address this problem:</source>
          <target state="translated">Así que los &quot;arquitectos&quot; de Java tenían 2 opciones para resolver este problema:</target>
        </trans-unit>
        <trans-unit id="09f145bb0cec9dfa89cc809b42253f1893cd611d" translate="yes" xml:space="preserve">
          <source>So suppose I have a method &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt;. By all the rules of inheritance and polymorphism, I would assume that a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; and a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt;.</source>
          <target state="translated">Supongamos que tengo un m&amp;eacute;todo &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt; . Seg&amp;uacute;n todas las reglas de herencia y polimorfismo, supongo que una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;es&lt;/em&gt; una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; y una &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; &lt;em&gt;es&lt;/em&gt; una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; , por lo que cualquiera podr&amp;iacute;a pasarse a este m&amp;eacute;todo. No tan. Si quiero lograr este comportamiento, tengo que decirle expl&amp;iacute;citamente al m&amp;eacute;todo que acepte una lista de cualquier subclase de Animal diciendo &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cca9629e4bee6bd9d98e8f03a6ec1b01b5f8071f" translate="yes" xml:space="preserve">
          <source>So suppose there is a method as given below:</source>
          <target state="translated">Así que supongamos que hay un método como el que se indica a continuación:</target>
        </trans-unit>
        <trans-unit id="a199246c454ab2f91900765521747e50834f16f8" translate="yes" xml:space="preserve">
          <source>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</source>
          <target state="translated">Así que por qué una lista de perros (círculos)no debe ser considerada implícitamente una lista de animales (formas)es debido a esta situación:</target>
        </trans-unit>
        <trans-unit id="6c83895af74d72b8dc8bbd8e3db07cd62efff8e4" translate="yes" xml:space="preserve">
          <source>Subtyping is &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;invariant&lt;/a&gt; for parameterized types. Even tough the class &lt;code&gt;Dog&lt;/code&gt; is a subtype of &lt;code&gt;Animal&lt;/code&gt;, the parameterized type &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. In contrast, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;covariant&lt;/a&gt; subtyping is used by arrays, so the array
type &lt;code&gt;Dog[]&lt;/code&gt; is a subtype of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">El subtipo es &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;invariante&lt;/a&gt; para los tipos parametrizados. Incluso si la clase &lt;code&gt;Dog&lt;/code&gt; es un subtipo de &lt;code&gt;Animal&lt;/code&gt; , el tipo parametrizado &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; no es un subtipo de &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; . Por el contrario, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;las&lt;/a&gt; matrices utilizan el subtipo covariante , por lo que el tipo de matriz &lt;code&gt;Dog[]&lt;/code&gt; es un subtipo de &lt;code&gt;Animal[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ff2a1d25d6a239c07acd25dde697fc50a42eb9" translate="yes" xml:space="preserve">
          <source>Suddenly you have a &lt;em&gt;very&lt;/em&gt; confused cat.</source>
          <target state="translated">De repente tienes un gato &lt;em&gt;muy&lt;/em&gt; confundido.</target>
        </trans-unit>
        <trans-unit id="16d127ac7c16458178ca5e456a5c49755036fe42" translate="yes" xml:space="preserve">
          <source>That code compiles fine, but throws a runtime error (&lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</source>
          <target state="translated">Ese c&amp;oacute;digo se compila bien, pero arroja un error de tiempo de ejecuci&amp;oacute;n ( &lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; en la segunda l&amp;iacute;nea). No es de tipo seguro. El objetivo de Generics es agregar la seguridad del tipo de tiempo de compilaci&amp;oacute;n, de lo contrario, podr&amp;iacute;a seguir con una clase simple sin gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="584190794514e75254dea7c2060370444e691d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Generics in the Java Language&lt;/a&gt; and the &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;Section on Generics from the Java Tutorials&lt;/a&gt; have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</source>
          <target state="translated">Los &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;gen&amp;eacute;ricos en el lenguaje Java&lt;/a&gt; y la &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;secci&amp;oacute;n sobre gen&amp;eacute;ricos de los tutoriales de Java&lt;/a&gt; tienen una muy buena explicaci&amp;oacute;n en profundidad de por qu&amp;eacute; algunas cosas son o no polim&amp;oacute;rficas o est&amp;aacute;n permitidas con gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="cc94e800ea480646ce6ba48ed62ffc07b3b6d12a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;answer&lt;/a&gt;  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.</source>
          <target state="translated">La &lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;respuesta&lt;/a&gt; , as&amp;iacute; como otras respuestas, son correctas. Voy a agregar a esas respuestas una soluci&amp;oacute;n que creo que ser&amp;aacute; &amp;uacute;til. Creo que esto aparece a menudo en la programaci&amp;oacute;n. Una cosa a tener en cuenta es que para las Colecciones (Listas, Conjuntos, etc.) el problema principal es agregar a la Colecci&amp;oacute;n. Ah&amp;iacute; es donde las cosas se rompen. Incluso eliminar est&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="d4a722f5af2f92c06a2884931937c02445379d87" translate="yes" xml:space="preserve">
          <source>The answers given here didn't fully convince me. So instead, I make another example.</source>
          <target state="translated">Las respuestas dadas aquí no me convencieron del todo.Así que en vez de eso,doy otro ejemplo.</target>
        </trans-unit>
        <trans-unit id="fa4065cf11262ad86892b5d6301cc8618a09d2ee" translate="yes" xml:space="preserve">
          <source>The basis logic for such behavior is that &lt;code&gt;Generics&lt;/code&gt; follow a mechanism of type erasure. So at run time you have no way if identifying the type of &lt;code&gt;collection&lt;/code&gt; unlike &lt;code&gt;arrays&lt;/code&gt; where there is no such erasure process. So coming back to your question...</source>
          <target state="translated">La l&amp;oacute;gica b&amp;aacute;sica para tal comportamiento es que los &lt;code&gt;Generics&lt;/code&gt; siguen un mecanismo de borrado de tipo. Entonces, en el tiempo de ejecuci&amp;oacute;n, no tiene forma de identificar el tipo de &lt;code&gt;collection&lt;/code&gt; diferencia de las &lt;code&gt;arrays&lt;/code&gt; donde no existe dicho proceso de borrado. Volviendo a tu pregunta ...</target>
        </trans-unit>
        <trans-unit id="9c3267d922c893a40cc754519d5648d0800218f7" translate="yes" xml:space="preserve">
          <source>The code is legal. However, throws an &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;array store exception&lt;/a&gt;.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping.</source>
          <target state="translated">El c&amp;oacute;digo es legal. Sin embargo, arroja una &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;excepci&amp;oacute;n de tienda de matriz&lt;/a&gt; . Una matriz lleva su tipo en tiempo de ejecuci&amp;oacute;n de esta manera JVM puede hacer cumplir la seguridad de tipo de subtipo covariante.</target>
        </trans-unit>
        <trans-unit id="ec880e5540e317191d0eda22061ad1f16aa30ff0" translate="yes" xml:space="preserve">
          <source>The problem has been well-identified. But there's a solution; make &lt;em&gt;doSomething&lt;/em&gt; generic:</source>
          <target state="translated">El problema ha sido bien identificado. Pero hay una soluci&amp;oacute;n; hacer hacer algo gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="b6440d667672409bf8fb7e0306aea73bb570933b" translate="yes" xml:space="preserve">
          <source>The reason a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, is that, for example, you can insert a &lt;code&gt;Cat&lt;/code&gt; into a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, but not into a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is the similar to reading from a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; -- but not writing.</source>
          <target state="translated">La raz&amp;oacute;n por la que una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; no es una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; , es que, por ejemplo, puede insertar un &lt;code&gt;Cat&lt;/code&gt; en una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; , pero no en una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ... puede usar comodines para crear gen&amp;eacute;ricos m&amp;aacute;s extensibles donde sea posible; por ejemplo, leer desde una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; es similar a leer desde una &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; , pero no escribir.</target>
        </trans-unit>
        <trans-unit id="ba7ebd605e2db9f872e9f4dc2e8be52afa87b964" translate="yes" xml:space="preserve">
          <source>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</source>
          <target state="translated">La forma en que funciona la intuición de la OP-que es completamente válida,por supuesto-es la última frase.Sin embargo,si aplicamos esta intuición obtenemos un lenguaje que no es de tipo Java en su sistema de tipos:Supongamos que nuestro lenguaje permite añadir un gato a nuestra lista de perros.¿Qué significaría eso? Significaría que la lista deja de ser una lista de perros,y se mantiene como una mera lista de animales.Y una lista de mamíferos,y una lista de cuadrúpedos.</target>
        </trans-unit>
        <trans-unit id="23ce7e603788be5aab21ee61b091d1a2fa64148a" translate="yes" xml:space="preserve">
          <source>Therefore arrays provide runtime type safety but not compile-time type safety.</source>
          <target state="translated">Por lo tanto,los arreglos proveen seguridad de tipo de tiempo de ejecución pero no de tipo de tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="c5bfdde28ebbe167fa1e050e24ae8f4ad024ab30" translate="yes" xml:space="preserve">
          <source>Therefore generics can't provide runtime type safety, but they provide compile-time type safety.</source>
          <target state="translated">Por lo tanto,los genéricos no pueden proporcionar seguridad de tipo de tiempo de ejecución,pero proporcionan seguridad de tipo de tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="00c82895236a0a7a878e98ac644697c1418510bb" translate="yes" xml:space="preserve">
          <source>This is usefull when you want to pass the list in a constructor or iterate over it</source>
          <target state="translated">Esto es útil cuando quieres pasar la lista en un constructor o iterar sobre ella</target>
        </trans-unit>
        <trans-unit id="57e00388dd7cbaf4c88629658063578936e69c09" translate="yes" xml:space="preserve">
          <source>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....</source>
          <target state="translated">Así que en esencia este comportamiento se implementa para que uno no pueda agregar cosas malas a la colección.Ahora creo que el borrado de tipos existe para dar compatibilidad con el legado java sin genéricos...</target>
        </trans-unit>
        <trans-unit id="4786f210fd6512db64d73fcfd87384dc56d0b91a" translate="yes" xml:space="preserve">
          <source>Thus we have &lt;code&gt;ListOfAnimal&lt;/code&gt;, &lt;code&gt;ListOfDog&lt;/code&gt;, &lt;code&gt;ListOfCat&lt;/code&gt;, etc, which are distinct classes that end up being &quot;created&quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to &lt;code&gt;List&lt;/code&gt; is not a hierarchy at all).</source>
          <target state="translated">Por lo tanto, tenemos &lt;code&gt;ListOfAnimal&lt;/code&gt; , &lt;code&gt;ListOfDog&lt;/code&gt; , &lt;code&gt;ListOfCat&lt;/code&gt; , etc., que son clases distintas que terminan siendo &quot;creadas&quot; por el compilador cuando especificamos los argumentos gen&amp;eacute;ricos. Y esta es una jerarqu&amp;iacute;a plana (en realidad con respecto a la &lt;code&gt;List&lt;/code&gt; a no es una jerarqu&amp;iacute;a en absoluto).</target>
        </trans-unit>
        <trans-unit id="7a9a72b3362404704da9568bb6fb9462dc5392cf" translate="yes" xml:space="preserve">
          <source>To put it another way: A &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; in Java does not mean &quot;a list of dogs&quot; in English, it means &quot;a list which can have dogs, and nothing else&quot;.</source>
          <target state="translated">Para decirlo de otra manera: Una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; en Java no significa &quot;una lista de perros&quot; en ingl&amp;eacute;s, significa &quot;una lista que puede tener perros, y nada m&amp;aacute;s&quot;.</target>
        </trans-unit>
        <trans-unit id="48cb4ab7d62851fc151a15505099e94b0316692e" translate="yes" xml:space="preserve">
          <source>To understand the problem it's useful to make comparison to arrays.</source>
          <target state="translated">Para entender el problema es útil hacer una comparación con las matrices.</target>
        </trans-unit>
        <trans-unit id="d5a9aae8fbcc3e1f36369c98b0b7f2207dc564a1" translate="yes" xml:space="preserve">
          <source>To understand this further let's look at the bytecode generated by &lt;code&gt;javap&lt;/code&gt; of the class below:</source>
          <target state="translated">Para entender esto a&amp;uacute;n m&amp;aacute;s, veamos el bytecode generado por &lt;code&gt;javap&lt;/code&gt; de la clase a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="03dfd09db768e40e7564a1ad7500d78d1c2d2d78" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;javap -c Demonstration&lt;/code&gt;, this shows the following Java bytecode:</source>
          <target state="translated">Usando el comando &lt;code&gt;javap -c Demonstration&lt;/code&gt; , esto muestra el siguiente c&amp;oacute;digo de bytes de Java:</target>
        </trans-unit>
        <trans-unit id="754919ef9edabe390bb0a56957e1038bbadc51c3" translate="yes" xml:space="preserve">
          <source>We even can do</source>
          <target state="translated">Incluso podemos hacer</target>
        </trans-unit>
        <trans-unit id="a4a8f17fd0e17a7a59d13cdf7845711a3b9c6069" translate="yes" xml:space="preserve">
          <source>We should also take in consideration how the compiler threats the generic classes: in &quot;instantiates&quot; a different type whenever we fill the generic arguments.</source>
          <target state="translated">También debemos tener en cuenta cómo el compilador amenaza a las clases genéricas:en &quot;instanciar&quot; un tipo diferente cada vez que llenamos los argumentos genéricos.</target>
        </trans-unit>
        <trans-unit id="53afcffe1e893d87963a71f6d157ea0408568d23" translate="yes" xml:space="preserve">
          <source>What you are looking for is called &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;covariant type&lt;/a&gt; parameters&lt;/em&gt;. This means that if one type of object can be substituted for another in a method (for instance, &lt;code&gt;Animal&lt;/code&gt; can be replaced with &lt;code&gt;Dog&lt;/code&gt;), the same applies to expressions using those objects (so &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; could be replaced with &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;, and it is being used as a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.  What happens when you try to add a Cat to this &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; which is really a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;?  Automatically allowing type parameters to be covariant breaks the type system.</source>
          <target state="translated">Lo que est&amp;aacute; buscando se llama &lt;em&gt;par&amp;aacute;metros de &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;tipo covariante&lt;/a&gt;&lt;/em&gt; . Esto significa que si un tipo de objeto se puede sustituir por otro en un m&amp;eacute;todo (por ejemplo, &lt;code&gt;Animal&lt;/code&gt; se puede reemplazar con &lt;code&gt;Dog&lt;/code&gt; ), lo mismo se aplica a las expresiones que usan esos objetos (por lo que &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; podr&amp;iacute;a reemplazarse con &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ) El problema es que la covarianza no es segura para listas mutables en general. Supongamos que tiene una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; , y se est&amp;aacute; utilizando como &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; . &amp;iquest;Qu&amp;eacute; sucede cuando intentas agregar un gato a esta &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; que es realmente una &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ? Permitir autom&amp;aacute;ticamente que los par&amp;aacute;metros de tipo sean covariantes rompe el sistema de tipos.</target>
        </trans-unit>
        <trans-unit id="8d5d23c16bd63540ead2c74914ddab1e126bc3f6" translate="yes" xml:space="preserve">
          <source>another solution is to build a new list</source>
          <target state="translated">otra solución es construir una nueva lista</target>
        </trans-unit>
        <trans-unit id="6ed375dc664a800e63fb268753b8f59714929e45" translate="yes" xml:space="preserve">
          <source>consider the subtype to be it's supertype and restrict at compile the &quot;add&quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</source>
          <target state="translated">considerar que el subtipo es su supertipo y restringir al compilar el método &quot;add&quot; (por lo que en el método drawAll,si se pasara una lista de círculos,subtipo de forma,el compilador debería detectarlo y restringirlo con error de compilación para hacerlo).</target>
        </trans-unit>
        <trans-unit id="9a49e1031f2ed9d14b8f10116b441e35b8bd75c8" translate="yes" xml:space="preserve">
          <source>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</source>
          <target state="translated">no considerar que un subtipo está implícitamente es supertipo,y dar un error de compilación,como sucede ahora</target>
        </trans-unit>
        <trans-unit id="917a49b3ab1b964d351680a9d496835660c085e3" translate="yes" xml:space="preserve">
          <source>it is also true that</source>
          <target state="translated">también es cierto que</target>
        </trans-unit>
        <trans-unit id="3109cbe3b4d36e8f4714482083b76fe25ee4a957" translate="yes" xml:space="preserve">
          <source>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</source>
          <target state="translated">se asegura de que sólo podamos utilizar un proveedor que nos proporcione el tipo de objeto adecuado para el consumidor.</target>
        </trans-unit>
        <trans-unit id="34263cba8588e8a17ab060861593d2d646e5fba6" translate="yes" xml:space="preserve">
          <source>now you can call doSomething with either List&amp;lt;Dog&amp;gt; or List&amp;lt;Cat&amp;gt; or List&amp;lt;Animal&amp;gt;.</source>
          <target state="translated">ahora puede llamar a doSomething con List &amp;lt;Dog&amp;gt; o List &amp;lt;Cat&amp;gt; o List &amp;lt;Animal&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="d331fcedf530a8517412040f7d5855e4ea193dae" translate="yes" xml:space="preserve">
          <source>sounds fine, doesn't it? But you can only pass &lt;code&gt;Consumer&lt;/code&gt;s and &lt;code&gt;Supplier&lt;/code&gt;s for &lt;code&gt;Animal&lt;/code&gt;s. If you have a &lt;code&gt;Mammal&lt;/code&gt; consumer, but a &lt;code&gt;Duck&lt;/code&gt; supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</source>
          <target state="translated">suena bien, &amp;iquest;no? Pero solo puede pasar al &lt;code&gt;Consumer&lt;/code&gt; y al &lt;code&gt;Supplier&lt;/code&gt; para &lt;code&gt;Animal&lt;/code&gt; . Si tiene un consumidor de &lt;code&gt;Mammal&lt;/code&gt; , pero un proveedor de &lt;code&gt;Duck&lt;/code&gt; , no deber&amp;iacute;an encajar, aunque ambos son animales. Para no permitir esto, se han agregado restricciones adicionales.</target>
        </trans-unit>
        <trans-unit id="0326968b7f692e04985959e0b5f6e025c50d1747" translate="yes" xml:space="preserve">
          <source>therefore you can't put the wrong subtype of &lt;code&gt;Animal&lt;/code&gt; into the list, because there is no wrong subtype -- any object of subtype &lt;code&gt;? extends Animal&lt;/code&gt; can be added to &lt;code&gt;animals&lt;/code&gt;.</source>
          <target state="translated">por lo tanto, no puede poner el subtipo incorrecto de &lt;code&gt;Animal&lt;/code&gt; en la lista, porque no hay un subtipo incorrecto, &amp;iquest;alg&amp;uacute;n objeto de subtipo &lt;code&gt;? extends Animal&lt;/code&gt; se extiende Animal se puede agregar a los &lt;code&gt;animals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f38425b32961346a1ff8ec4c2f4f3802f76f7cb1" translate="yes" xml:space="preserve">
          <source>where we go the other way: we define the type of the &lt;code&gt;Supplier&lt;/code&gt; and restrict that it can be put into the &lt;code&gt;Consumer&lt;/code&gt;.</source>
          <target state="translated">hacia d&amp;oacute;nde vamos en sentido contrario: definimos el tipo de &lt;code&gt;Supplier&lt;/code&gt; y restringimos que se pueda poner en el &lt;code&gt;Consumer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b6ffb0d183ccad287984bf71c0f6ef92c471a6" translate="yes" xml:space="preserve">
          <source>where, having the intuitive relations &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt;, &lt;code&gt;Cat&lt;/code&gt; etc., we could even put a &lt;code&gt;Mammal&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer, but not a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer.</source>
          <target state="translated">donde, teniendo las relaciones intuitivas &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt; , &lt;code&gt;Cat&lt;/code&gt; , etc., incluso podr&amp;iacute;amos poner un &lt;code&gt;Mammal&lt;/code&gt; en un consumidor de &lt;code&gt;Life&lt;/code&gt; , pero no una &lt;code&gt;String&lt;/code&gt; en un consumidor de &lt;code&gt;Life&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8cb6da1df995798f3ac8506f94719679ef5c11c" translate="yes" xml:space="preserve">
          <source>you can then use the collections using</source>
          <target state="translated">puedes usar las colecciones usando</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
