<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2745265">
    <body>
      <group id="2745265">
        <trans-unit id="90a10e20bd2c8e7f512a36f9986e6bd625a12b68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt; means their type information is fully available at runtime.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt; означает, что информация о их типе полностью доступна во время выполнения.</target>
        </trans-unit>
        <trans-unit id="d492a733adb02b8320864e88f8357ed772fc394d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; subclass of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; является подклассом &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b38d828fcef53ec9e2076c3fa73400ff6ed0737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; isn't-a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;&lt;strong&gt;in Java&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; not-a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; &lt;strong&gt;в Java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63014900394aa67a0cc9fc3284de4e4252474b9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Animal&lt;/strong&gt; (Parent)</source>
          <target state="translated">&lt;strong&gt;Животное&lt;/strong&gt; (родитель)</target>
        </trans-unit>
        <trans-unit id="e0fe91def2724cfdeae839f5686512b73124e94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays are &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;reifiable&lt;/a&gt; and covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Массивы являются &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;переопределимыми&lt;/a&gt; и ковариантными&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4e328038c60dede3020d85585548cc6d876f670a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But&lt;/strong&gt;&lt;code&gt;Dog[]&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; subclass of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Но&lt;/strong&gt; &lt;code&gt;Dog[]&lt;/code&gt; &lt;strong&gt;является&lt;/strong&gt; подклассом &lt;code&gt;Animal[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3f40109f1f6807b64f388fb31fb0af45ca1e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dog&lt;/strong&gt; - &lt;strong&gt;Cat&lt;/strong&gt; (Children)</source>
          <target state="translated">&lt;strong&gt;Собака&lt;/strong&gt; - &lt;strong&gt;Кот&lt;/strong&gt; (Дети)</target>
        </trans-unit>
        <trans-unit id="304ec5ad8646d255b82e3edf25a0ad01d2c2de03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generics are &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;erased&lt;/a&gt; and invariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Обобщения &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;стираются&lt;/a&gt; и инвариантны&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdca835127fee237411a140f68169f05cc675c3" translate="yes" xml:space="preserve">
          <source>A list of dogs is-a list of animals &lt;strong&gt;in English&lt;/strong&gt; (well, under a reasonable interpretation)</source>
          <target state="translated">Список собак - это список животных &lt;strong&gt;на английском языке&lt;/strong&gt; (ну при разумной интерпретации)</target>
        </trans-unit>
        <trans-unit id="e3f7f1c5a95fabfdae274ff4f328ee3f1b9a462f" translate="yes" xml:space="preserve">
          <source>A point I think should be added to what &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;answers&lt;/a&gt; mention is that while</source>
          <target state="translated">Я думаю, что к тому, что упоминают &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;другие&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;ответы,&lt;/a&gt; следует добавить</target>
        </trans-unit>
        <trans-unit id="6d7e1bb7645e004caf223707662fb2057339d98a" translate="yes" xml:space="preserve">
          <source>Actually you can use an interface to achieve what you want.</source>
          <target state="translated">На самом деле,вы можете использовать интерфейс для достижения того,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="344527118c80c2af2edf1e6d80bca72266b3175b" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt;, you cannot subsequently directly assign &lt;code&gt;animals&lt;/code&gt; to either &lt;code&gt;dogs&lt;/code&gt; or &lt;code&gt;cats&lt;/code&gt;:</source>
          <target state="translated">После вызова &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt; впоследствии вы не можете напрямую назначать &lt;code&gt;animals&lt;/code&gt; ни &lt;code&gt;dogs&lt;/code&gt; ни &lt;code&gt;cats&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e68eb3128cd4e3b375fed2af8ca940aea40c8999" translate="yes" xml:space="preserve">
          <source>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are &lt;code&gt;List&lt;/code&gt; instances. Specialising a &lt;code&gt;List&lt;/code&gt; by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</source>
          <target state="translated">Другим аргументом, почему ковариация не имеет смысла в случае универсальных классов, является тот факт, что в основе все классы одинаковы - это экземпляры &lt;code&gt;List&lt;/code&gt; . Специализация &lt;code&gt;List&lt;/code&gt; путем заполнения универсального аргумента не расширяет класс, а просто заставляет его работать с этим конкретным универсальным аргументом.</target>
        </trans-unit>
        <trans-unit id="7a959cb20c2a75f6a5e8944beb44f43926299f02" translate="yes" xml:space="preserve">
          <source>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</source>
          <target state="translated">Как заявил @Jon Skeet,этот код является незаконным,потому что в противном случае он будет нарушать ограничения типа,возвращая кошку,когда собака ожидала.</target>
        </trans-unit>
        <trans-unit id="9e0ea5bc85b2c61dce27b3c8ed31b0557f59af05" translate="yes" xml:space="preserve">
          <source>Assume the following hierarchy -</source>
          <target state="translated">Допустим,следующая иерархия -</target>
        </trans-unit>
        <trans-unit id="381c0989adf609934d9987de7750f37d8d6422bb" translate="yes" xml:space="preserve">
          <source>At the deepest level, the problem here is that &lt;code&gt;dogs&lt;/code&gt; and &lt;code&gt;animals&lt;/code&gt; share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</source>
          <target state="translated">На самом глубоком уровне проблема заключается в том, что &lt;code&gt;dogs&lt;/code&gt; и &lt;code&gt;animals&lt;/code&gt; имеют общую ссылку. Это означает, что один из способов сделать эту работу - скопировать весь список, что нарушит равенство ссылок:</target>
        </trans-unit>
        <trans-unit id="2eda859b24b9c57e6183b93096e9b63efeaee18e" translate="yes" xml:space="preserve">
          <source>E. g.,</source>
          <target state="translated">Например..,</target>
        </trans-unit>
        <trans-unit id="204aa29f1c9a6ab4ac20c77ee47b170439787c52" translate="yes" xml:space="preserve">
          <source>For obvious reasons, that chose the first way.</source>
          <target state="translated">По очевидным причинам,это выбрало первый путь.</target>
        </trans-unit>
        <trans-unit id="17d3a2e5b2ebbd18c169ee52622d864801d45a32" translate="yes" xml:space="preserve">
          <source>Further to the answer by Jon Skeet, which uses this example code:</source>
          <target state="translated">В дополнение к ответу Джона Скита,который использует этот пример кода:</target>
        </trans-unit>
        <trans-unit id="96f1150d546de158ef07e02fb89e723cc69163ca" translate="yes" xml:space="preserve">
          <source>I understand that this is Java's behavior. My question is &lt;em&gt;why&lt;/em&gt;? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</source>
          <target state="translated">Я понимаю, что это поведение Java. У меня вопрос &lt;em&gt;почему&lt;/em&gt; ? Почему полиморфизм обычно неявный, но когда дело доходит до дженериков, он должен быть указан?</target>
        </trans-unit>
        <trans-unit id="fccd4d39d44d0871993dd57d00b01ed07c504c36" translate="yes" xml:space="preserve">
          <source>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</source>
          <target state="translated">Я бы сказал,что вся суть &quot;Дженерикс&quot; в том,что она этого не допускает.Рассмотрим ситуацию с массивами,которые допускают такой тип ковариаций:</target>
        </trans-unit>
        <trans-unit id="01e70d4e3c86e0b7b2d3599eb15c5d79e5389855" translate="yes" xml:space="preserve">
          <source>I'm a bit confused about how Java generics handle inheritance / polymorphism.</source>
          <target state="translated">Я немного запутался в том,как Java generics справляется с полиморфизмом наследования.</target>
        </trans-unit>
        <trans-unit id="a2c736ed9244357382e64aceca74b1e587e71857" translate="yes" xml:space="preserve">
          <source>If you are sure that the list items are subclasses of that given super type you can cast the list using this approach:</source>
          <target state="translated">Если вы уверены,что элементы списка являются подклассами данного супертипа,вы можете разыграть список,используя этот подход:</target>
        </trans-unit>
        <trans-unit id="604f0777accde51cdb9a2e95bba2b694a31efdec" translate="yes" xml:space="preserve">
          <source>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</source>
          <target state="translated">В заключение следует отметить,что безопасность выполнения для параметризованных типов невозможна,так как компилятор заменяет каждый параметризованный тип на его стирание.Это делает параметризованные типы не более чем синтаксическим сахаром.</target>
        </trans-unit>
        <trans-unit id="c6df8c875d5596e81ece51df756bb5a6e3e44560" translate="yes" xml:space="preserve">
          <source>In most cases, we can use &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; rather then &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; to a &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.</source>
          <target state="translated">В большинстве случаев мы можем использовать &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; расширяет T&amp;gt;, а не &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; и это должно быть первым выбором. Однако я нахожу случаи, когда это нелегко сделать. Это спор о том, всегда ли это лучше всего делать. Я представляю здесь класс DownCastCollection, который может принять преобразование &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; расширяет T&amp;gt; до &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (мы можем определить аналогичные классы для List, Set, NavigableSet, ..), которые будут использоваться при использовании стандартного подхода, очень неудобно. Ниже приведен пример того, как его использовать (в этом случае мы могли бы также использовать &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; , но я упрощаю проиллюстрировать его с помощью DownCastCollection.</target>
        </trans-unit>
        <trans-unit id="1ffe7e463ad2cbcb1de6c5e2e33c9d5181c4568a" translate="yes" xml:space="preserve">
          <source>In the code below if generics were covariant it will be possible to make &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;heap pollution&lt;/a&gt; at line 3.</source>
          <target state="translated">В приведенном ниже коде, если генерики были ковариантными, в строке 3 будет возможно &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;загрязнение кучи&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db0d547b9a45e2cd6f0e18b37f983db0f182eec3" translate="yes" xml:space="preserve">
          <source>Instead of the above, we have to define relationships between the types we use.</source>
          <target state="translated">Вместо вышесказанного мы должны определить отношения между типами,которые мы используем.</target>
        </trans-unit>
        <trans-unit id="99aa3435dd6dd09d2f123ec6780ffb6b4b0e2c9e" translate="yes" xml:space="preserve">
          <source>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</source>
          <target state="translated">Инвариантный подтипирование гарантирует,что ограничения типа,налагаемые Java,не будут нарушены.Рассмотрим следующий код,заданный @Jon Skeet:</target>
        </trans-unit>
        <trans-unit id="29a4d80153ea7b51095ece74755bb5043916df2f" translate="yes" xml:space="preserve">
          <source>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic</source>
          <target state="translated">Список &lt;dog&gt; подкласс List &lt;animal&gt; ? Почему дженерики Java не являются неявно полиморфными &lt;/animal&gt;&lt;/dog&gt;</target>
        </trans-unit>
        <trans-unit id="91db49b2b9e77ed757d10476e32752227a891692" translate="yes" xml:space="preserve">
          <source>It is instructive to compare the above to analogous code for arrays.</source>
          <target state="translated">Полезно сравнить вышеизложенное с аналогичным кодом для массивов.</target>
        </trans-unit>
        <trans-unit id="3ed717cb0f96ab9f0d80c86ad25d852eb370af29" translate="yes" xml:space="preserve">
          <source>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the &lt;code&gt;? extends Foo&lt;/code&gt; in method declarations, but that does add additional complexity.</source>
          <target state="translated">Было бы полезно добавить синтаксис, позволяющий указывать параметры типа как ковариантные, что позволяет избежать &lt;code&gt;? extends Foo&lt;/code&gt; расширяет Foo в объявлениях методов, но это добавляет дополнительную сложность.</target>
        </trans-unit>
        <trans-unit id="e1b88103aa22a4125409bcc1ce1af145750f709c" translate="yes" xml:space="preserve">
          <source>It's vice versa for generics:</source>
          <target state="translated">Для дженериков это наоборот:</target>
        </trans-unit>
        <trans-unit id="6d9e846d6c182c9be543e2edb9fad821781f6e1c" translate="yes" xml:space="preserve">
          <source>Lets take the example from JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;tutorial&lt;/a&gt;</source>
          <target state="translated">Давайте возьмем пример из &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;учебника по&lt;/a&gt; JavaSE</target>
        </trans-unit>
        <trans-unit id="db49ead253373ebf491e45d83a3eaede6658b135" translate="yes" xml:space="preserve">
          <source>More generally, &lt;strong&gt;OP's intuition lends itself towards a language in which operations on objects can change their type&lt;/strong&gt;, or rather, an object's type(s) is a (dynamic) function of its value.</source>
          <target state="translated">В более общем смысле, &lt;strong&gt;интуиция OP ориентирована на язык, в котором операции над объектами могут изменять свой тип&lt;/strong&gt; , или, скорее, тип (ы) объекта является (динамической) функцией его значения.</target>
        </trans-unit>
        <trans-unit id="59becb84eaea3240c06cacb7affabdb553d2b2d4" translate="yes" xml:space="preserve">
          <source>No, a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. Consider what you can do with a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - you can add &lt;em&gt;any&lt;/em&gt; animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</source>
          <target state="translated">Нет, &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; является &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; . Подумайте, что вы можете сделать с &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - вы можете добавить к нему &lt;em&gt;любое&lt;/em&gt; животное ... включая кошку. Теперь, вы можете логически добавить кошку в помет щенков? Точно нет.</target>
        </trans-unit>
        <trans-unit id="169a8aa30694368f01ec9a80e5d310b4a4fa72a0" translate="yes" xml:space="preserve">
          <source>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</source>
          <target state="translated">Теперь,если java позволяет вызывающему абоненту добавлять List of type Animal в этот метод,то вы можете добавить в коллекцию неправильную вещь,и во время выполнения она тоже будет запущена из-за стирания типа.В то время как в случае с массивами вы получите исключение по времени выполнения для таких сценариев...</target>
        </trans-unit>
        <trans-unit id="b46664ca8654b90a0e162c4b3dff03b7d478ecda" translate="yes" xml:space="preserve">
          <source>Now the class:</source>
          <target state="translated">Теперь класс:</target>
        </trans-unit>
        <trans-unit id="dc101928e56b106ed14a4a66b3e29f57d6fb1fc6" translate="yes" xml:space="preserve">
          <source>Now there are times where you need to be more flexible and that is what the &lt;code&gt;? super Class&lt;/code&gt; and &lt;code&gt;? extends Class&lt;/code&gt; are for. The former is when you need to insert into a type &lt;code&gt;Collection&lt;/code&gt; (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</source>
          <target state="translated">Теперь есть времена, когда вам нужно быть более гибким, и это то, что &lt;code&gt;? super Class&lt;/code&gt; супер класс а &lt;code&gt;? extends Class&lt;/code&gt; расширяет класс для. Первый - когда вам нужно вставить в &lt;code&gt;Collection&lt;/code&gt; типов (например), а второй - когда вам нужно читать из него безопасным для типов способом. Но единственный способ сделать оба одновременно - это иметь определенный тип.</target>
        </trans-unit>
        <trans-unit id="0fd32cdcc763728be3ed9548fd8cc6d813d21f84" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;can't&lt;/em&gt; add a &lt;code&gt;Cat&lt;/code&gt; to a &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; because you don't know it's a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;. You can retrieve a value and know that it will be an &lt;code&gt;Animal&lt;/code&gt;, but you can't add arbitrary animals. The reverse is true for &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; - in that case you can add an &lt;code&gt;Animal&lt;/code&gt; to it safely, but you don't know anything about what might be retrieved from it, because it could be a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь вы &lt;em&gt;не можете&lt;/em&gt; добавить &lt;code&gt;Cat&lt;/code&gt; в &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; расширяет Animal&amp;gt;, потому что вы не знаете, что это &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; . Вы можете извлечь значение и знать, что это будет &lt;code&gt;Animal&lt;/code&gt; , но вы не можете добавлять произвольных животных. Обратное верно для &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; super Animal&amp;gt; - в этом случае вы можете безопасно добавить к нему &lt;code&gt;Animal&lt;/code&gt; , но ничего не знаете о том, что из него можно извлечь, потому что это может быть &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8252d2eb721be021d186b1fa8f366cf90af2fe" translate="yes" xml:space="preserve">
          <source>OTOH, we could as well do</source>
          <target state="translated">ОТОХ,мы с таким же успехом могли бы</target>
        </trans-unit>
        <trans-unit id="4f1b7d75431b202c7bc72bc61ee6387be8273957" translate="yes" xml:space="preserve">
          <source>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;erasure&lt;/a&gt;. This property is crucial meaning that it did not break backwards compatibility.</source>
          <target state="translated">Обратите внимание, что переведенный код тела метода идентичен. Компилятор заменил каждый параметризованный тип его &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;стиранием&lt;/a&gt; . Это свойство имеет решающее значение, так как оно не нарушает обратную совместимость.</target>
        </trans-unit>
        <trans-unit id="6f4ce7da4e6b06cef1e0b7c88880e970e5b28ba6" translate="yes" xml:space="preserve">
          <source>Obviously, this changes the semantics, since the lists &lt;code&gt;animals&lt;/code&gt; and &lt;code&gt;dogs&lt;/code&gt; are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a &lt;code&gt;Cat&lt;/code&gt; could be added to a list that is only supposed to contain &lt;code&gt;Dog&lt;/code&gt; objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</source>
          <target state="translated">Очевидно, это меняет семантику, так как списки &lt;code&gt;animals&lt;/code&gt; и &lt;code&gt;dogs&lt;/code&gt; больше не являются общими, поэтому добавление в один список не добавляет в другой (что именно вам нужно, чтобы избежать проблемы, &lt;code&gt;Cat&lt;/code&gt; добавлением кота в список). он должен содержать только объекты &lt;code&gt;Dog&lt;/code&gt; ). Кроме того, копирование всего списка может быть неэффективным. Однако это решает проблему эквивалентности типов, нарушая равенство ссылок.</target>
        </trans-unit>
        <trans-unit id="5d8a48922072f2b11fdf281f658f9367702184e2" translate="yes" xml:space="preserve">
          <source>So Java &quot;architects&quot; had 2 options which address this problem:</source>
          <target state="translated">Таким образом,у Java &quot;архитекторов&quot; было 2 варианта решения этой проблемы:</target>
        </trans-unit>
        <trans-unit id="09f145bb0cec9dfa89cc809b42253f1893cd611d" translate="yes" xml:space="preserve">
          <source>So suppose I have a method &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt;. By all the rules of inheritance and polymorphism, I would assume that a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; and a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt;.</source>
          <target state="translated">Итак, предположим, у меня есть метод &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt; . По всем правилам наследования и полиморфизма я бы предположил, что &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;-&lt;/em&gt; это &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; а &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; &lt;em&gt;-&lt;/em&gt; это &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - и поэтому любой из них может быть передан этому методу. Не так. Если я хочу добиться такого поведения, я должен явно указать методу, чтобы он принимал список любого подкласса Animal, сказав &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cca9629e4bee6bd9d98e8f03a6ec1b01b5f8071f" translate="yes" xml:space="preserve">
          <source>So suppose there is a method as given below:</source>
          <target state="translated">Так что предположим,что есть метод,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="a199246c454ab2f91900765521747e50834f16f8" translate="yes" xml:space="preserve">
          <source>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</source>
          <target state="translated">Так почему же список собак (кружочков)не должен рассматриваться неявно как список животных (фигур)именно из-за этой ситуации:</target>
        </trans-unit>
        <trans-unit id="6c83895af74d72b8dc8bbd8e3db07cd62efff8e4" translate="yes" xml:space="preserve">
          <source>Subtyping is &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;invariant&lt;/a&gt; for parameterized types. Even tough the class &lt;code&gt;Dog&lt;/code&gt; is a subtype of &lt;code&gt;Animal&lt;/code&gt;, the parameterized type &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. In contrast, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;covariant&lt;/a&gt; subtyping is used by arrays, so the array
type &lt;code&gt;Dog[]&lt;/code&gt; is a subtype of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">Подтипирование является &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;инвариантным&lt;/a&gt; для параметризованных типов. Даже если класс &lt;code&gt;Dog&lt;/code&gt; является подтипом &lt;code&gt;Animal&lt;/code&gt; , параметризованный тип &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; не является подтипом &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; . Напротив, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;ковариантный&lt;/a&gt; подтип используется массивами, поэтому тип массива &lt;code&gt;Dog[]&lt;/code&gt; является подтипом &lt;code&gt;Animal[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ff2a1d25d6a239c07acd25dde697fc50a42eb9" translate="yes" xml:space="preserve">
          <source>Suddenly you have a &lt;em&gt;very&lt;/em&gt; confused cat.</source>
          <target state="translated">Внезапно у вас &lt;em&gt;очень&lt;/em&gt; запутанная кошка.</target>
        </trans-unit>
        <trans-unit id="16d127ac7c16458178ca5e456a5c49755036fe42" translate="yes" xml:space="preserve">
          <source>That code compiles fine, but throws a runtime error (&lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</source>
          <target state="translated">Этот код хорошо компилируется, но выдает ошибку времени выполнения ( &lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; во второй строке). Это небезопасно. Задача Generics состоит в том, чтобы добавить безопасность типов времени компиляции, в противном случае вы можете просто придерживаться простого класса без обобщений.</target>
        </trans-unit>
        <trans-unit id="584190794514e75254dea7c2060370444e691d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Generics in the Java Language&lt;/a&gt; and the &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;Section on Generics from the Java Tutorials&lt;/a&gt; have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</source>
          <target state="translated">&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Дженерики в языке Java&lt;/a&gt; и &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;раздел &amp;laquo;Дженерики из учебников по Java&amp;raquo;&lt;/a&gt; содержат очень хорошее и подробное объяснение того, почему некоторые вещи являются или не являются полиморфными или допускаются с помощью дженериков.</target>
        </trans-unit>
        <trans-unit id="cc94e800ea480646ce6ba48ed62ffc07b3b6d12a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;answer&lt;/a&gt;  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;Ответ,&lt;/a&gt; как и другие ответы, верны. Я собираюсь добавить к этим ответам решение, которое, я думаю, будет полезным. Я думаю, что это часто встречается в программировании. Следует отметить, что для коллекций (списки, наборы и т. Д.) Основной проблемой является добавление в коллекцию. Вот где все рушится. Даже удаление в порядке.</target>
        </trans-unit>
        <trans-unit id="d4a722f5af2f92c06a2884931937c02445379d87" translate="yes" xml:space="preserve">
          <source>The answers given here didn't fully convince me. So instead, I make another example.</source>
          <target state="translated">Ответы,данные здесь,не полностью убедили меня.Поэтому вместо этого я привел еще один пример.</target>
        </trans-unit>
        <trans-unit id="fa4065cf11262ad86892b5d6301cc8618a09d2ee" translate="yes" xml:space="preserve">
          <source>The basis logic for such behavior is that &lt;code&gt;Generics&lt;/code&gt; follow a mechanism of type erasure. So at run time you have no way if identifying the type of &lt;code&gt;collection&lt;/code&gt; unlike &lt;code&gt;arrays&lt;/code&gt; where there is no such erasure process. So coming back to your question...</source>
          <target state="translated">Основная логика такого поведения заключается в том, что &lt;code&gt;Generics&lt;/code&gt; следуют механизму стирания типов. Таким образом, во время выполнения вы не можете определить тип &lt;code&gt;collection&lt;/code&gt; отличие от &lt;code&gt;arrays&lt;/code&gt; где нет такого процесса стирания. Итак, возвращаясь к вашему вопросу ...</target>
        </trans-unit>
        <trans-unit id="9c3267d922c893a40cc754519d5648d0800218f7" translate="yes" xml:space="preserve">
          <source>The code is legal. However, throws an &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;array store exception&lt;/a&gt;.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping.</source>
          <target state="translated">Код является законным. Однако выдает &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;исключение хранилища массива&lt;/a&gt; . Массив несет свой тип во время выполнения, так что JVM может обеспечить безопасность типов ковариантного подтипирования.</target>
        </trans-unit>
        <trans-unit id="ec880e5540e317191d0eda22061ad1f16aa30ff0" translate="yes" xml:space="preserve">
          <source>The problem has been well-identified. But there's a solution; make &lt;em&gt;doSomething&lt;/em&gt; generic:</source>
          <target state="translated">Проблема была хорошо определена. Но есть решение; сделайте что- &lt;em&gt;нибудь&lt;/em&gt; общее:</target>
        </trans-unit>
        <trans-unit id="b6440d667672409bf8fb7e0306aea73bb570933b" translate="yes" xml:space="preserve">
          <source>The reason a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, is that, for example, you can insert a &lt;code&gt;Cat&lt;/code&gt; into a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, but not into a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is the similar to reading from a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; -- but not writing.</source>
          <target state="translated">Причина, по которой &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; не является &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; , заключается в том, что, например, вы можете вставить &lt;code&gt;Cat&lt;/code&gt; в &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; , но не в &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ... вы можете использовать подстановочные знаки для генерики более расширяемые, где это возможно; например, чтение из &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; аналогично чтению из &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; но не записи.</target>
        </trans-unit>
        <trans-unit id="ba7ebd605e2db9f872e9f4dc2e8be52afa87b964" translate="yes" xml:space="preserve">
          <source>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</source>
          <target state="translated">То,как работает интуиция ОП-что,разумеется,полностью обосновано-это последнее предложение.Однако,если мы применим эту интуицию,то получим язык,не являющийся Java-esque в своей системе типов:Предположим,что наш язык позволяет добавлять кошку в список собак.Что бы это значило? Это будет означать,что список перестанет быть списком собак,и останется просто списком животных.И список млекопитающих,и список квадратистов.</target>
        </trans-unit>
        <trans-unit id="23ce7e603788be5aab21ee61b091d1a2fa64148a" translate="yes" xml:space="preserve">
          <source>Therefore arrays provide runtime type safety but not compile-time type safety.</source>
          <target state="translated">Поэтому массивы обеспечивают безопасность по типу исполнения,но не по типу компиляции.</target>
        </trans-unit>
        <trans-unit id="c5bfdde28ebbe167fa1e050e24ae8f4ad024ab30" translate="yes" xml:space="preserve">
          <source>Therefore generics can't provide runtime type safety, but they provide compile-time type safety.</source>
          <target state="translated">Поэтому дженерики не могут обеспечить безопасность типа исполнения,но они обеспечивают безопасность типа компиляции.</target>
        </trans-unit>
        <trans-unit id="00c82895236a0a7a878e98ac644697c1418510bb" translate="yes" xml:space="preserve">
          <source>This is usefull when you want to pass the list in a constructor or iterate over it</source>
          <target state="translated">Это полезно,когда вы хотите передать список в конструкторе или выполнить над ним итерацию</target>
        </trans-unit>
        <trans-unit id="57e00388dd7cbaf4c88629658063578936e69c09" translate="yes" xml:space="preserve">
          <source>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....</source>
          <target state="translated">Таким образом,по сути,такое поведение реализовано таким образом,что нельзя добавить в коллекцию неправильную вещь.Теперь я считаю,что стирание типов существует для того,чтобы дать совместимость с унаследованным java без дженериков......</target>
        </trans-unit>
        <trans-unit id="4786f210fd6512db64d73fcfd87384dc56d0b91a" translate="yes" xml:space="preserve">
          <source>Thus we have &lt;code&gt;ListOfAnimal&lt;/code&gt;, &lt;code&gt;ListOfDog&lt;/code&gt;, &lt;code&gt;ListOfCat&lt;/code&gt;, etc, which are distinct classes that end up being &quot;created&quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to &lt;code&gt;List&lt;/code&gt; is not a hierarchy at all).</source>
          <target state="translated">Таким образом, у нас есть &lt;code&gt;ListOfAnimal&lt;/code&gt; , &lt;code&gt;ListOfDog&lt;/code&gt; , &lt;code&gt;ListOfCat&lt;/code&gt; и т. Д. , Которые являются отдельными классами, которые в конечном итоге &amp;laquo;создаются&amp;raquo; компилятором, когда мы указываем общие аргументы. И это плоская иерархия (на самом деле в отношении &lt;code&gt;List&lt;/code&gt; это совсем не иерархия).</target>
        </trans-unit>
        <trans-unit id="7a9a72b3362404704da9568bb6fb9462dc5392cf" translate="yes" xml:space="preserve">
          <source>To put it another way: A &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; in Java does not mean &quot;a list of dogs&quot; in English, it means &quot;a list which can have dogs, and nothing else&quot;.</source>
          <target state="translated">Другими словами: &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; на Java не означает &amp;laquo;список собак&amp;raquo; на английском языке, это означает &amp;laquo;список, в котором могут быть собаки и ничего больше&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="48cb4ab7d62851fc151a15505099e94b0316692e" translate="yes" xml:space="preserve">
          <source>To understand the problem it's useful to make comparison to arrays.</source>
          <target state="translated">Чтобы понять проблему,полезно сравнить с массивами.</target>
        </trans-unit>
        <trans-unit id="d5a9aae8fbcc3e1f36369c98b0b7f2207dc564a1" translate="yes" xml:space="preserve">
          <source>To understand this further let's look at the bytecode generated by &lt;code&gt;javap&lt;/code&gt; of the class below:</source>
          <target state="translated">Чтобы понять это далее, давайте посмотрим на байт-код, сгенерированный &lt;code&gt;javap&lt;/code&gt; класса ниже:</target>
        </trans-unit>
        <trans-unit id="03dfd09db768e40e7564a1ad7500d78d1c2d2d78" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;javap -c Demonstration&lt;/code&gt;, this shows the following Java bytecode:</source>
          <target state="translated">Используя команду &lt;code&gt;javap -c Demonstration&lt;/code&gt; , это показывает следующий байт-код Java:</target>
        </trans-unit>
        <trans-unit id="754919ef9edabe390bb0a56957e1038bbadc51c3" translate="yes" xml:space="preserve">
          <source>We even can do</source>
          <target state="translated">Мы даже можем сделать</target>
        </trans-unit>
        <trans-unit id="a4a8f17fd0e17a7a59d13cdf7845711a3b9c6069" translate="yes" xml:space="preserve">
          <source>We should also take in consideration how the compiler threats the generic classes: in &quot;instantiates&quot; a different type whenever we fill the generic arguments.</source>
          <target state="translated">Мы также должны учитывать,как компилятор угрожает общим классам:в &quot;инстанциациях&quot; другой тип всякий раз,когда мы заполняем общие аргументы.</target>
        </trans-unit>
        <trans-unit id="53afcffe1e893d87963a71f6d157ea0408568d23" translate="yes" xml:space="preserve">
          <source>What you are looking for is called &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;covariant type&lt;/a&gt; parameters&lt;/em&gt;. This means that if one type of object can be substituted for another in a method (for instance, &lt;code&gt;Animal&lt;/code&gt; can be replaced with &lt;code&gt;Dog&lt;/code&gt;), the same applies to expressions using those objects (so &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; could be replaced with &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;, and it is being used as a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.  What happens when you try to add a Cat to this &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; which is really a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;?  Automatically allowing type parameters to be covariant breaks the type system.</source>
          <target state="translated">То, что вы ищете, называется &lt;em&gt;параметрами &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;ковариантного типа&lt;/a&gt;&lt;/em&gt; . Это означает, что если один тип объекта можно заменить другим в методе (например, &lt;code&gt;Animal&lt;/code&gt; можно заменить на &lt;code&gt;Dog&lt;/code&gt; ), то же самое относится к выражениям, использующим эти объекты (поэтому &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; можно заменить на &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ). Проблема в том, что ковариантность небезопасна для изменяемых списков в целом. Предположим, у вас есть &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; , и он используется как &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; . Что происходит, когда вы пытаетесь добавить кошку в этот &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; который действительно является &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ? Автоматическое допущение ковариантности параметров типа нарушает систему типов.</target>
        </trans-unit>
        <trans-unit id="8d5d23c16bd63540ead2c74914ddab1e126bc3f6" translate="yes" xml:space="preserve">
          <source>another solution is to build a new list</source>
          <target state="translated">другое решение-построить новый список</target>
        </trans-unit>
        <trans-unit id="6ed375dc664a800e63fb268753b8f59714929e45" translate="yes" xml:space="preserve">
          <source>consider the subtype to be it's supertype and restrict at compile the &quot;add&quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</source>
          <target state="translated">считать подтип супертипом и ограничить при компиляции методом &quot;add&quot; (так в методе drawAll,если будет передан список окружностей,подтип фигуры,компилятор должен это обнаружить и ограничить при компиляции ошибкой).</target>
        </trans-unit>
        <trans-unit id="9a49e1031f2ed9d14b8f10116b441e35b8bd75c8" translate="yes" xml:space="preserve">
          <source>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</source>
          <target state="translated">не считайте,что подтип неявно является супертипом,и дайте ошибку компиляции,как это происходит сейчас</target>
        </trans-unit>
        <trans-unit id="917a49b3ab1b964d351680a9d496835660c085e3" translate="yes" xml:space="preserve">
          <source>it is also true that</source>
          <target state="translated">верно также и то,что</target>
        </trans-unit>
        <trans-unit id="3109cbe3b4d36e8f4714482083b76fe25ee4a957" translate="yes" xml:space="preserve">
          <source>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</source>
          <target state="translated">убеждается,что мы можем использовать только того поставщика,который предоставит нам подходящий для потребителя тип объекта.</target>
        </trans-unit>
        <trans-unit id="34263cba8588e8a17ab060861593d2d646e5fba6" translate="yes" xml:space="preserve">
          <source>now you can call doSomething with either List&amp;lt;Dog&amp;gt; or List&amp;lt;Cat&amp;gt; or List&amp;lt;Animal&amp;gt;.</source>
          <target state="translated">теперь вы можете вызывать doSomething с помощью List &amp;lt;Dog&amp;gt; или List &amp;lt;Cat&amp;gt; или List &amp;lt;Animal&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="d331fcedf530a8517412040f7d5855e4ea193dae" translate="yes" xml:space="preserve">
          <source>sounds fine, doesn't it? But you can only pass &lt;code&gt;Consumer&lt;/code&gt;s and &lt;code&gt;Supplier&lt;/code&gt;s for &lt;code&gt;Animal&lt;/code&gt;s. If you have a &lt;code&gt;Mammal&lt;/code&gt; consumer, but a &lt;code&gt;Duck&lt;/code&gt; supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</source>
          <target state="translated">звучит нормально, не так ли? Но вы можете передать только &lt;code&gt;Consumer&lt;/code&gt; и &lt;code&gt;Supplier&lt;/code&gt; для &lt;code&gt;Animal&lt;/code&gt; . Если у вас есть потребитель &lt;code&gt;Mammal&lt;/code&gt; , но поставщик &lt;code&gt;Duck&lt;/code&gt; , они не должны подходить, хотя оба являются животными. Чтобы запретить это, были добавлены дополнительные ограничения.</target>
        </trans-unit>
        <trans-unit id="0326968b7f692e04985959e0b5f6e025c50d1747" translate="yes" xml:space="preserve">
          <source>therefore you can't put the wrong subtype of &lt;code&gt;Animal&lt;/code&gt; into the list, because there is no wrong subtype -- any object of subtype &lt;code&gt;? extends Animal&lt;/code&gt; can be added to &lt;code&gt;animals&lt;/code&gt;.</source>
          <target state="translated">поэтому вы не можете поместить неправильный подтип &lt;code&gt;Animal&lt;/code&gt; в список, потому что нет неправильного подтипа - любой объект подтипа &lt;code&gt;? extends Animal&lt;/code&gt; расширяет животных можно добавлять к &lt;code&gt;animals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f38425b32961346a1ff8ec4c2f4f3802f76f7cb1" translate="yes" xml:space="preserve">
          <source>where we go the other way: we define the type of the &lt;code&gt;Supplier&lt;/code&gt; and restrict that it can be put into the &lt;code&gt;Consumer&lt;/code&gt;.</source>
          <target state="translated">куда мы идем другим путем: мы определяем тип &lt;code&gt;Supplier&lt;/code&gt; и ограничиваем его использование у &lt;code&gt;Consumer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b6ffb0d183ccad287984bf71c0f6ef92c471a6" translate="yes" xml:space="preserve">
          <source>where, having the intuitive relations &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt;, &lt;code&gt;Cat&lt;/code&gt; etc., we could even put a &lt;code&gt;Mammal&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer, but not a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer.</source>
          <target state="translated">где, имея интуитивные отношения &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt; , &lt;code&gt;Cat&lt;/code&gt; и т. д., мы могли бы даже поместить &lt;code&gt;Mammal&lt;/code&gt; в потребителя &lt;code&gt;Life&lt;/code&gt; , но не &lt;code&gt;String&lt;/code&gt; в потребителя &lt;code&gt;Life&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8cb6da1df995798f3ac8506f94719679ef5c11c" translate="yes" xml:space="preserve">
          <source>you can then use the collections using</source>
          <target state="translated">вы можете использовать коллекции,используя</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
