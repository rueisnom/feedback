<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2745265">
    <body>
      <group id="2745265">
        <trans-unit id="90a10e20bd2c8e7f512a36f9986e6bd625a12b68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt; means their type information is fully available at runtime.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;可修复&lt;/a&gt;意味着它们的类型信息在运行时完全可用。</target>
        </trans-unit>
        <trans-unit id="d492a733adb02b8320864e88f8357ed772fc394d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; subclass of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;strong&gt;不是&lt;/strong&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 子类。</target>
        </trans-unit>
        <trans-unit id="5b38d828fcef53ec9e2076c3fa73400ff6ed0737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; isn't-a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;&lt;strong&gt;in Java&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 不是&lt;strong&gt;-Java中&lt;/strong&gt;的 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63014900394aa67a0cc9fc3284de4e4252474b9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Animal&lt;/strong&gt; (Parent)</source>
          <target state="translated">&lt;strong&gt;动物&lt;/strong&gt; （父母）</target>
        </trans-unit>
        <trans-unit id="e0fe91def2724cfdeae839f5686512b73124e94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays are &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;reifiable&lt;/a&gt; and covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;数组是可&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;校正&lt;/a&gt;且协变的&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e328038c60dede3020d85585548cc6d876f670a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But&lt;/strong&gt;&lt;code&gt;Dog[]&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; subclass of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;但是&lt;/strong&gt; &lt;code&gt;Dog[]&lt;/code&gt; &lt;strong&gt;是&lt;/strong&gt; &lt;code&gt;Animal[]&lt;/code&gt; 子类。</target>
        </trans-unit>
        <trans-unit id="eb3f40109f1f6807b64f388fb31fb0af45ca1e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dog&lt;/strong&gt; - &lt;strong&gt;Cat&lt;/strong&gt; (Children)</source>
          <target state="translated">&lt;strong&gt;狗&lt;/strong&gt; - &lt;strong&gt;猫&lt;/strong&gt; （儿童）</target>
        </trans-unit>
        <trans-unit id="304ec5ad8646d255b82e3edf25a0ad01d2c2de03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generics are &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;erased&lt;/a&gt; and invariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;泛型被&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;擦除&lt;/a&gt;且不变&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cdca835127fee237411a140f68169f05cc675c3" translate="yes" xml:space="preserve">
          <source>A list of dogs is-a list of animals &lt;strong&gt;in English&lt;/strong&gt; (well, under a reasonable interpretation)</source>
          <target state="translated">狗的清单是&lt;strong&gt;英语&lt;/strong&gt;的动物清单（在合理的解释下）</target>
        </trans-unit>
        <trans-unit id="e3f7f1c5a95fabfdae274ff4f328ee3f1b9a462f" translate="yes" xml:space="preserve">
          <source>A point I think should be added to what &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;answers&lt;/a&gt; mention is that while</source>
          <target state="translated">我认为应该在&lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;其他&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;答案中&lt;/a&gt;提到的一点是</target>
        </trans-unit>
        <trans-unit id="6d7e1bb7645e004caf223707662fb2057339d98a" translate="yes" xml:space="preserve">
          <source>Actually you can use an interface to achieve what you want.</source>
          <target state="translated">其实你可以用一个界面来实现你想要的东西。</target>
        </trans-unit>
        <trans-unit id="344527118c80c2af2edf1e6d80bca72266b3175b" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt;, you cannot subsequently directly assign &lt;code&gt;animals&lt;/code&gt; to either &lt;code&gt;dogs&lt;/code&gt; or &lt;code&gt;cats&lt;/code&gt;:</source>
          <target state="translated">调用 &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt; ，您以后便无法直接将 &lt;code&gt;animals&lt;/code&gt; 分配 &lt;code&gt;dogs&lt;/code&gt; 或 &lt;code&gt;cats&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e68eb3128cd4e3b375fed2af8ca940aea40c8999" translate="yes" xml:space="preserve">
          <source>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are &lt;code&gt;List&lt;/code&gt; instances. Specialising a &lt;code&gt;List&lt;/code&gt; by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</source>
          <target state="translated">为什么在通用类的情况下协方差没有意义的另一个论点是，实际上所有类都是相同的 &lt;code&gt;List&lt;/code&gt; 实例。 通过填充泛型参数来对 &lt;code&gt;List&lt;/code&gt; 进行特殊化不会扩展类，而只是使它适用于该特定的泛型参数。</target>
        </trans-unit>
        <trans-unit id="7a959cb20c2a75f6a5e8944beb44f43926299f02" translate="yes" xml:space="preserve">
          <source>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</source>
          <target state="translated">正如@Jon Skeet所说的那样,这个代码是非法的,因为否则就会违反类型约束,在狗预期的时候返回一只猫,这就违反了类型约束。</target>
        </trans-unit>
        <trans-unit id="9e0ea5bc85b2c61dce27b3c8ed31b0557f59af05" translate="yes" xml:space="preserve">
          <source>Assume the following hierarchy -</source>
          <target state="translated">假设有以下层次结构:</target>
        </trans-unit>
        <trans-unit id="381c0989adf609934d9987de7750f37d8d6422bb" translate="yes" xml:space="preserve">
          <source>At the deepest level, the problem here is that &lt;code&gt;dogs&lt;/code&gt; and &lt;code&gt;animals&lt;/code&gt; share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</source>
          <target state="translated">从最深层次上讲，这里的问题是 &lt;code&gt;dogs&lt;/code&gt; 和 &lt;code&gt;animals&lt;/code&gt; 共享参考。 这意味着进行这项工作的一种方法是复制整个列表，这将破坏引用的相等性：</target>
        </trans-unit>
        <trans-unit id="2eda859b24b9c57e6183b93096e9b63efeaee18e" translate="yes" xml:space="preserve">
          <source>E. g.,</source>
          <target state="translated">例如:.....,</target>
        </trans-unit>
        <trans-unit id="204aa29f1c9a6ab4ac20c77ee47b170439787c52" translate="yes" xml:space="preserve">
          <source>For obvious reasons, that chose the first way.</source>
          <target state="translated">由于明显的原因,那选择了第一种方式。</target>
        </trans-unit>
        <trans-unit id="17d3a2e5b2ebbd18c169ee52622d864801d45a32" translate="yes" xml:space="preserve">
          <source>Further to the answer by Jon Skeet, which uses this example code:</source>
          <target state="translated">再来看看乔恩-斯基特的答案,其中使用了这个例子的代码。</target>
        </trans-unit>
        <trans-unit id="96f1150d546de158ef07e02fb89e723cc69163ca" translate="yes" xml:space="preserve">
          <source>I understand that this is Java's behavior. My question is &lt;em&gt;why&lt;/em&gt;? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</source>
          <target state="translated">我了解这是Java的行为。 我的问题是&lt;em&gt;为什么&lt;/em&gt; ？ 为什么多态性通常是隐式的，但是当涉及泛型时，必须指定它？</target>
        </trans-unit>
        <trans-unit id="fccd4d39d44d0871993dd57d00b01ed07c504c36" translate="yes" xml:space="preserve">
          <source>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</source>
          <target state="translated">我想说的是,Generics的全部意义在于它不允许这样做。考虑一下数组的情况,它确实允许这种类型的协方差。</target>
        </trans-unit>
        <trans-unit id="01e70d4e3c86e0b7b2d3599eb15c5d79e5389855" translate="yes" xml:space="preserve">
          <source>I'm a bit confused about how Java generics handle inheritance / polymorphism.</source>
          <target state="translated">我对Java属性如何处理继承多态性有些困惑。</target>
        </trans-unit>
        <trans-unit id="a2c736ed9244357382e64aceca74b1e587e71857" translate="yes" xml:space="preserve">
          <source>If you are sure that the list items are subclasses of that given super type you can cast the list using this approach:</source>
          <target state="translated">如果你确定列表项是那个给定的超级类型的子类,你可以用这种方法投出列表。</target>
        </trans-unit>
        <trans-unit id="604f0777accde51cdb9a2e95bba2b694a31efdec" translate="yes" xml:space="preserve">
          <source>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</source>
          <target state="translated">总而言之,参数化类型的运行时安全是不可能的,因为编译器会用它的擦除来代替每个参数化类型。这使得参数化类型不过是语法上的糖。</target>
        </trans-unit>
        <trans-unit id="c6df8c875d5596e81ece51df756bb5a6e3e44560" translate="yes" xml:space="preserve">
          <source>In most cases, we can use &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; rather then &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; to a &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.</source>
          <target state="translated">在大多数情况下，我们可以使用 &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; 扩展T&amp;gt;，而不是 &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; ，那应该是首选。 但是，我发现不容易做到这一点的情况。 关于这是否始终是最好的事情，有待辩论。 我在这里展示的是DownCastCollection类，可以将其转换为 &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; 当使用标准方法非常不方便时，将T&amp;gt;扩展到 &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; （我们可以为List，Set，NavigableSet等定义类似的类）。 下面是一个如何使用它的示例（在这种情况下，我们也可以使用 &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; ，但是我将简化使用DownCastCollection的说明。</target>
        </trans-unit>
        <trans-unit id="1ffe7e463ad2cbcb1de6c5e2e33c9d5181c4568a" translate="yes" xml:space="preserve">
          <source>In the code below if generics were covariant it will be possible to make &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;heap pollution&lt;/a&gt; at line 3.</source>
          <target state="translated">在下面的代码中，如果泛型是协变的，则可能在第3行造成&lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;堆污染&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="db0d547b9a45e2cd6f0e18b37f983db0f182eec3" translate="yes" xml:space="preserve">
          <source>Instead of the above, we have to define relationships between the types we use.</source>
          <target state="translated">与其说上述,不如说我们要定义我们所使用的类型之间的关系。</target>
        </trans-unit>
        <trans-unit id="99aa3435dd6dd09d2f123ec6780ffb6b4b0e2c9e" translate="yes" xml:space="preserve">
          <source>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</source>
          <target state="translated">不变量子类型确保了Java所执行的类型约束不被违反。考虑一下@Jon Skeet给出的以下代码。</target>
        </trans-unit>
        <trans-unit id="29a4d80153ea7b51095ece74755bb5043916df2f" translate="yes" xml:space="preserve">
          <source>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic</source>
          <target state="translated">是清单 &lt;dog&gt; List的子类 &lt;animal&gt; ？ 为什么Java泛型不是隐式多态的 &lt;/animal&gt;&lt;/dog&gt;</target>
        </trans-unit>
        <trans-unit id="91db49b2b9e77ed757d10476e32752227a891692" translate="yes" xml:space="preserve">
          <source>It is instructive to compare the above to analogous code for arrays.</source>
          <target state="translated">将上面的代码与数组的类似代码进行比较,很有启发意义。</target>
        </trans-unit>
        <trans-unit id="3ed717cb0f96ab9f0d80c86ad25d852eb370af29" translate="yes" xml:space="preserve">
          <source>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the &lt;code&gt;? extends Foo&lt;/code&gt; in method declarations, but that does add additional complexity.</source>
          <target state="translated">添加语法以允许将类型参数指定为协变将很有用，这样可以避免使用 &lt;code&gt;? extends Foo&lt;/code&gt; 在方法声明中扩展了Foo ，但这确实增加了额外的复杂性。</target>
        </trans-unit>
        <trans-unit id="e1b88103aa22a4125409bcc1ce1af145750f709c" translate="yes" xml:space="preserve">
          <source>It's vice versa for generics:</source>
          <target state="translated">反之亦然。</target>
        </trans-unit>
        <trans-unit id="6d9e846d6c182c9be543e2edb9fad821781f6e1c" translate="yes" xml:space="preserve">
          <source>Lets take the example from JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;tutorial&lt;/a&gt;</source>
          <target state="translated">让我们以JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;教程&lt;/a&gt;为例</target>
        </trans-unit>
        <trans-unit id="db49ead253373ebf491e45d83a3eaede6658b135" translate="yes" xml:space="preserve">
          <source>More generally, &lt;strong&gt;OP's intuition lends itself towards a language in which operations on objects can change their type&lt;/strong&gt;, or rather, an object's type(s) is a (dynamic) function of its value.</source>
          <target state="translated">更一般而言， &lt;strong&gt;OP的直觉倾向于一种语言，在该语言上，对对象的操作可以更改其类型&lt;/strong&gt; ，或者更确切地说，对象的类型是其值的（动态）函数。</target>
        </trans-unit>
        <trans-unit id="59becb84eaea3240c06cacb7affabdb553d2b2d4" translate="yes" xml:space="preserve">
          <source>No, a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. Consider what you can do with a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - you can add &lt;em&gt;any&lt;/em&gt; animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</source>
          <target state="translated">不， &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;不是&lt;/em&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 。 考虑一下您可以使用 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 做什么-您可以向其中添加&lt;em&gt;任何&lt;/em&gt;动物...包括猫。 现在，您可以在逻辑上将猫添加到一窝小狗中吗？ 绝对不。</target>
        </trans-unit>
        <trans-unit id="169a8aa30694368f01ec9a80e5d310b4a4fa72a0" translate="yes" xml:space="preserve">
          <source>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</source>
          <target state="translated">现在,如果java允许调用者在这个方法中添加List类型的Animal,那么你可能会把错误的东西添加到集合中,在运行时也会因为类型擦除而运行。而在数组的情况下,你会得到一个运行时的异常......</target>
        </trans-unit>
        <trans-unit id="b46664ca8654b90a0e162c4b3dff03b7d478ecda" translate="yes" xml:space="preserve">
          <source>Now the class:</source>
          <target state="translated">现在的班级。</target>
        </trans-unit>
        <trans-unit id="dc101928e56b106ed14a4a66b3e29f57d6fb1fc6" translate="yes" xml:space="preserve">
          <source>Now there are times where you need to be more flexible and that is what the &lt;code&gt;? super Class&lt;/code&gt; and &lt;code&gt;? extends Class&lt;/code&gt; are for. The former is when you need to insert into a type &lt;code&gt;Collection&lt;/code&gt; (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</source>
          <target state="translated">现在有时候您需要更加灵活，那是什么 &lt;code&gt;? super Class&lt;/code&gt; 超级班和 &lt;code&gt;? extends Class&lt;/code&gt; 扩展类是。 前者是当您需要插入类型 &lt;code&gt;Collection&lt;/code&gt; （例如）时，后者是当您需要以类型安全的方式从中读取信息时。 但是，同时执行这两个操作的唯一方法是具有特定的类型。</target>
        </trans-unit>
        <trans-unit id="0fd32cdcc763728be3ed9548fd8cc6d813d21f84" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;can't&lt;/em&gt; add a &lt;code&gt;Cat&lt;/code&gt; to a &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; because you don't know it's a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;. You can retrieve a value and know that it will be an &lt;code&gt;Animal&lt;/code&gt;, but you can't add arbitrary animals. The reverse is true for &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; - in that case you can add an &lt;code&gt;Animal&lt;/code&gt; to it safely, but you don't know anything about what might be retrieved from it, because it could be a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">现在，您&lt;em&gt;不能&lt;/em&gt;将 &lt;code&gt;Cat&lt;/code&gt; 添加到 &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; 扩展Animal&amp;gt;，因为您不知道它是 &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; 。 您可以检索一个值并知道它将是 &lt;code&gt;Animal&lt;/code&gt; ，但是不能添加任意动物。 相反，对于 &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; 超级动物&amp;gt; -在那种情况下，您可以安全地向其添加 &lt;code&gt;Animal&lt;/code&gt; ，但是您可能对它不知道什么，因为它可能是 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8252d2eb721be021d186b1fa8f366cf90af2fe" translate="yes" xml:space="preserve">
          <source>OTOH, we could as well do</source>
          <target state="translated">话说回来,我们也可以做</target>
        </trans-unit>
        <trans-unit id="4f1b7d75431b202c7bc72bc61ee6387be8273957" translate="yes" xml:space="preserve">
          <source>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;erasure&lt;/a&gt;. This property is crucial meaning that it did not break backwards compatibility.</source>
          <target state="translated">请注意，方法主体的翻译代码相同。 编译器通过&lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;擦除来&lt;/a&gt;替换每个参数化类型。 此属性至关重要，意味着它不会破坏向后兼容性。</target>
        </trans-unit>
        <trans-unit id="6f4ce7da4e6b06cef1e0b7c88880e970e5b28ba6" translate="yes" xml:space="preserve">
          <source>Obviously, this changes the semantics, since the lists &lt;code&gt;animals&lt;/code&gt; and &lt;code&gt;dogs&lt;/code&gt; are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a &lt;code&gt;Cat&lt;/code&gt; could be added to a list that is only supposed to contain &lt;code&gt;Dog&lt;/code&gt; objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</source>
          <target state="translated">显然，这改变了语义，因为不再共享列表中的 &lt;code&gt;animals&lt;/code&gt; 和 &lt;code&gt;dogs&lt;/code&gt; ，因此添加到一个列表中不会添加到其他列表中（这正是您想要的，以避免将 &lt;code&gt;Cat&lt;/code&gt; 添加到列表中的问题只能包含 &lt;code&gt;Dog&lt;/code&gt; 对象）。 同样，复制整个列表可能效率很低。 但是，这确实通过打破引用相等来解决类型对等问题。</target>
        </trans-unit>
        <trans-unit id="5d8a48922072f2b11fdf281f658f9367702184e2" translate="yes" xml:space="preserve">
          <source>So Java &quot;architects&quot; had 2 options which address this problem:</source>
          <target state="translated">所以Java的 &quot;架构师 &quot;有2个选项可以解决这个问题。</target>
        </trans-unit>
        <trans-unit id="09f145bb0cec9dfa89cc809b42253f1893cd611d" translate="yes" xml:space="preserve">
          <source>So suppose I have a method &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt;. By all the rules of inheritance and polymorphism, I would assume that a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; and a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt;.</source>
          <target state="translated">因此，假设我有一个方法 &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt; 。 根据继承和多态性的所有规则，我将假设 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;是&lt;/em&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 而 &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; &lt;em&gt;是&lt;/em&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; -因此可以将任何一个传递给此方法。 不是这样 如果要实现此行为，则必须通过说 &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt; 来明确告诉该方法接受Animal的任何子类的列表 。</target>
        </trans-unit>
        <trans-unit id="cca9629e4bee6bd9d98e8f03a6ec1b01b5f8071f" translate="yes" xml:space="preserve">
          <source>So suppose there is a method as given below:</source>
          <target state="translated">所以,假设有如下方法。</target>
        </trans-unit>
        <trans-unit id="a199246c454ab2f91900765521747e50834f16f8" translate="yes" xml:space="preserve">
          <source>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</source>
          <target state="translated">所以,为什么不应该把狗(圈)的清单看成是隐性的动物(形状)清单,就是因为这种情况。</target>
        </trans-unit>
        <trans-unit id="6c83895af74d72b8dc8bbd8e3db07cd62efff8e4" translate="yes" xml:space="preserve">
          <source>Subtyping is &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;invariant&lt;/a&gt; for parameterized types. Even tough the class &lt;code&gt;Dog&lt;/code&gt; is a subtype of &lt;code&gt;Animal&lt;/code&gt;, the parameterized type &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. In contrast, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;covariant&lt;/a&gt; subtyping is used by arrays, so the array
type &lt;code&gt;Dog[]&lt;/code&gt; is a subtype of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">子类型对于参数化类型是&lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;不变&lt;/a&gt;的。 即使 &lt;code&gt;Dog&lt;/code&gt; 类是 &lt;code&gt;Animal&lt;/code&gt; 的子类型，参数化类型 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 也不是 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 的子类型。 相反，数组使用&lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;协变&lt;/a&gt;子类型，因此数组类型 &lt;code&gt;Dog[]&lt;/code&gt; 是 &lt;code&gt;Animal[]&lt;/code&gt; 的子类型。</target>
        </trans-unit>
        <trans-unit id="37ff2a1d25d6a239c07acd25dde697fc50a42eb9" translate="yes" xml:space="preserve">
          <source>Suddenly you have a &lt;em&gt;very&lt;/em&gt; confused cat.</source>
          <target state="translated">突然，你有一只&lt;em&gt;非常&lt;/em&gt;困惑的猫。</target>
        </trans-unit>
        <trans-unit id="16d127ac7c16458178ca5e456a5c49755036fe42" translate="yes" xml:space="preserve">
          <source>That code compiles fine, but throws a runtime error (&lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</source>
          <target state="translated">该代码可以正常编译，但是会引发运行时错误（第二行中是 &lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; ）。 它不是类型安全的。 泛型的要点是增加编译时类型的安全性，否则您可以坚持使用没有泛型的普通类。</target>
        </trans-unit>
        <trans-unit id="584190794514e75254dea7c2060370444e691d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Generics in the Java Language&lt;/a&gt; and the &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;Section on Generics from the Java Tutorials&lt;/a&gt; have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</source>
          <target state="translated">&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Java语言中&lt;/a&gt;的&lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;泛型和Java教程中的泛型部分对&lt;/a&gt;为什么某些东西是多态的或不允许使用泛型的，进行了很好的深入解释。</target>
        </trans-unit>
        <trans-unit id="cc94e800ea480646ce6ba48ed62ffc07b3b6d12a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;answer&lt;/a&gt;  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;答案&lt;/a&gt;以及其他答案都是正确的。 我将使用一种我认为会有所帮助的解决方案来补充这些答案。 我认为这在编程中经常会出现。 要注意的一件事是，对于集合（列表，集合等），主要问题是添加到集合中。 那是事情崩溃的地方。 即使删除也可以。</target>
        </trans-unit>
        <trans-unit id="d4a722f5af2f92c06a2884931937c02445379d87" translate="yes" xml:space="preserve">
          <source>The answers given here didn't fully convince me. So instead, I make another example.</source>
          <target state="translated">这里给出的答案并没有完全说服我。所以,我反过来又举了一个例子。</target>
        </trans-unit>
        <trans-unit id="fa4065cf11262ad86892b5d6301cc8618a09d2ee" translate="yes" xml:space="preserve">
          <source>The basis logic for such behavior is that &lt;code&gt;Generics&lt;/code&gt; follow a mechanism of type erasure. So at run time you have no way if identifying the type of &lt;code&gt;collection&lt;/code&gt; unlike &lt;code&gt;arrays&lt;/code&gt; where there is no such erasure process. So coming back to your question...</source>
          <target state="translated">这种行为的基本逻辑是 &lt;code&gt;Generics&lt;/code&gt; 遵循类型擦除机制。 因此，在运行时，您无法确定与不存在这种擦除过程的 &lt;code&gt;arrays&lt;/code&gt; 不同的 &lt;code&gt;collection&lt;/code&gt; 的类型。 所以回到你的问题...</target>
        </trans-unit>
        <trans-unit id="9c3267d922c893a40cc754519d5648d0800218f7" translate="yes" xml:space="preserve">
          <source>The code is legal. However, throws an &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;array store exception&lt;/a&gt;.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping.</source>
          <target state="translated">该代码是合法的。 但是，抛出一个&lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;数组存储异常&lt;/a&gt; 。 数组以这种方式在运行时携带其类型，从而JVM可以强制协变子类型的类型安全。</target>
        </trans-unit>
        <trans-unit id="ec880e5540e317191d0eda22061ad1f16aa30ff0" translate="yes" xml:space="preserve">
          <source>The problem has been well-identified. But there's a solution; make &lt;em&gt;doSomething&lt;/em&gt; generic:</source>
          <target state="translated">该问题已得到充分认识。 但是有一个解决方案。 使&lt;em&gt;doSomething&lt;/em&gt;通用：</target>
        </trans-unit>
        <trans-unit id="b6440d667672409bf8fb7e0306aea73bb570933b" translate="yes" xml:space="preserve">
          <source>The reason a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, is that, for example, you can insert a &lt;code&gt;Cat&lt;/code&gt; into a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, but not into a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is the similar to reading from a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; -- but not writing.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 不是 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 是，例如，您可以将 &lt;code&gt;Cat&lt;/code&gt; 插入 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; ，但不能插入 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ...您可以使用通配符泛型在可能的情况下更可扩展； 例如，从 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 读取与从 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 读取相似，但是不能写入。</target>
        </trans-unit>
        <trans-unit id="ba7ebd605e2db9f872e9f4dc2e8be52afa87b964" translate="yes" xml:space="preserve">
          <source>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</source>
          <target state="translated">OP的直觉的工作方式--当然这完全是有道理的--就是后一句。然而,如果我们应用这个直觉,我们得到的语言在类型系统上并不像Java那样的语言。假设我们的语言确实允许在狗的列表中添加一只猫。这将意味着什么?这意味着这个列表不再是一个狗的列表,而仅仅是一个动物的列表。还有一个哺乳动物和四足动物的列表,还有一个四足动物的列表。</target>
        </trans-unit>
        <trans-unit id="23ce7e603788be5aab21ee61b091d1a2fa64148a" translate="yes" xml:space="preserve">
          <source>Therefore arrays provide runtime type safety but not compile-time type safety.</source>
          <target state="translated">因此,数组提供了运行时的类型安全,但没有提供编译时的类型安全。</target>
        </trans-unit>
        <trans-unit id="c5bfdde28ebbe167fa1e050e24ae8f4ad024ab30" translate="yes" xml:space="preserve">
          <source>Therefore generics can't provide runtime type safety, but they provide compile-time type safety.</source>
          <target state="translated">因此通用型不能提供运行时的类型安全,但可以提供编译时的类型安全。</target>
        </trans-unit>
        <trans-unit id="00c82895236a0a7a878e98ac644697c1418510bb" translate="yes" xml:space="preserve">
          <source>This is usefull when you want to pass the list in a constructor or iterate over it</source>
          <target state="translated">当你想在构造函数中传递列表或在其上迭代时,这很有用</target>
        </trans-unit>
        <trans-unit id="57e00388dd7cbaf4c88629658063578936e69c09" translate="yes" xml:space="preserve">
          <source>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....</source>
          <target state="translated">因此本质上这个行为的实现是为了让人不能把错误的东西添加到集合中。现在,我相信类型擦除的存在是为了与没有通用性的传统java兼容.....。</target>
        </trans-unit>
        <trans-unit id="4786f210fd6512db64d73fcfd87384dc56d0b91a" translate="yes" xml:space="preserve">
          <source>Thus we have &lt;code&gt;ListOfAnimal&lt;/code&gt;, &lt;code&gt;ListOfDog&lt;/code&gt;, &lt;code&gt;ListOfCat&lt;/code&gt;, etc, which are distinct classes that end up being &quot;created&quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to &lt;code&gt;List&lt;/code&gt; is not a hierarchy at all).</source>
          <target state="translated">因此，我们具有 &lt;code&gt;ListOfAnimal&lt;/code&gt; ， &lt;code&gt;ListOfDog&lt;/code&gt; ， &lt;code&gt;ListOfCat&lt;/code&gt; 等，它们是不同的类，最终在指定通用参数时由编译器&amp;ldquo;创建&amp;rdquo;。 这是一个简单的层次结构（实际上，与 &lt;code&gt;List&lt;/code&gt; 根本不是一个层次结构）。</target>
        </trans-unit>
        <trans-unit id="7a9a72b3362404704da9568bb6fb9462dc5392cf" translate="yes" xml:space="preserve">
          <source>To put it another way: A &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; in Java does not mean &quot;a list of dogs&quot; in English, it means &quot;a list which can have dogs, and nothing else&quot;.</source>
          <target state="translated">换句话说：Java中的 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 并不意味着英语中的&amp;ldquo;狗列表&amp;rdquo;，而是&amp;ldquo;可以包含狗的列表，没有别的&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="48cb4ab7d62851fc151a15505099e94b0316692e" translate="yes" xml:space="preserve">
          <source>To understand the problem it's useful to make comparison to arrays.</source>
          <target state="translated">为了理解这个问题,我们可以将其与数组进行比较。</target>
        </trans-unit>
        <trans-unit id="d5a9aae8fbcc3e1f36369c98b0b7f2207dc564a1" translate="yes" xml:space="preserve">
          <source>To understand this further let's look at the bytecode generated by &lt;code&gt;javap&lt;/code&gt; of the class below:</source>
          <target state="translated">为了进一步了解这一点，让我们看一下下面的类的 &lt;code&gt;javap&lt;/code&gt; 生成的字节码：</target>
        </trans-unit>
        <trans-unit id="03dfd09db768e40e7564a1ad7500d78d1c2d2d78" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;javap -c Demonstration&lt;/code&gt;, this shows the following Java bytecode:</source>
          <target state="translated">使用命令 &lt;code&gt;javap -c Demonstration&lt;/code&gt; ，将显示以下Java字节码：</target>
        </trans-unit>
        <trans-unit id="754919ef9edabe390bb0a56957e1038bbadc51c3" translate="yes" xml:space="preserve">
          <source>We even can do</source>
          <target state="translated">我们甚至可以做到</target>
        </trans-unit>
        <trans-unit id="a4a8f17fd0e17a7a59d13cdf7845711a3b9c6069" translate="yes" xml:space="preserve">
          <source>We should also take in consideration how the compiler threats the generic classes: in &quot;instantiates&quot; a different type whenever we fill the generic arguments.</source>
          <target state="translated">我们还应该考虑到编译器是如何威胁泛型类的:在 &quot;实例化 &quot;中,每当我们填充泛型参数时,就会 &quot;实例化 &quot;一个不同的类型。</target>
        </trans-unit>
        <trans-unit id="53afcffe1e893d87963a71f6d157ea0408568d23" translate="yes" xml:space="preserve">
          <source>What you are looking for is called &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;covariant type&lt;/a&gt; parameters&lt;/em&gt;. This means that if one type of object can be substituted for another in a method (for instance, &lt;code&gt;Animal&lt;/code&gt; can be replaced with &lt;code&gt;Dog&lt;/code&gt;), the same applies to expressions using those objects (so &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; could be replaced with &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;, and it is being used as a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.  What happens when you try to add a Cat to this &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; which is really a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;?  Automatically allowing type parameters to be covariant breaks the type system.</source>
          <target state="translated">您正在寻找的被称为&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;协变类型&lt;/a&gt;参数&lt;/em&gt; 。 这意味着，如果一种对象类型可以在方法中替代另一种类型（例如， &lt;code&gt;Animal&lt;/code&gt; 可以用 &lt;code&gt;Dog&lt;/code&gt; 替换），则同样适用于使用这些对象的表达式（因此 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 可以替换为 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ）。 问题在于，协方差通常对于可变列表并不安全。 假设您有一个 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; ，并且它被用作 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 。 当您尝试将猫添加到此 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; （实际上是 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 什么？ 自动允许类型参数协变会破坏类型系统。</target>
        </trans-unit>
        <trans-unit id="8d5d23c16bd63540ead2c74914ddab1e126bc3f6" translate="yes" xml:space="preserve">
          <source>another solution is to build a new list</source>
          <target state="translated">另一个解决方案是建立一个新的列表</target>
        </trans-unit>
        <trans-unit id="6ed375dc664a800e63fb268753b8f59714929e45" translate="yes" xml:space="preserve">
          <source>consider the subtype to be it's supertype and restrict at compile the &quot;add&quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</source>
          <target state="translated">将子类型看作是它的超类型,并在编译时限制 &quot;add &quot;方法(所以在drawAll方法中,如果传递了一个圆的列表,即形状的子类型,编译器应该会检测到这一点,并限制你在编译时出错)。</target>
        </trans-unit>
        <trans-unit id="9a49e1031f2ed9d14b8f10116b441e35b8bd75c8" translate="yes" xml:space="preserve">
          <source>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</source>
          <target state="translated">不要认为一个子类型是隐含了它的超类型,并给出一个编译错误,就像现在发生的那样</target>
        </trans-unit>
        <trans-unit id="917a49b3ab1b964d351680a9d496835660c085e3" translate="yes" xml:space="preserve">
          <source>it is also true that</source>
          <target state="translated">也是</target>
        </trans-unit>
        <trans-unit id="3109cbe3b4d36e8f4714482083b76fe25ee4a957" translate="yes" xml:space="preserve">
          <source>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</source>
          <target state="translated">确保我们只能使用能够为消费者提供正确类型对象的供应商。</target>
        </trans-unit>
        <trans-unit id="34263cba8588e8a17ab060861593d2d646e5fba6" translate="yes" xml:space="preserve">
          <source>now you can call doSomething with either List&amp;lt;Dog&amp;gt; or List&amp;lt;Cat&amp;gt; or List&amp;lt;Animal&amp;gt;.</source>
          <target state="translated">现在您可以使用List &amp;lt;Dog&amp;gt;或List &amp;lt;Cat&amp;gt;或List &amp;lt;Animal&amp;gt;来调用doSomething。</target>
        </trans-unit>
        <trans-unit id="d331fcedf530a8517412040f7d5855e4ea193dae" translate="yes" xml:space="preserve">
          <source>sounds fine, doesn't it? But you can only pass &lt;code&gt;Consumer&lt;/code&gt;s and &lt;code&gt;Supplier&lt;/code&gt;s for &lt;code&gt;Animal&lt;/code&gt;s. If you have a &lt;code&gt;Mammal&lt;/code&gt; consumer, but a &lt;code&gt;Duck&lt;/code&gt; supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</source>
          <target state="translated">听起来不错，不是吗？ 但是您只能通过 &lt;code&gt;Consumer&lt;/code&gt; 和 &lt;code&gt;Supplier&lt;/code&gt; 的 &lt;code&gt;Animal&lt;/code&gt; 。 如果您有 &lt;code&gt;Mammal&lt;/code&gt; 消费者，但有 &lt;code&gt;Duck&lt;/code&gt; 供应商，尽管它们都是动物，但它们不适合。 为了禁止这种情况，添加了其他限制。</target>
        </trans-unit>
        <trans-unit id="0326968b7f692e04985959e0b5f6e025c50d1747" translate="yes" xml:space="preserve">
          <source>therefore you can't put the wrong subtype of &lt;code&gt;Animal&lt;/code&gt; into the list, because there is no wrong subtype -- any object of subtype &lt;code&gt;? extends Animal&lt;/code&gt; can be added to &lt;code&gt;animals&lt;/code&gt;.</source>
          <target state="translated">因此您不能将错误的 &lt;code&gt;Animal&lt;/code&gt; 子类型放入列表中，因为没有错误的子类型-任何子类型的对象 &lt;code&gt;? extends Animal&lt;/code&gt; 可以将 &lt;code&gt;animals&lt;/code&gt; 添加到动物中 。</target>
        </trans-unit>
        <trans-unit id="f38425b32961346a1ff8ec4c2f4f3802f76f7cb1" translate="yes" xml:space="preserve">
          <source>where we go the other way: we define the type of the &lt;code&gt;Supplier&lt;/code&gt; and restrict that it can be put into the &lt;code&gt;Consumer&lt;/code&gt;.</source>
          <target state="translated">我们采取另一种方式：定义 &lt;code&gt;Supplier&lt;/code&gt; 的类型，并限制可以放入 &lt;code&gt;Consumer&lt;/code&gt; 的类型 。</target>
        </trans-unit>
        <trans-unit id="62b6ffb0d183ccad287984bf71c0f6ef92c471a6" translate="yes" xml:space="preserve">
          <source>where, having the intuitive relations &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt;, &lt;code&gt;Cat&lt;/code&gt; etc., we could even put a &lt;code&gt;Mammal&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer, but not a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer.</source>
          <target state="translated">在这里，有了 &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt; ， &lt;code&gt;Cat&lt;/code&gt; 等的直观关系，我们甚至可以将 &lt;code&gt;Mammal&lt;/code&gt; 放入 &lt;code&gt;Life&lt;/code&gt; 消费者中，而不是将 &lt;code&gt;String&lt;/code&gt; 放入 &lt;code&gt;Life&lt;/code&gt; 消费者中。</target>
        </trans-unit>
        <trans-unit id="e8cb6da1df995798f3ac8506f94719679ef5c11c" translate="yes" xml:space="preserve">
          <source>you can then use the collections using</source>
          <target state="translated">然后你可以使用</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
