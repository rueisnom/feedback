<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2745265">
    <body>
      <group id="2745265">
        <trans-unit id="90a10e20bd2c8e7f512a36f9986e6bd625a12b68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt; means their type information is fully available at runtime.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;수정&lt;/a&gt; 가능은 유형 정보가 런타임시 완전히 사용 가능함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d492a733adb02b8320864e88f8357ed772fc394d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; subclass of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 는 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 서브 클래스가 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5b38d828fcef53ec9e2076c3fa73400ff6ed0737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; isn't-a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;&lt;strong&gt;in Java&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; &lt;strong&gt;는 Java&lt;/strong&gt; 의 List &amp;lt;Animal&amp;gt;이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="63014900394aa67a0cc9fc3284de4e4252474b9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Animal&lt;/strong&gt; (Parent)</source>
          <target state="translated">&lt;strong&gt;동물&lt;/strong&gt; (부모)</target>
        </trans-unit>
        <trans-unit id="e0fe91def2724cfdeae839f5686512b73124e94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays are &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;reifiable&lt;/a&gt; and covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;배열은 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;수정 가능&lt;/a&gt; 하며 공변량&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e328038c60dede3020d85585548cc6d876f670a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But&lt;/strong&gt;&lt;code&gt;Dog[]&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; subclass of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;그러나&lt;/strong&gt; &lt;code&gt;Dog[]&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; &lt;code&gt;Animal[]&lt;/code&gt; 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="eb3f40109f1f6807b64f388fb31fb0af45ca1e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dog&lt;/strong&gt; - &lt;strong&gt;Cat&lt;/strong&gt; (Children)</source>
          <target state="translated">&lt;strong&gt;개&lt;/strong&gt; - &lt;strong&gt;고양이&lt;/strong&gt; (어린이)</target>
        </trans-unit>
        <trans-unit id="304ec5ad8646d255b82e3edf25a0ad01d2c2de03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generics are &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;erased&lt;/a&gt; and invariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;제네릭은 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;지워지고&lt;/a&gt; 변하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdca835127fee237411a140f68169f05cc675c3" translate="yes" xml:space="preserve">
          <source>A list of dogs is-a list of animals &lt;strong&gt;in English&lt;/strong&gt; (well, under a reasonable interpretation)</source>
          <target state="translated">개 목록은 &lt;strong&gt;영어&lt;/strong&gt; 로 된 동물 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e3f7f1c5a95fabfdae274ff4f328ee3f1b9a462f" translate="yes" xml:space="preserve">
          <source>A point I think should be added to what &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;answers&lt;/a&gt; mention is that while</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;다른&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;답변에서&lt;/a&gt; 언급 한 것에 추가해야한다고 생각하는 점은</target>
        </trans-unit>
        <trans-unit id="6d7e1bb7645e004caf223707662fb2057339d98a" translate="yes" xml:space="preserve">
          <source>Actually you can use an interface to achieve what you want.</source>
          <target state="translated">실제로 인터페이스를 사용하여 원하는 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344527118c80c2af2edf1e6d80bca72266b3175b" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt;, you cannot subsequently directly assign &lt;code&gt;animals&lt;/code&gt; to either &lt;code&gt;dogs&lt;/code&gt; or &lt;code&gt;cats&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt; 호출 후 = new ArrayList &amp;lt;&amp;gt; (dogs); 그 후에는 &lt;code&gt;dogs&lt;/code&gt; &lt;code&gt;cats&lt;/code&gt; 에게 직접 &lt;code&gt;animals&lt;/code&gt; 을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e68eb3128cd4e3b375fed2af8ca940aea40c8999" translate="yes" xml:space="preserve">
          <source>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are &lt;code&gt;List&lt;/code&gt; instances. Specialising a &lt;code&gt;List&lt;/code&gt; by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</source>
          <target state="translated">제네릭 클래스의 경우 공분산이 의미가없는 또 다른 주장은 기본적으로 모든 클래스가 동일하다는 사실입니다. 즉, &lt;code&gt;List&lt;/code&gt; 인스턴스입니다. 제네릭 인수를 채워서 &lt;code&gt;List&lt;/code&gt; 를 전문화하면 클래스가 확장되지 않고 특정 제네릭 인수에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7a959cb20c2a75f6a5e8944beb44f43926299f02" translate="yes" xml:space="preserve">
          <source>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</source>
          <target state="translated">@Jon Skeet이 말했듯 이이 코드는 불법입니다. 그렇지 않으면 개가 예상했을 때 고양이를 반환하여 유형 제약 조건을 위반하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9e0ea5bc85b2c61dce27b3c8ed31b0557f59af05" translate="yes" xml:space="preserve">
          <source>Assume the following hierarchy -</source>
          <target state="translated">다음 계층을 가정하십시오-</target>
        </trans-unit>
        <trans-unit id="381c0989adf609934d9987de7750f37d8d6422bb" translate="yes" xml:space="preserve">
          <source>At the deepest level, the problem here is that &lt;code&gt;dogs&lt;/code&gt; and &lt;code&gt;animals&lt;/code&gt; share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</source>
          <target state="translated">가장 깊은 수준에서, 여기서 문제는 &lt;code&gt;dogs&lt;/code&gt; &lt;code&gt;animals&lt;/code&gt; 이 참조를 공유한다는 것입니다. 즉,이 작업을 수행하는 한 가지 방법은 전체 목록을 복사하여 참조 평등을 위반하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2eda859b24b9c57e6183b93096e9b63efeaee18e" translate="yes" xml:space="preserve">
          <source>E. g.,</source>
          <target state="translated">예 :</target>
        </trans-unit>
        <trans-unit id="204aa29f1c9a6ab4ac20c77ee47b170439787c52" translate="yes" xml:space="preserve">
          <source>For obvious reasons, that chose the first way.</source>
          <target state="translated">명백한 이유로, 그것은 첫 번째 방법을 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="17d3a2e5b2ebbd18c169ee52622d864801d45a32" translate="yes" xml:space="preserve">
          <source>Further to the answer by Jon Skeet, which uses this example code:</source>
          <target state="translated">이 예제 코드를 사용하는 Jon Skeet의 답변 외에도</target>
        </trans-unit>
        <trans-unit id="96f1150d546de158ef07e02fb89e723cc69163ca" translate="yes" xml:space="preserve">
          <source>I understand that this is Java's behavior. My question is &lt;em&gt;why&lt;/em&gt;? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</source>
          <target state="translated">나는 이것이 Java의 행동이라는 것을 이해합니다. 내 질문은 &lt;em&gt;왜&lt;/em&gt; ? 다형성이 일반적으로 암시적인 이유는 있지만 제네릭과 관련하여 지정해야합니까?</target>
        </trans-unit>
        <trans-unit id="fccd4d39d44d0871993dd57d00b01ed07c504c36" translate="yes" xml:space="preserve">
          <source>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</source>
          <target state="translated">나는 Generics의 요점은 그것을 허용하지 않는다는 것입니다. 해당 유형의 공분산을 허용하는 배열의 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="01e70d4e3c86e0b7b2d3599eb15c5d79e5389855" translate="yes" xml:space="preserve">
          <source>I'm a bit confused about how Java generics handle inheritance / polymorphism.</source>
          <target state="translated">Java 제네릭이 상속 / 다형성을 처리하는 방법에 대해 약간 혼란 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="a2c736ed9244357382e64aceca74b1e587e71857" translate="yes" xml:space="preserve">
          <source>If you are sure that the list items are subclasses of that given super type you can cast the list using this approach:</source>
          <target state="translated">목록 항목이 주어진 수퍼 유형의 서브 클래스임을 확신하는 경우 다음 방법을 사용하여 목록을 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604f0777accde51cdb9a2e95bba2b694a31efdec" translate="yes" xml:space="preserve">
          <source>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</source>
          <target state="translated">결론적으로 컴파일러는 각 매개 변수화 된 유형을 삭제로 대체하기 때문에 매개 변수화 된 유형에는 런타임 안전성이 불가능합니다. 이것은 매개 변수화 된 유형을 구문 설탕에 지나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6df8c875d5596e81ece51df756bb5a6e3e44560" translate="yes" xml:space="preserve">
          <source>In most cases, we can use &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; rather then &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; to a &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; T&amp;gt; 대신 T&amp;gt;를 확장 하므로 이것이 첫 번째 선택이어야합니다. 그러나 그렇게하기 쉽지 않은 사례를 찾고 있습니다. 그것이 항상 최선의 것인지 아닌지는 논쟁의 여지가 있습니다. 여기에 &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; 변환 할 수있는 DownCastCollection 클래스를 제시하고 있습니까? 표준 접근법을 사용하는 것이 매우 불편할 때 T&amp;gt; 를 &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (List, Set, NavigableSet, ..에 대해 유사한 클래스를 정의 할 수 있음)로 확장합니다. 아래는 그것을 사용하는 방법의 예입니다 (이 경우 &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 도 사용할 수 있지만 DownCastCollection을 사용하여 설명하는 것이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1ffe7e463ad2cbcb1de6c5e2e33c9d5181c4568a" translate="yes" xml:space="preserve">
          <source>In the code below if generics were covariant it will be possible to make &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;heap pollution&lt;/a&gt; at line 3.</source>
          <target state="translated">아래 코드에서 제네릭이 공변량 인 경우 3 행에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;힙 오염&lt;/a&gt; 을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0d547b9a45e2cd6f0e18b37f983db0f182eec3" translate="yes" xml:space="preserve">
          <source>Instead of the above, we have to define relationships between the types we use.</source>
          <target state="translated">위 대신에 사용하는 유형 간의 관계를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="99aa3435dd6dd09d2f123ec6780ffb6b4b0e2c9e" translate="yes" xml:space="preserve">
          <source>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</source>
          <target state="translated">변하지 않는 서브 타이핑은 Java에 의해 시행되는 유형 제약 조건이 위반되지 않도록합니다. @Jon Skeet이 제공 한 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="29a4d80153ea7b51095ece74755bb5043916df2f" translate="yes" xml:space="preserve">
          <source>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic</source>
          <target state="translated">목록 &lt;dog&gt; List의 서브 클래스 &lt;animal&gt; ? Java 제네릭이 암시 적으로 다형성이 아닌 이유 &lt;/animal&gt;&lt;/dog&gt;</target>
        </trans-unit>
        <trans-unit id="91db49b2b9e77ed757d10476e32752227a891692" translate="yes" xml:space="preserve">
          <source>It is instructive to compare the above to analogous code for arrays.</source>
          <target state="translated">위의 배열과 비슷한 코드를 비교하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3ed717cb0f96ab9f0d80c86ad25d852eb370af29" translate="yes" xml:space="preserve">
          <source>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the &lt;code&gt;? extends Foo&lt;/code&gt; in method declarations, but that does add additional complexity.</source>
          <target state="translated">유형 매개 변수를 공변량으로 지정할 수 있도록 구문을 추가하면 유용합니다 &lt;code&gt;? extends Foo&lt;/code&gt; 메소드 선언에서 Foo 를 확장 하지만 복잡성이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b88103aa22a4125409bcc1ce1af145750f709c" translate="yes" xml:space="preserve">
          <source>It's vice versa for generics:</source>
          <target state="translated">제네릭의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="6d9e846d6c182c9be543e2edb9fad821781f6e1c" translate="yes" xml:space="preserve">
          <source>Lets take the example from JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;tutorial&lt;/a&gt;</source>
          <target state="translated">JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;튜토리얼&lt;/a&gt; 에서 예제를 보자</target>
        </trans-unit>
        <trans-unit id="db49ead253373ebf491e45d83a3eaede6658b135" translate="yes" xml:space="preserve">
          <source>More generally, &lt;strong&gt;OP's intuition lends itself towards a language in which operations on objects can change their type&lt;/strong&gt;, or rather, an object's type(s) is a (dynamic) function of its value.</source>
          <target state="translated">보다 일반적으로 &lt;strong&gt;OP의 직관은 객체에 대한 작업이 유형을 변경할 수있는 언어에 적합&lt;/strong&gt; 하거나 오히려 객체의 유형이 값의 (동적) 함수입니다.</target>
        </trans-unit>
        <trans-unit id="59becb84eaea3240c06cacb7affabdb553d2b2d4" translate="yes" xml:space="preserve">
          <source>No, a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. Consider what you can do with a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - you can add &lt;em&gt;any&lt;/em&gt; animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</source>
          <target state="translated">아니요, &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 는 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 이 &lt;em&gt;아닙니다&lt;/em&gt; . 당신이 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 할 수있는 것을 고려하십시오-당신은 고양이를 포함하여 그것에 동물을 추가 할 수 있습니다. 이제 강아지 한 마리에 논리적으로 고양이를 추가 할 수 있습니까? 절대적으로하지.</target>
        </trans-unit>
        <trans-unit id="169a8aa30694368f01ec9a80e5d310b4a4fa72a0" translate="yes" xml:space="preserve">
          <source>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</source>
          <target state="translated">이제 java가 호출자 가이 메소드에 Animal 유형의 List를 추가 할 수있게하면 콜렉션에 잘못된 것을 추가 할 수 있으며 런타임에도 유형 삭제로 인해 실행됩니다. 배열의 경우 그러한 시나리오에 대해 런타임 예외가 발생합니다 ...</target>
        </trans-unit>
        <trans-unit id="b46664ca8654b90a0e162c4b3dff03b7d478ecda" translate="yes" xml:space="preserve">
          <source>Now the class:</source>
          <target state="translated">이제 수업 :</target>
        </trans-unit>
        <trans-unit id="dc101928e56b106ed14a4a66b3e29f57d6fb1fc6" translate="yes" xml:space="preserve">
          <source>Now there are times where you need to be more flexible and that is what the &lt;code&gt;? super Class&lt;/code&gt; and &lt;code&gt;? extends Class&lt;/code&gt; are for. The former is when you need to insert into a type &lt;code&gt;Collection&lt;/code&gt; (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</source>
          <target state="translated">이제 좀 더 융통성이 있어야 할 때가 있습니다 &lt;code&gt;? super Class&lt;/code&gt; 슈퍼 클래스 와 &lt;code&gt;? extends Class&lt;/code&gt; 클래스 가 확장 됩니다. 전자는 유형 &lt;code&gt;Collection&lt;/code&gt; 에 삽입해야 할 때 (예 :), 후자는 유형 안전 방식으로 읽어야 할 때입니다. 그러나 동시에 두 가지를 수행하는 유일한 방법은 특정 유형을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fd32cdcc763728be3ed9548fd8cc6d813d21f84" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;can't&lt;/em&gt; add a &lt;code&gt;Cat&lt;/code&gt; to a &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; because you don't know it's a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;. You can retrieve a value and know that it will be an &lt;code&gt;Animal&lt;/code&gt;, but you can't add arbitrary animals. The reverse is true for &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; - in that case you can add an &lt;code&gt;Animal&lt;/code&gt; to it safely, but you don't know anything about what might be retrieved from it, because it could be a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Cat&lt;/code&gt; 를 &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; 추가 할 &lt;em&gt;수 없습니다&lt;/em&gt; &amp;lt;? 당신이 &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; 인지 모르기 때문에 Animal&amp;gt; 확장 합니다. 값을 검색하여 그 값이 &lt;code&gt;Animal&lt;/code&gt; 일 수 있음을 알 수 있지만 임의의 동물을 추가 할 수는 없습니다. 반대로 &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; super Animal&amp;gt; -이 경우에는 &lt;code&gt;Animal&lt;/code&gt; 을 안전하게 추가 할 수 있지만, &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 일 수 있기 때문에 검색 할 수있는 항목에 대해서는 아무것도 모릅니다.</target>
        </trans-unit>
        <trans-unit id="7b8252d2eb721be021d186b1fa8f366cf90af2fe" translate="yes" xml:space="preserve">
          <source>OTOH, we could as well do</source>
          <target state="translated">OTOH, 우리도 할 수 있었다</target>
        </trans-unit>
        <trans-unit id="4f1b7d75431b202c7bc72bc61ee6387be8273957" translate="yes" xml:space="preserve">
          <source>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;erasure&lt;/a&gt;. This property is crucial meaning that it did not break backwards compatibility.</source>
          <target state="translated">번역 된 메소드 본문의 코드가 동일한 지 확인하십시오. 컴파일러는 각 매개 변수화 된 유형을 &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;삭제&lt;/a&gt; 로 대체했습니다. 이 속성은 이전 버전과의 호환성을 손상시키지 않았다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="6f4ce7da4e6b06cef1e0b7c88880e970e5b28ba6" translate="yes" xml:space="preserve">
          <source>Obviously, this changes the semantics, since the lists &lt;code&gt;animals&lt;/code&gt; and &lt;code&gt;dogs&lt;/code&gt; are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a &lt;code&gt;Cat&lt;/code&gt; could be added to a list that is only supposed to contain &lt;code&gt;Dog&lt;/code&gt; objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</source>
          <target state="translated">목록 &lt;code&gt;animals&lt;/code&gt; 과 &lt;code&gt;dogs&lt;/code&gt; 더 이상 공유되지 않기 때문에 의미가 변경됩니다. 따라서 한 목록에 추가해도 다른 목록에는 추가되지 않습니다 (정확히 원하는 것은 &lt;code&gt;Cat&lt;/code&gt; 이 목록에 추가 될 수있는 문제를 피하기 위해) 그것은 단지 &lt;code&gt;Dog&lt;/code&gt; 객체를 포함해야합니다). 또한 전체 목록을 복사하면 비효율적 일 수 있습니다. 그러나 이것은 참조 평등을 깨뜨림으로써 유형 동등성 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="5d8a48922072f2b11fdf281f658f9367702184e2" translate="yes" xml:space="preserve">
          <source>So Java &quot;architects&quot; had 2 options which address this problem:</source>
          <target state="translated">따라서 Java &quot;architects&quot;에는이 문제를 해결하는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f145bb0cec9dfa89cc809b42253f1893cd611d" translate="yes" xml:space="preserve">
          <source>So suppose I have a method &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt;. By all the rules of inheritance and polymorphism, I would assume that a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; and a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt;.</source>
          <target state="translated">그래서 &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt; 메소드가 있다고 가정하십시오. 상속과 다형성의 모든 규칙에 따라 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 이고 &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 하여 둘 중 하나를이 메서드에 전달할 수 있습니다. 별로. 이 동작을 달성하려면 &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt; 을 말하여 Animal의 하위 클래스 목록을 수락하도록 메소드에 명시 적으로 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="cca9629e4bee6bd9d98e8f03a6ec1b01b5f8071f" translate="yes" xml:space="preserve">
          <source>So suppose there is a method as given below:</source>
          <target state="translated">따라서 아래에 주어진 방법이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a199246c454ab2f91900765521747e50834f16f8" translate="yes" xml:space="preserve">
          <source>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</source>
          <target state="translated">따라서 개 (원) 목록이 암시 적으로 동물 (모양) 목록으로 간주되어서는 안되는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c83895af74d72b8dc8bbd8e3db07cd62efff8e4" translate="yes" xml:space="preserve">
          <source>Subtyping is &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;invariant&lt;/a&gt; for parameterized types. Even tough the class &lt;code&gt;Dog&lt;/code&gt; is a subtype of &lt;code&gt;Animal&lt;/code&gt;, the parameterized type &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. In contrast, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;covariant&lt;/a&gt; subtyping is used by arrays, so the array
type &lt;code&gt;Dog[]&lt;/code&gt; is a subtype of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">서브 타이핑은 매개 변수화 된 유형에 대해 &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;변하지 않습니다&lt;/a&gt; . &lt;code&gt;Dog&lt;/code&gt; 클래스가 &lt;code&gt;Animal&lt;/code&gt; 의 하위 유형 인 경우에도 매개 변수화 된 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 유형은 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 의 하위 유형이 아닙니다. 반대로 &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;공변량&lt;/a&gt; 하위 유형 지정은 배열에서 사용되므로 배열 유형 &lt;code&gt;Dog[]&lt;/code&gt; 는 &lt;code&gt;Animal[]&lt;/code&gt; 의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="37ff2a1d25d6a239c07acd25dde697fc50a42eb9" translate="yes" xml:space="preserve">
          <source>Suddenly you have a &lt;em&gt;very&lt;/em&gt; confused cat.</source>
          <target state="translated">갑자기 당신은 &lt;em&gt;매우&lt;/em&gt; 혼란스러운 고양이를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="16d127ac7c16458178ca5e456a5c49755036fe42" translate="yes" xml:space="preserve">
          <source>That code compiles fine, but throws a runtime error (&lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</source>
          <target state="translated">이 코드는 잘 컴파일되지만 런타임 오류가 발생합니다 (두 번째 줄에서 &lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; ). 형식이 안전하지 않습니다. 제네릭의 요점은 컴파일 타임 타입 안전을 추가하는 것입니다. 그렇지 않으면 제네릭이없는 일반 클래스를 고수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="584190794514e75254dea7c2060370444e691d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Generics in the Java Language&lt;/a&gt; and the &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;Section on Generics from the Java Tutorials&lt;/a&gt; have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</source>
          <target state="translated">&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;자바 언어&lt;/a&gt; 의 제네릭 과 &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;자바 튜토리얼의 제네릭 섹션은&lt;/a&gt; 왜 어떤 것이 다형성이거나 제네릭으로 허용되지 않는지에 대해 매우 잘 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc94e800ea480646ce6ba48ed62ffc07b3b6d12a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;answer&lt;/a&gt;  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.</source>
          <target state="translated">다른 대답뿐만 아니라 그 대답도 정확합니다. 나는 도움이 될 것이라고 생각되는 해결책으로 그 대답에 덧붙일 것입니다. 나는 이것이 종종 프로그래밍에서 나온다고 생각합니다. 주목해야 할 것은 컬렉션 (리스트, 세트 등)의 주요 문제는 컬렉션에 추가한다는 것입니다. 그곳이 상황이 무너지는 곳입니다. 제거해도 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="d4a722f5af2f92c06a2884931937c02445379d87" translate="yes" xml:space="preserve">
          <source>The answers given here didn't fully convince me. So instead, I make another example.</source>
          <target state="translated">여기에 주어진 대답은 완전히 확신하지 못했습니다. 대신 다른 예를 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="fa4065cf11262ad86892b5d6301cc8618a09d2ee" translate="yes" xml:space="preserve">
          <source>The basis logic for such behavior is that &lt;code&gt;Generics&lt;/code&gt; follow a mechanism of type erasure. So at run time you have no way if identifying the type of &lt;code&gt;collection&lt;/code&gt; unlike &lt;code&gt;arrays&lt;/code&gt; where there is no such erasure process. So coming back to your question...</source>
          <target state="translated">이러한 행동의 기본 논리는 &lt;code&gt;Generics&lt;/code&gt; 이 유형 삭제 메커니즘을 따르는 것입니다. 따라서 런타임에는 삭제 프로세스가없는 &lt;code&gt;arrays&lt;/code&gt; 과 달리 &lt;code&gt;collection&lt;/code&gt; 유형을 식별 할 수 있는 방법이 없습니다. 다시 질문으로 돌아와서</target>
        </trans-unit>
        <trans-unit id="9c3267d922c893a40cc754519d5648d0800218f7" translate="yes" xml:space="preserve">
          <source>The code is legal. However, throws an &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;array store exception&lt;/a&gt;.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping.</source>
          <target state="translated">코드는 합법적입니다. 그러나 &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;배열 저장소 예외가 발생&lt;/a&gt; 합니다. JVM이 공변량 하위 유형 지정의 유형 안전을 시행 할 수있는 방식으로 배열이 런타임에 해당 유형을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ec880e5540e317191d0eda22061ad1f16aa30ff0" translate="yes" xml:space="preserve">
          <source>The problem has been well-identified. But there's a solution; make &lt;em&gt;doSomething&lt;/em&gt; generic:</source>
          <target state="translated">문제가 잘 식별되었습니다. 그러나 해결책이 있습니다. &lt;em&gt;doSomething을&lt;/em&gt; 일반화하십시오.</target>
        </trans-unit>
        <trans-unit id="b6440d667672409bf8fb7e0306aea73bb570933b" translate="yes" xml:space="preserve">
          <source>The reason a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, is that, for example, you can insert a &lt;code&gt;Cat&lt;/code&gt; into a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, but not into a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is the similar to reading from a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; -- but not writing.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 가 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; &amp;gt; 이 아닌 이유는, 예를 들어, &lt;code&gt;Cat&lt;/code&gt; 을 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 삽입 할 수 있지만 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 삽입 할 수 없기 때문에 와일드 카드를 사용하여 만들 수 있기 때문입니다. 가능한 경우 더 확장 가능한 제네릭; 예를 들어 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 에서 읽는 것은 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 에서 읽는 것과 비슷하지만 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba7ebd605e2db9f872e9f4dc2e8be52afa87b964" translate="yes" xml:space="preserve">
          <source>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</source>
          <target state="translated">OP의 직관이 작동하는 방식은 물론 완전히 유효합니다. 후자의 문장입니다. 그러나이 직관을 적용하면 유형 체계에 Java가 아닌 언어가 생깁니다. 언어에서 개 목록에 고양이를 추가 할 수 있다고 가정합니다. 그게 무슨 뜻이야? 그것은 목록이 개 목록이 아니라 동물 목록 일 뿐이라는 것을 의미합니다. 그리고 포유류의 목록과 4 중의 목록.</target>
        </trans-unit>
        <trans-unit id="23ce7e603788be5aab21ee61b091d1a2fa64148a" translate="yes" xml:space="preserve">
          <source>Therefore arrays provide runtime type safety but not compile-time type safety.</source>
          <target state="translated">따라서 배열은 런타임 유형 안전을 제공하지만 컴파일 타임 유형 안전은 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5bfdde28ebbe167fa1e050e24ae8f4ad024ab30" translate="yes" xml:space="preserve">
          <source>Therefore generics can't provide runtime type safety, but they provide compile-time type safety.</source>
          <target state="translated">따라서 제네릭은 런타임 형식 안전을 제공 할 수 없지만 컴파일 타임 형식 안전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00c82895236a0a7a878e98ac644697c1418510bb" translate="yes" xml:space="preserve">
          <source>This is usefull when you want to pass the list in a constructor or iterate over it</source>
          <target state="translated">생성자에서 목록을 전달하거나 반복 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="57e00388dd7cbaf4c88629658063578936e69c09" translate="yes" xml:space="preserve">
          <source>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....</source>
          <target state="translated">따라서 본질적으로이 동작은 구현되어 잘못된 것을 컬렉션에 추가 할 수 없습니다. 이제 제네릭없이 레거시 Java와 호환되도록 유형 삭제가 존재한다고 생각합니다 ....</target>
        </trans-unit>
        <trans-unit id="4786f210fd6512db64d73fcfd87384dc56d0b91a" translate="yes" xml:space="preserve">
          <source>Thus we have &lt;code&gt;ListOfAnimal&lt;/code&gt;, &lt;code&gt;ListOfDog&lt;/code&gt;, &lt;code&gt;ListOfCat&lt;/code&gt;, etc, which are distinct classes that end up being &quot;created&quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to &lt;code&gt;List&lt;/code&gt; is not a hierarchy at all).</source>
          <target state="translated">따라서 &lt;code&gt;ListOfAnimal&lt;/code&gt; , &lt;code&gt;ListOfDog&lt;/code&gt; , &lt;code&gt;ListOfCat&lt;/code&gt; 등이 있는데, 이는 일반 인수를 지정할 때 컴파일러가 &quot;만들&quot;게되는 고유 한 클래스입니다. 그리고 이것은 평평한 계층 구조입니다 (실제로 &lt;code&gt;List&lt;/code&gt; 와 관련하여 전혀 계층 구조가 아닙니다).</target>
        </trans-unit>
        <trans-unit id="7a9a72b3362404704da9568bb6fb9462dc5392cf" translate="yes" xml:space="preserve">
          <source>To put it another way: A &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; in Java does not mean &quot;a list of dogs&quot; in English, it means &quot;a list which can have dogs, and nothing else&quot;.</source>
          <target state="translated">다시 말하면 Java의 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 는 영어로 &quot;개 목록&quot;을 의미하는 것이 아니라 &quot;개를 가질 수있는 목록&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="48cb4ab7d62851fc151a15505099e94b0316692e" translate="yes" xml:space="preserve">
          <source>To understand the problem it's useful to make comparison to arrays.</source>
          <target state="translated">문제를 이해하려면 배열과 비교하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d5a9aae8fbcc3e1f36369c98b0b7f2207dc564a1" translate="yes" xml:space="preserve">
          <source>To understand this further let's look at the bytecode generated by &lt;code&gt;javap&lt;/code&gt; of the class below:</source>
          <target state="translated">이것을 더 이해하기 위해 아래 클래스의 &lt;code&gt;javap&lt;/code&gt; 에 의해 생성 된 바이트 코드를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="03dfd09db768e40e7564a1ad7500d78d1c2d2d78" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;javap -c Demonstration&lt;/code&gt;, this shows the following Java bytecode:</source>
          <target state="translated">&lt;code&gt;javap -c Demonstration&lt;/code&gt; 명령을 사용하면 다음 Java 바이트 코드가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="754919ef9edabe390bb0a56957e1038bbadc51c3" translate="yes" xml:space="preserve">
          <source>We even can do</source>
          <target state="translated">우린 할 수있어</target>
        </trans-unit>
        <trans-unit id="a4a8f17fd0e17a7a59d13cdf7845711a3b9c6069" translate="yes" xml:space="preserve">
          <source>We should also take in consideration how the compiler threats the generic classes: in &quot;instantiates&quot; a different type whenever we fill the generic arguments.</source>
          <target state="translated">또한 컴파일러가 일반 클래스를 위협하는 방법을 고려해야합니다. 일반 인수를 채울 때마다 다른 유형을 &quot;인스턴스화&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="53afcffe1e893d87963a71f6d157ea0408568d23" translate="yes" xml:space="preserve">
          <source>What you are looking for is called &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;covariant type&lt;/a&gt; parameters&lt;/em&gt;. This means that if one type of object can be substituted for another in a method (for instance, &lt;code&gt;Animal&lt;/code&gt; can be replaced with &lt;code&gt;Dog&lt;/code&gt;), the same applies to expressions using those objects (so &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; could be replaced with &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;, and it is being used as a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.  What happens when you try to add a Cat to this &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; which is really a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;?  Automatically allowing type parameters to be covariant breaks the type system.</source>
          <target state="translated">찾고있는 것을 &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;공변량 유형&lt;/a&gt; 매개 변수&lt;/em&gt; 라고합니다. 즉, 메소드에서 한 유형의 오브젝트를 다른 유형으로 대체 할 수있는 경우 (예 : &lt;code&gt;Animal&lt;/code&gt; 을 &lt;code&gt;Dog&lt;/code&gt; 로 대체 할 수있는 경우) 해당 오브젝트를 사용하는 표현식에도 동일하게 적용됩니다 (따라서 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 은 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 로 대체 될 수 있음) ). 문제는 공분산이 일반적으로 가변 목록에 대해 안전하지 않다는 것입니다. &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 가 있고 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 으로 사용되고 있다고 가정하십시오. 이 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 에 실제로 Cat &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; Cat을 추가하려고하면 어떻게됩니까? 유형 매개 변수를 공변량으로 자동 허용하면 유형 시스템이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5d23c16bd63540ead2c74914ddab1e126bc3f6" translate="yes" xml:space="preserve">
          <source>another solution is to build a new list</source>
          <target state="translated">또 다른 해결책은 새로운 목록을 작성하는 것입니다</target>
        </trans-unit>
        <trans-unit id="6ed375dc664a800e63fb268753b8f59714929e45" translate="yes" xml:space="preserve">
          <source>consider the subtype to be it's supertype and restrict at compile the &quot;add&quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</source>
          <target state="translated">하위 유형을 상위 유형으로 간주하고 컴파일시 &quot;add&quot;메소드를 제한하십시오 (그래서 drawAll 메소드에서 원의 목록, 하위 유형의 모양이 전달되는 경우 컴파일러는이를 감지하고 컴파일 오류가 발생하도록 제한해야 함) 그).</target>
        </trans-unit>
        <trans-unit id="9a49e1031f2ed9d14b8f10116b441e35b8bd75c8" translate="yes" xml:space="preserve">
          <source>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</source>
          <target state="translated">하위 유형이 암시 적으로 수퍼 유형이라는 것을 고려하지 말고 컴파일 오류를 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="917a49b3ab1b964d351680a9d496835660c085e3" translate="yes" xml:space="preserve">
          <source>it is also true that</source>
          <target state="translated">또한 사실이다</target>
        </trans-unit>
        <trans-unit id="3109cbe3b4d36e8f4714482083b76fe25ee4a957" translate="yes" xml:space="preserve">
          <source>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</source>
          <target state="translated">소비자에게 적합한 유형의 물건을 제공하는 공급 업체 만 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="34263cba8588e8a17ab060861593d2d646e5fba6" translate="yes" xml:space="preserve">
          <source>now you can call doSomething with either List&amp;lt;Dog&amp;gt; or List&amp;lt;Cat&amp;gt; or List&amp;lt;Animal&amp;gt;.</source>
          <target state="translated">이제 List &amp;lt;Dog&amp;gt; 또는 List &amp;lt;Cat&amp;gt; 또는 List &amp;lt;Animal&amp;gt;을 사용하여 doSomething을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d331fcedf530a8517412040f7d5855e4ea193dae" translate="yes" xml:space="preserve">
          <source>sounds fine, doesn't it? But you can only pass &lt;code&gt;Consumer&lt;/code&gt;s and &lt;code&gt;Supplier&lt;/code&gt;s for &lt;code&gt;Animal&lt;/code&gt;s. If you have a &lt;code&gt;Mammal&lt;/code&gt; consumer, but a &lt;code&gt;Duck&lt;/code&gt; supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</source>
          <target state="translated">잘 들리나요? 그러나 &lt;code&gt;Animal&lt;/code&gt; 대해서는 &lt;code&gt;Consumer&lt;/code&gt; 및 &lt;code&gt;Supplier&lt;/code&gt; 만 전달할 수 있습니다. &lt;code&gt;Mammal&lt;/code&gt; 소비자이지만 &lt;code&gt;Duck&lt;/code&gt; 공급 업체 인 경우 둘 다 동물이지만 적합하지 않아야합니다. 이것을 허용하지 않기 위해 추가 제한이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0326968b7f692e04985959e0b5f6e025c50d1747" translate="yes" xml:space="preserve">
          <source>therefore you can't put the wrong subtype of &lt;code&gt;Animal&lt;/code&gt; into the list, because there is no wrong subtype -- any object of subtype &lt;code&gt;? extends Animal&lt;/code&gt; can be added to &lt;code&gt;animals&lt;/code&gt;.</source>
          <target state="translated">따라서 잘못된 하위 유형이 없기 때문에 잘못된 하위 유형의 &lt;code&gt;Animal&lt;/code&gt; 을 목록에 넣을 수 없습니다 &lt;code&gt;? extends Animal&lt;/code&gt; 확장 동물이 동물에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f38425b32961346a1ff8ec4c2f4f3802f76f7cb1" translate="yes" xml:space="preserve">
          <source>where we go the other way: we define the type of the &lt;code&gt;Supplier&lt;/code&gt; and restrict that it can be put into the &lt;code&gt;Consumer&lt;/code&gt;.</source>
          <target state="translated">우리가 다른 방향으로가는 곳 : &lt;code&gt;Supplier&lt;/code&gt; 의 유형을 정의하고 &lt;code&gt;Consumer&lt;/code&gt; 에게 공급할 수 있도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="62b6ffb0d183ccad287984bf71c0f6ef92c471a6" translate="yes" xml:space="preserve">
          <source>where, having the intuitive relations &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt;, &lt;code&gt;Cat&lt;/code&gt; etc., we could even put a &lt;code&gt;Mammal&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer, but not a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer.</source>
          <target state="translated">여기서 직관적 인 관계-&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt; , &lt;code&gt;Cat&lt;/code&gt; 등을 &lt;code&gt;Mammal&lt;/code&gt; 을 &lt;code&gt;Life&lt;/code&gt; 소비자로 넣을 수 있지만 &lt;code&gt;String&lt;/code&gt; 은 &lt;code&gt;Life&lt;/code&gt; 소비자로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8cb6da1df995798f3ac8506f94719679ef5c11c" translate="yes" xml:space="preserve">
          <source>you can then use the collections using</source>
          <target state="translated">그런 다음 컬렉션을 사용하여 사용할 수 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
