<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2745265">
    <body>
      <group id="2745265">
        <trans-unit id="90a10e20bd2c8e7f512a36f9986e6bd625a12b68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt; means their type information is fully available at runtime.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;Reifiable&lt;/a&gt;は、型情報が実行時に完全に利用可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="d492a733adb02b8320864e88f8357ed772fc394d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; subclass of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; は &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; サブクラスではあり&lt;strong&gt;ません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b38d828fcef53ec9e2076c3fa73400ff6ed0737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; isn't-a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;&lt;strong&gt;in Java&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; &lt;strong&gt;はJavaの&lt;/strong&gt; List &amp;lt;Animal&amp;gt; &lt;strong&gt;ではあり&lt;/strong&gt;ません</target>
        </trans-unit>
        <trans-unit id="63014900394aa67a0cc9fc3284de4e4252474b9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Animal&lt;/strong&gt; (Parent)</source>
          <target state="translated">&lt;strong&gt;動物&lt;/strong&gt; （親）</target>
        </trans-unit>
        <trans-unit id="e0fe91def2724cfdeae839f5686512b73124e94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays are &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;reifiable&lt;/a&gt; and covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;配列は&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html&quot;&gt;再構成可能&lt;/a&gt;で共変&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="4e328038c60dede3020d85585548cc6d876f670a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But&lt;/strong&gt;&lt;code&gt;Dog[]&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; subclass of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;しかし、&lt;/strong&gt; &lt;code&gt;Dog[]&lt;/code&gt; &lt;strong&gt;は&lt;/strong&gt; &lt;code&gt;Animal[]&lt;/code&gt; サブクラスです。</target>
        </trans-unit>
        <trans-unit id="eb3f40109f1f6807b64f388fb31fb0af45ca1e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dog&lt;/strong&gt; - &lt;strong&gt;Cat&lt;/strong&gt; (Children)</source>
          <target state="translated">&lt;strong&gt;犬&lt;/strong&gt; - &lt;strong&gt;猫&lt;/strong&gt; （子供）</target>
        </trans-unit>
        <trans-unit id="304ec5ad8646d255b82e3edf25a0ad01d2c2de03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generics are &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;erased&lt;/a&gt; and invariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;ジェネリックは&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html&quot;&gt;消去され&lt;/a&gt; 、不変&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="9cdca835127fee237411a140f68169f05cc675c3" translate="yes" xml:space="preserve">
          <source>A list of dogs is-a list of animals &lt;strong&gt;in English&lt;/strong&gt; (well, under a reasonable interpretation)</source>
          <target state="translated">犬のリストは&lt;strong&gt;英語&lt;/strong&gt;の動物のリストです（まあ、合理的な解釈の下で）</target>
        </trans-unit>
        <trans-unit id="e3f7f1c5a95fabfdae274ff4f328ee3f1b9a462f" translate="yes" xml:space="preserve">
          <source>A point I think should be added to what &lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;answers&lt;/a&gt; mention is that while</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2745301/1593077&quot;&gt;他の&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/2745319/1593077&quot;&gt;回答が&lt;/a&gt;言及していることに追加すべきだと思うポイントは、</target>
        </trans-unit>
        <trans-unit id="6d7e1bb7645e004caf223707662fb2057339d98a" translate="yes" xml:space="preserve">
          <source>Actually you can use an interface to achieve what you want.</source>
          <target state="translated">実際には、あなたが望むものを実現するためにインターフェースを使用することができます。</target>
        </trans-unit>
        <trans-unit id="344527118c80c2af2edf1e6d80bca72266b3175b" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt;, you cannot subsequently directly assign &lt;code&gt;animals&lt;/code&gt; to either &lt;code&gt;dogs&lt;/code&gt; or &lt;code&gt;cats&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Animal&amp;gt; animals = new ArrayList&amp;lt;&amp;gt;(dogs);&lt;/code&gt; 呼び出した後 、その後、 &lt;code&gt;dogs&lt;/code&gt; または &lt;code&gt;cats&lt;/code&gt; 直接 &lt;code&gt;animals&lt;/code&gt; を割り当てることはできません。</target>
        </trans-unit>
        <trans-unit id="e68eb3128cd4e3b375fed2af8ca940aea40c8999" translate="yes" xml:space="preserve">
          <source>Another argument why covariance doesn't make sense in case of generic classes is the fact that at base all classes are the same - are &lt;code&gt;List&lt;/code&gt; instances. Specialising a &lt;code&gt;List&lt;/code&gt; by filling the generic argument doesn't extend the class, it just makes it work for that particular generic argument.</source>
          <target state="translated">ジェネリッククラスの場合に共分散が意味をなさないもう1つの理由は、ベースではすべてのクラスが同じであるという事実です。つまり、 &lt;code&gt;List&lt;/code&gt; インスタンスです。 ジェネリック引数を入力して &lt;code&gt;List&lt;/code&gt; 特殊化しても、クラスは拡張されず、その特定のジェネリック引数に対して機能するだけです。</target>
        </trans-unit>
        <trans-unit id="7a959cb20c2a75f6a5e8944beb44f43926299f02" translate="yes" xml:space="preserve">
          <source>As stated by @Jon Skeet, this code is illegal, because otherwise it would violate the type constraints by returning a cat when a dog expected.</source>
          <target state="translated">Jon Skeet氏が述べているように、このコードは違法です。</target>
        </trans-unit>
        <trans-unit id="9e0ea5bc85b2c61dce27b3c8ed31b0557f59af05" translate="yes" xml:space="preserve">
          <source>Assume the following hierarchy -</source>
          <target state="translated">以下のような階層を想定してください。</target>
        </trans-unit>
        <trans-unit id="381c0989adf609934d9987de7750f37d8d6422bb" translate="yes" xml:space="preserve">
          <source>At the deepest level, the problem here is that &lt;code&gt;dogs&lt;/code&gt; and &lt;code&gt;animals&lt;/code&gt; share a reference. That means that one way to make this work would be to copy the entire list, which would break reference equality:</source>
          <target state="translated">最も深いレベルでの問題は、 &lt;code&gt;dogs&lt;/code&gt; と &lt;code&gt;animals&lt;/code&gt; が参照を共有していることです。 つまり、この作業を行う1つの方法は、リスト全体をコピーすることです。これにより、参照の等価性が失われます。</target>
        </trans-unit>
        <trans-unit id="2eda859b24b9c57e6183b93096e9b63efeaee18e" translate="yes" xml:space="preserve">
          <source>E. g.,</source>
          <target state="translated">例えば...</target>
        </trans-unit>
        <trans-unit id="204aa29f1c9a6ab4ac20c77ee47b170439787c52" translate="yes" xml:space="preserve">
          <source>For obvious reasons, that chose the first way.</source>
          <target state="translated">明らかな理由で、それが最初の方法を選んだのです。</target>
        </trans-unit>
        <trans-unit id="17d3a2e5b2ebbd18c169ee52622d864801d45a32" translate="yes" xml:space="preserve">
          <source>Further to the answer by Jon Skeet, which uses this example code:</source>
          <target state="translated">この例のコードを使用しているJon Skeetの回答にさらに進みます。</target>
        </trans-unit>
        <trans-unit id="96f1150d546de158ef07e02fb89e723cc69163ca" translate="yes" xml:space="preserve">
          <source>I understand that this is Java's behavior. My question is &lt;em&gt;why&lt;/em&gt;? Why is polymorphism generally implicit, but when it comes to generics it must be specified?</source>
          <target state="translated">これはJavaの動作であることを理解しています。 私の質問は&lt;em&gt;なぜ&lt;/em&gt;ですか？ なぜポリモーフィズムは一般的に暗黙的ですが、ジェネリックになるとそれを指定する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="fccd4d39d44d0871993dd57d00b01ed07c504c36" translate="yes" xml:space="preserve">
          <source>I would say the whole point of Generics is that it doesn't allow that. Consider the situation with arrays, which do allow that type of covariance:</source>
          <target state="translated">ジェネリックの全体的なポイントは、それを許さないということだと思います。配列の状況を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="01e70d4e3c86e0b7b2d3599eb15c5d79e5389855" translate="yes" xml:space="preserve">
          <source>I'm a bit confused about how Java generics handle inheritance / polymorphism.</source>
          <target state="translated">Javaのジェネリックが継承ポリモーフィズムをどのように扱うのか、少し戸惑っています。</target>
        </trans-unit>
        <trans-unit id="a2c736ed9244357382e64aceca74b1e587e71857" translate="yes" xml:space="preserve">
          <source>If you are sure that the list items are subclasses of that given super type you can cast the list using this approach:</source>
          <target state="translated">リストの項目が与えられたスーパー型のサブクラスであることが確かならば、このアプローチを使ってリストをキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="604f0777accde51cdb9a2e95bba2b694a31efdec" translate="yes" xml:space="preserve">
          <source>In conclusion, run-time safety is not possible for parameterized types, since compiler replaces each parameterized type by its erasure. This makes parameterized types are nothing more than syntactic sugar.</source>
          <target state="translated">結論から言うと、パラメータ化された型はコンパイラが各パラメータ化された型を消去することで置き換えてしまうため、実行時の安全性は確保できません。これにより、パラメタライズされた型は構文上の糖質に過ぎないことになります。</target>
        </trans-unit>
        <trans-unit id="c6df8c875d5596e81ece51df756bb5a6e3e44560" translate="yes" xml:space="preserve">
          <source>In most cases, we can use &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; rather then &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; and that should be the first choice.  However, I am finding cases where it is not easy to do that.  It is up for debate as to whether that is always the best thing to do.  I am presenting here a class DownCastCollection that can take convert a &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; to a &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; (we can define similar classes for List, Set, NavigableSet,..) to be used when using the standard approach is very inconvenient.  Below is an example of how to use it (we could also use &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; in this case, but I am keeping it simple to illustrate using DownCastCollection.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; を使用できます&amp;lt;？ &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; T&amp;gt;ではなくT&amp;gt;を拡張します。これが最初の選択肢です。 しかし、それが簡単ではないケースを見つけています。 それが常に最善の方法であるかどうかについては、議論の余地があります。 &lt;code&gt;Collection&amp;lt;? extends T&amp;gt;&lt;/code&gt; を変換できるDownCastCollectionクラスをここに提示します&amp;lt;？ T&amp;gt;を &lt;code&gt;Collection&amp;lt;T&amp;gt;&lt;/code&gt; 拡張します（List、Set、NavigableSetなどに同様のクラスを定義できます）。これは、標準的なアプローチを使用する場合に非常に不便です。 以下はそれを使用する方法の例です（この場合 &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; も使用できますが 、DownCastCollectionの使用を説明するために簡単にしています。</target>
        </trans-unit>
        <trans-unit id="1ffe7e463ad2cbcb1de6c5e2e33c9d5181c4568a" translate="yes" xml:space="preserve">
          <source>In the code below if generics were covariant it will be possible to make &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;heap pollution&lt;/a&gt; at line 3.</source>
          <target state="translated">以下のコードでは、ジェネリックが共変であった場合、3行目で&lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_pollution&quot;&gt;ヒープ汚染を引き起こす&lt;/a&gt;可能性があります 。</target>
        </trans-unit>
        <trans-unit id="db0d547b9a45e2cd6f0e18b37f983db0f182eec3" translate="yes" xml:space="preserve">
          <source>Instead of the above, we have to define relationships between the types we use.</source>
          <target state="translated">上記の代わりに、使用するタイプ間の関係性を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="99aa3435dd6dd09d2f123ec6780ffb6b4b0e2c9e" translate="yes" xml:space="preserve">
          <source>Invariant subtyping ensures that the type constraints enforced by Java are not violated. Consider the following code given by @Jon Skeet:</source>
          <target state="translated">不変サブタイプはJavaによって強制される型制約が違反されないことを保証します。Jon Skeetによって与えられた次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="29a4d80153ea7b51095ece74755bb5043916df2f" translate="yes" xml:space="preserve">
          <source>Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;? Why are Java generics not implicitly polymorphic</source>
          <target state="translated">リストです &lt;dog&gt; Listのサブクラス &lt;animal&gt; ？ Javaジェネリックが暗黙的にポリモーフィックではないのはなぜですか &lt;/animal&gt;&lt;/dog&gt;</target>
        </trans-unit>
        <trans-unit id="91db49b2b9e77ed757d10476e32752227a891692" translate="yes" xml:space="preserve">
          <source>It is instructive to compare the above to analogous code for arrays.</source>
          <target state="translated">上記を配列の類似コードと比較することは有益です。</target>
        </trans-unit>
        <trans-unit id="3ed717cb0f96ab9f0d80c86ad25d852eb370af29" translate="yes" xml:space="preserve">
          <source>It would be useful to add syntax to allow type parameters to be specified as covariant, which avoids the &lt;code&gt;? extends Foo&lt;/code&gt; in method declarations, but that does add additional complexity.</source>
          <target state="translated">型パラメーターを共変として指定できるように構文を追加すると、 &lt;code&gt;? extends Foo&lt;/code&gt; メソッド宣言でFooを拡張しますが、それによってさらに複雑になります。</target>
        </trans-unit>
        <trans-unit id="e1b88103aa22a4125409bcc1ce1af145750f709c" translate="yes" xml:space="preserve">
          <source>It's vice versa for generics:</source>
          <target state="translated">ジェネリックの場合はその逆です。</target>
        </trans-unit>
        <trans-unit id="6d9e846d6c182c9be543e2edb9fad821781f6e1c" translate="yes" xml:space="preserve">
          <source>Lets take the example from JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;tutorial&lt;/a&gt;</source>
          <target state="translated">JavaSE &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html&quot;&gt;チュートリアル&lt;/a&gt;の例を見てみましょう</target>
        </trans-unit>
        <trans-unit id="db49ead253373ebf491e45d83a3eaede6658b135" translate="yes" xml:space="preserve">
          <source>More generally, &lt;strong&gt;OP's intuition lends itself towards a language in which operations on objects can change their type&lt;/strong&gt;, or rather, an object's type(s) is a (dynamic) function of its value.</source>
          <target state="translated">より一般的には、 &lt;strong&gt;OPの直感は、オブジェクトに対する操作がその型を変更できる言語に向いています。つまり&lt;/strong&gt; 、オブジェクトの型は、その値の（動的）関数です。</target>
        </trans-unit>
        <trans-unit id="59becb84eaea3240c06cacb7affabdb553d2b2d4" translate="yes" xml:space="preserve">
          <source>No, a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. Consider what you can do with a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - you can add &lt;em&gt;any&lt;/em&gt; animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.</source>
          <target state="translated">いいえ、 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; は &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; はありません。 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; で何ができるかを考えてみましょう。猫も含めて、 &lt;em&gt;どんな&lt;/em&gt;動物でも追加&lt;em&gt;でき&lt;/em&gt;ます。 今、あなたは子犬のトイレに猫を論理的に追加できますか？ 絶対違う。</target>
        </trans-unit>
        <trans-unit id="169a8aa30694368f01ec9a80e5d310b4a4fa72a0" translate="yes" xml:space="preserve">
          <source>Now if java allows caller to add List of type Animal to this method then you might add wrong thing into collection and at run time too it will run due to type erasure. While in case of arrays you will get a run time exception for such scenarios...</source>
          <target state="translated">javaがこのメソッドにAnimal型のリストを追加することを呼び出し元に許可している場合、間違ったものをコレクションに追加してしまい、実行時にも型の消去が原因で実行されてしまう可能性があります。配列の場合は、このようなシナリオのために実行時に例外が発生しますが...。</target>
        </trans-unit>
        <trans-unit id="b46664ca8654b90a0e162c4b3dff03b7d478ecda" translate="yes" xml:space="preserve">
          <source>Now the class:</source>
          <target state="translated">今度はクラス。</target>
        </trans-unit>
        <trans-unit id="dc101928e56b106ed14a4a66b3e29f57d6fb1fc6" translate="yes" xml:space="preserve">
          <source>Now there are times where you need to be more flexible and that is what the &lt;code&gt;? super Class&lt;/code&gt; and &lt;code&gt;? extends Class&lt;/code&gt; are for. The former is when you need to insert into a type &lt;code&gt;Collection&lt;/code&gt; (for example), and the latter is for when you need to read from it, in a type safe manner. But the only way to do both at the same time is to have a specific type.</source>
          <target state="translated">今、あなたはより柔軟になる必要がある時があり、それは何 &lt;code&gt;? super Class&lt;/code&gt; スーパークラスと &lt;code&gt;? extends Class&lt;/code&gt; クラスを拡張します。 前者は（たとえば）型 &lt;code&gt;Collection&lt;/code&gt; に挿入する必要がある場合であり、後者は型セーフな方法でコレクションから読み取る必要がある場合です。 しかし、両方を同時に行う唯一の方法は、特定のタイプを持つことです。</target>
        </trans-unit>
        <trans-unit id="0fd32cdcc763728be3ed9548fd8cc6d813d21f84" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;can't&lt;/em&gt; add a &lt;code&gt;Cat&lt;/code&gt; to a &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; because you don't know it's a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;. You can retrieve a value and know that it will be an &lt;code&gt;Animal&lt;/code&gt;, but you can't add arbitrary animals. The reverse is true for &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; - in that case you can add an &lt;code&gt;Animal&lt;/code&gt; to it safely, but you don't know anything about what might be retrieved from it, because it could be a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">現在、 &lt;code&gt;List&amp;lt;? extends Animal&amp;gt;&lt;/code&gt; &lt;code&gt;Cat&lt;/code&gt; を追加すること&lt;em&gt;はできません&lt;/em&gt; &amp;lt;？ それが &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; あることを知らないため、 Animal&amp;gt;を拡張します。 値を取得して、それが &lt;code&gt;Animal&lt;/code&gt; になることがわかっていても、任意の動物を追加することはできません。 &lt;code&gt;List&amp;lt;? super Animal&amp;gt;&lt;/code&gt; super Animal&amp;gt; -その場合、 &lt;code&gt;Animal&lt;/code&gt; を安全に追加できますが、 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; である可能性があるため、そこから何が取得されるかについてはわかりません。</target>
        </trans-unit>
        <trans-unit id="7b8252d2eb721be021d186b1fa8f366cf90af2fe" translate="yes" xml:space="preserve">
          <source>OTOH, we could as well do</source>
          <target state="translated">OTOH、私たちは同じように行うことができます</target>
        </trans-unit>
        <trans-unit id="4f1b7d75431b202c7bc72bc61ee6387be8273957" translate="yes" xml:space="preserve">
          <source>Observe that the translated code of method bodies are identical. Compiler replaced each parameterized type by its &lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;erasure&lt;/a&gt;. This property is crucial meaning that it did not break backwards compatibility.</source>
          <target state="translated">メソッド本体の変換されたコードが同一であることを確認します。 コンパイラーは、パラメーター化された各タイプを&lt;a href=&quot;https://stackoverflow.com/questions/313584/what-is-the-concept-of-erasure-in-generics-in-java&quot;&gt;消去で&lt;/a&gt;置き換えました。 このプロパティは、下位互換性を損なうものではなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="6f4ce7da4e6b06cef1e0b7c88880e970e5b28ba6" translate="yes" xml:space="preserve">
          <source>Obviously, this changes the semantics, since the lists &lt;code&gt;animals&lt;/code&gt; and &lt;code&gt;dogs&lt;/code&gt; are no longer shared, so adding to one list does not add to the other (which is exactly what you want, to avoid the problem that a &lt;code&gt;Cat&lt;/code&gt; could be added to a list that is only supposed to contain &lt;code&gt;Dog&lt;/code&gt; objects). Also, copying the entire list can be inefficient. However, this does solve the type equivalence problem, by breaking reference equality.</source>
          <target state="translated">明らかに、これはセマンティクスを変更します。 &lt;code&gt;animals&lt;/code&gt; と &lt;code&gt;dogs&lt;/code&gt; のリストは共有されなくなったため、一方のリストに追加しても他方には追加されません（これはまさにあなたが望むものであり、 &lt;code&gt;Cat&lt;/code&gt; がリストに追加される可能性があるという問題を回避するためです）これは、 &lt;code&gt;Dog&lt;/code&gt; オブジェクトのみを含むことになっています）。 また、リスト全体をコピーすると非効率になる場合があります。 ただし、これは参照の等価性を壊すことにより、型の等価性の問題を解決します。</target>
        </trans-unit>
        <trans-unit id="5d8a48922072f2b11fdf281f658f9367702184e2" translate="yes" xml:space="preserve">
          <source>So Java &quot;architects&quot; had 2 options which address this problem:</source>
          <target state="translated">そのため、Javaの &quot;アーキテクト &quot;には、この問題に対処する2つの選択肢がありました。</target>
        </trans-unit>
        <trans-unit id="09f145bb0cec9dfa89cc809b42253f1893cd611d" translate="yes" xml:space="preserve">
          <source>So suppose I have a method &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt;. By all the rules of inheritance and polymorphism, I would assume that a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; and a &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; - and so either one could be passed to this method. Not so. If I want to achieve this behavior, I have to explicitly tell the method to accept a list of any subclass of Animal by saying &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt;.</source>
          <target state="translated">したがって、メソッド &lt;code&gt;doSomething(List&amp;lt;Animal&amp;gt; animals)&lt;/code&gt; ます。 継承とポリモーフィズムのすべてのルールにより、 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; &lt;em&gt;は&lt;/em&gt; &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; で、 &lt;code&gt;List&amp;lt;Cat&amp;gt;&lt;/code&gt; &lt;em&gt;は&lt;/em&gt; List &amp;lt;Animal&amp;gt;であると想定します。したがって、どちらか一方をこのメソッドに渡すことができます。 そうではありません。 この動作を実現したい場合は、 &lt;code&gt;doSomething(List&amp;lt;? extends Animal&amp;gt; animals)&lt;/code&gt; と言って、Animalのサブクラスのリストを受け入れるようにメソッドに明示的に指示する必要があります。</target>
        </trans-unit>
        <trans-unit id="cca9629e4bee6bd9d98e8f03a6ec1b01b5f8071f" translate="yes" xml:space="preserve">
          <source>So suppose there is a method as given below:</source>
          <target state="translated">そこで、以下のような方法があるとします。</target>
        </trans-unit>
        <trans-unit id="a199246c454ab2f91900765521747e50834f16f8" translate="yes" xml:space="preserve">
          <source>So why a list of dogs (circles) should not be considered implicitly a list of animals (shapes) is because of this situation:</source>
          <target state="translated">では、なぜ犬(円)のリストが暗黙のうちに動物(図形)のリストとみなされてはいけないのかというと、このような状況があるからです。</target>
        </trans-unit>
        <trans-unit id="6c83895af74d72b8dc8bbd8e3db07cd62efff8e4" translate="yes" xml:space="preserve">
          <source>Subtyping is &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;invariant&lt;/a&gt; for parameterized types. Even tough the class &lt;code&gt;Dog&lt;/code&gt; is a subtype of &lt;code&gt;Animal&lt;/code&gt;, the parameterized type &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;. In contrast, &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;covariant&lt;/a&gt; subtyping is used by arrays, so the array
type &lt;code&gt;Dog[]&lt;/code&gt; is a subtype of &lt;code&gt;Animal[]&lt;/code&gt;.</source>
          <target state="translated">パラメータ化された型の&lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;場合&lt;/a&gt; 、サブタイピングは不変です。 クラス &lt;code&gt;Dog&lt;/code&gt; が &lt;code&gt;Animal&lt;/code&gt; のサブタイプであるとしても、パラメータ化されたタイプ &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; は &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; サブタイプではありません。 対照的に、 &lt;a href=&quot;https://stackoverflow.com/questions/8481301/covariance-invariance-and-contravariance-explained-in-plain-english&quot;&gt;共変&lt;/a&gt;サブタイプは配列で使用されるため、配列型 &lt;code&gt;Dog[]&lt;/code&gt; は &lt;code&gt;Animal[]&lt;/code&gt; サブタイプです。</target>
        </trans-unit>
        <trans-unit id="37ff2a1d25d6a239c07acd25dde697fc50a42eb9" translate="yes" xml:space="preserve">
          <source>Suddenly you have a &lt;em&gt;very&lt;/em&gt; confused cat.</source>
          <target state="translated">突然あなたは&lt;em&gt;非常に&lt;/em&gt;混乱した猫を飼っています。</target>
        </trans-unit>
        <trans-unit id="16d127ac7c16458178ca5e456a5c49755036fe42" translate="yes" xml:space="preserve">
          <source>That code compiles fine, but throws a runtime error (&lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; in the second line). It is not typesafe. The point of Generics is to add the compile time type safety, otherwise you could just stick with a plain class without generics.</source>
          <target state="translated">そのコードは正常にコンパイルされますが、ランタイムエラーがスローされます（2行目の &lt;code&gt;java.lang.ArrayStoreException: java.lang.Boolean&lt;/code&gt; ）。 タイプセーフではありません。 Genericsのポイントは、コンパイル時の型安全性を追加することです。そうでない場合は、Genericsのないプレーンクラスをそのまま使用できます。</target>
        </trans-unit>
        <trans-unit id="584190794514e75254dea7c2060370444e691d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Generics in the Java Language&lt;/a&gt; and the &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;Section on Generics from the Java Tutorials&lt;/a&gt; have a very good, in-depth explanation as to why some things are or are not polymorphic or permitted with generics.</source>
          <target state="translated">&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;Java言語の&lt;/a&gt; &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/java/generics/index.html&quot;&gt;GenericsとJavaチュートリアルのGenericsに関するセクションに&lt;/a&gt;は、一部のものがポリモーフィックである、またはジェネリックで許可されていない理由について、非常に優れた詳細な説明があります。</target>
        </trans-unit>
        <trans-unit id="cc94e800ea480646ce6ba48ed62ffc07b3b6d12a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;answer&lt;/a&gt;  as well as other answers are correct. I am  going to add to those answers with a solution that I think will be helpful.  I think this comes up often in programming. One thing to note is that for Collections (Lists, Sets, etc.) the main issue is adding to the Collection. That is where things break down.  Even removing is OK.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2745301/4350148&quot;&gt;答え&lt;/a&gt;も他の答えも正しいです。 これらの答えに役立つと思う解決策を追加します。 これはプログラミングで頻繁に発生すると思います。 注意すべきことの1つは、コレクション（リスト、セットなど）の主な問題はコレクションへの追加です。 それは物事が壊れるところです。 取り外してもOKです。</target>
        </trans-unit>
        <trans-unit id="d4a722f5af2f92c06a2884931937c02445379d87" translate="yes" xml:space="preserve">
          <source>The answers given here didn't fully convince me. So instead, I make another example.</source>
          <target state="translated">ここで出された答えでは、私は十分に納得できませんでした。そこで、代わりに別の例を作ってみました。</target>
        </trans-unit>
        <trans-unit id="fa4065cf11262ad86892b5d6301cc8618a09d2ee" translate="yes" xml:space="preserve">
          <source>The basis logic for such behavior is that &lt;code&gt;Generics&lt;/code&gt; follow a mechanism of type erasure. So at run time you have no way if identifying the type of &lt;code&gt;collection&lt;/code&gt; unlike &lt;code&gt;arrays&lt;/code&gt; where there is no such erasure process. So coming back to your question...</source>
          <target state="translated">このような動作の基本ロジックは、 &lt;code&gt;Generics&lt;/code&gt; が型消去のメカニズムに従うことです。 そのため、実行時に、そのような消去プロセスがない &lt;code&gt;arrays&lt;/code&gt; とは異なり、 &lt;code&gt;collection&lt;/code&gt; のタイプを識別する方法はありません。 だからあなたの質問に戻って...</target>
        </trans-unit>
        <trans-unit id="9c3267d922c893a40cc754519d5648d0800218f7" translate="yes" xml:space="preserve">
          <source>The code is legal. However, throws an &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;array store exception&lt;/a&gt;.
An array carries its type at run-time this way JVM can enforce
type safety of covariant subtyping.</source>
          <target state="translated">コードは合法です。 ただし、 &lt;a href=&quot;https://stackoverflow.com/questions/12369957/dealing-with-an-arraystoreexception&quot;&gt;配列ストア例外を&lt;/a&gt;スローします 。 配列は、JVMが共変サブタイプのタイプセーフを実施できるように、実行時にそのタイプを保持します。</target>
        </trans-unit>
        <trans-unit id="ec880e5540e317191d0eda22061ad1f16aa30ff0" translate="yes" xml:space="preserve">
          <source>The problem has been well-identified. But there's a solution; make &lt;em&gt;doSomething&lt;/em&gt; generic:</source>
          <target state="translated">問題は十分に特定されています。 しかし、解決策があります。 &lt;em&gt;doSomethingを&lt;/em&gt;ジェネリックにします。</target>
        </trans-unit>
        <trans-unit id="b6440d667672409bf8fb7e0306aea73bb570933b" translate="yes" xml:space="preserve">
          <source>The reason a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, is that, for example, you can insert a &lt;code&gt;Cat&lt;/code&gt; into a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;, but not into a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;... you can use wildcards to make generics more extensible where possible; for example, reading from  a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; is the similar to reading from a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; -- but not writing.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; が &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; ではない理由は、たとえば、 &lt;code&gt;Cat&lt;/code&gt; を &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; に挿入できますが、 List &amp;lt;Dog&amp;gt;には挿入できません...ワイルドカードを使用して、ジェネリックは可能な限り拡張可能です。 たとえば、 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; からの読み取りは、 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; からの読み取りに似ていますが、書き込みは行いません。</target>
        </trans-unit>
        <trans-unit id="ba7ebd605e2db9f872e9f4dc2e8be52afa87b964" translate="yes" xml:space="preserve">
          <source>The way the OP's intuition works - which is completely valid of course - is the latter sentence. However, if we apply this intuition we get a language that is not Java-esque in its type system: Suppose our language does allow adding a cat to our list of dogs. What would that mean? It would mean that the list ceases to be a list of dogs, and remains merely a list of animals. And a list of mammals, and a list of quadrapeds.</source>
          <target state="translated">OPの直感の働き方-もちろんこれは完全に正しい-は後者の文章です。しかし、この直観を適用すると、型システムがJava風ではない言語ができあがります。私たちの言語では、犬のリストに猫を追加することができるとします。それは何を意味するでしょうか?それは、リストが犬のリストではなくなり、単なる動物のリストのままであることを意味します。哺乳類のリストと四足類のリストもあります。</target>
        </trans-unit>
        <trans-unit id="23ce7e603788be5aab21ee61b091d1a2fa64148a" translate="yes" xml:space="preserve">
          <source>Therefore arrays provide runtime type safety but not compile-time type safety.</source>
          <target state="translated">したがって、配列は実行時の型の安全性を提供しますが、コンパイル時の型の安全性は提供しません。</target>
        </trans-unit>
        <trans-unit id="c5bfdde28ebbe167fa1e050e24ae8f4ad024ab30" translate="yes" xml:space="preserve">
          <source>Therefore generics can't provide runtime type safety, but they provide compile-time type safety.</source>
          <target state="translated">したがって、ジェネリックは実行時の型の安全性を提供することはできませんが、コンパイル時の型の安全性は提供します。</target>
        </trans-unit>
        <trans-unit id="00c82895236a0a7a878e98ac644697c1418510bb" translate="yes" xml:space="preserve">
          <source>This is usefull when you want to pass the list in a constructor or iterate over it</source>
          <target state="translated">これは、コンストラクタでリストを渡したり、それを反復処理したりしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="57e00388dd7cbaf4c88629658063578936e69c09" translate="yes" xml:space="preserve">
          <source>Thus in essence this behavior is implemented so that one cannot add wrong thing into collection. Now  I believe type erasure exists so as to give compatibility with legacy java without generics....</source>
          <target state="translated">このように、本質的には、間違ったものをコレクションに追加できないように実装されています。現在、私はジェネリックを持たないレガシーなJavaとの互換性を持たせるために、型の消去が存在すると考えています。</target>
        </trans-unit>
        <trans-unit id="4786f210fd6512db64d73fcfd87384dc56d0b91a" translate="yes" xml:space="preserve">
          <source>Thus we have &lt;code&gt;ListOfAnimal&lt;/code&gt;, &lt;code&gt;ListOfDog&lt;/code&gt;, &lt;code&gt;ListOfCat&lt;/code&gt;, etc, which are distinct classes that end up being &quot;created&quot; by the compiler when we specify the generic arguments. And this is a flat hierarchy (actually regarding to &lt;code&gt;List&lt;/code&gt; is not a hierarchy at all).</source>
          <target state="translated">したがって、 &lt;code&gt;ListOfAnimal&lt;/code&gt; 、 &lt;code&gt;ListOfDog&lt;/code&gt; 、 &lt;code&gt;ListOfCat&lt;/code&gt; などがあります。これらは、一般的な引数を指定したときにコンパイラによって「作成」される最終的な別個のクラスです。 そして、これはフラットな階層です（実際、 &lt;code&gt;List&lt;/code&gt; に関しては階層ではありません）。</target>
        </trans-unit>
        <trans-unit id="7a9a72b3362404704da9568bb6fb9462dc5392cf" translate="yes" xml:space="preserve">
          <source>To put it another way: A &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; in Java does not mean &quot;a list of dogs&quot; in English, it means &quot;a list which can have dogs, and nothing else&quot;.</source>
          <target state="translated">別の言い方をすれば、Javaの &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; は、英語で「犬のリスト」を意味するのではなく、「犬を飼うことができ、他には何もないリスト」を意味します。</target>
        </trans-unit>
        <trans-unit id="48cb4ab7d62851fc151a15505099e94b0316692e" translate="yes" xml:space="preserve">
          <source>To understand the problem it's useful to make comparison to arrays.</source>
          <target state="translated">この問題を理解するためには,配列との比較をするのが便利です.</target>
        </trans-unit>
        <trans-unit id="d5a9aae8fbcc3e1f36369c98b0b7f2207dc564a1" translate="yes" xml:space="preserve">
          <source>To understand this further let's look at the bytecode generated by &lt;code&gt;javap&lt;/code&gt; of the class below:</source>
          <target state="translated">これをさらに理解するために、以下のクラスの &lt;code&gt;javap&lt;/code&gt; によって生成されたバイトコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="03dfd09db768e40e7564a1ad7500d78d1c2d2d78" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;javap -c Demonstration&lt;/code&gt;, this shows the following Java bytecode:</source>
          <target state="translated">コマンド &lt;code&gt;javap -c Demonstration&lt;/code&gt; を使用すると、次のJavaバイトコードが表示されます。</target>
        </trans-unit>
        <trans-unit id="754919ef9edabe390bb0a56957e1038bbadc51c3" translate="yes" xml:space="preserve">
          <source>We even can do</source>
          <target state="translated">私達はすることができます</target>
        </trans-unit>
        <trans-unit id="a4a8f17fd0e17a7a59d13cdf7845711a3b9c6069" translate="yes" xml:space="preserve">
          <source>We should also take in consideration how the compiler threats the generic classes: in &quot;instantiates&quot; a different type whenever we fill the generic arguments.</source>
          <target state="translated">また、コンパイラがどのようにしてジェネリック・クラスを脅かすかを考慮しなければなりません。</target>
        </trans-unit>
        <trans-unit id="53afcffe1e893d87963a71f6d157ea0408568d23" translate="yes" xml:space="preserve">
          <source>What you are looking for is called &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;covariant type&lt;/a&gt; parameters&lt;/em&gt;. This means that if one type of object can be substituted for another in a method (for instance, &lt;code&gt;Animal&lt;/code&gt; can be replaced with &lt;code&gt;Dog&lt;/code&gt;), the same applies to expressions using those objects (so &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; could be replaced with &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;). The problem is that covariance is not safe for mutable lists in general.  Suppose you have a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;, and it is being used as a &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt;.  What happens when you try to add a Cat to this &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; which is really a &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt;?  Automatically allowing type parameters to be covariant breaks the type system.</source>
          <target state="translated">探しているものは、 &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&quot;&gt;共変型&lt;/a&gt;パラメーター&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt; 。 つまり、メソッド内であるタイプのオブジェクトを別のタイプのオブジェクトに置き換えることができる場合（たとえば、 &lt;code&gt;Animal&lt;/code&gt; を &lt;code&gt;Dog&lt;/code&gt; に置き換えることができます）、同じことがそれらのオブジェクトを使用する式に適用されます（したがって、 &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; を &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; 置き換えることができます） ）。 問題は、一般に、可変リストに対して共分散が安全でないことです。 &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; があり、それが &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; として使用されているとします。 本当に &lt;code&gt;List&amp;lt;Dog&amp;gt;&lt;/code&gt; あるこの &lt;code&gt;List&amp;lt;Animal&amp;gt;&lt;/code&gt; 猫を追加しようとするとどうなりますか？ 型パラメーターを共変に自動的に許可すると、型システムが壊れます。</target>
        </trans-unit>
        <trans-unit id="8d5d23c16bd63540ead2c74914ddab1e126bc3f6" translate="yes" xml:space="preserve">
          <source>another solution is to build a new list</source>
          <target state="translated">別の解決策は、新しいリストを作成することです。</target>
        </trans-unit>
        <trans-unit id="6ed375dc664a800e63fb268753b8f59714929e45" translate="yes" xml:space="preserve">
          <source>consider the subtype to be it's supertype and restrict at compile the &quot;add&quot; method (so in the drawAll method, if a list of circles, subtype of shape, would be passed, the compiler should detected that and restrict you with compile error into doing that).</source>
          <target state="translated">サブタイプをスーパータイプとみなして、コンパイル時に &quot;add&quot; メソッドを制限します (つまり drawAll メソッドでは、もし円のリストが渡された場合、シェイプのサブタイプである円のリストが渡された場合、コンパイラはそれを検出してコンパイルエラーで制限しなければなりません)。</target>
        </trans-unit>
        <trans-unit id="9a49e1031f2ed9d14b8f10116b441e35b8bd75c8" translate="yes" xml:space="preserve">
          <source>do not consider that a subtype is implicitly it's supertype, and give a compile error, like it happens now</source>
          <target state="translated">サブタイプが暗黙的にスーパータイプであることを考慮せず、現在のようにコンパイルエラーを出してはいけません。</target>
        </trans-unit>
        <trans-unit id="917a49b3ab1b964d351680a9d496835660c085e3" translate="yes" xml:space="preserve">
          <source>it is also true that</source>
          <target state="translated">にもかかわらず</target>
        </trans-unit>
        <trans-unit id="3109cbe3b4d36e8f4714482083b76fe25ee4a957" translate="yes" xml:space="preserve">
          <source>makes sure that we can only use a supplier which provides us the right type of object for the consumer.</source>
          <target state="translated">これにより、消費者にとって正しいタイプのオブジェクトを提供してくれるサプライヤーのみを使用することができるようになります。</target>
        </trans-unit>
        <trans-unit id="34263cba8588e8a17ab060861593d2d646e5fba6" translate="yes" xml:space="preserve">
          <source>now you can call doSomething with either List&amp;lt;Dog&amp;gt; or List&amp;lt;Cat&amp;gt; or List&amp;lt;Animal&amp;gt;.</source>
          <target state="translated">これで、DoSomethingをList &amp;lt;Dog&amp;gt;、List &amp;lt;Cat&amp;gt;、またはList &amp;lt;Animal&amp;gt;のいずれかで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d331fcedf530a8517412040f7d5855e4ea193dae" translate="yes" xml:space="preserve">
          <source>sounds fine, doesn't it? But you can only pass &lt;code&gt;Consumer&lt;/code&gt;s and &lt;code&gt;Supplier&lt;/code&gt;s for &lt;code&gt;Animal&lt;/code&gt;s. If you have a &lt;code&gt;Mammal&lt;/code&gt; consumer, but a &lt;code&gt;Duck&lt;/code&gt; supplier, they should not fit although both are animals. In order to disallow this, additional restrictions have been added.</source>
          <target state="translated">いいですね。 ただし、合格できるのは &lt;code&gt;Animal&lt;/code&gt; の &lt;code&gt;Consumer&lt;/code&gt; と &lt;code&gt;Supplier&lt;/code&gt; のみです。 &lt;code&gt;Mammal&lt;/code&gt; 消費者がいるが、 &lt;code&gt;Duck&lt;/code&gt; サプライヤーの場合、どちらも動物ですが、それらは適合しないはずです。 これを禁止するために、追加の制限が追加されました。</target>
        </trans-unit>
        <trans-unit id="0326968b7f692e04985959e0b5f6e025c50d1747" translate="yes" xml:space="preserve">
          <source>therefore you can't put the wrong subtype of &lt;code&gt;Animal&lt;/code&gt; into the list, because there is no wrong subtype -- any object of subtype &lt;code&gt;? extends Animal&lt;/code&gt; can be added to &lt;code&gt;animals&lt;/code&gt;.</source>
          <target state="translated">したがって、間違ったサブタイプ（サブタイプのオブジェクト）がないため、 &lt;code&gt;Animal&lt;/code&gt; の間違ったサブタイプをリストに入れることはできません &lt;code&gt;? extends Animal&lt;/code&gt; 動物を動物に追加できます。</target>
        </trans-unit>
        <trans-unit id="f38425b32961346a1ff8ec4c2f4f3802f76f7cb1" translate="yes" xml:space="preserve">
          <source>where we go the other way: we define the type of the &lt;code&gt;Supplier&lt;/code&gt; and restrict that it can be put into the &lt;code&gt;Consumer&lt;/code&gt;.</source>
          <target state="translated">ここで、別の方向に進みます。 &lt;code&gt;Supplier&lt;/code&gt; のタイプを定義し、それを &lt;code&gt;Consumer&lt;/code&gt; 入れることができるように制限します。</target>
        </trans-unit>
        <trans-unit id="62b6ffb0d183ccad287984bf71c0f6ef92c471a6" translate="yes" xml:space="preserve">
          <source>where, having the intuitive relations &lt;code&gt;Life&lt;/code&gt; -&amp;gt; &lt;code&gt;Animal&lt;/code&gt; -&amp;gt; &lt;code&gt;Mammal&lt;/code&gt; -&amp;gt; &lt;code&gt;Dog&lt;/code&gt;, &lt;code&gt;Cat&lt;/code&gt; etc., we could even put a &lt;code&gt;Mammal&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer, but not a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Life&lt;/code&gt; consumer.</source>
          <target state="translated">ここで、直感的な関係である &lt;code&gt;Life&lt;/code&gt; - &amp;gt; &lt;code&gt;Mammal&lt;/code&gt; &amp;gt; Mammal- &amp;gt; &lt;code&gt;Dog&lt;/code&gt; 、 &lt;code&gt;Cat&lt;/code&gt; などの場合、 &lt;code&gt;Mammal&lt;/code&gt; を &lt;code&gt;Life&lt;/code&gt; コンシューマーに入れることはできますが、 &lt;code&gt;String&lt;/code&gt; をLifeコンシューマーに入れることはできません。</target>
        </trans-unit>
        <trans-unit id="e8cb6da1df995798f3ac8506f94719679ef5c11c" translate="yes" xml:space="preserve">
          <source>you can then use the collections using</source>
          <target state="translated">を使用してコレクションを使用することができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
