<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2793150">
    <body>
      <group id="2793150">
        <trans-unit id="975c1dfa1964f198cdee5775a3accdabd95ad8d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;HTTP response status&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;HTTP 응답 상태&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="959c0ca7759c5ec5d27677c7dbbad91620989326" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot;&gt;HTTP response headers&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot;&gt;HTTP 응답 헤더&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="06dde70bca8bad98c265c14d5bacb670007f5faf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17&quot;&gt;HTTP response encoding&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17&quot;&gt;HTTP 응답 인코딩&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a29f7d70acf2aff207d98c832c7e24f5bd6314f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://code.google.com/p/google-http-java-client/&quot;&gt;google-http-java-client&lt;/a&gt; is also a great open source resource.</source>
          <target state="translated">&lt;a href=&quot;https://code.google.com/p/google-http-java-client/&quot;&gt;google-http-java-client&lt;/a&gt; 도 훌륭한 오픈 소스 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="7bb771a0dc53b60f6a7a3d5cb4200691846761a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As per the Google blog&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;구글 블로그에 따르면&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c6f2fb508e9c9d2d8f115549e1079b067a899050" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;em&gt;First a disclaimer beforehand: the posted code snippets are all basic examples. You'll need to handle trivial &lt;code&gt;IOException&lt;/code&gt;s and &lt;code&gt;RuntimeException&lt;/code&gt;s like &lt;code&gt;NullPointerException&lt;/code&gt;, &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; and consorts yourself.&lt;/em&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;em&gt;먼저 고지 사항 : 게시 된 코드 스 니펫은 모두 기본 예입니다.&lt;/em&gt;&lt;/sup&gt; &lt;sup&gt;&lt;em&gt; &lt;code&gt;NullPointerException&lt;/code&gt; , &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 과 같은 사소한 &lt;code&gt;IOException&lt;/code&gt; 및 &lt;code&gt;RuntimeException&lt;/code&gt; 을 처리하고 직접 구성해야합니다.&lt;/em&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="faffc204004d62a95b1145d79275407e1dd03943" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;The &lt;code&gt;String#format()&lt;/code&gt; is just for convenience. I prefer it when I would need the String concatenation operator &lt;code&gt;+&lt;/code&gt; more than twice.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt; &lt;code&gt;String#format()&lt;/code&gt; 은 단지 편의를위한 것입니다.&lt;/sup&gt; &lt;sup&gt;String 연결 연산자 &lt;code&gt;+&lt;/code&gt; 가 두 번 이상 필요할 때 선호합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c6c5f21dfb9615bd2d9db1787c5053c94dfb1a75" translate="yes" xml:space="preserve">
          <source>Actually firing the HTTP request</source>
          <target state="translated">실제로 HTTP 요청을 발생</target>
        </trans-unit>
        <trans-unit id="41dfc929801cb239a0af069a424529289d11735a" translate="yes" xml:space="preserve">
          <source>After reading &lt;a href=&quot;http://www.rapidvaluesolutions.com/tech_blog/introduction-to-httpurlconnection-http-client-for-performing-efficient-network-operations/&quot;&gt;this article&lt;/a&gt; and some other stack over flow questions, I am convinced that &lt;code&gt;HttpURLConnection&lt;/code&gt; is going to stay for longer durations.</source>
          <target state="translated">&lt;a href=&quot;http://www.rapidvaluesolutions.com/tech_blog/introduction-to-httpurlconnection-http-client-for-performing-efficient-network-operations/&quot;&gt;이 기사&lt;/a&gt; 와 흐름 질문에 대한 다른 스택을 읽은 후 &lt;code&gt;HttpURLConnection&lt;/code&gt; 이 더 오랫동안 지속될 것이라고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="0093a63fbf369054a6f6c2506127fe2e1957efcc" translate="yes" xml:space="preserve">
          <source>Any query string should be concatenated to the URL using &lt;code&gt;?&lt;/code&gt;. The &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header may hint the server what encoding the parameters are in. If you don't send any query string, then you can leave the &lt;code&gt;Accept-Charset&lt;/code&gt; header away. If you don't need to set any headers, then you can even use the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URL.html#openStream%28%29&quot;&gt;&lt;code&gt;URL#openStream()&lt;/code&gt;&lt;/a&gt; shortcut method.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 를 사용하여 모든 쿼리 문자열을 URL에 연결해야합니다 . . &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; 헤더는 매개 변수가 어떤 인코딩인지 서버에 알려줄 수 있습니다. 쿼리 문자열을 보내지 않으면 &lt;code&gt;Accept-Charset&lt;/code&gt; 헤더를 그대로 둘 수 있습니다. 헤더를 설정할 필요가 없으면 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URL.html#openStream%28%29&quot;&gt; &lt;code&gt;URL#openStream()&lt;/code&gt; &lt;/a&gt; 바로 가기 메서드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1679d0c9ec10f0a2d281e386cdc692a5ffa7ff1" translate="yes" xml:space="preserve">
          <source>Apache HTTP client has fewer bugs on Eclair and Froyo. It is the best choice for these releases. For Gingerbread , HttpURLConnection is the best choice. Its simple API and small size makes it great fit for Android.</source>
          <target state="translated">Apache HTTP 클라이언트는 Eclair 및 Froyo에서 버그가 적습니다. 이 릴리스에 가장 적합한 선택입니다. Gingerbread의 경우 HttpURLConnection이 최선의 선택입니다. 간단한 API와 작은 크기로 Android에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d7ae51538bcb0af982c502657eba788ab086b6e5" translate="yes" xml:space="preserve">
          <source>But if the content length is really not known beforehand, then you can make use of chunked streaming mode by setting the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html#setChunkedStreamingMode%28int%29&quot;&gt;&lt;code&gt;HttpURLConnection#setChunkedStreamingMode()&lt;/code&gt;&lt;/a&gt; accordingly. This will set the HTTP &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.41&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header to &lt;code&gt;chunked&lt;/code&gt; which will force the request body being sent in chunks. The below example will send the body in chunks of 1KB.</source>
          <target state="translated">그러나 콘텐츠 길이를 미리 알 수 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html#setChunkedStreamingMode%28int%29&quot;&gt; &lt;code&gt;HttpURLConnection#setChunkedStreamingMode()&lt;/code&gt; &lt;/a&gt; 적절히 설정하여 청크 스트리밍 모드를 사용할 수 있습니다. 그러면 HTTP &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.41&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 헤더가 &lt;code&gt;chunked&lt;/code&gt; 되어 요청 본문이 청크로 전송됩니다. 아래 예제는 본문을 1KB 단위로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="6d2ad0b37ab28029e1684aee7e0a37c7de6e1d24" translate="yes" xml:space="preserve">
          <source>Check this blog post for more info: &lt;a href=&quot;http://www.yegor256.com/2014/04/11/jcabi-http-intro.html&quot;&gt;http://www.yegor256.com/2014/04/11/jcabi-http-intro.html&lt;/a&gt;</source>
          <target state="translated">자세한 내용은이 블로그 게시물을 확인하십시오. &lt;a href=&quot;http://www.yegor256.com/2014/04/11/jcabi-http-intro.html&quot;&gt;http://www.yegor256.com/2014/04/11/jcabi-http-intro.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="715a583ba8ed9a9e699e1daadc2485524b355cd6" translate="yes" xml:space="preserve">
          <source>Connection pooling reduces request latency (if HTTP/2 isn&amp;rsquo;t    available).</source>
          <target state="translated">연결 풀링은 요청 대기 시간을 줄입니다 (HTTP / 2를 사용할 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="0f2ec558caf71c2d6e4843f5910a60f78cfc0b6a" translate="yes" xml:space="preserve">
          <source>Dealing with untrusted or misconfigured HTTPS sites</source>
          <target state="translated">신뢰할 수 없거나 잘못 구성된 HTTPS 사이트 다루기</target>
        </trans-unit>
        <trans-unit id="d1d5bba5a50e2d6832ea3ffb015d9131ad4b1ac0" translate="yes" xml:space="preserve">
          <source>Either way, if the other side is a &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt;&lt;code&gt;HttpServlet&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doGet%28javax.servlet.http.HttpServletRequest,%20javax.servlet.http.HttpServletResponse%29&quot;&gt;&lt;code&gt;doGet()&lt;/code&gt;&lt;/a&gt; method will be called and the parameters will be available by &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter%28java.lang.String%29&quot;&gt;&lt;code&gt;HttpServletRequest#getParameter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어느 쪽이든, 다른 쪽이 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt; &lt;code&gt;HttpServlet&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doGet%28javax.servlet.http.HttpServletRequest,%20javax.servlet.http.HttpServletResponse%29&quot;&gt; &lt;code&gt;doGet()&lt;/code&gt; &lt;/a&gt; 메소드가 호출되고 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter%28java.lang.String%29&quot;&gt; &lt;code&gt;HttpServletRequest#getParameter()&lt;/code&gt; &lt;/a&gt; 가 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d82acf48a8ee26a9e13af783f08df134fca96580" translate="yes" xml:space="preserve">
          <source>Either way, if the other side is a &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt;&lt;code&gt;HttpServlet&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doPost%28javax.servlet.http.HttpServletRequest,%20javax.servlet.http.HttpServletResponse%29&quot;&gt;&lt;code&gt;doPost()&lt;/code&gt;&lt;/a&gt; method will be called and the parameters will be available by &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter%28java.lang.String%29&quot;&gt;&lt;code&gt;HttpServletRequest#getParameter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어느 쪽이든, 다른 쪽이 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt; &lt;code&gt;HttpServlet&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doPost%28javax.servlet.http.HttpServletRequest,%20javax.servlet.http.HttpServletResponse%29&quot;&gt; &lt;code&gt;doPost()&lt;/code&gt; &lt;/a&gt; 메소드가 호출되고 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html#getParameter%28java.lang.String%29&quot;&gt; &lt;code&gt;HttpServletRequest#getParameter()&lt;/code&gt; &lt;/a&gt; 의해 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="d4f73c040c596ee2ef346c2feda2867845e5ddb5" translate="yes" xml:space="preserve">
          <source>Example: Make a &lt;code&gt;GET&lt;/code&gt; request with content type &lt;code&gt;application/json&lt;/code&gt; and some query parameters:</source>
          <target state="translated">예 : 컨텐츠 유형 &lt;code&gt;application/json&lt;/code&gt; 및 일부 쿼리 매개 변수를 사용하여 &lt;code&gt;GET&lt;/code&gt; 요청을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="20c2a03c5ac435a4a11dac2d31ca5882fb7ce15b" translate="yes" xml:space="preserve">
          <source>Firing a &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3&quot;&gt;HTTP GET&lt;/a&gt; request with (optionally) query parameters</source>
          <target state="translated">(선택적) 쿼리 매개 변수를 사용하여 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3&quot;&gt;HTTP GET&lt;/a&gt; 요청 실행</target>
        </trans-unit>
        <trans-unit id="c66097016b3656bf9d5b2e58a50bfe9eb70e6bbf" translate="yes" xml:space="preserve">
          <source>Firing a &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;HTTP POST&lt;/a&gt; request with query parameters</source>
          <target state="translated">쿼리 매개 변수를 사용하여 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5&quot;&gt;HTTP POST&lt;/a&gt; 요청 실행</target>
        </trans-unit>
        <trans-unit id="5e8743edda175aa9df642433b4adaf41b0f867c8" translate="yes" xml:space="preserve">
          <source>First create an instance of &lt;code&gt;OkHttpClient&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;OkHttpClient&lt;/code&gt; 의 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="484908c53bf9b31b41b975d800ab29e3e8b07c1e" translate="yes" xml:space="preserve">
          <source>For more details, you can consult the &lt;a href=&quot;https://github.com/square/okhttp/wiki&quot;&gt;OkHttp's documentation&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/square/okhttp/wiki&quot;&gt;OkHttp의 설명서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="95aa55aa128a538aef0e3d44f2fde5d92c35cb54" translate="yes" xml:space="preserve">
          <source>For testing purposes, you can print the response body to stdout as below:</source>
          <target state="translated">테스트 목적으로 다음과 같이 응답 본문을 stdout에 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca46205e8825792a4703acde2ede24c2ebbb9b0" translate="yes" xml:space="preserve">
          <source>GET Request :-</source>
          <target state="translated">GET 요청 :-</target>
        </trans-unit>
        <trans-unit id="d3da28340f4864ceb4e03ee9789afb84d3657963" translate="yes" xml:space="preserve">
          <source>Gathering HTTP response information</source>
          <target state="translated">HTTP 응답 정보 수집</target>
        </trans-unit>
        <trans-unit id="1a6ef5a231303e8d156a517755985d8b184b5ca1" translate="yes" xml:space="preserve">
          <source>HTTP/2 support allows all requests to the same host to share a    socket.</source>
          <target state="translated">HTTP / 2 지원을 통해 동일한 호스트에 대한 모든 요청이 소켓을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26dc21c71d74cc902d915f5bf05dc5f4003564f9" translate="yes" xml:space="preserve">
          <source>Here are the tests:</source>
          <target state="translated">테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16d08d753650b0ae59643aeff835de3ea4f983ff" translate="yes" xml:space="preserve">
          <source>How to scan and extract a webpage in Java</source>
          <target state="translated">Java에서 웹 페이지를 스캔하고 추출하는 방법</target>
        </trans-unit>
        <trans-unit id="0bd47d93542a429e2f48a4fd94cfd7a8d5760d49" translate="yes" xml:space="preserve">
          <source>How to use java.net.URLConnection to fire and handle HTTP requests</source>
          <target state="translated">java.net.URLConnection을 사용하여 HTTP 요청을 발생시키고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="f33c6f8de770923d4335c65fe486deab78578a7f" translate="yes" xml:space="preserve">
          <source>HttpClient Examples</source>
          <target state="translated">HttpClient 예</target>
        </trans-unit>
        <trans-unit id="5568e7a06f498b248b080a22d596f54278634830" translate="yes" xml:space="preserve">
          <source>HttpClient Tutorial</source>
          <target state="translated">HttpClient 튜토리얼</target>
        </trans-unit>
        <trans-unit id="f5d64373417aceeb3c2bf0b468050984a0519159" translate="yes" xml:space="preserve">
          <source>HttpPost works in Java project, not in Android</source>
          <target state="translated">HttpPost는 Android가 아닌 Java 프로젝트에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3acccf44ba8aabdc4320ed9260e592d634a56e6c" translate="yes" xml:space="preserve">
          <source>I am often on projects where I need to do some HTTP, and I may not want to bring in a lot of 3rd party dependencies (which bring in others and so on and so on, etc.)</source>
          <target state="translated">나는 종종 일부 HTTP를 해야하는 프로젝트를 수행하고 있으며 많은 타사 종속성 (다른 것들 등을 가져 오는 등)을 가져오고 싶지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb118c28cf4b6dc08ee3b8f7b926076c1c7c84bd" translate="yes" xml:space="preserve">
          <source>I started to write my own utilities based on some of this conversation (not any where done):</source>
          <target state="translated">나는이 대화 중 일부를 기반으로 내 유틸리티를 작성하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="06b28cd77c5289f84671a130b69c53019f3c3f73" translate="yes" xml:space="preserve">
          <source>I suggest you take a look at the code on &lt;a href=&quot;https://github.com/kevinsawicki/http-request&quot;&gt;kevinsawicki/http-request&lt;/a&gt;, its basically a wrapper on top of &lt;code&gt;HttpUrlConnection&lt;/code&gt; it provides a much simpler API in case you just want to make the requests right now or you can take a look at the sources (it's not too big) to take a look at how connections are handled.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kevinsawicki/http-request&quot;&gt;kevinsawicki / http-request&lt;/a&gt; 의 코드를 살펴보십시오. 기본적으로 &lt;code&gt;HttpUrlConnection&lt;/code&gt; 상단의 래퍼는 요청을 원하거나 소스를 볼 수있는 경우 훨씬 간단한 API를 제공합니다. (너무 크지는 않습니다) 연결 처리 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="4411a3292bd52134010ba46240027edc99d4f15e" translate="yes" xml:space="preserve">
          <source>I was also very inspired by this response.</source>
          <target state="translated">나는 또한이 반응에 매우 고무되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ced244470b722113d64de223a0c1d89d2604c74" translate="yes" xml:space="preserve">
          <source>If all you want is parsing and extracting data from HTML, then better use a HTML parser like &lt;a href=&quot;http://jsoup.org&quot;&gt;Jsoup&lt;/a&gt;</source>
          <target state="translated">HTML에서 데이터를 파싱하고 추출하는 &lt;a href=&quot;http://jsoup.org&quot;&gt;것만으로 Jsoup&lt;/a&gt; 과 같은 HTML 파서를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b9d8807c291a3e658b46eccadc3cb3a6935f830" translate="yes" xml:space="preserve">
          <source>If the HTTP response code is -1, then something went wrong with connection and response handling. The &lt;code&gt;HttpURLConnection&lt;/code&gt; implementation is in older JREs somewhat buggy with keeping connections alive. You may want to turn it off by setting the &lt;code&gt;http.keepAlive&lt;/code&gt; system property to &lt;code&gt;false&lt;/code&gt;. You can do this programmatically in the beginning of your application by:</source>
          <target state="translated">HTTP 응답 코드가 -1이면 연결 및 응답 처리에 문제가 있습니다. &lt;code&gt;HttpURLConnection&lt;/code&gt; 구현은 이전 JRE에서 연결을 유지하는 데 다소 버그가 있습니다. &lt;code&gt;http.keepAlive&lt;/code&gt; 시스템 특성을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 해제 할 수 있습니다. 응용 프로그램을 시작할 때 다음과 같이 프로그래밍 방식으로이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f56e1911235fc91247cb91409f358c21c58abb8" translate="yes" xml:space="preserve">
          <source>If the HTTP response code is &lt;code&gt;4nn&lt;/code&gt; (Client Error) or &lt;code&gt;5nn&lt;/code&gt; (Server Error), then you may want to read the &lt;code&gt;HttpURLConnection#getErrorStream()&lt;/code&gt; to see if the server has sent any useful error information.</source>
          <target state="translated">HTTP 응답 코드가 &lt;code&gt;4nn&lt;/code&gt; (클라이언트 오류) 또는 &lt;code&gt;5nn&lt;/code&gt; (서버 오류) 인 경우 &lt;code&gt;HttpURLConnection#getErrorStream()&lt;/code&gt; 을 읽고 서버가 유용한 오류 정보를 보냈는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6bceabcdbfaeb1f57777f519294641221be252e" translate="yes" xml:space="preserve">
          <source>If the other side is a &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt;&lt;code&gt;HttpServlet&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doPost%28javax.servlet.http.HttpServletRequest,%20javax.servlet.http.HttpServletResponse%29&quot;&gt;&lt;code&gt;doPost()&lt;/code&gt;&lt;/a&gt; method will be called and the parts will be available by &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#getPart%28java.lang.String%29&quot;&gt;&lt;code&gt;HttpServletRequest#getPart()&lt;/code&gt;&lt;/a&gt; (note, thus &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;getParameter()&lt;/code&gt; and so on!). The &lt;code&gt;getPart()&lt;/code&gt; method is however relatively new, it's introduced in Servlet 3.0 (Glassfish 3, Tomcat 7, etc). Prior to Servlet 3.0, your best choice is using &lt;a href=&quot;http://commons.apache.org/fileupload&quot;&gt;Apache Commons FileUpload&lt;/a&gt; to parse a &lt;code&gt;multipart/form-data&lt;/code&gt; request. Also see &lt;a href=&quot;https://stackoverflow.com/questions/2422468/upload-big-file-to-servlet/2424824#2424824&quot;&gt;this answer&lt;/a&gt; for examples of both the FileUpload and the Servelt 3.0 approaches.</source>
          <target state="translated">다른 쪽이 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html&quot;&gt; &lt;code&gt;HttpServlet&lt;/code&gt; &lt;/a&gt; 인 경우 해당 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doPost%28javax.servlet.http.HttpServletRequest,%20javax.servlet.http.HttpServletResponse%29&quot;&gt; &lt;code&gt;doPost()&lt;/code&gt; &lt;/a&gt; 메소드가 호출되고 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#getPart%28java.lang.String%29&quot;&gt; &lt;code&gt;HttpServletRequest#getPart()&lt;/code&gt; &lt;/a&gt; 에서 파트를 사용할 수 있습니다 (따라서 &lt;code&gt;getParameter()&lt;/code&gt; 등이 &lt;strong&gt;아닙니다&lt;/strong&gt; !). 그러나 &lt;code&gt;getPart()&lt;/code&gt; 메소드는 비교적 새롭지 만 Servlet 3.0 (Glassfish 3, Tomcat 7 등)에 도입되었습니다. Servlet 3.0 이전에는 &lt;a href=&quot;http://commons.apache.org/fileupload&quot;&gt;Apache Commons FileUpload&lt;/a&gt; 를 사용하여 &lt;code&gt;multipart/form-data&lt;/code&gt; 요청을 구문 분석하는 것이 가장 좋습니다. FileUpload 및 Servelt 3.0 접근 방식의 예제 &lt;a href=&quot;https://stackoverflow.com/questions/2422468/upload-big-file-to-servlet/2424824#2424824&quot;&gt;도이 답변&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc63ce8074cd9ee38db3a4c5da77e39f7315bbd1" translate="yes" xml:space="preserve">
          <source>In Java 9, you can send a &lt;code&gt;GET&lt;/code&gt; request like:</source>
          <target state="translated">Java 9에서는 다음과 같은 &lt;code&gt;GET&lt;/code&gt; 요청을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b9f56c595438dc01a98819e4a2259644c6fb8d8" translate="yes" xml:space="preserve">
          <source>Initially I was misled by this &lt;a href=&quot;http://www.innovation.ch/java/HTTPClient/urlcon_vs_httpclient.html&quot;&gt;article&lt;/a&gt; which favours &lt;code&gt;HttpClient&lt;/code&gt;.</source>
          <target state="translated">처음에는 &lt;code&gt;HttpClient&lt;/code&gt; 를 선호하는이 &lt;a href=&quot;http://www.innovation.ch/java/HTTPClient/urlcon_vs_httpclient.html&quot;&gt;기사&lt;/a&gt; 로 잘못 인도되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d0bdb74262e8fbdaeeee9a5beab20dd176f26f9" translate="yes" xml:space="preserve">
          <source>Inspired by this and other questions on SO, I've created a minimal open source &lt;a href=&quot;http://code.google.com/p/basic-http-client/&quot;&gt;basic-http-client&lt;/a&gt; that embodies most of the techniques found here.</source>
          <target state="translated">SO에 대한이 질문과 다른 질문에서 영감을 얻어 여기에있는 대부분의 기술을 구현하는 최소한의 오픈 소스 &lt;a href=&quot;http://code.google.com/p/basic-http-client/&quot;&gt;기본 http 클라이언트&lt;/a&gt; 를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="63348a7dd0403434e8796bd29c3bb292d8dca732" translate="yes" xml:space="preserve">
          <source>It also provides useful HTTP constants so you can do:</source>
          <target state="translated">또한 유용한 HTTP 상수를 제공하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68567e9ae72ba700b72a34d34be82619ceee811b" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;a href=&quot;https://stackoverflow.com/questions/13670692/403-forbidden-with-java-but-not-web-browser&quot;&gt;a request returns an unexpected response, while it works fine with a real web browser&lt;/a&gt;. The server side is probably blocking requests based on the &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; request header. The &lt;code&gt;URLConnection&lt;/code&gt; will by default set it to &lt;code&gt;Java/1.6.0_19&lt;/code&gt; where the last part is obviously the JRE version. You can override this as follows:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/13670692/403-forbidden-with-java-but-not-web-browser&quot;&gt;요청이 예상치 못한 응답을 반환하는 반면 실제 웹 브라우저에서는 제대로 작동&lt;/a&gt; 할 수 있습니다. 서버 측이 아마도 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 요청 헤더를 기반으로 요청을 차단하고있을 것입니다. &lt;code&gt;URLConnection&lt;/code&gt; 은 기본적으로 &lt;code&gt;Java/1.6.0_19&lt;/code&gt; 로 설정되며 마지막 부분은 분명히 JRE 버전입니다. 다음과 같이이를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7422dbecf8099581403ca09f764e54cea391a0df" translate="yes" xml:space="preserve">
          <source>It's a trivial task. It's the default request method.</source>
          <target state="translated">사소한 일입니다. 기본 요청 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aa27b9815cfca97bc09894174bbc5029fa7ea762" translate="yes" xml:space="preserve">
          <source>Last words</source>
          <target state="translated">마지막 말</target>
        </trans-unit>
        <trans-unit id="9482fa56963f83fb2550b37ce827755da42ac272" translate="yes" xml:space="preserve">
          <source>Later I have been realized that &lt;code&gt;HttpURLConnection&lt;/code&gt; is going to stay from this &lt;a href=&quot;https://github.com/loopj/android-async-http/issues/75&quot;&gt;article&lt;/a&gt;</source>
          <target state="translated">나중에 나는이 &lt;a href=&quot;https://github.com/loopj/android-async-http/issues/75&quot;&gt;기사&lt;/a&gt; 에서 &lt;code&gt;HttpURLConnection&lt;/code&gt; 이 유지 될 것이라는 것을 깨달았습니다.</target>
        </trans-unit>
        <trans-unit id="bb8a41bac9558e1f20f19026a44cc55f106eb134" translate="yes" xml:space="preserve">
          <source>Maintaining the session</source>
          <target state="translated">세션 유지</target>
        </trans-unit>
        <trans-unit id="da8e68f12e7b5f0bfa225bc13ad362cf6b07b353" translate="yes" xml:space="preserve">
          <source>My goal is to provide the common things one would want to do in a bit more easier way then....</source>
          <target state="translated">내 목표는 좀 더 쉬운 방법으로하고 싶었던 일반적인 일을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1538eec6fdcc6ff63b8022296437fb4d2d4985cf" translate="yes" xml:space="preserve">
          <source>Note that this is known to not always work properly in all circumstances. If it fails for you, then best is to manually gather and set the cookie headers. You basically need to grab all &lt;code&gt;Set-Cookie&lt;/code&gt; headers from the response of the login or the first &lt;code&gt;GET&lt;/code&gt; request and then pass this through the subsequent requests.</source>
          <target state="translated">모든 상황에서 항상 제대로 작동하는 것은 아닙니다. 실패하면 쿠키 헤더를 수동으로 수집하고 설정하는 것이 가장 좋습니다. 기본적으로 로그인 또는 첫 번째 &lt;code&gt;GET&lt;/code&gt; 요청의 응답에서 모든 &lt;code&gt;Set-Cookie&lt;/code&gt; 헤더를 가져 와서 후속 요청을 통해 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dd9e192a0a1aa8909d21dd69949fca0329a96f3" translate="yes" xml:space="preserve">
          <source>Note: whenever you'd like to submit a HTML form programmatically, don't forget to take the &lt;code&gt;name=value&lt;/code&gt; pairs of any &lt;code&gt;&amp;lt;input type=&quot;hidden&quot;&amp;gt;&lt;/code&gt; elements into the query string and of course also the &lt;code&gt;name=value&lt;/code&gt; pair of the &lt;code&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&lt;/code&gt; element which you'd like to &quot;press&quot; programmatically (because that's usually been used in the server side to distinguish if a button was pressed and if so, which one).</source>
          <target state="translated">참고 : 프로그래밍 방식으로 HTML 양식을 제출할 때마다 &lt;code&gt;&amp;lt;input type=&quot;hidden&quot;&amp;gt;&lt;/code&gt; 요소의 &lt;code&gt;name=value&lt;/code&gt; 쌍을 쿼리 문자열에, 물론 &lt;code&gt;name=value&lt;/code&gt; 쌍을 가져가는 것을 잊지 마십시오. 프로그래밍 방식으로 &quot;누르고 싶은 &lt;code&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&lt;/code&gt; 요소 (일반적으로 서버 쪽에서 사용되어 단추를 눌렀는지 여부와 구분하는 데 사용되므로)</target>
        </trans-unit>
        <trans-unit id="33e9c50f69645e2cb6800b408f672ab0e3ee8286" translate="yes" xml:space="preserve">
          <source>On Android, make a POST request with URL Encoded Form data without using UrlEncodedFormEntity</source>
          <target state="translated">Android에서는 UrlEncodedFormEntity를 사용하지 않고 URL 인코딩 양식 데이터로 POST 요청을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="66ea277c2e0f622ddc5e7f9be44916709f6947f9" translate="yes" xml:space="preserve">
          <source>POST request :-</source>
          <target state="translated">POST 요청 :-</target>
        </trans-unit>
        <trans-unit id="3a64b90400294ec18f7feb8be0ec91aa41fba703" translate="yes" xml:space="preserve">
          <source>Parsing and extracting HTML</source>
          <target state="translated">HTML 파싱 및 추출</target>
        </trans-unit>
        <trans-unit id="96a9b7cdbe400c8b44756e76d158b85eb3370995" translate="yes" xml:space="preserve">
          <source>Preparing</source>
          <target state="translated">Preparing</target>
        </trans-unit>
        <trans-unit id="d9c61ae1dac7b9b68033b21358596746a90f4da4" translate="yes" xml:space="preserve">
          <source>Response caching avoids the network completely for repeat requests.</source>
          <target state="translated">응답 캐싱은 반복 요청에 대해 네트워크를 완전히 피합니다.</target>
        </trans-unit>
        <trans-unit id="8d4714f0c2528ca573fdfe05836a0ec828331d9b" translate="yes" xml:space="preserve">
          <source>Setting the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#setDoOutput%28boolean%29&quot;&gt;&lt;code&gt;URLConnection#setDoOutput()&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt; implicitly sets the request method to POST. The standard HTTP POST as web forms do is of type &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; wherein the query string is written to the request body.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#setDoOutput%28boolean%29&quot;&gt; &lt;code&gt;URLConnection#setDoOutput()&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 요청 메소드가 POST로 암시 적으로 설정됩니다. 웹 양식과 같은 표준 HTTP POST는 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 유형이며 쿼리 문자열은 요청 본문에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2626c2503b3d15b582a07bc74c5825b420a8e0ef" translate="yes" xml:space="preserve">
          <source>Since this new HTTP Client is in &lt;del&gt;&lt;code&gt;java.httpclient&lt;/code&gt;&lt;/del&gt;&lt;code&gt;jdk.incubator.httpclient&lt;/code&gt; module, you should declare this dependency in your &lt;code&gt;module-info.java&lt;/code&gt; file:</source>
          <target state="translated">이 새로운 HTTP 클라이언트는 &lt;del&gt; &lt;code&gt;java.httpclient&lt;/code&gt; &lt;/del&gt; &lt;code&gt;jdk.incubator.httpclient&lt;/code&gt; 모듈의 경우이 종속성을 &lt;code&gt;module-info.java&lt;/code&gt; 파일에 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="eac37fdc85282efe9d742d0cf3fe2a9370431885" translate="yes" xml:space="preserve">
          <source>So, how can I use &lt;code&gt;java.net.URLConnection&lt;/code&gt; to fire and handle &quot;advanced&quot; HTTP requests?</source>
          <target state="translated">어떻게 &lt;code&gt;java.net.URLConnection&lt;/code&gt; 을 사용하여 &quot;고급&quot;HTTP 요청을 시작하고 처리 할 수 ​​있습니까?</target>
        </trans-unit>
        <trans-unit id="9c2307597199d20f80fc7127a5f756094a1b21e0" translate="yes" xml:space="preserve">
          <source>Some of the SE questions favouring &lt;code&gt;HttpURLConnections&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;HttpURLConnections&lt;/code&gt; 를 선호하는 일부 SE 질문 :</target>
        </trans-unit>
        <trans-unit id="74aa71cdefcf3d3944750fb2d4856be051288828" translate="yes" xml:space="preserve">
          <source>Sometimes you need to connect a HTTPS URL, perhaps because you're writing a web scraper. In that case, you may likely face a &lt;code&gt;javax.net.ssl.SSLException: Not trusted server certificate&lt;/code&gt; on some HTTPS sites who doesn't keep their SSL certificates up to date, or a &lt;code&gt;java.security.cert.CertificateException: No subject alternative DNS name matching [hostname] found&lt;/code&gt; or &lt;code&gt;javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name&lt;/code&gt; on some misconfigured HTTPS sites.</source>
          <target state="translated">때로는 웹 스크레이퍼를 작성 중이기 때문에 HTTPS URL을 연결해야합니다. 이 경우 &lt;code&gt;javax.net.ssl.SSLException: Not trusted server certificate&lt;/code&gt; SSL 인증서를 최신 상태로 유지하지 않는 일부 HTTPS 사이트에서 신뢰할 수없는 서버 인증서 또는 &lt;code&gt;java.security.cert.CertificateException: No subject alternative DNS name matching [hostname] found&lt;/code&gt; 또는 &lt;code&gt;javax.net.ssl.SSLProtocolException: handshake alert: unrecognized_name&lt;/code&gt; 잘못 구성된 일부 HTTPS 사이트에서 unrecognized_name .</target>
        </trans-unit>
        <trans-unit id="b27bcabf080f8ed6fa7ee8f52c2c82970d5340a0" translate="yes" xml:space="preserve">
          <source>Streaming mode</source>
          <target state="translated">스트리밍 모드</target>
        </trans-unit>
        <trans-unit id="8247866800def1dff68716c91b51f90e9ed20fca" translate="yes" xml:space="preserve">
          <source>That tutorial basically only shows how to fire a GET request and read the response. It doesn't explain anywhere how to use it to among others perform a POST request, set request headers, read response headers, deal with cookies, submit a HTML form, upload a file, etc.</source>
          <target state="translated">이 튜토리얼은 기본적으로 GET 요청을 시작하고 응답을 읽는 방법 만 보여줍니다. POST 요청 수행, 요청 헤더 설정, 응답 헤더 읽기, 쿠키 처리, HTML 양식 제출, 파일 업로드 등을 사용하는 방법을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cefd11bcfad9b171d1b4e11e71e101f163a41e7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&quot;&gt;&lt;code&gt;HttpURLConnection&lt;/code&gt;&lt;/a&gt; will by default buffer the &lt;em&gt;entire&lt;/em&gt; request body before actually sending it, regardless of whether you've set a fixed content length yourself using &lt;code&gt;connection.setRequestProperty(&quot;Content-Length&quot;, contentLength);&lt;/code&gt;. This may cause &lt;code&gt;OutOfMemoryException&lt;/code&gt;s whenever you concurrently send large POST requests (e.g. uploading files). To avoid this, you would like to set the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html#setFixedLengthStreamingMode%28int%29&quot;&gt;&lt;code&gt;HttpURLConnection#setFixedLengthStreamingMode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&quot;&gt; &lt;code&gt;HttpURLConnection&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;connection.setRequestProperty(&quot;Content-Length&quot;, contentLength);&lt;/code&gt; 사용하여 고정 컨텐츠 길이를 직접 설정했는지 여부에 관계없이 실제로 보내기 전에 &lt;em&gt;전체&lt;/em&gt; 요청 본문을 버퍼링합니다 . . 큰 POST 요청을 동시에 보낼 때마다 (예 : 파일 업로드) &lt;code&gt;OutOfMemoryException&lt;/code&gt; 이 발생할 수 있습니다. 이를 피하기 위해 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html#setFixedLengthStreamingMode%28int%29&quot;&gt; &lt;code&gt;HttpURLConnection#setFixedLengthStreamingMode()&lt;/code&gt; &lt;/a&gt; 를 설정 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="7e29caf68eea1b63be43dd13fa30735f76e01d2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://hc.apache.org/httpcomponents-client-ga/&quot;&gt;Apache HttpComponents HttpClient&lt;/a&gt; is &lt;em&gt;much&lt;/em&gt; more convenient in this all :)</source>
          <target state="translated">&lt;a href=&quot;http://hc.apache.org/httpcomponents-client-ga/&quot;&gt;Apache HttpComponents HttpClient&lt;/a&gt; 는이 모든 &lt;em&gt;것&lt;/em&gt; 보다 &lt;em&gt;훨씬&lt;/em&gt; 편리합니다. :)</target>
        </trans-unit>
        <trans-unit id="b773487ec94a1a49efe84dbbc95359e07580fd5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split(&quot;;&quot;, 2)[0]&lt;/code&gt; is there to get rid of cookie attributes which are irrelevant for the server side like &lt;code&gt;expires&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, etc. Alternatively, you could also use &lt;code&gt;cookie.substring(0, cookie.indexOf(';'))&lt;/code&gt; instead of &lt;code&gt;split()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;split(&quot;;&quot;, 2)[0]&lt;/code&gt; 은 &lt;code&gt;expires&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; 등과 같이 서버 측과 관련이없는 쿠키 속성을 제거하기 위해 존재합니다. 또는 &lt;code&gt;cookie.substring(0, cookie.indexOf(';'))&lt;/code&gt; &lt;code&gt;split()&lt;/code&gt; 대신 ';') ) .</target>
        </trans-unit>
        <trans-unit id="53c03c0af7e46068b3bed62c81234c6aa842ef87" translate="yes" xml:space="preserve">
          <source>The following one-time-run &lt;code&gt;static&lt;/code&gt; initializer in your web scraper class should make &lt;code&gt;HttpsURLConnection&lt;/code&gt; more lenient as to those HTTPS sites and thus not throw those exceptions anymore.</source>
          <target state="translated">웹 스크래퍼 클래스에서 다음 한 번 실행되는 &lt;code&gt;static&lt;/code&gt; 초기화 프로그램은 &lt;code&gt;HttpsURLConnection&lt;/code&gt; 을 해당 HTTPS 사이트에 대해 더 관대하게 만들어 더 이상 예외를 발생시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a8580cefe60c53a1639b9d7b31e8136d8b2c52da" translate="yes" xml:space="preserve">
          <source>The new HTTP Client shipped with Java 9 but as part of an
  Incubator module named &lt;code&gt;jdk.incubator.httpclient&lt;/code&gt;. Incubator modules are
  a means of putting non-final APIs in the hands of developers while the
  APIs progress towards either finalization or removal in a future
  release.</source>
          <target state="translated">새로운 HTTP 클라이언트는 Java 9와 함께 제공되었지만 이름이 &lt;code&gt;jdk.incubator.httpclient&lt;/code&gt; 인큐베이터 모듈의 일부입니다. 인큐베이터 모듈은 최종 버전이 아닌 API를 개발자가 사용하는 한편 API는 향후 릴리스에서 마무리 또는 제거를 진행하는 수단입니다.</target>
        </trans-unit>
        <trans-unit id="0e41c56b017b73a4ec6d6bff1ce7acb78f13661d" translate="yes" xml:space="preserve">
          <source>The query parameters must be in &lt;code&gt;name=value&lt;/code&gt; format and be concatenated by &lt;code&gt;&amp;amp;&lt;/code&gt;. You would normally also &lt;a href=&quot;http://en.wikipedia.org/wiki/Percent-encoding&quot;&gt;URL-encode&lt;/a&gt; the query parameters with the specified charset using &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html#encode-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;URLEncoder#encode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쿼리 매개 변수는 &lt;code&gt;name=value&lt;/code&gt; 형식이어야하며 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 연결해야합니다. 일반적으로 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html#encode-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;URLEncoder#encode()&lt;/code&gt; &lt;/a&gt; 사용하여 지정된 문자 집합으로 쿼리 매개 변수를 &lt;a href=&quot;http://en.wikipedia.org/wiki/Percent-encoding&quot;&gt;URL 인코딩&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8593666940bc826ea99d8e0623a03e349931ad4d" translate="yes" xml:space="preserve">
          <source>The server side session is usually backed by a cookie. Some web forms require that you're logged in and/or are tracked by a session. You can use the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookieHandler.html&quot;&gt;&lt;code&gt;CookieHandler&lt;/code&gt;&lt;/a&gt; API to maintain cookies. You need to prepare a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookieManager.html&quot;&gt;&lt;code&gt;CookieManager&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookiePolicy.html&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookiePolicy.html#ACCEPT_ALL&quot;&gt;&lt;code&gt;ACCEPT_ALL&lt;/code&gt;&lt;/a&gt; before sending all HTTP requests.</source>
          <target state="translated">서버 측 세션은 일반적으로 쿠키에 의해 지원됩니다. 일부 웹 양식에서는 로그인 및 / 또는 세션에 의해 추적되어야합니다. &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookieHandler.html&quot;&gt; &lt;code&gt;CookieHandler&lt;/code&gt; &lt;/a&gt; API를 사용하여 쿠키를 유지 보수 할 수 있습니다. 모든 HTTP 요청을 보내기 전에 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookiePolicy.html#ACCEPT_ALL&quot;&gt; &lt;code&gt;ACCEPT_ALL&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookiePolicy.html&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/CookieManager.html&quot;&gt; &lt;code&gt;CookieManager&lt;/code&gt; &lt;/a&gt; 를 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d2645fc13885a4bae4ff65a48aa42f4cff6871a" translate="yes" xml:space="preserve">
          <source>Then post...</source>
          <target state="translated">그런 다음 게시하십시오 ...</target>
        </trans-unit>
        <trans-unit id="63dea9f748778fbab277521acf4d87c44eca39e6" translate="yes" xml:space="preserve">
          <source>Then there are just a bunch or static methods.</source>
          <target state="translated">그런 다음 묶음 또는 정적 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b27e91226948151af4e8360e03ba1054d95d256" translate="yes" xml:space="preserve">
          <source>Then you can examine the returned &lt;code&gt;HttpResponse&lt;/code&gt;:</source>
          <target state="translated">그런 다음 반환 된 &lt;code&gt;HttpResponse&lt;/code&gt; 를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f22159db8ad1aa13539ff3f81b9231b779218bc" translate="yes" xml:space="preserve">
          <source>Then you can instead of relying on &lt;code&gt;URLConnection#setDoOutput(true)&lt;/code&gt; to implicitly set the request method to &lt;em&gt;POST&lt;/em&gt; instead do &lt;code&gt;httpURLConnection.setRequestMethod(&quot;POST&quot;)&lt;/code&gt; which some might find more natural (and which also allows you to specify other request methods such as &lt;em&gt;PUT&lt;/em&gt;, &lt;em&gt;DELETE&lt;/em&gt;, ...).</source>
          <target state="translated">그런 다음 &lt;code&gt;URLConnection#setDoOutput(true)&lt;/code&gt; 을 사용하여 요청 메소드를 &lt;em&gt;POST&lt;/em&gt; 로 암시 적으로 설정하는 대신 &lt;code&gt;httpURLConnection.setRequestMethod(&quot;POST&quot;)&lt;/code&gt; 를 수행하여 더 자연스러운 것을 발견 할 수 있습니다. &lt;em&gt;PUT&lt;/em&gt; , &lt;em&gt;DELETE&lt;/em&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="0f6b1584a9e926b76a69d10eeae1623dbc4482f0" translate="yes" xml:space="preserve">
          <source>Then, prepare your &lt;code&gt;GET&lt;/code&gt; request:</source>
          <target state="translated">그런 다음 &lt;code&gt;GET&lt;/code&gt; 요청을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="0f902535bc39ac35baa3a76eb773caadf38f9288" translate="yes" xml:space="preserve">
          <source>There are 2 options you can go with HTTP URL Hits : GET / POST</source>
          <target state="translated">HTTP URL 조회와 함께 사용할 수있는 두 가지 옵션이 있습니다. GET / POST</target>
        </trans-unit>
        <trans-unit id="56fcef5e679e890c8323d7ba434fd4457461f29c" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://square.github.io/okhttp/&quot;&gt;OkHttp&lt;/a&gt;, which is an HTTP client that&amp;rsquo;s efficient by default:</source>
          <target state="translated">기본적으로 효율적인 HTTP 클라이언트 인 &lt;a href=&quot;http://square.github.io/okhttp/&quot;&gt;OkHttp&lt;/a&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdfb0a871a5b9a4e4a8fcc092d99369cc3d0df29" translate="yes" xml:space="preserve">
          <source>Transparent GZIP shrinks download sizes.</source>
          <target state="translated">투명한 GZIP는 다운로드 크기를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="a3843c0524e442447db8305e40492b673db4858a" translate="yes" xml:space="preserve">
          <source>Transparent compression and response caching reduce network use, improve speed and save battery. New applications should use HttpURLConnection; it is where we will be spending our energy going forward.</source>
          <target state="translated">투명한 압축 및 응답 캐싱은 네트워크 사용을 줄이고 속도를 개선하며 배터리를 절약합니다. 새로운 응용 프로그램은 HttpURLConnection을 사용해야합니다. 우리가 앞으로 에너지를 소비 할 곳입니다.</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="6536791df9cf8c9d858bd6467f1fcf7d5547da62" translate="yes" xml:space="preserve">
          <source>Uploading files</source>
          <target state="translated">파일 업로드</target>
        </trans-unit>
        <trans-unit id="cdf6e7e61a57a9c074c85eaacbf8d20c84021b29" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html&quot;&gt;&lt;code&gt;java.net.URLConnection&lt;/code&gt;&lt;/a&gt; is asked about pretty often here, and the &lt;a href=&quot;http://download.oracle.com/javase/tutorial/networking/urls/connecting.html&quot;&gt;Oracle tutorial&lt;/a&gt; is &lt;em&gt;too&lt;/em&gt; concise about it.</source>
          <target state="translated">여기에서 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html&quot;&gt; &lt;code&gt;java.net.URLConnection&lt;/code&gt; &lt;/a&gt; 사용에 대해 자주 묻는 질문에 대해 &lt;a href=&quot;http://download.oracle.com/javase/tutorial/networking/urls/connecting.html&quot;&gt;Oracle 자습서&lt;/a&gt; 가 &lt;em&gt;너무&lt;/em&gt; 간결합니다.</target>
        </trans-unit>
        <trans-unit id="3010c0f47d84431f832b9cc942462e9fd7a7078a" translate="yes" xml:space="preserve">
          <source>Use the User-Agent string from a &lt;a href=&quot;http://www.useragentstring.com/pages/useragentstring.php&quot;&gt;recent browser&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.useragentstring.com/pages/useragentstring.php&quot;&gt;최근 브라우저&lt;/a&gt; 에서 User-Agent 문자열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="170c6d2e56e8b4e9ec094b58afe212ec6e8296a6" translate="yes" xml:space="preserve">
          <source>User-Agent</source>
          <target state="translated">User-Agent</target>
        </trans-unit>
        <trans-unit id="a0bdac354463f4aa7a8344f606dcc8b40025b55c" translate="yes" xml:space="preserve">
          <source>We first need to know at least the URL and the charset. The parameters are optional and depend on the functional requirements.</source>
          <target state="translated">먼저 URL과 문자셋을 알아야합니다. 매개 변수는 선택 사항이며 기능 요구 사항에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f92416704f8a8d4f42a9c8dc6b1968bbafc1d8f3" translate="yes" xml:space="preserve">
          <source>Well you get the idea....</source>
          <target state="translated">당신은 아이디어를 얻는다.</target>
        </trans-unit>
        <trans-unit id="dc62eedf98791b8b1b66fa9567a6225b1fb76507" translate="yes" xml:space="preserve">
          <source>What are the pros/cons of leading HTML parsers in Java</source>
          <target state="translated">Java의 주요 HTML 파서의 장단점은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="a55575f702c1b342ddb362f25dba86b36f010efc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Content-Type&lt;/code&gt; contains a &lt;code&gt;charset&lt;/code&gt; parameter, then the response body is likely text based and we'd like to process the response body with the server-side specified character encoding then.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; 에 &lt;code&gt;charset&lt;/code&gt; 매개 변수가 포함 된 경우 응답 본문은 텍스트를 기반으로하며 서버 측에서 지정된 문자 인코딩으로 응답 본문을 처리하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d526efc0111fd1b42edf0c0dbeddae0446cb0ad4" translate="yes" xml:space="preserve">
          <source>When working with HTTP it's almost always more useful to refer to &lt;code&gt;HttpURLConnection&lt;/code&gt; rather than the base class &lt;code&gt;URLConnection&lt;/code&gt; (since &lt;code&gt;URLConnection&lt;/code&gt; is an abstract class when you ask for &lt;code&gt;URLConnection.openConnection()&lt;/code&gt; on a HTTP URL that's what you'll get back anyway).</source>
          <target state="translated">HTTP로 작업 할 때 기본 클래스 &lt;code&gt;URLConnection&lt;/code&gt; 대신 &lt;code&gt;HttpURLConnection&lt;/code&gt; 을 참조하는 것이 거의 항상 더 유용합니다 ( &lt;code&gt;URLConnection&lt;/code&gt; 은 HTTP URL에서 &lt;code&gt;URLConnection.openConnection()&lt;/code&gt; 을 요청할 때 추상 클래스이기 때문에 어쨌든 되돌아옵니다).</target>
        </trans-unit>
        <trans-unit id="ee13445be42661752d9f20714ba4931ba4496547" translate="yes" xml:space="preserve">
          <source>You can also cast the obtained &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html&quot;&gt;&lt;code&gt;URLConnection&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&quot;&gt;&lt;code&gt;HttpURLConnection&lt;/code&gt;&lt;/a&gt; and use its &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html#setRequestMethod%28java.lang.String%29&quot;&gt;&lt;code&gt;HttpURLConnection#setRequestMethod()&lt;/code&gt;&lt;/a&gt; instead. But if you're trying to use the connection for output you still need to set &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#setDoOutput%28boolean%29&quot;&gt;&lt;code&gt;URLConnection#setDoOutput()&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">또한 획득 한 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html&quot;&gt; &lt;code&gt;URLConnection&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&quot;&gt; &lt;code&gt;HttpURLConnection&lt;/code&gt; 으로&lt;/a&gt; 캐스트하고 대신 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html#setRequestMethod%28java.lang.String%29&quot;&gt; &lt;code&gt;HttpURLConnection#setRequestMethod()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다. 그러나 출력에 연결을 사용하려는 경우 여전히 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#setDoOutput%28boolean%29&quot;&gt; &lt;code&gt;URLConnection#setDoOutput()&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="245cdfa40863d8ce96448736e427726db5478e49" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://http.jcabi.com/apidocs-1.0/com/jcabi/http/request/JdkRequest.html&quot;&gt;&lt;code&gt;JdkRequest&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;http://http.jcabi.com&quot;&gt;jcabi-http&lt;/a&gt; (I'm a developer), which does all this work for you, decorating HttpURLConnection, firing HTTP requests and parsing responses, for example:</source>
          <target state="translated">&lt;a href=&quot;http://http.jcabi.com&quot;&gt;jcabi-http&lt;/a&gt; (개발자입니다)의 &lt;a href=&quot;http://http.jcabi.com/apidocs-1.0/com/jcabi/http/request/JdkRequest.html&quot;&gt; &lt;code&gt;JdkRequest&lt;/code&gt; &lt;/a&gt; 를 사용할 수도 있습니다.이 모든 작업은 HttpURLConnection을 장식하고 HTTP 요청을 발생시키고 응답을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6853cfae7e1be45777c7d0ee19f2361f883d28a6" translate="yes" xml:space="preserve">
          <source>You can find the rest here:</source>
          <target state="translated">나머지는 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a516ee6d5449cdc1e530b5ac409bc8ab1d4224cf" translate="yes" xml:space="preserve">
          <source>You can fire the HTTP request explicitly with &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#connect%28%29&quot;&gt;&lt;code&gt;URLConnection#connect()&lt;/code&gt;&lt;/a&gt;, but the request will automatically be fired on demand when you want to get any information about the HTTP response, such as the response body using &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#getInputStream%28%29&quot;&gt;&lt;code&gt;URLConnection#getInputStream()&lt;/code&gt;&lt;/a&gt; and so on. The above examples does exactly that, so the &lt;code&gt;connect()&lt;/code&gt; call is in fact superfluous.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#connect%28%29&quot;&gt; &lt;code&gt;URLConnection#connect()&lt;/code&gt; &lt;/a&gt; 하여 HTTP 요청을 명시 적으로 실행할 수 있지만 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/URLConnection.html#getInputStream%28%29&quot;&gt; &lt;code&gt;URLConnection#getInputStream()&lt;/code&gt; &lt;/a&gt; 등을 사용하는 응답 본문과 같은 HTTP 응답에 대한 정보를 얻으려는 경우 요청시 요청이 자동으로 시작됩니다. 위의 예제는 정확히 그렇게하므로 &lt;code&gt;connect()&lt;/code&gt; 호출은 실제로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="f11c5a14fc40b0f6eb020811787b2383a59638f9" translate="yes" xml:space="preserve">
          <source>You need a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&quot;&gt;&lt;code&gt;HttpURLConnection&lt;/code&gt;&lt;/a&gt; here. Cast it first if necessary.</source>
          <target state="translated">여기에 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html&quot;&gt; &lt;code&gt;HttpURLConnection&lt;/code&gt; &lt;/a&gt; 이 필요합니다. 필요한 경우 먼저 캐스팅하십시오.</target>
        </trans-unit>
        <trans-unit id="6e25f84dc6b1a2dd1fd66611ebea30b7a882ab8e" translate="yes" xml:space="preserve">
          <source>You'd normally use &lt;a href=&quot;http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2&quot;&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/a&gt; encoding for mixed POST content (binary and character data). The encoding is in more detail described in &lt;a href=&quot;http://www.faqs.org/rfcs/rfc2388.html&quot;&gt;RFC2388&lt;/a&gt;.</source>
          <target state="translated">일반적으로 혼합 POST 컨텐츠 (이진 및 문자 데이터)에 대해 &lt;a href=&quot;http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2&quot;&gt; &lt;code&gt;multipart/form-data&lt;/code&gt; &lt;/a&gt; 인코딩을 사용합니다. 인코딩은 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc2388.html&quot;&gt;RFC2388&lt;/a&gt; 에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8539a50b1ce172ac90829eab9332f574cb4eb60" translate="yes" xml:space="preserve">
          <source>finally, use &lt;code&gt;OkHttpClient&lt;/code&gt; to send prepared &lt;code&gt;Request&lt;/code&gt;:</source>
          <target state="translated">마지막으로 &lt;code&gt;OkHttpClient&lt;/code&gt; 를 사용하여 준비된 &lt;code&gt;Request&lt;/code&gt; 을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f070fe9a4e78b4a3f9ca1c6524388de4eda2dc4a" translate="yes" xml:space="preserve">
          <source>if you are using http get please remove this line</source>
          <target state="translated">http를 사용하는 경우이 줄을 제거하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
