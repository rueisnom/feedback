<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/271526">
    <body>
      <group id="271526">
        <trans-unit id="8c66c64b2bf5dce0f66d6a803ea6b6b85f2bd101" translate="yes" xml:space="preserve">
          <source>&quot;&lt;strong&gt;Illegal argument value null is encountered for parameter [plans]&lt;/strong&gt;&quot;</source>
          <target state="translated">&quot; &lt;strong&gt;パラメータ[プラン]に不正な引数値nullが見つかりました&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="3203cd5f2dfad1b7f4c9811b531d23931fbb7a62" translate="yes" xml:space="preserve">
          <source>(1) is a little harder.  If you have no control over the code you're calling then you're stuck.  If null is a valid response, you have to check for it.</source>
          <target state="translated">(1)は少し難しいです。呼び出しているコードを制御できない場合は行き詰ります。null が有効なレスポンスである場合は、それをチェックしなければなりません。</target>
        </trans-unit>
        <trans-unit id="a072e9edaf03771b557f7cc2e3b70299591cad35" translate="yes" xml:space="preserve">
          <source>(2) is easy.  Either use &lt;code&gt;assert&lt;/code&gt; statements (assertions) or allow failure (for example,  &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt;).  Assertions are a highly-underused Java feature that was added in 1.4.  The syntax is:</source>
          <target state="translated">（2）簡単です。 &lt;code&gt;assert&lt;/code&gt; ステートメント（アサーション）を使用するか、失敗を許可します（たとえば、 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt; ）。 アサーションは、1.4で追加された、十分に活用されていないJava機能です。 構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="69704da627fa56fa83a9194ab8bb332a79074ac1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option is a monad&lt;/a&gt;, so there is no need for verbose null checking, just use map/foreach/getOrElse or a similar combinator to safely use the value &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(example)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;オプションはモナド&lt;/a&gt;であるため、詳細なnullチェックは必要ありません。値を安全に使用するには、map / foreach / getOrElseまたは同様のコンビネーターを使用してください&lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;（例）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="46cc192e40835e83a2ea87cb1bc5d7df3ef20578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt; is a &lt;em&gt;Runtime exception&lt;/em&gt; that means it's developers fault and with enough experience it tells you exactly where is the error.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; は&lt;em&gt;ランタイム例外であり&lt;/em&gt; 、開発者の責任であり、十分な経験があれば、エラーの正確な場所がわかります。</target>
        </trans-unit>
        <trans-unit id="31c3bcb907f016d87b77fd8396afc5c0a9d646b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is a way of replacing a nullable T reference with a
  non-null value. An Optional may either contain a non-null T reference
  (in which case we say the reference is &quot;present&quot;), or it may contain
  nothing (in which case we say the reference is &quot;absent&quot;). It is never
  said to &quot;contain null.&quot;</source>
          <target state="translated">&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; は、null許容のT参照をnull以外の値に置き換える方法です。 Optionalには、null以外のT参照（この場合、参照が「存在する」と言う）を含めるか、何も含まない（この場合、参照が「存在しない」と言う）ことができます。 「ヌルを含む」とは決して言われません。</target>
        </trans-unit>
        <trans-unit id="795a75979fcb8e946ecd45684159328ee5bf5b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&lt;/code&gt; offers other convenient methods, such as &lt;code&gt;orElse&lt;/code&gt; that allow the use of a default value, and &lt;code&gt;ifPresent&lt;/code&gt; that works with &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Optional&lt;/code&gt; は、デフォルト値の使用を可能にする &lt;code&gt;ifPresent&lt;/code&gt; や&lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;ラムダ式&lt;/a&gt;で機能するifPresentなど、他の便利なメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="556c1089ee2ae80da8a26a4b08cfdc720295a1b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you have to deal with an API which might return nulls&lt;/em&gt;, you can't do much in Java. Xtend and Groovy have the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; and the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;null-safe dereference operator&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt;, but note that this returns null in case of a null reference, so it just &quot;defers&quot; the proper handling of null.</source>
          <target state="translated">&lt;em&gt;nullを返す可能性のあるAPIを処理する必要がある場合&lt;/em&gt; 、Javaでは多くのことはできません。 XtendとGroovyには、 &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis演算子&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; と&lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;nullセーフな逆参照演算子&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; ただし、これはnull参照の場合はnullを返すため、nullの適切な処理を「延期」するだけであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d1609ca504bef341cd938af5cc5c00b4d319ceb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to define a new API where undefined values make sense&lt;/em&gt;, use the &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Option Pattern&lt;/a&gt; (may be familiar from functional languages). It has the following advantages:</source>
          <target state="translated">&lt;em&gt;未定義の値が意味をなす新しいAPIを定義する場合&lt;/em&gt;は、 &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;オプションパターンを&lt;/a&gt;使用します（関数型言語でおなじみかもしれません）。 次の利点があります。</target>
        </trans-unit>
        <trans-unit id="9e6ce6480f1f89172e257cc33912ba94b061ffa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; An &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;official proposal&lt;/a&gt; for a null-safe operator in Java 7 has been submitted under &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; The syntax is a little different than the example above, but it's the same notion.</source>
          <target state="translated">&lt;em&gt;更新：&lt;/em&gt; Java 7のnullセーフオペレーターの&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;公式提案&lt;/a&gt;が&lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coinの&lt;/a&gt;下で提出されました。 構文は上の例とは少し異なりますが、同じ概念です。</target>
        </trans-unit>
        <trans-unit id="d03cf75fd803a5cd91e6e06263f455b21a109fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; The null-safe operator proposal didn't make it into Project Coin. So, you won't be seeing this syntax in Java 7.</source>
          <target state="translated">&lt;em&gt;更新：&lt;/em&gt; nullセーフオペレーターの提案は、Project Coinに組み込まれませんでした。 したがって、Java 7ではこの構文は表示されません。</target>
        </trans-unit>
        <trans-unit id="7e57dd158da7749eeb4adc7330e0e7f8c7be6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アプローチ1：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a45037cfed52a95964a4b6663009985c519b3729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アプローチ2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b038e1f7a0e785f507e502bb3ed742df87515a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アプローチ3：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80381f286585ad9109cf5867a45ab2d5ebfacaca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アプローチ4：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22fb44a7606c8a8e6c1eaf89ff705a2805a4a66f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check for 'No data' only if business logic implies it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ビジネスロジックが示唆する場合にのみ、「データなし」を確認します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30f5b35acd55daabe9c5d79fbb13c7d538970512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an 'unknown question' give 'unknown answer'.&lt;/strong&gt; (Be null-safe where this is correct from business point of view) Checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call.</source>
          <target state="translated">&lt;strong&gt;「不明な質問」の場合は「不明な答え」を入力してください。&lt;/strong&gt; （これがビジネスの観点から正しい場合はnullセーフである必要があります）使用前にメソッド内で引数のnullを一度チェックすると、複数の呼び出し元が呼び出しの前にそれらをチェックする必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="17a0daea56744b70e6139473e9163ad0064ca4c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is rather theoretical case and in most cases you should prefer java null safe API (in case it will be released in another 10 years), but &lt;code&gt;NullPointerException&lt;/code&gt; is subclass of an &lt;code&gt;Exception&lt;/code&gt;.&lt;/strong&gt; Thus it is a form of &lt;code&gt;Throwable&lt;/code&gt; that indicates conditions that a reasonable application might want to catch (&lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt;)! To use the first most advantage of exceptions and separate error-handling code from 'regular' code (&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;according to creators of Java&lt;/a&gt;) it is appropriate, as for me, to catch &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;これはかなり理論的なケースであり、ほとんどの場合、Java nullセーフAPI（さらに10年後にリリースされる場合）を好むはずですが、 &lt;code&gt;NullPointerException&lt;/code&gt; は &lt;code&gt;Exception&lt;/code&gt; のサブクラスです。&lt;/strong&gt; したがって、これは、合理的なアプリケーションがキャッチしたい条件を示す &lt;code&gt;Throwable&lt;/code&gt; の形式です（ &lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt; ）。 例外の一番最初の利点を使用し、エラー処理コードを「通常の」コードから分離するには（ &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;Javaの作成者によると&lt;/a&gt; ）、私にとっては、 &lt;code&gt;NullPointerException&lt;/code&gt; をキャッチするのが適切です。</target>
        </trans-unit>
        <trans-unit id="32581af00703ba13e0e48e757a8de5a8956459bb" translate="yes" xml:space="preserve">
          <source>A. It could take place if &lt;code&gt;getPhotoByName()&lt;/code&gt; would try to open a database connection, create &lt;code&gt;PreparedStatement&lt;/code&gt; and use the person name as an SQL parameter at last. The approach &lt;em&gt;for an unknown question gives an unknown answer&lt;/em&gt; (case 1) works here. Before grabbing resources the method should check parameters and return 'unknown' result if needed.</source>
          <target state="translated">A. &lt;code&gt;getPhotoByName()&lt;/code&gt; がデータベース接続を開き、 &lt;code&gt;PreparedStatement&lt;/code&gt; を作成し、最後に個人名をSQLパラメータとして使用しようとした場合に発生する可能性があります。 &lt;em&gt;未知の質問に対する&lt;/em&gt;アプローチ&lt;em&gt;は、未知の答え&lt;/em&gt; （ケース1）を提供します。 リソースを取得する前に、メソッドはパラメータをチェックし、必要に応じて「不明な」結果を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="d442bac768e012a67d8005e207d2f07c7f49c725" translate="yes" xml:space="preserve">
          <source>A. It is up to business logic. If I fail to find a photo album I'll show you no photos. What if appContext is not initialized? This method's business logic puts up with this. If the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). The &lt;strong&gt;new Java Null-safe API fits better here to specify selectively what implies and what does not imply to be initialized&lt;/strong&gt; to be fail-fast in case of programmer errors.</source>
          <target state="translated">A.ビジネスロジック次第です。 フォトアルバムが見つからない場合、写真は表示されません。 appContextが初期化されていない場合はどうなりますか？ このメソッドのビジネスロジックはこれに耐えます。 同じロジックをより厳密にする必要がある場合、例外をスローすることはビジネスロジックの一部であり、nullの明示的なチェックを使用する必要があります（ケース3）。 &lt;strong&gt;新しいJava Null-safe API&lt;/strong&gt;は、プログラマーのエラーが発生した場合にフェイルファストになる&lt;strong&gt;ように初期化&lt;/strong&gt;することを&lt;strong&gt;意味するものと意味しないものを選択的に指定するために、ここにうまく適合します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f2811ffff90eaa563c42e280cf9e259110f4e13" translate="yes" xml:space="preserve">
          <source>A. Software should be easy to understand and modify firstly. Only after this, one could think about performance, and only if needed! and where needed! (&lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;source&lt;/a&gt;), and many others).</source>
          <target state="translated">A.ソフトウェアは、まず理解しやすく、変更しやすいものでなければなりません。 この後初めて、パフォーマンスについて考えることができます。 そして必要なところに！ （ &lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;ソース&lt;/a&gt; ）、および他の多くの）。</target>
        </trans-unit>
        <trans-unit id="8d12b90120d6345989195a1a87e9ec644b614091" translate="yes" xml:space="preserve">
          <source>All private methods do not check for null since they are controlled methods (just let die with nullpointer exception in case it wasn't handled above)</source>
          <target state="translated">すべてのプライベートメソッドは制御されたメソッドであるため、nullをチェックしません(上記で処理されなかった場合に備えて、nullpointer例外を使ってdieさせればよいだけです)。</target>
        </trans-unit>
        <trans-unit id="2d362b47b1b8f524063ce05592e2517660992d07" translate="yes" xml:space="preserve">
          <source>All public methods / API always check its arguments for null</source>
          <target state="translated">すべてのパブリックメソッドAPIは常にその引数がnullであるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="651180d90e7fac397932e649f57913d6e17cbdb5" translate="yes" xml:space="preserve">
          <source>Also I would not recommend using this pattern where the type is meant to be a primitive type representation - like mathematical entities, that are not scalars: vectors, matrices, complex numbers and POD(Plain Old Data) objects, which are meant to hold state in form of Java built-in types. In the latter case you would end up calling getter methods with arbitrary results. For example what should a NullPerson.getName() method return?</source>
          <target state="translated">また、このパターンは、スカラーではない数学的実体、例えば、ベクトル、行列、複素数、POD(Plain Old Data)オブジェクトのように、Javaの組み込み型の形で状態を保持することを目的としたものにはお勧めできません。後者の場合、任意の結果を持つゲッターメソッドを呼び出すことになります。例えば、NullPerson.getName()メソッドは何を返すのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f7b3d415a8b44b9ed32e579112942a8c54368712" translate="yes" xml:space="preserve">
          <source>Also keep in mind, that null object pattern will be memory hungry if used without care. For this - the instance of a NullObject should be shared between owners, and not be an unigue instance for each of these.</source>
          <target state="translated">また、Nullオブジェクトパターンは、注意しないで使うとメモリを空腹にしてしまうことを覚えておきましょう。そのためには、NullObjectのインスタンスは所有者間で共有し、それぞれのインスタンスをunigueにしないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="f6cc029520b428014830a634a4f74acc230947ba" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;assert&lt;/code&gt; statement throws an &lt;code&gt;Error&lt;/code&gt; (&lt;code&gt;AssertionError&lt;/code&gt;) if the condition is not true.  By default, Java ignores assertions.  You can enable assertions by passing the option &lt;code&gt;-ea&lt;/code&gt; to the JVM.  You can enable and disable assertions for individual classes and packages.  This means that you can validate code with the assertions while developing and testing, and disable them in a production environment, although my testing has shown next to no performance impact from assertions.</source>
          <target state="translated">条件が真でない場合、 &lt;code&gt;assert&lt;/code&gt; ステートメントは &lt;code&gt;Error&lt;/code&gt; （ &lt;code&gt;AssertionError&lt;/code&gt; ）をスローします。 デフォルトでは、Javaはアサーションを無視します。 オプション &lt;code&gt;-ea&lt;/code&gt; をJVMに渡すことにより、アサーションを有効にできます 。 個々のクラスおよびパッケージのアサーションを有効または無効にすることができます。 これは、開発およびテスト中にアサーションを使用してコードを検証し、本番環境でそれらを無効にできることを意味しますが、テストではアサーションによるパフォーマンスへの影響はほとんどありませんでした。</target>
        </trans-unit>
        <trans-unit id="d1810451c6d1e409ac8c526fe9326856e3fc7731" translate="yes" xml:space="preserve">
          <source>An alternative solution is to never return null and instead use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object pattern&lt;/a&gt;:</source>
          <target state="translated">別の解決策は、nullを返さず、代わりに&lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Nullオブジェクトパターンを&lt;/a&gt;使用することです。</target>
        </trans-unit>
        <trans-unit id="935b1f02f26191e4d51fccc6975811fe44f6303a" translate="yes" xml:space="preserve">
          <source>An optional object for a given type (&lt;code&gt;Fruit&lt;/code&gt;) is created as the return type of a method. It can be empty or contain a &lt;code&gt;Fruit&lt;/code&gt; object:</source>
          <target state="translated">指定されたタイプ（ &lt;code&gt;Fruit&lt;/code&gt; ）のオプションのオブジェクトは、メソッドの戻りタイプとして作成されます。 空の場合もあれば、 &lt;code&gt;Fruit&lt;/code&gt; オブジェクトを含む場合もあります。</target>
        </trans-unit>
        <trans-unit id="7890138d52aa6dda680f54b0057313bbeec8699c" translate="yes" xml:space="preserve">
          <source>And don't loathe to type &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (generate javadoc in Eclipse) and write three additional words for you public API. This will be more than enough for all but those who don't read documentation.</source>
          <target state="translated">また、 &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; （Eclipseでjavadocを生成）と入力して、パブリックAPIのために3つの追加の単語を書くのを嫌う必要はありません。 これは、ドキュメントを読んでいない人以外は十分です。</target>
        </trans-unit>
        <trans-unit id="90d233698926e1669e5eb1d2e7cde879b5ea4b2a" translate="yes" xml:space="preserve">
          <source>And finally, in the code, the first line of the public method goes like this:</source>
          <target state="translated">そして最後に、コードの中で、パブリックメソッドの1行目は次のようになります。</target>
        </trans-unit>
        <trans-unit id="194d7971422626db3904b18b7a51e13251038301" translate="yes" xml:space="preserve">
          <source>And if you are using Spring, Spring also has the same functionality in its package, see library(spring-2.4.6.jar)</source>
          <target state="translated">また、Springを使用している場合、Springも同様の機能をパッケージ内に持っています。</target>
        </trans-unit>
        <trans-unit id="96abcbe58267cd8ab194fc60b9df329abfd8ab74" translate="yes" xml:space="preserve">
          <source>And it fits with new coming Java API (looking forward)</source>
          <target state="translated">そして、それは来るべき新しいJava APIに適合しています(楽しみにしています)。</target>
        </trans-unit>
        <trans-unit id="8a58cb59872c19e045b96568e04e4207657e1c22" translate="yes" xml:space="preserve">
          <source>And the usage is (with &lt;code&gt;import static&lt;/code&gt;):</source>
          <target state="translated">そして使用法は（ &lt;code&gt;import static&lt;/code&gt; ）で：</target>
        </trans-unit>
        <trans-unit id="ae0cf01358f7068b6df8fd1b93a1c98822554b48" translate="yes" xml:space="preserve">
          <source>And yes, we know that beyond this line we will no longer encounter a null value so we just safely invoke methods on those objects.</source>
          <target state="translated">そして、そうですね、この行を超えると null 値に遭遇しなくなることがわかっているので、これらのオブジェクトに対して安全にメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="81e8d209a324ece42ed62905642bf649b3662f32" translate="yes" xml:space="preserve">
          <source>And you can be sure that this won't happen. :)</source>
          <target state="translated">そして、このようなことは起こらないと確信してください :)</target>
        </trans-unit>
        <trans-unit id="3294bacd3a1276b7be29212d3a5dd40d74f51115" translate="yes" xml:space="preserve">
          <source>As explained in the wiki:</source>
          <target state="translated">wikiで説明されているように</target>
        </trans-unit>
        <trans-unit id="f927010b70c936bded38e97a00575ae4404173b5" translate="yes" xml:space="preserve">
          <source>As mentioned in some other answers, to avoid above problems you can follow the &lt;strong&gt;Design by contract&lt;/strong&gt; pattern. Please see &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt;.</source>
          <target state="translated">他のいくつかの回答で述べたように、上記の問題を回避するために&lt;strong&gt;、契約&lt;/strong&gt;パターン&lt;strong&gt;による設計に&lt;/strong&gt;従うことができます。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contractを&lt;/a&gt;参照してください 。</target>
        </trans-unit>
        <trans-unit id="9f1edc5d84268854adcf97f62dec08810475c6e1" translate="yes" xml:space="preserve">
          <source>As you can see, the second value in the addParam() method (string) is needed for the user message, because you cannot easily detect passed-in variable name, even with reflection (not subject of this post anyway...).</source>
          <target state="translated">ご覧のように、addParam()メソッドの2番目の値(文字列)は、ユーザメッセージに必要なものです。</target>
        </trans-unit>
        <trans-unit id="221c48cdf1c0d0839054379dfe7e20af1349a56a" translate="yes" xml:space="preserve">
          <source>As you see &lt;code&gt;Optional.ofNullable()&lt;/code&gt; provides an easy way to get the reference wrapped. There are another ways to get the reference of Optional, either &lt;code&gt;Optional.empty()&lt;/code&gt; &amp;amp; &lt;code&gt;Optional.of()&lt;/code&gt;. One for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively.</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;Optional.ofNullable()&lt;/code&gt; は、参照をラップする簡単な方法を提供します。 &lt;code&gt;Optional.empty()&lt;/code&gt; および &lt;code&gt;Optional.of()&lt;/code&gt; のいずれかでOptionalの参照を取得する別の方法があります。 1つはnullを再調整する代わりに空のオブジェクトを返し、もう1つはnullにできないオブジェクトをラップするためのものです。</target>
        </trans-unit>
        <trans-unit id="7d61afa6fe305594ae8b4e6cf7ecc955c25b75c5" translate="yes" xml:space="preserve">
          <source>Asking that question points out that you may be interested in error handling strategies.  Your team's architect should decide how to work errors.  There are several ways to do this:</source>
          <target state="translated">その質問をすることで、あなたがエラー処理戦略に興味を持っている可能性があることを指摘しています。あなたのチームのアーキテクトは、エラーをどのように処理するかを決めるべきです。これにはいくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="0b437dd2d827fe8753e6c8da99be2952fba3ea42" translate="yes" xml:space="preserve">
          <source>Avoiding != null statements</source>
          <target state="translated">null文の回避</target>
        </trans-unit>
        <trans-unit id="11cb1da4d18f15638f6174f01e98f7fee924565f" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with &quot;Tell, Don't Ask&quot; Style</source>
          <target state="translated">Tell,Don't Ask」スタイルでのヌルの回避</target>
        </trans-unit>
        <trans-unit id="c53936ddbedfa72c352067284a2a612bd38150c0" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with Polymorphic Dispatch</source>
          <target state="translated">ポリモーフィックなディスパッチでのヌルの回避</target>
        </trans-unit>
        <trans-unit id="f4719d3ce5a47c8365160718c824959b1f58c151" translate="yes" xml:space="preserve">
          <source>Basically, you've got &lt;code&gt;@Nullable&lt;/code&gt; and &lt;code&gt;@NotNull&lt;/code&gt;.</source>
          <target state="translated">基本的に、あなたは &lt;code&gt;@Nullable&lt;/code&gt; と &lt;code&gt;@NotNull&lt;/code&gt; を持っています。</target>
        </trans-unit>
        <trans-unit id="1c18860f21ab893032025c9ad8f874c57757e0d5" translate="yes" xml:space="preserve">
          <source>Byte!</source>
          <target state="translated">Byte!</target>
        </trans-unit>
        <trans-unit id="320bd43703cd7557626230bd2dde77c2b7640f71" translate="yes" xml:space="preserve">
          <source>Common &quot;problem&quot; in Java indeed.</source>
          <target state="translated">確かにJavaではよくある「問題」です。</target>
        </trans-unit>
        <trans-unit id="ab6b4e896ea7eaaed3d3b7bd63695ed61f2bc666" translate="yes" xml:space="preserve">
          <source>Compare:</source>
          <target state="translated">Compare:</target>
        </trans-unit>
        <trans-unit id="4890e65fe4afc7621e1eabc62ca877d901891501" translate="yes" xml:space="preserve">
          <source>Depending on what kind of objects you are checking you may be able to use some of the classes in the apache commons such as: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt;</source>
          <target state="translated">チェックするオブジェクトの種類によっては、次のようなapache commonsのクラスの一部を使用できる場合があります&lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;。apache commons lang&lt;/a&gt;および&lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commonsコレクション&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1611574f68477e79c3124a789db72e5b33b65570" translate="yes" xml:space="preserve">
          <source>Doing this</source>
          <target state="translated">これを行うこと</target>
        </trans-unit>
        <trans-unit id="9a7ba7e5ca69607940820be45f20c7f96e626e73" translate="yes" xml:space="preserve">
          <source>Doing this in your own code and you can avoid != null checks.</source>
          <target state="translated">これを自分のコードで行うことで、 !=nullチェックを回避することができます。</target>
        </trans-unit>
        <trans-unit id="a489753c928c4dfb8ffde543140ef98f7d16b3e3" translate="yes" xml:space="preserve">
          <source>Example on how to throw exception on null:</source>
          <target state="translated">nullに例外を投げる方法の例</target>
        </trans-unit>
        <trans-unit id="c10cb15cb38405cd962e584139f01df735b6c7b4" translate="yes" xml:space="preserve">
          <source>Example on how to use this static classf from spring(org.springframework.util.Assert)</source>
          <target state="translated">spring(org.springframework.util.Assert)からこの静的クラスを使う例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c7feb78075d63e6bedf1365cc55e6aa7fc3a87a8" translate="yes" xml:space="preserve">
          <source>Finally, here is our NPE as well as null check-free code:</source>
          <target state="translated">最後に、NPEだけでなく、ヌルチェックフリーのコードをご紹介します。</target>
        </trans-unit>
        <trans-unit id="1428f3662f53c4496ea96cf16634505d0f0a9b2c" translate="yes" xml:space="preserve">
          <source>First, I follow this convention:</source>
          <target state="translated">まず、私はこの慣習に従っています。</target>
        </trans-unit>
        <trans-unit id="3f6a27b732f1a0d9afc335cb45ef93731f4fb5bf" translate="yes" xml:space="preserve">
          <source>First, my thoughts on this:</source>
          <target state="translated">まず、これに対する私の考え。</target>
        </trans-unit>
        <trans-unit id="54463d0ab47a851d650e8259c2db7a0ae594a452" translate="yes" xml:space="preserve">
          <source>For example I often use:</source>
          <target state="translated">例えば私はよく使います。</target>
        </trans-unit>
        <trans-unit id="4b4c9cb4038fad0763e34c64a087da1f526c6087" translate="yes" xml:space="preserve">
          <source>Guava, a very useful core library by Google, has a nice and useful API to avoid nulls. I find &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained&lt;/a&gt; very helpful.</source>
          <target state="translated">グアバ、グーグルによる非常に便利なコアライブラリは、nullを回避するための素晴らしくて便利なAPIを備えています。 &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplainedは&lt;/a&gt;非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="2a6e8249d4017ff690264fec43a31540b1ea7759" translate="yes" xml:space="preserve">
          <source>Here follows an example of how you can use null vallidation in JAVA when you include apache library(commons-lang-2.4.jar)</source>
          <target state="translated">以下は、apache library(commons-lang-2.4.jar)をインクルードしたときに、JAVAでヌル無効化を使用する例です。</target>
        </trans-unit>
        <trans-unit id="37fc03c253b95910c6421c23c78078850ed69a95" translate="yes" xml:space="preserve">
          <source>However, if your method just passes the value on, and the next method passes it on etc. it could get problematic. In that case you may want to check the argument as above.</source>
          <target state="translated">しかし、あなたのメソッドが値を渡すだけで、次のメソッドが値を渡すなどの場合、問題が発生する可能性があります。その場合は、上記のように引数を確認してみてください。</target>
        </trans-unit>
        <trans-unit id="1d268653fde675e2306e93684be579aa72eb2868" translate="yes" xml:space="preserve">
          <source>I consider that it is bad to &quot;eat&quot; something when NULL was passed where NULL isn't a valid value. If you're not exiting the method with some sort of error then it means nothing went wrong in your method which is not true. Then you probably return null in this case, and in the receiving method you again check for null, and it never ends, and you end up with &quot;if != null&quot;, etc..</source>
          <target state="translated">私は、NULLが有効な値ではないところにNULLが渡されたときに何かを &quot;食べる &quot;のは悪いことだと考えています。もしあなたが何らかのエラーでメソッドを終了していないのであれば、それはあなたのメソッドで何も問題がなかったことを意味しますが、それは真ではありません。そうすると、おそらくこの場合はNULLを返し、受信側のメソッドでは再びNULLをチェックして終わりではなく、&quot;if !=null &quot;などで終わってしまうことになります。</target>
        </trans-unit>
        <trans-unit id="ac7c74b5f9864f037fc949031de21c91fd9060c0" translate="yes" xml:space="preserve">
          <source>I highly disregard answers that suggest using the null objects in every situation. This pattern may break the contract and bury problems deeper and deeper instead of solving them, not mentioning that used inappropriately will create another pile of boilerplate code that will require future maintenance.</source>
          <target state="translated">私は、すべての状況でヌルオブジェクトを使用することを示唆する回答を強く無視します。このパターンは契約を破棄し、問題を解決する代わりに問題をより深く埋めてしまう可能性があり、不適切に使用されることで、今後のメンテナンスが必要となる別の積み上げられたコードの山を作ることになることには言及していません。</target>
        </trans-unit>
        <trans-unit id="5e1533f4720d20d3996516b4af58f7d3dd16391a" translate="yes" xml:space="preserve">
          <source>I invite you to read this article (my main source for writing this answer) in which the &lt;code&gt;NullPointerException&lt;/code&gt; (and in general null pointer) problematic as well as the (partial) solution brought by &lt;code&gt;Optional&lt;/code&gt; are well explained: &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">この記事（この回答を書くための私の主な情報源）を読むことをお勧めします。ここでは、 &lt;code&gt;NullPointerException&lt;/code&gt; （および一般にnullポインター）の問題と、 &lt;code&gt;Optional&lt;/code&gt; によってもたらされる（部分的な）ソリューションがよく説明されています： &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9e91faab1ad00e77854ebd2d809262438fc2063" translate="yes" xml:space="preserve">
          <source>I like articles from Nat Pryce. Here are the links:</source>
          <target state="translated">ナット・プライスの記事が好きです。ここにリンクがあります。</target>
        </trans-unit>
        <trans-unit id="c4217f45a2775c21698ce1470fdcef44f36c7cb8" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;object != null&lt;/code&gt; a lot to avoid &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt;を回避するために、 &lt;code&gt;object != null&lt;/code&gt; を頻繁に使用しています 。</target>
        </trans-unit>
        <trans-unit id="43aae1b74babe4a5f7cffce5f010ac04c50784b7" translate="yes" xml:space="preserve">
          <source>I'm a fan of &quot;fail fast&quot; code. Ask yourself - are you doing something useful in the case where the parameter is null? If you don't have a clear answer for what your code should do in that case... I.e. it should never be null in the first place, then ignore it and allow a NullPointerException to be thrown. The calling code will make just as much sense of an NPE as it would an IllegalArgumentException, but it'll be easier for the developer to debug and understand what went wrong if an NPE is thrown rather than your code attempting to execute some other unexpected contingency logic - which ultimately results in the application failing anyway.</source>
          <target state="translated">私は &quot;fail fast &quot;コードのファンです。自問自答してみてください-パラメータがnullの場合に何か役に立つことをしていますか?もし、その場合にコードが何をすべきか明確な答えがないのであれば...つまり、そもそもパラメータがnullになるべきではないのですが、それを無視してNullPointerExceptionを発生させます。呼び出し元のコードは、IllegalArgumentException と同じように NPE を意味するでしょうが、開発者にとっては、NPE がスローされた場合に何が間違っていたのかをデバッグして理解することが容易になるでしょう。</target>
        </trans-unit>
        <trans-unit id="9d28525daf513a3218069e5463bb837227dd3063" translate="yes" xml:space="preserve">
          <source>I've tried the &lt;code&gt;NullObjectPattern&lt;/code&gt; but for me is not always the best way to go. There are sometimes when a &quot;no action&quot; is not appropiate.</source>
          <target state="translated">私は &lt;code&gt;NullObjectPattern&lt;/code&gt; を試しましたが、私にとって必ずしも最善の方法ではありません。 「アクションなし」が適切でない場合があります。</target>
        </trans-unit>
        <trans-unit id="55bdc40b2d33d1479a2eed8448e223fe33d03160" translate="yes" xml:space="preserve">
          <source>If (1) is not possible, initialise all collections and arrays to empty collections/arrays.</source>
          <target state="translated">(1)ができない場合は、すべてのコレクションと配列を空のcollectionsarraysに初期化します。</target>
        </trans-unit>
        <trans-unit id="0e0f1c759db9fd58b965ca2548b987ed339d8a59" translate="yes" xml:space="preserve">
          <source>If appContext or dataSource is not initialized unhandled runtime NullPointerException will kill current thread and will be processed by &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (for you to define and use your favorite logger or other notification mechanizm). If not set, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup#uncaughtException&lt;/a&gt; will print stacktrace to system err. One should monitor application error log and open Jira issue for each unhandled exception which in fact is application error. Programmer should fix bug somewhere in initialization stuff.</source>
          <target state="translated">appContextまたはdataSourceが初期化されていない場合、未処理のランタイムNullPointerExceptionは現在のスレッドを&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;強制終了し&lt;/a&gt; 、 Thread.defaultUncaughtExceptionHandlerによって処理されます （お気に入りのロガーまたは他の通知メカニズムを定義して使用するため）。 設定しない場合、 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup＃uncaughtException&lt;/a&gt;はスタックトレースをシステムエラーに出力します。 アプリケーションエラーログを監視し、実際にはアプリケーションエラーである未処理の例外ごとにJiraの問題を開く必要があります。 プログラマーは初期化のどこかでバグを修正するべきです。</target>
        </trans-unit>
        <trans-unit id="09e73ecfe67989af7dd8eaebfa15624f78eacae4" translate="yes" xml:space="preserve">
          <source>If it is an internal method (not part of an API), just document that it cannot be null, and that's it.</source>
          <target state="translated">内部メソッド(APIの一部ではない)であれば、それがnullにできないことを文書化すればいいだけです。</target>
        </trans-unit>
        <trans-unit id="0728dc4e2e97cf099cf3ab0e28a357ee05e7b6ca" translate="yes" xml:space="preserve">
          <source>If it's code that you do control, however (and this is often the case), then it's a different story.  Avoid using nulls as a response.  With methods that return collections, it's easy: return empty collections (or arrays) instead of nulls pretty much all the time.</source>
          <target state="translated">しかし、あなたがコントロールするコードであれば(これはよくあることです)、それは別の話です。レスポンスに NULL を使用しないようにしましょう。コレクションを返すメソッドでは、簡単です:ほとんどの場合、null の代わりに空のコレクション (または配列)を返すようにします。</target>
        </trans-unit>
        <trans-unit id="f619483031223d172a56c6c25092a69d35edf9be" translate="yes" xml:space="preserve">
          <source>If null is allowed</source>
          <target state="translated">nullが許可されている場合</target>
        </trans-unit>
        <trans-unit id="d5dc5db9bb49b83ae4fcd69d7d06a8b86bbf1b0a" translate="yes" xml:space="preserve">
          <source>If null-values are not allowed</source>
          <target state="translated">ヌル値が許可されていない場合</target>
        </trans-unit>
        <trans-unit id="9ff0191b7a1ec369d5c5805839743dd0c72f1b9e" translate="yes" xml:space="preserve">
          <source>If undefined values are not permitted:</source>
          <target state="translated">未定義の値が許可されていない場合。</target>
        </trans-unit>
        <trans-unit id="549ca9f1c825f259e5ce60b96c2984b9b0f5f764" translate="yes" xml:space="preserve">
          <source>If undefined values are permitted:</source>
          <target state="translated">未定義の値が許可されている場合。</target>
        </trans-unit>
        <trans-unit id="68f38a6783f67b9f294c501c4581c1585e95009c" translate="yes" xml:space="preserve">
          <source>If you ask me what is the name of my girlfriend I'll tell you that I have no girlfriend. In the Java language I'll return null. 
An alternative would be to throw meaningful exception to indicate some problem that can't be (or don't want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user.</source>
          <target state="translated">恋人の名前は何かと聞かれたら、彼女はいないと答えるだろう。Java言語ではnullを返します。代替案としては、その場で解決できない(したくない)何らかの問題を示すために意味のある例外を投げ、スタックのどこか上位に委譲して再試行したり、データアクセスエラーをユーザに報告したりすることが考えられます。</target>
        </trans-unit>
        <trans-unit id="632f1186cdb5143b60b5f2614ffe2a8a35f452f1" translate="yes" xml:space="preserve">
          <source>If you consider an object should not be null (or it is a bug) use an assert.</source>
          <target state="translated">オブジェクトがNULLであるべきではない(バグである)と考える場合は、アサートを使用してください。</target>
        </trans-unit>
        <trans-unit id="1cf153150df9563cc962ca474b13e56e5c751cce" translate="yes" xml:space="preserve">
          <source>If you know b can never be null, you can just swap it. It is most useful for equals:
Instead of &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; better do &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt;.</source>
          <target state="translated">bがnullになり得ないことがわかっている場合は、それを交換できます。 これはイコールに最も役立ちます： &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; の代わりに; &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt; ほうが適切です。 。</target>
        </trans-unit>
        <trans-unit id="46640e8236124be6c3cf80df96f4c3a462598491" translate="yes" xml:space="preserve">
          <source>If you use (or planning to use) a Java IDE like &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; or &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; or a tool like findbugs then you can use annotations to solve this problem.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt; 、 &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; 、 &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt;などのJava IDE、またはfindbugsなどのツールを使用している（または使用する予定の）場合は、注釈を使用してこの問題を解決できます。</target>
        </trans-unit>
        <trans-unit id="d9bd5740fe135b5553acbf51ff5056141fbbb4dc" translate="yes" xml:space="preserve">
          <source>If your method doesn't accept null params say it in the javadoc and use an assert.</source>
          <target state="translated">メソッドがnullパラメータを受け付けない場合は、javadocでその旨を述べ、アサートを使用してください。</target>
        </trans-unit>
        <trans-unit id="ce6b2cf4a5e96febfe5ce76451daef36e092d32b" translate="yes" xml:space="preserve">
          <source>If your method is called externally, start with something like this:</source>
          <target state="translated">メソッドが外部から呼び出される場合は、以下のように開始します。</target>
        </trans-unit>
        <trans-unit id="ab846b65d9a8fcd8a4b81c40b61e74e028b79991" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt;, a Java-derived language, there are two versions of all types: a potentially-null version and a not-null version. You can only invoke methods on not-null types. Potentially-null types can be converted to not-null types through explicit checking for null. This makes it much easier to know where null checks are necessary and where they aren't.</source>
          <target state="translated">Javaから派生した言語である&lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Niceに&lt;/a&gt;は、すべてのタイプの2つのバージョン（nullの可能性があるバージョンとnullでないバージョン）があります。 null以外の型のメソッドのみを呼び出すことができます。 nullの可能性がある型は、nullを明示的にチェックすることでnullでない型に変換できます。 これにより、nullチェックが必要な場所と不要な場所を簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="8317f0d2b647c2aff1a42d76d73339593f638877" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA 10.5 and on, they added support for any other &lt;code&gt;@Nullable&lt;/code&gt;&lt;code&gt;@NotNull&lt;/code&gt; implementations.</source>
          <target state="translated">IntelliJ IDEA 10.5以降では、他の &lt;code&gt;@Nullable&lt;/code&gt; &lt;code&gt;@NotNull&lt;/code&gt; 実装のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="920588de011f2e8dddc89ccb39b92ea0631e797c" translate="yes" xml:space="preserve">
          <source>In Objective-C, you can do the equivalent of invoking a method on &lt;code&gt;nil&lt;/code&gt;, and absolutely nothing will happen. This makes most null checks unnecessary, but it can make errors much harder to diagnose.</source>
          <target state="translated">Objective-Cでは、 &lt;code&gt;nil&lt;/code&gt; でメソッドを呼び出すのと同等のことができ、何も起こりません。 これにより、ほとんどのnullチェックが不要になりますが、エラーの診断がはるかに困難になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="04837dad91721b9799f52240befed0a8ce992bd5" translate="yes" xml:space="preserve">
          <source>In a nutshell, the Optional class includes methods to explicitly deal with the cases where a value is present or absent. However, the advantage compared to null references is that the Optional&amp;lt;T&amp;gt; class forces you to think about the case when the value is not present. As a consequence, you can prevent unintended null pointer exceptions.</source>
          <target state="translated">簡単に言うと、Optionalクラスには、値が存在する場合と存在しない場合を明示的に処理するメソッドが含まれています。 ただし、null参照と比較した場合の利点は、Optional &amp;lt;T&amp;gt;クラスでは、値が存在しない場合について考える必要があることです。 その結果、意図しないnullポインタ例外を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="f1f3e79c602141290377505754be2b4a12d560ec" translate="yes" xml:space="preserve">
          <source>In above example we have a home service factory that returns a handle to multiple appliances available in the home. But these services may or may not be available/functional; it means it may result in a NullPointerException. Instead of adding a null &lt;code&gt;if&lt;/code&gt; condition before using any service, let's wrap it in to Optional&amp;lt;Service&amp;gt;.</source>
          <target state="translated">上記の例では、家で利用可能な複数のアプライアンスのハンドルを返すホームサービスファクトリがあります。 ただし、これらのサービスは利用可能/機能しない場合があります。 つまり、NullPointerExceptionが発生する可能性があります。 サービスを使用する前にnull &lt;code&gt;if&lt;/code&gt; 条件を追加する代わりに、それをOptional &amp;lt;Service&amp;gt;にラップしましょう。</target>
        </trans-unit>
        <trans-unit id="fc6e5953a54a7e173cf74b9a49d8e3e1c3ed3c55" translate="yes" xml:space="preserve">
          <source>In addition to using &lt;code&gt;assert&lt;/code&gt; you can use the following:</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 使用に加えて、以下を使用できます。</target>
        </trans-unit>
        <trans-unit id="58e936cf946cec0419aa0692bf595f85b67c954b" translate="yes" xml:space="preserve">
          <source>In an API built from scratch using &lt;code&gt;Optional&lt;/code&gt; whenever a return value might be empty, and returning a plain object only when it cannot be &lt;code&gt;null&lt;/code&gt; (convention), the client code might abandon null checks on simple object return values...</source>
          <target state="translated">戻り値が空の場合はいつでも &lt;code&gt;Optional&lt;/code&gt; を使用して最初から構築されたAPIで、 &lt;code&gt;null&lt;/code&gt; にできない場合にのみプレーンオブジェクトを返す（従来）場合、クライアントコードは単純なオブジェクトの戻り値のnullチェックを放棄する可能性があります...</target>
        </trans-unit>
        <trans-unit id="992aee948602e38e384351d28a7dc64174420247" translate="yes" xml:space="preserve">
          <source>In my classes, most fields and local variables have non-null default values, and I add contract statements (always-on asserts) everywhere in the code to make sure this is being enforced (since it's more succinct, and more expressive than letting it come up as an NPE and then having to resolve the line number, etc.).</source>
          <target state="translated">私のクラスでは、ほとんどのフィールドとローカル変数のデフォルト値は非 null であり、これが実行されているかどうかを確認するために、コードのいたるところにコントラクト文 (常時オンアサート)を追加しています (その方が簡潔で、NPE として出てきてから行番号などを解決しなければならないよりも表現力があるからです)。</target>
        </trans-unit>
        <trans-unit id="a0427014adae81ed68e6059ae2ac27ebf2554012" translate="yes" xml:space="preserve">
          <source>In reality if something returned from a method can be null and the calling code has to make decision upon that, there should an earlier call that ensures the state.</source>
          <target state="translated">実際には、メソッドから返された何かがnullになる可能性があり、呼び出し側のコードがそれに基づいて決定しなければならない場合、その状態を保証するための初期の呼び出しがあるはずです。</target>
        </trans-unit>
        <trans-unit id="d28d029f197073e44a5cf2c959d2881818c5cbc8" translate="yes" xml:space="preserve">
          <source>In the articles there is also a link to a Git repository for a Java Maybe Type which I find interesting, but I don't think it alone could decrease the
checking code bloat. After doing some research on the Internet, I think &lt;strong&gt;!= null&lt;/strong&gt; code bloat could be decreased mainly by careful design.</source>
          <target state="translated">記事には、Java Maybe TypeのGitリポジトリへのリンクも含まれています。これは興味深いと思いますが、それだけでチェックコードの膨張を減らすことはできないと思います。 インターネットでいくつかの調査を行った後、私は&lt;strong&gt;！= null&lt;/strong&gt;コードの膨張は、主に注意深い設計によって減らすことができると思います。</target>
        </trans-unit>
        <trans-unit id="02e44622ee08c669f730bdcb2ba763d4bddbd763" translate="yes" xml:space="preserve">
          <source>Is there a good alternative to this?</source>
          <target state="translated">これに代わる良い方法はありますか?</target>
        </trans-unit>
        <trans-unit id="24df4f8ef6f8fd18a5d3ec048c3faffe1f0edf74" translate="yes" xml:space="preserve">
          <source>It is stated explicitly in the API whether an input or output exists or not.</source>
          <target state="translated">入力または出力が存在するかどうかはAPIで明示的に指定されます。</target>
        </trans-unit>
        <trans-unit id="6cd16395a598dc3b1c54e1c2de34abba05b16ef6" translate="yes" xml:space="preserve">
          <source>It may be easier to give you examples, if you show examples of where you typically use the idiom.</source>
          <target state="translated">慣用句はどこで使うのが一般的なのか、例を示した方が例を出しやすいかもしれません。</target>
        </trans-unit>
        <trans-unit id="c32880c4b10a50c8fb02fa59f5e5618dea4d1963" translate="yes" xml:space="preserve">
          <source>It's a nice way to let the compiler check something more than it usually does and to enforce your contracts to be stronger. Unfortunately, it's not supported by all the compilers.</source>
          <target state="translated">コンパイラに通常よりも何かをチェックさせて、契約をより強固なものにするために強制するのはいい方法です。残念ながら、すべてのコンパイラでサポートされているわけではありません。</target>
        </trans-unit>
        <trans-unit id="f405e902c0a66a3e8ffdf23a351c22c3a375631a" translate="yes" xml:space="preserve">
          <source>It's actually rare for me to use the idiom &quot;&lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt;&quot;.</source>
          <target state="translated">イディオム &quot; &lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt; &quot;を使用することは、実際にはまれです。</target>
        </trans-unit>
        <trans-unit id="714b225b9ed3d9fb4f8f780dad6fe5864bd2db61" translate="yes" xml:space="preserve">
          <source>It's worth considering such cases in order to avoid absurd results.</source>
          <target state="translated">不条理な結果にならないためにも、このようなケースは検討してみる価値があると思います。</target>
        </trans-unit>
        <trans-unit id="e2368895a515e87735e0f53eb54312d0b78e798a" translate="yes" xml:space="preserve">
          <source>Java 7 has a new &lt;code&gt;java.util.Objects&lt;/code&gt; utility class on which there is a &lt;code&gt;requireNonNull()&lt;/code&gt; method. All this does is throw a &lt;code&gt;NullPointerException&lt;/code&gt; if its argument is null, but it cleans up the code a bit. Example:</source>
          <target state="translated">Java 7には、 &lt;code&gt;requireNonNull()&lt;/code&gt; メソッドが存在する新しい &lt;code&gt;java.util.Objects&lt;/code&gt; ユーティリティクラスがあります。 これは、引数がnullの場合は &lt;code&gt;NullPointerException&lt;/code&gt; をスローするだけですが、コードを少しクリーンアップします。 例：</target>
        </trans-unit>
        <trans-unit id="edc6b48d824432a77a20f24921f65458059db63b" translate="yes" xml:space="preserve">
          <source>Java 7 introduced the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt;&lt;code&gt;Objects.requireNonNull&lt;/code&gt;&lt;/a&gt; method which can be handy when something should be checked for non-nullness. Example:</source>
          <target state="translated">Java 7は&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt; &lt;code&gt;Objects.requireNonNull&lt;/code&gt; &lt;/a&gt;メソッドを導入しました。これは、何かがnullでないかどうかをチェックする必要がある場合に便利です。 例：</target>
        </trans-unit>
        <trans-unit id="14057bbaba6e7ba4939e98331bee0a9d4cc6fd00" translate="yes" xml:space="preserve">
          <source>Java 8 has a built-in &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class (recommended); for earlier versions, there are library alternatives, for example &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;'s &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;. But like many functional-style patterns, using Option in Java (even 8) results in quite some boilerplate, which you can reduce using a less verbose JVM language, e.g. Scala or Xtend.</source>
          <target state="translated">Java 8には&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;クラスが組み込まれています（推奨）。 以前のバージョンでは、 &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;の&lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;の&lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;など、ライブラリの代替手段があります。 しかし、多くの関数型のパターンと同様に、Option in Java（8でも）を使用すると、かなり定型的な結果が得られます。これは、ScalaやXtendなどのより冗長でないJVM言語を使用して減らすことができます。</target>
        </trans-unit>
        <trans-unit id="23ec0515f353dee199aaa003dccab705cbddfd12" translate="yes" xml:space="preserve">
          <source>Java 8 has introduced &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;. It is a container that may or may not hold a non-null value. Java 8 has given a safer way to handle an object whose value may be null in some of the cases. It is inspired from the ideas of &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt;.</source>
          <target state="translated">Java 8は &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt; 導入しました。 これは、null以外の値を保持する場合と保持しない場合があるコンテナです。 Java 8では、場合によっては値がnullになる可能性のあるオブジェクトをより安全に処理する方法が提供されています。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt;と&lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scalaの&lt;/a&gt;アイデアから発想を得ています。</target>
        </trans-unit>
        <trans-unit id="b697deb5aa0b223e01560060b3cb1b1f61855b42" translate="yes" xml:space="preserve">
          <source>Just a sample:</source>
          <target state="translated">ただのサンプルです。</target>
        </trans-unit>
        <trans-unit id="e35fd4948c5a9357196b184cecdd55c2cc10c2d5" translate="yes" xml:space="preserve">
          <source>Just don't ever use null. Don't allow it.</source>
          <target state="translated">ただ、nullは絶対に使わないでください。許してはいけない</target>
        </trans-unit>
        <trans-unit id="e6f599b2f399715ad627af5bb0a6d5baae609bba" translate="yes" xml:space="preserve">
          <source>Last example using &lt;code&gt;@Nullable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@Nullable&lt;/code&gt; を使用した最後の例</target>
        </trans-unit>
        <trans-unit id="59402a00be4a0f11592ceaf67244cfe61d5bda51" translate="yes" xml:space="preserve">
          <source>Let's consider a method to get a reference of a service from a factory. Instead of returning the service reference, wrap it with Optional. It lets the API user know that the returned service may or may not available/functional, use defensively</source>
          <target state="translated">工場からサービスの参照を取得するメソッドを考えてみましょう。サービスの参照を返す代わりに、それを Optional でラップします。これにより、返されたサービスが利用可能かどうかを API ユーザーに知らせることができます。</target>
        </trans-unit>
        <trans-unit id="aabc2d3db3cef830d4da0377e4b7c5b1b3f518c5" translate="yes" xml:space="preserve">
          <source>May I answer it more generally!</source>
          <target state="translated">もっと大雑把に答えてもいいですか!?</target>
        </trans-unit>
        <trans-unit id="f433759684160d6db17bda40a8e075111a85c751" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;validate()&lt;/code&gt; will throw checked &lt;code&gt;ValidationException&lt;/code&gt; if any of the parameters is null (checked or unchecked is more a design/taste issue, but my &lt;code&gt;ValidationException&lt;/code&gt; is checked).</source>
          <target state="translated">メソッド &lt;code&gt;validate()&lt;/code&gt; は、パラメーターのいずれかがnullの場合、チェックされた &lt;code&gt;ValidationException&lt;/code&gt; をスローします（チェックまたはチェックされていない方がデザイン/味の問題ですが、私の &lt;code&gt;ValidationException&lt;/code&gt; はチェックされています）。</target>
        </trans-unit>
        <trans-unit id="3f01e85661d751c9b649b3a4ad66bff717bcfdf9" translate="yes" xml:space="preserve">
          <source>Most of the time null checks seem to guard loops over collections or arrays, so just initialise them empty, you won't need any null checks.</source>
          <target state="translated">ほとんどの場合、ヌルチェックはコレクションや配列のループをガードしているようなので、空に初期化すればヌルチェックは必要ありません。</target>
        </trans-unit>
        <trans-unit id="10245c94028cb40db8342e6e78c68de0822b9be5" translate="yes" xml:space="preserve">
          <source>Never initialise variables to null.</source>
          <target state="translated">変数を決してnullに初期化しないでください。</target>
        </trans-unit>
        <trans-unit id="92dc04e377ae99c8a6ebf3a5d7e85d43ee0f3ab3" translate="yes" xml:space="preserve">
          <source>Not checking if a variable is null before invoking an equals method (a string compare example below):</source>
          <target state="translated">Equalsメソッドを呼び出す前に変数がNULLかどうかをチェックしない(以下の文字列比較の例)。</target>
        </trans-unit>
        <trans-unit id="99556f0afc8bbece6b8c0e90382fe62b10f3db0b" translate="yes" xml:space="preserve">
          <source>Not using assertions in this case is OK because the code will just fail, which is what will happen if you use assertions.  The only difference is that with assertions it might happen sooner, in a more-meaningful way and possibly with extra information, which may help you to figure out why it happened if you weren't expecting it.</source>
          <target state="translated">この場合、アサーションを使用しなくてもコードは失敗するので問題ありません。唯一の違いは、アサーションを使用した場合には、より意味のある方法で、より早く、より意味のある方法で、そしておそらく余分な情報が含まれているかもしれないということです。</target>
        </trans-unit>
        <trans-unit id="176fa701c30ed80ae841f14d912217b3648526ea" translate="yes" xml:space="preserve">
          <source>Note that addParam() returns self, so that you can add more parameters to check.</source>
          <target state="translated">addParam()はselfを返すので、より多くのパラメータを追加してチェックすることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c7893143e601f4d7141dc682079d103f68d972b" translate="yes" xml:space="preserve">
          <source>Note that the accepted answer may be out of date, see &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; for a more recent approach.</source>
          <target state="translated">受け入れられた回答が古くなっている可能性があることに注意して&lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;ください&lt;/a&gt; 。最新のアプローチについては、 https：//stackoverflow.com/a/2386013/12943を参照してください 。</target>
        </trans-unit>
        <trans-unit id="08c509b05cd5ed1b8001a328275f057bb13241df" translate="yes" xml:space="preserve">
          <source>Now HomeServices.get() does same thing, but in a better way. It checks whether the service is already initialized of not. If it is then return the same or create a new New service. Optional&amp;lt;T&amp;gt;.orElse(T) helps to return a default value.</source>
          <target state="translated">現在、HomeServices.get（）は同じことを行いますが、より良い方法で行われます。 サービスがすでに初期化されているかどうかをチェックします。 場合は同じを返すか、新しい新しいサービスを作成します。 Optional &amp;lt;T&amp;gt; .orElse（T）は、デフォルト値を返すのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="243fc41a64042cfc5860b15fdd1a86b35656505b" translate="yes" xml:space="preserve">
          <source>Now look at this code where we search a list of &lt;code&gt;Fruit&lt;/code&gt; (&lt;code&gt;fruits&lt;/code&gt;) for a given Fruit instance:</source>
          <target state="translated">次に、特定のFruitインスタンスの &lt;code&gt;Fruit&lt;/code&gt; （ &lt;code&gt;fruits&lt;/code&gt; ）のリストを検索する次のコードを見てください。</target>
        </trans-unit>
        <trans-unit id="26b0fcf72724ae5ef092ca7b297d0d826206b5cb" translate="yes" xml:space="preserve">
          <source>Now the IntelliJ IDEA compiler will tell you that the check is useless, since the &lt;code&gt;helloWorld()&lt;/code&gt; function won't return &lt;code&gt;null&lt;/code&gt;, ever.</source>
          <target state="translated">&lt;code&gt;helloWorld()&lt;/code&gt; 関数は &lt;code&gt;null&lt;/code&gt; を返さないため、IntelliJ IDEAコンパイラはチェックが役に立たないことを通知します。</target>
        </trans-unit>
        <trans-unit id="cdc1b22c0d793a34bbcf4429fa3f1f90d9486b91" translate="yes" xml:space="preserve">
          <source>Now to the answer:</source>
          <target state="translated">さて、答えに行きましょう。</target>
        </trans-unit>
        <trans-unit id="2ea239f7f659ef1548e4d08d1e55d7c383740b1c" translate="yes" xml:space="preserve">
          <source>Now you can safely develop the core function of your method without needing to check input parameters, they guard your methods from unexpected parameters.</source>
          <target state="translated">これで、入力パラメータをチェックすることなく、安全にメソッドのコア関数を開発することができ、予期せぬパラメータからメソッドを守ります。</target>
        </trans-unit>
        <trans-unit id="edf43179ef58a381a95f2c17225fe5bf82d216c3" translate="yes" xml:space="preserve">
          <source>Null is not a 'problem'. It is an integral part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;complete&lt;/a&gt; modeling tool set. Software aims to model the complexity of the world and null bears its burden. &lt;strong&gt;Null indicates 'No data' or 'Unknown'&lt;/strong&gt; in Java and the like. So it is appropriate to use nulls for these purposes. I don't prefer the 'Null object' pattern; I think it rise the '&lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;who will guard
the guardians&lt;/a&gt;' problem.</source>
          <target state="translated">ヌルは「問題」ではありません。 これは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;完全な&lt;/a&gt;モデリングツールセットの不可欠な部分です。 ソフトウェアは世界の複雑さをモデル化することを目的としており、その負担はnullにあります。 &lt;strong&gt;nullは&lt;/strong&gt; 、Javaなどでは&lt;strong&gt;「データなし」または「不明」&lt;/strong&gt;を示します。 したがって、これらの目的にはnullを使用することが適切です。 「Nullオブジェクト」パターンは好みません。 「 &lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;誰が保護者を守るのか&lt;/a&gt; 」という問題が発生すると思います。</target>
        </trans-unit>
        <trans-unit id="29fec67aa38549dd5045b52d3829e32fb6b213cd" translate="yes" xml:space="preserve">
          <source>Of course &lt;code&gt;Optional&lt;/code&gt; could also be used as a method argument, perhaps a better way to indicate optional arguments than 5 or 10 overloading methods in some cases.</source>
          <target state="translated">もちろん、 &lt;code&gt;Optional&lt;/code&gt; メソッドの引数として使用することもできます。場合によっては、5または10のオーバーロードメソッドよりもオプションの引数を示すより良い方法です。</target>
        </trans-unit>
        <trans-unit id="4caa61cd647ca110cd57241ba6a32544f2821d80" translate="yes" xml:space="preserve">
          <source>Of course, experience is the better way to understand and apply this suggestion.</source>
          <target state="translated">もちろん、この提案を理解して応用するには、経験があった方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="1025ea9180532a8fb4fe82dbd19b0c29868734a2" translate="yes" xml:space="preserve">
          <source>Of course, the check for null/empty value is still necessary, but at least the developer is conscious that the value might be empty and the risk of forgetting to check is limited.</source>
          <target state="translated">もちろん、ヌルい値のチェックはまだ必要ですが、少なくとも開発者は「値が空になるかもしれない」という意識を持っているので、チェックを忘れてしまうリスクは限定的です。</target>
        </trans-unit>
        <trans-unit id="f9b45a3dc805fa3553c19beda43294e7e53857b2" translate="yes" xml:space="preserve">
          <source>Once I adopted this practice, I noticed that the problems seemed to fix themselves. You'd catch things much earlier in the development process just by accident and realize you had a weak spot..  and more importantly.. it helps encapsulate different modules' concerns, different modules can 'trust' each other, and no more littering the code with &lt;code&gt;if = null else&lt;/code&gt; constructs!</source>
          <target state="translated">この方法を採用してみると、問題が解決したように見えました。 開発プロセスのかなり早い段階で偶然に物事を把握し、弱点があることに気づくでしょう。そしてさらに重要なことに、これは、さまざまなモジュールの懸念をカプセル化するのに役立ち、さまざまなモジュールが互いに「信頼」でき、散らかす &lt;code&gt;if = null else&lt;/code&gt; 構成のコード！</target>
        </trans-unit>
        <trans-unit id="c50fca7276a877e4ddcc3641d754b50d96020d50" translate="yes" xml:space="preserve">
          <source>Once you have wrapped a reference object, Optional provides many useful methods to invoke methods on a wrapped reference without NPE.</source>
          <target state="translated">参照オブジェクトをラップしたら、Optional は、NPE を使用せずにラップされた参照上でメソッドを呼び出すための多くの便利なメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="72353b7bfc87776c765797b34857c518b0e8dcd9" translate="yes" xml:space="preserve">
          <source>Only for this situation -</source>
          <target state="translated">この状況のためだけに-。</target>
        </trans-unit>
        <trans-unit id="f657c8e08093a6452319f9c30f992b884323f041" translate="yes" xml:space="preserve">
          <source>Optional.ifPresent invokes the given Consumer with a reference if it is a non-null value. Otherwise, it does nothing.</source>
          <target state="translated">Optional.ifPresent は、指定された Consumer が非 null 値である場合、参照を使用して起動します。それ以外の場合は何もしません。</target>
        </trans-unit>
        <trans-unit id="6a132feaa88e9eaf93ca9f96a1e7df9448ce9003" translate="yes" xml:space="preserve">
          <source>Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.</source>
          <target state="translated">あるいは、トライキャッチのメカニズムがあまりにも醜いと思うならば、何もしないよりも、デフォルトのアクションがユーザーにフィードバックを提供すべきです。</target>
        </trans-unit>
        <trans-unit id="f766e2839d0e27333563fdfa4a7af0a22bd85132" translate="yes" xml:space="preserve">
          <source>Or in your example:</source>
          <target state="translated">あるいは、あなたの例では</target>
        </trans-unit>
        <trans-unit id="8d0c023e0356e1bab468181b4ff498742ae4781b" translate="yes" xml:space="preserve">
          <source>PPS. For those fast to downvote (and not so fast to read documentation) I would like to say that I've never caught a null-pointer exception (NPE) in my life. But this possibility was &lt;strong&gt;intentionally designed&lt;/strong&gt; by the Java creators because NPE is a subclass of &lt;code&gt;Exception&lt;/code&gt;. We have a precedent in Java history when &lt;code&gt;ThreadDeath&lt;/code&gt; is an &lt;code&gt;Error&lt;/code&gt; not because it is actually an application error, but solely because it was not intended to be caught! How much NPE fits to be an &lt;code&gt;Error&lt;/code&gt; than &lt;code&gt;ThreadDeath&lt;/code&gt;! But it is not.</source>
          <target state="translated">PPS。 投票に時間がかかる（ドキュメントを読むのが速くない）場合、私は人生でnullポインタ例外（NPE）を一度も受けたことがないと言いたいです。 ただし、NPEは &lt;code&gt;Exception&lt;/code&gt; のサブクラスであるため、この可能性はJava作成者が&lt;strong&gt;意図的に設計&lt;/strong&gt;したものです。 &lt;code&gt;ThreadDeath&lt;/code&gt; が &lt;code&gt;Error&lt;/code&gt; 場合、それが実際にアプリケーションエラーではなく、単にキャッチされることを意図していないため、Javaの歴史で先例があります。 どれだけのNPEが &lt;code&gt;ThreadDeath&lt;/code&gt; よりも &lt;code&gt;Error&lt;/code&gt; になるのに適しています！ そうではありません。</target>
        </trans-unit>
        <trans-unit id="9ee03b92c278aefd505b6e54e78c9dc0b157ad7a" translate="yes" xml:space="preserve">
          <source>PS. This approach will be as reasonable to use as the &lt;em&gt;separate error-handling code from &quot;regular&quot; code&lt;/em&gt; principle is reasonable to use in some place. Consider the next example:</source>
          <target state="translated">PS。 このアプローチは&lt;em&gt;、「通常の」コードの&lt;/em&gt;原則とは&lt;em&gt;別のエラー処理コード&lt;/em&gt;をどこかで使用するのが妥当であるため、使用するのが妥当です。 次の例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="ba90388bd4c171ca39fa6b73261783e63a2f28b2" translate="yes" xml:space="preserve">
          <source>Previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library.</source>
          <target state="translated">Previousは、私のフォトライブラリから存在しない彼女の写真を取得するための通常のロジックの流れにつながります。</target>
        </trans-unit>
        <trans-unit id="8f2b4864d43e2c92095e649bd1429a2c05d7ab61" translate="yes" xml:space="preserve">
          <source>Probably the best alternative for Java 8 or newer is to use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">おそらく、Java 8以降の最良の代替手段は、 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;クラスを使用することです。</target>
        </trans-unit>
        <trans-unit id="18ac346b6a23f38378a9759b924291326484c819" translate="yes" xml:space="preserve">
          <source>Q. Redundant code could be executed and unnecessary resources could be grabbed.</source>
          <target state="translated">Q.冗長なコードを実行してしまい、不要なリソースを掴まれてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="60f3d300f344070bb3660651b4b7c84a7c1a7806" translate="yes" xml:space="preserve">
          <source>Q. This approach has a performance penalty due to the try closure opening.</source>
          <target state="translated">Q.このアプローチは、トライ閉鎖のオープニングのため、パフォーマンスペナルティがあります。</target>
        </trans-unit>
        <trans-unit id="8ada7432c9d8ed60d8ddcb07057e3aa21a1cd988" translate="yes" xml:space="preserve">
          <source>Q. What if &lt;code&gt;getPhotoDataSource()&lt;/code&gt; returns null?</source>
          <target state="translated">Q. &lt;code&gt;getPhotoDataSource()&lt;/code&gt; がnullを返した場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="b0f21ff390c71b63fb33e4cf5b2e9b8e9cc3013f" translate="yes" xml:space="preserve">
          <source>Questions could arise:</source>
          <target state="translated">疑問が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0c25c125f68f171e56c5dc46a5e78dbdc73323ed" translate="yes" xml:space="preserve">
          <source>Rather than Null Object Pattern -- which has its uses -- you might consider situations where the null object is a bug.</source>
          <target state="translated">ヌルオブジェクトパターン --用途がある --よりも、ヌルオブジェクトがバグになっている状況を考えてみてはいかがでしょうか。</target>
        </trans-unit>
        <trans-unit id="4e1c9630619b3a985eea9596a353ce64e0b8e71b" translate="yes" xml:space="preserve">
          <source>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.
It is so clean and easy to understand. In the above code example, &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; gets invoked if the Optional holding reference is non-null.</source>
          <target state="translated">単一の入力引数を受け入れ、結果を返さない操作を表します。 他のほとんどの機能インターフェースとは異なり、コンシューマは副作用を介して動作することが期待されています。 とてもきれいでわかりやすいです。 上記のコード例では、Optional保持参照がnullでない場合、 &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9951bd4cc66be1c5bf9d684cb3738fbaaf27a9b2" translate="yes" xml:space="preserve">
          <source>SO HOW EXACTLY IT HELPS TO AVOID A NULL CHECK?</source>
          <target state="translated">では、具体的にどのようにしてヌルチェックを避けることができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="12ebfd30869dc6d7d284fbd49560456e553ae1a4" translate="yes" xml:space="preserve">
          <source>See blog post &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;More flexible and configurable @Nullable/@NotNull annotations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">ブログ投稿を参照&lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;より柔軟で構成可能な@ Nullable / @ NotNullアノテーション&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c614bff3bcea0ba91a4e4fc674cacfdf5b3e3421" translate="yes" xml:space="preserve">
          <source>So I branch, and do two completely different things. There is no ugly code snippet, because I really need to do two different things depending on the data. For example, should I work on the input, or should I calculate a good default value?</source>
          <target state="translated">だから私はブランチして、2つの全く異なることを行います。私は本当にデータに応じて2つの異なることを行う必要があるので、醜いコードスニペットはありません。例えば、私は入力に取り組むべきか、それとも良いデフォルト値を計算するべきか?</target>
        </trans-unit>
        <trans-unit id="ab095d82204599c2467871a3efe97685e021b767" translate="yes" xml:space="preserve">
          <source>So there is no difference between:</source>
          <target state="translated">の間には違いがないということですね。</target>
        </trans-unit>
        <trans-unit id="3832db2f40c93881b178af60f45fd152a79ed806" translate="yes" xml:space="preserve">
          <source>So, IMHO, null must be a critical error which prevents further execution (that is, where null is not a valid value).</source>
          <target state="translated">ですから、IMHOでは、nullはそれ以上の実行を妨げる致命的なエラーでなければなりません(つまり、nullが有効な値ではない場合)。</target>
        </trans-unit>
        <trans-unit id="91316cbc500c43d5b77c2b413a3f65b2f65958c8" translate="yes" xml:space="preserve">
          <source>Sometimes, you have methods that operate on its parameters that define a symmetric operation:</source>
          <target state="translated">時には、対称的な操作を定義するパラメータで操作するメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="b8ca7bcd4b5f1acf3e5ba33e4a5f508dec7dea54" translate="yes" xml:space="preserve">
          <source>Sure do have a look at Aspect Oriented Programming, too - they have neat ways to insert &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; into your bytecode.</source>
          <target state="translated">もちろんアスペクト指向プログラミングも見てください &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; をバイトコードに挿入するための素晴らしい方法があります。</target>
        </trans-unit>
        <trans-unit id="6f4cfb67cdd3b5f824a9934a1ed6c1fca9c1fc27" translate="yes" xml:space="preserve">
          <source>That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.</source>
          <target state="translated">とはいえ、おそらく findAction()メソッドが意味のあるエラーメッセージとともに例外をスローするのは完全に適切なことでしょう --特にユーザーの入力に依存しているこのケースでは。呼び出したメソッドが何の説明もなく単純な NullPointerException で爆発するよりも、findAction メソッドが例外を投げる方がずっと良いでしょう。</target>
        </trans-unit>
        <trans-unit id="7047d7ff31541da135908e8ecd7f812faea65471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?.&lt;/code&gt; means only de-reference the left identifier if it is not null, otherwise evaluate the remainder of the expression as &lt;code&gt;null&lt;/code&gt;. Some people, like Java Posse member Dick Wall and the &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;voters at Devoxx&lt;/a&gt; really love this proposal, but there is opposition too, on the grounds that it will actually encourage more use of &lt;code&gt;null&lt;/code&gt; as a sentinel value.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 左識別子がnullでない場合のみ逆参照することを意味し &lt;code&gt;null&lt;/code&gt; 。それ以外の場合は、式の残りの部分をnullとして評価します 。 Java PosseのメンバーであるDick Wallや&lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;Devoxx&lt;/a&gt;の有権者など、一部の人々はこの提案を本当に気に入ってい &lt;code&gt;null&lt;/code&gt; が、センチネル値としてのnullの使用を実際に奨励するという理由で反対もあります。</target>
        </trans-unit>
        <trans-unit id="78bbb74ffaaf0217ff4697c6fb561008da9384db" translate="yes" xml:space="preserve">
          <source>The Google collections framework offers a good and elegant way to achieve the null check.</source>
          <target state="translated">Google のコレクションフレームワークは、ヌルチェックを実現するための優れたエレガントな方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="1d0b369ef777f99443515fd98b70d6cbe6356789" translate="yes" xml:space="preserve">
          <source>The StringUtils class is only one of many; there are quite a few good classes in the commons that do null safe manipulation.</source>
          <target state="translated">StringUtils クラスは数あるクラスのうちの一つに過ぎません。</target>
        </trans-unit>
        <trans-unit id="b3066493bcd46f61316ddaca0d5573d18b01f7cd" translate="yes" xml:space="preserve">
          <source>The compiler forces you to handle the &quot;undefined&quot; case.</source>
          <target state="translated">コンパイラは「未定義」の場合を強制的に処理します。</target>
        </trans-unit>
        <trans-unit id="11db0d52c7259e3f5542cc11ae35ecc39a7f84be" translate="yes" xml:space="preserve">
          <source>The complete post is &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE as well as Null check-free code &amp;hellip; Really?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">完全な投稿は&lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPEとNullチェックフリーコードです&amp;hellip;本当に？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f36738048a72c2ff14555a1f49f971e924f9660" translate="yes" xml:space="preserve">
          <source>The contracts are like mini-unit tests which are always running, even in production, and when things fail, you know why, rather than a random NPE you have to somehow figure out.</source>
          <target state="translated">契約は、本番でも常に実行されているミニユニットテストのようなもので、物事が失敗したときに、その理由を知ることができます。</target>
        </trans-unit>
        <trans-unit id="8b07fde497d833a3dea4d5d1623ff04bff7cd150" translate="yes" xml:space="preserve">
          <source>The example given by Alex Miller looks like this:</source>
          <target state="translated">アレックス・ミラーが与えた例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="6b1e5e00880fd770c374b1874c5898efc9b29533" translate="yes" xml:space="preserve">
          <source>The message will contain the following text if, for example, &quot;plans&quot; is null:</source>
          <target state="translated">メッセージには、例えば &quot;plans &quot;がnullの場合、以下のようなテキストが含まれます。</target>
        </trans-unit>
        <trans-unit id="50acd96098203094b440f2ee9754742ef52b2da0" translate="yes" xml:space="preserve">
          <source>The method is most useful for &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;checking&lt;/a&gt; just before an assignment in a constructor, where each use of it can save three lines of code:</source>
          <target state="translated">このメソッドは、コンストラクタでの割り当ての直前を&lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;チェックする&lt;/a&gt;場合に最も役立ちます。このメソッドを使用するたびに、3行のコードを節約できます。</target>
        </trans-unit>
        <trans-unit id="e93d133895627c9a3d74a6c30e204dcdb8e532ac" translate="yes" xml:space="preserve">
          <source>The only other methods which do not check for null are utility methods. They are public, but if you call them for some reason, you know what parameters you pass. This is like trying to boil water in the kettle without providing water...</source>
          <target state="translated">null をチェックしないメソッドはユーティリティーメソッドだけです。これらのメソッドは公開されていますが、何らかの理由で呼び出した場合、どのようなパラメータを渡したかがわかります。これは、水を提供せずにやかんでお湯を沸かそうとしているようなものです...。</target>
        </trans-unit>
        <trans-unit id="3071661bc3a8f3f1fb050d846047c85545570484" translate="yes" xml:space="preserve">
          <source>The second example won't compile (in IntelliJ IDEA).</source>
          <target state="translated">2つ目の例では、(IntelliJ IDEAでは)コンパイルできません。</target>
        </trans-unit>
        <trans-unit id="d6530e4dc64d23e3133b0d5fd801c0b069e04e94" translate="yes" xml:space="preserve">
          <source>The way I solve this problem is this:</source>
          <target state="translated">私がこの問題を解決する方法はこれです。</target>
        </trans-unit>
        <trans-unit id="8b0438900bb10b9989752d1f3c4b40b7f47f6df7" translate="yes" xml:space="preserve">
          <source>Then, in the rest of that method, you'll know that &lt;code&gt;object&lt;/code&gt; is not null.</source>
          <target state="translated">次に、そのメソッドの残りの部分では、 &lt;code&gt;object&lt;/code&gt; がnullではないことがわかります。</target>
        </trans-unit>
        <trans-unit id="79a6826b25f58343482759c32d1843c3fcfde425" translate="yes" xml:space="preserve">
          <source>There is a method in a library class like this:</source>
          <target state="translated">ライブラリクラスにはこんなメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="7b611806237c884a66462ab8d01c1db4a0455d83" translate="yes" xml:space="preserve">
          <source>There is a proposal to add new annotations in Java7 to help with null / notnull params:
&lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</source>
          <target state="translated">null / notnullパラメータを支援するためにJava7に新しい注釈を追加する提案があります： &lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http&lt;/a&gt; ://tech.puredanger.com/java7/#jsr308</target>
        </trans-unit>
        <trans-unit id="bdcc90e0f67eeda9f92fa7029efb8f80e4f6cda3" translate="yes" xml:space="preserve">
          <source>There is a tiny overhead in this, but it's worth it for cleaner code and less NullPointerExceptions.</source>
          <target state="translated">これにはわずかなオーバーヘッドがありますが、コードをきれいにして NullPointerExceptions を減らすためには価値があります。</target>
        </trans-unit>
        <trans-unit id="a995a0c78ad44e2ea78fecf0b6b5ae088210dbfb" translate="yes" xml:space="preserve">
          <source>They both want to make sure that we received valid parameters, before we do any other functions.</source>
          <target state="translated">どちらも、他の関数を実行する前に、有効なパラメータを受け取ったことを確認したいと考えています。</target>
        </trans-unit>
        <trans-unit id="0de62a4c684b4be885c335e3c1f969aeb6ca39e3" translate="yes" xml:space="preserve">
          <source>They work like that:</source>
          <target state="translated">そんな感じで働いてくれています。</target>
        </trans-unit>
        <trans-unit id="6da291a4214849ad22b47d77f7b9e5c7c2ed3dbb" translate="yes" xml:space="preserve">
          <source>This checks for a &lt;code&gt;NullPointerException&lt;/code&gt; for the &lt;code&gt;someobject&lt;/code&gt; object in the above snippet.</source>
          <target state="translated">これにより、上記のスニペットの &lt;code&gt;someobject&lt;/code&gt; オブジェクトの &lt;code&gt;NullPointerException&lt;/code&gt; がチェックされます。</target>
        </trans-unit>
        <trans-unit id="a632edab67a162af8d6236e911205c0bd2945507" translate="yes" xml:space="preserve">
          <source>This is a very common problem for every Java developer. So there is official support in Java&amp;nbsp;8 to address these issues without cluttered code.</source>
          <target state="translated">これは、すべてのJava開発者にとって非常に一般的な問題です。 したがって、Java 8には、コードを雑然とせずにこれらの問題に対処するための公式サポートがあります。</target>
        </trans-unit>
        <trans-unit id="63475a15e2d7175b43a8eb4ced243071760761e7" translate="yes" xml:space="preserve">
          <source>This is defensive programming and results in much cleaner code in the long run. Always sanitize the data, e.g. here by enforcing rigid standards, and the problems go away.</source>
          <target state="translated">これは防御的なプログラミングであり、長い目で見ればコードをよりクリーンにすることができます。厳格な基準を適用することで、例えばここでは常にデータをサニタイズし、問題を解決します。</target>
        </trans-unit>
        <trans-unit id="96855dbf651af7ee23c0764f0f76d95841159676" translate="yes" xml:space="preserve">
          <source>This is especially handy for long chains of possible null values. Example:</source>
          <target state="translated">これは、可能性のあるヌル値の長いチェーンの場合に特に便利です。例</target>
        </trans-unit>
        <trans-unit id="ab20b6e950b963a0a9153b9bd523a03c124b9ceb" translate="yes" xml:space="preserve">
          <source>This is slightly better than:</source>
          <target state="translated">よりは若干マシです。</target>
        </trans-unit>
        <trans-unit id="4f0f6bf669b0e6c235196e52c58820b609d7a7a9" translate="yes" xml:space="preserve">
          <source>This is the most common error occurred for most of the developers.</source>
          <target state="translated">これは、ほとんどの開発者に共通して発生したエラーです。</target>
        </trans-unit>
        <trans-unit id="2c2ef7f8c0c5f5953f9d8dc9f87238113a866d47" translate="yes" xml:space="preserve">
          <source>This really depends. If find that I often do something like this:</source>
          <target state="translated">これは本当に次第です。私はしばしばこのようなことをすることを発見した場合。</target>
        </trans-unit>
        <trans-unit id="5f65d63d47b93827d172b66566e2699ba53e9246" translate="yes" xml:space="preserve">
          <source>This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don't know or don't trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.</source>
          <target state="translated">これは、ジュニアから中級者の開発者がどこかの時点で直面する傾向がある、合理的に一般的な問題のように思えます。さらに、自分たちのコードを書くときに、何かを示すためにnullを返すことに頼りがちで、呼び出し側にnullをチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="d66c4aae334386fa18d2bf51fc0dd0e22c5fcd02" translate="yes" xml:space="preserve">
          <source>This way, the code is clean, easy maintainable and readable.</source>
          <target state="translated">こうすることで、コードがきれいでメンテナンスがしやすく、読みやすいものになります。</target>
        </trans-unit>
        <trans-unit id="88e9d9f0b01df7bd366fd6f414813582c76c2a26" translate="yes" xml:space="preserve">
          <source>This won't compile.</source>
          <target state="translated">これではコンパイルできません。</target>
        </trans-unit>
        <trans-unit id="03a1146d56211c08b24efbc23fe64db2a1fe9e19" translate="yes" xml:space="preserve">
          <source>To implement this pattern in java, you can use core java annotations like &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; or use more sophisticated libraries like &lt;strong&gt;Hibernate Validator&lt;/strong&gt;.</source>
          <target state="translated">このパターンをJavaに実装するには、 &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt;などのコアJavaアノテーションを使用するか、 &lt;strong&gt;Hibernate Validator&lt;/strong&gt;などのより高度なライブラリを使用できます。</target>
        </trans-unit>
        <trans-unit id="65dd044ab70d140d1269ad7b58d585a319cf8c8e" translate="yes" xml:space="preserve">
          <source>To put this another way, there are two instances where null checking comes up:</source>
          <target state="translated">別の言い方をすると、ヌルチェックが出てくるのは2つの場合です。</target>
        </trans-unit>
        <trans-unit id="893faf3275f29660c0345c697429903da97cca3c" translate="yes" xml:space="preserve">
          <source>Try to make all your attributes and its accessors as private as possible or avoid to  expose them to the clients at all. You can have the argument values in the constructor of course, but by reducing the scope you don't let the client class pass an invalid value. If you need to modify the values, you can always create a new &lt;code&gt;object&lt;/code&gt;.  You check the values in the constructor only &lt;strong&gt;once&lt;/strong&gt; and in the rest of the methods you can be almost sure that the values are not null.</source>
          <target state="translated">すべての属性とそのアクセサーをできるだけプライベートにするか、クライアントに公開しないようにしてください。 もちろん、コンストラクターで引数の値を持つことができますが、スコープを縮小することで、クライアントクラスに無効な値を渡させません。 値を変更する必要がある場合は、いつでも新しい &lt;code&gt;object&lt;/code&gt; 作成できます 。 コンストラクタで値を確認するのは&lt;strong&gt;1回&lt;/strong&gt;だけで、残りのメソッドでは値がnullでないことをほぼ確認できます。</target>
        </trans-unit>
        <trans-unit id="5096108c9ee2936b6660a55e9c083bcd59532700" translate="yes" xml:space="preserve">
          <source>Ultimately, the only way to completely solve this problem is by using a different programming language:</source>
          <target state="translated">最終的には、この問題を完全に解決する唯一の方法は、別のプログラミング言語を使用することです。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="91e3b61c16f5d43c2c292405b4146327e9221a06" translate="yes" xml:space="preserve">
          <source>Using parameter</source>
          <target state="translated">パラメータの使用</target>
        </trans-unit>
        <trans-unit id="410ecb47e87fed6b528cde0e827e193125ef8e2c" translate="yes" xml:space="preserve">
          <source>WRAPPING TO OPTION&amp;lt;T&amp;gt;</source>
          <target state="translated">オプションへの折り返し&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16139730df851e7de2b4d9ecb2a4976efb2493cf" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;usually&lt;/strong&gt; face this issue when the methods get the parameters in the way we not expected (bad method call is programmer's fault). For example: you expect to get an object, instead you get a null. You expect to get an String with at least one character, instead you get an empty String ...</source>
          <target state="translated">&lt;strong&gt;通常&lt;/strong&gt; 、メソッドが予期しない方法でパラメーターを取得すると、この問題に直面します（悪いメソッド呼び出しはプログラマーの責任です）。 たとえば、オブジェクトを取得することを期待し、代わりにnullを取得します。 あなたは少なくとも1文字の文字列を取得することを期待していますが、代わりに空の文字列を取得します...</target>
        </trans-unit>
        <trans-unit id="81d7e415e730d427573e6b4ff607e889a2cb73ec" translate="yes" xml:space="preserve">
          <source>We have number of ways to handle this.</source>
          <target state="translated">対応方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="0f598db2507984034e96ef0808dfe220b74dab82" translate="yes" xml:space="preserve">
          <source>We use the ternary operator very often for checking null condition and return an alternative value or default value. Optional provides another way to handle the same condition without checking null. Optional.orElse(defaultObj) returns defaultObj if the Optional has a null value. Let's use this in our sample code:</source>
          <target state="translated">null 条件をチェックして代替値やデフォルト値を返す場合には、三項演算子をよく使用します。Optionalは、NULLをチェックせずに同じ条件を処理する別の方法を提供します。Optional.orElse(defaultObj)は、Optional が NULL 値を持つ場合に defaultObj を返します。サンプルコードでこれを使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="1b7de74b75d773507feae3e01547f3abd8a8e794" translate="yes" xml:space="preserve">
          <source>When the exception is thrown, examine the stack trace and work through the bug.</source>
          <target state="translated">例外が発生した場合は、スタックトレースを調べてバグを修正します。</target>
        </trans-unit>
        <trans-unit id="56f60bd1b035c1637de885e8364d676ed25dd3d5" translate="yes" xml:space="preserve">
          <source>When you use the first &lt;code&gt;helloWorld()&lt;/code&gt; function in another piece of code:</source>
          <target state="translated">別のコードで最初の &lt;code&gt;helloWorld()&lt;/code&gt; 関数を使用する場合：</target>
        </trans-unit>
        <trans-unit id="79b6177f112f6c351c671521cc708abf0dbc2ef4" translate="yes" xml:space="preserve">
          <source>Where it isn't a valid response.</source>
          <target state="translated">有効な回答になっていないところで</target>
        </trans-unit>
        <trans-unit id="35c99b0c8fc1f9ea3f573be119257028ced0e610" translate="yes" xml:space="preserve">
          <source>Where null is a valid response in terms of the contract; and</source>
          <target state="translated">nullが契約上の有効な応答である場合。</target>
        </trans-unit>
        <trans-unit id="cdfe105c8bfbcc3b13ac6840fef58d8c1666a5a4" translate="yes" xml:space="preserve">
          <source>While it is rather 'normal business flow' not to find photo stored into the DB for some person, I used to use pairs like below for some other cases</source>
          <target state="translated">DBに保存されている写真の中から、ある人の写真を見つけられないのは「普通の業務フロー」ですが、それ以外のケースでは以下のようなペアを使用していました。</target>
        </trans-unit>
        <trans-unit id="580ecabb6906d2e8e175eeee96c8cd0b5d5e79e0" translate="yes" xml:space="preserve">
          <source>With Java 8 comes the new &lt;code&gt;java.util.Optional&lt;/code&gt; class that arguably solves some of the problem. One can at least say that it improves the readability of the code, and in the case of public APIs make the API's contract clearer to the client developer.</source>
          <target state="translated">Java 8には、問題の一部を間違いなく解決する新しい &lt;code&gt;java.util.Optional&lt;/code&gt; クラスが付属しています。 少なくともコードの可読性が向上すると言うことができ、パブリックAPIの場合、クライアント開発者にとってAPIの契約をより明確にします。</target>
        </trans-unit>
        <trans-unit id="2f3836243579dcf0aab46f92bd120d19df8df941" translate="yes" xml:space="preserve">
          <source>With non-collections it might be harder.  Consider this as an example: if you have these interfaces:</source>
          <target state="translated">非コレクションの場合は難しいかもしれません。例えば、以下のようなインターフェイスがある場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a5b1abb2eabdd6b338fefcfe915a795e0025f2b9" translate="yes" xml:space="preserve">
          <source>Wow, I almost hate to add another answer when we have 57 different ways to recommend the &lt;code&gt;NullObject pattern&lt;/code&gt;, but I think that some people interested in this question may like to know that there is a proposal on the table for Java 7 to add &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;null-safe handling&quot;&lt;/a&gt;&amp;mdash;a streamlined syntax for if-not-equal-null logic.</source>
          <target state="translated">うわー、 &lt;code&gt;NullObject pattern&lt;/code&gt; を推奨する57の異なる方法がある場合、別の答えを追加するのはほとんど嫌ですが、この質問に興味のある人は、Java 7のテーブルに&lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;「null」&lt;/a&gt;を追加する提案があることを知りたいと思うかもしれません。 セーフハンドリング」-if -not-equal-nullロジックの合理化された構文。</target>
        </trans-unit>
        <trans-unit id="951af1231b6d7d7d241620882f25427c99d9e5db" translate="yes" xml:space="preserve">
          <source>You can avoid that if you compare your &lt;code&gt;String&lt;/code&gt;s like this:</source>
          <target state="translated">次のように &lt;code&gt;String&lt;/code&gt; を比較すると、それを回避できます。</target>
        </trans-unit>
        <trans-unit id="c7f4edd11fb336e0c393189054436b5ea0dd3965" translate="yes" xml:space="preserve">
          <source>You can go a step further and make sure that only valid pojos could be created in your application. (sample from hibernate validator site)</source>
          <target state="translated">さらに一歩進んで、アプリケーション内で有効な pojos だけが作成できるようにすることもできます。(サンプルは hibernate バリデータのサイトから)</target>
        </trans-unit>
        <trans-unit id="b426fa3dff81bdf8322ce5f08dc73d3a6c054889" translate="yes" xml:space="preserve">
          <source>You can use in method and parameters, like this:</source>
          <target state="translated">こんな感じで、メソッドやパラメータで使うことができます。</target>
        </trans-unit>
        <trans-unit id="f52d6127cbef2caa2515fee8335a6cf4b50a3ecc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map()&lt;/code&gt; operator to perform a computation on--or extract a value from--an optional object.  &lt;code&gt;orElse()&lt;/code&gt; lets you provide a fallback for missing values.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 演算子を使用して、オプションのオブジェクトに対して計算を実行したり、オプションのオブジェクトから値を抽出したりできます。 &lt;code&gt;orElse()&lt;/code&gt; を使用すると、欠損値のフォールバックを提供できます。</target>
        </trans-unit>
        <trans-unit id="1d33b9baf8ae290074a6e9952500c20b8c202dd6" translate="yes" xml:space="preserve">
          <source>You have to check for object != null only if you want to handle the case where the object may be null...</source>
          <target state="translated">オブジェクトがnullになる可能性がある場合にのみ、object !=nullをチェックする必要があります...。</target>
        </trans-unit>
        <trans-unit id="5146850a0aff4c1b7d4e622f1b93cada470ef71b" translate="yes" xml:space="preserve">
          <source>You might configure your IDE to warn you about potential null dereferencing. E.g. in Eclipse, see &lt;em&gt;Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors/Warnings/Null analysis&lt;/em&gt;.</source>
          <target state="translated">IDEを構成して、null逆参照の可能性について警告することができます。 たとえば、Eclipseの場合は、 &lt;em&gt;[設定]&amp;gt; [Java]&amp;gt; [コンパイラ]&amp;gt; [エラー/警告/ Null分析]を&lt;/em&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4f4a16be11579dd7183f0b53dba9326d6fee7a45" translate="yes" xml:space="preserve">
          <source>allow the Exceptions to ripple through - catch them at the 'main loop' or in some other managing routine.</source>
          <target state="translated">例外が波及するようにします。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a91d8763ddd012bd694861a83ced3c22ba85ef5a" translate="yes" xml:space="preserve">
          <source>check for error conditions and handle them appropriately</source>
          <target state="translated">エラー状態をチェックして適切に処理する</target>
        </trans-unit>
        <trans-unit id="242af77b8af1f9f1f76f01852e12bf007ce5565b" translate="yes" xml:space="preserve">
          <source>if you write something like:</source>
          <target state="translated">みたいなことを書くと</target>
        </trans-unit>
        <trans-unit id="37b00e27e7160b5c20659252018b000c5884b58a" translate="yes" xml:space="preserve">
          <source>notNull(Object object, String message)</source>
          <target state="translated">notNull(Object object,String message)</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7f59b1d21b6092bc9549f5f4ed93ec595233ec73" translate="yes" xml:space="preserve">
          <source>or (depending on what you need to check):</source>
          <target state="translated">または(確認すべきことに応じて)。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="8175c105a4fbc0c1bfbecc0778b58cf2689a03e3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; is a boolean expression and &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; is an object whose &lt;code&gt;toString()&lt;/code&gt; method's output will be included in the error.</source>
          <target state="translated">ここで、 &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; はブール式、 &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; は &lt;code&gt;toString()&lt;/code&gt; メソッドの出力がエラーに含まれるオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="66933b5352b59bac31f84234608a5d23ea089515" translate="yes" xml:space="preserve">
          <source>where Parser takes raw user input and finds something to do, perhaps if you're implementing a command line interface for something.  Now you might make the contract that it returns null if there's no appropriate action.  That leads the null checking you're talking about.</source>
          <target state="translated">ここで、パーサーは生のユーザ入力を受け取り、何かをするためのコマンドラインインターフェースを実装している場合、何かを見つけます。適切なアクションがない場合、NULLを返すという契約をするかもしれません。これはあなたが話しているNULLチェックを導きます。</target>
        </trans-unit>
        <trans-unit id="880c9234e5994e5388ead855bf7ee74adb695efb" translate="yes" xml:space="preserve">
          <source>which is a much better design because it leads to more concise code.</source>
          <target state="translated">これは、より簡潔なコードにつながるので、はるかに優れたデザインです。</target>
        </trans-unit>
        <trans-unit id="85d0952dedf1cf905b6bd07f33e02911381c8fd1" translate="yes" xml:space="preserve">
          <source>will result in a &lt;code&gt;NullPointerException&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; doesn't exist.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; が存在しない場合、 &lt;code&gt;NullPointerException&lt;/code&gt; が発生します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
