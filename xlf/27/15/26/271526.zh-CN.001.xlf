<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/271526">
    <body>
      <group id="271526">
        <trans-unit id="8c66c64b2bf5dce0f66d6a803ea6b6b85f2bd101" translate="yes" xml:space="preserve">
          <source>&quot;&lt;strong&gt;Illegal argument value null is encountered for parameter [plans]&lt;/strong&gt;&quot;</source>
          <target state="translated">&amp;ldquo; &lt;strong&gt;参数[plans]遇到非法的参数值null&lt;/strong&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3203cd5f2dfad1b7f4c9811b531d23931fbb7a62" translate="yes" xml:space="preserve">
          <source>(1) is a little harder.  If you have no control over the code you're calling then you're stuck.  If null is a valid response, you have to check for it.</source>
          <target state="translated">(1)是有点难。如果你无法控制你所调用的代码,那么你就卡住了。如果null是一个有效的响应,你必须检查它。</target>
        </trans-unit>
        <trans-unit id="a072e9edaf03771b557f7cc2e3b70299591cad35" translate="yes" xml:space="preserve">
          <source>(2) is easy.  Either use &lt;code&gt;assert&lt;/code&gt; statements (assertions) or allow failure (for example,  &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt;).  Assertions are a highly-underused Java feature that was added in 1.4.  The syntax is:</source>
          <target state="translated">（2）容易。 使用 &lt;code&gt;assert&lt;/code&gt; 语句（断言）或允许失败（例如&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt; ）。 断言是1.4中新增的一个未被充分利用的Java功能。 语法为：</target>
        </trans-unit>
        <trans-unit id="69704da627fa56fa83a9194ab8bb332a79074ac1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option is a monad&lt;/a&gt;, so there is no need for verbose null checking, just use map/foreach/getOrElse or a similar combinator to safely use the value &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(example)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option是monad&lt;/a&gt; ，因此不需要冗长的null检查，只需使用map / foreach / getOrElse或类似的组合器即可安全地使用该值&lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;（示例）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="46cc192e40835e83a2ea87cb1bc5d7df3ef20578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt; is a &lt;em&gt;Runtime exception&lt;/em&gt; that means it's developers fault and with enough experience it tells you exactly where is the error.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; 是&lt;em&gt;运行时异常&lt;/em&gt; ，这意味着它是开发人员的错误，并且有足够的经验，它可以告诉您错误的确切位置。</target>
        </trans-unit>
        <trans-unit id="31c3bcb907f016d87b77fd8396afc5c0a9d646b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is a way of replacing a nullable T reference with a
  non-null value. An Optional may either contain a non-null T reference
  (in which case we say the reference is &quot;present&quot;), or it may contain
  nothing (in which case we say the reference is &quot;absent&quot;). It is never
  said to &quot;contain null.&quot;</source>
          <target state="translated">&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; 是用非空值替换可空T引用的一种方法。 Optional可以包含非null T引用（在这种情况下，我们称该引用为&amp;ldquo;存在&amp;rdquo;），也可以不包含任何内容（在这种情况下，我们称该引用为&amp;ldquo;不存在&amp;rdquo;）。 从来没有说过&amp;ldquo;包含null&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="795a75979fcb8e946ecd45684159328ee5bf5b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&lt;/code&gt; offers other convenient methods, such as &lt;code&gt;orElse&lt;/code&gt; that allow the use of a default value, and &lt;code&gt;ifPresent&lt;/code&gt; that works with &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Optional&lt;/code&gt; 提供了其他方便的方法，例如 &lt;code&gt;orElse&lt;/code&gt; （允许使用默认值）以及 &lt;code&gt;ifPresent&lt;/code&gt; (与&lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda表达式一起使用）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="556c1089ee2ae80da8a26a4b08cfdc720295a1b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you have to deal with an API which might return nulls&lt;/em&gt;, you can't do much in Java. Xtend and Groovy have the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; and the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;null-safe dereference operator&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt;, but note that this returns null in case of a null reference, so it just &quot;defers&quot; the proper handling of null.</source>
          <target state="translated">&lt;em&gt;如果必须处理可能返回null的API，&lt;/em&gt;则在Java中不能做太多事情。 Xtend和Groovy具有&lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis运算符&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 和&lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;空安全解除引用运算符&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; ，但是请注意，如果引用为null，则返回null，因此它只是&amp;ldquo;推迟&amp;rdquo;了null的正确处理。</target>
        </trans-unit>
        <trans-unit id="d1609ca504bef341cd938af5cc5c00b4d319ceb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to define a new API where undefined values make sense&lt;/em&gt;, use the &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Option Pattern&lt;/a&gt; (may be familiar from functional languages). It has the following advantages:</source>
          <target state="translated">&lt;em&gt;如果您想定义有意义的新API&lt;/em&gt; ，请使用&lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Option Pattern&lt;/a&gt; （功能语言可能很熟悉）。 具有以下优点：</target>
        </trans-unit>
        <trans-unit id="9e6ce6480f1f89172e257cc33912ba94b061ffa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; An &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;official proposal&lt;/a&gt; for a null-safe operator in Java 7 has been submitted under &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; The syntax is a little different than the example above, but it's the same notion.</source>
          <target state="translated">&lt;em&gt;更新：&lt;/em&gt;在&lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin&lt;/a&gt;下已提交了有关Java 7中的空安全运算符的&lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;正式建议&lt;/a&gt; 。 语法与上面的示例略有不同，但是是相同的概念。</target>
        </trans-unit>
        <trans-unit id="d03cf75fd803a5cd91e6e06263f455b21a109fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; The null-safe operator proposal didn't make it into Project Coin. So, you won't be seeing this syntax in Java 7.</source>
          <target state="translated">&lt;em&gt;更新：&lt;/em&gt;空安全运算符建议未纳入Project Coin。 因此，您不会在Java 7中看到此语法。</target>
        </trans-unit>
        <trans-unit id="7e57dd158da7749eeb4adc7330e0e7f8c7be6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法1：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a45037cfed52a95964a4b6663009985c519b3729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法二：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b038e1f7a0e785f507e502bb3ed742df87515a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法3：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80381f286585ad9109cf5867a45ab2d5ebfacaca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法4：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22fb44a7606c8a8e6c1eaf89ff705a2805a4a66f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check for 'No data' only if business logic implies it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;仅当业务逻辑暗示时才检查&amp;ldquo;无数据&amp;rdquo;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30f5b35acd55daabe9c5d79fbb13c7d538970512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an 'unknown question' give 'unknown answer'.&lt;/strong&gt; (Be null-safe where this is correct from business point of view) Checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call.</source>
          <target state="translated">&lt;strong&gt;对于&amp;ldquo;未知问题&amp;rdquo;，请提供&amp;ldquo;未知答案&amp;rdquo;。&lt;/strong&gt; （从业务角度来看这是正确的，请保持null安全）在使用前在方法内部检查参数是否为null可以避免多个调用者在调用之前检查它们。</target>
        </trans-unit>
        <trans-unit id="17a0daea56744b70e6139473e9163ad0064ca4c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is rather theoretical case and in most cases you should prefer java null safe API (in case it will be released in another 10 years), but &lt;code&gt;NullPointerException&lt;/code&gt; is subclass of an &lt;code&gt;Exception&lt;/code&gt;.&lt;/strong&gt; Thus it is a form of &lt;code&gt;Throwable&lt;/code&gt; that indicates conditions that a reasonable application might want to catch (&lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt;)! To use the first most advantage of exceptions and separate error-handling code from 'regular' code (&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;according to creators of Java&lt;/a&gt;) it is appropriate, as for me, to catch &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;这是理论上的情况，在大多数情况下，您应该首选java null安全的API（以防在另外10年内发布），但是 &lt;code&gt;NullPointerException&lt;/code&gt; 是 &lt;code&gt;Exception&lt;/code&gt; 的子类。&lt;/strong&gt; 因此，它是 &lt;code&gt;Throwable&lt;/code&gt; 的一种形式，它指示合理的应用程序可能想要捕获的条件（ &lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt; ）！ 要使用异常的第一个最大优点，并且将错误处理代码与&amp;ldquo;常规&amp;rdquo;代码分开（ &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;根据Java的创建者&lt;/a&gt; ），对我来说，捕获 &lt;code&gt;NullPointerException&lt;/code&gt; 是合适的。</target>
        </trans-unit>
        <trans-unit id="32581af00703ba13e0e48e757a8de5a8956459bb" translate="yes" xml:space="preserve">
          <source>A. It could take place if &lt;code&gt;getPhotoByName()&lt;/code&gt; would try to open a database connection, create &lt;code&gt;PreparedStatement&lt;/code&gt; and use the person name as an SQL parameter at last. The approach &lt;em&gt;for an unknown question gives an unknown answer&lt;/em&gt; (case 1) works here. Before grabbing resources the method should check parameters and return 'unknown' result if needed.</source>
          <target state="translated">&lt;code&gt;getPhotoByName()&lt;/code&gt; 如果getPhotoByName（）尝试打开数据库连接，创建 &lt;code&gt;PreparedStatement&lt;/code&gt; 并最终使用人员名称作为SQL参数，则可能发生这种情况。 &lt;em&gt;未知问题&lt;/em&gt;的方法&lt;em&gt;给出了未知答案&lt;/em&gt; （案例1）在这里起作用。 在获取资源之前，该方法应检查参数，并在需要时返回&amp;ldquo;未知&amp;rdquo;结果。</target>
        </trans-unit>
        <trans-unit id="d442bac768e012a67d8005e207d2f07c7f49c725" translate="yes" xml:space="preserve">
          <source>A. It is up to business logic. If I fail to find a photo album I'll show you no photos. What if appContext is not initialized? This method's business logic puts up with this. If the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). The &lt;strong&gt;new Java Null-safe API fits better here to specify selectively what implies and what does not imply to be initialized&lt;/strong&gt; to be fail-fast in case of programmer errors.</source>
          <target state="translated">答：这取决于业务逻辑。 如果我找不到相册，则不会显示任何照片。 如果未初始化appContext怎么办？ 此方法的业务逻辑对此提出了建议。 如果相同的逻辑更严格，则引发异常，这是业务逻辑的一部分，应使用显式检查null的情况（情况3）。 &lt;strong&gt;新的Java Null-safe API更适合此处，以有选择地指定&lt;/strong&gt;在程序员错误的情况下隐式&lt;strong&gt;初始化和不隐式初始化&lt;/strong&gt;为快速失败的隐患。</target>
        </trans-unit>
        <trans-unit id="9f2811ffff90eaa563c42e280cf9e259110f4e13" translate="yes" xml:space="preserve">
          <source>A. Software should be easy to understand and modify firstly. Only after this, one could think about performance, and only if needed! and where needed! (&lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;source&lt;/a&gt;), and many others).</source>
          <target state="translated">答：首先应易于理解和修改软件。 只有在此之后，才有必要考虑性能！ 在需要的地方！ （ &lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;来源&lt;/a&gt; ），还有许多其他）。</target>
        </trans-unit>
        <trans-unit id="8d12b90120d6345989195a1a87e9ec644b614091" translate="yes" xml:space="preserve">
          <source>All private methods do not check for null since they are controlled methods (just let die with nullpointer exception in case it wasn't handled above)</source>
          <target state="translated">所有的私有方法都不检查null,因为它们都是受控方法(只是让die带nullpointer异常,以防上面没有处理)。</target>
        </trans-unit>
        <trans-unit id="2d362b47b1b8f524063ce05592e2517660992d07" translate="yes" xml:space="preserve">
          <source>All public methods / API always check its arguments for null</source>
          <target state="translated">所有的公共方法API总是检查其参数是否为空</target>
        </trans-unit>
        <trans-unit id="651180d90e7fac397932e649f57913d6e17cbdb5" translate="yes" xml:space="preserve">
          <source>Also I would not recommend using this pattern where the type is meant to be a primitive type representation - like mathematical entities, that are not scalars: vectors, matrices, complex numbers and POD(Plain Old Data) objects, which are meant to hold state in form of Java built-in types. In the latter case you would end up calling getter methods with arbitrary results. For example what should a NullPerson.getName() method return?</source>
          <target state="translated">另外,我不建议使用这种模式,如果类型是原始类型表示,比如数学实体,不是标量:向量、矩阵、复数和POD(Plain Old Data)对象,它们是以Java内置类型的形式保持状态。在后一种情况下,你最终会调用带有任意结果的getter方法。例如,NullPerson.getName()方法应该返回什么结果?</target>
        </trans-unit>
        <trans-unit id="f7b3d415a8b44b9ed32e579112942a8c54368712" translate="yes" xml:space="preserve">
          <source>Also keep in mind, that null object pattern will be memory hungry if used without care. For this - the instance of a NullObject should be shared between owners, and not be an unigue instance for each of these.</source>
          <target state="translated">另外请记住,如果不小心使用null对象模式会占用内存。对于这一点--NullObject的实例应该在所有者之间共享,而不是每一个NullObject都是一个unigue实例。</target>
        </trans-unit>
        <trans-unit id="f6cc029520b428014830a634a4f74acc230947ba" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;assert&lt;/code&gt; statement throws an &lt;code&gt;Error&lt;/code&gt; (&lt;code&gt;AssertionError&lt;/code&gt;) if the condition is not true.  By default, Java ignores assertions.  You can enable assertions by passing the option &lt;code&gt;-ea&lt;/code&gt; to the JVM.  You can enable and disable assertions for individual classes and packages.  This means that you can validate code with the assertions while developing and testing, and disable them in a production environment, although my testing has shown next to no performance impact from assertions.</source>
          <target state="translated">如果条件不成立，则 &lt;code&gt;assert&lt;/code&gt; 语句将引发 &lt;code&gt;Error&lt;/code&gt; （ &lt;code&gt;AssertionError&lt;/code&gt; ）。 默认情况下，Java会忽略断言。 您可以通过将选项 &lt;code&gt;-ea&lt;/code&gt; 传递给JVM来启用断言。 您可以启用和禁用单个类和程序包的断言。 这意味着您可以在开发和测试时使用断言来验证代码，并在生产环境中禁用它们，尽管我的测试几乎没有显示出断言对性能的影响。</target>
        </trans-unit>
        <trans-unit id="d1810451c6d1e409ac8c526fe9326856e3fc7731" translate="yes" xml:space="preserve">
          <source>An alternative solution is to never return null and instead use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object pattern&lt;/a&gt;:</source>
          <target state="translated">另一种解决方案是从不返回null，而使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object模式&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="935b1f02f26191e4d51fccc6975811fe44f6303a" translate="yes" xml:space="preserve">
          <source>An optional object for a given type (&lt;code&gt;Fruit&lt;/code&gt;) is created as the return type of a method. It can be empty or contain a &lt;code&gt;Fruit&lt;/code&gt; object:</source>
          <target state="translated">给定类型的一个可选对象（ &lt;code&gt;Fruit&lt;/code&gt; ）被创建为方法的返回类型。 它可以为空或包含一个 &lt;code&gt;Fruit&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="7890138d52aa6dda680f54b0057313bbeec8699c" translate="yes" xml:space="preserve">
          <source>And don't loathe to type &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (generate javadoc in Eclipse) and write three additional words for you public API. This will be more than enough for all but those who don't read documentation.</source>
          <target state="translated">并且不要讨厌键入 &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; （在Eclipse中生成javadoc）并为您的公共API编写另外三个单词。 对于那些不阅读文档的人来说，这已经足够了。</target>
        </trans-unit>
        <trans-unit id="90d233698926e1669e5eb1d2e7cde879b5ea4b2a" translate="yes" xml:space="preserve">
          <source>And finally, in the code, the first line of the public method goes like this:</source>
          <target state="translated">最后,在代码中,公共方法的第一行是这样的。</target>
        </trans-unit>
        <trans-unit id="194d7971422626db3904b18b7a51e13251038301" translate="yes" xml:space="preserve">
          <source>And if you are using Spring, Spring also has the same functionality in its package, see library(spring-2.4.6.jar)</source>
          <target state="translated">而如果你使用的是Spring,Spring的包中也有同样的功能,请看 library(spring-2.4.6.jar)</target>
        </trans-unit>
        <trans-unit id="96abcbe58267cd8ab194fc60b9df329abfd8ab74" translate="yes" xml:space="preserve">
          <source>And it fits with new coming Java API (looking forward)</source>
          <target state="translated">而且它与即将到来的新的Java API相吻合(期待着)。</target>
        </trans-unit>
        <trans-unit id="8a58cb59872c19e045b96568e04e4207657e1c22" translate="yes" xml:space="preserve">
          <source>And the usage is (with &lt;code&gt;import static&lt;/code&gt;):</source>
          <target state="translated">用法是（使用 &lt;code&gt;import static&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ae0cf01358f7068b6df8fd1b93a1c98822554b48" translate="yes" xml:space="preserve">
          <source>And yes, we know that beyond this line we will no longer encounter a null value so we just safely invoke methods on those objects.</source>
          <target state="translated">是的,我们知道过了这一行,我们就不会再遇到空值了,所以我们只需安全地在这些对象上调用方法即可。</target>
        </trans-unit>
        <trans-unit id="81e8d209a324ece42ed62905642bf649b3662f32" translate="yes" xml:space="preserve">
          <source>And you can be sure that this won't happen. :)</source>
          <target state="translated">你可以肯定的是,这不会发生。)</target>
        </trans-unit>
        <trans-unit id="3294bacd3a1276b7be29212d3a5dd40d74f51115" translate="yes" xml:space="preserve">
          <source>As explained in the wiki:</source>
          <target state="translated">正如维基中所解释的那样。</target>
        </trans-unit>
        <trans-unit id="f927010b70c936bded38e97a00575ae4404173b5" translate="yes" xml:space="preserve">
          <source>As mentioned in some other answers, to avoid above problems you can follow the &lt;strong&gt;Design by contract&lt;/strong&gt; pattern. Please see &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt;.</source>
          <target state="translated">如其他一些答案中所述，为避免出现上述问题，您可以遵循&amp;ldquo; &lt;strong&gt;按合同设计&amp;rdquo;&lt;/strong&gt;模式。 请参阅&lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f1edc5d84268854adcf97f62dec08810475c6e1" translate="yes" xml:space="preserve">
          <source>As you can see, the second value in the addParam() method (string) is needed for the user message, because you cannot easily detect passed-in variable name, even with reflection (not subject of this post anyway...).</source>
          <target state="translated">如你所见,addParam()方法中的第二个值(string)是用户消息需要的,因为你不能轻易地检测到传入的变量名,即使是通过反射也不容易检测到(反正不是本帖的主题...)。</target>
        </trans-unit>
        <trans-unit id="221c48cdf1c0d0839054379dfe7e20af1349a56a" translate="yes" xml:space="preserve">
          <source>As you see &lt;code&gt;Optional.ofNullable()&lt;/code&gt; provides an easy way to get the reference wrapped. There are another ways to get the reference of Optional, either &lt;code&gt;Optional.empty()&lt;/code&gt; &amp;amp; &lt;code&gt;Optional.of()&lt;/code&gt;. One for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively.</source>
          <target state="translated">如您所见， &lt;code&gt;Optional.ofNullable()&lt;/code&gt; 提供了一种简便的方法来包装引用。 还有其他方法可以获取Optional的引用，即 &lt;code&gt;Optional.empty()&lt;/code&gt; 和 &lt;code&gt;Optional.of()&lt;/code&gt; 。 一个用于返回一个空对象而不是重新调整null，另一个用于包装一个不可为空的对象。</target>
        </trans-unit>
        <trans-unit id="7d61afa6fe305594ae8b4e6cf7ecc955c25b75c5" translate="yes" xml:space="preserve">
          <source>Asking that question points out that you may be interested in error handling strategies.  Your team's architect should decide how to work errors.  There are several ways to do this:</source>
          <target state="translated">问这个问题指出,你可能对错误处理策略感兴趣。你的团队架构师应该决定如何处理错误。有几种方法可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="0b437dd2d827fe8753e6c8da99be2952fba3ea42" translate="yes" xml:space="preserve">
          <source>Avoiding != null statements</source>
          <target state="translated">避免使用 !=null 语句</target>
        </trans-unit>
        <trans-unit id="11cb1da4d18f15638f6174f01e98f7fee924565f" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with &quot;Tell, Don't Ask&quot; Style</source>
          <target state="translated">用 &quot;告诉,不要问 &quot;的方式避免空号</target>
        </trans-unit>
        <trans-unit id="c53936ddbedfa72c352067284a2a612bd38150c0" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with Polymorphic Dispatch</source>
          <target state="translated">使用多态调度避免空点</target>
        </trans-unit>
        <trans-unit id="f4719d3ce5a47c8365160718c824959b1f58c151" translate="yes" xml:space="preserve">
          <source>Basically, you've got &lt;code&gt;@Nullable&lt;/code&gt; and &lt;code&gt;@NotNull&lt;/code&gt;.</source>
          <target state="translated">基本上，您有 &lt;code&gt;@Nullable&lt;/code&gt; 和 &lt;code&gt;@NotNull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c18860f21ab893032025c9ad8f874c57757e0d5" translate="yes" xml:space="preserve">
          <source>Byte!</source>
          <target state="translated">Byte!</target>
        </trans-unit>
        <trans-unit id="320bd43703cd7557626230bd2dde77c2b7640f71" translate="yes" xml:space="preserve">
          <source>Common &quot;problem&quot; in Java indeed.</source>
          <target state="translated">Java中常见的 &quot;问题 &quot;确实是Java中常见的 &quot;问题&quot;。</target>
        </trans-unit>
        <trans-unit id="ab6b4e896ea7eaaed3d3b7bd63695ed61f2bc666" translate="yes" xml:space="preserve">
          <source>Compare:</source>
          <target state="translated">Compare:</target>
        </trans-unit>
        <trans-unit id="4890e65fe4afc7621e1eabc62ca877d901891501" translate="yes" xml:space="preserve">
          <source>Depending on what kind of objects you are checking you may be able to use some of the classes in the apache commons such as: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt;</source>
          <target state="translated">根据您要检查的对象的类型，您也许可以使用apache commons中的某些类，例如： &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt;和&lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1611574f68477e79c3124a789db72e5b33b65570" translate="yes" xml:space="preserve">
          <source>Doing this</source>
          <target state="translated">这样做</target>
        </trans-unit>
        <trans-unit id="9a7ba7e5ca69607940820be45f20c7f96e626e73" translate="yes" xml:space="preserve">
          <source>Doing this in your own code and you can avoid != null checks.</source>
          <target state="translated">在你自己的代码中这样做,你可以避免 !=null 检查。</target>
        </trans-unit>
        <trans-unit id="a489753c928c4dfb8ffde543140ef98f7d16b3e3" translate="yes" xml:space="preserve">
          <source>Example on how to throw exception on null:</source>
          <target state="translated">关于如何在null上抛出异常的例子。</target>
        </trans-unit>
        <trans-unit id="c10cb15cb38405cd962e584139f01df735b6c7b4" translate="yes" xml:space="preserve">
          <source>Example on how to use this static classf from spring(org.springframework.util.Assert)</source>
          <target state="translated">如何从spring(org.springframework.util.Assert)中使用这个静态classf的例子</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c7feb78075d63e6bedf1365cc55e6aa7fc3a87a8" translate="yes" xml:space="preserve">
          <source>Finally, here is our NPE as well as null check-free code:</source>
          <target state="translated">最后,这里是我们的NPE以及免检代码。</target>
        </trans-unit>
        <trans-unit id="1428f3662f53c4496ea96cf16634505d0f0a9b2c" translate="yes" xml:space="preserve">
          <source>First, I follow this convention:</source>
          <target state="translated">首先,我按照这个惯例。</target>
        </trans-unit>
        <trans-unit id="3f6a27b732f1a0d9afc335cb45ef93731f4fb5bf" translate="yes" xml:space="preserve">
          <source>First, my thoughts on this:</source>
          <target state="translated">首先,我对这个问题的想法。</target>
        </trans-unit>
        <trans-unit id="54463d0ab47a851d650e8259c2db7a0ae594a452" translate="yes" xml:space="preserve">
          <source>For example I often use:</source>
          <target state="translated">比如说我经常使用。</target>
        </trans-unit>
        <trans-unit id="4b4c9cb4038fad0763e34c64a087da1f526c6087" translate="yes" xml:space="preserve">
          <source>Guava, a very useful core library by Google, has a nice and useful API to avoid nulls. I find &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained&lt;/a&gt; very helpful.</source>
          <target state="translated">Guava是Google的非常有用的核心库，它具有避免空值的漂亮且有用的API。 我发现&lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained&lt;/a&gt;非常有帮助。</target>
        </trans-unit>
        <trans-unit id="2a6e8249d4017ff690264fec43a31540b1ea7759" translate="yes" xml:space="preserve">
          <source>Here follows an example of how you can use null vallidation in JAVA when you include apache library(commons-lang-2.4.jar)</source>
          <target state="translated">下面是一个例子,当你在JAVA中包含apache library(commons-lang-2.4.jar)时,如何在JAVA中使用null vallidation的例子</target>
        </trans-unit>
        <trans-unit id="37fc03c253b95910c6421c23c78078850ed69a95" translate="yes" xml:space="preserve">
          <source>However, if your method just passes the value on, and the next method passes it on etc. it could get problematic. In that case you may want to check the argument as above.</source>
          <target state="translated">但是,如果你的方法只是把值传过去,而下一个方法把它传过去等等,可能会有问题。在这种情况下,你可能要检查一下上面的参数。</target>
        </trans-unit>
        <trans-unit id="1d268653fde675e2306e93684be579aa72eb2868" translate="yes" xml:space="preserve">
          <source>I consider that it is bad to &quot;eat&quot; something when NULL was passed where NULL isn't a valid value. If you're not exiting the method with some sort of error then it means nothing went wrong in your method which is not true. Then you probably return null in this case, and in the receiving method you again check for null, and it never ends, and you end up with &quot;if != null&quot;, etc..</source>
          <target state="translated">我认为当传递了NULL不是有效值的时候,&quot;吃 &quot;掉一些东西是不好的。如果你在退出方法时没有出现某种错误,那么说明你的方法没有出错,而这并不是真的。那么在这种情况下,你很可能会返回null,在接收方法中,你再次检查null,而且它永远不会结束,最后你会出现 &quot;if !=null &quot;等。</target>
        </trans-unit>
        <trans-unit id="ac7c74b5f9864f037fc949031de21c91fd9060c0" translate="yes" xml:space="preserve">
          <source>I highly disregard answers that suggest using the null objects in every situation. This pattern may break the contract and bury problems deeper and deeper instead of solving them, not mentioning that used inappropriately will create another pile of boilerplate code that will require future maintenance.</source>
          <target state="translated">我非常不理会那些建议在任何情况下都使用null对象的答案。这种模式可能会破坏契约,把问题越埋越深,而不是解决问题,更何况使用不当会产生另一堆需要日后维护的锅炉板代码。</target>
        </trans-unit>
        <trans-unit id="5e1533f4720d20d3996516b4af58f7d3dd16391a" translate="yes" xml:space="preserve">
          <source>I invite you to read this article (my main source for writing this answer) in which the &lt;code&gt;NullPointerException&lt;/code&gt; (and in general null pointer) problematic as well as the (partial) solution brought by &lt;code&gt;Optional&lt;/code&gt; are well explained: &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">我邀请您阅读本文（我写此答案的主要来源），其中很好地解释了有问题的 &lt;code&gt;NullPointerException&lt;/code&gt; （通常是null指针）以及 &lt;code&gt;Optional&lt;/code&gt; 带来的（部分）解决方案： &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9e91faab1ad00e77854ebd2d809262438fc2063" translate="yes" xml:space="preserve">
          <source>I like articles from Nat Pryce. Here are the links:</source>
          <target state="translated">我喜欢纳特-普莱斯的文章。以下是链接。</target>
        </trans-unit>
        <trans-unit id="c4217f45a2775c21698ce1470fdcef44f36c7cb8" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;object != null&lt;/code&gt; a lot to avoid &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我经常使用 &lt;code&gt;object != null&lt;/code&gt; 来避免&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="43aae1b74babe4a5f7cffce5f010ac04c50784b7" translate="yes" xml:space="preserve">
          <source>I'm a fan of &quot;fail fast&quot; code. Ask yourself - are you doing something useful in the case where the parameter is null? If you don't have a clear answer for what your code should do in that case... I.e. it should never be null in the first place, then ignore it and allow a NullPointerException to be thrown. The calling code will make just as much sense of an NPE as it would an IllegalArgumentException, but it'll be easier for the developer to debug and understand what went wrong if an NPE is thrown rather than your code attempting to execute some other unexpected contingency logic - which ultimately results in the application failing anyway.</source>
          <target state="translated">我是 &quot;快速失败 &quot;代码的粉丝。扪心自问--在参数为空的情况下,你是否在做一些有用的事情?如果你没有一个明确的答案,你的代码在这种情况下应该怎么做......即:首先它不应该是null,那么就忽略它,并允许抛出一个NullPointerException。调用代码会和IllegalArgumentException一样,在NPE的情况下,调用代码也会像IllegalArgumentException一样有意义,但是如果抛出一个NPE,开发者更容易调试和理解出错的地方,而不是你的代码试图执行一些其他意外的应急逻辑--最终导致应用程序失败。</target>
        </trans-unit>
        <trans-unit id="9d28525daf513a3218069e5463bb837227dd3063" translate="yes" xml:space="preserve">
          <source>I've tried the &lt;code&gt;NullObjectPattern&lt;/code&gt; but for me is not always the best way to go. There are sometimes when a &quot;no action&quot; is not appropiate.</source>
          <target state="translated">我已经尝试过 &lt;code&gt;NullObjectPattern&lt;/code&gt; ,但对我来说并不总是最好的方法。 有时有时候&amp;ldquo;不采取行动&amp;rdquo;是不合适的。</target>
        </trans-unit>
        <trans-unit id="55bdc40b2d33d1479a2eed8448e223fe33d03160" translate="yes" xml:space="preserve">
          <source>If (1) is not possible, initialise all collections and arrays to empty collections/arrays.</source>
          <target state="translated">如果(1)不可能,将所有的集合和数组初始化为空的集合阵列。</target>
        </trans-unit>
        <trans-unit id="0e0f1c759db9fd58b965ca2548b987ed339d8a59" translate="yes" xml:space="preserve">
          <source>If appContext or dataSource is not initialized unhandled runtime NullPointerException will kill current thread and will be processed by &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (for you to define and use your favorite logger or other notification mechanizm). If not set, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup#uncaughtException&lt;/a&gt; will print stacktrace to system err. One should monitor application error log and open Jira issue for each unhandled exception which in fact is application error. Programmer should fix bug somewhere in initialization stuff.</source>
          <target state="translated">如果未初始化appContext或dataSource，则未处理的运行时NullPointerException将&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;终止&lt;/a&gt;当前线程，并将由Thread.defaultUncaughtExceptionHandler处理（供您定义和使用您喜欢的记录器或其他通知机制）。 如果未设置，则&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup＃uncaughtException&lt;/a&gt;将堆栈跟踪信息打印到系统err。 应该监视应用程序错误日志，并为每个未处理的异常打开Jira问题，实际上这是应用程序错误。 程序员应在初始化工作中的某处修复错误。</target>
        </trans-unit>
        <trans-unit id="09e73ecfe67989af7dd8eaebfa15624f78eacae4" translate="yes" xml:space="preserve">
          <source>If it is an internal method (not part of an API), just document that it cannot be null, and that's it.</source>
          <target state="translated">如果它是一个内部方法(不是API的一部分),只要记录它不能为空,就可以了。</target>
        </trans-unit>
        <trans-unit id="0728dc4e2e97cf099cf3ab0e28a357ee05e7b6ca" translate="yes" xml:space="preserve">
          <source>If it's code that you do control, however (and this is often the case), then it's a different story.  Avoid using nulls as a response.  With methods that return collections, it's easy: return empty collections (or arrays) instead of nulls pretty much all the time.</source>
          <target state="translated">但是,如果是你控制的代码(通常是这种情况),那就另当别论了。避免使用nulls作为响应。对于返回集合的方法,很简单:几乎所有的时候都要返回空集合(或数组),而不是nulls。</target>
        </trans-unit>
        <trans-unit id="f619483031223d172a56c6c25092a69d35edf9be" translate="yes" xml:space="preserve">
          <source>If null is allowed</source>
          <target state="translated">如果允许为零</target>
        </trans-unit>
        <trans-unit id="d5dc5db9bb49b83ae4fcd69d7d06a8b86bbf1b0a" translate="yes" xml:space="preserve">
          <source>If null-values are not allowed</source>
          <target state="translated">如果不允许空值</target>
        </trans-unit>
        <trans-unit id="9ff0191b7a1ec369d5c5805839743dd0c72f1b9e" translate="yes" xml:space="preserve">
          <source>If undefined values are not permitted:</source>
          <target state="translated">如果未定义的值不允许。</target>
        </trans-unit>
        <trans-unit id="549ca9f1c825f259e5ce60b96c2984b9b0f5f764" translate="yes" xml:space="preserve">
          <source>If undefined values are permitted:</source>
          <target state="translated">如果未定义的值是允许的。</target>
        </trans-unit>
        <trans-unit id="68f38a6783f67b9f294c501c4581c1585e95009c" translate="yes" xml:space="preserve">
          <source>If you ask me what is the name of my girlfriend I'll tell you that I have no girlfriend. In the Java language I'll return null. 
An alternative would be to throw meaningful exception to indicate some problem that can't be (or don't want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user.</source>
          <target state="translated">如果你问我女朋友叫什么名字,我会告诉你,我没有女朋友。在Java语言中,我会返回null。另一种方法是抛出有意义的异常来表示一些不能(或不想)就在那里解决的问题,并将其委托给堆栈中更高的地方来重试或向用户报告数据访问错误。</target>
        </trans-unit>
        <trans-unit id="632f1186cdb5143b60b5f2614ffe2a8a35f452f1" translate="yes" xml:space="preserve">
          <source>If you consider an object should not be null (or it is a bug) use an assert.</source>
          <target state="translated">如果你认为一个对象不应该是空的(或者说它是一个bug),那么就使用assert。</target>
        </trans-unit>
        <trans-unit id="1cf153150df9563cc962ca474b13e56e5c751cce" translate="yes" xml:space="preserve">
          <source>If you know b can never be null, you can just swap it. It is most useful for equals:
Instead of &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; better do &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt;.</source>
          <target state="translated">如果您知道b永远不能为null，则可以交换它。 对于equals最为有用：代替 &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; 最好做 &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46640e8236124be6c3cf80df96f4c3a462598491" translate="yes" xml:space="preserve">
          <source>If you use (or planning to use) a Java IDE like &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; or &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; or a tool like findbugs then you can use annotations to solve this problem.</source>
          <target state="translated">如果您使用（或计划使用） &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt; ， &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt;或&lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans之&lt;/a&gt;类的Java IDE或findbugs之类的工具，则可以使用注释来解决此问题。</target>
        </trans-unit>
        <trans-unit id="d9bd5740fe135b5553acbf51ff5056141fbbb4dc" translate="yes" xml:space="preserve">
          <source>If your method doesn't accept null params say it in the javadoc and use an assert.</source>
          <target state="translated">如果你的方法不接受null参数,请在javadoc中说出来,并使用assert。</target>
        </trans-unit>
        <trans-unit id="ce6b2cf4a5e96febfe5ce76451daef36e092d32b" translate="yes" xml:space="preserve">
          <source>If your method is called externally, start with something like this:</source>
          <target state="translated">如果你的方法是外部调用的,那就从这样开始。</target>
        </trans-unit>
        <trans-unit id="ab846b65d9a8fcd8a4b81c40b61e74e028b79991" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt;, a Java-derived language, there are two versions of all types: a potentially-null version and a not-null version. You can only invoke methods on not-null types. Potentially-null types can be converted to not-null types through explicit checking for null. This makes it much easier to know where null checks are necessary and where they aren't.</source>
          <target state="translated">在Java派生的语言&lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice中&lt;/a&gt; ，有两种类型的所有类型：可能为空的版本和非为空的版本。 您只能在非空类型上调用方法。 通过显式检查null，可以将潜在为null的类型转换为非null的类型。 这样可以更轻松地知道哪些地方需要空检查，哪些地方没有空检查。</target>
        </trans-unit>
        <trans-unit id="8317f0d2b647c2aff1a42d76d73339593f638877" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA 10.5 and on, they added support for any other &lt;code&gt;@Nullable&lt;/code&gt;&lt;code&gt;@NotNull&lt;/code&gt; implementations.</source>
          <target state="translated">在IntelliJ IDEA 10.5及 &lt;code&gt;@Nullable&lt;/code&gt; ，他们添加了对其他@Nullable &lt;code&gt;@NotNull&lt;/code&gt; 实现的支持。</target>
        </trans-unit>
        <trans-unit id="920588de011f2e8dddc89ccb39b92ea0631e797c" translate="yes" xml:space="preserve">
          <source>In Objective-C, you can do the equivalent of invoking a method on &lt;code&gt;nil&lt;/code&gt;, and absolutely nothing will happen. This makes most null checks unnecessary, but it can make errors much harder to diagnose.</source>
          <target state="translated">在Objective-C中，您可以等效于在 &lt;code&gt;nil&lt;/code&gt; 上调用方法，并且绝对不会发生任何事情。 这使得不必要执行大多数空检查，但会使错误更难以诊断。</target>
        </trans-unit>
        <trans-unit id="04837dad91721b9799f52240befed0a8ce992bd5" translate="yes" xml:space="preserve">
          <source>In a nutshell, the Optional class includes methods to explicitly deal with the cases where a value is present or absent. However, the advantage compared to null references is that the Optional&amp;lt;T&amp;gt; class forces you to think about the case when the value is not present. As a consequence, you can prevent unintended null pointer exceptions.</source>
          <target state="translated">简而言之，Optional类包含一些方法来显式处理存在或不存在值的情况。 但是，与null引用相比，优点是Optional &amp;lt;T&amp;gt;类迫使您考虑不存在该值的情况。 因此，您可以防止意外的空指针异常。</target>
        </trans-unit>
        <trans-unit id="f1f3e79c602141290377505754be2b4a12d560ec" translate="yes" xml:space="preserve">
          <source>In above example we have a home service factory that returns a handle to multiple appliances available in the home. But these services may or may not be available/functional; it means it may result in a NullPointerException. Instead of adding a null &lt;code&gt;if&lt;/code&gt; condition before using any service, let's wrap it in to Optional&amp;lt;Service&amp;gt;.</source>
          <target state="translated">在上面的示例中，我们有一个家庭服务工厂，该工厂将句柄返回给家庭中可用的多个设备。 但是这些服务可能不可用，也不可用。 这意味着它可能会导致NullPointerException。 不要在使用任何服务之前添加null &lt;code&gt;if&lt;/code&gt; 条件，而是将其包装到Optional &amp;lt;Service&amp;gt;中。</target>
        </trans-unit>
        <trans-unit id="fc6e5953a54a7e173cf74b9a49d8e3e1c3ed3c55" translate="yes" xml:space="preserve">
          <source>In addition to using &lt;code&gt;assert&lt;/code&gt; you can use the following:</source>
          <target state="translated">除了使用 &lt;code&gt;assert&lt;/code&gt; 之外，还可以使用以下内容：</target>
        </trans-unit>
        <trans-unit id="58e936cf946cec0419aa0692bf595f85b67c954b" translate="yes" xml:space="preserve">
          <source>In an API built from scratch using &lt;code&gt;Optional&lt;/code&gt; whenever a return value might be empty, and returning a plain object only when it cannot be &lt;code&gt;null&lt;/code&gt; (convention), the client code might abandon null checks on simple object return values...</source>
          <target state="translated">在使用 &lt;code&gt;Optional&lt;/code&gt; 从头构建的API中，无论何时返回值可能为空，并且仅当它不能为 &lt;code&gt;null&lt;/code&gt; （约定）时才返回纯对象，客户端代码可能会放弃对简单对象返回值的null检查...</target>
        </trans-unit>
        <trans-unit id="992aee948602e38e384351d28a7dc64174420247" translate="yes" xml:space="preserve">
          <source>In my classes, most fields and local variables have non-null default values, and I add contract statements (always-on asserts) everywhere in the code to make sure this is being enforced (since it's more succinct, and more expressive than letting it come up as an NPE and then having to resolve the line number, etc.).</source>
          <target state="translated">在我的类中,大多数字段和局部变量都有非空的默认值,我在代码中到处添加了契约语句(始终保持断言),以确保这一点被强制执行(因为这比让它作为NPE出现,然后必须解决行号等问题更简洁,也更有表现力)。</target>
        </trans-unit>
        <trans-unit id="a0427014adae81ed68e6059ae2ac27ebf2554012" translate="yes" xml:space="preserve">
          <source>In reality if something returned from a method can be null and the calling code has to make decision upon that, there should an earlier call that ensures the state.</source>
          <target state="translated">在现实中,如果一个方法返回的东西可能是空的,而调用的代码必须根据这一点做出决定,那么就应该有一个更早的调用来确保状态。</target>
        </trans-unit>
        <trans-unit id="d28d029f197073e44a5cf2c959d2881818c5cbc8" translate="yes" xml:space="preserve">
          <source>In the articles there is also a link to a Git repository for a Java Maybe Type which I find interesting, but I don't think it alone could decrease the
checking code bloat. After doing some research on the Internet, I think &lt;strong&gt;!= null&lt;/strong&gt; code bloat could be decreased mainly by careful design.</source>
          <target state="translated">在文章中，还有一个指向Java Maybe Type的Git存储库的链接，我觉得很有趣，但是我认为单独使用它可能不会减少检查代码的膨胀。 在Internet上进行了一些研究之后，我认为&lt;strong&gt;！=空&lt;/strong&gt;代码膨胀主要可以通过精心设计来减少。</target>
        </trans-unit>
        <trans-unit id="02e44622ee08c669f730bdcb2ba763d4bddbd763" translate="yes" xml:space="preserve">
          <source>Is there a good alternative to this?</source>
          <target state="translated">有没有好的替代品?</target>
        </trans-unit>
        <trans-unit id="24df4f8ef6f8fd18a5d3ec048c3faffe1f0edf74" translate="yes" xml:space="preserve">
          <source>It is stated explicitly in the API whether an input or output exists or not.</source>
          <target state="translated">它在API中明确说明了输入或输出是否存在。</target>
        </trans-unit>
        <trans-unit id="6cd16395a598dc3b1c54e1c2de34abba05b16ef6" translate="yes" xml:space="preserve">
          <source>It may be easier to give you examples, if you show examples of where you typically use the idiom.</source>
          <target state="translated">如果你举出成语的例子,可能会更容易些,如果你举出成语的例子,说明你一般在哪里用的是成语。</target>
        </trans-unit>
        <trans-unit id="c32880c4b10a50c8fb02fa59f5e5618dea4d1963" translate="yes" xml:space="preserve">
          <source>It's a nice way to let the compiler check something more than it usually does and to enforce your contracts to be stronger. Unfortunately, it's not supported by all the compilers.</source>
          <target state="translated">这是一个很好的方法,可以让编译器检查的东西比平时多一些,也可以让你的契约执行力更强。不幸的是,它并不是所有的编译器都支持。</target>
        </trans-unit>
        <trans-unit id="f405e902c0a66a3e8ffdf23a351c22c3a375631a" translate="yes" xml:space="preserve">
          <source>It's actually rare for me to use the idiom &quot;&lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt;&quot;.</source>
          <target state="translated">实际上，我很少使用惯用语&amp;ldquo; &lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="714b225b9ed3d9fb4f8f780dad6fe5864bd2db61" translate="yes" xml:space="preserve">
          <source>It's worth considering such cases in order to avoid absurd results.</source>
          <target state="translated">这类情况值得考虑,以免出现荒唐的结果。</target>
        </trans-unit>
        <trans-unit id="e2368895a515e87735e0f53eb54312d0b78e798a" translate="yes" xml:space="preserve">
          <source>Java 7 has a new &lt;code&gt;java.util.Objects&lt;/code&gt; utility class on which there is a &lt;code&gt;requireNonNull()&lt;/code&gt; method. All this does is throw a &lt;code&gt;NullPointerException&lt;/code&gt; if its argument is null, but it cleans up the code a bit. Example:</source>
          <target state="translated">Java 7具有一个新的 &lt;code&gt;java.util.Objects&lt;/code&gt; 实用程序类，在该类上具有 &lt;code&gt;requireNonNull()&lt;/code&gt; 方法。 如果它的参数为null，则所有操作都将引发 &lt;code&gt;NullPointerException&lt;/code&gt; ，但会稍微清理一下代码。 例：</target>
        </trans-unit>
        <trans-unit id="edc6b48d824432a77a20f24921f65458059db63b" translate="yes" xml:space="preserve">
          <source>Java 7 introduced the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt;&lt;code&gt;Objects.requireNonNull&lt;/code&gt;&lt;/a&gt; method which can be handy when something should be checked for non-nullness. Example:</source>
          <target state="translated">Java 7引入了&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt; &lt;code&gt;Objects.requireNonNull&lt;/code&gt; &lt;/a&gt;方法，该方法在检查某些内容是否为非空时非常方便。 例：</target>
        </trans-unit>
        <trans-unit id="14057bbaba6e7ba4939e98331bee0a9d4cc6fd00" translate="yes" xml:space="preserve">
          <source>Java 8 has a built-in &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class (recommended); for earlier versions, there are library alternatives, for example &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;'s &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;. But like many functional-style patterns, using Option in Java (even 8) results in quite some boilerplate, which you can reduce using a less verbose JVM language, e.g. Scala or Xtend.</source>
          <target state="translated">Java 8具有内置的&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;类（推荐）； 对于早期版本，有一些库替代方案，例如&lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;的&lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;的&lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 。 但是，就像许多功能样式的模式一样，在Java中使用Option（甚至8）会产生很多样板，您可以使用不太冗长的JVM语言（例如Scala或Xtend）来减少这种样板。</target>
        </trans-unit>
        <trans-unit id="23ec0515f353dee199aaa003dccab705cbddfd12" translate="yes" xml:space="preserve">
          <source>Java 8 has introduced &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;. It is a container that may or may not hold a non-null value. Java 8 has given a safer way to handle an object whose value may be null in some of the cases. It is inspired from the ideas of &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt;.</source>
          <target state="translated">Java 8引入了 &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt; 。 它是一个可能包含也可能不包含非null值的容器。 Java 8提供了一种更安全的方法来处理在某些情况下其值可能为null的对象。 它受&lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt;的思想启发。</target>
        </trans-unit>
        <trans-unit id="b697deb5aa0b223e01560060b3cb1b1f61855b42" translate="yes" xml:space="preserve">
          <source>Just a sample:</source>
          <target state="translated">只是一个样本。</target>
        </trans-unit>
        <trans-unit id="e35fd4948c5a9357196b184cecdd55c2cc10c2d5" translate="yes" xml:space="preserve">
          <source>Just don't ever use null. Don't allow it.</source>
          <target state="translated">只是千万不要用null。不要允许它。</target>
        </trans-unit>
        <trans-unit id="e6f599b2f399715ad627af5bb0a6d5baae609bba" translate="yes" xml:space="preserve">
          <source>Last example using &lt;code&gt;@Nullable&lt;/code&gt;</source>
          <target state="translated">最后一个使用 &lt;code&gt;@Nullable&lt;/code&gt; 的示例</target>
        </trans-unit>
        <trans-unit id="59402a00be4a0f11592ceaf67244cfe61d5bda51" translate="yes" xml:space="preserve">
          <source>Let's consider a method to get a reference of a service from a factory. Instead of returning the service reference, wrap it with Optional. It lets the API user know that the returned service may or may not available/functional, use defensively</source>
          <target state="translated">让我们考虑一个从工厂获取服务引用的方法。与其返回服务引用,不如用Optional来包装它。它让API用户知道,返回的服务可能或不可能是可用的functional,使用defensively</target>
        </trans-unit>
        <trans-unit id="aabc2d3db3cef830d4da0377e4b7c5b1b3f518c5" translate="yes" xml:space="preserve">
          <source>May I answer it more generally!</source>
          <target state="translated">请允许我概括地回答一下!</target>
        </trans-unit>
        <trans-unit id="f433759684160d6db17bda40a8e075111a85c751" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;validate()&lt;/code&gt; will throw checked &lt;code&gt;ValidationException&lt;/code&gt; if any of the parameters is null (checked or unchecked is more a design/taste issue, but my &lt;code&gt;ValidationException&lt;/code&gt; is checked).</source>
          <target state="translated">如果任何参数为null（选中或未选中是更多的设计/口味问题，但我的 &lt;code&gt;ValidationException&lt;/code&gt; 已选中），则 &lt;code&gt;validate()&lt;/code&gt; 方法将引发checked &lt;code&gt;ValidationException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f01e85661d751c9b649b3a4ad66bff717bcfdf9" translate="yes" xml:space="preserve">
          <source>Most of the time null checks seem to guard loops over collections or arrays, so just initialise them empty, you won't need any null checks.</source>
          <target state="translated">大多数时候null检查似乎都是在集合或数组上守护循环,所以只需初始化它们为空即可,你不需要任何null检查。</target>
        </trans-unit>
        <trans-unit id="10245c94028cb40db8342e6e78c68de0822b9be5" translate="yes" xml:space="preserve">
          <source>Never initialise variables to null.</source>
          <target state="translated">切勿将变量初始化为空。</target>
        </trans-unit>
        <trans-unit id="92dc04e377ae99c8a6ebf3a5d7e85d43ee0f3ab3" translate="yes" xml:space="preserve">
          <source>Not checking if a variable is null before invoking an equals method (a string compare example below):</source>
          <target state="translated">在调用equals方法之前不检查变量是否为空(下面的字符串比较例子)。</target>
        </trans-unit>
        <trans-unit id="99556f0afc8bbece6b8c0e90382fe62b10f3db0b" translate="yes" xml:space="preserve">
          <source>Not using assertions in this case is OK because the code will just fail, which is what will happen if you use assertions.  The only difference is that with assertions it might happen sooner, in a more-meaningful way and possibly with extra information, which may help you to figure out why it happened if you weren't expecting it.</source>
          <target state="translated">在这种情况下不使用断言是没有问题的,因为代码会失败,如果你使用断言,就会发生这种情况。唯一的区别是,使用断言可能会更快、更有意义地发生,而且可能会有额外的信息,这可能会帮助你弄清楚为什么会发生这种情况,如果你没有预料到的话。</target>
        </trans-unit>
        <trans-unit id="176fa701c30ed80ae841f14d912217b3648526ea" translate="yes" xml:space="preserve">
          <source>Note that addParam() returns self, so that you can add more parameters to check.</source>
          <target state="translated">注意,addParam()返回self,这样就可以添加更多的参数进行检查。</target>
        </trans-unit>
        <trans-unit id="9c7893143e601f4d7141dc682079d103f68d972b" translate="yes" xml:space="preserve">
          <source>Note that the accepted answer may be out of date, see &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; for a more recent approach.</source>
          <target state="translated">请注意，可接受的答案可能已过期，请参阅&lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt;以获取最新的方法。</target>
        </trans-unit>
        <trans-unit id="08c509b05cd5ed1b8001a328275f057bb13241df" translate="yes" xml:space="preserve">
          <source>Now HomeServices.get() does same thing, but in a better way. It checks whether the service is already initialized of not. If it is then return the same or create a new New service. Optional&amp;lt;T&amp;gt;.orElse(T) helps to return a default value.</source>
          <target state="translated">现在，HomeServices.get（）可以执行相同的操作，但是效果更好。 它检查服务是否已经初始化。 如果是，则返回相同值或创建新的新服务。 可选的&amp;lt;T&amp;gt; .orElse（T）有助于返回默认值。</target>
        </trans-unit>
        <trans-unit id="243fc41a64042cfc5860b15fdd1a86b35656505b" translate="yes" xml:space="preserve">
          <source>Now look at this code where we search a list of &lt;code&gt;Fruit&lt;/code&gt; (&lt;code&gt;fruits&lt;/code&gt;) for a given Fruit instance:</source>
          <target state="translated">现在看以下代码，我们在其中搜索给定的Fruit实例的 &lt;code&gt;Fruit&lt;/code&gt; 列表：</target>
        </trans-unit>
        <trans-unit id="26b0fcf72724ae5ef092ca7b297d0d826206b5cb" translate="yes" xml:space="preserve">
          <source>Now the IntelliJ IDEA compiler will tell you that the check is useless, since the &lt;code&gt;helloWorld()&lt;/code&gt; function won't return &lt;code&gt;null&lt;/code&gt;, ever.</source>
          <target state="translated">现在，IntelliJ IDEA编译器将告诉您该检查是无用的，因为 &lt;code&gt;helloWorld()&lt;/code&gt; 函数永远不会返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdc1b22c0d793a34bbcf4429fa3f1f90d9486b91" translate="yes" xml:space="preserve">
          <source>Now to the answer:</source>
          <target state="translated">现在到答案。</target>
        </trans-unit>
        <trans-unit id="2ea239f7f659ef1548e4d08d1e55d7c383740b1c" translate="yes" xml:space="preserve">
          <source>Now you can safely develop the core function of your method without needing to check input parameters, they guard your methods from unexpected parameters.</source>
          <target state="translated">现在你可以安全地开发你的方法的核心功能,而不需要检查输入参数,它们保护你的方法不受意外参数的影响。</target>
        </trans-unit>
        <trans-unit id="edf43179ef58a381a95f2c17225fe5bf82d216c3" translate="yes" xml:space="preserve">
          <source>Null is not a 'problem'. It is an integral part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;complete&lt;/a&gt; modeling tool set. Software aims to model the complexity of the world and null bears its burden. &lt;strong&gt;Null indicates 'No data' or 'Unknown'&lt;/strong&gt; in Java and the like. So it is appropriate to use nulls for these purposes. I don't prefer the 'Null object' pattern; I think it rise the '&lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;who will guard
the guardians&lt;/a&gt;' problem.</source>
          <target state="translated">空不是一个&amp;ldquo;问题&amp;rdquo;。 它是&lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;完整的&lt;/a&gt;建模工具集的组成部分。 软件旨在模拟世界的复杂性，而null承担了它的负担。 &lt;strong&gt;Null表示&lt;/strong&gt; Java等中的&lt;strong&gt;&amp;ldquo;无数据&amp;rdquo;或&amp;ldquo;未知&amp;rdquo;&lt;/strong&gt; 。 因此，将空值用于这些目的是适当的。 我不喜欢&amp;ldquo;空对象&amp;rdquo;模式； 我认为这引起了&amp;ldquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;谁来守护监护人&lt;/a&gt; &amp;rdquo;的问题。</target>
        </trans-unit>
        <trans-unit id="29fec67aa38549dd5045b52d3829e32fb6b213cd" translate="yes" xml:space="preserve">
          <source>Of course &lt;code&gt;Optional&lt;/code&gt; could also be used as a method argument, perhaps a better way to indicate optional arguments than 5 or 10 overloading methods in some cases.</source>
          <target state="translated">当然， &lt;code&gt;Optional&lt;/code&gt; 也可以用作方法参数，这在某些情况下可能是比5或10个重载方法更好的指示可选参数的方法。</target>
        </trans-unit>
        <trans-unit id="4caa61cd647ca110cd57241ba6a32544f2821d80" translate="yes" xml:space="preserve">
          <source>Of course, experience is the better way to understand and apply this suggestion.</source>
          <target state="translated">当然,经验是更好地理解和运用这个建议的方法。</target>
        </trans-unit>
        <trans-unit id="1025ea9180532a8fb4fe82dbd19b0c29868734a2" translate="yes" xml:space="preserve">
          <source>Of course, the check for null/empty value is still necessary, but at least the developer is conscious that the value might be empty and the risk of forgetting to check is limited.</source>
          <target state="translated">当然,对空值的检查还是有必要的,但至少开发者会意识到值可能是空的,忘记检查的风险是有限的。</target>
        </trans-unit>
        <trans-unit id="f9b45a3dc805fa3553c19beda43294e7e53857b2" translate="yes" xml:space="preserve">
          <source>Once I adopted this practice, I noticed that the problems seemed to fix themselves. You'd catch things much earlier in the development process just by accident and realize you had a weak spot..  and more importantly.. it helps encapsulate different modules' concerns, different modules can 'trust' each other, and no more littering the code with &lt;code&gt;if = null else&lt;/code&gt; constructs!</source>
          <target state="translated">一旦采用了这种做法，我发现问题似乎已经解决。 您会在开发过程中很早就偶然发现问题，并且意识到自己的弱点。更重要的是，它有助于封装不同模块的关注点，不同模块可以&amp;ldquo;相互信任&amp;rdquo;，而不会产生混乱 &lt;code&gt;if = null else&lt;/code&gt; 代码else构造！</target>
        </trans-unit>
        <trans-unit id="c50fca7276a877e4ddcc3641d754b50d96020d50" translate="yes" xml:space="preserve">
          <source>Once you have wrapped a reference object, Optional provides many useful methods to invoke methods on a wrapped reference without NPE.</source>
          <target state="translated">一旦你包装了一个引用对象,Optional提供了许多有用的方法,可以在没有NPE的情况下调用被包装的引用上的方法。</target>
        </trans-unit>
        <trans-unit id="72353b7bfc87776c765797b34857c518b0e8dcd9" translate="yes" xml:space="preserve">
          <source>Only for this situation -</source>
          <target state="translated">只针对这种情况 --</target>
        </trans-unit>
        <trans-unit id="f657c8e08093a6452319f9c30f992b884323f041" translate="yes" xml:space="preserve">
          <source>Optional.ifPresent invokes the given Consumer with a reference if it is a non-null value. Otherwise, it does nothing.</source>
          <target state="translated">Optional.ifPresent如果是一个非空值,则调用给定的Consumer。否则,它什么也不做。</target>
        </trans-unit>
        <trans-unit id="6a132feaa88e9eaf93ca9f96a1e7df9448ce9003" translate="yes" xml:space="preserve">
          <source>Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.</source>
          <target state="translated">或者如果你认为trycatch机制太难看,你的默认动作应该提供反馈给用户,而不是Do Nothing。</target>
        </trans-unit>
        <trans-unit id="f766e2839d0e27333563fdfa4a7af0a22bd85132" translate="yes" xml:space="preserve">
          <source>Or in your example:</source>
          <target state="translated">或者在你的例子中。</target>
        </trans-unit>
        <trans-unit id="8d0c023e0356e1bab468181b4ff498742ae4781b" translate="yes" xml:space="preserve">
          <source>PPS. For those fast to downvote (and not so fast to read documentation) I would like to say that I've never caught a null-pointer exception (NPE) in my life. But this possibility was &lt;strong&gt;intentionally designed&lt;/strong&gt; by the Java creators because NPE is a subclass of &lt;code&gt;Exception&lt;/code&gt;. We have a precedent in Java history when &lt;code&gt;ThreadDeath&lt;/code&gt; is an &lt;code&gt;Error&lt;/code&gt; not because it is actually an application error, but solely because it was not intended to be caught! How much NPE fits to be an &lt;code&gt;Error&lt;/code&gt; than &lt;code&gt;ThreadDeath&lt;/code&gt;! But it is not.</source>
          <target state="translated">PPS。 对于那些不愿投票的人（而不是那么快阅读文档的人），我想说我一生中从未遇到过空指针异常（NPE）。 但是这种可能性是Java创建者&lt;strong&gt;有意设计&lt;/strong&gt;的，因为NPE是 &lt;code&gt;Exception&lt;/code&gt; 的子类。 当 &lt;code&gt;ThreadDeath&lt;/code&gt; 为 &lt;code&gt;Error&lt;/code&gt; 时，我们在Java历史上已有先例，这不是因为它实际上是应用程序错误，而仅仅是因为它并非旨在被捕获！ 有多少NPE比 &lt;code&gt;ThreadDeath&lt;/code&gt; 更适合成为 &lt;code&gt;Error&lt;/code&gt; ！ 但事实并非如此。</target>
        </trans-unit>
        <trans-unit id="9ee03b92c278aefd505b6e54e78c9dc0b157ad7a" translate="yes" xml:space="preserve">
          <source>PS. This approach will be as reasonable to use as the &lt;em&gt;separate error-handling code from &quot;regular&quot; code&lt;/em&gt; principle is reasonable to use in some place. Consider the next example:</source>
          <target state="translated">PS。 使用这种方法将是合理的，因为在某些地方使用&lt;em&gt;与&amp;ldquo;常规&amp;rdquo;代码&lt;/em&gt;原理&lt;em&gt;分开的错误处理代码&lt;/em&gt;是合理的。 考虑下一个示例：</target>
        </trans-unit>
        <trans-unit id="ba90388bd4c171ca39fa6b73261783e63a2f28b2" translate="yes" xml:space="preserve">
          <source>Previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library.</source>
          <target state="translated">上一条导致正常的逻辑流程,从我的照片库中获取不存在的女朋友的照片。</target>
        </trans-unit>
        <trans-unit id="8f2b4864d43e2c92095e649bd1429a2c05d7ab61" translate="yes" xml:space="preserve">
          <source>Probably the best alternative for Java 8 or newer is to use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">对于Java 8或更高版本，最好的替代方法是使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt;类。</target>
        </trans-unit>
        <trans-unit id="18ac346b6a23f38378a9759b924291326484c819" translate="yes" xml:space="preserve">
          <source>Q. Redundant code could be executed and unnecessary resources could be grabbed.</source>
          <target state="translated">Q.冗余的代码可能会被执行,并抢占不必要的资源。</target>
        </trans-unit>
        <trans-unit id="60f3d300f344070bb3660651b4b7c84a7c1a7806" translate="yes" xml:space="preserve">
          <source>Q. This approach has a performance penalty due to the try closure opening.</source>
          <target state="translated">Q.这种方法由于尝试性的封闭式开局,有一定的性能惩罚。</target>
        </trans-unit>
        <trans-unit id="8ada7432c9d8ed60d8ddcb07057e3aa21a1cd988" translate="yes" xml:space="preserve">
          <source>Q. What if &lt;code&gt;getPhotoDataSource()&lt;/code&gt; returns null?</source>
          <target state="translated">问：如果 &lt;code&gt;getPhotoDataSource()&lt;/code&gt; 返回null怎么办？</target>
        </trans-unit>
        <trans-unit id="b0f21ff390c71b63fb33e4cf5b2e9b8e9cc3013f" translate="yes" xml:space="preserve">
          <source>Questions could arise:</source>
          <target state="translated">可能出现的问题。</target>
        </trans-unit>
        <trans-unit id="0c25c125f68f171e56c5dc46a5e78dbdc73323ed" translate="yes" xml:space="preserve">
          <source>Rather than Null Object Pattern -- which has its uses -- you might consider situations where the null object is a bug.</source>
          <target state="translated">与其说Null Object Pattern ----它有它的用处 ----你可以考虑空对象是bug的情况。</target>
        </trans-unit>
        <trans-unit id="4e1c9630619b3a985eea9596a353ce64e0b8e71b" translate="yes" xml:space="preserve">
          <source>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.
It is so clean and easy to understand. In the above code example, &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; gets invoked if the Optional holding reference is non-null.</source>
          <target state="translated">表示一个接受单个输入参数且不返回结果的操作。 与大多数其他功能接口不同，消费者有望通过副作用进行操作。 它是如此干净，易于理解。 在上面的代码示例中，如果Optional保持引用为非null，则调用 &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9951bd4cc66be1c5bf9d684cb3738fbaaf27a9b2" translate="yes" xml:space="preserve">
          <source>SO HOW EXACTLY IT HELPS TO AVOID A NULL CHECK?</source>
          <target state="translated">那么,它到底是如何帮助避免无效检查的呢?</target>
        </trans-unit>
        <trans-unit id="12ebfd30869dc6d7d284fbd49560456e553ae1a4" translate="yes" xml:space="preserve">
          <source>See blog post &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;More flexible and configurable @Nullable/@NotNull annotations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">请参阅博客文章&lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;更灵活和可配置的@ Nullable / @ NotNull批注&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c614bff3bcea0ba91a4e4fc674cacfdf5b3e3421" translate="yes" xml:space="preserve">
          <source>So I branch, and do two completely different things. There is no ugly code snippet, because I really need to do two different things depending on the data. For example, should I work on the input, or should I calculate a good default value?</source>
          <target state="translated">所以我分支,做了两件完全不同的事情。没有难看的代码片段,因为我真的需要根据数据的不同,做两件不同的事情。比如说,我是应该在输入上下功夫,还是应该计算出一个好的默认值?</target>
        </trans-unit>
        <trans-unit id="ab095d82204599c2467871a3efe97685e021b767" translate="yes" xml:space="preserve">
          <source>So there is no difference between:</source>
          <target state="translated">所以没有什么区别。</target>
        </trans-unit>
        <trans-unit id="3832db2f40c93881b178af60f45fd152a79ed806" translate="yes" xml:space="preserve">
          <source>So, IMHO, null must be a critical error which prevents further execution (that is, where null is not a valid value).</source>
          <target state="translated">所以,IMHO,null一定是一个重要的错误,它阻止了进一步的执行(也就是说,null不是一个有效值)。</target>
        </trans-unit>
        <trans-unit id="91316cbc500c43d5b77c2b413a3f65b2f65958c8" translate="yes" xml:space="preserve">
          <source>Sometimes, you have methods that operate on its parameters that define a symmetric operation:</source>
          <target state="translated">有时,你会有方法对其参数进行操作,定义了一个对称的操作。</target>
        </trans-unit>
        <trans-unit id="b8ca7bcd4b5f1acf3e5ba33e4a5f508dec7dea54" translate="yes" xml:space="preserve">
          <source>Sure do have a look at Aspect Oriented Programming, too - they have neat ways to insert &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; into your bytecode.</source>
          <target state="translated">当然也可以看看面向方面的编程-它们有巧妙的方法将 &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; 插入您的字节码中。</target>
        </trans-unit>
        <trans-unit id="6f4cfb67cdd3b5f824a9934a1ed6c1fca9c1fc27" translate="yes" xml:space="preserve">
          <source>That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.</source>
          <target state="translated">话虽如此,但也许让 findAction()方法抛出一个带有有意义的错误信息的 Exception 是完全合适的 ----特别是在这种情况下,当你依赖用户输入的时候。让findAction方法抛出一个Exception比让调用方法抛出一个简单的NullPointerException而不做解释要好得多。</target>
        </trans-unit>
        <trans-unit id="7047d7ff31541da135908e8ecd7f812faea65471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?.&lt;/code&gt; means only de-reference the left identifier if it is not null, otherwise evaluate the remainder of the expression as &lt;code&gt;null&lt;/code&gt;. Some people, like Java Posse member Dick Wall and the &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;voters at Devoxx&lt;/a&gt; really love this proposal, but there is opposition too, on the grounds that it will actually encourage more use of &lt;code&gt;null&lt;/code&gt; as a sentinel value.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 表示仅在不为null的情况下取消引用左标识符，否则将表达式的其余部分评估为 &lt;code&gt;null&lt;/code&gt; 。 有些人，例如Java Posse成员Dick Wall和&lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;Devoxx&lt;/a&gt;的选民确实喜欢这个提议，但也有人反对，理由是它实际上会鼓励更多地使用 &lt;code&gt;null&lt;/code&gt; 作为定点值。</target>
        </trans-unit>
        <trans-unit id="78bbb74ffaaf0217ff4697c6fb561008da9384db" translate="yes" xml:space="preserve">
          <source>The Google collections framework offers a good and elegant way to achieve the null check.</source>
          <target state="translated">谷歌的收藏框架提供了一种很好的、优雅的方式来实现空检。</target>
        </trans-unit>
        <trans-unit id="1d0b369ef777f99443515fd98b70d6cbe6356789" translate="yes" xml:space="preserve">
          <source>The StringUtils class is only one of many; there are quite a few good classes in the commons that do null safe manipulation.</source>
          <target state="translated">StringUtils类只是众多类中的一个;在commonons中,有不少好的类可以做null安全操作。</target>
        </trans-unit>
        <trans-unit id="b3066493bcd46f61316ddaca0d5573d18b01f7cd" translate="yes" xml:space="preserve">
          <source>The compiler forces you to handle the &quot;undefined&quot; case.</source>
          <target state="translated">编译器强制你处理 &quot;未定义 &quot;的情况。</target>
        </trans-unit>
        <trans-unit id="11db0d52c7259e3f5542cc11ae35ecc39a7f84be" translate="yes" xml:space="preserve">
          <source>The complete post is &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE as well as Null check-free code &amp;hellip; Really?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">完整的帖子是&lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE以及Null免提代码&amp;hellip;真的吗？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f36738048a72c2ff14555a1f49f971e924f9660" translate="yes" xml:space="preserve">
          <source>The contracts are like mini-unit tests which are always running, even in production, and when things fail, you know why, rather than a random NPE you have to somehow figure out.</source>
          <target state="translated">合同就像迷你单元测试一样,即使在生产中也会一直在运行,当事情失败时,你就会知道原因,而不是随机的NPE,你要想办法找出原因。</target>
        </trans-unit>
        <trans-unit id="8b07fde497d833a3dea4d5d1623ff04bff7cd150" translate="yes" xml:space="preserve">
          <source>The example given by Alex Miller looks like this:</source>
          <target state="translated">亚历克斯-米勒所举的例子是这样的。</target>
        </trans-unit>
        <trans-unit id="6b1e5e00880fd770c374b1874c5898efc9b29533" translate="yes" xml:space="preserve">
          <source>The message will contain the following text if, for example, &quot;plans&quot; is null:</source>
          <target state="translated">如果 &quot;计划 &quot;为空,该消息将包含以下文字:</target>
        </trans-unit>
        <trans-unit id="50acd96098203094b440f2ee9754742ef52b2da0" translate="yes" xml:space="preserve">
          <source>The method is most useful for &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;checking&lt;/a&gt; just before an assignment in a constructor, where each use of it can save three lines of code:</source>
          <target state="translated">该方法对于&lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;检查&lt;/a&gt;构造函数中的赋值之前最有用，该方法每次使用都可以节省三行代码：</target>
        </trans-unit>
        <trans-unit id="e93d133895627c9a3d74a6c30e204dcdb8e532ac" translate="yes" xml:space="preserve">
          <source>The only other methods which do not check for null are utility methods. They are public, but if you call them for some reason, you know what parameters you pass. This is like trying to boil water in the kettle without providing water...</source>
          <target state="translated">唯一不检查null的其他方法是实用程序方法。它们是公共的,但如果你因为某种原因调用它们,你就知道你传递了什么参数。这就像在不提供水的情况下,试图在水壶中烧开水一样......</target>
        </trans-unit>
        <trans-unit id="3071661bc3a8f3f1fb050d846047c85545570484" translate="yes" xml:space="preserve">
          <source>The second example won't compile (in IntelliJ IDEA).</source>
          <target state="translated">第二个例子无法编译(在IntelliJ IDEA中)。</target>
        </trans-unit>
        <trans-unit id="d6530e4dc64d23e3133b0d5fd801c0b069e04e94" translate="yes" xml:space="preserve">
          <source>The way I solve this problem is this:</source>
          <target state="translated">我解决这个问题的方法是这样的。</target>
        </trans-unit>
        <trans-unit id="8b0438900bb10b9989752d1f3c4b40b7f47f6df7" translate="yes" xml:space="preserve">
          <source>Then, in the rest of that method, you'll know that &lt;code&gt;object&lt;/code&gt; is not null.</source>
          <target state="translated">然后，在该方法的其余部分中，您将知道 &lt;code&gt;object&lt;/code&gt; 不为null。</target>
        </trans-unit>
        <trans-unit id="79a6826b25f58343482759c32d1843c3fcfde425" translate="yes" xml:space="preserve">
          <source>There is a method in a library class like this:</source>
          <target state="translated">在库类中有这样一个方法。</target>
        </trans-unit>
        <trans-unit id="7b611806237c884a66462ab8d01c1db4a0455d83" translate="yes" xml:space="preserve">
          <source>There is a proposal to add new annotations in Java7 to help with null / notnull params:
&lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</source>
          <target state="translated">有人建议在Java7中添加新的注释以帮助处理null / notnull参数： &lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http&lt;/a&gt; ://tech.puredanger.com/java7/#jsr308</target>
        </trans-unit>
        <trans-unit id="bdcc90e0f67eeda9f92fa7029efb8f80e4f6cda3" translate="yes" xml:space="preserve">
          <source>There is a tiny overhead in this, but it's worth it for cleaner code and less NullPointerExceptions.</source>
          <target state="translated">这样做会有很小的开销,但为了更干净的代码和更少的NullPointerExceptions,这样做是值得的。</target>
        </trans-unit>
        <trans-unit id="a995a0c78ad44e2ea78fecf0b6b5ae088210dbfb" translate="yes" xml:space="preserve">
          <source>They both want to make sure that we received valid parameters, before we do any other functions.</source>
          <target state="translated">他们都希望在我们做其他功能之前,先确定我们收到了有效的参数。</target>
        </trans-unit>
        <trans-unit id="0de62a4c684b4be885c335e3c1f969aeb6ca39e3" translate="yes" xml:space="preserve">
          <source>They work like that:</source>
          <target state="translated">他们的工作就是这样。</target>
        </trans-unit>
        <trans-unit id="6da291a4214849ad22b47d77f7b9e5c7c2ed3dbb" translate="yes" xml:space="preserve">
          <source>This checks for a &lt;code&gt;NullPointerException&lt;/code&gt; for the &lt;code&gt;someobject&lt;/code&gt; object in the above snippet.</source>
          <target state="translated">这将检查上述代码段中 &lt;code&gt;someobject&lt;/code&gt; 对象的 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a632edab67a162af8d6236e911205c0bd2945507" translate="yes" xml:space="preserve">
          <source>This is a very common problem for every Java developer. So there is official support in Java&amp;nbsp;8 to address these issues without cluttered code.</source>
          <target state="translated">对于每个Java开发人员来说，这都是一个非常普遍的问题。 因此，Java 8在没有混乱代码的情况下提供了官方支持来解决这些问题。</target>
        </trans-unit>
        <trans-unit id="63475a15e2d7175b43a8eb4ced243071760761e7" translate="yes" xml:space="preserve">
          <source>This is defensive programming and results in much cleaner code in the long run. Always sanitize the data, e.g. here by enforcing rigid standards, and the problems go away.</source>
          <target state="translated">这是防御性编程,从长远来看,这样做的结果是代码更干净。总是对数据进行消毒处理,比如这里通过执行刚性标准,问题就会消失。</target>
        </trans-unit>
        <trans-unit id="96855dbf651af7ee23c0764f0f76d95841159676" translate="yes" xml:space="preserve">
          <source>This is especially handy for long chains of possible null values. Example:</source>
          <target state="translated">这对于可能的空值的长链特别方便。举例说明。</target>
        </trans-unit>
        <trans-unit id="ab20b6e950b963a0a9153b9bd523a03c124b9ceb" translate="yes" xml:space="preserve">
          <source>This is slightly better than:</source>
          <target state="translated">这一点稍好于。</target>
        </trans-unit>
        <trans-unit id="4f0f6bf669b0e6c235196e52c58820b609d7a7a9" translate="yes" xml:space="preserve">
          <source>This is the most common error occurred for most of the developers.</source>
          <target state="translated">这是大多数开发者最常发生的错误。</target>
        </trans-unit>
        <trans-unit id="2c2ef7f8c0c5f5953f9d8dc9f87238113a866d47" translate="yes" xml:space="preserve">
          <source>This really depends. If find that I often do something like this:</source>
          <target state="translated">这真的要看情况。如果发现我经常做这样的事情。</target>
        </trans-unit>
        <trans-unit id="5f65d63d47b93827d172b66566e2699ba53e9246" translate="yes" xml:space="preserve">
          <source>This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don't know or don't trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.</source>
          <target state="translated">在我看来,这听起来像是初级到中级开发人员往往会在某个时候面临的一个合理的常见问题:他们要么不知道或者不信任他们所参与的合约,并且防御性地过度检查空值。此外,在编写自己的代码时,他们往往会依赖返回nulls来表示一些东西,从而要求调用者检查nulls。</target>
        </trans-unit>
        <trans-unit id="d66c4aae334386fa18d2bf51fc0dd0e22c5fcd02" translate="yes" xml:space="preserve">
          <source>This way, the code is clean, easy maintainable and readable.</source>
          <target state="translated">这样一来,代码干净利落,易维护,可读性强。</target>
        </trans-unit>
        <trans-unit id="88e9d9f0b01df7bd366fd6f414813582c76c2a26" translate="yes" xml:space="preserve">
          <source>This won't compile.</source>
          <target state="translated">这个不能编译。</target>
        </trans-unit>
        <trans-unit id="03a1146d56211c08b24efbc23fe64db2a1fe9e19" translate="yes" xml:space="preserve">
          <source>To implement this pattern in java, you can use core java annotations like &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; or use more sophisticated libraries like &lt;strong&gt;Hibernate Validator&lt;/strong&gt;.</source>
          <target state="translated">要在Java中实现此模式，可以使用核心Java批注（如&lt;strong&gt;javax.annotation.NotNull）&lt;/strong&gt;或使用更复杂的库（如&lt;strong&gt;Hibernate Validator）&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="65dd044ab70d140d1269ad7b58d585a319cf8c8e" translate="yes" xml:space="preserve">
          <source>To put this another way, there are two instances where null checking comes up:</source>
          <target state="translated">换个说法,有两种情况下会出现无效检查。</target>
        </trans-unit>
        <trans-unit id="893faf3275f29660c0345c697429903da97cca3c" translate="yes" xml:space="preserve">
          <source>Try to make all your attributes and its accessors as private as possible or avoid to  expose them to the clients at all. You can have the argument values in the constructor of course, but by reducing the scope you don't let the client class pass an invalid value. If you need to modify the values, you can always create a new &lt;code&gt;object&lt;/code&gt;.  You check the values in the constructor only &lt;strong&gt;once&lt;/strong&gt; and in the rest of the methods you can be almost sure that the values are not null.</source>
          <target state="translated">尝试使所有属性及其访问者尽可能地私有，或者完全避免将其公开给客户端。 您当然可以在构造函数中使用参数值，但是通过减小范围，您不会让客户端类传递无效的值。 如果需要修改值，则始终可以创建一个新 &lt;code&gt;object&lt;/code&gt; 。 您只需检查构造函数中的值&lt;strong&gt;一次，&lt;/strong&gt;而在其余方法中，几乎可以确定这些值不为null。</target>
        </trans-unit>
        <trans-unit id="5096108c9ee2936b6660a55e9c083bcd59532700" translate="yes" xml:space="preserve">
          <source>Ultimately, the only way to completely solve this problem is by using a different programming language:</source>
          <target state="translated">归根结底,要彻底解决这个问题,唯一的办法就是使用不同的编程语言。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="91e3b61c16f5d43c2c292405b4146327e9221a06" translate="yes" xml:space="preserve">
          <source>Using parameter</source>
          <target state="translated">使用参数</target>
        </trans-unit>
        <trans-unit id="410ecb47e87fed6b528cde0e827e193125ef8e2c" translate="yes" xml:space="preserve">
          <source>WRAPPING TO OPTION&amp;lt;T&amp;gt;</source>
          <target state="translated">包装到选项&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16139730df851e7de2b4d9ecb2a4976efb2493cf" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;usually&lt;/strong&gt; face this issue when the methods get the parameters in the way we not expected (bad method call is programmer's fault). For example: you expect to get an object, instead you get a null. You expect to get an String with at least one character, instead you get an empty String ...</source>
          <target state="translated">当方法以非预期的方式获取参数时， &lt;strong&gt;通常会&lt;/strong&gt;遇到此问题（错误的方法调用是程序员的错）。 例如：您期望获得一个对象，而是获得一个null。 您期望获得至少包含一个字符的字符串，而不是一个空字符串...</target>
        </trans-unit>
        <trans-unit id="81d7e415e730d427573e6b4ff607e889a2cb73ec" translate="yes" xml:space="preserve">
          <source>We have number of ways to handle this.</source>
          <target state="translated">我们有一些方法来处理这个问题。</target>
        </trans-unit>
        <trans-unit id="0f598db2507984034e96ef0808dfe220b74dab82" translate="yes" xml:space="preserve">
          <source>We use the ternary operator very often for checking null condition and return an alternative value or default value. Optional provides another way to handle the same condition without checking null. Optional.orElse(defaultObj) returns defaultObj if the Optional has a null value. Let's use this in our sample code:</source>
          <target state="translated">我们经常使用三元运算符来检查null条件,并返回一个替代值或默认值。Optional提供了另一种处理相同条件而不检查null条件的方法。Optional.orElse(defaultObj)如果Optional有一个null值,则返回defaultObj。让我们在示例代码中使用这个方法。</target>
        </trans-unit>
        <trans-unit id="1b7de74b75d773507feae3e01547f3abd8a8e794" translate="yes" xml:space="preserve">
          <source>When the exception is thrown, examine the stack trace and work through the bug.</source>
          <target state="translated">当抛出异常时,检查堆栈跟踪,并通过bug进行处理。</target>
        </trans-unit>
        <trans-unit id="56f60bd1b035c1637de885e8364d676ed25dd3d5" translate="yes" xml:space="preserve">
          <source>When you use the first &lt;code&gt;helloWorld()&lt;/code&gt; function in another piece of code:</source>
          <target state="translated">在另一段代码中使用第一个 &lt;code&gt;helloWorld()&lt;/code&gt; 函数时：</target>
        </trans-unit>
        <trans-unit id="79b6177f112f6c351c671521cc708abf0dbc2ef4" translate="yes" xml:space="preserve">
          <source>Where it isn't a valid response.</source>
          <target state="translated">哪里不是有效的回应。</target>
        </trans-unit>
        <trans-unit id="35c99b0c8fc1f9ea3f573be119257028ced0e610" translate="yes" xml:space="preserve">
          <source>Where null is a valid response in terms of the contract; and</source>
          <target state="translated">(a)在合同规定的有效答复为空的情况下;以及</target>
        </trans-unit>
        <trans-unit id="cdfe105c8bfbcc3b13ac6840fef58d8c1666a5a4" translate="yes" xml:space="preserve">
          <source>While it is rather 'normal business flow' not to find photo stored into the DB for some person, I used to use pairs like below for some other cases</source>
          <target state="translated">虽然不为某些人找到存储到DB中的照片是相当 &quot;正常的业务流程&quot;,但我曾经在其他一些情况下使用过像下面这样的对子</target>
        </trans-unit>
        <trans-unit id="580ecabb6906d2e8e175eeee96c8cd0b5d5e79e0" translate="yes" xml:space="preserve">
          <source>With Java 8 comes the new &lt;code&gt;java.util.Optional&lt;/code&gt; class that arguably solves some of the problem. One can at least say that it improves the readability of the code, and in the case of public APIs make the API's contract clearer to the client developer.</source>
          <target state="translated">Java 8附带了新的 &lt;code&gt;java.util.Optional&lt;/code&gt; 类，可以解决某些问题。 至少可以说，它提高了代码的可读性，并且在使用公共API的情况下，使API合同对客户开发人员更加清晰。</target>
        </trans-unit>
        <trans-unit id="2f3836243579dcf0aab46f92bd120d19df8df941" translate="yes" xml:space="preserve">
          <source>With non-collections it might be harder.  Consider this as an example: if you have these interfaces:</source>
          <target state="translated">对于非集合,可能会更难。以此为例:如果你有这些接口。</target>
        </trans-unit>
        <trans-unit id="a5b1abb2eabdd6b338fefcfe915a795e0025f2b9" translate="yes" xml:space="preserve">
          <source>Wow, I almost hate to add another answer when we have 57 different ways to recommend the &lt;code&gt;NullObject pattern&lt;/code&gt;, but I think that some people interested in this question may like to know that there is a proposal on the table for Java 7 to add &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;null-safe handling&quot;&lt;/a&gt;&amp;mdash;a streamlined syntax for if-not-equal-null logic.</source>
          <target state="translated">哇，当我们有57种不同的方法推荐 &lt;code&gt;NullObject pattern&lt;/code&gt; 时，我几乎不愿意添加另一个答案，但是我认为对这个问题感兴趣的某些人可能想知道在Java 7桌上有一个建议添加&lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&amp;ldquo; null&amp;rdquo; -&amp;ldquo;安全处理&amp;rdquo;-if&lt;/a&gt; -not-equal-null逻辑的简化语法。</target>
        </trans-unit>
        <trans-unit id="951af1231b6d7d7d241620882f25427c99d9e5db" translate="yes" xml:space="preserve">
          <source>You can avoid that if you compare your &lt;code&gt;String&lt;/code&gt;s like this:</source>
          <target state="translated">如果像这样比较 &lt;code&gt;String&lt;/code&gt; ，则可以避免这种情况：</target>
        </trans-unit>
        <trans-unit id="c7f4edd11fb336e0c393189054436b5ea0dd3965" translate="yes" xml:space="preserve">
          <source>You can go a step further and make sure that only valid pojos could be created in your application. (sample from hibernate validator site)</source>
          <target state="translated">你可以更进一步,确保你的应用程序中只有有效的pojos可以被创建。(样本来自hibernate验证器网站)</target>
        </trans-unit>
        <trans-unit id="b426fa3dff81bdf8322ce5f08dc73d3a6c054889" translate="yes" xml:space="preserve">
          <source>You can use in method and parameters, like this:</source>
          <target state="translated">你可以在方法和参数中使用,就像这样。</target>
        </trans-unit>
        <trans-unit id="f52d6127cbef2caa2515fee8335a6cf4b50a3ecc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map()&lt;/code&gt; operator to perform a computation on--or extract a value from--an optional object.  &lt;code&gt;orElse()&lt;/code&gt; lets you provide a fallback for missing values.</source>
          <target state="translated">您可以使用 &lt;code&gt;map()&lt;/code&gt; 运算符对可选对象执行计算或从中提取值。 &lt;code&gt;orElse()&lt;/code&gt; 允许您为缺少的值提供备用。</target>
        </trans-unit>
        <trans-unit id="1d33b9baf8ae290074a6e9952500c20b8c202dd6" translate="yes" xml:space="preserve">
          <source>You have to check for object != null only if you want to handle the case where the object may be null...</source>
          <target state="translated">如果你想处理对象可能为null的情况,你必须检查对象 !=null......</target>
        </trans-unit>
        <trans-unit id="5146850a0aff4c1b7d4e622f1b93cada470ef71b" translate="yes" xml:space="preserve">
          <source>You might configure your IDE to warn you about potential null dereferencing. E.g. in Eclipse, see &lt;em&gt;Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors/Warnings/Null analysis&lt;/em&gt;.</source>
          <target state="translated">您可以将IDE配置为警告您有关可能的空取消引用。 例如，在Eclipse中，请参见&lt;em&gt;首选项&amp;gt; Java&amp;gt;编译器&amp;gt;错误/警告/空分析&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f4a16be11579dd7183f0b53dba9326d6fee7a45" translate="yes" xml:space="preserve">
          <source>allow the Exceptions to ripple through - catch them at the 'main loop' or in some other managing routine.</source>
          <target state="translated">容许异常的发生--在 &quot;主循环 &quot;或其他管理例程中抓住它们。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a91d8763ddd012bd694861a83ced3c22ba85ef5a" translate="yes" xml:space="preserve">
          <source>check for error conditions and handle them appropriately</source>
          <target state="translated">查漏补缺,妥善处理</target>
        </trans-unit>
        <trans-unit id="242af77b8af1f9f1f76f01852e12bf007ce5565b" translate="yes" xml:space="preserve">
          <source>if you write something like:</source>
          <target state="translated">如果你写了这样的东西:</target>
        </trans-unit>
        <trans-unit id="37b00e27e7160b5c20659252018b000c5884b58a" translate="yes" xml:space="preserve">
          <source>notNull(Object object, String message)</source>
          <target state="translated">notNull(Object object,String message)</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7f59b1d21b6092bc9549f5f4ed93ec595233ec73" translate="yes" xml:space="preserve">
          <source>or (depending on what you need to check):</source>
          <target state="translated">或(视你需要检查的内容而定)。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="8175c105a4fbc0c1bfbecc0778b58cf2689a03e3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; is a boolean expression and &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; is an object whose &lt;code&gt;toString()&lt;/code&gt; method's output will be included in the error.</source>
          <target state="translated">其中， &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; 是布尔表达式， &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 是一个对象，其 &lt;code&gt;toString()&lt;/code&gt; 方法的输出将包含在错误中。</target>
        </trans-unit>
        <trans-unit id="66933b5352b59bac31f84234608a5d23ea089515" translate="yes" xml:space="preserve">
          <source>where Parser takes raw user input and finds something to do, perhaps if you're implementing a command line interface for something.  Now you might make the contract that it returns null if there's no appropriate action.  That leads the null checking you're talking about.</source>
          <target state="translated">Parser接收原始的用户输入,然后找到要做的事情,也许如果你正在实现一个命令行接口的东西。现在,你可以让它在没有合适的操作时返回null。这就导致了你所说的null检查。</target>
        </trans-unit>
        <trans-unit id="880c9234e5994e5388ead855bf7ee74adb695efb" translate="yes" xml:space="preserve">
          <source>which is a much better design because it leads to more concise code.</source>
          <target state="translated">这是一个更好的设计,因为它导致了更简洁的代码。</target>
        </trans-unit>
        <trans-unit id="85d0952dedf1cf905b6bd07f33e02911381c8fd1" translate="yes" xml:space="preserve">
          <source>will result in a &lt;code&gt;NullPointerException&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; doesn't exist.</source>
          <target state="translated">如果 &lt;code&gt;foo&lt;/code&gt; 不存在，将导致 &lt;code&gt;NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
