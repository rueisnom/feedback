<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/271526">
    <body>
      <group id="271526">
        <trans-unit id="8c66c64b2bf5dce0f66d6a803ea6b6b85f2bd101" translate="yes" xml:space="preserve">
          <source>&quot;&lt;strong&gt;Illegal argument value null is encountered for parameter [plans]&lt;/strong&gt;&quot;</source>
          <target state="translated">&quot; &lt;strong&gt;Недопустимое значение аргумента null для параметра [планы]&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="3203cd5f2dfad1b7f4c9811b531d23931fbb7a62" translate="yes" xml:space="preserve">
          <source>(1) is a little harder.  If you have no control over the code you're calling then you're stuck.  If null is a valid response, you have to check for it.</source>
          <target state="translated">(1)немного сложнее.Если ты не контролируешь код,который ты звонишь,то ты застрял.Если ноль-это правильный ответ,вы должны его проверить.</target>
        </trans-unit>
        <trans-unit id="a072e9edaf03771b557f7cc2e3b70299591cad35" translate="yes" xml:space="preserve">
          <source>(2) is easy.  Either use &lt;code&gt;assert&lt;/code&gt; statements (assertions) or allow failure (for example,  &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt;).  Assertions are a highly-underused Java feature that was added in 1.4.  The syntax is:</source>
          <target state="translated">(2) легко. Либо используйте операторы &lt;code&gt;assert&lt;/code&gt; (утверждения), либо допустите ошибку (например, &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt; ). Утверждения - это сильно недоиспользуемая функция Java, которая была добавлена ​​в 1.4. Синтаксис:</target>
        </trans-unit>
        <trans-unit id="69704da627fa56fa83a9194ab8bb332a79074ac1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option is a monad&lt;/a&gt;, so there is no need for verbose null checking, just use map/foreach/getOrElse or a similar combinator to safely use the value &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(example)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option является монадой&lt;/a&gt; , поэтому нет необходимости в многословной проверке нуля, просто используйте map / foreach / getOrElse или аналогичный комбинатор для безопасного использования значения &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(пример)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46cc192e40835e83a2ea87cb1bc5d7df3ef20578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt; is a &lt;em&gt;Runtime exception&lt;/em&gt; that means it's developers fault and with enough experience it tells you exactly where is the error.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; - &lt;em&gt;исключение времени выполнения,&lt;/em&gt; которое означает, что это ошибка разработчиков, и с достаточным опытом это точно скажет, где ошибка.</target>
        </trans-unit>
        <trans-unit id="31c3bcb907f016d87b77fd8396afc5c0a9d646b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is a way of replacing a nullable T reference with a
  non-null value. An Optional may either contain a non-null T reference
  (in which case we say the reference is &quot;present&quot;), or it may contain
  nothing (in which case we say the reference is &quot;absent&quot;). It is never
  said to &quot;contain null.&quot;</source>
          <target state="translated">&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; - это способ замены нулевой ссылки на T ненулевым значением. Необязательный может либо содержать ненулевую ссылку T (в этом случае мы говорим, что ссылка &amp;laquo;присутствует&amp;raquo;), либо он может ничего не содержать (в этом случае мы говорим, что ссылка &amp;laquo;отсутствует&amp;raquo;). Никогда не говорится, что он содержит &amp;laquo;ноль&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="795a75979fcb8e946ecd45684159328ee5bf5b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&lt;/code&gt; offers other convenient methods, such as &lt;code&gt;orElse&lt;/code&gt; that allow the use of a default value, and &lt;code&gt;ifPresent&lt;/code&gt; that works with &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Optional&lt;/code&gt; предлагает другие удобные методы, такие как &lt;code&gt;orElse&lt;/code&gt; , которые позволяют использовать значение по умолчанию, и &lt;code&gt;ifPresent&lt;/code&gt; , который работает с &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;лямбда-выражениями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="556c1089ee2ae80da8a26a4b08cfdc720295a1b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you have to deal with an API which might return nulls&lt;/em&gt;, you can't do much in Java. Xtend and Groovy have the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; and the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;null-safe dereference operator&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt;, but note that this returns null in case of a null reference, so it just &quot;defers&quot; the proper handling of null.</source>
          <target state="translated">&lt;em&gt;Если вам приходится иметь дело с API, который может возвращать нули&lt;/em&gt; , вы не можете сделать многое в Java. В Xtend и Groovy есть &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;оператор Элвиса&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; И &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;нулевой безопасный оператор разыменования&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; , но обратите внимание, что это возвращает нуль в случае нулевой ссылки, так что это просто &quot;откладывает&quot; правильную обработку нуля.</target>
        </trans-unit>
        <trans-unit id="d1609ca504bef341cd938af5cc5c00b4d319ceb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to define a new API where undefined values make sense&lt;/em&gt;, use the &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Option Pattern&lt;/a&gt; (may be familiar from functional languages). It has the following advantages:</source>
          <target state="translated">&lt;em&gt;Если вы хотите определить новый API, в котором неопределенные значения имеют смысл&lt;/em&gt; , используйте &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;шаблон параметров&lt;/a&gt; (может быть знаком по функциональным языкам). Имеет следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="9e6ce6480f1f89172e257cc33912ba94b061ffa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; An &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;official proposal&lt;/a&gt; for a null-safe operator in Java 7 has been submitted under &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; The syntax is a little different than the example above, but it's the same notion.</source>
          <target state="translated">&lt;em&gt;Обновление:&lt;/em&gt; &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;официальное предложение&lt;/a&gt; для нуль-безопасного оператора в Java 7 было представлено в &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; Синтаксис немного отличается от приведенного выше примера, но это то же самое понятие.</target>
        </trans-unit>
        <trans-unit id="d03cf75fd803a5cd91e6e06263f455b21a109fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; The null-safe operator proposal didn't make it into Project Coin. So, you won't be seeing this syntax in Java 7.</source>
          <target state="translated">&lt;em&gt;Обновление: предложение&lt;/em&gt; нулевого безопасного оператора не попало в Project Coin. Таким образом, вы не увидите этот синтаксис в Java 7.</target>
        </trans-unit>
        <trans-unit id="7e57dd158da7749eeb4adc7330e0e7f8c7be6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подход 1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a45037cfed52a95964a4b6663009985c519b3729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подход 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b038e1f7a0e785f507e502bb3ed742df87515a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подход 3:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80381f286585ad9109cf5867a45ab2d5ebfacaca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подход 4:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22fb44a7606c8a8e6c1eaf89ff705a2805a4a66f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check for 'No data' only if business logic implies it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Проверяйте &amp;laquo;Нет данных&amp;raquo;, только если это подразумевает бизнес-логика.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30f5b35acd55daabe9c5d79fbb13c7d538970512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an 'unknown question' give 'unknown answer'.&lt;/strong&gt; (Be null-safe where this is correct from business point of view) Checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call.</source>
          <target state="translated">&lt;strong&gt;Для &amp;laquo;неизвестного вопроса&amp;raquo; дайте &amp;laquo;неизвестный ответ&amp;raquo;.&lt;/strong&gt; (Будьте безопасны с нулевым значением, если это правильно с деловой точки зрения) Проверка аргументов на нулевое значение один раз внутри метода перед использованием освобождает нескольких вызывающих от проверки их перед вызовом.</target>
        </trans-unit>
        <trans-unit id="17a0daea56744b70e6139473e9163ad0064ca4c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is rather theoretical case and in most cases you should prefer java null safe API (in case it will be released in another 10 years), but &lt;code&gt;NullPointerException&lt;/code&gt; is subclass of an &lt;code&gt;Exception&lt;/code&gt;.&lt;/strong&gt; Thus it is a form of &lt;code&gt;Throwable&lt;/code&gt; that indicates conditions that a reasonable application might want to catch (&lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt;)! To use the first most advantage of exceptions and separate error-handling code from 'regular' code (&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;according to creators of Java&lt;/a&gt;) it is appropriate, as for me, to catch &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Это довольно теоретический случай, и в большинстве случаев вам следует предпочесть java нуль-безопасный API (в случае, если он будет выпущен через 10 лет), но &lt;code&gt;NullPointerException&lt;/code&gt; является подклассом &lt;code&gt;Exception&lt;/code&gt; .&lt;/strong&gt; Таким образом, это форма &lt;code&gt;Throwable&lt;/code&gt; , которая указывает условия, которые разумное приложение может захотеть поймать ( &lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt; )! Чтобы использовать первое из преимуществ исключений и отделить код обработки ошибок от &amp;laquo;обычного&amp;raquo; кода ( &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;по словам создателей Java&lt;/a&gt; ), уместно, как по мне, перехватить &lt;code&gt;NullPointerException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32581af00703ba13e0e48e757a8de5a8956459bb" translate="yes" xml:space="preserve">
          <source>A. It could take place if &lt;code&gt;getPhotoByName()&lt;/code&gt; would try to open a database connection, create &lt;code&gt;PreparedStatement&lt;/code&gt; and use the person name as an SQL parameter at last. The approach &lt;em&gt;for an unknown question gives an unknown answer&lt;/em&gt; (case 1) works here. Before grabbing resources the method should check parameters and return 'unknown' result if needed.</source>
          <target state="translated">&lt;code&gt;getPhotoByName()&lt;/code&gt; Это может произойти, если getPhotoByName () попытается открыть соединение с базой данных, создать &lt;code&gt;PreparedStatement&lt;/code&gt; и, наконец, использовать имя человека в качестве параметра SQL. Подход &lt;em&gt;к неизвестному вопросу дает неизвестный ответ&lt;/em&gt; (случай 1) работает здесь. Перед захватом ресурсов метод должен проверить параметры и вернуть &amp;laquo;неизвестный&amp;raquo; результат, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="d442bac768e012a67d8005e207d2f07c7f49c725" translate="yes" xml:space="preserve">
          <source>A. It is up to business logic. If I fail to find a photo album I'll show you no photos. What if appContext is not initialized? This method's business logic puts up with this. If the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). The &lt;strong&gt;new Java Null-safe API fits better here to specify selectively what implies and what does not imply to be initialized&lt;/strong&gt; to be fail-fast in case of programmer errors.</source>
          <target state="translated">О. Это зависит от бизнес-логики. Если я не смогу найти фотоальбом, я не покажу вам фотографий. Что если appContext не инициализирован? Бизнес-логика этого метода мирится с этим. Если та же логика должна быть более строгой, чем генерирование исключения, это является частью бизнес-логики, и следует использовать явную проверку на нулевое значение (случай 3). &lt;strong&gt;Новый Java Null-safe API лучше подходит для того, чтобы выборочно указывать, что подразумевается, а что не означает, что инициализация&lt;/strong&gt; должна быть безотказной в случае ошибок программиста.</target>
        </trans-unit>
        <trans-unit id="9f2811ffff90eaa563c42e280cf9e259110f4e13" translate="yes" xml:space="preserve">
          <source>A. Software should be easy to understand and modify firstly. Only after this, one could think about performance, and only if needed! and where needed! (&lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;source&lt;/a&gt;), and many others).</source>
          <target state="translated">О. Программное обеспечение должно быть легко понять и изменить в первую очередь. Только после этого можно думать о производительности и только при необходимости! и где нужно! ( &lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;источник&lt;/a&gt; ) и многие другие).</target>
        </trans-unit>
        <trans-unit id="8d12b90120d6345989195a1a87e9ec644b614091" translate="yes" xml:space="preserve">
          <source>All private methods do not check for null since they are controlled methods (just let die with nullpointer exception in case it wasn't handled above)</source>
          <target state="translated">Все приватные методы не проверяются на наличие нуля,так как они являются управляемыми методами (просто пусть погибает с исключением нулевого указателя,если он не был обработан выше).</target>
        </trans-unit>
        <trans-unit id="2d362b47b1b8f524063ce05592e2517660992d07" translate="yes" xml:space="preserve">
          <source>All public methods / API always check its arguments for null</source>
          <target state="translated">Все публичные методы API всегда проверяют свои аргументы на ноль</target>
        </trans-unit>
        <trans-unit id="651180d90e7fac397932e649f57913d6e17cbdb5" translate="yes" xml:space="preserve">
          <source>Also I would not recommend using this pattern where the type is meant to be a primitive type representation - like mathematical entities, that are not scalars: vectors, matrices, complex numbers and POD(Plain Old Data) objects, which are meant to hold state in form of Java built-in types. In the latter case you would end up calling getter methods with arbitrary results. For example what should a NullPerson.getName() method return?</source>
          <target state="translated">Также я бы не рекомендовал использовать этот шаблон,где тип предназначен для примитивного представления типа-как математические сущности,которые не являются скалярами:векторы,матрицы,комплексные числа и POD(Plain Old Data)объекты,которые предназначены для удержания состояния в виде встроенных типов Java.В последнем случае,в конце концов,вы будете вызывать методы-гетеры с произвольными результатами.Например,что должен возвращать метод NullPerson.getName()?</target>
        </trans-unit>
        <trans-unit id="f7b3d415a8b44b9ed32e579112942a8c54368712" translate="yes" xml:space="preserve">
          <source>Also keep in mind, that null object pattern will be memory hungry if used without care. For this - the instance of a NullObject should be shared between owners, and not be an unigue instance for each of these.</source>
          <target state="translated">Также имейте в виду,что нулевой объектный шаблон будет иметь голодную память,если его использовать безо всякой осторожности.Для этого-экземпляр NullObject должен быть разделен между владельцами,а не являться нелицеприятным экземпляром для каждого из них.</target>
        </trans-unit>
        <trans-unit id="f6cc029520b428014830a634a4f74acc230947ba" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;assert&lt;/code&gt; statement throws an &lt;code&gt;Error&lt;/code&gt; (&lt;code&gt;AssertionError&lt;/code&gt;) if the condition is not true.  By default, Java ignores assertions.  You can enable assertions by passing the option &lt;code&gt;-ea&lt;/code&gt; to the JVM.  You can enable and disable assertions for individual classes and packages.  This means that you can validate code with the assertions while developing and testing, and disable them in a production environment, although my testing has shown next to no performance impact from assertions.</source>
          <target state="translated">Оператор &lt;code&gt;assert&lt;/code&gt; выдает &lt;code&gt;Error&lt;/code&gt; ( &lt;code&gt;AssertionError&lt;/code&gt; ), если условие не выполнено. По умолчанию Java игнорирует утверждения. Вы можете включить утверждения, передав опцию &lt;code&gt;-ea&lt;/code&gt; JVM. Вы можете включать и отключать утверждения для отдельных классов и пакетов. Это означает, что вы можете проверять код с помощью утверждений при разработке и тестировании, а также отключать их в производственной среде, хотя мое тестирование показало, что утверждения не оказывают никакого влияния на производительность.</target>
        </trans-unit>
        <trans-unit id="d1810451c6d1e409ac8c526fe9326856e3fc7731" translate="yes" xml:space="preserve">
          <source>An alternative solution is to never return null and instead use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object pattern&lt;/a&gt;:</source>
          <target state="translated">Альтернативное решение - никогда не возвращать нуль и вместо этого использовать &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;шаблон Null Object&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="935b1f02f26191e4d51fccc6975811fe44f6303a" translate="yes" xml:space="preserve">
          <source>An optional object for a given type (&lt;code&gt;Fruit&lt;/code&gt;) is created as the return type of a method. It can be empty or contain a &lt;code&gt;Fruit&lt;/code&gt; object:</source>
          <target state="translated">Необязательный объект для данного типа ( &lt;code&gt;Fruit&lt;/code&gt; ) создается как тип возврата метода. Может быть пустым или содержать объект &lt;code&gt;Fruit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7890138d52aa6dda680f54b0057313bbeec8699c" translate="yes" xml:space="preserve">
          <source>And don't loathe to type &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (generate javadoc in Eclipse) and write three additional words for you public API. This will be more than enough for all but those who don't read documentation.</source>
          <target state="translated">И не против того, чтобы набирать &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (генерировать javadoc в Eclipse) и писать три дополнительных слова для вашего публичного API. Этого будет более чем достаточно для всех, кроме тех, кто не читает документацию.</target>
        </trans-unit>
        <trans-unit id="90d233698926e1669e5eb1d2e7cde879b5ea4b2a" translate="yes" xml:space="preserve">
          <source>And finally, in the code, the first line of the public method goes like this:</source>
          <target state="translated">И,наконец,в коде первая строчка публичного метода идет вот так:</target>
        </trans-unit>
        <trans-unit id="194d7971422626db3904b18b7a51e13251038301" translate="yes" xml:space="preserve">
          <source>And if you are using Spring, Spring also has the same functionality in its package, see library(spring-2.4.6.jar)</source>
          <target state="translated">И если вы используете пружину,то она также имеет такую же функциональность в своем корпусе,см.библиотеку(пружина-2.4.6.jar)</target>
        </trans-unit>
        <trans-unit id="96abcbe58267cd8ab194fc60b9df329abfd8ab74" translate="yes" xml:space="preserve">
          <source>And it fits with new coming Java API (looking forward)</source>
          <target state="translated">И это соответствует новому Java API (с нетерпением жду).</target>
        </trans-unit>
        <trans-unit id="8a58cb59872c19e045b96568e04e4207657e1c22" translate="yes" xml:space="preserve">
          <source>And the usage is (with &lt;code&gt;import static&lt;/code&gt;):</source>
          <target state="translated">И использование (со &lt;code&gt;import static&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ae0cf01358f7068b6df8fd1b93a1c98822554b48" translate="yes" xml:space="preserve">
          <source>And yes, we know that beyond this line we will no longer encounter a null value so we just safely invoke methods on those objects.</source>
          <target state="translated">И да,мы знаем,что за этой строкой мы больше не будем сталкиваться с нулевым значением,поэтому мы просто безопасно вызываем методы на этих объектах.</target>
        </trans-unit>
        <trans-unit id="81e8d209a324ece42ed62905642bf649b3662f32" translate="yes" xml:space="preserve">
          <source>And you can be sure that this won't happen. :)</source>
          <target state="translated">И ты можешь быть уверен,что этого не случится.:)</target>
        </trans-unit>
        <trans-unit id="3294bacd3a1276b7be29212d3a5dd40d74f51115" translate="yes" xml:space="preserve">
          <source>As explained in the wiki:</source>
          <target state="translated">Как объяснили в вики:</target>
        </trans-unit>
        <trans-unit id="f927010b70c936bded38e97a00575ae4404173b5" translate="yes" xml:space="preserve">
          <source>As mentioned in some other answers, to avoid above problems you can follow the &lt;strong&gt;Design by contract&lt;/strong&gt; pattern. Please see &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt;.</source>
          <target state="translated">Как уже упоминалось в некоторых других ответах, чтобы избежать вышеуказанных проблем, вы можете следовать схеме &lt;strong&gt;проектирования по контракту&lt;/strong&gt; . Пожалуйста, смотрите &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1edc5d84268854adcf97f62dec08810475c6e1" translate="yes" xml:space="preserve">
          <source>As you can see, the second value in the addParam() method (string) is needed for the user message, because you cannot easily detect passed-in variable name, even with reflection (not subject of this post anyway...).</source>
          <target state="translated">Как видите,второе значение в методе addParam()(string)необходимо для пользовательского сообщения,т.к.невозможно легко определить имя передаваемой переменной,даже при отражении (в любом случае,не являясь темой этого сообщения...).</target>
        </trans-unit>
        <trans-unit id="221c48cdf1c0d0839054379dfe7e20af1349a56a" translate="yes" xml:space="preserve">
          <source>As you see &lt;code&gt;Optional.ofNullable()&lt;/code&gt; provides an easy way to get the reference wrapped. There are another ways to get the reference of Optional, either &lt;code&gt;Optional.empty()&lt;/code&gt; &amp;amp; &lt;code&gt;Optional.of()&lt;/code&gt;. One for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively.</source>
          <target state="translated">Как видите, &lt;code&gt;Optional.ofNullable()&lt;/code&gt; предоставляет простой способ обернуть ссылку. Есть и другие способы получить ссылку на Optional: &lt;code&gt;Optional.empty()&lt;/code&gt; и &lt;code&gt;Optional.of()&lt;/code&gt; . Один для возврата пустого объекта вместо перенастройки null, а другой для переноса ненулевого объекта, соответственно.</target>
        </trans-unit>
        <trans-unit id="7d61afa6fe305594ae8b4e6cf7ecc955c25b75c5" translate="yes" xml:space="preserve">
          <source>Asking that question points out that you may be interested in error handling strategies.  Your team's architect should decide how to work errors.  There are several ways to do this:</source>
          <target state="translated">Задав этот вопрос,вы можете быть заинтересованы в работе со стратегиями обработки ошибок.Архитектор вашей команды должен решить,как работать с ошибками.Есть несколько способов сделать это:</target>
        </trans-unit>
        <trans-unit id="0b437dd2d827fe8753e6c8da99be2952fba3ea42" translate="yes" xml:space="preserve">
          <source>Avoiding != null statements</source>
          <target state="translated">Избегая !=нулевых заявлений</target>
        </trans-unit>
        <trans-unit id="11cb1da4d18f15638f6174f01e98f7fee924565f" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with &quot;Tell, Don't Ask&quot; Style</source>
          <target state="translated">Избегать Нуллс в стиле &quot;Скажи,не спрашивай&quot;.</target>
        </trans-unit>
        <trans-unit id="c53936ddbedfa72c352067284a2a612bd38150c0" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with Polymorphic Dispatch</source>
          <target state="translated">Избегание нулей с полиморфной диспетчеризацией</target>
        </trans-unit>
        <trans-unit id="f4719d3ce5a47c8365160718c824959b1f58c151" translate="yes" xml:space="preserve">
          <source>Basically, you've got &lt;code&gt;@Nullable&lt;/code&gt; and &lt;code&gt;@NotNull&lt;/code&gt;.</source>
          <target state="translated">По сути, у вас есть &lt;code&gt;@Nullable&lt;/code&gt; и &lt;code&gt;@NotNull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c18860f21ab893032025c9ad8f874c57757e0d5" translate="yes" xml:space="preserve">
          <source>Byte!</source>
          <target state="translated">Byte!</target>
        </trans-unit>
        <trans-unit id="320bd43703cd7557626230bd2dde77c2b7640f71" translate="yes" xml:space="preserve">
          <source>Common &quot;problem&quot; in Java indeed.</source>
          <target state="translated">Действительно,общая &quot;проблема&quot; на Java.</target>
        </trans-unit>
        <trans-unit id="ab6b4e896ea7eaaed3d3b7bd63695ed61f2bc666" translate="yes" xml:space="preserve">
          <source>Compare:</source>
          <target state="translated">Compare:</target>
        </trans-unit>
        <trans-unit id="4890e65fe4afc7621e1eabc62ca877d901891501" translate="yes" xml:space="preserve">
          <source>Depending on what kind of objects you are checking you may be able to use some of the classes in the apache commons such as: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt;</source>
          <target state="translated">В зависимости от того, какие объекты вы проверяете, вы можете использовать некоторые классы в &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;общих фондах&lt;/a&gt; apache, такие как: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; и apache commons collection</target>
        </trans-unit>
        <trans-unit id="1611574f68477e79c3124a789db72e5b33b65570" translate="yes" xml:space="preserve">
          <source>Doing this</source>
          <target state="translated">Делая это</target>
        </trans-unit>
        <trans-unit id="9a7ba7e5ca69607940820be45f20c7f96e626e73" translate="yes" xml:space="preserve">
          <source>Doing this in your own code and you can avoid != null checks.</source>
          <target state="translated">Делая это в своем собственном коде,вы можете избежать проверок !=null.</target>
        </trans-unit>
        <trans-unit id="a489753c928c4dfb8ffde543140ef98f7d16b3e3" translate="yes" xml:space="preserve">
          <source>Example on how to throw exception on null:</source>
          <target state="translated">Пример того,как бросить исключение на ноль:</target>
        </trans-unit>
        <trans-unit id="c10cb15cb38405cd962e584139f01df735b6c7b4" translate="yes" xml:space="preserve">
          <source>Example on how to use this static classf from spring(org.springframework.util.Assert)</source>
          <target state="translated">Пример использования этого статического classf из spring(org.springframework.util.Assert)</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c7feb78075d63e6bedf1365cc55e6aa7fc3a87a8" translate="yes" xml:space="preserve">
          <source>Finally, here is our NPE as well as null check-free code:</source>
          <target state="translated">Наконец,вот наш NPE,а также нулевой проверочный код:</target>
        </trans-unit>
        <trans-unit id="1428f3662f53c4496ea96cf16634505d0f0a9b2c" translate="yes" xml:space="preserve">
          <source>First, I follow this convention:</source>
          <target state="translated">Во-первых,я следую этой конвенции:</target>
        </trans-unit>
        <trans-unit id="3f6a27b732f1a0d9afc335cb45ef93731f4fb5bf" translate="yes" xml:space="preserve">
          <source>First, my thoughts on this:</source>
          <target state="translated">Во-первых,мои мысли об этом:</target>
        </trans-unit>
        <trans-unit id="54463d0ab47a851d650e8259c2db7a0ae594a452" translate="yes" xml:space="preserve">
          <source>For example I often use:</source>
          <target state="translated">Например,я часто пользуюсь:</target>
        </trans-unit>
        <trans-unit id="4b4c9cb4038fad0763e34c64a087da1f526c6087" translate="yes" xml:space="preserve">
          <source>Guava, a very useful core library by Google, has a nice and useful API to avoid nulls. I find &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained&lt;/a&gt; very helpful.</source>
          <target state="translated">Guava, очень полезная базовая библиотека от Google, имеет приятный и полезный API, чтобы избежать нулевых значений. Я считаю использование &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UseAndAvoidingNullExplained&lt;/a&gt; очень полезным.</target>
        </trans-unit>
        <trans-unit id="2a6e8249d4017ff690264fec43a31540b1ea7759" translate="yes" xml:space="preserve">
          <source>Here follows an example of how you can use null vallidation in JAVA when you include apache library(commons-lang-2.4.jar)</source>
          <target state="translated">Вот пример того,как можно использовать нулевую валлидацию в JAVA,когда вы включаете библиотеку apache (commons-lang-2.4.jar).</target>
        </trans-unit>
        <trans-unit id="37fc03c253b95910c6421c23c78078850ed69a95" translate="yes" xml:space="preserve">
          <source>However, if your method just passes the value on, and the next method passes it on etc. it could get problematic. In that case you may want to check the argument as above.</source>
          <target state="translated">Однако,если ваш метод просто передаст значение,а следующий метод передаст его и т.д.,то это может стать проблематичным.В этом случае вы можете проверить аргумент,как описано выше.</target>
        </trans-unit>
        <trans-unit id="1d268653fde675e2306e93684be579aa72eb2868" translate="yes" xml:space="preserve">
          <source>I consider that it is bad to &quot;eat&quot; something when NULL was passed where NULL isn't a valid value. If you're not exiting the method with some sort of error then it means nothing went wrong in your method which is not true. Then you probably return null in this case, and in the receiving method you again check for null, and it never ends, and you end up with &quot;if != null&quot;, etc..</source>
          <target state="translated">Я считаю,что плохо &quot;есть&quot; что-то,когда NULL был передан,где NULL не является действительным значением.Если вы не выходите из метода с какой-то ошибкой,это значит,что в вашем методе ничего не пошло не так,что это не так.Тогда,вероятно,в этом случае вы возвращаете ноль,а в принимающем методе снова проверяете на ноль,и он никогда не заканчивается,и в итоге получается &quot;if !=null&quot; и т.д...</target>
        </trans-unit>
        <trans-unit id="ac7c74b5f9864f037fc949031de21c91fd9060c0" translate="yes" xml:space="preserve">
          <source>I highly disregard answers that suggest using the null objects in every situation. This pattern may break the contract and bury problems deeper and deeper instead of solving them, not mentioning that used inappropriately will create another pile of boilerplate code that will require future maintenance.</source>
          <target state="translated">Я очень не обращаю внимания на ответы,которые предполагают использование нулевых объектов в любой ситуации.Эта закономерность может нарушить договор и закопать проблемы все глубже и глубже,вместо того,чтобы их решать,не говоря уже о том,что неправильное использование создаст еще одну кучу кода шаблона,которая в будущем потребует обслуживания.</target>
        </trans-unit>
        <trans-unit id="5e1533f4720d20d3996516b4af58f7d3dd16391a" translate="yes" xml:space="preserve">
          <source>I invite you to read this article (my main source for writing this answer) in which the &lt;code&gt;NullPointerException&lt;/code&gt; (and in general null pointer) problematic as well as the (partial) solution brought by &lt;code&gt;Optional&lt;/code&gt; are well explained: &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Я предлагаю вам прочитать эту статью (мой основной источник для написания этого ответа), в которой хорошо объяснены проблематичное &lt;code&gt;NullPointerException&lt;/code&gt; (и вообще нулевой указатель), а также (частичное) решение, представленное &lt;code&gt;Optional&lt;/code&gt; : &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Дополнительные объекты Java&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e91faab1ad00e77854ebd2d809262438fc2063" translate="yes" xml:space="preserve">
          <source>I like articles from Nat Pryce. Here are the links:</source>
          <target state="translated">Мне нравятся статьи Нэта Прайса.Вот ссылки:</target>
        </trans-unit>
        <trans-unit id="c4217f45a2775c21698ce1470fdcef44f36c7cb8" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;object != null&lt;/code&gt; a lot to avoid &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Я часто использую &lt;code&gt;object != null&lt;/code&gt; чтобы избежать исключения &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43aae1b74babe4a5f7cffce5f010ac04c50784b7" translate="yes" xml:space="preserve">
          <source>I'm a fan of &quot;fail fast&quot; code. Ask yourself - are you doing something useful in the case where the parameter is null? If you don't have a clear answer for what your code should do in that case... I.e. it should never be null in the first place, then ignore it and allow a NullPointerException to be thrown. The calling code will make just as much sense of an NPE as it would an IllegalArgumentException, but it'll be easier for the developer to debug and understand what went wrong if an NPE is thrown rather than your code attempting to execute some other unexpected contingency logic - which ultimately results in the application failing anyway.</source>
          <target state="translated">Я фанат кода &quot;fail fast&quot;.Спросите себя-вы делаете что-то полезное в случае,если параметр равен нулю? Если у вас нет четкого ответа на вопрос,что должен делать ваш код в этом случае...Т.е.он никогда не должен быть нулевым в первую очередь,то проигнорируйте его и разрешите бросить NullPointerException.Вызовной код будет иметь такой же смысл NPE,как и IllegalArgumentException,но разработчику будет проще отладить и понять,что пошло не так,если брошена NPE,а не ваш код,пытающийся выполнить какую-нибудь другую неожиданную логику,что в конечном итоге приведет к тому,что приложение все равно выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="9d28525daf513a3218069e5463bb837227dd3063" translate="yes" xml:space="preserve">
          <source>I've tried the &lt;code&gt;NullObjectPattern&lt;/code&gt; but for me is not always the best way to go. There are sometimes when a &quot;no action&quot; is not appropiate.</source>
          <target state="translated">Я пробовал &lt;code&gt;NullObjectPattern&lt;/code&gt; , но для меня это не всегда лучший способ. Бывают случаи, когда &amp;laquo;никаких действий&amp;raquo; не уместно.</target>
        </trans-unit>
        <trans-unit id="55bdc40b2d33d1479a2eed8448e223fe33d03160" translate="yes" xml:space="preserve">
          <source>If (1) is not possible, initialise all collections and arrays to empty collections/arrays.</source>
          <target state="translated">Если (1)это невозможно,инициализируйте все коллекции и массивы до пустых коллекторов.</target>
        </trans-unit>
        <trans-unit id="0e0f1c759db9fd58b965ca2548b987ed339d8a59" translate="yes" xml:space="preserve">
          <source>If appContext or dataSource is not initialized unhandled runtime NullPointerException will kill current thread and will be processed by &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (for you to define and use your favorite logger or other notification mechanizm). If not set, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup#uncaughtException&lt;/a&gt; will print stacktrace to system err. One should monitor application error log and open Jira issue for each unhandled exception which in fact is application error. Programmer should fix bug somewhere in initialization stuff.</source>
          <target state="translated">Если appContext или dataSource не инициализирован, необработанная среда выполнения NullPointerException уничтожит текущий поток и будет обработана &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (для вас, чтобы определить и использовать ваш любимый регистратор или другой механизм уведомлений). Если не установлено, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup # uncaughtException&lt;/a&gt; выведет трассировку стека в системную ошибку. Необходимо следить за журналом ошибок приложения и открывать проблему Jira для каждого необработанного исключения, которое фактически является ошибкой приложения. Программист должен исправить ошибку где-то в инициализации.</target>
        </trans-unit>
        <trans-unit id="09e73ecfe67989af7dd8eaebfa15624f78eacae4" translate="yes" xml:space="preserve">
          <source>If it is an internal method (not part of an API), just document that it cannot be null, and that's it.</source>
          <target state="translated">Если это внутренний метод (не часть API),просто задокументируйте,что он не может быть нулевым,и все.</target>
        </trans-unit>
        <trans-unit id="0728dc4e2e97cf099cf3ab0e28a357ee05e7b6ca" translate="yes" xml:space="preserve">
          <source>If it's code that you do control, however (and this is often the case), then it's a different story.  Avoid using nulls as a response.  With methods that return collections, it's easy: return empty collections (or arrays) instead of nulls pretty much all the time.</source>
          <target state="translated">Если же это код,которым вы управляете (а так часто бывает),то это совсем другая история.Избегайте использования нулей в качестве реакции.С методами,которые возвращают коллекции,это просто:возвращать пустые коллекции (или массивы)вместо нулей практически постоянно.</target>
        </trans-unit>
        <trans-unit id="f619483031223d172a56c6c25092a69d35edf9be" translate="yes" xml:space="preserve">
          <source>If null is allowed</source>
          <target state="translated">Если ноль допускается</target>
        </trans-unit>
        <trans-unit id="d5dc5db9bb49b83ae4fcd69d7d06a8b86bbf1b0a" translate="yes" xml:space="preserve">
          <source>If null-values are not allowed</source>
          <target state="translated">Если нулевые значения не допускаются</target>
        </trans-unit>
        <trans-unit id="9ff0191b7a1ec369d5c5805839743dd0c72f1b9e" translate="yes" xml:space="preserve">
          <source>If undefined values are not permitted:</source>
          <target state="translated">Если неопределенные значения не допускаются:</target>
        </trans-unit>
        <trans-unit id="549ca9f1c825f259e5ce60b96c2984b9b0f5f764" translate="yes" xml:space="preserve">
          <source>If undefined values are permitted:</source>
          <target state="translated">Если допускаются неопределённые значения:</target>
        </trans-unit>
        <trans-unit id="68f38a6783f67b9f294c501c4581c1585e95009c" translate="yes" xml:space="preserve">
          <source>If you ask me what is the name of my girlfriend I'll tell you that I have no girlfriend. In the Java language I'll return null. 
An alternative would be to throw meaningful exception to indicate some problem that can't be (or don't want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user.</source>
          <target state="translated">Если ты спросишь меня,как зовут мою девушку,я скажу тебе,что у меня нет девушки.На языке Java я верну ноль.Альтернативой будет бросить значимое исключение,чтобы указать на некоторую проблему,которая не может быть (или не хочет быть)решена прямо здесь,и делегировать ее где-нибудь выше в стеке для повторных попыток или сообщения пользователю об ошибке доступа к данным.</target>
        </trans-unit>
        <trans-unit id="632f1186cdb5143b60b5f2614ffe2a8a35f452f1" translate="yes" xml:space="preserve">
          <source>If you consider an object should not be null (or it is a bug) use an assert.</source>
          <target state="translated">Если вы считаете,что объект не должен быть нулевым (или это ошибка),используйте утверждение.</target>
        </trans-unit>
        <trans-unit id="1cf153150df9563cc962ca474b13e56e5c751cce" translate="yes" xml:space="preserve">
          <source>If you know b can never be null, you can just swap it. It is most useful for equals:
Instead of &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; better do &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt;.</source>
          <target state="translated">Если вы знаете, что b никогда не может быть нулевым, вы можете просто поменять его местами. Это наиболее полезно для equals: вместо &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; лучше сделать &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="46640e8236124be6c3cf80df96f4c3a462598491" translate="yes" xml:space="preserve">
          <source>If you use (or planning to use) a Java IDE like &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; or &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; or a tool like findbugs then you can use annotations to solve this problem.</source>
          <target state="translated">Если вы используете (или планируете использовать) Java IDE, такую ​​как &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; или &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans,&lt;/a&gt; или инструмент, подобный findbugs, то вы можете использовать аннотации для решения этой проблемы.</target>
        </trans-unit>
        <trans-unit id="d9bd5740fe135b5553acbf51ff5056141fbbb4dc" translate="yes" xml:space="preserve">
          <source>If your method doesn't accept null params say it in the javadoc and use an assert.</source>
          <target state="translated">Если ваш метод не принимает нулевые параметры,скажите это в javadoc и используйте assert.</target>
        </trans-unit>
        <trans-unit id="ce6b2cf4a5e96febfe5ce76451daef36e092d32b" translate="yes" xml:space="preserve">
          <source>If your method is called externally, start with something like this:</source>
          <target state="translated">Если ваш метод называется внешним,начните с чего-нибудь подобного:</target>
        </trans-unit>
        <trans-unit id="ab846b65d9a8fcd8a4b81c40b61e74e028b79991" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt;, a Java-derived language, there are two versions of all types: a potentially-null version and a not-null version. You can only invoke methods on not-null types. Potentially-null types can be converted to not-null types through explicit checking for null. This makes it much easier to know where null checks are necessary and where they aren't.</source>
          <target state="translated">В &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt; , производном от Java языке, есть две версии всех типов: потенциально нулевая версия и ненулевая версия. Вы можете вызывать методы только для ненулевых типов. Потенциально нулевые типы могут быть преобразованы в ненулевые типы с помощью явной проверки на нулевые. Это позволяет намного легче узнать, где необходимы нулевые проверки, а где нет.</target>
        </trans-unit>
        <trans-unit id="8317f0d2b647c2aff1a42d76d73339593f638877" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA 10.5 and on, they added support for any other &lt;code&gt;@Nullable&lt;/code&gt;&lt;code&gt;@NotNull&lt;/code&gt; implementations.</source>
          <target state="translated">В IntelliJ IDEA 10.5 и далее они добавили поддержку любых других реализаций &lt;code&gt;@Nullable&lt;/code&gt; &lt;code&gt;@NotNull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="920588de011f2e8dddc89ccb39b92ea0631e797c" translate="yes" xml:space="preserve">
          <source>In Objective-C, you can do the equivalent of invoking a method on &lt;code&gt;nil&lt;/code&gt;, and absolutely nothing will happen. This makes most null checks unnecessary, but it can make errors much harder to diagnose.</source>
          <target state="translated">В Objective-C вы можете сделать эквивалентный вызов метода для &lt;code&gt;nil&lt;/code&gt; , и абсолютно ничего не произойдет. Это делает ненужными большинство нулевых проверок, но может значительно усложнить диагностику ошибок.</target>
        </trans-unit>
        <trans-unit id="04837dad91721b9799f52240befed0a8ce992bd5" translate="yes" xml:space="preserve">
          <source>In a nutshell, the Optional class includes methods to explicitly deal with the cases where a value is present or absent. However, the advantage compared to null references is that the Optional&amp;lt;T&amp;gt; class forces you to think about the case when the value is not present. As a consequence, you can prevent unintended null pointer exceptions.</source>
          <target state="translated">В двух словах, в классе Optional есть методы для явного обращения со случаями, когда значение присутствует или отсутствует. Однако преимущество по сравнению с нулевыми ссылками заключается в том, что дополнительный класс &amp;lt;T&amp;gt; заставляет задуматься о случае, когда значение отсутствует. Как следствие, вы можете предотвратить непреднамеренные исключения нулевого указателя.</target>
        </trans-unit>
        <trans-unit id="f1f3e79c602141290377505754be2b4a12d560ec" translate="yes" xml:space="preserve">
          <source>In above example we have a home service factory that returns a handle to multiple appliances available in the home. But these services may or may not be available/functional; it means it may result in a NullPointerException. Instead of adding a null &lt;code&gt;if&lt;/code&gt; condition before using any service, let's wrap it in to Optional&amp;lt;Service&amp;gt;.</source>
          <target state="translated">В приведенном выше примере у нас есть фабрика обслуживания на дому, которая возвращает дескриптор для нескольких приборов, доступных в доме. Но эти услуги могут быть или не быть доступными / функциональными; это означает, что это может привести к NullPointerException. Вместо добавления условия null &lt;code&gt;if&lt;/code&gt; перед использованием какого-либо сервиса, давайте поместим его в Optional &amp;lt;Service&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="fc6e5953a54a7e173cf74b9a49d8e3e1c3ed3c55" translate="yes" xml:space="preserve">
          <source>In addition to using &lt;code&gt;assert&lt;/code&gt; you can use the following:</source>
          <target state="translated">В дополнение к использованию &lt;code&gt;assert&lt;/code&gt; вы можете использовать следующее:</target>
        </trans-unit>
        <trans-unit id="58e936cf946cec0419aa0692bf595f85b67c954b" translate="yes" xml:space="preserve">
          <source>In an API built from scratch using &lt;code&gt;Optional&lt;/code&gt; whenever a return value might be empty, and returning a plain object only when it cannot be &lt;code&gt;null&lt;/code&gt; (convention), the client code might abandon null checks on simple object return values...</source>
          <target state="translated">В API, построенном с нуля, используя &lt;code&gt;Optional&lt;/code&gt; , когда возвращаемое значение может быть пустым, и возвращая простой объект, только когда он не может быть &lt;code&gt;null&lt;/code&gt; (соглашение), клиентский код может отказаться от нулевых проверок возвращаемых значений простых объектов ...</target>
        </trans-unit>
        <trans-unit id="992aee948602e38e384351d28a7dc64174420247" translate="yes" xml:space="preserve">
          <source>In my classes, most fields and local variables have non-null default values, and I add contract statements (always-on asserts) everywhere in the code to make sure this is being enforced (since it's more succinct, and more expressive than letting it come up as an NPE and then having to resolve the line number, etc.).</source>
          <target state="translated">В моих классах большинство полей и локальных переменных имеют ненулевые значения по умолчанию,и я добавляю в код повсюду утверждения контрактов (всегда на утверждении),чтобы быть уверенным,что это выполняется (так как это более лаконично и выразительно,чем позволять это выглядеть как NPE,а затем разрешать номер строки и т.д.).</target>
        </trans-unit>
        <trans-unit id="a0427014adae81ed68e6059ae2ac27ebf2554012" translate="yes" xml:space="preserve">
          <source>In reality if something returned from a method can be null and the calling code has to make decision upon that, there should an earlier call that ensures the state.</source>
          <target state="translated">В реальности,если что-то,возвращаемое методом,может быть нулевым,и код вызова должен принять решение по этому поводу,то должен быть более ранний вызов,обеспечивающий состояние.</target>
        </trans-unit>
        <trans-unit id="d28d029f197073e44a5cf2c959d2881818c5cbc8" translate="yes" xml:space="preserve">
          <source>In the articles there is also a link to a Git repository for a Java Maybe Type which I find interesting, but I don't think it alone could decrease the
checking code bloat. After doing some research on the Internet, I think &lt;strong&gt;!= null&lt;/strong&gt; code bloat could be decreased mainly by careful design.</source>
          <target state="translated">В статьях есть также ссылка на Git-репозиторий для Java Maybe Type, который я нахожу интересным, но я не думаю, что он сам по себе может уменьшить количество проверяемого кода. После некоторых исследований в Интернете, я думаю &lt;strong&gt;! =&lt;/strong&gt; Раздувание &lt;strong&gt;нулевого&lt;/strong&gt; кода может быть уменьшено в основном благодаря тщательному дизайну.</target>
        </trans-unit>
        <trans-unit id="02e44622ee08c669f730bdcb2ba763d4bddbd763" translate="yes" xml:space="preserve">
          <source>Is there a good alternative to this?</source>
          <target state="translated">Есть хорошая альтернатива?</target>
        </trans-unit>
        <trans-unit id="24df4f8ef6f8fd18a5d3ec048c3faffe1f0edf74" translate="yes" xml:space="preserve">
          <source>It is stated explicitly in the API whether an input or output exists or not.</source>
          <target state="translated">В API прямо указано,существует ли вход или выход.</target>
        </trans-unit>
        <trans-unit id="6cd16395a598dc3b1c54e1c2de34abba05b16ef6" translate="yes" xml:space="preserve">
          <source>It may be easier to give you examples, if you show examples of where you typically use the idiom.</source>
          <target state="translated">Возможно,будет проще привести примеры,если вы покажете,где вы обычно используете идиому.</target>
        </trans-unit>
        <trans-unit id="c32880c4b10a50c8fb02fa59f5e5618dea4d1963" translate="yes" xml:space="preserve">
          <source>It's a nice way to let the compiler check something more than it usually does and to enforce your contracts to be stronger. Unfortunately, it's not supported by all the compilers.</source>
          <target state="translated">Это хороший способ позволить компилятору проверить что-то большее,чем он обычно делает,и добиться того,чтобы ваши контракты были сильнее.К сожалению,это поддерживается не всеми компиляторами.</target>
        </trans-unit>
        <trans-unit id="f405e902c0a66a3e8ffdf23a351c22c3a375631a" translate="yes" xml:space="preserve">
          <source>It's actually rare for me to use the idiom &quot;&lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt;&quot;.</source>
          <target state="translated">На самом деле я редко использую идиому &amp;laquo; &lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt; &amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="714b225b9ed3d9fb4f8f780dad6fe5864bd2db61" translate="yes" xml:space="preserve">
          <source>It's worth considering such cases in order to avoid absurd results.</source>
          <target state="translated">Стоит рассмотреть такие случаи,чтобы избежать абсурдных результатов.</target>
        </trans-unit>
        <trans-unit id="e2368895a515e87735e0f53eb54312d0b78e798a" translate="yes" xml:space="preserve">
          <source>Java 7 has a new &lt;code&gt;java.util.Objects&lt;/code&gt; utility class on which there is a &lt;code&gt;requireNonNull()&lt;/code&gt; method. All this does is throw a &lt;code&gt;NullPointerException&lt;/code&gt; if its argument is null, but it cleans up the code a bit. Example:</source>
          <target state="translated">В Java 7 появился новый служебный класс &lt;code&gt;java.util.Objects&lt;/code&gt; , в котором есть метод &lt;code&gt;requireNonNull()&lt;/code&gt; . Все, что это делает, это &lt;code&gt;NullPointerException&lt;/code&gt; если его аргумент равен нулю, но он немного очищает код. Пример:</target>
        </trans-unit>
        <trans-unit id="edc6b48d824432a77a20f24921f65458059db63b" translate="yes" xml:space="preserve">
          <source>Java 7 introduced the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt;&lt;code&gt;Objects.requireNonNull&lt;/code&gt;&lt;/a&gt; method which can be handy when something should be checked for non-nullness. Example:</source>
          <target state="translated">Java 7 представила метод &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt; &lt;code&gt;Objects.requireNonNull&lt;/code&gt; ,&lt;/a&gt; который может быть полезен, когда что-то должно быть проверено на ненулевое значение. Пример:</target>
        </trans-unit>
        <trans-unit id="14057bbaba6e7ba4939e98331bee0a9d4cc6fd00" translate="yes" xml:space="preserve">
          <source>Java 8 has a built-in &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class (recommended); for earlier versions, there are library alternatives, for example &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;'s &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;. But like many functional-style patterns, using Option in Java (even 8) results in quite some boilerplate, which you can reduce using a less verbose JVM language, e.g. Scala or Xtend.</source>
          <target state="translated">Java 8 имеет встроенный &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; класс (рекомендуется); для более ранних версий есть библиотечные альтернативы, например, &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt; 's &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt; 's &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; . Но, как и во многих шаблонах в функциональном стиле, использование Option в Java (даже 8) приводит к некоторому шаблону, который можно сократить, используя менее подробный язык JVM, например Scala или Xtend.</target>
        </trans-unit>
        <trans-unit id="23ec0515f353dee199aaa003dccab705cbddfd12" translate="yes" xml:space="preserve">
          <source>Java 8 has introduced &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;. It is a container that may or may not hold a non-null value. Java 8 has given a safer way to handle an object whose value may be null in some of the cases. It is inspired from the ideas of &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt;.</source>
          <target state="translated">Java 8 представила &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt; . Это контейнер, который может содержать или не содержать ненулевое значение. Java 8 предоставила более безопасный способ обработки объекта, значение которого может быть нулевым в некоторых случаях. Он вдохновлен идеями &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Хаскелла&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Скалы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b697deb5aa0b223e01560060b3cb1b1f61855b42" translate="yes" xml:space="preserve">
          <source>Just a sample:</source>
          <target state="translated">Просто образец:</target>
        </trans-unit>
        <trans-unit id="e35fd4948c5a9357196b184cecdd55c2cc10c2d5" translate="yes" xml:space="preserve">
          <source>Just don't ever use null. Don't allow it.</source>
          <target state="translated">Только никогда не используй ноль.Не позволяй.</target>
        </trans-unit>
        <trans-unit id="e6f599b2f399715ad627af5bb0a6d5baae609bba" translate="yes" xml:space="preserve">
          <source>Last example using &lt;code&gt;@Nullable&lt;/code&gt;</source>
          <target state="translated">Последний пример с использованием &lt;code&gt;@Nullable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59402a00be4a0f11592ceaf67244cfe61d5bda51" translate="yes" xml:space="preserve">
          <source>Let's consider a method to get a reference of a service from a factory. Instead of returning the service reference, wrap it with Optional. It lets the API user know that the returned service may or may not available/functional, use defensively</source>
          <target state="translated">Рассмотрим способ получения справки об услуге с завода.Вместо того,чтобы возвращать ссылку на сервис,оберните ее опционально.Он позволяет пользователю API узнать,что возвращаемый сервис может быть как доступным,так и недоступным,использовать оборонительно</target>
        </trans-unit>
        <trans-unit id="aabc2d3db3cef830d4da0377e4b7c5b1b3f518c5" translate="yes" xml:space="preserve">
          <source>May I answer it more generally!</source>
          <target state="translated">Могу я ответить более широко!</target>
        </trans-unit>
        <trans-unit id="f433759684160d6db17bda40a8e075111a85c751" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;validate()&lt;/code&gt; will throw checked &lt;code&gt;ValidationException&lt;/code&gt; if any of the parameters is null (checked or unchecked is more a design/taste issue, but my &lt;code&gt;ValidationException&lt;/code&gt; is checked).</source>
          <target state="translated">Метод &lt;code&gt;validate()&lt;/code&gt; выбрасывает флажок &lt;code&gt;ValidationException&lt;/code&gt; , если какой-либо из параметров имеет значение null (флажок или непроверенный - это скорее проблема дизайна / вкуса, но проверено мое &lt;code&gt;ValidationException&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f01e85661d751c9b649b3a4ad66bff717bcfdf9" translate="yes" xml:space="preserve">
          <source>Most of the time null checks seem to guard loops over collections or arrays, so just initialise them empty, you won't need any null checks.</source>
          <target state="translated">В большинстве случаев нулевые проверки,кажется,защищают циклы над коллекциями или массивами,так что просто инициализируйте их пустыми,вам не понадобится никаких нулевых проверок.</target>
        </trans-unit>
        <trans-unit id="10245c94028cb40db8342e6e78c68de0822b9be5" translate="yes" xml:space="preserve">
          <source>Never initialise variables to null.</source>
          <target state="translated">Никогда не инициализируйте переменные до нуля.</target>
        </trans-unit>
        <trans-unit id="92dc04e377ae99c8a6ebf3a5d7e85d43ee0f3ab3" translate="yes" xml:space="preserve">
          <source>Not checking if a variable is null before invoking an equals method (a string compare example below):</source>
          <target state="translated">Не проверять,является ли переменная нулевой,прежде чем вызывать метод equals (пример сравнения строк ниже):</target>
        </trans-unit>
        <trans-unit id="99556f0afc8bbece6b8c0e90382fe62b10f3db0b" translate="yes" xml:space="preserve">
          <source>Not using assertions in this case is OK because the code will just fail, which is what will happen if you use assertions.  The only difference is that with assertions it might happen sooner, in a more-meaningful way and possibly with extra information, which may help you to figure out why it happened if you weren't expecting it.</source>
          <target state="translated">Не использовать утверждения в этом случае нормально,потому что код просто не будет работать,что и произойдет,если вы используете утверждения.Разница лишь в том,что с утверждениями это может произойти раньше,более осмысленным способом и,возможно,с дополнительной информацией,которая может помочь вам понять,почему это случилось,если вы этого не ожидали.</target>
        </trans-unit>
        <trans-unit id="176fa701c30ed80ae841f14d912217b3648526ea" translate="yes" xml:space="preserve">
          <source>Note that addParam() returns self, so that you can add more parameters to check.</source>
          <target state="translated">Обратите внимание,что addParam()возвращает себя,так что вы можете добавить больше параметров для проверки.</target>
        </trans-unit>
        <trans-unit id="9c7893143e601f4d7141dc682079d103f68d972b" translate="yes" xml:space="preserve">
          <source>Note that the accepted answer may be out of date, see &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; for a more recent approach.</source>
          <target state="translated">Обратите внимание, что принятый ответ может быть устаревшим, см. &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;Https://stackoverflow.com/a/2386013/12943&lt;/a&gt; для более недавнего подхода.</target>
        </trans-unit>
        <trans-unit id="08c509b05cd5ed1b8001a328275f057bb13241df" translate="yes" xml:space="preserve">
          <source>Now HomeServices.get() does same thing, but in a better way. It checks whether the service is already initialized of not. If it is then return the same or create a new New service. Optional&amp;lt;T&amp;gt;.orElse(T) helps to return a default value.</source>
          <target state="translated">Теперь HomeServices.get () делает то же самое, но лучше. Он проверяет, инициализирован ли сервис или нет. Если это так, верните то же самое или создайте новый новый сервис. Необязательный &amp;lt;T&amp;gt; .orElse (T) помогает вернуть значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="243fc41a64042cfc5860b15fdd1a86b35656505b" translate="yes" xml:space="preserve">
          <source>Now look at this code where we search a list of &lt;code&gt;Fruit&lt;/code&gt; (&lt;code&gt;fruits&lt;/code&gt;) for a given Fruit instance:</source>
          <target state="translated">Теперь посмотрите на этот код, где мы ищем список &lt;code&gt;Fruit&lt;/code&gt; ( &lt;code&gt;fruits&lt;/code&gt; ) для данного экземпляра Fruit:</target>
        </trans-unit>
        <trans-unit id="26b0fcf72724ae5ef092ca7b297d0d826206b5cb" translate="yes" xml:space="preserve">
          <source>Now the IntelliJ IDEA compiler will tell you that the check is useless, since the &lt;code&gt;helloWorld()&lt;/code&gt; function won't return &lt;code&gt;null&lt;/code&gt;, ever.</source>
          <target state="translated">Теперь компилятор IntelliJ IDEA скажет вам, что проверка бесполезна, поскольку функция &lt;code&gt;helloWorld()&lt;/code&gt; никогда не вернет значение &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdc1b22c0d793a34bbcf4429fa3f1f90d9486b91" translate="yes" xml:space="preserve">
          <source>Now to the answer:</source>
          <target state="translated">Теперь к ответу:</target>
        </trans-unit>
        <trans-unit id="2ea239f7f659ef1548e4d08d1e55d7c383740b1c" translate="yes" xml:space="preserve">
          <source>Now you can safely develop the core function of your method without needing to check input parameters, they guard your methods from unexpected parameters.</source>
          <target state="translated">Теперь вы можете безопасно развивать основную функцию вашего метода,не проверяя входные параметры,они защищают ваши методы от неожиданных параметров.</target>
        </trans-unit>
        <trans-unit id="edf43179ef58a381a95f2c17225fe5bf82d216c3" translate="yes" xml:space="preserve">
          <source>Null is not a 'problem'. It is an integral part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;complete&lt;/a&gt; modeling tool set. Software aims to model the complexity of the world and null bears its burden. &lt;strong&gt;Null indicates 'No data' or 'Unknown'&lt;/strong&gt; in Java and the like. So it is appropriate to use nulls for these purposes. I don't prefer the 'Null object' pattern; I think it rise the '&lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;who will guard
the guardians&lt;/a&gt;' problem.</source>
          <target state="translated">Нуль не является &amp;laquo;проблемой&amp;raquo;. Это неотъемлемая часть &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;полного&lt;/a&gt; набора инструментов моделирования. Программное обеспечение стремится моделировать сложность мира и ноль несет свое бремя. &lt;strong&gt;Нуль означает &amp;laquo;Нет данных&amp;raquo; или &amp;laquo;Неизвестно&amp;raquo;&lt;/strong&gt; в Java и тому подобное. Поэтому для этих целей целесообразно использовать нули. Я не предпочитаю шаблон &amp;laquo;Нулевой объект&amp;raquo;; Я думаю, что это поднимает проблему &amp;laquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;кто будет охранять стражей&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="29fec67aa38549dd5045b52d3829e32fb6b213cd" translate="yes" xml:space="preserve">
          <source>Of course &lt;code&gt;Optional&lt;/code&gt; could also be used as a method argument, perhaps a better way to indicate optional arguments than 5 or 10 overloading methods in some cases.</source>
          <target state="translated">Конечно, &lt;code&gt;Optional&lt;/code&gt; может также использоваться в качестве аргумента метода, возможно, лучший способ указать необязательные аргументы, чем 5 или 10 методов перегрузки в некоторых случаях.</target>
        </trans-unit>
        <trans-unit id="4caa61cd647ca110cd57241ba6a32544f2821d80" translate="yes" xml:space="preserve">
          <source>Of course, experience is the better way to understand and apply this suggestion.</source>
          <target state="translated">Конечно,опыт-это лучший способ понять и применить это предложение.</target>
        </trans-unit>
        <trans-unit id="1025ea9180532a8fb4fe82dbd19b0c29868734a2" translate="yes" xml:space="preserve">
          <source>Of course, the check for null/empty value is still necessary, but at least the developer is conscious that the value might be empty and the risk of forgetting to check is limited.</source>
          <target state="translated">Конечно,проверка на nullempty значение все равно необходима,но,по крайней мере,разработчик осознает,что значение может быть пустым,и риск забыть проверить ограничен.</target>
        </trans-unit>
        <trans-unit id="f9b45a3dc805fa3553c19beda43294e7e53857b2" translate="yes" xml:space="preserve">
          <source>Once I adopted this practice, I noticed that the problems seemed to fix themselves. You'd catch things much earlier in the development process just by accident and realize you had a weak spot..  and more importantly.. it helps encapsulate different modules' concerns, different modules can 'trust' each other, and no more littering the code with &lt;code&gt;if = null else&lt;/code&gt; constructs!</source>
          <target state="translated">Как только я принял эту практику, я заметил, что проблемы, похоже, решаются сами собой. Вы поймете вещи намного раньше в процессе разработки просто случайно и поймете, что у вас есть слабое место ... и что еще более важно ... это помогает инкапсулировать проблемы разных модулей, разные модули могут &quot;доверять&quot; друг другу и больше не засорять код с конструкциями &lt;code&gt;if = null else&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="c50fca7276a877e4ddcc3641d754b50d96020d50" translate="yes" xml:space="preserve">
          <source>Once you have wrapped a reference object, Optional provides many useful methods to invoke methods on a wrapped reference without NPE.</source>
          <target state="translated">После того,как вы обернули объект ссылки,Optional предоставляет множество полезных методов для вызова методов на обернутой ссылке без NPE.</target>
        </trans-unit>
        <trans-unit id="72353b7bfc87776c765797b34857c518b0e8dcd9" translate="yes" xml:space="preserve">
          <source>Only for this situation -</source>
          <target state="translated">Только для этой ситуации -</target>
        </trans-unit>
        <trans-unit id="f657c8e08093a6452319f9c30f992b884323f041" translate="yes" xml:space="preserve">
          <source>Optional.ifPresent invokes the given Consumer with a reference if it is a non-null value. Otherwise, it does nothing.</source>
          <target state="translated">Optional.ifPresent ссылается на данного Потребителя со ссылкой,если это ненулевое значение.В противном случае,он ничего не делает.</target>
        </trans-unit>
        <trans-unit id="6a132feaa88e9eaf93ca9f96a1e7df9448ce9003" translate="yes" xml:space="preserve">
          <source>Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.</source>
          <target state="translated">Или если вы считаете,что механизм trycatch слишком уродлив,а не Do Nothing ваше действие по умолчанию не должно обеспечивать обратную связь с пользователем.</target>
        </trans-unit>
        <trans-unit id="f766e2839d0e27333563fdfa4a7af0a22bd85132" translate="yes" xml:space="preserve">
          <source>Or in your example:</source>
          <target state="translated">Или в вашем примере:</target>
        </trans-unit>
        <trans-unit id="8d0c023e0356e1bab468181b4ff498742ae4781b" translate="yes" xml:space="preserve">
          <source>PPS. For those fast to downvote (and not so fast to read documentation) I would like to say that I've never caught a null-pointer exception (NPE) in my life. But this possibility was &lt;strong&gt;intentionally designed&lt;/strong&gt; by the Java creators because NPE is a subclass of &lt;code&gt;Exception&lt;/code&gt;. We have a precedent in Java history when &lt;code&gt;ThreadDeath&lt;/code&gt; is an &lt;code&gt;Error&lt;/code&gt; not because it is actually an application error, but solely because it was not intended to be caught! How much NPE fits to be an &lt;code&gt;Error&lt;/code&gt; than &lt;code&gt;ThreadDeath&lt;/code&gt;! But it is not.</source>
          <target state="translated">PPS. Для тех, кто быстро понижает голос (и не так быстро читает документацию), я хотел бы сказать, что я никогда не ловил исключение с нулевым указателем (NPE) в своей жизни. Но эта возможность была &lt;strong&gt;специально разработана&lt;/strong&gt; создателями Java, потому что NPE является подклассом &lt;code&gt;Exception&lt;/code&gt; . У нас есть прецедент в истории Java, когда &lt;code&gt;ThreadDeath&lt;/code&gt; является &lt;code&gt;Error&lt;/code&gt; не потому, что на самом деле это ошибка приложения, а исключительно потому, что она не была предназначена для перехвата! Сколько NPE подходит, чтобы быть &lt;code&gt;Error&lt;/code&gt; чем &lt;code&gt;ThreadDeath&lt;/code&gt; ! Но это не так.</target>
        </trans-unit>
        <trans-unit id="9ee03b92c278aefd505b6e54e78c9dc0b157ad7a" translate="yes" xml:space="preserve">
          <source>PS. This approach will be as reasonable to use as the &lt;em&gt;separate error-handling code from &quot;regular&quot; code&lt;/em&gt; principle is reasonable to use in some place. Consider the next example:</source>
          <target state="translated">PS. Этот подход будет настолько же разумным, чтобы использовать его, так как &lt;em&gt;отдельный код обработки ошибок от&lt;/em&gt; принципа &lt;em&gt;&amp;laquo;обычного&amp;raquo; кода&lt;/em&gt; целесообразно использовать в некоторых местах. Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="ba90388bd4c171ca39fa6b73261783e63a2f28b2" translate="yes" xml:space="preserve">
          <source>Previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library.</source>
          <target state="translated">Предыдущее приводит к нормальному логическому потоку,чтобы не получить фотографию несуществующей девушки из моей фотобиблиотеки.</target>
        </trans-unit>
        <trans-unit id="8f2b4864d43e2c92095e649bd1429a2c05d7ab61" translate="yes" xml:space="preserve">
          <source>Probably the best alternative for Java 8 or newer is to use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">Вероятно, лучшая альтернатива для Java 8 или новее - использовать класс &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18ac346b6a23f38378a9759b924291326484c819" translate="yes" xml:space="preserve">
          <source>Q. Redundant code could be executed and unnecessary resources could be grabbed.</source>
          <target state="translated">Q.Может быть выполнен избыточный код,и лишние ресурсы могут быть захвачены.</target>
        </trans-unit>
        <trans-unit id="60f3d300f344070bb3660651b4b7c84a7c1a7806" translate="yes" xml:space="preserve">
          <source>Q. This approach has a performance penalty due to the try closure opening.</source>
          <target state="translated">Q.Этот подход имеет штрафной балл в связи с открытием пробного закрытия.</target>
        </trans-unit>
        <trans-unit id="8ada7432c9d8ed60d8ddcb07057e3aa21a1cd988" translate="yes" xml:space="preserve">
          <source>Q. What if &lt;code&gt;getPhotoDataSource()&lt;/code&gt; returns null?</source>
          <target state="translated">В. Что если &lt;code&gt;getPhotoDataSource()&lt;/code&gt; возвращает ноль ?</target>
        </trans-unit>
        <trans-unit id="b0f21ff390c71b63fb33e4cf5b2e9b8e9cc3013f" translate="yes" xml:space="preserve">
          <source>Questions could arise:</source>
          <target state="translated">Могут возникнуть вопросы:</target>
        </trans-unit>
        <trans-unit id="0c25c125f68f171e56c5dc46a5e78dbdc73323ed" translate="yes" xml:space="preserve">
          <source>Rather than Null Object Pattern -- which has its uses -- you might consider situations where the null object is a bug.</source>
          <target state="translated">Вместо Null Object Pattern --который имеет свое применение --вы можете рассмотреть ситуации,когда нулевой объект является ошибкой.</target>
        </trans-unit>
        <trans-unit id="4e1c9630619b3a985eea9596a353ce64e0b8e71b" translate="yes" xml:space="preserve">
          <source>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.
It is so clean and easy to understand. In the above code example, &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; gets invoked if the Optional holding reference is non-null.</source>
          <target state="translated">Представляет операцию, которая принимает один входной аргумент и не возвращает результата. В отличие от большинства других функциональных интерфейсов, ожидается, что потребитель будет работать через побочные эффекты. Это так чисто и легко понять. В приведенном выше примере кода &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; вызывается, если необязательная ссылка удержания не равна нулю.</target>
        </trans-unit>
        <trans-unit id="9951bd4cc66be1c5bf9d684cb3738fbaaf27a9b2" translate="yes" xml:space="preserve">
          <source>SO HOW EXACTLY IT HELPS TO AVOID A NULL CHECK?</source>
          <target state="translated">ТАК КАК ИМЕННО ЭТО ПОМОГАЕТ ИЗБЕЖАТЬ НУЛЕВОЙ ПРОВЕРКИ?</target>
        </trans-unit>
        <trans-unit id="12ebfd30869dc6d7d284fbd49560456e553ae1a4" translate="yes" xml:space="preserve">
          <source>See blog post &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;More flexible and configurable @Nullable/@NotNull annotations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Смотрите сообщение в блоге. &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;Более гибкие и настраиваемые аннотации @ Nullable / @ NotNull&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c614bff3bcea0ba91a4e4fc674cacfdf5b3e3421" translate="yes" xml:space="preserve">
          <source>So I branch, and do two completely different things. There is no ugly code snippet, because I really need to do two different things depending on the data. For example, should I work on the input, or should I calculate a good default value?</source>
          <target state="translated">Так что,я разветвляюсь,и делаю две совершенно разные вещи.Нет никакого уродливого фрагмента кода,потому что мне действительно нужно делать две разные вещи в зависимости от данных.Например,должен ли я работать над входными данными или вычислять хорошее значение по умолчанию?</target>
        </trans-unit>
        <trans-unit id="ab095d82204599c2467871a3efe97685e021b767" translate="yes" xml:space="preserve">
          <source>So there is no difference between:</source>
          <target state="translated">Так что никакой разницы нет:</target>
        </trans-unit>
        <trans-unit id="3832db2f40c93881b178af60f45fd152a79ed806" translate="yes" xml:space="preserve">
          <source>So, IMHO, null must be a critical error which prevents further execution (that is, where null is not a valid value).</source>
          <target state="translated">Таким образом,IMHO,ноль должен быть критической ошибкой,которая препятствует дальнейшему выполнению (то есть,когда ноль не является действительным значением).</target>
        </trans-unit>
        <trans-unit id="91316cbc500c43d5b77c2b413a3f65b2f65958c8" translate="yes" xml:space="preserve">
          <source>Sometimes, you have methods that operate on its parameters that define a symmetric operation:</source>
          <target state="translated">Иногда есть методы,которые работают с его параметрами,определяющими симметричную операцию:</target>
        </trans-unit>
        <trans-unit id="b8ca7bcd4b5f1acf3e5ba33e4a5f508dec7dea54" translate="yes" xml:space="preserve">
          <source>Sure do have a look at Aspect Oriented Programming, too - they have neat ways to insert &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; into your bytecode.</source>
          <target state="translated">Конечно, взгляните также на Аспектно-ориентированное программирование - у них есть изящные способы вставить &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; в ваш байт-код.</target>
        </trans-unit>
        <trans-unit id="6f4cfb67cdd3b5f824a9934a1ed6c1fca9c1fc27" translate="yes" xml:space="preserve">
          <source>That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.</source>
          <target state="translated">Тем не менее,возможно,для метода findAction()вполне уместно бросать Исключение со смысловым сообщением об ошибке-особенно в этом случае,когда вы полагаетесь на пользовательский ввод.Для метода findAction гораздо лучше бросить Exception,чем для вызывающего метода взорвать простое исключение NullPointerException без объяснения причин.</target>
        </trans-unit>
        <trans-unit id="7047d7ff31541da135908e8ecd7f812faea65471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?.&lt;/code&gt; means only de-reference the left identifier if it is not null, otherwise evaluate the remainder of the expression as &lt;code&gt;null&lt;/code&gt;. Some people, like Java Posse member Dick Wall and the &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;voters at Devoxx&lt;/a&gt; really love this proposal, but there is opposition too, on the grounds that it will actually encourage more use of &lt;code&gt;null&lt;/code&gt; as a sentinel value.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; означает только отмену ссылки на левый идентификатор, если он не равен нулю, в противном случае оцените оставшуюся часть выражения как &lt;code&gt;null&lt;/code&gt; Некоторым людям, таким как член Java Posse Дик Уолл и &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;избиратели в Devoxx,&lt;/a&gt; действительно нравится это предложение, но есть и оппозиция на том основании, что оно фактически будет поощрять более широкое использование &lt;code&gt;null&lt;/code&gt; в качестве дозорного значения.</target>
        </trans-unit>
        <trans-unit id="78bbb74ffaaf0217ff4697c6fb561008da9384db" translate="yes" xml:space="preserve">
          <source>The Google collections framework offers a good and elegant way to achieve the null check.</source>
          <target state="translated">Фреймворк коллекций Google предлагает хороший и элегантный способ достижения нулевой проверки.</target>
        </trans-unit>
        <trans-unit id="1d0b369ef777f99443515fd98b70d6cbe6356789" translate="yes" xml:space="preserve">
          <source>The StringUtils class is only one of many; there are quite a few good classes in the commons that do null safe manipulation.</source>
          <target state="translated">Класс StringUtils-только один из многих;в общих чертах существует довольно много хороших классов,которые делают нулевые безопасные манипуляции.</target>
        </trans-unit>
        <trans-unit id="b3066493bcd46f61316ddaca0d5573d18b01f7cd" translate="yes" xml:space="preserve">
          <source>The compiler forces you to handle the &quot;undefined&quot; case.</source>
          <target state="translated">Компилятор заставляет вас обрабатывать &quot;неопределенный&quot; случай.</target>
        </trans-unit>
        <trans-unit id="11db0d52c7259e3f5542cc11ae35ecc39a7f84be" translate="yes" xml:space="preserve">
          <source>The complete post is &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE as well as Null check-free code &amp;hellip; Really?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Полный пост - &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE, а также пустой код без проверки ... Правда?&lt;/a&gt;&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="6f36738048a72c2ff14555a1f49f971e924f9660" translate="yes" xml:space="preserve">
          <source>The contracts are like mini-unit tests which are always running, even in production, and when things fail, you know why, rather than a random NPE you have to somehow figure out.</source>
          <target state="translated">Контракты похожи на мини-тесты,которые всегда выполняются,даже на производстве,и когда что-то терпит неудачу,вы знаете почему,а не случайное NPE,вы должны как-то разобраться.</target>
        </trans-unit>
        <trans-unit id="8b07fde497d833a3dea4d5d1623ff04bff7cd150" translate="yes" xml:space="preserve">
          <source>The example given by Alex Miller looks like this:</source>
          <target state="translated">Пример,приведенный Алексом Миллером,выглядит так:</target>
        </trans-unit>
        <trans-unit id="6b1e5e00880fd770c374b1874c5898efc9b29533" translate="yes" xml:space="preserve">
          <source>The message will contain the following text if, for example, &quot;plans&quot; is null:</source>
          <target state="translated">Сообщение будет содержать следующий текст,если,например,&quot;планы&quot; являются нулевыми:</target>
        </trans-unit>
        <trans-unit id="50acd96098203094b440f2ee9754742ef52b2da0" translate="yes" xml:space="preserve">
          <source>The method is most useful for &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;checking&lt;/a&gt; just before an assignment in a constructor, where each use of it can save three lines of code:</source>
          <target state="translated">Этот метод наиболее полезен для &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;проверки&lt;/a&gt; непосредственно перед присваиванием в конструкторе, где при каждом его использовании можно сохранить три строки кода:</target>
        </trans-unit>
        <trans-unit id="e93d133895627c9a3d74a6c30e204dcdb8e532ac" translate="yes" xml:space="preserve">
          <source>The only other methods which do not check for null are utility methods. They are public, but if you call them for some reason, you know what parameters you pass. This is like trying to boil water in the kettle without providing water...</source>
          <target state="translated">Единственные другие методы,которые не проверяют на ноль-это утилитные методы.Они являются общедоступными,но если вы вызываете их по какой-то причине,вы знаете,какие параметры вы передаете.Это все равно,что пытаться кипятить воду в чайнике,не предоставляя воду...</target>
        </trans-unit>
        <trans-unit id="3071661bc3a8f3f1fb050d846047c85545570484" translate="yes" xml:space="preserve">
          <source>The second example won't compile (in IntelliJ IDEA).</source>
          <target state="translated">Второй пример не компилируется (в IntelliJ IDEA).</target>
        </trans-unit>
        <trans-unit id="d6530e4dc64d23e3133b0d5fd801c0b069e04e94" translate="yes" xml:space="preserve">
          <source>The way I solve this problem is this:</source>
          <target state="translated">Я решаю эту проблему вот так:</target>
        </trans-unit>
        <trans-unit id="8b0438900bb10b9989752d1f3c4b40b7f47f6df7" translate="yes" xml:space="preserve">
          <source>Then, in the rest of that method, you'll know that &lt;code&gt;object&lt;/code&gt; is not null.</source>
          <target state="translated">Затем в оставшейся части этого метода вы будете знать, что &lt;code&gt;object&lt;/code&gt; не равен нулю.</target>
        </trans-unit>
        <trans-unit id="79a6826b25f58343482759c32d1843c3fcfde425" translate="yes" xml:space="preserve">
          <source>There is a method in a library class like this:</source>
          <target state="translated">В классе библиотеки есть такой метод:</target>
        </trans-unit>
        <trans-unit id="7b611806237c884a66462ab8d01c1db4a0455d83" translate="yes" xml:space="preserve">
          <source>There is a proposal to add new annotations in Java7 to help with null / notnull params:
&lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</source>
          <target state="translated">Существует предложение добавить новые аннотации в Java7, чтобы помочь с пустыми / ненулевыми параметрами: &lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdcc90e0f67eeda9f92fa7029efb8f80e4f6cda3" translate="yes" xml:space="preserve">
          <source>There is a tiny overhead in this, but it's worth it for cleaner code and less NullPointerExceptions.</source>
          <target state="translated">В этом есть крошечные накладные расходы,но это стоит того для более чистого кода и меньше NullPointerExceptions.</target>
        </trans-unit>
        <trans-unit id="a995a0c78ad44e2ea78fecf0b6b5ae088210dbfb" translate="yes" xml:space="preserve">
          <source>They both want to make sure that we received valid parameters, before we do any other functions.</source>
          <target state="translated">Они оба хотят удостовериться,что мы получили правильные параметры,прежде чем мы приступим к выполнению других функций.</target>
        </trans-unit>
        <trans-unit id="0de62a4c684b4be885c335e3c1f969aeb6ca39e3" translate="yes" xml:space="preserve">
          <source>They work like that:</source>
          <target state="translated">Они так работают:</target>
        </trans-unit>
        <trans-unit id="6da291a4214849ad22b47d77f7b9e5c7c2ed3dbb" translate="yes" xml:space="preserve">
          <source>This checks for a &lt;code&gt;NullPointerException&lt;/code&gt; for the &lt;code&gt;someobject&lt;/code&gt; object in the above snippet.</source>
          <target state="translated">Это проверяет &lt;code&gt;someobject&lt;/code&gt; &lt;code&gt;NullPointerException&lt;/code&gt; для объекта someobject в приведенном выше фрагменте.</target>
        </trans-unit>
        <trans-unit id="a632edab67a162af8d6236e911205c0bd2945507" translate="yes" xml:space="preserve">
          <source>This is a very common problem for every Java developer. So there is official support in Java&amp;nbsp;8 to address these issues without cluttered code.</source>
          <target state="translated">Это очень распространенная проблема для каждого разработчика Java. Так что в Java 8 есть официальная поддержка для решения этих проблем без загроможденного кода.</target>
        </trans-unit>
        <trans-unit id="63475a15e2d7175b43a8eb4ced243071760761e7" translate="yes" xml:space="preserve">
          <source>This is defensive programming and results in much cleaner code in the long run. Always sanitize the data, e.g. here by enforcing rigid standards, and the problems go away.</source>
          <target state="translated">Это защитное программирование,в результате чего в конечном итоге получается гораздо более чистый код.Всегда дезинфицируйте данные,например,здесь,применяя жесткие стандарты,и проблемы исчезают.</target>
        </trans-unit>
        <trans-unit id="96855dbf651af7ee23c0764f0f76d95841159676" translate="yes" xml:space="preserve">
          <source>This is especially handy for long chains of possible null values. Example:</source>
          <target state="translated">Это особенно удобно для длинных цепочек возможных нулевых значений.Пример:</target>
        </trans-unit>
        <trans-unit id="ab20b6e950b963a0a9153b9bd523a03c124b9ceb" translate="yes" xml:space="preserve">
          <source>This is slightly better than:</source>
          <target state="translated">Это немного лучше,чем:</target>
        </trans-unit>
        <trans-unit id="4f0f6bf669b0e6c235196e52c58820b609d7a7a9" translate="yes" xml:space="preserve">
          <source>This is the most common error occurred for most of the developers.</source>
          <target state="translated">Это самая распространенная ошибка,возникающая у большинства разработчиков.</target>
        </trans-unit>
        <trans-unit id="2c2ef7f8c0c5f5953f9d8dc9f87238113a866d47" translate="yes" xml:space="preserve">
          <source>This really depends. If find that I often do something like this:</source>
          <target state="translated">Это действительно зависит.Если выяснится,что я часто делаю что-то подобное:</target>
        </trans-unit>
        <trans-unit id="5f65d63d47b93827d172b66566e2699ba53e9246" translate="yes" xml:space="preserve">
          <source>This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don't know or don't trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.</source>
          <target state="translated">Для меня это звучит как достаточно распространенная проблема,с которой в какой-то момент сталкиваются младшие и средние разработчики:они либо не знают,либо не доверяют контрактам,в которых участвуют,и оборонительно перепроверяют их на нули.Кроме того,при написании собственного кода они склонны полагаться на возврат нулей,чтобы указать что-то,что требует от звонящего проверить на наличие нулей.</target>
        </trans-unit>
        <trans-unit id="d66c4aae334386fa18d2bf51fc0dd0e22c5fcd02" translate="yes" xml:space="preserve">
          <source>This way, the code is clean, easy maintainable and readable.</source>
          <target state="translated">Таким образом,код чистый,легко обслуживается и читается.</target>
        </trans-unit>
        <trans-unit id="88e9d9f0b01df7bd366fd6f414813582c76c2a26" translate="yes" xml:space="preserve">
          <source>This won't compile.</source>
          <target state="translated">Это не сработает.</target>
        </trans-unit>
        <trans-unit id="03a1146d56211c08b24efbc23fe64db2a1fe9e19" translate="yes" xml:space="preserve">
          <source>To implement this pattern in java, you can use core java annotations like &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; or use more sophisticated libraries like &lt;strong&gt;Hibernate Validator&lt;/strong&gt;.</source>
          <target state="translated">Чтобы реализовать этот шаблон в Java, вы можете использовать основные аннотации Java, такие как &lt;strong&gt;javax.annotation.NotNull,&lt;/strong&gt; или использовать более сложные библиотеки, такие как &lt;strong&gt;Hibernate Validator&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="65dd044ab70d140d1269ad7b58d585a319cf8c8e" translate="yes" xml:space="preserve">
          <source>To put this another way, there are two instances where null checking comes up:</source>
          <target state="translated">Другими словами,есть два случая,когда проверяется нулевой результат:</target>
        </trans-unit>
        <trans-unit id="893faf3275f29660c0345c697429903da97cca3c" translate="yes" xml:space="preserve">
          <source>Try to make all your attributes and its accessors as private as possible or avoid to  expose them to the clients at all. You can have the argument values in the constructor of course, but by reducing the scope you don't let the client class pass an invalid value. If you need to modify the values, you can always create a new &lt;code&gt;object&lt;/code&gt;.  You check the values in the constructor only &lt;strong&gt;once&lt;/strong&gt; and in the rest of the methods you can be almost sure that the values are not null.</source>
          <target state="translated">Постарайтесь сделать все свои атрибуты и их методы доступа максимально конфиденциальными или вообще не показывать их клиентам. Конечно, вы можете иметь значения аргумента в конструкторе, но, уменьшая область действия, вы не позволяете клиентскому классу передавать недопустимое значение. Если вам нужно изменить значения, вы всегда можете создать новый &lt;code&gt;object&lt;/code&gt; . Вы проверяете значения в конструкторе только &lt;strong&gt;один раз,&lt;/strong&gt; а в остальных методах вы можете быть почти уверены, что значения не равны NULL.</target>
        </trans-unit>
        <trans-unit id="5096108c9ee2936b6660a55e9c083bcd59532700" translate="yes" xml:space="preserve">
          <source>Ultimately, the only way to completely solve this problem is by using a different programming language:</source>
          <target state="translated">В конечном счете,единственный способ полностью решить эту проблему-это использование другого языка программирования:</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="91e3b61c16f5d43c2c292405b4146327e9221a06" translate="yes" xml:space="preserve">
          <source>Using parameter</source>
          <target state="translated">Использование параметра</target>
        </trans-unit>
        <trans-unit id="410ecb47e87fed6b528cde0e827e193125ef8e2c" translate="yes" xml:space="preserve">
          <source>WRAPPING TO OPTION&amp;lt;T&amp;gt;</source>
          <target state="translated">ОБРАЩЕНИЕ К ВАРИАНТУ &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16139730df851e7de2b4d9ecb2a4976efb2493cf" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;usually&lt;/strong&gt; face this issue when the methods get the parameters in the way we not expected (bad method call is programmer's fault). For example: you expect to get an object, instead you get a null. You expect to get an String with at least one character, instead you get an empty String ...</source>
          <target state="translated">Мы &lt;strong&gt;обычно&lt;/strong&gt; сталкиваемся с этой проблемой, когда методы получают параметры так, как мы этого не ожидали (неправильный вызов метода - ошибка программиста). Например: вы ожидаете получить объект, вместо этого вы получите ноль. Вы ожидаете получить строку как минимум с одним символом, вместо этого вы получите пустую строку ...</target>
        </trans-unit>
        <trans-unit id="81d7e415e730d427573e6b4ff607e889a2cb73ec" translate="yes" xml:space="preserve">
          <source>We have number of ways to handle this.</source>
          <target state="translated">У нас есть несколько способов справиться с этим.</target>
        </trans-unit>
        <trans-unit id="0f598db2507984034e96ef0808dfe220b74dab82" translate="yes" xml:space="preserve">
          <source>We use the ternary operator very often for checking null condition and return an alternative value or default value. Optional provides another way to handle the same condition without checking null. Optional.orElse(defaultObj) returns defaultObj if the Optional has a null value. Let's use this in our sample code:</source>
          <target state="translated">Очень часто мы используем тернарный оператор для проверки нулевого условия и возвращаем альтернативное значение или значение по умолчанию.Необязательный оператор предоставляет другой способ обработки одного и того же условия без проверки нуля.Optional.orElse(defaultObj)возвращает defaultObj,если опция имеет нулевое значение.Используем это в нашем примере:</target>
        </trans-unit>
        <trans-unit id="1b7de74b75d773507feae3e01547f3abd8a8e794" translate="yes" xml:space="preserve">
          <source>When the exception is thrown, examine the stack trace and work through the bug.</source>
          <target state="translated">Когда выбрасывается исключение,проверьте след стека и проработайте ошибку.</target>
        </trans-unit>
        <trans-unit id="56f60bd1b035c1637de885e8364d676ed25dd3d5" translate="yes" xml:space="preserve">
          <source>When you use the first &lt;code&gt;helloWorld()&lt;/code&gt; function in another piece of code:</source>
          <target state="translated">Когда вы используете первую функцию &lt;code&gt;helloWorld()&lt;/code&gt; в другом фрагменте кода:</target>
        </trans-unit>
        <trans-unit id="79b6177f112f6c351c671521cc708abf0dbc2ef4" translate="yes" xml:space="preserve">
          <source>Where it isn't a valid response.</source>
          <target state="translated">Там,где это не является правильным ответом.</target>
        </trans-unit>
        <trans-unit id="35c99b0c8fc1f9ea3f573be119257028ced0e610" translate="yes" xml:space="preserve">
          <source>Where null is a valid response in terms of the contract; and</source>
          <target state="translated">Если недействительным является действительный ответ по условиям договора;и</target>
        </trans-unit>
        <trans-unit id="cdfe105c8bfbcc3b13ac6840fef58d8c1666a5a4" translate="yes" xml:space="preserve">
          <source>While it is rather 'normal business flow' not to find photo stored into the DB for some person, I used to use pairs like below for some other cases</source>
          <target state="translated">Хотя это довольно &quot;нормальный бизнес-процесс&quot;-не находить фотографию,хранящуюся в БД для какого-то человека,для некоторых других случаев я использовал пары,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="580ecabb6906d2e8e175eeee96c8cd0b5d5e79e0" translate="yes" xml:space="preserve">
          <source>With Java 8 comes the new &lt;code&gt;java.util.Optional&lt;/code&gt; class that arguably solves some of the problem. One can at least say that it improves the readability of the code, and in the case of public APIs make the API's contract clearer to the client developer.</source>
          <target state="translated">С Java 8 поставляется новый класс &lt;code&gt;java.util.Optional&lt;/code&gt; , который, возможно, решает некоторые проблемы. Можно, по крайней мере, сказать, что это улучшает читабельность кода, а в случае открытых API-интерфейсов делает контракт API-интерфейса более понятным для клиента-разработчика.</target>
        </trans-unit>
        <trans-unit id="2f3836243579dcf0aab46f92bd120d19df8df941" translate="yes" xml:space="preserve">
          <source>With non-collections it might be harder.  Consider this as an example: if you have these interfaces:</source>
          <target state="translated">С несобираемостью это может быть труднее.Рассмотрим это как пример:если у вас есть эти интерфейсы:</target>
        </trans-unit>
        <trans-unit id="a5b1abb2eabdd6b338fefcfe915a795e0025f2b9" translate="yes" xml:space="preserve">
          <source>Wow, I almost hate to add another answer when we have 57 different ways to recommend the &lt;code&gt;NullObject pattern&lt;/code&gt;, but I think that some people interested in this question may like to know that there is a proposal on the table for Java 7 to add &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;null-safe handling&quot;&lt;/a&gt;&amp;mdash;a streamlined syntax for if-not-equal-null logic.</source>
          <target state="translated">Ничего себе, я почти не хочу добавлять другой ответ, когда у нас есть 57 различных способов рекомендовать &lt;code&gt;NullObject pattern&lt;/code&gt; , но я думаю, что некоторым людям, интересующимся этим вопросом, может быть интересно узнать, что на столе есть предложение для Java 7 добавить &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&amp;laquo;ноль&amp;raquo; -обезопасная обработка &quot;&lt;/a&gt; - упрощенный синтаксис для логики if-not-equal-null.</target>
        </trans-unit>
        <trans-unit id="951af1231b6d7d7d241620882f25427c99d9e5db" translate="yes" xml:space="preserve">
          <source>You can avoid that if you compare your &lt;code&gt;String&lt;/code&gt;s like this:</source>
          <target state="translated">Вы можете избежать этого, если сравниваете свои &lt;code&gt;String&lt;/code&gt; так:</target>
        </trans-unit>
        <trans-unit id="c7f4edd11fb336e0c393189054436b5ea0dd3965" translate="yes" xml:space="preserve">
          <source>You can go a step further and make sure that only valid pojos could be created in your application. (sample from hibernate validator site)</source>
          <target state="translated">Вы можете пойти дальше и удостовериться,что в вашем приложении могут быть созданы только действительные pojos.(образец с сайта валидатора в спящем режиме)</target>
        </trans-unit>
        <trans-unit id="b426fa3dff81bdf8322ce5f08dc73d3a6c054889" translate="yes" xml:space="preserve">
          <source>You can use in method and parameters, like this:</source>
          <target state="translated">Вы можете использовать в методе и параметрах,как это:</target>
        </trans-unit>
        <trans-unit id="f52d6127cbef2caa2515fee8335a6cf4b50a3ecc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map()&lt;/code&gt; operator to perform a computation on--or extract a value from--an optional object.  &lt;code&gt;orElse()&lt;/code&gt; lets you provide a fallback for missing values.</source>
          <target state="translated">Вы можете использовать оператор &lt;code&gt;map()&lt;/code&gt; для вычисления или извлечения значения из необязательного объекта. &lt;code&gt;orElse()&lt;/code&gt; позволяет вам предоставить запасной вариант для пропущенных значений.</target>
        </trans-unit>
        <trans-unit id="1d33b9baf8ae290074a6e9952500c20b8c202dd6" translate="yes" xml:space="preserve">
          <source>You have to check for object != null only if you want to handle the case where the object may be null...</source>
          <target state="translated">Проверять на наличие объекта !=null нужно только в том случае,если вы хотите обработать случай,когда объект может быть нулевым....</target>
        </trans-unit>
        <trans-unit id="5146850a0aff4c1b7d4e622f1b93cada470ef71b" translate="yes" xml:space="preserve">
          <source>You might configure your IDE to warn you about potential null dereferencing. E.g. in Eclipse, see &lt;em&gt;Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors/Warnings/Null analysis&lt;/em&gt;.</source>
          <target state="translated">Вы можете настроить свою среду IDE так, чтобы она предупреждала вас о возможной нулевой разыменованию Например, в Eclipse см. &lt;em&gt;Настройки&amp;gt; Java&amp;gt; Компилятор&amp;gt; Ошибки / Предупреждения / Нулевой анализ&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4a16be11579dd7183f0b53dba9326d6fee7a45" translate="yes" xml:space="preserve">
          <source>allow the Exceptions to ripple through - catch them at the 'main loop' or in some other managing routine.</source>
          <target state="translated">Позволить Исключениям пробиться-поймать их на &quot;главном контуре&quot; или в какой-нибудь другой рутине управления.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a91d8763ddd012bd694861a83ced3c22ba85ef5a" translate="yes" xml:space="preserve">
          <source>check for error conditions and handle them appropriately</source>
          <target state="translated">проверять на наличие ошибок и обращаться с ними соответствующим образом</target>
        </trans-unit>
        <trans-unit id="242af77b8af1f9f1f76f01852e12bf007ce5565b" translate="yes" xml:space="preserve">
          <source>if you write something like:</source>
          <target state="translated">если ты напишешь что-то вроде:</target>
        </trans-unit>
        <trans-unit id="37b00e27e7160b5c20659252018b000c5884b58a" translate="yes" xml:space="preserve">
          <source>notNull(Object object, String message)</source>
          <target state="translated">notNull(Объект,строковое сообщение)</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7f59b1d21b6092bc9549f5f4ed93ec595233ec73" translate="yes" xml:space="preserve">
          <source>or (depending on what you need to check):</source>
          <target state="translated">или (в зависимости от того,что вам нужно проверить):</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="8175c105a4fbc0c1bfbecc0778b58cf2689a03e3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; is a boolean expression and &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; is an object whose &lt;code&gt;toString()&lt;/code&gt; method's output will be included in the error.</source>
          <target state="translated">где &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; - логическое выражение, а &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; - объект, чей вывод метода &lt;code&gt;toString()&lt;/code&gt; будет включен в ошибку.</target>
        </trans-unit>
        <trans-unit id="66933b5352b59bac31f84234608a5d23ea089515" translate="yes" xml:space="preserve">
          <source>where Parser takes raw user input and finds something to do, perhaps if you're implementing a command line interface for something.  Now you might make the contract that it returns null if there's no appropriate action.  That leads the null checking you're talking about.</source>
          <target state="translated">где Parser принимает необработанный пользовательский ввод и находит,что делать,возможно,если вы реализуете интерфейс командной строки для чего-то.Теперь вы можете заключить контракт,что он вернет ноль,если не будет предпринято никаких соответствующих действий.Это приводит к нулевой проверке,о которой вы говорите.</target>
        </trans-unit>
        <trans-unit id="880c9234e5994e5388ead855bf7ee74adb695efb" translate="yes" xml:space="preserve">
          <source>which is a much better design because it leads to more concise code.</source>
          <target state="translated">что гораздо лучше,потому что это приводит к более лаконичному коду.</target>
        </trans-unit>
        <trans-unit id="85d0952dedf1cf905b6bd07f33e02911381c8fd1" translate="yes" xml:space="preserve">
          <source>will result in a &lt;code&gt;NullPointerException&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; doesn't exist.</source>
          <target state="translated">приведет к &lt;code&gt;NullPointerException&lt;/code&gt; , если &lt;code&gt;foo&lt;/code&gt; не существует.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
