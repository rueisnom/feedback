<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/271526">
    <body>
      <group id="271526">
        <trans-unit id="8c66c64b2bf5dce0f66d6a803ea6b6b85f2bd101" translate="yes" xml:space="preserve">
          <source>&quot;&lt;strong&gt;Illegal argument value null is encountered for parameter [plans]&lt;/strong&gt;&quot;</source>
          <target state="translated">&quot; &lt;strong&gt;Se encontr&amp;oacute; un valor de argumento ilegal nulo para el par&amp;aacute;metro [planes]&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="3203cd5f2dfad1b7f4c9811b531d23931fbb7a62" translate="yes" xml:space="preserve">
          <source>(1) is a little harder.  If you have no control over the code you're calling then you're stuck.  If null is a valid response, you have to check for it.</source>
          <target state="translated">(1)es un poco más difícil.Si no tienes control sobre el código al que estás llamando,entonces estás atascado.Si nulo es una respuesta válida,tienes que comprobarlo.</target>
        </trans-unit>
        <trans-unit id="a072e9edaf03771b557f7cc2e3b70299591cad35" translate="yes" xml:space="preserve">
          <source>(2) is easy.  Either use &lt;code&gt;assert&lt;/code&gt; statements (assertions) or allow failure (for example,  &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt;).  Assertions are a highly-underused Java feature that was added in 1.4.  The syntax is:</source>
          <target state="translated">(2) es f&amp;aacute;cil. Utilice las declaraciones de aserci&amp;oacute;n (aserciones) o permita la falla (por ejemplo, &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt; ). Las aserciones son una caracter&amp;iacute;stica de Java altamente infrautilizada que se agreg&amp;oacute; en 1.4. La sintaxis es:</target>
        </trans-unit>
        <trans-unit id="69704da627fa56fa83a9194ab8bb332a79074ac1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option is a monad&lt;/a&gt;, so there is no need for verbose null checking, just use map/foreach/getOrElse or a similar combinator to safely use the value &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(example)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;La opci&amp;oacute;n es una m&amp;oacute;nada&lt;/a&gt; , por lo que no hay necesidad de una verificaci&amp;oacute;n detallada nula, solo use map / foreach / getOrElse o un combinador similar para usar el valor de manera segura &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(ejemplo)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46cc192e40835e83a2ea87cb1bc5d7df3ef20578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt; is a &lt;em&gt;Runtime exception&lt;/em&gt; that means it's developers fault and with enough experience it tells you exactly where is the error.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; es una &lt;em&gt;excepci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n&lt;/em&gt; que significa que es culpa del desarrollador y con suficiente experiencia le dice exactamente d&amp;oacute;nde est&amp;aacute; el error.</target>
        </trans-unit>
        <trans-unit id="31c3bcb907f016d87b77fd8396afc5c0a9d646b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is a way of replacing a nullable T reference with a
  non-null value. An Optional may either contain a non-null T reference
  (in which case we say the reference is &quot;present&quot;), or it may contain
  nothing (in which case we say the reference is &quot;absent&quot;). It is never
  said to &quot;contain null.&quot;</source>
          <target state="translated">&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; es una forma de reemplazar una referencia T anulable con un valor no nulo. Un Opcional puede contener una referencia T no nula (en cuyo caso decimos que la referencia est&amp;aacute; &quot;presente&quot;) o puede no contener nada (en cuyo caso decimos que la referencia est&amp;aacute; &quot;ausente&quot;). Nunca se dice que &quot;contenga nulo&quot;.</target>
        </trans-unit>
        <trans-unit id="795a75979fcb8e946ecd45684159328ee5bf5b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&lt;/code&gt; offers other convenient methods, such as &lt;code&gt;orElse&lt;/code&gt; that allow the use of a default value, and &lt;code&gt;ifPresent&lt;/code&gt; that works with &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Optional&lt;/code&gt; ofrece otros m&amp;eacute;todos convenientes, como &lt;code&gt;orElse&lt;/code&gt; que permiten el uso de un valor predeterminado y &lt;code&gt;ifPresent&lt;/code&gt; que funciona con &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;expresiones lambda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="556c1089ee2ae80da8a26a4b08cfdc720295a1b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you have to deal with an API which might return nulls&lt;/em&gt;, you can't do much in Java. Xtend and Groovy have the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; and the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;null-safe dereference operator&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt;, but note that this returns null in case of a null reference, so it just &quot;defers&quot; the proper handling of null.</source>
          <target state="translated">&lt;em&gt;Si tiene que lidiar con una API que podr&amp;iacute;a devolver nulos&lt;/em&gt; , no puede hacer mucho en Java. Xtend y Groovy tienen el &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;operador de Elvis&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; Y el &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;operador de anulaci&amp;oacute;n de referencia de seguridad nula&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; , pero tenga en cuenta que esto devuelve nulo en caso de una referencia nula, por lo que simplemente &quot;difiere&quot; el manejo adecuado de nulo.</target>
        </trans-unit>
        <trans-unit id="d1609ca504bef341cd938af5cc5c00b4d319ceb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to define a new API where undefined values make sense&lt;/em&gt;, use the &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Option Pattern&lt;/a&gt; (may be familiar from functional languages). It has the following advantages:</source>
          <target state="translated">&lt;em&gt;Si desea definir una nueva API donde los valores indefinidos tienen sentido&lt;/em&gt; , use el &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Patr&amp;oacute;n de opci&amp;oacute;n&lt;/a&gt; (puede ser familiar a partir de lenguajes funcionales). Tiene las siguientes ventajas:</target>
        </trans-unit>
        <trans-unit id="9e6ce6480f1f89172e257cc33912ba94b061ffa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; An &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;official proposal&lt;/a&gt; for a null-safe operator in Java 7 has been submitted under &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; The syntax is a little different than the example above, but it's the same notion.</source>
          <target state="translated">&lt;em&gt;Actualizaci&amp;oacute;n: se ha presentado&lt;/em&gt; una &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;propuesta oficial&lt;/a&gt; para un operador nulo seguro en Java 7 bajo &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; La sintaxis es un poco diferente al ejemplo anterior, pero es la misma noci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d03cf75fd803a5cd91e6e06263f455b21a109fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; The null-safe operator proposal didn't make it into Project Coin. So, you won't be seeing this syntax in Java 7.</source>
          <target state="translated">&lt;em&gt;Actualizaci&amp;oacute;n: la&lt;/em&gt; propuesta del operador nulo-seguro no se convirti&amp;oacute; en Project Coin. Por lo tanto, no ver&amp;aacute; esta sintaxis en Java 7.</target>
        </trans-unit>
        <trans-unit id="7e57dd158da7749eeb4adc7330e0e7f8c7be6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Enfoque 1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a45037cfed52a95964a4b6663009985c519b3729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Enfoque 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b038e1f7a0e785f507e502bb3ed742df87515a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Enfoque 3:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80381f286585ad9109cf5867a45ab2d5ebfacaca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Enfoque 4:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22fb44a7606c8a8e6c1eaf89ff705a2805a4a66f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check for 'No data' only if business logic implies it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Verifique 'Sin datos' solo si la l&amp;oacute;gica de negocios lo implica.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30f5b35acd55daabe9c5d79fbb13c7d538970512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an 'unknown question' give 'unknown answer'.&lt;/strong&gt; (Be null-safe where this is correct from business point of view) Checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call.</source>
          <target state="translated">&lt;strong&gt;Para una 'pregunta desconocida', d&amp;eacute; 'respuesta desconocida'.&lt;/strong&gt; (Sea nulo seguro cuando esto sea correcto desde el punto de vista comercial) Verificar los argumentos para nulo una vez dentro de un m&amp;eacute;todo antes de su uso alivia a varios llamantes de verificarlos antes de una llamada.</target>
        </trans-unit>
        <trans-unit id="17a0daea56744b70e6139473e9163ad0064ca4c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is rather theoretical case and in most cases you should prefer java null safe API (in case it will be released in another 10 years), but &lt;code&gt;NullPointerException&lt;/code&gt; is subclass of an &lt;code&gt;Exception&lt;/code&gt;.&lt;/strong&gt; Thus it is a form of &lt;code&gt;Throwable&lt;/code&gt; that indicates conditions that a reasonable application might want to catch (&lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt;)! To use the first most advantage of exceptions and separate error-handling code from 'regular' code (&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;according to creators of Java&lt;/a&gt;) it is appropriate, as for me, to catch &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Este es un caso bastante te&amp;oacute;rico y, en la mayor&amp;iacute;a de los casos, deber&amp;iacute;a preferir la API Java null safe (en caso de que se lance en otros 10 a&amp;ntilde;os), pero &lt;code&gt;NullPointerException&lt;/code&gt; es una subclase de una &lt;code&gt;Exception&lt;/code&gt; .&lt;/strong&gt; &amp;iexcl;Por lo tanto, es una forma de &lt;code&gt;Throwable&lt;/code&gt; que indica condiciones que una aplicaci&amp;oacute;n razonable podr&amp;iacute;a querer atrapar ( &lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt; )! Para utilizar la primera ventaja de las excepciones y separar el c&amp;oacute;digo de manejo de errores del c&amp;oacute;digo 'regular' ( &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;seg&amp;uacute;n los creadores de Java&lt;/a&gt; ), es apropiado, para m&amp;iacute;, atrapar &lt;code&gt;NullPointerException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32581af00703ba13e0e48e757a8de5a8956459bb" translate="yes" xml:space="preserve">
          <source>A. It could take place if &lt;code&gt;getPhotoByName()&lt;/code&gt; would try to open a database connection, create &lt;code&gt;PreparedStatement&lt;/code&gt; and use the person name as an SQL parameter at last. The approach &lt;em&gt;for an unknown question gives an unknown answer&lt;/em&gt; (case 1) works here. Before grabbing resources the method should check parameters and return 'unknown' result if needed.</source>
          <target state="translated">R. Podr&amp;iacute;a tener lugar si &lt;code&gt;getPhotoByName()&lt;/code&gt; intentara abrir una conexi&amp;oacute;n de base de datos, crear &lt;code&gt;PreparedStatement&lt;/code&gt; y utilizar el nombre de la persona como un par&amp;aacute;metro SQL por fin. El enfoque &lt;em&gt;para una pregunta desconocida da una respuesta desconocida&lt;/em&gt; (caso 1) funciona aqu&amp;iacute;. Antes de obtener recursos, el m&amp;eacute;todo debe verificar los par&amp;aacute;metros y devolver el resultado 'desconocido' si es necesario.</target>
        </trans-unit>
        <trans-unit id="d442bac768e012a67d8005e207d2f07c7f49c725" translate="yes" xml:space="preserve">
          <source>A. It is up to business logic. If I fail to find a photo album I'll show you no photos. What if appContext is not initialized? This method's business logic puts up with this. If the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). The &lt;strong&gt;new Java Null-safe API fits better here to specify selectively what implies and what does not imply to be initialized&lt;/strong&gt; to be fail-fast in case of programmer errors.</source>
          <target state="translated">A. Depende de la l&amp;oacute;gica de negocios. Si no encuentro un &amp;aacute;lbum de fotos, no te mostrar&amp;eacute; fotos. &amp;iquest;Qu&amp;eacute; pasa si appContext no se inicializa? La l&amp;oacute;gica de negocios de este m&amp;eacute;todo lo soporta. Si la misma l&amp;oacute;gica debe ser m&amp;aacute;s estricta que lanzar una excepci&amp;oacute;n, es parte de la l&amp;oacute;gica de negocios y se debe utilizar la verificaci&amp;oacute;n expl&amp;iacute;cita de nulo (caso 3). La &lt;strong&gt;nueva API Java Null-safe encaja mejor aqu&amp;iacute; para especificar selectivamente lo que implica y lo que no implica que se inicialice&lt;/strong&gt; para fallar r&amp;aacute;pidamente en caso de errores del programador.</target>
        </trans-unit>
        <trans-unit id="9f2811ffff90eaa563c42e280cf9e259110f4e13" translate="yes" xml:space="preserve">
          <source>A. Software should be easy to understand and modify firstly. Only after this, one could think about performance, and only if needed! and where needed! (&lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;source&lt;/a&gt;), and many others).</source>
          <target state="translated">A. El software debe ser f&amp;aacute;cil de entender y modificar en primer lugar. Solo despu&amp;eacute;s de esto, uno podr&amp;iacute;a pensar en el rendimiento, &amp;iexcl;y solo si es necesario! y donde sea necesario! ( &lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;fuente&lt;/a&gt; ) y muchos otros).</target>
        </trans-unit>
        <trans-unit id="8d12b90120d6345989195a1a87e9ec644b614091" translate="yes" xml:space="preserve">
          <source>All private methods do not check for null since they are controlled methods (just let die with nullpointer exception in case it wasn't handled above)</source>
          <target state="translated">Todos los métodos privados no comprueban si son nulos,ya que son métodos controlados (sólo dejar morir con la excepción de los nullpointer en caso de que no se hayan manejado anteriormente)</target>
        </trans-unit>
        <trans-unit id="2d362b47b1b8f524063ce05592e2517660992d07" translate="yes" xml:space="preserve">
          <source>All public methods / API always check its arguments for null</source>
          <target state="translated">Todos los métodos públicos de la API siempre comprueban sus argumentos para nulo</target>
        </trans-unit>
        <trans-unit id="651180d90e7fac397932e649f57913d6e17cbdb5" translate="yes" xml:space="preserve">
          <source>Also I would not recommend using this pattern where the type is meant to be a primitive type representation - like mathematical entities, that are not scalars: vectors, matrices, complex numbers and POD(Plain Old Data) objects, which are meant to hold state in form of Java built-in types. In the latter case you would end up calling getter methods with arbitrary results. For example what should a NullPerson.getName() method return?</source>
          <target state="translated">Tampoco recomendaría usar este patrón donde el tipo está destinado a ser una representación de tipo primitivo-como entidades matemáticas,que no son escalares:vectores,matrices,números complejos y objetos POD (Plain Old Data),que están destinados a mantener el estado en forma de tipos incorporados en Java.En este último caso,se terminaría llamando métodos de getter con resultados arbitrarios.Por ejemplo,¿qué debería devolver un método NullPerson.getName()?</target>
        </trans-unit>
        <trans-unit id="f7b3d415a8b44b9ed32e579112942a8c54368712" translate="yes" xml:space="preserve">
          <source>Also keep in mind, that null object pattern will be memory hungry if used without care. For this - the instance of a NullObject should be shared between owners, and not be an unigue instance for each of these.</source>
          <target state="translated">También tenga en cuenta que ese patrón de objeto nulo será hambriento de memoria si se usa sin cuidado.Para esto-la instancia de un Objeto Nulo debe ser compartida entre los propietarios,y no ser una instancia de unigüedad para cada uno de ellos.</target>
        </trans-unit>
        <trans-unit id="f6cc029520b428014830a634a4f74acc230947ba" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;assert&lt;/code&gt; statement throws an &lt;code&gt;Error&lt;/code&gt; (&lt;code&gt;AssertionError&lt;/code&gt;) if the condition is not true.  By default, Java ignores assertions.  You can enable assertions by passing the option &lt;code&gt;-ea&lt;/code&gt; to the JVM.  You can enable and disable assertions for individual classes and packages.  This means that you can validate code with the assertions while developing and testing, and disable them in a production environment, although my testing has shown next to no performance impact from assertions.</source>
          <target state="translated">Una declaraci&amp;oacute;n de aserci&amp;oacute;n arroja un &lt;code&gt;Error&lt;/code&gt; ( &lt;code&gt;AssertionError&lt;/code&gt; ) si la condici&amp;oacute;n no es verdadera. Por defecto, Java ignora las aserciones. Puede habilitar las aserciones pasando la opci&amp;oacute;n &lt;code&gt;-ea&lt;/code&gt; a la JVM. Puede habilitar y deshabilitar aserciones para clases y paquetes individuales. Esto significa que puede validar el c&amp;oacute;digo con las aserciones durante el desarrollo y las pruebas, y deshabilitarlas en un entorno de producci&amp;oacute;n, aunque mis pruebas casi no han demostrado un impacto en el rendimiento de las aserciones.</target>
        </trans-unit>
        <trans-unit id="d1810451c6d1e409ac8c526fe9326856e3fc7731" translate="yes" xml:space="preserve">
          <source>An alternative solution is to never return null and instead use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object pattern&lt;/a&gt;:</source>
          <target state="translated">Una soluci&amp;oacute;n alternativa es no devolver nunca nulo y en su lugar usar el &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;patr&amp;oacute;n de objeto nulo&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="935b1f02f26191e4d51fccc6975811fe44f6303a" translate="yes" xml:space="preserve">
          <source>An optional object for a given type (&lt;code&gt;Fruit&lt;/code&gt;) is created as the return type of a method. It can be empty or contain a &lt;code&gt;Fruit&lt;/code&gt; object:</source>
          <target state="translated">Se crea un objeto opcional para un tipo dado ( &lt;code&gt;Fruit&lt;/code&gt; ) como el tipo de retorno de un m&amp;eacute;todo. Puede estar vac&amp;iacute;o o contener un objeto &lt;code&gt;Fruit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7890138d52aa6dda680f54b0057313bbeec8699c" translate="yes" xml:space="preserve">
          <source>And don't loathe to type &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (generate javadoc in Eclipse) and write three additional words for you public API. This will be more than enough for all but those who don't read documentation.</source>
          <target state="translated">Y no detesta escribir &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (generar javadoc en Eclipse) y escribir tres palabras adicionales para su API p&amp;uacute;blica. Esto ser&amp;aacute; m&amp;aacute;s que suficiente para todos, excepto para aquellos que no leen la documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90d233698926e1669e5eb1d2e7cde879b5ea4b2a" translate="yes" xml:space="preserve">
          <source>And finally, in the code, the first line of the public method goes like this:</source>
          <target state="translated">Y finalmente,en el código,la primera línea del método público dice así:</target>
        </trans-unit>
        <trans-unit id="194d7971422626db3904b18b7a51e13251038301" translate="yes" xml:space="preserve">
          <source>And if you are using Spring, Spring also has the same functionality in its package, see library(spring-2.4.6.jar)</source>
          <target state="translated">Y si estás usando Spring,Spring también tiene la misma funcionalidad en su paquete,ver library(spring-2.4.6.jar)</target>
        </trans-unit>
        <trans-unit id="96abcbe58267cd8ab194fc60b9df329abfd8ab74" translate="yes" xml:space="preserve">
          <source>And it fits with new coming Java API (looking forward)</source>
          <target state="translated">Y encaja con la nueva API Java que viene (mirando hacia adelante)</target>
        </trans-unit>
        <trans-unit id="8a58cb59872c19e045b96568e04e4207657e1c22" translate="yes" xml:space="preserve">
          <source>And the usage is (with &lt;code&gt;import static&lt;/code&gt;):</source>
          <target state="translated">Y el uso es (con &lt;code&gt;import static&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ae0cf01358f7068b6df8fd1b93a1c98822554b48" translate="yes" xml:space="preserve">
          <source>And yes, we know that beyond this line we will no longer encounter a null value so we just safely invoke methods on those objects.</source>
          <target state="translated">Y sí,sabemos que más allá de esta línea ya no nos encontraremos con un valor nulo,así que simplemente invocamos métodos seguros en esos objetos.</target>
        </trans-unit>
        <trans-unit id="81e8d209a324ece42ed62905642bf649b3662f32" translate="yes" xml:space="preserve">
          <source>And you can be sure that this won't happen. :)</source>
          <target state="translated">Y puedes estar seguro de que esto no sucederá.:)</target>
        </trans-unit>
        <trans-unit id="3294bacd3a1276b7be29212d3a5dd40d74f51115" translate="yes" xml:space="preserve">
          <source>As explained in the wiki:</source>
          <target state="translated">Como se explica en la wiki:</target>
        </trans-unit>
        <trans-unit id="f927010b70c936bded38e97a00575ae4404173b5" translate="yes" xml:space="preserve">
          <source>As mentioned in some other answers, to avoid above problems you can follow the &lt;strong&gt;Design by contract&lt;/strong&gt; pattern. Please see &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt;.</source>
          <target state="translated">Como se menciona en algunas otras respuestas, para evitar los problemas anteriores, puede seguir el patr&amp;oacute;n &lt;strong&gt;Dise&amp;ntilde;o por contrato&lt;/strong&gt; . Consulte &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1edc5d84268854adcf97f62dec08810475c6e1" translate="yes" xml:space="preserve">
          <source>As you can see, the second value in the addParam() method (string) is needed for the user message, because you cannot easily detect passed-in variable name, even with reflection (not subject of this post anyway...).</source>
          <target state="translated">Como puedes ver,el segundo valor del método addParam()(string)es necesario para el mensaje de usuario,porque no puedes detectar fácilmente el nombre de la variable pasada,incluso con la reflexión (no es el tema de este post de todos modos...).</target>
        </trans-unit>
        <trans-unit id="221c48cdf1c0d0839054379dfe7e20af1349a56a" translate="yes" xml:space="preserve">
          <source>As you see &lt;code&gt;Optional.ofNullable()&lt;/code&gt; provides an easy way to get the reference wrapped. There are another ways to get the reference of Optional, either &lt;code&gt;Optional.empty()&lt;/code&gt; &amp;amp; &lt;code&gt;Optional.of()&lt;/code&gt;. One for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively.</source>
          <target state="translated">Como puede ver, &lt;code&gt;Optional.ofNullable()&lt;/code&gt; proporciona una manera f&amp;aacute;cil de ajustar la referencia. Hay otras formas de obtener la referencia de Opcional, ya sea &lt;code&gt;Optional.empty()&lt;/code&gt; y &lt;code&gt;Optional.of()&lt;/code&gt; . Uno para devolver un objeto vac&amp;iacute;o en lugar de volver a ajustar nulo y el otro para envolver un objeto no anulable, respectivamente.</target>
        </trans-unit>
        <trans-unit id="7d61afa6fe305594ae8b4e6cf7ecc955c25b75c5" translate="yes" xml:space="preserve">
          <source>Asking that question points out that you may be interested in error handling strategies.  Your team's architect should decide how to work errors.  There are several ways to do this:</source>
          <target state="translated">Hacer esa pregunta indica que puede estar interesado en estrategias de manejo de errores.El arquitecto de tu equipo debería decidir cómo trabajar los errores.Hay varias maneras de hacerlo:</target>
        </trans-unit>
        <trans-unit id="0b437dd2d827fe8753e6c8da99be2952fba3ea42" translate="yes" xml:space="preserve">
          <source>Avoiding != null statements</source>
          <target state="translated">Evitar declaraciones nulas</target>
        </trans-unit>
        <trans-unit id="11cb1da4d18f15638f6174f01e98f7fee924565f" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with &quot;Tell, Don't Ask&quot; Style</source>
          <target state="translated">Evitar las nulidades con el estilo &quot;Tell,Don't Ask&quot;.</target>
        </trans-unit>
        <trans-unit id="c53936ddbedfa72c352067284a2a612bd38150c0" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with Polymorphic Dispatch</source>
          <target state="translated">Evitar los nulos con el Despacho Polimórfico</target>
        </trans-unit>
        <trans-unit id="f4719d3ce5a47c8365160718c824959b1f58c151" translate="yes" xml:space="preserve">
          <source>Basically, you've got &lt;code&gt;@Nullable&lt;/code&gt; and &lt;code&gt;@NotNull&lt;/code&gt;.</source>
          <target state="translated">B&amp;aacute;sicamente, tienes &lt;code&gt;@Nullable&lt;/code&gt; y &lt;code&gt;@NotNull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c18860f21ab893032025c9ad8f874c57757e0d5" translate="yes" xml:space="preserve">
          <source>Byte!</source>
          <target state="translated">Byte!</target>
        </trans-unit>
        <trans-unit id="320bd43703cd7557626230bd2dde77c2b7640f71" translate="yes" xml:space="preserve">
          <source>Common &quot;problem&quot; in Java indeed.</source>
          <target state="translated">Un &quot;problema&quot; común en Java,de hecho.</target>
        </trans-unit>
        <trans-unit id="ab6b4e896ea7eaaed3d3b7bd63695ed61f2bc666" translate="yes" xml:space="preserve">
          <source>Compare:</source>
          <target state="translated">Compare:</target>
        </trans-unit>
        <trans-unit id="4890e65fe4afc7621e1eabc62ca877d901891501" translate="yes" xml:space="preserve">
          <source>Depending on what kind of objects you are checking you may be able to use some of the classes in the apache commons such as: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt;</source>
          <target state="translated">Dependiendo del tipo de objetos que est&amp;eacute; verificando, puede usar algunas de las clases en los comunes de apache como: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; y &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;colecciones de apache commons&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1611574f68477e79c3124a789db72e5b33b65570" translate="yes" xml:space="preserve">
          <source>Doing this</source>
          <target state="translated">Haciendo esto</target>
        </trans-unit>
        <trans-unit id="9a7ba7e5ca69607940820be45f20c7f96e626e73" translate="yes" xml:space="preserve">
          <source>Doing this in your own code and you can avoid != null checks.</source>
          <target state="translated">Haciendo esto en tu propio código y puedes evitar los controles nulos.</target>
        </trans-unit>
        <trans-unit id="a489753c928c4dfb8ffde543140ef98f7d16b3e3" translate="yes" xml:space="preserve">
          <source>Example on how to throw exception on null:</source>
          <target state="translated">Ejemplo de cómo lanzar la excepción sobre el nulo:</target>
        </trans-unit>
        <trans-unit id="c10cb15cb38405cd962e584139f01df735b6c7b4" translate="yes" xml:space="preserve">
          <source>Example on how to use this static classf from spring(org.springframework.util.Assert)</source>
          <target state="translated">Ejemplo de cómo utilizar esta clase estática de spring(org.springframework.util.Assert)</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c7feb78075d63e6bedf1365cc55e6aa7fc3a87a8" translate="yes" xml:space="preserve">
          <source>Finally, here is our NPE as well as null check-free code:</source>
          <target state="translated">Finalmente,aquí está nuestro NPE así como el código nulo libre de cheques:</target>
        </trans-unit>
        <trans-unit id="1428f3662f53c4496ea96cf16634505d0f0a9b2c" translate="yes" xml:space="preserve">
          <source>First, I follow this convention:</source>
          <target state="translated">Primero,sigo esta convención:</target>
        </trans-unit>
        <trans-unit id="3f6a27b732f1a0d9afc335cb45ef93731f4fb5bf" translate="yes" xml:space="preserve">
          <source>First, my thoughts on this:</source>
          <target state="translated">Primero,mis pensamientos sobre esto:</target>
        </trans-unit>
        <trans-unit id="54463d0ab47a851d650e8259c2db7a0ae594a452" translate="yes" xml:space="preserve">
          <source>For example I often use:</source>
          <target state="translated">Por ejemplo,yo uso a menudo:</target>
        </trans-unit>
        <trans-unit id="4b4c9cb4038fad0763e34c64a087da1f526c6087" translate="yes" xml:space="preserve">
          <source>Guava, a very useful core library by Google, has a nice and useful API to avoid nulls. I find &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained&lt;/a&gt; very helpful.</source>
          <target state="translated">Guava, una biblioteca b&amp;aacute;sica muy &amp;uacute;til de Google, tiene una API agradable y &amp;uacute;til para evitar nulos. Considero que &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained es&lt;/a&gt; muy &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="2a6e8249d4017ff690264fec43a31540b1ea7759" translate="yes" xml:space="preserve">
          <source>Here follows an example of how you can use null vallidation in JAVA when you include apache library(commons-lang-2.4.jar)</source>
          <target state="translated">A continuación se muestra un ejemplo de cómo se puede utilizar la validación nula en JAVA cuando se incluye la biblioteca apache (commons-lang-2.4.jar)</target>
        </trans-unit>
        <trans-unit id="37fc03c253b95910c6421c23c78078850ed69a95" translate="yes" xml:space="preserve">
          <source>However, if your method just passes the value on, and the next method passes it on etc. it could get problematic. In that case you may want to check the argument as above.</source>
          <target state="translated">Sin embargo,si su método sólo pasa el valor,y el siguiente método lo pasa,etc.podría ser problemático.En ese caso,puede que quieras comprobar el argumento como se ha indicado anteriormente.</target>
        </trans-unit>
        <trans-unit id="1d268653fde675e2306e93684be579aa72eb2868" translate="yes" xml:space="preserve">
          <source>I consider that it is bad to &quot;eat&quot; something when NULL was passed where NULL isn't a valid value. If you're not exiting the method with some sort of error then it means nothing went wrong in your method which is not true. Then you probably return null in this case, and in the receiving method you again check for null, and it never ends, and you end up with &quot;if != null&quot;, etc..</source>
          <target state="translated">Considero que es malo &quot;comer&quot; algo cuando se ha pasado NULL donde NULL no es un valor válido.Si no sales del método con algún tipo de error,significa que nada salió mal en tu método,lo cual no es cierto.Entonces probablemente devuelvas null en este caso,y en el método receptor vuelvas a comprobar si es null,y nunca termina,y terminas con &quot;if !=null&quot;,etc..</target>
        </trans-unit>
        <trans-unit id="ac7c74b5f9864f037fc949031de21c91fd9060c0" translate="yes" xml:space="preserve">
          <source>I highly disregard answers that suggest using the null objects in every situation. This pattern may break the contract and bury problems deeper and deeper instead of solving them, not mentioning that used inappropriately will create another pile of boilerplate code that will require future maintenance.</source>
          <target state="translated">Descuido las respuestas que sugieren usar los objetos nulos en cada situación.Este patrón puede romper el contrato y enterrar los problemas cada vez más profundamente en lugar de resolverlos,sin mencionar que el uso inapropiado creará otra pila de código de calderilla que requerirá un futuro mantenimiento.</target>
        </trans-unit>
        <trans-unit id="5e1533f4720d20d3996516b4af58f7d3dd16391a" translate="yes" xml:space="preserve">
          <source>I invite you to read this article (my main source for writing this answer) in which the &lt;code&gt;NullPointerException&lt;/code&gt; (and in general null pointer) problematic as well as the (partial) solution brought by &lt;code&gt;Optional&lt;/code&gt; are well explained: &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Los invito a leer este art&amp;iacute;culo (mi fuente principal para escribir esta respuesta) en el que la &lt;code&gt;NullPointerException&lt;/code&gt; (y, en general, el puntero nulo) problem&amp;aacute;tica, as&amp;iacute; como la soluci&amp;oacute;n (parcial) tra&amp;iacute;da por &lt;code&gt;Optional&lt;/code&gt; est&amp;aacute;n bien explicadas: &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Objetos opcionales de Java&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e91faab1ad00e77854ebd2d809262438fc2063" translate="yes" xml:space="preserve">
          <source>I like articles from Nat Pryce. Here are the links:</source>
          <target state="translated">Me gustan los artículos de Nat Pryce.Aquí están los enlaces:</target>
        </trans-unit>
        <trans-unit id="c4217f45a2775c21698ce1470fdcef44f36c7cb8" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;object != null&lt;/code&gt; a lot to avoid &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Yo uso &lt;code&gt;object != null&lt;/code&gt; mucho para evitar &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43aae1b74babe4a5f7cffce5f010ac04c50784b7" translate="yes" xml:space="preserve">
          <source>I'm a fan of &quot;fail fast&quot; code. Ask yourself - are you doing something useful in the case where the parameter is null? If you don't have a clear answer for what your code should do in that case... I.e. it should never be null in the first place, then ignore it and allow a NullPointerException to be thrown. The calling code will make just as much sense of an NPE as it would an IllegalArgumentException, but it'll be easier for the developer to debug and understand what went wrong if an NPE is thrown rather than your code attempting to execute some other unexpected contingency logic - which ultimately results in the application failing anyway.</source>
          <target state="translated">Soy un fanático del código de &quot;falla rápido&quot;.Pregúntate a ti mismo-¿estás haciendo algo útil en el caso de que el parámetro sea nulo? Si no tienes una respuesta clara de lo que tu código debería hacer en ese caso...es decir,nunca debería ser nulo en primer lugar,entonces ignóralo y permite que se lance una excepción de &quot;NullPointerException&quot;.El código de llamada tendrá tanto sentido para una NPE como para una IllegalArgumentException,pero será más fácil para el desarrollador depurar y entender lo que salió mal si se lanza una NPE en lugar de que tu código intente ejecutar alguna otra lógica de contingencia inesperada-lo que finalmente resulta en que la aplicación falle de todos modos.</target>
        </trans-unit>
        <trans-unit id="9d28525daf513a3218069e5463bb837227dd3063" translate="yes" xml:space="preserve">
          <source>I've tried the &lt;code&gt;NullObjectPattern&lt;/code&gt; but for me is not always the best way to go. There are sometimes when a &quot;no action&quot; is not appropiate.</source>
          <target state="translated">He probado el &lt;code&gt;NullObjectPattern&lt;/code&gt; pero para m&amp;iacute; no siempre es la mejor manera de hacerlo. A veces hay una &quot;no acci&amp;oacute;n&quot; que no es apropiada.</target>
        </trans-unit>
        <trans-unit id="55bdc40b2d33d1479a2eed8448e223fe33d03160" translate="yes" xml:space="preserve">
          <source>If (1) is not possible, initialise all collections and arrays to empty collections/arrays.</source>
          <target state="translated">Si (1)no es posible,inicialice todas las colecciones y matrices en matrices vacías.</target>
        </trans-unit>
        <trans-unit id="0e0f1c759db9fd58b965ca2548b987ed339d8a59" translate="yes" xml:space="preserve">
          <source>If appContext or dataSource is not initialized unhandled runtime NullPointerException will kill current thread and will be processed by &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (for you to define and use your favorite logger or other notification mechanizm). If not set, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup#uncaughtException&lt;/a&gt; will print stacktrace to system err. One should monitor application error log and open Jira issue for each unhandled exception which in fact is application error. Programmer should fix bug somewhere in initialization stuff.</source>
          <target state="translated">Si appContext o dataSource no se inicializa en tiempo de ejecuci&amp;oacute;n no controlado, NullPointerException matar&amp;aacute; el subproceso actual y ser&amp;aacute; procesado por &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (para que pueda definir y utilizar su registrador favorito u otro mecanismo de notificaci&amp;oacute;n). Si no se establece, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup # uncaughtException&lt;/a&gt; imprimir&amp;aacute; stacktrace en el sistema err. Uno debe monitorear el registro de errores de la aplicaci&amp;oacute;n y abrir el problema de Jira para cada excepci&amp;oacute;n no manejada, que de hecho es un error de la aplicaci&amp;oacute;n. El programador debe corregir el error en alg&amp;uacute;n lugar de las cosas de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="09e73ecfe67989af7dd8eaebfa15624f78eacae4" translate="yes" xml:space="preserve">
          <source>If it is an internal method (not part of an API), just document that it cannot be null, and that's it.</source>
          <target state="translated">Si se trata de un método interno (que no forma parte de una API),basta con documentar que no puede ser nulo,y eso es todo.</target>
        </trans-unit>
        <trans-unit id="0728dc4e2e97cf099cf3ab0e28a357ee05e7b6ca" translate="yes" xml:space="preserve">
          <source>If it's code that you do control, however (and this is often the case), then it's a different story.  Avoid using nulls as a response.  With methods that return collections, it's easy: return empty collections (or arrays) instead of nulls pretty much all the time.</source>
          <target state="translated">Sin embargo,si se trata de un código que sí controlas (y esto es a menudo el caso),entonces es una historia diferente.Evite usar nulos como respuesta.Con los métodos que devuelven colecciones,es fácil:devuelve colecciones vacías (o matrices)en lugar de nulos casi todo el tiempo.</target>
        </trans-unit>
        <trans-unit id="f619483031223d172a56c6c25092a69d35edf9be" translate="yes" xml:space="preserve">
          <source>If null is allowed</source>
          <target state="translated">Si se permite la nulidad</target>
        </trans-unit>
        <trans-unit id="d5dc5db9bb49b83ae4fcd69d7d06a8b86bbf1b0a" translate="yes" xml:space="preserve">
          <source>If null-values are not allowed</source>
          <target state="translated">Si los valores nulos no están permitidos</target>
        </trans-unit>
        <trans-unit id="9ff0191b7a1ec369d5c5805839743dd0c72f1b9e" translate="yes" xml:space="preserve">
          <source>If undefined values are not permitted:</source>
          <target state="translated">Si no se permiten valores no definidos:</target>
        </trans-unit>
        <trans-unit id="549ca9f1c825f259e5ce60b96c2984b9b0f5f764" translate="yes" xml:space="preserve">
          <source>If undefined values are permitted:</source>
          <target state="translated">Si se permiten valores no definidos:</target>
        </trans-unit>
        <trans-unit id="68f38a6783f67b9f294c501c4581c1585e95009c" translate="yes" xml:space="preserve">
          <source>If you ask me what is the name of my girlfriend I'll tell you that I have no girlfriend. In the Java language I'll return null. 
An alternative would be to throw meaningful exception to indicate some problem that can't be (or don't want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user.</source>
          <target state="translated">Si me preguntas cómo se llama mi novia,te diré que no tengo novia.En el lenguaje de Java volveré nulo.Una alternativa sería lanzar una excepción significativa para indicar algún problema que no puede (o no quiere)ser resuelto allí mismo y delegarlo en algún lugar más alto de la pila para reintentar o informar de un error de acceso a los datos al usuario.</target>
        </trans-unit>
        <trans-unit id="632f1186cdb5143b60b5f2614ffe2a8a35f452f1" translate="yes" xml:space="preserve">
          <source>If you consider an object should not be null (or it is a bug) use an assert.</source>
          <target state="translated">Si considera que un objeto no debe ser nulo (o que es un bicho)utilice una afirmación.</target>
        </trans-unit>
        <trans-unit id="1cf153150df9563cc962ca474b13e56e5c751cce" translate="yes" xml:space="preserve">
          <source>If you know b can never be null, you can just swap it. It is most useful for equals:
Instead of &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; better do &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt;.</source>
          <target state="translated">Si sabe que b nunca puede ser nulo, simplemente puede intercambiarlo. Es m&amp;aacute;s &amp;uacute;til para iguales: en lugar de &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; mejor hacer &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46640e8236124be6c3cf80df96f4c3a462598491" translate="yes" xml:space="preserve">
          <source>If you use (or planning to use) a Java IDE like &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; or &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; or a tool like findbugs then you can use annotations to solve this problem.</source>
          <target state="translated">Si usa (o planea usar) un IDE de Java como &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; o &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; o una herramienta como findbugs, puede usar anotaciones para resolver este problema.</target>
        </trans-unit>
        <trans-unit id="d9bd5740fe135b5553acbf51ff5056141fbbb4dc" translate="yes" xml:space="preserve">
          <source>If your method doesn't accept null params say it in the javadoc and use an assert.</source>
          <target state="translated">Si tu método no acepta params nulos dilo en el javadoc y usa una afirmación.</target>
        </trans-unit>
        <trans-unit id="ce6b2cf4a5e96febfe5ce76451daef36e092d32b" translate="yes" xml:space="preserve">
          <source>If your method is called externally, start with something like this:</source>
          <target state="translated">Si su método se llama externamente,empiece con algo como esto:</target>
        </trans-unit>
        <trans-unit id="ab846b65d9a8fcd8a4b81c40b61e74e028b79991" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt;, a Java-derived language, there are two versions of all types: a potentially-null version and a not-null version. You can only invoke methods on not-null types. Potentially-null types can be converted to not-null types through explicit checking for null. This makes it much easier to know where null checks are necessary and where they aren't.</source>
          <target state="translated">En &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Niza&lt;/a&gt; , un lenguaje derivado de Java, hay dos versiones de todos los tipos: una versi&amp;oacute;n potencialmente nula y una versi&amp;oacute;n no nula. Solo puede invocar m&amp;eacute;todos en tipos no nulos. Los tipos potencialmente nulos se pueden convertir en tipos no nulos mediante la comprobaci&amp;oacute;n expl&amp;iacute;cita de nulos. Esto hace que sea mucho m&amp;aacute;s f&amp;aacute;cil saber d&amp;oacute;nde son necesarias las comprobaciones nulas y d&amp;oacute;nde no.</target>
        </trans-unit>
        <trans-unit id="8317f0d2b647c2aff1a42d76d73339593f638877" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA 10.5 and on, they added support for any other &lt;code&gt;@Nullable&lt;/code&gt;&lt;code&gt;@NotNull&lt;/code&gt; implementations.</source>
          <target state="translated">En IntelliJ IDEA 10.5 y posteriores, agregaron soporte para cualquier otra implementaci&amp;oacute;n de &lt;code&gt;@Nullable&lt;/code&gt; &lt;code&gt;@NotNull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="920588de011f2e8dddc89ccb39b92ea0631e797c" translate="yes" xml:space="preserve">
          <source>In Objective-C, you can do the equivalent of invoking a method on &lt;code&gt;nil&lt;/code&gt;, and absolutely nothing will happen. This makes most null checks unnecessary, but it can make errors much harder to diagnose.</source>
          <target state="translated">En Objective-C, puede hacer el equivalente de invocar un m&amp;eacute;todo en &lt;code&gt;nil&lt;/code&gt; , y absolutamente nada suceder&amp;aacute;. Esto hace que la mayor&amp;iacute;a de las verificaciones nulas sean innecesarias, pero puede hacer que los errores sean mucho m&amp;aacute;s dif&amp;iacute;ciles de diagnosticar.</target>
        </trans-unit>
        <trans-unit id="04837dad91721b9799f52240befed0a8ce992bd5" translate="yes" xml:space="preserve">
          <source>In a nutshell, the Optional class includes methods to explicitly deal with the cases where a value is present or absent. However, the advantage compared to null references is that the Optional&amp;lt;T&amp;gt; class forces you to think about the case when the value is not present. As a consequence, you can prevent unintended null pointer exceptions.</source>
          <target state="translated">En pocas palabras, la clase Opcional incluye m&amp;eacute;todos para tratar expl&amp;iacute;citamente los casos en que un valor est&amp;aacute; presente o ausente. Sin embargo, la ventaja en comparaci&amp;oacute;n con las referencias nulas es que la clase Opcional &amp;lt;T&amp;gt; lo obliga a pensar en el caso cuando el valor no est&amp;aacute; presente. Como consecuencia, puede evitar excepciones de puntero nulo no intencionadas.</target>
        </trans-unit>
        <trans-unit id="f1f3e79c602141290377505754be2b4a12d560ec" translate="yes" xml:space="preserve">
          <source>In above example we have a home service factory that returns a handle to multiple appliances available in the home. But these services may or may not be available/functional; it means it may result in a NullPointerException. Instead of adding a null &lt;code&gt;if&lt;/code&gt; condition before using any service, let's wrap it in to Optional&amp;lt;Service&amp;gt;.</source>
          <target state="translated">En el ejemplo anterior, tenemos una f&amp;aacute;brica de servicios para el hogar que devuelve una manija a varios dispositivos disponibles en el hogar. Pero estos servicios pueden o no estar disponibles / funcionales; significa que puede dar lugar a una NullPointerException. En lugar de agregar una condici&amp;oacute;n &lt;code&gt;if&lt;/code&gt; nula antes de usar cualquier servicio, envu&amp;eacute;lvala a Opcional &amp;lt;Service&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="fc6e5953a54a7e173cf74b9a49d8e3e1c3ed3c55" translate="yes" xml:space="preserve">
          <source>In addition to using &lt;code&gt;assert&lt;/code&gt; you can use the following:</source>
          <target state="translated">Adem&amp;aacute;s de usar la &lt;code&gt;assert&lt;/code&gt; , puede usar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="58e936cf946cec0419aa0692bf595f85b67c954b" translate="yes" xml:space="preserve">
          <source>In an API built from scratch using &lt;code&gt;Optional&lt;/code&gt; whenever a return value might be empty, and returning a plain object only when it cannot be &lt;code&gt;null&lt;/code&gt; (convention), the client code might abandon null checks on simple object return values...</source>
          <target state="translated">En una API construida desde cero usando &lt;code&gt;Optional&lt;/code&gt; siempre que un valor de retorno pueda estar vac&amp;iacute;o, y devolver un objeto plano solo cuando no puede ser &lt;code&gt;null&lt;/code&gt; (convenci&amp;oacute;n), el c&amp;oacute;digo del cliente puede abandonar las verificaciones nulas en valores de retorno de objetos simples ...</target>
        </trans-unit>
        <trans-unit id="992aee948602e38e384351d28a7dc64174420247" translate="yes" xml:space="preserve">
          <source>In my classes, most fields and local variables have non-null default values, and I add contract statements (always-on asserts) everywhere in the code to make sure this is being enforced (since it's more succinct, and more expressive than letting it come up as an NPE and then having to resolve the line number, etc.).</source>
          <target state="translated">En mis clases,la mayoría de los campos y variables locales tienen valores por defecto no nulos,y añado declaraciones de contrato (always-on asserts)en todas partes del código para asegurarme de que esto se cumple (ya que es más sucinto,y más expresivo que dejar que aparezca como un NPE y luego tener que resolver el número de línea,etc.).</target>
        </trans-unit>
        <trans-unit id="a0427014adae81ed68e6059ae2ac27ebf2554012" translate="yes" xml:space="preserve">
          <source>In reality if something returned from a method can be null and the calling code has to make decision upon that, there should an earlier call that ensures the state.</source>
          <target state="translated">En realidad,si algo devuelto de un método puede ser nulo y el código de llamada tiene que tomar una decisión al respecto,debe haber una llamada anterior que asegure el estado.</target>
        </trans-unit>
        <trans-unit id="d28d029f197073e44a5cf2c959d2881818c5cbc8" translate="yes" xml:space="preserve">
          <source>In the articles there is also a link to a Git repository for a Java Maybe Type which I find interesting, but I don't think it alone could decrease the
checking code bloat. After doing some research on the Internet, I think &lt;strong&gt;!= null&lt;/strong&gt; code bloat could be decreased mainly by careful design.</source>
          <target state="translated">En los art&amp;iacute;culos tambi&amp;eacute;n hay un enlace a un repositorio de Git para un Java Maybe Type que me parece interesante, pero no creo que por s&amp;iacute; solo pueda disminuir la hinchaz&amp;oacute;n del c&amp;oacute;digo de verificaci&amp;oacute;n. Despu&amp;eacute;s de investigar un poco en Internet, creo que &lt;strong&gt;! = La expansi&amp;oacute;n de&lt;/strong&gt; c&amp;oacute;digo &lt;strong&gt;nulo&lt;/strong&gt; podr&amp;iacute;a reducirse principalmente mediante un dise&amp;ntilde;o cuidadoso.</target>
        </trans-unit>
        <trans-unit id="02e44622ee08c669f730bdcb2ba763d4bddbd763" translate="yes" xml:space="preserve">
          <source>Is there a good alternative to this?</source>
          <target state="translated">¿Hay una buena alternativa a esto?</target>
        </trans-unit>
        <trans-unit id="24df4f8ef6f8fd18a5d3ec048c3faffe1f0edf74" translate="yes" xml:space="preserve">
          <source>It is stated explicitly in the API whether an input or output exists or not.</source>
          <target state="translated">En la API se indica explícitamente si existe o no una entrada o una salida.</target>
        </trans-unit>
        <trans-unit id="6cd16395a598dc3b1c54e1c2de34abba05b16ef6" translate="yes" xml:space="preserve">
          <source>It may be easier to give you examples, if you show examples of where you typically use the idiom.</source>
          <target state="translated">Puede ser más fácil darle ejemplos,si muestra ejemplos de dónde usa típicamente el modismo.</target>
        </trans-unit>
        <trans-unit id="c32880c4b10a50c8fb02fa59f5e5618dea4d1963" translate="yes" xml:space="preserve">
          <source>It's a nice way to let the compiler check something more than it usually does and to enforce your contracts to be stronger. Unfortunately, it's not supported by all the compilers.</source>
          <target state="translated">Es una buena forma de dejar que el compilador compruebe algo más de lo que suele hacer y de hacer cumplir sus contratos para ser más fuerte.Desafortunadamente,no está soportado por todos los compiladores.</target>
        </trans-unit>
        <trans-unit id="f405e902c0a66a3e8ffdf23a351c22c3a375631a" translate="yes" xml:space="preserve">
          <source>It's actually rare for me to use the idiom &quot;&lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt;&quot;.</source>
          <target state="translated">En realidad, es raro que use el modismo &quot; &lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="714b225b9ed3d9fb4f8f780dad6fe5864bd2db61" translate="yes" xml:space="preserve">
          <source>It's worth considering such cases in order to avoid absurd results.</source>
          <target state="translated">Vale la pena considerar estos casos para evitar resultados absurdos.</target>
        </trans-unit>
        <trans-unit id="e2368895a515e87735e0f53eb54312d0b78e798a" translate="yes" xml:space="preserve">
          <source>Java 7 has a new &lt;code&gt;java.util.Objects&lt;/code&gt; utility class on which there is a &lt;code&gt;requireNonNull()&lt;/code&gt; method. All this does is throw a &lt;code&gt;NullPointerException&lt;/code&gt; if its argument is null, but it cleans up the code a bit. Example:</source>
          <target state="translated">Java 7 tiene una nueva clase de utilidad &lt;code&gt;java.util.Objects&lt;/code&gt; en la que hay un m&amp;eacute;todo &lt;code&gt;requireNonNull()&lt;/code&gt; . Todo lo que hace es lanzar una &lt;code&gt;NullPointerException&lt;/code&gt; si su argumento es nulo, pero limpia un poco el c&amp;oacute;digo. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="edc6b48d824432a77a20f24921f65458059db63b" translate="yes" xml:space="preserve">
          <source>Java 7 introduced the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt;&lt;code&gt;Objects.requireNonNull&lt;/code&gt;&lt;/a&gt; method which can be handy when something should be checked for non-nullness. Example:</source>
          <target state="translated">Java 7 introdujo el m&amp;eacute;todo &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt; &lt;code&gt;Objects.requireNonNull&lt;/code&gt; &lt;/a&gt; que puede ser &amp;uacute;til cuando se debe verificar que algo no sea nulo. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="14057bbaba6e7ba4939e98331bee0a9d4cc6fd00" translate="yes" xml:space="preserve">
          <source>Java 8 has a built-in &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class (recommended); for earlier versions, there are library alternatives, for example &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;'s &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;. But like many functional-style patterns, using Option in Java (even 8) results in quite some boilerplate, which you can reduce using a less verbose JVM language, e.g. Scala or Xtend.</source>
          <target state="translated">Java 8 tiene una clase &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; incorporada (recomendado); para versiones anteriores, hay alternativas de biblioteca, por ejemplo, la &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt; o la &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt; . Pero al igual que muchos patrones de estilo funcional, el uso de Opci&amp;oacute;n en Java (incluso 8) da como resultado un poco de repetitivo, que puede reducir utilizando un lenguaje JVM menos detallado, por ejemplo, Scala o Xtend.</target>
        </trans-unit>
        <trans-unit id="23ec0515f353dee199aaa003dccab705cbddfd12" translate="yes" xml:space="preserve">
          <source>Java 8 has introduced &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;. It is a container that may or may not hold a non-null value. Java 8 has given a safer way to handle an object whose value may be null in some of the cases. It is inspired from the ideas of &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt;.</source>
          <target state="translated">Java 8 ha introducido &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt; . Es un contenedor que puede contener o no un valor no nulo. Java 8 ha dado una forma m&amp;aacute;s segura de manejar un objeto cuyo valor puede ser nulo en algunos de los casos. Est&amp;aacute; inspirado en las ideas de &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; y &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b697deb5aa0b223e01560060b3cb1b1f61855b42" translate="yes" xml:space="preserve">
          <source>Just a sample:</source>
          <target state="translated">Sólo una muestra:</target>
        </trans-unit>
        <trans-unit id="e35fd4948c5a9357196b184cecdd55c2cc10c2d5" translate="yes" xml:space="preserve">
          <source>Just don't ever use null. Don't allow it.</source>
          <target state="translated">Sólo que nunca uses el nulo.No lo permitas.</target>
        </trans-unit>
        <trans-unit id="e6f599b2f399715ad627af5bb0a6d5baae609bba" translate="yes" xml:space="preserve">
          <source>Last example using &lt;code&gt;@Nullable&lt;/code&gt;</source>
          <target state="translated">&amp;Uacute;ltimo ejemplo usando &lt;code&gt;@Nullable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59402a00be4a0f11592ceaf67244cfe61d5bda51" translate="yes" xml:space="preserve">
          <source>Let's consider a method to get a reference of a service from a factory. Instead of returning the service reference, wrap it with Optional. It lets the API user know that the returned service may or may not available/functional, use defensively</source>
          <target state="translated">Consideremos un método para obtener una referencia de un servicio de una fábrica.En lugar de devolver la referencia del servicio,envuélvala con Opcional.Permite al usuario de la API saber que el servicio devuelto puede o no estar disponiblefuncional,usar defensivamente</target>
        </trans-unit>
        <trans-unit id="aabc2d3db3cef830d4da0377e4b7c5b1b3f518c5" translate="yes" xml:space="preserve">
          <source>May I answer it more generally!</source>
          <target state="translated">¡Puedo responder de manera más general!</target>
        </trans-unit>
        <trans-unit id="f433759684160d6db17bda40a8e075111a85c751" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;validate()&lt;/code&gt; will throw checked &lt;code&gt;ValidationException&lt;/code&gt; if any of the parameters is null (checked or unchecked is more a design/taste issue, but my &lt;code&gt;ValidationException&lt;/code&gt; is checked).</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;validate()&lt;/code&gt; arrojar&amp;aacute; &lt;code&gt;ValidationException&lt;/code&gt; marcada si alguno de los par&amp;aacute;metros es nulo (marcado o no marcado es m&amp;aacute;s un problema de dise&amp;ntilde;o / sabor, pero mi &lt;code&gt;ValidationException&lt;/code&gt; est&amp;aacute; marcada).</target>
        </trans-unit>
        <trans-unit id="3f01e85661d751c9b649b3a4ad66bff717bcfdf9" translate="yes" xml:space="preserve">
          <source>Most of the time null checks seem to guard loops over collections or arrays, so just initialise them empty, you won't need any null checks.</source>
          <target state="translated">La mayoría de las veces los cheques nulos parecen guardar bucles sobre colecciones o matrices,así que sólo inicialízalos vacíos,no necesitarás ningún cheque nulo.</target>
        </trans-unit>
        <trans-unit id="10245c94028cb40db8342e6e78c68de0822b9be5" translate="yes" xml:space="preserve">
          <source>Never initialise variables to null.</source>
          <target state="translated">Nunca inicialice las variables a nulo.</target>
        </trans-unit>
        <trans-unit id="92dc04e377ae99c8a6ebf3a5d7e85d43ee0f3ab3" translate="yes" xml:space="preserve">
          <source>Not checking if a variable is null before invoking an equals method (a string compare example below):</source>
          <target state="translated">No comprobar si una variable es nula antes de invocar un método de igualación (un ejemplo de comparación de cadenas más abajo):</target>
        </trans-unit>
        <trans-unit id="99556f0afc8bbece6b8c0e90382fe62b10f3db0b" translate="yes" xml:space="preserve">
          <source>Not using assertions in this case is OK because the code will just fail, which is what will happen if you use assertions.  The only difference is that with assertions it might happen sooner, in a more-meaningful way and possibly with extra information, which may help you to figure out why it happened if you weren't expecting it.</source>
          <target state="translated">No usar aseveraciones en este caso está bien porque el código simplemente fallará,que es lo que sucederá si usas aseveraciones.La única diferencia es que con las aseveraciones puede suceder antes,de una manera más significativa y posiblemente con información adicional,que puede ayudarte a averiguar por qué sucedió si no lo esperabas.</target>
        </trans-unit>
        <trans-unit id="176fa701c30ed80ae841f14d912217b3648526ea" translate="yes" xml:space="preserve">
          <source>Note that addParam() returns self, so that you can add more parameters to check.</source>
          <target state="translated">Ten en cuenta que addParam()se devuelve a sí mismo,por lo que puedes añadir más parámetros para comprobar.</target>
        </trans-unit>
        <trans-unit id="9c7893143e601f4d7141dc682079d103f68d972b" translate="yes" xml:space="preserve">
          <source>Note that the accepted answer may be out of date, see &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; for a more recent approach.</source>
          <target state="translated">Tenga en cuenta que la respuesta aceptada puede estar desactualizada; consulte &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; para obtener un enfoque m&amp;aacute;s reciente.</target>
        </trans-unit>
        <trans-unit id="08c509b05cd5ed1b8001a328275f057bb13241df" translate="yes" xml:space="preserve">
          <source>Now HomeServices.get() does same thing, but in a better way. It checks whether the service is already initialized of not. If it is then return the same or create a new New service. Optional&amp;lt;T&amp;gt;.orElse(T) helps to return a default value.</source>
          <target state="translated">Ahora HomeServices.get () hace lo mismo, pero de una mejor manera. Comprueba si el servicio ya est&amp;aacute; inicializado o no. Si es as&amp;iacute;, devuelva el mismo o cree un nuevo servicio nuevo. Opcional &amp;lt;T&amp;gt; .orElse (T) ayuda a devolver un valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="243fc41a64042cfc5860b15fdd1a86b35656505b" translate="yes" xml:space="preserve">
          <source>Now look at this code where we search a list of &lt;code&gt;Fruit&lt;/code&gt; (&lt;code&gt;fruits&lt;/code&gt;) for a given Fruit instance:</source>
          <target state="translated">Ahora mire este c&amp;oacute;digo donde buscamos una lista de &lt;code&gt;Fruit&lt;/code&gt; ( &lt;code&gt;fruits&lt;/code&gt; ) para una instancia de Fruta dada:</target>
        </trans-unit>
        <trans-unit id="26b0fcf72724ae5ef092ca7b297d0d826206b5cb" translate="yes" xml:space="preserve">
          <source>Now the IntelliJ IDEA compiler will tell you that the check is useless, since the &lt;code&gt;helloWorld()&lt;/code&gt; function won't return &lt;code&gt;null&lt;/code&gt;, ever.</source>
          <target state="translated">Ahora el compilador IDEA de IntelliJ le dir&amp;aacute; que la comprobaci&amp;oacute;n es in&amp;uacute;til, ya que la funci&amp;oacute;n &lt;code&gt;helloWorld()&lt;/code&gt; no volver&amp;aacute; &lt;code&gt;null&lt;/code&gt; , nunca.</target>
        </trans-unit>
        <trans-unit id="cdc1b22c0d793a34bbcf4429fa3f1f90d9486b91" translate="yes" xml:space="preserve">
          <source>Now to the answer:</source>
          <target state="translated">Ahora la respuesta:</target>
        </trans-unit>
        <trans-unit id="2ea239f7f659ef1548e4d08d1e55d7c383740b1c" translate="yes" xml:space="preserve">
          <source>Now you can safely develop the core function of your method without needing to check input parameters, they guard your methods from unexpected parameters.</source>
          <target state="translated">Ahora puede desarrollar con seguridad la función principal de su método sin necesidad de comprobar los parámetros de entrada,protegen sus métodos de parámetros inesperados.</target>
        </trans-unit>
        <trans-unit id="edf43179ef58a381a95f2c17225fe5bf82d216c3" translate="yes" xml:space="preserve">
          <source>Null is not a 'problem'. It is an integral part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;complete&lt;/a&gt; modeling tool set. Software aims to model the complexity of the world and null bears its burden. &lt;strong&gt;Null indicates 'No data' or 'Unknown'&lt;/strong&gt; in Java and the like. So it is appropriate to use nulls for these purposes. I don't prefer the 'Null object' pattern; I think it rise the '&lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;who will guard
the guardians&lt;/a&gt;' problem.</source>
          <target state="translated">Nulo no es un &quot;problema&quot;. Es una parte integral de un conjunto &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;completo de&lt;/a&gt; herramientas de modelado. El software tiene como objetivo modelar la complejidad del mundo y el nulo lleva su carga. &lt;strong&gt;Nulo indica 'Sin datos' o 'Desconocido'&lt;/strong&gt; en Java y similares. Por lo tanto, es apropiado utilizar valores nulos para estos fines. No prefiero el patr&amp;oacute;n 'Objeto nulo'; Creo que surge el problema de &quot; &lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;qui&amp;eacute;n proteger&amp;aacute; a los guardianes&lt;/a&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="29fec67aa38549dd5045b52d3829e32fb6b213cd" translate="yes" xml:space="preserve">
          <source>Of course &lt;code&gt;Optional&lt;/code&gt; could also be used as a method argument, perhaps a better way to indicate optional arguments than 5 or 10 overloading methods in some cases.</source>
          <target state="translated">Por supuesto, &lt;code&gt;Optional&lt;/code&gt; tambi&amp;eacute;n podr&amp;iacute;a usarse como argumento de m&amp;eacute;todo, quiz&amp;aacute;s una mejor manera de indicar argumentos opcionales que 5 o 10 m&amp;eacute;todos de sobrecarga en algunos casos.</target>
        </trans-unit>
        <trans-unit id="4caa61cd647ca110cd57241ba6a32544f2821d80" translate="yes" xml:space="preserve">
          <source>Of course, experience is the better way to understand and apply this suggestion.</source>
          <target state="translated">Por supuesto,la experiencia es la mejor manera de entender y aplicar esta sugerencia.</target>
        </trans-unit>
        <trans-unit id="1025ea9180532a8fb4fe82dbd19b0c29868734a2" translate="yes" xml:space="preserve">
          <source>Of course, the check for null/empty value is still necessary, but at least the developer is conscious that the value might be empty and the risk of forgetting to check is limited.</source>
          <target state="translated">Por supuesto,la comprobación del valor nulo sigue siendo necesaria,pero al menos el desarrollador es consciente de que el valor puede estar vacío y el riesgo de olvidar la comprobación es limitado.</target>
        </trans-unit>
        <trans-unit id="f9b45a3dc805fa3553c19beda43294e7e53857b2" translate="yes" xml:space="preserve">
          <source>Once I adopted this practice, I noticed that the problems seemed to fix themselves. You'd catch things much earlier in the development process just by accident and realize you had a weak spot..  and more importantly.. it helps encapsulate different modules' concerns, different modules can 'trust' each other, and no more littering the code with &lt;code&gt;if = null else&lt;/code&gt; constructs!</source>
          <target state="translated">Una vez que adopt&amp;eacute; esta pr&amp;aacute;ctica, not&amp;eacute; que los problemas parec&amp;iacute;an solucionarse. Descubrir&amp;iacute;a cosas mucho antes en el proceso de desarrollo solo por accidente y se dar&amp;iacute;a cuenta de que ten&amp;iacute;a un punto d&amp;eacute;bil ... y, lo que es m&amp;aacute;s importante, ayuda a encapsular las preocupaciones de los diferentes m&amp;oacute;dulos, los diferentes m&amp;oacute;dulos pueden 'confiar' entre s&amp;iacute; y no dejar m&amp;aacute;s basura c&amp;oacute;digo con &lt;code&gt;if = null else&lt;/code&gt; constructs!</target>
        </trans-unit>
        <trans-unit id="c50fca7276a877e4ddcc3641d754b50d96020d50" translate="yes" xml:space="preserve">
          <source>Once you have wrapped a reference object, Optional provides many useful methods to invoke methods on a wrapped reference without NPE.</source>
          <target state="translated">Una vez que se ha envuelto un objeto de referencia,Opcional proporciona muchos métodos útiles para invocar métodos en una referencia envuelta sin NPE.</target>
        </trans-unit>
        <trans-unit id="72353b7bfc87776c765797b34857c518b0e8dcd9" translate="yes" xml:space="preserve">
          <source>Only for this situation -</source>
          <target state="translated">Sólo para esta situación...</target>
        </trans-unit>
        <trans-unit id="f657c8e08093a6452319f9c30f992b884323f041" translate="yes" xml:space="preserve">
          <source>Optional.ifPresent invokes the given Consumer with a reference if it is a non-null value. Otherwise, it does nothing.</source>
          <target state="translated">Opcional.siPresente invoca al Consumidor dado con una referencia si es un valor no nulo.De lo contrario,no hace nada.</target>
        </trans-unit>
        <trans-unit id="6a132feaa88e9eaf93ca9f96a1e7df9448ce9003" translate="yes" xml:space="preserve">
          <source>Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.</source>
          <target state="translated">O si cree que el mecanismo de trycatch es demasiado feo,en lugar de hacer nada,su acción predeterminada debería proporcionar retroalimentación al usuario.</target>
        </trans-unit>
        <trans-unit id="f766e2839d0e27333563fdfa4a7af0a22bd85132" translate="yes" xml:space="preserve">
          <source>Or in your example:</source>
          <target state="translated">O en su ejemplo:</target>
        </trans-unit>
        <trans-unit id="8d0c023e0356e1bab468181b4ff498742ae4781b" translate="yes" xml:space="preserve">
          <source>PPS. For those fast to downvote (and not so fast to read documentation) I would like to say that I've never caught a null-pointer exception (NPE) in my life. But this possibility was &lt;strong&gt;intentionally designed&lt;/strong&gt; by the Java creators because NPE is a subclass of &lt;code&gt;Exception&lt;/code&gt;. We have a precedent in Java history when &lt;code&gt;ThreadDeath&lt;/code&gt; is an &lt;code&gt;Error&lt;/code&gt; not because it is actually an application error, but solely because it was not intended to be caught! How much NPE fits to be an &lt;code&gt;Error&lt;/code&gt; than &lt;code&gt;ThreadDeath&lt;/code&gt;! But it is not.</source>
          <target state="translated">PPS Para aquellos que deseen votar r&amp;aacute;pidamente (y no tan r&amp;aacute;pido para leer la documentaci&amp;oacute;n), me gustar&amp;iacute;a decir que nunca he visto una excepci&amp;oacute;n de puntero nulo (NPE) en mi vida. Pero esta posibilidad fue &lt;strong&gt;dise&amp;ntilde;ada intencionalmente&lt;/strong&gt; por los creadores de Java porque NPE es una subclase de &lt;code&gt;Exception&lt;/code&gt; . Tenemos un precedente en la historia de Java cuando &lt;code&gt;ThreadDeath&lt;/code&gt; es un &lt;code&gt;Error&lt;/code&gt; no porque en realidad sea un error de aplicaci&amp;oacute;n, &amp;iexcl;sino solo porque no fue pensado para ser detectado! &amp;iexcl;Cu&amp;aacute;nto NPE se ajusta para ser un &lt;code&gt;Error&lt;/code&gt; que &lt;code&gt;ThreadDeath&lt;/code&gt; ! Pero no lo es.</target>
        </trans-unit>
        <trans-unit id="9ee03b92c278aefd505b6e54e78c9dc0b157ad7a" translate="yes" xml:space="preserve">
          <source>PS. This approach will be as reasonable to use as the &lt;em&gt;separate error-handling code from &quot;regular&quot; code&lt;/em&gt; principle is reasonable to use in some place. Consider the next example:</source>
          <target state="translated">PD. Este enfoque ser&amp;aacute; tan razonable de usar como el &lt;em&gt;c&amp;oacute;digo de manejo de errores separado del&lt;/em&gt; principio del &lt;em&gt;c&amp;oacute;digo &quot;regular&quot;&lt;/em&gt; es razonable de usar en alg&amp;uacute;n lugar. Considere el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="ba90388bd4c171ca39fa6b73261783e63a2f28b2" translate="yes" xml:space="preserve">
          <source>Previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library.</source>
          <target state="translated">Lo anterior conduce a un flujo lógico normal para no obtener ninguna foto de una novia inexistente de mi biblioteca de fotos.</target>
        </trans-unit>
        <trans-unit id="8f2b4864d43e2c92095e649bd1429a2c05d7ab61" translate="yes" xml:space="preserve">
          <source>Probably the best alternative for Java 8 or newer is to use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">Probablemente la mejor alternativa para Java 8 o m&amp;aacute;s reciente es usar la clase &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18ac346b6a23f38378a9759b924291326484c819" translate="yes" xml:space="preserve">
          <source>Q. Redundant code could be executed and unnecessary resources could be grabbed.</source>
          <target state="translated">Q.El código redundante podría ser ejecutado y se podrían tomar recursos innecesarios.</target>
        </trans-unit>
        <trans-unit id="60f3d300f344070bb3660651b4b7c84a7c1a7806" translate="yes" xml:space="preserve">
          <source>Q. This approach has a performance penalty due to the try closure opening.</source>
          <target state="translated">Q.Este enfoque tiene una penalización de rendimiento debido a la apertura del cierre del ensayo.</target>
        </trans-unit>
        <trans-unit id="8ada7432c9d8ed60d8ddcb07057e3aa21a1cd988" translate="yes" xml:space="preserve">
          <source>Q. What if &lt;code&gt;getPhotoDataSource()&lt;/code&gt; returns null?</source>
          <target state="translated">Q. &amp;iquest;Qu&amp;eacute; pasa si &lt;code&gt;getPhotoDataSource()&lt;/code&gt; devuelve nulo?</target>
        </trans-unit>
        <trans-unit id="b0f21ff390c71b63fb33e4cf5b2e9b8e9cc3013f" translate="yes" xml:space="preserve">
          <source>Questions could arise:</source>
          <target state="translated">Podrían surgir preguntas:</target>
        </trans-unit>
        <trans-unit id="0c25c125f68f171e56c5dc46a5e78dbdc73323ed" translate="yes" xml:space="preserve">
          <source>Rather than Null Object Pattern -- which has its uses -- you might consider situations where the null object is a bug.</source>
          <target state="translated">En lugar del Patrón de Objeto Nulo-que tiene sus usos-se podrían considerar situaciones en las que el objeto nulo es un bicho.</target>
        </trans-unit>
        <trans-unit id="4e1c9630619b3a985eea9596a353ce64e0b8e71b" translate="yes" xml:space="preserve">
          <source>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.
It is so clean and easy to understand. In the above code example, &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; gets invoked if the Optional holding reference is non-null.</source>
          <target state="translated">Representa una operaci&amp;oacute;n que acepta un &amp;uacute;nico argumento de entrada y no devuelve ning&amp;uacute;n resultado. A diferencia de la mayor&amp;iacute;a de las otras interfaces funcionales, se espera que Consumer opere a trav&amp;eacute;s de efectos secundarios. Es muy limpio y f&amp;aacute;cil de entender. En el ejemplo de c&amp;oacute;digo anterior, se invoca &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; si la referencia de retenci&amp;oacute;n Opcional no es nula.</target>
        </trans-unit>
        <trans-unit id="9951bd4cc66be1c5bf9d684cb3738fbaaf27a9b2" translate="yes" xml:space="preserve">
          <source>SO HOW EXACTLY IT HELPS TO AVOID A NULL CHECK?</source>
          <target state="translated">ASÍ QUE,¿CÓMO AYUDA EXACTAMENTE A EVITAR UN CHEQUE NULO?</target>
        </trans-unit>
        <trans-unit id="12ebfd30869dc6d7d284fbd49560456e553ae1a4" translate="yes" xml:space="preserve">
          <source>See blog post &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;More flexible and configurable @Nullable/@NotNull annotations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Vea la publicaci&amp;oacute;n del blog &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;Anotaciones m&amp;aacute;s flexibles y configurables de @ Nullable / @ NotNull&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c614bff3bcea0ba91a4e4fc674cacfdf5b3e3421" translate="yes" xml:space="preserve">
          <source>So I branch, and do two completely different things. There is no ugly code snippet, because I really need to do two different things depending on the data. For example, should I work on the input, or should I calculate a good default value?</source>
          <target state="translated">Así que me ramifico,y hago dos cosas completamente diferentes.No hay ningún recorte de código feo,porque realmente necesito hacer dos cosas diferentes dependiendo de los datos.Por ejemplo,¿debería trabajar en la entrada,o debería calcular un buen valor por defecto?</target>
        </trans-unit>
        <trans-unit id="ab095d82204599c2467871a3efe97685e021b767" translate="yes" xml:space="preserve">
          <source>So there is no difference between:</source>
          <target state="translated">Así que no hay diferencia entre:</target>
        </trans-unit>
        <trans-unit id="3832db2f40c93881b178af60f45fd152a79ed806" translate="yes" xml:space="preserve">
          <source>So, IMHO, null must be a critical error which prevents further execution (that is, where null is not a valid value).</source>
          <target state="translated">Por lo tanto,IMHO,nulo debe ser un error crítico que impide la ejecución posterior (es decir,cuando nulo no es un valor válido).</target>
        </trans-unit>
        <trans-unit id="91316cbc500c43d5b77c2b413a3f65b2f65958c8" translate="yes" xml:space="preserve">
          <source>Sometimes, you have methods that operate on its parameters that define a symmetric operation:</source>
          <target state="translated">A veces,tienes métodos que funcionan con sus parámetros que definen una operación simétrica:</target>
        </trans-unit>
        <trans-unit id="b8ca7bcd4b5f1acf3e5ba33e4a5f508dec7dea54" translate="yes" xml:space="preserve">
          <source>Sure do have a look at Aspect Oriented Programming, too - they have neat ways to insert &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; into your bytecode.</source>
          <target state="translated">Claro que tambi&amp;eacute;n eche un vistazo a la Programaci&amp;oacute;n Orientada a Aspectos: tienen formas ordenadas de insertar &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; en su c&amp;oacute;digo de bytes .</target>
        </trans-unit>
        <trans-unit id="6f4cfb67cdd3b5f824a9934a1ed6c1fca9c1fc27" translate="yes" xml:space="preserve">
          <source>That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.</source>
          <target state="translated">Dicho esto,tal vez sea totalmente apropiado que el método findAction()lance una Excepción con un mensaje de error significativo --especialmente en este caso en el que se está confiando en la entrada del usuario.Sería mucho mejor para el método findAction lanzar una Excepción que para el método que llama a explotar con una simple NullPointerException sin explicación.</target>
        </trans-unit>
        <trans-unit id="7047d7ff31541da135908e8ecd7f812faea65471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?.&lt;/code&gt; means only de-reference the left identifier if it is not null, otherwise evaluate the remainder of the expression as &lt;code&gt;null&lt;/code&gt;. Some people, like Java Posse member Dick Wall and the &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;voters at Devoxx&lt;/a&gt; really love this proposal, but there is opposition too, on the grounds that it will actually encourage more use of &lt;code&gt;null&lt;/code&gt; as a sentinel value.</source>
          <target state="translated">El &lt;code&gt;?.&lt;/code&gt; significa solo desreferenciar el identificador izquierdo si no es nulo; de lo contrario, eval&amp;uacute;e el resto de la expresi&amp;oacute;n como &lt;code&gt;null&lt;/code&gt; . Algunas personas, como Dick Wall, miembro de Java Posse, y los &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;votantes de Devoxx&lt;/a&gt; realmente adoran esta propuesta, pero tambi&amp;eacute;n hay oposici&amp;oacute;n, porque alentar&amp;aacute; un mayor uso de &lt;code&gt;null&lt;/code&gt; como valor centinela.</target>
        </trans-unit>
        <trans-unit id="78bbb74ffaaf0217ff4697c6fb561008da9384db" translate="yes" xml:space="preserve">
          <source>The Google collections framework offers a good and elegant way to achieve the null check.</source>
          <target state="translated">El marco de las colecciones de Google ofrece una buena y elegante manera de lograr el cheque nulo.</target>
        </trans-unit>
        <trans-unit id="1d0b369ef777f99443515fd98b70d6cbe6356789" translate="yes" xml:space="preserve">
          <source>The StringUtils class is only one of many; there are quite a few good classes in the commons that do null safe manipulation.</source>
          <target state="translated">La clase StringUtils es sólo una de muchas;hay bastantes buenas clases en los comunes que hacen nula la manipulación segura.</target>
        </trans-unit>
        <trans-unit id="b3066493bcd46f61316ddaca0d5573d18b01f7cd" translate="yes" xml:space="preserve">
          <source>The compiler forces you to handle the &quot;undefined&quot; case.</source>
          <target state="translated">El compilador te obliga a manejar el caso &quot;indefinido&quot;.</target>
        </trans-unit>
        <trans-unit id="11db0d52c7259e3f5542cc11ae35ecc39a7f84be" translate="yes" xml:space="preserve">
          <source>The complete post is &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE as well as Null check-free code &amp;hellip; Really?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">La publicaci&amp;oacute;n completa es &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE, as&amp;iacute; como un c&amp;oacute;digo de verificaci&amp;oacute;n nulo ... &amp;iquest;En serio?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6f36738048a72c2ff14555a1f49f971e924f9660" translate="yes" xml:space="preserve">
          <source>The contracts are like mini-unit tests which are always running, even in production, and when things fail, you know why, rather than a random NPE you have to somehow figure out.</source>
          <target state="translated">Los contratos son como mini-unidades de prueba que siempre están en funcionamiento,incluso en la producción,y cuando las cosas fallan,sabes por qué,en lugar de un NPE aleatorio tienes que averiguar de alguna manera.</target>
        </trans-unit>
        <trans-unit id="8b07fde497d833a3dea4d5d1623ff04bff7cd150" translate="yes" xml:space="preserve">
          <source>The example given by Alex Miller looks like this:</source>
          <target state="translated">El ejemplo dado por Alex Miller se parece a esto:</target>
        </trans-unit>
        <trans-unit id="6b1e5e00880fd770c374b1874c5898efc9b29533" translate="yes" xml:space="preserve">
          <source>The message will contain the following text if, for example, &quot;plans&quot; is null:</source>
          <target state="translated">El mensaje contendrá el siguiente texto si,por ejemplo,&quot;planes&quot; es nulo:</target>
        </trans-unit>
        <trans-unit id="50acd96098203094b440f2ee9754742ef52b2da0" translate="yes" xml:space="preserve">
          <source>The method is most useful for &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;checking&lt;/a&gt; just before an assignment in a constructor, where each use of it can save three lines of code:</source>
          <target state="translated">El m&amp;eacute;todo es m&amp;aacute;s &amp;uacute;til para &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;verificar&lt;/a&gt; justo antes de una asignaci&amp;oacute;n en un constructor, donde cada uso del mismo puede guardar tres l&amp;iacute;neas de c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="e93d133895627c9a3d74a6c30e204dcdb8e532ac" translate="yes" xml:space="preserve">
          <source>The only other methods which do not check for null are utility methods. They are public, but if you call them for some reason, you know what parameters you pass. This is like trying to boil water in the kettle without providing water...</source>
          <target state="translated">Los únicos otros métodos que no comprueban la nulidad son los métodos de utilidad.Son públicos,pero si los llamas por alguna razón,sabes qué parámetros pasas.Esto es como intentar hervir agua en la tetera sin proporcionar agua...</target>
        </trans-unit>
        <trans-unit id="3071661bc3a8f3f1fb050d846047c85545570484" translate="yes" xml:space="preserve">
          <source>The second example won't compile (in IntelliJ IDEA).</source>
          <target state="translated">El segundo ejemplo no compilará (en IntelliJ IDEA).</target>
        </trans-unit>
        <trans-unit id="d6530e4dc64d23e3133b0d5fd801c0b069e04e94" translate="yes" xml:space="preserve">
          <source>The way I solve this problem is this:</source>
          <target state="translated">La forma en que resuelvo este problema es esta:</target>
        </trans-unit>
        <trans-unit id="8b0438900bb10b9989752d1f3c4b40b7f47f6df7" translate="yes" xml:space="preserve">
          <source>Then, in the rest of that method, you'll know that &lt;code&gt;object&lt;/code&gt; is not null.</source>
          <target state="translated">Luego, en el resto de ese m&amp;eacute;todo, sabr&amp;aacute; que el &lt;code&gt;object&lt;/code&gt; no es nulo.</target>
        </trans-unit>
        <trans-unit id="79a6826b25f58343482759c32d1843c3fcfde425" translate="yes" xml:space="preserve">
          <source>There is a method in a library class like this:</source>
          <target state="translated">Hay un método en una clase de biblioteca como esta:</target>
        </trans-unit>
        <trans-unit id="7b611806237c884a66462ab8d01c1db4a0455d83" translate="yes" xml:space="preserve">
          <source>There is a proposal to add new annotations in Java7 to help with null / notnull params:
&lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</source>
          <target state="translated">Hay una propuesta para agregar nuevas anotaciones en Java7 para ayudar con los par&amp;aacute;metros nulos / no nulos: &lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdcc90e0f67eeda9f92fa7029efb8f80e4f6cda3" translate="yes" xml:space="preserve">
          <source>There is a tiny overhead in this, but it's worth it for cleaner code and less NullPointerExceptions.</source>
          <target state="translated">Hay una pequeña sobrecarga en esto,pero vale la pena por un código más limpio y menos excepciones de NullPointer.</target>
        </trans-unit>
        <trans-unit id="a995a0c78ad44e2ea78fecf0b6b5ae088210dbfb" translate="yes" xml:space="preserve">
          <source>They both want to make sure that we received valid parameters, before we do any other functions.</source>
          <target state="translated">Ambos quieren asegurarse de que recibimos parámetros válidos,antes de hacer cualquier otra función.</target>
        </trans-unit>
        <trans-unit id="0de62a4c684b4be885c335e3c1f969aeb6ca39e3" translate="yes" xml:space="preserve">
          <source>They work like that:</source>
          <target state="translated">Trabajan así:</target>
        </trans-unit>
        <trans-unit id="6da291a4214849ad22b47d77f7b9e5c7c2ed3dbb" translate="yes" xml:space="preserve">
          <source>This checks for a &lt;code&gt;NullPointerException&lt;/code&gt; for the &lt;code&gt;someobject&lt;/code&gt; object in the above snippet.</source>
          <target state="translated">Esto busca una &lt;code&gt;NullPointerException&lt;/code&gt; para el objeto de &lt;code&gt;someobject&lt;/code&gt; objeto en el fragmento anterior.</target>
        </trans-unit>
        <trans-unit id="a632edab67a162af8d6236e911205c0bd2945507" translate="yes" xml:space="preserve">
          <source>This is a very common problem for every Java developer. So there is official support in Java&amp;nbsp;8 to address these issues without cluttered code.</source>
          <target state="translated">Este es un problema muy com&amp;uacute;n para todos los desarrolladores de Java. Por lo tanto, hay soporte oficial en Java 8 para abordar estos problemas sin c&amp;oacute;digo desordenado.</target>
        </trans-unit>
        <trans-unit id="63475a15e2d7175b43a8eb4ced243071760761e7" translate="yes" xml:space="preserve">
          <source>This is defensive programming and results in much cleaner code in the long run. Always sanitize the data, e.g. here by enforcing rigid standards, and the problems go away.</source>
          <target state="translated">Esta es una programación defensiva y resulta en un código mucho más limpio a largo plazo.Siempre desinfecte los datos,por ejemplo aquí haciendo cumplir normas rígidas,y los problemas desaparecen.</target>
        </trans-unit>
        <trans-unit id="96855dbf651af7ee23c0764f0f76d95841159676" translate="yes" xml:space="preserve">
          <source>This is especially handy for long chains of possible null values. Example:</source>
          <target state="translated">Esto es especialmente útil para las largas cadenas de posibles valores nulos.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="ab20b6e950b963a0a9153b9bd523a03c124b9ceb" translate="yes" xml:space="preserve">
          <source>This is slightly better than:</source>
          <target state="translated">Esto es ligeramente mejor que:</target>
        </trans-unit>
        <trans-unit id="4f0f6bf669b0e6c235196e52c58820b609d7a7a9" translate="yes" xml:space="preserve">
          <source>This is the most common error occurred for most of the developers.</source>
          <target state="translated">Este es el error más común ocurrido para la mayoría de los desarrolladores.</target>
        </trans-unit>
        <trans-unit id="2c2ef7f8c0c5f5953f9d8dc9f87238113a866d47" translate="yes" xml:space="preserve">
          <source>This really depends. If find that I often do something like this:</source>
          <target state="translated">Esto realmente depende.Si descubro que a menudo hago algo como esto:</target>
        </trans-unit>
        <trans-unit id="5f65d63d47b93827d172b66566e2699ba53e9246" translate="yes" xml:space="preserve">
          <source>This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don't know or don't trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.</source>
          <target state="translated">Esto me suena como un problema razonablemente común que los desarrolladores de nivel inferior a intermedio tienden a enfrentar en algún momento:o no saben o no confían en los contratos en los que están participando y sobrevuelan defensivamente en busca de nulos.Además,cuando escriben su propio código,tienden a confiar en la devolución de los nulos para indicar algo,lo que requiere que la persona que llama compruebe si hay nulos.</target>
        </trans-unit>
        <trans-unit id="d66c4aae334386fa18d2bf51fc0dd0e22c5fcd02" translate="yes" xml:space="preserve">
          <source>This way, the code is clean, easy maintainable and readable.</source>
          <target state="translated">De esta manera,el código es limpio,fácil de mantener y de leer.</target>
        </trans-unit>
        <trans-unit id="88e9d9f0b01df7bd366fd6f414813582c76c2a26" translate="yes" xml:space="preserve">
          <source>This won't compile.</source>
          <target state="translated">Esto no se compilará.</target>
        </trans-unit>
        <trans-unit id="03a1146d56211c08b24efbc23fe64db2a1fe9e19" translate="yes" xml:space="preserve">
          <source>To implement this pattern in java, you can use core java annotations like &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; or use more sophisticated libraries like &lt;strong&gt;Hibernate Validator&lt;/strong&gt;.</source>
          <target state="translated">Para implementar este patr&amp;oacute;n en java, puede usar anotaciones centrales de java como &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; o usar bibliotecas m&amp;aacute;s sofisticadas como &lt;strong&gt;Hibernate Validator&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="65dd044ab70d140d1269ad7b58d585a319cf8c8e" translate="yes" xml:space="preserve">
          <source>To put this another way, there are two instances where null checking comes up:</source>
          <target state="translated">Para decirlo de otra manera,hay dos casos en los que la comprobación nula surge:</target>
        </trans-unit>
        <trans-unit id="893faf3275f29660c0345c697429903da97cca3c" translate="yes" xml:space="preserve">
          <source>Try to make all your attributes and its accessors as private as possible or avoid to  expose them to the clients at all. You can have the argument values in the constructor of course, but by reducing the scope you don't let the client class pass an invalid value. If you need to modify the values, you can always create a new &lt;code&gt;object&lt;/code&gt;.  You check the values in the constructor only &lt;strong&gt;once&lt;/strong&gt; and in the rest of the methods you can be almost sure that the values are not null.</source>
          <target state="translated">Intente hacer que todos sus atributos y sus accesores sean lo m&amp;aacute;s privados posible o evite exponerlos a los clientes. Puede tener los valores de argumento en el constructor, por supuesto, pero al reducir el alcance no permite que la clase del cliente pase un valor no v&amp;aacute;lido. Si necesita modificar los valores, siempre puede crear un nuevo &lt;code&gt;object&lt;/code&gt; . Verifica los valores en el constructor solo &lt;strong&gt;una vez&lt;/strong&gt; y en el resto de los m&amp;eacute;todos puede estar casi seguro de que los valores no son nulos.</target>
        </trans-unit>
        <trans-unit id="5096108c9ee2936b6660a55e9c083bcd59532700" translate="yes" xml:space="preserve">
          <source>Ultimately, the only way to completely solve this problem is by using a different programming language:</source>
          <target state="translated">En última instancia,la única manera de resolver completamente este problema es usando un lenguaje de programación diferente:</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="91e3b61c16f5d43c2c292405b4146327e9221a06" translate="yes" xml:space="preserve">
          <source>Using parameter</source>
          <target state="translated">Usando el parámetro</target>
        </trans-unit>
        <trans-unit id="410ecb47e87fed6b528cde0e827e193125ef8e2c" translate="yes" xml:space="preserve">
          <source>WRAPPING TO OPTION&amp;lt;T&amp;gt;</source>
          <target state="translated">ENVOLVER A LA OPCI&amp;Oacute;N &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16139730df851e7de2b4d9ecb2a4976efb2493cf" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;usually&lt;/strong&gt; face this issue when the methods get the parameters in the way we not expected (bad method call is programmer's fault). For example: you expect to get an object, instead you get a null. You expect to get an String with at least one character, instead you get an empty String ...</source>
          <target state="translated">Por lo &lt;strong&gt;general,&lt;/strong&gt; nos enfrentamos a este problema cuando los m&amp;eacute;todos obtienen los par&amp;aacute;metros de la manera que no esper&amp;aacute;bamos (la llamada al m&amp;eacute;todo incorrecta es culpa del programador). Por ejemplo: espera obtener un objeto, en su lugar, obtiene un valor nulo. Esperas obtener una Cadena con al menos un car&amp;aacute;cter, en su lugar obtienes una Cadena vac&amp;iacute;a ...</target>
        </trans-unit>
        <trans-unit id="81d7e415e730d427573e6b4ff607e889a2cb73ec" translate="yes" xml:space="preserve">
          <source>We have number of ways to handle this.</source>
          <target state="translated">Tenemos varias maneras de manejar esto.</target>
        </trans-unit>
        <trans-unit id="0f598db2507984034e96ef0808dfe220b74dab82" translate="yes" xml:space="preserve">
          <source>We use the ternary operator very often for checking null condition and return an alternative value or default value. Optional provides another way to handle the same condition without checking null. Optional.orElse(defaultObj) returns defaultObj if the Optional has a null value. Let's use this in our sample code:</source>
          <target state="translated">Utilizamos el operador ternario muy a menudo para comprobar la condición nula y devolver un valor alternativo o un valor por defecto.Opcional proporciona otra forma de manejar la misma condición sin comprobar la nulidad.Opcional.oElse(defaultObj)devuelve defaultObj si el Opcional tiene un valor nulo.Usemos esto en nuestro código de muestra:</target>
        </trans-unit>
        <trans-unit id="1b7de74b75d773507feae3e01547f3abd8a8e794" translate="yes" xml:space="preserve">
          <source>When the exception is thrown, examine the stack trace and work through the bug.</source>
          <target state="translated">Cuando la excepción es lanzada,examine el rastro de la pila y trabaje a través del bicho.</target>
        </trans-unit>
        <trans-unit id="56f60bd1b035c1637de885e8364d676ed25dd3d5" translate="yes" xml:space="preserve">
          <source>When you use the first &lt;code&gt;helloWorld()&lt;/code&gt; function in another piece of code:</source>
          <target state="translated">Cuando usa la primera funci&amp;oacute;n &lt;code&gt;helloWorld()&lt;/code&gt; en otro c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="79b6177f112f6c351c671521cc708abf0dbc2ef4" translate="yes" xml:space="preserve">
          <source>Where it isn't a valid response.</source>
          <target state="translated">Donde no es una respuesta válida.</target>
        </trans-unit>
        <trans-unit id="35c99b0c8fc1f9ea3f573be119257028ced0e610" translate="yes" xml:space="preserve">
          <source>Where null is a valid response in terms of the contract; and</source>
          <target state="translated">Cuando la nulidad es una respuesta válida en los términos del contrato;y</target>
        </trans-unit>
        <trans-unit id="cdfe105c8bfbcc3b13ac6840fef58d8c1666a5a4" translate="yes" xml:space="preserve">
          <source>While it is rather 'normal business flow' not to find photo stored into the DB for some person, I used to use pairs like below for some other cases</source>
          <target state="translated">Aunque es bastante &quot;normal&quot; no encontrar fotos almacenadas en la base de datos de alguna persona,solía usar pares como el de abajo para algunos otros casos.</target>
        </trans-unit>
        <trans-unit id="580ecabb6906d2e8e175eeee96c8cd0b5d5e79e0" translate="yes" xml:space="preserve">
          <source>With Java 8 comes the new &lt;code&gt;java.util.Optional&lt;/code&gt; class that arguably solves some of the problem. One can at least say that it improves the readability of the code, and in the case of public APIs make the API's contract clearer to the client developer.</source>
          <target state="translated">Con Java 8 viene la nueva clase &lt;code&gt;java.util.Optional&lt;/code&gt; que podr&amp;iacute;a resolver parte del problema. Al menos se puede decir que mejora la legibilidad del c&amp;oacute;digo y, en el caso de las API p&amp;uacute;blicas, hace que el contrato de la API sea m&amp;aacute;s claro para el desarrollador del cliente.</target>
        </trans-unit>
        <trans-unit id="2f3836243579dcf0aab46f92bd120d19df8df941" translate="yes" xml:space="preserve">
          <source>With non-collections it might be harder.  Consider this as an example: if you have these interfaces:</source>
          <target state="translated">Con las no colecciones puede ser más difícil.Considere esto como un ejemplo:si tiene estas interfaces:</target>
        </trans-unit>
        <trans-unit id="a5b1abb2eabdd6b338fefcfe915a795e0025f2b9" translate="yes" xml:space="preserve">
          <source>Wow, I almost hate to add another answer when we have 57 different ways to recommend the &lt;code&gt;NullObject pattern&lt;/code&gt;, but I think that some people interested in this question may like to know that there is a proposal on the table for Java 7 to add &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;null-safe handling&quot;&lt;/a&gt;&amp;mdash;a streamlined syntax for if-not-equal-null logic.</source>
          <target state="translated">Wow, casi odio agregar otra respuesta cuando tenemos 57 formas diferentes de recomendar el &lt;code&gt;NullObject pattern&lt;/code&gt; , pero creo que a algunas personas interesadas en esta pregunta les gustar&amp;iacute;a saber que hay una propuesta sobre la mesa para Java 7 para agregar &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;nulo &quot;manejo seguro&quot;:&lt;/a&gt; una sintaxis optimizada para la l&amp;oacute;gica si no es igual a nula.</target>
        </trans-unit>
        <trans-unit id="951af1231b6d7d7d241620882f25427c99d9e5db" translate="yes" xml:space="preserve">
          <source>You can avoid that if you compare your &lt;code&gt;String&lt;/code&gt;s like this:</source>
          <target state="translated">Puede evitar eso si compara sus &lt;code&gt;String&lt;/code&gt; esta manera:</target>
        </trans-unit>
        <trans-unit id="c7f4edd11fb336e0c393189054436b5ea0dd3965" translate="yes" xml:space="preserve">
          <source>You can go a step further and make sure that only valid pojos could be created in your application. (sample from hibernate validator site)</source>
          <target state="translated">Puedes ir un paso más allá y asegurarte de que sólo se puedan crear pojos válidos en tu aplicación.(muestra del sitio del validador de hibernación)</target>
        </trans-unit>
        <trans-unit id="b426fa3dff81bdf8322ce5f08dc73d3a6c054889" translate="yes" xml:space="preserve">
          <source>You can use in method and parameters, like this:</source>
          <target state="translated">Se puede usar en el método y los parámetros,así:</target>
        </trans-unit>
        <trans-unit id="f52d6127cbef2caa2515fee8335a6cf4b50a3ecc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map()&lt;/code&gt; operator to perform a computation on--or extract a value from--an optional object.  &lt;code&gt;orElse()&lt;/code&gt; lets you provide a fallback for missing values.</source>
          <target state="translated">Puede usar el operador &lt;code&gt;map()&lt;/code&gt; para realizar un c&amp;aacute;lculo en, o extraer un valor de, un objeto opcional. &lt;code&gt;orElse()&lt;/code&gt; permite proporcionar una reserva para los valores faltantes.</target>
        </trans-unit>
        <trans-unit id="1d33b9baf8ae290074a6e9952500c20b8c202dd6" translate="yes" xml:space="preserve">
          <source>You have to check for object != null only if you want to handle the case where the object may be null...</source>
          <target state="translated">Tienes que comprobar si el objeto es nulo sólo si quieres manejar el caso de que el objeto sea nulo...</target>
        </trans-unit>
        <trans-unit id="5146850a0aff4c1b7d4e622f1b93cada470ef71b" translate="yes" xml:space="preserve">
          <source>You might configure your IDE to warn you about potential null dereferencing. E.g. in Eclipse, see &lt;em&gt;Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors/Warnings/Null analysis&lt;/em&gt;.</source>
          <target state="translated">Puede configurar su IDE para advertirle sobre una posible desreferencia nula. Por ejemplo, en Eclipse, vea &lt;em&gt;Preferencias&amp;gt; Java&amp;gt; Compilador&amp;gt; Errores / Advertencias / An&amp;aacute;lisis nulo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4a16be11579dd7183f0b53dba9326d6fee7a45" translate="yes" xml:space="preserve">
          <source>allow the Exceptions to ripple through - catch them at the 'main loop' or in some other managing routine.</source>
          <target state="translated">permitir que las Excepciones se abran paso-atraparlas en el &quot;bucle principal&quot; o en alguna otra rutina de manejo.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a91d8763ddd012bd694861a83ced3c22ba85ef5a" translate="yes" xml:space="preserve">
          <source>check for error conditions and handle them appropriately</source>
          <target state="translated">comprobar las condiciones de error y manejarlas apropiadamente</target>
        </trans-unit>
        <trans-unit id="242af77b8af1f9f1f76f01852e12bf007ce5565b" translate="yes" xml:space="preserve">
          <source>if you write something like:</source>
          <target state="translated">si escribes algo como:</target>
        </trans-unit>
        <trans-unit id="37b00e27e7160b5c20659252018b000c5884b58a" translate="yes" xml:space="preserve">
          <source>notNull(Object object, String message)</source>
          <target state="translated">notNull(Objeto objeto,mensaje de cadena)</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7f59b1d21b6092bc9549f5f4ed93ec595233ec73" translate="yes" xml:space="preserve">
          <source>or (depending on what you need to check):</source>
          <target state="translated">o (dependiendo de lo que necesites comprobar):</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="8175c105a4fbc0c1bfbecc0778b58cf2689a03e3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; is a boolean expression and &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; is an object whose &lt;code&gt;toString()&lt;/code&gt; method's output will be included in the error.</source>
          <target state="translated">donde &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; es una expresi&amp;oacute;n booleana y &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; es un objeto cuya salida del m&amp;eacute;todo &lt;code&gt;toString()&lt;/code&gt; se incluir&amp;aacute; en el error.</target>
        </trans-unit>
        <trans-unit id="66933b5352b59bac31f84234608a5d23ea089515" translate="yes" xml:space="preserve">
          <source>where Parser takes raw user input and finds something to do, perhaps if you're implementing a command line interface for something.  Now you might make the contract that it returns null if there's no appropriate action.  That leads the null checking you're talking about.</source>
          <target state="translated">donde Parser toma las entradas del usuario en bruto y encuentra algo que hacer,tal vez si estás implementando una interfaz de línea de comandos para algo.Ahora podrías hacer que el contrato que devuelve sea nulo si no hay una acción apropiada.Eso lleva a la comprobación de nulos de la que estás hablando.</target>
        </trans-unit>
        <trans-unit id="880c9234e5994e5388ead855bf7ee74adb695efb" translate="yes" xml:space="preserve">
          <source>which is a much better design because it leads to more concise code.</source>
          <target state="translated">que es un diseño mucho mejor porque conduce a un código más conciso.</target>
        </trans-unit>
        <trans-unit id="85d0952dedf1cf905b6bd07f33e02911381c8fd1" translate="yes" xml:space="preserve">
          <source>will result in a &lt;code&gt;NullPointerException&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; doesn't exist.</source>
          <target state="translated">resultar&amp;aacute; en una &lt;code&gt;NullPointerException&lt;/code&gt; si &lt;code&gt;foo&lt;/code&gt; no existe.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
