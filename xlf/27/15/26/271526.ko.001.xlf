<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/271526">
    <body>
      <group id="271526">
        <trans-unit id="8c66c64b2bf5dce0f66d6a803ea6b6b85f2bd101" translate="yes" xml:space="preserve">
          <source>&quot;&lt;strong&gt;Illegal argument value null is encountered for parameter [plans]&lt;/strong&gt;&quot;</source>
          <target state="translated">&quot; &lt;strong&gt;매개 변수 [plans]에 대해 잘못된 인수 값 null이 발생했습니다.&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="3203cd5f2dfad1b7f4c9811b531d23931fbb7a62" translate="yes" xml:space="preserve">
          <source>(1) is a little harder.  If you have no control over the code you're calling then you're stuck.  If null is a valid response, you have to check for it.</source>
          <target state="translated">(1) 조금 더 어렵다. 호출하는 코드를 제어 할 수 없으면 문제가 발생한 것입니다. null이 유효한 응답 인 경우 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="a072e9edaf03771b557f7cc2e3b70299591cad35" translate="yes" xml:space="preserve">
          <source>(2) is easy.  Either use &lt;code&gt;assert&lt;/code&gt; statements (assertions) or allow failure (for example,  &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt;).  Assertions are a highly-underused Java feature that was added in 1.4.  The syntax is:</source>
          <target state="translated">(2) 쉽다. &lt;code&gt;assert&lt;/code&gt; 문 (어설 션)을 사용하거나 실패를 허용하십시오 (예 : &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/index.html?java/lang/NullPointerException.html&quot;&gt;NullPointerException&lt;/a&gt; ). 어설 션은 1.4에서 추가 된 잘 사용되지 않는 Java 기능입니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69704da627fa56fa83a9194ab8bb332a79074ac1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option is a monad&lt;/a&gt;, so there is no need for verbose null checking, just use map/foreach/getOrElse or a similar combinator to safely use the value &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(example)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://james-iry.blogspot.com/2007/08/martians-vs-monads-null-considered.html&quot;&gt;Option은 모나드&lt;/a&gt; 이므로 자세한 null 검사가 필요하지 않습니다. map / foreach / getOrElse 또는 유사한 결합기를 사용하여 값을 안전하게 사용하십시오 &lt;a href=&quot;http://blog.tackley.net/2010/09/option-in-scala-vs-null-in-java.html&quot;&gt;(example)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46cc192e40835e83a2ea87cb1bc5d7df3ef20578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt; is a &lt;em&gt;Runtime exception&lt;/em&gt; that means it's developers fault and with enough experience it tells you exactly where is the error.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; 은 &lt;em&gt;런타임 예외&lt;/em&gt; 이며 개발자의 결함이며 충분한 경험이 있으면 오류의 정확한 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="31c3bcb907f016d87b77fd8396afc5c0a9d646b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; is a way of replacing a nullable T reference with a
  non-null value. An Optional may either contain a non-null T reference
  (in which case we say the reference is &quot;present&quot;), or it may contain
  nothing (in which case we say the reference is &quot;absent&quot;). It is never
  said to &quot;contain null.&quot;</source>
          <target state="translated">&lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; 는 널 입력 가능 T 참조를 널이 아닌 값으로 바꾸는 방법입니다. 선택 사항은 널이 아닌 T 참조 (이 경우 참조가 &quot;현재&quot;라고 함)를 포함하거나 아무것도 포함하지 않을 수 있습니다 (이 경우 참조가 &quot;없음&quot;이라고 함). &quot;널을 포함한다&quot;고 말한 적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="795a75979fcb8e946ecd45684159328ee5bf5b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&lt;/code&gt; offers other convenient methods, such as &lt;code&gt;orElse&lt;/code&gt; that allow the use of a default value, and &lt;code&gt;ifPresent&lt;/code&gt; that works with &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Optional&lt;/code&gt; 은 기본값을 사용할 수있는 &lt;code&gt;ifPresent&lt;/code&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;람다 표현식&lt;/a&gt; 과 함께 작동하는 &lt;code&gt;orElse&lt;/code&gt; 와 같은 다른 편리한 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="556c1089ee2ae80da8a26a4b08cfdc720295a1b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you have to deal with an API which might return nulls&lt;/em&gt;, you can't do much in Java. Xtend and Groovy have the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; and the &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;null-safe dereference operator&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt;, but note that this returns null in case of a null reference, so it just &quot;defers&quot; the proper handling of null.</source>
          <target state="translated">&lt;em&gt;null을 반환&lt;/em&gt; 할 수 &lt;em&gt;있는 API를 처리해야하는 경우&lt;/em&gt; Java에서 많은 작업을 수행 할 수 없습니다. Xtend와 Groovy에는 &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#operators&quot;&gt;Elvis 연산자&lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 와 &lt;a href=&quot;https://www.eclipse.org/xtend/documentation.html#nullSafeFeatureCalls&quot;&gt;null 안전 역 참조 연산자&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; 하지만 null 참조의 경우 null을 반환하므로 null의 적절한 처리를 &quot;지정&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="d1609ca504bef341cd938af5cc5c00b4d319ceb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you want to define a new API where undefined values make sense&lt;/em&gt;, use the &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;Option Pattern&lt;/a&gt; (may be familiar from functional languages). It has the following advantages:</source>
          <target state="translated">&lt;em&gt;정의되지 않은 값이 적합한 새 API를 정의&lt;/em&gt; 하려면 &lt;a href=&quot;http://www.codecommit.com/blog/scala/the-option-pattern&quot;&gt;옵션 패턴을&lt;/a&gt; 사용하십시오 (기능적 언어에 익숙 할 수 있음). 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6ce6480f1f89172e257cc33912ba94b061ffa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; An &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;official proposal&lt;/a&gt; for a null-safe operator in Java 7 has been submitted under &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin.&lt;/a&gt; The syntax is a little different than the example above, but it's the same notion.</source>
          <target state="translated">&lt;em&gt;업데이트 :&lt;/em&gt; Java 7의 null 안전 연산자에 대한 &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/coin-dev/2009-March/000047.html&quot;&gt;공식 제안&lt;/a&gt; 이 &lt;a href=&quot;http://openjdk.java.net/projects/coin/&quot;&gt;Project Coin&lt;/a&gt; 에 제출되었습니다 . 구문은 위의 예와 약간 다르지만 같은 개념입니다.</target>
        </trans-unit>
        <trans-unit id="d03cf75fd803a5cd91e6e06263f455b21a109fa6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update:&lt;/em&gt; The null-safe operator proposal didn't make it into Project Coin. So, you won't be seeing this syntax in Java 7.</source>
          <target state="translated">&lt;em&gt;업데이트 :&lt;/em&gt; null 안전 연산자 제안서가 Project Coin으로 제안되지 않았습니다. 따라서 Java 7에서는이 구문이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e57dd158da7749eeb4adc7330e0e7f8c7be6aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;접근법 1 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a45037cfed52a95964a4b6663009985c519b3729" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;접근법 2 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b038e1f7a0e785f507e502bb3ed742df87515a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;접근법 3 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80381f286585ad9109cf5867a45ab2d5ebfacaca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Approach 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;접근법 4 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22fb44a7606c8a8e6c1eaf89ff705a2805a4a66f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check for 'No data' only if business logic implies it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비즈니스 로직이 의미하는 경우에만 '데이터 없음'을 확인하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30f5b35acd55daabe9c5d79fbb13c7d538970512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For an 'unknown question' give 'unknown answer'.&lt;/strong&gt; (Be null-safe where this is correct from business point of view) Checking arguments for null once inside a method before usage relieves multiple callers from checking them before a call.</source>
          <target state="translated">&lt;strong&gt;'알 수없는 질문'은 '알 수없는 답변'을 제시하십시오.&lt;/strong&gt; (비즈니스 관점에서 올바른 경우 null 안전) 사용하기 전에 메서드 내에서 null 인수를 한 번 확인하면 여러 호출자가 호출하기 전에 인수를 확인하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="17a0daea56744b70e6139473e9163ad0064ca4c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is rather theoretical case and in most cases you should prefer java null safe API (in case it will be released in another 10 years), but &lt;code&gt;NullPointerException&lt;/code&gt; is subclass of an &lt;code&gt;Exception&lt;/code&gt;.&lt;/strong&gt; Thus it is a form of &lt;code&gt;Throwable&lt;/code&gt; that indicates conditions that a reasonable application might want to catch (&lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt;)! To use the first most advantage of exceptions and separate error-handling code from 'regular' code (&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;according to creators of Java&lt;/a&gt;) it is appropriate, as for me, to catch &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;이것은 다소 이론적 인 경우이며 대부분의 경우 java null safe API를 선호해야하지만 (10 년 후에 출시 될 경우) &lt;code&gt;NullPointerException&lt;/code&gt; 은 &lt;code&gt;Exception&lt;/code&gt; 의 하위 클래스입니다.&lt;/strong&gt; 따라서 합리적인 응용 프로그램이 잡을 수있는 조건을 나타내는 &lt;code&gt;Throwable&lt;/code&gt; 형식입니다 ( &lt;a href=&quot;http://javasourcecode.org/html/open-source/jdk/jdk-6u23/java/lang/Exception.html&quot;&gt;javadoc&lt;/a&gt; )! 예외의 첫 번째 가장 큰 장점을 사용하고 오류 처리 코드를 '일반적인'코드와 분리하려면 ( &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html&quot;&gt;Java 작성자에&lt;/a&gt; 따라) &lt;code&gt;NullPointerException&lt;/code&gt; 을 포착하는 것이 적절합니다.</target>
        </trans-unit>
        <trans-unit id="32581af00703ba13e0e48e757a8de5a8956459bb" translate="yes" xml:space="preserve">
          <source>A. It could take place if &lt;code&gt;getPhotoByName()&lt;/code&gt; would try to open a database connection, create &lt;code&gt;PreparedStatement&lt;/code&gt; and use the person name as an SQL parameter at last. The approach &lt;em&gt;for an unknown question gives an unknown answer&lt;/em&gt; (case 1) works here. Before grabbing resources the method should check parameters and return 'unknown' result if needed.</source>
          <target state="translated">A. &lt;code&gt;getPhotoByName()&lt;/code&gt; 이 데이터베이스 연결을 열려고 &lt;code&gt;PreparedStatement&lt;/code&gt; 를 생성 한 후 사람 이름을 마지막으로 SQL 매개 변수로 사용하면 발생할 수 있습니다. &lt;em&gt;알 수없는 질문에 대한&lt;/em&gt; 접근 방식 &lt;em&gt;은 알 수없는 대답&lt;/em&gt; (사례 1)을 제공합니다. 리소스를 가져 오기 전에 메서드는 매개 변수를 확인하고 필요한 경우 '알 수없는'결과를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d442bac768e012a67d8005e207d2f07c7f49c725" translate="yes" xml:space="preserve">
          <source>A. It is up to business logic. If I fail to find a photo album I'll show you no photos. What if appContext is not initialized? This method's business logic puts up with this. If the same logic should be more strict then throwing an exception it is part of the business logic and explicit check for null should be used (case 3). The &lt;strong&gt;new Java Null-safe API fits better here to specify selectively what implies and what does not imply to be initialized&lt;/strong&gt; to be fail-fast in case of programmer errors.</source>
          <target state="translated">A. 비즈니스 로직에 달려 있습니다. 사진 앨범을 찾지 못하면 사진이 표시되지 않습니다. appContext가 초기화되지 않으면 어떻게됩니까? 이 방법의 비즈니스 로직은이를 반영합니다. 동일한 로직이 더 엄격해야하는 경우 예외를 발생시키는 것은 비즈니스 로직의 일부이며 널에 대한 명시 적 점검을 사용해야합니다 (사례 3). &lt;strong&gt;새로운 Java Null 안전 API&lt;/strong&gt; 는 프로그래머 오류가 발생할 경우 오류가 발생 &lt;strong&gt;하지 않도록 초기화&lt;/strong&gt; 하고 &lt;strong&gt;암시하지 않을 것을 선택적으로 지정하는 데 더 적합&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9f2811ffff90eaa563c42e280cf9e259110f4e13" translate="yes" xml:space="preserve">
          <source>A. Software should be easy to understand and modify firstly. Only after this, one could think about performance, and only if needed! and where needed! (&lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;source&lt;/a&gt;), and many others).</source>
          <target state="translated">A. 소프트웨어는 먼저 이해하고 수정하기 쉬워야합니다. 이 후에야 성능에 대해 생각할 수 있으며 필요한 경우에만 가능합니다! 그리고 필요한 곳! ( &lt;a href=&quot;http://www.amazon.co.uk/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=dp_ob_title_bk&quot;&gt;출처&lt;/a&gt; ) 및 기타 여러 가지).</target>
        </trans-unit>
        <trans-unit id="8d12b90120d6345989195a1a87e9ec644b614091" translate="yes" xml:space="preserve">
          <source>All private methods do not check for null since they are controlled methods (just let die with nullpointer exception in case it wasn't handled above)</source>
          <target state="translated">모든 개인 메소드는 제어 된 메소드이기 때문에 null을 검사하지 않습니다 (위에서 처리되지 않은 경우 널 포인터 예외로 죽게하십시오)</target>
        </trans-unit>
        <trans-unit id="2d362b47b1b8f524063ce05592e2517660992d07" translate="yes" xml:space="preserve">
          <source>All public methods / API always check its arguments for null</source>
          <target state="translated">모든 공개 메소드 / API는 항상 null에 대한 인수를 확인합니다</target>
        </trans-unit>
        <trans-unit id="651180d90e7fac397932e649f57913d6e17cbdb5" translate="yes" xml:space="preserve">
          <source>Also I would not recommend using this pattern where the type is meant to be a primitive type representation - like mathematical entities, that are not scalars: vectors, matrices, complex numbers and POD(Plain Old Data) objects, which are meant to hold state in form of Java built-in types. In the latter case you would end up calling getter methods with arbitrary results. For example what should a NullPerson.getName() method return?</source>
          <target state="translated">또한 유형이 스칼라가 아닌 수학적 엔티티와 같은 기본 유형 표현 인 벡터, 행렬, 복소수 및 POD (Plain Old Data) 객체 인 경우이 패턴을 사용하지 않는 것이 좋습니다. Java 내장 유형의 형태로. 후자의 경우 임의의 결과로 getter 메소드를 호출하게됩니다. 예를 들어 NullPerson.getName () 메소드는 무엇을 반환해야합니까?</target>
        </trans-unit>
        <trans-unit id="f7b3d415a8b44b9ed32e579112942a8c54368712" translate="yes" xml:space="preserve">
          <source>Also keep in mind, that null object pattern will be memory hungry if used without care. For this - the instance of a NullObject should be shared between owners, and not be an unigue instance for each of these.</source>
          <target state="translated">또한 null 오브젝트 패턴은주의없이 사용하면 메모리가 부족하다는 점을 명심하십시오. 이를 위해 NullObject의 인스턴스는 소유자간에 공유되어야하며 각 인스턴스의 고유 한 인스턴스가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6cc029520b428014830a634a4f74acc230947ba" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;assert&lt;/code&gt; statement throws an &lt;code&gt;Error&lt;/code&gt; (&lt;code&gt;AssertionError&lt;/code&gt;) if the condition is not true.  By default, Java ignores assertions.  You can enable assertions by passing the option &lt;code&gt;-ea&lt;/code&gt; to the JVM.  You can enable and disable assertions for individual classes and packages.  This means that you can validate code with the assertions while developing and testing, and disable them in a production environment, although my testing has shown next to no performance impact from assertions.</source>
          <target state="translated">조건이 true가 아닌 경우 &lt;code&gt;assert&lt;/code&gt; 문은 &lt;code&gt;Error&lt;/code&gt; ( &lt;code&gt;AssertionError&lt;/code&gt; )를 발생시킵니다. 기본적으로 Java는 어설 션을 무시합니다. &lt;code&gt;-ea&lt;/code&gt; 옵션을 JVM에 전달하여 어설 션을 사용할 수 있습니다. 개별 클래스 및 패키지에 대한 어설 션을 활성화 및 비활성화 할 수 있습니다. 즉, 테스트에서 어설 션의 성능에 영향을 미치지 않는 것으로 나타 났지만 프로덕션 환경에서 어설 션으로 코드의 유효성을 검사하고 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1810451c6d1e409ac8c526fe9326856e3fc7731" translate="yes" xml:space="preserve">
          <source>An alternative solution is to never return null and instead use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object pattern&lt;/a&gt;:</source>
          <target state="translated">다른 해결책은 null을 반환하지 않고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_Object_pattern&quot;&gt;Null Object 패턴을&lt;/a&gt; 대신 사용하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="935b1f02f26191e4d51fccc6975811fe44f6303a" translate="yes" xml:space="preserve">
          <source>An optional object for a given type (&lt;code&gt;Fruit&lt;/code&gt;) is created as the return type of a method. It can be empty or contain a &lt;code&gt;Fruit&lt;/code&gt; object:</source>
          <target state="translated">지정된 유형 ( &lt;code&gt;Fruit&lt;/code&gt; )에 대한 선택적 객체가 메소드의 리턴 유형으로 작성됩니다. 비어 있거나 &lt;code&gt;Fruit&lt;/code&gt; 객체를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7890138d52aa6dda680f54b0057313bbeec8699c" translate="yes" xml:space="preserve">
          <source>And don't loathe to type &lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (generate javadoc in Eclipse) and write three additional words for you public API. This will be more than enough for all but those who don't read documentation.</source>
          <target state="translated">&lt;code&gt;&amp;lt;alt&amp;gt; + &amp;lt;shift&amp;gt; + &amp;lt;j&amp;gt;&lt;/code&gt; (Eclipse에서 javadoc 생성)를 입력하고 공개 API를 위해 세 개의 단어를 추가로 작성하지 마십시오. 이것은 문서를 읽지 않는 사람들을 위해 충분할 것입니다.</target>
        </trans-unit>
        <trans-unit id="90d233698926e1669e5eb1d2e7cde879b5ea4b2a" translate="yes" xml:space="preserve">
          <source>And finally, in the code, the first line of the public method goes like this:</source>
          <target state="translated">마지막으로 코드에서 공개 메소드의 첫 번째 행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="194d7971422626db3904b18b7a51e13251038301" translate="yes" xml:space="preserve">
          <source>And if you are using Spring, Spring also has the same functionality in its package, see library(spring-2.4.6.jar)</source>
          <target state="translated">Spring을 사용하는 경우 Spring도 패키지에 동일한 기능을 가지고 있습니다. library (spring-2.4.6.jar)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96abcbe58267cd8ab194fc60b9df329abfd8ab74" translate="yes" xml:space="preserve">
          <source>And it fits with new coming Java API (looking forward)</source>
          <target state="translated">그리고 앞으로 나올 새로운 Java API에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8a58cb59872c19e045b96568e04e4207657e1c22" translate="yes" xml:space="preserve">
          <source>And the usage is (with &lt;code&gt;import static&lt;/code&gt;):</source>
          <target state="translated">그리고 사용법은 ( &lt;code&gt;import static&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="ae0cf01358f7068b6df8fd1b93a1c98822554b48" translate="yes" xml:space="preserve">
          <source>And yes, we know that beyond this line we will no longer encounter a null value so we just safely invoke methods on those objects.</source>
          <target state="translated">그리고 네, 우리는이 줄을 넘어 서면 더 이상 널 (null) 값을 겪지 않을 것입니다. 그래서 우리는 그 객체들에 대해 메소드를 안전하게 호출 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="81e8d209a324ece42ed62905642bf649b3662f32" translate="yes" xml:space="preserve">
          <source>And you can be sure that this won't happen. :)</source>
          <target state="translated">그리고 당신은 이것이 일어나지 않을 것이라고 확신 할 수 있습니다. :)</target>
        </trans-unit>
        <trans-unit id="3294bacd3a1276b7be29212d3a5dd40d74f51115" translate="yes" xml:space="preserve">
          <source>As explained in the wiki:</source>
          <target state="translated">위키에 설명 된대로 :</target>
        </trans-unit>
        <trans-unit id="f927010b70c936bded38e97a00575ae4404173b5" translate="yes" xml:space="preserve">
          <source>As mentioned in some other answers, to avoid above problems you can follow the &lt;strong&gt;Design by contract&lt;/strong&gt; pattern. Please see &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract&lt;/a&gt;.</source>
          <target state="translated">다른 답변에서 언급했듯이 위의 문제를 피하기 위해 &lt;strong&gt;계약&lt;/strong&gt; 패턴 &lt;strong&gt;별로 디자인을&lt;/strong&gt; 따를 수 있습니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_by_contract&quot;&gt;http://en.wikipedia.org/wiki/Design_by_contract를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f1edc5d84268854adcf97f62dec08810475c6e1" translate="yes" xml:space="preserve">
          <source>As you can see, the second value in the addParam() method (string) is needed for the user message, because you cannot easily detect passed-in variable name, even with reflection (not subject of this post anyway...).</source>
          <target state="translated">보시다시피 addParam () 메소드의 두 번째 값 (문자열)은 사용자 메시지에 필요합니다. 반향이 있어도 전달 된 변수 이름을 쉽게 감지 할 수 없기 때문입니다 (어쨌든이 게시물의 주제는 아닙니다).</target>
        </trans-unit>
        <trans-unit id="221c48cdf1c0d0839054379dfe7e20af1349a56a" translate="yes" xml:space="preserve">
          <source>As you see &lt;code&gt;Optional.ofNullable()&lt;/code&gt; provides an easy way to get the reference wrapped. There are another ways to get the reference of Optional, either &lt;code&gt;Optional.empty()&lt;/code&gt; &amp;amp; &lt;code&gt;Optional.of()&lt;/code&gt;. One for returning an empty object instead of retuning null and the other to wrap a non-nullable object, respectively.</source>
          <target state="translated">보시다시피 &lt;code&gt;Optional.ofNullable()&lt;/code&gt; 은 참조를 래핑하는 쉬운 방법을 제공합니다. Optional에 대한 다른 방법은 &lt;code&gt;Optional.empty()&lt;/code&gt; &amp;amp; &lt;code&gt;Optional.of()&lt;/code&gt; 입니다. 하나는 null을 재조정하는 대신 빈 객체를 반환하고 다른 하나는 null을 허용하지 않는 객체를 각각 래핑하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7d61afa6fe305594ae8b4e6cf7ecc955c25b75c5" translate="yes" xml:space="preserve">
          <source>Asking that question points out that you may be interested in error handling strategies.  Your team's architect should decide how to work errors.  There are several ways to do this:</source>
          <target state="translated">이 질문을하면 오류 처리 전략에 관심이있을 수 있습니다. 팀의 설계자는 오류를 처리하는 방법을 결정해야합니다. 이를 수행하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b437dd2d827fe8753e6c8da99be2952fba3ea42" translate="yes" xml:space="preserve">
          <source>Avoiding != null statements</source>
          <target state="translated">! = null 문 피하기</target>
        </trans-unit>
        <trans-unit id="11cb1da4d18f15638f6174f01e98f7fee924565f" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with &quot;Tell, Don't Ask&quot; Style</source>
          <target state="translated">&quot;말하고 묻지 말 것&quot;스타일로 널 (Null) 방지</target>
        </trans-unit>
        <trans-unit id="c53936ddbedfa72c352067284a2a612bd38150c0" translate="yes" xml:space="preserve">
          <source>Avoiding Nulls with Polymorphic Dispatch</source>
          <target state="translated">다형성 파견으로 널 (Null) 방지</target>
        </trans-unit>
        <trans-unit id="f4719d3ce5a47c8365160718c824959b1f58c151" translate="yes" xml:space="preserve">
          <source>Basically, you've got &lt;code&gt;@Nullable&lt;/code&gt; and &lt;code&gt;@NotNull&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;@Nullable&lt;/code&gt; 및 &lt;code&gt;@NotNull&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c18860f21ab893032025c9ad8f874c57757e0d5" translate="yes" xml:space="preserve">
          <source>Byte!</source>
          <target state="translated">Byte!</target>
        </trans-unit>
        <trans-unit id="320bd43703cd7557626230bd2dde77c2b7640f71" translate="yes" xml:space="preserve">
          <source>Common &quot;problem&quot; in Java indeed.</source>
          <target state="translated">실제로 Java의 일반적인 &quot;문제&quot;.</target>
        </trans-unit>
        <trans-unit id="ab6b4e896ea7eaaed3d3b7bd63695ed61f2bc666" translate="yes" xml:space="preserve">
          <source>Compare:</source>
          <target state="translated">Compare:</target>
        </trans-unit>
        <trans-unit id="4890e65fe4afc7621e1eabc62ca877d901891501" translate="yes" xml:space="preserve">
          <source>Depending on what kind of objects you are checking you may be able to use some of the classes in the apache commons such as: &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt;</source>
          <target state="translated">확인하는 객체의 종류에 따라 &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;apache commons lang&lt;/a&gt; 및 &lt;a href=&quot;http://commons.apache.org/collections/&quot;&gt;apache commons collections&lt;/a&gt; 와 같은 아파치 커먼즈의 일부 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1611574f68477e79c3124a789db72e5b33b65570" translate="yes" xml:space="preserve">
          <source>Doing this</source>
          <target state="translated">이렇게</target>
        </trans-unit>
        <trans-unit id="9a7ba7e5ca69607940820be45f20c7f96e626e73" translate="yes" xml:space="preserve">
          <source>Doing this in your own code and you can avoid != null checks.</source>
          <target state="translated">자신의 코드 에서이 작업을 수행하면! = null 검사를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a489753c928c4dfb8ffde543140ef98f7d16b3e3" translate="yes" xml:space="preserve">
          <source>Example on how to throw exception on null:</source>
          <target state="translated">null에 예외를 던지는 방법에 대한 예 :</target>
        </trans-unit>
        <trans-unit id="c10cb15cb38405cd962e584139f01df735b6c7b4" translate="yes" xml:space="preserve">
          <source>Example on how to use this static classf from spring(org.springframework.util.Assert)</source>
          <target state="translated">spring (org.springframework.util.Assert)에서이 정적 클래스를 사용하는 방법에 대한 예제</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="c7feb78075d63e6bedf1365cc55e6aa7fc3a87a8" translate="yes" xml:space="preserve">
          <source>Finally, here is our NPE as well as null check-free code:</source>
          <target state="translated">마지막으로 NPE와 null check-free 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1428f3662f53c4496ea96cf16634505d0f0a9b2c" translate="yes" xml:space="preserve">
          <source>First, I follow this convention:</source>
          <target state="translated">먼저이 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3f6a27b732f1a0d9afc335cb45ef93731f4fb5bf" translate="yes" xml:space="preserve">
          <source>First, my thoughts on this:</source>
          <target state="translated">먼저, 이것에 대한 나의 생각 :</target>
        </trans-unit>
        <trans-unit id="54463d0ab47a851d650e8259c2db7a0ae594a452" translate="yes" xml:space="preserve">
          <source>For example I often use:</source>
          <target state="translated">예를 들어 자주 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4b4c9cb4038fad0763e34c64a087da1f526c6087" translate="yes" xml:space="preserve">
          <source>Guava, a very useful core library by Google, has a nice and useful API to avoid nulls. I find &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained&lt;/a&gt; very helpful.</source>
          <target state="translated">Google의 매우 유용한 핵심 라이브러리 인 Guava에는 null을 피할 수있는 훌륭하고 유용한 API가 있습니다. &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;UsingAndAvoidingNullExplained가&lt;/a&gt; 매우 유용 하다는 것을 알았 습니다.</target>
        </trans-unit>
        <trans-unit id="2a6e8249d4017ff690264fec43a31540b1ea7759" translate="yes" xml:space="preserve">
          <source>Here follows an example of how you can use null vallidation in JAVA when you include apache library(commons-lang-2.4.jar)</source>
          <target state="translated">다음은 아파치 라이브러리 (commons-lang-2.4.jar)를 포함 할 때 JAVA에서 null vallidation을 사용하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="37fc03c253b95910c6421c23c78078850ed69a95" translate="yes" xml:space="preserve">
          <source>However, if your method just passes the value on, and the next method passes it on etc. it could get problematic. In that case you may want to check the argument as above.</source>
          <target state="translated">그러나 메소드가 값을 전달하고 다음 메소드가 값을 전달하면 문제가 발생할 수 있습니다. 이 경우 위와 같이 인수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d268653fde675e2306e93684be579aa72eb2868" translate="yes" xml:space="preserve">
          <source>I consider that it is bad to &quot;eat&quot; something when NULL was passed where NULL isn't a valid value. If you're not exiting the method with some sort of error then it means nothing went wrong in your method which is not true. Then you probably return null in this case, and in the receiving method you again check for null, and it never ends, and you end up with &quot;if != null&quot;, etc..</source>
          <target state="translated">NULL이 유효하지 않은 곳에서 NULL이 전달 될 때 무언가를 &quot;먹는&quot;것은 좋지 않다고 생각합니다. 어떤 종류의 오류로 메소드를 종료하지 않으면 메소드에 아무런 문제가 없다는 것을 의미합니다. 그런 다음 아마도이 경우 null을 반환하고 수신 방법에서 다시 null을 확인하고 끝나지 않으며 &quot;if! = null&quot;등으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="ac7c74b5f9864f037fc949031de21c91fd9060c0" translate="yes" xml:space="preserve">
          <source>I highly disregard answers that suggest using the null objects in every situation. This pattern may break the contract and bury problems deeper and deeper instead of solving them, not mentioning that used inappropriately will create another pile of boilerplate code that will require future maintenance.</source>
          <target state="translated">모든 상황에서 null 객체 사용을 제안하는 답변을 무시합니다. 이 패턴은 계약을 위반하고 문제를 해결하는 대신 깊고 깊이 파 묻는 문제를 부각시킬 수 있습니다. 부적절하게 사용하면 향후 유지 보수가 필요한 보일러 플레이트 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e1533f4720d20d3996516b4af58f7d3dd16391a" translate="yes" xml:space="preserve">
          <source>I invite you to read this article (my main source for writing this answer) in which the &lt;code&gt;NullPointerException&lt;/code&gt; (and in general null pointer) problematic as well as the (partial) solution brought by &lt;code&gt;Optional&lt;/code&gt; are well explained: &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;Java Optional Objects&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; (및 일반적으로 null 포인터)뿐만 아니라 &lt;code&gt;Optional&lt;/code&gt; 이 가져온 (부분) 솔루션에 대해 잘 설명 된이 기사 (이 답변을 작성하는 주요 소스)를 읽으십시오 &lt;em&gt;&lt;a href=&quot;http://java.dzone.com/articles/java-optional-objects&quot;&gt;.Java Optional Objects&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e91faab1ad00e77854ebd2d809262438fc2063" translate="yes" xml:space="preserve">
          <source>I like articles from Nat Pryce. Here are the links:</source>
          <target state="translated">나는 Nat Pryce의 기사를 좋아한다. 링크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4217f45a2775c21698ce1470fdcef44f36c7cb8" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;object != null&lt;/code&gt; a lot to avoid &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 을 피하기 위해 &lt;code&gt;object != null&lt;/code&gt; 을 많이 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="43aae1b74babe4a5f7cffce5f010ac04c50784b7" translate="yes" xml:space="preserve">
          <source>I'm a fan of &quot;fail fast&quot; code. Ask yourself - are you doing something useful in the case where the parameter is null? If you don't have a clear answer for what your code should do in that case... I.e. it should never be null in the first place, then ignore it and allow a NullPointerException to be thrown. The calling code will make just as much sense of an NPE as it would an IllegalArgumentException, but it'll be easier for the developer to debug and understand what went wrong if an NPE is thrown rather than your code attempting to execute some other unexpected contingency logic - which ultimately results in the application failing anyway.</source>
          <target state="translated">나는 &quot;실패&quot;코드의 팬입니다. 스스로에게 물어보십시오-매개 변수가 null 인 경우 유용한 것을하고 있습니까? 이 경우 코드가 무엇을 해야하는지에 대한 명확한 대답이 없다면 ... 즉, 처음에는 null이 아니어야하며 무시하고 NullPointerException이 발생하도록하십시오. 호출 코드는 IllegalArgumentException과 마찬가지로 NPE를 이해하는 데 도움이되지만 개발자가 코드에서 예기치 않은 다른 우발 상황을 실행하려고 시도하는 것보다 NPE가 발생하면 무엇이 잘못되었는지 디버그하고 이해하는 것이 더 쉽습니다. 논리-결국 응용 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="9d28525daf513a3218069e5463bb837227dd3063" translate="yes" xml:space="preserve">
          <source>I've tried the &lt;code&gt;NullObjectPattern&lt;/code&gt; but for me is not always the best way to go. There are sometimes when a &quot;no action&quot; is not appropiate.</source>
          <target state="translated">&lt;code&gt;NullObjectPattern&lt;/code&gt; 을 시도했지만 항상 최선의 방법은 아닙니다. &quot;조치 없음&quot;이 적절하지 않은 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="55bdc40b2d33d1479a2eed8448e223fe33d03160" translate="yes" xml:space="preserve">
          <source>If (1) is not possible, initialise all collections and arrays to empty collections/arrays.</source>
          <target state="translated">(1)을 사용할 수 없으면 모든 컬렉션과 배열을 빈 컬렉션 / 배열로 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="0e0f1c759db9fd58b965ca2548b987ed339d8a59" translate="yes" xml:space="preserve">
          <source>If appContext or dataSource is not initialized unhandled runtime NullPointerException will kill current thread and will be processed by &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler&lt;/a&gt; (for you to define and use your favorite logger or other notification mechanizm). If not set, &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup#uncaughtException&lt;/a&gt; will print stacktrace to system err. One should monitor application error log and open Jira issue for each unhandled exception which in fact is application error. Programmer should fix bug somewhere in initialization stuff.</source>
          <target state="translated">appContext 또는 dataSource가 처리되지 않은 런타임으로 초기화되지 않은 경우 NullPointerException은 현재 스레드를 종료하고 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html&quot;&gt;Thread.defaultUncaughtExceptionHandler에&lt;/a&gt; 의해 처리됩니다 (원하는 로거 또는 기타 알림 메커니즘 을 정의하고 사용하기 위해). 설정하지 않으면 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread,%20java.lang.Throwable)&quot;&gt;ThreadGroup # uncaughtException&lt;/a&gt; 은 스택 추적을 시스템 err에 인쇄합니다. 처리되지 않은 각 예외 (사실 응용 프로그램 오류)에 대해 응용 프로그램 오류 로그를 모니터링하고 Jira 문제를 열어야합니다. 프로그래머는 초기화 작업에서 버그를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="09e73ecfe67989af7dd8eaebfa15624f78eacae4" translate="yes" xml:space="preserve">
          <source>If it is an internal method (not part of an API), just document that it cannot be null, and that's it.</source>
          <target state="translated">내부 메소드 (API의 일부가 아닌) 인 경우 null이 될 수 없다는 것을 문서화하십시오.</target>
        </trans-unit>
        <trans-unit id="0728dc4e2e97cf099cf3ab0e28a357ee05e7b6ca" translate="yes" xml:space="preserve">
          <source>If it's code that you do control, however (and this is often the case), then it's a different story.  Avoid using nulls as a response.  With methods that return collections, it's easy: return empty collections (or arrays) instead of nulls pretty much all the time.</source>
          <target state="translated">그러나 제어하는 ​​코드 (이 경우는 종종 있음) 인 경우 다른 이야기입니다. 응답으로 널을 사용하지 마십시오. 컬렉션을 반환하는 메서드를 사용하면 쉽습니다. 거의 항상 null 대신 빈 컬렉션 (또는 배열)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f619483031223d172a56c6c25092a69d35edf9be" translate="yes" xml:space="preserve">
          <source>If null is allowed</source>
          <target state="translated">널이 허용되는 경우</target>
        </trans-unit>
        <trans-unit id="d5dc5db9bb49b83ae4fcd69d7d06a8b86bbf1b0a" translate="yes" xml:space="preserve">
          <source>If null-values are not allowed</source>
          <target state="translated">널값이 허용되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="9ff0191b7a1ec369d5c5805839743dd0c72f1b9e" translate="yes" xml:space="preserve">
          <source>If undefined values are not permitted:</source>
          <target state="translated">정의되지 않은 값이 허용되지 않는 경우 :</target>
        </trans-unit>
        <trans-unit id="549ca9f1c825f259e5ce60b96c2984b9b0f5f764" translate="yes" xml:space="preserve">
          <source>If undefined values are permitted:</source>
          <target state="translated">정의되지 않은 값이 허용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="68f38a6783f67b9f294c501c4581c1585e95009c" translate="yes" xml:space="preserve">
          <source>If you ask me what is the name of my girlfriend I'll tell you that I have no girlfriend. In the Java language I'll return null. 
An alternative would be to throw meaningful exception to indicate some problem that can't be (or don't want to be) solved right there and delegate it somewhere higher in the stack to retry or report data access error to the user.</source>
          <target state="translated">내 여자 친구의 이름이 무엇인지 물어 보면 여자 친구가 없다고 말할 수 있습니다. Java 언어에서는 null을 반환합니다. 대안은 의미있는 예외를 던져서 바로 해결할 수없는 (또는 원하지 않는) 일부 문제를 표시하고 스택의 상위 위치에 위임하여 사용자에게 데이터 액세스 오류를 다시 시도하거나보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="632f1186cdb5143b60b5f2614ffe2a8a35f452f1" translate="yes" xml:space="preserve">
          <source>If you consider an object should not be null (or it is a bug) use an assert.</source>
          <target state="translated">객체가 null이 아니거나 버그 인 경우에는 assert를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf153150df9563cc962ca474b13e56e5c751cce" translate="yes" xml:space="preserve">
          <source>If you know b can never be null, you can just swap it. It is most useful for equals:
Instead of &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; better do &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt;.</source>
          <target state="translated">b가 null이 될 수 없다는 것을 알고 있다면 그냥 바꿀 수 있습니다. equals에 가장 유용합니다. 대신 &lt;code&gt;foo.equals(&quot;bar&quot;);&lt;/code&gt; &lt;code&gt;&quot;bar&quot;.equals(foo);&lt;/code&gt; 것이 좋습니다 .equals (foo); .</target>
        </trans-unit>
        <trans-unit id="46640e8236124be6c3cf80df96f4c3a462598491" translate="yes" xml:space="preserve">
          <source>If you use (or planning to use) a Java IDE like &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; or &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; or a tool like findbugs then you can use annotations to solve this problem.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;JetBrains IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;https://www.eclipse.org/&quot;&gt;Eclipse&lt;/a&gt; 또는 &lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; 와 같은 Java IDE 또는 findbugs와 같은 도구를 사용하거나 사용하려는 경우 주석을 사용하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9bd5740fe135b5553acbf51ff5056141fbbb4dc" translate="yes" xml:space="preserve">
          <source>If your method doesn't accept null params say it in the javadoc and use an assert.</source>
          <target state="translated">메소드가 널 매개 변수를 허용하지 않으면 javadoc에서 말하고 어설 션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ce6b2cf4a5e96febfe5ce76451daef36e092d32b" translate="yes" xml:space="preserve">
          <source>If your method is called externally, start with something like this:</source>
          <target state="translated">메소드가 외부에서 호출되면 다음과 같이 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="ab846b65d9a8fcd8a4b81c40b61e74e028b79991" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt;, a Java-derived language, there are two versions of all types: a potentially-null version and a not-null version. You can only invoke methods on not-null types. Potentially-null types can be converted to not-null types through explicit checking for null. This makes it much easier to know where null checks are necessary and where they aren't.</source>
          <target state="translated">Java 파생 언어 인 &lt;a href=&quot;http://nice.sourceforge.net/safety.html#id2487946&quot;&gt;Nice&lt;/a&gt; 에는 모든 유형의 널 버전과 널이 아닌 버전의 두 가지 버전이 있습니다. 널이 아닌 유형에서만 메소드를 호출 할 수 있습니다. 널 (null)을 명시 적으로 검사하여 널 (null) 유형을 널이 아닌 유형으로 변환 할 수 있습니다. 따라서 null 검사가 필요한 위치와 필요하지 않은 위치를 훨씬 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8317f0d2b647c2aff1a42d76d73339593f638877" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA 10.5 and on, they added support for any other &lt;code&gt;@Nullable&lt;/code&gt;&lt;code&gt;@NotNull&lt;/code&gt; implementations.</source>
          <target state="translated">IntelliJ IDEA 10.5 이상에서는 다른 &lt;code&gt;@Nullable&lt;/code&gt; &lt;code&gt;@NotNull&lt;/code&gt; 구현에 대한 지원을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="920588de011f2e8dddc89ccb39b92ea0631e797c" translate="yes" xml:space="preserve">
          <source>In Objective-C, you can do the equivalent of invoking a method on &lt;code&gt;nil&lt;/code&gt;, and absolutely nothing will happen. This makes most null checks unnecessary, but it can make errors much harder to diagnose.</source>
          <target state="translated">Objective-C에서는 &lt;code&gt;nil&lt;/code&gt; 에서 메소드를 호출하는 것과 동등한 작업을 수행 할 수 있으며 아무 일도 일어나지 않습니다. 따라서 대부분의 null 검사가 불필요하지만 오류를 진단하기가 훨씬 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04837dad91721b9799f52240befed0a8ce992bd5" translate="yes" xml:space="preserve">
          <source>In a nutshell, the Optional class includes methods to explicitly deal with the cases where a value is present or absent. However, the advantage compared to null references is that the Optional&amp;lt;T&amp;gt; class forces you to think about the case when the value is not present. As a consequence, you can prevent unintended null pointer exceptions.</source>
          <target state="translated">요컨대, Optional 클래스에는 값이 있거나없는 경우를 명시 적으로 처리하는 메서드가 포함되어 있습니다. 그러나 null 참조와 비교할 때 Optional &amp;lt;T&amp;gt; 클래스를 사용하면 값이없는 경우에 대해 생각해야합니다. 결과적으로 의도하지 않은 널 포인터 예외를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f3e79c602141290377505754be2b4a12d560ec" translate="yes" xml:space="preserve">
          <source>In above example we have a home service factory that returns a handle to multiple appliances available in the home. But these services may or may not be available/functional; it means it may result in a NullPointerException. Instead of adding a null &lt;code&gt;if&lt;/code&gt; condition before using any service, let's wrap it in to Optional&amp;lt;Service&amp;gt;.</source>
          <target state="translated">위의 예에서는 가정에서 사용 가능한 여러 기기에 대한 핸들을 반환하는 가정 서비스 팩토리가 있습니다. 그러나 이러한 서비스는 사용 가능하거나 작동하지 않을 수 있습니다. NullPointerException이 발생할 수 있음을 의미합니다. 서비스를 사용하기 전에 null &lt;code&gt;if&lt;/code&gt; 조건을 추가하는 대신 Optional &amp;lt;Service&amp;gt;로 감싸도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="fc6e5953a54a7e173cf74b9a49d8e3e1c3ed3c55" translate="yes" xml:space="preserve">
          <source>In addition to using &lt;code&gt;assert&lt;/code&gt; you can use the following:</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 를 사용 하는 것 외에도 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e936cf946cec0419aa0692bf595f85b67c954b" translate="yes" xml:space="preserve">
          <source>In an API built from scratch using &lt;code&gt;Optional&lt;/code&gt; whenever a return value might be empty, and returning a plain object only when it cannot be &lt;code&gt;null&lt;/code&gt; (convention), the client code might abandon null checks on simple object return values...</source>
          <target state="translated">반환 값이 비어있을 때마다 &lt;code&gt;Optional&lt;/code&gt; 사용하여 처음부터 빌드 한 API에서 &lt;code&gt;null&lt;/code&gt; 이 될 수없는 경우에만 일반 객체를 반환 (컨벤션) 클라이언트 코드는 간단한 객체 반환 값에 대한 null 검사를 포기할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="992aee948602e38e384351d28a7dc64174420247" translate="yes" xml:space="preserve">
          <source>In my classes, most fields and local variables have non-null default values, and I add contract statements (always-on asserts) everywhere in the code to make sure this is being enforced (since it's more succinct, and more expressive than letting it come up as an NPE and then having to resolve the line number, etc.).</source>
          <target state="translated">내 클래스에서 대부분의 필드와 로컬 변수에는 null이 아닌 기본값이 있으며 코드의 모든 곳에 계약서 (항상 주장하는)를 추가하여 코드가 적용되도록합니다 (간결하고 표현하기 쉽기 때문에) NPE로 올라 와서 줄 번호 등을 해결해야합니다.)</target>
        </trans-unit>
        <trans-unit id="a0427014adae81ed68e6059ae2ac27ebf2554012" translate="yes" xml:space="preserve">
          <source>In reality if something returned from a method can be null and the calling code has to make decision upon that, there should an earlier call that ensures the state.</source>
          <target state="translated">실제로 메소드에서 리턴 된 것이 널이 될 수 있고 호출 코드가이를 결정해야하는 경우, 상태를 보장하는 이전 호출이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d28d029f197073e44a5cf2c959d2881818c5cbc8" translate="yes" xml:space="preserve">
          <source>In the articles there is also a link to a Git repository for a Java Maybe Type which I find interesting, but I don't think it alone could decrease the
checking code bloat. After doing some research on the Internet, I think &lt;strong&gt;!= null&lt;/strong&gt; code bloat could be decreased mainly by careful design.</source>
          <target state="translated">이 기사에는 Java Maybe Type에 대한 Git 저장소에 대한 링크가 있습니다.하지만 흥미로운 것으로 확인하지만 검사 코드 팽창을 줄일 수 있다고 생각하지 않습니다. 인터넷에서 약간의 연구를 한 후에는 신중한 디자인으로 &lt;strong&gt;! = null&lt;/strong&gt; code bloat를 줄일 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="02e44622ee08c669f730bdcb2ba763d4bddbd763" translate="yes" xml:space="preserve">
          <source>Is there a good alternative to this?</source>
          <target state="translated">이것에 대한 좋은 대안이 있습니까?</target>
        </trans-unit>
        <trans-unit id="24df4f8ef6f8fd18a5d3ec048c3faffe1f0edf74" translate="yes" xml:space="preserve">
          <source>It is stated explicitly in the API whether an input or output exists or not.</source>
          <target state="translated">입력 또는 출력이 존재하는지 여부는 API에 명시 적으로 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd16395a598dc3b1c54e1c2de34abba05b16ef6" translate="yes" xml:space="preserve">
          <source>It may be easier to give you examples, if you show examples of where you typically use the idiom.</source>
          <target state="translated">일반적으로 관용구를 사용하는 위치의 예를 보여 주면 예를 제공하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c32880c4b10a50c8fb02fa59f5e5618dea4d1963" translate="yes" xml:space="preserve">
          <source>It's a nice way to let the compiler check something more than it usually does and to enforce your contracts to be stronger. Unfortunately, it's not supported by all the compilers.</source>
          <target state="translated">컴파일러가 평소보다 더 많은 것을 확인하고 계약을 강화하도록하는 좋은 방법입니다. 불행히도 모든 컴파일러가 지원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f405e902c0a66a3e8ffdf23a351c22c3a375631a" translate="yes" xml:space="preserve">
          <source>It's actually rare for me to use the idiom &quot;&lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt;&quot;.</source>
          <target state="translated">실제로 &quot; &lt;code&gt;if (object != null &amp;amp;&amp;amp; ...&lt;/code&gt; &quot;관용구를 사용하는 경우 는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="714b225b9ed3d9fb4f8f780dad6fe5864bd2db61" translate="yes" xml:space="preserve">
          <source>It's worth considering such cases in order to avoid absurd results.</source>
          <target state="translated">터무니없는 결과를 피하기 위해 그러한 경우를 고려해 볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2368895a515e87735e0f53eb54312d0b78e798a" translate="yes" xml:space="preserve">
          <source>Java 7 has a new &lt;code&gt;java.util.Objects&lt;/code&gt; utility class on which there is a &lt;code&gt;requireNonNull()&lt;/code&gt; method. All this does is throw a &lt;code&gt;NullPointerException&lt;/code&gt; if its argument is null, but it cleans up the code a bit. Example:</source>
          <target state="translated">Java 7에는 &lt;code&gt;requireNonNull()&lt;/code&gt; 메소드가있는 새로운 &lt;code&gt;java.util.Objects&lt;/code&gt; 유틸리티 클래스가 있습니다. 인수가 null 인 경우 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생하지만 코드를 약간 정리합니다. 예:</target>
        </trans-unit>
        <trans-unit id="edc6b48d824432a77a20f24921f65458059db63b" translate="yes" xml:space="preserve">
          <source>Java 7 introduced the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt;&lt;code&gt;Objects.requireNonNull&lt;/code&gt;&lt;/a&gt; method which can be handy when something should be checked for non-nullness. Example:</source>
          <target state="translated">Java 7에는 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T,%20java.lang.String)&quot;&gt; &lt;code&gt;Objects.requireNonNull&lt;/code&gt; &lt;/a&gt; 메소드가 도입되어 null이 아닌 항목을 검사해야 할 때 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="14057bbaba6e7ba4939e98331bee0a9d4cc6fd00" translate="yes" xml:space="preserve">
          <source>Java 8 has a built-in &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class (recommended); for earlier versions, there are library alternatives, for example &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt;'s &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt;'s &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;. But like many functional-style patterns, using Option in Java (even 8) results in quite some boilerplate, which you can reduce using a less verbose JVM language, e.g. Scala or Xtend.</source>
          <target state="translated">Java 8에는 기본 제공되는 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; 클래스 (권장)가 있습니다. 이전 버전의 경우 라이브러리 대안 (예 : &lt;a href=&quot;http://code.google.com/p/guava-libraries/wiki/UsingAndAvoidingNullExplained&quot;&gt;Guava&lt;/a&gt; 의 &lt;a href=&quot;https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://code.google.com/p/functionaljava&quot;&gt;FunctionalJava&lt;/a&gt; 's &lt;a href=&quot;http://www.functionaljava.org/javadoc/4.4/functionaljava/fj/data/Option.html&quot;&gt; &lt;code&gt;Option&lt;/code&gt; )이&lt;/a&gt; 있습니다. 그러나 많은 기능적 스타일 패턴과 마찬가지로 Java에서 옵션 (8 개)을 사용하면 상당히 약간의 상용구가 생겨 Scala 또는 Xtend와 같이 덜 장황한 JVM 언어를 사용하여 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23ec0515f353dee199aaa003dccab705cbddfd12" translate="yes" xml:space="preserve">
          <source>Java 8 has introduced &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;. It is a container that may or may not hold a non-null value. Java 8 has given a safer way to handle an object whose value may be null in some of the cases. It is inspired from the ideas of &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt;.</source>
          <target state="translated">Java 8은 &lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt; 도입했습니다. 널이 아닌 값을 보유하거나 보유하지 않을 수있는 컨테이너입니다. Java 8에서는 일부 경우에 값이 null 일 수있는 객체를보다 안전하게 처리 할 수 ​​있습니다. 그것은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; 과 &lt;a href=&quot;http://en.wikipedia.org/wiki/Scala_%28programming_language%29&quot;&gt;Scala&lt;/a&gt; 의 아이디어에서 영감을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="b697deb5aa0b223e01560060b3cb1b1f61855b42" translate="yes" xml:space="preserve">
          <source>Just a sample:</source>
          <target state="translated">단지 샘플 :</target>
        </trans-unit>
        <trans-unit id="e35fd4948c5a9357196b184cecdd55c2cc10c2d5" translate="yes" xml:space="preserve">
          <source>Just don't ever use null. Don't allow it.</source>
          <target state="translated">null을 사용하지 마십시오. 허용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e6f599b2f399715ad627af5bb0a6d5baae609bba" translate="yes" xml:space="preserve">
          <source>Last example using &lt;code&gt;@Nullable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@Nullable&lt;/code&gt; 을 사용한 마지막 예</target>
        </trans-unit>
        <trans-unit id="59402a00be4a0f11592ceaf67244cfe61d5bda51" translate="yes" xml:space="preserve">
          <source>Let's consider a method to get a reference of a service from a factory. Instead of returning the service reference, wrap it with Optional. It lets the API user know that the returned service may or may not available/functional, use defensively</source>
          <target state="translated">공장에서 서비스에 대한 참조를 얻는 방법을 고려해 봅시다. 서비스 참조를 리턴하는 대신 선택 사항으로 랩하십시오. 반환 된 서비스가 사용 가능하거나 작동하지 않을 수 있음을 API 사용자에게 알려 방어 적으로 사용</target>
        </trans-unit>
        <trans-unit id="aabc2d3db3cef830d4da0377e4b7c5b1b3f518c5" translate="yes" xml:space="preserve">
          <source>May I answer it more generally!</source>
          <target state="translated">더 일반적으로 대답하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f433759684160d6db17bda40a8e075111a85c751" translate="yes" xml:space="preserve">
          <source>Method &lt;code&gt;validate()&lt;/code&gt; will throw checked &lt;code&gt;ValidationException&lt;/code&gt; if any of the parameters is null (checked or unchecked is more a design/taste issue, but my &lt;code&gt;ValidationException&lt;/code&gt; is checked).</source>
          <target state="translated">매개 변수 중 하나가 null 인 경우 &lt;code&gt;validate()&lt;/code&gt; 메서드는 확인 된 &lt;code&gt;ValidationException&lt;/code&gt; 을 throw합니다 (체크 또는 체크되지 않은 디자인 / 맛 문제이지만 내 &lt;code&gt;ValidationException&lt;/code&gt; 이 검사 됨).</target>
        </trans-unit>
        <trans-unit id="3f01e85661d751c9b649b3a4ad66bff717bcfdf9" translate="yes" xml:space="preserve">
          <source>Most of the time null checks seem to guard loops over collections or arrays, so just initialise them empty, you won't need any null checks.</source>
          <target state="translated">대부분의 경우 null 검사는 컬렉션이나 배열에 대한 루프를 보호하는 것처럼 보이므로 빈 초기화하면 null 검사가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10245c94028cb40db8342e6e78c68de0822b9be5" translate="yes" xml:space="preserve">
          <source>Never initialise variables to null.</source>
          <target state="translated">변수를 null로 초기화하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="92dc04e377ae99c8a6ebf3a5d7e85d43ee0f3ab3" translate="yes" xml:space="preserve">
          <source>Not checking if a variable is null before invoking an equals method (a string compare example below):</source>
          <target state="translated">equals 메소드를 호출하기 전에 변수가 널인지 확인하지 않음 (아래 문자열 비교 예) :</target>
        </trans-unit>
        <trans-unit id="99556f0afc8bbece6b8c0e90382fe62b10f3db0b" translate="yes" xml:space="preserve">
          <source>Not using assertions in this case is OK because the code will just fail, which is what will happen if you use assertions.  The only difference is that with assertions it might happen sooner, in a more-meaningful way and possibly with extra information, which may help you to figure out why it happened if you weren't expecting it.</source>
          <target state="translated">이 경우 어설 션을 사용하지 않으면 코드가 실패하기 때문에 어설 션을 사용하면 발생합니다. 단 한가지 차이점은 단언이 더 의미있는 방식으로 그리고 추가 정보와 함께 더 빨리 발생할 수 있다는 것입니다. 예상하지 못한 경우 왜 그런 일이 발생했는지 파악하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="176fa701c30ed80ae841f14d912217b3648526ea" translate="yes" xml:space="preserve">
          <source>Note that addParam() returns self, so that you can add more parameters to check.</source>
          <target state="translated">addParam ()은 self를 반환하므로 확인할 매개 변수를 더 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c7893143e601f4d7141dc682079d103f68d972b" translate="yes" xml:space="preserve">
          <source>Note that the accepted answer may be out of date, see &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; for a more recent approach.</source>
          <target state="translated">허용되는 답변이 최신 정보가 아닐 수 있습니다. 최신 접근 방식은 &lt;a href=&quot;https://stackoverflow.com/a/2386013/12943&quot;&gt;https://stackoverflow.com/a/2386013/12943&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="08c509b05cd5ed1b8001a328275f057bb13241df" translate="yes" xml:space="preserve">
          <source>Now HomeServices.get() does same thing, but in a better way. It checks whether the service is already initialized of not. If it is then return the same or create a new New service. Optional&amp;lt;T&amp;gt;.orElse(T) helps to return a default value.</source>
          <target state="translated">이제 HomeServices.get ()은 같은 일을하지만 더 나은 방법으로 수행합니다. 서비스가 이미 초기화되지 않았는지 확인합니다. 그렇다면 같은 것을 반환하거나 새로운 새 서비스를 만듭니다. 선택적인 &amp;lt;T&amp;gt; .ElEl (T)는 기본값을 반환하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="243fc41a64042cfc5860b15fdd1a86b35656505b" translate="yes" xml:space="preserve">
          <source>Now look at this code where we search a list of &lt;code&gt;Fruit&lt;/code&gt; (&lt;code&gt;fruits&lt;/code&gt;) for a given Fruit instance:</source>
          <target state="translated">이제 주어진 Fruit 인스턴스에 대해 &lt;code&gt;Fruit&lt;/code&gt; ( &lt;code&gt;fruits&lt;/code&gt; ) 목록을 검색하는이 코드를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="26b0fcf72724ae5ef092ca7b297d0d826206b5cb" translate="yes" xml:space="preserve">
          <source>Now the IntelliJ IDEA compiler will tell you that the check is useless, since the &lt;code&gt;helloWorld()&lt;/code&gt; function won't return &lt;code&gt;null&lt;/code&gt;, ever.</source>
          <target state="translated">&lt;code&gt;helloWorld()&lt;/code&gt; 함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하지 않기 때문에 IntelliJ IDEA 컴파일러는 검사가 쓸모가 없다고 알려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="cdc1b22c0d793a34bbcf4429fa3f1f90d9486b91" translate="yes" xml:space="preserve">
          <source>Now to the answer:</source>
          <target state="translated">이제 대답에 :</target>
        </trans-unit>
        <trans-unit id="2ea239f7f659ef1548e4d08d1e55d7c383740b1c" translate="yes" xml:space="preserve">
          <source>Now you can safely develop the core function of your method without needing to check input parameters, they guard your methods from unexpected parameters.</source>
          <target state="translated">이제 입력 매개 변수를 확인하지 않고도 분석법의 핵심 기능을 안전하게 개발할 수 있으며 예기치 않은 매개 변수로부터 분석법을 보호합니다.</target>
        </trans-unit>
        <trans-unit id="edf43179ef58a381a95f2c17225fe5bf82d216c3" translate="yes" xml:space="preserve">
          <source>Null is not a 'problem'. It is an integral part of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;complete&lt;/a&gt; modeling tool set. Software aims to model the complexity of the world and null bears its burden. &lt;strong&gt;Null indicates 'No data' or 'Unknown'&lt;/strong&gt; in Java and the like. So it is appropriate to use nulls for these purposes. I don't prefer the 'Null object' pattern; I think it rise the '&lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;who will guard
the guardians&lt;/a&gt;' problem.</source>
          <target state="translated">널은 '문제'가 아닙니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_completeness&quot;&gt;완전한&lt;/a&gt; 모델링 도구 세트의 필수 부분입니다. 소프트웨어는 세계의 복잡성을 모델링하는 것을 목표로하며, 그 부담은 없습니다. &lt;strong&gt;Null은&lt;/strong&gt; Java 등에서 &lt;strong&gt;'데이터 없음'또는 '알 수 없음'&lt;/strong&gt; 을 &lt;strong&gt;나타냅니다&lt;/strong&gt; . 따라서 이러한 목적으로 null을 사용하는 것이 좋습니다. 나는 'Null object'패턴을 선호하지 않습니다. 나는 ' &lt;a href=&quot;http://en.wikipedia.org/wiki/Who_will_guard_the_guards%3F&quot;&gt;후견인을 지키는 사람&lt;/a&gt; '문제를 일으킨다.</target>
        </trans-unit>
        <trans-unit id="29fec67aa38549dd5045b52d3829e32fb6b213cd" translate="yes" xml:space="preserve">
          <source>Of course &lt;code&gt;Optional&lt;/code&gt; could also be used as a method argument, perhaps a better way to indicate optional arguments than 5 or 10 overloading methods in some cases.</source>
          <target state="translated">물론 &lt;code&gt;Optional&lt;/code&gt; 을 메소드 인수로 사용할 수도 있습니다. 경우에 따라 5 또는 10 개의 오버로드 메소드보다 선택적 인수를 나타내는 더 좋은 방법 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4caa61cd647ca110cd57241ba6a32544f2821d80" translate="yes" xml:space="preserve">
          <source>Of course, experience is the better way to understand and apply this suggestion.</source>
          <target state="translated">물론 경험이이 제안을 이해하고 적용하는 더 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1025ea9180532a8fb4fe82dbd19b0c29868734a2" translate="yes" xml:space="preserve">
          <source>Of course, the check for null/empty value is still necessary, but at least the developer is conscious that the value might be empty and the risk of forgetting to check is limited.</source>
          <target state="translated">물론, null / empty 값에 대한 점검은 여전히 ​​필요하지만 최소한 개발자는 값이 비어있을 수 있음을 인식하고 점검 잊어 버릴 위험이 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="f9b45a3dc805fa3553c19beda43294e7e53857b2" translate="yes" xml:space="preserve">
          <source>Once I adopted this practice, I noticed that the problems seemed to fix themselves. You'd catch things much earlier in the development process just by accident and realize you had a weak spot..  and more importantly.. it helps encapsulate different modules' concerns, different modules can 'trust' each other, and no more littering the code with &lt;code&gt;if = null else&lt;/code&gt; constructs!</source>
          <target state="translated">이 연습을 채택한 후에는 문제가 스스로 해결되는 것처럼 보였습니다. 우연히 개발 과정에서 훨씬 일찍 일을 포착하고 약점을 발견했습니다. 더 중요한 것은 서로 다른 모듈의 문제를 캡슐화하는 데 도움이되며 다른 모듈은 서로 '신뢰'할 수 있으며 더 이상 쓰레기를 버리지 않습니다. &lt;code&gt;if = null else&lt;/code&gt; 코드를 작성 하십시오 !</target>
        </trans-unit>
        <trans-unit id="c50fca7276a877e4ddcc3641d754b50d96020d50" translate="yes" xml:space="preserve">
          <source>Once you have wrapped a reference object, Optional provides many useful methods to invoke methods on a wrapped reference without NPE.</source>
          <target state="translated">참조 객체를 래핑 한 후 Optional은 NPE없이 래핑 된 참조에서 메서드를 호출하는 많은 유용한 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72353b7bfc87776c765797b34857c518b0e8dcd9" translate="yes" xml:space="preserve">
          <source>Only for this situation -</source>
          <target state="translated">이 상황에서만-</target>
        </trans-unit>
        <trans-unit id="f657c8e08093a6452319f9c30f992b884323f041" translate="yes" xml:space="preserve">
          <source>Optional.ifPresent invokes the given Consumer with a reference if it is a non-null value. Otherwise, it does nothing.</source>
          <target state="translated">Optional.ifPresent는 널이 아닌 값인 경우 참조로 지정된 이용자를 호출합니다. 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a132feaa88e9eaf93ca9f96a1e7df9448ce9003" translate="yes" xml:space="preserve">
          <source>Or if you think the try/catch mechanism is too ugly, rather than Do Nothing your default action should provide feedback to the user.</source>
          <target state="translated">또는 시도 / 잡기 메커니즘이 너무 추악하다고 생각되면 아무 것도하지 말고 기본 동작이 사용자에게 피드백을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f766e2839d0e27333563fdfa4a7af0a22bd85132" translate="yes" xml:space="preserve">
          <source>Or in your example:</source>
          <target state="translated">또는 귀하의 예에서 :</target>
        </trans-unit>
        <trans-unit id="8d0c023e0356e1bab468181b4ff498742ae4781b" translate="yes" xml:space="preserve">
          <source>PPS. For those fast to downvote (and not so fast to read documentation) I would like to say that I've never caught a null-pointer exception (NPE) in my life. But this possibility was &lt;strong&gt;intentionally designed&lt;/strong&gt; by the Java creators because NPE is a subclass of &lt;code&gt;Exception&lt;/code&gt;. We have a precedent in Java history when &lt;code&gt;ThreadDeath&lt;/code&gt; is an &lt;code&gt;Error&lt;/code&gt; not because it is actually an application error, but solely because it was not intended to be caught! How much NPE fits to be an &lt;code&gt;Error&lt;/code&gt; than &lt;code&gt;ThreadDeath&lt;/code&gt;! But it is not.</source>
          <target state="translated">PPS. 공감 율이 빠른 사람들 (그리고 문서를 읽는 속도가 빠르지 않은 사람들)을 위해 나는 인생에서 널 포인터 예외 (NPE)를 발견 한 적이 없다고 말하고 싶다. 그러나 NPE가 &lt;code&gt;Exception&lt;/code&gt; 의 서브 클래스이기 때문에 이러한 가능성은 &lt;strong&gt;의도적으로&lt;/strong&gt; Java 작성자가 &lt;strong&gt;설계&lt;/strong&gt; 한 것입니다. &lt;code&gt;ThreadDeath&lt;/code&gt; 가 &lt;code&gt;Error&lt;/code&gt; 인 경우 Java 히스토리에 선례가 있습니다. 실제로 애플리케이션 오류이기 때문이 아니라 잡히지 않았기 때문입니다! &lt;code&gt;ThreadDeath&lt;/code&gt; 보다 얼마나 많은 NPE가 &lt;code&gt;Error&lt;/code&gt; 가 될 수 있습니까! 그러나 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ee03b92c278aefd505b6e54e78c9dc0b157ad7a" translate="yes" xml:space="preserve">
          <source>PS. This approach will be as reasonable to use as the &lt;em&gt;separate error-handling code from &quot;regular&quot; code&lt;/em&gt; principle is reasonable to use in some place. Consider the next example:</source>
          <target state="translated">추신. 이 방법은 &lt;em&gt;&quot;일반적인&quot;코드&lt;/em&gt; 원칙과 &lt;em&gt;별도의 오류 처리 코드&lt;/em&gt; 가 어떤 장소에서 사용하기에 합리적이므로 사용하는 것이 합리적입니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ba90388bd4c171ca39fa6b73261783e63a2f28b2" translate="yes" xml:space="preserve">
          <source>Previous leads to normal logic flow to get no photo of a non-existent girlfriend from my photo library.</source>
          <target state="translated">이전에는 사진 라이브러리에서 존재하지 않는 여자 친구의 사진을 가져 오지 않기 위해 정상적인 논리 흐름으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="8f2b4864d43e2c92095e649bd1429a2c05d7ab61" translate="yes" xml:space="preserve">
          <source>Probably the best alternative for Java 8 or newer is to use the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">아마도 Java 8 이상에 대한 최상의 대안은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; 클래스를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18ac346b6a23f38378a9759b924291326484c819" translate="yes" xml:space="preserve">
          <source>Q. Redundant code could be executed and unnecessary resources could be grabbed.</source>
          <target state="translated">Q. 중복 코드가 실행될 수 있고 불필요한 리소스가 확보 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f3d300f344070bb3660651b4b7c84a7c1a7806" translate="yes" xml:space="preserve">
          <source>Q. This approach has a performance penalty due to the try closure opening.</source>
          <target state="translated">Q.이 방법은 시험 폐쇄 개방으로 인해 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="8ada7432c9d8ed60d8ddcb07057e3aa21a1cd988" translate="yes" xml:space="preserve">
          <source>Q. What if &lt;code&gt;getPhotoDataSource()&lt;/code&gt; returns null?</source>
          <target state="translated">Q. &lt;code&gt;getPhotoDataSource()&lt;/code&gt; 가 null을 반환하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="b0f21ff390c71b63fb33e4cf5b2e9b8e9cc3013f" translate="yes" xml:space="preserve">
          <source>Questions could arise:</source>
          <target state="translated">질문이 생길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c25c125f68f171e56c5dc46a5e78dbdc73323ed" translate="yes" xml:space="preserve">
          <source>Rather than Null Object Pattern -- which has its uses -- you might consider situations where the null object is a bug.</source>
          <target state="translated">Null 객체 패턴 (용도 사용)이 아니라 null 객체가 버그 인 상황을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1c9630619b3a985eea9596a353ce64e0b8e71b" translate="yes" xml:space="preserve">
          <source>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.
It is so clean and easy to understand. In the above code example, &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; gets invoked if the Optional holding reference is non-null.</source>
          <target state="translated">단일 입력 인수를 허용하고 결과를 반환하지 않는 작업을 나타냅니다. 대부분의 다른 기능 인터페이스와 달리 소비자는 부작용을 통해 작동해야합니다. 너무 깨끗하고 이해하기 쉽습니다. 위의 코드 예제에서 선택적 보유 참조가 널이 아닌 경우 &lt;code&gt;HomeService.switchOn(Service)&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9951bd4cc66be1c5bf9d684cb3738fbaaf27a9b2" translate="yes" xml:space="preserve">
          <source>SO HOW EXACTLY IT HELPS TO AVOID A NULL CHECK?</source>
          <target state="translated">그렇다면 NULL 점검을 피하는 것이 정확히 어떻게 도움이됩니까?</target>
        </trans-unit>
        <trans-unit id="12ebfd30869dc6d7d284fbd49560456e553ae1a4" translate="yes" xml:space="preserve">
          <source>See blog post &lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;More flexible and configurable @Nullable/@NotNull annotations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://blog.jetbrains.com/idea/2011/03/more-flexible-and-configurable-nullublenotnull-annotations/&quot;&gt;보다 유연하고 구성 가능한 @ Nullable / @ NotNull 주석&lt;/a&gt;&lt;/em&gt; 블로그 게시물을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c614bff3bcea0ba91a4e4fc674cacfdf5b3e3421" translate="yes" xml:space="preserve">
          <source>So I branch, and do two completely different things. There is no ugly code snippet, because I really need to do two different things depending on the data. For example, should I work on the input, or should I calculate a good default value?</source>
          <target state="translated">그래서 저는 분기하고 완전히 다른 두 가지 일을합니다. 데이터에 따라 두 가지 다른 작업을 수행해야하기 때문에 추악한 코드 스 니펫이 없습니다. 예를 들어 입력 작업을 수행해야합니까, 아니면 올바른 기본값을 계산해야합니까?</target>
        </trans-unit>
        <trans-unit id="ab095d82204599c2467871a3efe97685e021b767" translate="yes" xml:space="preserve">
          <source>So there is no difference between:</source>
          <target state="translated">따라서 다음과 같은 차이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3832db2f40c93881b178af60f45fd152a79ed806" translate="yes" xml:space="preserve">
          <source>So, IMHO, null must be a critical error which prevents further execution (that is, where null is not a valid value).</source>
          <target state="translated">따라서 IMHO, null은 추가 실행을 방지하는 중대한 오류 여야합니다 (즉, null이 유효한 값이 아닌 경우).</target>
        </trans-unit>
        <trans-unit id="91316cbc500c43d5b77c2b413a3f65b2f65958c8" translate="yes" xml:space="preserve">
          <source>Sometimes, you have methods that operate on its parameters that define a symmetric operation:</source>
          <target state="translated">때로는 매개 변수를 조작하여 대칭 조작을 정의하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8ca7bcd4b5f1acf3e5ba33e4a5f508dec7dea54" translate="yes" xml:space="preserve">
          <source>Sure do have a look at Aspect Oriented Programming, too - they have neat ways to insert &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; into your bytecode.</source>
          <target state="translated">Aspect &lt;code&gt;if( o == null ) handleNull()&lt;/code&gt; Programming도 살펴보십시오-바이트 코드에 if (o == null) handleNull () 을 삽입 하는 깔끔한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4cfb67cdd3b5f824a9934a1ed6c1fca9c1fc27" translate="yes" xml:space="preserve">
          <source>That said, perhaps it is entirely appropriate for the findAction() method to throw an Exception with a meaningful error message -- especially in this case where you are relying on user input.  It would be much better for the findAction method to throw an Exception than for the calling method to blow up with a simple NullPointerException with no explanation.</source>
          <target state="translated">즉, findAction () 메소드가 의미있는 오류 메시지 (특히이 경우 사용자 입력에 의존하는 경우)와 함께 예외를 발생시키는 것이 전적으로 적합 할 것입니다. findAction 메소드가 설명없이 간단한 NullPointerException으로 폭발하는 것보다 Exception을 던지는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7047d7ff31541da135908e8ecd7f812faea65471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?.&lt;/code&gt; means only de-reference the left identifier if it is not null, otherwise evaluate the remainder of the expression as &lt;code&gt;null&lt;/code&gt;. Some people, like Java Posse member Dick Wall and the &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;voters at Devoxx&lt;/a&gt; really love this proposal, but there is opposition too, on the grounds that it will actually encourage more use of &lt;code&gt;null&lt;/code&gt; as a sentinel value.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 왼쪽 식별자가 null이 아닌 경우에만 왼쪽 참조를 역 참조하고, 그렇지 않으면 나머지 표현식을 &lt;code&gt;null&lt;/code&gt; 로 평가합니다. Java Posse 멤버 Dick Wall 및 &lt;a href=&quot;http://blog.joda.org/2008/12/jdk-7-language-changes-devoxx-votes_3751.html&quot;&gt;Devoxx 유권자&lt;/a&gt; 와 같은 일부 사람들은이 제안을 정말 좋아하지만 실제로는 &lt;code&gt;null&lt;/code&gt; 을 센티넬 값으로 더 많이 사용하도록 권장한다는 반대 입장도 있습니다.</target>
        </trans-unit>
        <trans-unit id="78bbb74ffaaf0217ff4697c6fb561008da9384db" translate="yes" xml:space="preserve">
          <source>The Google collections framework offers a good and elegant way to achieve the null check.</source>
          <target state="translated">Google 컬렉션 프레임 워크는 null 검사를 수행 할 수있는 훌륭하고 우아한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1d0b369ef777f99443515fd98b70d6cbe6356789" translate="yes" xml:space="preserve">
          <source>The StringUtils class is only one of many; there are quite a few good classes in the commons that do null safe manipulation.</source>
          <target state="translated">StringUtils 클래스는 많은 것 중 하나 일뿐입니다. null 안전 조작을 수행하는 커먼즈에는 꽤 좋은 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3066493bcd46f61316ddaca0d5573d18b01f7cd" translate="yes" xml:space="preserve">
          <source>The compiler forces you to handle the &quot;undefined&quot; case.</source>
          <target state="translated">컴파일러는 &quot;정의되지 않은&quot;경우를 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="11db0d52c7259e3f5542cc11ae35ecc39a7f84be" translate="yes" xml:space="preserve">
          <source>The complete post is &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE as well as Null check-free code &amp;hellip; Really?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">완전한 게시물은 &lt;em&gt;&lt;a href=&quot;http://ydtech.blogspot.in/2015/04/npe-as-well-as-null-check-free-code.html&quot;&gt;NPE와 Null 무 검사 코드입니다.&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6f36738048a72c2ff14555a1f49f971e924f9660" translate="yes" xml:space="preserve">
          <source>The contracts are like mini-unit tests which are always running, even in production, and when things fail, you know why, rather than a random NPE you have to somehow figure out.</source>
          <target state="translated">계약은 생산 중에도 항상 실행되는 미니 유닛 테스트와 같으며 일이 실패 할 때 임의의 NPE가 아닌 이유를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="8b07fde497d833a3dea4d5d1623ff04bff7cd150" translate="yes" xml:space="preserve">
          <source>The example given by Alex Miller looks like this:</source>
          <target state="translated">Alex Miller가 제공 한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b1e5e00880fd770c374b1874c5898efc9b29533" translate="yes" xml:space="preserve">
          <source>The message will contain the following text if, for example, &quot;plans&quot; is null:</source>
          <target state="translated">예를 들어 &quot;plans&quot;가 null 인 경우 메시지에 다음 텍스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="50acd96098203094b440f2ee9754742ef52b2da0" translate="yes" xml:space="preserve">
          <source>The method is most useful for &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;checking&lt;/a&gt; just before an assignment in a constructor, where each use of it can save three lines of code:</source>
          <target state="translated">이 메소드는 생성자에서 할당 직전에 &lt;a href=&quot;https://stackoverflow.com/questions/3322638/is-it-okay-to-throw-nullpointerexception-programatically&quot;&gt;확인하는&lt;/a&gt; 데 가장 유용하며, 각 메소드를 사용하면 세 줄의 코드를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93d133895627c9a3d74a6c30e204dcdb8e532ac" translate="yes" xml:space="preserve">
          <source>The only other methods which do not check for null are utility methods. They are public, but if you call them for some reason, you know what parameters you pass. This is like trying to boil water in the kettle without providing water...</source>
          <target state="translated">널을 확인하지 않는 유일한 다른 메소드는 유틸리티 메소드입니다. 그것들은 공개적이지만 어떤 이유로 호출하면 어떤 매개 변수를 전달하는지 알 수 있습니다. 이것은 물을 공급하지 않고 주전자에서 물을 끓이려고하는 것과 같습니다 ...</target>
        </trans-unit>
        <trans-unit id="3071661bc3a8f3f1fb050d846047c85545570484" translate="yes" xml:space="preserve">
          <source>The second example won't compile (in IntelliJ IDEA).</source>
          <target state="translated">두 번째 예제는 컴파일되지 않습니다 (IntelliJ IDEA에서).</target>
        </trans-unit>
        <trans-unit id="d6530e4dc64d23e3133b0d5fd801c0b069e04e94" translate="yes" xml:space="preserve">
          <source>The way I solve this problem is this:</source>
          <target state="translated">이 문제를 해결하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b0438900bb10b9989752d1f3c4b40b7f47f6df7" translate="yes" xml:space="preserve">
          <source>Then, in the rest of that method, you'll know that &lt;code&gt;object&lt;/code&gt; is not null.</source>
          <target state="translated">그런 다음 나머지 메소드에서 &lt;code&gt;object&lt;/code&gt; 가 null이 아님을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79a6826b25f58343482759c32d1843c3fcfde425" translate="yes" xml:space="preserve">
          <source>There is a method in a library class like this:</source>
          <target state="translated">라이브러리 클래스에는 다음과 같은 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b611806237c884a66462ab8d01c1db4a0455d83" translate="yes" xml:space="preserve">
          <source>There is a proposal to add new annotations in Java7 to help with null / notnull params:
&lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</source>
          <target state="translated">null / notnull 매개 변수를 지원하기 위해 Java7에 새 주석을 추가하라는 제안이 있습니다. &lt;a href=&quot;http://tech.puredanger.com/java7/#jsr308&quot;&gt;http://tech.puredanger.com/java7/#jsr308&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdcc90e0f67eeda9f92fa7029efb8f80e4f6cda3" translate="yes" xml:space="preserve">
          <source>There is a tiny overhead in this, but it's worth it for cleaner code and less NullPointerExceptions.</source>
          <target state="translated">이것에는 작은 오버 헤드가 있지만 더 깨끗한 코드와 적은 NullPointerExceptions에 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a995a0c78ad44e2ea78fecf0b6b5ae088210dbfb" translate="yes" xml:space="preserve">
          <source>They both want to make sure that we received valid parameters, before we do any other functions.</source>
          <target state="translated">그들은 우리가 다른 기능을 수행하기 전에 유효한 매개 변수를 받았는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0de62a4c684b4be885c335e3c1f969aeb6ca39e3" translate="yes" xml:space="preserve">
          <source>They work like that:</source>
          <target state="translated">그들은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6da291a4214849ad22b47d77f7b9e5c7c2ed3dbb" translate="yes" xml:space="preserve">
          <source>This checks for a &lt;code&gt;NullPointerException&lt;/code&gt; for the &lt;code&gt;someobject&lt;/code&gt; object in the above snippet.</source>
          <target state="translated">위의 스 니펫에서 &lt;code&gt;someobject&lt;/code&gt; 객체에 대한 &lt;code&gt;NullPointerException&lt;/code&gt; 을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a632edab67a162af8d6236e911205c0bd2945507" translate="yes" xml:space="preserve">
          <source>This is a very common problem for every Java developer. So there is official support in Java&amp;nbsp;8 to address these issues without cluttered code.</source>
          <target state="translated">이것은 모든 Java 개발자에게 매우 일반적인 문제입니다. 따라서 Java 8에는 복잡한 코드없이 이러한 문제를 해결하기위한 공식 지원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63475a15e2d7175b43a8eb4ced243071760761e7" translate="yes" xml:space="preserve">
          <source>This is defensive programming and results in much cleaner code in the long run. Always sanitize the data, e.g. here by enforcing rigid standards, and the problems go away.</source>
          <target state="translated">이것은 방어적인 프로그래밍이며 장기적으로 훨씬 깨끗한 코드를 생성합니다. 예를 들어 엄격한 표준을 적용하여 데이터를 항상 삭제하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="96855dbf651af7ee23c0764f0f76d95841159676" translate="yes" xml:space="preserve">
          <source>This is especially handy for long chains of possible null values. Example:</source>
          <target state="translated">이것은 가능한 null 값의 긴 체인에 특히 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="ab20b6e950b963a0a9153b9bd523a03c124b9ceb" translate="yes" xml:space="preserve">
          <source>This is slightly better than:</source>
          <target state="translated">이것은 다음보다 약간 낫습니다.</target>
        </trans-unit>
        <trans-unit id="4f0f6bf669b0e6c235196e52c58820b609d7a7a9" translate="yes" xml:space="preserve">
          <source>This is the most common error occurred for most of the developers.</source>
          <target state="translated">이것은 대부분의 개발자에게 가장 일반적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2c2ef7f8c0c5f5953f9d8dc9f87238113a866d47" translate="yes" xml:space="preserve">
          <source>This really depends. If find that I often do something like this:</source>
          <target state="translated">이것은 정말 다릅니다. 내가 종종 이런 식으로 뭔가를 발견하면 :</target>
        </trans-unit>
        <trans-unit id="5f65d63d47b93827d172b66566e2699ba53e9246" translate="yes" xml:space="preserve">
          <source>This to me sounds like a reasonably common problem that junior to intermediate developers tend to face at some point: they either don't know or don't trust the contracts they are participating in and defensively overcheck for nulls.  Additionally, when writing their own code, they tend to rely on returning nulls to indicate something thus requiring the caller to check for nulls.</source>
          <target state="translated">이것은 저에게 중급 개발자가 중간 시점에서 직면하는 경향이있는 합리적으로 일반적인 문제인 것 같습니다. 그들은 참여하고있는 계약을 모르거나 신뢰하지 않고 널을 과도하게 점검합니다. 또한 자체 코드를 작성할 때 null을 반환하여 호출자가 null을 확인 해야하는 것을 나타내는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66c4aae334386fa18d2bf51fc0dd0e22c5fcd02" translate="yes" xml:space="preserve">
          <source>This way, the code is clean, easy maintainable and readable.</source>
          <target state="translated">이런 식으로 코드는 깨끗하고 유지 관리가 쉽고 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88e9d9f0b01df7bd366fd6f414813582c76c2a26" translate="yes" xml:space="preserve">
          <source>This won't compile.</source>
          <target state="translated">컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03a1146d56211c08b24efbc23fe64db2a1fe9e19" translate="yes" xml:space="preserve">
          <source>To implement this pattern in java, you can use core java annotations like &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; or use more sophisticated libraries like &lt;strong&gt;Hibernate Validator&lt;/strong&gt;.</source>
          <target state="translated">이 패턴을 Java로 구현하려면 &lt;strong&gt;javax.annotation.NotNull&lt;/strong&gt; 과 같은 핵심 Java 어노테이션을 사용하거나 &lt;strong&gt;Hibernate Validator&lt;/strong&gt; 와 같은보다 정교한 라이브러리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65dd044ab70d140d1269ad7b58d585a319cf8c8e" translate="yes" xml:space="preserve">
          <source>To put this another way, there are two instances where null checking comes up:</source>
          <target state="translated">다른 방법으로 null 검사가 나타나는 두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="893faf3275f29660c0345c697429903da97cca3c" translate="yes" xml:space="preserve">
          <source>Try to make all your attributes and its accessors as private as possible or avoid to  expose them to the clients at all. You can have the argument values in the constructor of course, but by reducing the scope you don't let the client class pass an invalid value. If you need to modify the values, you can always create a new &lt;code&gt;object&lt;/code&gt;.  You check the values in the constructor only &lt;strong&gt;once&lt;/strong&gt; and in the rest of the methods you can be almost sure that the values are not null.</source>
          <target state="translated">모든 속성과 접근자를 가능한 한 비공개로 만들거나 클라이언트에 노출시키지 마십시오. 물론 생성자에 인수 값을 가질 수 있지만 범위를 줄이면 클라이언트 클래스가 유효하지 않은 값을 전달하지 못하게됩니다. 값을 수정해야하는 경우 언제든지 새 &lt;code&gt;object&lt;/code&gt; 만들 수 있습니다. 생성자에서 &lt;strong&gt;한 번만&lt;/strong&gt; 값을 확인하고 나머지 메소드에서는 값이 널이 아님을 거의 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5096108c9ee2936b6660a55e9c083bcd59532700" translate="yes" xml:space="preserve">
          <source>Ultimately, the only way to completely solve this problem is by using a different programming language:</source>
          <target state="translated">궁극적으로이 문제를 완전히 해결하는 유일한 방법은 다른 프로그래밍 언어를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="91e3b61c16f5d43c2c292405b4146327e9221a06" translate="yes" xml:space="preserve">
          <source>Using parameter</source>
          <target state="translated">매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="410ecb47e87fed6b528cde0e827e193125ef8e2c" translate="yes" xml:space="preserve">
          <source>WRAPPING TO OPTION&amp;lt;T&amp;gt;</source>
          <target state="translated">랩핑 옵션 &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="16139730df851e7de2b4d9ecb2a4976efb2493cf" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;usually&lt;/strong&gt; face this issue when the methods get the parameters in the way we not expected (bad method call is programmer's fault). For example: you expect to get an object, instead you get a null. You expect to get an String with at least one character, instead you get an empty String ...</source>
          <target state="translated">우리는 &lt;strong&gt;일반적으로&lt;/strong&gt; 메소드가 예상하지 않은 방식으로 매개 변수를 가져올 때이 문제에 직면합니다 (잘못된 메소드 호출은 프로그래머의 결함입니다). 예를 들어, 객체를 얻는 대신 null을 얻습니다. 적어도 하나의 문자가있는 문자열을 얻을 것으로 예상되는 대신 빈 문자열을 얻습니다 ...</target>
        </trans-unit>
        <trans-unit id="81d7e415e730d427573e6b4ff607e889a2cb73ec" translate="yes" xml:space="preserve">
          <source>We have number of ways to handle this.</source>
          <target state="translated">이를 처리 할 수있는 방법이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f598db2507984034e96ef0808dfe220b74dab82" translate="yes" xml:space="preserve">
          <source>We use the ternary operator very often for checking null condition and return an alternative value or default value. Optional provides another way to handle the same condition without checking null. Optional.orElse(defaultObj) returns defaultObj if the Optional has a null value. Let's use this in our sample code:</source>
          <target state="translated">우리는 null 조건을 확인하기 위해 삼항 연산자를 자주 사용하고 대체 값 또는 기본값을 반환합니다. 선택 사항은 null을 확인하지 않고 동일한 조건을 처리하는 다른 방법을 제공합니다. Optional.orelse (defaultObj)는 Optional에 null 값이 있으면 defaultObj를 반환합니다. 샘플 코드에서 이것을 사용하자 :</target>
        </trans-unit>
        <trans-unit id="1b7de74b75d773507feae3e01547f3abd8a8e794" translate="yes" xml:space="preserve">
          <source>When the exception is thrown, examine the stack trace and work through the bug.</source>
          <target state="translated">예외가 발생하면 스택 추적을 검사하고 버그를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="56f60bd1b035c1637de885e8364d676ed25dd3d5" translate="yes" xml:space="preserve">
          <source>When you use the first &lt;code&gt;helloWorld()&lt;/code&gt; function in another piece of code:</source>
          <target state="translated">다른 코드에서 첫 번째 &lt;code&gt;helloWorld()&lt;/code&gt; 함수를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="79b6177f112f6c351c671521cc708abf0dbc2ef4" translate="yes" xml:space="preserve">
          <source>Where it isn't a valid response.</source>
          <target state="translated">올바른 응답이 아닌 곳.</target>
        </trans-unit>
        <trans-unit id="35c99b0c8fc1f9ea3f573be119257028ced0e610" translate="yes" xml:space="preserve">
          <source>Where null is a valid response in terms of the contract; and</source>
          <target state="translated">계약에있어서 유효한 응답이 null 인 경우 과</target>
        </trans-unit>
        <trans-unit id="cdfe105c8bfbcc3b13ac6840fef58d8c1666a5a4" translate="yes" xml:space="preserve">
          <source>While it is rather 'normal business flow' not to find photo stored into the DB for some person, I used to use pairs like below for some other cases</source>
          <target state="translated">어떤 사람에게는 DB에 저장된 사진을 찾지 못하는 것이 오히려 '정상적인 업무 흐름'이지만, 다른 경우에는 아래와 같이 쌍을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="580ecabb6906d2e8e175eeee96c8cd0b5d5e79e0" translate="yes" xml:space="preserve">
          <source>With Java 8 comes the new &lt;code&gt;java.util.Optional&lt;/code&gt; class that arguably solves some of the problem. One can at least say that it improves the readability of the code, and in the case of public APIs make the API's contract clearer to the client developer.</source>
          <target state="translated">Java 8에는 문제를 해결하는 새로운 &lt;code&gt;java.util.Optional&lt;/code&gt; 클래스가 있습니다. 적어도 코드의 가독성을 향상시키고 퍼블릭 API의 경우 API 계약을 클라이언트 개발자에게 명확하게 만들 수 있다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f3836243579dcf0aab46f92bd120d19df8df941" translate="yes" xml:space="preserve">
          <source>With non-collections it might be harder.  Consider this as an example: if you have these interfaces:</source>
          <target state="translated">컬렉션이 아닌 경우 어려울 수 있습니다. 이러한 인터페이스를 예로 들면 다음과 같이 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a5b1abb2eabdd6b338fefcfe915a795e0025f2b9" translate="yes" xml:space="preserve">
          <source>Wow, I almost hate to add another answer when we have 57 different ways to recommend the &lt;code&gt;NullObject pattern&lt;/code&gt;, but I think that some people interested in this question may like to know that there is a proposal on the table for Java 7 to add &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;null-safe handling&quot;&lt;/a&gt;&amp;mdash;a streamlined syntax for if-not-equal-null logic.</source>
          <target state="translated">와우, 나는 &lt;code&gt;NullObject pattern&lt;/code&gt; 을 추천하는 57 가지 방법이있을 때 또 다른 대답을 추가하는 것을 거의 싫어하지만이 질문에 관심이있는 사람들은 Java 7 표에 &lt;a href=&quot;http://tech.puredanger.com/java7/#null&quot;&gt;&quot;null&lt;/a&gt; 을 추가하라는 제안이 있다는 것을 알고 싶어 할 것입니다. -safe handling &quot;-if - nqual -null 논리에 대한 간소화 된 구문.</target>
        </trans-unit>
        <trans-unit id="951af1231b6d7d7d241620882f25427c99d9e5db" translate="yes" xml:space="preserve">
          <source>You can avoid that if you compare your &lt;code&gt;String&lt;/code&gt;s like this:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 을 다음 과 같이 비교하면 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f4edd11fb336e0c393189054436b5ea0dd3965" translate="yes" xml:space="preserve">
          <source>You can go a step further and make sure that only valid pojos could be created in your application. (sample from hibernate validator site)</source>
          <target state="translated">한 단계 더 나아가 응용 프로그램에서 유효한 pojo 만 작성할 수 있습니다. (최대 절전 모드 검사기 사이트의 샘플)</target>
        </trans-unit>
        <trans-unit id="b426fa3dff81bdf8322ce5f08dc73d3a6c054889" translate="yes" xml:space="preserve">
          <source>You can use in method and parameters, like this:</source>
          <target state="translated">다음과 같이 메소드 및 매개 변수에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f52d6127cbef2caa2515fee8335a6cf4b50a3ecc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map()&lt;/code&gt; operator to perform a computation on--or extract a value from--an optional object.  &lt;code&gt;orElse()&lt;/code&gt; lets you provide a fallback for missing values.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 연산자를 사용하여 선택적 객체에서 계산을 수행하거나 값을 추출 할 수 있습니다. &lt;code&gt;orElse()&lt;/code&gt; 사용하면 결 측값에 대한 폴백을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d33b9baf8ae290074a6e9952500c20b8c202dd6" translate="yes" xml:space="preserve">
          <source>You have to check for object != null only if you want to handle the case where the object may be null...</source>
          <target state="translated">객체가 null 일 수있는 경우를 처리하려는 경우에만 객체! = null을 확인해야합니다 ...</target>
        </trans-unit>
        <trans-unit id="5146850a0aff4c1b7d4e622f1b93cada470ef71b" translate="yes" xml:space="preserve">
          <source>You might configure your IDE to warn you about potential null dereferencing. E.g. in Eclipse, see &lt;em&gt;Preferences &amp;gt; Java &amp;gt; Compiler &amp;gt; Errors/Warnings/Null analysis&lt;/em&gt;.</source>
          <target state="translated">잠재적 인 null 역 참조에 대해 경고하도록 IDE를 구성 할 수 있습니다. 예를 들어 Eclipse에서 &lt;em&gt;환경 설정&amp;gt; Java&amp;gt; 컴파일러&amp;gt; 오류 / 경고 / 널 분석을 참조하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4f4a16be11579dd7183f0b53dba9326d6fee7a45" translate="yes" xml:space="preserve">
          <source>allow the Exceptions to ripple through - catch them at the 'main loop' or in some other managing routine.</source>
          <target state="translated">예외가 파급되도록 허용- '메인 루프'또는 다른 관리 루틴에서 예외를 포착하십시오.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a91d8763ddd012bd694861a83ced3c22ba85ef5a" translate="yes" xml:space="preserve">
          <source>check for error conditions and handle them appropriately</source>
          <target state="translated">오류 상태를 확인하고 적절히 처리하십시오</target>
        </trans-unit>
        <trans-unit id="242af77b8af1f9f1f76f01852e12bf007ce5565b" translate="yes" xml:space="preserve">
          <source>if you write something like:</source>
          <target state="translated">다음과 같은 것을 작성하면 :</target>
        </trans-unit>
        <trans-unit id="37b00e27e7160b5c20659252018b000c5884b58a" translate="yes" xml:space="preserve">
          <source>notNull(Object object, String message)</source>
          <target state="translated">notNull (객체 객체, 문자열 메시지)</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7f59b1d21b6092bc9549f5f4ed93ec595233ec73" translate="yes" xml:space="preserve">
          <source>or (depending on what you need to check):</source>
          <target state="translated">또는 (확인해야 할 사항에 따라) :</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="8175c105a4fbc0c1bfbecc0778b58cf2689a03e3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; is a boolean expression and &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; is an object whose &lt;code&gt;toString()&lt;/code&gt; method's output will be included in the error.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; 은 부울 표현식이고 &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 는 &lt;code&gt;toString()&lt;/code&gt; 메서드의 출력이 오류에 포함되는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="66933b5352b59bac31f84234608a5d23ea089515" translate="yes" xml:space="preserve">
          <source>where Parser takes raw user input and finds something to do, perhaps if you're implementing a command line interface for something.  Now you might make the contract that it returns null if there's no appropriate action.  That leads the null checking you're talking about.</source>
          <target state="translated">파서는 원시 사용자 입력을 취하고 무언가에 대한 명령 행 인터페이스를 구현하는 경우해야 할 일을 찾습니다. 적절한 조치가 없으면 계약이 널을 리턴하도록 만들 수 있습니다. 그것은 당신이 말하는 null 점검을 이끈다.</target>
        </trans-unit>
        <trans-unit id="880c9234e5994e5388ead855bf7ee74adb695efb" translate="yes" xml:space="preserve">
          <source>which is a much better design because it leads to more concise code.</source>
          <target state="translated">더 간결한 코드로 이어지기 때문에 훨씬 더 나은 디자인입니다.</target>
        </trans-unit>
        <trans-unit id="85d0952dedf1cf905b6bd07f33e02911381c8fd1" translate="yes" xml:space="preserve">
          <source>will result in a &lt;code&gt;NullPointerException&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; doesn't exist.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 가 존재하지 않으면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
