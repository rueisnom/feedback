<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2770321">
    <body>
      <group id="2770321">
        <trans-unit id="9bb688abe7c73fe83082a7942e2afa010b95bd2e" translate="yes" xml:space="preserve">
          <source>&quot;Raw types&quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</source>
          <target state="translated">&quot;Типы сырья&quot; используются для обратной совместимости.Их использование в новом коде не рекомендуется,так как использование обобщенного класса с аргументом типа позволяет более сильную типизацию,что в свою очередь может улучшить понятность кода и привести к более раннему выявлению потенциальных проблем.</target>
        </trans-unit>
        <trans-unit id="5e202a8885e8f2a0b0b18f657d2d758c8387e684" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; continues to explain the following:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; продолжает объяснять следующее:</target>
        </trans-unit>
        <trans-unit id="9bcbbc30c3a268dc93ee0fcdcac237b04fa72318" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;tutorial page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;учебная страница&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5eeaf258c2f69574da220e548fe8afb66742168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; it is a &lt;code&gt;ArrayList&lt;/code&gt; reference variable with type &lt;code&gt;String&lt;/code&gt; which reference to a &lt;code&gt;ArralyList&lt;/code&gt; Object of Type &lt;code&gt;String&lt;/code&gt;. It means it can hold only String type Object.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; это ссылочная переменная &lt;code&gt;ArrayList&lt;/code&gt; с типом &lt;code&gt;String&lt;/code&gt; , которая ссылается на объект &lt;code&gt;ArralyList&lt;/code&gt; типа &lt;code&gt;String&lt;/code&gt; . Это означает, что он может содержать только объект типа String.</target>
        </trans-unit>
        <trans-unit id="5b6476b68a8bec6fe2c018b1e2dce00d036d2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, etc are all &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;, so it may be tempting to just say that they're just &lt;code&gt;List&lt;/code&gt; instead. However, there is a major difference: since a &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; defines only &lt;code&gt;add(E)&lt;/code&gt;, you can't add just any arbitrary object to a &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;. On the other hand, since the raw type &lt;code&gt;List&lt;/code&gt; does not have type safety, you can &lt;code&gt;add&lt;/code&gt; just about anything to a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; , &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; и т. Д. - все это &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; , Поэтому может показаться заманчивым просто сказать, что они просто &lt;code&gt;List&lt;/code&gt; . Однако есть существенное отличие: поскольку &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; определяет только &lt;code&gt;add(E)&lt;/code&gt; , вы не можете добавить любой произвольный объект в &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; . С другой стороны, поскольку необработанный тип &lt;code&gt;List&lt;/code&gt; не имеет безопасности типов, вы можете &lt;code&gt;add&lt;/code&gt; в &lt;code&gt;List&lt;/code&gt; практически все, что угодно.</target>
        </trans-unit>
        <trans-unit id="c965c3b6097bff5c3d5f7d3ca7b09048dacbe93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&lt;/code&gt; is defined to support generics: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt;. This allows many type-safe operations, that are checked compile-time.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; определен для поддержки обобщений: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt; . Это позволяет выполнять многие безопасные с точки зрения типов операции, которые проверяются во время компиляции.</target>
        </trans-unit>
        <trans-unit id="29a69c16f89c3fd935dd606a5d4b3dbdabe380d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MyType.Nested&lt;/code&gt; is not a parameterized type, even though it's a member type of a parameterized type &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;, because it's &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MyType.Nested&lt;/code&gt; не является параметризованным типом, даже если это тип члена параметризованного типа &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; , поскольку он является &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f052ee67a2af0dd5f9f4bd5d42450f8187a17d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; operand, e.g. &lt;code&gt;o instanceof Set&lt;/code&gt;, not &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; операнда, например, &lt;code&gt;o instanceof Set&lt;/code&gt; , а не &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3aa367113494aa1a8fa752010519a9dd14831d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt1&lt;/code&gt;, and &lt;code&gt;mt2&lt;/code&gt; are both declared with actual type parameters, so they're not raw types.</source>
          <target state="translated">&lt;code&gt;mt1&lt;/code&gt; и &lt;code&gt;mt2&lt;/code&gt; оба объявлены с фактическими параметрами типа, поэтому они не являются необработанными типами.</target>
        </trans-unit>
        <trans-unit id="c778f211d4f54dd9219432d85be2ae77c19c5d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt&lt;/code&gt; has a raw type (and generates a compilation warning) by the first bullet point in the above definition; &lt;code&gt;inn&lt;/code&gt; also has a raw type by the third bullet point.</source>
          <target state="translated">&lt;code&gt;mt&lt;/code&gt; имеет необработанный тип (и генерирует предупреждение о компиляции) по первому пункту в приведенном выше определении; &lt;code&gt;inn&lt;/code&gt; также есть необработанный тип по третьему пункту.</target>
        </trans-unit>
        <trans-unit id="bcbfd569522fe96225142a9dbce9d9b99256d6ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Effective Java 2nd Edition&lt;/em&gt; also has this to add:</source>
          <target state="translated">&lt;em&gt;Effective Java 2nd Edition&lt;/em&gt; также имеет следующее:</target>
        </trans-unit>
        <trans-unit id="06c568b39defa968eaf6d417143a99d437431f20" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For example&lt;/em&gt;,</source>
          <target state="translated">&lt;em&gt;Например&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="3120d5d3ec33fa18134615010180259f358798d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is a raw type and why do I often hear that they shouldn't be used in new code?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Что такое необработанный тип и почему я часто слышу, что его не следует использовать в новом коде?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd279a8439dba2e5fdaf708d98b1db46ee00ff1e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the alternative if we can't use raw types, and how is it better?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Какая альтернатива, если мы не можем использовать необработанные типы, и как это лучше?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b80e7105e2584ff1d4ed97bfe515dcd23c4b2311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[...]&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e42a4f633bcd32dbe51455ca6bdd7612a294cb1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid raw types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Избегайте необработанных типов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e599fb38e4978d9cad0bf8657fc35335efcaf1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For reference&lt;/strong&gt;: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Для справки&lt;/strong&gt; : &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c5165c71ee10325066370d72c5f9a39d27bb232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Возвращаемый тип метода и параметры типа универсального метода или конструктора также стираются, если сигнатура метода или конструктора удалена.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4311a85106cdf76087c5d49e5214fd1bb252ec93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They should be avoided&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Их следует избегать&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f0d740fb2f9099a842f154be27e6d2d6ade17b18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.&lt;/strong&gt; The erasure of a constructor or method signature &lt;code&gt;s&lt;/code&gt; is a signature consisting of the same name as &lt;code&gt;s&lt;/code&gt; and the erasures of all the formal parameter types given in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Стирание типа также отображает сигнатуру конструктора или метода в сигнатуру, которая не имеет параметризованных типов или переменных типа.&lt;/strong&gt; Удаление сигнатуры конструктора или метода &lt;code&gt;s&lt;/code&gt; - это сигнатура, состоящая из того же имени, что и &lt;code&gt;s&lt;/code&gt; , и стирания всех типов формальных параметров, указанных в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365cf8a2d2c5f7bc6bd0f00615a2382dd4286f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Raw&lt;/code&gt; Type Object is referenced to a &lt;code&gt;Strict&lt;/code&gt; type Referenced Variable of &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : - Объект &lt;code&gt;Raw&lt;/code&gt; типа ссылается на ссылочную переменную &lt;code&gt;Strict&lt;/code&gt; типа &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5cf18f48861714cd2c12682318f23cca1637eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Strict&lt;/code&gt; Type Object is referenced to a &lt;code&gt;raw&lt;/code&gt; type referenced Variable.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : - Объект &lt;code&gt;Strict&lt;/code&gt; типа ссылается на переменную &lt;code&gt;raw&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="90a252e2d44f3f2a8b1890033755001338955145" translate="yes" xml:space="preserve">
          <source>============== I went from this code as provide by the sample ===============</source>
          <target state="translated">==================Я пошел от этого кода,как показано в примере ===============</target>
        </trans-unit>
        <trans-unit id="b2eab9097b3ec971d127fbaff91ee92679421cbf" translate="yes" xml:space="preserve">
          <source>====================== To This code ========================</source>
          <target state="translated">==============================К этому коду ========================================</target>
        </trans-unit>
        <trans-unit id="7a19b8e149aed7175b12239c8772988575617b7c" translate="yes" xml:space="preserve">
          <source>A &quot;raw type&quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using &lt;code&gt;List&lt;/code&gt; instead of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a &quot;raw type&quot; (without specifying a type argument) allowed legacy code to still compile.</source>
          <target state="translated">&amp;laquo;Необработанный тип&amp;raquo; - это использование универсального класса без указания аргумента (ов) типа для его параметризованного типа (типов), например, использование &lt;code&gt;List&lt;/code&gt; вместо &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; . Когда дженерики были введены в Java, несколько классов были обновлены для использования дженериков. Использование этих классов в качестве &amp;laquo;необработанного типа&amp;raquo; (без указания аргумента типа) позволило устаревшему коду все еще компилироваться.</target>
        </trans-unit>
        <trans-unit id="33ba04d196a3008973ddc2524394442fa33e4d49" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; type in Java is a class which is non-generic and deals with &quot;raw&quot; Objects, rather than type-safe generic type parameters.</source>
          <target state="translated">Тип &quot;raw&quot; в Java-это класс,который не является генерическим и имеет дело с &quot;сырыми&quot; Объектами,а не с типологически безопасными общими параметрами типа.</target>
        </trans-unit>
        <trans-unit id="c99659ce7dbf112bd14117c16ebbd8db3d175959" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;raw&lt;/em&gt;-type is the a lack of a &lt;em&gt;type parameter&lt;/em&gt; when using a generic type.</source>
          <target state="translated">&lt;em&gt;Необработанный&lt;/em&gt; тип - это отсутствие &lt;em&gt;параметра типа&lt;/em&gt; при использовании универсального типа.</target>
        </trans-unit>
        <trans-unit id="a826d4198daa01070b87640f459ca71ec283ab02" translate="yes" xml:space="preserve">
          <source>A list is a raw type, while &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a parameterized type.</source>
          <target state="translated">Список является необработанным типом, а &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; является параметризованным типом.</target>
        </trans-unit>
        <trans-unit id="f8572ed900bc3ec607e2c608d6c9250f0ee36db6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; member type of a raw type &lt;code&gt;R&lt;/code&gt; that is not inherited from a superclass or superinterface of &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">Нестатический тип члена необработанного типа &lt;code&gt;R&lt;/code&gt; , который не унаследован от суперкласса или суперинтерфейса &lt;code&gt;R&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a5287cb23f3eeae5edf828005202ed23e61a642" translate="yes" xml:space="preserve">
          <source>A raw type is defined to be one of:</source>
          <target state="translated">Сырой тип определяется как один из них:</target>
        </trans-unit>
        <trans-unit id="205748e8c233f71145a1f2bd274309746828335f" translate="yes" xml:space="preserve">
          <source>A raw type is the erasure of that type</source>
          <target state="translated">Сырой тип-это стирание этого типа.</target>
        </trans-unit>
        <trans-unit id="6a29e532dca4388e029fb3ea7d50673d5d01e2fd" translate="yes" xml:space="preserve">
          <source>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</source>
          <target state="translated">Необработанный тип-это имя общего класса или интерфейса без аргументов типа.Например,учитывая общий класс Box:</target>
        </trans-unit>
        <trans-unit id="8845a4e3b681a7b8affa2bfb6f73c348d4d14738" translate="yes" xml:space="preserve">
          <source>An array type whose element type is a raw type.</source>
          <target state="translated">Тип массива,тип элемента которого является необработанным типом.</target>
        </trans-unit>
        <trans-unit id="aca82bd9f96a2ad182aa1d73db0796bc4f782989" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Object&lt;/code&gt; stored in a &lt;code&gt;Collection&lt;/code&gt; has to be cast before it can be used</source>
          <target state="translated">Любой &lt;code&gt;Object&lt;/code&gt; хранящийся в &lt;code&gt;Collection&lt;/code&gt; должен быть приведен к использованию перед использованием.</target>
        </trans-unit>
        <trans-unit id="7d029af1223f081b1921aa7f94ee3bf1b6d1d8ad" translate="yes" xml:space="preserve">
          <source>Are there no exceptions?</source>
          <target state="translated">Исключений нет?</target>
        </trans-unit>
        <trans-unit id="340c1df6af27884fb6eb161fdf86234b7c9f6b06" translate="yes" xml:space="preserve">
          <source>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</source>
          <target state="translated">Как упоминалось ранее,при смешивании устаревшего кода с общим кодом,вы можете столкнуться с предупреждающими сообщениями,похожими на следующие:</target>
        </trans-unit>
        <trans-unit id="5c59276c92cf37b7805c3861f7c5d5b2178bb735" translate="yes" xml:space="preserve">
          <source>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just &lt;code&gt;Object&lt;/code&gt;).</source>
          <target state="translated">Как уже упоминалось в принятом ответе, вы теряете всю поддержку обобщений в коде необработанного типа. Каждый параметр типа преобразуется в его стирание (которое в приведенном выше примере является просто &lt;code&gt;Object&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="54ed0f30909fe006459ed6df04d66c2798441b16" translate="yes" xml:space="preserve">
          <source>Back to JLS 4.8:</source>
          <target state="translated">Назад к JLS 4.8:</target>
        </trans-unit>
        <trans-unit id="6b592f4fe7b7afd4d7a2840c62e109cd230efddb" translate="yes" xml:space="preserve">
          <source>But if you assign a raw type to a parameterized type, you get a warning:</source>
          <target state="translated">Но если вы назначите тип raw параметризованному типу,вы получите предупреждение:</target>
        </trans-unit>
        <trans-unit id="03b28b2417326b91d54010c203487876d052c1ec" translate="yes" xml:space="preserve">
          <source>Case 1</source>
          <target state="translated">Дело 1</target>
        </trans-unit>
        <trans-unit id="ee1189515944c7f281c8f48e390364b2fc748d15" translate="yes" xml:space="preserve">
          <source>Case 2</source>
          <target state="translated">Дело 2</target>
        </trans-unit>
        <trans-unit id="16024e7ee398804bd61c244d6dfbc1dea703c6c9" translate="yes" xml:space="preserve">
          <source>Case 3</source>
          <target state="translated">Дело 3</target>
        </trans-unit>
        <trans-unit id="5928bc5d24ccc7a0cbc69187317ba17c2da6578c" translate="yes" xml:space="preserve">
          <source>Class literals, e.g. &lt;code&gt;List.class&lt;/code&gt;, not &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</source>
          <target state="translated">Литералы класса, например &lt;code&gt;List.class&lt;/code&gt; , а не &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="037a786100af58ee1da0c90e38df1f04d615f726" translate="yes" xml:space="preserve">
          <source>Consider the following variation of the previous snippet:</source>
          <target state="translated">Рассмотрим следующий вариант предыдущего фрагмента:</target>
        </trans-unit>
        <trans-unit id="a34e95f456c0661699837d4636ebb3f2edebde4e" translate="yes" xml:space="preserve">
          <source>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</source>
          <target state="translated">По сути,необработанные типы ведут себя так же,как и до появления дженериков.То есть,на этапе компиляции следующее полностью легально.</target>
        </trans-unit>
        <trans-unit id="6313dbb779b20ad4f398638fbcdaa19e63ee873e" translate="yes" xml:space="preserve">
          <source>For Comparison:</source>
          <target state="translated">Для сравнения:</target>
        </trans-unit>
        <trans-unit id="9a6955f50cd2bc2e9964cae7d37ac387cdbb56dc" translate="yes" xml:space="preserve">
          <source>For example, a deserialisation function might return a &lt;code&gt;List&lt;/code&gt;, but it doesn't know the list's element type. So &lt;code&gt;List&lt;/code&gt; is the appropriate return type here.</source>
          <target state="translated">Например, функция десериализации может возвращать &lt;code&gt;List&lt;/code&gt; , но она не знает тип элемента списка. Итак, &lt;code&gt;List&lt;/code&gt; является подходящим типом возврата здесь.</target>
        </trans-unit>
        <trans-unit id="e824bccb93fe388c271ceb20b71590f44f37ea03" translate="yes" xml:space="preserve">
          <source>For example, before Java generics was available, you would use a collection class like this:</source>
          <target state="translated">Например,до того,как Java generics был доступен,вы бы использовали класс коллекции,подобный этому:</target>
        </trans-unit>
        <trans-unit id="e68e2841763bad1c52ec9e83909704bd0166a574" translate="yes" xml:space="preserve">
          <source>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</source>
          <target state="translated">Например,для метода,в котором программист хочет,чтобы переменная List,называемая 'names',содержала только строки:</target>
        </trans-unit>
        <trans-unit id="35882b9379794132d1c5486b062c0880c7da27dd" translate="yes" xml:space="preserve">
          <source>Generics in Java are invariant. A &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, so the following would generate a compiler warning:</source>
          <target state="translated">Обобщения в Java инвариантны. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; не является &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; , поэтому следующее генерирует предупреждение компилятора:</target>
        </trans-unit>
        <trans-unit id="47bd8a7573789546aea546b52e9e17f8f529ba04" translate="yes" xml:space="preserve">
          <source>Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</source>
          <target state="translated">Generics,где придумали обойти это ограничение,разработчик объявлял бы хранимый тип один раз,а компилятор делал бы это вместо него.</target>
        </trans-unit>
        <trans-unit id="d4a604535de856a836d66ebc92fdb85bc5b349f1" translate="yes" xml:space="preserve">
          <source>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</source>
          <target state="translated">Учитывая,что не следует использовать сырые типы,почему языковые дизайнеры их разрешили? Чтобы обеспечить совместимость.</target>
        </trans-unit>
        <trans-unit id="8f83f0fc624d5c25c1d4070c5d15292bc4b6daf3" translate="yes" xml:space="preserve">
          <source>Here I am Considering multiple cases  through which you can clearify  the concept</source>
          <target state="translated">Здесь я рассматриваю несколько случаев,с помощью которых вы можете прояснить концепцию...</target>
        </trans-unit>
        <trans-unit id="7e44f900cff505560d3f89e716fe1e3c0fb1bb5f" translate="yes" xml:space="preserve">
          <source>Here's an example to illustrate:</source>
          <target state="translated">Вот пример для иллюстрации:</target>
        </trans-unit>
        <trans-unit id="dde31552770aa87ec22e55f9344569717d0b6871" translate="yes" xml:space="preserve">
          <source>Here's another case where raw types will bite you:</source>
          <target state="translated">Вот еще один случай,когда тебя укусят необработанные типы:</target>
        </trans-unit>
        <trans-unit id="67fa04e9f046a5adbebd5113ffaf92fe26a3311b" translate="yes" xml:space="preserve">
          <source>Here's another quote from JLS 4.8:</source>
          <target state="translated">Вот еще одна цитата из JLS 4.8:</target>
        </trans-unit>
        <trans-unit id="43637dfe4455ba4d2171e4f14f305298cd8cd98c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; is a &lt;em&gt;parameterized type&lt;/em&gt; (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt;). It is common to colloquially refer to this type as simply &lt;code&gt;MyType&lt;/code&gt; for short, but technically the name is &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; является &lt;em&gt;параметризованным типом&lt;/em&gt; ( &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt; ). Обычно этот &lt;code&gt;MyType&lt;/code&gt; называют просто MyType для краткости, но технически это имя &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44ce7e40d47187da08c05cca9611e28d52d1fa17" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; as a type parameter?</source>
          <target state="translated">Чем необработанный тип отличается от использования &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; В качестве параметра типа?</target>
        </trans-unit>
        <trans-unit id="0ed2484f8d50e469e79f1ef84d9f9bad64fc9188" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; as type parameters?</source>
          <target state="translated">Чем необработанный тип отличается от использования &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; в качестве параметров типа?</target>
        </trans-unit>
        <trans-unit id="48564f1fb0c047112af75c3e77e435ffab422e47" translate="yes" xml:space="preserve">
          <source>I found this page after doing some sample exercises and having the exact same puzzlement.</source>
          <target state="translated">Я нашел эту страницу после того,как сделал несколько пробных упражнений и имел точно такую же головоломку.</target>
        </trans-unit>
        <trans-unit id="748d8dd3315f134cfa40b10f3d5a0a2dff4020c9" translate="yes" xml:space="preserve">
          <source>If it's unsafe, why is it allowed to use a raw type?</source>
          <target state="translated">Если это небезопасно,почему разрешено использовать сырой тип?</target>
        </trans-unit>
        <trans-unit id="757cde53b1d07914c3de66734bfcb1a0d037c4db" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Если фактический аргумент типа опущен, вы создаете необработанный тип &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9aeb471379aedc5abe716fbf10b8294ce63c6335" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of Box:</source>
          <target state="translated">Если фактический аргумент типа опущен,вы создаете необработанный тип Box:</target>
        </trans-unit>
        <trans-unit id="0cc605baa568c21a2584d85b111e38c62a278623" translate="yes" xml:space="preserve">
          <source>If you had declared &lt;code&gt;appendNewObject&lt;/code&gt; to take a raw type &lt;code&gt;List&lt;/code&gt; as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</source>
          <target state="translated">Если бы вы объявили &lt;code&gt;appendNewObject&lt;/code&gt; , чтобы принимать необработанный тип &lt;code&gt;List&lt;/code&gt; в качестве параметра, тогда это скомпилировалось бы, и поэтому вы потеряли бы безопасность типов, которую вы получаете от обобщений.</target>
        </trans-unit>
        <trans-unit id="dd2d4a705143feb6d0a89160672246231005a289" translate="yes" xml:space="preserve">
          <source>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</source>
          <target state="translated">В общем,лучше параметризовать коллекции,чтобы у вас не было проблем с конвертацией,вы сможете добавлять только элементы параметризованного типа,а ваш редактор предложит вам подходящие методы для выбора.</target>
        </trans-unit>
        <trans-unit id="3744921c19e7629a4f01f2555627f746743882d4" translate="yes" xml:space="preserve">
          <source>In simpler terms, when a raw type is used, the constructors, instance methods and non-&lt;code&gt;static&lt;/code&gt; fields are &lt;em&gt;also erased&lt;/em&gt;.</source>
          <target state="translated">Проще говоря, когда используется необработанный тип, конструкторы, методы экземпляра и &lt;code&gt;static&lt;/code&gt; поля &lt;em&gt;также стираются&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="756666332aa7004e808286b5b848c619457b8b90" translate="yes" xml:space="preserve">
          <source>In summary, raw types should NEVER be used in new code. &lt;strong&gt;You should always use parameterized types&lt;/strong&gt;.</source>
          <target state="translated">Таким образом, необработанные типы никогда не должны использоваться в новом коде. &lt;strong&gt;Вы должны всегда использовать параметризованные типы&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b474182f196f28b6d9bc2a82197e85bb395fb460" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList arr&lt;/code&gt; is a raw type but your Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; is a Strict type.</source>
          <target state="translated">В этом случае &lt;code&gt;ArrayList arr&lt;/code&gt; является необработанным типом, но ваш Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; является строгим типом.</target>
        </trans-unit>
        <trans-unit id="f1c1ae68c9409c5f5812e26d3d923d56dab69ce2" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; is a strict type but your Object &lt;code&gt;new ArrayList();&lt;/code&gt; is a raw type.</source>
          <target state="translated">В этом случае &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; является строгим типом, но ваш Object &lt;code&gt;new ArrayList();&lt;/code&gt; это сырой тип.</target>
        </trans-unit>
        <trans-unit id="8c2f74dfe2af17f55f4ba29be8ccb19139a8d1f6" translate="yes" xml:space="preserve">
          <source>It is a Strict to &lt;code&gt;String&lt;/code&gt; not  a Raw Type so, It will never raise an warning .</source>
          <target state="translated">Это &lt;code&gt;String&lt;/code&gt; to String, а не необработанный тип, поэтому он никогда не выдаст предупреждение.</target>
        </trans-unit>
        <trans-unit id="af64c2b91282b2bc128075031a67b506f57156cd" translate="yes" xml:space="preserve">
          <source>It is possible to use as a type &lt;strong&gt;the erasure&lt;/strong&gt; of a parameterized type or the erasure of an array type whose element type is a parameterized type. &lt;strong&gt;Such a type is called a &lt;em&gt;raw type&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">В качестве типа можно использовать &lt;strong&gt;стирание&lt;/strong&gt; параметризованного типа или стирание типа массива, тип элемента которого является параметризованным типом. &lt;strong&gt;Такой тип называется &lt;em&gt;необработанным типом&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d69f46a16cf7ee0a31e5e918cb4caa8f4a361e8" translate="yes" xml:space="preserve">
          <source>It may be safer but took 4  hours to demuddle the philosophy...</source>
          <target state="translated">Может быть,это и безопаснее,но ушло 4 часа на то,чтобы разрушить философию...</target>
        </trans-unit>
        <trans-unit id="c7b6e70f29e6d47c95b4ce838419d160d7d44651" translate="yes" xml:space="preserve">
          <source>It will add any type of Object into it because &lt;code&gt;arr&lt;/code&gt; is a Raw Type.</source>
          <target state="translated">Он добавит в него любой тип объекта, потому что &lt;code&gt;arr&lt;/code&gt; является необработанным типом.</target>
        </trans-unit>
        <trans-unit id="7c357301ad31d5a2328f52fdfde2afee191052a2" translate="yes" xml:space="preserve">
          <source>JLS 4.8 Raw Types</source>
          <target state="translated">JLS 4.8 Сырые типы</target>
        </trans-unit>
        <trans-unit id="d96b21d482d675d54b9a9afda2b5ba4acaaf0b98" translate="yes" xml:space="preserve">
          <source>Java Tutorials/Generics</source>
          <target state="translated">Java-учебникиГенерика</target>
        </trans-unit>
        <trans-unit id="d9c140e4568d16dd9563d8ab811a377f394c3ad0" translate="yes" xml:space="preserve">
          <source>Just what is the difference between the raw type &lt;code&gt;List&lt;/code&gt; and the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; to a parameter of type &lt;code&gt;List&lt;/code&gt;, you can't pass it to a parameter of type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. There are subtyping rules for generics, and &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a subtype of the raw type &lt;code&gt;List&lt;/code&gt;, but not of the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. As a consequence, &lt;strong&gt;you lose type safety if you use raw type like &lt;code&gt;List&lt;/code&gt;, but not if you use a parameterized type like &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">В чем разница между необработанным типом &lt;code&gt;List&lt;/code&gt; и параметризованным типом &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; ? Грубо говоря, первый отказался от проверки универсального типа, а второй явно сказал компилятору, что он способен содержать объекты любого типа. Хотя вы можете передать &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; параметру типа &lt;code&gt;List&lt;/code&gt; , вы не можете передать его параметру типа &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; . Существуют правила подтипов для обобщений, и &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; является подтипом необработанного типа &lt;code&gt;List&lt;/code&gt; , но не параметризованного типа &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; . Как следствие, &lt;strong&gt;вы теряете безопасность типов, если используете необработанный тип, такой как &lt;code&gt;List&lt;/code&gt; , но не если вы используете параметризованный тип, например &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="850a74790dcd52d9b6cd99dd8612f5711bc8e124" translate="yes" xml:space="preserve">
          <source>More complex the Compareable interface:</source>
          <target state="translated">Более сложный интерфейс Сравнимый:</target>
        </trans-unit>
        <trans-unit id="dfdfd6745128ac64237078d81256b1a171bc2dd6" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to implement the &lt;code&gt;CompareAble&lt;/code&gt; interface with &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; with raw types.
Why you should not use them:</source>
          <target state="translated">Обратите внимание, что невозможно реализовать интерфейс &lt;code&gt;CompareAble&lt;/code&gt; с &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; с необработанными типами. Почему вы не должны использовать их:</target>
        </trans-unit>
        <trans-unit id="296b126e38fe8034587cb665417ce3c7024ae780" translate="yes" xml:space="preserve">
          <source>Note: Example.java uses unchecked or unsafe operations.</source>
          <target state="translated">Примечание:В примере.java используются неконтролируемые или небезопасные операции.</target>
        </trans-unit>
        <trans-unit id="3499d2ef5e16f0b55aee68466deae9940cc994c4" translate="yes" xml:space="preserve">
          <source>Note: Recompile with -Xlint:unchecked for details.</source>
          <target state="translated">Примечание:Перекомпилируйте с помощью -Xlint:unchecked для получения подробной информации.</target>
        </trans-unit>
        <trans-unit id="254f98057318b73a6885ac9033cf6c0a3f78cd90" translate="yes" xml:space="preserve">
          <source>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.</source>
          <target state="translated">Обратите внимание,что с дженериками вам не придется разыгрывать объект,пришедший от вызова get,коллекция предопределена только для работы с MyObject.Именно этот факт является основным движущим фактором для дженериков.Он превращает источник ошибок во время выполнения в то,что можно проверить во время компиляции.</target>
        </trans-unit>
        <trans-unit id="b6af0e34c6cc7075ebe7a4a3f42d6d402756c648" translate="yes" xml:space="preserve">
          <source>Now we run into trouble at run-time, because &lt;code&gt;names&lt;/code&gt; contains something that isn't an &lt;code&gt;instanceof String&lt;/code&gt;.</source>
          <target state="translated">Теперь мы сталкиваемся с проблемами во время выполнения, потому что &lt;code&gt;names&lt;/code&gt; содержат что-то, что не является &lt;code&gt;instanceof String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac370a883ec182a3baba7d9265d02ace81c41512" translate="yes" xml:space="preserve">
          <source>Of course, if you &lt;em&gt;DO&lt;/em&gt; want &lt;code&gt;names&lt;/code&gt; to allow a &lt;code&gt;Boolean&lt;/code&gt;, then you can declare it as &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt;, and the above code would compile.</source>
          <target state="translated">Конечно, если вы хотите, чтобы &lt;code&gt;names&lt;/code&gt; разрешали &lt;code&gt;Boolean&lt;/code&gt; , вы можете объявить его как &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt; , и приведенный выше код скомпилируется.</target>
        </trans-unit>
        <trans-unit id="5f3e174709eebda3c2a288755f4a44a380585674" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</source>
          <target state="translated">Первоначальный источник: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecee4396959b71721b4635fbfb006a7cc0e9a651" translate="yes" xml:space="preserve">
          <source>Presumably, if you want &lt;code&gt;names&lt;/code&gt; to contain only &lt;code&gt;String&lt;/code&gt;, you &lt;em&gt;could&lt;/em&gt; perhaps still use a raw type and &lt;em&gt;manually check every&lt;/em&gt;&lt;code&gt;add&lt;/code&gt; yourself, and then &lt;em&gt;manually cast&lt;/em&gt; to &lt;code&gt;String&lt;/code&gt; every item from &lt;code&gt;names&lt;/code&gt;. &lt;strong&gt;Even better&lt;/strong&gt;, though is NOT to use a raw type and &lt;em&gt;let the compiler do all the work for you&lt;/em&gt;, harnessing the power of Java generics.</source>
          <target state="translated">Предположительно, если вы хотите, чтобы &lt;code&gt;names&lt;/code&gt; содержали только &lt;code&gt;String&lt;/code&gt; , вы, возможно, &lt;em&gt;могли бы по-&lt;/em&gt; прежнему использовать необработанный тип и &lt;em&gt;вручную проверять каждое&lt;/em&gt; &lt;code&gt;add&lt;/code&gt; , а затем &lt;em&gt;вручную приводить&lt;/em&gt; к &lt;code&gt;String&lt;/code&gt; каждый элемент из &lt;code&gt;names&lt;/code&gt; . &lt;strong&gt;Еще лучше&lt;/strong&gt; , хотя НЕ использовать необработанный тип и &lt;em&gt;позволить компилятору сделать всю работу за вас&lt;/em&gt; , используя всю мощь Java-обобщений.</target>
        </trans-unit>
        <trans-unit id="7e63fc58ab6bfca9e67eebb8a65352e54e0fd330" translate="yes" xml:space="preserve">
          <source>Questions:</source>
          <target state="translated">Questions:</target>
        </trans-unit>
        <trans-unit id="14c39264748158f870d8f43c71ea7f51c1859672" translate="yes" xml:space="preserve">
          <source>Raw types are fine when they express what you want to express.</source>
          <target state="translated">Сырые типы прекрасно подходят,когда они выражают то,что вы хотите выразить.</target>
        </trans-unit>
        <trans-unit id="47f403e27f4c62d43a2933f83a0dd997ab56d1e0" translate="yes" xml:space="preserve">
          <source>Raw types refer to using a generic type without specifying a type parameter.</source>
          <target state="translated">Типы сырья относятся к использованию общего типа без указания параметра типа.</target>
        </trans-unit>
        <trans-unit id="f6709747af5a036dfca6571b0519116f90e0e9ec" translate="yes" xml:space="preserve">
          <source>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior &amp;mdash; a &lt;code&gt;Box&lt;/code&gt; gives you &lt;code&gt;Object&lt;/code&gt;s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</source>
          <target state="translated">Необработанные типы отображаются в устаревшем коде, потому что многие классы API (такие как классы Collections) не были универсальными до JDK 5.0. При использовании необработанных типов вы, по сути, получаете пре-родовое поведение - &lt;code&gt;Box&lt;/code&gt; дает вам &lt;code&gt;Object&lt;/code&gt; s . Для обратной совместимости допускается присвоение параметризованного типа его необработанному типу:</target>
        </trans-unit>
        <trans-unit id="5edab9471a19ae73475c8ed0622f2789a8bbd38d" translate="yes" xml:space="preserve">
          <source>Raw-type should not be used because it could cause runtime errors, like inserting a &lt;code&gt;double&lt;/code&gt; into what was supposed to be a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">Не следует использовать raw-тип, потому что он может вызвать ошибки во время выполнения, такие как вставка типа &lt;code&gt;double&lt;/code&gt; в то, что должно быть &lt;code&gt;Set&lt;/code&gt; &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b73c83827ddf3571b554094ecd15284c3d9f51ff" translate="yes" xml:space="preserve">
          <source>Raw-types are ancient history of the Java language. In the beginning there were &lt;code&gt;Collections&lt;/code&gt; and they held &lt;code&gt;Objects&lt;/code&gt; nothing more and nothing less. Every operation on &lt;code&gt;Collections&lt;/code&gt; required casts from &lt;code&gt;Object&lt;/code&gt; to the desired type.</source>
          <target state="translated">Raw-типы - это древняя история языка Java. В начале были &lt;code&gt;Collections&lt;/code&gt; и они держали &lt;code&gt;Objects&lt;/code&gt; не больше и не меньше. Каждая операция с &lt;code&gt;Collections&lt;/code&gt; требует преобразования &lt;code&gt;Object&lt;/code&gt; в нужный тип.</target>
        </trans-unit>
        <trans-unit id="fda027c268c4ae6152aa9f57c1dfaab8a4ae0670" translate="yes" xml:space="preserve">
          <source>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</source>
          <target state="translated">Перекомпиляция предыдущего примера с -Xlint:unchecked раскрывает следующую дополнительную информацию:</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">Возьмем следующий пример:</target>
        </trans-unit>
        <trans-unit id="29e893a5bedf20dc1b4e344373155ba8e5623141" translate="yes" xml:space="preserve">
          <source>The Java Language Specification defines a &lt;em&gt;raw type&lt;/em&gt; as follows:</source>
          <target state="translated">Спецификация языка Java определяет &lt;em&gt;необработанный тип&lt;/em&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="f03d888157a822dae6298c0edd4e09b264238529" translate="yes" xml:space="preserve">
          <source>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as &lt;em&gt;migration compatibility&lt;/em&gt;, drove the decision to support raw types.</source>
          <target state="translated">Платформа Java собиралась вступить во второе десятилетие, когда были представлены дженерики, и существовало огромное количество Java-кода, который не использовал дженерики. Было сочтено критически важным, чтобы весь этот код оставался легальным и совместимым с новым кодом, который использует дженерики. Должно быть допустимо передавать экземпляры параметризованных типов в методы, которые были разработаны для использования с обычными типами, и наоборот. Это требование, известное как &lt;em&gt;совместимость миграции&lt;/em&gt; , привело к принятию решения о поддержке необработанных типов.</target>
        </trans-unit>
        <trans-unit id="405919cad9921e0b63d1c1d0b23b75783e9838de" translate="yes" xml:space="preserve">
          <source>The Type Erasure section has more information on how the Java compiler uses raw types.</source>
          <target state="translated">В разделе Type Erasure вы найдёте больше информации о том,как компилятор Java использует необработанные типы.</target>
        </trans-unit>
        <trans-unit id="19cba934a6c7509721bb93f99ce5196844f697ea" translate="yes" xml:space="preserve">
          <source>The above code runs just fine, but suppose you also have the following:</source>
          <target state="translated">Вышеуказанный код работает просто отлично,но предположим,что у вас также есть следующее:</target>
        </trans-unit>
        <trans-unit id="ae33c93ae8545a049054d56f94b52ddadc4db2ff" translate="yes" xml:space="preserve">
          <source>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;! If you had declared the parameter as the raw type &lt;code&gt;List list&lt;/code&gt;, then the code would compile, and you'd violate the type invariant of &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt;.</source>
          <target state="translated">Компилятор прекрасно защитил вас от возможного нарушения неизменности типов в &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; ! Если бы вы объявили параметр как необработанный &lt;code&gt;List list&lt;/code&gt; типа List , то код скомпилировался бы, и вы нарушили бы инвариант типа &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51a5fbcc09ae553d5fd592ab6795f02eaba69382" translate="yes" xml:space="preserve">
          <source>The compiler wants you to write this:</source>
          <target state="translated">Компилятор хочет,чтобы ты написал это:</target>
        </trans-unit>
        <trans-unit id="0363d591375571e48f68366a7f025385874a4bc8" translate="yes" xml:space="preserve">
          <source>The erasure of the signature of a generic method has no type parameters.</source>
          <target state="translated">Стирание подписи общего метода не имеет параметров типа.</target>
        </trans-unit>
        <trans-unit id="4741487f156eaa93feddb499e8df578c72023c56" translate="yes" xml:space="preserve">
          <source>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-6400189&lt;/a&gt;. (In short, it makes the specification simpler.)</source>
          <target state="translated">В следующем отчете об ошибках содержатся некоторые соображения Маурицио Чимадамора, разработчика компилятора, и Алекса Бакли, одного из авторов JLS, о причинах такого поведения: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse / JDK-6400189&lt;/a&gt; . (Короче говоря, это упрощает спецификацию.)</target>
        </trans-unit>
        <trans-unit id="a9f82fe99578f6009d5eb0412ee1e187309afacb" translate="yes" xml:space="preserve">
          <source>The following is a quote from &lt;em&gt;Effective Java 2nd Edition, Item 23: Don't use raw types in new code&lt;/em&gt;:</source>
          <target state="translated">Ниже приводится цитата из &lt;em&gt;Effective Java 2nd Edition, пункт 23. Не используйте необработанные типы в новом коде&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="ba2996d73cdc2d5e8adf9bc06d73367a443e54a0" translate="yes" xml:space="preserve">
          <source>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.</source>
          <target state="translated">Старые бесшрифтовые коллекции не могли обеспечить безопасность типов,поэтому программист должен был помнить,что он хранил в коллекции.</target>
        </trans-unit>
        <trans-unit id="224867fabb32bca2e488d4f0445bcb8a5d12ece3" translate="yes" xml:space="preserve">
          <source>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.</source>
          <target state="translated">Предпочтительной альтернативой является использование универсальных классов по назначению - с подходящим аргументом типа (например, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; ). Это позволяет программисту более конкретно указывать типы, сообщает будущим разработчикам больше смысла о предполагаемом использовании переменной или структуры данных, а также позволяет компилятору обеспечивать лучшую безопасность типов. Вместе эти преимущества могут улучшить качество кода и помочь предотвратить появление некоторых ошибок кодирования.</target>
        </trans-unit>
        <trans-unit id="bdde1ec38079b0f21677aedb8ffed79d4ee40436" translate="yes" xml:space="preserve">
          <source>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</source>
          <target state="translated">Тип ссылки,который формируется путем взятия имени родового объявления типа без сопровождающего списка аргументов типа.</target>
        </trans-unit>
        <trans-unit id="7b95d6baee239d3ff4e3ced680ad026c49c8a6fa" translate="yes" xml:space="preserve">
          <source>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</source>
          <target state="translated">Супер-классы (соответственно,суперинтерфейсы)необработанного типа-это стирания супер-классов (супер-интерфейсов)любой из параметризаций общего типа.</target>
        </trans-unit>
        <trans-unit id="028dac7a1835527c760373499e5bd53972c19762" translate="yes" xml:space="preserve">
          <source>The term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.</source>
          <target state="translated">Термин &quot;unchecked&quot; означает,что компилятор не имеет достаточного количества информации о типах для выполнения всех проверок типов,необходимых для обеспечения безопасности типов.Предупреждение &quot;unchecked&quot; по умолчанию отключено,хотя компилятор дает подсказку.Чтобы увидеть все &quot;непроверенные&quot; предупреждения,перекомпилируйте их с помощью -Xlint:unchecked.</target>
        </trans-unit>
        <trans-unit id="1c1d40c286a32e79507bdccf064061a7398aec1e" translate="yes" xml:space="preserve">
          <source>The type of a constructor, instance method, or non-&lt;code&gt;static&lt;/code&gt; field of a raw type &lt;code&gt;C&lt;/code&gt; that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">Тип конструктора, метода экземпляра или &lt;code&gt;static&lt;/code&gt; поля необработанного типа &lt;code&gt;C&lt;/code&gt; , который не унаследован от его суперклассов или суперинтерфейсов, является необработанным типом, который соответствует стиранию его типа в общем объявлении, соответствующем &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4de2e6bc304bdcf427827a31f05067b528fb6ec7" translate="yes" xml:space="preserve">
          <source>The use of raw types is allowed only as a concession to compatibility of legacy code. &lt;em&gt;The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.&lt;/em&gt;</source>
          <target state="translated">Использование необработанных типов допускается только в качестве уступки совместимости устаревшего кода. &lt;em&gt;Использование необработанных типов в коде, написанном после введения универсальности в язык программирования Java, настоятельно не рекомендуется.&lt;/em&gt; &lt;em&gt;Вполне возможно, что будущие версии языка программирования Java будут запрещать использование необработанных типов.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38130b794559a4c9afe8f8b9c015c9dde8e522d2" translate="yes" xml:space="preserve">
          <source>The warning advises that types that are defined to support &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;generics&lt;/a&gt; should be parameterized, rather than using their raw form.</source>
          <target state="translated">Предупреждение предупреждает, что типы, которые определены для поддержки &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;обобщений,&lt;/a&gt; должны быть параметризованы, а не использовать их необработанную форму.</target>
        </trans-unit>
        <trans-unit id="66ca0326f80fbd6c5b5f545e591d10cb1a33c496" translate="yes" xml:space="preserve">
          <source>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</source>
          <target state="translated">Предупреждение показывает,что сырые типы обходят общие проверки типов,откладывая ловлю небезопасного кода на время выполнения.Поэтому следует избегать использования типов raw.</target>
        </trans-unit>
        <trans-unit id="26f6914ed49c5138e2d0f7911e928bb8bc17625c" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;Box&lt;/code&gt; is the raw type of the generic type &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. However, a non-generic class or interface type is not a raw type.</source>
          <target state="translated">Следовательно, &lt;code&gt;Box&lt;/code&gt; является необработанным типом универсального типа &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Однако неуниверсальный класс или тип интерфейса не является необработанным типом.</target>
        </trans-unit>
        <trans-unit id="00b4626a1162938da83e931c64651ef346add10f" translate="yes" xml:space="preserve">
          <source>They are less expressive, and don't self-document in the same way as parameterized types
&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">Они менее выразительны и не документируют себя так же, как параметризованные типы. &lt;strong&gt;Пример&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebc27a91176efcbb20410934abb5853c0008136" translate="yes" xml:space="preserve">
          <source>They aren't type safe, and some important kinds of errors will only appear at runtime</source>
          <target state="translated">Они не безопасны для ввода,и некоторые важные виды ошибок будут появляться только во время исполнения.</target>
        </trans-unit>
        <trans-unit id="1e9dd9b1ece7f9d0090b47a3a8306fdc209f6a95" translate="yes" xml:space="preserve">
          <source>They usually require casts</source>
          <target state="translated">Обычно для них требуются слепки</target>
        </trans-unit>
        <trans-unit id="5873e20d029e66a8c51641dd8139270aaedf4381" translate="yes" xml:space="preserve">
          <source>This can happen when using an older API that operates on raw types, as shown in the following example:</source>
          <target state="translated">Это может произойти при использовании более старого API,работающего с типами raw,как показано в следующем примере:</target>
        </trans-unit>
        <trans-unit id="75bbc98951486b296100d29e447bb2550f22a5bd" translate="yes" xml:space="preserve">
          <source>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the &lt;code&gt;CompareAble&lt;/code&gt; interface, I guess that it creates two &lt;code&gt;compareTo&lt;/code&gt; functions, one taking a &lt;code&gt;MyCompareAble&lt;/code&gt; and the other taking an &lt;code&gt;Object&lt;/code&gt; and passing it to the first after casting it.</source>
          <target state="translated">Это тот же код, который вы написали бы, если бы использовали непосредственные типы. &lt;code&gt;CompareAble&lt;/code&gt; я не уверен, что происходит с интерфейсом CompareAble , я предполагаю, что он создает две функции &lt;code&gt;MyCompareAble&lt;/code&gt; , одна из которых берет MyCompareAble, а другая берет &lt;code&gt;Object&lt;/code&gt; и передает его первому после его приведения.</target>
        </trans-unit>
        <trans-unit id="766f0ea717ddd326371c9d9cdc14d6d42b78ca3d" translate="yes" xml:space="preserve">
          <source>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; annotation suppresses unchecked warnings. If you are unfamiliar with the &lt;code&gt;@SuppressWarnings&lt;/code&gt; syntax, see Annotations.</source>
          <target state="translated">Чтобы полностью отключить непроверенные предупреждения, используйте флаг -Xlint: -unchecked. &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; подавляет непроверенные предупреждения. Если вы не знакомы с синтаксисом &lt;code&gt;@SuppressWarnings&lt;/code&gt; , см. Аннотации.</target>
        </trans-unit>
        <trans-unit id="80251fc31dcb833fa8957ce6961b665392d800db" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, you supply an actual type argument for the formal type parameter &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Чтобы создать параметризованный тип &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , вы предоставляете фактический аргумент типа для параметра формального типа &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="738e743b4a29658389df8f72c91705203651edac" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:</source>
          <target state="translated">Для создания параметризованного типа Box,вы предоставляете фактический аргумент типа для формального параметра типа T:</target>
        </trans-unit>
        <trans-unit id="2e0d2fd5cc02c819f4b51dbe7cb93f09af65fbd8" translate="yes" xml:space="preserve">
          <source>To illustrate the point, consider the following method which takes a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; and appends a &lt;code&gt;new Object()&lt;/code&gt;.</source>
          <target state="translated">Чтобы проиллюстрировать это, рассмотрим следующий метод, который берет &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; и добавляет &lt;code&gt;new Object()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="556b94a170a618efa12635f0635c19579ef283b9" translate="yes" xml:space="preserve">
          <source>Unchecked Error Messages</source>
          <target state="translated">Непроверенные сообщения об ошибках</target>
        </trans-unit>
        <trans-unit id="1488eddd4ac4e26c448d84102357cfa845ad5972" translate="yes" xml:space="preserve">
          <source>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</source>
          <target state="translated">К сожалению,из-за того,что Java-генерики не редуцируются,есть два исключения,где в новом коде должны использоваться сырые типы:</target>
        </trans-unit>
        <trans-unit id="1e5e7d3116ebd3de1a83a1241dab9045f1ec61bf" translate="yes" xml:space="preserve">
          <source>Using generics enables compile time checks</source>
          <target state="translated">Использование дженериков позволяет проводить проверку времени компиляции</target>
        </trans-unit>
        <trans-unit id="c633498ea9a29fa72a0bbecb71a9da972a698387" translate="yes" xml:space="preserve">
          <source>Using generics, you remove the &quot;unknown&quot; factor, because you must explicitly specify which type of objects can go in the list:</source>
          <target state="translated">Используя дженерики,вы удаляете &quot;неизвестный&quot; фактор,потому что вы должны явно указать,какой тип объектов может идти в списке:</target>
        </trans-unit>
        <trans-unit id="374c5fd146735c599512bad185fd1451f407b63e" translate="yes" xml:space="preserve">
          <source>Using raw types is the same as storing each value as &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">Использование необработанных типов аналогично сохранению каждого значения как &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eab2ae60ad80fc1f68d0fef0fa0d1c390dad5ca0" translate="yes" xml:space="preserve">
          <source>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</source>
          <target state="translated">Что такое сырые типы в Java,и почему я часто слышу,что их не следует использовать в новом коде?</target>
        </trans-unit>
        <trans-unit id="30ee936b3a2d7e626d1240eed0e0228cdf2781b3" translate="yes" xml:space="preserve">
          <source>What are the alternatives to raw types: Use &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;generics&lt;/a&gt;</source>
          <target state="translated">Какие альтернативы необработанным типам: Используйте &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;дженерики&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13e18159e991cbf27833d847ecb850a6500c5b60" translate="yes" xml:space="preserve">
          <source>What is a raw type and why shouldn't we use it</source>
          <target state="translated">Что такое сырой тип,и почему бы нам не использовать его...</target>
        </trans-unit>
        <trans-unit id="d33f524f99b128a863eea8abf8b22cdb547ff070" translate="yes" xml:space="preserve">
          <source>What is a raw type?</source>
          <target state="translated">Что такое сырой тип?</target>
        </trans-unit>
        <trans-unit id="0c94f16920c76542bf263ada24624cb0b28ce1fd" translate="yes" xml:space="preserve">
          <source>What is saying is that your &lt;code&gt;list&lt;/code&gt; is a &lt;code&gt;List&lt;/code&gt; of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</source>
          <target state="translated">Что говорит о том, что ваш &lt;code&gt;list&lt;/code&gt; является &lt;code&gt;List&lt;/code&gt; неуказанных объектов. То есть Java не знает, какие объекты находятся внутри списка. Затем, когда вы хотите перебрать список, вы должны привести каждый элемент, чтобы иметь доступ к свойствам этого элемента (в данном случае, String).</target>
        </trans-unit>
        <trans-unit id="fdeab1d68011a57fce4cd4ba9f9c74abe4ff5bea" translate="yes" xml:space="preserve">
          <source>What is the alternative if we can't use raw types, and how is it better?</source>
          <target state="translated">Какая альтернатива,если мы не можем использовать сырые типы,и как это лучше?</target>
        </trans-unit>
        <trans-unit id="7e187deccee3bced2f61d49a1c4f1805a24f3514" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">В чем разница между &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2000b4089ba1692a89afa72ea69f43fb13328c31" translate="yes" xml:space="preserve">
          <source>What the compiler does:
Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</source>
          <target state="translated">Что делает компилятор:Генерики обратно совместимы,они используют те же java-классы,что и необработанные типы.Волшебство происходит в основном во время компиляции.</target>
        </trans-unit>
        <trans-unit id="4f8e701743ca8556df10918c1399924693590de0" translate="yes" xml:space="preserve">
          <source>What's so special about raw types?</source>
          <target state="translated">Что такого особенного в сырых типах?</target>
        </trans-unit>
        <trans-unit id="c0bec40361472ae5df662e245af72cd245cacb6e" translate="yes" xml:space="preserve">
          <source>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java. Although using raw types is still possible,</source>
          <target state="translated">Когда дженерики были введены в JDK 1.5,сырые типы были сохранены только для поддержания обратной совместимости со старыми версиями Java.Хотя использование raw-типов все еще возможно,</target>
        </trans-unit>
        <trans-unit id="07f051d6fc7fc8fbf515fd0cd3c1f563cb40b271" translate="yes" xml:space="preserve">
          <source>When retrieving the stuff from the &lt;code&gt;Set&lt;/code&gt;, you don't know what is coming out. Let's assume that you expect it to be all &lt;code&gt;int&lt;/code&gt;s, you are casting it to &lt;code&gt;Integer&lt;/code&gt;; exception at runtime when the &lt;code&gt;double&lt;/code&gt; 3.45 comes along.</source>
          <target state="translated">При извлечении материала из &lt;code&gt;Set&lt;/code&gt; вы не знаете, что выходит. Давайте предположим, что вы ожидаете, что все это будет &lt;code&gt;int&lt;/code&gt; , вы приводите его к &lt;code&gt;Integer&lt;/code&gt; ; исключение во время выполнения, когда появляется &lt;code&gt;double&lt;/code&gt; 3.45.</target>
        </trans-unit>
        <trans-unit id="229813f4d96b2d1b1f45b96f3d4597193f7d55d2" translate="yes" xml:space="preserve">
          <source>When we use the raw &lt;code&gt;MyType&lt;/code&gt;, &lt;code&gt;getNames&lt;/code&gt; becomes erased as well, so that it returns a raw &lt;code&gt;List&lt;/code&gt;!</source>
          <target state="translated">Когда мы используем сырой &lt;code&gt;MyType&lt;/code&gt; , &lt;code&gt;getNames&lt;/code&gt; также удаляется, так что он возвращает сырой &lt;code&gt;List&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="03b03c443a4d1bf6d6fc2a3db1b553df7f30657f" translate="yes" xml:space="preserve">
          <source>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</source>
          <target state="translated">Когда вы добавляете свой объект в список,ему все равно,какой это тип объекта,и когда вы получаете его из списка,вы должны явно привести его к тому типу,который вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="c740556a6d482ca7b34342229dd689c7478cd44e" translate="yes" xml:space="preserve">
          <source>While this worked most of the time, errors did happen</source>
          <target state="translated">В то время как это работало большую часть времени,ошибки все же случались.</target>
        </trans-unit>
        <trans-unit id="f1d1a366a93b477706dd8b3d6105c9c1a9eeba6a" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; Illegal?</source>
          <target state="translated">Почему &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; незаконна?</target>
        </trans-unit>
        <trans-unit id="1719e030f1ab15bdc53d7b641986ffbe8aab10b1" translate="yes" xml:space="preserve">
          <source>Will be compiled as:</source>
          <target state="translated">Будет составлено как:</target>
        </trans-unit>
        <trans-unit id="dee4689d8bcf66596d11372b703adb5272094959" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;type parameter&lt;/em&gt; added to your &lt;code&gt;Set&lt;/code&gt;, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</source>
          <target state="translated">С &lt;em&gt;параметром типа,&lt;/em&gt; добавленным в ваш &lt;code&gt;Set&lt;/code&gt; , вы сразу получите ошибку компиляции. Эта упреждающая ошибка позволяет вам исправить проблему до того, как что-то взорвется во время выполнения (тем самым сэкономив время и усилия).</target>
        </trans-unit>
        <trans-unit id="a7d70712fc20b205ca2cc8c4b74bad333f629980" translate="yes" xml:space="preserve">
          <source>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</source>
          <target state="translated">Вы также получаете предупреждение,если используете необработанный тип для вызова общих методов,определенных в соответствующем общем типе:</target>
        </trans-unit>
        <trans-unit id="197389cd6f3b37b3190a3a6a52add9e46a256131" translate="yes" xml:space="preserve">
          <source>You should specify the type-parameter.</source>
          <target state="translated">Необходимо указать типовой параметр.</target>
        </trans-unit>
        <trans-unit id="1ac174dc270f36327a0a027750b18bebbfaf4d7a" translate="yes" xml:space="preserve">
          <source>because otherwise, you could add any type you like into &lt;code&gt;list&lt;/code&gt;, making the instantiation as &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; pointless. Java generics are a compile-time feature only, so an object created with &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; will happily accept &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;JFrame&lt;/code&gt; elements if assigned to a reference of the &quot;raw type&quot; &lt;code&gt;List&lt;/code&gt; - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</source>
          <target state="translated">потому что в противном случае вы можете добавить в &lt;code&gt;list&lt;/code&gt; любой понравившийся вам тип, что делает бессмысленным создание &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; экземпляров ArrayList &amp;lt;String&amp;gt; () . Обобщения Java являются только функцией времени компиляции, поэтому объект, созданный с помощью &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; , с радостью примет элементы &lt;code&gt;Integer&lt;/code&gt; или &lt;code&gt;JFrame&lt;/code&gt; , если ему присвоить ссылку на список &amp;laquo;необработанного типа&amp;raquo; - сам объект ничего не знает о том, какие типы он должен содержать только компилятор.</target>
        </trans-unit>
        <trans-unit id="ea7878de5b8eeb89d003e785fa175fd505a012b3" translate="yes" xml:space="preserve">
          <source>here &lt;code&gt;arr&lt;/code&gt; is a Strict type. So, It will raise compile time error when adding a &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">здесь &lt;code&gt;arr&lt;/code&gt; является строгим типом. Таким образом, это приведет к ошибке времени компиляции при добавлении &lt;code&gt;integer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2927dfb347fedd73a36f6f620a3aae2975129af7" translate="yes" xml:space="preserve">
          <source>java generics (not) covariance</source>
          <target state="translated">ява дженерики (не)ковариация</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
