<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2770321">
    <body>
      <group id="2770321">
        <trans-unit id="9bb688abe7c73fe83082a7942e2afa010b95bd2e" translate="yes" xml:space="preserve">
          <source>&quot;Raw types&quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</source>
          <target state="translated">&quot;原始类型 &quot;是为了向后兼容而使用的。不建议在新代码中使用这些类型,因为使用带有类型参数的通用类可以使类型化更强,这反过来又可以提高代码的可理解性,从而更早地发现潜在的问题。</target>
        </trans-unit>
        <trans-unit id="5e202a8885e8f2a0b0b18f657d2d758c8387e684" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; continues to explain the following:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt;继续解释以下内容：</target>
        </trans-unit>
        <trans-unit id="9bcbbc30c3a268dc93ee0fcdcac237b04fa72318" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;tutorial page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;教程页面&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5eeaf258c2f69574da220e548fe8afb66742168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; it is a &lt;code&gt;ArrayList&lt;/code&gt; reference variable with type &lt;code&gt;String&lt;/code&gt; which reference to a &lt;code&gt;ArralyList&lt;/code&gt; Object of Type &lt;code&gt;String&lt;/code&gt;. It means it can hold only String type Object.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; 它是类型为 &lt;code&gt;String&lt;/code&gt; 的 &lt;code&gt;ArrayList&lt;/code&gt; 引用变量，它引用类型为String的 &lt;code&gt;ArralyList&lt;/code&gt; 对象。 这意味着它只能容纳String类型的Object。</target>
        </trans-unit>
        <trans-unit id="5b6476b68a8bec6fe2c018b1e2dce00d036d2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, etc are all &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;, so it may be tempting to just say that they're just &lt;code&gt;List&lt;/code&gt; instead. However, there is a major difference: since a &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; defines only &lt;code&gt;add(E)&lt;/code&gt;, you can't add just any arbitrary object to a &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;. On the other hand, since the raw type &lt;code&gt;List&lt;/code&gt; does not have type safety, you can &lt;code&gt;add&lt;/code&gt; just about anything to a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; ， &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 等都是 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; ，因此可能会很想说它们只是 &lt;code&gt;List&lt;/code&gt; 而已。 但是，有一个主要区别：由于 &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; 仅定义 &lt;code&gt;add(E)&lt;/code&gt; ，因此您不能仅将任意对象添加到 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 。 另一方面，由于原始类型 &lt;code&gt;List&lt;/code&gt; 没有类型安全性，因此您几乎可以 &lt;code&gt;add&lt;/code&gt; 任何内容添加到 &lt;code&gt;List&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="c965c3b6097bff5c3d5f7d3ca7b09048dacbe93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&lt;/code&gt; is defined to support generics: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt;. This allows many type-safe operations, that are checked compile-time.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; 被定义为支持泛型： &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt; 。 这允许在编译时检查许多类型安全的操作。</target>
        </trans-unit>
        <trans-unit id="29a69c16f89c3fd935dd606a5d4b3dbdabe380d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MyType.Nested&lt;/code&gt; is not a parameterized type, even though it's a member type of a parameterized type &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;, because it's &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MyType.Nested&lt;/code&gt; 不是参数化类型，即使它是参数化类型 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; 的成员类型，因为它是 &lt;code&gt;static&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f052ee67a2af0dd5f9f4bd5d42450f8187a17d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; operand, e.g. &lt;code&gt;o instanceof Set&lt;/code&gt;, not &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 操作数，例如 &lt;code&gt;o instanceof Set&lt;/code&gt; ，而不是 &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3aa367113494aa1a8fa752010519a9dd14831d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt1&lt;/code&gt;, and &lt;code&gt;mt2&lt;/code&gt; are both declared with actual type parameters, so they're not raw types.</source>
          <target state="translated">&lt;code&gt;mt1&lt;/code&gt; 和 &lt;code&gt;mt2&lt;/code&gt; 都使用实际的类型参数声明，因此它们不是原始类型。</target>
        </trans-unit>
        <trans-unit id="c778f211d4f54dd9219432d85be2ae77c19c5d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt&lt;/code&gt; has a raw type (and generates a compilation warning) by the first bullet point in the above definition; &lt;code&gt;inn&lt;/code&gt; also has a raw type by the third bullet point.</source>
          <target state="translated">&lt;code&gt;mt&lt;/code&gt; 在上述定义的第一个要点之前具有原始类型（并生成编译警告）； &lt;code&gt;inn&lt;/code&gt; 在第三个要点之前也具有原始类型。</target>
        </trans-unit>
        <trans-unit id="bcbfd569522fe96225142a9dbce9d9b99256d6ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Effective Java 2nd Edition&lt;/em&gt; also has this to add:</source>
          <target state="translated">&lt;em&gt;有效的Java 2nd Edition&lt;/em&gt;也要添加以下内容：</target>
        </trans-unit>
        <trans-unit id="06c568b39defa968eaf6d417143a99d437431f20" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For example&lt;/em&gt;,</source>
          <target state="translated">&lt;em&gt;例如&lt;/em&gt; ，</target>
        </trans-unit>
        <trans-unit id="3120d5d3ec33fa18134615010180259f358798d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is a raw type and why do I often hear that they shouldn't be used in new code?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;什么是原始类型？为什么我经常听到它们不应该在新代码中使用？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd279a8439dba2e5fdaf708d98b1db46ee00ff1e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the alternative if we can't use raw types, and how is it better?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果我们不能使用原始类型，那有什么选择呢？有什么更好的选择？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b80e7105e2584ff1d4ed97bfe515dcd23c4b2311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[...]&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e42a4f633bcd32dbe51455ca6bdd7612a294cb1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid raw types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;避免原始类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e599fb38e4978d9cad0bf8657fc35335efcaf1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For reference&lt;/strong&gt;: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;供参考&lt;/strong&gt; ： &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https&lt;/a&gt; : //docs.oracle.com/javase/tutorial/java/generics/rawTypes.html</target>
        </trans-unit>
        <trans-unit id="6c5165c71ee10325066370d72c5f9a39d27bb232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果删除方法或构造函数的签名，则方法的返回类型以及通用方法或构造函数的类型参数也会被擦除。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4311a85106cdf76087c5d49e5214fd1bb252ec93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They should be avoided&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;应该避免它们&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f0d740fb2f9099a842f154be27e6d2d6ade17b18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.&lt;/strong&gt; The erasure of a constructor or method signature &lt;code&gt;s&lt;/code&gt; is a signature consisting of the same name as &lt;code&gt;s&lt;/code&gt; and the erasures of all the formal parameter types given in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;类型擦除还将映射构造函数或方法的签名到没有参数化类型或类型变量的签名。&lt;/strong&gt; 删除构造函数或方法签名 &lt;code&gt;s&lt;/code&gt; 是由与 &lt;code&gt;s&lt;/code&gt; 相同的名称以及s中给出的所有形式参数类型的擦除组成的签名。</target>
        </trans-unit>
        <trans-unit id="365cf8a2d2c5f7bc6bd0f00615a2382dd4286f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Raw&lt;/code&gt; Type Object is referenced to a &lt;code&gt;Strict&lt;/code&gt; type Referenced Variable of &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：- &lt;code&gt;Raw&lt;/code&gt; 类型对象被引用为 &lt;code&gt;ArrayList&lt;/code&gt; 的 &lt;code&gt;Strict&lt;/code&gt; 类型引用变量。</target>
        </trans-unit>
        <trans-unit id="5f5cf18f48861714cd2c12682318f23cca1637eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Strict&lt;/code&gt; Type Object is referenced to a &lt;code&gt;raw&lt;/code&gt; type referenced Variable.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：- &lt;code&gt;Strict&lt;/code&gt; 类型对象引用到 &lt;code&gt;raw&lt;/code&gt; 类型引用的变量。</target>
        </trans-unit>
        <trans-unit id="90a252e2d44f3f2a8b1890033755001338955145" translate="yes" xml:space="preserve">
          <source>============== I went from this code as provide by the sample ===============</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2eab9097b3ec971d127fbaff91ee92679421cbf" translate="yes" xml:space="preserve">
          <source>====================== To This code ========================</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a19b8e149aed7175b12239c8772988575617b7c" translate="yes" xml:space="preserve">
          <source>A &quot;raw type&quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using &lt;code&gt;List&lt;/code&gt; instead of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a &quot;raw type&quot; (without specifying a type argument) allowed legacy code to still compile.</source>
          <target state="translated">&amp;ldquo;原始类型&amp;rdquo;是通用类的使用，而没有为其参数化类型指定类型实参，例如，使用 &lt;code&gt;List&lt;/code&gt; 而不是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 。 当将泛型引入Java时，几个类已更新为使用泛型。 将这些类用作&amp;ldquo;原始类型&amp;rdquo;（不指定类型实参）允许遗留代码继续编译。</target>
        </trans-unit>
        <trans-unit id="33ba04d196a3008973ddc2524394442fa33e4d49" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; type in Java is a class which is non-generic and deals with &quot;raw&quot; Objects, rather than type-safe generic type parameters.</source>
          <target state="translated">在Java中,&quot;原始 &quot;类型是一个非通用的类,它处理的是 &quot;原始 &quot;对象,而不是类型安全的通用类型参数。</target>
        </trans-unit>
        <trans-unit id="c99659ce7dbf112bd14117c16ebbd8db3d175959" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;raw&lt;/em&gt;-type is the a lack of a &lt;em&gt;type parameter&lt;/em&gt; when using a generic type.</source>
          <target state="translated">&lt;em&gt;原始&lt;/em&gt;类型是在使用泛型类型时缺少&lt;em&gt;类型参数&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a826d4198daa01070b87640f459ca71ec283ab02" translate="yes" xml:space="preserve">
          <source>A list is a raw type, while &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a parameterized type.</source>
          <target state="translated">列表是原始类型，而 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 是参数化类型。</target>
        </trans-unit>
        <trans-unit id="f8572ed900bc3ec607e2c608d6c9250f0ee36db6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; member type of a raw type &lt;code&gt;R&lt;/code&gt; that is not inherited from a superclass or superinterface of &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">原始类型 &lt;code&gt;R&lt;/code&gt; 的非 &lt;code&gt;static&lt;/code&gt; 成员类型，该成员类型不继承自 &lt;code&gt;R&lt;/code&gt; 的超类或超接口。</target>
        </trans-unit>
        <trans-unit id="6a5287cb23f3eeae5edf828005202ed23e61a642" translate="yes" xml:space="preserve">
          <source>A raw type is defined to be one of:</source>
          <target state="translated">原始类型被定义为:</target>
        </trans-unit>
        <trans-unit id="205748e8c233f71145a1f2bd274309746828335f" translate="yes" xml:space="preserve">
          <source>A raw type is the erasure of that type</source>
          <target state="translated">原始类型是对该类型的擦除。</target>
        </trans-unit>
        <trans-unit id="6a29e532dca4388e029fb3ea7d50673d5d01e2fd" translate="yes" xml:space="preserve">
          <source>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</source>
          <target state="translated">原始类型是一个没有任何类型参数的通用类或接口的名称。例如,给定一个通用的Box类。</target>
        </trans-unit>
        <trans-unit id="8845a4e3b681a7b8affa2bfb6f73c348d4d14738" translate="yes" xml:space="preserve">
          <source>An array type whose element type is a raw type.</source>
          <target state="translated">元素类型为原始类型的数组类型。</target>
        </trans-unit>
        <trans-unit id="aca82bd9f96a2ad182aa1d73db0796bc4f782989" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Object&lt;/code&gt; stored in a &lt;code&gt;Collection&lt;/code&gt; has to be cast before it can be used</source>
          <target state="translated">&lt;code&gt;Collection&lt;/code&gt; 存储的任何 &lt;code&gt;Object&lt;/code&gt; 都必须先进行投射，然后才能使用</target>
        </trans-unit>
        <trans-unit id="7d029af1223f081b1921aa7f94ee3bf1b6d1d8ad" translate="yes" xml:space="preserve">
          <source>Are there no exceptions?</source>
          <target state="translated">难道就没有例外吗?</target>
        </trans-unit>
        <trans-unit id="340c1df6af27884fb6eb161fdf86234b7c9f6b06" translate="yes" xml:space="preserve">
          <source>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</source>
          <target state="translated">如前所述,当传统代码与通用代码混合时,你可能会遇到类似以下的警告信息。</target>
        </trans-unit>
        <trans-unit id="5c59276c92cf37b7805c3861f7c5d5b2178bb735" translate="yes" xml:space="preserve">
          <source>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just &lt;code&gt;Object&lt;/code&gt;).</source>
          <target state="translated">如已接受的答案中所述，您将在原始类型的代码中失去对泛型的所有支持。 每个类型参数都将转换为其擦除（在上面的示例中只是 &lt;code&gt;Object&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="54ed0f30909fe006459ed6df04d66c2798441b16" translate="yes" xml:space="preserve">
          <source>Back to JLS 4.8:</source>
          <target state="translated">返回到JLS 4.8。</target>
        </trans-unit>
        <trans-unit id="6b592f4fe7b7afd4d7a2840c62e109cd230efddb" translate="yes" xml:space="preserve">
          <source>But if you assign a raw type to a parameterized type, you get a warning:</source>
          <target state="translated">但是如果你把一个原始类型分配给一个参数化类型,你会得到一个警告。</target>
        </trans-unit>
        <trans-unit id="03b28b2417326b91d54010c203487876d052c1ec" translate="yes" xml:space="preserve">
          <source>Case 1</source>
          <target state="translated">案例1</target>
        </trans-unit>
        <trans-unit id="ee1189515944c7f281c8f48e390364b2fc748d15" translate="yes" xml:space="preserve">
          <source>Case 2</source>
          <target state="translated">案例2</target>
        </trans-unit>
        <trans-unit id="16024e7ee398804bd61c244d6dfbc1dea703c6c9" translate="yes" xml:space="preserve">
          <source>Case 3</source>
          <target state="translated">案例3</target>
        </trans-unit>
        <trans-unit id="5928bc5d24ccc7a0cbc69187317ba17c2da6578c" translate="yes" xml:space="preserve">
          <source>Class literals, e.g. &lt;code&gt;List.class&lt;/code&gt;, not &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</source>
          <target state="translated">类文字，例如 &lt;code&gt;List.class&lt;/code&gt; ，而不是 &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="037a786100af58ee1da0c90e38df1f04d615f726" translate="yes" xml:space="preserve">
          <source>Consider the following variation of the previous snippet:</source>
          <target state="translated">考虑以下是前一段的变体:</target>
        </trans-unit>
        <trans-unit id="a34e95f456c0661699837d4636ebb3f2edebde4e" translate="yes" xml:space="preserve">
          <source>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</source>
          <target state="translated">从本质上说,原始类型的行为就像通用类型出现之前一样。也就是说,在编译的时候,以下这些类型是完全合法的。</target>
        </trans-unit>
        <trans-unit id="6313dbb779b20ad4f398638fbcdaa19e63ee873e" translate="yes" xml:space="preserve">
          <source>For Comparison:</source>
          <target state="translated">为了比较。</target>
        </trans-unit>
        <trans-unit id="9a6955f50cd2bc2e9964cae7d37ac387cdbb56dc" translate="yes" xml:space="preserve">
          <source>For example, a deserialisation function might return a &lt;code&gt;List&lt;/code&gt;, but it doesn't know the list's element type. So &lt;code&gt;List&lt;/code&gt; is the appropriate return type here.</source>
          <target state="translated">例如，反序列化函数可能返回 &lt;code&gt;List&lt;/code&gt; ，但它不知道列表的元素类型。 所以 &lt;code&gt;List&lt;/code&gt; 是这里合适的返回类型。</target>
        </trans-unit>
        <trans-unit id="e824bccb93fe388c271ceb20b71590f44f37ea03" translate="yes" xml:space="preserve">
          <source>For example, before Java generics was available, you would use a collection class like this:</source>
          <target state="translated">例如,在Java通用类出现之前,你会使用这样的集合类。</target>
        </trans-unit>
        <trans-unit id="e68e2841763bad1c52ec9e83909704bd0166a574" translate="yes" xml:space="preserve">
          <source>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</source>
          <target state="translated">例如,对于一个方法,程序员希望确保名为 &quot;names &quot;的List变量只包含Strings。</target>
        </trans-unit>
        <trans-unit id="35882b9379794132d1c5486b062c0880c7da27dd" translate="yes" xml:space="preserve">
          <source>Generics in Java are invariant. A &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, so the following would generate a compiler warning:</source>
          <target state="translated">Java中的泛型是不变的。 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 不是 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; ，因此以下内容将生成编译器警告：</target>
        </trans-unit>
        <trans-unit id="47bd8a7573789546aea546b52e9e17f8f529ba04" translate="yes" xml:space="preserve">
          <source>Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</source>
          <target state="translated">为了绕开这个限制,开发者会声明一次存储类型,然后由编译器来完成。</target>
        </trans-unit>
        <trans-unit id="d4a604535de856a836d66ebc92fdb85bc5b349f1" translate="yes" xml:space="preserve">
          <source>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</source>
          <target state="translated">既然你不应该使用原始类型,为什么语言设计者要允许它们?为了提供兼容性。</target>
        </trans-unit>
        <trans-unit id="8f83f0fc624d5c25c1d4070c5d15292bc4b6daf3" translate="yes" xml:space="preserve">
          <source>Here I am Considering multiple cases  through which you can clearify  the concept</source>
          <target state="translated">在这里,我考虑了多个案例,通过这些案例可以明确概念</target>
        </trans-unit>
        <trans-unit id="7e44f900cff505560d3f89e716fe1e3c0fb1bb5f" translate="yes" xml:space="preserve">
          <source>Here's an example to illustrate:</source>
          <target state="translated">下面举个例子来说明。</target>
        </trans-unit>
        <trans-unit id="dde31552770aa87ec22e55f9344569717d0b6871" translate="yes" xml:space="preserve">
          <source>Here's another case where raw types will bite you:</source>
          <target state="translated">这里是另一种情况,生的类型会咬你。</target>
        </trans-unit>
        <trans-unit id="67fa04e9f046a5adbebd5113ffaf92fe26a3311b" translate="yes" xml:space="preserve">
          <source>Here's another quote from JLS 4.8:</source>
          <target state="translated">下面是JLS 4.8中的另一句话。</target>
        </trans-unit>
        <trans-unit id="43637dfe4455ba4d2171e4f14f305298cd8cd98c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; is a &lt;em&gt;parameterized type&lt;/em&gt; (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt;). It is common to colloquially refer to this type as simply &lt;code&gt;MyType&lt;/code&gt; for short, but technically the name is &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; 是&lt;em&gt;参数化类型&lt;/em&gt; （ &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt; ）。 通常将这种类型简称为 &lt;code&gt;MyType&lt;/code&gt; ，但从技术上来说，名称为 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44ce7e40d47187da08c05cca9611e28d52d1fa17" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; as a type parameter?</source>
          <target state="translated">原始类型与使用 &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 作为类型参数有何不同？</target>
        </trans-unit>
        <trans-unit id="0ed2484f8d50e469e79f1ef84d9f9bad64fc9188" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; as type parameters?</source>
          <target state="translated">原始类型与使用 &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; 作为类型参数有何不同？</target>
        </trans-unit>
        <trans-unit id="48564f1fb0c047112af75c3e77e435ffab422e47" translate="yes" xml:space="preserve">
          <source>I found this page after doing some sample exercises and having the exact same puzzlement.</source>
          <target state="translated">我在做了一些例题练习后发现了这一页,有了完全相同的困惑。</target>
        </trans-unit>
        <trans-unit id="748d8dd3315f134cfa40b10f3d5a0a2dff4020c9" translate="yes" xml:space="preserve">
          <source>If it's unsafe, why is it allowed to use a raw type?</source>
          <target state="translated">既然不安全,为什么允许用生字型?</target>
        </trans-unit>
        <trans-unit id="757cde53b1d07914c3de66734bfcb1a0d037c4db" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">如果省略实际类型参数，则创建 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的原始类型：</target>
        </trans-unit>
        <trans-unit id="9aeb471379aedc5abe716fbf10b8294ce63c6335" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of Box:</source>
          <target state="translated">如果省略了实际类型参数,则创建一个原始类型的Box。</target>
        </trans-unit>
        <trans-unit id="0cc605baa568c21a2584d85b111e38c62a278623" translate="yes" xml:space="preserve">
          <source>If you had declared &lt;code&gt;appendNewObject&lt;/code&gt; to take a raw type &lt;code&gt;List&lt;/code&gt; as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</source>
          <target state="translated">如果您已声明 &lt;code&gt;appendNewObject&lt;/code&gt; 以原始类型 &lt;code&gt;List&lt;/code&gt; 作为参数，那么它将被编译，因此您将失去从泛型获得的类型安全性。</target>
        </trans-unit>
        <trans-unit id="dd2d4a705143feb6d0a89160672246231005a289" translate="yes" xml:space="preserve">
          <source>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</source>
          <target state="translated">一般情况下是比较好的方法是对集合进行参数化,这样你就不会出现转换问题,你只需要添加参数化类型的元素就可以了,你的编辑器会提供给你选择合适的方法。</target>
        </trans-unit>
        <trans-unit id="3744921c19e7629a4f01f2555627f746743882d4" translate="yes" xml:space="preserve">
          <source>In simpler terms, when a raw type is used, the constructors, instance methods and non-&lt;code&gt;static&lt;/code&gt; fields are &lt;em&gt;also erased&lt;/em&gt;.</source>
          <target state="translated">简单来说，当使用原始类型时，构造函数，实例方法和非 &lt;code&gt;static&lt;/code&gt; 字段&lt;em&gt;也会被删除&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="756666332aa7004e808286b5b848c619457b8b90" translate="yes" xml:space="preserve">
          <source>In summary, raw types should NEVER be used in new code. &lt;strong&gt;You should always use parameterized types&lt;/strong&gt;.</source>
          <target state="translated">总而言之，绝对不要在新代码中使用原始类型。 &lt;strong&gt;您应该始终使用参数化类型&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b474182f196f28b6d9bc2a82197e85bb395fb460" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList arr&lt;/code&gt; is a raw type but your Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; is a Strict type.</source>
          <target state="translated">在这种情况下， &lt;code&gt;ArrayList arr&lt;/code&gt; 是原始类型，但是您的Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; 是严格类型。</target>
        </trans-unit>
        <trans-unit id="f1c1ae68c9409c5f5812e26d3d923d56dab69ce2" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; is a strict type but your Object &lt;code&gt;new ArrayList();&lt;/code&gt; is a raw type.</source>
          <target state="translated">在这种情况下， &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; 是严格类型，但您的Object &lt;code&gt;new ArrayList();&lt;/code&gt; 是原始类型。</target>
        </trans-unit>
        <trans-unit id="8c2f74dfe2af17f55f4ba29be8ccb19139a8d1f6" translate="yes" xml:space="preserve">
          <source>It is a Strict to &lt;code&gt;String&lt;/code&gt; not  a Raw Type so, It will never raise an warning .</source>
          <target state="translated">这是严格的 &lt;code&gt;String&lt;/code&gt; 而不是原始类型，因此，它永远不会发出警告。</target>
        </trans-unit>
        <trans-unit id="af64c2b91282b2bc128075031a67b506f57156cd" translate="yes" xml:space="preserve">
          <source>It is possible to use as a type &lt;strong&gt;the erasure&lt;/strong&gt; of a parameterized type or the erasure of an array type whose element type is a parameterized type. &lt;strong&gt;Such a type is called a &lt;em&gt;raw type&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">可以将参数化类型的擦除或元素类型为参数化类型的数组类型的擦除用作类型。 &lt;strong&gt;这种类型称为&lt;em&gt;原始类型&lt;/em&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d69f46a16cf7ee0a31e5e918cb4caa8f4a361e8" translate="yes" xml:space="preserve">
          <source>It may be safer but took 4  hours to demuddle the philosophy...</source>
          <target state="translated">可能比较安全,但花了4个小时的时间去化解哲学的.....</target>
        </trans-unit>
        <trans-unit id="c7b6e70f29e6d47c95b4ce838419d160d7d44651" translate="yes" xml:space="preserve">
          <source>It will add any type of Object into it because &lt;code&gt;arr&lt;/code&gt; is a Raw Type.</source>
          <target state="translated">因为 &lt;code&gt;arr&lt;/code&gt; 是Raw Type，它将在其中添加任何类型的Object。</target>
        </trans-unit>
        <trans-unit id="7c357301ad31d5a2328f52fdfde2afee191052a2" translate="yes" xml:space="preserve">
          <source>JLS 4.8 Raw Types</source>
          <target state="translated">JLS 4.8 原始类型</target>
        </trans-unit>
        <trans-unit id="d96b21d482d675d54b9a9afda2b5ba4acaaf0b98" translate="yes" xml:space="preserve">
          <source>Java Tutorials/Generics</source>
          <target state="translated">Java教程通用知识</target>
        </trans-unit>
        <trans-unit id="d9c140e4568d16dd9563d8ab811a377f394c3ad0" translate="yes" xml:space="preserve">
          <source>Just what is the difference between the raw type &lt;code&gt;List&lt;/code&gt; and the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; to a parameter of type &lt;code&gt;List&lt;/code&gt;, you can't pass it to a parameter of type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. There are subtyping rules for generics, and &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a subtype of the raw type &lt;code&gt;List&lt;/code&gt;, but not of the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. As a consequence, &lt;strong&gt;you lose type safety if you use raw type like &lt;code&gt;List&lt;/code&gt;, but not if you use a parameterized type like &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">原始类型 &lt;code&gt;List&lt;/code&gt; 和参数化类型 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 之间有什么区别？ 松散地说，前者选择了泛型类型检查，而后者则明确告诉编译器它能够保存任何类型的对象。 虽然可以将 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 传递给List类型的参数，但是不能将其传递给 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 类型的参数。 有泛型的子类型化规则，并且 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 是原始类型 &lt;code&gt;List&lt;/code&gt; 的子类型，但不是参数化类型 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 类型。 因此， &lt;strong&gt;如果使用像 &lt;code&gt;List&lt;/code&gt; 这样的原始类型，就不会失去类型安全性，但是如果使用像 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 这样的参数化类型，就不会失去类型安全性&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="850a74790dcd52d9b6cd99dd8612f5711bc8e124" translate="yes" xml:space="preserve">
          <source>More complex the Compareable interface:</source>
          <target state="translated">更为复杂的可比较界面。</target>
        </trans-unit>
        <trans-unit id="dfdfd6745128ac64237078d81256b1a171bc2dd6" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to implement the &lt;code&gt;CompareAble&lt;/code&gt; interface with &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; with raw types.
Why you should not use them:</source>
          <target state="translated">请注意，无法使用带有原始类型的 &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; 实现 &lt;code&gt;CompareAble&lt;/code&gt; 接口。 为什么不应该使用它们：</target>
        </trans-unit>
        <trans-unit id="296b126e38fe8034587cb665417ce3c7024ae780" translate="yes" xml:space="preserve">
          <source>Note: Example.java uses unchecked or unsafe operations.</source>
          <target state="translated">注意:示例.java使用未选中或不安全的操作。</target>
        </trans-unit>
        <trans-unit id="3499d2ef5e16f0b55aee68466deae9940cc994c4" translate="yes" xml:space="preserve">
          <source>Note: Recompile with -Xlint:unchecked for details.</source>
          <target state="translated">注意:重新编译时使用 -Xlint:unchecked 来了解详情。</target>
        </trans-unit>
        <trans-unit id="254f98057318b73a6885ac9033cf6c0a3f78cd90" translate="yes" xml:space="preserve">
          <source>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.</source>
          <target state="translated">请注意,使用generics时,你不需要对来自get调用的对象进行投射,集合是预先定义好的,只对MyObject工作。这个事实是驱动generics的主要因素。它将运行时的错误源变成了可以在编译时检查的东西。</target>
        </trans-unit>
        <trans-unit id="b6af0e34c6cc7075ebe7a4a3f42d6d402756c648" translate="yes" xml:space="preserve">
          <source>Now we run into trouble at run-time, because &lt;code&gt;names&lt;/code&gt; contains something that isn't an &lt;code&gt;instanceof String&lt;/code&gt;.</source>
          <target state="translated">现在我们在运行时遇到麻烦，因为 &lt;code&gt;names&lt;/code&gt; 包含的内容不是 &lt;code&gt;instanceof String&lt;/code&gt; 的instanceof 。</target>
        </trans-unit>
        <trans-unit id="ac370a883ec182a3baba7d9265d02ace81c41512" translate="yes" xml:space="preserve">
          <source>Of course, if you &lt;em&gt;DO&lt;/em&gt; want &lt;code&gt;names&lt;/code&gt; to allow a &lt;code&gt;Boolean&lt;/code&gt;, then you can declare it as &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt;, and the above code would compile.</source>
          <target state="translated">当然，如果您确实希望 &lt;code&gt;names&lt;/code&gt; 允许 &lt;code&gt;Boolean&lt;/code&gt; ，则可以将其声明为 &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt; ，并且上面的代码将进行编译。</target>
        </trans-unit>
        <trans-unit id="5f3e174709eebda3c2a288755f4a44a380585674" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</source>
          <target state="translated">原始资料： &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java教程&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecee4396959b71721b4635fbfb006a7cc0e9a651" translate="yes" xml:space="preserve">
          <source>Presumably, if you want &lt;code&gt;names&lt;/code&gt; to contain only &lt;code&gt;String&lt;/code&gt;, you &lt;em&gt;could&lt;/em&gt; perhaps still use a raw type and &lt;em&gt;manually check every&lt;/em&gt;&lt;code&gt;add&lt;/code&gt; yourself, and then &lt;em&gt;manually cast&lt;/em&gt; to &lt;code&gt;String&lt;/code&gt; every item from &lt;code&gt;names&lt;/code&gt;. &lt;strong&gt;Even better&lt;/strong&gt;, though is NOT to use a raw type and &lt;em&gt;let the compiler do all the work for you&lt;/em&gt;, harnessing the power of Java generics.</source>
          <target state="translated">大概，如果您希望 &lt;code&gt;names&lt;/code&gt; 仅包含 &lt;code&gt;String&lt;/code&gt; ，则可能仍可以使用原始类型并&lt;em&gt;手动检查每个&lt;/em&gt; &lt;code&gt;add&lt;/code&gt; ，然后&lt;em&gt;将&lt;/em&gt; &lt;code&gt;names&lt;/code&gt; 中的每个项目&lt;em&gt;手动转换&lt;/em&gt;为 &lt;code&gt;String&lt;/code&gt; 。 &lt;strong&gt;更好的是&lt;/strong&gt; ，尽管不要使用原始类型，而&lt;em&gt;让编译器&lt;/em&gt;利用Java泛型的强大功能&lt;em&gt;为您完成所有工作&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e63fc58ab6bfca9e67eebb8a65352e54e0fd330" translate="yes" xml:space="preserve">
          <source>Questions:</source>
          <target state="translated">Questions:</target>
        </trans-unit>
        <trans-unit id="14c39264748158f870d8f43c71ea7f51c1859672" translate="yes" xml:space="preserve">
          <source>Raw types are fine when they express what you want to express.</source>
          <target state="translated">原始类型表达你想表达的东西就可以了。</target>
        </trans-unit>
        <trans-unit id="47f403e27f4c62d43a2933f83a0dd997ab56d1e0" translate="yes" xml:space="preserve">
          <source>Raw types refer to using a generic type without specifying a type parameter.</source>
          <target state="translated">原始类型是指不指定类型参数而使用通用类型。</target>
        </trans-unit>
        <trans-unit id="f6709747af5a036dfca6571b0519116f90e0e9ec" translate="yes" xml:space="preserve">
          <source>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior &amp;mdash; a &lt;code&gt;Box&lt;/code&gt; gives you &lt;code&gt;Object&lt;/code&gt;s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</source>
          <target state="translated">原始类型显示在旧版代码中，因为在JDK 5.0之前，许多API类（例如Collections类）不是通用的。 使用原始类型时，您实际上会获得泛型行为 &lt;code&gt;Box&lt;/code&gt; 为您提供 &lt;code&gt;Object&lt;/code&gt; 。 为了向后兼容，允许将参数化类型分配给其原始类型：</target>
        </trans-unit>
        <trans-unit id="5edab9471a19ae73475c8ed0622f2789a8bbd38d" translate="yes" xml:space="preserve">
          <source>Raw-type should not be used because it could cause runtime errors, like inserting a &lt;code&gt;double&lt;/code&gt; into what was supposed to be a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">不应使用Raw-type，因为它可能会导致运行时错误，例如将 &lt;code&gt;double&lt;/code&gt; 插入应该为 &lt;code&gt;int&lt;/code&gt; 的 &lt;code&gt;Set&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b73c83827ddf3571b554094ecd15284c3d9f51ff" translate="yes" xml:space="preserve">
          <source>Raw-types are ancient history of the Java language. In the beginning there were &lt;code&gt;Collections&lt;/code&gt; and they held &lt;code&gt;Objects&lt;/code&gt; nothing more and nothing less. Every operation on &lt;code&gt;Collections&lt;/code&gt; required casts from &lt;code&gt;Object&lt;/code&gt; to the desired type.</source>
          <target state="translated">原始类型是Java语言的古老历史。 最初有 &lt;code&gt;Collections&lt;/code&gt; ，它们只保留 &lt;code&gt;Objects&lt;/code&gt; 而已。 对 &lt;code&gt;Collections&lt;/code&gt; 进行的每个操作都需要将 &lt;code&gt;Object&lt;/code&gt; 强制转换为所需的类型。</target>
        </trans-unit>
        <trans-unit id="fda027c268c4ae6152aa9f57c1dfaab8a4ae0670" translate="yes" xml:space="preserve">
          <source>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</source>
          <target state="translated">用-Xlint:unchecked重新编译前面的例子,会发现以下附加信息。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">以下面的例子为例。</target>
        </trans-unit>
        <trans-unit id="29e893a5bedf20dc1b4e344373155ba8e5623141" translate="yes" xml:space="preserve">
          <source>The Java Language Specification defines a &lt;em&gt;raw type&lt;/em&gt; as follows:</source>
          <target state="translated">Java语言规范对&lt;em&gt;原始类型的&lt;/em&gt;定义如下：</target>
        </trans-unit>
        <trans-unit id="f03d888157a822dae6298c0edd4e09b264238529" translate="yes" xml:space="preserve">
          <source>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as &lt;em&gt;migration compatibility&lt;/em&gt;, drove the decision to support raw types.</source>
          <target state="translated">引入泛型后，Java平台即将进入第二个十年，并且存在大量不使用泛型的Java代码。 至关重要的是，所有这些代码都必须合法并可以与使用泛型的新代码互操作。 将参数化类型的实例传递给设计用于普通类型的方法必须合法，反之亦然。 这项要求称为&lt;em&gt;迁移兼容性&lt;/em&gt; ，因此决定支持原始类型。</target>
        </trans-unit>
        <trans-unit id="405919cad9921e0b63d1c1d0b23b75783e9838de" translate="yes" xml:space="preserve">
          <source>The Type Erasure section has more information on how the Java compiler uses raw types.</source>
          <target state="translated">类型清除部分有更多关于Java编译器如何使用原始类型的信息。</target>
        </trans-unit>
        <trans-unit id="19cba934a6c7509721bb93f99ce5196844f697ea" translate="yes" xml:space="preserve">
          <source>The above code runs just fine, but suppose you also have the following:</source>
          <target state="translated">上面的代码可以正常运行,但假设你也有以下情况。</target>
        </trans-unit>
        <trans-unit id="ae33c93ae8545a049054d56f94b52ddadc4db2ff" translate="yes" xml:space="preserve">
          <source>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;! If you had declared the parameter as the raw type &lt;code&gt;List list&lt;/code&gt;, then the code would compile, and you'd violate the type invariant of &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt;.</source>
          <target state="translated">编译器做了出色的工作，可以保护您避免违反 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 的类型不变性！ 如果已将参数声明为原始类型 &lt;code&gt;List list&lt;/code&gt; ，则代码将编译，并且违反了 &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt; 的类型不变式。</target>
        </trans-unit>
        <trans-unit id="51a5fbcc09ae553d5fd592ab6795f02eaba69382" translate="yes" xml:space="preserve">
          <source>The compiler wants you to write this:</source>
          <target state="translated">编译器要你写这个。</target>
        </trans-unit>
        <trans-unit id="0363d591375571e48f68366a7f025385874a4bc8" translate="yes" xml:space="preserve">
          <source>The erasure of the signature of a generic method has no type parameters.</source>
          <target state="translated">通用方法的签名的擦除没有类型参数。</target>
        </trans-unit>
        <trans-unit id="4741487f156eaa93feddb499e8df578c72023c56" translate="yes" xml:space="preserve">
          <source>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-6400189&lt;/a&gt;. (In short, it makes the specification simpler.)</source>
          <target state="translated">以下错误报告包含编译器开发人员Maurizio Cimadamore和JLS的作者之一Alex Buckley关于为何应发生这种行为的一些想法： &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https&lt;/a&gt; : //bugs.openjdk.java.net/browse / JDK-6400189 。 （简而言之，它使规范更简单。）</target>
        </trans-unit>
        <trans-unit id="a9f82fe99578f6009d5eb0412ee1e187309afacb" translate="yes" xml:space="preserve">
          <source>The following is a quote from &lt;em&gt;Effective Java 2nd Edition, Item 23: Don't use raw types in new code&lt;/em&gt;:</source>
          <target state="translated">以下是来自&lt;em&gt;有效Java 2nd Edition，项目23&lt;/em&gt;的引用&lt;em&gt;：不要在新代码中使用原始类型&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba2996d73cdc2d5e8adf9bc06d73367a443e54a0" translate="yes" xml:space="preserve">
          <source>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.</source>
          <target state="translated">旧的无类型集合无法执行类型安全,所以程序员必须记住他在集合中存储的内容。</target>
        </trans-unit>
        <trans-unit id="224867fabb32bca2e488d4f0445bcb8a5d12ece3" translate="yes" xml:space="preserve">
          <source>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.</source>
          <target state="translated">首选的替代方法是按预期使用通用类-带有合适的类型参数（例如 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; ）。 这使程序员可以更具体地指定类型，将有关变量或数据结构的预期用途的更多含义传达给未来的维护者，并允许编译器强制实施更好的类型安全性。 这些优点一起可以提高代码质量，并有助于防止引入某些编码错误。</target>
        </trans-unit>
        <trans-unit id="bdde1ec38079b0f21677aedb8ffed79d4ee40436" translate="yes" xml:space="preserve">
          <source>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</source>
          <target state="translated">引用类型,是指在没有附带类型参数列表的情况下,采用通用类型声明的名称形成的引用类型。</target>
        </trans-unit>
        <trans-unit id="7b95d6baee239d3ff4e3ced680ad026c49c8a6fa" translate="yes" xml:space="preserve">
          <source>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</source>
          <target state="translated">一个原始类型的超类(分别为超接口)是对通用类型的任何一个参数化的超类(超接口)的擦除。</target>
        </trans-unit>
        <trans-unit id="028dac7a1835527c760373499e5bd53972c19762" translate="yes" xml:space="preserve">
          <source>The term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.</source>
          <target state="translated">术语 &quot;未选中 &quot;意味着编译器没有足够的类型信息来执行所有必要的类型检查以确保类型安全。默认情况下,&quot;unchecked &quot;警告被禁用,尽管编译器会给出提示。要查看所有 &quot;unchecked&quot; 警告,请使用 -Xlint:unchecked 重新编译。</target>
        </trans-unit>
        <trans-unit id="1c1d40c286a32e79507bdccf064061a7398aec1e" translate="yes" xml:space="preserve">
          <source>The type of a constructor, instance method, or non-&lt;code&gt;static&lt;/code&gt; field of a raw type &lt;code&gt;C&lt;/code&gt; that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">未从其超类或超接口继承的原始类型 &lt;code&gt;C&lt;/code&gt; 的构造函数，实例方法或非 &lt;code&gt;static&lt;/code&gt; 字段的类型是原始类型，其对应于在与 &lt;code&gt;C&lt;/code&gt; 对应的通用声明中擦除其类型。</target>
        </trans-unit>
        <trans-unit id="4de2e6bc304bdcf427827a31f05067b528fb6ec7" translate="yes" xml:space="preserve">
          <source>The use of raw types is allowed only as a concession to compatibility of legacy code. &lt;em&gt;The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.&lt;/em&gt;</source>
          <target state="translated">仅允许使用原始类型作为对遗留代码兼容性的让步。 &lt;em&gt;强烈建议不要在将通用性引入Java编程语言后在编写的代码中使用原始类型。&lt;/em&gt; &lt;em&gt;Java编程语言的未来版本可能会禁止使用原始类型。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38130b794559a4c9afe8f8b9c015c9dde8e522d2" translate="yes" xml:space="preserve">
          <source>The warning advises that types that are defined to support &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;generics&lt;/a&gt; should be parameterized, rather than using their raw form.</source>
          <target state="translated">该警告建议应定义参数以支持&lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;泛型&lt;/a&gt; ，而不要使用其原始格式。</target>
        </trans-unit>
        <trans-unit id="66ca0326f80fbd6c5b5f545e591d10cb1a33c496" translate="yes" xml:space="preserve">
          <source>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</source>
          <target state="translated">该警告显示,原始类型绕过了通用类型检查,将不安全代码的捕获推迟到运行时进行。因此,你应该避免使用原始类型。</target>
        </trans-unit>
        <trans-unit id="26f6914ed49c5138e2d0f7911e928bb8bc17625c" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;Box&lt;/code&gt; is the raw type of the generic type &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. However, a non-generic class or interface type is not a raw type.</source>
          <target state="translated">因此， &lt;code&gt;Box&lt;/code&gt; 是通用类型 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的原始类型。 但是，非泛型类或接口类型不是原始类型。</target>
        </trans-unit>
        <trans-unit id="00b4626a1162938da83e931c64651ef346add10f" translate="yes" xml:space="preserve">
          <source>They are less expressive, and don't self-document in the same way as parameterized types
&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">它们的表现力较低，并且不会以与参数化类型相同的方式进行自我记录</target>
        </trans-unit>
        <trans-unit id="0ebc27a91176efcbb20410934abb5853c0008136" translate="yes" xml:space="preserve">
          <source>They aren't type safe, and some important kinds of errors will only appear at runtime</source>
          <target state="translated">它们并不安全,一些重要的错误只有在运行时才会出现。</target>
        </trans-unit>
        <trans-unit id="1e9dd9b1ece7f9d0090b47a3a8306fdc209f6a95" translate="yes" xml:space="preserve">
          <source>They usually require casts</source>
          <target state="translated">他们通常需要的是石膏</target>
        </trans-unit>
        <trans-unit id="5873e20d029e66a8c51641dd8139270aaedf4381" translate="yes" xml:space="preserve">
          <source>This can happen when using an older API that operates on raw types, as shown in the following example:</source>
          <target state="translated">当使用旧的API操作原始类型时可能会出现这种情况,如下例所示。</target>
        </trans-unit>
        <trans-unit id="75bbc98951486b296100d29e447bb2550f22a5bd" translate="yes" xml:space="preserve">
          <source>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the &lt;code&gt;CompareAble&lt;/code&gt; interface, I guess that it creates two &lt;code&gt;compareTo&lt;/code&gt; functions, one taking a &lt;code&gt;MyCompareAble&lt;/code&gt; and the other taking an &lt;code&gt;Object&lt;/code&gt; and passing it to the first after casting it.</source>
          <target state="translated">如果直接使用原始类型，则与编写相同的代码。 我以为我不确定 &lt;code&gt;CompareAble&lt;/code&gt; 接口会发生什么，我猜想它创建了两个 &lt;code&gt;compareTo&lt;/code&gt; 函数，一个使用 &lt;code&gt;MyCompareAble&lt;/code&gt; ，另一个使用 &lt;code&gt;Object&lt;/code&gt; ,然后将其传递给第一个对象 。</target>
        </trans-unit>
        <trans-unit id="766f0ea717ddd326371c9d9cdc14d6d42b78ca3d" translate="yes" xml:space="preserve">
          <source>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; annotation suppresses unchecked warnings. If you are unfamiliar with the &lt;code&gt;@SuppressWarnings&lt;/code&gt; syntax, see Annotations.</source>
          <target state="translated">要完全禁用未检查的警告，请使用-Xlint：-unchecked标志。 &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; 注释禁止未检查的警告。 如果您不熟悉 &lt;code&gt;@SuppressWarnings&lt;/code&gt; 语法，请参阅注释。</target>
        </trans-unit>
        <trans-unit id="80251fc31dcb833fa8957ce6961b665392d800db" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, you supply an actual type argument for the formal type parameter &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">要创建 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 的参数化类型，请为形式类型参数 &lt;code&gt;T&lt;/code&gt; 提供一个实际的类型参数：</target>
        </trans-unit>
        <trans-unit id="738e743b4a29658389df8f72c91705203651edac" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:</source>
          <target state="translated">要创建一个参数化的Box类型,需要为正式类型参数T提供一个实际的类型参数。</target>
        </trans-unit>
        <trans-unit id="2e0d2fd5cc02c819f4b51dbe7cb93f09af65fbd8" translate="yes" xml:space="preserve">
          <source>To illustrate the point, consider the following method which takes a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; and appends a &lt;code&gt;new Object()&lt;/code&gt;.</source>
          <target state="translated">为了说明这一点，请考虑以下方法，该方法采用 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 并附加一个 &lt;code&gt;new Object()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="556b94a170a618efa12635f0635c19579ef283b9" translate="yes" xml:space="preserve">
          <source>Unchecked Error Messages</source>
          <target state="translated">未勾选的错误信息</target>
        </trans-unit>
        <trans-unit id="1488eddd4ac4e26c448d84102357cfa845ad5972" translate="yes" xml:space="preserve">
          <source>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</source>
          <target state="translated">不幸的是,由于Java的通用类型是非rereified的,所以有两种例外情况,在新代码中必须使用原始类型。</target>
        </trans-unit>
        <trans-unit id="1e5e7d3116ebd3de1a83a1241dab9045f1ec61bf" translate="yes" xml:space="preserve">
          <source>Using generics enables compile time checks</source>
          <target state="translated">使用泛函可以进行编译时间检查</target>
        </trans-unit>
        <trans-unit id="c633498ea9a29fa72a0bbecb71a9da972a698387" translate="yes" xml:space="preserve">
          <source>Using generics, you remove the &quot;unknown&quot; factor, because you must explicitly specify which type of objects can go in the list:</source>
          <target state="translated">使用属性,你去掉了 &quot;未知 &quot;因素,因为你必须明确指定哪些类型的对象可以进入列表。</target>
        </trans-unit>
        <trans-unit id="374c5fd146735c599512bad185fd1451f407b63e" translate="yes" xml:space="preserve">
          <source>Using raw types is the same as storing each value as &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">使用原始类型与将每个值存储为 &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eab2ae60ad80fc1f68d0fef0fa0d1c390dad5ca0" translate="yes" xml:space="preserve">
          <source>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</source>
          <target state="translated">什么是Java中的原始类型,为什么我经常听说在新代码中不应该使用原始类型?</target>
        </trans-unit>
        <trans-unit id="30ee936b3a2d7e626d1240eed0e0228cdf2781b3" translate="yes" xml:space="preserve">
          <source>What are the alternatives to raw types: Use &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;generics&lt;/a&gt;</source>
          <target state="translated">原始类型的替代方法是什么：使用&lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;泛型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13e18159e991cbf27833d847ecb850a6500c5b60" translate="yes" xml:space="preserve">
          <source>What is a raw type and why shouldn't we use it</source>
          <target state="translated">什么是原始类型,为什么我们不应该使用它?</target>
        </trans-unit>
        <trans-unit id="d33f524f99b128a863eea8abf8b22cdb547ff070" translate="yes" xml:space="preserve">
          <source>What is a raw type?</source>
          <target state="translated">什么是原始型?</target>
        </trans-unit>
        <trans-unit id="0c94f16920c76542bf263ada24624cb0b28ce1fd" translate="yes" xml:space="preserve">
          <source>What is saying is that your &lt;code&gt;list&lt;/code&gt; is a &lt;code&gt;List&lt;/code&gt; of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</source>
          <target state="translated">也就是说，您的 &lt;code&gt;list&lt;/code&gt; 是未指定对象的 &lt;code&gt;List&lt;/code&gt; 。 那就是Java不知道列表中包含哪种对象。 然后，当您要遍历列表时，必须强制转换每个元素，以便能够访问该元素的属性（在本例中为String）。</target>
        </trans-unit>
        <trans-unit id="fdeab1d68011a57fce4cd4ba9f9c74abe4ff5bea" translate="yes" xml:space="preserve">
          <source>What is the alternative if we can't use raw types, and how is it better?</source>
          <target state="translated">如果我们不能使用原始类型,有什么办法可以替代呢?</target>
        </trans-unit>
        <trans-unit id="7e187deccee3bced2f61d49a1c4f1805a24f3514" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="2000b4089ba1692a89afa72ea69f43fb13328c31" translate="yes" xml:space="preserve">
          <source>What the compiler does:
Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</source>
          <target state="translated">编译器所做的事情。通用类是向后兼容的,它们使用与原始类型相同的java类。魔力主要发生在编译时。</target>
        </trans-unit>
        <trans-unit id="4f8e701743ca8556df10918c1399924693590de0" translate="yes" xml:space="preserve">
          <source>What's so special about raw types?</source>
          <target state="translated">原始类型有什么特别之处?</target>
        </trans-unit>
        <trans-unit id="c0bec40361472ae5df662e245af72cd245cacb6e" translate="yes" xml:space="preserve">
          <source>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java. Although using raw types is still possible,</source>
          <target state="translated">当JDK 1.5中引入通用类型时,原始类型被保留下来,只是为了保持与旧版本的Java向后兼容。虽然仍然可以使用原始类型。</target>
        </trans-unit>
        <trans-unit id="07f051d6fc7fc8fbf515fd0cd3c1f563cb40b271" translate="yes" xml:space="preserve">
          <source>When retrieving the stuff from the &lt;code&gt;Set&lt;/code&gt;, you don't know what is coming out. Let's assume that you expect it to be all &lt;code&gt;int&lt;/code&gt;s, you are casting it to &lt;code&gt;Integer&lt;/code&gt;; exception at runtime when the &lt;code&gt;double&lt;/code&gt; 3.45 comes along.</source>
          <target state="translated">从 &lt;code&gt;Set&lt;/code&gt; 中检索东西时，您不知道会发生什么。 假设您期望它全部是 &lt;code&gt;int&lt;/code&gt; ，并且将其强制转换为 &lt;code&gt;Integer&lt;/code&gt; ； &lt;code&gt;double&lt;/code&gt; 精度3.45出现时在运行时发生异常。</target>
        </trans-unit>
        <trans-unit id="229813f4d96b2d1b1f45b96f3d4597193f7d55d2" translate="yes" xml:space="preserve">
          <source>When we use the raw &lt;code&gt;MyType&lt;/code&gt;, &lt;code&gt;getNames&lt;/code&gt; becomes erased as well, so that it returns a raw &lt;code&gt;List&lt;/code&gt;!</source>
          <target state="translated">当我们使用原始的 &lt;code&gt;MyType&lt;/code&gt; 时 ， &lt;code&gt;getNames&lt;/code&gt; 也将被擦除，因此它返回原始的 &lt;code&gt;List&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="03b03c443a4d1bf6d6fc2a3db1b553df7f30657f" translate="yes" xml:space="preserve">
          <source>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</source>
          <target state="translated">当你把对象添加到列表中时,它并不在乎它是什么类型的对象,当你从列表中得到它时,你必须明确地把它投给你期望的类型。</target>
        </trans-unit>
        <trans-unit id="c740556a6d482ca7b34342229dd689c7478cd44e" translate="yes" xml:space="preserve">
          <source>While this worked most of the time, errors did happen</source>
          <target state="translated">虽然这在大多数情况下都是有效的,但也确实发生过错误</target>
        </trans-unit>
        <trans-unit id="f1d1a366a93b477706dd8b3d6105c9c1a9eeba6a" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; Illegal?</source>
          <target state="translated">为什么 &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; 非法？</target>
        </trans-unit>
        <trans-unit id="1719e030f1ab15bdc53d7b641986ffbe8aab10b1" translate="yes" xml:space="preserve">
          <source>Will be compiled as:</source>
          <target state="translated">将被编为:</target>
        </trans-unit>
        <trans-unit id="dee4689d8bcf66596d11372b703adb5272094959" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;type parameter&lt;/em&gt; added to your &lt;code&gt;Set&lt;/code&gt;, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</source>
          <target state="translated">将&lt;em&gt;类型参数&lt;/em&gt;添加到 &lt;code&gt;Set&lt;/code&gt; 中后 ，您将立即获得编译错误。 这种先发制人的错误使您可以在运行时发生故障之前解决问题（从而节省时间和精力）。</target>
        </trans-unit>
        <trans-unit id="a7d70712fc20b205ca2cc8c4b74bad333f629980" translate="yes" xml:space="preserve">
          <source>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</source>
          <target state="translated">如果你使用原始类型来调用在相应的通用类型中定义的通用方法,你也会得到一个警告。</target>
        </trans-unit>
        <trans-unit id="197389cd6f3b37b3190a3a6a52add9e46a256131" translate="yes" xml:space="preserve">
          <source>You should specify the type-parameter.</source>
          <target state="translated">你应该指定类型参数。</target>
        </trans-unit>
        <trans-unit id="1ac174dc270f36327a0a027750b18bebbfaf4d7a" translate="yes" xml:space="preserve">
          <source>because otherwise, you could add any type you like into &lt;code&gt;list&lt;/code&gt;, making the instantiation as &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; pointless. Java generics are a compile-time feature only, so an object created with &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; will happily accept &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;JFrame&lt;/code&gt; elements if assigned to a reference of the &quot;raw type&quot; &lt;code&gt;List&lt;/code&gt; - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</source>
          <target state="translated">因为否则可以将任何喜欢的类型添加到 &lt;code&gt;list&lt;/code&gt; 中 ，从而使实例化为 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; 毫无意义。 Java泛型仅是编译时功能，因此，如果将 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; 创建的对象分配给&amp;ldquo;原始类型&amp;rdquo; &lt;code&gt;List&lt;/code&gt; 的引用，则该对象将很乐意接受 &lt;code&gt;Integer&lt;/code&gt; 或 &lt;code&gt;JFrame&lt;/code&gt; 元素-该对象本身不知道什么类型它应该包含，只有编译器可以。</target>
        </trans-unit>
        <trans-unit id="ea7878de5b8eeb89d003e785fa175fd505a012b3" translate="yes" xml:space="preserve">
          <source>here &lt;code&gt;arr&lt;/code&gt; is a Strict type. So, It will raise compile time error when adding a &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;arr&lt;/code&gt; 是严格类型。 因此，添加 &lt;code&gt;integer&lt;/code&gt; 时会产生编译时错误。</target>
        </trans-unit>
        <trans-unit id="2927dfb347fedd73a36f6f620a3aae2975129af7" translate="yes" xml:space="preserve">
          <source>java generics (not) covariance</source>
          <target state="translated">协方差</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
