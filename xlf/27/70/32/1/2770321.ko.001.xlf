<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2770321">
    <body>
      <group id="2770321">
        <trans-unit id="9bb688abe7c73fe83082a7942e2afa010b95bd2e" translate="yes" xml:space="preserve">
          <source>&quot;Raw types&quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</source>
          <target state="translated">&quot;원시 유형&quot;은 이전 버전과의 호환성을 위해 사용됩니다. 형식 인수와 함께 제네릭 클래스를 사용하면 더 강력한 타이핑이 가능 해져 코드 이해가 향상되고 잠재적 인 문제를 조기에 발견 할 수 있으므로 새 코드에서의 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e202a8885e8f2a0b0b18f657d2d758c8387e684" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; continues to explain the following:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; 은 다음을 계속 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9bcbbc30c3a268dc93ee0fcdcac237b04fa72318" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;tutorial page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;튜토리얼 페이지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5eeaf258c2f69574da220e548fe8afb66742168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; it is a &lt;code&gt;ArrayList&lt;/code&gt; reference variable with type &lt;code&gt;String&lt;/code&gt; which reference to a &lt;code&gt;ArralyList&lt;/code&gt; Object of Type &lt;code&gt;String&lt;/code&gt;. It means it can hold only String type Object.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; 유형의 &lt;code&gt;ArralyList&lt;/code&gt; 객체를 참조하는 &lt;code&gt;String&lt;/code&gt; 유형의 &lt;code&gt;ArrayList&lt;/code&gt; 참조 변수입니다. 문자열 유형 객체 만 보유 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5b6476b68a8bec6fe2c018b1e2dce00d036d2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, etc are all &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;, so it may be tempting to just say that they're just &lt;code&gt;List&lt;/code&gt; instead. However, there is a major difference: since a &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; defines only &lt;code&gt;add(E)&lt;/code&gt;, you can't add just any arbitrary object to a &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;. On the other hand, since the raw type &lt;code&gt;List&lt;/code&gt; does not have type safety, you can &lt;code&gt;add&lt;/code&gt; just about anything to a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; , &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 등은 모두 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 이므로 대신 &lt;code&gt;List&lt;/code&gt; 일 뿐이라고 유혹 할 수 있습니다. 그러나 &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; 는 &lt;code&gt;add(E)&lt;/code&gt; 만 정의하므로 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 임의의 객체 만 추가 할 수는 없습니다. 반면, 원시 유형 &lt;code&gt;List&lt;/code&gt; 에는 유형 안전이 없으므로 List 에 거의 아무것도 &lt;code&gt;add&lt;/code&gt; 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c965c3b6097bff5c3d5f7d3ca7b09048dacbe93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&lt;/code&gt; is defined to support generics: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt;. This allows many type-safe operations, that are checked compile-time.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; 는 제네릭을 지원하도록 정의되어 있습니다 : &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt; . 이를 통해 컴파일시 확인되는 많은 유형 안전 작업이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="29a69c16f89c3fd935dd606a5d4b3dbdabe380d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MyType.Nested&lt;/code&gt; is not a parameterized type, even though it's a member type of a parameterized type &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;, because it's &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MyType.Nested&lt;/code&gt; 는 매개 변수화 된 유형 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; 의 멤버 유형이지만 &lt;code&gt;static&lt;/code&gt; 이기 때문에 매개 변수화 된 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f052ee67a2af0dd5f9f4bd5d42450f8187a17d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; operand, e.g. &lt;code&gt;o instanceof Set&lt;/code&gt;, not &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 피연산자, 예 : &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt; 아닌 instanceof Set</target>
        </trans-unit>
        <trans-unit id="3aa367113494aa1a8fa752010519a9dd14831d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt1&lt;/code&gt;, and &lt;code&gt;mt2&lt;/code&gt; are both declared with actual type parameters, so they're not raw types.</source>
          <target state="translated">&lt;code&gt;mt1&lt;/code&gt; 및 &lt;code&gt;mt2&lt;/code&gt; 는 모두 실제 유형 매개 변수로 선언되므로 원시 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c778f211d4f54dd9219432d85be2ae77c19c5d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt&lt;/code&gt; has a raw type (and generates a compilation warning) by the first bullet point in the above definition; &lt;code&gt;inn&lt;/code&gt; also has a raw type by the third bullet point.</source>
          <target state="translated">&lt;code&gt;mt&lt;/code&gt; 는 위 정의의 첫 번째 글 머리 기호에 의해 원시 유형을 가지며 컴파일 경고를 생성합니다. &lt;code&gt;inn&lt;/code&gt; 은 또한 세 번째 글 머리 기호로 원시 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bcbfd569522fe96225142a9dbce9d9b99256d6ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Effective Java 2nd Edition&lt;/em&gt; also has this to add:</source>
          <target state="translated">&lt;em&gt;효과적인 Java 2nd Edition&lt;/em&gt; 에는 다음이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="06c568b39defa968eaf6d417143a99d437431f20" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For example&lt;/em&gt;,</source>
          <target state="translated">&lt;em&gt;예를 들어&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3120d5d3ec33fa18134615010180259f358798d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is a raw type and why do I often hear that they shouldn't be used in new code?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;원시 유형은 무엇이며 왜 새 코드에서 사용해서는 안된다는 말을 자주 듣습니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd279a8439dba2e5fdaf708d98b1db46ee00ff1e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the alternative if we can't use raw types, and how is it better?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;원시 유형을 사용할 수없는 경우 대안은 무엇이며 어떻게 더 좋습니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b80e7105e2584ff1d4ed97bfe515dcd23c4b2311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[...]&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e42a4f633bcd32dbe51455ca6bdd7612a294cb1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid raw types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;원시 유형을 피하십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e599fb38e4978d9cad0bf8657fc35335efcaf1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For reference&lt;/strong&gt;: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참조&lt;/strong&gt; : &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c5165c71ee10325066370d72c5f9a39d27bb232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;메소드 또는 생성자의 서명이 지워지면 메소드의 리턴 유형과 일반 메소드 또는 생성자의 유형 매개 변수도 삭제됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4311a85106cdf76087c5d49e5214fd1bb252ec93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They should be avoided&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;그들은 피해야합니다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f0d740fb2f9099a842f154be27e6d2d6ade17b18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.&lt;/strong&gt; The erasure of a constructor or method signature &lt;code&gt;s&lt;/code&gt; is a signature consisting of the same name as &lt;code&gt;s&lt;/code&gt; and the erasures of all the formal parameter types given in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;또한 유형 삭제는 생성자 또는 메서드의 서명을 매개 변수화 된 유형 또는 유형 변수가없는 서명에 매핑합니다.&lt;/strong&gt; 생성자 또는 메소드 서명 &lt;code&gt;s&lt;/code&gt; 삭제는 &lt;code&gt;s&lt;/code&gt; 와 동일한 이름과 s에 지정된 모든 형식 매개 변수 유형의 삭제로 구성된 서명입니다.</target>
        </trans-unit>
        <trans-unit id="365cf8a2d2c5f7bc6bd0f00615a2382dd4286f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Raw&lt;/code&gt; Type Object is referenced to a &lt;code&gt;Strict&lt;/code&gt; type Referenced Variable of &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :- &lt;code&gt;Raw&lt;/code&gt; 유형 객체는 &lt;code&gt;Strict&lt;/code&gt; 유형의 참조 변수 인 &lt;code&gt;ArrayList&lt;/code&gt; 를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="5f5cf18f48861714cd2c12682318f23cca1637eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Strict&lt;/code&gt; Type Object is referenced to a &lt;code&gt;raw&lt;/code&gt; type referenced Variable.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :- &lt;code&gt;Strict&lt;/code&gt; 유형 개체는 &lt;code&gt;raw&lt;/code&gt; 유형 참조 변수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="90a252e2d44f3f2a8b1890033755001338955145" translate="yes" xml:space="preserve">
          <source>============== I went from this code as provide by the sample ===============</source>
          <target state="translated">============== 샘플에서 제공 한대로이 코드에서 나왔습니다 ================</target>
        </trans-unit>
        <trans-unit id="b2eab9097b3ec971d127fbaff91ee92679421cbf" translate="yes" xml:space="preserve">
          <source>====================== To This code ========================</source>
          <target state="translated">======================이 코드에 =========================</target>
        </trans-unit>
        <trans-unit id="7a19b8e149aed7175b12239c8772988575617b7c" translate="yes" xml:space="preserve">
          <source>A &quot;raw type&quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using &lt;code&gt;List&lt;/code&gt; instead of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a &quot;raw type&quot; (without specifying a type argument) allowed legacy code to still compile.</source>
          <target state="translated">&quot;원시 유형&quot;은 매개 변수화 된 유형에 유형 인수를 지정하지 않고 일반 클래스를 사용하는 것입니다 (예 : &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 대신 List 사용). 제네릭이 Java에 도입되었을 때 제네릭을 사용하도록 여러 클래스가 업데이트되었습니다. 이 클래스를 &quot;원시 유형&quot;(유형 인수를 지정하지 않고)으로 사용하면 레거시 코드가 여전히 컴파일 될 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="33ba04d196a3008973ddc2524394442fa33e4d49" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; type in Java is a class which is non-generic and deals with &quot;raw&quot; Objects, rather than type-safe generic type parameters.</source>
          <target state="translated">Java에서 &quot;원시&quot;유형은 제네릭이 아니며 유형 안전 일반 유형 매개 변수가 아닌 &quot;원시&quot;오브젝트를 처리하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c99659ce7dbf112bd14117c16ebbd8db3d175959" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;raw&lt;/em&gt;-type is the a lack of a &lt;em&gt;type parameter&lt;/em&gt; when using a generic type.</source>
          <target state="translated">&lt;em&gt;raw&lt;/em&gt; -type은 제네릭 형식을 사용할 때 &lt;em&gt;형식 매개 변수&lt;/em&gt; 가 부족하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a826d4198daa01070b87640f459ca71ec283ab02" translate="yes" xml:space="preserve">
          <source>A list is a raw type, while &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a parameterized type.</source>
          <target state="translated">목록은 원시 유형이고 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 은 매개 변수화 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f8572ed900bc3ec607e2c608d6c9250f0ee36db6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; member type of a raw type &lt;code&gt;R&lt;/code&gt; that is not inherited from a superclass or superinterface of &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 의 수퍼 클래스 또는 수퍼 인터페이스에서 상속되지 않은 원시 유형 R 의 &lt;code&gt;static&lt;/code&gt; 아닌 멤버 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6a5287cb23f3eeae5edf828005202ed23e61a642" translate="yes" xml:space="preserve">
          <source>A raw type is defined to be one of:</source>
          <target state="translated">원시 유형은 다음 중 하나로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="205748e8c233f71145a1f2bd274309746828335f" translate="yes" xml:space="preserve">
          <source>A raw type is the erasure of that type</source>
          <target state="translated">원시 유형은 해당 유형의 삭제입니다.</target>
        </trans-unit>
        <trans-unit id="6a29e532dca4388e029fb3ea7d50673d5d01e2fd" translate="yes" xml:space="preserve">
          <source>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</source>
          <target state="translated">원시 유형은 유형 인수가없는 일반 클래스 또는 인터페이스의 이름입니다. 예를 들어, 일반 Box 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8845a4e3b681a7b8affa2bfb6f73c348d4d14738" translate="yes" xml:space="preserve">
          <source>An array type whose element type is a raw type.</source>
          <target state="translated">요소 유형이 원시 유형 인 배열 유형입니다.</target>
        </trans-unit>
        <trans-unit id="aca82bd9f96a2ad182aa1d73db0796bc4f782989" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Object&lt;/code&gt; stored in a &lt;code&gt;Collection&lt;/code&gt; has to be cast before it can be used</source>
          <target state="translated">&lt;code&gt;Collection&lt;/code&gt; 에 저장된 모든 &lt;code&gt;Object&lt;/code&gt; 는 사용하기 전에 캐스팅되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d029af1223f081b1921aa7f94ee3bf1b6d1d8ad" translate="yes" xml:space="preserve">
          <source>Are there no exceptions?</source>
          <target state="translated">예외는 없습니까?</target>
        </trans-unit>
        <trans-unit id="340c1df6af27884fb6eb161fdf86234b7c9f6b06" translate="yes" xml:space="preserve">
          <source>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</source>
          <target state="translated">앞에서 언급했듯이 레거시 코드와 일반 코드를 혼합 할 때 다음과 유사한 경고 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c59276c92cf37b7805c3861f7c5d5b2178bb735" translate="yes" xml:space="preserve">
          <source>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just &lt;code&gt;Object&lt;/code&gt;).</source>
          <target state="translated">허용 된 답변에서 언급했듯이 원시 유형의 코드 내에서 제네릭에 대한 모든 지원이 손실됩니다. 모든 유형 매개 변수는 삭제로 변환됩니다 (위의 예에서는 &lt;code&gt;Object&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="54ed0f30909fe006459ed6df04d66c2798441b16" translate="yes" xml:space="preserve">
          <source>Back to JLS 4.8:</source>
          <target state="translated">JLS 4.8로 돌아 가기 :</target>
        </trans-unit>
        <trans-unit id="6b592f4fe7b7afd4d7a2840c62e109cd230efddb" translate="yes" xml:space="preserve">
          <source>But if you assign a raw type to a parameterized type, you get a warning:</source>
          <target state="translated">그러나 원시 유형을 매개 변수화 된 유형에 지정하면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="03b28b2417326b91d54010c203487876d052c1ec" translate="yes" xml:space="preserve">
          <source>Case 1</source>
          <target state="translated">사례 1</target>
        </trans-unit>
        <trans-unit id="ee1189515944c7f281c8f48e390364b2fc748d15" translate="yes" xml:space="preserve">
          <source>Case 2</source>
          <target state="translated">사례 2</target>
        </trans-unit>
        <trans-unit id="16024e7ee398804bd61c244d6dfbc1dea703c6c9" translate="yes" xml:space="preserve">
          <source>Case 3</source>
          <target state="translated">사례 3</target>
        </trans-unit>
        <trans-unit id="5928bc5d24ccc7a0cbc69187317ba17c2da6578c" translate="yes" xml:space="preserve">
          <source>Class literals, e.g. &lt;code&gt;List.class&lt;/code&gt;, not &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</source>
          <target state="translated">클래스 리터럴 (예 : &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt; 아닌 &lt;code&gt;List.class&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="037a786100af58ee1da0c90e38df1f04d615f726" translate="yes" xml:space="preserve">
          <source>Consider the following variation of the previous snippet:</source>
          <target state="translated">이전 스 니펫의 다음 변형을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a34e95f456c0661699837d4636ebb3f2edebde4e" translate="yes" xml:space="preserve">
          <source>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</source>
          <target state="translated">기본적으로 원시 유형은 제네릭이 도입되기 전과 동일하게 작동합니다. 즉, 다음은 컴파일 타임에 전적으로 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="6313dbb779b20ad4f398638fbcdaa19e63ee873e" translate="yes" xml:space="preserve">
          <source>For Comparison:</source>
          <target state="translated">비교하려고:</target>
        </trans-unit>
        <trans-unit id="9a6955f50cd2bc2e9964cae7d37ac387cdbb56dc" translate="yes" xml:space="preserve">
          <source>For example, a deserialisation function might return a &lt;code&gt;List&lt;/code&gt;, but it doesn't know the list's element type. So &lt;code&gt;List&lt;/code&gt; is the appropriate return type here.</source>
          <target state="translated">예를 들어 역 직렬화 함수는 &lt;code&gt;List&lt;/code&gt; 를 반환하지만 목록의 요소 유형을 모릅니다. 따라서 &lt;code&gt;List&lt;/code&gt; 는 적절한 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e824bccb93fe388c271ceb20b71590f44f37ea03" translate="yes" xml:space="preserve">
          <source>For example, before Java generics was available, you would use a collection class like this:</source>
          <target state="translated">예를 들어 Java 제네릭을 사용하기 전에 다음과 같은 컬렉션 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e68e2841763bad1c52ec9e83909704bd0166a574" translate="yes" xml:space="preserve">
          <source>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</source>
          <target state="translated">예를 들어, 프로그래머가 'names'라는 List 변수에 문자열 만 포함 시키도록하려는 방법의 경우 :</target>
        </trans-unit>
        <trans-unit id="35882b9379794132d1c5486b062c0880c7da27dd" translate="yes" xml:space="preserve">
          <source>Generics in Java are invariant. A &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, so the following would generate a compiler warning:</source>
          <target state="translated">Java의 제네릭은 변하지 않습니다. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 은 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 가 아니므로 다음은 컴파일러 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="47bd8a7573789546aea546b52e9e17f8f529ba04" translate="yes" xml:space="preserve">
          <source>Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</source>
          <target state="translated">이 한계를 극복하기 위해 고안된 제네릭은 개발자가 저장된 유형을 한 번 선언하면 컴파일러가 대신 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d4a604535de856a836d66ebc92fdb85bc5b349f1" translate="yes" xml:space="preserve">
          <source>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</source>
          <target state="translated">원시 유형을 사용해서는 안된다는 것을 감안할 때 언어 설계자가 왜 허용합니까? 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f83f0fc624d5c25c1d4070c5d15292bc4b6daf3" translate="yes" xml:space="preserve">
          <source>Here I am Considering multiple cases  through which you can clearify  the concept</source>
          <target state="translated">여기서 나는 개념을 명확하게 할 수있는 여러 가지 경우를 고려하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e44f900cff505560d3f89e716fe1e3c0fb1bb5f" translate="yes" xml:space="preserve">
          <source>Here's an example to illustrate:</source>
          <target state="translated">다음은 설명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="dde31552770aa87ec22e55f9344569717d0b6871" translate="yes" xml:space="preserve">
          <source>Here's another case where raw types will bite you:</source>
          <target state="translated">다음은 원시 유형이 물린 경우입니다.</target>
        </trans-unit>
        <trans-unit id="67fa04e9f046a5adbebd5113ffaf92fe26a3311b" translate="yes" xml:space="preserve">
          <source>Here's another quote from JLS 4.8:</source>
          <target state="translated">JLS 4.8의 또 다른 인용문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43637dfe4455ba4d2171e4f14f305298cd8cd98c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; is a &lt;em&gt;parameterized type&lt;/em&gt; (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt;). It is common to colloquially refer to this type as simply &lt;code&gt;MyType&lt;/code&gt; for short, but technically the name is &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; 는 &lt;em&gt;매개 변수화 된 유형&lt;/em&gt; ( &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt; )입니다. 이 유형을 간단히 간단히 &lt;code&gt;MyType&lt;/code&gt; 이라고 부르는 것이 일반적이지만 기술적으로 이름은 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44ce7e40d47187da08c05cca9611e28d52d1fa17" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; as a type parameter?</source>
          <target state="translated">&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 를 유형 매개 변수로 사용하는 것과 원시 유형은 어떻게 다릅니 까?</target>
        </trans-unit>
        <trans-unit id="0ed2484f8d50e469e79f1ef84d9f9bad64fc9188" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; as type parameters?</source>
          <target state="translated">&lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; 를 형식 매개 변수로 사용하는 것과 원시 형식은 어떻게 다릅니 까?</target>
        </trans-unit>
        <trans-unit id="48564f1fb0c047112af75c3e77e435ffab422e47" translate="yes" xml:space="preserve">
          <source>I found this page after doing some sample exercises and having the exact same puzzlement.</source>
          <target state="translated">몇 가지 샘플 연습을 수행하고 똑같은 퍼즐을 한 후에이 페이지를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="748d8dd3315f134cfa40b10f3d5a0a2dff4020c9" translate="yes" xml:space="preserve">
          <source>If it's unsafe, why is it allowed to use a raw type?</source>
          <target state="translated">안전하지 않은 경우 왜 원시 유형을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="757cde53b1d07914c3de66734bfcb1a0d037c4db" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">실제 유형 인수가 생략되면 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 의 원시 유형이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9aeb471379aedc5abe716fbf10b8294ce63c6335" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of Box:</source>
          <target state="translated">실제 유형 인수가 생략되면 원시 유형의 Box를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0cc605baa568c21a2584d85b111e38c62a278623" translate="yes" xml:space="preserve">
          <source>If you had declared &lt;code&gt;appendNewObject&lt;/code&gt; to take a raw type &lt;code&gt;List&lt;/code&gt; as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</source>
          <target state="translated">&lt;code&gt;appendNewObject&lt;/code&gt; &lt;code&gt;List&lt;/code&gt; 를 매개 변수로 사용하도록 appendNewObject 를 선언 한 경우 컴파일되어 제네릭에서 얻을 수있는 형식 안전성을 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="dd2d4a705143feb6d0a89160672246231005a289" translate="yes" xml:space="preserve">
          <source>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</source>
          <target state="translated">일반적으로 컬렉션을 매개 변수화하는 것이 더 좋습니다. 따라서 변환 문제가 없으며 매개 변수화 된 유형의 요소 만 추가 할 수 있으며 편집기는 적절한 메서드를 선택하여 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3744921c19e7629a4f01f2555627f746743882d4" translate="yes" xml:space="preserve">
          <source>In simpler terms, when a raw type is used, the constructors, instance methods and non-&lt;code&gt;static&lt;/code&gt; fields are &lt;em&gt;also erased&lt;/em&gt;.</source>
          <target state="translated">간단히 말해, 원시 유형을 사용하면 생성자, 인스턴스 메소드 및 비 &lt;code&gt;static&lt;/code&gt; 필드 &lt;em&gt;도 지워&lt;/em&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="756666332aa7004e808286b5b848c619457b8b90" translate="yes" xml:space="preserve">
          <source>In summary, raw types should NEVER be used in new code. &lt;strong&gt;You should always use parameterized types&lt;/strong&gt;.</source>
          <target state="translated">요약하면 원시 코드는 새 코드에서 절대 사용해서는 안됩니다. &lt;strong&gt;항상 매개 변수화 된 유형을 사용해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b474182f196f28b6d9bc2a82197e85bb395fb460" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList arr&lt;/code&gt; is a raw type but your Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; is a Strict type.</source>
          <target state="translated">이 경우 &lt;code&gt;ArrayList arr&lt;/code&gt; 은 원시 유형이지만 Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; 엄격한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f1c1ae68c9409c5f5812e26d3d923d56dab69ce2" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; is a strict type but your Object &lt;code&gt;new ArrayList();&lt;/code&gt; is a raw type.</source>
          <target state="translated">이 경우 &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; 은 엄격한 유형이지만 Object &lt;code&gt;new ArrayList();&lt;/code&gt; 원시 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8c2f74dfe2af17f55f4ba29be8ccb19139a8d1f6" translate="yes" xml:space="preserve">
          <source>It is a Strict to &lt;code&gt;String&lt;/code&gt; not  a Raw Type so, It will never raise an warning .</source>
          <target state="translated">Raw Type이 아닌 &lt;code&gt;String&lt;/code&gt; to Strict이므로 경고가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af64c2b91282b2bc128075031a67b506f57156cd" translate="yes" xml:space="preserve">
          <source>It is possible to use as a type &lt;strong&gt;the erasure&lt;/strong&gt; of a parameterized type or the erasure of an array type whose element type is a parameterized type. &lt;strong&gt;Such a type is called a &lt;em&gt;raw type&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">매개 변수화 된 유형의 소거 또는 요소 유형이 매개 변수화 된 유형 인 배열 유형의 소거를 유형으로 사용할 수 있습니다. &lt;strong&gt;이러한 유형을 &lt;em&gt;원시 유형&lt;/em&gt; 이라고합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d69f46a16cf7ee0a31e5e918cb4caa8f4a361e8" translate="yes" xml:space="preserve">
          <source>It may be safer but took 4  hours to demuddle the philosophy...</source>
          <target state="translated">더 안전 할 수는 있지만 철학을 어지럽히는 데 4 시간이 걸렸습니다 ...</target>
        </trans-unit>
        <trans-unit id="c7b6e70f29e6d47c95b4ce838419d160d7d44651" translate="yes" xml:space="preserve">
          <source>It will add any type of Object into it because &lt;code&gt;arr&lt;/code&gt; is a Raw Type.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 은 Raw Type이므로 모든 유형의 Object를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7c357301ad31d5a2328f52fdfde2afee191052a2" translate="yes" xml:space="preserve">
          <source>JLS 4.8 Raw Types</source>
          <target state="translated">JLS 4.8 원시 유형</target>
        </trans-unit>
        <trans-unit id="d96b21d482d675d54b9a9afda2b5ba4acaaf0b98" translate="yes" xml:space="preserve">
          <source>Java Tutorials/Generics</source>
          <target state="translated">자바 튜토리얼 / 일반</target>
        </trans-unit>
        <trans-unit id="d9c140e4568d16dd9563d8ab811a377f394c3ad0" translate="yes" xml:space="preserve">
          <source>Just what is the difference between the raw type &lt;code&gt;List&lt;/code&gt; and the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; to a parameter of type &lt;code&gt;List&lt;/code&gt;, you can't pass it to a parameter of type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. There are subtyping rules for generics, and &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a subtype of the raw type &lt;code&gt;List&lt;/code&gt;, but not of the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. As a consequence, &lt;strong&gt;you lose type safety if you use raw type like &lt;code&gt;List&lt;/code&gt;, but not if you use a parameterized type like &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">원시 형식 &lt;code&gt;List&lt;/code&gt; 와 매개 변수화 된 형식 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 의 차이점은 무엇입니까? 느슨하게 말해서 전자는 일반 유형 검사를 선택하지 않았으며 후자는 명시 적으로 컴파일러에게 모든 유형의 객체를 보유 할 수 있다고 말했습니다. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 을 &lt;code&gt;List&lt;/code&gt; 유형의 매개 변수로 전달할 수는 있지만 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 유형의 매개 변수로 전달할 수는 없습니다. 제네릭에 대한 하위 입력 규칙이 있으며 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 은 원시 유형 &lt;code&gt;List&lt;/code&gt; 의 하위 유형이지만 매개 변수화 된 유형 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 는 아닙니다. 결과적으로 &lt;strong&gt; &lt;code&gt;List&lt;/code&gt; 와 같은 원시 유형을 사용하면 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 와 같은 매개 변수화 된 유형을 사용하지 않으면 유형 안전성이 손실됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="850a74790dcd52d9b6cd99dd8612f5711bc8e124" translate="yes" xml:space="preserve">
          <source>More complex the Compareable interface:</source>
          <target state="translated">비교 가능한 인터페이스가 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="dfdfd6745128ac64237078d81256b1a171bc2dd6" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to implement the &lt;code&gt;CompareAble&lt;/code&gt; interface with &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; with raw types.
Why you should not use them:</source>
          <target state="translated">원시 유형으로 &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; 사용하여 &lt;code&gt;CompareAble&lt;/code&gt; 인터페이스를 구현할 수 없습니다. 왜 사용하지 말아야합니까?</target>
        </trans-unit>
        <trans-unit id="296b126e38fe8034587cb665417ce3c7024ae780" translate="yes" xml:space="preserve">
          <source>Note: Example.java uses unchecked or unsafe operations.</source>
          <target state="translated">참고 : Example.java는 검사되지 않거나 안전하지 않은 작업을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3499d2ef5e16f0b55aee68466deae9940cc994c4" translate="yes" xml:space="preserve">
          <source>Note: Recompile with -Xlint:unchecked for details.</source>
          <target state="translated">참고 : 자세한 내용은 -Xlint : unchecked를 사용하여 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="254f98057318b73a6885ac9033cf6c0a3f78cd90" translate="yes" xml:space="preserve">
          <source>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.</source>
          <target state="translated">제네릭을 사용하면 get 호출에서 오는 개체를 캐스팅 할 필요가 없으며 컬렉션은 MyObject에서만 작동하도록 미리 정의되어 있습니다. 이 사실은 제네릭의 주요 동인입니다. 런타임 오류 소스를 컴파일 타임에 확인할 수있는 것으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b6af0e34c6cc7075ebe7a4a3f42d6d402756c648" translate="yes" xml:space="preserve">
          <source>Now we run into trouble at run-time, because &lt;code&gt;names&lt;/code&gt; contains something that isn't an &lt;code&gt;instanceof String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 에는 &lt;code&gt;instanceof String&lt;/code&gt; 의 인스턴스 가 아닌 것이 포함되어 있기 때문에 런타임에 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac370a883ec182a3baba7d9265d02ace81c41512" translate="yes" xml:space="preserve">
          <source>Of course, if you &lt;em&gt;DO&lt;/em&gt; want &lt;code&gt;names&lt;/code&gt; to allow a &lt;code&gt;Boolean&lt;/code&gt;, then you can declare it as &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt;, and the above code would compile.</source>
          <target state="translated">물론 &lt;code&gt;Boolean&lt;/code&gt; 을 허용하는 &lt;code&gt;names&lt;/code&gt; 을 원한다면 &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt; 로 선언하면 위 코드가 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3e174709eebda3c2a288755f4a44a380585674" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</source>
          <target state="translated">원본 출처 : &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecee4396959b71721b4635fbfb006a7cc0e9a651" translate="yes" xml:space="preserve">
          <source>Presumably, if you want &lt;code&gt;names&lt;/code&gt; to contain only &lt;code&gt;String&lt;/code&gt;, you &lt;em&gt;could&lt;/em&gt; perhaps still use a raw type and &lt;em&gt;manually check every&lt;/em&gt;&lt;code&gt;add&lt;/code&gt; yourself, and then &lt;em&gt;manually cast&lt;/em&gt; to &lt;code&gt;String&lt;/code&gt; every item from &lt;code&gt;names&lt;/code&gt;. &lt;strong&gt;Even better&lt;/strong&gt;, though is NOT to use a raw type and &lt;em&gt;let the compiler do all the work for you&lt;/em&gt;, harnessing the power of Java generics.</source>
          <target state="translated">아마도 &lt;code&gt;names&lt;/code&gt; 에 &lt;code&gt;String&lt;/code&gt; 만 포함하고 싶다면 여전히 원시 유형을 사용하고 &lt;em&gt;수동으로 모든&lt;/em&gt; &lt;code&gt;add&lt;/code&gt; 직접 &lt;em&gt;확인한&lt;/em&gt; 다음 &lt;code&gt;names&lt;/code&gt; 에서 모든 항목을 &lt;em&gt;수동으로&lt;/em&gt; &lt;code&gt;String&lt;/code&gt; &lt;em&gt;으로 캐스팅&lt;/em&gt; 할 수 있습니다 . &lt;strong&gt;더 좋은&lt;/strong&gt; 방법은 원시 형식을 사용하지 않고 &lt;em&gt;컴파일러가&lt;/em&gt; Java 제네릭의 힘을 활용하여 &lt;em&gt;모든 작업을 수행하도록하는 것입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7e63fc58ab6bfca9e67eebb8a65352e54e0fd330" translate="yes" xml:space="preserve">
          <source>Questions:</source>
          <target state="translated">Questions:</target>
        </trans-unit>
        <trans-unit id="14c39264748158f870d8f43c71ea7f51c1859672" translate="yes" xml:space="preserve">
          <source>Raw types are fine when they express what you want to express.</source>
          <target state="translated">표현하려는 내용을 표현할 때 원시 유형이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47f403e27f4c62d43a2933f83a0dd997ab56d1e0" translate="yes" xml:space="preserve">
          <source>Raw types refer to using a generic type without specifying a type parameter.</source>
          <target state="translated">원시 유형은 유형 매개 변수를 지정하지 않고 일반 유형을 사용하는 것을 말합니다.</target>
        </trans-unit>
        <trans-unit id="f6709747af5a036dfca6571b0519116f90e0e9ec" translate="yes" xml:space="preserve">
          <source>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior &amp;mdash; a &lt;code&gt;Box&lt;/code&gt; gives you &lt;code&gt;Object&lt;/code&gt;s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</source>
          <target state="translated">원시 클래스는 JDK 5.0 이전에는 많은 API 클래스 (예 : Collections 클래스)가 일반적이지 않기 때문에 레거시 코드에 표시됩니다. raw 타입을 사용할 때, 당신은 본질적으로 pre-generics 동작을 얻습니다 &amp;ndash; &lt;code&gt;Box&lt;/code&gt; 는 &lt;code&gt;Object&lt;/code&gt; 를 제공합니다. 이전 버전과의 호환성을 위해 매개 변수화 된 형식을 원시 형식에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5edab9471a19ae73475c8ed0622f2789a8bbd38d" translate="yes" xml:space="preserve">
          <source>Raw-type should not be used because it could cause runtime errors, like inserting a &lt;code&gt;double&lt;/code&gt; into what was supposed to be a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">Raw 유형은 &lt;code&gt;int&lt;/code&gt; &lt;code&gt;Set&lt;/code&gt; 으로 가정 된 것에 &lt;code&gt;double&lt;/code&gt; 을 삽입하는 것과 같은 런타임 오류를 일으킬 수 있으므로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b73c83827ddf3571b554094ecd15284c3d9f51ff" translate="yes" xml:space="preserve">
          <source>Raw-types are ancient history of the Java language. In the beginning there were &lt;code&gt;Collections&lt;/code&gt; and they held &lt;code&gt;Objects&lt;/code&gt; nothing more and nothing less. Every operation on &lt;code&gt;Collections&lt;/code&gt; required casts from &lt;code&gt;Object&lt;/code&gt; to the desired type.</source>
          <target state="translated">원시 유형은 Java 언어의 고대 역사입니다. 처음에는 &lt;code&gt;Collections&lt;/code&gt; 이 있었고 &lt;code&gt;Objects&lt;/code&gt; 더 이상 아무것도 보유하지 않았습니다. &lt;code&gt;Collections&lt;/code&gt; 에 대한 모든 작업은 &lt;code&gt;Object&lt;/code&gt; 에서 원하는 유형으로 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="fda027c268c4ae6152aa9f57c1dfaab8a4ae0670" translate="yes" xml:space="preserve">
          <source>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</source>
          <target state="translated">-Xlint : unchecked를 사용하여 이전 예제를 다시 컴파일하면 다음과 같은 추가 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">다음 예를 보자.</target>
        </trans-unit>
        <trans-unit id="29e893a5bedf20dc1b4e344373155ba8e5623141" translate="yes" xml:space="preserve">
          <source>The Java Language Specification defines a &lt;em&gt;raw type&lt;/em&gt; as follows:</source>
          <target state="translated">Java 언어 사양은 다음과 같이 &lt;em&gt;원시 유형&lt;/em&gt; 을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f03d888157a822dae6298c0edd4e09b264238529" translate="yes" xml:space="preserve">
          <source>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as &lt;em&gt;migration compatibility&lt;/em&gt;, drove the decision to support raw types.</source>
          <target state="translated">Java 플랫폼은 제네릭이 도입 된 후 20 년이되었을 때 제네릭을 사용하지 않는 엄청난 양의 Java 코드가 존재했습니다. 이 모든 코드가 제네릭을 사용하는 새로운 코드와 합법적이고 상호 운용 가능한 상태로 유지되는 것이 중요하다고 간주되었습니다. 매개 변수화 된 유형의 인스턴스를 일반 유형과 함께 사용하도록 설계된 메소드로 전달하는 것이 합법적이어야했습니다. &lt;em&gt;마이그레이션 호환성으로&lt;/em&gt; 알려진이 요구 사항은 원시 유형을 지원하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="405919cad9921e0b63d1c1d0b23b75783e9838de" translate="yes" xml:space="preserve">
          <source>The Type Erasure section has more information on how the Java compiler uses raw types.</source>
          <target state="translated">Type Erasure 섹션에는 Java 컴파일러가 원시 유형을 사용하는 방법에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cba934a6c7509721bb93f99ce5196844f697ea" translate="yes" xml:space="preserve">
          <source>The above code runs just fine, but suppose you also have the following:</source>
          <target state="translated">위의 코드는 정상적으로 실행되지만 다음과 같은 사항이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ae33c93ae8545a049054d56f94b52ddadc4db2ff" translate="yes" xml:space="preserve">
          <source>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;! If you had declared the parameter as the raw type &lt;code&gt;List list&lt;/code&gt;, then the code would compile, and you'd violate the type invariant of &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 의 형식 불일치를 잠재적으로 위반하지 않도록 보호하는 훌륭한 작업을 수행했습니다! 매개 변수를 원시 유형 &lt;code&gt;List list&lt;/code&gt; 로 선언하면 코드가 컴파일되고 &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt; 불변 유형을 위반하게 됩니다 .</target>
        </trans-unit>
        <trans-unit id="51a5fbcc09ae553d5fd592ab6795f02eaba69382" translate="yes" xml:space="preserve">
          <source>The compiler wants you to write this:</source>
          <target state="translated">컴파일러는 다음과 같이 작성하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="0363d591375571e48f68366a7f025385874a4bc8" translate="yes" xml:space="preserve">
          <source>The erasure of the signature of a generic method has no type parameters.</source>
          <target state="translated">제네릭 메서드의 서명 지우기에는 형식 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4741487f156eaa93feddb499e8df578c72023c56" translate="yes" xml:space="preserve">
          <source>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-6400189&lt;/a&gt;. (In short, it makes the specification simpler.)</source>
          <target state="translated">다음 버그 보고서에는 컴파일러 개발자 인 Maurizio Cimadamore와 JLS의 저자 인 Alex Buckley가 이런 종류의 동작이 발생하는 이유에 대한 의견이 포함되어 있습니다. &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse / JDK-6400189&lt;/a&gt; . 즉, 사양이 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="a9f82fe99578f6009d5eb0412ee1e187309afacb" translate="yes" xml:space="preserve">
          <source>The following is a quote from &lt;em&gt;Effective Java 2nd Edition, Item 23: Don't use raw types in new code&lt;/em&gt;:</source>
          <target state="translated">다음은 &lt;em&gt;Effective Java 2nd Edition, Item 23&lt;/em&gt; 의 인용문 &lt;em&gt;입니다. 새 코드에서 원시 유형을 사용하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ba2996d73cdc2d5e8adf9bc06d73367a443e54a0" translate="yes" xml:space="preserve">
          <source>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.</source>
          <target state="translated">오래된 타입리스 컬렉션은 타입 안전을 강제 할 수 없었으므로 프로그래머는 컬렉션 내에 저장된 것을 기억해야했습니다.</target>
        </trans-unit>
        <trans-unit id="224867fabb32bca2e488d4f0445bcb8a5d12ece3" translate="yes" xml:space="preserve">
          <source>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.</source>
          <target state="translated">선호되는 대안은 적합한 유형 인수 (예 : &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; )와 함께 일반 클래스를 의도 한대로 사용하는 것입니다. 이를 통해 프로그래머는 유형을보다 구체적으로 지정할 수 있으며 변수 또는 데이터 구조의 용도에 대해 미래의 관리자에게 더 많은 의미를 전달할 수 있으며 컴파일러가 더 나은 유형 안전을 시행 할 수 있습니다. 이러한 장점을 함께 사용하면 코드 품질이 향상되고 일부 코딩 오류가 발생하는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdde1ec38079b0f21677aedb8ffed79d4ee40436" translate="yes" xml:space="preserve">
          <source>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</source>
          <target state="translated">함께 제공되는 형식 인수 목록없이 일반 형식 선언의 이름을 사용하여 구성된 참조 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7b95d6baee239d3ff4e3ced680ad026c49c8a6fa" translate="yes" xml:space="preserve">
          <source>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</source>
          <target state="translated">원시 유형의 수퍼 클래스 (각각 수퍼 인터페이스)는 일반 유형의 모든 매개 변수화에 대한 수퍼 클래스 (수퍼 인터페이스)의 삭제입니다.</target>
        </trans-unit>
        <trans-unit id="028dac7a1835527c760373499e5bd53972c19762" translate="yes" xml:space="preserve">
          <source>The term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.</source>
          <target state="translated">&quot;체크되지 않은&quot;이라는 용어는 컴파일러에 형식 안전성을 보장하는 데 필요한 모든 형식 검사를 수행하기에 충분한 형식 정보가 없음을 의미합니다. 컴파일러가 힌트를 제공하지만 &quot;확인되지 않은&quot;경고는 기본적으로 비활성화되어 있습니다. &quot;확인되지 않은&quot;경고를 모두 보려면 -Xlint : unchecked로 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="1c1d40c286a32e79507bdccf064061a7398aec1e" translate="yes" xml:space="preserve">
          <source>The type of a constructor, instance method, or non-&lt;code&gt;static&lt;/code&gt; field of a raw type &lt;code&gt;C&lt;/code&gt; that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">수퍼 클래스 또는 수퍼 인터페이스에서 상속되지 않은 원시 유형 &lt;code&gt;C&lt;/code&gt; 의 생성자, 인스턴스 메소드 또는 &lt;code&gt;static&lt;/code&gt; 아닌 필드의 유형은 C에 해당하는 일반 선언에서 해당 유형의 지우기에 해당하는 원시 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4de2e6bc304bdcf427827a31f05067b528fb6ec7" translate="yes" xml:space="preserve">
          <source>The use of raw types is allowed only as a concession to compatibility of legacy code. &lt;em&gt;The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.&lt;/em&gt;</source>
          <target state="translated">원시 유형의 사용은 레거시 코드의 호환성에 대한 양보로만 허용됩니다. &lt;em&gt;Java 프로그래밍 언어에 일반성을 도입 한 후에 작성된 코드에서 원시 유형을 사용하는 것은 권장하지 않습니다.&lt;/em&gt; &lt;em&gt;향후 버전의 Java 프로그래밍 언어에서 원시 유형을 사용할 수 없게 될 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38130b794559a4c9afe8f8b9c015c9dde8e522d2" translate="yes" xml:space="preserve">
          <source>The warning advises that types that are defined to support &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;generics&lt;/a&gt; should be parameterized, rather than using their raw form.</source>
          <target state="translated">경고는 &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;제네릭&lt;/a&gt; 을 지원하도록 정의 된 형식은 원시 형식을 사용하지 않고 매개 변수화해야합니다.</target>
        </trans-unit>
        <trans-unit id="66ca0326f80fbd6c5b5f545e591d10cb1a33c496" translate="yes" xml:space="preserve">
          <source>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</source>
          <target state="translated">경고는 원시 유형이 일반 유형 검사를 우회하여 안전하지 않은 코드의 캐치를 런타임으로 연기하는 것을 보여줍니다. 따라서 원시 유형을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="26f6914ed49c5138e2d0f7911e928bb8bc17625c" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;Box&lt;/code&gt; is the raw type of the generic type &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. However, a non-generic class or interface type is not a raw type.</source>
          <target state="translated">따라서 &lt;code&gt;Box&lt;/code&gt; 는 제네릭 형식 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 의 원시 형식입니다. 그러나 제네릭이 아닌 클래스 또는 인터페이스 유형은 원시 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="00b4626a1162938da83e931c64651ef346add10f" translate="yes" xml:space="preserve">
          <source>They are less expressive, and don't self-document in the same way as parameterized types
&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">표현력이 떨어지고 매개 변수화 된 유형과 같은 방식으로 자체 문서화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ebc27a91176efcbb20410934abb5853c0008136" translate="yes" xml:space="preserve">
          <source>They aren't type safe, and some important kinds of errors will only appear at runtime</source>
          <target state="translated">형식이 안전하지 않으며 일부 중요한 종류의 오류는 런타임에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1e9dd9b1ece7f9d0090b47a3a8306fdc209f6a95" translate="yes" xml:space="preserve">
          <source>They usually require casts</source>
          <target state="translated">그들은 일반적으로 캐스트가 필요합니다</target>
        </trans-unit>
        <trans-unit id="5873e20d029e66a8c51641dd8139270aaedf4381" translate="yes" xml:space="preserve">
          <source>This can happen when using an older API that operates on raw types, as shown in the following example:</source>
          <target state="translated">이는 다음 예제와 같이 원시 유형에서 작동하는 이전 API를 사용할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75bbc98951486b296100d29e447bb2550f22a5bd" translate="yes" xml:space="preserve">
          <source>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the &lt;code&gt;CompareAble&lt;/code&gt; interface, I guess that it creates two &lt;code&gt;compareTo&lt;/code&gt; functions, one taking a &lt;code&gt;MyCompareAble&lt;/code&gt; and the other taking an &lt;code&gt;Object&lt;/code&gt; and passing it to the first after casting it.</source>
          <target state="translated">이는 원시 유형을 직접 사용한 경우 작성하는 코드와 동일합니다. &lt;code&gt;CompareAble&lt;/code&gt; 인터페이스에서 어떤 일이 발생하는지 잘 모르겠지만, 하나는 &lt;code&gt;MyCompareAble&lt;/code&gt; 을 사용하고 다른 하나는 &lt;code&gt;Object&lt;/code&gt; 를 사용 하고 캐스팅 후 첫 번째로 전달하는 &lt;code&gt;compareTo&lt;/code&gt; 함수 두 개를 생성한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="766f0ea717ddd326371c9d9cdc14d6d42b78ca3d" translate="yes" xml:space="preserve">
          <source>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; annotation suppresses unchecked warnings. If you are unfamiliar with the &lt;code&gt;@SuppressWarnings&lt;/code&gt; syntax, see Annotations.</source>
          <target state="translated">확인되지 않은 경고를 완전히 비활성화하려면 -Xlint : -unchecked 플래그를 사용하십시오. &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; 주석은 확인되지 않은 경고를 표시하지 않습니다. &lt;code&gt;@SuppressWarnings&lt;/code&gt; 구문에 익숙하지 않은 경우 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="80251fc31dcb833fa8957ce6961b665392d800db" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, you supply an actual type argument for the formal type parameter &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 의 매개 변수화 된 유형을 작성하려면 공식 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 에 실제 유형 인수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="738e743b4a29658389df8f72c91705203651edac" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:</source>
          <target state="translated">매개 변수화 된 유형의 Box를 작성하려면 공식 유형 매개 변수 T에 실제 유형 인수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="2e0d2fd5cc02c819f4b51dbe7cb93f09af65fbd8" translate="yes" xml:space="preserve">
          <source>To illustrate the point, consider the following method which takes a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; and appends a &lt;code&gt;new Object()&lt;/code&gt;.</source>
          <target state="translated">요점을 설명하기 위해 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 하고 &lt;code&gt;new Object()&lt;/code&gt; 추가하는 다음 방법을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="556b94a170a618efa12635f0635c19579ef283b9" translate="yes" xml:space="preserve">
          <source>Unchecked Error Messages</source>
          <target state="translated">확인되지 않은 오류 메시지</target>
        </trans-unit>
        <trans-unit id="1488eddd4ac4e26c448d84102357cfa845ad5972" translate="yes" xml:space="preserve">
          <source>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</source>
          <target state="translated">불행하게도, Java 제네릭은 통일되지 않기 때문에 새로운 코드에서 raw 유형을 사용해야하는 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e5e7d3116ebd3de1a83a1241dab9045f1ec61bf" translate="yes" xml:space="preserve">
          <source>Using generics enables compile time checks</source>
          <target state="translated">제네릭을 사용하면 컴파일 시간을 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c633498ea9a29fa72a0bbecb71a9da972a698387" translate="yes" xml:space="preserve">
          <source>Using generics, you remove the &quot;unknown&quot; factor, because you must explicitly specify which type of objects can go in the list:</source>
          <target state="translated">제네릭을 사용하면 목록에 들어갈 수있는 개체 유형을 명시 적으로 지정해야하기 때문에 &quot;알 수없는&quot;요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="374c5fd146735c599512bad185fd1451f407b63e" translate="yes" xml:space="preserve">
          <source>Using raw types is the same as storing each value as &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">원시 유형을 사용하는 것은 각 값을 &lt;code&gt;Object&lt;/code&gt; 로 저장하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eab2ae60ad80fc1f68d0fef0fa0d1c390dad5ca0" translate="yes" xml:space="preserve">
          <source>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</source>
          <target state="translated">Java의 원시 유형은 무엇이며 왜 새 코드에서 사용해서는 안된다고 자주 들립니까?</target>
        </trans-unit>
        <trans-unit id="30ee936b3a2d7e626d1240eed0e0228cdf2781b3" translate="yes" xml:space="preserve">
          <source>What are the alternatives to raw types: Use &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;generics&lt;/a&gt;</source>
          <target state="translated">원시 유형에 대한 대안은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="13e18159e991cbf27833d847ecb850a6500c5b60" translate="yes" xml:space="preserve">
          <source>What is a raw type and why shouldn't we use it</source>
          <target state="translated">원시 유형은 무엇이며 왜 사용해서는 안됩니까?</target>
        </trans-unit>
        <trans-unit id="d33f524f99b128a863eea8abf8b22cdb547ff070" translate="yes" xml:space="preserve">
          <source>What is a raw type?</source>
          <target state="translated">원시 유형은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0c94f16920c76542bf263ada24624cb0b28ce1fd" translate="yes" xml:space="preserve">
          <source>What is saying is that your &lt;code&gt;list&lt;/code&gt; is a &lt;code&gt;List&lt;/code&gt; of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</source>
          <target state="translated">말하는 것은 &lt;code&gt;List&lt;/code&gt; 이 지정되지 않은 객체의 목록 이라는 것입니다. 즉, Java는 목록에 어떤 종류의 객체가 있는지 알지 못합니다. 그런 다음 목록을 반복하려면 모든 요소를 ​​캐스팅하고 해당 요소의 속성 (이 경우 String)에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fdeab1d68011a57fce4cd4ba9f9c74abe4ff5bea" translate="yes" xml:space="preserve">
          <source>What is the alternative if we can't use raw types, and how is it better?</source>
          <target state="translated">원시 유형을 사용할 수없는 경우 대안은 무엇이며 어떻게 더 좋습니까?</target>
        </trans-unit>
        <trans-unit id="7e187deccee3bced2f61d49a1c4f1805a24f3514" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt; 의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2000b4089ba1692a89afa72ea69f43fb13328c31" translate="yes" xml:space="preserve">
          <source>What the compiler does:
Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</source>
          <target state="translated">컴파일러의 기능 : 제네릭은 이전 버전과 호환되며 원시 유형과 동일한 Java 클래스를 사용합니다. 마술은 대부분 컴파일 타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f8e701743ca8556df10918c1399924693590de0" translate="yes" xml:space="preserve">
          <source>What's so special about raw types?</source>
          <target state="translated">원시 유형에서 특별한 점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c0bec40361472ae5df662e245af72cd245cacb6e" translate="yes" xml:space="preserve">
          <source>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java. Although using raw types is still possible,</source>
          <target state="translated">JDK 1.5에서 제네릭이 도입되었을 때, 이전 버전의 Java와의 하위 호환성을 유지하기 위해 원시 유형 만 유지되었습니다. 원시 유형을 사용하는 것이 여전히 가능하지만</target>
        </trans-unit>
        <trans-unit id="07f051d6fc7fc8fbf515fd0cd3c1f563cb40b271" translate="yes" xml:space="preserve">
          <source>When retrieving the stuff from the &lt;code&gt;Set&lt;/code&gt;, you don't know what is coming out. Let's assume that you expect it to be all &lt;code&gt;int&lt;/code&gt;s, you are casting it to &lt;code&gt;Integer&lt;/code&gt;; exception at runtime when the &lt;code&gt;double&lt;/code&gt; 3.45 comes along.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 에서 물건을 검색 할 때, 무엇이 나오는지 알 수 없습니다. 모든 &lt;code&gt;int&lt;/code&gt; 일 것으로 예상하고 &lt;code&gt;Integer&lt;/code&gt; 로 캐스팅한다고 가정 해 봅시다. &lt;code&gt;double&lt;/code&gt; 3.45가 나오면 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="229813f4d96b2d1b1f45b96f3d4597193f7d55d2" translate="yes" xml:space="preserve">
          <source>When we use the raw &lt;code&gt;MyType&lt;/code&gt;, &lt;code&gt;getNames&lt;/code&gt; becomes erased as well, so that it returns a raw &lt;code&gt;List&lt;/code&gt;!</source>
          <target state="translated">raw &lt;code&gt;MyType&lt;/code&gt; 을 사용하면 &lt;code&gt;getNames&lt;/code&gt; 도 지워 지므로 raw &lt;code&gt;List&lt;/code&gt; 가 반환됩니다!</target>
        </trans-unit>
        <trans-unit id="03b03c443a4d1bf6d6fc2a3db1b553df7f30657f" translate="yes" xml:space="preserve">
          <source>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</source>
          <target state="translated">객체를 목록에 추가 할 때는 객체의 유형이 중요하지 않으며 목록에서 가져 오면 예상 한 유형으로 명시 적으로 캐스팅해야합니다.</target>
        </trans-unit>
        <trans-unit id="c740556a6d482ca7b34342229dd689c7478cd44e" translate="yes" xml:space="preserve">
          <source>While this worked most of the time, errors did happen</source>
          <target state="translated">대부분의 시간 동안 작동했지만 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="f1d1a366a93b477706dd8b3d6105c9c1a9eeba6a" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; Illegal?</source>
          <target state="translated">&lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; 가 왜 불법입니까?</target>
        </trans-unit>
        <trans-unit id="1719e030f1ab15bdc53d7b641986ffbe8aab10b1" translate="yes" xml:space="preserve">
          <source>Will be compiled as:</source>
          <target state="translated">다음과 같이 컴파일됩니다 :</target>
        </trans-unit>
        <trans-unit id="dee4689d8bcf66596d11372b703adb5272094959" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;type parameter&lt;/em&gt; added to your &lt;code&gt;Set&lt;/code&gt;, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 에 &lt;em&gt;type 매개 변수를&lt;/em&gt; 추가하면 컴파일 오류가 한 번에 발생합니다. 이 선점 오류를 통해 런타임 중에 문제가 발생하기 전에 문제를 해결할 수 있습니다 (따라서 시간과 노력을 절약).</target>
        </trans-unit>
        <trans-unit id="a7d70712fc20b205ca2cc8c4b74bad333f629980" translate="yes" xml:space="preserve">
          <source>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</source>
          <target state="translated">원시 유형을 사용하여 해당 일반 유형에 정의 된 일반 메소드를 호출하면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="197389cd6f3b37b3190a3a6a52add9e46a256131" translate="yes" xml:space="preserve">
          <source>You should specify the type-parameter.</source>
          <target state="translated">type-parameter를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ac174dc270f36327a0a027750b18bebbfaf4d7a" translate="yes" xml:space="preserve">
          <source>because otherwise, you could add any type you like into &lt;code&gt;list&lt;/code&gt;, making the instantiation as &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; pointless. Java generics are a compile-time feature only, so an object created with &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; will happily accept &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;JFrame&lt;/code&gt; elements if assigned to a reference of the &quot;raw type&quot; &lt;code&gt;List&lt;/code&gt; - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</source>
          <target state="translated">그렇지 않으면 원하는 모든 유형을 &lt;code&gt;list&lt;/code&gt; 에 추가하여 인스턴스화를 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; 무의미하게 만들 수 있습니다. Java 제네릭은 컴파일 타임 기능 일 뿐이므로 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; 생성 된 객체는 &quot;원시 유형&quot; &lt;code&gt;List&lt;/code&gt; 의 참조에 할당 된 경우 &lt;code&gt;Integer&lt;/code&gt; 또는 &lt;code&gt;JFrame&lt;/code&gt; 요소를 행복하게 받아들입니다. 컴파일러 만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea7878de5b8eeb89d003e785fa175fd505a012b3" translate="yes" xml:space="preserve">
          <source>here &lt;code&gt;arr&lt;/code&gt; is a Strict type. So, It will raise compile time error when adding a &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;arr&lt;/code&gt; 는 엄격한 유형입니다. 따라서 &lt;code&gt;integer&lt;/code&gt; 추가하면 컴파일 시간 오류가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="2927dfb347fedd73a36f6f620a3aae2975129af7" translate="yes" xml:space="preserve">
          <source>java generics (not) covariance</source>
          <target state="translated">Java 제네릭 (비공개) 공분산</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
