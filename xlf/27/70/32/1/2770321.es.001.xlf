<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2770321">
    <body>
      <group id="2770321">
        <trans-unit id="9bb688abe7c73fe83082a7942e2afa010b95bd2e" translate="yes" xml:space="preserve">
          <source>&quot;Raw types&quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</source>
          <target state="translated">Los &quot;tipos crudos&quot; se usan para la compatibilidad con el pasado.No se recomienda su uso en código nuevo porque el uso de la clase genérica con un argumento de tipo permite una escritura más fuerte,lo que a su vez puede mejorar la comprensibilidad del código y hacer que se detecten antes los posibles problemas.</target>
        </trans-unit>
        <trans-unit id="5e202a8885e8f2a0b0b18f657d2d758c8387e684" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; continues to explain the following:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; contin&amp;uacute;a explicando lo siguiente:</target>
        </trans-unit>
        <trans-unit id="9bcbbc30c3a268dc93ee0fcdcac237b04fa72318" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;tutorial page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;p&amp;aacute;gina tutorial&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5eeaf258c2f69574da220e548fe8afb66742168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; it is a &lt;code&gt;ArrayList&lt;/code&gt; reference variable with type &lt;code&gt;String&lt;/code&gt; which reference to a &lt;code&gt;ArralyList&lt;/code&gt; Object of Type &lt;code&gt;String&lt;/code&gt;. It means it can hold only String type Object.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; es una variable de referencia &lt;code&gt;ArrayList&lt;/code&gt; con tipo &lt;code&gt;String&lt;/code&gt; que hace referencia a un objeto &lt;code&gt;ArralyList&lt;/code&gt; de tipo &lt;code&gt;String&lt;/code&gt; . Significa que solo puede contener objetos de tipo cadena.</target>
        </trans-unit>
        <trans-unit id="5b6476b68a8bec6fe2c018b1e2dce00d036d2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, etc are all &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;, so it may be tempting to just say that they're just &lt;code&gt;List&lt;/code&gt; instead. However, there is a major difference: since a &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; defines only &lt;code&gt;add(E)&lt;/code&gt;, you can't add just any arbitrary object to a &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;. On the other hand, since the raw type &lt;code&gt;List&lt;/code&gt; does not have type safety, you can &lt;code&gt;add&lt;/code&gt; just about anything to a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; , &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; , etc. son todos &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; , Por lo que puede ser tentador decir que son &lt;code&gt;List&lt;/code&gt; . Sin embargo, hay una gran diferencia: dado que una &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; define solo &lt;code&gt;add(E)&lt;/code&gt; , no puede agregar cualquier objeto arbitrario a una &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; . Por otro lado, dado que la &lt;code&gt;List&lt;/code&gt; a de tipo sin formato no tiene seguridad de tipo, puede &lt;code&gt;add&lt;/code&gt; casi cualquier cosa a una &lt;code&gt;List&lt;/code&gt; a .</target>
        </trans-unit>
        <trans-unit id="c965c3b6097bff5c3d5f7d3ca7b09048dacbe93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&lt;/code&gt; is defined to support generics: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt;. This allows many type-safe operations, that are checked compile-time.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; se define para admitir gen&amp;eacute;ricos: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt; . Esto permite muchas operaciones de tipo seguro, que se verifican en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29a69c16f89c3fd935dd606a5d4b3dbdabe380d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MyType.Nested&lt;/code&gt; is not a parameterized type, even though it's a member type of a parameterized type &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;, because it's &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MyType.Nested&lt;/code&gt; no es un tipo parametrizado, aunque es un tipo de miembro de un tipo parametrizado &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; , porque es &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f052ee67a2af0dd5f9f4bd5d42450f8187a17d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; operand, e.g. &lt;code&gt;o instanceof Set&lt;/code&gt;, not &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; operand, por ejemplo, &lt;code&gt;o instanceof Set&lt;/code&gt; , no &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3aa367113494aa1a8fa752010519a9dd14831d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt1&lt;/code&gt;, and &lt;code&gt;mt2&lt;/code&gt; are both declared with actual type parameters, so they're not raw types.</source>
          <target state="translated">&lt;code&gt;mt1&lt;/code&gt; y &lt;code&gt;mt2&lt;/code&gt; se declaran con par&amp;aacute;metros de tipo reales, por lo que no son tipos sin formato.</target>
        </trans-unit>
        <trans-unit id="c778f211d4f54dd9219432d85be2ae77c19c5d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt&lt;/code&gt; has a raw type (and generates a compilation warning) by the first bullet point in the above definition; &lt;code&gt;inn&lt;/code&gt; also has a raw type by the third bullet point.</source>
          <target state="translated">&lt;code&gt;mt&lt;/code&gt; tiene un tipo sin formato (y genera una advertencia de compilaci&amp;oacute;n) por el primer punto en la definici&amp;oacute;n anterior; &lt;code&gt;inn&lt;/code&gt; tambi&amp;eacute;n tiene un tipo sin procesar en el tercer punto de vi&amp;ntilde;eta.</target>
        </trans-unit>
        <trans-unit id="bcbfd569522fe96225142a9dbce9d9b99256d6ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Effective Java 2nd Edition&lt;/em&gt; also has this to add:</source>
          <target state="translated">&lt;em&gt;Efectivo Java 2nd Edition&lt;/em&gt; tambi&amp;eacute;n tiene esto para agregar:</target>
        </trans-unit>
        <trans-unit id="06c568b39defa968eaf6d417143a99d437431f20" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For example&lt;/em&gt;,</source>
          <target state="translated">&lt;em&gt;Por ejemplo&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="3120d5d3ec33fa18134615010180259f358798d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is a raw type and why do I often hear that they shouldn't be used in new code?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Qu&amp;eacute; es un tipo sin formato y por qu&amp;eacute; a menudo escucho que no deben usarse en c&amp;oacute;digo nuevo?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd279a8439dba2e5fdaf708d98b1db46ee00ff1e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the alternative if we can't use raw types, and how is it better?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Cu&amp;aacute;l es la alternativa si no podemos usar tipos sin procesar y c&amp;oacute;mo es mejor?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b80e7105e2584ff1d4ed97bfe515dcd23c4b2311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[...]&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e42a4f633bcd32dbe51455ca6bdd7612a294cb1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid raw types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evitar tipos crudos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e599fb38e4978d9cad0bf8657fc35335efcaf1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For reference&lt;/strong&gt;: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Para referencia&lt;/strong&gt; : &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c5165c71ee10325066370d72c5f9a39d27bb232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El tipo de retorno de un m&amp;eacute;todo y los par&amp;aacute;metros de tipo de un m&amp;eacute;todo gen&amp;eacute;rico o constructor tambi&amp;eacute;n se borran si se borra la firma del m&amp;eacute;todo o del constructor.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4311a85106cdf76087c5d49e5214fd1bb252ec93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They should be avoided&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Deben evitarse&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f0d740fb2f9099a842f154be27e6d2d6ade17b18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.&lt;/strong&gt; The erasure of a constructor or method signature &lt;code&gt;s&lt;/code&gt; is a signature consisting of the same name as &lt;code&gt;s&lt;/code&gt; and the erasures of all the formal parameter types given in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;El borrado de tipos tambi&amp;eacute;n asigna la firma de un constructor o m&amp;eacute;todo a una firma que no tiene tipos parametrizados o variables de tipo.&lt;/strong&gt; La eliminaci&amp;oacute;n de una firma de constructor o m&amp;eacute;todo &lt;code&gt;s&lt;/code&gt; es una firma que consta del mismo nombre que &lt;code&gt;s&lt;/code&gt; y las eliminaciones de todos los tipos de par&amp;aacute;metros formales dados en &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365cf8a2d2c5f7bc6bd0f00615a2382dd4286f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Raw&lt;/code&gt; Type Object is referenced to a &lt;code&gt;Strict&lt;/code&gt; type Referenced Variable of &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : - Un objeto de tipo sin formato se hace referencia a una variable referenciada de tipo &lt;code&gt;Strict&lt;/code&gt; de &lt;code&gt;ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5cf18f48861714cd2c12682318f23cca1637eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Strict&lt;/code&gt; Type Object is referenced to a &lt;code&gt;raw&lt;/code&gt; type referenced Variable.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : - Un objeto de tipo &lt;code&gt;Strict&lt;/code&gt; est&amp;aacute; referenciado a una variable referenciada de tipo sin formato.</target>
        </trans-unit>
        <trans-unit id="90a252e2d44f3f2a8b1890033755001338955145" translate="yes" xml:space="preserve">
          <source>============== I went from this code as provide by the sample ===============</source>
          <target state="translated">==============Pasé de este código como lo indica la muestra ================</target>
        </trans-unit>
        <trans-unit id="b2eab9097b3ec971d127fbaff91ee92679421cbf" translate="yes" xml:space="preserve">
          <source>====================== To This code ========================</source>
          <target state="translated">==========================A este código ============================</target>
        </trans-unit>
        <trans-unit id="7a19b8e149aed7175b12239c8772988575617b7c" translate="yes" xml:space="preserve">
          <source>A &quot;raw type&quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using &lt;code&gt;List&lt;/code&gt; instead of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a &quot;raw type&quot; (without specifying a type argument) allowed legacy code to still compile.</source>
          <target state="translated">Un &quot;tipo sin formato&quot; es el uso de una clase gen&amp;eacute;rica sin especificar un argumento de tipo (s) para su tipo (s) parametrizado (s), por ejemplo, usando &lt;code&gt;List&lt;/code&gt; en lugar de &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; . Cuando se introdujeron los gen&amp;eacute;ricos en Java, se actualizaron varias clases para usar los gen&amp;eacute;ricos. El uso de estas clases como un &quot;tipo sin formato&quot; (sin especificar un argumento de tipo) permiti&amp;oacute; que el c&amp;oacute;digo heredado a&amp;uacute;n se compilara.</target>
        </trans-unit>
        <trans-unit id="33ba04d196a3008973ddc2524394442fa33e4d49" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; type in Java is a class which is non-generic and deals with &quot;raw&quot; Objects, rather than type-safe generic type parameters.</source>
          <target state="translated">Un tipo &quot;crudo&quot; en Java es una clase no genérica que trata de objetos &quot;crudos&quot;,en lugar de parámetros de tipo genérico seguros.</target>
        </trans-unit>
        <trans-unit id="c99659ce7dbf112bd14117c16ebbd8db3d175959" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;raw&lt;/em&gt;-type is the a lack of a &lt;em&gt;type parameter&lt;/em&gt; when using a generic type.</source>
          <target state="translated">Un tipo &lt;em&gt;sin&lt;/em&gt; formato es la falta de un &lt;em&gt;par&amp;aacute;metro de tipo&lt;/em&gt; cuando se usa un tipo gen&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="a826d4198daa01070b87640f459ca71ec283ab02" translate="yes" xml:space="preserve">
          <source>A list is a raw type, while &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a parameterized type.</source>
          <target state="translated">Una lista es un tipo sin formato, mientras que &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; es un tipo parametrizado.</target>
        </trans-unit>
        <trans-unit id="f8572ed900bc3ec607e2c608d6c9250f0ee36db6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; member type of a raw type &lt;code&gt;R&lt;/code&gt; that is not inherited from a superclass or superinterface of &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">Un tipo de miembro no &lt;code&gt;static&lt;/code&gt; de un tipo &lt;code&gt;R&lt;/code&gt; sin procesar que no se hereda de una superclase o superinterfaz de &lt;code&gt;R&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a5287cb23f3eeae5edf828005202ed23e61a642" translate="yes" xml:space="preserve">
          <source>A raw type is defined to be one of:</source>
          <target state="translated">Un tipo crudo se define como uno de:</target>
        </trans-unit>
        <trans-unit id="205748e8c233f71145a1f2bd274309746828335f" translate="yes" xml:space="preserve">
          <source>A raw type is the erasure of that type</source>
          <target state="translated">Un tipo crudo es el borrado de ese tipo</target>
        </trans-unit>
        <trans-unit id="6a29e532dca4388e029fb3ea7d50673d5d01e2fd" translate="yes" xml:space="preserve">
          <source>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</source>
          <target state="translated">Un tipo crudo es el nombre de una clase o interfaz genérica sin ningún tipo de argumentos.Por ejemplo,dada la clase genérica Box:</target>
        </trans-unit>
        <trans-unit id="8845a4e3b681a7b8affa2bfb6f73c348d4d14738" translate="yes" xml:space="preserve">
          <source>An array type whose element type is a raw type.</source>
          <target state="translated">Un tipo de matriz cuyo tipo de elemento es un tipo crudo.</target>
        </trans-unit>
        <trans-unit id="aca82bd9f96a2ad182aa1d73db0796bc4f782989" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Object&lt;/code&gt; stored in a &lt;code&gt;Collection&lt;/code&gt; has to be cast before it can be used</source>
          <target state="translated">Cualquier &lt;code&gt;Object&lt;/code&gt; almacenado en una &lt;code&gt;Collection&lt;/code&gt; tiene que ser lanzado antes de que pueda ser usado</target>
        </trans-unit>
        <trans-unit id="7d029af1223f081b1921aa7f94ee3bf1b6d1d8ad" translate="yes" xml:space="preserve">
          <source>Are there no exceptions?</source>
          <target state="translated">¿No hay excepciones?</target>
        </trans-unit>
        <trans-unit id="340c1df6af27884fb6eb161fdf86234b7c9f6b06" translate="yes" xml:space="preserve">
          <source>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</source>
          <target state="translated">Como se mencionó anteriormente,al mezclar el código heredado con el código genérico,puede encontrar mensajes de advertencia similares a los siguientes:</target>
        </trans-unit>
        <trans-unit id="5c59276c92cf37b7805c3861f7c5d5b2178bb735" translate="yes" xml:space="preserve">
          <source>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just &lt;code&gt;Object&lt;/code&gt;).</source>
          <target state="translated">Como se mencion&amp;oacute; en la respuesta aceptada, pierde todo el soporte para gen&amp;eacute;ricos dentro del c&amp;oacute;digo de tipo sin formato. Cada par&amp;aacute;metro de tipo se convierte en su borrado (que en el ejemplo anterior es solo &lt;code&gt;Object&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="54ed0f30909fe006459ed6df04d66c2798441b16" translate="yes" xml:space="preserve">
          <source>Back to JLS 4.8:</source>
          <target state="translated">Volvamos al JLS 4.8:</target>
        </trans-unit>
        <trans-unit id="6b592f4fe7b7afd4d7a2840c62e109cd230efddb" translate="yes" xml:space="preserve">
          <source>But if you assign a raw type to a parameterized type, you get a warning:</source>
          <target state="translated">Pero si asignas un tipo crudo a un tipo parametrizado,obtienes una advertencia:</target>
        </trans-unit>
        <trans-unit id="03b28b2417326b91d54010c203487876d052c1ec" translate="yes" xml:space="preserve">
          <source>Case 1</source>
          <target state="translated">Caso 1</target>
        </trans-unit>
        <trans-unit id="ee1189515944c7f281c8f48e390364b2fc748d15" translate="yes" xml:space="preserve">
          <source>Case 2</source>
          <target state="translated">Caso 2</target>
        </trans-unit>
        <trans-unit id="16024e7ee398804bd61c244d6dfbc1dea703c6c9" translate="yes" xml:space="preserve">
          <source>Case 3</source>
          <target state="translated">Caso 3</target>
        </trans-unit>
        <trans-unit id="5928bc5d24ccc7a0cbc69187317ba17c2da6578c" translate="yes" xml:space="preserve">
          <source>Class literals, e.g. &lt;code&gt;List.class&lt;/code&gt;, not &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;List.class&lt;/code&gt; clase, por ejemplo, List.class , no &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="037a786100af58ee1da0c90e38df1f04d615f726" translate="yes" xml:space="preserve">
          <source>Consider the following variation of the previous snippet:</source>
          <target state="translated">Considere la siguiente variación del recorte anterior:</target>
        </trans-unit>
        <trans-unit id="a34e95f456c0661699837d4636ebb3f2edebde4e" translate="yes" xml:space="preserve">
          <source>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</source>
          <target state="translated">Esencialmente,los tipos crudos se comportan igual que antes de que se introdujeran los genéricos.Es decir,lo siguiente es totalmente legal en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="6313dbb779b20ad4f398638fbcdaa19e63ee873e" translate="yes" xml:space="preserve">
          <source>For Comparison:</source>
          <target state="translated">Para la comparación:</target>
        </trans-unit>
        <trans-unit id="9a6955f50cd2bc2e9964cae7d37ac387cdbb56dc" translate="yes" xml:space="preserve">
          <source>For example, a deserialisation function might return a &lt;code&gt;List&lt;/code&gt;, but it doesn't know the list's element type. So &lt;code&gt;List&lt;/code&gt; is the appropriate return type here.</source>
          <target state="translated">Por ejemplo, una funci&amp;oacute;n de deserializaci&amp;oacute;n puede devolver una &lt;code&gt;List&lt;/code&gt; a , pero no conoce el tipo de elemento de la lista. Entonces &lt;code&gt;List&lt;/code&gt; es el tipo de retorno apropiado aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="e824bccb93fe388c271ceb20b71590f44f37ea03" translate="yes" xml:space="preserve">
          <source>For example, before Java generics was available, you would use a collection class like this:</source>
          <target state="translated">Por ejemplo,antes de que los genéricos de Java estuvieran disponibles,se usaba una clase de colección como esta:</target>
        </trans-unit>
        <trans-unit id="e68e2841763bad1c52ec9e83909704bd0166a574" translate="yes" xml:space="preserve">
          <source>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</source>
          <target state="translated">Por ejemplo,para un método en el que el programador quiere asegurarse de que una variable de la lista llamada &quot;nombres&quot; contiene sólo cadenas:</target>
        </trans-unit>
        <trans-unit id="35882b9379794132d1c5486b062c0880c7da27dd" translate="yes" xml:space="preserve">
          <source>Generics in Java are invariant. A &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, so the following would generate a compiler warning:</source>
          <target state="translated">Los gen&amp;eacute;ricos en Java son invariables. Una &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; no es una &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; , por lo que lo siguiente generar&amp;iacute;a una advertencia de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="47bd8a7573789546aea546b52e9e17f8f529ba04" translate="yes" xml:space="preserve">
          <source>Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</source>
          <target state="translated">Los genéricos se inventaron para sortear esta limitación,el desarrollador declararía el tipo almacenado una vez y el compilador lo haría en su lugar.</target>
        </trans-unit>
        <trans-unit id="d4a604535de856a836d66ebc92fdb85bc5b349f1" translate="yes" xml:space="preserve">
          <source>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</source>
          <target state="translated">Dado que no se deben usar tipos crudos,¿por qué los diseñadores del lenguaje los permitieron? Para proporcionar compatibilidad.</target>
        </trans-unit>
        <trans-unit id="8f83f0fc624d5c25c1d4070c5d15292bc4b6daf3" translate="yes" xml:space="preserve">
          <source>Here I am Considering multiple cases  through which you can clearify  the concept</source>
          <target state="translated">Aquí estoy considerando múltiples casos a través de los cuales se puede aclarar el concepto</target>
        </trans-unit>
        <trans-unit id="7e44f900cff505560d3f89e716fe1e3c0fb1bb5f" translate="yes" xml:space="preserve">
          <source>Here's an example to illustrate:</source>
          <target state="translated">Aquí hay un ejemplo para ilustrar:</target>
        </trans-unit>
        <trans-unit id="dde31552770aa87ec22e55f9344569717d0b6871" translate="yes" xml:space="preserve">
          <source>Here's another case where raw types will bite you:</source>
          <target state="translated">Aquí hay otro caso en el que los tipos crudos te morderán:</target>
        </trans-unit>
        <trans-unit id="67fa04e9f046a5adbebd5113ffaf92fe26a3311b" translate="yes" xml:space="preserve">
          <source>Here's another quote from JLS 4.8:</source>
          <target state="translated">Aquí hay otra cita de JLS 4.8:</target>
        </trans-unit>
        <trans-unit id="43637dfe4455ba4d2171e4f14f305298cd8cd98c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; is a &lt;em&gt;parameterized type&lt;/em&gt; (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt;). It is common to colloquially refer to this type as simply &lt;code&gt;MyType&lt;/code&gt; for short, but technically the name is &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; es un &lt;em&gt;tipo parametrizado&lt;/em&gt; ( &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt; ). Es com&amp;uacute;n referirse coloquialmente a este tipo como simplemente &lt;code&gt;MyType&lt;/code&gt; para abreviar, pero t&amp;eacute;cnicamente el nombre es &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44ce7e40d47187da08c05cca9611e28d52d1fa17" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; as a type parameter?</source>
          <target state="translated">&amp;iquest;En qu&amp;eacute; se diferencia un tipo sin formato de usar &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; Como par&amp;aacute;metro de tipo?</target>
        </trans-unit>
        <trans-unit id="0ed2484f8d50e469e79f1ef84d9f9bad64fc9188" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; as type parameters?</source>
          <target state="translated">&amp;iquest;En qu&amp;eacute; se diferencia un tipo sin formato de usar &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; como par&amp;aacute;metros de tipo?</target>
        </trans-unit>
        <trans-unit id="48564f1fb0c047112af75c3e77e435ffab422e47" translate="yes" xml:space="preserve">
          <source>I found this page after doing some sample exercises and having the exact same puzzlement.</source>
          <target state="translated">Encontré esta página después de hacer algunos ejercicios de muestra y de tener exactamente la misma perplejidad.</target>
        </trans-unit>
        <trans-unit id="748d8dd3315f134cfa40b10f3d5a0a2dff4020c9" translate="yes" xml:space="preserve">
          <source>If it's unsafe, why is it allowed to use a raw type?</source>
          <target state="translated">Si no es seguro,¿por qué se permite usar un tipo crudo?</target>
        </trans-unit>
        <trans-unit id="757cde53b1d07914c3de66734bfcb1a0d037c4db" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Si se omite el argumento de tipo real, crea un tipo sin formato de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9aeb471379aedc5abe716fbf10b8294ce63c6335" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of Box:</source>
          <target state="translated">Si se omite el argumento del tipo real,se crea un tipo de Caja sin procesar:</target>
        </trans-unit>
        <trans-unit id="0cc605baa568c21a2584d85b111e38c62a278623" translate="yes" xml:space="preserve">
          <source>If you had declared &lt;code&gt;appendNewObject&lt;/code&gt; to take a raw type &lt;code&gt;List&lt;/code&gt; as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</source>
          <target state="translated">Si hubiera declarado &lt;code&gt;appendNewObject&lt;/code&gt; para tomar una &lt;code&gt;List&lt;/code&gt; tipos sin procesar como par&amp;aacute;metro, esto se compilar&amp;iacute;a y, por lo tanto, perder&amp;iacute;a la seguridad de tipo que obtiene de los gen&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="dd2d4a705143feb6d0a89160672246231005a289" translate="yes" xml:space="preserve">
          <source>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</source>
          <target state="translated">En general es mejor idea parametrizar las colecciones,así no tendrás problemas de conversión,sólo podrás añadir elementos del tipo parametrizado y tu editor te ofrecerá los métodos apropiados para seleccionar.</target>
        </trans-unit>
        <trans-unit id="3744921c19e7629a4f01f2555627f746743882d4" translate="yes" xml:space="preserve">
          <source>In simpler terms, when a raw type is used, the constructors, instance methods and non-&lt;code&gt;static&lt;/code&gt; fields are &lt;em&gt;also erased&lt;/em&gt;.</source>
          <target state="translated">En t&amp;eacute;rminos m&amp;aacute;s simples, cuando se usa un tipo sin formato, los constructores, los m&amp;eacute;todos de instancia y &lt;code&gt;static&lt;/code&gt; campos no est&amp;aacute;ticos &lt;em&gt;tambi&amp;eacute;n se borran&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="756666332aa7004e808286b5b848c619457b8b90" translate="yes" xml:space="preserve">
          <source>In summary, raw types should NEVER be used in new code. &lt;strong&gt;You should always use parameterized types&lt;/strong&gt;.</source>
          <target state="translated">En resumen, los tipos sin formato NUNCA deben usarse en un c&amp;oacute;digo nuevo. &lt;strong&gt;Siempre debe usar tipos parametrizados&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b474182f196f28b6d9bc2a82197e85bb395fb460" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList arr&lt;/code&gt; is a raw type but your Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; is a Strict type.</source>
          <target state="translated">En este caso, &lt;code&gt;ArrayList arr&lt;/code&gt; es un tipo sin &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; pero su Object new ArrayList &amp;lt;String&amp;gt; (); Es un tipo estricto.</target>
        </trans-unit>
        <trans-unit id="f1c1ae68c9409c5f5812e26d3d923d56dab69ce2" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; is a strict type but your Object &lt;code&gt;new ArrayList();&lt;/code&gt; is a raw type.</source>
          <target state="translated">En este caso, &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; es un tipo estricto pero su Object &lt;code&gt;new ArrayList();&lt;/code&gt; Es un tipo crudo.</target>
        </trans-unit>
        <trans-unit id="8c2f74dfe2af17f55f4ba29be8ccb19139a8d1f6" translate="yes" xml:space="preserve">
          <source>It is a Strict to &lt;code&gt;String&lt;/code&gt; not  a Raw Type so, It will never raise an warning .</source>
          <target state="translated">Es un Strict to &lt;code&gt;String&lt;/code&gt; , no un Raw Type, por lo que nunca generar&amp;aacute; una advertencia.</target>
        </trans-unit>
        <trans-unit id="af64c2b91282b2bc128075031a67b506f57156cd" translate="yes" xml:space="preserve">
          <source>It is possible to use as a type &lt;strong&gt;the erasure&lt;/strong&gt; of a parameterized type or the erasure of an array type whose element type is a parameterized type. &lt;strong&gt;Such a type is called a &lt;em&gt;raw type&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">Es posible utilizar como tipo &lt;strong&gt;la eliminaci&amp;oacute;n&lt;/strong&gt; de un tipo parametrizado o la eliminaci&amp;oacute;n de un tipo de matriz cuyo tipo de elemento es un tipo parametrizado. &lt;strong&gt;Tal tipo se llama &lt;em&gt;tipo crudo&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d69f46a16cf7ee0a31e5e918cb4caa8f4a361e8" translate="yes" xml:space="preserve">
          <source>It may be safer but took 4  hours to demuddle the philosophy...</source>
          <target state="translated">Puede ser más seguro,pero tomó 4 horas para desmantelar la filosofía...</target>
        </trans-unit>
        <trans-unit id="c7b6e70f29e6d47c95b4ce838419d160d7d44651" translate="yes" xml:space="preserve">
          <source>It will add any type of Object into it because &lt;code&gt;arr&lt;/code&gt; is a Raw Type.</source>
          <target state="translated">Agregar&amp;aacute; cualquier tipo de objeto porque &lt;code&gt;arr&lt;/code&gt; es un tipo sin formato.</target>
        </trans-unit>
        <trans-unit id="7c357301ad31d5a2328f52fdfde2afee191052a2" translate="yes" xml:space="preserve">
          <source>JLS 4.8 Raw Types</source>
          <target state="translated">JLS 4.8 Tipos de crudo</target>
        </trans-unit>
        <trans-unit id="d96b21d482d675d54b9a9afda2b5ba4acaaf0b98" translate="yes" xml:space="preserve">
          <source>Java Tutorials/Generics</source>
          <target state="translated">Tutoriales de JavaGenéricos</target>
        </trans-unit>
        <trans-unit id="d9c140e4568d16dd9563d8ab811a377f394c3ad0" translate="yes" xml:space="preserve">
          <source>Just what is the difference between the raw type &lt;code&gt;List&lt;/code&gt; and the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; to a parameter of type &lt;code&gt;List&lt;/code&gt;, you can't pass it to a parameter of type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. There are subtyping rules for generics, and &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a subtype of the raw type &lt;code&gt;List&lt;/code&gt;, but not of the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. As a consequence, &lt;strong&gt;you lose type safety if you use raw type like &lt;code&gt;List&lt;/code&gt;, but not if you use a parameterized type like &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre la &lt;code&gt;List&lt;/code&gt; tipos sin formato y la &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; tipos parametrizados &amp;lt;Objeto&amp;gt; ? Hablando en t&amp;eacute;rminos generales, el primero ha optado por la verificaci&amp;oacute;n de tipos gen&amp;eacute;ricos, mientras que el segundo le dijo expl&amp;iacute;citamente al compilador que es capaz de contener objetos de cualquier tipo. Si bien puede pasar una &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; a un par&amp;aacute;metro de tipo &lt;code&gt;List&lt;/code&gt; a , no puede pasarla a un par&amp;aacute;metro de tipo &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; . Existen reglas de subtipo para gen&amp;eacute;ricos, y &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; es un subtipo del tipo sin procesar &lt;code&gt;List&lt;/code&gt; , pero no del tipo parametrizado &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; . Como consecuencia, &lt;strong&gt;pierde seguridad de tipo si usa un tipo sin procesar como &lt;code&gt;List&lt;/code&gt; , pero no si usa un tipo parametrizado como &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="850a74790dcd52d9b6cd99dd8612f5711bc8e124" translate="yes" xml:space="preserve">
          <source>More complex the Compareable interface:</source>
          <target state="translated">Más compleja la interfaz Comparable:</target>
        </trans-unit>
        <trans-unit id="dfdfd6745128ac64237078d81256b1a171bc2dd6" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to implement the &lt;code&gt;CompareAble&lt;/code&gt; interface with &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; with raw types.
Why you should not use them:</source>
          <target state="translated">Tenga en cuenta que es imposible implementar la interfaz &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; con compareTo (MyCompareAble) con tipos sin formato . Por qu&amp;eacute; no deber&amp;iacute;as usarlos:</target>
        </trans-unit>
        <trans-unit id="296b126e38fe8034587cb665417ce3c7024ae780" translate="yes" xml:space="preserve">
          <source>Note: Example.java uses unchecked or unsafe operations.</source>
          <target state="translated">Nota:Example.java utiliza operaciones no controladas o inseguras.</target>
        </trans-unit>
        <trans-unit id="3499d2ef5e16f0b55aee68466deae9940cc994c4" translate="yes" xml:space="preserve">
          <source>Note: Recompile with -Xlint:unchecked for details.</source>
          <target state="translated">Nota:Recompilar con -Xlint:desmarcado para los detalles.</target>
        </trans-unit>
        <trans-unit id="254f98057318b73a6885ac9033cf6c0a3f78cd90" translate="yes" xml:space="preserve">
          <source>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.</source>
          <target state="translated">Fíjate que con los genéricos no tienes que lanzar el objeto que viene del get call,la colección está predefinida para trabajar sólo con MyObject.Este mismo hecho es el principal factor impulsor de los genéricos.Cambia una fuente de errores en tiempo de ejecución en algo que puede ser comprobado en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="b6af0e34c6cc7075ebe7a4a3f42d6d402756c648" translate="yes" xml:space="preserve">
          <source>Now we run into trouble at run-time, because &lt;code&gt;names&lt;/code&gt; contains something that isn't an &lt;code&gt;instanceof String&lt;/code&gt;.</source>
          <target state="translated">Ahora nos encontramos con problemas en tiempo de ejecuci&amp;oacute;n, porque los &lt;code&gt;names&lt;/code&gt; contienen algo que no es una &lt;code&gt;instanceof String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac370a883ec182a3baba7d9265d02ace81c41512" translate="yes" xml:space="preserve">
          <source>Of course, if you &lt;em&gt;DO&lt;/em&gt; want &lt;code&gt;names&lt;/code&gt; to allow a &lt;code&gt;Boolean&lt;/code&gt;, then you can declare it as &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt;, and the above code would compile.</source>
          <target state="translated">Por supuesto, si desea que los &lt;code&gt;names&lt;/code&gt; permitan un &lt;code&gt;Boolean&lt;/code&gt; , puede declararlo como &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt; , y el c&amp;oacute;digo anterior se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="5f3e174709eebda3c2a288755f4a44a380585674" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</source>
          <target state="translated">Fuente original: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Tutoriales de Java&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecee4396959b71721b4635fbfb006a7cc0e9a651" translate="yes" xml:space="preserve">
          <source>Presumably, if you want &lt;code&gt;names&lt;/code&gt; to contain only &lt;code&gt;String&lt;/code&gt;, you &lt;em&gt;could&lt;/em&gt; perhaps still use a raw type and &lt;em&gt;manually check every&lt;/em&gt;&lt;code&gt;add&lt;/code&gt; yourself, and then &lt;em&gt;manually cast&lt;/em&gt; to &lt;code&gt;String&lt;/code&gt; every item from &lt;code&gt;names&lt;/code&gt;. &lt;strong&gt;Even better&lt;/strong&gt;, though is NOT to use a raw type and &lt;em&gt;let the compiler do all the work for you&lt;/em&gt;, harnessing the power of Java generics.</source>
          <target state="translated">Presumiblemente, si desea que los &lt;code&gt;names&lt;/code&gt; contengan solo &lt;code&gt;String&lt;/code&gt; , tal vez a&amp;uacute;n &lt;em&gt;pueda&lt;/em&gt; usar un tipo sin procesar y &lt;em&gt;verificar manualmente cada&lt;/em&gt; &lt;code&gt;add&lt;/code&gt; usted mismo, y luego &lt;em&gt;convertir manualmente&lt;/em&gt; a &lt;code&gt;String&lt;/code&gt; cada elemento desde los &lt;code&gt;names&lt;/code&gt; . &lt;strong&gt;A&amp;uacute;n mejor&lt;/strong&gt; , aunque NO es usar un tipo sin procesar y &lt;em&gt;dejar que el compilador haga todo el trabajo por usted&lt;/em&gt; , aprovechando el poder de los gen&amp;eacute;ricos de Java.</target>
        </trans-unit>
        <trans-unit id="7e63fc58ab6bfca9e67eebb8a65352e54e0fd330" translate="yes" xml:space="preserve">
          <source>Questions:</source>
          <target state="translated">Questions:</target>
        </trans-unit>
        <trans-unit id="14c39264748158f870d8f43c71ea7f51c1859672" translate="yes" xml:space="preserve">
          <source>Raw types are fine when they express what you want to express.</source>
          <target state="translated">Los tipos crudos están bien cuando expresan lo que quieres expresar.</target>
        </trans-unit>
        <trans-unit id="47f403e27f4c62d43a2933f83a0dd997ab56d1e0" translate="yes" xml:space="preserve">
          <source>Raw types refer to using a generic type without specifying a type parameter.</source>
          <target state="translated">Los tipos crudos se refieren al uso de un tipo genérico sin especificar un parámetro de tipo.</target>
        </trans-unit>
        <trans-unit id="f6709747af5a036dfca6571b0519116f90e0e9ec" translate="yes" xml:space="preserve">
          <source>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior &amp;mdash; a &lt;code&gt;Box&lt;/code&gt; gives you &lt;code&gt;Object&lt;/code&gt;s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</source>
          <target state="translated">Los tipos sin formato aparecen en el c&amp;oacute;digo heredado porque muchas clases de API (como las clases de Colecciones) no eran gen&amp;eacute;ricas antes de JDK 5.0. Cuando se utilizan tipos sin formato, esencialmente se obtiene un comportamiento pre-gen&amp;eacute;rico: un &lt;code&gt;Box&lt;/code&gt; le proporciona &lt;code&gt;Object&lt;/code&gt; . Por compatibilidad con versiones anteriores, se permite asignar un tipo parametrizado a su tipo sin formato:</target>
        </trans-unit>
        <trans-unit id="5edab9471a19ae73475c8ed0622f2789a8bbd38d" translate="yes" xml:space="preserve">
          <source>Raw-type should not be used because it could cause runtime errors, like inserting a &lt;code&gt;double&lt;/code&gt; into what was supposed to be a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">El tipo sin formato no se debe usar porque podr&amp;iacute;a causar errores de tiempo de ejecuci&amp;oacute;n, como insertar un &lt;code&gt;double&lt;/code&gt; en lo que se supon&amp;iacute;a que era un &lt;code&gt;Set&lt;/code&gt; de &lt;code&gt;int&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="b73c83827ddf3571b554094ecd15284c3d9f51ff" translate="yes" xml:space="preserve">
          <source>Raw-types are ancient history of the Java language. In the beginning there were &lt;code&gt;Collections&lt;/code&gt; and they held &lt;code&gt;Objects&lt;/code&gt; nothing more and nothing less. Every operation on &lt;code&gt;Collections&lt;/code&gt; required casts from &lt;code&gt;Object&lt;/code&gt; to the desired type.</source>
          <target state="translated">Los tipos sin procesar son historia antigua del lenguaje Java. Al principio hab&amp;iacute;a &lt;code&gt;Collections&lt;/code&gt; y conten&amp;iacute;an &lt;code&gt;Objects&lt;/code&gt; nada m&amp;aacute;s y nada menos. Cada operaci&amp;oacute;n en &lt;code&gt;Collections&lt;/code&gt; requer&amp;iacute;a lanzamientos de &lt;code&gt;Object&lt;/code&gt; al tipo deseado.</target>
        </trans-unit>
        <trans-unit id="fda027c268c4ae6152aa9f57c1dfaab8a4ae0670" translate="yes" xml:space="preserve">
          <source>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</source>
          <target state="translated">Recopilando el ejemplo anterior con -Xlint:uncheed revela la siguiente información adicional:</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">Tomemos el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="29e893a5bedf20dc1b4e344373155ba8e5623141" translate="yes" xml:space="preserve">
          <source>The Java Language Specification defines a &lt;em&gt;raw type&lt;/em&gt; as follows:</source>
          <target state="translated">La especificaci&amp;oacute;n del lenguaje Java define un &lt;em&gt;tipo sin procesar de la&lt;/em&gt; siguiente manera:</target>
        </trans-unit>
        <trans-unit id="f03d888157a822dae6298c0edd4e09b264238529" translate="yes" xml:space="preserve">
          <source>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as &lt;em&gt;migration compatibility&lt;/em&gt;, drove the decision to support raw types.</source>
          <target state="translated">La plataforma Java estaba a punto de entrar en su segunda d&amp;eacute;cada cuando se introdujeron los gen&amp;eacute;ricos, y exist&amp;iacute;a una enorme cantidad de c&amp;oacute;digo Java que no usaba gen&amp;eacute;ricos. Se consider&amp;oacute; cr&amp;iacute;tico que todo este c&amp;oacute;digo siga siendo legal e interoperable con el nuevo c&amp;oacute;digo que usa gen&amp;eacute;ricos. Ten&amp;iacute;a que ser legal pasar instancias de tipos parametrizados a m&amp;eacute;todos dise&amp;ntilde;ados para su uso con tipos normales, y viceversa. Este requisito, conocido como &lt;em&gt;compatibilidad de migraci&amp;oacute;n&lt;/em&gt; , llev&amp;oacute; a la decisi&amp;oacute;n de admitir tipos sin formato.</target>
        </trans-unit>
        <trans-unit id="405919cad9921e0b63d1c1d0b23b75783e9838de" translate="yes" xml:space="preserve">
          <source>The Type Erasure section has more information on how the Java compiler uses raw types.</source>
          <target state="translated">La sección Borrado de tipos tiene más información sobre cómo el compilador de Java usa los tipos sin procesar.</target>
        </trans-unit>
        <trans-unit id="19cba934a6c7509721bb93f99ce5196844f697ea" translate="yes" xml:space="preserve">
          <source>The above code runs just fine, but suppose you also have the following:</source>
          <target state="translated">El código anterior funciona bien,pero supongamos que también tienes lo siguiente:</target>
        </trans-unit>
        <trans-unit id="ae33c93ae8545a049054d56f94b52ddadc4db2ff" translate="yes" xml:space="preserve">
          <source>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;! If you had declared the parameter as the raw type &lt;code&gt;List list&lt;/code&gt;, then the code would compile, and you'd violate the type invariant of &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;El compilador hizo un trabajo maravilloso al protegerlo de violar potencialmente la invariancia de tipo de la &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; ! Si hubiera declarado el par&amp;aacute;metro como la &lt;code&gt;List list&lt;/code&gt; tipo sin formato , el c&amp;oacute;digo se compilar&amp;iacute;a y violar&amp;iacute;a el tipo invariante de los &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51a5fbcc09ae553d5fd592ab6795f02eaba69382" translate="yes" xml:space="preserve">
          <source>The compiler wants you to write this:</source>
          <target state="translated">El compilador quiere que escribas esto:</target>
        </trans-unit>
        <trans-unit id="0363d591375571e48f68366a7f025385874a4bc8" translate="yes" xml:space="preserve">
          <source>The erasure of the signature of a generic method has no type parameters.</source>
          <target state="translated">La supresión de la firma de un método genérico no tiene parámetros de tipo.</target>
        </trans-unit>
        <trans-unit id="4741487f156eaa93feddb499e8df578c72023c56" translate="yes" xml:space="preserve">
          <source>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-6400189&lt;/a&gt;. (In short, it makes the specification simpler.)</source>
          <target state="translated">El siguiente informe de error contiene algunas reflexiones de Maurizio Cimadamore, un desarrollador del compilador, y Alex Buckley, uno de los autores de JLS, sobre por qu&amp;eacute; deber&amp;iacute;a ocurrir este tipo de comportamiento: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse / JDK-6400189&lt;/a&gt; . (En resumen, simplifica la especificaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="a9f82fe99578f6009d5eb0412ee1e187309afacb" translate="yes" xml:space="preserve">
          <source>The following is a quote from &lt;em&gt;Effective Java 2nd Edition, Item 23: Don't use raw types in new code&lt;/em&gt;:</source>
          <target state="translated">La siguiente es una cita de &lt;em&gt;Effective Java 2nd Edition, Art&amp;iacute;culo 23: No use tipos sin procesar en c&amp;oacute;digo nuevo&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="ba2996d73cdc2d5e8adf9bc06d73367a443e54a0" translate="yes" xml:space="preserve">
          <source>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.</source>
          <target state="translated">Las viejas colecciones sin tipo de letra no podían hacer cumplir la seguridad tipográfica,así que el programador tenía que recordar lo que almacenaba dentro de una colección.</target>
        </trans-unit>
        <trans-unit id="224867fabb32bca2e488d4f0445bcb8a5d12ece3" translate="yes" xml:space="preserve">
          <source>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.</source>
          <target state="translated">La alternativa preferida es usar clases gen&amp;eacute;ricas seg&amp;uacute;n lo previsto, con un argumento de tipo adecuado (por ejemplo, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; ). Esto permite al programador especificar tipos m&amp;aacute;s espec&amp;iacute;ficamente, transmite m&amp;aacute;s significado a los futuros mantenedores sobre el uso previsto de una estructura de datos o variable, y permite al compilador hacer cumplir una mejor seguridad de tipos. Estas ventajas juntas pueden mejorar la calidad del c&amp;oacute;digo y ayudar a prevenir la introducci&amp;oacute;n de algunos errores de codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bdde1ec38079b0f21677aedb8ffed79d4ee40436" translate="yes" xml:space="preserve">
          <source>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</source>
          <target state="translated">El tipo de referencia que se forma tomando el nombre de una declaración de tipo genérico sin una lista de argumentos de tipo adjunta.</target>
        </trans-unit>
        <trans-unit id="7b95d6baee239d3ff4e3ced680ad026c49c8a6fa" translate="yes" xml:space="preserve">
          <source>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</source>
          <target state="translated">Las superclases (respectivamente,superinterfaces)de un tipo crudo son los borrados de las superclases (superinterfaces)de cualquiera de las parametrizaciones del tipo genérico.</target>
        </trans-unit>
        <trans-unit id="028dac7a1835527c760373499e5bd53972c19762" translate="yes" xml:space="preserve">
          <source>The term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.</source>
          <target state="translated">El término &quot;no comprobado&quot; significa que el compilador no tiene suficiente información de tipo para realizar todas las comprobaciones de tipo necesarias para garantizar la seguridad del tipo.La advertencia de &quot;no comprobado&quot; está desactivada,por defecto,aunque el compilador da una pista.Para ver todas las advertencias &quot;desmarcadas&quot;,recompila con -Xlint:desmarcado.</target>
        </trans-unit>
        <trans-unit id="1c1d40c286a32e79507bdccf064061a7398aec1e" translate="yes" xml:space="preserve">
          <source>The type of a constructor, instance method, or non-&lt;code&gt;static&lt;/code&gt; field of a raw type &lt;code&gt;C&lt;/code&gt; that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">El tipo de constructor, m&amp;eacute;todo de instancia o campo no &lt;code&gt;static&lt;/code&gt; de un tipo sin formato &lt;code&gt;C&lt;/code&gt; que no se hereda de sus superclases o superinterfaces es el tipo sin formato que corresponde a la eliminaci&amp;oacute;n de su tipo en la declaraci&amp;oacute;n gen&amp;eacute;rica correspondiente a &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4de2e6bc304bdcf427827a31f05067b528fb6ec7" translate="yes" xml:space="preserve">
          <source>The use of raw types is allowed only as a concession to compatibility of legacy code. &lt;em&gt;The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.&lt;/em&gt;</source>
          <target state="translated">El uso de tipos sin formato solo se permite como una concesi&amp;oacute;n a la compatibilidad del c&amp;oacute;digo heredado. &lt;em&gt;Se desaconseja el uso de tipos sin formato en el c&amp;oacute;digo escrito despu&amp;eacute;s de la introducci&amp;oacute;n de la gen&amp;eacute;rica en el lenguaje de programaci&amp;oacute;n Java.&lt;/em&gt; &lt;em&gt;Es posible que las futuras versiones del lenguaje de programaci&amp;oacute;n Java no permitan el uso de tipos sin formato.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38130b794559a4c9afe8f8b9c015c9dde8e522d2" translate="yes" xml:space="preserve">
          <source>The warning advises that types that are defined to support &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;generics&lt;/a&gt; should be parameterized, rather than using their raw form.</source>
          <target state="translated">La advertencia informa que los tipos definidos para admitir &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;gen&amp;eacute;ricos&lt;/a&gt; deben ser parametrizados, en lugar de utilizar su forma sin formato.</target>
        </trans-unit>
        <trans-unit id="66ca0326f80fbd6c5b5f545e591d10cb1a33c496" translate="yes" xml:space="preserve">
          <source>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</source>
          <target state="translated">La advertencia muestra que los tipos crudos eluden las comprobaciones de tipo genérico,aplazando la captura de código inseguro al tiempo de ejecución.Por lo tanto,debe evitar el uso de tipos crudos.</target>
        </trans-unit>
        <trans-unit id="26f6914ed49c5138e2d0f7911e928bb8bc17625c" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;Box&lt;/code&gt; is the raw type of the generic type &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. However, a non-generic class or interface type is not a raw type.</source>
          <target state="translated">Por lo tanto, &lt;code&gt;Box&lt;/code&gt; es el tipo sin formato del tipo gen&amp;eacute;rico &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; . Sin embargo, una clase no gen&amp;eacute;rica o tipo de interfaz no es un tipo sin formato.</target>
        </trans-unit>
        <trans-unit id="00b4626a1162938da83e931c64651ef346add10f" translate="yes" xml:space="preserve">
          <source>They are less expressive, and don't self-document in the same way as parameterized types
&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">Son menos expresivos y no se documentan de la misma manera que los tipos parametrizados &lt;strong&gt;Ejemplo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebc27a91176efcbb20410934abb5853c0008136" translate="yes" xml:space="preserve">
          <source>They aren't type safe, and some important kinds of errors will only appear at runtime</source>
          <target state="translated">No son seguros de tipo,y algunos tipos importantes de errores sólo aparecerán en tiempo de ejecución</target>
        </trans-unit>
        <trans-unit id="1e9dd9b1ece7f9d0090b47a3a8306fdc209f6a95" translate="yes" xml:space="preserve">
          <source>They usually require casts</source>
          <target state="translated">Por lo general,requieren de yesos</target>
        </trans-unit>
        <trans-unit id="5873e20d029e66a8c51641dd8139270aaedf4381" translate="yes" xml:space="preserve">
          <source>This can happen when using an older API that operates on raw types, as shown in the following example:</source>
          <target state="translated">Esto puede suceder cuando se utiliza una API más antigua que funciona con tipos sin procesar,como se muestra en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="75bbc98951486b296100d29e447bb2550f22a5bd" translate="yes" xml:space="preserve">
          <source>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the &lt;code&gt;CompareAble&lt;/code&gt; interface, I guess that it creates two &lt;code&gt;compareTo&lt;/code&gt; functions, one taking a &lt;code&gt;MyCompareAble&lt;/code&gt; and the other taking an &lt;code&gt;Object&lt;/code&gt; and passing it to the first after casting it.</source>
          <target state="translated">Este es el mismo c&amp;oacute;digo que escribir&amp;iacute;a si utilizara los tipos sin formato directamente. Aunque no estoy seguro de lo que sucede con la interfaz &lt;code&gt;CompareAble&lt;/code&gt; , creo que crea dos funciones &lt;code&gt;compareTo&lt;/code&gt; , una toma &lt;code&gt;MyCompareAble&lt;/code&gt; y la otra toma un &lt;code&gt;Object&lt;/code&gt; y lo pasa al primero despu&amp;eacute;s de lanzarlo.</target>
        </trans-unit>
        <trans-unit id="766f0ea717ddd326371c9d9cdc14d6d42b78ca3d" translate="yes" xml:space="preserve">
          <source>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; annotation suppresses unchecked warnings. If you are unfamiliar with the &lt;code&gt;@SuppressWarnings&lt;/code&gt; syntax, see Annotations.</source>
          <target state="translated">Para deshabilitar completamente las advertencias no verificadas, use el indicador -Xlint: -unchecked. La &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; suprime las advertencias sin marcar. Si no est&amp;aacute; familiarizado con la sintaxis de &lt;code&gt;@SuppressWarnings&lt;/code&gt; , consulte Anotaciones.</target>
        </trans-unit>
        <trans-unit id="80251fc31dcb833fa8957ce6961b665392d800db" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, you supply an actual type argument for the formal type parameter &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Para crear un tipo parametrizado de &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , debe proporcionar un argumento de tipo real para el par&amp;aacute;metro de tipo formal &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="738e743b4a29658389df8f72c91705203651edac" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:</source>
          <target state="translated">Para crear un tipo de Box parametrizado,se proporciona un argumento de tipo real para el parámetro de tipo formal T:</target>
        </trans-unit>
        <trans-unit id="2e0d2fd5cc02c819f4b51dbe7cb93f09af65fbd8" translate="yes" xml:space="preserve">
          <source>To illustrate the point, consider the following method which takes a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; and appends a &lt;code&gt;new Object()&lt;/code&gt;.</source>
          <target state="translated">Para ilustrar el punto, considere el siguiente m&amp;eacute;todo que toma un &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; y agrega un &lt;code&gt;new Object()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="556b94a170a618efa12635f0635c19579ef283b9" translate="yes" xml:space="preserve">
          <source>Unchecked Error Messages</source>
          <target state="translated">Mensajes de error no comprobados</target>
        </trans-unit>
        <trans-unit id="1488eddd4ac4e26c448d84102357cfa845ad5972" translate="yes" xml:space="preserve">
          <source>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</source>
          <target state="translated">Desafortunadamente,debido a que los genéricos de Java no están reificados,hay dos excepciones en las que los tipos crudos deben ser usados en el nuevo código:</target>
        </trans-unit>
        <trans-unit id="1e5e7d3116ebd3de1a83a1241dab9045f1ec61bf" translate="yes" xml:space="preserve">
          <source>Using generics enables compile time checks</source>
          <target state="translated">El uso de genéricos permite compilar controles de tiempo</target>
        </trans-unit>
        <trans-unit id="c633498ea9a29fa72a0bbecb71a9da972a698387" translate="yes" xml:space="preserve">
          <source>Using generics, you remove the &quot;unknown&quot; factor, because you must explicitly specify which type of objects can go in the list:</source>
          <target state="translated">Utilizando los genéricos,se elimina el factor &quot;desconocido&quot;,porque se debe especificar explícitamente qué tipo de objetos pueden ir en la lista:</target>
        </trans-unit>
        <trans-unit id="374c5fd146735c599512bad185fd1451f407b63e" translate="yes" xml:space="preserve">
          <source>Using raw types is the same as storing each value as &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">Usar tipos sin formato es lo mismo que almacenar cada valor como &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eab2ae60ad80fc1f68d0fef0fa0d1c390dad5ca0" translate="yes" xml:space="preserve">
          <source>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</source>
          <target state="translated">¿Qué son los tipos crudos en Java,y por qué a menudo escucho que no deben ser usados en el nuevo código?</target>
        </trans-unit>
        <trans-unit id="30ee936b3a2d7e626d1240eed0e0228cdf2781b3" translate="yes" xml:space="preserve">
          <source>What are the alternatives to raw types: Use &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;generics&lt;/a&gt;</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son las alternativas a los tipos sin procesar: usar &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;gen&amp;eacute;ricos&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13e18159e991cbf27833d847ecb850a6500c5b60" translate="yes" xml:space="preserve">
          <source>What is a raw type and why shouldn't we use it</source>
          <target state="translated">¿Qué es un tipo crudo y por qué no deberíamos usarlo</target>
        </trans-unit>
        <trans-unit id="d33f524f99b128a863eea8abf8b22cdb547ff070" translate="yes" xml:space="preserve">
          <source>What is a raw type?</source>
          <target state="translated">¿Qué es un tipo crudo?</target>
        </trans-unit>
        <trans-unit id="0c94f16920c76542bf263ada24624cb0b28ce1fd" translate="yes" xml:space="preserve">
          <source>What is saying is that your &lt;code&gt;list&lt;/code&gt; is a &lt;code&gt;List&lt;/code&gt; of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</source>
          <target state="translated">Lo que est&amp;aacute; diciendo es que su &lt;code&gt;list&lt;/code&gt; a es una &lt;code&gt;List&lt;/code&gt; a de objetos no especificados. Es decir, Java no sabe qu&amp;eacute; tipo de objetos est&amp;aacute;n dentro de la lista. Luego, cuando desee iterar la lista, debe convertir cada elemento para poder acceder a las propiedades de ese elemento (en este caso, Cadena).</target>
        </trans-unit>
        <trans-unit id="fdeab1d68011a57fce4cd4ba9f9c74abe4ff5bea" translate="yes" xml:space="preserve">
          <source>What is the alternative if we can't use raw types, and how is it better?</source>
          <target state="translated">¿Cuál es la alternativa si no podemos usar tipos crudos,y cómo es mejor?</target>
        </trans-unit>
        <trans-unit id="7e187deccee3bced2f61d49a1c4f1805a24f3514" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2000b4089ba1692a89afa72ea69f43fb13328c31" translate="yes" xml:space="preserve">
          <source>What the compiler does:
Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</source>
          <target state="translated">Lo que hace el compilador:Los genéricos son compatibles hacia atrás,usan las mismas clases de java que los tipos crudos.La magia ocurre mayormente en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="4f8e701743ca8556df10918c1399924693590de0" translate="yes" xml:space="preserve">
          <source>What's so special about raw types?</source>
          <target state="translated">¿Qué tienen de especial los tipos crudos?</target>
        </trans-unit>
        <trans-unit id="c0bec40361472ae5df662e245af72cd245cacb6e" translate="yes" xml:space="preserve">
          <source>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java. Although using raw types is still possible,</source>
          <target state="translated">Cuando se introdujeron los genéricos en el JDK 1.5,los tipos crudos se conservaron sólo para mantener la compatibilidad con versiones anteriores de Java.Aunque el uso de tipos crudos todavía es posible,</target>
        </trans-unit>
        <trans-unit id="07f051d6fc7fc8fbf515fd0cd3c1f563cb40b271" translate="yes" xml:space="preserve">
          <source>When retrieving the stuff from the &lt;code&gt;Set&lt;/code&gt;, you don't know what is coming out. Let's assume that you expect it to be all &lt;code&gt;int&lt;/code&gt;s, you are casting it to &lt;code&gt;Integer&lt;/code&gt;; exception at runtime when the &lt;code&gt;double&lt;/code&gt; 3.45 comes along.</source>
          <target state="translated">Al recuperar las cosas del &lt;code&gt;Set&lt;/code&gt; , no sabes lo que est&amp;aacute; saliendo. Supongamos que espera que sea todo &lt;code&gt;int&lt;/code&gt; s, lo est&amp;aacute; transmitiendo a &lt;code&gt;Integer&lt;/code&gt; ; excepci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n cuando aparece el &lt;code&gt;double&lt;/code&gt; 3.45.</target>
        </trans-unit>
        <trans-unit id="229813f4d96b2d1b1f45b96f3d4597193f7d55d2" translate="yes" xml:space="preserve">
          <source>When we use the raw &lt;code&gt;MyType&lt;/code&gt;, &lt;code&gt;getNames&lt;/code&gt; becomes erased as well, so that it returns a raw &lt;code&gt;List&lt;/code&gt;!</source>
          <target state="translated">Cuando usamos &lt;code&gt;MyType&lt;/code&gt; sin procesar , &lt;code&gt;getNames&lt;/code&gt; tambi&amp;eacute;n se borra, de modo que devuelve una &lt;code&gt;List&lt;/code&gt; a sin procesar.</target>
        </trans-unit>
        <trans-unit id="03b03c443a4d1bf6d6fc2a3db1b553df7f30657f" translate="yes" xml:space="preserve">
          <source>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</source>
          <target state="translated">Cuando añades un objeto a la lista,no importa de qué tipo es,y cuando lo sacas de la lista,tienes que echarlo explícitamente al tipo que esperas.</target>
        </trans-unit>
        <trans-unit id="c740556a6d482ca7b34342229dd689c7478cd44e" translate="yes" xml:space="preserve">
          <source>While this worked most of the time, errors did happen</source>
          <target state="translated">Si bien esto funcionó la mayor parte del tiempo,se produjeron errores</target>
        </trans-unit>
        <trans-unit id="f1d1a366a93b477706dd8b3d6105c9c1a9eeba6a" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; Illegal?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; la &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; ilegal?</target>
        </trans-unit>
        <trans-unit id="1719e030f1ab15bdc53d7b641986ffbe8aab10b1" translate="yes" xml:space="preserve">
          <source>Will be compiled as:</source>
          <target state="translated">Será compilado como:</target>
        </trans-unit>
        <trans-unit id="dee4689d8bcf66596d11372b703adb5272094959" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;type parameter&lt;/em&gt; added to your &lt;code&gt;Set&lt;/code&gt;, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</source>
          <target state="translated">Con un &lt;em&gt;par&amp;aacute;metro de tipo&lt;/em&gt; agregado a su &lt;code&gt;Set&lt;/code&gt; , obtendr&amp;aacute; un error de compilaci&amp;oacute;n de inmediato. Este error preventivo le permite solucionar el problema antes de que algo explote durante el tiempo de ejecuci&amp;oacute;n (ahorrando tiempo y esfuerzo).</target>
        </trans-unit>
        <trans-unit id="a7d70712fc20b205ca2cc8c4b74bad333f629980" translate="yes" xml:space="preserve">
          <source>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</source>
          <target state="translated">También se obtiene una advertencia si se utiliza un tipo crudo para invocar métodos genéricos definidos en el tipo genérico correspondiente:</target>
        </trans-unit>
        <trans-unit id="197389cd6f3b37b3190a3a6a52add9e46a256131" translate="yes" xml:space="preserve">
          <source>You should specify the type-parameter.</source>
          <target state="translated">Debe especificar el parámetro del tipo.</target>
        </trans-unit>
        <trans-unit id="1ac174dc270f36327a0a027750b18bebbfaf4d7a" translate="yes" xml:space="preserve">
          <source>because otherwise, you could add any type you like into &lt;code&gt;list&lt;/code&gt;, making the instantiation as &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; pointless. Java generics are a compile-time feature only, so an object created with &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; will happily accept &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;JFrame&lt;/code&gt; elements if assigned to a reference of the &quot;raw type&quot; &lt;code&gt;List&lt;/code&gt; - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</source>
          <target state="translated">porque de lo contrario, podr&amp;iacute;a agregar cualquier tipo que desee en la &lt;code&gt;list&lt;/code&gt; a , haciendo que la instanciaci&amp;oacute;n como &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; tenga sentido. Los gen&amp;eacute;ricos de Java son solo una caracter&amp;iacute;stica de tiempo de compilaci&amp;oacute;n, por lo que un objeto creado con la &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; aceptar&amp;aacute; felizmente elementos &lt;code&gt;Integer&lt;/code&gt; o &lt;code&gt;JFrame&lt;/code&gt; si se le asigna a una referencia de la lista de &quot;tipos sin formato&quot;: el objeto en s&amp;iacute; mismo no sabe nada sobre qu&amp;eacute; tipos se supone que contiene, solo el compilador lo hace.</target>
        </trans-unit>
        <trans-unit id="ea7878de5b8eeb89d003e785fa175fd505a012b3" translate="yes" xml:space="preserve">
          <source>here &lt;code&gt;arr&lt;/code&gt; is a Strict type. So, It will raise compile time error when adding a &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">aqu&amp;iacute; &lt;code&gt;arr&lt;/code&gt; es un tipo estricto. Por lo tanto, generar&amp;aacute; un error de tiempo de compilaci&amp;oacute;n al agregar un &lt;code&gt;integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2927dfb347fedd73a36f6f620a3aae2975129af7" translate="yes" xml:space="preserve">
          <source>java generics (not) covariance</source>
          <target state="translated">covarianza de los genéricos java (no)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
