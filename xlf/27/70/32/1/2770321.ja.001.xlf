<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2770321">
    <body>
      <group id="2770321">
        <trans-unit id="9bb688abe7c73fe83082a7942e2afa010b95bd2e" translate="yes" xml:space="preserve">
          <source>&quot;Raw types&quot; are used for backwards compatibility. Their use in new code is not recommended because using the generic class with a type argument allows for stronger typing, which in turn may improve code understandability and lead to catching potential problems earlier.</source>
          <target state="translated">&quot;Raw types&quot; は下位互換性のために使用されます。なぜなら、ジェネリッククラスを型引数で使用することでより強力な型付けが可能になるため、新しいコードでの使用は推奨されていません。</target>
        </trans-unit>
        <trans-unit id="5e202a8885e8f2a0b0b18f657d2d758c8387e684" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt; continues to explain the following:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6&quot;&gt;JLS 4.6&lt;/a&gt;は引き続き次のことを説明します。</target>
        </trans-unit>
        <trans-unit id="9bcbbc30c3a268dc93ee0fcdcac237b04fa72318" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;tutorial page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;チュートリアルページ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5eeaf258c2f69574da220e548fe8afb66742168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; it is a &lt;code&gt;ArrayList&lt;/code&gt; reference variable with type &lt;code&gt;String&lt;/code&gt; which reference to a &lt;code&gt;ArralyList&lt;/code&gt; Object of Type &lt;code&gt;String&lt;/code&gt;. It means it can hold only String type Object.</source>
          <target state="translated">&lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; これは、タイプ &lt;code&gt;String&lt;/code&gt; の &lt;code&gt;ArralyList&lt;/code&gt; オブジェクトを参照するタイプStringの &lt;code&gt;ArrayList&lt;/code&gt; 参照変数です 。 つまり、String型のオブジェクトのみを保持できます。</target>
        </trans-unit>
        <trans-unit id="5b6476b68a8bec6fe2c018b1e2dce00d036d2c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;, etc are all &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;, so it may be tempting to just say that they're just &lt;code&gt;List&lt;/code&gt; instead. However, there is a major difference: since a &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; defines only &lt;code&gt;add(E)&lt;/code&gt;, you can't add just any arbitrary object to a &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;. On the other hand, since the raw type &lt;code&gt;List&lt;/code&gt; does not have type safety, you can &lt;code&gt;add&lt;/code&gt; just about anything to a &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 、 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; などはすべて &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; であるため、代わりに単なる &lt;code&gt;List&lt;/code&gt; であると言いたくなるかもしれません。 ただし、大きな違いがあります。List &lt;code&gt;List&amp;lt;E&amp;gt;&lt;/code&gt; は &lt;code&gt;add(E)&lt;/code&gt; のみを定義するため、任意のオブジェクトだけを &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 追加することはできません。 一方、生の型 &lt;code&gt;List&lt;/code&gt; は型の安全性がないため、 リストにはほとんど何でも &lt;code&gt;add&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="c965c3b6097bff5c3d5f7d3ca7b09048dacbe93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;List&lt;/code&gt; is defined to support generics: &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt;. This allows many type-safe operations, that are checked compile-time.</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; はジェネリックをサポートするように定義されています： &lt;code&gt;public class List&amp;lt;E&amp;gt;&lt;/code&gt; 。 これにより、コンパイル時にチェックされる多くのタイプセーフな操作が可能になります。</target>
        </trans-unit>
        <trans-unit id="29a69c16f89c3fd935dd606a5d4b3dbdabe380d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MyType.Nested&lt;/code&gt; is not a parameterized type, even though it's a member type of a parameterized type &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;, because it's &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MyType.Nested&lt;/code&gt; は &lt;code&gt;static&lt;/code&gt; であるため、パラメーター化された型 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; メンバー型ですが、パラメーター化された型ではありません。</target>
        </trans-unit>
        <trans-unit id="f052ee67a2af0dd5f9f4bd5d42450f8187a17d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; operand, e.g. &lt;code&gt;o instanceof Set&lt;/code&gt;, not &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; オペランド、たとえば &lt;code&gt;o instanceof Set&lt;/code&gt; &lt;code&gt;o instanceof Set&amp;lt;String&amp;gt;&lt;/code&gt; ではなくo instanceof Set</target>
        </trans-unit>
        <trans-unit id="3aa367113494aa1a8fa752010519a9dd14831d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt1&lt;/code&gt;, and &lt;code&gt;mt2&lt;/code&gt; are both declared with actual type parameters, so they're not raw types.</source>
          <target state="translated">&lt;code&gt;mt1&lt;/code&gt; と &lt;code&gt;mt2&lt;/code&gt; はどちらも実際の型パラメーターで宣言されているため、生の型ではありません。</target>
        </trans-unit>
        <trans-unit id="c778f211d4f54dd9219432d85be2ae77c19c5d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt&lt;/code&gt; has a raw type (and generates a compilation warning) by the first bullet point in the above definition; &lt;code&gt;inn&lt;/code&gt; also has a raw type by the third bullet point.</source>
          <target state="translated">&lt;code&gt;mt&lt;/code&gt; には、上記の定義の最初の箇条書きによるrawタイプ（およびコンパイル警告を生成）があります。 &lt;code&gt;inn&lt;/code&gt; も3番目の箇条書きでrawタイプを持っています。</target>
        </trans-unit>
        <trans-unit id="bcbfd569522fe96225142a9dbce9d9b99256d6ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Effective Java 2nd Edition&lt;/em&gt; also has this to add:</source>
          <target state="translated">&lt;em&gt;効果的なJava 2nd Edition&lt;/em&gt;には、これを追加する機能もあります。</target>
        </trans-unit>
        <trans-unit id="06c568b39defa968eaf6d417143a99d437431f20" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For example&lt;/em&gt;,</source>
          <target state="translated">&lt;em&gt;たとえば&lt;/em&gt; 、</target>
        </trans-unit>
        <trans-unit id="3120d5d3ec33fa18134615010180259f358798d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is a raw type and why do I often hear that they shouldn't be used in new code?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rawタイプとは何ですか？なぜそれらが新しいコードで使用されるべきではないとしばしば聞かれるのですか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd279a8439dba2e5fdaf708d98b1db46ee00ff1e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What is the alternative if we can't use raw types, and how is it better?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;生の型を使用できない場合の代替策は何ですか？それはどのように優れていますか？&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b80e7105e2584ff1d4ed97bfe515dcd23c4b2311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[...]&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[...]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e42a4f633bcd32dbe51455ca6bdd7612a294cb1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid raw types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;生の型を避ける&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e599fb38e4978d9cad0bf8657fc35335efcaf1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For reference&lt;/strong&gt;: &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;参照用&lt;/strong&gt; ： &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;https&lt;/a&gt; : //docs.oracle.com/javase/tutorial/java/generics/rawTypes.html</target>
        </trans-unit>
        <trans-unit id="6c5165c71ee10325066370d72c5f9a39d27bb232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The return type of a method and the type parameters of a generic method or constructor also undergo erasure if the method or constructor's signature is erased.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;メソッドまたはコンストラクターのシグニチャーが消去されると、メソッドの戻りタイプおよびジェネリックメソッドまたはコンストラクターのタイプパラメーターも消去されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4311a85106cdf76087c5d49e5214fd1bb252ec93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They should be avoided&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;彼らは避けるべきです&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f0d740fb2f9099a842f154be27e6d2d6ade17b18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type erasure also maps the signature of a constructor or method to a signature that has no parameterized types or type variables.&lt;/strong&gt; The erasure of a constructor or method signature &lt;code&gt;s&lt;/code&gt; is a signature consisting of the same name as &lt;code&gt;s&lt;/code&gt; and the erasures of all the formal parameter types given in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;型消去は、コンストラクターまたはメソッドのシグニチャーを、パラメーター化された型または型変数を持たないシグニチャーにマップします。&lt;/strong&gt; コンストラクターまたはメソッドシグネチャ &lt;code&gt;s&lt;/code&gt; の消去は、 &lt;code&gt;s&lt;/code&gt; と同じ名前とsで指定されたすべての仮パラメータータイプの消去で構成されるシグネチャです。</target>
        </trans-unit>
        <trans-unit id="365cf8a2d2c5f7bc6bd0f00615a2382dd4286f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Raw&lt;/code&gt; Type Object is referenced to a &lt;code&gt;Strict&lt;/code&gt; type Referenced Variable of &lt;code&gt;ArrayList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ： &lt;code&gt;Raw&lt;/code&gt; タイプオブジェクトは、 &lt;code&gt;ArrayList&lt;/code&gt; の &lt;code&gt;Strict&lt;/code&gt; タイプの参照変数を参照しています。</target>
        </trans-unit>
        <trans-unit id="5f5cf18f48861714cd2c12682318f23cca1637eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt; :- A &lt;code&gt;Strict&lt;/code&gt; Type Object is referenced to a &lt;code&gt;raw&lt;/code&gt; type referenced Variable.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：- &lt;code&gt;Strict&lt;/code&gt; 型オブジェクトは、 &lt;code&gt;raw&lt;/code&gt; 型で参照される変数を参照しています。</target>
        </trans-unit>
        <trans-unit id="90a252e2d44f3f2a8b1890033755001338955145" translate="yes" xml:space="preserve">
          <source>============== I went from this code as provide by the sample ===============</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2eab9097b3ec971d127fbaff91ee92679421cbf" translate="yes" xml:space="preserve">
          <source>====================== To This code ========================</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a19b8e149aed7175b12239c8772988575617b7c" translate="yes" xml:space="preserve">
          <source>A &quot;raw type&quot; is the use of a generic class without specifying a type argument(s) for its parameterized type(s), e.g. using &lt;code&gt;List&lt;/code&gt; instead of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;. When generics were introduced into Java, several classes were updated to use generics.  Using these class as a &quot;raw type&quot; (without specifying a type argument) allowed legacy code to still compile.</source>
          <target state="translated">「生の型」とは、パラメーター化された型の型引数を指定せずにジェネリッククラスを使用することです。たとえば、 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 代わりにListを使用します。 ジェネリックがJavaに導入されたとき、ジェネリックを使用するようにいくつかのクラスが更新されました。 これらのクラスを「生の型」として（型引数を指定せずに）使用すると、レガシーコードをコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="33ba04d196a3008973ddc2524394442fa33e4d49" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; type in Java is a class which is non-generic and deals with &quot;raw&quot; Objects, rather than type-safe generic type parameters.</source>
          <target state="translated">Javaにおける「生」型とは、型安全な汎用型パラメータではなく、非汎用型で「生」のオブジェクトを扱うクラスのことです。</target>
        </trans-unit>
        <trans-unit id="c99659ce7dbf112bd14117c16ebbd8db3d175959" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;raw&lt;/em&gt;-type is the a lack of a &lt;em&gt;type parameter&lt;/em&gt; when using a generic type.</source>
          <target state="translated">&lt;em&gt;raw&lt;/em&gt;タイプは、ジェネリックタイプを使用する場合の&lt;em&gt;タイプパラメータの&lt;/em&gt;欠如です。</target>
        </trans-unit>
        <trans-unit id="a826d4198daa01070b87640f459ca71ec283ab02" translate="yes" xml:space="preserve">
          <source>A list is a raw type, while &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a parameterized type.</source>
          <target state="translated">リストは生の型ですが、 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; はパラメーター化された型です。</target>
        </trans-unit>
        <trans-unit id="f8572ed900bc3ec607e2c608d6c9250f0ee36db6" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; member type of a raw type &lt;code&gt;R&lt;/code&gt; that is not inherited from a superclass or superinterface of &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; のスーパークラスまたはスーパーインターフェースから継承されていない、 R型の非 &lt;code&gt;static&lt;/code&gt; メンバー型。</target>
        </trans-unit>
        <trans-unit id="6a5287cb23f3eeae5edf828005202ed23e61a642" translate="yes" xml:space="preserve">
          <source>A raw type is defined to be one of:</source>
          <target state="translated">生型は、以下のいずれかであると定義されています。</target>
        </trans-unit>
        <trans-unit id="205748e8c233f71145a1f2bd274309746828335f" translate="yes" xml:space="preserve">
          <source>A raw type is the erasure of that type</source>
          <target state="translated">生型はその型の消去</target>
        </trans-unit>
        <trans-unit id="6a29e532dca4388e029fb3ea7d50673d5d01e2fd" translate="yes" xml:space="preserve">
          <source>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</source>
          <target state="translated">生の型とは、型の引数を持たない一般的なクラスやインターフェースの名前です。例えば、ジェネリックなBoxクラスが与えられているとします。</target>
        </trans-unit>
        <trans-unit id="8845a4e3b681a7b8affa2bfb6f73c348d4d14738" translate="yes" xml:space="preserve">
          <source>An array type whose element type is a raw type.</source>
          <target state="translated">要素の型が生型である配列型。</target>
        </trans-unit>
        <trans-unit id="aca82bd9f96a2ad182aa1d73db0796bc4f782989" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Object&lt;/code&gt; stored in a &lt;code&gt;Collection&lt;/code&gt; has to be cast before it can be used</source>
          <target state="translated">&lt;code&gt;Collection&lt;/code&gt; 格納されている &lt;code&gt;Object&lt;/code&gt; は、使用する前にキャストする必要があります</target>
        </trans-unit>
        <trans-unit id="7d029af1223f081b1921aa7f94ee3bf1b6d1d8ad" translate="yes" xml:space="preserve">
          <source>Are there no exceptions?</source>
          <target state="translated">例外はないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="340c1df6af27884fb6eb161fdf86234b7c9f6b06" translate="yes" xml:space="preserve">
          <source>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</source>
          <target state="translated">前述したように、レガシーコードとジェネリックコードを混ぜると、以下のような警告メッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="5c59276c92cf37b7805c3861f7c5d5b2178bb735" translate="yes" xml:space="preserve">
          <source>As was mentioned in the accepted answer, you lose all support for generics within the code of the raw type. Every type parameter is converted to its erasure (which in the above example is just &lt;code&gt;Object&lt;/code&gt;).</source>
          <target state="translated">受け入れられた回答で述べたように、生の型のコード内のジェネリックのサポートはすべて失われます。 すべての型パラメーターは、消去（上記の例では単なる &lt;code&gt;Object&lt;/code&gt; ）に変換されます。</target>
        </trans-unit>
        <trans-unit id="54ed0f30909fe006459ed6df04d66c2798441b16" translate="yes" xml:space="preserve">
          <source>Back to JLS 4.8:</source>
          <target state="translated">JLS 4.8 に戻る。</target>
        </trans-unit>
        <trans-unit id="6b592f4fe7b7afd4d7a2840c62e109cd230efddb" translate="yes" xml:space="preserve">
          <source>But if you assign a raw type to a parameterized type, you get a warning:</source>
          <target state="translated">しかし、パラメータ化された型に生の型を代入すると警告が出ます。</target>
        </trans-unit>
        <trans-unit id="03b28b2417326b91d54010c203487876d052c1ec" translate="yes" xml:space="preserve">
          <source>Case 1</source>
          <target state="translated">ケース1</target>
        </trans-unit>
        <trans-unit id="ee1189515944c7f281c8f48e390364b2fc748d15" translate="yes" xml:space="preserve">
          <source>Case 2</source>
          <target state="translated">ケース2</target>
        </trans-unit>
        <trans-unit id="16024e7ee398804bd61c244d6dfbc1dea703c6c9" translate="yes" xml:space="preserve">
          <source>Case 3</source>
          <target state="translated">ケース3</target>
        </trans-unit>
        <trans-unit id="5928bc5d24ccc7a0cbc69187317ba17c2da6578c" translate="yes" xml:space="preserve">
          <source>Class literals, e.g. &lt;code&gt;List.class&lt;/code&gt;, not &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt;</source>
          <target state="translated">クラスリテラル。例： &lt;code&gt;List&amp;lt;String&amp;gt;.class&lt;/code&gt; ではなく &lt;code&gt;List.class&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="037a786100af58ee1da0c90e38df1f04d615f726" translate="yes" xml:space="preserve">
          <source>Consider the following variation of the previous snippet:</source>
          <target state="translated">先ほどのスニペットの次のバリエーションを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a34e95f456c0661699837d4636ebb3f2edebde4e" translate="yes" xml:space="preserve">
          <source>Essentially, raw types behaves just like they were before generics were introduced. That is, the following is entirely legal at compile-time.</source>
          <target state="translated">基本的に raw 型は、ジェネリックが導入される前と同じように振る舞います。つまり、以下はコンパイル時に完全に合法です。</target>
        </trans-unit>
        <trans-unit id="6313dbb779b20ad4f398638fbcdaa19e63ee873e" translate="yes" xml:space="preserve">
          <source>For Comparison:</source>
          <target state="translated">比較のために。</target>
        </trans-unit>
        <trans-unit id="9a6955f50cd2bc2e9964cae7d37ac387cdbb56dc" translate="yes" xml:space="preserve">
          <source>For example, a deserialisation function might return a &lt;code&gt;List&lt;/code&gt;, but it doesn't know the list's element type. So &lt;code&gt;List&lt;/code&gt; is the appropriate return type here.</source>
          <target state="translated">たとえば、逆シリアル化関数は &lt;code&gt;List&lt;/code&gt; を返す場合がありますが、リストの要素の種類はわかりません。 したがって、ここでは &lt;code&gt;List&lt;/code&gt; が適切な戻り型です。</target>
        </trans-unit>
        <trans-unit id="e824bccb93fe388c271ceb20b71590f44f37ea03" translate="yes" xml:space="preserve">
          <source>For example, before Java generics was available, you would use a collection class like this:</source>
          <target state="translated">例えば、Javaジェネリックが利用できるようになる前は、このようなコレクションクラスを使っていました。</target>
        </trans-unit>
        <trans-unit id="e68e2841763bad1c52ec9e83909704bd0166a574" translate="yes" xml:space="preserve">
          <source>For example, for a method where the programmer wants to ensure a List variable called 'names' contains only Strings:</source>
          <target state="translated">例えば、プログラマが 'names' という名前のリスト変数に文字列のみを含むようにしたい場合のメソッドの場合。</target>
        </trans-unit>
        <trans-unit id="35882b9379794132d1c5486b062c0880c7da27dd" translate="yes" xml:space="preserve">
          <source>Generics in Java are invariant. A &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is not a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;, so the following would generate a compiler warning:</source>
          <target state="translated">Javaのジェネリックスは不変です。 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; は &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; ではないため、次の場合はコンパイラの警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="47bd8a7573789546aea546b52e9e17f8f529ba04" translate="yes" xml:space="preserve">
          <source>Generics where invented to get around this limitation, the developer would declare the stored type once and the compiler would do it instead.</source>
          <target state="translated">ジェネリックはこの制限を回避するために発明されたもので、開発者は一度ストアド型を宣言し、代わりにコンパイラがそれを行います。</target>
        </trans-unit>
        <trans-unit id="d4a604535de856a836d66ebc92fdb85bc5b349f1" translate="yes" xml:space="preserve">
          <source>Given that you shouldn't use raw types, why did the language designers allow them? To provide compatibility.</source>
          <target state="translated">生の型を使うべきではないことを考えると、なぜ言語設計者はそれを許可したのでしょうか?互換性を提供するためです。</target>
        </trans-unit>
        <trans-unit id="8f83f0fc624d5c25c1d4070c5d15292bc4b6daf3" translate="yes" xml:space="preserve">
          <source>Here I am Considering multiple cases  through which you can clearify  the concept</source>
          <target state="translated">ここでは、概念を明確にすることができる複数のケースを検討しています。</target>
        </trans-unit>
        <trans-unit id="7e44f900cff505560d3f89e716fe1e3c0fb1bb5f" translate="yes" xml:space="preserve">
          <source>Here's an example to illustrate:</source>
          <target state="translated">例を挙げて説明します。</target>
        </trans-unit>
        <trans-unit id="dde31552770aa87ec22e55f9344569717d0b6871" translate="yes" xml:space="preserve">
          <source>Here's another case where raw types will bite you:</source>
          <target state="translated">ここにも生タイプが噛み付いてくるケースがあります。</target>
        </trans-unit>
        <trans-unit id="67fa04e9f046a5adbebd5113ffaf92fe26a3311b" translate="yes" xml:space="preserve">
          <source>Here's another quote from JLS 4.8:</source>
          <target state="translated">ここにも JLS 4.8 からの引用があります。</target>
        </trans-unit>
        <trans-unit id="43637dfe4455ba4d2171e4f14f305298cd8cd98c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; is a &lt;em&gt;parameterized type&lt;/em&gt; (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt;). It is common to colloquially refer to this type as simply &lt;code&gt;MyType&lt;/code&gt; for short, but technically the name is &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; は&lt;em&gt;パラメーター化されたタイプです&lt;/em&gt; （ &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5&quot;&gt;JLS 4.5&lt;/a&gt; ）。 このタイプを口語的に単に &lt;code&gt;MyType&lt;/code&gt; と略して呼ぶのが一般的ですが、技術的には名前は &lt;code&gt;MyType&amp;lt;E&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="44ce7e40d47187da08c05cca9611e28d52d1fa17" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; as a type parameter?</source>
          <target state="translated">生の型は、型パラメーターとして &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; を使用する場合とどう違うのですか？</target>
        </trans-unit>
        <trans-unit id="0ed2484f8d50e469e79f1ef84d9f9bad64fc9188" translate="yes" xml:space="preserve">
          <source>How's a raw type different from using &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; as type parameters?</source>
          <target state="translated">生の型は、型パラメーターとして &lt;code&gt;&amp;lt;Object&amp;gt;&lt;/code&gt; を使用するのとどのように異なりますか？</target>
        </trans-unit>
        <trans-unit id="48564f1fb0c047112af75c3e77e435ffab422e47" translate="yes" xml:space="preserve">
          <source>I found this page after doing some sample exercises and having the exact same puzzlement.</source>
          <target state="translated">いくつかのサンプル演習をした後にこのページを見つけたのですが、全く同じような戸惑いがありました。</target>
        </trans-unit>
        <trans-unit id="748d8dd3315f134cfa40b10f3d5a0a2dff4020c9" translate="yes" xml:space="preserve">
          <source>If it's unsafe, why is it allowed to use a raw type?</source>
          <target state="translated">安全性に問題があるなら、なぜ生型が許されるのか?</target>
        </trans-unit>
        <trans-unit id="757cde53b1d07914c3de66734bfcb1a0d037c4db" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">実際の型引数が省略されている場合、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; raw型を作成します。</target>
        </trans-unit>
        <trans-unit id="9aeb471379aedc5abe716fbf10b8294ce63c6335" translate="yes" xml:space="preserve">
          <source>If the actual type argument is omitted, you create a raw type of Box:</source>
          <target state="translated">実際の型の引数が省略されている場合は、Boxの生型を作成します。</target>
        </trans-unit>
        <trans-unit id="0cc605baa568c21a2584d85b111e38c62a278623" translate="yes" xml:space="preserve">
          <source>If you had declared &lt;code&gt;appendNewObject&lt;/code&gt; to take a raw type &lt;code&gt;List&lt;/code&gt; as parameter, then this would compile, and you'd therefore lose the type safety that you get from generics.</source>
          <target state="translated">生の型 &lt;code&gt;List&lt;/code&gt; をパラメーターとして取るように &lt;code&gt;appendNewObject&lt;/code&gt; を宣言した場合、これはコンパイルされ、したがって、ジェネリックスから得られる型の安全性が失われます。</target>
        </trans-unit>
        <trans-unit id="dd2d4a705143feb6d0a89160672246231005a289" translate="yes" xml:space="preserve">
          <source>In general is a better idea to parametrize the collections, so you don't have conversion problems, you will only be able to add elements of the parametrized type and your editor will offer you the appropiate methods to select.</source>
          <target state="translated">一般的にはコレクションをパラメトリックにすることをお勧めしますので、変換の問題を持っていないので、あなたは唯一のパラメトリック型の要素を追加することができますし、あなたのエディタはあなたが選択するための適切なメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="3744921c19e7629a4f01f2555627f746743882d4" translate="yes" xml:space="preserve">
          <source>In simpler terms, when a raw type is used, the constructors, instance methods and non-&lt;code&gt;static&lt;/code&gt; fields are &lt;em&gt;also erased&lt;/em&gt;.</source>
          <target state="translated">簡単に言うと、生の型が使用されると、コンストラクター、インスタンスメソッド、および非 &lt;code&gt;static&lt;/code&gt; フィールド&lt;em&gt;も消去され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="756666332aa7004e808286b5b848c619457b8b90" translate="yes" xml:space="preserve">
          <source>In summary, raw types should NEVER be used in new code. &lt;strong&gt;You should always use parameterized types&lt;/strong&gt;.</source>
          <target state="translated">要約すると、生の型は決して新しいコードで使用すべきではありません。 &lt;strong&gt;常にパラメータ化された型を使用する必要があります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b474182f196f28b6d9bc2a82197e85bb395fb460" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList arr&lt;/code&gt; is a raw type but your Object &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; is a Strict type.</source>
          <target state="translated">この場合、 &lt;code&gt;ArrayList arr&lt;/code&gt; は生の型 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;();&lt;/code&gt; が、Object new ArrayList &amp;lt;String&amp;gt;（）; Strictタイプです。</target>
        </trans-unit>
        <trans-unit id="f1c1ae68c9409c5f5812e26d3d923d56dab69ce2" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; is a strict type but your Object &lt;code&gt;new ArrayList();&lt;/code&gt; is a raw type.</source>
          <target state="translated">この場合、 &lt;code&gt;ArrayList&amp;lt;String&amp;gt; arr&lt;/code&gt; は厳密な型 &lt;code&gt;new ArrayList();&lt;/code&gt; が、Object new ArrayList（）; 生のタイプです。</target>
        </trans-unit>
        <trans-unit id="8c2f74dfe2af17f55f4ba29be8ccb19139a8d1f6" translate="yes" xml:space="preserve">
          <source>It is a Strict to &lt;code&gt;String&lt;/code&gt; not  a Raw Type so, It will never raise an warning .</source>
          <target state="translated">これは、Raw型ではなくStrict to &lt;code&gt;String&lt;/code&gt; であるため、警告が発生することはありません。</target>
        </trans-unit>
        <trans-unit id="af64c2b91282b2bc128075031a67b506f57156cd" translate="yes" xml:space="preserve">
          <source>It is possible to use as a type &lt;strong&gt;the erasure&lt;/strong&gt; of a parameterized type or the erasure of an array type whose element type is a parameterized type. &lt;strong&gt;Such a type is called a &lt;em&gt;raw type&lt;/em&gt;.&lt;/strong&gt;</source>
          <target state="translated">型として、パラメーター化された型&lt;strong&gt;の消去&lt;/strong&gt;または要素型がパラメーター化された型である配列型の消去を使用できます。 &lt;strong&gt;このような型は、 &lt;em&gt;raw型&lt;/em&gt;と呼ばれます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d69f46a16cf7ee0a31e5e918cb4caa8f4a361e8" translate="yes" xml:space="preserve">
          <source>It may be safer but took 4  hours to demuddle the philosophy...</source>
          <target state="translated">安全なのかもしれませんが、哲学を脱泥させるのに4時間もかかってしまいました......。</target>
        </trans-unit>
        <trans-unit id="c7b6e70f29e6d47c95b4ce838419d160d7d44651" translate="yes" xml:space="preserve">
          <source>It will add any type of Object into it because &lt;code&gt;arr&lt;/code&gt; is a Raw Type.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; はRawタイプであるため、任意のタイプのオブジェクトが追加されます。</target>
        </trans-unit>
        <trans-unit id="7c357301ad31d5a2328f52fdfde2afee191052a2" translate="yes" xml:space="preserve">
          <source>JLS 4.8 Raw Types</source>
          <target state="translated">JLS 4.8 原材料の種類</target>
        </trans-unit>
        <trans-unit id="d96b21d482d675d54b9a9afda2b5ba4acaaf0b98" translate="yes" xml:space="preserve">
          <source>Java Tutorials/Generics</source>
          <target state="translated">Javaチュートリアル一般</target>
        </trans-unit>
        <trans-unit id="d9c140e4568d16dd9563d8ab811a377f394c3ad0" translate="yes" xml:space="preserve">
          <source>Just what is the difference between the raw type &lt;code&gt;List&lt;/code&gt; and the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;? Loosely speaking, the former has opted out generic type checking, while the latter explicitly told the compiler that it is capable of holding objects of any type. While you can pass a &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; to a parameter of type &lt;code&gt;List&lt;/code&gt;, you can't pass it to a parameter of type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. There are subtyping rules for generics, and &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is a subtype of the raw type &lt;code&gt;List&lt;/code&gt;, but not of the parameterized type &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;. As a consequence, &lt;strong&gt;you lose type safety if you use raw type like &lt;code&gt;List&lt;/code&gt;, but not if you use a parameterized type like &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">生の型 &lt;code&gt;List&lt;/code&gt; とパラメーター化された型 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; の違いは何ですか？ 大まかに言えば、前者はジェネリック型チェックをオプトアウトしましたが、後者はコンパイラに任意の型のオブジェクトを保持できることを明示的に伝えました。 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; を &lt;code&gt;List&lt;/code&gt; 型のパラメーターに渡すことはできますが、 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 型のパラメーターに渡すことはできません。 ジェネリックスにはサブタイプ規則があり、 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; は生のタイプ &lt;code&gt;List&lt;/code&gt; のサブタイプですが、パラメーター化されたタイプ &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; サブタイプではありません。 結果として、 &lt;strong&gt; &lt;code&gt;List&lt;/code&gt; のような生の型を使用する場合は型の安全性が失われますが、 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; ようなパラメーター化された型を使用する場合は失われません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="850a74790dcd52d9b6cd99dd8612f5711bc8e124" translate="yes" xml:space="preserve">
          <source>More complex the Compareable interface:</source>
          <target state="translated">比較可能なインターフェイスがより複雑になります。</target>
        </trans-unit>
        <trans-unit id="dfdfd6745128ac64237078d81256b1a171bc2dd6" translate="yes" xml:space="preserve">
          <source>Note that it is impossible to implement the &lt;code&gt;CompareAble&lt;/code&gt; interface with &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; with raw types.
Why you should not use them:</source>
          <target state="translated">生の型では、 &lt;code&gt;compareTo(MyCompareAble)&lt;/code&gt; で &lt;code&gt;CompareAble&lt;/code&gt; インターフェースを実装することは不可能であることに注意してください。 それらを使用すべきでない理由：</target>
        </trans-unit>
        <trans-unit id="296b126e38fe8034587cb665417ce3c7024ae780" translate="yes" xml:space="preserve">
          <source>Note: Example.java uses unchecked or unsafe operations.</source>
          <target state="translated">注意:Example.javaでは、チェックが入っていない、または安全でない操作を使用しています。</target>
        </trans-unit>
        <trans-unit id="3499d2ef5e16f0b55aee68466deae9940cc994c4" translate="yes" xml:space="preserve">
          <source>Note: Recompile with -Xlint:unchecked for details.</source>
          <target state="translated">注意:詳細は -Xlint:unchecked でリコンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="254f98057318b73a6885ac9033cf6c0a3f78cd90" translate="yes" xml:space="preserve">
          <source>Notice that with generics you don't have to cast the object coming from the get call, the collection is pre-defined to only work with MyObject.  This very fact is the main driving factor for generics.  It changes a source of runtime errors into something that can be checked at compile time.</source>
          <target state="translated">ジェネリックでは、getコールから来たオブジェクトをキャストする必要がないことに注意してください。この事実こそが、ジェネリックを推進する主な要因です。これにより、ランタイムエラーの原因をコンパイル時にチェックできるものに変えることができます。</target>
        </trans-unit>
        <trans-unit id="b6af0e34c6cc7075ebe7a4a3f42d6d402756c648" translate="yes" xml:space="preserve">
          <source>Now we run into trouble at run-time, because &lt;code&gt;names&lt;/code&gt; contains something that isn't an &lt;code&gt;instanceof String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; に &lt;code&gt;instanceof String&lt;/code&gt; のインスタンスではないものが含まれているため、実行時に問題が発生します 。</target>
        </trans-unit>
        <trans-unit id="ac370a883ec182a3baba7d9265d02ace81c41512" translate="yes" xml:space="preserve">
          <source>Of course, if you &lt;em&gt;DO&lt;/em&gt; want &lt;code&gt;names&lt;/code&gt; to allow a &lt;code&gt;Boolean&lt;/code&gt;, then you can declare it as &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt;, and the above code would compile.</source>
          <target state="translated">もちろん、 &lt;code&gt;names&lt;/code&gt; に &lt;code&gt;Boolean&lt;/code&gt; を許可したい場合は、それを &lt;code&gt;List&amp;lt;Object&amp;gt; names&lt;/code&gt; として宣言すると、上記のコードがコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="5f3e174709eebda3c2a288755f4a44a380585674" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Java Tutorials&lt;/a&gt;</source>
          <target state="translated">元のソース： &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html&quot;&gt;Javaチュートリアル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecee4396959b71721b4635fbfb006a7cc0e9a651" translate="yes" xml:space="preserve">
          <source>Presumably, if you want &lt;code&gt;names&lt;/code&gt; to contain only &lt;code&gt;String&lt;/code&gt;, you &lt;em&gt;could&lt;/em&gt; perhaps still use a raw type and &lt;em&gt;manually check every&lt;/em&gt;&lt;code&gt;add&lt;/code&gt; yourself, and then &lt;em&gt;manually cast&lt;/em&gt; to &lt;code&gt;String&lt;/code&gt; every item from &lt;code&gt;names&lt;/code&gt;. &lt;strong&gt;Even better&lt;/strong&gt;, though is NOT to use a raw type and &lt;em&gt;let the compiler do all the work for you&lt;/em&gt;, harnessing the power of Java generics.</source>
          <target state="translated">おそらく、 &lt;code&gt;names&lt;/code&gt; に &lt;code&gt;String&lt;/code&gt; のみを含めたい場合は、未加工の型を使用して&lt;em&gt;すべての&lt;/em&gt; &lt;code&gt;add&lt;/code&gt; を&lt;em&gt;手動で確認し&lt;/em&gt; 、 &lt;code&gt;names&lt;/code&gt; からすべての項目を&lt;em&gt;手動で&lt;/em&gt; &lt;code&gt;String&lt;/code&gt; に &lt;em&gt;キャスト&lt;/em&gt; できます。 &lt;strong&gt;さらに良いの&lt;/strong&gt;は、生の型を使用&lt;em&gt;せず、&lt;/em&gt; Javaジェネリックの力を利用して&lt;em&gt;コンパイラーにすべての作業を任せることです&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e63fc58ab6bfca9e67eebb8a65352e54e0fd330" translate="yes" xml:space="preserve">
          <source>Questions:</source>
          <target state="translated">Questions:</target>
        </trans-unit>
        <trans-unit id="14c39264748158f870d8f43c71ea7f51c1859672" translate="yes" xml:space="preserve">
          <source>Raw types are fine when they express what you want to express.</source>
          <target state="translated">生タイプは表現したいことを表現してくれれば問題ありません。</target>
        </trans-unit>
        <trans-unit id="47f403e27f4c62d43a2933f83a0dd997ab56d1e0" translate="yes" xml:space="preserve">
          <source>Raw types refer to using a generic type without specifying a type parameter.</source>
          <target state="translated">Raw 型とは、型パラメータを指定せずに汎用型を使用することを指します。</target>
        </trans-unit>
        <trans-unit id="f6709747af5a036dfca6571b0519116f90e0e9ec" translate="yes" xml:space="preserve">
          <source>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior &amp;mdash; a &lt;code&gt;Box&lt;/code&gt; gives you &lt;code&gt;Object&lt;/code&gt;s. For backward compatibility, assigning a parameterized type to its raw type is allowed:</source>
          <target state="translated">多くのAPIクラス（Collectionsクラスなど）はJDK 5.0以前では汎用的ではなかったため、生の型はレガシーコードに表示されます。 rawタイプを使用すると、基本的にジェネリック前の動作が得られます &lt;code&gt;Object&lt;/code&gt; を提供します。 下位互換性のために、パラメータ化された型をそのraw型に割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="5edab9471a19ae73475c8ed0622f2789a8bbd38d" translate="yes" xml:space="preserve">
          <source>Raw-type should not be used because it could cause runtime errors, like inserting a &lt;code&gt;double&lt;/code&gt; into what was supposed to be a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt;s.</source>
          <target state="translated">raw型は、 &lt;code&gt;int&lt;/code&gt; の &lt;code&gt;Set&lt;/code&gt; であるはずのものに &lt;code&gt;double&lt;/code&gt; を挿入するなどの実行時エラーを引き起こす可能性があるため、使用しないでください。</target>
        </trans-unit>
        <trans-unit id="b73c83827ddf3571b554094ecd15284c3d9f51ff" translate="yes" xml:space="preserve">
          <source>Raw-types are ancient history of the Java language. In the beginning there were &lt;code&gt;Collections&lt;/code&gt; and they held &lt;code&gt;Objects&lt;/code&gt; nothing more and nothing less. Every operation on &lt;code&gt;Collections&lt;/code&gt; required casts from &lt;code&gt;Object&lt;/code&gt; to the desired type.</source>
          <target state="translated">Raw型はJava言語の古代の歴史です。 初めは &lt;code&gt;Collections&lt;/code&gt; あり、 &lt;code&gt;Objects&lt;/code&gt; それ以上何もありませんでした。 &lt;code&gt;Collections&lt;/code&gt; に対するすべての操作には、 &lt;code&gt;Object&lt;/code&gt; から目的の型へのキャストが必要でした。</target>
        </trans-unit>
        <trans-unit id="fda027c268c4ae6152aa9f57c1dfaab8a4ae0670" translate="yes" xml:space="preserve">
          <source>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</source>
          <target state="translated">Xlint:unchecked を指定して前の例を再コンパイルすると、以下の追加情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照</target>
        </trans-unit>
        <trans-unit id="4e5c1cb438afe66a7a3ce7f0162632afd0f40816" translate="yes" xml:space="preserve">
          <source>Take the following example:</source>
          <target state="translated">次のような例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="29e893a5bedf20dc1b4e344373155ba8e5623141" translate="yes" xml:space="preserve">
          <source>The Java Language Specification defines a &lt;em&gt;raw type&lt;/em&gt; as follows:</source>
          <target state="translated">Java言語仕様では、 &lt;em&gt;raw型&lt;/em&gt;を次のように定義しています。</target>
        </trans-unit>
        <trans-unit id="f03d888157a822dae6298c0edd4e09b264238529" translate="yes" xml:space="preserve">
          <source>The Java platform was about to enter its second decade when generics were introduced, and there was an enormous amount of Java code in existence that did not use generics. It was deemed critical that all this code remains legal and interoperable with new code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with ordinary types, and vice versa. This requirement, known as &lt;em&gt;migration compatibility&lt;/em&gt;, drove the decision to support raw types.</source>
          <target state="translated">Javaプラットフォームは、ジェネリックが導入されてから20年を迎えようとしており、ジェネリックを使用しない膨大な量のJavaコードが存在していました。 このすべてのコードが合法であり、ジェネリックを使用する新しいコードと相互運用可能であることが重要であると見なされました。 パラメータ化された型のインスタンスを、通常の型で使用するように設計されたメソッドに渡すこと、およびその逆を行うことは合法である必要がありました。 &lt;em&gt;移行の互換性&lt;/em&gt;と呼ばれるこの要件により、rawタイプをサポートする決定が下されました。</target>
        </trans-unit>
        <trans-unit id="405919cad9921e0b63d1c1d0b23b75783e9838de" translate="yes" xml:space="preserve">
          <source>The Type Erasure section has more information on how the Java compiler uses raw types.</source>
          <target state="translated">型の消去」のセクションには、Java コンパイラがどのように生の型を使用するかについての詳細な情報があります。</target>
        </trans-unit>
        <trans-unit id="19cba934a6c7509721bb93f99ce5196844f697ea" translate="yes" xml:space="preserve">
          <source>The above code runs just fine, but suppose you also have the following:</source>
          <target state="translated">上記のコードは問題なく動作しますが、以下のようなコードもあるとします。</target>
        </trans-unit>
        <trans-unit id="ae33c93ae8545a049054d56f94b52ddadc4db2ff" translate="yes" xml:space="preserve">
          <source>The compiler did a wonderful job of protecting you from potentially violating the type invariance of the &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt;! If you had declared the parameter as the raw type &lt;code&gt;List list&lt;/code&gt;, then the code would compile, and you'd violate the type invariant of &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 型の不変性に違反する可能性からユーザーを保護するというすばらしい仕事をしました&amp;lt;？&amp;gt; ！ パラメータを生の &lt;code&gt;List list&lt;/code&gt; として宣言した場合、コードはコンパイルされ、 &lt;code&gt;List&amp;lt;String&amp;gt; names&lt;/code&gt; タイプ不変式に違反します 。</target>
        </trans-unit>
        <trans-unit id="51a5fbcc09ae553d5fd592ab6795f02eaba69382" translate="yes" xml:space="preserve">
          <source>The compiler wants you to write this:</source>
          <target state="translated">コンパイラはこれを書いて欲しいと言っています。</target>
        </trans-unit>
        <trans-unit id="0363d591375571e48f68366a7f025385874a4bc8" translate="yes" xml:space="preserve">
          <source>The erasure of the signature of a generic method has no type parameters.</source>
          <target state="translated">ジェネリックメソッドのシグネチャの消去には型パラメータがありません。</target>
        </trans-unit>
        <trans-unit id="4741487f156eaa93feddb499e8df578c72023c56" translate="yes" xml:space="preserve">
          <source>The following bug report contains some thoughts from Maurizio Cimadamore, a compiler dev, and Alex Buckley, one of the authors of the JLS, on why this sort of behavior ought to occur: &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-6400189&lt;/a&gt;. (In short, it makes the specification simpler.)</source>
          <target state="translated">次のバグレポートには、コンパイラ開発者のMaurizio CimadamoreとJLSの作者の1人であるAlex Buckleyが、この種の動作が発生する理由についていくつかの考えが含まれています。https：//bugs.openjdk.java.net/browse &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-6400189&quot;&gt;/ JDK-6400189&lt;/a&gt; 。 （つまり、仕様が単純になります。）</target>
        </trans-unit>
        <trans-unit id="a9f82fe99578f6009d5eb0412ee1e187309afacb" translate="yes" xml:space="preserve">
          <source>The following is a quote from &lt;em&gt;Effective Java 2nd Edition, Item 23: Don't use raw types in new code&lt;/em&gt;:</source>
          <target state="translated">以下は、 &lt;em&gt;Effective Java 2nd Edition、Item 23：Do n't use raw types in new code&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="ba2996d73cdc2d5e8adf9bc06d73367a443e54a0" translate="yes" xml:space="preserve">
          <source>The old typeless collections could not enforce type-safety so the programmer had to remember what he stored within a collection.</source>
          <target state="translated">古いタイプレスコレクションではタイプセーフティーを実施できないので、プログラマはコレクション内に何を保存したかを覚えておかなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="224867fabb32bca2e488d4f0445bcb8a5d12ece3" translate="yes" xml:space="preserve">
          <source>The preferred alternative is to use generic classes as intended - with a suitable type argument (e.g. &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;). This allows the programmer to specify types more specifically, conveys more meaning to future maintainers about the intended use of a variable or data structure, and it allows compiler to enforce better type-safety.  These advantages together may improve code quality and help prevent the introduction of some coding errors.</source>
          <target state="translated">推奨される代替策は、適切な型引数（例： &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; ）を使用して、意図したとおりにジェネリッククラスを使用することです。 これにより、プログラマーはタイプをより具体的に指定でき、変数またはデータ構造の使用目的について将来のメンテナーにより多くの意味を伝え、コンパイラーはより優れたタイプセーフを実施できます。 これらの利点により、コードの品質が向上し、コーディングエラーの発生を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="bdde1ec38079b0f21677aedb8ffed79d4ee40436" translate="yes" xml:space="preserve">
          <source>The reference type that is formed by taking the name of a generic type declaration without an accompanying type argument list.</source>
          <target state="translated">型の引数リストを伴わない汎用型宣言の名前を取って形成される参照型。</target>
        </trans-unit>
        <trans-unit id="7b95d6baee239d3ff4e3ced680ad026c49c8a6fa" translate="yes" xml:space="preserve">
          <source>The superclasses (respectively, superinterfaces) of a raw type are the erasures of the superclasses (superinterfaces) of any of the parameterizations of the generic type.</source>
          <target state="translated">生型のスーパークラス(それぞれスーパーインターフェース)は、汎用型のいずれかのパラメータ化のスーパークラス(スーパーインターフェース)の消去です。</target>
        </trans-unit>
        <trans-unit id="028dac7a1835527c760373499e5bd53972c19762" translate="yes" xml:space="preserve">
          <source>The term &quot;unchecked&quot; means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The &quot;unchecked&quot; warning is disabled, by default, though the compiler gives a hint. To see all &quot;unchecked&quot; warnings, recompile with -Xlint:unchecked.</source>
          <target state="translated">unchecked」とは、コンパイラが型の安全性を確保するために必要なすべての型チェックを実行するのに十分な型情報を持っていないことを意味します。unhecked &quot;警告はデフォルトでは無効になっていますが、コンパイラはヒントを与えてくれます。すべての &quot;unchecked &quot;警告を見るには、-Xlint:uncheckedで再コンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="1c1d40c286a32e79507bdccf064061a7398aec1e" translate="yes" xml:space="preserve">
          <source>The type of a constructor, instance method, or non-&lt;code&gt;static&lt;/code&gt; field of a raw type &lt;code&gt;C&lt;/code&gt; that is not inherited from its superclasses or superinterfaces is the raw type that corresponds to the erasure of its type in the generic declaration corresponding to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">スーパークラスまたはスーパーインターフェースから継承されていない、生の型 &lt;code&gt;C&lt;/code&gt; のコンストラクター、インスタンスメソッド、または非 &lt;code&gt;static&lt;/code&gt; フィールドの型は、 &lt;code&gt;C&lt;/code&gt; に対応するジェネリック宣言でその型の消去に対応する生の型です。</target>
        </trans-unit>
        <trans-unit id="4de2e6bc304bdcf427827a31f05067b528fb6ec7" translate="yes" xml:space="preserve">
          <source>The use of raw types is allowed only as a concession to compatibility of legacy code. &lt;em&gt;The use of raw types in code written after the introduction of genericity into the Java programming language is strongly discouraged. It is possible that future versions of the Java programming language will disallow the use of raw types.&lt;/em&gt;</source>
          <target state="translated">生の型の使用は、レガシーコードの互換性への譲歩としてのみ許可されています。 &lt;em&gt;Javaプログラミング言語へのジェネリック性の導入後に記述されたコードで生の型を使用することは強くお勧めしません。&lt;/em&gt; &lt;em&gt;Javaプログラミング言語の将来のバージョンでは、raw型を使用できなくなる可能性があります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38130b794559a4c9afe8f8b9c015c9dde8e522d2" translate="yes" xml:space="preserve">
          <source>The warning advises that types that are defined to support &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;generics&lt;/a&gt; should be parameterized, rather than using their raw form.</source>
          <target state="translated">警告は、 &lt;a href=&quot;http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html&quot;&gt;ジェネリック&lt;/a&gt;をサポートするように定義されている型は、生の形式を使用するのではなく、パラメーター化する必要があることを示しています。</target>
        </trans-unit>
        <trans-unit id="66ca0326f80fbd6c5b5f545e591d10cb1a33c496" translate="yes" xml:space="preserve">
          <source>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</source>
          <target state="translated">この警告は、生の型が一般的な型チェックをバイパスし、安全でないコードのキャッチを実行時に延期することを示しています。したがって、生の型の使用は避けるべきです。</target>
        </trans-unit>
        <trans-unit id="26f6914ed49c5138e2d0f7911e928bb8bc17625c" translate="yes" xml:space="preserve">
          <source>Therefore, &lt;code&gt;Box&lt;/code&gt; is the raw type of the generic type &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. However, a non-generic class or interface type is not a raw type.</source>
          <target state="translated">したがって、 &lt;code&gt;Box&lt;/code&gt; はジェネリック型 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; の生の型です。 ただし、非ジェネリッククラスまたはインターフェイス型はraw型ではありません。</target>
        </trans-unit>
        <trans-unit id="00b4626a1162938da83e931c64651ef346add10f" translate="yes" xml:space="preserve">
          <source>They are less expressive, and don't self-document in the same way as parameterized types
&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">それらは表現力が低く、パラメータ化された型と同じように自己文書化しません。</target>
        </trans-unit>
        <trans-unit id="0ebc27a91176efcbb20410934abb5853c0008136" translate="yes" xml:space="preserve">
          <source>They aren't type safe, and some important kinds of errors will only appear at runtime</source>
          <target state="translated">これらは型安全ではなく、いくつかの重要な種類のエラーは実行時にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="1e9dd9b1ece7f9d0090b47a3a8306fdc209f6a95" translate="yes" xml:space="preserve">
          <source>They usually require casts</source>
          <target state="translated">彼らは通常、キャストを必要とします。</target>
        </trans-unit>
        <trans-unit id="5873e20d029e66a8c51641dd8139270aaedf4381" translate="yes" xml:space="preserve">
          <source>This can happen when using an older API that operates on raw types, as shown in the following example:</source>
          <target state="translated">これは、以下の例に示すように、生の型で動作する古い API を使用している場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="75bbc98951486b296100d29e447bb2550f22a5bd" translate="yes" xml:space="preserve">
          <source>This is the same code you would write if you used the raw types directly. Thought I'm not sure what happens with the &lt;code&gt;CompareAble&lt;/code&gt; interface, I guess that it creates two &lt;code&gt;compareTo&lt;/code&gt; functions, one taking a &lt;code&gt;MyCompareAble&lt;/code&gt; and the other taking an &lt;code&gt;Object&lt;/code&gt; and passing it to the first after casting it.</source>
          <target state="translated">これは、生の型を直接使用した場合と同じコードです。 &lt;code&gt;CompareAble&lt;/code&gt; インターフェースで何が起こるかはわかりませんが、2つの &lt;code&gt;compareTo&lt;/code&gt; 関数が作成され、1つは &lt;code&gt;MyCompareAble&lt;/code&gt; を受け取り 、もう1つは &lt;code&gt;Object&lt;/code&gt; を受け取り 、キャスト後に最初のオブジェクトに渡します。</target>
        </trans-unit>
        <trans-unit id="766f0ea717ddd326371c9d9cdc14d6d42b78ca3d" translate="yes" xml:space="preserve">
          <source>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; annotation suppresses unchecked warnings. If you are unfamiliar with the &lt;code&gt;@SuppressWarnings&lt;/code&gt; syntax, see Annotations.</source>
          <target state="translated">未チェックの警告を完全に無効にするには、-Xlint：-uncheckedフラグを使用します。 &lt;code&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/code&gt; アノテーションは、チェックされていない警告を抑制します。 &lt;code&gt;@SuppressWarnings&lt;/code&gt; 構文に慣れていない場合は、注釈を参照してください。</target>
        </trans-unit>
        <trans-unit id="80251fc31dcb833fa8957ce6961b665392d800db" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, you supply an actual type argument for the formal type parameter &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; パラメーター化された型を作成するには、仮型パラメーター &lt;code&gt;T&lt;/code&gt; の実際の型引数を指定します。</target>
        </trans-unit>
        <trans-unit id="738e743b4a29658389df8f72c91705203651edac" translate="yes" xml:space="preserve">
          <source>To create a parameterized type of Box, you supply an actual type argument for the formal type parameter T:</source>
          <target state="translated">Boxのパラメータ化された型を作成するには、形式的な型パラメータTに実際の型の引数を与えます。</target>
        </trans-unit>
        <trans-unit id="2e0d2fd5cc02c819f4b51dbe7cb93f09af65fbd8" translate="yes" xml:space="preserve">
          <source>To illustrate the point, consider the following method which takes a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; and appends a &lt;code&gt;new Object()&lt;/code&gt;.</source>
          <target state="translated">ポイントを説明するために、 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; を取り、 &lt;code&gt;new Object()&lt;/code&gt; を追加する次のメソッドを考えます。</target>
        </trans-unit>
        <trans-unit id="556b94a170a618efa12635f0635c19579ef283b9" translate="yes" xml:space="preserve">
          <source>Unchecked Error Messages</source>
          <target state="translated">チェックを外したエラーメッセージ</target>
        </trans-unit>
        <trans-unit id="1488eddd4ac4e26c448d84102357cfa845ad5972" translate="yes" xml:space="preserve">
          <source>Unfortunately, because Java generics are non-reified, there are two exceptions where raw types must be used in new code:</source>
          <target state="translated">残念ながら、Javaのジェネリックは非正規化なので、新しいコードで生の型を使わなければならない例外が2つあります。</target>
        </trans-unit>
        <trans-unit id="1e5e7d3116ebd3de1a83a1241dab9045f1ec61bf" translate="yes" xml:space="preserve">
          <source>Using generics enables compile time checks</source>
          <target state="translated">ジェネリックを使用することでコンパイル時のチェックが可能</target>
        </trans-unit>
        <trans-unit id="c633498ea9a29fa72a0bbecb71a9da972a698387" translate="yes" xml:space="preserve">
          <source>Using generics, you remove the &quot;unknown&quot; factor, because you must explicitly specify which type of objects can go in the list:</source>
          <target state="translated">ジェネリックを使用すると、リストに入るオブジェクトのタイプを明示的に指定しなければならないため、「不明」の要素を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="374c5fd146735c599512bad185fd1451f407b63e" translate="yes" xml:space="preserve">
          <source>Using raw types is the same as storing each value as &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">生の型を使用することは、各値を &lt;code&gt;Object&lt;/code&gt; として格納することと同じです</target>
        </trans-unit>
        <trans-unit id="eab2ae60ad80fc1f68d0fef0fa0d1c390dad5ca0" translate="yes" xml:space="preserve">
          <source>What are raw types in Java, and why do I often hear that they shouldn't be used in new code?</source>
          <target state="translated">Javaの生の型とは何ですか?</target>
        </trans-unit>
        <trans-unit id="30ee936b3a2d7e626d1240eed0e0228cdf2781b3" translate="yes" xml:space="preserve">
          <source>What are the alternatives to raw types: Use &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;generics&lt;/a&gt;</source>
          <target state="translated">生の型に代わるものは何ですか？ &lt;a href=&quot;http://java.sun.com/docs/books/tutorial/extra/generics/index.html&quot;&gt;ジェネリックを&lt;/a&gt;使用してください</target>
        </trans-unit>
        <trans-unit id="13e18159e991cbf27833d847ecb850a6500c5b60" translate="yes" xml:space="preserve">
          <source>What is a raw type and why shouldn't we use it</source>
          <target state="translated">生型とは何か、なぜ使ってはいけないのか</target>
        </trans-unit>
        <trans-unit id="d33f524f99b128a863eea8abf8b22cdb547ff070" translate="yes" xml:space="preserve">
          <source>What is a raw type?</source>
          <target state="translated">生型とは?</target>
        </trans-unit>
        <trans-unit id="0c94f16920c76542bf263ada24624cb0b28ce1fd" translate="yes" xml:space="preserve">
          <source>What is saying is that your &lt;code&gt;list&lt;/code&gt; is a &lt;code&gt;List&lt;/code&gt; of unespecified objects. That is that Java does not know what kind of objects are inside the list. Then when you want to iterate the list you have to cast every element, to be able to access the properties of that element (in this case, String).</source>
          <target state="translated">言っていることはあなたの &lt;code&gt;list&lt;/code&gt; が不特定のオブジェクトの &lt;code&gt;List&lt;/code&gt; であるということです。 つまり、Javaはリスト内にどのようなオブジェクトがあるかを認識していません。 次に、リストを反復処理する場合は、すべての要素をキャストして、その要素（この場合は文字列）のプロパティにアクセスできるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="fdeab1d68011a57fce4cd4ba9f9c74abe4ff5bea" translate="yes" xml:space="preserve">
          <source>What is the alternative if we can't use raw types, and how is it better?</source>
          <target state="translated">生タイプが使えない場合の代替案と、その方が良い点は?</target>
        </trans-unit>
        <trans-unit id="7e187deccee3bced2f61d49a1c4f1805a24f3514" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;&amp;lt;E extends Number&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;Number&amp;gt;&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="2000b4089ba1692a89afa72ea69f43fb13328c31" translate="yes" xml:space="preserve">
          <source>What the compiler does:
Generics are backward compatible, they use the same java classes as the raw types do. The magic happens mostly at compile time.</source>
          <target state="translated">コンパイラが行うこと。ジェネリックは下位互換性があり、生の型と同じjavaクラスを使用します。マジックはほとんどの場合、コンパイル時に発生します。</target>
        </trans-unit>
        <trans-unit id="4f8e701743ca8556df10918c1399924693590de0" translate="yes" xml:space="preserve">
          <source>What's so special about raw types?</source>
          <target state="translated">生タイプの何が特別なの?</target>
        </trans-unit>
        <trans-unit id="c0bec40361472ae5df662e245af72cd245cacb6e" translate="yes" xml:space="preserve">
          <source>When generics were introduced in JDK 1.5, raw types were retained only to maintain backwards compatibility with older versions of Java. Although using raw types is still possible,</source>
          <target state="translated">JDK 1.5 でジェネリックが導入されたとき、古いバージョンの Java との下位互換性を維持するためだけに raw 型が保持されました。生の型を使用することは今でも可能ですが。</target>
        </trans-unit>
        <trans-unit id="07f051d6fc7fc8fbf515fd0cd3c1f563cb40b271" translate="yes" xml:space="preserve">
          <source>When retrieving the stuff from the &lt;code&gt;Set&lt;/code&gt;, you don't know what is coming out. Let's assume that you expect it to be all &lt;code&gt;int&lt;/code&gt;s, you are casting it to &lt;code&gt;Integer&lt;/code&gt;; exception at runtime when the &lt;code&gt;double&lt;/code&gt; 3.45 comes along.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; からのものを取得するとき、何が出てくるのかわかりません。 すべてが &lt;code&gt;int&lt;/code&gt; であると想定し、 &lt;code&gt;Integer&lt;/code&gt; にキャストするとします。 &lt;code&gt;double&lt;/code&gt; 3.45が登場する実行時の例外。</target>
        </trans-unit>
        <trans-unit id="229813f4d96b2d1b1f45b96f3d4597193f7d55d2" translate="yes" xml:space="preserve">
          <source>When we use the raw &lt;code&gt;MyType&lt;/code&gt;, &lt;code&gt;getNames&lt;/code&gt; becomes erased as well, so that it returns a raw &lt;code&gt;List&lt;/code&gt;!</source>
          <target state="translated">生の &lt;code&gt;MyType&lt;/code&gt; を使用すると、 &lt;code&gt;getNames&lt;/code&gt; も消去され、生の &lt;code&gt;List&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="03b03c443a4d1bf6d6fc2a3db1b553df7f30657f" translate="yes" xml:space="preserve">
          <source>When you add your object to the list, it doesn't care what type of object it is, and when you get it from the list, you have to explicitly cast it to the type you are expecting.</source>
          <target state="translated">オブジェクトをリストに追加するときには、オブジェクトのタイプを気にせず、リストからオブジェクトを取得するときには、明示的に期待するタイプにキャストしなければなりません。</target>
        </trans-unit>
        <trans-unit id="c740556a6d482ca7b34342229dd689c7478cd44e" translate="yes" xml:space="preserve">
          <source>While this worked most of the time, errors did happen</source>
          <target state="translated">これはほとんどの時間で動作しましたが、エラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="f1d1a366a93b477706dd8b3d6105c9c1a9eeba6a" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; Illegal?</source>
          <target state="translated">&lt;code&gt;Collection&amp;lt;String&amp;gt;.class&lt;/code&gt; 違法なのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="1719e030f1ab15bdc53d7b641986ffbe8aab10b1" translate="yes" xml:space="preserve">
          <source>Will be compiled as:</source>
          <target state="translated">としてコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="dee4689d8bcf66596d11372b703adb5272094959" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;type parameter&lt;/em&gt; added to your &lt;code&gt;Set&lt;/code&gt;, you will get a compile error at once. This preemptive error lets you fix the problem before something blows up during runtime (thus saving on time and effort).</source>
          <target state="translated">&lt;em&gt;型パラメーター&lt;/em&gt;を &lt;code&gt;Set&lt;/code&gt; に追加すると、コンパイルエラーがすぐに発生します。 このプリエンプティブエラーにより、ランタイム中に何かが爆発する前に問題を修正できます（したがって、時間と労力を節約できます）。</target>
        </trans-unit>
        <trans-unit id="a7d70712fc20b205ca2cc8c4b74bad333f629980" translate="yes" xml:space="preserve">
          <source>You also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:</source>
          <target state="translated">また、生の型を使用して、対応するジェネリック型で定義されたジェネリックメソッドを呼び出す場合も警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="197389cd6f3b37b3190a3a6a52add9e46a256131" translate="yes" xml:space="preserve">
          <source>You should specify the type-parameter.</source>
          <target state="translated">type-parameterを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ac174dc270f36327a0a027750b18bebbfaf4d7a" translate="yes" xml:space="preserve">
          <source>because otherwise, you could add any type you like into &lt;code&gt;list&lt;/code&gt;, making the instantiation as &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; pointless. Java generics are a compile-time feature only, so an object created with &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; will happily accept &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;JFrame&lt;/code&gt; elements if assigned to a reference of the &quot;raw type&quot; &lt;code&gt;List&lt;/code&gt; - the object itself knows nothing about what types it's supposed to contain, only the compiler does.</source>
          <target state="translated">それ以外の場合は、好きなタイプを &lt;code&gt;list&lt;/code&gt; に追加して、インスタンス化を &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; 無意味にすることができるからです。 Javaジェネリックはコンパイル時の機能のみであるため、「生タイプ」 &lt;code&gt;List&lt;/code&gt; 参照に割り当てられている場合、 &lt;code&gt;new ArrayList&amp;lt;String&amp;gt;()&lt;/code&gt; 作成されたオブジェクトは &lt;code&gt;Integer&lt;/code&gt; または &lt;code&gt;JFrame&lt;/code&gt; 要素を喜んで受け入れます-オブジェクト自体はどのタイプについても認識しませんそれは含まれることになっています、コンパイラだけが含みます。</target>
        </trans-unit>
        <trans-unit id="ea7878de5b8eeb89d003e785fa175fd505a012b3" translate="yes" xml:space="preserve">
          <source>here &lt;code&gt;arr&lt;/code&gt; is a Strict type. So, It will raise compile time error when adding a &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;arr&lt;/code&gt; はStrictタイプです。 したがって、 &lt;code&gt;integer&lt;/code&gt; 追加すると、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="2927dfb347fedd73a36f6f620a3aae2975129af7" translate="yes" xml:space="preserve">
          <source>java generics (not) covariance</source>
          <target state="translated">ジャワジェネリック共分散</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
