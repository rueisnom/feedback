<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/27581">
    <body>
      <group id="27581">
        <trans-unit id="f62941d18c07c2767c9aca935f7eefec2dc77803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22930a9e5f455ca30ff8f6af54e4c0c72690ea3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt;) must define an equivalence relation (it must be &lt;em&gt;reflexive&lt;/em&gt;, &lt;em&gt;symmetric&lt;/em&gt;, and &lt;em&gt;transitive&lt;/em&gt;). In addition, it must be &lt;em&gt;consistent&lt;/em&gt; (if the objects are not modified, then it must keep returning the same value). Furthermore, &lt;code&gt;o.equals(null)&lt;/code&gt; must always return false.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt; )는 동등성 관계를 정의해야합니다 ( &lt;em&gt;반사적&lt;/em&gt; , &lt;em&gt;대칭 적&lt;/em&gt; 및 &lt;em&gt;전 이적&lt;/em&gt; 이어야 함). 또한 &lt;em&gt;일관성&lt;/em&gt; 이 있어야합니다 (개체를 수정하지 않은 경우 계속 같은 값을 반환해야 함). 또한 &lt;code&gt;o.equals(null)&lt;/code&gt; 은 항상 false를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="09d759af345e9f8fc9cbd37acbd9f09a7c5c1bb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashCode()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt;) must also be &lt;em&gt;consistent&lt;/em&gt; (if the object is not modified in terms of &lt;code&gt;equals()&lt;/code&gt;, it must keep returning the same value).</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt; )도 &lt;em&gt;일관성이&lt;/em&gt; 있어야합니다 (객체가 &lt;code&gt;equals()&lt;/code&gt; 관점에서 수정되지 않으면 계속 같은 값을 반환해야합니다).</target>
        </trans-unit>
        <trans-unit id="f41e0d94b82c1244acfb38f6d85fd02451fdf588" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;hashCode()&lt;/code&gt; should use the non-changing subset of properties from &lt;code&gt;equals()&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;hashCode()&lt;/code&gt; 는 &lt;code&gt;equals()&lt;/code&gt; 에서 변경되지 않는 속성의 하위 집합을 사용해야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e513d55f8afc9df2979625f0240690bceadb1f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, make sure to always use getters, and never field references in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ORM을 다루는 경우 항상 getter를 사용하고 &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;equals()&lt;/code&gt; 에서 필드 참조를 사용하지 않아야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bfc4b9d4bb3b068f6f1690ffa035879735ef0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, using &lt;code&gt;o instanceof Person&lt;/code&gt; is the only thing that will behave correctly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ORM을 다루는 경우 &lt;code&gt;o instanceof Person&lt;/code&gt; 을 사용하는 것이 올바르게 작동하는 유일한 것입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bb03d5ecac5303318cbc14a70e6135b46c649ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever &lt;code&gt;a.equals(b)&lt;/code&gt;, then &lt;code&gt;a.hashCode()&lt;/code&gt; must be same as &lt;code&gt;b.hashCode()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;a.equals(b)&lt;/code&gt; 마다 &lt;code&gt;a.hashCode()&lt;/code&gt; 는 b.hashCode ()와 같아야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fba4a5bb0e819dded5facb835f31f90454fed74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects are subclasses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지연로드 된 객체는 서브 클래스입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5416b666233e493bf1163608c860bed1b45e705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects have null-fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;게으른로드 된 오브젝트에는 널 필드가 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87b9966cd9c56cfca42f79b00795981cc5b96b8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Saving an object will change its state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체를 저장하면 상태가 변경됩니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea919cd896a4ea6d29d672ece79624db4359bb54" translate="yes" xml:space="preserve">
          <source>A clarification about the &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj.getClass() != getClass()&lt;/code&gt; 에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="6895129e381c47582a6f95e9ff2da53a7d042422" translate="yes" xml:space="preserve">
          <source>A pattern I often use is</source>
          <target state="translated">내가 자주 사용하는 패턴은</target>
        </trans-unit>
        <trans-unit id="024cbca8c731c5b64edbfcc991e3b2f63e66f972" translate="yes" xml:space="preserve">
          <source>Also remember:</source>
          <target state="translated">또한 기억하십시오 :</target>
        </trans-unit>
        <trans-unit id="39075a8ee0cb791ba0482d1d3898b58397927809" translate="yes" xml:space="preserve">
          <source>But &lt;strong&gt;not&lt;/strong&gt; vice-versa!</source>
          <target state="translated">그러나 그 반대는 &lt;strong&gt;아닙니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="7d1bbdf358d01354cb4828d3a9b90762d31822ec" translate="yes" xml:space="preserve">
          <source>But: you cannot include &lt;code&gt;getId()&lt;/code&gt; in &lt;code&gt;hashCode()&lt;/code&gt;. If you do, when an object is persisted, its &lt;code&gt;hashCode&lt;/code&gt; changes. If the object is in a &lt;code&gt;HashSet&lt;/code&gt;, you'll &quot;never&quot; find it again.</source>
          <target state="translated">그러나 &lt;code&gt;hashCode()&lt;/code&gt; 에 &lt;code&gt;getId()&lt;/code&gt; 를 포함 할 수 없습니다. 그렇게하면 객체가 지속될 때 &lt;code&gt;hashCode&lt;/code&gt; 변경됩니다. 객체가 &lt;code&gt;HashSet&lt;/code&gt; 에 있으면 다시 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7c505f16d180c269b917e56b85bc20a74debb36" translate="yes" xml:space="preserve">
          <source>Consider the following example of what happens when the statement is omitted:</source>
          <target state="translated">명령문이 생략 될 때 발생하는 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e0824b4fba51777e4feffc1f5c2b3a206868d206" translate="yes" xml:space="preserve">
          <source>Default implementation given is hashCode() method in Object class uses the internal address of the object and converts it into integer and returns it.</source>
          <target state="translated">주어진 기본 구현은 Object 클래스의 hashCode () 메서드입니다. 객체의 내부 주소를 사용하여 정수로 변환하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fe35515e27e7aa13569acd40fe243cd2f28732f" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Also, &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; result give out true, as it should.</source>
          <target state="translated">&lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; 또한 &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; 결과는 원하는대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="59ded4d66e030811c0cecc5c18265651f8781edb" translate="yes" xml:space="preserve">
          <source>Equal objects must produce the same hash code as long as they are equal, however unequal objects need not produce distinct hash codes.</source>
          <target state="translated">동일한 객체는 동일한 해시 코드를 생성해야하지만 동일하지 않은 객체는 고유 한 해시 코드를 생성 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="67b3b65f196732922817614de3686f24f48f5c43" translate="yes" xml:space="preserve">
          <source>Example Code Output:</source>
          <target state="translated">코드 출력 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a8bd05092951921e316937eaf9f671cae2150a0c" translate="yes" xml:space="preserve">
          <source>For an inheritance-friendly implementation, check out Tal Cohen's solution, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;How Do I Correctly Implement the equals() Method?&lt;/a&gt;</source>
          <target state="translated">상속 친화적 인 구현을 위해서는 Tal Cohen의 솔루션, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;equals () 메소드를 올바르게 구현하는 방법을 확인하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d70b5f678ecec38b3080112485d7acc173ba57" translate="yes" xml:space="preserve">
          <source>For equals, look into &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secrets of Equals&lt;/a&gt;&lt;/strong&gt; by &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt;. I love it very much. She's also a great FAQ about &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics in Java&lt;/a&gt;&lt;/strong&gt;. View her other articles &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;here&lt;/a&gt; (scroll down to &quot;Core Java&quot;), where she also goes on with Part-2 and &quot;mixed type comparison&quot;. Have fun reading them!</source>
          <target state="translated">동등한 경우 &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt; &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;의 Equals of Secrets를&lt;/a&gt;&lt;/strong&gt; 살펴보십시오. 나는 그것을 아주 좋아합니다. 또한 &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics in Java&lt;/a&gt;&lt;/strong&gt; 에 대한 훌륭한 FAQ이기도합니다. 그녀의 다른 기사 ( &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;여기서는&lt;/a&gt; &quot;Core Java&quot;로 스크롤)에서 Part-2 및 &quot;혼합 유형 비교&quot;를 진행합니다. 재미있게 읽어보세요!</target>
        </trans-unit>
        <trans-unit id="3a0c83711ad78e79ea2e6a7e1075120a2ea2f087" translate="yes" xml:space="preserve">
          <source>Have Fun! @.@</source>
          <target state="translated">즐기세요! @. @</target>
        </trans-unit>
        <trans-unit id="28ac6d01c3b11a1242288d16c354d1d149c86bd7" translate="yes" xml:space="preserve">
          <source>His solution is to implement equals() by calling another nonsymmetric blindlyEquals() both ways.  blindlyEquals() is overridden by subclasses, equals() is inherited, and never overridden.</source>
          <target state="translated">그의 해결책은 두 가지 방법으로 다른 비대칭 blindlyEquals ()를 호출하여 equals ()를 구현하는 것입니다. blindlyEquals ()는 서브 클래스로 대체되고 equals ()는 상속되며 절대 재정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e068331a67b03e8bb4ff13910221de891b1c9497" translate="yes" xml:space="preserve">
          <source>I use #1 in a &lt;code&gt;final&lt;/code&gt; equals implementation, or when implementing an interface that prescribes an algorithm for equals (like the &lt;code&gt;java.util&lt;/code&gt; collection interfaces&amp;mdash;the right way to check with with &lt;code&gt;(obj instanceof Set)&lt;/code&gt; or whatever interface you're implementing). It's generally a bad choice when equals can be overridden because that breaks the symmetry property.</source>
          <target state="translated">필자는 equals 구현에서 # 1을 사용하거나 &lt;code&gt;java.util&lt;/code&gt; 컬렉션 인터페이스와 같은 알고리즘을 규정하는 인터페이스를 구현할 때 &lt;code&gt;(obj instanceof Set)&lt;/code&gt; 로 확인하는 올바른 방법 또는 구현하는 인터페이스) . 대칭 속성을 손상시키기 때문에 equals를 무시할 수있는 경우 일반적으로 나쁜 선택입니다.</target>
        </trans-unit>
        <trans-unit id="c047b686130b5ac2ddd022d754531089b0f8a3ea" translate="yes" xml:space="preserve">
          <source>If you include both ends of the relationship in your hashCode or equals tests it's possible to get into a recursive loop which ends in a StackOverflowException.</source>
          <target state="translated">hashCode 또는 equals 테스트에 관계의 양쪽 끝을 포함하면 재귀 루프로 들어가서 StackOverflowException으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af0d87ad2f0fa603892e358c5f2e857b7e5b7326" translate="yes" xml:space="preserve">
          <source>If you override one, then you should override the other.</source>
          <target state="translated">하나를 재정의하면 다른 것을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e86f786bee221b53f9c6d6b66a3286e528acaa30" translate="yes" xml:space="preserve">
          <source>If you want get more, please check this link as &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</source>
          <target state="translated">더 자세한 정보를 원하시면 &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt; 로이 링크를 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="b11b283ab4205e58d038c48a1b4263bb016b302d" translate="yes" xml:space="preserve">
          <source>If you want to ensure the symmetric condition. a=b if b=a and the Liskov substitution principle call &lt;code&gt;super.equals(other)&lt;/code&gt; not only in the case of &lt;code&gt;B&lt;/code&gt; instance, but check after for &lt;code&gt;A&lt;/code&gt; instance:</source>
          <target state="translated">대칭 조건을 보장하려는 경우. b = a이고 Liskov 대체 원리가 &lt;code&gt;B&lt;/code&gt; 인스턴스의 경우뿐만 아니라 &lt;code&gt;A&lt;/code&gt; . 인스턴스를 확인한 후 &lt;code&gt;super.equals(other)&lt;/code&gt; 호출하는 경우 a = b :</target>
        </trans-unit>
        <trans-unit id="f258ed46101818db9a26a356669ab445fa34d732" translate="yes" xml:space="preserve">
          <source>If your class is also &lt;code&gt;Comparable&lt;/code&gt;, the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; methods should be consistent too. Here's a template for the equals method in a &lt;code&gt;Comparable&lt;/code&gt; class:</source>
          <target state="translated">클래스가 &lt;code&gt;Comparable&lt;/code&gt; 인 경우 &lt;code&gt;equals&lt;/code&gt; 및 &lt;code&gt;compareTo&lt;/code&gt; 메소드도 일관성이 있어야합니다. 다음은 &lt;code&gt;Comparable&lt;/code&gt; 클래스의 equals 메서드에 대한 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="fedc3fcbdaf830c5e6d2b71eabde54346df9994d" translate="yes" xml:space="preserve">
          <source>If your objects are persisted using an ORM, in many cases you will be dealing with dynamic proxies to avoid loading object too early from the data store. These proxies are implemented as subclasses of your own class. This means that&lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;. For example:</source>
          <target state="translated">ORM을 사용하여 객체를 유지하는 경우 많은 경우 데이터 프록시에서 객체를 너무 일찍로드하지 않도록 동적 프록시를 처리하게됩니다. 이 프록시는 자신의 클래스의 서브 클래스로 구현됩니다. 이것은 &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 함을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="897ebe0396bd9c0c657be610c7aeeb790710f6ac" translate="yes" xml:space="preserve">
          <source>In his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; (Addison-Wesley, 2001), Joshua Bloch claims that &quot;There is simply no way to extend an instantiable class and add an aspect while preserving the equals contract.&quot;  Tal disagrees.</source>
          <target state="translated">Joshua Bloch는 자신의 저서 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; (Addison-Wesley, 2001)에서 &quot;인스턴스 계약을 유지하면서 인스턴스화 가능한 클래스를 확장하고 측면을 추가 할 수있는 방법이 없다&quot;고 주장합니다. 탈이 동의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad7a3fd4c935ce7834ae51563058277f54f97bde" translate="yes" xml:space="preserve">
          <source>In my &lt;code&gt;Person&lt;/code&gt; example, I probably would use &lt;code&gt;getName()&lt;/code&gt; for &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;getId()&lt;/code&gt; plus &lt;code&gt;getName()&lt;/code&gt; (just for paranoia) for &lt;code&gt;equals()&lt;/code&gt;. It's okay if there are some risk of &quot;collisions&quot; for &lt;code&gt;hashCode()&lt;/code&gt;, but never okay for &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">내 &lt;code&gt;Person&lt;/code&gt; 예제에서 아마도 &lt;code&gt;hashCode&lt;/code&gt; 에 &lt;code&gt;getName()&lt;/code&gt; 을 사용하고 &lt;code&gt;equals()&lt;/code&gt; &lt;code&gt;getName()&lt;/code&gt; 추가 할 것입니다. &lt;code&gt;hashCode()&lt;/code&gt; 에 &quot;충돌&quot;의 위험이있는 경우에는 괜찮지 만 &lt;code&gt;equals()&lt;/code&gt; 대해서는 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">실제로:</target>
        </trans-unit>
        <trans-unit id="0056a4f499f49f25d8e6d30cf07c16396cec89b6" translate="yes" xml:space="preserve">
          <source>Logically we have:</source>
          <target state="translated">논리적으로 우리는 :</target>
        </trans-unit>
        <trans-unit id="8b0458d416c6aa631736525627993e3207809598" translate="yes" xml:space="preserve">
          <source>Note that equals() must work across inheritance hierarchies if the &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; is to be satisfied.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov 대체 원칙&lt;/a&gt; 을 만족하려면 equals ()가 상속 계층 구조에서 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="64751fa16b61e77aab739d5f48f9057d95bc8bda" translate="yes" xml:space="preserve">
          <source>ORMs usually use the getters to force loading of lazy loaded objects. This means that &lt;code&gt;person.name&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;person&lt;/code&gt; is lazy loaded, even if &lt;code&gt;person.getName()&lt;/code&gt; forces loading and returns &quot;John Doe&quot;. In my experience, this crops up more often in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">ORM은 일반적으로 게터를 사용하여 지연로드 된 객체를 강제로로드합니다. 이는 &lt;code&gt;person.getName()&lt;/code&gt; 강제로로드되고 &quot;John Doe&quot;를 리턴하더라도 &lt;code&gt;person&lt;/code&gt; 이 게으른로드 인 경우 &lt;code&gt;person.name&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 임을 의미합니다. 내 경험상 이것은 &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;equals()&lt;/code&gt; 에서 더 자주 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e55ddccff6f2168523d83cfed3055eb78cc02d47" translate="yes" xml:space="preserve">
          <source>Obviously, this is wrong.</source>
          <target state="translated">분명히 이것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9acc2aebc5911d699b1cfca78287f2872811476" translate="yes" xml:space="preserve">
          <source>One gotcha I have found is where two objects contain references to each other (one example being a parent/child relationship with a convenience method on the parent to get all children).</source>
          <target state="translated">내가 찾은 하나의 문제는 두 객체가 서로에 대한 참조를 포함하는 곳입니다 (예 : 모든 자식을 얻는 부모의 편리한 메소드와 부모 / 자식 관계).</target>
        </trans-unit>
        <trans-unit id="582f11dd91a22a0cb84bffe58835664e4a71997c" translate="yes" xml:space="preserve">
          <source>Option #2 allows the class to be safely extended without overriding equals or breaking symmetry.</source>
          <target state="translated">옵션 # 2를 사용하면 동등을 무시하거나 대칭을 위반하지 않고 클래스를 안전하게 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ccabf9026a63683181043461c7eab59eedbb945" translate="yes" xml:space="preserve">
          <source>Persistent objects often use a &lt;code&gt;id&lt;/code&gt; field to hold the key of the object. This field will be automatically updated when an object is first saved. Don't use an id field in &lt;code&gt;hashCode()&lt;/code&gt;. But you can use it in &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">영구 객체는 종종 &lt;code&gt;id&lt;/code&gt; 필드를 사용하여 객체의 키를 보유합니다. 이 필드는 객체가 처음 저장 될 때 자동으로 업데이트됩니다. &lt;code&gt;hashCode()&lt;/code&gt; 에서 id 필드를 사용하지 마십시오. 그러나 &lt;code&gt;equals()&lt;/code&gt; 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="412e4422ca7b5954610c57f820c03e025a5e4807" translate="yes" xml:space="preserve">
          <source>Still amazed that none recommended the guava library for this.</source>
          <target state="translated">아무도 구아바 도서관을 추천하지 않았다는 것에 여전히 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="2dd1ac43cd73c07de447dcf4d3ab834a73b813db" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;relation&lt;/strong&gt; between the two methods is:</source>
          <target state="translated">두 방법의 &lt;strong&gt;관계&lt;/strong&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f7ba8efb1b467a2d1d7ddc6e6ab2aa6615e546c" translate="yes" xml:space="preserve">
          <source>The simplest solution is to not include the getChildren collection in the methods.</source>
          <target state="translated">가장 간단한 해결책은 메소드에 getChildren 콜렉션을 포함시키지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f4e16ff4a047ab502e99233c3f9c9aa1da0e7e09" translate="yes" xml:space="preserve">
          <source>The theory (for the language lawyers and the mathematically inclined):</source>
          <target state="translated">이론 (언어 변호사와 수학적으로 기울어 진) :</target>
        </trans-unit>
        <trans-unit id="bd8de4fded13757eff562bd4d021d4c7fa85a974" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do your check for class equality before checking member equality, and I think both are useful in the right circumstances.</source>
          <target state="translated">멤버 평등을 확인하기 전에 클래스 평등을 확인하는 몇 가지 방법이 있으며 올바른 환경에서 두 가지 모두 유용하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="50aaa6f26406d17bbdd71f58caccfc4f9979e795" translate="yes" xml:space="preserve">
          <source>There are some issues worth noticing if you're dealing with classes that are persisted using an Object-Relationship Mapper (ORM) like Hibernate, if you didn't think this was unreasonably complicated already!</source>
          <target state="translated">Hibernate와 같은 ORM (Object-Relationship Mapper)을 사용하여 지속되는 클래스를 다루는 경우 주목할 가치가있는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d711e49f79cabb0e9cc44e4606a1763d31519d" translate="yes" xml:space="preserve">
          <source>There are two methods in super class as java.lang.Object. We need to override them to custom object.</source>
          <target state="translated">수퍼 클래스에는 java.lang.Object라는 두 가지 메소드가 있습니다. 우리는 그것들을 커스텀 객체로 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a710bd29adb9290c00bbe7e48301371863f4b68" translate="yes" xml:space="preserve">
          <source>These sorts of things are fairly common when doing Hibernate mappings for example.</source>
          <target state="translated">이러한 종류의 것들은 예를 들어 Hibernate 매핑을 할 때 상당히 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ba83f17eb5a6602129a7a4f14a4268637521e6dc" translate="yes" xml:space="preserve">
          <source>This is another example,
&lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</source>
          <target state="translated">이것은 또 다른 예입니다. &lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bf5ac0cdd28ee7b36aff2c63722f286ac508b17" translate="yes" xml:space="preserve">
          <source>This looks all very good, but look what happens if we try to use both classes:</source>
          <target state="translated">이것은 매우 좋아 보이지만 두 클래스를 모두 사용하려고하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="7c9abc37f86cb000f84106519fa519800f0ae298" translate="yes" xml:space="preserve">
          <source>This statement is the result of &lt;code&gt;equals()&lt;/code&gt; being inheritance unfriendly. The JLS (Java language specification) specifies that if &lt;code&gt;A.equals(B) == true&lt;/code&gt; then &lt;code&gt;B.equals(A)&lt;/code&gt; must also return &lt;code&gt;true&lt;/code&gt;. If you omit that statement inheriting classes that override &lt;code&gt;equals()&lt;/code&gt; (and change its behavior) will break this specification.</source>
          <target state="translated">이 문장은 &lt;code&gt;equals()&lt;/code&gt; 가 비우호적 인 상속의 결과입니다. JLS (Java 언어 사양)는 &lt;code&gt;A.equals(B) == true&lt;/code&gt; 경우 &lt;code&gt;B.equals(A)&lt;/code&gt; 도 &lt;code&gt;true&lt;/code&gt; 를 반환하도록 지정 합니다 . &lt;code&gt;equals()&lt;/code&gt; 를 재정의하고 (동작을 변경하는 ) 클래스를 상속하는 명령문을 생략하면이 스펙이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="8d8057b34bb99a355b34d0844f873952e99075d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30d3721bcf2fd63752954949b7f62b79546fe86" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;instanceof&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0995e6a2763ac6d3b2e19a4bfb99a7c9d23b580c" translate="yes" xml:space="preserve">
          <source>Use the excellent helper classes &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; from the &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; library. An example:</source>
          <target state="translated">&lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; 라이브러리의 탁월한 헬퍼 클래스 &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; 및 &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; 를 사용하십시오. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0b00259f707253247792f28e940445bdf7e58a8b" translate="yes" xml:space="preserve">
          <source>Use the same set of fields that you use to compute &lt;code&gt;equals()&lt;/code&gt; to compute &lt;code&gt;hashCode()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; 를 계산하여 &lt;code&gt;hashCode()&lt;/code&gt; 를 계산하는 데 사용하는 것과 동일한 필드 세트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99584a09a17d85e0f9f5d2d3ae48353752b8b362" translate="yes" xml:space="preserve">
          <source>What issues / pitfalls must be considered when overriding &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; 및 &lt;code&gt;hashCode&lt;/code&gt; 를 재정의 할 때 어떤 문제 / 함정을 고려해야합니까?</target>
        </trans-unit>
        <trans-unit id="79ea937511f4975749deb53d859a2fd8fbdad4d4" translate="yes" xml:space="preserve">
          <source>What issues should be considered when overriding equals and hashCode in Java</source>
          <target state="translated">Java에서 equals 및 hashCode를 재정의 할 때 고려해야 할 사항</target>
        </trans-unit>
        <trans-unit id="e19c974a30c9bf4c69bca42a0d41ab8839e6f676" translate="yes" xml:space="preserve">
          <source>When using a hash-based &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; such as &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt;, or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt;, make sure that the hashCode() of the key objects that you put into the collection never changes while the object is in the collection. The bulletproof way to ensure this is to make your keys immutable, &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;which has also other benefits&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt; 또는 &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt; 과 같은 해시 기반 &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; 또는 &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map을&lt;/a&gt; 사용하는 경우 컬렉션에 넣은 키 객체의 hashCode ()가 객체가 컬렉션에있는 동안 절대 변경되지 않도록하십시오. 이를 보장하는 방탄 방법은 키를 불변으로 만드는 &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;것인데 다른 이점도&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="43884696debd7a85de030b8b5a1a412e31c22fbe" translate="yes" xml:space="preserve">
          <source>Where, if &lt;code&gt;a&lt;/code&gt; is not a reference of &lt;code&gt;B&lt;/code&gt;, then it might be a be a reference of class &lt;code&gt;A&lt;/code&gt; (because you extend it), in this case you call &lt;code&gt;super.equals()&lt;/code&gt;&lt;strong&gt;too&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 의 참조가 아닌 경우 클래스 &lt;code&gt;A&lt;/code&gt; 의 참조가 될 수 있습니다 (확장하기 때문에).이 경우에는 &lt;code&gt;super.equals()&lt;/code&gt; &lt;strong&gt;도&lt;/strong&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4a6a8e83c94551b351ee98cb4b41c601c395eccd" translate="yes" xml:space="preserve">
          <source>Which will output:</source>
          <target state="translated">어느 것이 출력 될까요?</target>
        </trans-unit>
        <trans-unit id="421d84666068bc80bff12dbe67ae6a6e7b85cee2" translate="yes" xml:space="preserve">
          <source>as int value of 10 is always equal to 10. But this equals() method is about equality of two objects. When we say object, it will have properties. To decide about equality those properties are considered. It is not necessary that all properties must be taken into account to determine the equality and with respect to the class definition and context it can be decided. Then the equals() method can be overridden.</source>
          <target state="translated">int 값 10은 항상 10과 같습니다. 그러나이 equals () 메소드는 두 객체의 동등성에 관한 것입니다. 우리가 객체를 말할 때 속성이 있습니다. 평등을 결정하기 위해 이러한 속성이 고려됩니다. 동등성을 결정하고 클래스 정의 및 컨텍스트와 관련하여 결정될 수있는 모든 특성을 고려할 필요는 없습니다. 그런 다음 equals () 메서드를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8739389b6ffea0ddb7c0f395adb0b7ca53613654" translate="yes" xml:space="preserve">
          <source>equals() method is used to determine the equality of two objects.</source>
          <target state="translated">equals () 메소드는 두 객체의 동등성을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6cbedcc10dbb92919101264b42789bfd9475d7da" translate="yes" xml:space="preserve">
          <source>we should always override hashCode() method whenever we override equals() method. If not, what will happen? If we use hashtables in our application, it will not behave as expected. As the hashCode is used in determining the equality of values stored, it will not return the right corresponding value for a key.</source>
          <target state="translated">equals () 메서드를 재정의 할 때마다 항상 hashCode () 메서드를 재정의해야합니다. 그렇지 않은 경우 어떻게됩니까? 응용 프로그램에서 해시 테이블을 사용하면 예상대로 작동하지 않습니다. 해시 코드는 저장된 값의 동등성을 결정하는 데 사용되므로 키에 대한 해당 값을 반환하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
