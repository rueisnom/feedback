<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/27581">
    <body>
      <group id="27581">
        <trans-unit id="f62941d18c07c2767c9aca935f7eefec2dc77803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22930a9e5f455ca30ff8f6af54e4c0c72690ea3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt;) must define an equivalence relation (it must be &lt;em&gt;reflexive&lt;/em&gt;, &lt;em&gt;symmetric&lt;/em&gt;, and &lt;em&gt;transitive&lt;/em&gt;). In addition, it must be &lt;em&gt;consistent&lt;/em&gt; (if the objects are not modified, then it must keep returning the same value). Furthermore, &lt;code&gt;o.equals(null)&lt;/code&gt; must always return false.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; （ &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt; ）必须定义一个等价关系（它必须是&lt;em&gt;自反的&lt;/em&gt; ， &lt;em&gt;对称的&lt;/em&gt;和可&lt;em&gt;传递的&lt;/em&gt; ）。 另外，它必须是&lt;em&gt;一致的&lt;/em&gt; （如果未修改对象，则它必须保持返回相同的值）。 此外， &lt;code&gt;o.equals(null)&lt;/code&gt; 必须始终返回false。</target>
        </trans-unit>
        <trans-unit id="09d759af345e9f8fc9cbd37acbd9f09a7c5c1bb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashCode()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt;) must also be &lt;em&gt;consistent&lt;/em&gt; (if the object is not modified in terms of &lt;code&gt;equals()&lt;/code&gt;, it must keep returning the same value).</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; （ &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt; ）也必须是&lt;em&gt;一致的&lt;/em&gt; （如果未按照 &lt;code&gt;equals()&lt;/code&gt; 修改对象，则必须保持返回相同的值）。</target>
        </trans-unit>
        <trans-unit id="f41e0d94b82c1244acfb38f6d85fd02451fdf588" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;hashCode()&lt;/code&gt; should use the non-changing subset of properties from &lt;code&gt;equals()&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;hashCode()&lt;/code&gt; 应该使用 &lt;code&gt;equals()&lt;/code&gt; 中不变的属性子集&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e513d55f8afc9df2979625f0240690bceadb1f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, make sure to always use getters, and never field references in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果您正在处理ORM，请确保始终使用getter，并且永远不要在 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 中引用字段。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bfc4b9d4bb3b068f6f1690ffa035879735ef0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, using &lt;code&gt;o instanceof Person&lt;/code&gt; is the only thing that will behave correctly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果您正在处理ORM，则使用 &lt;code&gt;o instanceof Person&lt;/code&gt; 是唯一可以正确运行的东西。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bb03d5ecac5303318cbc14a70e6135b46c649ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever &lt;code&gt;a.equals(b)&lt;/code&gt;, then &lt;code&gt;a.hashCode()&lt;/code&gt; must be same as &lt;code&gt;b.hashCode()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;每当 &lt;code&gt;a.equals(b)&lt;/code&gt; 时 ， &lt;code&gt;a.hashCode()&lt;/code&gt; 必须与 &lt;code&gt;b.hashCode()&lt;/code&gt; 相同。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fba4a5bb0e819dded5facb835f31f90454fed74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects are subclasses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;延迟加载的对象是子类&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5416b666233e493bf1163608c860bed1b45e705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects have null-fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;延迟加载的对象具有空字段&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87b9966cd9c56cfca42f79b00795981cc5b96b8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Saving an object will change its state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;保存对象将更改其状态&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea919cd896a4ea6d29d672ece79624db4359bb54" translate="yes" xml:space="preserve">
          <source>A clarification about the &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt;.</source>
          <target state="translated">关于 &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt; 澄清。</target>
        </trans-unit>
        <trans-unit id="6895129e381c47582a6f95e9ff2da53a7d042422" translate="yes" xml:space="preserve">
          <source>A pattern I often use is</source>
          <target state="translated">我经常使用的一个模式是</target>
        </trans-unit>
        <trans-unit id="024cbca8c731c5b64edbfcc991e3b2f63e66f972" translate="yes" xml:space="preserve">
          <source>Also remember:</source>
          <target state="translated">还记得:</target>
        </trans-unit>
        <trans-unit id="39075a8ee0cb791ba0482d1d3898b58397927809" translate="yes" xml:space="preserve">
          <source>But &lt;strong&gt;not&lt;/strong&gt; vice-versa!</source>
          <target state="translated">但反之亦然！</target>
        </trans-unit>
        <trans-unit id="7d1bbdf358d01354cb4828d3a9b90762d31822ec" translate="yes" xml:space="preserve">
          <source>But: you cannot include &lt;code&gt;getId()&lt;/code&gt; in &lt;code&gt;hashCode()&lt;/code&gt;. If you do, when an object is persisted, its &lt;code&gt;hashCode&lt;/code&gt; changes. If the object is in a &lt;code&gt;HashSet&lt;/code&gt;, you'll &quot;never&quot; find it again.</source>
          <target state="translated">但是：您不能在 &lt;code&gt;hashCode()&lt;/code&gt; 中包含 &lt;code&gt;getId()&lt;/code&gt; （） 。 如果这样做，则持久化对象时，其 &lt;code&gt;hashCode&lt;/code&gt; 会更改。 如果对象位于 &lt;code&gt;HashSet&lt;/code&gt; 中 ，则将&amp;ldquo;再也找不到&amp;rdquo;它了。</target>
        </trans-unit>
        <trans-unit id="c7c505f16d180c269b917e56b85bc20a74debb36" translate="yes" xml:space="preserve">
          <source>Consider the following example of what happens when the statement is omitted:</source>
          <target state="translated">考虑一下下面的例子,当语句被省略时,会发生什么情况。</target>
        </trans-unit>
        <trans-unit id="e0824b4fba51777e4feffc1f5c2b3a206868d206" translate="yes" xml:space="preserve">
          <source>Default implementation given is hashCode() method in Object class uses the internal address of the object and converts it into integer and returns it.</source>
          <target state="translated">给出的默认实现是Object类中的hashCode()方法使用对象的内部地址并将其转换为整数并返回。</target>
        </trans-unit>
        <trans-unit id="9fe35515e27e7aa13569acd40fe243cd2f28732f" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Also, &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; result give out true, as it should.</source>
          <target state="translated">进行 &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; 此外， &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; 结果应为true。</target>
        </trans-unit>
        <trans-unit id="59ded4d66e030811c0cecc5c18265651f8781edb" translate="yes" xml:space="preserve">
          <source>Equal objects must produce the same hash code as long as they are equal, however unequal objects need not produce distinct hash codes.</source>
          <target state="translated">只要是相等的对象,就必须产生相同的哈希码,但是不相等的对象不需要产生不同的哈希码。</target>
        </trans-unit>
        <trans-unit id="67b3b65f196732922817614de3686f24f48f5c43" translate="yes" xml:space="preserve">
          <source>Example Code Output:</source>
          <target state="translated">示例代码输出。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a8bd05092951921e316937eaf9f671cae2150a0c" translate="yes" xml:space="preserve">
          <source>For an inheritance-friendly implementation, check out Tal Cohen's solution, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;How Do I Correctly Implement the equals() Method?&lt;/a&gt;</source>
          <target state="translated">对于继承友好的实现，请查看Tal Cohen的解决方案， &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;如何正确实现equals（）方法？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d70b5f678ecec38b3080112485d7acc173ba57" translate="yes" xml:space="preserve">
          <source>For equals, look into &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secrets of Equals&lt;/a&gt;&lt;/strong&gt; by &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt;. I love it very much. She's also a great FAQ about &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics in Java&lt;/a&gt;&lt;/strong&gt;. View her other articles &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;here&lt;/a&gt; (scroll down to &quot;Core Java&quot;), where she also goes on with Part-2 and &quot;mixed type comparison&quot;. Have fun reading them!</source>
          <target state="translated">对于平等，请看&lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;安吉莉卡&amp;middot;兰格&lt;/a&gt; （ Angelika Langer）的《平等的&lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;秘密》&lt;/a&gt;&lt;/strong&gt; 。 我非常爱它。 她还是有关&lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Java泛型&lt;/a&gt;&lt;/strong&gt;的很好的FAQ。 &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;在这里&lt;/a&gt;查看她的其他文章（向下滚动至&amp;ldquo; Core Java&amp;rdquo;），她还将继续进行第2部分和&amp;ldquo;混合类型比较&amp;rdquo;。 祝他们阅读愉快！</target>
        </trans-unit>
        <trans-unit id="3a0c83711ad78e79ea2e6a7e1075120a2ea2f087" translate="yes" xml:space="preserve">
          <source>Have Fun! @.@</source>
          <target state="translated">玩得开心! @.@</target>
        </trans-unit>
        <trans-unit id="28ac6d01c3b11a1242288d16c354d1d149c86bd7" translate="yes" xml:space="preserve">
          <source>His solution is to implement equals() by calling another nonsymmetric blindlyEquals() both ways.  blindlyEquals() is overridden by subclasses, equals() is inherited, and never overridden.</source>
          <target state="translated">他的解决方案是通过调用另一个非对称的bindlyEquals()来实现equals(),bindlyEquals()被子类重载,equals()是继承的,永远不会被重载。</target>
        </trans-unit>
        <trans-unit id="e068331a67b03e8bb4ff13910221de891b1c9497" translate="yes" xml:space="preserve">
          <source>I use #1 in a &lt;code&gt;final&lt;/code&gt; equals implementation, or when implementing an interface that prescribes an algorithm for equals (like the &lt;code&gt;java.util&lt;/code&gt; collection interfaces&amp;mdash;the right way to check with with &lt;code&gt;(obj instanceof Set)&lt;/code&gt; or whatever interface you're implementing). It's generally a bad choice when equals can be overridden because that breaks the symmetry property.</source>
          <target state="translated">我在 &lt;code&gt;final&lt;/code&gt; equals实现中使用＃1，或者在实现规定了equals算法的接口时使用（例如 &lt;code&gt;java.util&lt;/code&gt; 集合接口-使用 &lt;code&gt;(obj instanceof Set)&lt;/code&gt; 或要实现的任何接口进行检查的正确方法） 。 当可以覆盖equals时，这通常是一个错误的选择，因为这会破坏对称性。</target>
        </trans-unit>
        <trans-unit id="c047b686130b5ac2ddd022d754531089b0f8a3ea" translate="yes" xml:space="preserve">
          <source>If you include both ends of the relationship in your hashCode or equals tests it's possible to get into a recursive loop which ends in a StackOverflowException.</source>
          <target state="translated">如果你在hashCode或equals测试中包含了关系的两端,那么就有可能进入一个递归循环,最终导致StackOverflowException。</target>
        </trans-unit>
        <trans-unit id="af0d87ad2f0fa603892e358c5f2e857b7e5b7326" translate="yes" xml:space="preserve">
          <source>If you override one, then you should override the other.</source>
          <target state="translated">如果你推翻了一个,那么你就应该推翻另一个。</target>
        </trans-unit>
        <trans-unit id="e86f786bee221b53f9c6d6b66a3286e528acaa30" translate="yes" xml:space="preserve">
          <source>If you want get more, please check this link as &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</source>
          <target state="translated">如果您想获得更多，请检查此链接， &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;网址&lt;/a&gt;为http://www.javaranch.com/journal/2002/10/equalhash.html</target>
        </trans-unit>
        <trans-unit id="b11b283ab4205e58d038c48a1b4263bb016b302d" translate="yes" xml:space="preserve">
          <source>If you want to ensure the symmetric condition. a=b if b=a and the Liskov substitution principle call &lt;code&gt;super.equals(other)&lt;/code&gt; not only in the case of &lt;code&gt;B&lt;/code&gt; instance, but check after for &lt;code&gt;A&lt;/code&gt; instance:</source>
          <target state="translated">如果要确保对称条件。 a = b如果b = a且Liskov替换原理不仅在 &lt;code&gt;B&lt;/code&gt; 实例的情况下调用 &lt;code&gt;super.equals(other)&lt;/code&gt; ,还在之后检查 &lt;code&gt;A&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="f258ed46101818db9a26a356669ab445fa34d732" translate="yes" xml:space="preserve">
          <source>If your class is also &lt;code&gt;Comparable&lt;/code&gt;, the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; methods should be consistent too. Here's a template for the equals method in a &lt;code&gt;Comparable&lt;/code&gt; class:</source>
          <target state="translated">如果您的类也是 &lt;code&gt;Comparable&lt;/code&gt; ，则 &lt;code&gt;equals&lt;/code&gt; 和 &lt;code&gt;compareTo&lt;/code&gt; 方法也应保持一致。 这是 &lt;code&gt;Comparable&lt;/code&gt; 类中equals方法的模板：</target>
        </trans-unit>
        <trans-unit id="fedc3fcbdaf830c5e6d2b71eabde54346df9994d" translate="yes" xml:space="preserve">
          <source>If your objects are persisted using an ORM, in many cases you will be dealing with dynamic proxies to avoid loading object too early from the data store. These proxies are implemented as subclasses of your own class. This means that&lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;. For example:</source>
          <target state="translated">如果您的对象是使用ORM持久保存的，那么在许多情况下，您将使用动态代理来避免从数据存储中加载对象太早。 这些代理被实现为您自己类的子类。 这意味着 &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; 将返回 &lt;code&gt;false&lt;/code&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="897ebe0396bd9c0c657be610c7aeeb790710f6ac" translate="yes" xml:space="preserve">
          <source>In his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; (Addison-Wesley, 2001), Joshua Bloch claims that &quot;There is simply no way to extend an instantiable class and add an aspect while preserving the equals contract.&quot;  Tal disagrees.</source>
          <target state="translated">约书亚&amp;middot;布洛赫（Joshua Bloch）在他的《 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;有效的Java编程语言指南》&lt;/a&gt; （Addison-Wesley，2001年）一书中声称：&amp;ldquo;根本没有办法扩展可实例化的类并在保留平等契约的同时增加方面。&amp;rdquo; 塔尔不同意。</target>
        </trans-unit>
        <trans-unit id="ad7a3fd4c935ce7834ae51563058277f54f97bde" translate="yes" xml:space="preserve">
          <source>In my &lt;code&gt;Person&lt;/code&gt; example, I probably would use &lt;code&gt;getName()&lt;/code&gt; for &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;getId()&lt;/code&gt; plus &lt;code&gt;getName()&lt;/code&gt; (just for paranoia) for &lt;code&gt;equals()&lt;/code&gt;. It's okay if there are some risk of &quot;collisions&quot; for &lt;code&gt;hashCode()&lt;/code&gt;, but never okay for &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">在我的 &lt;code&gt;Person&lt;/code&gt; 示例中，我可能会将 &lt;code&gt;getName()&lt;/code&gt; 用于 &lt;code&gt;hashCode&lt;/code&gt; ，将 &lt;code&gt;getId()&lt;/code&gt; 加上 &lt;code&gt;getName()&lt;/code&gt; （仅用于偏执狂）用于 &lt;code&gt;equals()&lt;/code&gt; 。 如果 &lt;code&gt;hashCode()&lt;/code&gt; 存在&amp;ldquo;冲突&amp;rdquo;的风险是可以的，但对于 &lt;code&gt;equals()&lt;/code&gt; 则永远没有问题。</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">在实际工作中。</target>
        </trans-unit>
        <trans-unit id="0056a4f499f49f25d8e6d30cf07c16396cec89b6" translate="yes" xml:space="preserve">
          <source>Logically we have:</source>
          <target state="translated">逻辑上我们有。</target>
        </trans-unit>
        <trans-unit id="8b0458d416c6aa631736525627993e3207809598" translate="yes" xml:space="preserve">
          <source>Note that equals() must work across inheritance hierarchies if the &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; is to be satisfied.</source>
          <target state="translated">请注意，如果要满足&lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov替换原则&lt;/a&gt; ，则equals（）必须跨继承层次结构工作。</target>
        </trans-unit>
        <trans-unit id="64751fa16b61e77aab739d5f48f9057d95bc8bda" translate="yes" xml:space="preserve">
          <source>ORMs usually use the getters to force loading of lazy loaded objects. This means that &lt;code&gt;person.name&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;person&lt;/code&gt; is lazy loaded, even if &lt;code&gt;person.getName()&lt;/code&gt; forces loading and returns &quot;John Doe&quot;. In my experience, this crops up more often in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">ORM通常使用吸气剂来强制加载延迟加载的对象。 这意味着即使 &lt;code&gt;person&lt;/code&gt; 延迟加载， &lt;code&gt;person.name&lt;/code&gt; 也将为 &lt;code&gt;null&lt;/code&gt; ，即使 &lt;code&gt;person.getName()&lt;/code&gt; 强制加载并返回&amp;ldquo; John Doe&amp;rdquo;。 以我的经验，这种情况更多地出现在 &lt;code&gt;hashCode()&lt;/code&gt; 和 &lt;code&gt;equals()&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="e55ddccff6f2168523d83cfed3055eb78cc02d47" translate="yes" xml:space="preserve">
          <source>Obviously, this is wrong.</source>
          <target state="translated">很显然,这是不对的。</target>
        </trans-unit>
        <trans-unit id="d9acc2aebc5911d699b1cfca78287f2872811476" translate="yes" xml:space="preserve">
          <source>One gotcha I have found is where two objects contain references to each other (one example being a parent/child relationship with a convenience method on the parent to get all children).</source>
          <target state="translated">我发现的一个问题是,当两个对象之间包含相互引用的时候(一个例子是父子关系,在父对象上有一个方便的方法来获取所有的子对象)。</target>
        </trans-unit>
        <trans-unit id="582f11dd91a22a0cb84bffe58835664e4a71997c" translate="yes" xml:space="preserve">
          <source>Option #2 allows the class to be safely extended without overriding equals or breaking symmetry.</source>
          <target state="translated">选项#2允许安全地扩展类,而不需要覆盖等号或打破对称性。</target>
        </trans-unit>
        <trans-unit id="3ccabf9026a63683181043461c7eab59eedbb945" translate="yes" xml:space="preserve">
          <source>Persistent objects often use a &lt;code&gt;id&lt;/code&gt; field to hold the key of the object. This field will be automatically updated when an object is first saved. Don't use an id field in &lt;code&gt;hashCode()&lt;/code&gt;. But you can use it in &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">持久性对象通常使用 &lt;code&gt;id&lt;/code&gt; 字段来保存对象的键。 首次保存对象时，此字段将自动更新。 不要在 &lt;code&gt;hashCode()&lt;/code&gt; 中使用id字段。 但是您可以在 &lt;code&gt;equals()&lt;/code&gt; 中使用它。</target>
        </trans-unit>
        <trans-unit id="412e4422ca7b5954610c57f820c03e025a5e4807" translate="yes" xml:space="preserve">
          <source>Still amazed that none recommended the guava library for this.</source>
          <target state="translated">还是很惊讶,没有一个人推荐番石榴文库来做这个。</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="2dd1ac43cd73c07de447dcf4d3ab834a73b813db" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;relation&lt;/strong&gt; between the two methods is:</source>
          <target state="translated">两种方法之间的&lt;strong&gt;关系&lt;/strong&gt;为：</target>
        </trans-unit>
        <trans-unit id="5f7ba8efb1b467a2d1d7ddc6e6ab2aa6615e546c" translate="yes" xml:space="preserve">
          <source>The simplest solution is to not include the getChildren collection in the methods.</source>
          <target state="translated">最简单的解决方案是不在方法中包含getChildren集合。</target>
        </trans-unit>
        <trans-unit id="f4e16ff4a047ab502e99233c3f9c9aa1da0e7e09" translate="yes" xml:space="preserve">
          <source>The theory (for the language lawyers and the mathematically inclined):</source>
          <target state="translated">理论(针对语言法学家和有数学倾向的人)。</target>
        </trans-unit>
        <trans-unit id="bd8de4fded13757eff562bd4d021d4c7fa85a974" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do your check for class equality before checking member equality, and I think both are useful in the right circumstances.</source>
          <target state="translated">在检查会员平等性之前,有几种方法可以做班级平等性的检查,我认为这两种方法在合适的情况下都是有用的。</target>
        </trans-unit>
        <trans-unit id="50aaa6f26406d17bbdd71f58caccfc4f9979e795" translate="yes" xml:space="preserve">
          <source>There are some issues worth noticing if you're dealing with classes that are persisted using an Object-Relationship Mapper (ORM) like Hibernate, if you didn't think this was unreasonably complicated already!</source>
          <target state="translated">如果你在处理使用像Hibernate这样的对象关系映射器(ORM)持久化的类,有一些问题值得注意,如果你还不觉得这已经是不合理的复杂了的话!如果你在处理使用对象关系映射器(ORM)持久化的类,有一些问题值得注意</target>
        </trans-unit>
        <trans-unit id="69d711e49f79cabb0e9cc44e4606a1763d31519d" translate="yes" xml:space="preserve">
          <source>There are two methods in super class as java.lang.Object. We need to override them to custom object.</source>
          <target state="translated">在超级类中,有两个方法是java.lang.Object。我们需要将它们覆盖到自定义对象中。</target>
        </trans-unit>
        <trans-unit id="2a710bd29adb9290c00bbe7e48301371863f4b68" translate="yes" xml:space="preserve">
          <source>These sorts of things are fairly common when doing Hibernate mappings for example.</source>
          <target state="translated">例如,在做Hibernate映射时,这类事情是相当常见的。</target>
        </trans-unit>
        <trans-unit id="ba83f17eb5a6602129a7a4f14a4268637521e6dc" translate="yes" xml:space="preserve">
          <source>This is another example,
&lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</source>
          <target state="translated">这是另一个示例， &lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bf5ac0cdd28ee7b36aff2c63722f286ac508b17" translate="yes" xml:space="preserve">
          <source>This looks all very good, but look what happens if we try to use both classes:</source>
          <target state="translated">这看起来都很好,但看看如果我们尝试使用这两个类会发生什么。</target>
        </trans-unit>
        <trans-unit id="7c9abc37f86cb000f84106519fa519800f0ae298" translate="yes" xml:space="preserve">
          <source>This statement is the result of &lt;code&gt;equals()&lt;/code&gt; being inheritance unfriendly. The JLS (Java language specification) specifies that if &lt;code&gt;A.equals(B) == true&lt;/code&gt; then &lt;code&gt;B.equals(A)&lt;/code&gt; must also return &lt;code&gt;true&lt;/code&gt;. If you omit that statement inheriting classes that override &lt;code&gt;equals()&lt;/code&gt; (and change its behavior) will break this specification.</source>
          <target state="translated">该语句是 &lt;code&gt;equals()&lt;/code&gt; 被继承不友好的结果。 JLS（Java语言规范）指定，如果 &lt;code&gt;A.equals(B) == true&lt;/code&gt; 则 &lt;code&gt;B.equals(A)&lt;/code&gt; 也必须返回 &lt;code&gt;true&lt;/code&gt; 。 如果忽略该语句，则该类继承了覆盖 &lt;code&gt;equals()&lt;/code&gt; 的类 （并更改其行为）将违反此规范。</target>
        </trans-unit>
        <trans-unit id="8d8057b34bb99a355b34d0844f873952e99075d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e30d3721bcf2fd63752954949b7f62b79546fe86" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;instanceof&lt;/code&gt; operator.</source>
          <target state="translated">使用 &lt;code&gt;instanceof&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="0995e6a2763ac6d3b2e19a4bfb99a7c9d23b580c" translate="yes" xml:space="preserve">
          <source>Use the excellent helper classes &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; from the &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; library. An example:</source>
          <target state="translated">使用&lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt;库中出色的帮助程序类&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt;和&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; 。 一个例子：</target>
        </trans-unit>
        <trans-unit id="0b00259f707253247792f28e940445bdf7e58a8b" translate="yes" xml:space="preserve">
          <source>Use the same set of fields that you use to compute &lt;code&gt;equals()&lt;/code&gt; to compute &lt;code&gt;hashCode()&lt;/code&gt;.</source>
          <target state="translated">使用用于计算 &lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 的同一组字段。</target>
        </trans-unit>
        <trans-unit id="99584a09a17d85e0f9f5d2d3ae48353752b8b362" translate="yes" xml:space="preserve">
          <source>What issues / pitfalls must be considered when overriding &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;?</source>
          <target state="translated">覆盖 &lt;code&gt;equals&lt;/code&gt; 和 &lt;code&gt;hashCode&lt;/code&gt; 时必须考虑哪些问题/陷阱？</target>
        </trans-unit>
        <trans-unit id="79ea937511f4975749deb53d859a2fd8fbdad4d4" translate="yes" xml:space="preserve">
          <source>What issues should be considered when overriding equals and hashCode in Java</source>
          <target state="translated">在Java中覆盖equals和hashCode时,应该考虑哪些问题?</target>
        </trans-unit>
        <trans-unit id="e19c974a30c9bf4c69bca42a0d41ab8839e6f676" translate="yes" xml:space="preserve">
          <source>When using a hash-based &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; such as &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt;, or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt;, make sure that the hashCode() of the key objects that you put into the collection never changes while the object is in the collection. The bulletproof way to ensure this is to make your keys immutable, &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;which has also other benefits&lt;/a&gt;.</source>
          <target state="translated">当使用基于哈希的&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt;或&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map（&lt;/a&gt;例如&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt; ， &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt; ， &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; ， &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt;或&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap）时&lt;/a&gt; ，请确保放入对象的关键对象的hashCode（）永远不会在对象位于集合中时改变。 确保这一点的防弹方法是使您的钥匙不可变， &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;这还有其他好处&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="43884696debd7a85de030b8b5a1a412e31c22fbe" translate="yes" xml:space="preserve">
          <source>Where, if &lt;code&gt;a&lt;/code&gt; is not a reference of &lt;code&gt;B&lt;/code&gt;, then it might be a be a reference of class &lt;code&gt;A&lt;/code&gt; (because you extend it), in this case you call &lt;code&gt;super.equals()&lt;/code&gt;&lt;strong&gt;too&lt;/strong&gt;.</source>
          <target state="translated">其中，如果 &lt;code&gt;a&lt;/code&gt; 不是 &lt;code&gt;B&lt;/code&gt; 的引用，则它可能是 &lt;code&gt;A&lt;/code&gt; 类的引用（因为您对其进行了扩展），在这种情况下，您也调用了 &lt;code&gt;super.equals()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a6a8e83c94551b351ee98cb4b41c601c395eccd" translate="yes" xml:space="preserve">
          <source>Which will output:</source>
          <target state="translated">这将输出。</target>
        </trans-unit>
        <trans-unit id="421d84666068bc80bff12dbe67ae6a6e7b85cee2" translate="yes" xml:space="preserve">
          <source>as int value of 10 is always equal to 10. But this equals() method is about equality of two objects. When we say object, it will have properties. To decide about equality those properties are considered. It is not necessary that all properties must be taken into account to determine the equality and with respect to the class definition and context it can be decided. Then the equals() method can be overridden.</source>
          <target state="translated">作为int值的10总是等于10。但这个equals()方法是关于两个对象的平等。当我们说对象的时候,它将有属性。要决定是否平等,就要考虑这些属性。不一定要考虑到所有的属性来决定是否相等,根据类的定义和上下文就可以决定。那么equals()方法可以被覆盖。</target>
        </trans-unit>
        <trans-unit id="8739389b6ffea0ddb7c0f395adb0b7ca53613654" translate="yes" xml:space="preserve">
          <source>equals() method is used to determine the equality of two objects.</source>
          <target state="translated">equals()方法用于确定两个对象的平等性。</target>
        </trans-unit>
        <trans-unit id="6cbedcc10dbb92919101264b42789bfd9475d7da" translate="yes" xml:space="preserve">
          <source>we should always override hashCode() method whenever we override equals() method. If not, what will happen? If we use hashtables in our application, it will not behave as expected. As the hashCode is used in determining the equality of values stored, it will not return the right corresponding value for a key.</source>
          <target state="translated">每当我们覆盖equals()方法时,我们应该总是覆盖hashCode()方法。如果不这样做,会发生什么?如果我们在应用程序中使用hashCode方法,那么它的行为将不会像预期的那样。因为hashCode是用来确定存储的值的平等性,所以它不会返回一个键的正确对应值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
