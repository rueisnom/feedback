<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/27581">
    <body>
      <group id="27581">
        <trans-unit id="f62941d18c07c2767c9aca935f7eefec2dc77803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22930a9e5f455ca30ff8f6af54e4c0c72690ea3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt;) must define an equivalence relation (it must be &lt;em&gt;reflexive&lt;/em&gt;, &lt;em&gt;symmetric&lt;/em&gt;, and &lt;em&gt;transitive&lt;/em&gt;). In addition, it must be &lt;em&gt;consistent&lt;/em&gt; (if the objects are not modified, then it must keep returning the same value). Furthermore, &lt;code&gt;o.equals(null)&lt;/code&gt; must always return false.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt; ) debe definir una relaci&amp;oacute;n de equivalencia (debe ser &lt;em&gt;reflexiva&lt;/em&gt; , &lt;em&gt;sim&amp;eacute;trica&lt;/em&gt; y &lt;em&gt;transitiva&lt;/em&gt; ). Adem&amp;aacute;s, debe ser &lt;em&gt;coherente&lt;/em&gt; (si los objetos no se modifican, debe seguir devolviendo el mismo valor). Adem&amp;aacute;s, &lt;code&gt;o.equals(null)&lt;/code&gt; siempre debe devolver falso.</target>
        </trans-unit>
        <trans-unit id="09d759af345e9f8fc9cbd37acbd9f09a7c5c1bb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashCode()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt;) must also be &lt;em&gt;consistent&lt;/em&gt; (if the object is not modified in terms of &lt;code&gt;equals()&lt;/code&gt;, it must keep returning the same value).</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt; ) tambi&amp;eacute;n debe ser &lt;em&gt;coherente&lt;/em&gt; (si el objeto no se modifica en t&amp;eacute;rminos de &lt;code&gt;equals()&lt;/code&gt; , debe seguir devolviendo el mismo valor).</target>
        </trans-unit>
        <trans-unit id="f41e0d94b82c1244acfb38f6d85fd02451fdf588" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;hashCode()&lt;/code&gt; should use the non-changing subset of properties from &lt;code&gt;equals()&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;hashCode()&lt;/code&gt; debe usar el subconjunto de propiedades que no cambia de &lt;code&gt;equals()&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e513d55f8afc9df2979625f0240690bceadb1f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, make sure to always use getters, and never field references in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Si se trata de un ORM, aseg&amp;uacute;rese de usar siempre getters y nunca las referencias de campo en &lt;code&gt;hashCode()&lt;/code&gt; y &lt;code&gt;equals()&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bfc4b9d4bb3b068f6f1690ffa035879735ef0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, using &lt;code&gt;o instanceof Person&lt;/code&gt; is the only thing that will behave correctly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Si se trata de un ORM, usar &lt;code&gt;o instanceof Person&lt;/code&gt; es lo &amp;uacute;nico que se comportar&amp;aacute; correctamente.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bb03d5ecac5303318cbc14a70e6135b46c649ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever &lt;code&gt;a.equals(b)&lt;/code&gt;, then &lt;code&gt;a.hashCode()&lt;/code&gt; must be same as &lt;code&gt;b.hashCode()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Siempre que &lt;code&gt;a.equals(b)&lt;/code&gt; , &lt;code&gt;a.hashCode()&lt;/code&gt; debe ser el mismo que &lt;code&gt;b.hashCode()&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fba4a5bb0e819dded5facb835f31f90454fed74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects are subclasses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Los objetos con carga diferida son subclases&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5416b666233e493bf1163608c860bed1b45e705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects have null-fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Los objetos cargados perezosos tienen campos nulos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87b9966cd9c56cfca42f79b00795981cc5b96b8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Saving an object will change its state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Guardar un objeto cambiar&amp;aacute; su estado&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea919cd896a4ea6d29d672ece79624db4359bb54" translate="yes" xml:space="preserve">
          <source>A clarification about the &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt;.</source>
          <target state="translated">Una aclaraci&amp;oacute;n sobre &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6895129e381c47582a6f95e9ff2da53a7d042422" translate="yes" xml:space="preserve">
          <source>A pattern I often use is</source>
          <target state="translated">Un patrón que uso a menudo es</target>
        </trans-unit>
        <trans-unit id="024cbca8c731c5b64edbfcc991e3b2f63e66f972" translate="yes" xml:space="preserve">
          <source>Also remember:</source>
          <target state="translated">También recuerde:</target>
        </trans-unit>
        <trans-unit id="39075a8ee0cb791ba0482d1d3898b58397927809" translate="yes" xml:space="preserve">
          <source>But &lt;strong&gt;not&lt;/strong&gt; vice-versa!</source>
          <target state="translated">&amp;iexcl;Pero &lt;strong&gt;no&lt;/strong&gt; al rev&amp;eacute;s!</target>
        </trans-unit>
        <trans-unit id="7d1bbdf358d01354cb4828d3a9b90762d31822ec" translate="yes" xml:space="preserve">
          <source>But: you cannot include &lt;code&gt;getId()&lt;/code&gt; in &lt;code&gt;hashCode()&lt;/code&gt;. If you do, when an object is persisted, its &lt;code&gt;hashCode&lt;/code&gt; changes. If the object is in a &lt;code&gt;HashSet&lt;/code&gt;, you'll &quot;never&quot; find it again.</source>
          <target state="translated">Pero: no puede incluir &lt;code&gt;getId()&lt;/code&gt; en &lt;code&gt;hashCode()&lt;/code&gt; . Si lo hace, cuando un objeto persiste, su &lt;code&gt;hashCode&lt;/code&gt; cambia. Si el objeto est&amp;aacute; en un &lt;code&gt;HashSet&lt;/code&gt; , &quot;nunca&quot; lo encontrar&amp;aacute; de nuevo.</target>
        </trans-unit>
        <trans-unit id="c7c505f16d180c269b917e56b85bc20a74debb36" translate="yes" xml:space="preserve">
          <source>Consider the following example of what happens when the statement is omitted:</source>
          <target state="translated">Considere el siguiente ejemplo de lo que sucede cuando se omite la declaración:</target>
        </trans-unit>
        <trans-unit id="e0824b4fba51777e4feffc1f5c2b3a206868d206" translate="yes" xml:space="preserve">
          <source>Default implementation given is hashCode() method in Object class uses the internal address of the object and converts it into integer and returns it.</source>
          <target state="translated">La implementación por defecto dada es el método hashCode()en la clase Object utiliza la dirección interna del objeto y la convierte en entero y la devuelve.</target>
        </trans-unit>
        <trans-unit id="9fe35515e27e7aa13569acd40fe243cd2f28732f" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Also, &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; result give out true, as it should.</source>
          <target state="translated">Hacer &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Adem&amp;aacute;s, el &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; resulta verdadero, como deber&amp;iacute;a ser.</target>
        </trans-unit>
        <trans-unit id="59ded4d66e030811c0cecc5c18265651f8781edb" translate="yes" xml:space="preserve">
          <source>Equal objects must produce the same hash code as long as they are equal, however unequal objects need not produce distinct hash codes.</source>
          <target state="translated">Los objetos iguales deben producir el mismo código hash siempre y cuando sean iguales,sin embargo los objetos desiguales no necesitan producir códigos hash distintos.</target>
        </trans-unit>
        <trans-unit id="67b3b65f196732922817614de3686f24f48f5c43" translate="yes" xml:space="preserve">
          <source>Example Code Output:</source>
          <target state="translated">Ejemplo de código de salida:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a8bd05092951921e316937eaf9f671cae2150a0c" translate="yes" xml:space="preserve">
          <source>For an inheritance-friendly implementation, check out Tal Cohen's solution, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;How Do I Correctly Implement the equals() Method?&lt;/a&gt;</source>
          <target state="translated">Para una implementaci&amp;oacute;n amigable con la herencia, consulte la soluci&amp;oacute;n de Tal Cohen, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;&amp;iquest;C&amp;oacute;mo implemento correctamente el m&amp;eacute;todo equals ()?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d70b5f678ecec38b3080112485d7acc173ba57" translate="yes" xml:space="preserve">
          <source>For equals, look into &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secrets of Equals&lt;/a&gt;&lt;/strong&gt; by &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt;. I love it very much. She's also a great FAQ about &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics in Java&lt;/a&gt;&lt;/strong&gt;. View her other articles &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;here&lt;/a&gt; (scroll down to &quot;Core Java&quot;), where she also goes on with Part-2 and &quot;mixed type comparison&quot;. Have fun reading them!</source>
          <target state="translated">Para los iguales, busque &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secretos de los iguales&lt;/a&gt;&lt;/strong&gt; de &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt; . Yo la amo mucho. Tambi&amp;eacute;n es una gran pregunta frecuente sobre &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;gen&amp;eacute;ricos en Java&lt;/a&gt;&lt;/strong&gt; . Vea sus otros art&amp;iacute;culos &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;aqu&amp;iacute;&lt;/a&gt; (despl&amp;aacute;cese hacia abajo hasta &quot;Core Java&quot;), donde tambi&amp;eacute;n contin&amp;uacute;a con la Parte 2 y la &quot;comparaci&amp;oacute;n de tipos mixtos&quot;. &amp;iexcl;Divi&amp;eacute;rtete ley&amp;eacute;ndolos!</target>
        </trans-unit>
        <trans-unit id="3a0c83711ad78e79ea2e6a7e1075120a2ea2f087" translate="yes" xml:space="preserve">
          <source>Have Fun! @.@</source>
          <target state="translated">¡Diviértete! @.@</target>
        </trans-unit>
        <trans-unit id="28ac6d01c3b11a1242288d16c354d1d149c86bd7" translate="yes" xml:space="preserve">
          <source>His solution is to implement equals() by calling another nonsymmetric blindlyEquals() both ways.  blindlyEquals() is overridden by subclasses, equals() is inherited, and never overridden.</source>
          <target state="translated">Su solución es implementar equals()llamando a otro no simétrico blindlyEquals()en ambos sentidos.blindlyEquals()es anulado por subclases,equals()es heredado,y nunca anulado.</target>
        </trans-unit>
        <trans-unit id="e068331a67b03e8bb4ff13910221de891b1c9497" translate="yes" xml:space="preserve">
          <source>I use #1 in a &lt;code&gt;final&lt;/code&gt; equals implementation, or when implementing an interface that prescribes an algorithm for equals (like the &lt;code&gt;java.util&lt;/code&gt; collection interfaces&amp;mdash;the right way to check with with &lt;code&gt;(obj instanceof Set)&lt;/code&gt; or whatever interface you're implementing). It's generally a bad choice when equals can be overridden because that breaks the symmetry property.</source>
          <target state="translated">Uso el n. &amp;deg; 1 en una implementaci&amp;oacute;n de igualdad &lt;code&gt;final&lt;/code&gt; , o cuando implemento una interfaz que prescribe un algoritmo para igualdad (como las interfaces de colecci&amp;oacute;n &lt;code&gt;java.util&lt;/code&gt; , la forma correcta de verificar con &lt;code&gt;(obj instanceof Set)&lt;/code&gt; o cualquier interfaz que est&amp;eacute; implementando) . En general, es una mala elecci&amp;oacute;n cuando se pueden anular iguales porque eso rompe la propiedad de simetr&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="c047b686130b5ac2ddd022d754531089b0f8a3ea" translate="yes" xml:space="preserve">
          <source>If you include both ends of the relationship in your hashCode or equals tests it's possible to get into a recursive loop which ends in a StackOverflowException.</source>
          <target state="translated">Si incluyes ambos extremos de la relación en tu hashCode o pruebas de igualdad es posible entrar en un bucle recursivo que termina en un StackOverflowException.</target>
        </trans-unit>
        <trans-unit id="af0d87ad2f0fa603892e358c5f2e857b7e5b7326" translate="yes" xml:space="preserve">
          <source>If you override one, then you should override the other.</source>
          <target state="translated">Si anulas una,entonces deberías anular la otra.</target>
        </trans-unit>
        <trans-unit id="e86f786bee221b53f9c6d6b66a3286e528acaa30" translate="yes" xml:space="preserve">
          <source>If you want get more, please check this link as &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</source>
          <target state="translated">Si desea obtener m&amp;aacute;s, consulte este enlace como &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b11b283ab4205e58d038c48a1b4263bb016b302d" translate="yes" xml:space="preserve">
          <source>If you want to ensure the symmetric condition. a=b if b=a and the Liskov substitution principle call &lt;code&gt;super.equals(other)&lt;/code&gt; not only in the case of &lt;code&gt;B&lt;/code&gt; instance, but check after for &lt;code&gt;A&lt;/code&gt; instance:</source>
          <target state="translated">Si desea garantizar la condici&amp;oacute;n sim&amp;eacute;trica. a = b si b = a y el principio de sustituci&amp;oacute;n de Liskov llama a &lt;code&gt;super.equals(other)&lt;/code&gt; no solo en el caso de la instancia de &lt;code&gt;B&lt;/code&gt; , sino que comprueba despu&amp;eacute;s la instancia de &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f258ed46101818db9a26a356669ab445fa34d732" translate="yes" xml:space="preserve">
          <source>If your class is also &lt;code&gt;Comparable&lt;/code&gt;, the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; methods should be consistent too. Here's a template for the equals method in a &lt;code&gt;Comparable&lt;/code&gt; class:</source>
          <target state="translated">Si su clase tambi&amp;eacute;n es &lt;code&gt;Comparable&lt;/code&gt; , los m&amp;eacute;todos &lt;code&gt;equals&lt;/code&gt; y &lt;code&gt;compareTo&lt;/code&gt; tambi&amp;eacute;n deber&amp;iacute;an ser consistentes. Aqu&amp;iacute; hay una plantilla para el m&amp;eacute;todo igual en una clase &lt;code&gt;Comparable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fedc3fcbdaf830c5e6d2b71eabde54346df9994d" translate="yes" xml:space="preserve">
          <source>If your objects are persisted using an ORM, in many cases you will be dealing with dynamic proxies to avoid loading object too early from the data store. These proxies are implemented as subclasses of your own class. This means that&lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;. For example:</source>
          <target state="translated">Si sus objetos persisten utilizando un ORM, en muchos casos estar&amp;aacute; tratando con proxys din&amp;aacute;micos para evitar cargar objetos demasiado pronto desde el almac&amp;eacute;n de datos. Estos proxies se implementan como subclases de su propia clase. Esto significa que &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="897ebe0396bd9c0c657be610c7aeeb790710f6ac" translate="yes" xml:space="preserve">
          <source>In his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; (Addison-Wesley, 2001), Joshua Bloch claims that &quot;There is simply no way to extend an instantiable class and add an aspect while preserving the equals contract.&quot;  Tal disagrees.</source>
          <target state="translated">En su libro &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Gu&amp;iacute;a efectiva del lenguaje de programaci&amp;oacute;n Java&lt;/a&gt; (Addison-Wesley, 2001), Joshua Bloch afirma que &quot;simplemente no hay forma de extender una clase instanciable y agregar un aspecto mientras se preserva el contrato igual&quot;. Tal no est&amp;aacute; de acuerdo.</target>
        </trans-unit>
        <trans-unit id="ad7a3fd4c935ce7834ae51563058277f54f97bde" translate="yes" xml:space="preserve">
          <source>In my &lt;code&gt;Person&lt;/code&gt; example, I probably would use &lt;code&gt;getName()&lt;/code&gt; for &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;getId()&lt;/code&gt; plus &lt;code&gt;getName()&lt;/code&gt; (just for paranoia) for &lt;code&gt;equals()&lt;/code&gt;. It's okay if there are some risk of &quot;collisions&quot; for &lt;code&gt;hashCode()&lt;/code&gt;, but never okay for &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">En mi ejemplo de &lt;code&gt;Person&lt;/code&gt; , probablemente usar&amp;iacute;a &lt;code&gt;getName()&lt;/code&gt; para &lt;code&gt;hashCode&lt;/code&gt; y &lt;code&gt;getId()&lt;/code&gt; m&amp;aacute;s &lt;code&gt;getName()&lt;/code&gt; (solo para paranoia) para &lt;code&gt;equals()&lt;/code&gt; . Est&amp;aacute; bien si hay alg&amp;uacute;n riesgo de &quot;colisiones&quot; para &lt;code&gt;hashCode()&lt;/code&gt; , pero nunca est&amp;aacute; bien para &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">En la práctica:</target>
        </trans-unit>
        <trans-unit id="0056a4f499f49f25d8e6d30cf07c16396cec89b6" translate="yes" xml:space="preserve">
          <source>Logically we have:</source>
          <target state="translated">Lógicamente lo hemos hecho:</target>
        </trans-unit>
        <trans-unit id="8b0458d416c6aa631736525627993e3207809598" translate="yes" xml:space="preserve">
          <source>Note that equals() must work across inheritance hierarchies if the &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; is to be satisfied.</source>
          <target state="translated">Tenga en cuenta que equals () debe funcionar en todas las jerarqu&amp;iacute;as de herencia si se debe cumplir el &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Principio de sustituci&amp;oacute;n de Liskov&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64751fa16b61e77aab739d5f48f9057d95bc8bda" translate="yes" xml:space="preserve">
          <source>ORMs usually use the getters to force loading of lazy loaded objects. This means that &lt;code&gt;person.name&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;person&lt;/code&gt; is lazy loaded, even if &lt;code&gt;person.getName()&lt;/code&gt; forces loading and returns &quot;John Doe&quot;. In my experience, this crops up more often in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">Los ORM generalmente usan los captadores para forzar la carga de objetos con carga lenta. Esto significa que &lt;code&gt;person.name&lt;/code&gt; ser&amp;aacute; &lt;code&gt;null&lt;/code&gt; si la &lt;code&gt;person&lt;/code&gt; a tiene una carga diferida, incluso si &lt;code&gt;person.getName()&lt;/code&gt; fuerza la carga y devuelve &quot;John Doe&quot;. En mi experiencia, esto surge m&amp;aacute;s a menudo en &lt;code&gt;hashCode()&lt;/code&gt; y &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e55ddccff6f2168523d83cfed3055eb78cc02d47" translate="yes" xml:space="preserve">
          <source>Obviously, this is wrong.</source>
          <target state="translated">Obviamente,esto está mal.</target>
        </trans-unit>
        <trans-unit id="d9acc2aebc5911d699b1cfca78287f2872811476" translate="yes" xml:space="preserve">
          <source>One gotcha I have found is where two objects contain references to each other (one example being a parent/child relationship with a convenience method on the parent to get all children).</source>
          <target state="translated">Una de las cosas que he encontrado es que dos objetos contienen referencias el uno al otro (un ejemplo es una relación padre-hijo con un método de conveniencia en el padre para conseguir todos los hijos).</target>
        </trans-unit>
        <trans-unit id="582f11dd91a22a0cb84bffe58835664e4a71997c" translate="yes" xml:space="preserve">
          <source>Option #2 allows the class to be safely extended without overriding equals or breaking symmetry.</source>
          <target state="translated">La opción 2 permite que la clase se extienda con seguridad sin anular los iguales o romper la simetría.</target>
        </trans-unit>
        <trans-unit id="3ccabf9026a63683181043461c7eab59eedbb945" translate="yes" xml:space="preserve">
          <source>Persistent objects often use a &lt;code&gt;id&lt;/code&gt; field to hold the key of the object. This field will be automatically updated when an object is first saved. Don't use an id field in &lt;code&gt;hashCode()&lt;/code&gt;. But you can use it in &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">Los objetos persistentes a menudo usan un campo de &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n para mantener la clave del objeto. Este campo se actualizar&amp;aacute; autom&amp;aacute;ticamente cuando se guarde un objeto por primera vez. No use un campo de identificaci&amp;oacute;n en &lt;code&gt;hashCode()&lt;/code&gt; . Pero puedes usarlo en &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="412e4422ca7b5954610c57f820c03e025a5e4807" translate="yes" xml:space="preserve">
          <source>Still amazed that none recommended the guava library for this.</source>
          <target state="translated">Todavía me sorprende que nadie haya recomendado la biblioteca de guayabas para esto.</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="2dd1ac43cd73c07de447dcf4d3ab834a73b813db" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;relation&lt;/strong&gt; between the two methods is:</source>
          <target state="translated">La &lt;strong&gt;relaci&amp;oacute;n&lt;/strong&gt; entre los dos m&amp;eacute;todos es:</target>
        </trans-unit>
        <trans-unit id="5f7ba8efb1b467a2d1d7ddc6e6ab2aa6615e546c" translate="yes" xml:space="preserve">
          <source>The simplest solution is to not include the getChildren collection in the methods.</source>
          <target state="translated">La solución más simple es no incluir la colección getChildren en los métodos.</target>
        </trans-unit>
        <trans-unit id="f4e16ff4a047ab502e99233c3f9c9aa1da0e7e09" translate="yes" xml:space="preserve">
          <source>The theory (for the language lawyers and the mathematically inclined):</source>
          <target state="translated">La teoría (para los abogados del lenguaje y los que se inclinan por las matemáticas):</target>
        </trans-unit>
        <trans-unit id="bd8de4fded13757eff562bd4d021d4c7fa85a974" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do your check for class equality before checking member equality, and I think both are useful in the right circumstances.</source>
          <target state="translated">Hay un par de formas de comprobar la igualdad de clase antes de comprobar la igualdad de los miembros,y creo que ambas son útiles en las circunstancias adecuadas.</target>
        </trans-unit>
        <trans-unit id="50aaa6f26406d17bbdd71f58caccfc4f9979e795" translate="yes" xml:space="preserve">
          <source>There are some issues worth noticing if you're dealing with classes that are persisted using an Object-Relationship Mapper (ORM) like Hibernate, if you didn't think this was unreasonably complicated already!</source>
          <target state="translated">Hay algunas cuestiones que vale la pena notar si estás tratando con clases que se persiguen usando un Mapeador de Relación de Objetos (ORM)como Hibernar,¡si no pensabas que esto ya era irrazonablemente complicado!</target>
        </trans-unit>
        <trans-unit id="69d711e49f79cabb0e9cc44e4606a1763d31519d" translate="yes" xml:space="preserve">
          <source>There are two methods in super class as java.lang.Object. We need to override them to custom object.</source>
          <target state="translated">Hay dos métodos en la superclase como java.lang.Object.Necesitamos anularlos para personalizar el objeto.</target>
        </trans-unit>
        <trans-unit id="2a710bd29adb9290c00bbe7e48301371863f4b68" translate="yes" xml:space="preserve">
          <source>These sorts of things are fairly common when doing Hibernate mappings for example.</source>
          <target state="translated">Este tipo de cosas son bastante comunes cuando se hacen mapeos de Hibernación,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="ba83f17eb5a6602129a7a4f14a4268637521e6dc" translate="yes" xml:space="preserve">
          <source>This is another example,
&lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</source>
          <target state="translated">Este es otro ejemplo, &lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bf5ac0cdd28ee7b36aff2c63722f286ac508b17" translate="yes" xml:space="preserve">
          <source>This looks all very good, but look what happens if we try to use both classes:</source>
          <target state="translated">Todo esto se ve muy bien,pero mira lo que pasa si tratamos de usar ambas clases:</target>
        </trans-unit>
        <trans-unit id="7c9abc37f86cb000f84106519fa519800f0ae298" translate="yes" xml:space="preserve">
          <source>This statement is the result of &lt;code&gt;equals()&lt;/code&gt; being inheritance unfriendly. The JLS (Java language specification) specifies that if &lt;code&gt;A.equals(B) == true&lt;/code&gt; then &lt;code&gt;B.equals(A)&lt;/code&gt; must also return &lt;code&gt;true&lt;/code&gt;. If you omit that statement inheriting classes that override &lt;code&gt;equals()&lt;/code&gt; (and change its behavior) will break this specification.</source>
          <target state="translated">Esta declaraci&amp;oacute;n es el resultado de que &lt;code&gt;equals()&lt;/code&gt; es una herencia hostil. La JLS (especificaci&amp;oacute;n del lenguaje Java) especifica que si &lt;code&gt;A.equals(B) == true&lt;/code&gt; entonces &lt;code&gt;B.equals(A)&lt;/code&gt; tambi&amp;eacute;n debe devolver &lt;code&gt;true&lt;/code&gt; . Si omite esa declaraci&amp;oacute;n, las clases heredadas que anulan &lt;code&gt;equals()&lt;/code&gt; (y cambian su comportamiento) romper&amp;aacute;n esta especificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8d8057b34bb99a355b34d0844f873952e99075d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt;.</source>
          <target state="translated">Use &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30d3721bcf2fd63752954949b7f62b79546fe86" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;instanceof&lt;/code&gt; operator.</source>
          <target state="translated">Use el operador &lt;code&gt;instanceof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0995e6a2763ac6d3b2e19a4bfb99a7c9d23b580c" translate="yes" xml:space="preserve">
          <source>Use the excellent helper classes &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; from the &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; library. An example:</source>
          <target state="translated">Utilice las excelentes clases auxiliares &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; y &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; de la biblioteca &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Lang de Apache Commons&lt;/a&gt; . Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="0b00259f707253247792f28e940445bdf7e58a8b" translate="yes" xml:space="preserve">
          <source>Use the same set of fields that you use to compute &lt;code&gt;equals()&lt;/code&gt; to compute &lt;code&gt;hashCode()&lt;/code&gt;.</source>
          <target state="translated">Use el mismo conjunto de campos que usa para calcular &lt;code&gt;equals()&lt;/code&gt; para calcular &lt;code&gt;hashCode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99584a09a17d85e0f9f5d2d3ae48353752b8b362" translate="yes" xml:space="preserve">
          <source>What issues / pitfalls must be considered when overriding &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; problemas / dificultades deben tenerse en cuenta al anular &lt;code&gt;equals&lt;/code&gt; y &lt;code&gt;hashCode&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="79ea937511f4975749deb53d859a2fd8fbdad4d4" translate="yes" xml:space="preserve">
          <source>What issues should be considered when overriding equals and hashCode in Java</source>
          <target state="translated">¿Qué cuestiones deben ser consideradas cuando se anulan las igualdades y el hashCode en Java?</target>
        </trans-unit>
        <trans-unit id="e19c974a30c9bf4c69bca42a0d41ab8839e6f676" translate="yes" xml:space="preserve">
          <source>When using a hash-based &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; such as &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt;, or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt;, make sure that the hashCode() of the key objects that you put into the collection never changes while the object is in the collection. The bulletproof way to ensure this is to make your keys immutable, &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;which has also other benefits&lt;/a&gt;.</source>
          <target state="translated">Cuando utilice una &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;colecci&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;mapa&lt;/a&gt; basado en hash, como &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt; o &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt; , aseg&amp;uacute;rese de que el hashCode () de los objetos clave que coloca en la colecci&amp;oacute;n nunca cambie mientras el objeto est&amp;aacute; en la colecci&amp;oacute;n. La forma a prueba de balas para garantizar esto es hacer que sus claves sean inmutables, lo &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;que tambi&amp;eacute;n tiene otros beneficios&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43884696debd7a85de030b8b5a1a412e31c22fbe" translate="yes" xml:space="preserve">
          <source>Where, if &lt;code&gt;a&lt;/code&gt; is not a reference of &lt;code&gt;B&lt;/code&gt;, then it might be a be a reference of class &lt;code&gt;A&lt;/code&gt; (because you extend it), in this case you call &lt;code&gt;super.equals()&lt;/code&gt;&lt;strong&gt;too&lt;/strong&gt;.</source>
          <target state="translated">Donde, si &lt;code&gt;a&lt;/code&gt; no es una referencia de &lt;code&gt;B&lt;/code&gt; , entonces podr&amp;iacute;a ser una referencia de clase &lt;code&gt;A&lt;/code&gt; (porque la extiende), en este caso tambi&amp;eacute;n se llama &lt;code&gt;super.equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a6a8e83c94551b351ee98cb4b41c601c395eccd" translate="yes" xml:space="preserve">
          <source>Which will output:</source>
          <target state="translated">Que saldrá:</target>
        </trans-unit>
        <trans-unit id="421d84666068bc80bff12dbe67ae6a6e7b85cee2" translate="yes" xml:space="preserve">
          <source>as int value of 10 is always equal to 10. But this equals() method is about equality of two objects. When we say object, it will have properties. To decide about equality those properties are considered. It is not necessary that all properties must be taken into account to determine the equality and with respect to the class definition and context it can be decided. Then the equals() method can be overridden.</source>
          <target state="translated">ya que el valor int de 10 es siempre igual a 10.Pero este método equals()se trata de la igualdad de dos objetos.Cuando decimos objeto,tendrá propiedades.Para decidir sobre la igualdad se consideran esas propiedades.No es necesario que se tengan en cuenta todas las propiedades para determinar la igualdad y con respecto a la definición de la clase y el contexto se puede decidir.Entonces el método equals()puede ser anulado.</target>
        </trans-unit>
        <trans-unit id="8739389b6ffea0ddb7c0f395adb0b7ca53613654" translate="yes" xml:space="preserve">
          <source>equals() method is used to determine the equality of two objects.</source>
          <target state="translated">El método equals()se utiliza para determinar la igualdad de dos objetos.</target>
        </trans-unit>
        <trans-unit id="6cbedcc10dbb92919101264b42789bfd9475d7da" translate="yes" xml:space="preserve">
          <source>we should always override hashCode() method whenever we override equals() method. If not, what will happen? If we use hashtables in our application, it will not behave as expected. As the hashCode is used in determining the equality of values stored, it will not return the right corresponding value for a key.</source>
          <target state="translated">siempre debemos anular el método hashCode()cuando anulamos el método equals().Si no,¿qué pasará? Si usamos hashtables en nuestra aplicación,no se comportará como se esperaba.Como el hashCode se utiliza para determinar la igualdad de los valores almacenados,no devolverá el valor correcto correspondiente a una clave.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
