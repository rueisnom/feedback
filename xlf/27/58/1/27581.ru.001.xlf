<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/27581">
    <body>
      <group id="27581">
        <trans-unit id="f62941d18c07c2767c9aca935f7eefec2dc77803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22930a9e5f455ca30ff8f6af54e4c0c72690ea3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt;) must define an equivalence relation (it must be &lt;em&gt;reflexive&lt;/em&gt;, &lt;em&gt;symmetric&lt;/em&gt;, and &lt;em&gt;transitive&lt;/em&gt;). In addition, it must be &lt;em&gt;consistent&lt;/em&gt; (if the objects are not modified, then it must keep returning the same value). Furthermore, &lt;code&gt;o.equals(null)&lt;/code&gt; must always return false.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt; ) должна определять отношение эквивалентности (оно должно быть &lt;em&gt;рефлексивным&lt;/em&gt; , &lt;em&gt;симметричным&lt;/em&gt; и &lt;em&gt;транзитивным&lt;/em&gt; ). Кроме того, он должен быть &lt;em&gt;согласованным&lt;/em&gt; (если объекты не изменены, то он должен продолжать возвращать одно и то же значение). Кроме того, &lt;code&gt;o.equals(null)&lt;/code&gt; всегда должен возвращать false.</target>
        </trans-unit>
        <trans-unit id="09d759af345e9f8fc9cbd37acbd9f09a7c5c1bb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashCode()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt;) must also be &lt;em&gt;consistent&lt;/em&gt; (if the object is not modified in terms of &lt;code&gt;equals()&lt;/code&gt;, it must keep returning the same value).</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; ( &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt; ) также должен быть &lt;em&gt;непротиворечивым&lt;/em&gt; (если объект не изменен в терминах &lt;code&gt;equals()&lt;/code&gt; , он должен продолжать возвращать одно и то же значение).</target>
        </trans-unit>
        <trans-unit id="f41e0d94b82c1244acfb38f6d85fd02451fdf588" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;hashCode()&lt;/code&gt; should use the non-changing subset of properties from &lt;code&gt;equals()&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;hashCode()&lt;/code&gt; должен использовать неизменяемое подмножество свойств из &lt;code&gt;equals()&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e513d55f8afc9df2979625f0240690bceadb1f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, make sure to always use getters, and never field references in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Если вы имеете дело с ORM, всегда используйте геттеры и никогда не &lt;code&gt;hashCode()&lt;/code&gt; ссылки в полях в hashCode () и &lt;code&gt;equals()&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bfc4b9d4bb3b068f6f1690ffa035879735ef0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, using &lt;code&gt;o instanceof Person&lt;/code&gt; is the only thing that will behave correctly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Если вы имеете дело с ORM, использование &lt;code&gt;o instanceof Person&lt;/code&gt; - единственное, что будет вести себя правильно.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bb03d5ecac5303318cbc14a70e6135b46c649ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever &lt;code&gt;a.equals(b)&lt;/code&gt;, then &lt;code&gt;a.hashCode()&lt;/code&gt; must be same as &lt;code&gt;b.hashCode()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Всякий раз, когда &lt;code&gt;a.equals(b)&lt;/code&gt; , тогда &lt;code&gt;a.hashCode()&lt;/code&gt; должен быть таким же, как &lt;code&gt;b.hashCode()&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fba4a5bb0e819dded5facb835f31f90454fed74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects are subclasses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ленивые загруженные объекты являются подклассами&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5416b666233e493bf1163608c860bed1b45e705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects have null-fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ленивые загруженные объекты имеют нулевые поля&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87b9966cd9c56cfca42f79b00795981cc5b96b8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Saving an object will change its state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сохранение объекта изменит его состояние&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea919cd896a4ea6d29d672ece79624db4359bb54" translate="yes" xml:space="preserve">
          <source>A clarification about the &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj.getClass() != getClass()&lt;/code&gt; о obj.getClass ()! = GetClass () .</target>
        </trans-unit>
        <trans-unit id="6895129e381c47582a6f95e9ff2da53a7d042422" translate="yes" xml:space="preserve">
          <source>A pattern I often use is</source>
          <target state="translated">Образец,который я часто использую.</target>
        </trans-unit>
        <trans-unit id="024cbca8c731c5b64edbfcc991e3b2f63e66f972" translate="yes" xml:space="preserve">
          <source>Also remember:</source>
          <target state="translated">И не забудь:</target>
        </trans-unit>
        <trans-unit id="39075a8ee0cb791ba0482d1d3898b58397927809" translate="yes" xml:space="preserve">
          <source>But &lt;strong&gt;not&lt;/strong&gt; vice-versa!</source>
          <target state="translated">Но &lt;strong&gt;не&lt;/strong&gt; наоборот!</target>
        </trans-unit>
        <trans-unit id="7d1bbdf358d01354cb4828d3a9b90762d31822ec" translate="yes" xml:space="preserve">
          <source>But: you cannot include &lt;code&gt;getId()&lt;/code&gt; in &lt;code&gt;hashCode()&lt;/code&gt;. If you do, when an object is persisted, its &lt;code&gt;hashCode&lt;/code&gt; changes. If the object is in a &lt;code&gt;HashSet&lt;/code&gt;, you'll &quot;never&quot; find it again.</source>
          <target state="translated">Но: вы не можете включить &lt;code&gt;getId()&lt;/code&gt; в &lt;code&gt;hashCode()&lt;/code&gt; . Если вы делаете, когда объект сохраняется, его &lt;code&gt;hashCode&lt;/code&gt; изменяется. Если объект находится в &lt;code&gt;HashSet&lt;/code&gt; , вы никогда не найдете его снова.</target>
        </trans-unit>
        <trans-unit id="c7c505f16d180c269b917e56b85bc20a74debb36" translate="yes" xml:space="preserve">
          <source>Consider the following example of what happens when the statement is omitted:</source>
          <target state="translated">Рассмотрим следующий пример того,что происходит,когда утверждение опущено:</target>
        </trans-unit>
        <trans-unit id="e0824b4fba51777e4feffc1f5c2b3a206868d206" translate="yes" xml:space="preserve">
          <source>Default implementation given is hashCode() method in Object class uses the internal address of the object and converts it into integer and returns it.</source>
          <target state="translated">Реализация по умолчанию-метод hashCode()в классе Object использует внутренний адрес объекта,преобразует его в целое число и возвращает его.</target>
        </trans-unit>
        <trans-unit id="9fe35515e27e7aa13569acd40fe243cd2f28732f" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Also, &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; result give out true, as it should.</source>
          <target state="translated">Выполнение &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Кроме того, &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; выдает true, как и должно быть.</target>
        </trans-unit>
        <trans-unit id="59ded4d66e030811c0cecc5c18265651f8781edb" translate="yes" xml:space="preserve">
          <source>Equal objects must produce the same hash code as long as they are equal, however unequal objects need not produce distinct hash codes.</source>
          <target state="translated">Равные объекты должны выдавать один и тот же хэш-код при условии,что они равны,однако неравные объекты не должны выдавать разные хэш-коды.</target>
        </trans-unit>
        <trans-unit id="67b3b65f196732922817614de3686f24f48f5c43" translate="yes" xml:space="preserve">
          <source>Example Code Output:</source>
          <target state="translated">Пример вывода кода:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a8bd05092951921e316937eaf9f671cae2150a0c" translate="yes" xml:space="preserve">
          <source>For an inheritance-friendly implementation, check out Tal Cohen's solution, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;How Do I Correctly Implement the equals() Method?&lt;/a&gt;</source>
          <target state="translated">Для реализации, дружественной к наследованию, ознакомьтесь с решением Тэла Коэна &amp;laquo; &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;Как правильно реализовать метод equals ()&amp;raquo;?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d70b5f678ecec38b3080112485d7acc173ba57" translate="yes" xml:space="preserve">
          <source>For equals, look into &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secrets of Equals&lt;/a&gt;&lt;/strong&gt; by &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt;. I love it very much. She's also a great FAQ about &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics in Java&lt;/a&gt;&lt;/strong&gt;. View her other articles &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;here&lt;/a&gt; (scroll down to &quot;Core Java&quot;), where she also goes on with Part-2 and &quot;mixed type comparison&quot;. Have fun reading them!</source>
          <target state="translated">Для равных, посмотрите на &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Тайны Равных&lt;/a&gt;&lt;/strong&gt; &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Анжеликой Лангер&lt;/a&gt; . Я очень люблю это. Она также является отличным FAQ по &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics в Java&lt;/a&gt;&lt;/strong&gt; . Посмотрите ее другие статьи &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;здесь&lt;/a&gt; (прокрутите вниз до &amp;laquo;Базовая Java&amp;raquo;), где она также продолжает Часть 2 и &amp;laquo;Сравнение смешанных типов&amp;raquo;. Приятного чтения!</target>
        </trans-unit>
        <trans-unit id="3a0c83711ad78e79ea2e6a7e1075120a2ea2f087" translate="yes" xml:space="preserve">
          <source>Have Fun! @.@</source>
          <target state="translated">Веселитесь! @.@</target>
        </trans-unit>
        <trans-unit id="28ac6d01c3b11a1242288d16c354d1d149c86bd7" translate="yes" xml:space="preserve">
          <source>His solution is to implement equals() by calling another nonsymmetric blindlyEquals() both ways.  blindlyEquals() is overridden by subclasses, equals() is inherited, and never overridden.</source>
          <target state="translated">Его решение заключается в реализации функции equals()путем вызова другой несимметричной blindlyEquals()в обоих направлениях.blindlyEquals()переопределяется подклассами,equals()наследуется и никогда не переопределяется.</target>
        </trans-unit>
        <trans-unit id="e068331a67b03e8bb4ff13910221de891b1c9497" translate="yes" xml:space="preserve">
          <source>I use #1 in a &lt;code&gt;final&lt;/code&gt; equals implementation, or when implementing an interface that prescribes an algorithm for equals (like the &lt;code&gt;java.util&lt;/code&gt; collection interfaces&amp;mdash;the right way to check with with &lt;code&gt;(obj instanceof Set)&lt;/code&gt; or whatever interface you're implementing). It's generally a bad choice when equals can be overridden because that breaks the symmetry property.</source>
          <target state="translated">Я использую # 1 в &lt;code&gt;final&lt;/code&gt; реализации equals или при реализации интерфейса, который предписывает алгоритм для equals (например, интерфейсы коллекции &lt;code&gt;java.util&lt;/code&gt; - правильный способ проверки с помощью &lt;code&gt;(obj instanceof Set)&lt;/code&gt; или любого интерфейса, который вы реализуете) , Обычно это плохой выбор, когда равенства могут быть переопределены, потому что это нарушает свойство симметрии.</target>
        </trans-unit>
        <trans-unit id="c047b686130b5ac2ddd022d754531089b0f8a3ea" translate="yes" xml:space="preserve">
          <source>If you include both ends of the relationship in your hashCode or equals tests it's possible to get into a recursive loop which ends in a StackOverflowException.</source>
          <target state="translated">Если вы включите оба конца отношений в свой хэшкод или равнозначные тесты,то можно попасть в рекурсивный цикл,который заканчивается в StackOverflowException.</target>
        </trans-unit>
        <trans-unit id="af0d87ad2f0fa603892e358c5f2e857b7e5b7326" translate="yes" xml:space="preserve">
          <source>If you override one, then you should override the other.</source>
          <target state="translated">Если ты переопределяешь одного,то ты должен переопределить другого.</target>
        </trans-unit>
        <trans-unit id="e86f786bee221b53f9c6d6b66a3286e528acaa30" translate="yes" xml:space="preserve">
          <source>If you want get more, please check this link as &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</source>
          <target state="translated">Если вы хотите получить больше, проверьте эту ссылку как &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b11b283ab4205e58d038c48a1b4263bb016b302d" translate="yes" xml:space="preserve">
          <source>If you want to ensure the symmetric condition. a=b if b=a and the Liskov substitution principle call &lt;code&gt;super.equals(other)&lt;/code&gt; not only in the case of &lt;code&gt;B&lt;/code&gt; instance, but check after for &lt;code&gt;A&lt;/code&gt; instance:</source>
          <target state="translated">Если вы хотите обеспечить симметричное условие. a = b, если b = a и принцип подстановки Лискова вызывает &lt;code&gt;super.equals(other)&lt;/code&gt; не только в случае экземпляра &lt;code&gt;B&lt;/code&gt; , но и проверяет наличие экземпляра &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f258ed46101818db9a26a356669ab445fa34d732" translate="yes" xml:space="preserve">
          <source>If your class is also &lt;code&gt;Comparable&lt;/code&gt;, the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; methods should be consistent too. Here's a template for the equals method in a &lt;code&gt;Comparable&lt;/code&gt; class:</source>
          <target state="translated">Если ваш класс также &lt;code&gt;Comparable&lt;/code&gt; , методы &lt;code&gt;equals&lt;/code&gt; и &lt;code&gt;compareTo&lt;/code&gt; также должны быть согласованными. Вот шаблон для метода equals в классе &lt;code&gt;Comparable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fedc3fcbdaf830c5e6d2b71eabde54346df9994d" translate="yes" xml:space="preserve">
          <source>If your objects are persisted using an ORM, in many cases you will be dealing with dynamic proxies to avoid loading object too early from the data store. These proxies are implemented as subclasses of your own class. This means that&lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;. For example:</source>
          <target state="translated">Если ваши объекты сохраняются с использованием ORM, во многих случаях вы будете иметь дело с динамическими прокси, чтобы избежать слишком ранней загрузки объекта из хранилища данных. Эти прокси реализованы как подклассы вашего собственного класса. Это означает, что &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; вернет &lt;code&gt;false&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="897ebe0396bd9c0c657be610c7aeeb790710f6ac" translate="yes" xml:space="preserve">
          <source>In his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; (Addison-Wesley, 2001), Joshua Bloch claims that &quot;There is simply no way to extend an instantiable class and add an aspect while preserving the equals contract.&quot;  Tal disagrees.</source>
          <target state="translated">В своей книге &amp;laquo; &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Эффективное руководство по языку программирования Java&amp;raquo;&lt;/a&gt; (Addison-Wesley, 2001) Джошуа Блох утверждает, что &amp;laquo;просто нет способа расширить экземплярный класс и добавить аспект при сохранении контракта равных&amp;raquo;. Тал не согласен.</target>
        </trans-unit>
        <trans-unit id="ad7a3fd4c935ce7834ae51563058277f54f97bde" translate="yes" xml:space="preserve">
          <source>In my &lt;code&gt;Person&lt;/code&gt; example, I probably would use &lt;code&gt;getName()&lt;/code&gt; for &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;getId()&lt;/code&gt; plus &lt;code&gt;getName()&lt;/code&gt; (just for paranoia) for &lt;code&gt;equals()&lt;/code&gt;. It's okay if there are some risk of &quot;collisions&quot; for &lt;code&gt;hashCode()&lt;/code&gt;, but never okay for &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">В моем примере &lt;code&gt;Person&lt;/code&gt; я, вероятно, использовал бы &lt;code&gt;getName()&lt;/code&gt; для &lt;code&gt;hashCode&lt;/code&gt; и &lt;code&gt;getId()&lt;/code&gt; плюс &lt;code&gt;getName()&lt;/code&gt; (только для паранойи) для &lt;code&gt;equals()&lt;/code&gt; . Это нормально, если есть некоторый риск &amp;laquo;коллизий&amp;raquo; для &lt;code&gt;hashCode()&lt;/code&gt; , но никогда не в порядке для &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">На практике:</target>
        </trans-unit>
        <trans-unit id="0056a4f499f49f25d8e6d30cf07c16396cec89b6" translate="yes" xml:space="preserve">
          <source>Logically we have:</source>
          <target state="translated">Логично,что так:</target>
        </trans-unit>
        <trans-unit id="8b0458d416c6aa631736525627993e3207809598" translate="yes" xml:space="preserve">
          <source>Note that equals() must work across inheritance hierarchies if the &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; is to be satisfied.</source>
          <target state="translated">Обратите внимание, что метод equals () должен работать в иерархиях наследования, если необходимо выполнить &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;принцип подстановки Лискова&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64751fa16b61e77aab739d5f48f9057d95bc8bda" translate="yes" xml:space="preserve">
          <source>ORMs usually use the getters to force loading of lazy loaded objects. This means that &lt;code&gt;person.name&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;person&lt;/code&gt; is lazy loaded, even if &lt;code&gt;person.getName()&lt;/code&gt; forces loading and returns &quot;John Doe&quot;. In my experience, this crops up more often in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">ORM обычно используют геттеры для принудительной загрузки лениво загруженных объектов. Это означает, что &lt;code&gt;person.name&lt;/code&gt; будет &lt;code&gt;null&lt;/code&gt; если &lt;code&gt;person&lt;/code&gt; загружен лениво, даже если &lt;code&gt;person.getName()&lt;/code&gt; форсирует загрузку и возвращает &amp;laquo;John Doe&amp;raquo;. По моему опыту, это чаще встречается в &lt;code&gt;hashCode()&lt;/code&gt; и &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e55ddccff6f2168523d83cfed3055eb78cc02d47" translate="yes" xml:space="preserve">
          <source>Obviously, this is wrong.</source>
          <target state="translated">Очевидно,это неправильно.</target>
        </trans-unit>
        <trans-unit id="d9acc2aebc5911d699b1cfca78287f2872811476" translate="yes" xml:space="preserve">
          <source>One gotcha I have found is where two objects contain references to each other (one example being a parent/child relationship with a convenience method on the parent to get all children).</source>
          <target state="translated">Одна из найденных мной вещей заключается в том,что два объекта содержат ссылки друг на друга (один пример-родительские отношения с удобным для родителя методом,чтобы получить всех детей).</target>
        </trans-unit>
        <trans-unit id="582f11dd91a22a0cb84bffe58835664e4a71997c" translate="yes" xml:space="preserve">
          <source>Option #2 allows the class to be safely extended without overriding equals or breaking symmetry.</source>
          <target state="translated">Опция №2 позволяет безопасно расширять класс,не переопределяя равенства и не нарушая симметрию.</target>
        </trans-unit>
        <trans-unit id="3ccabf9026a63683181043461c7eab59eedbb945" translate="yes" xml:space="preserve">
          <source>Persistent objects often use a &lt;code&gt;id&lt;/code&gt; field to hold the key of the object. This field will be automatically updated when an object is first saved. Don't use an id field in &lt;code&gt;hashCode()&lt;/code&gt;. But you can use it in &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">Постоянные объекты часто используют поле &lt;code&gt;id&lt;/code&gt; для хранения ключа объекта. Это поле будет автоматически обновляться при первом сохранении объекта. Не используйте поле id в &lt;code&gt;hashCode()&lt;/code&gt; . Но вы можете использовать его в &lt;code&gt;equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="412e4422ca7b5954610c57f820c03e025a5e4807" translate="yes" xml:space="preserve">
          <source>Still amazed that none recommended the guava library for this.</source>
          <target state="translated">Все еще удивлен,что никто не рекомендовал для этого библиотеку гуавы.</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="2dd1ac43cd73c07de447dcf4d3ab834a73b813db" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;relation&lt;/strong&gt; between the two methods is:</source>
          <target state="translated">&lt;strong&gt;Соотношение&lt;/strong&gt; между этими двумя методами:</target>
        </trans-unit>
        <trans-unit id="5f7ba8efb1b467a2d1d7ddc6e6ab2aa6615e546c" translate="yes" xml:space="preserve">
          <source>The simplest solution is to not include the getChildren collection in the methods.</source>
          <target state="translated">Самое простое решение-не включать в методы коллекцию getChildren.</target>
        </trans-unit>
        <trans-unit id="f4e16ff4a047ab502e99233c3f9c9aa1da0e7e09" translate="yes" xml:space="preserve">
          <source>The theory (for the language lawyers and the mathematically inclined):</source>
          <target state="translated">Теория (для юристов языка и математически наклоненных):</target>
        </trans-unit>
        <trans-unit id="bd8de4fded13757eff562bd4d021d4c7fa85a974" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do your check for class equality before checking member equality, and I think both are useful in the right circumstances.</source>
          <target state="translated">Есть пара способов проверить классовое равенство перед проверкой членского состава,и я думаю,что оба они полезны при правильных обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="50aaa6f26406d17bbdd71f58caccfc4f9979e795" translate="yes" xml:space="preserve">
          <source>There are some issues worth noticing if you're dealing with classes that are persisted using an Object-Relationship Mapper (ORM) like Hibernate, if you didn't think this was unreasonably complicated already!</source>
          <target state="translated">Есть некоторые проблемы,на которые стоит обратить внимание,если вы имеете дело с классами,которые сохраняются с помощью Object-Relationship Mapper (ORM)вроде Hibernate,если вы не думали,что это уже неразумно сложно!</target>
        </trans-unit>
        <trans-unit id="69d711e49f79cabb0e9cc44e4606a1763d31519d" translate="yes" xml:space="preserve">
          <source>There are two methods in super class as java.lang.Object. We need to override them to custom object.</source>
          <target state="translated">В суперклассе есть два метода как java.lang.Object.Нам нужно переопределить их на пользовательский объект.</target>
        </trans-unit>
        <trans-unit id="2a710bd29adb9290c00bbe7e48301371863f4b68" translate="yes" xml:space="preserve">
          <source>These sorts of things are fairly common when doing Hibernate mappings for example.</source>
          <target state="translated">Такие вещи довольно часто встречаются,например,при сопоставлении в спящем режиме.</target>
        </trans-unit>
        <trans-unit id="ba83f17eb5a6602129a7a4f14a4268637521e6dc" translate="yes" xml:space="preserve">
          <source>This is another example,
&lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</source>
          <target state="translated">Это еще один пример, &lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bf5ac0cdd28ee7b36aff2c63722f286ac508b17" translate="yes" xml:space="preserve">
          <source>This looks all very good, but look what happens if we try to use both classes:</source>
          <target state="translated">Все это выглядит очень хорошо,но посмотрите,что произойдет,если мы попробуем использовать оба класса:</target>
        </trans-unit>
        <trans-unit id="7c9abc37f86cb000f84106519fa519800f0ae298" translate="yes" xml:space="preserve">
          <source>This statement is the result of &lt;code&gt;equals()&lt;/code&gt; being inheritance unfriendly. The JLS (Java language specification) specifies that if &lt;code&gt;A.equals(B) == true&lt;/code&gt; then &lt;code&gt;B.equals(A)&lt;/code&gt; must also return &lt;code&gt;true&lt;/code&gt;. If you omit that statement inheriting classes that override &lt;code&gt;equals()&lt;/code&gt; (and change its behavior) will break this specification.</source>
          <target state="translated">Это утверждение является результатом &lt;code&gt;equals()&lt;/code&gt; недружелюбного наследования. JLS (спецификация языка Java) указывает, что если &lt;code&gt;A.equals(B) == true&lt;/code&gt; то &lt;code&gt;B.equals(A)&lt;/code&gt; также должен возвращать &lt;code&gt;true&lt;/code&gt; . Если вы пропустите этот оператор, наследуя классы, которые переопределяют &lt;code&gt;equals()&lt;/code&gt; (и измените его поведение), это нарушит эту спецификацию.</target>
        </trans-unit>
        <trans-unit id="8d8057b34bb99a355b34d0844f873952e99075d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30d3721bcf2fd63752954949b7f62b79546fe86" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;instanceof&lt;/code&gt; operator.</source>
          <target state="translated">Используйте оператор &lt;code&gt;instanceof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0995e6a2763ac6d3b2e19a4bfb99a7c9d23b580c" translate="yes" xml:space="preserve">
          <source>Use the excellent helper classes &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; from the &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; library. An example:</source>
          <target state="translated">Используйте отличные вспомогательные классы &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; и &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; из библиотеки &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="0b00259f707253247792f28e940445bdf7e58a8b" translate="yes" xml:space="preserve">
          <source>Use the same set of fields that you use to compute &lt;code&gt;equals()&lt;/code&gt; to compute &lt;code&gt;hashCode()&lt;/code&gt;.</source>
          <target state="translated">Используйте тот же набор полей, который вы используете для вычисления &lt;code&gt;equals()&lt;/code&gt; для вычисления &lt;code&gt;hashCode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99584a09a17d85e0f9f5d2d3ae48353752b8b362" translate="yes" xml:space="preserve">
          <source>What issues / pitfalls must be considered when overriding &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;?</source>
          <target state="translated">Какие проблемы / ловушки нужно учитывать при переопределении &lt;code&gt;equals&lt;/code&gt; и &lt;code&gt;hashCode&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="79ea937511f4975749deb53d859a2fd8fbdad4d4" translate="yes" xml:space="preserve">
          <source>What issues should be considered when overriding equals and hashCode in Java</source>
          <target state="translated">На какие вопросы следует обращать внимание,если в Java-версии равны и имеют хэш-код.</target>
        </trans-unit>
        <trans-unit id="e19c974a30c9bf4c69bca42a0d41ab8839e6f676" translate="yes" xml:space="preserve">
          <source>When using a hash-based &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; such as &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt;, or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt;, make sure that the hashCode() of the key objects that you put into the collection never changes while the object is in the collection. The bulletproof way to ensure this is to make your keys immutable, &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;which has also other benefits&lt;/a&gt;.</source>
          <target state="translated">При использовании &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;коллекции&lt;/a&gt; или &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;карты на&lt;/a&gt; основе хеша, таких как &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; , &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt; или &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt; , убедитесь, что hashCode () ключевых объектов, которые вы помещаете в коллекцию, никогда не изменяется, пока объект находится в коллекции. Пуленепробиваемый способ обеспечить это - сделать ваши ключи неизменяемыми, &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;что имеет и другие преимущества&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43884696debd7a85de030b8b5a1a412e31c22fbe" translate="yes" xml:space="preserve">
          <source>Where, if &lt;code&gt;a&lt;/code&gt; is not a reference of &lt;code&gt;B&lt;/code&gt;, then it might be a be a reference of class &lt;code&gt;A&lt;/code&gt; (because you extend it), in this case you call &lt;code&gt;super.equals()&lt;/code&gt;&lt;strong&gt;too&lt;/strong&gt;.</source>
          <target state="translated">Где, если &lt;code&gt;a&lt;/code&gt; не является ссылкой на &lt;code&gt;B&lt;/code&gt; , то это может быть ссылка на класс &lt;code&gt;A&lt;/code&gt; (потому что вы расширяете его), в этом случае вы также вызываете &lt;code&gt;super.equals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a6a8e83c94551b351ee98cb4b41c601c395eccd" translate="yes" xml:space="preserve">
          <source>Which will output:</source>
          <target state="translated">Который приведет к результату:</target>
        </trans-unit>
        <trans-unit id="421d84666068bc80bff12dbe67ae6a6e7b85cee2" translate="yes" xml:space="preserve">
          <source>as int value of 10 is always equal to 10. But this equals() method is about equality of two objects. When we say object, it will have properties. To decide about equality those properties are considered. It is not necessary that all properties must be taken into account to determine the equality and with respect to the class definition and context it can be decided. Then the equals() method can be overridden.</source>
          <target state="translated">так как значение int 10 всегда равно 10.Но метод equals()равен двум объектам.Когда мы говорим объект,он будет иметь свойства.Для принятия решения о равенстве учитываются эти свойства.Не обязательно,чтобы для определения равенства учитывались все свойства,а с учетом определения класса и контекста его можно решить.Тогда можно переопределить метод equals().</target>
        </trans-unit>
        <trans-unit id="8739389b6ffea0ddb7c0f395adb0b7ca53613654" translate="yes" xml:space="preserve">
          <source>equals() method is used to determine the equality of two objects.</source>
          <target state="translated">метод equals()используется для определения равенства двух объектов.</target>
        </trans-unit>
        <trans-unit id="6cbedcc10dbb92919101264b42789bfd9475d7da" translate="yes" xml:space="preserve">
          <source>we should always override hashCode() method whenever we override equals() method. If not, what will happen? If we use hashtables in our application, it will not behave as expected. As the hashCode is used in determining the equality of values stored, it will not return the right corresponding value for a key.</source>
          <target state="translated">мы всегда должны переопределять метод hashCode()всякий раз,когда мы переопределяем метод equals().Если нет,что произойдет? Если мы используем хэш-таблицы в нашем приложении,он будет вести себя не так,как ожидалось.Так как метод hashCode используется для определения равенства хранимых значений,он не вернет правильное соответствующее значение для ключа.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
