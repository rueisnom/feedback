<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/27581">
    <body>
      <group id="27581">
        <trans-unit id="f62941d18c07c2767c9aca935f7eefec2dc77803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &amp;rArr; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.getClass().equals(b.getClass()) &amp;amp;&amp;amp; a.equals(b)&lt;/code&gt; &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22930a9e5f455ca30ff8f6af54e4c0c72690ea3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equals()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt;) must define an equivalence relation (it must be &lt;em&gt;reflexive&lt;/em&gt;, &lt;em&gt;symmetric&lt;/em&gt;, and &lt;em&gt;transitive&lt;/em&gt;). In addition, it must be &lt;em&gt;consistent&lt;/em&gt; (if the objects are not modified, then it must keep returning the same value). Furthermore, &lt;code&gt;o.equals(null)&lt;/code&gt; must always return false.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; （ &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)&quot;&gt;javadoc&lt;/a&gt; ）は同値関係を定義する必要があります（ &lt;em&gt;再帰的&lt;/em&gt; 、 &lt;em&gt;対称的&lt;/em&gt; 、および&lt;em&gt;推移&lt;/em&gt; &lt;em&gt;的&lt;/em&gt;でなければなりません）。 さらに、 &lt;em&gt;一貫性が&lt;/em&gt;なければなりません（オブジェクトが変更されない場合、同じ値を返し続ける必要があります）。 さらに、 &lt;code&gt;o.equals(null)&lt;/code&gt; は常にfalseを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="09d759af345e9f8fc9cbd37acbd9f09a7c5c1bb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hashCode()&lt;/code&gt; (&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt;) must also be &lt;em&gt;consistent&lt;/em&gt; (if the object is not modified in terms of &lt;code&gt;equals()&lt;/code&gt;, it must keep returning the same value).</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; （ &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()&quot;&gt;javadoc&lt;/a&gt; ）も&lt;em&gt;一貫している&lt;/em&gt;必要があります（オブジェクトが &lt;code&gt;equals()&lt;/code&gt; に関して変更されていない場合は、同じ値を返し続ける必要があります）。</target>
        </trans-unit>
        <trans-unit id="f41e0d94b82c1244acfb38f6d85fd02451fdf588" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;hashCode()&lt;/code&gt; should use the non-changing subset of properties from &lt;code&gt;equals()&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;hashCode()&lt;/code&gt; は、 &lt;code&gt;equals()&lt;/code&gt; の変更されないプロパティのサブセットを使用する必要があります&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e513d55f8afc9df2979625f0240690bceadb1f9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, make sure to always use getters, and never field references in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ORMを処理する場合は、常にゲッターを使用し、 &lt;code&gt;hashCode()&lt;/code&gt; および &lt;code&gt;equals()&lt;/code&gt; でフィールド参照を使用しないようにしてください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bfc4b9d4bb3b068f6f1690ffa035879735ef0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you're dealing with an ORM, using &lt;code&gt;o instanceof Person&lt;/code&gt; is the only thing that will behave correctly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ORMを処理している &lt;code&gt;o instanceof Person&lt;/code&gt; は、 o instanceof Personの使用のみが正しく動作します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5bb03d5ecac5303318cbc14a70e6135b46c649ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever &lt;code&gt;a.equals(b)&lt;/code&gt;, then &lt;code&gt;a.hashCode()&lt;/code&gt; must be same as &lt;code&gt;b.hashCode()&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;a.equals(b)&lt;/code&gt; の場合は &lt;code&gt;a.hashCode()&lt;/code&gt; 、 a.hashCode（）はb.hashCode（）と同じでなければなりません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fba4a5bb0e819dded5facb835f31f90454fed74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects are subclasses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;遅延読み込みされたオブジェクトはサブクラスです&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5416b666233e493bf1163608c860bed1b45e705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazy loaded objects have null-fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;遅延読み込みされたオブジェクトにはnullフィールドがあります&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87b9966cd9c56cfca42f79b00795981cc5b96b8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Saving an object will change its state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オブジェクトを保存すると、その状態が変わります&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea919cd896a4ea6d29d672ece79624db4359bb54" translate="yes" xml:space="preserve">
          <source>A clarification about the &lt;code&gt;obj.getClass() != getClass()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj.getClass() != getClass()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6895129e381c47582a6f95e9ff2da53a7d042422" translate="yes" xml:space="preserve">
          <source>A pattern I often use is</source>
          <target state="translated">私がよく使うパターンは</target>
        </trans-unit>
        <trans-unit id="024cbca8c731c5b64edbfcc991e3b2f63e66f972" translate="yes" xml:space="preserve">
          <source>Also remember:</source>
          <target state="translated">また、覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="39075a8ee0cb791ba0482d1d3898b58397927809" translate="yes" xml:space="preserve">
          <source>But &lt;strong&gt;not&lt;/strong&gt; vice-versa!</source>
          <target state="translated">しかし&lt;strong&gt;、&lt;/strong&gt;その逆で&lt;strong&gt;はありません&lt;/strong&gt; ！</target>
        </trans-unit>
        <trans-unit id="7d1bbdf358d01354cb4828d3a9b90762d31822ec" translate="yes" xml:space="preserve">
          <source>But: you cannot include &lt;code&gt;getId()&lt;/code&gt; in &lt;code&gt;hashCode()&lt;/code&gt;. If you do, when an object is persisted, its &lt;code&gt;hashCode&lt;/code&gt; changes. If the object is in a &lt;code&gt;HashSet&lt;/code&gt;, you'll &quot;never&quot; find it again.</source>
          <target state="translated">ただし： &lt;code&gt;hashCode()&lt;/code&gt; に &lt;code&gt;getId()&lt;/code&gt; を含めることはできません。 その場合、オブジェクトが永続化されると、その &lt;code&gt;hashCode&lt;/code&gt; が変更されます。 オブジェクトが &lt;code&gt;HashSet&lt;/code&gt; 内にある場合、再び見つけることは「決してない」でしょう。</target>
        </trans-unit>
        <trans-unit id="c7c505f16d180c269b917e56b85bc20a74debb36" translate="yes" xml:space="preserve">
          <source>Consider the following example of what happens when the statement is omitted:</source>
          <target state="translated">文が省略されるとどうなるか、次の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e0824b4fba51777e4feffc1f5c2b3a206868d206" translate="yes" xml:space="preserve">
          <source>Default implementation given is hashCode() method in Object class uses the internal address of the object and converts it into integer and returns it.</source>
          <target state="translated">デフォルトの実装はObjectクラスのhashCode()メソッドで、オブジェクトの内部アドレスを使用して整数に変換して返します。</target>
        </trans-unit>
        <trans-unit id="9fe35515e27e7aa13569acd40fe243cd2f28732f" translate="yes" xml:space="preserve">
          <source>Doing &lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; Also, &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; result give out true, as it should.</source>
          <target state="translated">&lt;code&gt;new A(1).equals(new A(1))&lt;/code&gt; また、 &lt;code&gt;new B(1,1).equals(new B(1,1))&lt;/code&gt; 結果は、必要に応じてtrueになります。</target>
        </trans-unit>
        <trans-unit id="59ded4d66e030811c0cecc5c18265651f8781edb" translate="yes" xml:space="preserve">
          <source>Equal objects must produce the same hash code as long as they are equal, however unequal objects need not produce distinct hash codes.</source>
          <target state="translated">等しいオブジェクトは等しい限り同じハッシュコードを生成しなければなりませんが、不等しいオブジェクトは別個のハッシュコードを生成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="67b3b65f196732922817614de3686f24f48f5c43" translate="yes" xml:space="preserve">
          <source>Example Code Output:</source>
          <target state="translated">コード出力例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a8bd05092951921e316937eaf9f671cae2150a0c" translate="yes" xml:space="preserve">
          <source>For an inheritance-friendly implementation, check out Tal Cohen's solution, &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;How Do I Correctly Implement the equals() Method?&lt;/a&gt;</source>
          <target state="translated">継承に適した実装については、Tal Cohenのソリューション、 &lt;a href=&quot;http://www.drdobbs.com/jvm/java-qa-how-do-i-correctly-implement-th/184405053&quot;&gt;equals（）メソッドを正しく実装する方法を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="a1d70b5f678ecec38b3080112485d7acc173ba57" translate="yes" xml:space="preserve">
          <source>For equals, look into &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secrets of Equals&lt;/a&gt;&lt;/strong&gt; by &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langer&lt;/a&gt;. I love it very much. She's also a great FAQ about &lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;Generics in Java&lt;/a&gt;&lt;/strong&gt;. View her other articles &lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;here&lt;/a&gt; (scroll down to &quot;Core Java&quot;), where she also goes on with Part-2 and &quot;mixed type comparison&quot;. Have fun reading them!</source>
          <target state="translated">イコールについては、 &lt;a href=&quot;http://www.angelikalanger.com/&quot;&gt;Angelika Langerに&lt;/a&gt;よる&lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html&quot;&gt;Secrets of Equalsを&lt;/a&gt;&lt;/strong&gt;参照してください。 私はそれが大好きです。 彼女&lt;strong&gt;&lt;a href=&quot;http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html&quot;&gt;はJavaでのジェネリック&lt;/a&gt;&lt;/strong&gt;に関する素晴らしいFAQでもあり&lt;strong&gt;ます&lt;/strong&gt; 。 彼女の他の記事を&lt;a href=&quot;http://www.angelikalanger.com/Articles/Topics.html#JAVA&quot;&gt;ここに&lt;/a&gt;表示し（「コアJava」までスクロールして）、そこでパート2と「混合型の比較」も続けます。 それらを読んで楽しんでください！</target>
        </trans-unit>
        <trans-unit id="3a0c83711ad78e79ea2e6a7e1075120a2ea2f087" translate="yes" xml:space="preserve">
          <source>Have Fun! @.@</source>
          <target state="translated">楽しんできてね! @.@</target>
        </trans-unit>
        <trans-unit id="28ac6d01c3b11a1242288d16c354d1d149c86bd7" translate="yes" xml:space="preserve">
          <source>His solution is to implement equals() by calling another nonsymmetric blindlyEquals() both ways.  blindlyEquals() is overridden by subclasses, equals() is inherited, and never overridden.</source>
          <target state="translated">彼の解決策は、別の非対称な blindlyEquals()を両方の方法で呼び出すことで equals()を実装することです。 blindlyEquals()はサブクラスによってオーバーライドされ、 equals()は継承され、オーバーライドされることはありません。</target>
        </trans-unit>
        <trans-unit id="e068331a67b03e8bb4ff13910221de891b1c9497" translate="yes" xml:space="preserve">
          <source>I use #1 in a &lt;code&gt;final&lt;/code&gt; equals implementation, or when implementing an interface that prescribes an algorithm for equals (like the &lt;code&gt;java.util&lt;/code&gt; collection interfaces&amp;mdash;the right way to check with with &lt;code&gt;(obj instanceof Set)&lt;/code&gt; or whatever interface you're implementing). It's generally a bad choice when equals can be overridden because that breaks the symmetry property.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; イコールの実装で＃1を使用するか、イコールのアルゴリズムを規定するインターフェースを実装するときに（ &lt;code&gt;java.util&lt;/code&gt; コレクションインターフェースのように、 &lt;code&gt;(obj instanceof Set)&lt;/code&gt; または実装しているインターフェースで確認する正しい方法） 。 equalsがオーバーライドされる可能性がある場合、対称性のプロパティが壊れるので、一般的にこれは悪い選択です。</target>
        </trans-unit>
        <trans-unit id="c047b686130b5ac2ddd022d754531089b0f8a3ea" translate="yes" xml:space="preserve">
          <source>If you include both ends of the relationship in your hashCode or equals tests it's possible to get into a recursive loop which ends in a StackOverflowException.</source>
          <target state="translated">ハッシュコードやイコールテストにリレーションの両端を含めると、再帰的なループに陥って StackOverflowException で終わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="af0d87ad2f0fa603892e358c5f2e857b7e5b7326" translate="yes" xml:space="preserve">
          <source>If you override one, then you should override the other.</source>
          <target state="translated">片方をオーバーライドした場合は、もう片方をオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="e86f786bee221b53f9c6d6b66a3286e528acaa30" translate="yes" xml:space="preserve">
          <source>If you want get more, please check this link as &lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;</source>
          <target state="translated">さらに取得したい場合は、このリンクを&lt;a href=&quot;http://www.javaranch.com/journal/2002/10/equalhash.html&quot;&gt;http://www.javaranch.com/journal/2002/10/equalhash.html&lt;/a&gt;として確認してください。</target>
        </trans-unit>
        <trans-unit id="b11b283ab4205e58d038c48a1b4263bb016b302d" translate="yes" xml:space="preserve">
          <source>If you want to ensure the symmetric condition. a=b if b=a and the Liskov substitution principle call &lt;code&gt;super.equals(other)&lt;/code&gt; not only in the case of &lt;code&gt;B&lt;/code&gt; instance, but check after for &lt;code&gt;A&lt;/code&gt; instance:</source>
          <target state="translated">対称状態を確保したい場合。 b = aの場合はa = bであり、Liskov置換原理は &lt;code&gt;B&lt;/code&gt; インスタンスの場合だけでなく、 &lt;code&gt;A&lt;/code&gt; インスタンスの後にも確認して &lt;code&gt;super.equals(other)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="f258ed46101818db9a26a356669ab445fa34d732" translate="yes" xml:space="preserve">
          <source>If your class is also &lt;code&gt;Comparable&lt;/code&gt;, the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;compareTo&lt;/code&gt; methods should be consistent too. Here's a template for the equals method in a &lt;code&gt;Comparable&lt;/code&gt; class:</source>
          <target state="translated">クラスも &lt;code&gt;Comparable&lt;/code&gt; の場合、 &lt;code&gt;equals&lt;/code&gt; メソッドと &lt;code&gt;compareTo&lt;/code&gt; メソッドも一貫している必要があります。 以下は、 &lt;code&gt;Comparable&lt;/code&gt; クラスのequalsメソッドのテンプレートです。</target>
        </trans-unit>
        <trans-unit id="fedc3fcbdaf830c5e6d2b71eabde54346df9994d" translate="yes" xml:space="preserve">
          <source>If your objects are persisted using an ORM, in many cases you will be dealing with dynamic proxies to avoid loading object too early from the data store. These proxies are implemented as subclasses of your own class. This means that&lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;. For example:</source>
          <target state="translated">オブジェクトがORMを使用して永続化されている場合、多くの場合、動的プロキシを処理して、オブジェクトをデータストアから早くロードしすぎないようにします。 これらのプロキシは、独自のクラスのサブクラスとして実装されます。 つまり、 &lt;code&gt;this.getClass() == o.getClass()&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; を返します 。 例えば：</target>
        </trans-unit>
        <trans-unit id="897ebe0396bd9c0c657be610c7aeeb790710f6ac" translate="yes" xml:space="preserve">
          <source>In his book &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; (Addison-Wesley, 2001), Joshua Bloch claims that &quot;There is simply no way to extend an instantiable class and add an aspect while preserving the equals contract.&quot;  Tal disagrees.</source>
          <target state="translated">Joshua Blochは、彼の著書「 &lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201310058&quot;&gt;Effective Java Programming Language Guide&lt;/a&gt; （Addison-Wesley、2001）」で、「インスタンス化可能なクラスを拡張してアスペクトを追加しながらアスペクトを追加する方法はない」と述べています。 タルはそう思わない。</target>
        </trans-unit>
        <trans-unit id="ad7a3fd4c935ce7834ae51563058277f54f97bde" translate="yes" xml:space="preserve">
          <source>In my &lt;code&gt;Person&lt;/code&gt; example, I probably would use &lt;code&gt;getName()&lt;/code&gt; for &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;getId()&lt;/code&gt; plus &lt;code&gt;getName()&lt;/code&gt; (just for paranoia) for &lt;code&gt;equals()&lt;/code&gt;. It's okay if there are some risk of &quot;collisions&quot; for &lt;code&gt;hashCode()&lt;/code&gt;, but never okay for &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">私の &lt;code&gt;Person&lt;/code&gt; の例では、おそらく &lt;code&gt;hashCode&lt;/code&gt; に &lt;code&gt;getName()&lt;/code&gt; を使用し、 &lt;code&gt;getId()&lt;/code&gt; 加えて &lt;code&gt;getName()&lt;/code&gt; （パラノイアのみ &lt;code&gt;equals()&lt;/code&gt; ます。 &lt;code&gt;hashCode()&lt;/code&gt; に「衝突」のリスクがある場合は問題ありませんが、 &lt;code&gt;equals()&lt;/code&gt; は問題ありません。</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">実践では</target>
        </trans-unit>
        <trans-unit id="0056a4f499f49f25d8e6d30cf07c16396cec89b6" translate="yes" xml:space="preserve">
          <source>Logically we have:</source>
          <target state="translated">論理的にはあります。</target>
        </trans-unit>
        <trans-unit id="8b0458d416c6aa631736525627993e3207809598" translate="yes" xml:space="preserve">
          <source>Note that equals() must work across inheritance hierarchies if the &lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov Substitution Principle&lt;/a&gt; is to be satisfied.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Liskov_substitution_principle&quot;&gt;Liskov置換原則&lt;/a&gt;が満たされる場合、equals（）は継承階層全体で機能する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="64751fa16b61e77aab739d5f48f9057d95bc8bda" translate="yes" xml:space="preserve">
          <source>ORMs usually use the getters to force loading of lazy loaded objects. This means that &lt;code&gt;person.name&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;person&lt;/code&gt; is lazy loaded, even if &lt;code&gt;person.getName()&lt;/code&gt; forces loading and returns &quot;John Doe&quot;. In my experience, this crops up more often in &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">ORMは通常、遅延読み込みオブジェクトを強制的に読み込むためにゲッターを使用します。 つまり、 &lt;code&gt;person.name&lt;/code&gt; &lt;code&gt;person.getName()&lt;/code&gt; 強制的にロードして「John Doe」を返したとしても、 &lt;code&gt;person&lt;/code&gt; が遅延ロードされている場合、 person.nameは &lt;code&gt;null&lt;/code&gt; になります 。 私の経験では、これは &lt;code&gt;hashCode()&lt;/code&gt; と &lt;code&gt;equals()&lt;/code&gt; で頻繁に発生します。</target>
        </trans-unit>
        <trans-unit id="e55ddccff6f2168523d83cfed3055eb78cc02d47" translate="yes" xml:space="preserve">
          <source>Obviously, this is wrong.</source>
          <target state="translated">明らかに間違っている。</target>
        </trans-unit>
        <trans-unit id="d9acc2aebc5911d699b1cfca78287f2872811476" translate="yes" xml:space="preserve">
          <source>One gotcha I have found is where two objects contain references to each other (one example being a parent/child relationship with a convenience method on the parent to get all children).</source>
          <target state="translated">私が見つけた1つのゲッタは、2つのオブジェクトがお互いへの参照を含む場合です(1つの例は、すべての子を取得するための親の便利なメソッドを持つ親と子の関係です)。</target>
        </trans-unit>
        <trans-unit id="582f11dd91a22a0cb84bffe58835664e4a71997c" translate="yes" xml:space="preserve">
          <source>Option #2 allows the class to be safely extended without overriding equals or breaking symmetry.</source>
          <target state="translated">オプション#2では、等号をオーバーライドしたり対称性を崩さずに安全にクラスを拡張することができます。</target>
        </trans-unit>
        <trans-unit id="3ccabf9026a63683181043461c7eab59eedbb945" translate="yes" xml:space="preserve">
          <source>Persistent objects often use a &lt;code&gt;id&lt;/code&gt; field to hold the key of the object. This field will be automatically updated when an object is first saved. Don't use an id field in &lt;code&gt;hashCode()&lt;/code&gt;. But you can use it in &lt;code&gt;equals()&lt;/code&gt;.</source>
          <target state="translated">多くの場合、永続オブジェクトは &lt;code&gt;id&lt;/code&gt; フィールドを使用してオブジェクトのキーを保持します。 このフィールドは、オブジェクトが最初に保存されるときに自動的に更新されます。 &lt;code&gt;hashCode()&lt;/code&gt; でidフィールドを使用しないでください。 しかし、それは &lt;code&gt;equals()&lt;/code&gt; で使用できます。</target>
        </trans-unit>
        <trans-unit id="412e4422ca7b5954610c57f820c03e025a5e4807" translate="yes" xml:space="preserve">
          <source>Still amazed that none recommended the guava library for this.</source>
          <target state="translated">まだ誰もこのためにグァバのライブラリを推奨していないことに驚いています。</target>
        </trans-unit>
        <trans-unit id="6ed816d75e1c95434823496141b81fdcea2cbda9" translate="yes" xml:space="preserve">
          <source>Summary:</source>
          <target state="translated">Summary:</target>
        </trans-unit>
        <trans-unit id="2dd1ac43cd73c07de447dcf4d3ab834a73b813db" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;relation&lt;/strong&gt; between the two methods is:</source>
          <target state="translated">2つの方法の&lt;strong&gt;関係&lt;/strong&gt;は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5f7ba8efb1b467a2d1d7ddc6e6ab2aa6615e546c" translate="yes" xml:space="preserve">
          <source>The simplest solution is to not include the getChildren collection in the methods.</source>
          <target state="translated">最も単純な解決策は、メソッドにgetChildrenコレクションを含まないことです。</target>
        </trans-unit>
        <trans-unit id="f4e16ff4a047ab502e99233c3f9c9aa1da0e7e09" translate="yes" xml:space="preserve">
          <source>The theory (for the language lawyers and the mathematically inclined):</source>
          <target state="translated">理論(言語法学者と数学的に考える人のための)です。</target>
        </trans-unit>
        <trans-unit id="bd8de4fded13757eff562bd4d021d4c7fa85a974" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do your check for class equality before checking member equality, and I think both are useful in the right circumstances.</source>
          <target state="translated">メンバーの平等性をチェックする前にクラスの平等性をチェックする方法はいくつかありますが、どちらも状況に応じて有効な方法だと思います。</target>
        </trans-unit>
        <trans-unit id="50aaa6f26406d17bbdd71f58caccfc4f9979e795" translate="yes" xml:space="preserve">
          <source>There are some issues worth noticing if you're dealing with classes that are persisted using an Object-Relationship Mapper (ORM) like Hibernate, if you didn't think this was unreasonably complicated already!</source>
          <target state="translated">Hibernate のような ORM (Object-Relationship Mapper)を使って永続化されたクラスを扱っている場合、これはもう理不尽に複雑だと思わなかったのであれば、注意する価値のある問題がいくつかあります!</target>
        </trans-unit>
        <trans-unit id="69d711e49f79cabb0e9cc44e4606a1763d31519d" translate="yes" xml:space="preserve">
          <source>There are two methods in super class as java.lang.Object. We need to override them to custom object.</source>
          <target state="translated">スーパークラスにはjava.lang.Objectとして2つのメソッドがあります。これらをカスタムオブジェクトにオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="2a710bd29adb9290c00bbe7e48301371863f4b68" translate="yes" xml:space="preserve">
          <source>These sorts of things are fairly common when doing Hibernate mappings for example.</source>
          <target state="translated">この種のことは、例えばHibernateのマッピングを行うときにはかなり一般的です。</target>
        </trans-unit>
        <trans-unit id="ba83f17eb5a6602129a7a4f14a4268637521e6dc" translate="yes" xml:space="preserve">
          <source>This is another example,
&lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</source>
          <target state="translated">これは別の例です&lt;a href=&quot;http://java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&quot;&gt;。http：//java67.blogspot.com/2013/04/example-of-overriding-equals-hashcode-compareTo-java-method.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1bf5ac0cdd28ee7b36aff2c63722f286ac508b17" translate="yes" xml:space="preserve">
          <source>This looks all very good, but look what happens if we try to use both classes:</source>
          <target state="translated">これはとても良さそうに見えますが、両方のクラスを使おうとするとどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="7c9abc37f86cb000f84106519fa519800f0ae298" translate="yes" xml:space="preserve">
          <source>This statement is the result of &lt;code&gt;equals()&lt;/code&gt; being inheritance unfriendly. The JLS (Java language specification) specifies that if &lt;code&gt;A.equals(B) == true&lt;/code&gt; then &lt;code&gt;B.equals(A)&lt;/code&gt; must also return &lt;code&gt;true&lt;/code&gt;. If you omit that statement inheriting classes that override &lt;code&gt;equals()&lt;/code&gt; (and change its behavior) will break this specification.</source>
          <target state="translated">このステートメントは、 &lt;code&gt;equals()&lt;/code&gt; が継承に不適切である結果です。 JLS（Java言語仕様）は、 &lt;code&gt;A.equals(B) == true&lt;/code&gt; 、 &lt;code&gt;B.equals(A)&lt;/code&gt; も &lt;code&gt;true&lt;/code&gt; を返す必要があることを指定しています 。 &lt;code&gt;equals()&lt;/code&gt; をオーバーライドするクラスを継承するステートメントを省略した場合（およびその動作を変更した場合）は、この仕様に違反します。</target>
        </trans-unit>
        <trans-unit id="8d8057b34bb99a355b34d0844f873952e99075d9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this.getClass().equals(that.getClass())&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e30d3721bcf2fd63752954949b7f62b79546fe86" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;instanceof&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 演算子を使用します 。</target>
        </trans-unit>
        <trans-unit id="0995e6a2763ac6d3b2e19a4bfb99a7c9d23b580c" translate="yes" xml:space="preserve">
          <source>Use the excellent helper classes &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt; and &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt; from the &lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt; library. An example:</source>
          <target state="translated">&lt;a href=&quot;http://commons.apache.org/lang/&quot;&gt;Apache Commons Lang&lt;/a&gt;ライブラリーの優れたヘルパークラスである&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html&quot;&gt;EqualsBuilder&lt;/a&gt;および&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html&quot;&gt;HashCodeBuilder&lt;/a&gt;を使用してください。 例：</target>
        </trans-unit>
        <trans-unit id="0b00259f707253247792f28e940445bdf7e58a8b" translate="yes" xml:space="preserve">
          <source>Use the same set of fields that you use to compute &lt;code&gt;equals()&lt;/code&gt; to compute &lt;code&gt;hashCode()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; の計算に使用するのと同じフィールドのセットを使用して、 &lt;code&gt;hashCode()&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="99584a09a17d85e0f9f5d2d3ae48353752b8b362" translate="yes" xml:space="preserve">
          <source>What issues / pitfalls must be considered when overriding &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; と &lt;code&gt;hashCode&lt;/code&gt; オーバーライドするときに考慮しなければならない問題/落とし穴は何ですか？</target>
        </trans-unit>
        <trans-unit id="79ea937511f4975749deb53d859a2fd8fbdad4d4" translate="yes" xml:space="preserve">
          <source>What issues should be considered when overriding equals and hashCode in Java</source>
          <target state="translated">Javaで等号やhashCodeをオーバーライドする際に考慮すべき問題点は?</target>
        </trans-unit>
        <trans-unit id="e19c974a30c9bf4c69bca42a0d41ab8839e6f676" translate="yes" xml:space="preserve">
          <source>When using a hash-based &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; such as &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt;, &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt;, or &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt;, make sure that the hashCode() of the key objects that you put into the collection never changes while the object is in the collection. The bulletproof way to ensure this is to make your keys immutable, &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;which has also other benefits&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashSet.html&quot;&gt;HashSet&lt;/a&gt; 、 &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/LinkedHashSet.html&quot;&gt;LinkedHashSet&lt;/a&gt; 、 &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/HashMap.html&quot;&gt;HashMap&lt;/a&gt; 、 &lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Hashtable.html&quot;&gt;Hashtable&lt;/a&gt; 、または&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/WeakHashMap.html&quot;&gt;WeakHashMap&lt;/a&gt;などのハッシュベースの&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Collection.html&quot;&gt;コレクション&lt;/a&gt;または&lt;a href=&quot;http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html&quot;&gt;マップ&lt;/a&gt;を使用する場合は、オブジェクトがコレクション内にある間、コレクションに入れたキーオブジェクトのhashCode（）が変更されないようにしてください。 これを確実にする完全な方法は、キーを不変に&lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=29&quot;&gt;すること&lt;/a&gt;です。 これには他の利点もあります 。</target>
        </trans-unit>
        <trans-unit id="43884696debd7a85de030b8b5a1a412e31c22fbe" translate="yes" xml:space="preserve">
          <source>Where, if &lt;code&gt;a&lt;/code&gt; is not a reference of &lt;code&gt;B&lt;/code&gt;, then it might be a be a reference of class &lt;code&gt;A&lt;/code&gt; (because you extend it), in this case you call &lt;code&gt;super.equals()&lt;/code&gt;&lt;strong&gt;too&lt;/strong&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;B&lt;/code&gt; の参照でない場合、それはクラス &lt;code&gt;A&lt;/code&gt; の参照である可能性があります（それを拡張するため）。この場合、 &lt;code&gt;super.equals()&lt;/code&gt; &lt;strong&gt;も&lt;/strong&gt;呼び出し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a6a8e83c94551b351ee98cb4b41c601c395eccd" translate="yes" xml:space="preserve">
          <source>Which will output:</source>
          <target state="translated">どちらが出力されるか。</target>
        </trans-unit>
        <trans-unit id="421d84666068bc80bff12dbe67ae6a6e7b85cee2" translate="yes" xml:space="preserve">
          <source>as int value of 10 is always equal to 10. But this equals() method is about equality of two objects. When we say object, it will have properties. To decide about equality those properties are considered. It is not necessary that all properties must be taken into account to determine the equality and with respect to the class definition and context it can be decided. Then the equals() method can be overridden.</source>
          <target state="translated">のように、int の値が 10 の場合は常に 10 と等しくなります。しかし、このequals()メソッドは2つのオブジェクトを等しくすることを目的としています。オブジェクトと言えばプロパティを持っています。等しいかどうかを決めるには、それらのプロパティを考慮します。全てのプロパティを考慮して等しさを決める必要はなく、クラスの定義や文脈を考慮して決めることができます。そうすれば、equals()メソッドをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="8739389b6ffea0ddb7c0f395adb0b7ca53613654" translate="yes" xml:space="preserve">
          <source>equals() method is used to determine the equality of two objects.</source>
          <target state="translated">equals()メソッドは、2つのオブジェクトの等しさを決定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="6cbedcc10dbb92919101264b42789bfd9475d7da" translate="yes" xml:space="preserve">
          <source>we should always override hashCode() method whenever we override equals() method. If not, what will happen? If we use hashtables in our application, it will not behave as expected. As the hashCode is used in determining the equality of values stored, it will not return the right corresponding value for a key.</source>
          <target state="translated">equals()メソッドをオーバーライドするときは必ずhashCode()メソッドをオーバーライドすべきです。そうしないと、何が起こるでしょうか?アプリケーションでハッシュテーブルを使用すると、期待通りの動作をしません。ハッシュコードは格納されている値の等しさを決定するために使用されるので、キーに対して正しい対応する値を返すことはありません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
