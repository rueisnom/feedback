<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2785485">
    <body>
      <group id="2785485">
        <trans-unit id="b181b1b9d0c086707ac87cdae3439b4b938c3820" translate="yes" xml:space="preserve">
          <source>(Extra info: The technique given above was copied from an article on &lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;Pocket Magic&lt;/a&gt;.)</source>
          <target state="translated">(추가 정보 : 위에 제공된 기술은 &lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;Pocket Magic&lt;/a&gt; 의 기사에서 복사 한 것입니다.)</target>
        </trans-unit>
        <trans-unit id="f46132bef288a5dfab4aa74662227d9af6352df6" translate="yes" xml:space="preserve">
          <source>- Guarantee uniqueness (include rooted devices) for API &amp;gt;= 9/10 (99.5% of Android devices)</source>
          <target state="translated">-API&amp;gt; = 9/10 (Android 기기의 99.5 %)에 대한 고유성 보장 (루팅 된 기기 포함)</target>
        </trans-unit>
        <trans-unit id="64a8a656b27e5414def3b68719d22dbd0722b3fe" translate="yes" xml:space="preserve">
          <source>- No extra permissions</source>
          <target state="translated">-추가 권한이 없습니다</target>
        </trans-unit>
        <trans-unit id="3dbcc62d78a806b5dd67ba63ab7e0076a5dee116" translate="yes" xml:space="preserve">
          <source>3 IDs are:</source>
          <target state="translated">3 개의 ID는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24308b13f274d9b2b66681dadbb1969845233a3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.android.com/google/play-services/id.html&quot;&gt;http://developer.android.com/google/play-services/id.html&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&quot;&gt;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/google/play-services/id.html&quot;&gt;http://developer.android.com/google/play-services/id.html&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&quot;&gt;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aad57647718e1189a9ca068c1268dc9b89e9426f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt;&lt;code&gt;Settings.Secure#ANDROID_ID&lt;/code&gt;&lt;/a&gt; returns the Android ID as an &lt;em&gt;&lt;a href=&quot;https://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt;unique for each user&lt;/a&gt;&lt;/em&gt; 64-bit hex string.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt; &lt;code&gt;Settings.Secure#ANDROID_ID&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;&lt;a href=&quot;https://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt;각 사용자&lt;/a&gt;&lt;/em&gt; 64 비트 16 진 문자열 &lt;em&gt;에 대해 고유 한&lt;/em&gt; Android ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e220c504ed1a53f66958d05ced7b441afe39b2ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANDROID_ID&lt;/code&gt; seems a good choice for a unique device identifier. There are downsides: First, it is not 100% reliable on releases of Android prior to 2.2 &lt;code&gt;(&amp;ldquo;Froyo&amp;rdquo;).&lt;/code&gt; Also, there has been at least one widely-observed bug in a popular handset from a major manufacturer, where every instance has the same ANDROID_ID.</source>
          <target state="translated">&lt;code&gt;ANDROID_ID&lt;/code&gt; 는 고유 한 기기 식별자에 적합합니다. 단점 : 첫째, 2.2 이전 버전의 Android &lt;code&gt;(&amp;ldquo;Froyo&amp;rdquo;).&lt;/code&gt; 에서는 100 % 신뢰할 수 없습니다 . 또한 모든 제조업체의 ANDROID_ID가 동일한 주요 제조업체의 인기있는 핸드셋에서 하나 이상의 광범위하게 발견 된 버그가있었습니다.</target>
        </trans-unit>
        <trans-unit id="2a7ecef876d978aff21a723a463c8cce70f74986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ANDROID_ID&lt;/strong&gt; - &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;ANDROID_ID-&lt;/strong&gt; &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; &lt;strong&gt;.ANDROID_ID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea50d53bb38b142bacc83d97cb9a3172bd16f9e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android ID - Hardware&lt;/strong&gt; (can be null, can change upon factory reset, can be altered on a rooted device)</source>
          <target state="translated">&lt;strong&gt;Android ID-하드웨어&lt;/strong&gt; (null 일 수 있음, 초기화시 변경 가능, 루팅 된 기기에서 변경 가능)</target>
        </trans-unit>
        <trans-unit id="8db07429bf3578e05973ce8664b1a9bb4287d884" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android ID&lt;/strong&gt; (can be null, can change upon factory reset, can be altered on rooted phone)</source>
          <target state="translated">&lt;strong&gt;Android ID&lt;/strong&gt; (null 일 수 있음, 초기화시 변경 가능, 루팅 된 전화에서 변경 가능)</target>
        </trans-unit>
        <trans-unit id="b44abe0e3872a3ddf088098375b5b0ae4112d430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid using hardware identifiers&lt;/strong&gt;, such as SSAID (Android ID), IMEI, MAC address, etc...</source>
          <target state="translated">SSAID (Android ID), IMEI, MAC 주소 등과 같은 &lt;strong&gt;하드웨어 식별자를 사용하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c8d538e3ef150d20979c342b78b601121605b217" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BT MAC Address&lt;/strong&gt; string (devices with Bluetooth, needs &lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;BT MAC 주소&lt;/strong&gt; 문자열 (블루투스가있는 기기, &lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt; 필요)</target>
        </trans-unit>
        <trans-unit id="bafd04e528102e85d4eeba4b49e7e6ebeeec8fb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practices for unique identifiers:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;고유 식별자에 대한 모범 사례 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecd8905c7608c04bb17e1494f7f8edfc6c13ec35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bluetooth Address&lt;/strong&gt; - Bluetooth adapter address</source>
          <target state="translated">&lt;strong&gt;블루투스 주소&lt;/strong&gt; -블루투스 어댑터 주소</target>
        </trans-unit>
        <trans-unit id="45d48748303dd882fbebc79403ba709067aa415c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bluetooth MAC Address - Hardware&lt;/strong&gt; (devices with Bluetooth, needs &lt;strong&gt;&lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;블루투스 MAC 주소-하드웨어&lt;/strong&gt; (블루투스가있는 기기, &lt;strong&gt; &lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt; &lt;/strong&gt; 필요)</target>
        </trans-unit>
        <trans-unit id="411c38caf68a6ed824124e24cd4675443673ecf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From the Google Play Developer's console:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Google Play 개발자 콘솔에서 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="957809252710cee9969716976cc2c3db8defd64a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Google Instance ID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Google 인스턴스 ID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab8e6abb67f419400f610c6784d884532f8e22fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMEI - Hardware&lt;/strong&gt; (only phones, needs &lt;strong&gt;&lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;IMEI-하드웨어&lt;/strong&gt; (휴대 전화 만, &lt;strong&gt; &lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt; &lt;/strong&gt; 필요)</target>
        </trans-unit>
        <trans-unit id="ade3c7f4182c7dcfa5ef96877cdd5eaca6556b53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMEI&lt;/strong&gt; (only for Android devices with Phone use; needs &lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;IMEI&lt;/strong&gt; (전화를 사용하는 Android 기기에만 해당, &lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt; 필요)</target>
        </trans-unit>
        <trans-unit id="f83425a65c1c8ba0f03466a55d7707c4f2fa69f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="962b31d714025ad16d50eaddcc6f19a63d8d2d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; From Android 6.x, it returns consistent fake mac address: &lt;code&gt;02:00:00:00:00:00&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Android 6.x에서 일관된 가짜 맥 주소를 반환합니다 : &lt;code&gt;02:00:00:00:00:00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba920baef2e1d3c3aa47f6f7d2ad1446698b61b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only use an Advertising ID for user profiling or ads use cases&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용자 프로파일 링 또는 광고 사용 사례에만 광고 ID를 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d109d7d27f4b7602674fb5784993cbe1455bc34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudo-ID&lt;/strong&gt; - It is generated based on physical device specifications</source>
          <target state="translated">&lt;strong&gt;의사 ID-&lt;/strong&gt; 실제 장치 사양을 기반으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="815a9883ed04b839e75540b14a9029833584eabe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudo-Unique ID - Software&lt;/strong&gt; (for all Android devices)</source>
          <target state="translated">&lt;strong&gt;의사 고유 ID-소프트웨어&lt;/strong&gt; (모든 Android 장치 용)</target>
        </trans-unit>
        <trans-unit id="562a2ba67fe226b4583a2412fbc3121061de8f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudo-Unique ID&lt;/strong&gt; (for all Android devices)</source>
          <target state="translated">&lt;strong&gt;의사 고유 ID&lt;/strong&gt; (모든 Android 장치 용)</target>
        </trans-unit>
        <trans-unit id="3fd7c31e3b7b82748b721e9ea087cfb28bb8a87c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REMEMBER&lt;/strong&gt;, you are technically only missing out on around 0.5% of users &lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;who have API &amp;lt; 9&lt;/a&gt;. So you can focus on the rest: This is 99.5% of the users!</source>
          <target state="translated">&lt;strong&gt;기억하십시오&lt;/strong&gt; , &lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;API &amp;lt;9&lt;/a&gt; 인 사용자의 약 0.5 %만이 기술적으로 누락 된 것입니다. 따라서 나머지 부분에 집중할 수 있습니다. 사용자의 99.5 %입니다.</target>
        </trans-unit>
        <trans-unit id="1f5e9d463b8f8c18af8677bb343915a7bfe86673" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Settings.Secure.ANDROID_ID&lt;/strong&gt; that returns the Android ID as an unique 64-bit hex string.</source>
          <target state="translated">Android ID를 고유 한 64 비트 16 진수 문자열로 반환하는 &lt;strong&gt;Settings.Secure.ANDROID_ID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80eef0df3a09d650af671812b11c019ca7ae0159" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source/Docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Source/Docs:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15790c02e5af662271cb875986ccd5a65911222a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TelephonyManger.getDeviceId()&lt;/strong&gt; Returns the unique device ID, for example, the IMEI for GSM and the MEID or ESN for CDMA phones.</source>
          <target state="translated">&lt;strong&gt;TelephonyManger.getDeviceId ()&lt;/strong&gt; 고유 장치 ID (예 : GSM의 경우 IMEI, CDMA 전화의 경우 MEID 또는 ESN &lt;strong&gt;)를&lt;/strong&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa2405819ce2f56f35d257d203c19d30a9159b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The advantages of instance ID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인스턴스 ID의 장점&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d042742c0ce55d371e0baed1452d826e2d0af521" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages/issues&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;단점 / 문제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f7e9b35e6804a6b024cdee61b803053446c2cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: As of recent versions of Android, many of the issues with &lt;code&gt;ANDROID_ID&lt;/code&gt; have been resolved, and I believe this approach is no longer necessary. Please take a look at &lt;a href=&quot;https://stackoverflow.com/a/2785493/231078&quot;&gt;Anthony's answer&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;업데이트&lt;/strong&gt; : 최신 버전의 Android에서 &lt;code&gt;ANDROID_ID&lt;/code&gt; 와 관련된 많은 문제가 해결되었으며 더 이상이 접근법이 필요하지 않다고 생각합니다. &lt;a href=&quot;https://stackoverflow.com/a/2785493/231078&quot;&gt;Anthony의 답변을&lt;/a&gt; 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="18d0b195c6490ecf8258b68c44ba7edb801668ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use a FirebaseInstanceId or a privately stored GUID&lt;/strong&gt; whenever possible for all other use cases, except for payment fraud prevention and telephony.</source>
          <target state="translated">지불 사기 방지 및 전화 통신을 제외한 다른 모든 사용 사례에 대해 가능 &lt;strong&gt;하면 FirebaseInstanceId 또는 비공개 저장된 GUID를 사용하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b2e9748d24580165cbb22e2726f522e8b890e0b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;User Email - Software&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용자 이메일-소프트웨어&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b795ef3d501d5a65ec77a93fb104d3f775a17b7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;User Phone Number - Software&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용자 전화 번호-소프트웨어&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6199e99727aa312214a0a51a948a3a4853b9ba6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WLAN MAC Address - Hardware&lt;/strong&gt; (needs &lt;strong&gt;&lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;WLAN MAC 주소-하드웨어&lt;/strong&gt; ( &lt;strong&gt; &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; &lt;/strong&gt; 필요)</target>
        </trans-unit>
        <trans-unit id="d78239e458e5232305215bdb49433ff53b4c162a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WLAN MAC Address&lt;/strong&gt; string (needs &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;WLAN MAC 주소&lt;/strong&gt; 문자열 ( &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; 필요)</target>
        </trans-unit>
        <trans-unit id="ebdbf7280232433bb44ce8df29850d11f2652d33" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://developer.android.com/reference/android/os/Build.html#SERIAL&quot;&gt;Serial&lt;/a&gt; field was added to the &lt;code&gt;Build&lt;/code&gt; class in API level 9 (Android 2.3 - Gingerbread). Documentation says it represents the hardware serial number. Thus it should be unique, if it exists on the device.</source>
          <target state="translated">API 레벨 9 (Android 2.3-Gingerbread)의 &lt;code&gt;Build&lt;/code&gt; 클래스에 &lt;a href=&quot;http://developer.android.com/reference/android/os/Build.html#SERIAL&quot;&gt;Serial&lt;/a&gt; 필드가 추가되었습니다. 설명서에 하드웨어 일련 번호가 표시되어 있습니다. 따라서 장치에 존재하는 경우 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b4a06b5ef830134d9fec0ddd03fca8e9d484bb1" translate="yes" xml:space="preserve">
          <source>ANDROID_ID is the preferred device identifier.  ANDROID_ID is perfectly reliable on versions of Android &amp;lt;=2.1 or &amp;gt;=2.3.  Only 2.2 has the problems mentioned in the post.</source>
          <target state="translated">ANDROID_ID는 기본 장치 식별자입니다. ANDROID_ID는 Android &amp;lt;= 2.1 또는&amp;gt; = 2.3 버전에서 완벽하게 신뢰할 수 있습니다. 게시물에 언급 된 문제는 2.2 만입니다.</target>
        </trans-unit>
        <trans-unit id="68aa9980fe376e4905566c98ee670984dbe45080" translate="yes" xml:space="preserve">
          <source>API &amp;gt;= 9:</source>
          <target state="translated">API&amp;gt; = 9 :</target>
        </trans-unit>
        <trans-unit id="29a897557ef6d56f7d7d648fcaddf92743c494e5" translate="yes" xml:space="preserve">
          <source>API &amp;lt; 9:</source>
          <target state="translated">API &amp;lt;9 :</target>
        </trans-unit>
        <trans-unit id="f0bdeaf0b89418308e592d0083e5b065f0e07b91" translate="yes" xml:space="preserve">
          <source>API 14+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_PROFILE&quot; /&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&amp;gt;&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/2112965/how-to-get-the-android-devices-primary-e-mail-address&quot;&gt;How to get the Android device's primary e-mail address&lt;/a&gt;)</source>
          <target state="translated">API 14+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_PROFILE&quot; /&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&amp;gt;&lt;/code&gt; ( &lt;a href=&quot;https://stackoverflow.com/questions/2112965/how-to-get-the-android-devices-primary-e-mail-address&quot;&gt;Android 기기의 기본 이메일 주소를 얻는 방법&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a41b24d1a450d71fe88f28c02825ff387777023d" translate="yes" xml:space="preserve">
          <source>API 5+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&amp;gt;&lt;/code&gt; or</source>
          <target state="translated">API 5 이상 &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&amp;gt;&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="89b151af4a909f2db1de25b74e9195a4ef188176" translate="yes" xml:space="preserve">
          <source>Abusing other IDs like &lt;a href=&quot;https://en.wikipedia.org/wiki/International_Mobile_Station_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt;, serial number, Wi-Fi/Bluetooth-MAC address (they won't exist on all devices or additional permissions become necessary)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/International_Mobile_Station_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt; , 일련 번호, Wi-Fi / Bluetooth-MAC 주소와 같은 다른 ID 남용 (일부 장치에 존재하지 않거나 추가 권한이 필요함)</target>
        </trans-unit>
        <trans-unit id="c12f5ec035062f96ae0b0e2215e9dbc890a13231" translate="yes" xml:space="preserve">
          <source>Add Below code in class file:</source>
          <target state="translated">클래스 파일에 아래 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0e30f5508581eb8326f00fd68d87f89e0c275a2f" translate="yes" xml:space="preserve">
          <source>Add in AndroidManifest.xml:</source>
          <target state="translated">AndroidManifest.xml에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2c199c5dde5288a035f4af10d6f11a0e368ca3e5" translate="yes" xml:space="preserve">
          <source>After reading every Stack Overflow post about creating a unique ID, the Google developer blog and Android documentation, I feel as if the 'Pseudo ID' is the best possible option.</source>
          <target state="translated">고유 ID, Google 개발자 블로그 및 Android 설명서 작성에 대한 모든 스택 오버플로 게시물을 읽은 후 '의사 ID'가 최상의 옵션 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3e749475078b1c951d38bbbc94315254d2f3009" translate="yes" xml:space="preserve">
          <source>Again, this code is for a device ID, not an app installation ID.  For most situations, an app installation ID is probably what you're looking for.  But if you do need a device ID, then the following code will probably work for you.</source>
          <target state="translated">이 코드는 앱 설치 ID가 아니라 장치 ID 용입니다. 대부분의 경우 앱 설치 ID가 원하는 것일 수 있습니다. 그러나 장치 ID가 필요한 경우 다음 코드가 적합 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a92c69287df1de09fcce1814c08b09a18e1c16d" translate="yes" xml:space="preserve">
          <source>All CDMA devices returned null for &lt;code&gt;getSimSerialNumber()&lt;/code&gt; (as expected)</source>
          <target state="translated">모든 CDMA 장치가 &lt;code&gt;getSimSerialNumber()&lt;/code&gt; 대해 null을 반환 했습니다 ( 예상)</target>
        </trans-unit>
        <trans-unit id="72ac9336052e7432124e824524b2a7f0e7906d72" translate="yes" xml:space="preserve">
          <source>All CDMA devices returned the same value (or derivation of the same value) for both &lt;code&gt;ANDROID_ID&lt;/code&gt; and &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt; -- &lt;em&gt;as long as&lt;/em&gt; a Google account has been added during setup.</source>
          <target state="translated">모든 CDMA 장치는 설정 중에 Google 계정이 추가 &lt;em&gt;되어&lt;/em&gt; 있는 한 &lt;code&gt;ANDROID_ID&lt;/code&gt; 및 &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt; 대해 동일한 값 (또는 동일한 값 파생)을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="2dd555f826a536eccab4f888bde32943a6a65c01" translate="yes" xml:space="preserve">
          <source>All GSM devices (all tested with a SIM) returned a value for &lt;code&gt;TelephonyManager.getSimSerialNumber()&lt;/code&gt;</source>
          <target state="translated">모든 GSM 장치 (모두 SIM으로 테스트)는 &lt;code&gt;TelephonyManager.getSimSerialNumber()&lt;/code&gt; 대한 값을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="82968c3a33493da4908421d9d3916cd2a050b103" translate="yes" xml:space="preserve">
          <source>All devices tested returned a value for &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt;</source>
          <target state="translated">테스트 된 모든 장치가 &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt; 대한 값을 리턴했습니다.</target>
        </trans-unit>
        <trans-unit id="82a207f42b5d4fa46e41089bee741f31f1ace78b" translate="yes" xml:space="preserve">
          <source>All devices with a Google account added returned a value for &lt;code&gt;ANDROID_ID&lt;/code&gt;</source>
          <target state="translated">Google 계정이 추가 된 모든 기기에서 &lt;code&gt;ANDROID_ID&lt;/code&gt; 에 대한 값을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="9e2a6399aef2e6af31c0bc620b1b6d8c81bf7654" translate="yes" xml:space="preserve">
          <source>All the hardware based identifiers (SSAID, IMEI, MAC, etc) are unreliable for non-google's devices (Everything except Pixels and Nexuses), which are more than 50% of active devices worldwide. Therefore official &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;Android identifiers best practices&lt;/a&gt; clearly states:</source>
          <target state="translated">모든 하드웨어 기반 식별자 (SSAID, IMEI, MAC 등)는 전 세계 활성 기기의 50 % 이상인 Google 이외의 기기 (픽셀 및 Nexus 제외)에는 신뢰할 수 없습니다. 따라서 공식 &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;Android 식별자 모범 사례&lt;/a&gt; 에는 다음과 같이 명확하게 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b721bff82659fe3b5c324c29d407b7ffd71e37e" translate="yes" xml:space="preserve">
          <source>Also you might consider the Wi-Fi adapter's MAC address. Retrieved thusly:</source>
          <target state="translated">또한 Wi-Fi 어댑터의 MAC 주소를 고려할 수 있습니다. 따라서 검색 :</target>
        </trans-unit>
        <trans-unit id="0384ddde4f6c46d85c48c9f0e81874ca1cb837a8" translate="yes" xml:space="preserve">
          <source>And for full details of how to implement the backup agent see &lt;em&gt;&lt;a href=&quot;http://developer.android.com/guide/topics/data/backup.html&quot;&gt;Data Backup&lt;/a&gt;&lt;/em&gt;. I particularly recommend the section at the bottom on testing as the backup does not happen instantaneously and so to test you have to force the backup.</source>
          <target state="translated">백업 에이전트를 구현하는 방법에 대한 자세한 내용은 &lt;em&gt;&lt;a href=&quot;http://developer.android.com/guide/topics/data/backup.html&quot;&gt;데이터 백업을&lt;/a&gt;&lt;/em&gt; 참조하십시오. 백업이 즉시 수행되지 않으므로 테스트를 수행하려면 백업 맨 아래 섹션을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="287d37fcbbd0b457575f30632d52a2581be37066" translate="yes" xml:space="preserve">
          <source>And use the code below in a background thread:</source>
          <target state="translated">그리고 백그라운드 스레드에서 아래 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a2ff67e89682f23c7d347c28c1e4eb8cef1210bf" translate="yes" xml:space="preserve">
          <source>Another way is to use &lt;code&gt;/sys/class/android_usb/android0/iSerial&lt;/code&gt; in an app without any permissions whatsoever.</source>
          <target state="translated">또 다른 방법은 권한없이 앱에서 &lt;code&gt;/sys/class/android_usb/android0/iSerial&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="15316009acf564b5ec5c638dfc827a10d8ab311c" translate="yes" xml:space="preserve">
          <source>As Dave Webb mentions, the &lt;a href=&quot;https://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android Developer Blog has an article&lt;/a&gt; that covers this.  Their preferred solution is to track app installs rather than devices, and that will work well for most use cases.  The blog post will show you the necessary code to make that work, and I recommend you check it out.</source>
          <target state="translated">Dave Webb가 언급했듯이 &lt;a href=&quot;https://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android 개발자 블로그에는&lt;/a&gt; 이를 다루는 기사 가 있습니다. 그들이 선호하는 솔루션은 기기가 아닌 앱 설치를 추적하는 것이며 대부분의 사용 사례에서 잘 작동합니다. 블로그 게시물에는 해당 작업을 수행하는 데 필요한 코드가 표시되어 있으므로 확인하시기 바랍니다.</target>
        </trans-unit>
        <trans-unit id="e7798ee7e23de9bd2dfada829db8987b37fcd47f" translate="yes" xml:space="preserve">
          <source>As Richard mentions below, don't forget that you need permission to read the &lt;code&gt;TelephonyManager&lt;/code&gt; properties, so add this to your manifest:</source>
          <target state="translated">Richard가 아래에 언급했듯이 &lt;code&gt;TelephonyManager&lt;/code&gt; 속성을 읽을 수있는 권한이 필요하다는 것을 잊지 마십시오. 매니페스트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a2123c71994da4ed1f169f9aa935b0767903ddce" translate="yes" xml:space="preserve">
          <source>As example &lt;code&gt;CVE-2018-9489&lt;/code&gt; which affects all the WIFI based techniques mentioned above.</source>
          <target state="translated">위에서 언급 한 모든 WIFI 기반 기술에 영향을주는 예제 &lt;code&gt;CVE-2018-9489&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e65ec7745c482ede932c1bda8de37db0c79df5" translate="yes" xml:space="preserve">
          <source>As far as I've been able to determine, all affected devices have &lt;a href=&quot;https://issuetracker.google.com/issues/36920653&quot;&gt;the same ANDROID_ID&lt;/a&gt;, which is &lt;a href=&quot;https://www.google.com/search?sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;q=9774d56d682e549c&quot;&gt;9774d56d682e549c&lt;/a&gt;.  Which is also the same device id reported by the emulator, btw.</source>
          <target state="translated">내가 결정할 수있는 한, 영향을받는 모든 장치는 &lt;a href=&quot;https://issuetracker.google.com/issues/36920653&quot;&gt;동일한 ANDROID_ID&lt;/a&gt; 인 &lt;a href=&quot;https://www.google.com/search?sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;q=9774d56d682e549c&quot;&gt;9774d56d682e549c&lt;/a&gt; 입니다. 에뮬레이터에서보고 한 것과 동일한 장치 ID 인 btw도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60dc22dc2be6b68254c05392e8b934f87a0ef9f0" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I/O&lt;/a&gt; Reto Meier released a robust answer to how to approach this which should meet most developers needs to track users across installations. Anthony Nolan shows the direction in his answer, but I thought I'd write out the full approach so that others can easily see how to do it (it took me a while to figure out the details).</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I / O에서&lt;/a&gt; Reto Meier는이 방법에 접근하는 방법에 대한 강력한 답변을 발표했습니다. Anthony Nolan은 그의 대답에 방향을 보여 주지만 다른 사람들이 쉽게 방법을 볼 수 있도록 전체 접근 방식을 작성한다고 생각했습니다 (세부 사항을 파악하는 데 시간이 걸렸습니다).</target>
        </trans-unit>
        <trans-unit id="bc88674eb70c904f011dc5ee3fb4f27aba9862f2" translate="yes" xml:space="preserve">
          <source>At least the following devices are known to have this file world-readable:</source>
          <target state="translated">최소한 다음 장치는이 파일을 세계에서 읽을 수있는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="b831a6047597da45c8ebb40fb3b3f371f45a7ca5" translate="yes" xml:space="preserve">
          <source>Based on Google's recommendations, I implemented a class that will generate a unique UUID for each device, using ANDROID_ID as the seed where appropriate, falling back on TelephonyManager.getDeviceId() as necessary, and if that fails, resorting to a randomly generated unique UUID that is persisted across app restarts (but not app re-installations).</source>
          <target state="translated">Google의 권장 사항을 바탕으로 ANDROID_ID를 적절한 시드로 사용하여 필요에 따라 TelephonyManager.getDeviceId ()로 돌아가고 실패하면 임의로 생성 된 고유 UUID를 사용하여 각 장치에 대해 고유 한 UUID를 생성하는 클래스를 구현했습니다. 이는 앱을 다시 시작해도 지속되지만 앱을 다시 설치하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce0e5f8df217bf7f4b4bc0e5b9db109dc4e72700" translate="yes" xml:space="preserve">
          <source>Based on my tests of devices (all phones, at least one of which is not activated):</source>
          <target state="translated">장치에 대한 나의 테스트 (적어도 하나는 활성화되지 않은 모든 전화기)를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="4a41bd95f5fe6b7b904cbf8306ccd3f50f598759" translate="yes" xml:space="preserve">
          <source>Beginning August 1st, 2014, the Google Play Developer Program Policy
  requires all new app uploads and updates to use the advertising ID in
  lieu of any other persistent identifiers for any advertising purposes.
  Learn more</source>
          <target state="translated">2014 년 8 월 1 일부터 Google Play 개발자 프로그램 정책에 따라 광고 목적으로 다른 영구 식별자 대신 광고 ID를 사용하려면 모든 새로운 앱 업로드 및 업데이트가 필요합니다. 더 알아보기</target>
        </trans-unit>
        <trans-unit id="5551d514845c47662940105033550cdb6568d20e" translate="yes" xml:space="preserve">
          <source>But I strongly recommend a method suggested by Google, see &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.mx/2011/03/identifying-app-installations.html&quot;&gt;Identifying App Installations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">그러나 Google에서 제안한 방법을 강력히 권장합니다 ( &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.mx/2011/03/identifying-app-installations.html&quot;&gt;앱 설치 식별&lt;/a&gt;&lt;/em&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="c1190cce9e57205b886e4861b18c71cf98724858" translate="yes" xml:space="preserve">
          <source>But i recommend to use:</source>
          <target state="translated">그러나 나는 다음을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4f0c2ef1b6ba41d408d174704493fdeecddd1f5" translate="yes" xml:space="preserve">
          <source>Changed the Pseudo</source>
          <target state="translated">의사 변경</target>
        </trans-unit>
        <trans-unit id="d797b89f3211afa4ec1e56bf65e028e8ed315137" translate="yes" xml:space="preserve">
          <source>Changes:</source>
          <target state="translated">Changes:</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="b3faa22d95bd029d5e8eb421fac2504f3d17d490" translate="yes" xml:space="preserve">
          <source>Do Android devices have a unique ID, and if so, what is a simple way to access it using Java?</source>
          <target state="translated">Android 기기에는 고유 ID가 있습니까? 그렇다면 Java를 사용하여 액세스하는 간단한 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ee4b6d17a79863a088ad5f4cb3971a3a274cea1b" translate="yes" xml:space="preserve">
          <source>Edited the code to change on API</source>
          <target state="translated">API에서 변경하도록 코드를 편집했습니다.</target>
        </trans-unit>
        <trans-unit id="81d8557b9b477cf320e57ebec08f61219c93cad4" translate="yes" xml:space="preserve">
          <source>Finally create a user ID, if it doesn't already exist, and store it in the SharedPreferences:</source>
          <target state="translated">마지막으로 사용자 ID가없는 경우이를 작성하여 SharedPreferences에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="4d508e5126e2607ecdbc5585d6f5feddb0141747" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;TRACKING HARDWARE&lt;/strong&gt;, this is a great idea</source>
          <target state="translated">&lt;strong&gt;하드웨어 추적의&lt;/strong&gt; 경우 이는 좋은 아이디어입니다</target>
        </trans-unit>
        <trans-unit id="a5aaa337d1440bdae5d23e8ace9adf091f4c1bb2" translate="yes" xml:space="preserve">
          <source>For detailed instructions on how to get a unique identifier for each Android device your application is installed from, see the official Android Developers Blog posting &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Identifying App Installations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">애플리케이션이 설치된 각 Android 기기마다 고유 식별자를 얻는 방법에 대한 자세한 지침은 공식 Android 개발자 블로그 게시물 &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;앱 설치 식별을&lt;/a&gt;&lt;/em&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7fcb4dff4d000ebe9767dab18b43055f96799e0" translate="yes" xml:space="preserve">
          <source>For hardware recognition of a specific Android device you could check the MAC Addresses.</source>
          <target state="translated">특정 Android 기기의 하드웨어 인식을 위해 MAC 주소를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74a63bc03f2c45c8de27ed0ee3cd9f09b7d7ae05" translate="yes" xml:space="preserve">
          <source>For more information on this approach see &lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;Reto's talk&lt;/a&gt;.</source>
          <target state="translated">이 접근법에 대한 자세한 정보는 &lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;Reto 's talk을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c761e900a9e6f2abf00dadb6a1e61c902d515440" translate="yes" xml:space="preserve">
          <source>Full disclosure: my app used the below approach originally but no longer uses this approach, and we now use the approach outlined in the &lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android Developer Blog&lt;/a&gt; entry that &lt;a href=&quot;https://stackoverflow.com/a/5626208/231078&quot;&gt;emmby's answer&lt;/a&gt; links to (namely, generating and saving a &lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html#randomUUID()&quot;&gt;&lt;code&gt;UUID#randomUUID()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">전체 공개 : 내 앱은 원래 아래 접근법을 사용했지만 더 이상이 접근법을 사용하지 않으며 이제는 &lt;a href=&quot;https://stackoverflow.com/a/5626208/231078&quot;&gt;emmby의 답변이&lt;/a&gt; 링크 된 (즉, &lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html#randomUUID()&quot;&gt; &lt;code&gt;UUID#randomUUID()&lt;/code&gt; &lt;/a&gt; 생성 및 저장) &lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android 개발자 블로그&lt;/a&gt; 항목에 설명 된 접근법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c2cd906ea84d8bcee34e2068a1fa4560468873b" translate="yes" xml:space="preserve">
          <source>Galaxy Nexus</source>
          <target state="translated">갤럭시 넥서스</target>
        </trans-unit>
        <trans-unit id="44fffff309134b9b2bdf71b19d330caa1f1f4db7" translate="yes" xml:space="preserve">
          <source>Google Player Services InstanceID</source>
          <target state="translated">Google 플레이어 서비스 인스턴스 ID</target>
        </trans-unit>
        <trans-unit id="64bb16ae288df58d9c0fb9528840bd40020a3ef4" translate="yes" xml:space="preserve">
          <source>Google believes that OEMs have patched the issue for many or most of their devices, but I was able to verify that as of the beginning of April 2011, at least, it's still quite easy to find devices that have the broken ANDROID_ID.</source>
          <target state="translated">Google은 OEM이 대부분 또는 대부분의 기기에서이 문제를 해결했다고 생각하지만, 2011 년 4 월 초부터 ANDROID_ID가 손상된 기기를 찾는 것이 여전히 쉬운 지 확인할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="66ffbf021486edd946d859959189cdbdaa6ac774" translate="yes" xml:space="preserve">
          <source>Google will give you a backup service key which you need to add to the manifest. You also need to tell the application to use the BackupAgent as follows:</source>
          <target state="translated">Google은 매니페스트에 추가해야하는 백업 서비스 키를 제공합니다. 또한 응용 프로그램에 다음과 같이 BackupAgent를 사용하도록 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc10b27cdcc1e9484e50c527f7df63edcd51bd5" translate="yes" xml:space="preserve">
          <source>HTC One V</source>
          <target state="translated">HTC 하나 V</target>
        </trans-unit>
        <trans-unit id="b76ab65957a69ff57e8c72352794d437fd34c788" translate="yes" xml:space="preserve">
          <source>Hardware</source>
          <target state="translated">Hardware</target>
        </trans-unit>
        <trans-unit id="c328e6f1d27b686f33f8c2a1cb31439f110901b3" translate="yes" xml:space="preserve">
          <source>Here are a few things to take in mind:</source>
          <target state="translated">명심해야 할 몇 가지 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db30e0d3f173e7a651d727b69350a9ac513b2027" translate="yes" xml:space="preserve">
          <source>Here is how I am generating the unique id:</source>
          <target state="translated">고유 ID를 생성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="909ed0a3f13ac0a179921a37eecac87855d385d5" translate="yes" xml:space="preserve">
          <source>Here is the code that Reto Meier used in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I/O&lt;/a&gt; presentation this year to get a unique id for the user:</source>
          <target state="translated">다음은 Reto Meier가 올해 &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I / O&lt;/a&gt; 프레젠테이션에서 사용자의 고유 ID를 얻기 위해 사용한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="c38334779e436ea91f7bfab6257a7dad9862f212" translate="yes" xml:space="preserve">
          <source>How about the &lt;a href=&quot;http://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt;. That is unique for Android or other mobile devices.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt; 는 어떻습니까. 이는 Android 또는 다른 모바일 장치에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="7748c168ff521cd3dda63c31c7fb08b724c2706a" translate="yes" xml:space="preserve">
          <source>However, the blog post goes on to discuss solutions if you need a device identifier rather than an app installation identifier.  I spoke with someone at Google to get some additional clarification on a few items in the event that you need to do so.  Here's what I discovered about device identifiers that's NOT mentioned in the aforementioned blog post:</source>
          <target state="translated">그러나 앱 설치 식별자가 아닌 장치 식별자가 필요한 경우 블로그 게시물에서 솔루션에 대해 논의합니다. Google 담당자에게 문의하여 필요한 경우 몇 가지 항목에 대한 추가 설명을 얻었습니다. 위에서 언급 한 블로그 게시물에서 언급하지 않은 장치 식별자에 대해 발견 한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="156b25fd784ead3f040e53e4d7236506840f56f2" translate="yes" xml:space="preserve">
          <source>I did not yet have a chance to test GSM devices with no SIM, a GSM device with no Google account added, or any of the devices in airplane mode.</source>
          <target state="translated">SIM이없는 GSM 장치, Google 계정이 추가되지 않은 GSM 장치 또는 비행기 모드의 장치는 아직 테스트 할 기회가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="a4c6aa4b572309ea35cf741ad3d2a12472e946d4" translate="yes" xml:space="preserve">
          <source>I don't know whether it is actually supported (=not null) by all devices with API level &amp;gt;= 9 though.</source>
          <target state="translated">API 수준이 9보다 큰 모든 장치에서 실제로 지원되는지 (= null이 아닌지) 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="3a733cbbb39274e68cf086005cf1e1f3376f3f67" translate="yes" xml:space="preserve">
          <source>I have tried to reference every link that I took information from. If you are missing and need to be included, please comment!</source>
          <target state="translated">정보를 얻은 모든 링크를 참조하려고했습니다. 누락되어 포함해야 할 경우 의견을 말하십시오!</target>
        </trans-unit>
        <trans-unit id="c9e6270ca55fb5962a1695210945e5b160b251aa" translate="yes" xml:space="preserve">
          <source>I know there isn't any 'perfect' way of getting a unique ID without using permissions; however, sometimes we only really need to track the device installation. When it comes to creating a unique ID, we can create a 'pseudo unique id' based solely off of information that the Android API gives us without using extra permissions. This way, we can show the user respect and try to offer a good user experience as well.</source>
          <target state="translated">권한을 사용하지 않고 고유 ID를 얻는 '완벽한'방법이 없다는 것을 알고 있습니다. 그러나 때로는 장치 설치 만 추적하면됩니다. 고유 ID를 만들 때 추가 권한을 사용하지 않고 Android API가 제공 한 정보만으로 '의사 고유 ID'를 만들 수 있습니다. 이런 식으로, 우리는 사용자를 존중하고 좋은 사용자 경험을 제공하려고 노력할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa122338cdf92af7137efd94b974b0d33bd5fd1" translate="yes" xml:space="preserve">
          <source>I myself prefer using an existing OpenUDID implementation (see &lt;a href=&quot;https://github.com/ylechelle/OpenUDID&quot;&gt;https://github.com/ylechelle/OpenUDID&lt;/a&gt;) for Android (see &lt;a href=&quot;https://github.com/vieux/OpenUDID&quot;&gt;https://github.com/vieux/OpenUDID&lt;/a&gt;). It is easy to integrate and makes use of the &lt;code&gt;ANDROID_ID&lt;/code&gt; with fallbacks for those issues mentioned above.</source>
          <target state="translated">본인은 Android 용 기존 OpenUDID 구현 ( &lt;a href=&quot;https://github.com/ylechelle/OpenUDID&quot;&gt;https://github.com/ylechelle/OpenUDID 참조&lt;/a&gt; )을 선호합니다 ( &lt;a href=&quot;https://github.com/vieux/OpenUDID&quot;&gt;https://github.com/vieux/OpenUDID 참조&lt;/a&gt; ). 위에서 언급 한 문제에 대해 &lt;code&gt;ANDROID_ID&lt;/code&gt; 를 쉽게 통합하고 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b606db7e3a8dffabbb25480301dd8f04d9879aa" translate="yes" xml:space="preserve">
          <source>I personally find this acceptable but not ideal. No one identifier provided by Android works in all instances as most are dependent on the phone's radio states (Wi-Fi on/off, cellular on/off, Bluetooth on/off). The others, like &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; must be implemented by the manufacturer and are not guaranteed to be unique.</source>
          <target state="translated">나는 개인적으로 이것을 받아 들일 수 있지만 이상적이지는 않다. 대부분의 경우 휴대 전화의 라디오 상태 (Wi-Fi 켜기 / 끄기, 셀룰러 켜기 / 끄기, 블루투스 켜기 / 끄기)에 따라 Android에서 제공하는 식별자가 모든 경우에 작동하지 않습니다. &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; 와 같은 다른 것은 제조업체가 구현해야하며 고유하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e938574a512fc75c74a4248fc0bef6cc438366b9" translate="yes" xml:space="preserve">
          <source>I think this is sure fire way of building a skeleton for a unique ID...  check it out.</source>
          <target state="translated">나는 이것이 유일한 ID를위한 골격을 구축하는 확실한 방법이라고 생각합니다 ... 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f81d00de22f916abb3004846fde32e53ec7ae94d" translate="yes" xml:space="preserve">
          <source>I use the following code to get the &lt;code&gt;IMEI&lt;/code&gt; or use Secure.&lt;code&gt;ANDROID_ID&lt;/code&gt; as an alternative, when the device doesn't have phone capabilities:</source>
          <target state="translated">다음 코드를 사용하여 &lt;code&gt;IMEI&lt;/code&gt; 를 얻거나 보안을 사용합니다. 기기에 전화 기능이없는 경우 대안으로 &lt;code&gt;ANDROID_ID&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="57a804aec5bf6e57ee40407af2a281ca3431eca3" translate="yes" xml:space="preserve">
          <source>IMEI, Mac Addresses, Instance Id, GUIDs, SSAID, Advertising Id, Safety Net API to verify devices.</source>
          <target state="translated">장치를 확인하기위한 IMEI, Mac 주소, 인스턴스 ID, GUID, SSAID, 광고 ID, Safety Net API.</target>
        </trans-unit>
        <trans-unit id="06071d8f8cd78e028ee7c3525bd3c0ef79dc3ddd" translate="yes" xml:space="preserve">
          <source>If all else fails, if the user does have lower than API 9 (lower than Gingerbread), has reset their device or 'Secure.ANDROID_ID' returns 'null', then simply the ID returned will be solely based off their Android device information. This is where the collisions can happen.</source>
          <target state="translated">사용자가 API 9보다 낮거나 (Gingerbread보다 낮은) 기기를 재설정했거나 'Secure.ANDROID_ID'가 'null'을 반환하면 다른 모든 방법이 실패하면 단순히 반환 된 ID는 Android 기기 정보를 기반으로합니다. 충돌이 발생할 수있는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="dc3a0a3dba7c8ea7891c00a199b23c671d5c51a8" translate="yes" xml:space="preserve">
          <source>If all else fails:</source>
          <target state="translated">다른 모든 것이 실패하면 :</target>
        </trans-unit>
        <trans-unit id="762e4f4e43bad11983bc567125f5da4ca9333dd0" translate="yes" xml:space="preserve">
          <source>If the user's Android device is lower than API 9; hopefully, they have not done a factory reset and their 'Secure.ANDROID_ID' will be preserved or not 'null'. (see &lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;http://developer.android.com/about/dashboards/index.html&lt;/a&gt;)</source>
          <target state="translated">사용자의 Android 기기가 API 9보다 낮은 경우 희망적으로, 그들은 공장 초기화를하지 않았고 그들의 'Secure.ANDROID_ID'는 보존되거나 '널'이 아닙니다. ( &lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;http://developer.android.com/about/dashboards/index.html 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="fa0ea4d56f487e060e2bef1ed328eb75796b719b" translate="yes" xml:space="preserve">
          <source>If their Android device is API 9 or over, this is guaranteed to be unique because of the 'Build.SERIAL' field.</source>
          <target state="translated">Android 기기가 API 9 이상인 경우 'Build.SERIAL'필드 때문에 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="3575fde2de857ff87c8118647f87e52a16628549" translate="yes" xml:space="preserve">
          <source>If you couple this with a backup strategy to send preferences to the cloud (also described in Reto's &lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;talk&lt;/a&gt;, you should have an id that ties to a user and sticks around after the device has been wiped, or even replaced. I plan to use this in analytics going forward (in other words, I have not done that bit yet :).</source>
          <target state="translated">이 옵션을 백업 전략과 결합하여 환경 설정을 클라우드에 전송하는 경우 (Reto 's &lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;talk에&lt;/a&gt; 설명되어 있음), 사용자를 연결하고 장치가 지워지거나 교체 된 후에도 연결되는 ID가 있어야합니다. 앞으로 분석에서 (즉, 아직 그 일을하지 않았습니다 :).</target>
        </trans-unit>
        <trans-unit id="3eb06bbafe2a8c1917c4f2423475d42118fed40e" translate="yes" xml:space="preserve">
          <source>If you have a user with a factory reset device, the value may have changed or altered on the rooted device so there may be duplicates entries if you are tracking user installs.</source>
          <target state="translated">출고시 재설정 장치를 사용하는 사용자가있는 경우 루팅 된 장치에서 값이 변경되거나 변경되어 사용자 설치를 추적하는 경우 항목이 중복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4de44081ecbabe0f12a4e9710368ae86429838b2" translate="yes" xml:space="preserve">
          <source>If you need to store the device identification on your remote server, then don't store it as is (plain text), but a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;hash with salt&lt;/a&gt;.</source>
          <target state="translated">장치 식별을 원격 서버에 저장해야하는 경우에는 그대로 (일반 텍스트) 저장하지 말고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;salt&lt;/a&gt; 로 해시하십시오 .</target>
        </trans-unit>
        <trans-unit id="c69ab1c2ee0514d03ee5cd6b934bf576aa81b87c" translate="yes" xml:space="preserve">
          <source>If you use GCM, then you will eventually need to use this instance ID because you need it in order to get the GCM token (which replaces the old GCM registration ID).</source>
          <target state="translated">GCM을 사용하는 경우 GCM 토큰 (이전 GCM 등록 ID를 대체 함)을 가져 오기 위해이 인스턴스 ID가 필요하므로 결국이 인스턴스 ID를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="528661f594242632fc3a1475ecad83ff4445ee50" translate="yes" xml:space="preserve">
          <source>If you use the ID for the purposes they intend - eg. app authentication, app identification, GCM - I think this 1-3 seconds could be a nuisance (depending on your app, of course).</source>
          <target state="translated">의도 한 목적으로 ID를 사용하는 경우-예. 앱 인증, 앱 식별, GCM-이 1-3 초가 성가신 것으로 생각합니다 (물론 앱에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="1ac06007cebb29579c97114d7324ea4840e62e4a" translate="yes" xml:space="preserve">
          <source>Implementing a custom ID generation algorithm (based on device properties that are supposed to be static and won't change -&amp;gt; who knows)</source>
          <target state="translated">사용자 정의 ID 생성 알고리즘 구현 (정적이며 변경되지 않아야하는 장치 속성을 기반으로-&amp;gt; 아는 사람)</target>
        </trans-unit>
        <trans-unit id="18dd7e894b3d90006c19d4622173976d09581f63" translate="yes" xml:space="preserve">
          <source>Important:</source>
          <target state="translated">Important:</target>
        </trans-unit>
        <trans-unit id="75a08b4ae0701d301a9b9dd2a57267b1b16cb80c" translate="yes" xml:space="preserve">
          <source>In every Android device their is at least a &quot;wlan0&quot; Interface witch is the WI-FI chip.
This code works even when WI-FI is not turned on.</source>
          <target state="translated">모든 Android 기기에서 최소 &quot;wlan0&quot;인터페이스 마녀는 WI-FI 칩입니다. 이 코드는 WI-FI가 켜져 있지 않은 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a63fbc8d29b93f78056c57ad30866d3b8fd12d3e" translate="yes" xml:space="preserve">
          <source>In the current implementation (GPS 7.5) the instance ID is retrieved from a server when your app requests it.  This means that the call above is a blocking call - in my unscientific testing it takes 1-3 seconds if the device is online, and 0.5 - 1.0 seconds if off-line (presumably this is how long it waits before giving up and generating a random ID).  This was tested in North America on Nexus 5 with Android 5.1.1 and GPS 7.5.</source>
          <target state="translated">현재 구현 (GPS 7.5)에서 앱이 요청하면 인스턴스 ID가 서버에서 검색됩니다. 이것은 위의 호출이 차단 호출이라는 것을 의미합니다. 비과학적인 테스트에서는 장치가 온라인 상태 인 경우 1 ~ 3 초, 오프라인 상태 인 경우 0.5 ~ 1.0 초 (아마도 포기하고 생성하기까지 대기하는 시간입니다) 임의의 ID). Android 5.1.1 및 GPS 7.5가 설치된 Nexus 5에서 북미 지역에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="2ae8f70f4300bc2ba3098af2f4adc093761dbe21" translate="yes" xml:space="preserve">
          <source>Instead, I encapsulated the various strategies for getting a (device) ID in an enum - changing the order of the enum constants affects the priority of the various ways of getting the ID. The first non-null ID is returned or an exception is thrown (as per good Java practices of not giving null a meaning). So for instance I have the TELEPHONY one first - but a good default choice would be the ANDROID_ID
&lt;strong&gt;beta:&lt;/strong&gt;</source>
          <target state="translated">대신 열거 형에서 (장치) ID를 얻는 다양한 전략을 요약했습니다. 열거 상수의 순서를 변경하면 ID를 얻는 다양한 방법의 우선 순위에 영향을 미칩니다. 널 (null)이 아닌 ID가 리턴되거나 예외가 발생합니다 (좋은 Java 관행에 따라 널 (null)에 의미를주지 않음) 예를 들어 TELEPHONY를 먼저 가지고 있지만 기본적으로 ANDROID_ID &lt;strong&gt;베타를&lt;/strong&gt; 선택하는 것이 좋습니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c29126da6664f6edcac9f12325eb165daa92de65" translate="yes" xml:space="preserve">
          <source>Is there a unique Android device ID</source>
          <target state="translated">고유 한 Android 기기 ID가 있습니까</target>
        </trans-unit>
        <trans-unit id="b47bb185dbab4ea38c6cbb61b904354a8215bbea" translate="yes" xml:space="preserve">
          <source>It appears to me that Google intends for it to be used for this purpose (identifying your installations), it is cross-platform, and can be used for a number of other purposes (see the links above).</source>
          <target state="translated">Google 은이 목적으로 (설치를 식별하는) 목적으로 사용하려고하며, 플랫폼 간이며 여러 다른 목적으로 사용할 수 있습니다 (위 링크 참조).</target>
        </trans-unit>
        <trans-unit id="e48e1d7951eaa1e687adda314e217b648f7dd4d3" translate="yes" xml:space="preserve">
          <source>It combines 3 IDs and creates a 32-digit hex string. It has worked very well for me.</source>
          <target state="translated">3 개의 ID를 결합하고 32 자리 16 진 문자열을 작성합니다. 그것은 나를 위해 아주 잘 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="2c160ef6ce12d88a829702227c10d5289519ab11" translate="yes" xml:space="preserve">
          <source>It covers five different ID types:</source>
          <target state="translated">다섯 가지 ID 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a9ced4556496d02cc0a71b2e1e4ff599463200a" translate="yes" xml:space="preserve">
          <source>It identifies an installation rather then a device, but then again, ANDROID_ID (which is the accepted answer) now no longer identifies devices either.  With the ARC runtime a new ANDROID_ID is generated for every installation (&lt;a href=&quot;https://stackoverflow.com/questions/29656101/how-does-android-id-on-arc-chrome-differ-from-android&quot;&gt;details here&lt;/a&gt;), just like this new instance ID.  Also, I think that identifying installations (not devices) is what most of us are actually looking for.</source>
          <target state="translated">장치 대신 설치를 식별하지만 다시 ANDROID_ID (허용되는 답변)는 더 이상 장치를 식별하지 않습니다. ARC 런타임을 사용하면이 새 인스턴스 ID와 마찬가지로 모든 설치에 대해 새 ANDROID_ID가 생성됩니다 ( &lt;a href=&quot;https://stackoverflow.com/questions/29656101/how-does-android-id-on-arc-chrome-differ-from-android&quot;&gt;자세한 내용은 여기 참조&lt;/a&gt; ). 또한, 우리는 대부분의 사람들이 실제로 장치를 찾는 것이 설치를 식별하는 것이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="a64f6056588034fc4d220538d26c0b1682bf2e4d" translate="yes" xml:space="preserve">
          <source>It is intended that the advertising ID completely replace existing
  usage of other identifiers for ads purposes (such as the use of ANDROID_ID
  in Settings.Secure) when Google Play Services is available. Cases
  where Google Play Services is unavailable are indicated by a
  GooglePlayServicesNotAvailableException being thrown by
  getAdvertisingIdInfo().</source>
          <target state="translated">Google Play 서비스를 사용할 수있는 경우 광고 ID는 광고 목적으로 다른 식별자의 기존 사용법 (예 : Settings.Secure에서 ANDROID_ID 사용)을 완전히 대체합니다. Google Play 서비스를 사용할 수없는 경우 getAdvertisingIdInfo ()에 의해 발생한 GooglePlayServicesNotAvailableException이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="48ab83801f8db7d5cd0d68add1c88ce8c0ff1d0e" translate="yes" xml:space="preserve">
          <source>It seems that Google intends for this ID to be used to identify installations across Android, Chrome, and iOS.</source>
          <target state="translated">Google은이 ID를 사용하여 Android, Chrome 및 iOS에서 설치를 식별하려고합니다.</target>
        </trans-unit>
        <trans-unit id="661748ef478e8f40ca9ba7610f202aa6326f6fdf" translate="yes" xml:space="preserve">
          <source>It seems the best way is for you to generate one yourself upon installation and subsequently read it when the application is re-launched.</source>
          <target state="translated">가장 좋은 방법은 설치시 직접 생성하여 응용 프로그램을 다시 시작할 때 읽는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c60f8164d86460485efd8a7405c3f239b0f4e312" translate="yes" xml:space="preserve">
          <source>It will return something like this:  &lt;strong&gt;551F27C060712A72730B0A0F734064B1&lt;/strong&gt;</source>
          <target state="translated">다음과 같이 반환됩니다 : &lt;strong&gt;551F27C060712A72730B0A0F734064B1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e469922a6bbfc6a99ddffec61b7d063177d70a1c" translate="yes" xml:space="preserve">
          <source>It works well enough for me.</source>
          <target state="translated">그것은 나를 위해 충분히 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5f78b3acf61010d46d7a439aaa6bd62d6aeb0a2d" translate="yes" xml:space="preserve">
          <source>It's a simple question, with no simple answer.</source>
          <target state="translated">간단한 대답이없는 간단한 질문입니다.</target>
        </trans-unit>
        <trans-unit id="247f9767730bc5c8c15744b994fbc8656ec12600" translate="yes" xml:space="preserve">
          <source>It's not only unreliable for device identification, but you also must follow the &lt;a href=&quot;https://play.google.com/about/monetization-ads/ads/#!?zippy_activeEl=ad-id#ad-id&quot;&gt;user privacy regarding ad tracking&lt;/a&gt; policy, which states clearly that user can reset or block it at any moment.</source>
          <target state="translated">기기 식별에는 신뢰할 수 없을뿐만 아니라 &lt;a href=&quot;https://play.google.com/about/monetization-ads/ads/#!?zippy_activeEl=ad-id#ad-id&quot;&gt;광고 추적&lt;/a&gt; 정책 과 관련된 사용자 개인 정보 보호 정책을 준수해야합니다.이 정책은 사용자가 언제든지 재설정하거나 차단할 수 있음을 명확하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e3a4a1aa378c1161638d051127dad02b5e8af7a4" translate="yes" xml:space="preserve">
          <source>It's unique for the application installation on the device, so when the user uninstall the app - it's wiped out, so it's not 100% reliable, but it's the next best thing.</source>
          <target state="translated">장치에 응용 프로그램을 설치하는 데 고유하므로 사용자가 응용 프로그램을 제거하면 응용 프로그램이 지워 지므로 100 % 신뢰할 수는 없지만 다음으로 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e2cd4c7ea6ed9c1da9c0b5458920576c63b6da8" translate="yes" xml:space="preserve">
          <source>Last Updated: 6/2/15</source>
          <target state="translated">최종 업데이트 : 15. 6. 2.</target>
        </trans-unit>
        <trans-unit id="496c98f39e8e3600d46a85e0a6a8f53c36f64d75" translate="yes" xml:space="preserve">
          <source>Let's go through the full approach. First, we need to create a backup for our SharedPreferences using the Android Backup Service. Start by registering your app via &lt;code&gt;http://developer.android.com/google/backup/signup.html&lt;/code&gt;.</source>
          <target state="translated">전체 접근 방식을 살펴 보겠습니다. 먼저 Android 백업 서비스를 사용하여 SharedPreferences에 대한 백업을 만들어야합니다. &lt;code&gt;http://developer.android.com/google/backup/signup.html&lt;/code&gt; 을 통해 앱을 등록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d1d40e4e6e4d5b5057568f722d23bc52c97f7bf" translate="yes" xml:space="preserve">
          <source>List of options - reasons why/ why not to use them:</source>
          <target state="translated">옵션 목록-이유 / 사용하지 않는 이유 :</target>
        </trans-unit>
        <trans-unit id="8ed8661fcd4fe9d083532cfc96cbc88d049d4b3a" translate="yes" xml:space="preserve">
          <source>Main Issue: Hardware vs Software</source>
          <target state="translated">주요 문제 : 하드웨어 및 소프트웨어</target>
        </trans-unit>
        <trans-unit id="9cb382f8ab032841aa8265aab6792980ecc82a07" translate="yes" xml:space="preserve">
          <source>Makes it interesting playing &quot;Pocket Empires&quot; which gives you instant access to someone's account based on the &quot;unique&quot; DeviceID.</source>
          <target state="translated">&quot;고유 한&quot;DeviceID를 기반으로 누군가의 계정에 즉시 액세스 할 수있는 &quot;Pocket Empires&quot;를 재생하는 것이 재미있어집니다.</target>
        </trans-unit>
        <trans-unit id="8407cc5c571fc70b49a29b1d8d5c087a101668c0" translate="yes" xml:space="preserve">
          <source>Many other answers here are suggesting to use the &lt;code&gt;AdvertisingIdClient&lt;/code&gt;, which is also incompatible, as its by design should be used only for ads profiling. It's also stated in the &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;official reference&lt;/a&gt;</source>
          <target state="translated">다른 많은 답변은 &lt;code&gt;AdvertisingIdClient&lt;/code&gt; 사용을 제안하고 있습니다. AdvertisingIdClient 는 의도적으로 설계되어 광고 프로파일 링에만 사용해야하므로 호환되지 않습니다. &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;공식 참조&lt;/a&gt; 에도 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad1775c5ffeddd50a06ef8242262cdc6b3efc15" translate="yes" xml:space="preserve">
          <source>Mini MK802</source>
          <target state="translated">미니 MK802</target>
        </trans-unit>
        <trans-unit id="20633f608fc0a2559531f24278a3c2e5959dce8a" translate="yes" xml:space="preserve">
          <source>More over, all of the existing answers here are whether out of date or unreliable.</source>
          <target state="translated">또한 기존의 모든 답변은 오래되었거나 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9dcd7866a1f6d57e1475eb160f7d5e8cb2eb96a8" translate="yes" xml:space="preserve">
          <source>More specifically, &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt;. This is a 64-bit quantity that is generated and stored when the device first boots. It is reset when the device is wiped.</source>
          <target state="translated">더 구체적으로, &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; 입니다. 이것은 장치가 처음 부팅 될 때 생성 및 저장되는 64 비트 수량입니다. 장치를 닦으면 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b532ed3a11e14d9ce0eab31a5498be481833d792" translate="yes" xml:space="preserve">
          <source>Most applications on the market do not use Bluetooth, and so if your application doesn't use Bluetooth and you are including this, the user could become suspicious.</source>
          <target state="translated">시장에 나와있는 대부분의 응용 프로그램은 Bluetooth를 사용하지 않으므로 응용 프로그램에서 Bluetooth를 사용하지 않고이를 포함하면 사용자가 의심 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df90379ebe5f94bce4c858d9844cdc05ecf3ba9b" translate="yes" xml:space="preserve">
          <source>Most of the Build members are strings, what we're doing here is to take their length and transform it via modulo in a digit. We have 13 such digits and we are adding two more in front (35) to have the same size ID as the IMEI (15 digits). There are other possibilities here are well, just have a look at these strings.
Returns something like &lt;code&gt;355715565309247&lt;/code&gt;. No special permission is required, making this approach very convenient.</source>
          <target state="translated">대부분의 Build 멤버는 문자열이며 여기서 수행하는 것은 길이를 가져 와서 모듈로를 통해 숫자로 변환하는 것입니다. 우리는 13 자리 숫자를 가지고 있으며 IMEI (15 자리)와 동일한 크기의 ID를 갖기 위해 앞에 두 개를 더 추가합니다 (35). 여기에 다른 가능성이 있습니다.이 문자열을 살펴보십시오. &lt;code&gt;355715565309247&lt;/code&gt; 과 같은 것을 반환합니다. 특별한 접근이 필요하지 않으므로이 접근 방식이 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="45ad2b97af05faae0b04ef0eca23dec62b094976" translate="yes" xml:space="preserve">
          <source>Most users hate the fact that it says &quot;Phone Calls&quot; in the permission. Some users give bad ratings, because they believe you are simply stealing their personal information when all you really want to do is track device installs. It is obvious that you are collecting data.</source>
          <target state="translated">대부분의 사용자는 권한에서 &quot;전화 통화&quot;라는 사실을 싫어합니다. 기기를 추적하는 것만으로도 개인 정보를 훔치기 만한다고 믿기 때문에 일부 사용자의 평가는 좋지 않습니다. 데이터를 수집하고 있음이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="f83d27aeb68503f7856b1a64f2202d260cb1f5a6" translate="yes" xml:space="preserve">
          <source>Motorola Xoom 3G</source>
          <target state="translated">모토로라 Xoom 3G</target>
        </trans-unit>
        <trans-unit id="b1d9cca4bbe81715372255d8568403f7b52ca07c" translate="yes" xml:space="preserve">
          <source>My device does not have a cell radio.</source>
          <target state="translated">내 장치에는 셀 라디오가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ca245e28b63eff96a79947951e1ad46738bf8bc" translate="yes" xml:space="preserve">
          <source>My two cents - NB this is for a &lt;em&gt;device (err) unique ID&lt;/em&gt; - not the installation one as discussed in the &lt;a href=&quot;http://android-developers.blogspot.gr/2011/03/identifying-app-installations.html&quot;&gt;Android developers's blog&lt;/a&gt;.</source>
          <target state="translated">내 두 센트-NB 이것은 &lt;em&gt;장치 (err) 고유 ID를위한 것입니다&lt;/em&gt; - &lt;a href=&quot;http://android-developers.blogspot.gr/2011/03/identifying-app-installations.html&quot;&gt;안드로이드 개발자 블로그&lt;/a&gt; 에서 논의 된 것처럼 설치 &lt;em&gt;ID가&lt;/em&gt; 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a22ea5efcc531b0a7f05e8d215d271931ba7a266" translate="yes" xml:space="preserve">
          <source>New (for apps with ads AND Google Play Services):</source>
          <target state="translated">새로운 기능 (광고 및 Google Play 서비스가있는 앱) :</target>
        </trans-unit>
        <trans-unit id="7c1f3d3b5bb9ed8154189e664ae03163e3d63802" translate="yes" xml:space="preserve">
          <source>Nexus S</source>
          <target state="translated">넥서스 S</target>
        </trans-unit>
        <trans-unit id="51bf8e626689b71d70b2d25b5cffc6d0364d6086" translate="yes" xml:space="preserve">
          <source>Note that for devices that have to fallback on the device ID, the unique ID &lt;strong&gt;WILL&lt;/strong&gt; persist across factory resets.  This is something to be aware of.  If you need to ensure that a factory reset will reset your unique ID, you may want to consider falling back directly to the random UUID instead of the device ID.</source>
          <target state="translated">장치 ID를 대체해야하는 장치의 경우 고유 한 ID는 공장 초기화시에도 유지됩니다. 이것은 알아야 할 사항입니다. 출고시 재설정으로 고유 ID를 재설정해야하는 경우 장치 ID 대신 임의의 UUID로 직접 폴백하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c7d96cc46215857f3ab29923513d98b7caa4abb4" translate="yes" xml:space="preserve">
          <source>Note: You can always add more IDs to the &lt;code&gt;longId&lt;/code&gt; string. For example, Serial #. wifi adapter address. IMEI. This way you are making it more unique per device.</source>
          <target state="translated">참고 : &lt;code&gt;longId&lt;/code&gt; 문자열에 언제든지 더 많은 ID를 추가 할 수 있습니다. 예를 들어, 일련 번호입니다. 와이파이 어댑터 주소. IMEI. 이렇게하면 장치마다 더 독창적입니다.</target>
        </trans-unit>
        <trans-unit id="c2b3b587b0270f11cd6fb7276d052c83fb8e31d3" translate="yes" xml:space="preserve">
          <source>Of note that the &lt;a href=&quot;https://stackoverflow.com/a/5626208/281545&quot;&gt;solution&lt;/a&gt; provided by @emmby falls back in a per application ID as the SharedPreferences are not synchronized across processes (see &lt;a href=&quot;https://stackoverflow.com/a/4695567/281545&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/12430507/281545&quot;&gt;here&lt;/a&gt;). So I avoided this altogether.</source>
          <target state="translated">@emmby가 제공하는 &lt;a href=&quot;https://stackoverflow.com/a/5626208/281545&quot;&gt;솔루션&lt;/a&gt; 은 SharedPreferences가 프로세스간에 동기화되지 않기 때문에 응용 프로그램 ID별로 폴백합니다 ( &lt;a href=&quot;https://stackoverflow.com/a/4695567/281545&quot;&gt;여기&lt;/a&gt; 및 &lt;a href=&quot;https://stackoverflow.com/a/12430507/281545&quot;&gt;여기&lt;/a&gt; 참조). 그래서 나는 이것을 피했습니다.</target>
        </trans-unit>
        <trans-unit id="7b858ac6ee952c4e1c29dbed67542329a12e91ca" translate="yes" xml:space="preserve">
          <source>On some devices, it's not available when Wi-Fi is turned off.</source>
          <target state="translated">일부 기기에서는 Wi-Fi가 꺼져있을 때 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fea990c88823f6a996f794658a2b1f4a63161630" translate="yes" xml:space="preserve">
          <source>One thing I'll add - I have one of those unique situations.</source>
          <target state="translated">내가 추가 할 한 가지-나는 독특한 상황 중 하나를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0628d57a71956a4d436825b3621152ec1cdcb9" translate="yes" xml:space="preserve">
          <source>Overall breakdown with Android</source>
          <target state="translated">Android의 전반적인 고장</target>
        </trans-unit>
        <trans-unit id="d1d4f3a4b1a894473b73554723e896e7999c4e19" translate="yes" xml:space="preserve">
          <source>P.S.
Their are a bunch of other Interfaces you will get from the list containing MACS But this can change between phones.</source>
          <target state="translated">PS MACS가 포함 된 목록에서 얻을 수있는 다른 인터페이스들입니다. 그러나 이것은 전화기마다 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9438f2fced23130820e071328ec1f2bcf6199b7c" translate="yes" xml:space="preserve">
          <source>Permission:</source>
          <target state="translated">Permission:</target>
        </trans-unit>
        <trans-unit id="93f824548789ff13bb6d1d934795cc90b5617e43" translate="yes" xml:space="preserve">
          <source>Please take a look at the method below:</source>
          <target state="translated">아래 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="b9c68184369baf07c4fe98cf6d372fcfa66f85cb" translate="yes" xml:space="preserve">
          <source>Pseudo-Unique ID, that works on all Android devices
Some devices don't have a phone (eg. Tablets) or for some reason, you don't want to include the READ_PHONE_STATE permission. You can still read details like ROM Version, Manufacturer name, CPU type, and other hardware details, that will be well suited if you want to use the ID for a serial key check, or other general purposes. The ID computed in this way won't be unique: it is possible to find two devices with the same ID (based on the same hardware and ROM image) but the changes in real-world applications are negligible. For this purpose you can use the Build class:</source>
          <target state="translated">모든 Android 기기에서 작동하는 의사 고유 ID 일부 기기에는 휴대 전화 (예 : 태블릿)가 없거나 어떤 이유로 READ_PHONE_STATE 권한을 포함하고 싶지 않습니다. ROM 버전, 제조업체 이름, CPU 유형 및 기타 하드웨어 세부 사항과 같은 세부 사항을 계속 읽을 수 있습니다.이 세부 사항은 일련 키 확인 또는 기타 일반적인 목적으로 ID를 사용하려는 경우에 적합합니다. 이러한 방식으로 계산 된 ID는 고유하지 않습니다. 동일한 하드웨어 및 ROM 이미지를 기반으로 동일한 ID를 가진 두 개의 장치를 찾을 수 있지만 실제 응용 프로그램의 변경 사항은 무시할 수 있습니다. 이를 위해 Build 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="828b89426734a1dbf3d781b4c25ec7ed065cbe5d" translate="yes" xml:space="preserve">
          <source>Psuedo code:</source>
          <target state="translated">슈도 코드 :</target>
        </trans-unit>
        <trans-unit id="1ffe529de2ce9e48aa199df705c1bc6a92bf20fb" translate="yes" xml:space="preserve">
          <source>Released at I/O 2015; on Android requires play services 7.5.</source>
          <target state="translated">I / O 2015에서 발표; 안드로이드에서는 플레이 서비스 7.5가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6de6b60549f50e1d1cbaf1b29181768532c910e9" translate="yes" xml:space="preserve">
          <source>Removed 'Android.SECURE_ID' because of factory resets could cause the value to change</source>
          <target state="translated">초기화로 인해 'Android.SECURE_ID'가 제거되어 값이 변경 될 수 있음</target>
        </trans-unit>
        <trans-unit id="8270d4f261192696bb72cbe06c682b3f122e2a07" translate="yes" xml:space="preserve">
          <source>Reported to be available even when Wi-Fi is not connected. If Joe from the answer above gives this one a try on his many devices, that'd be nice.</source>
          <target state="translated">Wi-Fi가 연결되지 않은 경우에도 사용할 수 있다고보고되었습니다. 위의 답변에서 Joe 가이 장치를 많은 장치에서 사용해 볼 수 있다면 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="134114ca5240a5e4691dd1e37f4c5aa68fc6acc8" translate="yes" xml:space="preserve">
          <source>Requires permission &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; in the manifest.</source>
          <target state="translated">매니페스트에 &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ee4d3582f9c51303c6568490e833b1f95b0069fd" translate="yes" xml:space="preserve">
          <source>Samsung Galaxy S II</source>
          <target state="translated">삼성 갤럭시 S II</target>
        </trans-unit>
        <trans-unit id="5ce411708b005262ceb84b1c8eb166c785e758e8" translate="yes" xml:space="preserve">
          <source>Several devices by several manufacturers are affected by the ANDROID_ID bug in 2.2.</source>
          <target state="translated">여러 제조업체의 여러 장치가 2.2의 ANDROID_ID 버그의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="7e62cfb084266e44f02a7e371b4bd1adc044c427" translate="yes" xml:space="preserve">
          <source>Since it can be 'null', we can check for 'null' and change its value, but this means it will no longer be unique.</source>
          <target state="translated">'null'일 수 있으므로 'null'을 확인하고 값을 변경할 수 있지만 더 이상 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d920418d8f4614d4d0b63e82f9636375e140b2d6" translate="yes" xml:space="preserve">
          <source>Since you cannot have the desired static globally unique and reliable device identifier. Android's official reference suggest:</source>
          <target state="translated">원하는 정적 전역 고유하고 안정적인 장치 식별자를 가질 수 없기 때문입니다. 안드로이드의 공식 참조 제안 :</target>
        </trans-unit>
        <trans-unit id="cdcf5ddba809b2ba77d0382e19fc247a84923e08" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;don't use it either&lt;/strong&gt;.</source>
          <target state="translated">따라서 &lt;strong&gt;어느 것도 사용하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5e16899c26951bab23a1b9380b2fc33c3c1eaa76" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;if you're searching for a solution in 2020&lt;/strong&gt;.</source>
          <target state="translated">따라서 &lt;strong&gt;2020 년에 솔루션을 찾고 있다면&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e7777ad95f1578ad31f8994518a10746131c329c" translate="yes" xml:space="preserve">
          <source>So if you want something unique to the device itself, &lt;code&gt;TM.getDeviceId()&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; be sufficient.  Obviously some users are more paranoid than others, so it might be useful to hash 1 or more of these identifiers, so that the string is still virtually unique to the device, but does not explicitly identify the user's actual device.  For example, using &lt;code&gt;String.hashCode()&lt;/code&gt;, combined with a UUID:</source>
          <target state="translated">따라서 장치 자체에 고유 한 것을 &lt;code&gt;TM.getDeviceId()&lt;/code&gt; 이면 충분합니다. 분명히 일부 사용자는 다른 사용자보다 편집증이 많으므로 문자열이 실제로 장치에 고유하지만 사용자의 실제 장치를 명시 적으로 식별하지 않도록 이러한 식별자 중 하나 이상을 해시하는 것이 유용 할 수 있습니다. 예를 들어, UUID와 결합 된 &lt;code&gt;String.hashCode()&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="b4523d93c05eeae3b5f762c60fbb784c35c4eab3" translate="yes" xml:space="preserve">
          <source>So in simpler words: &lt;strong&gt;don't use those techniques&lt;/strong&gt;.</source>
          <target state="translated">더 간단한 말로, &lt;strong&gt;그 기술을 사용하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9ad052271e0186ed108ab51a2c5684a90c5a025a" translate="yes" xml:space="preserve">
          <source>Software</source>
          <target state="translated">Software</target>
        </trans-unit>
        <trans-unit id="824e115bb343a6c2b073c90b205c674541dede20" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;strong&gt;TelephonyManger.getDeviceId()&lt;/strong&gt; will return null, so to assure an unique id you will use this method:</source>
          <target state="translated">때때로 &lt;strong&gt;TelephonyManger.getDeviceId ()&lt;/strong&gt; 는 null을 반환하므로 고유 한 ID를 보장하기 위해이 메소드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa282f2cba151c130ce9452ee659d095a0527356" translate="yes" xml:space="preserve">
          <source>Thanks to @stansult for posting &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/9186943/950427&quot;&gt;all of our options&lt;/a&gt;&lt;/em&gt; (in this Stack Overflow question).</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/9186943/950427&quot;&gt;모든&lt;/a&gt;&lt;/em&gt; 스택 &lt;em&gt;옵션&lt;/em&gt; (이 스택 오버플로 질문)을 게시 해 주신 @stansult에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="9529b3a28c1cf43145ca418d76d36d8cf35abea2" translate="yes" xml:space="preserve">
          <source>That makes most of the answers above invalid. Also due to different android security updates, some of them require newer and stricter runtime permissions, which can be simply denied by user.</source>
          <target state="translated">위의 답변 대부분이 유효하지 않습니다. 또한 다양한 안드로이드 보안 업데이트로 인해 일부는 더 새롭고 더 엄격한 런타임 권한이 필요하며 이는 사용자가 간단하게 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e6856a55aeec398595efc5e505f103b1698374f" translate="yes" xml:space="preserve">
          <source>That makes those identifiers not only unreliable, but also unaccessible in many cases.</source>
          <target state="translated">따라서 이러한 식별자를 신뢰할 수 없을뿐만 아니라 많은 경우 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="905daa971c03007ead998008eca6fb60a27cff11" translate="yes" xml:space="preserve">
          <source>The best want to &lt;strong&gt;TRACK AN INDIVIDUAL USER&lt;/strong&gt; with their &lt;strong&gt;consent&lt;/strong&gt; is to simply have them login (make this seamless using OAuth)</source>
          <target state="translated">&lt;strong&gt;동의 한&lt;/strong&gt; &lt;strong&gt;개별 사용자&lt;/strong&gt; 를 &lt;strong&gt;추적&lt;/strong&gt; 하려는 가장 좋은 방법은 단순히 로그인을하는 것입니다 (OAuth를 사용하여 원활하게 작성).</target>
        </trans-unit>
        <trans-unit id="36bf022d28e15b55eb29741570cafc304868cddb" translate="yes" xml:space="preserve">
          <source>The following code returns the device serial number using a hidden Android API. But, this code don't works on Samsung Galaxy Tab because &quot;ro.serialno&quot; isn't set on this device.</source>
          <target state="translated">다음 코드는 숨겨진 Android API를 사용하여 장치 일련 번호를 반환합니다. 그러나이 코드는이 장치에서 &quot;ro.serialno&quot;가 설정되어 있지 않아 Samsung Galaxy Tab에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6577cebf8bae08c3eded7692e3648e217ceef6f" translate="yes" xml:space="preserve">
          <source>The following is an example of writing data to an &lt;em&gt;installation&lt;/em&gt; file that would be stored along with any other data the application saves locally.</source>
          <target state="translated">다음은 응용 프로그램이 로컬로 저장하는 다른 데이터와 함께 저장되는 &lt;em&gt;설치&lt;/em&gt; 파일에 데이터를 쓰는 예입니다.</target>
        </trans-unit>
        <trans-unit id="80fc7d27c0f1418901088d16652afa967d1415b3" translate="yes" xml:space="preserve">
          <source>The official Android Developers Blog now has a full article just about this very subject, &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Identifying App Installations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">공식 Android 개발자 블로그에는 이제 바로이 주제에 관한 전체 기사 인 &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;앱 설치 식별&lt;/a&gt;&lt;/em&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="074be9cec2bc29c9ee4c0e9dbb3fe0548fb0d38d" translate="yes" xml:space="preserve">
          <source>The unique device ID of an Android OS device as String, using &lt;code&gt;TelephonyManager&lt;/code&gt; and &lt;code&gt;ANDROID_ID&lt;/code&gt;, is obtained by:</source>
          <target state="translated">&lt;code&gt;TelephonyManager&lt;/code&gt; 및 &lt;code&gt;ANDROID_ID&lt;/code&gt; 를 사용하여 Android OS 디바이스의 고유 디바이스 ID (문자열)는 다음에 의해 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="bc09c662db608413c569349598f23d8b62ac1e78" translate="yes" xml:space="preserve">
          <source>Then you need to create the backup agent and tell it to use the helper agent for sharedpreferences:</source>
          <target state="translated">그런 다음 백업 에이전트를 작성하고 공유 환경 설정에 헬퍼 에이전트를 사용하도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="d8fc0f501e5874abfd9379770f3cee8f3c897aec" translate="yes" xml:space="preserve">
          <source>There are 30+ answers here and some are same and some are unique. This answer is based on few of those answers. One of them being @Lenn Dolling's answer.</source>
          <target state="translated">여기에 30 개 이상의 답변이 있으며 일부는 동일하고 일부는 독특합니다. 이 답변은 그 답변 중 일부를 기반으로합니다. 그중 하나는 @Len Dolling의 답변입니다.</target>
        </trans-unit>
        <trans-unit id="29056e3e33a93c541a24754b8c06e180ba1ae93d" translate="yes" xml:space="preserve">
          <source>There are a lot of different approaches to work around those &lt;code&gt;ANDROID_ID&lt;/code&gt; issues (may be &lt;code&gt;null&lt;/code&gt; sometimes or devices of a specific model always return the same ID) with pros and cons:</source>
          <target state="translated">장단점과 함께 &lt;code&gt;ANDROID_ID&lt;/code&gt; 문제를 해결하는 방법에는 여러 가지가 있습니다 (때로는 &lt;code&gt;null&lt;/code&gt; 이거나 특정 모델의 장치가 항상 동일한 ID를 반환 함).</target>
        </trans-unit>
        <trans-unit id="01ed028e38c624820207a524646c40ef83ca4867" translate="yes" xml:space="preserve">
          <source>There are many answers to this question, most of which will only work &quot;some&quot; of the time, and unfortunately that's not good enough.</source>
          <target state="translated">이 질문에 대한 많은 답변이 있으며, 대부분은 &quot;일부&quot;만 작동하지만 불행히도 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e201f88d418a41f759fed71d40f5ade63db27d32" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s rather useful info &lt;strong&gt;&lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;여기에&lt;/a&gt;&lt;/strong&gt; 유용한 정보가 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="562a763319bb1d2ce353484fa678f6b147833dd2" translate="yes" xml:space="preserve">
          <source>This User_ID will now be persistent across installations, even if the user moves device.</source>
          <target state="translated">이 User_ID는 이제 사용자가 장치를 이동하더라도 설치 전체에서 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="302601b1cc75faca7a1d398bd9ba7abf9898f8f1" translate="yes" xml:space="preserve">
          <source>This allows you to have an 'almost unique' ID from the user without taking anything that is private. You can create your own anonymous ID from device information.</source>
          <target state="translated">개인 정보를 사용하지 않고도 사용자로부터 '거의 고유 한'ID를 가질 수 있습니다. 장치 정보에서 자신의 익명 ID를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4bd714a0dd7483ee18a4fdbf629832954e33bdb" translate="yes" xml:space="preserve">
          <source>This approach will give you an anonymous, secure user ID which will be persistent for the user across different devices (based on the primary Google account) and across installs. The basic approach is to generate a random user ID and to store this in the apps' shared preferences. You then use Google's backup agent to store the shared preferences linked to the Google account in the cloud.</source>
          <target state="translated">이 방법을 사용하면 익명의 안전한 사용자 ID가 제공되며, 이는 기본 Google 계정을 기반으로하는 여러 기기 및 설치에서 사용자에게 지속됩니다. 기본 접근 방식은 임의의 사용자 ID를 생성하고이를 앱의 공유 환경 설정에 저장하는 것입니다. 그런 다음 Google 백업 에이전트를 사용하여 Google 계정에 연결된 공유 환경 설정을 클라우드에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9f50ac534bb8c59be341b2d0712eafda3bd4512a" translate="yes" xml:space="preserve">
          <source>This could be the second best option, but you are still collecting and storing a unique identifier that comes directly from a user. This is obvious that you are collecting data.</source>
          <target state="translated">이것은 두 번째 가장 좋은 옵션 일 수 있지만 여전히 사용자가 직접 제공하는 고유 식별자를 수집하여 저장하고 있습니다. 데이터를 수집하고 있음이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="a2e7b7e94544edb39f6971fe9517b25bad113277" translate="yes" xml:space="preserve">
          <source>To complete the backup you need to create an instance of BackupManager in your main Activity:</source>
          <target state="translated">백업을 완료하려면 기본 활동에서 BackupManager 인스턴스를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="13ab41a1d9198a55ef12f9d41d9d016266a0a92e" translate="yes" xml:space="preserve">
          <source>To do this in Java one would just use a FileInputStream to open the iSerial file and read out the characters. Just be sure you wrap it in an exception handler, because not all devices have this file.</source>
          <target state="translated">Java 에서이 작업을 수행하려면 FileInputStream을 사용하여 iSerial 파일을 열고 문자를 읽으십시오. 모든 장치에이 파일이있는 것은 아니기 때문에 예외 처리기로 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="b58b17f345f421d7ea4731213d42eb8ef4c1f87e" translate="yes" xml:space="preserve">
          <source>To understand the available Unique Ids in Android devices. Use this official guide.</source>
          <target state="translated">Android 기기에서 사용 가능한 고유 ID를 이해합니다. 이 공식 안내서를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3ebe8b4731cdde611da33593d1f3f3a78ae88a34" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;FirebaseInstanceId&lt;/code&gt; add the &lt;a href=&quot;https://firebase.google.com/support/release-notes/android#latest_sdk_versions&quot;&gt;latest firebase-messaging dependency&lt;/a&gt; into your gradle</source>
          <target state="translated">&lt;code&gt;FirebaseInstanceId&lt;/code&gt; 를 사용하려면 &lt;a href=&quot;https://firebase.google.com/support/release-notes/android#latest_sdk_versions&quot;&gt;최신&lt;/a&gt; firebase -messaging 종속성 을 gradle에 추가하십시오</target>
        </trans-unit>
        <trans-unit id="1f853b1bfb2a0e3a98db7409ef50f8db8efb056d" translate="yes" xml:space="preserve">
          <source>Today it's not only a best practice, you actually must to do it by law according to &lt;a href=&quot;https://gdpr.eu/eu-gdpr-personal-data/&quot;&gt;GDPR - identifiers&lt;/a&gt; and similar regulations.</source>
          <target state="translated">오늘날 그것은 모범 사례 일뿐 만 아니라 실제로 &lt;a href=&quot;https://gdpr.eu/eu-gdpr-personal-data/&quot;&gt;GDPR&lt;/a&gt; 에 따라 법에 따라해야 합니다-식별자 및 유사한 규정.</target>
        </trans-unit>
        <trans-unit id="68d47c10de20824156d87337e3f252405833a920" translate="yes" xml:space="preserve">
          <source>Toshiba AT300</source>
          <target state="translated">도시바 AT300</target>
        </trans-unit>
        <trans-unit id="45ccc2fea58a079a8f7060830d2466031b3a736e" translate="yes" xml:space="preserve">
          <source>Turns out that even though my Viewsonic G Tablet reports a DeviceID that is not Null, every single G Tablet reports the same number.</source>
          <target state="translated">Viewsonic G Tablet이 Null이 아닌 DeviceID를보고하더라도 모든 G Tablet은 모두 같은 숫자를보고합니다.</target>
        </trans-unit>
        <trans-unit id="9f1880d3d84b85c4d9d8a877ac7b0d41644b35ef" translate="yes" xml:space="preserve">
          <source>User could change email - HIGHLY unlikely</source>
          <target state="translated">사용자가 이메일을 변경할 수 있음-거의 없을 것</target>
        </trans-unit>
        <trans-unit id="ce1e8bd228fc7c368c4c0db36b399db47b4e3058" translate="yes" xml:space="preserve">
          <source>Users can change their hardware, Android tablet or phone, so unique IDs based on hardware are not good ideas for &lt;strong&gt;TRACKING USERS&lt;/strong&gt;</source>
          <target state="translated">사용자는 하드웨어, Android 태블릿 또는 휴대 전화를 변경할 수 있으므로 하드웨어를 기반으로하는 고유 ID는 &lt;strong&gt;추적 사용자&lt;/strong&gt; 에게 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8dcf78b4b2188b958880e49748a252aefba98c7e" translate="yes" xml:space="preserve">
          <source>Users can wipe/change their ROM if they are rooted</source>
          <target state="translated">사용자가 루팅 된 경우 ROM을 지우거나 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e7eb67e2f0bd5ad6aae1393f7bce212f2e980fe6" translate="yes" xml:space="preserve">
          <source>Users could change phone numbers - HIGHLY unlikely</source>
          <target state="translated">사용자가 전화 번호를 변경할 수 있음-거의 없을 것</target>
        </trans-unit>
        <trans-unit id="3f6ae3a6aaf32da958424d244bb3083082ba470d" translate="yes" xml:space="preserve">
          <source>Using the code below, you can get the unique device ID of an Android OS device as a string.</source>
          <target state="translated">아래 코드를 사용하면 Android OS 기기의 고유 기기 ID를 문자열로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b960faa3ac35c8978dd66d8ba117ea264270677" translate="yes" xml:space="preserve">
          <source>Using:</source>
          <target state="translated">Using:</target>
        </trans-unit>
        <trans-unit id="374831e7e5ef5c7511cef96a4ee5925588f2e76c" translate="yes" xml:space="preserve">
          <source>Very possible, may contain collisions - See my method posted below!</source>
          <target state="translated">매우 가능하며 충돌이있을 수 있습니다-아래에 게시 된 내 방법을 참조하십시오!</target>
        </trans-unit>
        <trans-unit id="591e68bf2b0c7304e63142b9d6a9d22e41a8c1dd" translate="yes" xml:space="preserve">
          <source>Warning, users can reset:</source>
          <target state="translated">경고, 사용자는 다음을 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a15f5d49c1738f4d1b8b8a0f1122ca9168c573" translate="yes" xml:space="preserve">
          <source>With a pseudo-unique id, you really only run into the fact that there may be duplicates based on the fact that there are similar devices. You can tweak the combined method to make it more unique; however, some developers need to track device installs and this will do the trick or performance based on similar devices.</source>
          <target state="translated">의사 고유 ID를 사용하면 유사한 장치가 있다는 사실에 따라 중복이있을 수 있다는 사실 만 알게됩니다. 결합 된 방법을 조정하여 더 고유하게 만들 수 있습니다. 그러나 일부 개발자는 장치 설치를 추적해야하며 유사한 장치를 기반으로 트릭이나 성능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="84f20f82be25d2fdf6c2dd296bacc22769b6a570" translate="yes" xml:space="preserve">
          <source>You can also see my blog post &lt;em&gt;&lt;a href=&quot;http://insitusec.blogspot.com/2013/01/leaking-android-hardware-serial-number.html&quot;&gt;Leaking Android hardware serial number to unprivileged apps&lt;/a&gt;&lt;/em&gt; where I discuss what other files are available for information.</source>
          <target state="translated">또한 내 블로그 게시물 &lt;em&gt;&lt;a href=&quot;http://insitusec.blogspot.com/2013/01/leaking-android-hardware-serial-number.html&quot;&gt;권한이없는 앱에 Android 하드웨어 일련 번호 누출&lt;/a&gt;&lt;/em&gt; 정보를 제공하는 다른 파일에 대해 논의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d9deceaffad86d123cd0bee2083628aeef9feb" translate="yes" xml:space="preserve">
          <source>You can track users across platforms (iOS, Android, Windows, and Web)</source>
          <target state="translated">여러 플랫폼 (iOS, Android, Windows 및 웹)에서 사용자를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379004bd3f37392fadc9d014330f1a47f898b470" translate="yes" xml:space="preserve">
          <source>import libs</source>
          <target state="translated">라이브러리 가져 오기</target>
        </trans-unit>
        <trans-unit id="3fcb64d53ad87994fc0bcbc5f34fea67765a96ca" translate="yes" xml:space="preserve">
          <source>in AndroidManifest.xml</source>
          <target state="translated">AndroidManifest.xml에서</target>
        </trans-unit>
        <trans-unit id="0f70d4331be095195b9db0d315b40035a3f6c635" translate="yes" xml:space="preserve">
          <source>might result in something like: &lt;code&gt;00000000-54b3-e7c7-0000-000046bffd97&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;00000000-54b3-e7c7-0000-000046bffd97&lt;/code&gt; 과 같은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec4d23caadb883c263af5bd03cdfe1bc2b9b9c0e" translate="yes" xml:space="preserve">
          <source>now in your code:</source>
          <target state="translated">지금 당신의 코드에서 :</target>
        </trans-unit>
        <trans-unit id="88cc1dabe4fc988630e5d8d02389533e0523b9c6" translate="yes" xml:space="preserve">
          <source>you can do it that way:</source>
          <target state="translated">당신은 그렇게 할 수 있습니다 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
