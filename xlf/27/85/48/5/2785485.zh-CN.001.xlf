<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2785485">
    <body>
      <group id="2785485">
        <trans-unit id="b181b1b9d0c086707ac87cdae3439b4b938c3820" translate="yes" xml:space="preserve">
          <source>(Extra info: The technique given above was copied from an article on &lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;Pocket Magic&lt;/a&gt;.)</source>
          <target state="translated">（额外信息：以上给出的技术是从&lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;Pocket Magic&lt;/a&gt;上的一篇文章中复制的。）</target>
        </trans-unit>
        <trans-unit id="f46132bef288a5dfab4aa74662227d9af6352df6" translate="yes" xml:space="preserve">
          <source>- Guarantee uniqueness (include rooted devices) for API &amp;gt;= 9/10 (99.5% of Android devices)</source>
          <target state="translated">-保证API&amp;gt; = 9/10的唯一性（包括根设备）（占Android设备的99.5％）</target>
        </trans-unit>
        <trans-unit id="64a8a656b27e5414def3b68719d22dbd0722b3fe" translate="yes" xml:space="preserve">
          <source>- No extra permissions</source>
          <target state="translated">-无额外权限</target>
        </trans-unit>
        <trans-unit id="3dbcc62d78a806b5dd67ba63ab7e0076a5dee116" translate="yes" xml:space="preserve">
          <source>3 IDs are:</source>
          <target state="translated">3个身份证是:</target>
        </trans-unit>
        <trans-unit id="24308b13f274d9b2b66681dadbb1969845233a3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.android.com/google/play-services/id.html&quot;&gt;http://developer.android.com/google/play-services/id.html&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&quot;&gt;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/google/play-services/id.html&quot;&gt;http://developer.android.com/google/play-services/id.html&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&quot;&gt;http://developer.android.com/reference/com/google/android/gms/ads/identifier/AdvertisingIdClient.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aad57647718e1189a9ca068c1268dc9b89e9426f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt;&lt;code&gt;Settings.Secure#ANDROID_ID&lt;/code&gt;&lt;/a&gt; returns the Android ID as an &lt;em&gt;&lt;a href=&quot;https://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt;unique for each user&lt;/a&gt;&lt;/em&gt; 64-bit hex string.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt; &lt;code&gt;Settings.Secure#ANDROID_ID&lt;/code&gt; &lt;/a&gt; &lt;em&gt;&lt;a href=&quot;https://developer.android.com/reference/android/provider/Settings.Secure.html#ANDROID_ID&quot;&gt;以每个用户&lt;/a&gt;&lt;/em&gt; 64位十六进制字符串的&lt;em&gt;唯一&lt;/em&gt;身份返回Android ID。</target>
        </trans-unit>
        <trans-unit id="e220c504ed1a53f66958d05ced7b441afe39b2ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANDROID_ID&lt;/code&gt; seems a good choice for a unique device identifier. There are downsides: First, it is not 100% reliable on releases of Android prior to 2.2 &lt;code&gt;(&amp;ldquo;Froyo&amp;rdquo;).&lt;/code&gt; Also, there has been at least one widely-observed bug in a popular handset from a major manufacturer, where every instance has the same ANDROID_ID.</source>
          <target state="translated">对于唯一的设备标识符， &lt;code&gt;ANDROID_ID&lt;/code&gt; 似乎是一个不错的选择。 有缺点：首先，在2.2之前的Android版本 &lt;code&gt;(&amp;ldquo;Froyo&amp;rdquo;).&lt;/code&gt; 上，它不是100％可靠的。 而且，在一家主要制造商的流行手机中，至少有一个广为人知的错误，其中每个实例都具有相同的ANDROID_ID。</target>
        </trans-unit>
        <trans-unit id="2a7ecef876d978aff21a723a463c8cce70f74986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ANDROID_ID&lt;/strong&gt; - &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;ANDROID_ID&lt;/strong&gt; - &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea50d53bb38b142bacc83d97cb9a3172bd16f9e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android ID - Hardware&lt;/strong&gt; (can be null, can change upon factory reset, can be altered on a rooted device)</source>
          <target state="translated">&lt;strong&gt;Android ID-硬件&lt;/strong&gt; （可以为空，可以在恢复出厂设置时更改，可以在有根设备上更改）</target>
        </trans-unit>
        <trans-unit id="8db07429bf3578e05973ce8664b1a9bb4287d884" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android ID&lt;/strong&gt; (can be null, can change upon factory reset, can be altered on rooted phone)</source>
          <target state="translated">&lt;strong&gt;Android ID&lt;/strong&gt; （可以为空，可以在恢复出厂设置时更改，可以在有根电话上更改）</target>
        </trans-unit>
        <trans-unit id="b44abe0e3872a3ddf088098375b5b0ae4112d430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid using hardware identifiers&lt;/strong&gt;, such as SSAID (Android ID), IMEI, MAC address, etc...</source>
          <target state="translated">&lt;strong&gt;避免使用硬件标识符&lt;/strong&gt; ，例如SSAID（Android ID），IMEI，MAC地址等。</target>
        </trans-unit>
        <trans-unit id="c8d538e3ef150d20979c342b78b601121605b217" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BT MAC Address&lt;/strong&gt; string (devices with Bluetooth, needs &lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;BT MAC地址&lt;/strong&gt;字符串（具有蓝牙的设备，需要 &lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="bafd04e528102e85d4eeba4b49e7e6ebeeec8fb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practices for unique identifiers:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;唯一标识符的最佳做法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecd8905c7608c04bb17e1494f7f8edfc6c13ec35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bluetooth Address&lt;/strong&gt; - Bluetooth adapter address</source>
          <target state="translated">&lt;strong&gt;蓝牙地址&lt;/strong&gt; -蓝牙适配器地址</target>
        </trans-unit>
        <trans-unit id="45d48748303dd882fbebc79403ba709067aa415c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bluetooth MAC Address - Hardware&lt;/strong&gt; (devices with Bluetooth, needs &lt;strong&gt;&lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;蓝牙MAC地址-硬件&lt;/strong&gt; （带有蓝牙的设备，需要&lt;strong&gt; &lt;code&gt;android.permission.BLUETOOTH&lt;/code&gt; &lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="411c38caf68a6ed824124e24cd4675443673ecf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From the Google Play Developer's console:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在Google Play开发者控制台中：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="957809252710cee9969716976cc2c3db8defd64a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Google Instance ID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Google实例ID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab8e6abb67f419400f610c6784d884532f8e22fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMEI - Hardware&lt;/strong&gt; (only phones, needs &lt;strong&gt;&lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;IMEI-硬件&lt;/strong&gt; （仅手机，需要&lt;strong&gt; &lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt; &lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="ade3c7f4182c7dcfa5ef96877cdd5eaca6556b53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMEI&lt;/strong&gt; (only for Android devices with Phone use; needs &lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;IMEI&lt;/strong&gt; （仅适用于使用Phone的Android设备；需要 &lt;code&gt;android.permission.READ_PHONE_STATE&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f83425a65c1c8ba0f03466a55d7707c4f2fa69f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implementation&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Implementation&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="962b31d714025ad16d50eaddcc6f19a63d8d2d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; From Android 6.x, it returns consistent fake mac address: &lt;code&gt;02:00:00:00:00:00&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;从Android 6.x，它将返回一致的假MAC地址： &lt;code&gt;02:00:00:00:00:00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba920baef2e1d3c3aa47f6f7d2ad1446698b61b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only use an Advertising ID for user profiling or ads use cases&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;仅将广告ID用于用户配置文件或广告用例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d109d7d27f4b7602674fb5784993cbe1455bc34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudo-ID&lt;/strong&gt; - It is generated based on physical device specifications</source>
          <target state="translated">&lt;strong&gt;伪ID-&lt;/strong&gt;根据物理设备规范生成</target>
        </trans-unit>
        <trans-unit id="815a9883ed04b839e75540b14a9029833584eabe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudo-Unique ID - Software&lt;/strong&gt; (for all Android devices)</source>
          <target state="translated">&lt;strong&gt;伪唯一ID-软件&lt;/strong&gt; （适用于所有Android设备）</target>
        </trans-unit>
        <trans-unit id="562a2ba67fe226b4583a2412fbc3121061de8f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudo-Unique ID&lt;/strong&gt; (for all Android devices)</source>
          <target state="translated">&lt;strong&gt;伪唯一ID&lt;/strong&gt; （适用于所有Android设备）</target>
        </trans-unit>
        <trans-unit id="3fd7c31e3b7b82748b721e9ea087cfb28bb8a87c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REMEMBER&lt;/strong&gt;, you are technically only missing out on around 0.5% of users &lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;who have API &amp;lt; 9&lt;/a&gt;. So you can focus on the rest: This is 99.5% of the users!</source>
          <target state="translated">&lt;strong&gt;请记住&lt;/strong&gt; ，从技术上讲，您仅会错过大约0.5％的&lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;API &amp;lt;9&lt;/a&gt;用户。 因此，您可以专注于其余部分：这是99.5％的用户！</target>
        </trans-unit>
        <trans-unit id="1f5e9d463b8f8c18af8677bb343915a7bfe86673" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Settings.Secure.ANDROID_ID&lt;/strong&gt; that returns the Android ID as an unique 64-bit hex string.</source>
          <target state="translated">&lt;strong&gt;Settings.Secure.ANDROID_ID&lt;/strong&gt; ，以唯一的64位十六进制字符串形式返回Android ID。</target>
        </trans-unit>
        <trans-unit id="80eef0df3a09d650af671812b11c019ca7ae0159" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source/Docs:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Source/Docs:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15790c02e5af662271cb875986ccd5a65911222a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TelephonyManger.getDeviceId()&lt;/strong&gt; Returns the unique device ID, for example, the IMEI for GSM and the MEID or ESN for CDMA phones.</source>
          <target state="translated">&lt;strong&gt;TelephonyManger.getDeviceId（）&lt;/strong&gt;返回唯一的设备ID，例如，GSM的IMEI和CDMA电话的MEID或ESN。</target>
        </trans-unit>
        <trans-unit id="aa2405819ce2f56f35d257d203c19d30a9159b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The advantages of instance ID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;实例ID的优点&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d042742c0ce55d371e0baed1452d826e2d0af521" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages/issues&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;缺点/问题&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f7e9b35e6804a6b024cdee61b803053446c2cd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;: As of recent versions of Android, many of the issues with &lt;code&gt;ANDROID_ID&lt;/code&gt; have been resolved, and I believe this approach is no longer necessary. Please take a look at &lt;a href=&quot;https://stackoverflow.com/a/2785493/231078&quot;&gt;Anthony's answer&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt; ：从Android的最新版本开始， &lt;code&gt;ANDROID_ID&lt;/code&gt; 的许多问题已解决，我相信不再需要这种方法。 请看一下&lt;a href=&quot;https://stackoverflow.com/a/2785493/231078&quot;&gt;安东尼的回答&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d0b195c6490ecf8258b68c44ba7edb801668ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use a FirebaseInstanceId or a privately stored GUID&lt;/strong&gt; whenever possible for all other use cases, except for payment fraud prevention and telephony.</source>
          <target state="translated">对于所有其他用例，请尽可能&lt;strong&gt;使用FirebaseInstanceId或私有存储的GUID&lt;/strong&gt; ，但要防止付款欺诈和电话。</target>
        </trans-unit>
        <trans-unit id="b2e9748d24580165cbb22e2726f522e8b890e0b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;User Email - Software&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;用户电子邮件-软件&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b795ef3d501d5a65ec77a93fb104d3f775a17b7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;User Phone Number - Software&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;用户电话号码-软件&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6199e99727aa312214a0a51a948a3a4853b9ba6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WLAN MAC Address - Hardware&lt;/strong&gt; (needs &lt;strong&gt;&lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;WLAN MAC地址-硬件&lt;/strong&gt; （需要&lt;strong&gt; &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; &lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="d78239e458e5232305215bdb49433ff53b4c162a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WLAN MAC Address&lt;/strong&gt; string (needs &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;WLAN MAC地址&lt;/strong&gt;字符串（需要 &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ebdbf7280232433bb44ce8df29850d11f2652d33" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://developer.android.com/reference/android/os/Build.html#SERIAL&quot;&gt;Serial&lt;/a&gt; field was added to the &lt;code&gt;Build&lt;/code&gt; class in API level 9 (Android 2.3 - Gingerbread). Documentation says it represents the hardware serial number. Thus it should be unique, if it exists on the device.</source>
          <target state="translated">在API级别9（Android 2.3-Gingerbread）中，将&amp;ldquo; &lt;a href=&quot;http://developer.android.com/reference/android/os/Build.html#SERIAL&quot;&gt;序列&amp;rdquo;&lt;/a&gt;字段添加到了 &lt;code&gt;Build&lt;/code&gt; 类。 文档说它代表硬件序列号。 因此，如果设备上存在它，则它应该是唯一的。</target>
        </trans-unit>
        <trans-unit id="6b4a06b5ef830134d9fec0ddd03fca8e9d484bb1" translate="yes" xml:space="preserve">
          <source>ANDROID_ID is the preferred device identifier.  ANDROID_ID is perfectly reliable on versions of Android &amp;lt;=2.1 or &amp;gt;=2.3.  Only 2.2 has the problems mentioned in the post.</source>
          <target state="translated">ANDROID_ID是首选的设备标识符。 ANDROID_ID在Android &amp;lt;= 2.1或&amp;gt; = 2.3的版本上完全可靠。 只有2.2具有帖子中提到的问题。</target>
        </trans-unit>
        <trans-unit id="68aa9980fe376e4905566c98ee670984dbe45080" translate="yes" xml:space="preserve">
          <source>API &amp;gt;= 9:</source>
          <target state="translated">API&amp;gt; = 9：</target>
        </trans-unit>
        <trans-unit id="29a897557ef6d56f7d7d648fcaddf92743c494e5" translate="yes" xml:space="preserve">
          <source>API &amp;lt; 9:</source>
          <target state="translated">API &amp;lt;9：</target>
        </trans-unit>
        <trans-unit id="f0bdeaf0b89418308e592d0083e5b065f0e07b91" translate="yes" xml:space="preserve">
          <source>API 14+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_PROFILE&quot; /&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&amp;gt;&lt;/code&gt; (&lt;a href=&quot;https://stackoverflow.com/questions/2112965/how-to-get-the-android-devices-primary-e-mail-address&quot;&gt;How to get the Android device's primary e-mail address&lt;/a&gt;)</source>
          <target state="translated">API 14+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_PROFILE&quot; /&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&amp;gt;&lt;/code&gt; （ &lt;a href=&quot;https://stackoverflow.com/questions/2112965/how-to-get-the-android-devices-primary-e-mail-address&quot;&gt;如何获取Android设备的主要电子邮件地址&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="a41b24d1a450d71fe88f28c02825ff387777023d" translate="yes" xml:space="preserve">
          <source>API 5+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&amp;gt;&lt;/code&gt; or</source>
          <target state="translated">API 5+ &lt;code&gt;&amp;lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&amp;gt;&lt;/code&gt; 或</target>
        </trans-unit>
        <trans-unit id="89b151af4a909f2db1de25b74e9195a4ef188176" translate="yes" xml:space="preserve">
          <source>Abusing other IDs like &lt;a href=&quot;https://en.wikipedia.org/wiki/International_Mobile_Station_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt;, serial number, Wi-Fi/Bluetooth-MAC address (they won't exist on all devices or additional permissions become necessary)</source>
          <target state="translated">滥用其他ID，例如&lt;a href=&quot;https://en.wikipedia.org/wiki/International_Mobile_Station_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt; ，序列号，Wi-Fi /蓝牙MAC地址（它们不会在所有设备上都存在，或者需要其他权限）</target>
        </trans-unit>
        <trans-unit id="c12f5ec035062f96ae0b0e2215e9dbc890a13231" translate="yes" xml:space="preserve">
          <source>Add Below code in class file:</source>
          <target state="translated">在类文件中添加下面的代码。</target>
        </trans-unit>
        <trans-unit id="0e30f5508581eb8326f00fd68d87f89e0c275a2f" translate="yes" xml:space="preserve">
          <source>Add in AndroidManifest.xml:</source>
          <target state="translated">添加到AndroidManifest.xml中。</target>
        </trans-unit>
        <trans-unit id="2c199c5dde5288a035f4af10d6f11a0e368ca3e5" translate="yes" xml:space="preserve">
          <source>After reading every Stack Overflow post about creating a unique ID, the Google developer blog and Android documentation, I feel as if the 'Pseudo ID' is the best possible option.</source>
          <target state="translated">在阅读了每一篇关于创建唯一ID的Stack Overflow帖子、Google开发者博客和Android文档后,我觉得 &quot;伪ID &quot;是最好的选择。</target>
        </trans-unit>
        <trans-unit id="c3e749475078b1c951d38bbbc94315254d2f3009" translate="yes" xml:space="preserve">
          <source>Again, this code is for a device ID, not an app installation ID.  For most situations, an app installation ID is probably what you're looking for.  But if you do need a device ID, then the following code will probably work for you.</source>
          <target state="translated">同样,这个代码是针对设备ID,而不是应用安装ID。在大多数情况下,你需要的可能是一个应用安装ID。但如果你需要一个设备ID,那么下面的代码可能对你有用。</target>
        </trans-unit>
        <trans-unit id="5a92c69287df1de09fcce1814c08b09a18e1c16d" translate="yes" xml:space="preserve">
          <source>All CDMA devices returned null for &lt;code&gt;getSimSerialNumber()&lt;/code&gt; (as expected)</source>
          <target state="translated">所有CDMA设备的 &lt;code&gt;getSimSerialNumber()&lt;/code&gt; 返回null（按预期方式）</target>
        </trans-unit>
        <trans-unit id="72ac9336052e7432124e824524b2a7f0e7906d72" translate="yes" xml:space="preserve">
          <source>All CDMA devices returned the same value (or derivation of the same value) for both &lt;code&gt;ANDROID_ID&lt;/code&gt; and &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt; -- &lt;em&gt;as long as&lt;/em&gt; a Google account has been added during setup.</source>
          <target state="translated">所有CDMA设备对于 &lt;code&gt;ANDROID_ID&lt;/code&gt; 和 &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt; 都返回相同的值（或得出相同的值） - &lt;em&gt;只要&lt;/em&gt;在安装过程中添加了Google帐户即可。</target>
        </trans-unit>
        <trans-unit id="2dd555f826a536eccab4f888bde32943a6a65c01" translate="yes" xml:space="preserve">
          <source>All GSM devices (all tested with a SIM) returned a value for &lt;code&gt;TelephonyManager.getSimSerialNumber()&lt;/code&gt;</source>
          <target state="translated">所有GSM设备（均已通过SIM测试）均返回 &lt;code&gt;TelephonyManager.getSimSerialNumber()&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="82968c3a33493da4908421d9d3916cd2a050b103" translate="yes" xml:space="preserve">
          <source>All devices tested returned a value for &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt;</source>
          <target state="translated">所有测试的设备均返回 &lt;code&gt;TelephonyManager.getDeviceId()&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="82a207f42b5d4fa46e41089bee741f31f1ace78b" translate="yes" xml:space="preserve">
          <source>All devices with a Google account added returned a value for &lt;code&gt;ANDROID_ID&lt;/code&gt;</source>
          <target state="translated">所有添加了Google帐户的设备都返回了 &lt;code&gt;ANDROID_ID&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="9e2a6399aef2e6af31c0bc620b1b6d8c81bf7654" translate="yes" xml:space="preserve">
          <source>All the hardware based identifiers (SSAID, IMEI, MAC, etc) are unreliable for non-google's devices (Everything except Pixels and Nexuses), which are more than 50% of active devices worldwide. Therefore official &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;Android identifiers best practices&lt;/a&gt; clearly states:</source>
          <target state="translated">所有基于硬件的标识符（SSAID，IMEI，MAC等）对于非Google的设备（除Pixels和Nexus以外的所有设备）都不可靠，这些设备占全球活动设备的50％以上。 因此，官方&lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;Android标识符最佳做法&lt;/a&gt;明确指出：</target>
        </trans-unit>
        <trans-unit id="1b721bff82659fe3b5c324c29d407b7ffd71e37e" translate="yes" xml:space="preserve">
          <source>Also you might consider the Wi-Fi adapter's MAC address. Retrieved thusly:</source>
          <target state="translated">另外,你可以考虑Wi-Fi适配器的MAC地址。这样检索到的。</target>
        </trans-unit>
        <trans-unit id="0384ddde4f6c46d85c48c9f0e81874ca1cb837a8" translate="yes" xml:space="preserve">
          <source>And for full details of how to implement the backup agent see &lt;em&gt;&lt;a href=&quot;http://developer.android.com/guide/topics/data/backup.html&quot;&gt;Data Backup&lt;/a&gt;&lt;/em&gt;. I particularly recommend the section at the bottom on testing as the backup does not happen instantaneously and so to test you have to force the backup.</source>
          <target state="translated">有关如何实施备份代理的完整详细信息，请参见&lt;em&gt;&lt;a href=&quot;http://developer.android.com/guide/topics/data/backup.html&quot;&gt;数据备份&lt;/a&gt;&lt;/em&gt; 。 我特别推荐测试底部的部分，因为备份不会立即发生，因此要进行测试，您必须强制执行备份。</target>
        </trans-unit>
        <trans-unit id="287d37fcbbd0b457575f30632d52a2581be37066" translate="yes" xml:space="preserve">
          <source>And use the code below in a background thread:</source>
          <target state="translated">并在背景线程中使用下面的代码。</target>
        </trans-unit>
        <trans-unit id="a2ff67e89682f23c7d347c28c1e4eb8cef1210bf" translate="yes" xml:space="preserve">
          <source>Another way is to use &lt;code&gt;/sys/class/android_usb/android0/iSerial&lt;/code&gt; in an app without any permissions whatsoever.</source>
          <target state="translated">另一种方法是在没有任何许可的情况下在应用程序中使用 &lt;code&gt;/sys/class/android_usb/android0/iSerial&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15316009acf564b5ec5c638dfc827a10d8ab311c" translate="yes" xml:space="preserve">
          <source>As Dave Webb mentions, the &lt;a href=&quot;https://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android Developer Blog has an article&lt;/a&gt; that covers this.  Their preferred solution is to track app installs rather than devices, and that will work well for most use cases.  The blog post will show you the necessary code to make that work, and I recommend you check it out.</source>
          <target state="translated">正如Dave Webb所提到的， &lt;a href=&quot;https://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android开发者博客上有一篇文章&lt;/a&gt;对此进行了介绍。 他们的首选解决方案是跟踪应用安装而不是设备，并且在大多数用例中都可以很好地工作。 博客文章将向您显示完成该工作所需的代码，我建议您检查一下。</target>
        </trans-unit>
        <trans-unit id="e7798ee7e23de9bd2dfada829db8987b37fcd47f" translate="yes" xml:space="preserve">
          <source>As Richard mentions below, don't forget that you need permission to read the &lt;code&gt;TelephonyManager&lt;/code&gt; properties, so add this to your manifest:</source>
          <target state="translated">正如Richard在下面提到的那样，请不要忘记您需要阅读 &lt;code&gt;TelephonyManager&lt;/code&gt; 属性的权限，因此请将其添加到清单中：</target>
        </trans-unit>
        <trans-unit id="a2123c71994da4ed1f169f9aa935b0767903ddce" translate="yes" xml:space="preserve">
          <source>As example &lt;code&gt;CVE-2018-9489&lt;/code&gt; which affects all the WIFI based techniques mentioned above.</source>
          <target state="translated">作为示例 &lt;code&gt;CVE-2018-9489&lt;/code&gt; ，它会影响上述所有基于WIFI的技术。</target>
        </trans-unit>
        <trans-unit id="82e65ec7745c482ede932c1bda8de37db0c79df5" translate="yes" xml:space="preserve">
          <source>As far as I've been able to determine, all affected devices have &lt;a href=&quot;https://issuetracker.google.com/issues/36920653&quot;&gt;the same ANDROID_ID&lt;/a&gt;, which is &lt;a href=&quot;https://www.google.com/search?sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;q=9774d56d682e549c&quot;&gt;9774d56d682e549c&lt;/a&gt;.  Which is also the same device id reported by the emulator, btw.</source>
          <target state="translated">据我所确定，所有受影响的设备都具有&lt;a href=&quot;https://issuetracker.google.com/issues/36920653&quot;&gt;相同的ANDROID_ID&lt;/a&gt; ，即&lt;a href=&quot;https://www.google.com/search?sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;q=9774d56d682e549c&quot;&gt;9774d56d682e549c&lt;/a&gt; 。 这也是模拟器报告的相同设备ID，btw。</target>
        </trans-unit>
        <trans-unit id="60dc22dc2be6b68254c05392e8b934f87a0ef9f0" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I/O&lt;/a&gt; Reto Meier released a robust answer to how to approach this which should meet most developers needs to track users across installations. Anthony Nolan shows the direction in his answer, but I thought I'd write out the full approach so that others can easily see how to do it (it took me a while to figure out the details).</source>
          <target state="translated">Reto Meier在&lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I / O上&lt;/a&gt;发布了一个强有力的答案，说明了如何解决此问题，这应满足大多数开发人员跟踪安装之间用户的需求。 安东尼&amp;middot;诺兰（Anthony Nolan）在回答中指明了方向，但我认为我应该写出完整的方法，以便其他人可以轻松地了解如何做到这一点（花了我一段时间才弄清楚细节）。</target>
        </trans-unit>
        <trans-unit id="bc88674eb70c904f011dc5ee3fb4f27aba9862f2" translate="yes" xml:space="preserve">
          <source>At least the following devices are known to have this file world-readable:</source>
          <target state="translated">已知至少有以下设备具有该文件的世界可读性。</target>
        </trans-unit>
        <trans-unit id="b831a6047597da45c8ebb40fb3b3f371f45a7ca5" translate="yes" xml:space="preserve">
          <source>Based on Google's recommendations, I implemented a class that will generate a unique UUID for each device, using ANDROID_ID as the seed where appropriate, falling back on TelephonyManager.getDeviceId() as necessary, and if that fails, resorting to a randomly generated unique UUID that is persisted across app restarts (but not app re-installations).</source>
          <target state="translated">根据Google的建议,我实现了一个类,它将为每个设备生成一个唯一的UUUID,在适当的情况下使用ANDROID_ID作为种子,必要时返回到TelephonyManager.getDeviceId(),如果失败,则采用随机生成的唯一UUUID,该UUUID将在应用程序重启时持久化(但不是应用程序重装)。</target>
        </trans-unit>
        <trans-unit id="ce0e5f8df217bf7f4b4bc0e5b9db109dc4e72700" translate="yes" xml:space="preserve">
          <source>Based on my tests of devices (all phones, at least one of which is not activated):</source>
          <target state="translated">根据我对设备的测试(所有的手机,至少有一部没有激活)。</target>
        </trans-unit>
        <trans-unit id="4a41bd95f5fe6b7b904cbf8306ccd3f50f598759" translate="yes" xml:space="preserve">
          <source>Beginning August 1st, 2014, the Google Play Developer Program Policy
  requires all new app uploads and updates to use the advertising ID in
  lieu of any other persistent identifiers for any advertising purposes.
  Learn more</source>
          <target state="translated">从2014年8月1日开始,Google Play开发者计划政策要求所有新上传和更新的应用都必须使用广告ID代替任何其他持久性标识符用于任何广告目的。了解更多</target>
        </trans-unit>
        <trans-unit id="5551d514845c47662940105033550cdb6568d20e" translate="yes" xml:space="preserve">
          <source>But I strongly recommend a method suggested by Google, see &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.mx/2011/03/identifying-app-installations.html&quot;&gt;Identifying App Installations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">但我强烈建议Google建议一种方法，请参阅&lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.mx/2011/03/identifying-app-installations.html&quot;&gt;识别应用程序安装&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1190cce9e57205b886e4861b18c71cf98724858" translate="yes" xml:space="preserve">
          <source>But i recommend to use:</source>
          <target state="translated">但我推荐使用。</target>
        </trans-unit>
        <trans-unit id="e4f0c2ef1b6ba41d408d174704493fdeecddd1f5" translate="yes" xml:space="preserve">
          <source>Changed the Pseudo</source>
          <target state="translated">改变了伪装</target>
        </trans-unit>
        <trans-unit id="d797b89f3211afa4ec1e56bf65e028e8ed315137" translate="yes" xml:space="preserve">
          <source>Changes:</source>
          <target state="translated">Changes:</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="b3faa22d95bd029d5e8eb421fac2504f3d17d490" translate="yes" xml:space="preserve">
          <source>Do Android devices have a unique ID, and if so, what is a simple way to access it using Java?</source>
          <target state="translated">安卓设备是否有唯一的ID,如果有,有什么简单的方法可以用Java访问?</target>
        </trans-unit>
        <trans-unit id="ee4b6d17a79863a088ad5f4cb3971a3a274cea1b" translate="yes" xml:space="preserve">
          <source>Edited the code to change on API</source>
          <target state="translated">编辑了代码,在API上进行修改</target>
        </trans-unit>
        <trans-unit id="81d8557b9b477cf320e57ebec08f61219c93cad4" translate="yes" xml:space="preserve">
          <source>Finally create a user ID, if it doesn't already exist, and store it in the SharedPreferences:</source>
          <target state="translated">最后创建一个用户ID,如果还不存在的话,就创建一个用户ID,并将其存储在SharedPreferences中。</target>
        </trans-unit>
        <trans-unit id="4d508e5126e2607ecdbc5585d6f5feddb0141747" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;TRACKING HARDWARE&lt;/strong&gt;, this is a great idea</source>
          <target state="translated">对于&lt;strong&gt;跟踪硬件&lt;/strong&gt; ，这是个好主意</target>
        </trans-unit>
        <trans-unit id="a5aaa337d1440bdae5d23e8ace9adf091f4c1bb2" translate="yes" xml:space="preserve">
          <source>For detailed instructions on how to get a unique identifier for each Android device your application is installed from, see the official Android Developers Blog posting &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Identifying App Installations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">有关如何获取安装了应用程序的每个Android设备的唯一标识符的详细说明，请参阅发布了&amp;ldquo; &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;标识应用程序安装&amp;rdquo;&lt;/a&gt;&lt;/em&gt;的官方Android开发者博客。</target>
        </trans-unit>
        <trans-unit id="c7fcb4dff4d000ebe9767dab18b43055f96799e0" translate="yes" xml:space="preserve">
          <source>For hardware recognition of a specific Android device you could check the MAC Addresses.</source>
          <target state="translated">对于特定Android设备的硬件识别,你可以查看MAC地址。</target>
        </trans-unit>
        <trans-unit id="74a63bc03f2c45c8de27ed0ee3cd9f09b7d7ae05" translate="yes" xml:space="preserve">
          <source>For more information on this approach see &lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;Reto's talk&lt;/a&gt;.</source>
          <target state="translated">有关此方法的更多信息，请参见&lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;Reto的演讲&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c761e900a9e6f2abf00dadb6a1e61c902d515440" translate="yes" xml:space="preserve">
          <source>Full disclosure: my app used the below approach originally but no longer uses this approach, and we now use the approach outlined in the &lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android Developer Blog&lt;/a&gt; entry that &lt;a href=&quot;https://stackoverflow.com/a/5626208/231078&quot;&gt;emmby's answer&lt;/a&gt; links to (namely, generating and saving a &lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html#randomUUID()&quot;&gt;&lt;code&gt;UUID#randomUUID()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">完整披露：我的应用最初使用以下方法，但不再使用此方法，现在我们使用&lt;a href=&quot;https://stackoverflow.com/a/5626208/231078&quot;&gt;emmby的答案&lt;/a&gt;链接到的&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Android开发者博客&lt;/a&gt;条目中概述的方法（即，生成并保存&lt;a href=&quot;http://developer.android.com/reference/java/util/UUID.html#randomUUID()&quot;&gt; &lt;code&gt;UUID#randomUUID()&lt;/code&gt; &lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2c2cd906ea84d8bcee34e2068a1fa4560468873b" translate="yes" xml:space="preserve">
          <source>Galaxy Nexus</source>
          <target state="translated">Galaxy Nexus</target>
        </trans-unit>
        <trans-unit id="44fffff309134b9b2bdf71b19d330caa1f1f4db7" translate="yes" xml:space="preserve">
          <source>Google Player Services InstanceID</source>
          <target state="translated">Google Player Services InstanceID</target>
        </trans-unit>
        <trans-unit id="64bb16ae288df58d9c0fb9528840bd40020a3ef4" translate="yes" xml:space="preserve">
          <source>Google believes that OEMs have patched the issue for many or most of their devices, but I was able to verify that as of the beginning of April 2011, at least, it's still quite easy to find devices that have the broken ANDROID_ID.</source>
          <target state="translated">谷歌认为,OEM厂商已经为他们的许多或大部分设备打了补丁,但我能够证实的是,至少在2011年4月初,至少在2011年4月的时候,要找到有破损的ANDROID_ID的设备还是相当容易的。</target>
        </trans-unit>
        <trans-unit id="66ffbf021486edd946d859959189cdbdaa6ac774" translate="yes" xml:space="preserve">
          <source>Google will give you a backup service key which you need to add to the manifest. You also need to tell the application to use the BackupAgent as follows:</source>
          <target state="translated">Google会给你一个备份服务密钥,你需要将其添加到清单中。您还需要告诉应用程序使用BackupAgent,如下所示。</target>
        </trans-unit>
        <trans-unit id="0cc10b27cdcc1e9484e50c527f7df63edcd51bd5" translate="yes" xml:space="preserve">
          <source>HTC One V</source>
          <target state="translated">HTC One V</target>
        </trans-unit>
        <trans-unit id="b76ab65957a69ff57e8c72352794d437fd34c788" translate="yes" xml:space="preserve">
          <source>Hardware</source>
          <target state="translated">Hardware</target>
        </trans-unit>
        <trans-unit id="c328e6f1d27b686f33f8c2a1cb31439f110901b3" translate="yes" xml:space="preserve">
          <source>Here are a few things to take in mind:</source>
          <target state="translated">以下是一些需要注意的事项。</target>
        </trans-unit>
        <trans-unit id="db30e0d3f173e7a651d727b69350a9ac513b2027" translate="yes" xml:space="preserve">
          <source>Here is how I am generating the unique id:</source>
          <target state="translated">以下是我是如何生成唯一的ID的。</target>
        </trans-unit>
        <trans-unit id="909ed0a3f13ac0a179921a37eecac87855d385d5" translate="yes" xml:space="preserve">
          <source>Here is the code that Reto Meier used in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I/O&lt;/a&gt; presentation this year to get a unique id for the user:</source>
          <target state="translated">这是Reto Meier今年在&lt;a href=&quot;https://en.wikipedia.org/wiki/Google_I/O&quot;&gt;Google I / O&lt;/a&gt;演示中使用的代码，用于为用户获取唯一的ID：</target>
        </trans-unit>
        <trans-unit id="c38334779e436ea91f7bfab6257a7dad9862f212" translate="yes" xml:space="preserve">
          <source>How about the &lt;a href=&quot;http://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity&quot;&gt;IMEI&lt;/a&gt;. That is unique for Android or other mobile devices.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity&quot;&gt;IMEI呢&lt;/a&gt; ？ 这对于Android或其他移动设备而言是唯一的。</target>
        </trans-unit>
        <trans-unit id="7748c168ff521cd3dda63c31c7fb08b724c2706a" translate="yes" xml:space="preserve">
          <source>However, the blog post goes on to discuss solutions if you need a device identifier rather than an app installation identifier.  I spoke with someone at Google to get some additional clarification on a few items in the event that you need to do so.  Here's what I discovered about device identifiers that's NOT mentioned in the aforementioned blog post:</source>
          <target state="translated">然而,如果你需要一个设备标识符而不是应用安装标识符的话,这篇博文继续讨论解决方案。我与谷歌的人进行了交谈,以获得一些额外的澄清,如果你需要这样做的情况下,一些项目。以下是我发现的关于设备标识符的内容,在上述博文中没有提到。</target>
        </trans-unit>
        <trans-unit id="156b25fd784ead3f040e53e4d7236506840f56f2" translate="yes" xml:space="preserve">
          <source>I did not yet have a chance to test GSM devices with no SIM, a GSM device with no Google account added, or any of the devices in airplane mode.</source>
          <target state="translated">我还没有机会测试没有SIM卡的GSM设备,没有添加谷歌账户的GSM设备,也没有测试飞机模式下的任何设备。</target>
        </trans-unit>
        <trans-unit id="a4c6aa4b572309ea35cf741ad3d2a12472e946d4" translate="yes" xml:space="preserve">
          <source>I don't know whether it is actually supported (=not null) by all devices with API level &amp;gt;= 9 though.</source>
          <target state="translated">我不知道API级别&amp;gt; = 9的所有设备是否实际上都支持（=不为null）。</target>
        </trans-unit>
        <trans-unit id="3a733cbbb39274e68cf086005cf1e1f3376f3f67" translate="yes" xml:space="preserve">
          <source>I have tried to reference every link that I took information from. If you are missing and need to be included, please comment!</source>
          <target state="translated">我已经尽力参考了每一个链接,我所提取的资料。如有遗漏,需要收录的,请评论!</target>
        </trans-unit>
        <trans-unit id="c9e6270ca55fb5962a1695210945e5b160b251aa" translate="yes" xml:space="preserve">
          <source>I know there isn't any 'perfect' way of getting a unique ID without using permissions; however, sometimes we only really need to track the device installation. When it comes to creating a unique ID, we can create a 'pseudo unique id' based solely off of information that the Android API gives us without using extra permissions. This way, we can show the user respect and try to offer a good user experience as well.</source>
          <target state="translated">我知道没有任何 &quot;完美 &quot;的方法可以在不使用权限的情况下获得一个唯一的ID;然而,有时我们只需要跟踪设备的安装情况。当谈到创建一个唯一的ID时,我们可以完全根据Android API给我们的信息创建一个 &quot;伪唯一ID&quot;,而不使用额外的权限。这样一来,我们既能体现出对用户的尊重,又能尽量提供良好的用户体验。</target>
        </trans-unit>
        <trans-unit id="bfa122338cdf92af7137efd94b974b0d33bd5fd1" translate="yes" xml:space="preserve">
          <source>I myself prefer using an existing OpenUDID implementation (see &lt;a href=&quot;https://github.com/ylechelle/OpenUDID&quot;&gt;https://github.com/ylechelle/OpenUDID&lt;/a&gt;) for Android (see &lt;a href=&quot;https://github.com/vieux/OpenUDID&quot;&gt;https://github.com/vieux/OpenUDID&lt;/a&gt;). It is easy to integrate and makes use of the &lt;code&gt;ANDROID_ID&lt;/code&gt; with fallbacks for those issues mentioned above.</source>
          <target state="translated">我本人更喜欢使用适用于Android的现有OpenUDID实现（请参阅&lt;a href=&quot;https://github.com/ylechelle/OpenUDID&quot;&gt;https://github.com/ylechelle/OpenUDID&lt;/a&gt; ）（请参阅&lt;a href=&quot;https://github.com/vieux/OpenUDID&quot;&gt;https://github.com/vieux/OpenUDID&lt;/a&gt; ）。 它很容易集成，并且可以将 &lt;code&gt;ANDROID_ID&lt;/code&gt; 与备用功能结合使用来解决上述问题。</target>
        </trans-unit>
        <trans-unit id="6b606db7e3a8dffabbb25480301dd8f04d9879aa" translate="yes" xml:space="preserve">
          <source>I personally find this acceptable but not ideal. No one identifier provided by Android works in all instances as most are dependent on the phone's radio states (Wi-Fi on/off, cellular on/off, Bluetooth on/off). The others, like &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; must be implemented by the manufacturer and are not guaranteed to be unique.</source>
          <target state="translated">我个人认为这可以接受，但并不理想。 Android提供的任何标识符都无法在所有情况下正常工作，因为大多数标识符都取决于手机的无线电状态（Wi-Fi开/关，蜂窝式开/关，蓝牙开/关）。 其他 &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; （例如Settings.Secure.ANDROID_ID）必须由制造商实现，并且不能保证唯一。</target>
        </trans-unit>
        <trans-unit id="e938574a512fc75c74a4248fc0bef6cc438366b9" translate="yes" xml:space="preserve">
          <source>I think this is sure fire way of building a skeleton for a unique ID...  check it out.</source>
          <target state="translated">我觉得这是个很有把握的方法,可以打造一个独一无二的ID骨架...........看看吧。</target>
        </trans-unit>
        <trans-unit id="f81d00de22f916abb3004846fde32e53ec7ae94d" translate="yes" xml:space="preserve">
          <source>I use the following code to get the &lt;code&gt;IMEI&lt;/code&gt; or use Secure.&lt;code&gt;ANDROID_ID&lt;/code&gt; as an alternative, when the device doesn't have phone capabilities:</source>
          <target state="translated">我使用以下代码获取 &lt;code&gt;IMEI&lt;/code&gt; 或使用Secure。 当设备不具备电话功能时，可以使用 &lt;code&gt;ANDROID_ID&lt;/code&gt; 作为替代：</target>
        </trans-unit>
        <trans-unit id="57a804aec5bf6e57ee40407af2a281ca3431eca3" translate="yes" xml:space="preserve">
          <source>IMEI, Mac Addresses, Instance Id, GUIDs, SSAID, Advertising Id, Safety Net API to verify devices.</source>
          <target state="translated">IMEI、Mac地址、Instance Id、GUID、SSAID、广告ID、安全网API验证设备。</target>
        </trans-unit>
        <trans-unit id="06071d8f8cd78e028ee7c3525bd3c0ef79dc3ddd" translate="yes" xml:space="preserve">
          <source>If all else fails, if the user does have lower than API 9 (lower than Gingerbread), has reset their device or 'Secure.ANDROID_ID' returns 'null', then simply the ID returned will be solely based off their Android device information. This is where the collisions can happen.</source>
          <target state="translated">如果其他的方法都失败了,如果用户的设备确实低于API 9(低于Gingerbread),重置了他们的设备,或者'Secure.ANDROID_ID'返回'null',那么返回的ID将完全基于他们的Android设备信息。这就是可能发生碰撞的地方。</target>
        </trans-unit>
        <trans-unit id="dc3a0a3dba7c8ea7891c00a199b23c671d5c51a8" translate="yes" xml:space="preserve">
          <source>If all else fails:</source>
          <target state="translated">如果其他方面都失败了。</target>
        </trans-unit>
        <trans-unit id="762e4f4e43bad11983bc567125f5da4ca9333dd0" translate="yes" xml:space="preserve">
          <source>If the user's Android device is lower than API 9; hopefully, they have not done a factory reset and their 'Secure.ANDROID_ID' will be preserved or not 'null'. (see &lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;http://developer.android.com/about/dashboards/index.html&lt;/a&gt;)</source>
          <target state="translated">如果用户的Android设备低于API 9； 希望他们没有恢复出厂设置，并且他们的&amp;ldquo; Secure.ANDROID_ID&amp;rdquo;将保留或不为&amp;ldquo; null&amp;rdquo;。 （请参阅&lt;a href=&quot;http://developer.android.com/about/dashboards/index.html&quot;&gt;http://developer.android.com/about/dashboards/index.html&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="fa0ea4d56f487e060e2bef1ed328eb75796b719b" translate="yes" xml:space="preserve">
          <source>If their Android device is API 9 or over, this is guaranteed to be unique because of the 'Build.SERIAL' field.</source>
          <target state="translated">如果他们的安卓设备是API 9或以上的设备,由于 &quot;Build.SERIAL &quot;字段的存在,保证了这是唯一的。</target>
        </trans-unit>
        <trans-unit id="3575fde2de857ff87c8118647f87e52a16628549" translate="yes" xml:space="preserve">
          <source>If you couple this with a backup strategy to send preferences to the cloud (also described in Reto's &lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;talk&lt;/a&gt;, you should have an id that ties to a user and sticks around after the device has been wiped, or even replaced. I plan to use this in analytics going forward (in other words, I have not done that bit yet :).</source>
          <target state="translated">如果将此方法与备份策略结合使用，以将首选项发送到云（在Reto的&lt;a href=&quot;http://www.google.com/events/io/2011/sessions/android-protips-advanced-topics-for-expert-android-app-developers.html&quot;&gt;演讲中&lt;/a&gt;也有介绍），则应该有一个与用户相关联的ID，并在擦除或更换设备后仍然存在。我计划使用此ID。在未来的分析中（换句话说，我还没有这样做：）。</target>
        </trans-unit>
        <trans-unit id="3eb06bbafe2a8c1917c4f2423475d42118fed40e" translate="yes" xml:space="preserve">
          <source>If you have a user with a factory reset device, the value may have changed or altered on the rooted device so there may be duplicates entries if you are tracking user installs.</source>
          <target state="translated">如果你有一个用户使用了出厂重置设备,那么该值可能已经改变或改变了根设备上的值,所以如果你跟踪用户安装,可能会有重复的条目。</target>
        </trans-unit>
        <trans-unit id="4de44081ecbabe0f12a4e9710368ae86429838b2" translate="yes" xml:space="preserve">
          <source>If you need to store the device identification on your remote server, then don't store it as is (plain text), but a &lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;hash with salt&lt;/a&gt;.</source>
          <target state="translated">如果您需要将设备标识存储在远程服务器上，则不要按原样存储（纯文本），而是存储&lt;a href=&quot;https://en.wikipedia.org/wiki/Salt_(cryptography)&quot;&gt;带有salt&lt;/a&gt;的哈希 。</target>
        </trans-unit>
        <trans-unit id="c69ab1c2ee0514d03ee5cd6b934bf576aa81b87c" translate="yes" xml:space="preserve">
          <source>If you use GCM, then you will eventually need to use this instance ID because you need it in order to get the GCM token (which replaces the old GCM registration ID).</source>
          <target state="translated">如果你使用GCM,那么你最终需要使用这个实例ID,因为你需要它来获得GCM令牌(它取代了旧的GCM注册ID)。</target>
        </trans-unit>
        <trans-unit id="528661f594242632fc3a1475ecad83ff4445ee50" translate="yes" xml:space="preserve">
          <source>If you use the ID for the purposes they intend - eg. app authentication, app identification, GCM - I think this 1-3 seconds could be a nuisance (depending on your app, of course).</source>
          <target state="translated">如果你使用ID的目的是为了他们想要的目的--例如:应用认证、应用识别、GCM--我认为这1-3秒的时间可能会让你很烦(当然,这取决于你的应用)。</target>
        </trans-unit>
        <trans-unit id="1ac06007cebb29579c97114d7324ea4840e62e4a" translate="yes" xml:space="preserve">
          <source>Implementing a custom ID generation algorithm (based on device properties that are supposed to be static and won't change -&amp;gt; who knows)</source>
          <target state="translated">实现自定义ID生成算法（基于应该是静态且不会更改的设备属性-&amp;gt;谁知道）</target>
        </trans-unit>
        <trans-unit id="18dd7e894b3d90006c19d4622173976d09581f63" translate="yes" xml:space="preserve">
          <source>Important:</source>
          <target state="translated">Important:</target>
        </trans-unit>
        <trans-unit id="75a08b4ae0701d301a9b9dd2a57267b1b16cb80c" translate="yes" xml:space="preserve">
          <source>In every Android device their is at least a &quot;wlan0&quot; Interface witch is the WI-FI chip.
This code works even when WI-FI is not turned on.</source>
          <target state="translated">每个Android设备中至少有一个 &quot;wlan0 &quot;接口,这就是WI-FI芯片。即使在没有开启WI-FI的情况下,这个代码也能工作。</target>
        </trans-unit>
        <trans-unit id="a63fbc8d29b93f78056c57ad30866d3b8fd12d3e" translate="yes" xml:space="preserve">
          <source>In the current implementation (GPS 7.5) the instance ID is retrieved from a server when your app requests it.  This means that the call above is a blocking call - in my unscientific testing it takes 1-3 seconds if the device is online, and 0.5 - 1.0 seconds if off-line (presumably this is how long it waits before giving up and generating a random ID).  This was tested in North America on Nexus 5 with Android 5.1.1 and GPS 7.5.</source>
          <target state="translated">在目前的实现中(GPS 7.5),当你的应用请求时,实例ID是在服务器上获取的。这意味着上面的呼叫是一个阻断呼叫--在我不科学的测试中,如果设备是在线的,需要1-3秒,如果是离线的,需要0.5-1.0秒(大概就是在放弃和生成一个随机ID之前,它可能会等待多长时间)。这是在北美的Nexus 5上进行的测试,使用Android 5.1.1.1和GPS 7.5系统。</target>
        </trans-unit>
        <trans-unit id="2ae8f70f4300bc2ba3098af2f4adc093761dbe21" translate="yes" xml:space="preserve">
          <source>Instead, I encapsulated the various strategies for getting a (device) ID in an enum - changing the order of the enum constants affects the priority of the various ways of getting the ID. The first non-null ID is returned or an exception is thrown (as per good Java practices of not giving null a meaning). So for instance I have the TELEPHONY one first - but a good default choice would be the ANDROID_ID
&lt;strong&gt;beta:&lt;/strong&gt;</source>
          <target state="translated">相反，我封装了在枚举中获取（设备）ID的各种策略-更改枚举常量的顺序会影响获取ID的各种方式的优先级。 返回第一个非null的ID或引发异常（按照Java的良好做法，即不赋予null含义）。 举例来说，我首先使用TELEPHONY-但一个很好的默认选择是ANDROID_ID &lt;strong&gt;beta：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c29126da6664f6edcac9f12325eb165daa92de65" translate="yes" xml:space="preserve">
          <source>Is there a unique Android device ID</source>
          <target state="translated">是否有一个唯一的Android设备ID</target>
        </trans-unit>
        <trans-unit id="b47bb185dbab4ea38c6cbb61b904354a8215bbea" translate="yes" xml:space="preserve">
          <source>It appears to me that Google intends for it to be used for this purpose (identifying your installations), it is cross-platform, and can be used for a number of other purposes (see the links above).</source>
          <target state="translated">在我看来,谷歌的意图是为了这个目的(识别你的安装),它是跨平台的,可以用于其他一些目的(见上面的链接)。</target>
        </trans-unit>
        <trans-unit id="e48e1d7951eaa1e687adda314e217b648f7dd4d3" translate="yes" xml:space="preserve">
          <source>It combines 3 IDs and creates a 32-digit hex string. It has worked very well for me.</source>
          <target state="translated">它结合了3个ID,并创建了一个32位数的十六进制字符串。对我来说,它的效果非常好。</target>
        </trans-unit>
        <trans-unit id="2c160ef6ce12d88a829702227c10d5289519ab11" translate="yes" xml:space="preserve">
          <source>It covers five different ID types:</source>
          <target state="translated">它涵盖了五种不同的ID类型。</target>
        </trans-unit>
        <trans-unit id="1a9ced4556496d02cc0a71b2e1e4ff599463200a" translate="yes" xml:space="preserve">
          <source>It identifies an installation rather then a device, but then again, ANDROID_ID (which is the accepted answer) now no longer identifies devices either.  With the ARC runtime a new ANDROID_ID is generated for every installation (&lt;a href=&quot;https://stackoverflow.com/questions/29656101/how-does-android-id-on-arc-chrome-differ-from-android&quot;&gt;details here&lt;/a&gt;), just like this new instance ID.  Also, I think that identifying installations (not devices) is what most of us are actually looking for.</source>
          <target state="translated">它标识的是安装而不是设备，但是，ANDROID_ID（这是公认的答案）现在也不再标识设备。 借助ARC运行时，将为每个安装生成一个新的ANDROID_ID（ &lt;a href=&quot;https://stackoverflow.com/questions/29656101/how-does-android-id-on-arc-chrome-differ-from-android&quot;&gt;此处有详细信息&lt;/a&gt; ），就像此新实例ID一样。 另外，我认为识别安装（不是设备）是我们大多数人真正想要的。</target>
        </trans-unit>
        <trans-unit id="a64f6056588034fc4d220538d26c0b1682bf2e4d" translate="yes" xml:space="preserve">
          <source>It is intended that the advertising ID completely replace existing
  usage of other identifiers for ads purposes (such as the use of ANDROID_ID
  in Settings.Secure) when Google Play Services is available. Cases
  where Google Play Services is unavailable are indicated by a
  GooglePlayServicesNotAvailableException being thrown by
  getAdvertisingIdInfo().</source>
          <target state="translated">当GooglePlay服务可用时,广告ID将完全取代现有的其他标识符用于广告目的(如在Settings.Secure中使用ANDROID_ID)。在GooglePlay服务不可用的情况下,通过getAdvertisingIdInfo()抛出一个GooglePlayServicesNotAvailableException来表示。</target>
        </trans-unit>
        <trans-unit id="48ab83801f8db7d5cd0d68add1c88ce8c0ff1d0e" translate="yes" xml:space="preserve">
          <source>It seems that Google intends for this ID to be used to identify installations across Android, Chrome, and iOS.</source>
          <target state="translated">看来,谷歌打算用这个ID来识别横跨安卓、Chrome和iOS系统的安装,这似乎是谷歌的意图。</target>
        </trans-unit>
        <trans-unit id="661748ef478e8f40ca9ba7610f202aa6326f6fdf" translate="yes" xml:space="preserve">
          <source>It seems the best way is for you to generate one yourself upon installation and subsequently read it when the application is re-launched.</source>
          <target state="translated">最好的方法似乎是在安装时自己生成一个,随后在重新启动应用程序时读取。</target>
        </trans-unit>
        <trans-unit id="c60f8164d86460485efd8a7405c3f239b0f4e312" translate="yes" xml:space="preserve">
          <source>It will return something like this:  &lt;strong&gt;551F27C060712A72730B0A0F734064B1&lt;/strong&gt;</source>
          <target state="translated">它将返回如下内容： &lt;strong&gt;551F27C060712A72730B0A0F734064B1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e469922a6bbfc6a99ddffec61b7d063177d70a1c" translate="yes" xml:space="preserve">
          <source>It works well enough for me.</source>
          <target state="translated">它对我来说已经足够好用了。</target>
        </trans-unit>
        <trans-unit id="5f78b3acf61010d46d7a439aaa6bd62d6aeb0a2d" translate="yes" xml:space="preserve">
          <source>It's a simple question, with no simple answer.</source>
          <target state="translated">这是一个简单的问题,没有简单的答案。</target>
        </trans-unit>
        <trans-unit id="247f9767730bc5c8c15744b994fbc8656ec12600" translate="yes" xml:space="preserve">
          <source>It's not only unreliable for device identification, but you also must follow the &lt;a href=&quot;https://play.google.com/about/monetization-ads/ads/#!?zippy_activeEl=ad-id#ad-id&quot;&gt;user privacy regarding ad tracking&lt;/a&gt; policy, which states clearly that user can reset or block it at any moment.</source>
          <target state="translated">这不仅会导致设备识别不可靠，而且您还必须遵守&lt;a href=&quot;https://play.google.com/about/monetization-ads/ads/#!?zippy_activeEl=ad-id#ad-id&quot;&gt;用户隐私权有关的广告跟踪&lt;/a&gt;政策，该政策明确规定用户可以随时重置或阻止它。</target>
        </trans-unit>
        <trans-unit id="e3a4a1aa378c1161638d051127dad02b5e8af7a4" translate="yes" xml:space="preserve">
          <source>It's unique for the application installation on the device, so when the user uninstall the app - it's wiped out, so it's not 100% reliable, but it's the next best thing.</source>
          <target state="translated">它对设备上的应用安装是唯一的,所以当用户卸载应用时--应用被抹掉了,所以不是100%可靠,但它是次要的。</target>
        </trans-unit>
        <trans-unit id="8e2cd4c7ea6ed9c1da9c0b5458920576c63b6da8" translate="yes" xml:space="preserve">
          <source>Last Updated: 6/2/15</source>
          <target state="translated">最近一次更新。6215</target>
        </trans-unit>
        <trans-unit id="496c98f39e8e3600d46a85e0a6a8f53c36f64d75" translate="yes" xml:space="preserve">
          <source>Let's go through the full approach. First, we need to create a backup for our SharedPreferences using the Android Backup Service. Start by registering your app via &lt;code&gt;http://developer.android.com/google/backup/signup.html&lt;/code&gt;.</source>
          <target state="translated">让我们来看看完整的方法。 首先，我们需要使用Android备份服务为SharedPreferences创建备份。 首先通过 &lt;code&gt;http://developer.android.com/google/backup/signup.html&lt;/code&gt; 注册您的应用。</target>
        </trans-unit>
        <trans-unit id="4d1d40e4e6e4d5b5057568f722d23bc52c97f7bf" translate="yes" xml:space="preserve">
          <source>List of options - reasons why/ why not to use them:</source>
          <target state="translated">选项清单----为什么不使用这些选项的原因。</target>
        </trans-unit>
        <trans-unit id="8ed8661fcd4fe9d083532cfc96cbc88d049d4b3a" translate="yes" xml:space="preserve">
          <source>Main Issue: Hardware vs Software</source>
          <target state="translated">主要问题。硬件与软件</target>
        </trans-unit>
        <trans-unit id="9cb382f8ab032841aa8265aab6792980ecc82a07" translate="yes" xml:space="preserve">
          <source>Makes it interesting playing &quot;Pocket Empires&quot; which gives you instant access to someone's account based on the &quot;unique&quot; DeviceID.</source>
          <target state="translated">使得玩 &quot;口袋帝国 &quot;很有意思,它可以根据 &quot;唯一 &quot;的DeviceID即时访问某人的账户。</target>
        </trans-unit>
        <trans-unit id="8407cc5c571fc70b49a29b1d8d5c087a101668c0" translate="yes" xml:space="preserve">
          <source>Many other answers here are suggesting to use the &lt;code&gt;AdvertisingIdClient&lt;/code&gt;, which is also incompatible, as its by design should be used only for ads profiling. It's also stated in the &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;official reference&lt;/a&gt;</source>
          <target state="translated">这里的许多其他答案都建议使用 &lt;code&gt;AdvertisingIdClient&lt;/code&gt; ，这也是不兼容的，因为它的设计目的仅应用于广告概要分析。 &lt;a href=&quot;https://developer.android.com/training/articles/user-data-ids&quot;&gt;官方参考资料中&lt;/a&gt;也有说明</target>
        </trans-unit>
        <trans-unit id="8ad1775c5ffeddd50a06ef8242262cdc6b3efc15" translate="yes" xml:space="preserve">
          <source>Mini MK802</source>
          <target state="translated">迷你MK802</target>
        </trans-unit>
        <trans-unit id="20633f608fc0a2559531f24278a3c2e5959dce8a" translate="yes" xml:space="preserve">
          <source>More over, all of the existing answers here are whether out of date or unreliable.</source>
          <target state="translated">更多的是,这里现有的答案都是过期或不可靠。</target>
        </trans-unit>
        <trans-unit id="9dcd7866a1f6d57e1475eb160f7d5e8cb2eb96a8" translate="yes" xml:space="preserve">
          <source>More specifically, &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt;. This is a 64-bit quantity that is generated and stored when the device first boots. It is reset when the device is wiped.</source>
          <target state="translated">更具体地说，是 &lt;code&gt;Settings.Secure.ANDROID_ID&lt;/code&gt; 。 这是设备首次启动时生成并存储的64位数量。 擦拭设备时将其重置。</target>
        </trans-unit>
        <trans-unit id="b532ed3a11e14d9ce0eab31a5498be481833d792" translate="yes" xml:space="preserve">
          <source>Most applications on the market do not use Bluetooth, and so if your application doesn't use Bluetooth and you are including this, the user could become suspicious.</source>
          <target state="translated">市场上大多数应用都不使用蓝牙,所以如果你的应用没有使用蓝牙,而你的应用包括了这一点,用户可能会变得可疑。</target>
        </trans-unit>
        <trans-unit id="df90379ebe5f94bce4c858d9844cdc05ecf3ba9b" translate="yes" xml:space="preserve">
          <source>Most of the Build members are strings, what we're doing here is to take their length and transform it via modulo in a digit. We have 13 such digits and we are adding two more in front (35) to have the same size ID as the IMEI (15 digits). There are other possibilities here are well, just have a look at these strings.
Returns something like &lt;code&gt;355715565309247&lt;/code&gt;. No special permission is required, making this approach very convenient.</source>
          <target state="translated">大多数Build成员都是字符串，我们在这里要做的是获取它们的长度并通过对数字进行模运算来对其进行转换。 我们有13个这样的数字，并且在前面增加了两个数字（35），以具有与IMEI相同的大小ID（15个数字）。 这里还有其他可能性，只看这些字符串即可。 返回类似 &lt;code&gt;355715565309247&lt;/code&gt; 的内容 。 不需要特殊许可，这使此方法非常方便。</target>
        </trans-unit>
        <trans-unit id="45ad2b97af05faae0b04ef0eca23dec62b094976" translate="yes" xml:space="preserve">
          <source>Most users hate the fact that it says &quot;Phone Calls&quot; in the permission. Some users give bad ratings, because they believe you are simply stealing their personal information when all you really want to do is track device installs. It is obvious that you are collecting data.</source>
          <target state="translated">大多数用户讨厌它在权限中写着 &quot;电话通话 &quot;这一事实。一些用户给出了差评,因为他们认为你只是在窃取他们的个人信息,而你真正想做的是跟踪设备安装情况。很明显,你是在收集数据。</target>
        </trans-unit>
        <trans-unit id="f83d27aeb68503f7856b1a64f2202d260cb1f5a6" translate="yes" xml:space="preserve">
          <source>Motorola Xoom 3G</source>
          <target state="translated">摩托罗拉Xoom 3G</target>
        </trans-unit>
        <trans-unit id="b1d9cca4bbe81715372255d8568403f7b52ca07c" translate="yes" xml:space="preserve">
          <source>My device does not have a cell radio.</source>
          <target state="translated">我的设备没有手机收音机。</target>
        </trans-unit>
        <trans-unit id="5ca245e28b63eff96a79947951e1ad46738bf8bc" translate="yes" xml:space="preserve">
          <source>My two cents - NB this is for a &lt;em&gt;device (err) unique ID&lt;/em&gt; - not the installation one as discussed in the &lt;a href=&quot;http://android-developers.blogspot.gr/2011/03/identifying-app-installations.html&quot;&gt;Android developers's blog&lt;/a&gt;.</source>
          <target state="translated">我的两分钱-注意，这是针对&lt;em&gt;设备（err）的唯一ID-&lt;/em&gt;而不是&lt;a href=&quot;http://android-developers.blogspot.gr/2011/03/identifying-app-installations.html&quot;&gt;Android开发者博客中&lt;/a&gt;讨论的安装&lt;em&gt;ID&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a22ea5efcc531b0a7f05e8d215d271931ba7a266" translate="yes" xml:space="preserve">
          <source>New (for apps with ads AND Google Play Services):</source>
          <target state="translated">新的(适用于有广告和Google Play服务的应用)。</target>
        </trans-unit>
        <trans-unit id="7c1f3d3b5bb9ed8154189e664ae03163e3d63802" translate="yes" xml:space="preserve">
          <source>Nexus S</source>
          <target state="translated">Nexus S</target>
        </trans-unit>
        <trans-unit id="51bf8e626689b71d70b2d25b5cffc6d0364d6086" translate="yes" xml:space="preserve">
          <source>Note that for devices that have to fallback on the device ID, the unique ID &lt;strong&gt;WILL&lt;/strong&gt; persist across factory resets.  This is something to be aware of.  If you need to ensure that a factory reset will reset your unique ID, you may want to consider falling back directly to the random UUID instead of the device ID.</source>
          <target state="translated">请注意，对于必须回退到设备ID的设备，唯一ID &lt;strong&gt;将&lt;/strong&gt;在出厂重置后保持不变。 这是要注意的事情。 如果您需要确保恢复出厂设置会重置您的唯一ID，则可以考虑直接使用随机UUID代替设备ID。</target>
        </trans-unit>
        <trans-unit id="c7d96cc46215857f3ab29923513d98b7caa4abb4" translate="yes" xml:space="preserve">
          <source>Note: You can always add more IDs to the &lt;code&gt;longId&lt;/code&gt; string. For example, Serial #. wifi adapter address. IMEI. This way you are making it more unique per device.</source>
          <target state="translated">注意：您始终可以向 &lt;code&gt;longId&lt;/code&gt; 字符串添加更多ID。 例如，序列号。 wifi适配器地址。 IMEI。 这样，您就可以使每个设备变得更加独特。</target>
        </trans-unit>
        <trans-unit id="c2b3b587b0270f11cd6fb7276d052c83fb8e31d3" translate="yes" xml:space="preserve">
          <source>Of note that the &lt;a href=&quot;https://stackoverflow.com/a/5626208/281545&quot;&gt;solution&lt;/a&gt; provided by @emmby falls back in a per application ID as the SharedPreferences are not synchronized across processes (see &lt;a href=&quot;https://stackoverflow.com/a/4695567/281545&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/12430507/281545&quot;&gt;here&lt;/a&gt;). So I avoided this altogether.</source>
          <target state="translated">值得注意的是，@emmby提供的&lt;a href=&quot;https://stackoverflow.com/a/5626208/281545&quot;&gt;解决方案&lt;/a&gt;在每个应用程序ID中都回退，因为SharedPreferences在各个进程之间不同步（请参见&lt;a href=&quot;https://stackoverflow.com/a/4695567/281545&quot;&gt;此处&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/a/12430507/281545&quot;&gt;此处&lt;/a&gt; ）。 因此，我完全避免了这种情况。</target>
        </trans-unit>
        <trans-unit id="7b858ac6ee952c4e1c29dbed67542329a12e91ca" translate="yes" xml:space="preserve">
          <source>On some devices, it's not available when Wi-Fi is turned off.</source>
          <target state="translated">在某些设备上,当关闭Wi-Fi时,它无法使用。</target>
        </trans-unit>
        <trans-unit id="fea990c88823f6a996f794658a2b1f4a63161630" translate="yes" xml:space="preserve">
          <source>One thing I'll add - I have one of those unique situations.</source>
          <target state="translated">我要补充一点--我有一个独特的情况。</target>
        </trans-unit>
        <trans-unit id="6b0628d57a71956a4d436825b3621152ec1cdcb9" translate="yes" xml:space="preserve">
          <source>Overall breakdown with Android</source>
          <target state="translated">与安卓系统的整体细分</target>
        </trans-unit>
        <trans-unit id="d1d4f3a4b1a894473b73554723e896e7999c4e19" translate="yes" xml:space="preserve">
          <source>P.S.
Their are a bunch of other Interfaces you will get from the list containing MACS But this can change between phones.</source>
          <target state="translated">P.S.S.他们还有很多其他的接口,你可以从包含MACS的列表中获得,但这可能会在不同的手机之间改变。</target>
        </trans-unit>
        <trans-unit id="9438f2fced23130820e071328ec1f2bcf6199b7c" translate="yes" xml:space="preserve">
          <source>Permission:</source>
          <target state="translated">Permission:</target>
        </trans-unit>
        <trans-unit id="93f824548789ff13bb6d1d934795cc90b5617e43" translate="yes" xml:space="preserve">
          <source>Please take a look at the method below:</source>
          <target state="translated">请看一下下面的方法。</target>
        </trans-unit>
        <trans-unit id="b9c68184369baf07c4fe98cf6d372fcfa66f85cb" translate="yes" xml:space="preserve">
          <source>Pseudo-Unique ID, that works on all Android devices
Some devices don't have a phone (eg. Tablets) or for some reason, you don't want to include the READ_PHONE_STATE permission. You can still read details like ROM Version, Manufacturer name, CPU type, and other hardware details, that will be well suited if you want to use the ID for a serial key check, or other general purposes. The ID computed in this way won't be unique: it is possible to find two devices with the same ID (based on the same hardware and ROM image) but the changes in real-world applications are negligible. For this purpose you can use the Build class:</source>
          <target state="translated">伪唯一的ID,可以在所有的Android设备上使用 有些设备没有手机(例如:平板电脑),或者由于某些原因,你不想包含READ_PHONE_STATE权限。你仍然可以读取诸如ROM版本、制造商名称、CPU类型和其他硬件细节,如果你想用这个ID来检查序列号,或者其他一般用途,这些都是很适合的。用这种方式计算出来的ID不会是唯一的:有可能找到两个具有相同ID的设备(基于相同的硬件和ROM映像),但在实际应用中的变化可以忽略不计。为了这个目的,你可以使用Build类。</target>
        </trans-unit>
        <trans-unit id="828b89426734a1dbf3d781b4c25ec7ed065cbe5d" translate="yes" xml:space="preserve">
          <source>Psuedo code:</source>
          <target state="translated">Psuedo代码。</target>
        </trans-unit>
        <trans-unit id="1ffe529de2ce9e48aa199df705c1bc6a92bf20fb" translate="yes" xml:space="preserve">
          <source>Released at I/O 2015; on Android requires play services 7.5.</source>
          <target state="translated">在IO 2015上发布;在安卓系统上需要播放服务7.5版本。</target>
        </trans-unit>
        <trans-unit id="6de6b60549f50e1d1cbaf1b29181768532c910e9" translate="yes" xml:space="preserve">
          <source>Removed 'Android.SECURE_ID' because of factory resets could cause the value to change</source>
          <target state="translated">删除了'Android.SECURE_ID',因为工厂重置可能会导致值发生变化。</target>
        </trans-unit>
        <trans-unit id="8270d4f261192696bb72cbe06c682b3f122e2a07" translate="yes" xml:space="preserve">
          <source>Reported to be available even when Wi-Fi is not connected. If Joe from the answer above gives this one a try on his many devices, that'd be nice.</source>
          <target state="translated">据报道,即使在没有连接Wi-Fi的情况下也能使用。如果上面的答案中的Joe能在他的众多设备上试用一下这个,那就好了。</target>
        </trans-unit>
        <trans-unit id="134114ca5240a5e4691dd1e37f4c5aa68fc6acc8" translate="yes" xml:space="preserve">
          <source>Requires permission &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; in the manifest.</source>
          <target state="translated">清单中需要 &lt;code&gt;android.permission.ACCESS_WIFI_STATE&lt;/code&gt; 权限。</target>
        </trans-unit>
        <trans-unit id="ee4d3582f9c51303c6568490e833b1f95b0069fd" translate="yes" xml:space="preserve">
          <source>Samsung Galaxy S II</source>
          <target state="translated">三星Galaxy S II</target>
        </trans-unit>
        <trans-unit id="5ce411708b005262ceb84b1c8eb166c785e758e8" translate="yes" xml:space="preserve">
          <source>Several devices by several manufacturers are affected by the ANDROID_ID bug in 2.2.</source>
          <target state="translated">多个厂商的几款设备在2.2中受到ANDROID_ID bug的影响。</target>
        </trans-unit>
        <trans-unit id="7e62cfb084266e44f02a7e371b4bd1adc044c427" translate="yes" xml:space="preserve">
          <source>Since it can be 'null', we can check for 'null' and change its value, but this means it will no longer be unique.</source>
          <target state="translated">既然它可以是'null',我们可以检查'null'并改变它的值,但这意味着它将不再是唯一的。</target>
        </trans-unit>
        <trans-unit id="d920418d8f4614d4d0b63e82f9636375e140b2d6" translate="yes" xml:space="preserve">
          <source>Since you cannot have the desired static globally unique and reliable device identifier. Android's official reference suggest:</source>
          <target state="translated">因为你无法拥有所需的静态的全局唯一的、可靠的设备标识符。Android的官方参考建议。</target>
        </trans-unit>
        <trans-unit id="cdcf5ddba809b2ba77d0382e19fc247a84923e08" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;don't use it either&lt;/strong&gt;.</source>
          <target state="translated">所以&lt;strong&gt;也不要使用它&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e16899c26951bab23a1b9380b2fc33c3c1eaa76" translate="yes" xml:space="preserve">
          <source>So &lt;strong&gt;if you're searching for a solution in 2020&lt;/strong&gt;.</source>
          <target state="translated">因此， &lt;strong&gt;如果您要在2020年寻求解决方案&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7777ad95f1578ad31f8994518a10746131c329c" translate="yes" xml:space="preserve">
          <source>So if you want something unique to the device itself, &lt;code&gt;TM.getDeviceId()&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; be sufficient.  Obviously some users are more paranoid than others, so it might be useful to hash 1 or more of these identifiers, so that the string is still virtually unique to the device, but does not explicitly identify the user's actual device.  For example, using &lt;code&gt;String.hashCode()&lt;/code&gt;, combined with a UUID:</source>
          <target state="translated">因此，如果您想要设备本身特有的功能，则 &lt;code&gt;TM.getDeviceId()&lt;/code&gt; &lt;em&gt;应该&lt;/em&gt;足够了。 显然，某些用户比其他用户更偏执，因此散列1个或多个这些标识符可能会很有用，这样该字符串实际上对于设备仍然是唯一的，但不会明确标识用户的实际设备。 例如，结合使用 &lt;code&gt;String.hashCode()&lt;/code&gt; 和UUID：</target>
        </trans-unit>
        <trans-unit id="b4523d93c05eeae3b5f762c60fbb784c35c4eab3" translate="yes" xml:space="preserve">
          <source>So in simpler words: &lt;strong&gt;don't use those techniques&lt;/strong&gt;.</source>
          <target state="translated">所以用简单的话来说： &lt;strong&gt;不要使用那些技术&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ad052271e0186ed108ab51a2c5684a90c5a025a" translate="yes" xml:space="preserve">
          <source>Software</source>
          <target state="translated">Software</target>
        </trans-unit>
        <trans-unit id="824e115bb343a6c2b073c90b205c674541dede20" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;strong&gt;TelephonyManger.getDeviceId()&lt;/strong&gt; will return null, so to assure an unique id you will use this method:</source>
          <target state="translated">有时&lt;strong&gt;TelephonyManger.getDeviceId（）&lt;/strong&gt;将返回null，因此，为确保唯一的ID，您将使用此方法：</target>
        </trans-unit>
        <trans-unit id="fa282f2cba151c130ce9452ee659d095a0527356" translate="yes" xml:space="preserve">
          <source>Thanks to @stansult for posting &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/9186943/950427&quot;&gt;all of our options&lt;/a&gt;&lt;/em&gt; (in this Stack Overflow question).</source>
          <target state="translated">感谢@stansult发布&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/9186943/950427&quot;&gt;了我们所有的选项&lt;/a&gt;&lt;/em&gt; （在此Stack Overflow问题中）。</target>
        </trans-unit>
        <trans-unit id="9529b3a28c1cf43145ca418d76d36d8cf35abea2" translate="yes" xml:space="preserve">
          <source>That makes most of the answers above invalid. Also due to different android security updates, some of them require newer and stricter runtime permissions, which can be simply denied by user.</source>
          <target state="translated">这使得上面的大部分答案都是无效的。同时由于安卓安全更新的不同,有些安卓安全更新要求更新更多、更严格的运行时权限,用户可以直接拒绝。</target>
        </trans-unit>
        <trans-unit id="4e6856a55aeec398595efc5e505f103b1698374f" translate="yes" xml:space="preserve">
          <source>That makes those identifiers not only unreliable, but also unaccessible in many cases.</source>
          <target state="translated">这使得这些标识符不仅不可靠,而且在许多情况下也无法获得。</target>
        </trans-unit>
        <trans-unit id="905daa971c03007ead998008eca6fb60a27cff11" translate="yes" xml:space="preserve">
          <source>The best want to &lt;strong&gt;TRACK AN INDIVIDUAL USER&lt;/strong&gt; with their &lt;strong&gt;consent&lt;/strong&gt; is to simply have them login (make this seamless using OAuth)</source>
          <target state="translated">&lt;strong&gt;征得&lt;/strong&gt;他们的&lt;strong&gt;同意后&lt;/strong&gt; ， &lt;strong&gt;跟踪个人用户&lt;/strong&gt;的最好方法就是简单地让他们登录（使用OAuth使其无缝连接）</target>
        </trans-unit>
        <trans-unit id="36bf022d28e15b55eb29741570cafc304868cddb" translate="yes" xml:space="preserve">
          <source>The following code returns the device serial number using a hidden Android API. But, this code don't works on Samsung Galaxy Tab because &quot;ro.serialno&quot; isn't set on this device.</source>
          <target state="translated">下面的代码使用隐藏的Android API返回设备的序列号。但是,这段代码在三星Galaxy Tab上不能使用,因为 &quot;ro.serialno &quot;并没有在这个设备上设置。</target>
        </trans-unit>
        <trans-unit id="b6577cebf8bae08c3eded7692e3648e217ceef6f" translate="yes" xml:space="preserve">
          <source>The following is an example of writing data to an &lt;em&gt;installation&lt;/em&gt; file that would be stored along with any other data the application saves locally.</source>
          <target state="translated">以下是将数据写入&lt;em&gt;安装&lt;/em&gt;文件的示例，该文件将与应用程序本地保存的任何其他数据一起存储。</target>
        </trans-unit>
        <trans-unit id="80fc7d27c0f1418901088d16652afa967d1415b3" translate="yes" xml:space="preserve">
          <source>The official Android Developers Blog now has a full article just about this very subject, &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;Identifying App Installations&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">现在，Android开发者官方博客正式发布了有关此主题的完整文章， &lt;em&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2011/03/identifying-app-installations.html&quot;&gt;标识应用程序安装&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="074be9cec2bc29c9ee4c0e9dbb3fe0548fb0d38d" translate="yes" xml:space="preserve">
          <source>The unique device ID of an Android OS device as String, using &lt;code&gt;TelephonyManager&lt;/code&gt; and &lt;code&gt;ANDROID_ID&lt;/code&gt;, is obtained by:</source>
          <target state="translated">使用 &lt;code&gt;TelephonyManager&lt;/code&gt; 和 &lt;code&gt;ANDROID_ID&lt;/code&gt; 可以将Android OS设备的唯一设备ID作为String获取，方法是：</target>
        </trans-unit>
        <trans-unit id="bc09c662db608413c569349598f23d8b62ac1e78" translate="yes" xml:space="preserve">
          <source>Then you need to create the backup agent and tell it to use the helper agent for sharedpreferences:</source>
          <target state="translated">然后,你需要创建备份代理,并告诉它使用共享首选项的帮助代理。</target>
        </trans-unit>
        <trans-unit id="d8fc0f501e5874abfd9379770f3cee8f3c897aec" translate="yes" xml:space="preserve">
          <source>There are 30+ answers here and some are same and some are unique. This answer is based on few of those answers. One of them being @Lenn Dolling's answer.</source>
          <target state="translated">这里有30多个答案,有的答案是一样的,有的答案是唯一的。这个答案是基于其中的几个答案。其中一个是@Lenn Dolling的答案。</target>
        </trans-unit>
        <trans-unit id="29056e3e33a93c541a24754b8c06e180ba1ae93d" translate="yes" xml:space="preserve">
          <source>There are a lot of different approaches to work around those &lt;code&gt;ANDROID_ID&lt;/code&gt; issues (may be &lt;code&gt;null&lt;/code&gt; sometimes or devices of a specific model always return the same ID) with pros and cons:</source>
          <target state="translated">有许多不同的方法可以解决这些 &lt;code&gt;ANDROID_ID&lt;/code&gt; 问题（有时可能为 &lt;code&gt;null&lt;/code&gt; 或特定模型的设备总是返回相同的ID），但各有利弊：</target>
        </trans-unit>
        <trans-unit id="01ed028e38c624820207a524646c40ef83ca4867" translate="yes" xml:space="preserve">
          <source>There are many answers to this question, most of which will only work &quot;some&quot; of the time, and unfortunately that's not good enough.</source>
          <target state="translated">这个问题的答案有很多,大部分都只能在 &quot;部分 &quot;时间内起作用,遗憾的是,这还不够好。</target>
        </trans-unit>
        <trans-unit id="e201f88d418a41f759fed71d40f5ade63db27d32" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s rather useful info &lt;strong&gt;&lt;a href=&quot;http://www.pocketmagic.net/?p=1662&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">这里有相当有用的信息。</target>
        </trans-unit>
        <trans-unit id="562a763319bb1d2ce353484fa678f6b147833dd2" translate="yes" xml:space="preserve">
          <source>This User_ID will now be persistent across installations, even if the user moves device.</source>
          <target state="translated">现在,即使用户移动设备,这个User_ID也会在整个安装过程中保持不变。</target>
        </trans-unit>
        <trans-unit id="302601b1cc75faca7a1d398bd9ba7abf9898f8f1" translate="yes" xml:space="preserve">
          <source>This allows you to have an 'almost unique' ID from the user without taking anything that is private. You can create your own anonymous ID from device information.</source>
          <target state="translated">这让你可以从用户那里得到一个 &quot;几乎唯一 &quot;的ID,而不需要拿走任何隐私的东西。你可以从设备信息中创建自己的匿名ID。</target>
        </trans-unit>
        <trans-unit id="d4bd714a0dd7483ee18a4fdbf629832954e33bdb" translate="yes" xml:space="preserve">
          <source>This approach will give you an anonymous, secure user ID which will be persistent for the user across different devices (based on the primary Google account) and across installs. The basic approach is to generate a random user ID and to store this in the apps' shared preferences. You then use Google's backup agent to store the shared preferences linked to the Google account in the cloud.</source>
          <target state="translated">这种方法将给你一个匿名的、安全的用户ID,这个ID将在不同的设备上(基于主要的Google账户)和跨安装的用户持久化。基本方法是生成一个随机的用户ID,并将其存储在应用程序的共享首选项中。然后使用谷歌的备份代理将与谷歌账户关联的共享首选项存储在云端。</target>
        </trans-unit>
        <trans-unit id="9f50ac534bb8c59be341b2d0712eafda3bd4512a" translate="yes" xml:space="preserve">
          <source>This could be the second best option, but you are still collecting and storing a unique identifier that comes directly from a user. This is obvious that you are collecting data.</source>
          <target state="translated">这可能是第二好的选择,但你仍然在收集和存储一个直接来自用户的唯一标识符。这显然是你在收集数据。</target>
        </trans-unit>
        <trans-unit id="a2e7b7e94544edb39f6971fe9517b25bad113277" translate="yes" xml:space="preserve">
          <source>To complete the backup you need to create an instance of BackupManager in your main Activity:</source>
          <target state="translated">要完成备份,您需要在主活动中创建一个BackupManager实例。</target>
        </trans-unit>
        <trans-unit id="13ab41a1d9198a55ef12f9d41d9d016266a0a92e" translate="yes" xml:space="preserve">
          <source>To do this in Java one would just use a FileInputStream to open the iSerial file and read out the characters. Just be sure you wrap it in an exception handler, because not all devices have this file.</source>
          <target state="translated">要在Java中做到这一点,只需使用FileInputStream来打开iSerial文件并读出字符。只要确保你把它封装在一个异常处理程序中就可以了,因为不是所有的设备都有这个文件。</target>
        </trans-unit>
        <trans-unit id="b58b17f345f421d7ea4731213d42eb8ef4c1f87e" translate="yes" xml:space="preserve">
          <source>To understand the available Unique Ids in Android devices. Use this official guide.</source>
          <target state="translated">要了解Android设备中可用的Unique Ids。请使用本官方指南。</target>
        </trans-unit>
        <trans-unit id="3ebe8b4731cdde611da33593d1f3f3a78ae88a34" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;FirebaseInstanceId&lt;/code&gt; add the &lt;a href=&quot;https://firebase.google.com/support/release-notes/android#latest_sdk_versions&quot;&gt;latest firebase-messaging dependency&lt;/a&gt; into your gradle</source>
          <target state="translated">要使用 &lt;code&gt;FirebaseInstanceId&lt;/code&gt; ,请将&lt;a href=&quot;https://firebase.google.com/support/release-notes/android#latest_sdk_versions&quot;&gt;最新&lt;/a&gt;的firebase -messaging依赖项添加到gradle中</target>
        </trans-unit>
        <trans-unit id="1f853b1bfb2a0e3a98db7409ef50f8db8efb056d" translate="yes" xml:space="preserve">
          <source>Today it's not only a best practice, you actually must to do it by law according to &lt;a href=&quot;https://gdpr.eu/eu-gdpr-personal-data/&quot;&gt;GDPR - identifiers&lt;/a&gt; and similar regulations.</source>
          <target state="translated">今天，这不仅是一种最佳做法，实际上您还必须根据&lt;a href=&quot;https://gdpr.eu/eu-gdpr-personal-data/&quot;&gt;GDPR（标识符&lt;/a&gt;和类似法规）依法进行。</target>
        </trans-unit>
        <trans-unit id="68d47c10de20824156d87337e3f252405833a920" translate="yes" xml:space="preserve">
          <source>Toshiba AT300</source>
          <target state="translated">东芝AT300</target>
        </trans-unit>
        <trans-unit id="45ccc2fea58a079a8f7060830d2466031b3a736e" translate="yes" xml:space="preserve">
          <source>Turns out that even though my Viewsonic G Tablet reports a DeviceID that is not Null, every single G Tablet reports the same number.</source>
          <target state="translated">结果发现,即使我的Viewsonic G平板电脑报告的DeviceID不是Null,但每一个G平板电脑报告的数字都是一样的。</target>
        </trans-unit>
        <trans-unit id="9f1880d3d84b85c4d9d8a877ac7b0d41644b35ef" translate="yes" xml:space="preserve">
          <source>User could change email - HIGHLY unlikely</source>
          <target state="translated">用户可以更改电子邮件-极其不可能</target>
        </trans-unit>
        <trans-unit id="ce1e8bd228fc7c368c4c0db36b399db47b4e3058" translate="yes" xml:space="preserve">
          <source>Users can change their hardware, Android tablet or phone, so unique IDs based on hardware are not good ideas for &lt;strong&gt;TRACKING USERS&lt;/strong&gt;</source>
          <target state="translated">用户可以更改其硬件，Android平板电脑或手机，因此基于硬件的唯一ID并不是&lt;strong&gt;跟踪用户的&lt;/strong&gt;好主意</target>
        </trans-unit>
        <trans-unit id="8dcf78b4b2188b958880e49748a252aefba98c7e" translate="yes" xml:space="preserve">
          <source>Users can wipe/change their ROM if they are rooted</source>
          <target state="translated">如果用户是root用户,可以擦除更换他们的ROM。</target>
        </trans-unit>
        <trans-unit id="e7eb67e2f0bd5ad6aae1393f7bce212f2e980fe6" translate="yes" xml:space="preserve">
          <source>Users could change phone numbers - HIGHLY unlikely</source>
          <target state="translated">用户可以更改电话号码--可能性很小</target>
        </trans-unit>
        <trans-unit id="3f6ae3a6aaf32da958424d244bb3083082ba470d" translate="yes" xml:space="preserve">
          <source>Using the code below, you can get the unique device ID of an Android OS device as a string.</source>
          <target state="translated">使用下面的代码,你可以得到Android操作系统设备的唯一设备ID作为一个字符串。</target>
        </trans-unit>
        <trans-unit id="6b960faa3ac35c8978dd66d8ba117ea264270677" translate="yes" xml:space="preserve">
          <source>Using:</source>
          <target state="translated">Using:</target>
        </trans-unit>
        <trans-unit id="374831e7e5ef5c7511cef96a4ee5925588f2e76c" translate="yes" xml:space="preserve">
          <source>Very possible, may contain collisions - See my method posted below!</source>
          <target state="translated">很有可能,可能包含碰撞----请看我在下面贴出的方法!</target>
        </trans-unit>
        <trans-unit id="591e68bf2b0c7304e63142b9d6a9d22e41a8c1dd" translate="yes" xml:space="preserve">
          <source>Warning, users can reset:</source>
          <target state="translated">警告,用户可以重置。</target>
        </trans-unit>
        <trans-unit id="07a15f5d49c1738f4d1b8b8a0f1122ca9168c573" translate="yes" xml:space="preserve">
          <source>With a pseudo-unique id, you really only run into the fact that there may be duplicates based on the fact that there are similar devices. You can tweak the combined method to make it more unique; however, some developers need to track device installs and this will do the trick or performance based on similar devices.</source>
          <target state="translated">使用伪唯一性ID,你真的只是遇到了基于相似设备可能存在重复的事实。你可以调整组合方法,使其更加独特;然而,有些开发者需要跟踪设备安装,这将基于相似设备的性能或基于相似设备的性能。</target>
        </trans-unit>
        <trans-unit id="84f20f82be25d2fdf6c2dd296bacc22769b6a570" translate="yes" xml:space="preserve">
          <source>You can also see my blog post &lt;em&gt;&lt;a href=&quot;http://insitusec.blogspot.com/2013/01/leaking-android-hardware-serial-number.html&quot;&gt;Leaking Android hardware serial number to unprivileged apps&lt;/a&gt;&lt;/em&gt; where I discuss what other files are available for information.</source>
          <target state="translated">您也可以在我的博客文章中讨论&lt;em&gt;&lt;a href=&quot;http://insitusec.blogspot.com/2013/01/leaking-android-hardware-serial-number.html&quot;&gt;将Android硬件序列号泄漏到非特权应用程序中&lt;/a&gt;&lt;/em&gt; ，并在其中讨论哪些其他文件可供参考。</target>
        </trans-unit>
        <trans-unit id="78d9deceaffad86d123cd0bee2083628aeef9feb" translate="yes" xml:space="preserve">
          <source>You can track users across platforms (iOS, Android, Windows, and Web)</source>
          <target state="translated">您可以跨平台追踪用户(iOS、Android、Windows和Web)。</target>
        </trans-unit>
        <trans-unit id="379004bd3f37392fadc9d014330f1a47f898b470" translate="yes" xml:space="preserve">
          <source>import libs</source>
          <target state="translated">导入 libs</target>
        </trans-unit>
        <trans-unit id="3fcb64d53ad87994fc0bcbc5f34fea67765a96ca" translate="yes" xml:space="preserve">
          <source>in AndroidManifest.xml</source>
          <target state="translated">在AndroidManifest.xml中</target>
        </trans-unit>
        <trans-unit id="0f70d4331be095195b9db0d315b40035a3f6c635" translate="yes" xml:space="preserve">
          <source>might result in something like: &lt;code&gt;00000000-54b3-e7c7-0000-000046bffd97&lt;/code&gt;</source>
          <target state="translated">可能会导致类似以下内容的情况： &lt;code&gt;00000000-54b3-e7c7-0000-000046bffd97&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec4d23caadb883c263af5bd03cdfe1bc2b9b9c0e" translate="yes" xml:space="preserve">
          <source>now in your code:</source>
          <target state="translated">现在在你的代码中。</target>
        </trans-unit>
        <trans-unit id="88cc1dabe4fc988630e5d8d02389533e0523b9c6" translate="yes" xml:space="preserve">
          <source>you can do it that way:</source>
          <target state="translated">你可以这样做。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
