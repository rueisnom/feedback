<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/273192">
    <body>
      <group id="273192">
        <trans-unit id="3121ac2ed4bcb912f44c1a708fd4fa005c62df64" translate="yes" xml:space="preserve">
          <source>(For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)</source>
          <target state="translated">(为了了解上下文,我在用一个脚本来跟踪我的每周代表。下面是脚本中的相关部分代码,这些代码让我避免了每天为相同的数据而点击Stack Overflow不止一次)。)</target>
        </trans-unit>
        <trans-unit id="3eb796c0d6b99c763af93d3b97f34d9a1877151e" translate="yes" xml:space="preserve">
          <source>(just as &lt;a href=&quot;https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt; got an &lt;code&gt;exist_ok&lt;/code&gt; flag starting from python 3.2 e.g &lt;code&gt;os.makedirs(path, exist_ok=True)&lt;/code&gt;)</source>
          <target state="translated">（就像&lt;a href=&quot;https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt;从python 3.2开始有一个 &lt;code&gt;exist_ok&lt;/code&gt; 标志，例如 &lt;code&gt;os.makedirs(path, exist_ok=True)&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="18a3c7a1b3ef5d5d0b224c6076395a8aa2e4273e" translate="yes" xml:space="preserve">
          <source>... You're going to end up with a directory named &lt;code&gt;filename.etc&lt;/code&gt; when you pass that argument to &lt;code&gt;os.makedirs()&lt;/code&gt; if you test with &lt;code&gt;os.path.exists()&lt;/code&gt;.</source>
          <target state="translated">...如果使用 &lt;code&gt;os.path.exists()&lt;/code&gt; 进行测试，则将该参数传递给 &lt;code&gt;os.makedirs()&lt;/code&gt; 时，将以一个名为 &lt;code&gt;filename.etc&lt;/code&gt; 的目录结尾。</target>
        </trans-unit>
        <trans-unit id="12b82177815800e1d2adf2e41a4a0b40631382f5" translate="yes" xml:space="preserve">
          <source>...and by allowing &lt;a href=&quot;https://docs.python.org/3.2/library/os.html#os.makedirs&quot;&gt;a keyword argument to &lt;code&gt;os.makedirs&lt;/code&gt; called &lt;code&gt;exist_ok&lt;/code&gt;&lt;/a&gt; (in 3.2+).</source>
          <target state="translated">...，并允许&lt;a href=&quot;https://docs.python.org/3.2/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; 的关键字参数称为 &lt;code&gt;exist_ok&lt;/code&gt; &lt;/a&gt; （在3.2+中）。</target>
        </trans-unit>
        <trans-unit id="d2cb971d27ac509e9772623d927e6363ff0a92a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt;&lt;code&gt;mkpath&lt;/code&gt;&lt;/a&gt; creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt; &lt;code&gt;mkpath&lt;/code&gt; &lt;/a&gt;创建嵌套目录，如果目录已经存在， 则不执行任何操作。 这适用于Python 2和3。</target>
        </trans-unit>
        <trans-unit id="0443b8240c037eb60f44be401cd11e8ad86dd87b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt; as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional &lt;code&gt;exist_ok&lt;/code&gt; argument only if using Python 3.2+, with a default value of &lt;code&gt;False&lt;/code&gt;. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt;使用的os.makedirs递归创建目录，如果目录已经存在，则不会引发异常。 仅当使用Python 3.2+时，它才具有可选的 &lt;code&gt;exist_ok&lt;/code&gt; 参数，默认值为 &lt;code&gt;False&lt;/code&gt; 。 在Python 2.x 2.7之前的版本中不存在此参数。 这样，就不需要像Python 2.7那样的手动异常处理。</target>
        </trans-unit>
        <trans-unit id="c69cbbeb4b9bb92190a2541fb7a478447ef001ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;pathlib.Path.mkdir&lt;/code&gt;&lt;/a&gt; as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the &lt;code&gt;parents&lt;/code&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;pathlib.Path.mkdir&lt;/code&gt; &lt;/a&gt;使用的pathlib.Path.mkdir递归创建目录，如果目录已经存在，则不会引发异常。 如果不需要或不希望创建 &lt;code&gt;parents&lt;/code&gt; ，请跳过&amp;ldquo; 父母&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="5722f73ffd926bda9aeb0c49ae9810a9cdeffffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Path&lt;/code&gt; objects have to be coerced to &lt;code&gt;str&lt;/code&gt; before other APIs that expect &lt;code&gt;str&lt;/code&gt; paths can use them.</source>
          <target state="translated">在其他期望 &lt;code&gt;str&lt;/code&gt; 路径可以使用它们的API之前，必须将 &lt;code&gt;Path&lt;/code&gt; 对象强制转换为 &lt;code&gt;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02fbfa8e9162845467edc255293ffbc665a98adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check if a directory exists and create it if necessary?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;检查目录是否存在，并在必要时创建它？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e2a9d4549bcebed0d695f93286f43be9880e1ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using &lt;code&gt;os&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;os&lt;/code&gt; ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="513f1e61389d5d53dc42b6dd097dcfa305b4e3e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using &lt;code&gt;pathlib&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;pathlib&lt;/code&gt; ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90a13575f8e0892507d63b6f2ba2e38915862974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or&lt;/strong&gt; if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:</source>
          <target state="translated">&lt;strong&gt;或者&lt;/strong&gt;如果使目录符合竞争条件（即如果检查路径是否存在，则可能已经建立了其他路径），请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="3b8239e68048624328c3887db9856779071451e0" translate="yes" xml:space="preserve">
          <source>Alternative:</source>
          <target state="translated">Alternative:</target>
        </trans-unit>
        <trans-unit id="a1cf8b16dad890eb5c4e0c9271810e8851b63291" translate="yes" xml:space="preserve">
          <source>Alternatively, there could be a second &lt;code&gt;os.path.exists&lt;/code&gt;, but suppose another created the directory after the first check, then removed it before the second one &amp;ndash; we could still be fooled.</source>
          <target state="translated">或者，可能还有第二个 &lt;code&gt;os.path.exists&lt;/code&gt; ，但假设另一个在第一次检查后创建了目录，然后在第二次检查之前将其删除了&amp;ndash;我们仍然可能会上当。</target>
        </trans-unit>
        <trans-unit id="5425ec8a183a1bc6b38039d433238fd743244e9d" translate="yes" xml:space="preserve">
          <source>And a foolish user input:</source>
          <target state="translated">还有就是傻瓜式的用户输入。</target>
        </trans-unit>
        <trans-unit id="1c86fe1e6829df459e27c81259e6840525f66bc8" translate="yes" xml:space="preserve">
          <source>As noted in comments and elsewhere, there's a race condition &amp;ndash; if the directory is created between the &lt;code&gt;os.path.exists&lt;/code&gt; and the &lt;code&gt;os.makedirs&lt;/code&gt; calls, the &lt;code&gt;os.makedirs&lt;/code&gt; will fail with an &lt;code&gt;OSError&lt;/code&gt;. Unfortunately, blanket-catching &lt;code&gt;OSError&lt;/code&gt; and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</source>
          <target state="translated">如注释和其他地方所述，这是一个竞争条件&amp;ndash;如果在 &lt;code&gt;os.path.exists&lt;/code&gt; 和 &lt;code&gt;os.makedirs&lt;/code&gt; 调用之间创建目录，则 &lt;code&gt;os.makedirs&lt;/code&gt; 将失败，并显示 &lt;code&gt;OSError&lt;/code&gt; 。 不幸的是，全面捕获 &lt;code&gt;OSError&lt;/code&gt; 并继续操作并非万无一失，因为它会忽略由于其他因素（例如权限不足，磁盘已满等）而导致的目录创建失败。</target>
        </trans-unit>
        <trans-unit id="7ee80f57ba0d6d00c9276e06f774ed3925ebe0d9" translate="yes" xml:space="preserve">
          <source>Assuming opening for reading</source>
          <target state="translated">假设开放供阅读</target>
        </trans-unit>
        <trans-unit id="a732816cb0c9b0cc684d45193ba9368d44c027e2" translate="yes" xml:space="preserve">
          <source>Assuming we're opening for writing</source>
          <target state="translated">假设我们是为了写作而开放</target>
        </trans-unit>
        <trans-unit id="8c423e5c0dfe6a62a16b5a6a6f5ed6162e97b8c5" translate="yes" xml:space="preserve">
          <source>But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via &lt;a href=&quot;https://docs.python.org/library/tempfile.html#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">但是，也许更好的方法是通过&lt;a href=&quot;https://docs.python.org/library/tempfile.html#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile&lt;/code&gt; &lt;/a&gt;使用临时目录来避免资源争用问题：</target>
        </trans-unit>
        <trans-unit id="4e1673fa7c1d5fc36445668c4adb7c1b8bc89428" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;create_dir()&lt;/code&gt; at the entry point of your program/project.</source>
          <target state="translated">在程序/项目的入口点调用函数 &lt;code&gt;create_dir()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01ca4760ac618ba068fbfb39127ce9adee4f1bac" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt;:  (It makes sure the complete path exists.)</source>
          <target state="translated">检查&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt; ：（确保存在完整路径。）</target>
        </trans-unit>
        <trans-unit id="6164c0b5b7d56fc2c96acfc1e85d0aea94d39e63" translate="yes" xml:space="preserve">
          <source>Conclusion: in my opinion, &quot;Method 2&quot; is more robust.</source>
          <target state="translated">总结:在我看来,&quot;方法二 &quot;比较稳健。</target>
        </trans-unit>
        <trans-unit id="2f45eec4334aa25687d578b05a730ae07f2d8c14" translate="yes" xml:space="preserve">
          <source>Consider this directory structure:</source>
          <target state="translated">考虑一下这个目录结构。</target>
        </trans-unit>
        <trans-unit id="d2d4fee838a956a0a5155cf4a5747b0668a441c2" translate="yes" xml:space="preserve">
          <source>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</source>
          <target state="translated">根据应用程序的不同,并发操作的危险性可能比文件权限等其他因素造成的危险性要大或小。开发者在选择实现方式之前,必须对正在开发的特定应用及其预期环境有更多的了解。</target>
        </trans-unit>
        <trans-unit id="deae96764aa4587da73f1ce1ffb9899c015ce4c4" translate="yes" xml:space="preserve">
          <source>Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.</source>
          <target state="translated">即使在这种情况下,这种做法也是不好的,会导致长时间的无用调试。例如,我们设置一个目录的权限,不应该给我们留下这样的印象:权限的设置是为了我们的目的而适当的。一个父目录可以用其他权限挂载。总的来说,一个程序应该始终正确的运行,程序员不应该期待一个特定的环境。</target>
        </trans-unit>
        <trans-unit id="35c95b4868de9bf6ba8db931f46dd2e29eb6e01c" translate="yes" xml:space="preserve">
          <source>First the relevant imports:</source>
          <target state="translated">首先是相关的进口产品。</target>
        </trans-unit>
        <trans-unit id="f48e8c1c7ccf846218c4fb87f4a1f71363cf5c47" translate="yes" xml:space="preserve">
          <source>For a one-liner solution, you can use &lt;a href=&quot;https://github.com/ipython/ipython/blob/b70b3f21749ca969088fdb54edcc36bb8a2267b9/IPython/utils/path.py#L423-L438&quot;&gt;&lt;code&gt;IPython.utils.path.ensure_dir_exists()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">对于&lt;a href=&quot;https://github.com/ipython/ipython/blob/b70b3f21749ca969088fdb54edcc36bb8a2267b9/IPython/utils/path.py#L423-L438&quot;&gt; &lt;code&gt;IPython.utils.path.ensure_dir_exists()&lt;/code&gt; &lt;/a&gt;解决方案，可以使用IPython.utils.path.ensure_dir_exists（） ：</target>
        </trans-unit>
        <trans-unit id="5eb6cd999782910d8577c5e49c2cabbd7c4cfe91" translate="yes" xml:space="preserve">
          <source>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:</source>
          <target state="translated">对于老版本的Python,我看到有两个答案,各有各的优点,各有各的小缺点,下面我就说说我的看法。</target>
        </trans-unit>
        <trans-unit id="ad50b66f54fc8b40a971a312b1e7b1f89975e434" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists&quot;&gt;documentation&lt;/a&gt;: &lt;em&gt;Ensure that a directory exists. If it doesn&amp;rsquo;t exist, try to create it and protect against a race condition if another process is doing the same.&lt;/em&gt;</source>
          <target state="translated">从&lt;a href=&quot;https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists&quot;&gt;文档中&lt;/a&gt; ： &lt;em&gt;确保目录存在。&lt;/em&gt; &lt;em&gt;如果不存在，请尝试创建它，并在其他进程正在这样做的情况下防止出现竞争情况。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac620040ee41da4ac4af95274cdd1c3f011dd85f" translate="yes" xml:space="preserve">
          <source>Here are my experiments/notes, which clarifies things:</source>
          <target state="translated">以下是我的实验笔记,它澄清了一些事情。</target>
        </trans-unit>
        <trans-unit id="4f35d5503e88dfd831b6147a4612e9bccc4447fc" translate="yes" xml:space="preserve">
          <source>Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory.</source>
          <target state="translated">这里有一些脚本----在我的情况下,我没有受到竞赛条件的限制,我只有一个进程期望目录(或包含的文件)在那里,而且我没有任何东西试图删除目录。</target>
        </trans-unit>
        <trans-unit id="a3a28383d88c9f97f89da0f85ed2d6ea047cf57b" translate="yes" xml:space="preserve">
          <source>Here's the essentials from the online doc:</source>
          <target state="translated">以下是网上DOC中的精华内容。</target>
        </trans-unit>
        <trans-unit id="422c9974b57e23de918cca25a8e4e75144ac9949" translate="yes" xml:space="preserve">
          <source>Here's the relevant part of the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">这是&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;文档&lt;/a&gt;的相关部分：</target>
        </trans-unit>
        <trans-unit id="abc4d97edcbb87d0e3301e065d3b93e2104ed36d" translate="yes" xml:space="preserve">
          <source>How can I safely create a nested directory</source>
          <target state="translated">如何安全地创建一个嵌套目录</target>
        </trans-unit>
        <trans-unit id="43df623a8684ce2d0992ddf3e318fee0b73a5bca" translate="yes" xml:space="preserve">
          <source>However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the &lt;code&gt;makedirs&lt;/code&gt; call in a try-except block.</source>
          <target state="translated">但是，假设我们有几个Python进程试图将其所有数据放入同一目录。 然后，我们可能会对目录的创建产生争议。 在这种情况下，最好将 &lt;code&gt;makedirs&lt;/code&gt; 调用包装在try-except块中。</target>
        </trans-unit>
        <trans-unit id="01b533ca1cfd4009ed30def6151904b1fbc1ac26" translate="yes" xml:space="preserve">
          <source>I found this Q/A and I was initially puzzled by some of the failures and errors I was getting. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system).</source>
          <target state="translated">我发现了这个QA,最初我对一些故障和错误感到困惑。我正在使用Python 3 (在一个Arch Linux x86_64系统上的Anaconda虚拟环境中的v.3.5)工作。</target>
        </trans-unit>
        <trans-unit id="bcf2d027a264623ff0d6f130ef23fd5cf6a23215" translate="yes" xml:space="preserve">
          <source>I have put the following down. It's not totally foolproof though.</source>
          <target state="translated">我已经把下面的内容记下来了。虽说不是完全的万无一失。</target>
        </trans-unit>
        <trans-unit id="9d92b1d4efb363280e561cb068cc7fe185f10913" translate="yes" xml:space="preserve">
          <source>I saw &lt;a href=&quot;https://stackoverflow.com/a/5032238/3051142&quot;&gt;Heikki Toivonen&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/14364249&quot;&gt;A-B-B&lt;/a&gt;'s answers and thought of this variation.</source>
          <target state="translated">我看到了&lt;a href=&quot;https://stackoverflow.com/a/5032238/3051142&quot;&gt;Heikki Toivonen&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/a/14364249&quot;&gt;ABB&lt;/a&gt;的答案，并想到了这种变化。</target>
        </trans-unit>
        <trans-unit id="44bc7785155af664bc388bf4072f7f57fab5223a" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;os.path.exists()&lt;/code&gt;, &lt;a href=&quot;http://pastebin.com/vnVk2rY5&quot;&gt;here&lt;/a&gt; is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired).</source>
          <target state="translated">我使用 &lt;code&gt;os.path.exists()&lt;/code&gt; ， &lt;a href=&quot;http://pastebin.com/vnVk2rY5&quot;&gt;这&lt;/a&gt;是一个Python 3脚本，可用于检查目录是否存在，如果不存在则创建一个目录，如果存在则将其删除（如果需要）。</target>
        </trans-unit>
        <trans-unit id="dda21083479a5a551734a83ecabb56f6a839f5f8" translate="yes" xml:space="preserve">
          <source>I would personally recommend that you use &lt;code&gt;os.path.isdir()&lt;/code&gt; to test instead of &lt;code&gt;os.path.exists()&lt;/code&gt;.</source>
          <target state="translated">我个人建议您使用 &lt;code&gt;os.path.isdir()&lt;/code&gt; 代替os.path.exists（）进行测试。</target>
        </trans-unit>
        <trans-unit id="98719f93c1117e90bd3d2ccd57a9fbbebdadfceb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exist_ok&lt;/code&gt; is true, &lt;code&gt;FileExistsError&lt;/code&gt; exceptions will be ignored (same behavior as the &lt;code&gt;POSIX mkdir -p&lt;/code&gt; command), but only if the last path component is not an existing non-directory file.</source>
          <target state="translated">如果 &lt;code&gt;exist_ok&lt;/code&gt; 为true， &lt;code&gt;FileExistsError&lt;/code&gt; 忽略FileExistsError异常（与 &lt;code&gt;POSIX mkdir -p&lt;/code&gt; 命令相同的行为），但是仅当最后一个路径组件不是现有的非目录文件时才如此。</target>
        </trans-unit>
        <trans-unit id="9c76336e3b2bcc4c3ff147925ca8a2045da088d7" translate="yes" xml:space="preserve">
          <source>If the directory or file isn't there, you'll get an &lt;code&gt;IOError&lt;/code&gt; with an associated error number: &lt;code&gt;errno.ENOENT&lt;/code&gt; will point to the correct error number regardless of your platform. You can catch it if you want, for example:</source>
          <target state="translated">如果目录或文件不存在，您将得到一个带有相关错误号的 &lt;code&gt;IOError&lt;/code&gt; ： &lt;code&gt;errno.ENOENT&lt;/code&gt; 将指向正确的错误号，而不管您的平台如何。 您可以根据需要捕获它，例如：</target>
        </trans-unit>
        <trans-unit id="47f877478b34abfa92dad52ab6be30c3ff05158b" translate="yes" xml:space="preserve">
          <source>If using Python 3.4, even though it comes with &lt;code&gt;pathlib&lt;/code&gt;, it is missing the useful &lt;code&gt;exist_ok&lt;/code&gt; option. The backport is intended to offer a newer and superior implementation of &lt;code&gt;mkdir&lt;/code&gt; which includes this missing option.</source>
          <target state="translated">如果使用Python 3.4，即使 &lt;code&gt;pathlib&lt;/code&gt; 附带了它 ，它也会缺少有用的 &lt;code&gt;exist_ok&lt;/code&gt; 选项。 反向端口旨在提供 &lt;code&gt;mkdir&lt;/code&gt; 的更新和更好的实现，其中包括此缺少的选项。</target>
        </trans-unit>
        <trans-unit id="f859712e9880cf77f7dea1b20c5921a1728a2543" translate="yes" xml:space="preserve">
          <source>If you can, install the current &lt;code&gt;pathlib&lt;/code&gt; backport named &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt;&lt;code&gt;pathlib2&lt;/code&gt;&lt;/a&gt;. Do not install the older unmaintained backport named &lt;a href=&quot;https://pypi.python.org/pypi/pathlib/&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt;. Next, refer to the Python 3.5+ section above and use it the same.</source>
          <target state="translated">如果可以，请安装名为&lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt; &lt;code&gt;pathlib2&lt;/code&gt; &lt;/a&gt;的当前 &lt;code&gt;pathlib&lt;/code&gt; 反向端口 。 不要安装名为&lt;a href=&quot;https://pypi.python.org/pypi/pathlib/&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt;的较旧的未维护的反向端口 。 接下来，请参考上面的Python 3.5+部分，并对其进行相同的使用。</target>
        </trans-unit>
        <trans-unit id="d3f798f5adf38af98cf182c37eab7725c5f2cb46" translate="yes" xml:space="preserve">
          <source>If you consider the following:</source>
          <target state="translated">如果你考虑到以下几点:</target>
        </trans-unit>
        <trans-unit id="39889263d487079852bb1c20c0aa134d99325643" translate="yes" xml:space="preserve">
          <source>If you have:</source>
          <target state="translated">如果你有。</target>
        </trans-unit>
        <trans-unit id="3d535b65e069fedb4050c6a2e3fdb6276eaaa0d0" translate="yes" xml:space="preserve">
          <source>If you need error handling:</source>
          <target state="translated">如果你需要错误处理。</target>
        </trans-unit>
        <trans-unit id="da4a9ca8792c5dc564c13bc23c48d1785b25767f" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Python2&lt;/strong&gt;, &lt;code&gt;os.makedirs&lt;/code&gt; doesn't support setting &lt;code&gt;exist_ok&lt;/code&gt;. You can use the approach in &lt;a href=&quot;https://stackoverflow.com/a/5032238/3109254&quot;&gt;heikki-toivonen's answer&lt;/a&gt;:</source>
          <target state="translated">在&lt;strong&gt;Python2中&lt;/strong&gt; ， &lt;code&gt;os.makedirs&lt;/code&gt; 不支持设置 &lt;code&gt;exist_ok&lt;/code&gt; 。 您可以在&lt;a href=&quot;https://stackoverflow.com/a/5032238/3109254&quot;&gt;heikki-toivonen的答案中&lt;/a&gt;使用该方法：</target>
        </trans-unit>
        <trans-unit id="8625861c30a24838ae98628bdb27d023a533c351" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Python3&lt;/strong&gt;, &lt;code&gt;os.makedirs&lt;/code&gt; supports setting &lt;code&gt;exist_ok&lt;/code&gt;. The default setting is &lt;code&gt;False&lt;/code&gt;, which means an &lt;code&gt;OSError&lt;/code&gt; will be raised if the target directory already exists. By setting &lt;code&gt;exist_ok&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;OSError&lt;/code&gt; (directory exists) will be ignored and the directory will not be created.</source>
          <target state="translated">在&lt;strong&gt;Python3中&lt;/strong&gt; ， &lt;code&gt;os.makedirs&lt;/code&gt; 支持设置 &lt;code&gt;exist_ok&lt;/code&gt; 。 默认设置为 &lt;code&gt;False&lt;/code&gt; ，这意味着如果目标目录已经存在，则会引发 &lt;code&gt;OSError&lt;/code&gt; 。 通过将 &lt;code&gt;exist_ok&lt;/code&gt; 设置为 &lt;code&gt;True&lt;/code&gt; ，将忽略 &lt;code&gt;OSError&lt;/code&gt; （目录存在），并且不会创建目录。</target>
        </trans-unit>
        <trans-unit id="5bc5e0146edc2ae08e3b66fbc6a7f8915debe013" translate="yes" xml:space="preserve">
          <source>In Python 3.4 you can also use the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html&quot;&gt;brand new &lt;code&gt;pathlib&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">在Python 3.4中，您还可以使用&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html&quot;&gt;全新的 &lt;code&gt;pathlib&lt;/code&gt; 模块&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="3b0312661232fca3e0cc2f2d4f7b9512298dd650" translate="yes" xml:space="preserve">
          <source>In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an &lt;code&gt;OSError&lt;/code&gt; raised with &lt;code&gt;errno.EACCES&lt;/code&gt; (Permission denied, error 13).</source>
          <target state="translated">换句话说，我们尝试创建目录，但是如果它们已经存在，我们将忽略该错误。 另一方面，将报告任何其他错误。 例如，如果您预先创建目录'a'并从中删除所有权限，则将出现 &lt;code&gt;errno.EACCES&lt;/code&gt; 引发 &lt;code&gt;OSError&lt;/code&gt; （权限被拒绝，错误13）。</target>
        </trans-unit>
        <trans-unit id="bc2cb7f7490dce0c4ecef3917af3d76415cc76ab" translate="yes" xml:space="preserve">
          <source>In situations where portability doesn't matter (ex, using docker) the solution is a clean 2 lines. You also don't have to add logic to check if directories exist or not. Finally, it is safe to re-run without any side effects</source>
          <target state="translated">在可移植性并不重要的情况下(例如,使用 docker),解决方案是简洁的 2 行。你也不需要添加逻辑来检查目录是否存在。最后,重新运行是安全的,没有任何副作用。</target>
        </trans-unit>
        <trans-unit id="f57111a438a1422cc4a9a213182fba093c5300a3" translate="yes" xml:space="preserve">
          <source>In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the &lt;code&gt;w&lt;/code&gt; mode (or &lt;code&gt;a&lt;/code&gt; to append). It's also a Python best practice to use the context manager for opening files.</source>
          <target state="translated">在这种情况下，我们可能没有面对任何比赛条件。 因此，请照原样进行操作，但请注意，编写时需要使用 &lt;code&gt;w&lt;/code&gt; 模式打开（或添加a）。 使用上下文管理器打开文件也是Python的最佳实践。</target>
        </trans-unit>
        <trans-unit id="7bac4e71dafd67ff58d4f3cd38dc5a8e3db6a7a5" translate="yes" xml:space="preserve">
          <source>Insights on the specifics of this situation</source>
          <target state="translated">关于这种情况的具体情况的见解</target>
        </trans-unit>
        <trans-unit id="94a86bef186f48282460ed5f521d706d87bb14f7" translate="yes" xml:space="preserve">
          <source>Is there a flag for &quot;open&quot;, that makes this happen automatically?</source>
          <target state="translated">有没有一个 &quot;打开 &quot;的标志,让这种情况自动发生?</target>
        </trans-unit>
        <trans-unit id="53a6078a60c2df8b65bf5650f02981b382340f9c" translate="yes" xml:space="preserve">
          <source>It prompts users for input of the directory and can be easily modified.</source>
          <target state="translated">它提示用户输入目录,可以方便的修改。</target>
        </trans-unit>
        <trans-unit id="2c98cd5e104877c93e7679c628c3a41a50e08e7f" translate="yes" xml:space="preserve">
          <source>It works for Python 2 and 3.</source>
          <target state="translated">它适用于Python 2和3。</target>
        </trans-unit>
        <trans-unit id="7da5e505d3b9d04e82715fd31962bc7254adf01d" translate="yes" xml:space="preserve">
          <source>Just attempt to open the file.</source>
          <target state="translated">只要尝试打开文件就可以了。</target>
        </trans-unit>
        <trans-unit id="ffb042fc6fd8ec1e8c1ccfc1c371d7c8a49dd347" translate="yes" xml:space="preserve">
          <source>Modern versions of Python improve this code quite a bit, both by exposing &lt;a href=&quot;https://docs.python.org/3.3/library/exceptions.html?#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; (in 3.3+)...</source>
          <target state="translated">现代版本的Python通过暴露&lt;a href=&quot;https://docs.python.org/3.3/library/exceptions.html?#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; （在3.3+版本中）大大改进了此代码。</target>
        </trans-unit>
        <trans-unit id="55638ec05de3f80638e1e9ba3970e3a5f900619e" translate="yes" xml:space="preserve">
          <source>New in Python 3.5: &lt;code&gt;pathlib.Path&lt;/code&gt; with &lt;code&gt;exist_ok&lt;/code&gt;</source>
          <target state="translated">Python 3.5的新功能：具有 &lt;code&gt;exist_ok&lt;/code&gt; 的pathlib.Path</target>
        </trans-unit>
        <trans-unit id="e9a44c5e1ab9cdaaa3baa8a75f9dca9b73072610" translate="yes" xml:space="preserve">
          <source>Note that capturing the exception and using &lt;code&gt;errno&lt;/code&gt; is of limited usefulness because &lt;code&gt;OSError: [Errno 17] File exists&lt;/code&gt;, i.e. &lt;code&gt;errno.EEXIST&lt;/code&gt;, is raised for both files and directories. It is more reliable simply to check if the directory exists.</source>
          <target state="translated">请注意，捕获异常并使用 &lt;code&gt;errno&lt;/code&gt; 的用途有限，因为 &lt;code&gt;OSError: [Errno 17] File exists&lt;/code&gt; ，即为文件和目录引发 &lt;code&gt;errno.EEXIST&lt;/code&gt; 。 仅检查目录是否存在更为可靠。</target>
        </trans-unit>
        <trans-unit id="7a148cef5cbd02be1bd31d991f8041fdbd60ae6b" translate="yes" xml:space="preserve">
          <source>Note that it will create the ancestor directories as well.</source>
          <target state="translated">注意,它也会创建祖先目录。</target>
        </trans-unit>
        <trans-unit id="82ccbd2ecaf0605297a7236e42508b9b3d15fdd4" translate="yes" xml:space="preserve">
          <source>Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.</source>
          <target state="translated">现在,正如我所说,这并不是真正的万无一失,因为我们有可能无法创建目录,而另一个进程在这期间创建目录。</target>
        </trans-unit>
        <trans-unit id="3e1d25d6194016ea62683fc16ffea1c40c3692d1" translate="yes" xml:space="preserve">
          <source>On Python &amp;ge; 3.5, use &lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;pathlib.Path.mkdir&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在&lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;pathlib.Path.mkdir&lt;/code&gt; &lt;/a&gt; ，使用pathlib.Path.mkdir ：</target>
        </trans-unit>
        <trans-unit id="e2ca98d5312a1b512bc5c2fe3a1c52f2cf022ea3" translate="yes" xml:space="preserve">
          <source>One option would be to trap the &lt;code&gt;OSError&lt;/code&gt; and examine the embedded error code (see &lt;a href=&quot;https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror&quot;&gt;Is there a cross-platform way of getting information from Python&amp;rsquo;s OSError&lt;/a&gt;):</source>
          <target state="translated">一种选择是捕获 &lt;code&gt;OSError&lt;/code&gt; 并检查嵌入式错误代码（请参阅&lt;a href=&quot;https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror&quot;&gt;是否存在从Python的OSError中获取信息的跨平台方法&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="5c5f8f0eeaea28800db9b820b5fbb8284e30bc53" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://bugs.python.org/issue10948&quot;&gt;Bug 10948&lt;/a&gt;, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use &lt;code&gt;mkpath&lt;/code&gt; again to recreate the same directory, &lt;code&gt;mkpath&lt;/code&gt; will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, &lt;code&gt;os.makedirs&lt;/code&gt; doesn't rely on any such cache. This limitation may be okay for some applications.</source>
          <target state="translated">根据&lt;a href=&quot;http://bugs.python.org/issue10948&quot;&gt;Bug 10948&lt;/a&gt; ，此替代方案的严重局限性在于，对于给定路径，每个python进程仅工作一次。 换句话说，如果使用它来创建目录，然后从Python内部或外部删除目录，然后再次使用 &lt;code&gt;mkpath&lt;/code&gt; 来重新创建同一目录，则 &lt;code&gt;mkpath&lt;/code&gt; 将简单地使用其先前已创建目录的无效缓存信息，并且实际上不会再次创建目录。 相反， &lt;code&gt;os.makedirs&lt;/code&gt; 不依赖任何此类缓存。 对于某些应用程序，此限制可能还可以。</target>
        </trans-unit>
        <trans-unit id="b714db9ab64cbcc0558c99fdae141bb4bffeba79" translate="yes" xml:space="preserve">
          <source>Perhaps Pandas should be updated to accept instances of the abstract base class, &lt;code&gt;os.PathLike&lt;/code&gt;.</source>
          <target state="translated">也许应该更新Pandas以接受抽象基类 &lt;code&gt;os.PathLike&lt;/code&gt; 的实例 。</target>
        </trans-unit>
        <trans-unit id="c8b6b264b5910f832bc73c8e3c67b2e6cac151a2" translate="yes" xml:space="preserve">
          <source>Python 2.7+:</source>
          <target state="translated">Python 2.7以上。</target>
        </trans-unit>
        <trans-unit id="9dc5b6e19a47dc56fe4767ef1ee75046725962d3" translate="yes" xml:space="preserve">
          <source>Python 3.2+:</source>
          <target state="translated">Python 3.2以上。</target>
        </trans-unit>
        <trans-unit id="b6c7cbad30d0e4fcc82218434d4da66a329f0f4c" translate="yes" xml:space="preserve">
          <source>Python 3.5+:</source>
          <target state="translated">Python 3.5以上。</target>
        </trans-unit>
        <trans-unit id="99ea9cce0004a02a19d071bb0d88263b0cdffab9" translate="yes" xml:space="preserve">
          <source>Should do the trick on most systems.</source>
          <target state="translated">在大多数系统上应该都能做到。</target>
        </trans-unit>
        <trans-unit id="2528b184172d909d0a003be1f5b82244c09b314c" translate="yes" xml:space="preserve">
          <source>Somehow, I missed &lt;code&gt;os.path.exists&lt;/code&gt; (thanks kanja, Blair, and Douglas). This is what I have now:</source>
          <target state="translated">不知何故，我错过了 &lt;code&gt;os.path.exists&lt;/code&gt; （感谢kanja，Blair和Douglas）。 这就是我现在所拥有的：</target>
        </trans-unit>
        <trans-unit id="741c763ee51bfb7f42f00814eb975dcae82f7c3a" translate="yes" xml:space="preserve">
          <source>Starting from Python 3.5, &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;pathlib.Path.mkdir&lt;/code&gt;&lt;/a&gt; has an &lt;code&gt;exist_ok&lt;/code&gt; flag:</source>
          <target state="translated">从Python 3.5开始， &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;pathlib.Path.mkdir&lt;/code&gt; &lt;/a&gt;具有 &lt;code&gt;exist_ok&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="f5b3a30e36f4f71f626659831f64892222b27ac9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;relevant Python documentation&lt;/a&gt; suggests the use of the &lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;EAFP coding style (Easier to Ask for Forgiveness than Permission)&lt;/a&gt;. This means that the code</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;相关的Python文档&lt;/a&gt;建议使用&lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;EAFP编码样式（比许可权更容易获得宽恕）&lt;/a&gt; 。 这意味着代码</target>
        </trans-unit>
        <trans-unit id="4f2cb7d89de589f8b7b4be46373643c7fc94a4a6" translate="yes" xml:space="preserve">
          <source>The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory:</source>
          <target state="translated">这个问题的直接答案是,假设是一个简单的情况,假设你不指望其他用户或进程来捣乱你的目录。</target>
        </trans-unit>
        <trans-unit id="4710e08c1ac50234e9a8f275e35d17b272a4422c" translate="yes" xml:space="preserve">
          <source>The documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).</source>
          <target state="translated">文档中提出这一点,正是因为这个问题中讨论的竞赛条件。此外,正如其他人在这里提到的,查询一次而不是查询两次操作系统也有性能上的优势。最后,在某些情况下,有可能提出的论点--当开发者知道应用程序运行的环境时--只有在程序为自己(和同一程序的其他实例)设置了一个私有环境的特殊情况下,才有可能主张使用第二种代码。</target>
        </trans-unit>
        <trans-unit id="e70e2a42fc247116f91a4df146bd9f5fac1c216a" translate="yes" xml:space="preserve">
          <source>Then I idempotently ensure the directory exists - the &lt;code&gt;exist_ok&lt;/code&gt; argument shows up in Python 3.5:</source>
          <target state="translated">然后，我确定地确保目录存在-在Python 3.5中显示了 &lt;code&gt;exist_ok&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="33ca90387ef8d91e4035a5b4710c91811fb051a1" translate="yes" xml:space="preserve">
          <source>There's a new &lt;code&gt;Path&lt;/code&gt; object (as of 3.4) with lots of methods one would want to use with paths - one of which is &lt;code&gt;mkdir&lt;/code&gt;.</source>
          <target state="translated">有一个新的 &lt;code&gt;Path&lt;/code&gt; 对象（从3.4版本开始），它具有许多要与路径一起使用的方法-其中之一是 &lt;code&gt;mkdir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="657d6466f2c29036b521dba710de96bf6626c3f1" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;probably&lt;/em&gt; what you're wanting.</source>
          <target state="translated">这&lt;em&gt;可能&lt;/em&gt;就是您想要的。</target>
        </trans-unit>
        <trans-unit id="a27e3016628be07b12b5296742271d571bf02444" translate="yes" xml:space="preserve">
          <source>This recursively creates the directory and does not raise an exception if the directory already exists.</source>
          <target state="translated">如果该目录已经存在,则递归创建该目录,并且不会产生异常。</target>
        </trans-unit>
        <trans-unit id="57735e971e5d9abfe4e85a53e5b3fbec952b4ecf" translate="yes" xml:space="preserve">
          <source>This will check if the file is there if it is not then it will create it.</source>
          <target state="translated">这将检查文件是否存在,如果不存在就会创建它。</target>
        </trans-unit>
        <trans-unit id="aa2b9eba9ec58ac7050dd1d51ea5c53f1d30b5db" translate="yes" xml:space="preserve">
          <source>This works for me and hopefully, it will works for you as well</source>
          <target state="translated">这对我来说很有效,希望你也能用得上</target>
        </trans-unit>
        <trans-unit id="7c2148bdc16b268a891d8a64e49184d47d3abb20" translate="yes" xml:space="preserve">
          <source>To handle the fact the directory might exist, catch &lt;code&gt;OSError&lt;/code&gt;.
(If &lt;code&gt;exist_ok&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; (the default), an &lt;code&gt;OSError&lt;/code&gt; is raised if the target directory already exists.)</source>
          <target state="translated">要处理目录可能存在的事实，请捕获 &lt;code&gt;OSError&lt;/code&gt; 。 （如果 &lt;code&gt;exist_ok&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; （默认值），则在目标目录已存在的情况下引发 &lt;code&gt;OSError&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="413520a3e50df142a8c05148995fafc683b360a4" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt;, and consider &lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt; for the creation.</source>
          <target state="translated">尝试使用&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; &lt;/a&gt; ，并考虑使用&lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt;进行创建。</target>
        </trans-unit>
        <trans-unit id="d3a86694ded81c408581f5b397aed6145c4f9368" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">尝试&lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; &lt;/a&gt;函数</target>
        </trans-unit>
        <trans-unit id="d93092b9342d22e87a8ef4100a56936800ce7a2c" translate="yes" xml:space="preserve">
          <source>Use this command check and create dir</source>
          <target state="translated">使用此命令检查并创建dir</target>
        </trans-unit>
        <trans-unit id="525d8f8ad87a61e4610250dc956442abe1b9c698" translate="yes" xml:space="preserve">
          <source>Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:</source>
          <target state="translated">使用try except和Errno模块中的正确错误代码可以摆脱竞赛条件,并且是跨平台的。</target>
        </trans-unit>
        <trans-unit id="917f074e5df4ab35c7e80d23c79df3c2ec82b36f" translate="yes" xml:space="preserve">
          <source>We don't have to deal with &lt;code&gt;os.path.join&lt;/code&gt; now - just join path parts with a &lt;code&gt;/&lt;/code&gt;:</source>
          <target state="translated">我们现在不必处理 &lt;code&gt;os.path.join&lt;/code&gt; -只需使用 &lt;code&gt;/&lt;/code&gt; 连接路径部分：</target>
        </trans-unit>
        <trans-unit id="99ce28997107d476e9fc3a63d0852739434e0296" translate="yes" xml:space="preserve">
          <source>We want to avoid overwriting the builtin function, &lt;code&gt;dir&lt;/code&gt;. Also, &lt;code&gt;filepath&lt;/code&gt; or perhaps &lt;code&gt;fullfilepath&lt;/code&gt; is probably a better semantic name than &lt;code&gt;filename&lt;/code&gt; so this would be better written:</source>
          <target state="translated">我们要避免覆盖内置函数 &lt;code&gt;dir&lt;/code&gt; 。 而且，文件 &lt;code&gt;filepath&lt;/code&gt; 或也许全 &lt;code&gt;filename&lt;/code&gt; 路径可能是比文件名更好的语义名称，因此这样写会更好：</target>
        </trans-unit>
        <trans-unit id="a1a9dedb1be746f42e86f1ff0f02a289d4ab1d3a" translate="yes" xml:space="preserve">
          <source>What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:</source>
          <target state="translated">有什么最优雅的方法来检查文件要写入的目录是否存在,如果不存在,用Python创建目录?以下是我的尝试。</target>
        </trans-unit>
        <trans-unit id="d28058b7ba10d7c6fe4a05256f5ed97045c03268" translate="yes" xml:space="preserve">
          <source>Where your code here is use the (touch) command</source>
          <target state="translated">你这里的代码是使用(触摸)命令</target>
        </trans-unit>
        <trans-unit id="f2e23ce686569ad8350733206c7706eea07f3673" translate="yes" xml:space="preserve">
          <source>While a naive solution may first use &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.isdir&quot;&gt;&lt;code&gt;os.path.isdir&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt;, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.</source>
          <target state="translated">虽然幼稚的解决方案可能首先使用&lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.isdir&quot;&gt; &lt;code&gt;os.path.isdir&lt;/code&gt; ,&lt;/a&gt;然后使用&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt; ，但是上述解决方案颠倒了这两个操作的顺序。 这样，它可以防止由于创建目录的重复尝试而导致的常见竞争状况，并且还可以消除目录中文件的歧义。</target>
        </trans-unit>
        <trans-unit id="ac34cea4b6ca681e86fcb74a12d4d027962a4177" translate="yes" xml:space="preserve">
          <source>Why not use subprocess module if running on a machine that supports command 
&lt;code&gt;mkdir&lt;/code&gt; with &lt;code&gt;-p&lt;/code&gt; option ? 
Works on python 2.7 and python 3.6</source>
          <target state="translated">如果在支持带有 &lt;code&gt;-p&lt;/code&gt; 选项的命令 &lt;code&gt;mkdir&lt;/code&gt; 的计算机上运行，​​为什么不使用子进程模块？ 适用于python 2.7和python 3.6</target>
        </trans-unit>
        <trans-unit id="e4777a61e82b0ede8c278f3167a642217b27846d" translate="yes" xml:space="preserve">
          <source>Why would you make a directory for a file that you expect to be there and be able to read?</source>
          <target state="translated">你为什么要为一个你期望在那里的文件做一个目录,并且能够读取?</target>
        </trans-unit>
        <trans-unit id="614d7fe50ef625fdc00076885ef6a0958e2074f3" translate="yes" xml:space="preserve">
          <source>With regard to the directory's &lt;em&gt;mode&lt;/em&gt;, please refer to the documentation if you care about it.</source>
          <target state="translated">关于目录的&lt;em&gt;模式&lt;/em&gt; ，如果您关心它，请参考文档。</target>
        </trans-unit>
        <trans-unit id="2733f4de239159b7954ae10717a9de4a0d8f2130" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt;&lt;code&gt;mkpath&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt; &lt;code&gt;mkpath&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06628bc05e1d54f41341f98d20675258e87615f8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;os.listdir&lt;/code&gt; for this:</source>
          <target state="translated">您可以为此使用 &lt;code&gt;os.listdir&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7cf103c255fa677ea9f423097c9a44c5cfe7a020" translate="yes" xml:space="preserve">
          <source>You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:</source>
          <target state="translated">你给一个特定的文件在某一个路径,你从文件路径中拉出目录。然后在确定了目录之后,再尝试打开一个文件进行读取。要对这段代码进行注释。</target>
        </trans-unit>
        <trans-unit id="6052af5853fd347b0aeab05bc6bcc4f07874858c" translate="yes" xml:space="preserve">
          <source>You have to set the full path before creating the directory:</source>
          <target state="translated">你必须在创建目录前设置完整路径。</target>
        </trans-unit>
        <trans-unit id="56d28d9565a39da08aca1caa9e22049b44a768f3" translate="yes" xml:space="preserve">
          <source>Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for &lt;strong&gt;reading&lt;/strong&gt;:</source>
          <target state="translated">您的最终目标是打开该文件，一开始就声明要写入，但是实际上您正在达到这个目标（基于您的代码），就像这样，打开该文件进行&lt;strong&gt;读取&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="0c7364050c5331f5b0b43cbfbb9de956a1867c02" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist&quot;&gt;How can I create a directory if it does not exist?&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist&quot;&gt;如果目录不存在，如何创建？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="549fd39871f5892c4092cced01f37a74c23c77cc" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt;https://docs.python.org/3/library/os.html#os.makedirs&lt;/a&gt;</source>
          <target state="translated">[2] &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt;https://docs.python.org/3/library/os.html#os.makedirs&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ac45d7f4ee3550c6ad3415c9a62ec084feb6538" translate="yes" xml:space="preserve">
          <source>is better than the alternative</source>
          <target state="translated">胜在</target>
        </trans-unit>
        <trans-unit id="32133da69c38d6a432b2087ec0dfe35d3e89bf02" translate="yes" xml:space="preserve">
          <source>means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists.</source>
          <target state="translated">表示一个目录(路径)存在并且是一个目录。所以对我来说,这种方式可以满足我的需求。所以我可以确定它是文件夹(不是文件),并且存在。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
