<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/273192">
    <body>
      <group id="273192">
        <trans-unit id="3121ac2ed4bcb912f44c1a708fd4fa005c62df64" translate="yes" xml:space="preserve">
          <source>(For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)</source>
          <target state="translated">상황에 따라 스크립트를 사용하여 주간 담당자를 추적하고 있습니다. 다음은 동일한 데이터에 대해 하루에 두 번 이상 스택 오버플로를 피할 수있게하는 스크립트의 관련 코드 부분입니다.</target>
        </trans-unit>
        <trans-unit id="3eb796c0d6b99c763af93d3b97f34d9a1877151e" translate="yes" xml:space="preserve">
          <source>(just as &lt;a href=&quot;https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt; got an &lt;code&gt;exist_ok&lt;/code&gt; flag starting from python 3.2 e.g &lt;code&gt;os.makedirs(path, exist_ok=True)&lt;/code&gt;)</source>
          <target state="translated">( &lt;a href=&quot;https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt; 가 python 3.2에서 시작하여 &lt;code&gt;exist_ok&lt;/code&gt; 플래그를 얻은 것처럼 os.makedirs &lt;code&gt;os.makedirs(path, exist_ok=True)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="18a3c7a1b3ef5d5d0b224c6076395a8aa2e4273e" translate="yes" xml:space="preserve">
          <source>... You're going to end up with a directory named &lt;code&gt;filename.etc&lt;/code&gt; when you pass that argument to &lt;code&gt;os.makedirs()&lt;/code&gt; if you test with &lt;code&gt;os.path.exists()&lt;/code&gt;.</source>
          <target state="translated">... &lt;code&gt;os.path.exists()&lt;/code&gt; 테스트하면 &lt;code&gt;os.makedirs()&lt;/code&gt; 인수를 전달할 때 &lt;code&gt;filename.etc&lt;/code&gt; 라는 디렉토리가 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="12b82177815800e1d2adf2e41a4a0b40631382f5" translate="yes" xml:space="preserve">
          <source>...and by allowing &lt;a href=&quot;https://docs.python.org/3.2/library/os.html#os.makedirs&quot;&gt;a keyword argument to &lt;code&gt;os.makedirs&lt;/code&gt; called &lt;code&gt;exist_ok&lt;/code&gt;&lt;/a&gt; (in 3.2+).</source>
          <target state="translated">&amp;hellip; &lt;a href=&quot;https://docs.python.org/3.2/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;exist_ok&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;os.makedirs&lt;/code&gt; 라는 os.makedirs에 키워드 인수를 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="d2cb971d27ac509e9772623d927e6363ff0a92a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt;&lt;code&gt;mkpath&lt;/code&gt;&lt;/a&gt; creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt; &lt;code&gt;mkpath&lt;/code&gt; &lt;/a&gt; 는 내포 된 디렉토리를 작성하고 디렉토리가 이미 존재하면 아무 것도 수행하지 않습니다. 이것은 Python 2와 3에서 모두 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0443b8240c037eb60f44be401cd11e8ad86dd87b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt; as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional &lt;code&gt;exist_ok&lt;/code&gt; argument only if using Python 3.2+, with a default value of &lt;code&gt;False&lt;/code&gt;. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.</source>
          <target state="translated">위에서 사용한 &lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt; 는 디렉토리를 재귀 적으로 작성하며 디렉토리가 이미 존재하는 경우 예외를 발생시키지 않습니다. Python 3.2 이상을 사용하는 경우에만 기본값 인 &lt;code&gt;False&lt;/code&gt; 를 사용하는 경우에만 선택적 &lt;code&gt;exist_ok&lt;/code&gt; 인수가 있습니다. 이 인수는 Python 2.x에서 2.7까지 존재하지 않습니다. 따라서 Python 2.7에서와 같이 수동 예외 처리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c69cbbeb4b9bb92190a2541fb7a478447ef001ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;pathlib.Path.mkdir&lt;/code&gt;&lt;/a&gt; as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the &lt;code&gt;parents&lt;/code&gt; argument.</source>
          <target state="translated">위에서 사용한 &lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;pathlib.Path.mkdir&lt;/code&gt; &lt;/a&gt; 는 디렉토리를 재귀 적으로 작성하며 디렉토리가 이미 존재하는 경우 예외를 발생시키지 않습니다. 부모를 만들 필요가 없거나 원하지 않는 경우 &lt;code&gt;parents&lt;/code&gt; 인수를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5722f73ffd926bda9aeb0c49ae9810a9cdeffffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Path&lt;/code&gt; objects have to be coerced to &lt;code&gt;str&lt;/code&gt; before other APIs that expect &lt;code&gt;str&lt;/code&gt; paths can use them.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 경로를 사용할 수있는 다른 API가 사용하기 전에 &lt;code&gt;Path&lt;/code&gt; 객체를 &lt;code&gt;str&lt;/code&gt; 로 강제 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="02fbfa8e9162845467edc255293ffbc665a98adc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Check if a directory exists and create it if necessary?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;디렉토리가 존재하는지 확인하고 필요한 경우 작성 하시겠습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e2a9d4549bcebed0d695f93286f43be9880e1ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using &lt;code&gt;os&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;os&lt;/code&gt; 사용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="513f1e61389d5d53dc42b6dd097dcfa305b4e3e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using &lt;code&gt;pathlib&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;pathlib&lt;/code&gt; 사용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90a13575f8e0892507d63b6f2ba2e38915862974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or&lt;/strong&gt; if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:</source>
          <target state="translated">&lt;strong&gt;또는&lt;/strong&gt; 디렉토리를 만드는 데 경쟁 조건이 적용되는 경우 (예 : 경로를 확인한 후 다른 항목이 이미 만든 경우) 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3b8239e68048624328c3887db9856779071451e0" translate="yes" xml:space="preserve">
          <source>Alternative:</source>
          <target state="translated">Alternative:</target>
        </trans-unit>
        <trans-unit id="a1cf8b16dad890eb5c4e0c9271810e8851b63291" translate="yes" xml:space="preserve">
          <source>Alternatively, there could be a second &lt;code&gt;os.path.exists&lt;/code&gt;, but suppose another created the directory after the first check, then removed it before the second one &amp;ndash; we could still be fooled.</source>
          <target state="translated">또는 두 번째 &lt;code&gt;os.path.exists&lt;/code&gt; 가있을 수 있지만 첫 번째 검사 후 다른 디렉터리를 만든 다음 두 번째 디렉터리 이전에 해당 디렉터리를 제거했다고 가정하면 여전히 속일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5425ec8a183a1bc6b38039d433238fd743244e9d" translate="yes" xml:space="preserve">
          <source>And a foolish user input:</source>
          <target state="translated">그리고 어리석은 사용자 입력 :</target>
        </trans-unit>
        <trans-unit id="1c86fe1e6829df459e27c81259e6840525f66bc8" translate="yes" xml:space="preserve">
          <source>As noted in comments and elsewhere, there's a race condition &amp;ndash; if the directory is created between the &lt;code&gt;os.path.exists&lt;/code&gt; and the &lt;code&gt;os.makedirs&lt;/code&gt; calls, the &lt;code&gt;os.makedirs&lt;/code&gt; will fail with an &lt;code&gt;OSError&lt;/code&gt;. Unfortunately, blanket-catching &lt;code&gt;OSError&lt;/code&gt; and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</source>
          <target state="translated">주석과 다른 곳에서 언급했듯이 경쟁 조건이 있습니다. &lt;code&gt;os.path.exists&lt;/code&gt; 와 &lt;code&gt;os.makedirs&lt;/code&gt; 호출 사이에 디렉토리가 생성되면 &lt;code&gt;os.makedirs&lt;/code&gt; 는 &lt;code&gt;OSError&lt;/code&gt; 와 함께 실패합니다. 불행히도, 불완전한 권한, 전체 디스크 등과 같은 다른 요인으로 인해 디렉토리를 만들지 못하는 것을 무시할 것이므로 담요 잡기 &lt;code&gt;OSError&lt;/code&gt; 및 계속은 절대 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7ee80f57ba0d6d00c9276e06f774ed3925ebe0d9" translate="yes" xml:space="preserve">
          <source>Assuming opening for reading</source>
          <target state="translated">독서를위한 오프닝 가정</target>
        </trans-unit>
        <trans-unit id="a732816cb0c9b0cc684d45193ba9368d44c027e2" translate="yes" xml:space="preserve">
          <source>Assuming we're opening for writing</source>
          <target state="translated">우리가 글쓰기를 시작한다고 가정</target>
        </trans-unit>
        <trans-unit id="8c423e5c0dfe6a62a16b5a6a6f5ed6162e97b8c5" translate="yes" xml:space="preserve">
          <source>But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via &lt;a href=&quot;https://docs.python.org/library/tempfile.html#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그러나 &lt;a href=&quot;https://docs.python.org/library/tempfile.html#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile&lt;/code&gt; 을&lt;/a&gt; 통해 임시 디렉토리를 사용하여 리소스 경합 문제를 피하는 것이 더 나은 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1673fa7c1d5fc36445668c4adb7c1b8bc89428" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;create_dir()&lt;/code&gt; at the entry point of your program/project.</source>
          <target state="translated">프로그램 / 프로젝트의 시작점에서 &lt;code&gt;create_dir()&lt;/code&gt; 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="01ca4760ac618ba068fbfb39127ce9adee4f1bac" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt;:  (It makes sure the complete path exists.)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt; : (전체 경로가 존재하는지 확인하십시오.)</target>
        </trans-unit>
        <trans-unit id="6164c0b5b7d56fc2c96acfc1e85d0aea94d39e63" translate="yes" xml:space="preserve">
          <source>Conclusion: in my opinion, &quot;Method 2&quot; is more robust.</source>
          <target state="translated">결론 : 제 생각에는 &quot;방법 2&quot;가 더 강력합니다.</target>
        </trans-unit>
        <trans-unit id="2f45eec4334aa25687d578b05a730ae07f2d8c14" translate="yes" xml:space="preserve">
          <source>Consider this directory structure:</source>
          <target state="translated">이 디렉토리 구조를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d2d4fee838a956a0a5155cf4a5747b0668a441c2" translate="yes" xml:space="preserve">
          <source>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</source>
          <target state="translated">응용 프로그램에 따라 동시 작업의 위험은 파일 권한과 같은 다른 요인으로 인한 위험보다 많거나 적을 수 있습니다. 개발자는 구현을 선택하기 전에 개발중인 특정 응용 프로그램과 예상 환경에 대해 더 많이 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="deae96764aa4587da73f1ce1ffb9899c015ce4c4" translate="yes" xml:space="preserve">
          <source>Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.</source>
          <target state="translated">이 경우에도 이것은 나쁜 습관이며 오랫동안 쓸모없는 디버깅으로 이어질 수 있습니다. 예를 들어, 디렉토리에 대한 권한을 설정한다는 사실은 노출 권한이 목적에 맞게 설정되어 있지 않아야합니다. 상위 디렉토리는 다른 권한으로 마운트 될 수 있습니다. 일반적으로 프로그램은 항상 올바르게 작동해야하며 프로그래머는 특정 환경을 기 대해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="35c95b4868de9bf6ba8db931f46dd2e29eb6e01c" translate="yes" xml:space="preserve">
          <source>First the relevant imports:</source>
          <target state="translated">먼저 관련 수입품 :</target>
        </trans-unit>
        <trans-unit id="f48e8c1c7ccf846218c4fb87f4a1f71363cf5c47" translate="yes" xml:space="preserve">
          <source>For a one-liner solution, you can use &lt;a href=&quot;https://github.com/ipython/ipython/blob/b70b3f21749ca969088fdb54edcc36bb8a2267b9/IPython/utils/path.py#L423-L438&quot;&gt;&lt;code&gt;IPython.utils.path.ensure_dir_exists()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">한 줄짜리 솔루션의 경우 &lt;a href=&quot;https://github.com/ipython/ipython/blob/b70b3f21749ca969088fdb54edcc36bb8a2267b9/IPython/utils/path.py#L423-L438&quot;&gt; &lt;code&gt;IPython.utils.path.ensure_dir_exists()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eb6cd999782910d8577c5e49c2cabbd7c4cfe91" translate="yes" xml:space="preserve">
          <source>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:</source>
          <target state="translated">이전 버전의 Python의 경우 작은 결함이있는 좋은 품질의 두 가지 답변을 보았습니다. 따라서 이에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ad50b66f54fc8b40a971a312b1e7b1f89975e434" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists&quot;&gt;documentation&lt;/a&gt;: &lt;em&gt;Ensure that a directory exists. If it doesn&amp;rsquo;t exist, try to create it and protect against a race condition if another process is doing the same.&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists&quot;&gt;설명서에서&lt;/a&gt; : &lt;em&gt;디렉토리가 존재하는지 확인하십시오.&lt;/em&gt; &lt;em&gt;존재하지 않는 경우 다른 프로세스가 동일한 작업을 수행하는 경우이를 작성하고 경쟁 조건으로부터 보호하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac620040ee41da4ac4af95274cdd1c3f011dd85f" translate="yes" xml:space="preserve">
          <source>Here are my experiments/notes, which clarifies things:</source>
          <target state="translated">다음은 실험 / 노트입니다.</target>
        </trans-unit>
        <trans-unit id="4f35d5503e88dfd831b6147a4612e9bccc4447fc" translate="yes" xml:space="preserve">
          <source>Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory.</source>
          <target state="translated">여기에 약간의 스크립트가 있습니다-제 경우에는 경쟁 조건이 아니며 디렉토리 (또는 포함 된 파일)가있을 것으로 예상되는 프로세스가 하나 뿐이며 제거하려는 것이 없습니다. 디렉토리.</target>
        </trans-unit>
        <trans-unit id="a3a28383d88c9f97f89da0f85ed2d6ea047cf57b" translate="yes" xml:space="preserve">
          <source>Here's the essentials from the online doc:</source>
          <target state="translated">온라인 문서의 필수 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="422c9974b57e23de918cca25a8e4e75144ac9949" translate="yes" xml:space="preserve">
          <source>Here's the relevant part of the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;문서&lt;/a&gt; 의 관련 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abc4d97edcbb87d0e3301e065d3b93e2104ed36d" translate="yes" xml:space="preserve">
          <source>How can I safely create a nested directory</source>
          <target state="translated">내포 된 디렉토리를 안전하게 만드는 방법</target>
        </trans-unit>
        <trans-unit id="43df623a8684ce2d0992ddf3e318fee0b73a5bca" translate="yes" xml:space="preserve">
          <source>However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the &lt;code&gt;makedirs&lt;/code&gt; call in a try-except block.</source>
          <target state="translated">그러나 모든 데이터를 동일한 디렉토리에 넣으려고 시도하는 여러 Python 프로세스가 있다고 가정하십시오. 그런 다음 디렉토리 작성에 대한 경합이있을 수 있습니다. 이 경우 &lt;code&gt;makedirs&lt;/code&gt; 호출을 try-except 블록에 래핑하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01b533ca1cfd4009ed30def6151904b1fbc1ac26" translate="yes" xml:space="preserve">
          <source>I found this Q/A and I was initially puzzled by some of the failures and errors I was getting. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system).</source>
          <target state="translated">나는이 Q / A를 발견했고 처음에 내가 겪고있는 몇 가지 실패와 오류에 당황했습니다. Python 3 (Arch Linux x86_64 시스템의 Anaconda 가상 환경에서 v.3.5)에서 일하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcf2d027a264623ff0d6f130ef23fd5cf6a23215" translate="yes" xml:space="preserve">
          <source>I have put the following down. It's not totally foolproof though.</source>
          <target state="translated">나는 다음을 내려 놓았다. 그러나 완전히 바보는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9d92b1d4efb363280e561cb068cc7fe185f10913" translate="yes" xml:space="preserve">
          <source>I saw &lt;a href=&quot;https://stackoverflow.com/a/5032238/3051142&quot;&gt;Heikki Toivonen&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/14364249&quot;&gt;A-B-B&lt;/a&gt;'s answers and thought of this variation.</source>
          <target state="translated">나는 &lt;a href=&quot;https://stackoverflow.com/a/5032238/3051142&quot;&gt;Heikki Toivonen&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/a/14364249&quot;&gt;ABB&lt;/a&gt; 의 답변을 보았고이 변형에 대해 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="44bc7785155af664bc388bf4072f7f57fab5223a" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;os.path.exists()&lt;/code&gt;, &lt;a href=&quot;http://pastebin.com/vnVk2rY5&quot;&gt;here&lt;/a&gt; is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired).</source>
          <target state="translated">&lt;code&gt;os.path.exists()&lt;/code&gt; . &lt;a href=&quot;http://pastebin.com/vnVk2rY5&quot;&gt;여기서&lt;/a&gt; 디렉토리가 존재하는지 확인하고 존재하지 않는 경우 디렉토리를 만들고 존재하는 경우 삭제하는 데 사용할 수있는 Python 3 스크립트가 있습니다 (원하는 경우).</target>
        </trans-unit>
        <trans-unit id="dda21083479a5a551734a83ecabb56f6a839f5f8" translate="yes" xml:space="preserve">
          <source>I would personally recommend that you use &lt;code&gt;os.path.isdir()&lt;/code&gt; to test instead of &lt;code&gt;os.path.exists()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.path.isdir()&lt;/code&gt; 대신 os.path.isdir () 을 사용하여 테스트하는 것이 개인적으로 권장합니다.</target>
        </trans-unit>
        <trans-unit id="98719f93c1117e90bd3d2ccd57a9fbbebdadfceb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exist_ok&lt;/code&gt; is true, &lt;code&gt;FileExistsError&lt;/code&gt; exceptions will be ignored (same behavior as the &lt;code&gt;POSIX mkdir -p&lt;/code&gt; command), but only if the last path component is not an existing non-directory file.</source>
          <target state="translated">&lt;code&gt;exist_ok&lt;/code&gt; 가 true 인 경우 마지막 경로 구성 요소가 기존의 디렉토리가 아닌 파일이 아닌 경우에만 &lt;code&gt;FileExistsError&lt;/code&gt; 예외가 무시됩니다 ( &lt;code&gt;POSIX mkdir -p&lt;/code&gt; 명령과 동일한 동작).</target>
        </trans-unit>
        <trans-unit id="9c76336e3b2bcc4c3ff147925ca8a2045da088d7" translate="yes" xml:space="preserve">
          <source>If the directory or file isn't there, you'll get an &lt;code&gt;IOError&lt;/code&gt; with an associated error number: &lt;code&gt;errno.ENOENT&lt;/code&gt; will point to the correct error number regardless of your platform. You can catch it if you want, for example:</source>
          <target state="translated">디렉토리 나 파일이 없으면 관련 오류 번호와 함께 &lt;code&gt;IOError&lt;/code&gt; 가 발생합니다. &lt;code&gt;errno.ENOENT&lt;/code&gt; 는 플랫폼에 관계없이 올바른 오류 번호를 가리 킵니다. 예를 들어 원하는 경우 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f877478b34abfa92dad52ab6be30c3ff05158b" translate="yes" xml:space="preserve">
          <source>If using Python 3.4, even though it comes with &lt;code&gt;pathlib&lt;/code&gt;, it is missing the useful &lt;code&gt;exist_ok&lt;/code&gt; option. The backport is intended to offer a newer and superior implementation of &lt;code&gt;mkdir&lt;/code&gt; which includes this missing option.</source>
          <target state="translated">Python 3.4를 사용하는 경우 &lt;code&gt;pathlib&lt;/code&gt; 와 함께 제공되지만 유용한 &lt;code&gt;exist_ok&lt;/code&gt; 옵션이 없습니다. 백 포트는이 누락 된 옵션을 포함하는 &lt;code&gt;mkdir&lt;/code&gt; 의 새롭고 우수한 구현을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f859712e9880cf77f7dea1b20c5921a1728a2543" translate="yes" xml:space="preserve">
          <source>If you can, install the current &lt;code&gt;pathlib&lt;/code&gt; backport named &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt;&lt;code&gt;pathlib2&lt;/code&gt;&lt;/a&gt;. Do not install the older unmaintained backport named &lt;a href=&quot;https://pypi.python.org/pypi/pathlib/&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt;. Next, refer to the Python 3.5+ section above and use it the same.</source>
          <target state="translated">가능하면 &lt;code&gt;pathlib&lt;/code&gt; 2 라는 현재 pathlib 백 포트를 설치하십시오. &lt;a href=&quot;https://pypi.python.org/pypi/pathlib/&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt; 라는 오래된 유지 관리되지 않은 백 포트를 설치하지 마십시오. 다음으로, 위의 Python 3.5+ 섹션을 참조하여 동일하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d3f798f5adf38af98cf182c37eab7725c5f2cb46" translate="yes" xml:space="preserve">
          <source>If you consider the following:</source>
          <target state="translated">다음을 고려하면 :</target>
        </trans-unit>
        <trans-unit id="39889263d487079852bb1c20c0aa134d99325643" translate="yes" xml:space="preserve">
          <source>If you have:</source>
          <target state="translated">당신이 가지고 있다면:</target>
        </trans-unit>
        <trans-unit id="3d535b65e069fedb4050c6a2e3fdb6276eaaa0d0" translate="yes" xml:space="preserve">
          <source>If you need error handling:</source>
          <target state="translated">오류 처리가 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="da4a9ca8792c5dc564c13bc23c48d1785b25767f" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Python2&lt;/strong&gt;, &lt;code&gt;os.makedirs&lt;/code&gt; doesn't support setting &lt;code&gt;exist_ok&lt;/code&gt;. You can use the approach in &lt;a href=&quot;https://stackoverflow.com/a/5032238/3109254&quot;&gt;heikki-toivonen's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Python2&lt;/strong&gt; 에서 &lt;code&gt;os.makedirs&lt;/code&gt; 는 &lt;code&gt;exist_ok&lt;/code&gt; 설정을 지원하지 않습니다. &lt;a href=&quot;https://stackoverflow.com/a/5032238/3109254&quot;&gt;heikki-toivonen의 답변&lt;/a&gt; 에서 접근 방식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8625861c30a24838ae98628bdb27d023a533c351" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Python3&lt;/strong&gt;, &lt;code&gt;os.makedirs&lt;/code&gt; supports setting &lt;code&gt;exist_ok&lt;/code&gt;. The default setting is &lt;code&gt;False&lt;/code&gt;, which means an &lt;code&gt;OSError&lt;/code&gt; will be raised if the target directory already exists. By setting &lt;code&gt;exist_ok&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;OSError&lt;/code&gt; (directory exists) will be ignored and the directory will not be created.</source>
          <target state="translated">&lt;strong&gt;Python3&lt;/strong&gt; 에서 &lt;code&gt;os.makedirs&lt;/code&gt; 는 &lt;code&gt;exist_ok&lt;/code&gt; 설정을 지원합니다. 기본 설정은 &lt;code&gt;False&lt;/code&gt; 이며, 대상 디렉토리가 이미 존재하면 &lt;code&gt;OSError&lt;/code&gt; 가 발생합니다. &lt;code&gt;exist_ok&lt;/code&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정하면 &lt;code&gt;OSError&lt;/code&gt; (디렉토리 존재)가 무시되고 디렉토리가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bc5e0146edc2ae08e3b66fbc6a7f8915debe013" translate="yes" xml:space="preserve">
          <source>In Python 3.4 you can also use the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html&quot;&gt;brand new &lt;code&gt;pathlib&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">Python 3.4에서는 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html&quot;&gt;새로운 &lt;code&gt;pathlib&lt;/code&gt; 모듈을&lt;/a&gt; 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b0312661232fca3e0cc2f2d4f7b9512298dd650" translate="yes" xml:space="preserve">
          <source>In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an &lt;code&gt;OSError&lt;/code&gt; raised with &lt;code&gt;errno.EACCES&lt;/code&gt; (Permission denied, error 13).</source>
          <target state="translated">다시 말해 디렉토리를 만들려고하지만 이미 존재하는 경우 오류를 무시합니다. 반면에 다른 오류는보고됩니다. 예를 들어, 사전에 dir 'a'를 작성하고 모든 권한을 제거하면 &lt;code&gt;errno.EACCES&lt;/code&gt; (권한 거부, 오류 13)로 &lt;code&gt;OSError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bc2cb7f7490dce0c4ecef3917af3d76415cc76ab" translate="yes" xml:space="preserve">
          <source>In situations where portability doesn't matter (ex, using docker) the solution is a clean 2 lines. You also don't have to add logic to check if directories exist or not. Finally, it is safe to re-run without any side effects</source>
          <target state="translated">이식성이 중요하지 않은 상황 (예 : 도커 사용)에서 솔루션은 깔끔한 2 줄입니다. 또한 디렉토리가 존재하는지 여부를 확인하기 위해 로직을 추가 할 필요가 없습니다. 마지막으로 부작용없이 다시 실행하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f57111a438a1422cc4a9a213182fba093c5300a3" translate="yes" xml:space="preserve">
          <source>In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the &lt;code&gt;w&lt;/code&gt; mode (or &lt;code&gt;a&lt;/code&gt; to append). It's also a Python best practice to use the context manager for opening files.</source>
          <target state="translated">이 경우 경쟁 조건이 없을 것입니다. 따라서 그대로 작업을 수행하지만 쓰기를 위해서는 &lt;code&gt;w&lt;/code&gt; 모드 (또는 추가 할 &lt;code&gt;a&lt;/code&gt; )로 열어야합니다. 컨텍스트 관리자를 사용하여 파일을 여는 것도 Python 모범 사례입니다.</target>
        </trans-unit>
        <trans-unit id="7bac4e71dafd67ff58d4f3cd38dc5a8e3db6a7a5" translate="yes" xml:space="preserve">
          <source>Insights on the specifics of this situation</source>
          <target state="translated">이 상황의 특성에 대한 통찰력</target>
        </trans-unit>
        <trans-unit id="94a86bef186f48282460ed5f521d706d87bb14f7" translate="yes" xml:space="preserve">
          <source>Is there a flag for &quot;open&quot;, that makes this happen automatically?</source>
          <target state="translated">&quot;open&quot;에 대한 플래그가 있습니까? 자동으로 발생합니까?</target>
        </trans-unit>
        <trans-unit id="53a6078a60c2df8b65bf5650f02981b382340f9c" translate="yes" xml:space="preserve">
          <source>It prompts users for input of the directory and can be easily modified.</source>
          <target state="translated">사용자에게 디렉토리를 입력하라는 프롬프트를 표시하며 쉽게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c98cd5e104877c93e7679c628c3a41a50e08e7f" translate="yes" xml:space="preserve">
          <source>It works for Python 2 and 3.</source>
          <target state="translated">파이썬 2와 3에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7da5e505d3b9d04e82715fd31962bc7254adf01d" translate="yes" xml:space="preserve">
          <source>Just attempt to open the file.</source>
          <target state="translated">파일을 열어보십시오.</target>
        </trans-unit>
        <trans-unit id="ffb042fc6fd8ec1e8c1ccfc1c371d7c8a49dd347" translate="yes" xml:space="preserve">
          <source>Modern versions of Python improve this code quite a bit, both by exposing &lt;a href=&quot;https://docs.python.org/3.3/library/exceptions.html?#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; (in 3.3+)...</source>
          <target state="translated">최신 버전의 Python은 &lt;a href=&quot;https://docs.python.org/3.3/library/exceptions.html?#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; (3.3 이상)를 노출 시켜이 코드를 상당히 개선합니다 ...</target>
        </trans-unit>
        <trans-unit id="55638ec05de3f80638e1e9ba3970e3a5f900619e" translate="yes" xml:space="preserve">
          <source>New in Python 3.5: &lt;code&gt;pathlib.Path&lt;/code&gt; with &lt;code&gt;exist_ok&lt;/code&gt;</source>
          <target state="translated">Python 3.5의 새로운 기능 : &lt;code&gt;pathlib.Path&lt;/code&gt; 있는 &lt;code&gt;exist_ok&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9a44c5e1ab9cdaaa3baa8a75f9dca9b73072610" translate="yes" xml:space="preserve">
          <source>Note that capturing the exception and using &lt;code&gt;errno&lt;/code&gt; is of limited usefulness because &lt;code&gt;OSError: [Errno 17] File exists&lt;/code&gt;, i.e. &lt;code&gt;errno.EEXIST&lt;/code&gt;, is raised for both files and directories. It is more reliable simply to check if the directory exists.</source>
          <target state="translated">&lt;code&gt;OSError: [Errno 17] File exists&lt;/code&gt; (예 : &lt;code&gt;errno.EEXIST&lt;/code&gt; )는 파일과 디렉토리 모두에 대해 발생하므로 예외를 캡처하고 &lt;code&gt;errno&lt;/code&gt; 를 사용하는 것은 유용하지 않습니다 . 디렉토리가 존재하는지 확인하는 것이 더 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="7a148cef5cbd02be1bd31d991f8041fdbd60ae6b" translate="yes" xml:space="preserve">
          <source>Note that it will create the ancestor directories as well.</source>
          <target state="translated">또한 조상 디렉토리도 생성합니다.</target>
        </trans-unit>
        <trans-unit id="82ccbd2ecaf0605297a7236e42508b9b3d15fdd4" translate="yes" xml:space="preserve">
          <source>Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.</source>
          <target state="translated">내가 말했듯이, 우리는 디렉토리를 만들지 못할 가능성이 있고 그 기간 동안 다른 프로세스를 만들 수 있기 때문에 이것이 결코 바보가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3e1d25d6194016ea62683fc16ffea1c40c3692d1" translate="yes" xml:space="preserve">
          <source>On Python &amp;ge; 3.5, use &lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;pathlib.Path.mkdir&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Python &amp;ge; 3.5에서는 &lt;a href=&quot;https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;pathlib.Path.mkdir&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2ca98d5312a1b512bc5c2fe3a1c52f2cf022ea3" translate="yes" xml:space="preserve">
          <source>One option would be to trap the &lt;code&gt;OSError&lt;/code&gt; and examine the embedded error code (see &lt;a href=&quot;https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror&quot;&gt;Is there a cross-platform way of getting information from Python&amp;rsquo;s OSError&lt;/a&gt;):</source>
          <target state="translated">한 가지 옵션은 &lt;code&gt;OSError&lt;/code&gt; 를 포착하고 포함 된 오류 코드를 검사하는 &lt;a href=&quot;https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror&quot;&gt;것입니다 (Python의 OSError에서 정보를 가져 오는 플랫폼 간 방법이 있습니까)를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c5f8f0eeaea28800db9b820b5fbb8284e30bc53" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;http://bugs.python.org/issue10948&quot;&gt;Bug 10948&lt;/a&gt;, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use &lt;code&gt;mkpath&lt;/code&gt; again to recreate the same directory, &lt;code&gt;mkpath&lt;/code&gt; will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, &lt;code&gt;os.makedirs&lt;/code&gt; doesn't rely on any such cache. This limitation may be okay for some applications.</source>
          <target state="translated">&lt;a href=&quot;http://bugs.python.org/issue10948&quot;&gt;버그 10948&lt;/a&gt; 당이 대안의 심각한 제한은 주어진 경로에 대해 파이썬 프로세스 당 한 번만 작동한다는 것입니다. 즉, 디렉토리를 생성하는 데 디렉토리를 생성 한 다음 파이썬 내부 또는 외부에서 디렉토리를 삭제 한 다음 &lt;code&gt;mkpath&lt;/code&gt; 를 사용하여 동일한 디렉토리를 다시 생성하면 &lt;code&gt;mkpath&lt;/code&gt; 는 이전에 디렉토리를 생성 한 잘못된 캐시 된 정보를 자동으로 사용합니다. 실제로 디렉토리를 다시 만들지는 않습니다. 반대로, &lt;code&gt;os.makedirs&lt;/code&gt; 는 그러한 캐시에 의존하지 않습니다. 일부 응용 프로그램에서는이 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b714db9ab64cbcc0558c99fdae141bb4bffeba79" translate="yes" xml:space="preserve">
          <source>Perhaps Pandas should be updated to accept instances of the abstract base class, &lt;code&gt;os.PathLike&lt;/code&gt;.</source>
          <target state="translated">아마도 팬더는 추상 기본 클래스 &lt;code&gt;os.PathLike&lt;/code&gt; 의 인스턴스를 허용하도록 업데이트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8b6b264b5910f832bc73c8e3c67b2e6cac151a2" translate="yes" xml:space="preserve">
          <source>Python 2.7+:</source>
          <target state="translated">파이썬 2.7+ :</target>
        </trans-unit>
        <trans-unit id="9dc5b6e19a47dc56fe4767ef1ee75046725962d3" translate="yes" xml:space="preserve">
          <source>Python 3.2+:</source>
          <target state="translated">파이썬 3.2 이상 :</target>
        </trans-unit>
        <trans-unit id="b6c7cbad30d0e4fcc82218434d4da66a329f0f4c" translate="yes" xml:space="preserve">
          <source>Python 3.5+:</source>
          <target state="translated">파이썬 3.5 이상 :</target>
        </trans-unit>
        <trans-unit id="99ea9cce0004a02a19d071bb0d88263b0cdffab9" translate="yes" xml:space="preserve">
          <source>Should do the trick on most systems.</source>
          <target state="translated">대부분의 시스템에서 트릭을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2528b184172d909d0a003be1f5b82244c09b314c" translate="yes" xml:space="preserve">
          <source>Somehow, I missed &lt;code&gt;os.path.exists&lt;/code&gt; (thanks kanja, Blair, and Douglas). This is what I have now:</source>
          <target state="translated">어떻게 든 &lt;code&gt;os.path.exists&lt;/code&gt; (kanja, Blair 및 Douglas 덕분에)를 놓쳤습니다. 이것이 내가 지금 가진 것입니다.</target>
        </trans-unit>
        <trans-unit id="741c763ee51bfb7f42f00814eb975dcae82f7c3a" translate="yes" xml:space="preserve">
          <source>Starting from Python 3.5, &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;pathlib.Path.mkdir&lt;/code&gt;&lt;/a&gt; has an &lt;code&gt;exist_ok&lt;/code&gt; flag:</source>
          <target state="translated">Python 3.5부터 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;pathlib.Path.mkdir&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;exist_ok&lt;/code&gt; 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5b3a30e36f4f71f626659831f64892222b27ac9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;relevant Python documentation&lt;/a&gt; suggests the use of the &lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;EAFP coding style (Easier to Ask for Forgiveness than Permission)&lt;/a&gt;. This means that the code</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;관련 파이썬 문서&lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/2/library/os.html#files-and-directories&quot;&gt;EAFP 코딩 스타일 (권한보다 용서를 구하는 것이 더 쉽다)&lt;/a&gt; 의 사용을 제안합니다. 이것은 코드가</target>
        </trans-unit>
        <trans-unit id="4f2cb7d89de589f8b7b4be46373643c7fc94a4a6" translate="yes" xml:space="preserve">
          <source>The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory:</source>
          <target state="translated">이에 대한 직접적인 대답은 다른 사용자 또는 프로세스가 디렉토리를 망칠 것으로 예상하지 않는 간단한 상황을 가정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4710e08c1ac50234e9a8f275e35d17b272a4422c" translate="yes" xml:space="preserve">
          <source>The documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).</source>
          <target state="translated">문서는이 질문에서 논의 된 경쟁 조건으로 인해 정확하게 제안합니다. 또한 다른 사람들이 언급했듯이 OS의 두 배가 아닌 한 번만 쿼리하면 성능 이점이 있습니다. 마지막으로, 어떤 경우에는 개발자가 응용 프로그램이 실행중인 환경을 알고있을 때 두 번째 코드를 선호하여이 주장이 제기되어 프로그램이 전용 환경을 설정 한 특별한 경우에만 옹호 될 수 있습니다. 자체 (및 동일한 프로그램의 다른 인스턴스).</target>
        </trans-unit>
        <trans-unit id="e70e2a42fc247116f91a4df146bd9f5fac1c216a" translate="yes" xml:space="preserve">
          <source>Then I idempotently ensure the directory exists - the &lt;code&gt;exist_ok&lt;/code&gt; argument shows up in Python 3.5:</source>
          <target state="translated">그런 다음 필자는 idempotently 디렉토리가 존재하는지 확인합니다. &lt;code&gt;exist_ok&lt;/code&gt; 인수는 Python 3.5에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="33ca90387ef8d91e4035a5b4710c91811fb051a1" translate="yes" xml:space="preserve">
          <source>There's a new &lt;code&gt;Path&lt;/code&gt; object (as of 3.4) with lots of methods one would want to use with paths - one of which is &lt;code&gt;mkdir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 와 함께 사용하려는 많은 메소드가있는 새로운 Path 객체 (3.4 현재)가 있습니다-그중 하나는 &lt;code&gt;mkdir&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="657d6466f2c29036b521dba710de96bf6626c3f1" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;probably&lt;/em&gt; what you're wanting.</source>
          <target state="translated">이것은 &lt;em&gt;아마도&lt;/em&gt; 당신이 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a27e3016628be07b12b5296742271d571bf02444" translate="yes" xml:space="preserve">
          <source>This recursively creates the directory and does not raise an exception if the directory already exists.</source>
          <target state="translated">이는 재귀 적으로 디렉토리를 작성하며 디렉토리가 이미 존재하는 경우 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57735e971e5d9abfe4e85a53e5b3fbec952b4ecf" translate="yes" xml:space="preserve">
          <source>This will check if the file is there if it is not then it will create it.</source>
          <target state="translated">파일이 없으면 파일이 있는지 확인한 다음 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aa2b9eba9ec58ac7050dd1d51ea5c53f1d30b5db" translate="yes" xml:space="preserve">
          <source>This works for me and hopefully, it will works for you as well</source>
          <target state="translated">이것은 나를 위해 작동하며 희망적으로도 당신을 위해 작동합니다</target>
        </trans-unit>
        <trans-unit id="7c2148bdc16b268a891d8a64e49184d47d3abb20" translate="yes" xml:space="preserve">
          <source>To handle the fact the directory might exist, catch &lt;code&gt;OSError&lt;/code&gt;.
(If &lt;code&gt;exist_ok&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; (the default), an &lt;code&gt;OSError&lt;/code&gt; is raised if the target directory already exists.)</source>
          <target state="translated">디렉토리가 존재할 수있는 사실을 처리하려면 &lt;code&gt;OSError&lt;/code&gt; 를 잡으십시오. &lt;code&gt;exist_ok&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; (기본값) 인 경우 대상 디렉토리가 이미 존재하면 &lt;code&gt;OSError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="413520a3e50df142a8c05148995fafc683b360a4" translate="yes" xml:space="preserve">
          <source>Try &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt;, and consider &lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt; for the creation.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; 를&lt;/a&gt; 시도하고 작성을 위해 &lt;a href=&quot;https://docs.python.org/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; &lt;/a&gt; 를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d3a86694ded81c408581f5b397aed6145c4f9368" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; &lt;/a&gt; 함수를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="d93092b9342d22e87a8ef4100a56936800ce7a2c" translate="yes" xml:space="preserve">
          <source>Use this command check and create dir</source>
          <target state="translated">이 명령 확인을 사용하고 dir을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="525d8f8ad87a61e4610250dc956442abe1b9c698" translate="yes" xml:space="preserve">
          <source>Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:</source>
          <target state="translated">errno 모듈의 try except 및 올바른 오류 코드를 사용하면 경쟁 조건이 제거되고 크로스 플랫폼이 있습니다.</target>
        </trans-unit>
        <trans-unit id="917f074e5df4ab35c7e80d23c79df3c2ec82b36f" translate="yes" xml:space="preserve">
          <source>We don't have to deal with &lt;code&gt;os.path.join&lt;/code&gt; now - just join path parts with a &lt;code&gt;/&lt;/code&gt;:</source>
          <target state="translated">우리는 지금 &lt;code&gt;os.path.join&lt;/code&gt; 을 다룰 필요가 없습니다. 단지 경로 부분을 &lt;code&gt;/&lt;/code&gt; 로 연결하십시오 :</target>
        </trans-unit>
        <trans-unit id="99ce28997107d476e9fc3a63d0852739434e0296" translate="yes" xml:space="preserve">
          <source>We want to avoid overwriting the builtin function, &lt;code&gt;dir&lt;/code&gt;. Also, &lt;code&gt;filepath&lt;/code&gt; or perhaps &lt;code&gt;fullfilepath&lt;/code&gt; is probably a better semantic name than &lt;code&gt;filename&lt;/code&gt; so this would be better written:</source>
          <target state="translated">내장 함수 &lt;code&gt;dir&lt;/code&gt; 을 덮어 쓰지 않기를 원합니다. 또한 &lt;code&gt;filepath&lt;/code&gt; 또는 &lt;code&gt;fullfilepath&lt;/code&gt; 는 &lt;code&gt;filename&lt;/code&gt; 보다 더 나은 의미 이름 일 수 있으므로 다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a1a9dedb1be746f42e86f1ff0f02a289d4ab1d3a" translate="yes" xml:space="preserve">
          <source>What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:</source>
          <target state="translated">파일을 작성할 디렉토리가 존재하는지 확인하고 그렇지 않은 경우 Python을 사용하여 디렉토리를 작성하는 가장 우아한 방법은 무엇입니까? 내가 시도한 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d28058b7ba10d7c6fe4a05256f5ed97045c03268" translate="yes" xml:space="preserve">
          <source>Where your code here is use the (touch) command</source>
          <target state="translated">여기 코드가 (touch) 명령을 사용하는 곳</target>
        </trans-unit>
        <trans-unit id="f2e23ce686569ad8350733206c7706eea07f3673" translate="yes" xml:space="preserve">
          <source>While a naive solution may first use &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.isdir&quot;&gt;&lt;code&gt;os.path.isdir&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.makedirs&quot;&gt;&lt;code&gt;os.makedirs&lt;/code&gt;&lt;/a&gt;, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.</source>
          <target state="translated">순진한 솔루션은 먼저 &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.isdir&quot;&gt; &lt;code&gt;os.path.isdir&lt;/code&gt; &lt;/a&gt; 다음에 &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.makedirs&quot;&gt; &lt;code&gt;os.makedirs&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있지만 위의 솔루션은 두 작업의 순서를 반대로합니다. 이렇게하면 디렉토리를 만들려는 중복 된 시도와 관련된 일반적인 경쟁 조건이 방지되고 디렉토리에서 파일이 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="ac34cea4b6ca681e86fcb74a12d4d027962a4177" translate="yes" xml:space="preserve">
          <source>Why not use subprocess module if running on a machine that supports command 
&lt;code&gt;mkdir&lt;/code&gt; with &lt;code&gt;-p&lt;/code&gt; option ? 
Works on python 2.7 and python 3.6</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; 옵션과 함께 &lt;code&gt;mkdir&lt;/code&gt; 명령을 지원하는 시스템에서 실행중인 경우 하위 프로세스 모듈을 사용하지 않는 이유는 무엇입니까? Python 2.7 및 Python 3.6에서 작동</target>
        </trans-unit>
        <trans-unit id="e4777a61e82b0ede8c278f3167a642217b27846d" translate="yes" xml:space="preserve">
          <source>Why would you make a directory for a file that you expect to be there and be able to read?</source>
          <target state="translated">거기에 있고 읽을 수있는 파일의 디렉토리를 만드는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="614d7fe50ef625fdc00076885ef6a0958e2074f3" translate="yes" xml:space="preserve">
          <source>With regard to the directory's &lt;em&gt;mode&lt;/em&gt;, please refer to the documentation if you care about it.</source>
          <target state="translated">디렉토리 &lt;em&gt;모드&lt;/em&gt; 와 관련하여 관심이있는 경우 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2733f4de239159b7954ae10717a9de4a0d8f2130" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt;&lt;code&gt;mkpath&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath&quot;&gt; &lt;code&gt;mkpath&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="06628bc05e1d54f41341f98d20675258e87615f8" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;os.listdir&lt;/code&gt; for this:</source>
          <target state="translated">이를 위해 &lt;code&gt;os.listdir&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf103c255fa677ea9f423097c9a44c5cfe7a020" translate="yes" xml:space="preserve">
          <source>You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:</source>
          <target state="translated">특정 경로에 특정 파일을 제공하고 파일 경로에서 디렉토리를 가져옵니다. 그런 다음 디렉토리가 있는지 확인한 후 읽을 파일을 열려고 시도하십시오. 이 코드에 주석을 달려면 :</target>
        </trans-unit>
        <trans-unit id="6052af5853fd347b0aeab05bc6bcc4f07874858c" translate="yes" xml:space="preserve">
          <source>You have to set the full path before creating the directory:</source>
          <target state="translated">디렉토리를 작성하기 전에 전체 경로를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="56d28d9565a39da08aca1caa9e22049b44a768f3" translate="yes" xml:space="preserve">
          <source>Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for &lt;strong&gt;reading&lt;/strong&gt;:</source>
          <target state="translated">최종 목표는이 파일을 여는 것입니다. 처음에는 작성을 위해 언급하지만 기본적으로 다음과 같은 목표에 접근하고 있습니다 (코드를 기준으로).</target>
        </trans-unit>
        <trans-unit id="0c7364050c5331f5b0b43cbfbb9de956a1867c02" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist&quot;&gt;How can I create a directory if it does not exist?&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist&quot;&gt;디렉토리가 없으면 어떻게 만들 수 있습니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="549fd39871f5892c4092cced01f37a74c23c77cc" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt;https://docs.python.org/3/library/os.html#os.makedirs&lt;/a&gt;</source>
          <target state="translated">[2] &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.makedirs&quot;&gt;https://docs.python.org/3/library/os.html#os.makedirs&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ac45d7f4ee3550c6ad3415c9a62ec084feb6538" translate="yes" xml:space="preserve">
          <source>is better than the alternative</source>
          <target state="translated">대안보다 낫다</target>
        </trans-unit>
        <trans-unit id="32133da69c38d6a432b2087ec0dfe35d3e89bf02" translate="yes" xml:space="preserve">
          <source>means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists.</source>
          <target state="translated">디렉토리 (경로)가 존재하고 디렉토리임을 의미합니다. 그래서 나를 위해이 방법은 내가 필요한 것을합니다. 따라서 폴더 (파일이 아님)이고 존재하는지 확인할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
