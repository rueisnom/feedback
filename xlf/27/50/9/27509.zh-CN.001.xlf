<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/27509">
    <body>
      <group id="27509">
        <trans-unit id="9b76c7ee3ed3b22fe6b40e7d1df6c18824b37a8f" translate="yes" xml:space="preserve">
          <source>'&lt;em&gt;if (window.x) { }&lt;/em&gt;' is error safe</source>
          <target state="translated">' &lt;em&gt;如果（window.x）{}&lt;/em&gt; '是错误安全的</target>
        </trans-unit>
        <trans-unit id="7afec1ce47ff900682bd7a527552baf0b3f48e7e" translate="yes" xml:space="preserve">
          <source>(y)</source>
          <target state="translated">(y)</target>
        </trans-unit>
        <trans-unit id="1963f681a0dc2983468889df82f1affdbe4cb8ed" translate="yes" xml:space="preserve">
          <source>1) You want to know if a property is undefined by either the first or second meaning (the most typical situation).</source>
          <target state="translated">1)你想知道一个属性是否由第一义或第二义未定义(最典型的情况)。</target>
        </trans-unit>
        <trans-unit id="2eff931c0d1f6eda47f88e36e5e2ca665e39f0b0" translate="yes" xml:space="preserve">
          <source>2) You want to just know if object has some property and don't care about its value.</source>
          <target state="translated">2)你只想知道对象是否具有某种属性,不关心它的价值。</target>
        </trans-unit>
        <trans-unit id="d95915c48ebcaada4c615be17c20592ad7a87e7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt;链接</target>
        </trans-unit>
        <trans-unit id="f3c686407b77ca61732d9533437b84cc6af2398a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'undefned'&lt;/code&gt; (&lt;em&gt;misspelled&lt;/em&gt;) here is just a string constant, so the JavaScript engine can't help you if you have misspelled it like I just did.</source>
          <target state="translated">&lt;code&gt;'undefned'&lt;/code&gt; （ &lt;em&gt;拼写错误&lt;/em&gt; ）只是一个字符串常量，因此，如果您像我刚才那样拼写错误，那么JavaScript引擎将无法为您提供帮助。</target>
        </trans-unit>
        <trans-unit id="66262b2e58df668340e9c997b4fcbb22d477d689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; can be overridden in old browsers</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 可以在旧的浏览器中覆盖</target>
        </trans-unit>
        <trans-unit id="9c0eca093d608d52888040610ad0fea09fe42fae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Note that the use of &lt;code&gt;var&lt;/code&gt; for &lt;code&gt;in&lt;/code&gt; tests make a difference when in a scoped wrapper)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（请注意，在范围内的包装器中， &lt;code&gt;in&lt;/code&gt; 测试中使用 &lt;code&gt;var&lt;/code&gt; 会有所不同）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5812b0fa88241095ef998b82d3c2929c6f31055" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Specific to this question, see test cases with &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;特定于此问题，请参阅带有 &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt; 测试用例。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b325ccf6a947861f6e178afd3921cc763cca384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;more&lt;/em&gt; dangerous than using the global &lt;code&gt;undefined&lt;/code&gt;. If you have to be ES3-compatible, replace &lt;code&gt;undefined&lt;/code&gt; with &lt;code&gt;void 0&lt;/code&gt; &amp;ndash; don&amp;rsquo;t resort to &lt;code&gt;typeof&lt;/code&gt;. (&lt;code&gt;void&lt;/code&gt; has always been a unary operator that evaluates to the Undefined value for any operand.)</source>
          <target state="translated">比使用全局 &lt;code&gt;undefined&lt;/code&gt; &lt;em&gt;更&lt;/em&gt;危险。 如果必须与ES3兼容，请将 &lt;code&gt;undefined&lt;/code&gt; 替换为 &lt;code&gt;void 0&lt;/code&gt; &amp;ndash;请勿使用 &lt;code&gt;typeof&lt;/code&gt; 。 （ &lt;code&gt;void&lt;/code&gt; 一直是一元运算符，其任何操作数的计算结果均为未定义值。）</target>
        </trans-unit>
        <trans-unit id="d6d59c5f807d7ec4a037b85ca3c5e7f05986ccb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; In response to your edit, object properties should work the same way.</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;响应您的编辑，对象属性应该以相同的方式工作。</target>
        </trans-unit>
        <trans-unit id="19806bd40175fc10a877fea67f68c16ed7195667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strict equality and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;严格平等和不确定&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110d482d5dc176523e015517737b158007fd1e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is a difference between an undefined member and a defined member with an undefined value.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;未定义成员与具有未定义值的已定义成员之间存在差异。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f031e352cc2a0b3518c3a7f16759780f937d7a44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typeof operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Typeof运算符和未定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36bde56374a3373b2f73b61dde0097263e17ddb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Void operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;无效运算符和未定义&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d8f959e87c1d0dffd229886fa52757ad009bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;null&lt;/strong&gt; means that the variable value is defined and set to null (has no value).</source>
          <target state="translated">&lt;strong&gt;null&lt;/strong&gt;表示已定义变量值并将其设置为null（无值）。</target>
        </trans-unit>
        <trans-unit id="bec2062ef6d9e093a5eeb78377aa98519f789843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined&lt;/strong&gt; means that the variable value has not been defined; it is not known what the value is.</source>
          <target state="translated">&lt;strong&gt;未定义&lt;/strong&gt;表示尚未定义变量值； 目前尚不清楚该值是多少。</target>
        </trans-unit>
        <trans-unit id="7ef0f25ff59da22f20a9f581d372dd5532c68b8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;window&lt;/strong&gt; is an object which holds all global variables as its members, and it is legal to try to access a non-existing member. If &lt;strong&gt;x&lt;/strong&gt; hasn't been declared or hasn't been set then &lt;code&gt;window.x&lt;/code&gt; returns &lt;strong&gt;undefined&lt;/strong&gt;. &lt;strong&gt;undefined&lt;/strong&gt; leads to &lt;strong&gt;false&lt;/strong&gt; when &lt;strong&gt;if()&lt;/strong&gt; evaluates it.</source>
          <target state="translated">&lt;strong&gt;window&lt;/strong&gt;是一个将所有全局变量作为其成员的对象，尝试访问不存在的成员是合法的。 如果尚未声明&lt;strong&gt;x&lt;/strong&gt;或尚未设置&lt;strong&gt;x，&lt;/strong&gt;则 &lt;code&gt;window.x&lt;/code&gt; 返回&lt;strong&gt;undefined&lt;/strong&gt; 。 当&lt;strong&gt;if（）&lt;/strong&gt;对其求值时， &lt;strong&gt;undefined&lt;/strong&gt;导致&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0196332640a9574b642791f69278e0108d64482" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup1; unusual choice of example variable name? this is real dead code from the NoScript extension for Firefox.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup1;示例变量名称的异常选择？&lt;/sub&gt; &lt;sub&gt;这是来自Firefox的NoScript扩展的真正的死代码。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="832763f5083c7d8a0f4ef0ca33f1a035e0a67dc1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup2; don&amp;rsquo;t assume that not knowing what&amp;rsquo;s in scope is okay in general, though. bonus vulnerability caused by abuse of dynamic scope: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup2;不过，不要以为总体上不知道范围是什么。&lt;/sub&gt; &lt;sub&gt;动态范围滥用引起的额外漏洞： &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;零项目1225&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="84456406b0e70016bbb43249541eb7f735f005f4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup3; once again assuming an ES5+ environment and that &lt;code&gt;undefined&lt;/code&gt; refers to the &lt;code&gt;undefined&lt;/code&gt; property of the global object. substitute &lt;code&gt;void 0&lt;/code&gt; otherwise.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup3;再次假设为ES5 +环境，并且 &lt;code&gt;undefined&lt;/code&gt; 是指全局对象的 &lt;code&gt;undefined&lt;/code&gt; 属性。&lt;/sub&gt; &lt;sub&gt;否则将 &lt;code&gt;void 0&lt;/code&gt; 替换为0 。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="58cef43f9cc148fe201f6a40aa751b0117edb0fa" translate="yes" xml:space="preserve">
          <source>Actually it can mean two quite different things! First, it can mean &lt;em&gt;the property that has never been defined&lt;/em&gt; in the object and, second, it can mean the &lt;em&gt;property that has an undefined value&lt;/em&gt;. Let's look at this code:</source>
          <target state="translated">实际上，这可能意味着两个截然不同的事情！ 首先，它可以表示&lt;em&gt;从未&lt;/em&gt;在对象中&lt;em&gt;定义&lt;/em&gt;的属性，其次，它可以表示&lt;em&gt;具有未定义值&lt;/em&gt;的&lt;em&gt;属性&lt;/em&gt; 。 让我们看一下这段代码：</target>
        </trans-unit>
        <trans-unit id="349ce103efd4c2fadb9a858b41201bbd6794a393" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;myVar === undefined&lt;/code&gt; will raise an error in the situation where myVar is undeclared.</source>
          <target state="translated">此外，在未声明myVar的情况下， &lt;code&gt;myVar === undefined&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="286d348194a35b840509a9c9d1227df8acbbd2ec" translate="yes" xml:space="preserve">
          <source>All the answers are incomplete. This is the right way of knowing that there is a property 'defined as undefined' :</source>
          <target state="translated">所有的答案都是不完整的。这就是正确的方法,知道有一个属性 &quot;定义为未定义&quot;。</target>
        </trans-unit>
        <trans-unit id="f10c4fd9df413d69738977ff9f171b41d4667fe1" translate="yes" xml:space="preserve">
          <source>Also one more thing, for checking property on an object in a real application which you not sure even the object exists or not, check if the object exists first.</source>
          <target state="translated">另外还有一点,在实际应用中,如果你不确定对象是否存在,先检查对象是否存在,检查对象的属性。</target>
        </trans-unit>
        <trans-unit id="219f34b6015e059105c29a26a98358fba3b56ee1" translate="yes" xml:space="preserve">
          <source>Also other javascript frameworks like underscore has similar defining check, but I recommend you use &lt;code&gt;typeof&lt;/code&gt; if you already not using any frameworks.</source>
          <target state="translated">另外，其他JavaScript框架（例如下划线）也具有类似的定义检查，但是如果您尚未使用任何框架，建议您使用 &lt;code&gt;typeof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="791ed3302cfee030f9c8fa3bee23d8d3e1f0bc24" translate="yes" xml:space="preserve">
          <source>Alternatively, typeof can be used:</source>
          <target state="translated">另外,也可以使用typeof。</target>
        </trans-unit>
        <trans-unit id="63b964d88fc95bd706292cbaa247b9c16e2755e4" translate="yes" xml:space="preserve">
          <source>And results:</source>
          <target state="translated">和结果。</target>
        </trans-unit>
        <trans-unit id="d83e8ed16ed58afb7ab32795cb6009ac31db06ab" translate="yes" xml:space="preserve">
          <source>As you see we can check anything with using something like this in our code, as mentioned you can simply use &lt;code&gt;typeof&lt;/code&gt; in your code, but if you are using it over and over, create a function like the angular sample which I share and keep reusing as following DRY code pattern.</source>
          <target state="translated">如您所见，我们可以在代码中使用类似这样的内容进行检查，如上所述，您可以在代码中简单地使用 &lt;code&gt;typeof&lt;/code&gt; ，但是如果您一遍又一遍地使用它，请创建一个函数，例如我共享并继续重复使用的angular示例如下DRY代码模式。</target>
        </trans-unit>
        <trans-unit id="87f10ffef733699e5454e0973b6bbcf28272a26a" translate="yes" xml:space="preserve">
          <source>Because the window object has a global scope (default object) outside a function, a declaration will be 'attached' to the window object.</source>
          <target state="translated">因为窗口对象在函数外有一个全局范围(默认对象),所以声明将被 &quot;附加 &quot;到窗口对象上。</target>
        </trans-unit>
        <trans-unit id="2f6b520b68a6505ce09b8eb40967aa50ccdc1dcc" translate="yes" xml:space="preserve">
          <source>But as has been mentioned these are not exactly the same (but are more than good enough for my needs).</source>
          <target state="translated">但正如前面提到的,这些都不完全相同(但对我的需求来说已经足够好了)。</target>
        </trans-unit>
        <trans-unit id="fcfbf2fbae71c2369946c84ef809e8845fa289d8" translate="yes" xml:space="preserve">
          <source>But unhappily &lt;code&gt;typeof obj.foo&lt;/code&gt; does not tell us which of the three cases we have. However we can combine this with &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; to distinguish the cases.</source>
          <target state="translated">但是不幸的是， &lt;code&gt;typeof obj.foo&lt;/code&gt; 并没有告诉我们这三种情况中的哪一种。 但是，我们可以将它与 &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; 结合使用以区分大小写。</target>
        </trans-unit>
        <trans-unit id="1daf4b17726ef0dab632dbab9c7df1fe0d5f44a0" translate="yes" xml:space="preserve">
          <source>Code for reference:</source>
          <target state="translated">代码供参考。</target>
        </trans-unit>
        <trans-unit id="fd83e3fc07c2d36f7a50c3554edc7779b39383e8" translate="yes" xml:space="preserve">
          <source>Commonly, people have asked me for an algorithm to figure out if a value is either falsy, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;. The following works.</source>
          <target state="translated">通常，人们要求我提供一种算法来判断值是伪造的， &lt;code&gt;undefined&lt;/code&gt; 还是 &lt;code&gt;null&lt;/code&gt; 。 以下作品。</target>
        </trans-unit>
        <trans-unit id="40c624d52a56db62dd4208fe5347d5d97cd36d54" translate="yes" xml:space="preserve">
          <source>Compare with &lt;code&gt;void 0&lt;/code&gt;, for terseness.</source>
          <target state="translated">与 &lt;code&gt;void 0&lt;/code&gt; 比较，简洁。</target>
        </trans-unit>
        <trans-unit id="3e55bf53313fd9840391bfd75f5d5b1153e71e7c" translate="yes" xml:space="preserve">
          <source>Convert input value to string to compare with &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; and ensure it's negative value.</source>
          <target state="translated">将输入值转换为字符串以与 &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; 进行比较，并确保其为负值。</target>
        </trans-unit>
        <trans-unit id="e38b4ae3f7cb873e402c0c020e6e974a8e377719" translate="yes" xml:space="preserve">
          <source>Correct Code</source>
          <target state="translated">正确的代码</target>
        </trans-unit>
        <trans-unit id="bbf717127e889535958ab6c66e7ca4d538373008" translate="yes" xml:space="preserve">
          <source>Crossposting my &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;answer&lt;/a&gt; from related question &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;How to check for &quot;undefined&quot; in JavaScript?&lt;/a&gt;</source>
          <target state="translated">我从相关问题中交叉&lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;回答&lt;/a&gt;我的答案 &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;如何在JavaScript中检查&amp;ldquo;未定义&amp;rdquo;？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e2c55e17d9d063d6e819462c4f293237ba47eba" translate="yes" xml:space="preserve">
          <source>Defined as a falsy value, undefined,null, or never defined.</source>
          <target state="translated">定义为虚假值、未定义、null或从未定义过。</target>
        </trans-unit>
        <trans-unit id="f4c589078846130bd5d8f8b014b127005e460131" translate="yes" xml:space="preserve">
          <source>Defined as undefined Or never Defined</source>
          <target state="translated">定义为未定义或从未定义</target>
        </trans-unit>
        <trans-unit id="71177ce1bd442c1e211b610b3ce841a27b46d68f" translate="yes" xml:space="preserve">
          <source>Degenerate code. DO NOT USE.</source>
          <target state="translated">堕落的代码。请勿使用。</target>
        </trans-unit>
        <trans-unit id="5e35f4620392124dd0fdbc52a3c5eb05fbd9f75d" translate="yes" xml:space="preserve">
          <source>Despite being vehemently recommended by many other answers here, &lt;code&gt;typeof&lt;/code&gt;&lt;em&gt;is a bad choice&lt;/em&gt;. It should never be used for checking whether variables have the value &lt;code&gt;undefined&lt;/code&gt;, because it acts as a combined check for the value &lt;code&gt;undefined&lt;/code&gt; and for whether a variable exists. In the vast majority of cases, you know when a variable exists, and &lt;code&gt;typeof&lt;/code&gt; will just introduce the potential for a silent failure if you make a typo in the variable name or in the string literal &lt;code&gt;'undefined'&lt;/code&gt;.</source>
          <target state="translated">尽管这里的许多其他答案都强烈建议 &lt;code&gt;typeof&lt;/code&gt; ， 但这 &lt;em&gt;是一个不好的选择&lt;/em&gt; 。 永远不要将其用于检查变量是否具有值 &lt;code&gt;undefined&lt;/code&gt; ，因为它可以作为对值 &lt;code&gt;undefined&lt;/code&gt; 和变量是否存在的组合检查。 在大多数情况下，您知道何时存在变量，并且如果在变量名称或字符串文字 &lt;code&gt;'undefined'&lt;/code&gt; 中输入错误， &lt;code&gt;typeof&lt;/code&gt; 只会导致潜在的失败。</target>
        </trans-unit>
        <trans-unit id="09909cfd981fdef3626ccc9834d9448da9e9745f" translate="yes" xml:space="preserve">
          <source>Detecting an undefined object property</source>
          <target state="translated">检测未定义的对象属性</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58abfcd5560647f71db6174e6dae2c1d7b00956b" translate="yes" xml:space="preserve">
          <source>Example: I want to know if my browser supports History API</source>
          <target state="translated">例如,我想知道我的浏览器是否支持历史API。我想知道我的浏览器是否支持历史记录API</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="1cc20ab6bb45b09d067f86e897de287544ccc18a" translate="yes" xml:space="preserve">
          <source>Final fight: &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</source>
          <target state="translated">最后一战： &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="a66f6d43d5e07190edcbfd047a24a1c644663c95" translate="yes" xml:space="preserve">
          <source>For example: I've just been refactoring a bunch of code that had a bunch of checks whether an object had a given property.</source>
          <target state="translated">举个例子。我刚刚重构了一堆代码,其中有一堆检查对象是否有给定属性的代码。</target>
        </trans-unit>
        <trans-unit id="11cb88bb285ee32166071503cea3f43fbd246c9f" translate="yes" xml:space="preserve">
          <source>For my situation, if restResult.data[0] === &quot;object&quot;, then I can safely start inspecting the rest of the members.  If undefined then throw the error as above.</source>
          <target state="translated">对于我的情况,如果 restResult.data[0]=====&quot;object&quot;,那么我可以安全地开始检查其余成员。如果未定义,则会抛出如上所述的错误。</target>
        </trans-unit>
        <trans-unit id="282a1a5fba1c9f99dd9c65da723cf7e6ca6d5c3b" translate="yes" xml:space="preserve">
          <source>From lodash.js.</source>
          <target state="translated">来自 lodash.js。</target>
        </trans-unit>
        <trans-unit id="724505ac659cb61ec2ae6752fea94b6583d5c2e3" translate="yes" xml:space="preserve">
          <source>Going through the comments, for those who want to check both is it undefined or its value is null:</source>
          <target state="translated">通过评论,对于那些想检查这两点的人来说,是未定义还是它的值为空。</target>
        </trans-unit>
        <trans-unit id="12f327f57e715c27af2a0b9e2dc98dfb92d437ff" translate="yes" xml:space="preserve">
          <source>Here is my situation:</source>
          <target state="translated">这里是我的情况。</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">希望对你有帮助!</target>
        </trans-unit>
        <trans-unit id="21afb40540c44bc457dfbcf79a0414bc7750aa85" translate="yes" xml:space="preserve">
          <source>How this works:</source>
          <target state="translated">这事怎么做的。</target>
        </trans-unit>
        <trans-unit id="5d0e7097fe8f3623c402467f8277e8158fe7d304" translate="yes" xml:space="preserve">
          <source>However, this kind of technique should be avoided. JavaScript is a
  statically scoped language, so knowing if a variable is declared can
  be read by seeing whether it is declared in an enclosing context. The
  only exception is the global scope, but the global scope is bound to
  the global object, so checking the existence of a variable in the
  global context can be done by checking the existence of a property on
  the global object (using the in operator, for instance).</source>
          <target state="translated">但是,这种技术应该避免使用。JavaScript是一种静态作用域语言,所以知道一个变量是否声明了,可以通过查看变量是否在全局上下文中声明了,就可以读出它的存在。唯一的例外是全局范围,但全局范围是和全局对象绑定在一起的,所以检查变量在全局上下文中是否存在,可以通过检查全局对象上的属性(例如使用in操作符)来完成。</target>
        </trans-unit>
        <trans-unit id="6fecf04984cba74419822b109f93545b2cd336ab" translate="yes" xml:space="preserve">
          <source>I also add this section from MDN which has got useful information about typeof, undefined and void(0).</source>
          <target state="translated">我还从MDN中添加了这一节,其中有关于typeof、undefined和void(0)的有用信息。</target>
        </trans-unit>
        <trans-unit id="ca90e82d4aa8f47040cff0d3ebf2778f42cec981" translate="yes" xml:space="preserve">
          <source>I am using the result of a REST call.
The result should be parsed from JSON to a JavaScript object.</source>
          <target state="translated">我正在使用一个REST调用的结果。结果应该从JSON解析成JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="44d30a96fae36c5b6279d6d45740204cbf4ff5a0" translate="yes" xml:space="preserve">
          <source>I believe there are a number of incorrect answers to this topic. Contrary to common belief, &quot;undefined&quot; is &lt;strong&gt;not&lt;/strong&gt; a keyword in JavaScript and can in fact have a value assigned to it.</source>
          <target state="translated">我相信对此主题有许多不正确的答案。 与通常的看法相反，&amp;ldquo;未定义&amp;rdquo; &lt;strong&gt;不是&lt;/strong&gt; JavaScript中的关键字，实际上可以为其分配值。</target>
        </trans-unit>
        <trans-unit id="b37013d283a8127b7370563a4c36a206388c33a2" translate="yes" xml:space="preserve">
          <source>I didn't see (hope I didn't miss it) anyone checking the object before the property. So, this is the shortest and most effective (though not necessarily the most clear):</source>
          <target state="translated">我没有看到(希望我没有错过)有人在属性之前检查对象(希望我没有错过)。所以,这是最短的,也是最有效的(虽然不一定最清楚)。</target>
        </trans-unit>
        <trans-unit id="4358f6b4064ade07b2efbf8a21e0f4135f510c95" translate="yes" xml:space="preserve">
          <source>I found lodash updated its implementation. See &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;my issue&lt;/a&gt; and &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;the code&lt;/a&gt;.</source>
          <target state="translated">我发现lodash更新了其实现。 请参阅&lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;我的问题&lt;/a&gt;和&lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;代码&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a132ebdcb8942d7a076277423ad437744ce7794" translate="yes" xml:space="preserve">
          <source>I provide three ways here for those who expect weird answers:</source>
          <target state="translated">我在这里提供了三种方法,供期待奇葩答案的人参考。</target>
        </trans-unit>
        <trans-unit id="48e26ba605da52f2cf32ca734ac26d9e06215803" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;if (this.variable)&lt;/code&gt; to test if it is defined. Simple &lt;code&gt;if (variable)&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;recommended above&lt;/a&gt;, fails for me. It turns out that it works only when variable is a field of some object, &lt;code&gt;obj.someField&lt;/code&gt; to check if it is defined in the dictionary. But we can use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; as the dictionary object since any variable is a field in current window, as I understand it. Therefore here is a test</source>
          <target state="translated">我使用 &lt;code&gt;if (this.variable)&lt;/code&gt; 测试是否已定义。 &lt;code&gt;if (variable)&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;上面推荐的&lt;/a&gt; if（variable）对我来说很简单， 那就失败了。 事实证明，只有当变量是某个对象的字段 &lt;code&gt;obj.someField&lt;/code&gt; 才能检查它是否在字典中定义时，它才起作用。 但是我们可以 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;window&lt;/code&gt; 用作字典对象，因为据我所知，任何变量都是当前窗口中的一个字段。 因此，这是一个测试</target>
        </trans-unit>
        <trans-unit id="9e125ebcc0697240332e778b82ebf4d7f9c17043" translate="yes" xml:space="preserve">
          <source>I would like to show you something I'm using in order to protect the &lt;code&gt;undefined&lt;/code&gt; variable:</source>
          <target state="translated">我想向您展示一些我正在使用的东西，以保护 &lt;code&gt;undefined&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="d5a6d2b02368855c6fda929fd61af0ea56454c18" translate="yes" xml:space="preserve">
          <source>I'd argue that in some cases it makes more sense (and is clearer) to check whether the property is there, than checking whether it is undefined, and the only case where this check will be different is case 2, the rare case of an actual entry in the object with an undefined value.</source>
          <target state="translated">我认为,在某些情况下,检查属性是否存在比检查属性是否未定义更有意义(也更清楚),而这种检查将不同的唯一情况是情况2,即对象中的实际条目有一个未定义值的罕见情况。</target>
        </trans-unit>
        <trans-unit id="7a7486fe538e6ce861baa007fbb0f526deff33d5" translate="yes" xml:space="preserve">
          <source>I'm not sure where the origin of using &lt;code&gt;===&lt;/code&gt; with &lt;code&gt;typeof&lt;/code&gt; came from, and as a convention I see it used in many libraries, but the typeof operator returns a string literal, and we know that up front, so why would you also want to type check it too?</source>
          <target state="translated">我不确定在 &lt;code&gt;typeof&lt;/code&gt; 中使用 &lt;code&gt;===&lt;/code&gt; 的起源是什么，并且按照惯例，我看到它在许多库中都使用过，但是typeof运算符返回的是字符串文字，而且我们很早就知道这一点，所以为什么要这么做还想输入检查吗？</target>
        </trans-unit>
        <trans-unit id="6ef1c4a3ea0bc81cc7398a1d04f0515bcbd0fb86" translate="yes" xml:space="preserve">
          <source>If an object variable which have some properties you can use same thing like this:</source>
          <target state="translated">如果一个对象变量有一些属性,你可以使用同样的东西,就像这样。</target>
        </trans-unit>
        <trans-unit id="84c7f1a126730161309b91866d156c12a47d03cd" translate="yes" xml:space="preserve">
          <source>If the obj or obj.prop is undefined, null, or &quot;falsy&quot;, the if statement will not execute the code block. This is &lt;em&gt;usually&lt;/em&gt; the desired behavior in most code block statements (in JavaScript).</source>
          <target state="translated">如果obj或obj.prop未定义，为null或为&amp;ldquo; falsy&amp;rdquo;，则if语句将不执行代码块。 这&lt;em&gt;通常&lt;/em&gt;是大多数代码块语句（在JavaScript中）所需的行为。</target>
        </trans-unit>
        <trans-unit id="0d8a3869bd9a3727544999c872ed66c32e2161a3" translate="yes" xml:space="preserve">
          <source>If the value of an object was never defined, this will prevent from returning &lt;code&gt;true&lt;/code&gt; if it is defined as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. This is helpful if you want true to be returned for values set as &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">如果从未定义对象的值，则如果将其定义为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，这将防止返回 &lt;code&gt;true&lt;/code&gt; 。 如果您希望为设置为 &lt;code&gt;undefined&lt;/code&gt; 的值返回true，这将很有帮助</target>
        </trans-unit>
        <trans-unit id="e37e4c8d75647a160e70f184781ee5d3320919a7" translate="yes" xml:space="preserve">
          <source>If you are using Angular:</source>
          <target state="translated">如果你使用的是Angular。</target>
        </trans-unit>
        <trans-unit id="38b2ee0e2820da1917baa311fe8dc70a8ba6eb39" translate="yes" xml:space="preserve">
          <source>If you are using jQuery Library then &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; will suffice for both cases,</source>
          <target state="translated">如果您使用的是jQuery库，则 &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; 足以满足这两种情况，</target>
        </trans-unit>
        <trans-unit id="4a3f6705c1b3da9943592b3d90136b8c5856782d" translate="yes" xml:space="preserve">
          <source>If you check a property on an object and the object doesn't exist, will throw an error and stop the whole application running.</source>
          <target state="translated">如果你检查一个对象上的属性,而这个对象不存在,会抛出一个错误并停止整个应用程序的运行。</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">如果你做了</target>
        </trans-unit>
        <trans-unit id="efde9566bc6269c016eb40d2c931ee65be1256d5" translate="yes" xml:space="preserve">
          <source>If you want it to result as &lt;code&gt;true&lt;/code&gt; for values defined with the value of &lt;code&gt;undefined&lt;/code&gt;, or never defined, you can simply use &lt;code&gt;=== undefined&lt;/code&gt;</source>
          <target state="translated">如果您希望对使用 &lt;code&gt;undefined&lt;/code&gt; 或从未定义的值定义的结果为 &lt;code&gt;true&lt;/code&gt; ，则可以简单地使用 &lt;code&gt;=== undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c710b9144a4a4de7a8033df9d90b0d520b9d93cc" translate="yes" xml:space="preserve">
          <source>In JavaScript there is &lt;strong&gt;null&lt;/strong&gt; and there is &lt;strong&gt;undefined&lt;/strong&gt;.  They have different meanings.</source>
          <target state="translated">在JavaScript中，存在&lt;strong&gt;null&lt;/strong&gt; &lt;strong&gt;且未定义&lt;/strong&gt; 。 它们具有不同的含义。</target>
        </trans-unit>
        <trans-unit id="676832a5b39fcd247b5da8131c2bb20e3f4e6479" translate="yes" xml:space="preserve">
          <source>In js, optional parameter works when the input value is exactly &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">在js中，当输入值完全 &lt;code&gt;undefined&lt;/code&gt; 时，可选参数有效。</target>
        </trans-unit>
        <trans-unit id="47b70d6bd5d7420590fbe686fa1aa65f6aff345c" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Exploring the Abyss of Null and Undefined in JavaScript &lt;/a&gt;&lt;/em&gt; I read that frameworks like &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; use this function:</source>
          <target state="translated">在《 &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;探索JavaScript中的Null和Undefined的深渊》一文中，&lt;/a&gt;&lt;/em&gt;我读到诸如&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js之类的&lt;/a&gt;框架使用此函数：</target>
        </trans-unit>
        <trans-unit id="d6f3fa461bad66e062e473e85ddb6843faa72ad8" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;o.a&lt;/code&gt; undefined? Yes! Its value is undefined. Is &lt;code&gt;o.b&lt;/code&gt; undefined? Sure! There is no property 'b' at all! OK, see now how different approaches behave in both situations:</source>
          <target state="translated">&lt;code&gt;o.a&lt;/code&gt; 是未定义的吗？ 是! 其值是不确定的。 &lt;code&gt;o.b&lt;/code&gt; 是undefined吗？ 当然！ 根本没有属性&amp;ldquo; b&amp;rdquo;！ 好的，现在看一下两种情况下不同方法的行为：</target>
        </trans-unit>
        <trans-unit id="5fd8487b64efdd4bc0f74bc89dcb48fb3b637b18" translate="yes" xml:space="preserve">
          <source>It creates a LOCAL variable named &lt;code&gt;undefined&lt;/code&gt; which is initialized with the default value -- the real &lt;code&gt;undefined&lt;/code&gt;, then compares &lt;code&gt;value&lt;/code&gt; with the variable &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">它创建一个名为 &lt;code&gt;undefined&lt;/code&gt; 的LOCAL变量，该变量将使用默认值-真正的 &lt;code&gt;undefined&lt;/code&gt; 初始化，然后将 &lt;code&gt;value&lt;/code&gt; 与变量 &lt;code&gt;undefined&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="cc7e62a0477f84c6e213a2a66a6810ed10b81109" translate="yes" xml:space="preserve">
          <source>It first detects that variable &lt;code&gt;abc&lt;/code&gt; is undefined and it is defined after initialization.</source>
          <target state="translated">它首先检测到变量 &lt;code&gt;abc&lt;/code&gt; 未定义，并且在初始化后定义。</target>
        </trans-unit>
        <trans-unit id="0a0f662835940c2e3dcfdd198a56eabd87b6dab3" translate="yes" xml:space="preserve">
          <source>It is always better to use the instance/object of the variable to check if it got a valid value. It is more stable and is a better way of programming.</source>
          <target state="translated">通常情况下,使用变量的instanceobject来检查它是否得到了一个有效的值。这样做比较稳定,是一种比较好的编程方式。</target>
        </trans-unit>
        <trans-unit id="4d8fd1abf77f99fdff5448384c2ed4fee6e5c474" translate="yes" xml:space="preserve">
          <source>It is really universal! It works in new and old browsers.</source>
          <target state="translated">它真的是通用的! 它可以在新的和旧的浏览器中使用。</target>
        </trans-unit>
        <trans-unit id="a3b4d7eb65e80473b0d023a35685a8a9cba1977e" translate="yes" xml:space="preserve">
          <source>It's a bit shorter and looks a bit prettier</source>
          <target state="translated">稍微短了一点,看起来更漂亮一点</target>
        </trans-unit>
        <trans-unit id="1f9e9fe4a20d8dcfcf0cd7dd398ac00aaebacdc0" translate="yes" xml:space="preserve">
          <source>It's not as verbose as &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</source>
          <target state="translated">它不像 &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt; 那样冗长</target>
        </trans-unit>
        <trans-unit id="bda34532c7ceeef815dfdb84a302308f13b1698b" translate="yes" xml:space="preserve">
          <source>It's suitable if you have a function, which receives an additional config property:</source>
          <target state="translated">如果你有一个函数,它适用于接收一个额外的config属性的函数。</target>
        </trans-unit>
        <trans-unit id="90a5de8bf9ed40e458f73d3c2fa132d1f4efa842" translate="yes" xml:space="preserve">
          <source>Its worth noting that these tests are the same for &lt;code&gt;null&lt;/code&gt; entries too</source>
          <target state="translated">值得注意的是，对于 &lt;code&gt;null&lt;/code&gt; 条目，这些测试也相同</target>
        </trans-unit>
        <trans-unit id="cca12d9c31c7dc579429ae296a479d2f796bada7" translate="yes" xml:space="preserve">
          <source>JavaScript has &lt;code&gt;typeof&lt;/code&gt; which make it very easy to detect an undefined variable.</source>
          <target state="translated">JavaScript具有 &lt;code&gt;typeof&lt;/code&gt; ，可以很容易地检测到未定义的变量。</target>
        </trans-unit>
        <trans-unit id="a82d750a33e643b1a8a39e0ebb43d3b5768eaffc" translate="yes" xml:space="preserve">
          <source>Marijn Haverbeke states, in his free, online book &quot;&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt;&quot; (emphasis mine):</source>
          <target state="translated">Marijn Haverbeke在他的免费在线书&amp;ldquo; &lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt; &amp;rdquo;（强调我的）中指出：</target>
        </trans-unit>
        <trans-unit id="5f9f4ff7cb7c3bd40b09bbc0a21ff4e94114ed3a" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;obj.prop === undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0671b57c33e2e288915d086d37cc882d4a48e654" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6bea7aa73158aa827a9c1bea87ededed070dc457" translate="yes" xml:space="preserve">
          <source>Most likely you want &lt;code&gt;if (window.x)&lt;/code&gt;. This check is safe even if x hasn't been declared (&lt;code&gt;var x;&lt;/code&gt;) - browser doesn't throw an error.</source>
          <target state="translated">您最可能想要 &lt;code&gt;if (window.x)&lt;/code&gt; 。 即使未声明 &lt;code&gt;var x;&lt;/code&gt; （ var x; ），此检查也是安全的-浏览器不会引发错误。</target>
        </trans-unit>
        <trans-unit id="9b4b5105b3b3a13be5c61e3fa3df47a1366e4075" translate="yes" xml:space="preserve">
          <source>Never Defined</source>
          <target state="translated">从未定义</target>
        </trans-unit>
        <trans-unit id="9484abb038e36cb0cd8cbbc623288ca1c4c7dc51" translate="yes" xml:space="preserve">
          <source>Node.js supports the global variable &lt;code&gt;undefined&lt;/code&gt; as &lt;code&gt;global.undefined&lt;/code&gt; (it can also be used without the 'global' prefix). I don't know about other implementations of server-side JavaScript.</source>
          <target state="translated">Node.js支持将 &lt;code&gt;undefined&lt;/code&gt; 定义为 &lt;code&gt;global.undefined&lt;/code&gt; （也可以不使用'global'前缀使用）。 我不知道服务器端JavaScript的其他实现。</target>
        </trans-unit>
        <trans-unit id="25e7237d29d65a8052d28a50ad68997f82c2cf73" translate="yes" xml:space="preserve">
          <source>Note: The strict equality operator rather than the standard equality
  operator must be used here, because x == undefined also checks whether
  x is null, while strict equality doesn't. null is not equivalent to
  undefined. See comparison operators for details.</source>
          <target state="translated">注意:这里必须使用严格的平等运算符,而不是标准的平等运算符,因为x ==undefined也会检查x是否为空,而严格的平等运算符不检查。详情请参阅比较运算符。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="59c5fb8a80a77710fbcb25bc27178f51a4e9b105" translate="yes" xml:space="preserve">
          <source>Now executing</source>
          <target state="translated">现在执行</target>
        </trans-unit>
        <trans-unit id="b2491f157aee8344e47a52d1010d094626fad59f" translate="yes" xml:space="preserve">
          <source>One reason to use typeof is that it does not throw an error if the
  variable has not been declared.</source>
          <target state="translated">使用typeof的一个原因是,如果变量没有被声明,它不会抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="aeca9079848cd62aa72e0c9da1ae45fee2f68f0f" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;obj.prop === undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c47d4b2cec06b65e3df4b5dc37d83b7c1779a8b3" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ab5bb084b0953bb529d05917ef5d0f8f02b4e552" translate="yes" xml:space="preserve">
          <source>Reading through this, I'm amazed I didn't see this. I have found multiple algorithms that would work for this.</source>
          <target state="translated">读完这些,我很惊讶自己没有发现这个问题。我找到了多种算法,都能适用于此。</target>
        </trans-unit>
        <trans-unit id="bb5a0c2d5893ca1120918abd2e27fe466333b1bf" translate="yes" xml:space="preserve">
          <source>Returns false if variable is set, and true if is undefined.</source>
          <target state="translated">如果变量被设置,则返回false,如果未定义,则返回true。</target>
        </trans-unit>
        <trans-unit id="883a8c4f5ebd87c4fde0e73e9656f30546585657" translate="yes" xml:space="preserve">
          <source>Simply anything is not defined in JavaScript, is &lt;strong&gt;undefined&lt;/strong&gt;, doesn't matter if it's a property inside an &lt;strong&gt;Object/Array&lt;/strong&gt; or as just a simple variable...</source>
          <target state="translated">只是任何未在JavaScript中&lt;strong&gt;定义&lt;/strong&gt; ， &lt;strong&gt;未定义&lt;/strong&gt; ，是&lt;strong&gt;对象/数组中&lt;/strong&gt;的属性还是简单变量都没有关系...</target>
        </trans-unit>
        <trans-unit id="aedd3fc984632b50a483c5fe2c50d6f41d6d1779" translate="yes" xml:space="preserve">
          <source>Simply check if &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; and it will return a boolean.</source>
          <target state="translated">只需检查 &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; 是否==='undefined' ，它将返回一个布尔值。</target>
        </trans-unit>
        <trans-unit id="f828f39971d418b0bc13a1d98409cc5e98730d01" translate="yes" xml:space="preserve">
          <source>So as you see the function receive a value, if that value is defined, it will return &lt;code&gt;false&lt;/code&gt;, otherwise for undefined values, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">因此，如您所见，函数收到一个值，如果定义了该值，它将返回 &lt;code&gt;false&lt;/code&gt; ，否则，对于未定义的值，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="418ae1e2e0311d3d2c105a70491013660c6a928b" translate="yes" xml:space="preserve">
          <source>So let's have a look what gonna be the results when we passing values, including object properties like below, this is the list of variables we have:</source>
          <target state="translated">那么我们来看看当我们传递值的时候会有什么结果,包括像下面这样的对象属性,这就是我们的变量列表。</target>
        </trans-unit>
        <trans-unit id="26532241df6bb6d2e9b7919c8174d92f3c3e9956" translate="yes" xml:space="preserve">
          <source>So simple you can wrap inside an if statement like below:</source>
          <target state="translated">如此简单,你可以像下面的if语句一样,把它包在里面。</target>
        </trans-unit>
        <trans-unit id="c03f8753c6b8939bcb611d65d70cd9f2e93a2bf4" translate="yes" xml:space="preserve">
          <source>So unless you&amp;rsquo;re doing feature detection&amp;sup2;, where there&amp;rsquo;s uncertainty whether a given name will be in scope (like checking &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; as a step in code specific to a CommonJS environment), &lt;code&gt;typeof&lt;/code&gt; is a harmful choice when used on a variable, and the correct option is to compare the value directly:</source>
          <target state="translated">因此，除非您要进行特征检测&amp;sup2;，否则在不确定给定名称是否会在范围内的情况下（例如检查 &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; 作为特定于CommonJS环境的代码中的步骤）， &lt;code&gt;typeof&lt;/code&gt; 是使用时的有害选择在变量上，正确的选择是直接比较值：</target>
        </trans-unit>
        <trans-unit id="9e1c8c9a0796fba24c5ae142d24dc8713fd92971" translate="yes" xml:space="preserve">
          <source>So what to do?</source>
          <target state="translated">那该怎么做?</target>
        </trans-unit>
        <trans-unit id="c4de3d5c3b3ce53f18295c6866165a0b386a0cc6" translate="yes" xml:space="preserve">
          <source>So, I guess the best way to check if something was undefined would be:</source>
          <target state="translated">所以,我想最好的检查方法是,如果有什么东西没有被定义的话。</target>
        </trans-unit>
        <trans-unit id="62861616fb8499b1333e632d8f4f8c9d96d9ca16" translate="yes" xml:space="preserve">
          <source>So, for anyone who pass by, I will give you undefineds for free!!</source>
          <target state="translated">所以,凡是路过的人,我都会免费送给你未定义的东西!</target>
        </trans-unit>
        <trans-unit id="93c6077f6664588e7ec5fe7e874c0816d5e39229" translate="yes" xml:space="preserve">
          <source>Some common misconceptions about this include:</source>
          <target state="translated">这方面的一些常见误解包括:</target>
        </trans-unit>
        <trans-unit id="141f21882b084552acee073fca83c3cc0c42e7c8" translate="yes" xml:space="preserve">
          <source>Some scenarios illustrating the results of the various answers:
&lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</source>
          <target state="translated">一些场景说明了各种答案的结果： &lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/drzaus/UVjM4/</target>
        </trans-unit>
        <trans-unit id="e5e2bb80f10dad7f8c5f9960cd6007b457637109" translate="yes" xml:space="preserve">
          <source>Something else to consider when it comes to object properties is whether you really want to check for &lt;code&gt;undefined&lt;/code&gt; at all. A given property name can be absent on an object (producing the value &lt;code&gt;undefined&lt;/code&gt; when read), present on the object itself with the value &lt;code&gt;undefined&lt;/code&gt;, present on the object&amp;rsquo;s prototype with the value &lt;code&gt;undefined&lt;/code&gt;, or present on either of those with a non-&lt;code&gt;undefined&lt;/code&gt; value. &lt;code&gt;'key' in obj&lt;/code&gt; will tell you whether a key is anywhere on an object&amp;rsquo;s prototype chain, and &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; will tell you whether it&amp;rsquo;s directly on the object. I won&amp;rsquo;t go into detail in this answer about prototypes and using objects as string-keyed maps, though, because it&amp;rsquo;s mostly intended to counter all the bad advice in other answers irrespective of the possible interpretations of the original question. Read up on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;object prototypes on MDN&lt;/a&gt; for more!</source>
          <target state="translated">关于对象属性，还有其他需要考虑的事情是您是否真的要检查 &lt;code&gt;undefined&lt;/code&gt; 的对象。 给定的属性名称可以不存在于对象上（在读取时产生 &lt;code&gt;undefined&lt;/code&gt; 的值），可以在对象本身上显示为 &lt;code&gt;undefined&lt;/code&gt; 值，可以在对象的原型上显示为 &lt;code&gt;undefined&lt;/code&gt; 值，也可以在任何一个具有 &lt;code&gt;undefined&lt;/code&gt; 的属性上出现值。 &lt;code&gt;'key' in obj&lt;/code&gt; 会告诉您密钥是否在对象原型链上的任何位置，而 &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; 会告诉您密钥是否直接在对象上。 不过，在这个答案中，我不会详细介绍原型以及将对象用作字符串键映射的原因，因为它的主要目的是与其他答案中的所有不良建议相抵触，而与对原始问题的可能解释无关。 阅读&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;有关MDN的对象原型&lt;/a&gt;的更多信息！</target>
        </trans-unit>
        <trans-unit id="09414607443b3c66a48d7b3cc8690784e89229ef" translate="yes" xml:space="preserve">
          <source>That's how the famous function &lt;code&gt;isUndefined()&lt;/code&gt; in AngularJs v.1x is written:</source>
          <target state="translated">这就是AngularJs v.1x中著名的函数 &lt;code&gt;isUndefined()&lt;/code&gt; 的编写方式：</target>
        </trans-unit>
        <trans-unit id="1d798e4166272be66a0741b99698bc5ab930a831" translate="yes" xml:space="preserve">
          <source>The JavaScript engine will give you an error if you have misspelled &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">如果您拼错了 &lt;code&gt;undefined&lt;/code&gt; ，JavaScript引擎会给您一个错误</target>
        </trans-unit>
        <trans-unit id="656b5d05c99fef961580b61f3edcaf330a6d66b8" translate="yes" xml:space="preserve">
          <source>The global variable &lt;em&gt;myvar&lt;/em&gt; is the same as &lt;em&gt;window.myvar&lt;/em&gt; or &lt;em&gt;window['myvar']&lt;/em&gt;</source>
          <target state="translated">全局变量&lt;em&gt;myvar&lt;/em&gt;与&lt;em&gt;window.myvar&lt;/em&gt;或&lt;em&gt;window ['myvar']相同&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29914467b1012003b3afd9aaffdcc32d8b458da1" translate="yes" xml:space="preserve">
          <source>The issue boils down to three cases:</source>
          <target state="translated">这个问题可以归结为三种情况。</target>
        </trans-unit>
        <trans-unit id="8f19ead080cc475b112d23d1a87b473d84ebf23e" translate="yes" xml:space="preserve">
          <source>The most robust way to perform this test is:</source>
          <target state="translated">进行这项测试的最稳健的方法是。</target>
        </trans-unit>
        <trans-unit id="195e6d98a22addf60a5f15d53507e42b6d225705" translate="yes" xml:space="preserve">
          <source>The object does not have the property.</source>
          <target state="translated">该对象不具有该属性。</target>
        </trans-unit>
        <trans-unit id="af4e3304635702004a3bc294a84b85b272ed0251" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">该对象具有属性，其值是 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0000fbbbec8c44ca2bc7134d63869dbf22df5843" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is not &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">对象具有属性，其值不是 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f12e6a8e8479790bcfba92ce8e2bdb1c0b5a2c71" translate="yes" xml:space="preserve">
          <source>The question if a variable really exists doesn't matter, its value is incorrect. Otherwise, it is silly to initialize variables with undefined, and it is better use the value false to initialize. When you know that all variables that you declare are initialized with false, you can simply check its type or rely on &lt;code&gt;!window.myvar&lt;/code&gt; to check if it has a proper/valid value. So even when the variable is not defined then &lt;code&gt;!window.myvar&lt;/code&gt; is the same for &lt;code&gt;myvar = undefined&lt;/code&gt; or &lt;code&gt;myvar = false&lt;/code&gt; or &lt;code&gt;myvar = 0&lt;/code&gt;.</source>
          <target state="translated">变量是否确实存在的问题并不重要，其值不正确。 否则，用undefined初始化变量是愚蠢的，最好使用值false进行初始化。 当您知道声明的所有变量都用false初始化时，您可以简单地检查其类型或依靠 &lt;code&gt;!window.myvar&lt;/code&gt; 来检查其是否具有正确/有效的值。 因此，即使未定义变量，对于 &lt;code&gt;myvar = undefined&lt;/code&gt; 或 &lt;code&gt;myvar = false&lt;/code&gt; 或 &lt;code&gt;myvar = 0&lt;/code&gt; &lt;code&gt;!window.myvar&lt;/code&gt; 也是相同的。</target>
        </trans-unit>
        <trans-unit id="f6c187da4b16a273b05320f38b78197032e5f666" translate="yes" xml:space="preserve">
          <source>The solution is incorrect. In JavaScript,</source>
          <target state="translated">这个解决方案是不正确的。在JavaScript中。</target>
        </trans-unit>
        <trans-unit id="99c5e812eeb793c06c61ae79d6ce567d31253c67" translate="yes" xml:space="preserve">
          <source>The void operator is a third alternative.</source>
          <target state="translated">void运算器是第三种选择。</target>
        </trans-unit>
        <trans-unit id="2624b916bf01c722be8fb21993d9edd3842b5f8d" translate="yes" xml:space="preserve">
          <source>Then use:</source>
          <target state="translated">然后用。</target>
        </trans-unit>
        <trans-unit id="c306c1e05cc386f4fb986ead9800e3cb51d7d7ac" translate="yes" xml:space="preserve">
          <source>There is a nice &amp;amp; elegant way to assign a defined property to a new variable if it is defined or assign a default value to it as a fallback if it&amp;acute;s undefined.</source>
          <target state="translated">如果定义了新变量，则可以使用一种很好的方式优雅地将已定义的属性分配给新变量；如果未定义，则可以为其分配默认值作为后备。</target>
        </trans-unit>
        <trans-unit id="909331b017c727d6b638a10340bcfa91fc4e0156" translate="yes" xml:space="preserve">
          <source>There is also a similar value, null, whose meaning is 'this value is defined, but it does not have a value'. The difference in meaning between undefined and null is mostly academic, and usually not very interesting. &lt;strong&gt;In practical programs, it is often necessary to check whether something 'has a value'. In these cases, the expression something == undefined may be used, because, even though they are not exactly the same value, null == undefined will produce true.&lt;/strong&gt;</source>
          <target state="translated">还有一个相似的值null，其含义是&amp;ldquo;已定义此值，但没有值&amp;rdquo;。 undefined和null之间的含义差异主要是学术上的，通常不是很有趣。 &lt;strong&gt;在实际程序中，通常需要检查某些东西是否&amp;ldquo;有价值&amp;rdquo;。&lt;/strong&gt; &lt;strong&gt;在这些情况下，可以使用表达式something == undefined，因为即使它们的值不完全相同，null == undefined也会产生true。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="066374c5c4c92cd26ce46b50a318fdbc81da8197" translate="yes" xml:space="preserve">
          <source>There is one error I need to defend.
If the args to the rest call were incorrect as far as the user specifying the args wrong, the rest call comes back basically empty.</source>
          <target state="translated">有一个错误我需要维护。如果休息调用的参数不对,因为用户指定的参数不对,休息调用基本上是空的。</target>
        </trans-unit>
        <trans-unit id="4a1c97843ddae12e312165772ba1724256c18040" translate="yes" xml:space="preserve">
          <source>This forbids anyone to change the &lt;code&gt;window.undefined&lt;/code&gt; value therefore destroying the code based on that variable. If using &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;, anything trying to change its value will end in error, otherwise it would be silently ignored.</source>
          <target state="translated">这禁止任何人更改 &lt;code&gt;window.undefined&lt;/code&gt; 值，因此会破坏基于该变量的代码。 如果使用 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; ，则任何试图更改其值的操作都将以错误结尾，否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="206b6848288b0371c75a01e649b5ef1c02732df1" translate="yes" xml:space="preserve">
          <source>This tells us something I consider important:</source>
          <target state="translated">这告诉我们一些我认为很重要的事情。</target>
        </trans-unit>
        <trans-unit id="882cd19a028fc5fdf4ac576781232fd9fb438143" translate="yes" xml:space="preserve">
          <source>This will always return the correct result, and even handles the situation where &lt;code&gt;myVar&lt;/code&gt; is not declared.</source>
          <target state="translated">这将始终返回正确的结果，甚至可以处理未声明 &lt;code&gt;myVar&lt;/code&gt; 的情况。</target>
        </trans-unit>
        <trans-unit id="65d3b63892021dfc610049dfe83bb84e542216eb" translate="yes" xml:space="preserve">
          <source>This worked for me while the others didn't.</source>
          <target state="translated">这对我来说很管用,而其他的都不行。</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="1156bb5b9c53b338e90526a8c3e0f9157c2cdd5d" translate="yes" xml:space="preserve">
          <source>To avoid errors to test when a global variable exists, you better use:</source>
          <target state="translated">为了避免测试全局变量存在时出错,最好使用。</target>
        </trans-unit>
        <trans-unit id="af5a50ed0ca791f35da42bf271615ae60f9119f4" translate="yes" xml:space="preserve">
          <source>To be bullet-proof, simply use:</source>
          <target state="translated">要做到防弹,只需使用。</target>
        </trans-unit>
        <trans-unit id="a3733768c50f085f705798790041179dcb01dd51" translate="yes" xml:space="preserve">
          <source>Too bad that this been the right answer is buried in wrong answers &amp;gt;_&amp;lt;</source>
          <target state="translated">不幸的是，这是正确的答案却被错误的答案掩盖了&amp;gt; _ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2a836e46c13894957834965487f79f243bd458f6" translate="yes" xml:space="preserve">
          <source>Try to get a property of the input value, check the error message if it exists. If the input value is undefined, the error message would be &lt;em&gt;Uncaught TypeError: Cannot read property 'b' of undefined&lt;/em&gt;</source>
          <target state="translated">尝试获取输入值的属性，检查错误消息是否存在。 如果输入值未定义，则错误消息将为&lt;em&gt;Uncaught TypeError：无法读取未定义的属性'b'&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31c8242d038a57a98e29aa92351bb4eeba57a99f" translate="yes" xml:space="preserve">
          <source>Underscore.js:</source>
          <target state="translated">Underscore.js:</target>
        </trans-unit>
        <trans-unit id="624f88833e4aa36d20755eda53fb498e36cc6d82" translate="yes" xml:space="preserve">
          <source>Update (for server-side JavaScript):</source>
          <target state="translated">更新(针对服务器端JavaScript)。</target>
        </trans-unit>
        <trans-unit id="0a8d800169d3f3a27add31e922bf0bca161dd01d" translate="yes" xml:space="preserve">
          <source>Update 9/9/2019</source>
          <target state="translated">更新992019</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="ca3566d6d324a104499679565f550124050f47c6" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;undefined&lt;/code&gt; is a global variable (so actually it is &lt;code&gt;window.undefined&lt;/code&gt; in browsers). It has been supported since ECMAScript 1st Edition and since ECMAScript 5 it is &lt;strong&gt;read only&lt;/strong&gt;. So in modern browsers it can't be &lt;em&gt;redefined to true&lt;/em&gt; as many authors love to frighten us with, but this is still a true for older browsers.</source>
          <target state="translated">变量 &lt;code&gt;undefined&lt;/code&gt; 是全局变量（因此实际上它是浏览器中的 &lt;code&gt;window.undefined&lt;/code&gt; ）。 从ECMAScript 1st Edition和ECMAScript 5开始，它一直受支持。 因此，在现代浏览器中，不能像许多作者喜欢的那样将其&lt;em&gt;重新定义为true&lt;/em&gt; ，但是这对于较旧的浏览器仍然是正确的。</target>
        </trans-unit>
        <trans-unit id="aa644c9b6d28b03bec73d65a8433d912ec0dc967" translate="yes" xml:space="preserve">
          <source>We can clearly see that &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; and &lt;code&gt;obj.prop === undefined&lt;/code&gt; are equivalent, and they do not distinguish those different situations. And &lt;code&gt;'prop' in obj&lt;/code&gt; can detect the situation when a property hasn't been defined at all and doesn't pay attention to the property value which may be undefined.</source>
          <target state="translated">我们可以清楚地看到 &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; 和 &lt;code&gt;obj.prop === undefined&lt;/code&gt; 是等效的，并且它们不能区分那些不同的情况。 &lt;code&gt;'prop' in obj&lt;/code&gt; 可以检测到根本没有定义属性并且不注意可能未定义的属性值的情况。</target>
        </trans-unit>
        <trans-unit id="b4348ecc1522f37bea2a74798eccb1c698101bae" translate="yes" xml:space="preserve">
          <source>What I am saying is that for my situation, all the suggestions above in this post did not work.  I'm not saying I'm right and everyone is wrong.  I am not a JavaScript master at all, but hopefully this will help someone.</source>
          <target state="translated">我想说的是,就我的情况而言,上面这个帖子里的所有建议都没有起到作用。我并不是说我是对的,大家都是错的。我完全不是一个JavaScript高手,但希望这篇文章能帮助到大家。</target>
        </trans-unit>
        <trans-unit id="6c6a10825c9a1a5ecbcd512402eb30eb39482e71" translate="yes" xml:space="preserve">
          <source>What does this mean: &lt;strong&gt;&quot;undefined object property&quot;&lt;/strong&gt;?</source>
          <target state="translated">这是什么意思： &lt;strong&gt;&amp;ldquo;未定义的对象属性&amp;rdquo;&lt;/strong&gt; ？</target>
        </trans-unit>
        <trans-unit id="86d7d00a77d485aef47636c622133ba6e079f28d" translate="yes" xml:space="preserve">
          <source>What's the best way of checking if an object property in JavaScript is &lt;code&gt;undefined&lt;/code&gt;?</source>
          <target state="translated">检查JavaScript中的对象属性是否 &lt;code&gt;undefined&lt;/code&gt; 的最佳方法是什么？</target>
        </trans-unit>
        <trans-unit id="6a44c70b62e1f951bfff4ad714a3bf6f9c36a141" translate="yes" xml:space="preserve">
          <source>When the first and simple condition is true, the interpreter skips the next tests.</source>
          <target state="translated">当第一个简单条件为真时,解释器跳过接下来的测试。</target>
        </trans-unit>
        <trans-unit id="b7221864517c5c211586a94530d68cdcfc6ea425" translate="yes" xml:space="preserve">
          <source>When you expect a specific type, test the type of the variable. To speed up testing a condition you better do:</source>
          <target state="translated">当你期待一个特定类型时,测试变量的类型。为了加快测试一个条件,你最好做。</target>
        </trans-unit>
        <trans-unit id="d60051b913c76582de7e88350c42134161b10c93" translate="yes" xml:space="preserve">
          <source>Which also equal to isDefined in Angular 1.x...</source>
          <target state="translated">这也相当于Angular 1.x中的isDefined......</target>
        </trans-unit>
        <trans-unit id="88ec2543321a88029f849108c87daeb5587d1c2d" translate="yes" xml:space="preserve">
          <source>Which was clearer when written without a check for undefined.</source>
          <target state="translated">哪一个在写的时候没有检查未定义的时候更清楚。</target>
        </trans-unit>
        <trans-unit id="5b51b27fa3903d28d3f04b6c171ad09973278eb9" translate="yes" xml:space="preserve">
          <source>While using this post to help me defend against this, I tried this.</source>
          <target state="translated">在用这个帖子帮我抵挡的同时,我试了一下这个。</target>
        </trans-unit>
        <trans-unit id="e71f039272b0f0e068195d6015ac5f2784fca83b" translate="yes" xml:space="preserve">
          <source>With how variables work out of the way, it&amp;rsquo;s time to address the actual question: object properties. There is no reason to ever use &lt;code&gt;typeof&lt;/code&gt; for object properties. The earlier exception regarding feature detection doesn&amp;rsquo;t apply here &amp;ndash; &lt;code&gt;typeof&lt;/code&gt; only has special behaviour on variables, and expressions that reference object properties are not variables.</source>
          <target state="translated">随着变量如何发挥作用，是时候解决一个实际问题：对象属性。 没有理由将 &lt;code&gt;typeof&lt;/code&gt; 用于对象属性。 较早的关于特征检测的例外不适用于此&amp;ndash; &lt;code&gt;typeof&lt;/code&gt; 仅对变量具有特殊的行为，而引用对象属性的表达式不是变量。</target>
        </trans-unit>
        <trans-unit id="fdb6add32a76812e71fb836b3a0175d29a715c41" translate="yes" xml:space="preserve">
          <source>You can get an array all undefined with path using the following code.</source>
          <target state="translated">你可以使用下面的代码获得一个数组所有未定义的路径。</target>
        </trans-unit>
        <trans-unit id="fd195a5d241f7801da7590d49a101b3417b1d020" translate="yes" xml:space="preserve">
          <source>You can use undefined and the strict equality and inequality operators to determine whether a variable has
  a value. In the following code, the variable x is not defined, and the
  if statement evaluates to true.</source>
          <target state="translated">你可以使用未定义和严格的平等和不平等运算符来确定一个变量是否有值。在下面的代码中,变量x没有被定义,而if语句的值为true。</target>
        </trans-unit>
        <trans-unit id="8bd945be1ad955926cb0576570ca86d427690000" translate="yes" xml:space="preserve">
          <source>You can't check an object and its property at the same time. For example, this &lt;code&gt;x.a === undefined&lt;/code&gt; or this &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; raises &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; if x is not defined.</source>
          <target state="translated">您不能同时检查一个对象及其属性。 例如，此 &lt;code&gt;x.a === undefined&lt;/code&gt; 或此类型的 &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; 引发 &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; 如果未定义 x，则未定义 x。</target>
        </trans-unit>
        <trans-unit id="afb57f9c5e1cd65cb89577ac225085a571888c95" translate="yes" xml:space="preserve">
          <source>and taking into account the advice above, to avoid confusing readers as to why you&amp;rsquo;re using &lt;code&gt;typeof&lt;/code&gt;, because it makes the most sense to use &lt;code&gt;===&lt;/code&gt; to check for equality, because it could be refactored to checking a variable&amp;rsquo;s value later, and because it just plain looks better, &lt;strong&gt;you should always use &lt;code&gt;=== undefined&lt;/code&gt;&amp;sup3; here as well&lt;/strong&gt;.</source>
          <target state="translated">并考虑到以上建议，以避免使读者对您为什么使用 &lt;code&gt;typeof&lt;/code&gt; 感到困惑，因为使用 &lt;code&gt;===&lt;/code&gt; 来检查相等性是最有意义的，因为以后可以将其重构为检查变量的值，并且由于它看起来比较好看，因此&lt;strong&gt;您也应该在此处始终使用 &lt;code&gt;=== undefined&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d105f7494e87ab388edea0f7b8c3a73720d04c6" translate="yes" xml:space="preserve">
          <source>and we check them as below, you can see the results in front of them as a comment:</source>
          <target state="translated">和我们检查他们如下,你可以看到在他们面前的结果作为一个评论。</target>
        </trans-unit>
        <trans-unit id="1a3490def710ea1d24edc82b74a46f9764b33bda" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;always exactly equivalent&lt;/em&gt; to this&amp;sup3;:</source>
          <target state="translated">&lt;em&gt;始终完全等&lt;/em&gt;于此&amp;sup3;：</target>
        </trans-unit>
        <trans-unit id="4778deb55d8cd5675a499ac484ad2ef5c74ec10c" translate="yes" xml:space="preserve">
          <source>isUndefined1:</source>
          <target state="translated">isUndefined1:</target>
        </trans-unit>
        <trans-unit id="15fa6dc48f1d00cd33b8f768892cc3b8131f1bbb" translate="yes" xml:space="preserve">
          <source>isUndefined2:</source>
          <target state="translated">isUndefined2:</target>
        </trans-unit>
        <trans-unit id="c871adbf9668a35abe539aa06d9c0dafaf3ce3ee" translate="yes" xml:space="preserve">
          <source>isUndefined3:</source>
          <target state="translated">isUndefined3:</target>
        </trans-unit>
        <trans-unit id="8ac534c595dd379491a89bb14380a533170408b9" translate="yes" xml:space="preserve">
          <source>it will fail when the variable &lt;code&gt;myvar&lt;/code&gt; does not exists, because myvar is not defined, so the script is broken and the test has no effect.</source>
          <target state="translated">当变量 &lt;code&gt;myvar&lt;/code&gt; 不存在时，它将失败，因为未定义myvar，因此脚本已损坏并且测试无效。</target>
        </trans-unit>
        <trans-unit id="985aa8a699702f412ce09aab8fceeb541def9317" translate="yes" xml:space="preserve">
          <source>more &amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">更多&amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;这里&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b79ab4d893a4264fa8785737934a4d1503cc8e5" translate="yes" xml:space="preserve">
          <source>so you will use it like:</source>
          <target state="translated">所以你会使用它的样子。</target>
        </trans-unit>
        <trans-unit id="157d0448c1dd7a8c6cfeab738ffaa2775caae49d" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;undefined&lt;/code&gt; can be overwritten. There&amp;rsquo;s a lot more to this. &lt;code&gt;undefined&lt;/code&gt; is not a keyword in JavaScript. Instead, it&amp;rsquo;s a property on the global object with the Undefined value. However, since ES5, this property has been &lt;em&gt;read-only&lt;/em&gt; and &lt;em&gt;non-configurable&lt;/em&gt;. No modern browser will allow the &lt;code&gt;undefined&lt;/code&gt; property to be changed, and as of 2017 this has been the case for a long time. Lack of strict mode doesn&amp;rsquo;t affect &lt;code&gt;undefined&lt;/code&gt;&amp;rsquo;s behaviour either &amp;ndash; it just makes statements like &lt;code&gt;undefined = 5&lt;/code&gt; do nothing instead of throwing. Since it isn&amp;rsquo;t a keyword, though, you can &lt;em&gt;declare&lt;/em&gt; variables with the name &lt;code&gt;undefined&lt;/code&gt;, and those variables could be changed, making this once-common pattern:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 可以被覆盖。 还有很多。 &lt;code&gt;undefined&lt;/code&gt; 不是JavaScript中的关键字。 相反，它是具有Undefined值的全局对象的属性。 但是，从ES5开始，此属性为&lt;em&gt;只读&lt;/em&gt;且&lt;em&gt;不可配置&lt;/em&gt; 。 没有最新的浏览器将允许更改 &lt;code&gt;undefined&lt;/code&gt; 属性，从2017年开始，这种情况已经存在很长时间了。 缺乏严格模式也不会影响 &lt;code&gt;undefined&lt;/code&gt; 的行为-只会使 &lt;code&gt;undefined = 5&lt;/code&gt; 类的语句无用而不是抛出。 但是，由于它不是关键字，因此可以使用 &lt;code&gt;undefined&lt;/code&gt; 名称&lt;em&gt;声明&lt;/em&gt;变量，并且可以更改这些变量，从而形成以下常见的模式：</target>
        </trans-unit>
        <trans-unit id="0793e2c88390a29b1957e9039867ab8ffb4111d4" translate="yes" xml:space="preserve">
          <source>that reading an &amp;ldquo;uninitialized&amp;rdquo; variable (&lt;code&gt;var foo&lt;/code&gt;) or parameter (&lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt;, called as &lt;code&gt;bar()&lt;/code&gt;) will fail. This is simply not true &amp;ndash; variables without explicit initialization and parameters that weren&amp;rsquo;t given values always become &lt;code&gt;undefined&lt;/code&gt;, and are always in scope.</source>
          <target state="translated">读取&amp;ldquo;未初始化的&amp;rdquo;变量（ &lt;code&gt;var foo&lt;/code&gt; ）或参数（ &lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt; ，称为 &lt;code&gt;bar()&lt;/code&gt; ）将失败。 这根本不是真的&amp;ndash;没有显式初始化的变量和没有给定值的参数始终变为 &lt;code&gt;undefined&lt;/code&gt; ，并且始终在范围内。</target>
        </trans-unit>
        <trans-unit id="36867f049a149d6504389c0dac25fc3f11212dfd" translate="yes" xml:space="preserve">
          <source>which is the identity operator...</source>
          <target state="translated">这就是特征运算符.....</target>
        </trans-unit>
        <trans-unit id="e0cafe396bcf72dbf7b9b4bc907e035155d2be4e" translate="yes" xml:space="preserve">
          <source>will return true, because they both are &quot;casted&quot; to a boolean and are false. The correct way would be to check</source>
          <target state="translated">将返回true,因为它们都被 &quot;铸成 &quot;为布尔值,并且是false。正确的方法是检查</target>
        </trans-unit>
        <trans-unit id="786ca9a6ff480fa14542ee13006ae5e448160486" translate="yes" xml:space="preserve">
          <source>you can also use Proxy, it will work with nested calls, but will require one extra check:</source>
          <target state="translated">你也可以使用Proxy,它可以使用嵌套调用,但需要额外的检查。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
