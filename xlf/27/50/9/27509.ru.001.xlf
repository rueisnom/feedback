<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/27509">
    <body>
      <group id="27509">
        <trans-unit id="9b76c7ee3ed3b22fe6b40e7d1df6c18824b37a8f" translate="yes" xml:space="preserve">
          <source>'&lt;em&gt;if (window.x) { }&lt;/em&gt;' is error safe</source>
          <target state="translated">' &lt;em&gt;if (window.x) {}&lt;/em&gt; ' безопасен от ошибок</target>
        </trans-unit>
        <trans-unit id="7afec1ce47ff900682bd7a527552baf0b3f48e7e" translate="yes" xml:space="preserve">
          <source>(y)</source>
          <target state="translated">(y)</target>
        </trans-unit>
        <trans-unit id="1963f681a0dc2983468889df82f1affdbe4cb8ed" translate="yes" xml:space="preserve">
          <source>1) You want to know if a property is undefined by either the first or second meaning (the most typical situation).</source>
          <target state="translated">1)Вы хотите знать,не определено ли свойство первым или вторым значением (наиболее типичная ситуация).</target>
        </trans-unit>
        <trans-unit id="2eff931c0d1f6eda47f88e36e5e2ca665e39f0b0" translate="yes" xml:space="preserve">
          <source>2) You want to just know if object has some property and don't care about its value.</source>
          <target state="translated">2)Вы хотите просто знать,имеет ли объект какую-либо собственность и не заботитесь о его стоимости.</target>
        </trans-unit>
        <trans-unit id="d95915c48ebcaada4c615be17c20592ad7a87e7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">ссылка &lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3c686407b77ca61732d9533437b84cc6af2398a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'undefned'&lt;/code&gt; (&lt;em&gt;misspelled&lt;/em&gt;) here is just a string constant, so the JavaScript engine can't help you if you have misspelled it like I just did.</source>
          <target state="translated">&lt;code&gt;'undefned'&lt;/code&gt; (с &lt;em&gt;орфографической ошибкой&lt;/em&gt; ) - это просто строковая константа, поэтому движок JavaScript не может помочь вам, если вы ошиблись, как я только что сделал.</target>
        </trans-unit>
        <trans-unit id="66262b2e58df668340e9c997b4fcbb22d477d689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; can be overridden in old browsers</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; может быть переопределен в старых браузерах</target>
        </trans-unit>
        <trans-unit id="9c0eca093d608d52888040610ad0fea09fe42fae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Note that the use of &lt;code&gt;var&lt;/code&gt; for &lt;code&gt;in&lt;/code&gt; tests make a difference when in a scoped wrapper)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Обратите внимание, что использование &lt;code&gt;var&lt;/code&gt; for &lt;code&gt;in&lt;/code&gt; тестах имеет значение, когда используется оболочка с заданной областью действия)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5812b0fa88241095ef998b82d3c2929c6f31055" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Specific to this question, see test cases with &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Специфично для этого вопроса, см. &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt; примеры с someObject .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b325ccf6a947861f6e178afd3921cc763cca384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;more&lt;/em&gt; dangerous than using the global &lt;code&gt;undefined&lt;/code&gt;. If you have to be ES3-compatible, replace &lt;code&gt;undefined&lt;/code&gt; with &lt;code&gt;void 0&lt;/code&gt; &amp;ndash; don&amp;rsquo;t resort to &lt;code&gt;typeof&lt;/code&gt;. (&lt;code&gt;void&lt;/code&gt; has always been a unary operator that evaluates to the Undefined value for any operand.)</source>
          <target state="translated">&lt;em&gt;более&lt;/em&gt; опасно, чем использование глобального &lt;code&gt;undefined&lt;/code&gt; . Если вам нужно быть совместимым с ES3, замените &lt;code&gt;undefined&lt;/code&gt; на &lt;code&gt;void 0&lt;/code&gt; - не прибегайте к &lt;code&gt;typeof&lt;/code&gt; . ( &lt;code&gt;void&lt;/code&gt; всегда был унарным оператором, который оценивается как неопределенное значение для любого операнда.)</target>
        </trans-unit>
        <trans-unit id="d6d59c5f807d7ec4a037b85ca3c5e7f05986ccb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; In response to your edit, object properties should work the same way.</source>
          <target state="translated">&lt;strong&gt;Редактировать:&lt;/strong&gt; в ответ на ваше редактирование свойства объекта должны работать так же.</target>
        </trans-unit>
        <trans-unit id="19806bd40175fc10a877fea67f68c16ed7195667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strict equality and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Строгое равенство и неопределенность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110d482d5dc176523e015517737b158007fd1e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is a difference between an undefined member and a defined member with an undefined value.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Существует разница между неопределенным членом и определенным членом с неопределенным значением.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f031e352cc2a0b3518c3a7f16759780f937d7a44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typeof operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тип оператора и неопределенный&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36bde56374a3373b2f73b61dde0097263e17ddb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Void operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пустой оператор и неопределенный&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d8f959e87c1d0dffd229886fa52757ad009bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;null&lt;/strong&gt; means that the variable value is defined and set to null (has no value).</source>
          <target state="translated">&lt;strong&gt;NULL&lt;/strong&gt; означает, что значение переменной определено и имеет значение NULL (не имеет значения).</target>
        </trans-unit>
        <trans-unit id="bec2062ef6d9e093a5eeb78377aa98519f789843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined&lt;/strong&gt; means that the variable value has not been defined; it is not known what the value is.</source>
          <target state="translated">&lt;strong&gt;undefined&lt;/strong&gt; означает, что значение переменной не было определено; неизвестно, какова стоимость.</target>
        </trans-unit>
        <trans-unit id="7ef0f25ff59da22f20a9f581d372dd5532c68b8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;window&lt;/strong&gt; is an object which holds all global variables as its members, and it is legal to try to access a non-existing member. If &lt;strong&gt;x&lt;/strong&gt; hasn't been declared or hasn't been set then &lt;code&gt;window.x&lt;/code&gt; returns &lt;strong&gt;undefined&lt;/strong&gt;. &lt;strong&gt;undefined&lt;/strong&gt; leads to &lt;strong&gt;false&lt;/strong&gt; when &lt;strong&gt;if()&lt;/strong&gt; evaluates it.</source>
          <target state="translated">&lt;strong&gt;window&lt;/strong&gt; - это объект, который содержит все глобальные переменные в качестве своих членов, и допустимо пытаться получить доступ к несуществующему члену. Если &lt;strong&gt;x&lt;/strong&gt; не был объявлен или не был установлен, то &lt;code&gt;window.x&lt;/code&gt; возвращает &lt;strong&gt;undefined&lt;/strong&gt; . &lt;strong&gt;undefined&lt;/strong&gt; приводит к &lt;strong&gt;ложному,&lt;/strong&gt; когда &lt;strong&gt;if ()&lt;/strong&gt; оценивает его.</target>
        </trans-unit>
        <trans-unit id="f0196332640a9574b642791f69278e0108d64482" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup1; unusual choice of example variable name? this is real dead code from the NoScript extension for Firefox.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup1; необычный выбор примера имени переменной?&lt;/sub&gt; &lt;sub&gt;это настоящий мертвый код из расширения NoScript для Firefox.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="832763f5083c7d8a0f4ef0ca33f1a035e0a67dc1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup2; don&amp;rsquo;t assume that not knowing what&amp;rsquo;s in scope is okay in general, though. bonus vulnerability caused by abuse of dynamic scope: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup2; не думайте, что не зная, что находится в области видимости, в целом все же хорошо.&lt;/sub&gt; &lt;sub&gt;бонусная уязвимость, вызванная злоупотреблением динамической областью действия: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="84456406b0e70016bbb43249541eb7f735f005f4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup3; once again assuming an ES5+ environment and that &lt;code&gt;undefined&lt;/code&gt; refers to the &lt;code&gt;undefined&lt;/code&gt; property of the global object. substitute &lt;code&gt;void 0&lt;/code&gt; otherwise.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup3; еще раз, предполагая, что среда ES5 + и что &lt;code&gt;undefined&lt;/code&gt; ссылается на &lt;code&gt;undefined&lt;/code&gt; свойство глобального объекта.&lt;/sub&gt; &lt;sub&gt;подставьте &lt;code&gt;void 0&lt;/code&gt; в противном случае.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="58cef43f9cc148fe201f6a40aa751b0117edb0fa" translate="yes" xml:space="preserve">
          <source>Actually it can mean two quite different things! First, it can mean &lt;em&gt;the property that has never been defined&lt;/em&gt; in the object and, second, it can mean the &lt;em&gt;property that has an undefined value&lt;/em&gt;. Let's look at this code:</source>
          <target state="translated">На самом деле это может означать две совершенно разные вещи! Во-первых, это может означать &lt;em&gt;свойство, которое никогда не было определено&lt;/em&gt; в объекте, и, во-вторых, это может означать &lt;em&gt;свойство, которое имеет неопределенное значение&lt;/em&gt; . Давайте посмотрим на этот код:</target>
        </trans-unit>
        <trans-unit id="349ce103efd4c2fadb9a858b41201bbd6794a393" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;myVar === undefined&lt;/code&gt; will raise an error in the situation where myVar is undeclared.</source>
          <target state="translated">Кроме того, &lt;code&gt;myVar === undefined&lt;/code&gt; вызовет ошибку в ситуации, когда myVar не объявлен.</target>
        </trans-unit>
        <trans-unit id="286d348194a35b840509a9c9d1227df8acbbd2ec" translate="yes" xml:space="preserve">
          <source>All the answers are incomplete. This is the right way of knowing that there is a property 'defined as undefined' :</source>
          <target state="translated">Все ответы неполные.Это правильный способ узнать,что есть свойство &quot;определено как неопределенное&quot;:</target>
        </trans-unit>
        <trans-unit id="f10c4fd9df413d69738977ff9f171b41d4667fe1" translate="yes" xml:space="preserve">
          <source>Also one more thing, for checking property on an object in a real application which you not sure even the object exists or not, check if the object exists first.</source>
          <target state="translated">Также еще одна вещь,для проверки свойств объекта в реальном приложении,в котором вы не уверены даже в том,что объект существует или нет,сначала проверьте,существует ли этот объект.</target>
        </trans-unit>
        <trans-unit id="219f34b6015e059105c29a26a98358fba3b56ee1" translate="yes" xml:space="preserve">
          <source>Also other javascript frameworks like underscore has similar defining check, but I recommend you use &lt;code&gt;typeof&lt;/code&gt; if you already not using any frameworks.</source>
          <target state="translated">Также другие фреймворки javascript, такие как подчеркивание, имеют аналогичную проверочную проверку, но я рекомендую использовать &lt;code&gt;typeof&lt;/code&gt; , если вы уже не используете фреймворки.</target>
        </trans-unit>
        <trans-unit id="791ed3302cfee030f9c8fa3bee23d8d3e1f0bc24" translate="yes" xml:space="preserve">
          <source>Alternatively, typeof can be used:</source>
          <target state="translated">В качестве альтернативы можно использовать тип:</target>
        </trans-unit>
        <trans-unit id="63b964d88fc95bd706292cbaa247b9c16e2755e4" translate="yes" xml:space="preserve">
          <source>And results:</source>
          <target state="translated">И результаты:</target>
        </trans-unit>
        <trans-unit id="d83e8ed16ed58afb7ab32795cb6009ac31db06ab" translate="yes" xml:space="preserve">
          <source>As you see we can check anything with using something like this in our code, as mentioned you can simply use &lt;code&gt;typeof&lt;/code&gt; in your code, but if you are using it over and over, create a function like the angular sample which I share and keep reusing as following DRY code pattern.</source>
          <target state="translated">Как вы видите, мы можем проверить что угодно, используя что-то подобное в нашем коде, как уже упоминалось, вы можете просто использовать &lt;code&gt;typeof&lt;/code&gt; в своем коде, но если вы используете его снова и снова, создайте функцию, подобную угловой выборке, которую я разделяю, и продолжаю использовать повторно. как следующий шаблон кода DRY.</target>
        </trans-unit>
        <trans-unit id="87f10ffef733699e5454e0973b6bbcf28272a26a" translate="yes" xml:space="preserve">
          <source>Because the window object has a global scope (default object) outside a function, a declaration will be 'attached' to the window object.</source>
          <target state="translated">Поскольку объект окна имеет глобальную область видимости (объект по умолчанию)вне функции,декларация будет &quot;прикреплена&quot; к объекту окна.</target>
        </trans-unit>
        <trans-unit id="2f6b520b68a6505ce09b8eb40967aa50ccdc1dcc" translate="yes" xml:space="preserve">
          <source>But as has been mentioned these are not exactly the same (but are more than good enough for my needs).</source>
          <target state="translated">Но,как уже было сказано,они не совсем одинаковые (но более чем достаточно хороши для моих нужд).</target>
        </trans-unit>
        <trans-unit id="fcfbf2fbae71c2369946c84ef809e8845fa289d8" translate="yes" xml:space="preserve">
          <source>But unhappily &lt;code&gt;typeof obj.foo&lt;/code&gt; does not tell us which of the three cases we have. However we can combine this with &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; to distinguish the cases.</source>
          <target state="translated">Но, к сожалению, &lt;code&gt;typeof obj.foo&lt;/code&gt; не говорит нам, какой из трех случаев у нас есть. Однако мы можем комбинировать это с &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; чтобы различать случаи.</target>
        </trans-unit>
        <trans-unit id="1daf4b17726ef0dab632dbab9c7df1fe0d5f44a0" translate="yes" xml:space="preserve">
          <source>Code for reference:</source>
          <target state="translated">Код для справки:</target>
        </trans-unit>
        <trans-unit id="fd83e3fc07c2d36f7a50c3554edc7779b39383e8" translate="yes" xml:space="preserve">
          <source>Commonly, people have asked me for an algorithm to figure out if a value is either falsy, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;. The following works.</source>
          <target state="translated">Обычно люди просят у меня алгоритм, чтобы выяснить, является ли значение ложным, &lt;code&gt;undefined&lt;/code&gt; или &lt;code&gt;null&lt;/code&gt; . Следующие работы.</target>
        </trans-unit>
        <trans-unit id="40c624d52a56db62dd4208fe5347d5d97cd36d54" translate="yes" xml:space="preserve">
          <source>Compare with &lt;code&gt;void 0&lt;/code&gt;, for terseness.</source>
          <target state="translated">Сравните с &lt;code&gt;void 0&lt;/code&gt; , для краткости.</target>
        </trans-unit>
        <trans-unit id="3e55bf53313fd9840391bfd75f5d5b1153e71e7c" translate="yes" xml:space="preserve">
          <source>Convert input value to string to compare with &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; and ensure it's negative value.</source>
          <target state="translated">Преобразуйте входное значение в строку для сравнения с &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; и убедитесь, что оно отрицательное.</target>
        </trans-unit>
        <trans-unit id="e38b4ae3f7cb873e402c0c020e6e974a8e377719" translate="yes" xml:space="preserve">
          <source>Correct Code</source>
          <target state="translated">Корректный код</target>
        </trans-unit>
        <trans-unit id="bbf717127e889535958ab6c66e7ca4d538373008" translate="yes" xml:space="preserve">
          <source>Crossposting my &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;answer&lt;/a&gt; from related question &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;How to check for &quot;undefined&quot; in JavaScript?&lt;/a&gt;</source>
          <target state="translated">Перекрестный &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;ответ на&lt;/a&gt; мой ответ по связанному вопросу &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;Как проверить &amp;laquo;неопределенный&amp;raquo; в JavaScript?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e2c55e17d9d063d6e819462c4f293237ba47eba" translate="yes" xml:space="preserve">
          <source>Defined as a falsy value, undefined,null, or never defined.</source>
          <target state="translated">Определяется как фальшивое значение,неопределенное,нулевое или никогда не определенное.</target>
        </trans-unit>
        <trans-unit id="f4c589078846130bd5d8f8b014b127005e460131" translate="yes" xml:space="preserve">
          <source>Defined as undefined Or never Defined</source>
          <target state="translated">Определяется как неопределенный или никогда не Определяется</target>
        </trans-unit>
        <trans-unit id="71177ce1bd442c1e211b610b3ce841a27b46d68f" translate="yes" xml:space="preserve">
          <source>Degenerate code. DO NOT USE.</source>
          <target state="translated">Дегенеративный код.НЕ ИСПОЛЬЗУЙТЕ.</target>
        </trans-unit>
        <trans-unit id="5e35f4620392124dd0fdbc52a3c5eb05fbd9f75d" translate="yes" xml:space="preserve">
          <source>Despite being vehemently recommended by many other answers here, &lt;code&gt;typeof&lt;/code&gt;&lt;em&gt;is a bad choice&lt;/em&gt;. It should never be used for checking whether variables have the value &lt;code&gt;undefined&lt;/code&gt;, because it acts as a combined check for the value &lt;code&gt;undefined&lt;/code&gt; and for whether a variable exists. In the vast majority of cases, you know when a variable exists, and &lt;code&gt;typeof&lt;/code&gt; will just introduce the potential for a silent failure if you make a typo in the variable name or in the string literal &lt;code&gt;'undefined'&lt;/code&gt;.</source>
          <target state="translated">Несмотря на то, что здесь яростно рекомендуют многие другие ответы, &lt;code&gt;typeof&lt;/code&gt; &lt;em&gt;- плохой выбор&lt;/em&gt; . Он никогда не должен использоваться для проверки, имеет ли переменная значение &lt;code&gt;undefined&lt;/code&gt; , потому что он действует как комбинированная проверка для значения &lt;code&gt;undefined&lt;/code&gt; и для существования переменной. В подавляющем большинстве случаев вы знаете, когда существует переменная, и &lt;code&gt;typeof&lt;/code&gt; просто представит возможность молчаливого сбоя, если вы сделаете опечатку в имени переменной или в строковом литерале &lt;code&gt;'undefined'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09909cfd981fdef3626ccc9834d9448da9e9745f" translate="yes" xml:space="preserve">
          <source>Detecting an undefined object property</source>
          <target state="translated">Обнаружение неопределенного свойства объекта</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58abfcd5560647f71db6174e6dae2c1d7b00956b" translate="yes" xml:space="preserve">
          <source>Example: I want to know if my browser supports History API</source>
          <target state="translated">Пример:Я хочу знать,поддерживает ли мой браузер API истории.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="1cc20ab6bb45b09d067f86e897de287544ccc18a" translate="yes" xml:space="preserve">
          <source>Final fight: &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</source>
          <target state="translated">Финальный бой: &lt;code&gt;obj.prop === undefined&lt;/code&gt; против &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="a66f6d43d5e07190edcbfd047a24a1c644663c95" translate="yes" xml:space="preserve">
          <source>For example: I've just been refactoring a bunch of code that had a bunch of checks whether an object had a given property.</source>
          <target state="translated">Например:Я только что рефакторинговал кучу кода,в котором была куча проверок,имеет ли объект заданное свойство.</target>
        </trans-unit>
        <trans-unit id="11cb88bb285ee32166071503cea3f43fbd246c9f" translate="yes" xml:space="preserve">
          <source>For my situation, if restResult.data[0] === &quot;object&quot;, then I can safely start inspecting the rest of the members.  If undefined then throw the error as above.</source>
          <target state="translated">Для моей ситуации,если restResult.data[0]===&quot;object&quot;,то я могу спокойно начать проверку остальных членов.Если не определено,то бросьте ошибку,как описано выше.</target>
        </trans-unit>
        <trans-unit id="282a1a5fba1c9f99dd9c65da723cf7e6ca6d5c3b" translate="yes" xml:space="preserve">
          <source>From lodash.js.</source>
          <target state="translated">Из Лоуэш Джейс.</target>
        </trans-unit>
        <trans-unit id="724505ac659cb61ec2ae6752fea94b6583d5c2e3" translate="yes" xml:space="preserve">
          <source>Going through the comments, for those who want to check both is it undefined or its value is null:</source>
          <target state="translated">Просматривая комментарии,для тех,кто хочет проверить и то,и другое,он неопределен или его значение нулевое:</target>
        </trans-unit>
        <trans-unit id="12f327f57e715c27af2a0b9e2dc98dfb92d437ff" translate="yes" xml:space="preserve">
          <source>Here is my situation:</source>
          <target state="translated">Вот моя ситуация:</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">Надеюсь,это поможет!</target>
        </trans-unit>
        <trans-unit id="21afb40540c44bc457dfbcf79a0414bc7750aa85" translate="yes" xml:space="preserve">
          <source>How this works:</source>
          <target state="translated">Как это работает:</target>
        </trans-unit>
        <trans-unit id="5d0e7097fe8f3623c402467f8277e8158fe7d304" translate="yes" xml:space="preserve">
          <source>However, this kind of technique should be avoided. JavaScript is a
  statically scoped language, so knowing if a variable is declared can
  be read by seeing whether it is declared in an enclosing context. The
  only exception is the global scope, but the global scope is bound to
  the global object, so checking the existence of a variable in the
  global context can be done by checking the existence of a property on
  the global object (using the in operator, for instance).</source>
          <target state="translated">Однако такого рода техники следует избегать.JavaScript является статически скопированным языком,поэтому знание того,объявлена ли переменная,можно прочитать,посмотрев,объявлена ли она в окружающем контексте.Единственным исключением является глобальная область видимости,но глобальная область видимости привязана к глобальному объекту,поэтому проверка существования переменной в глобальном контексте может быть осуществлена путем проверки существования свойства на глобальном объекте (например,с помощью оператора in).</target>
        </trans-unit>
        <trans-unit id="6fecf04984cba74419822b109f93545b2cd336ab" translate="yes" xml:space="preserve">
          <source>I also add this section from MDN which has got useful information about typeof, undefined and void(0).</source>
          <target state="translated">Я также добавляю этот раздел из MDN,который имеет полезную информацию о typeof,undefined и void(0).</target>
        </trans-unit>
        <trans-unit id="ca90e82d4aa8f47040cff0d3ebf2778f42cec981" translate="yes" xml:space="preserve">
          <source>I am using the result of a REST call.
The result should be parsed from JSON to a JavaScript object.</source>
          <target state="translated">Я использую результат REST-звонка.Результат должен быть разобран из JSON в объект JavaScript.</target>
        </trans-unit>
        <trans-unit id="44d30a96fae36c5b6279d6d45740204cbf4ff5a0" translate="yes" xml:space="preserve">
          <source>I believe there are a number of incorrect answers to this topic. Contrary to common belief, &quot;undefined&quot; is &lt;strong&gt;not&lt;/strong&gt; a keyword in JavaScript and can in fact have a value assigned to it.</source>
          <target state="translated">Я считаю, что есть ряд неправильных ответов на эту тему. Вопреки распространенному мнению, &amp;laquo;undefined&amp;raquo; &lt;strong&gt;не&lt;/strong&gt; является ключевым словом в JavaScript и может фактически иметь присвоенное ему значение.</target>
        </trans-unit>
        <trans-unit id="b37013d283a8127b7370563a4c36a206388c33a2" translate="yes" xml:space="preserve">
          <source>I didn't see (hope I didn't miss it) anyone checking the object before the property. So, this is the shortest and most effective (though not necessarily the most clear):</source>
          <target state="translated">Я не видел (надеюсь,я не пропустил)никого,кто проверял бы объект до того,как он стал собственностью.Таким образом,это самый короткий и самый эффективный (хотя и не обязательно самый ясный)объект:</target>
        </trans-unit>
        <trans-unit id="4358f6b4064ade07b2efbf8a21e0f4135f510c95" translate="yes" xml:space="preserve">
          <source>I found lodash updated its implementation. See &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;my issue&lt;/a&gt; and &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;the code&lt;/a&gt;.</source>
          <target state="translated">Я нашел, что lodash обновил свою реализацию. Смотрите &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;мою проблему&lt;/a&gt; и &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;код&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a132ebdcb8942d7a076277423ad437744ce7794" translate="yes" xml:space="preserve">
          <source>I provide three ways here for those who expect weird answers:</source>
          <target state="translated">Я предлагаю три способа для тех,кто ожидает странных ответов:</target>
        </trans-unit>
        <trans-unit id="48e26ba605da52f2cf32ca734ac26d9e06215803" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;if (this.variable)&lt;/code&gt; to test if it is defined. Simple &lt;code&gt;if (variable)&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;recommended above&lt;/a&gt;, fails for me. It turns out that it works only when variable is a field of some object, &lt;code&gt;obj.someField&lt;/code&gt; to check if it is defined in the dictionary. But we can use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; as the dictionary object since any variable is a field in current window, as I understand it. Therefore here is a test</source>
          <target state="translated">Я использую &lt;code&gt;if (this.variable)&lt;/code&gt; , чтобы проверить, определено ли оно. Простой &lt;code&gt;if (variable)&lt;/code&gt; , &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;рекомендованная выше&lt;/a&gt; , не работает Оказывается, это работает только тогда, когда переменная является полем некоторого объекта, &lt;code&gt;obj.someField&lt;/code&gt; , чтобы проверить, определено ли оно в словаре. Но мы можем использовать &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;window&lt;/code&gt; в качестве объекта словаря, поскольку любая переменная является полем в текущем окне, насколько я понимаю. Поэтому вот тест</target>
        </trans-unit>
        <trans-unit id="9e125ebcc0697240332e778b82ebf4d7f9c17043" translate="yes" xml:space="preserve">
          <source>I would like to show you something I'm using in order to protect the &lt;code&gt;undefined&lt;/code&gt; variable:</source>
          <target state="translated">Я хотел бы показать вам кое-что, что я использую для защиты &lt;code&gt;undefined&lt;/code&gt; переменной:</target>
        </trans-unit>
        <trans-unit id="d5a6d2b02368855c6fda929fd61af0ea56454c18" translate="yes" xml:space="preserve">
          <source>I'd argue that in some cases it makes more sense (and is clearer) to check whether the property is there, than checking whether it is undefined, and the only case where this check will be different is case 2, the rare case of an actual entry in the object with an undefined value.</source>
          <target state="translated">Я бы утверждал,что в некоторых случаях более разумно (и понятнее)проверять,есть ли свойство,чем проверять,не определено ли оно,и единственный случай,когда эта проверка будет отличаться-это случай 2,редкий случай фактической записи в объекте с неопределенным значением.</target>
        </trans-unit>
        <trans-unit id="7a7486fe538e6ce861baa007fbb0f526deff33d5" translate="yes" xml:space="preserve">
          <source>I'm not sure where the origin of using &lt;code&gt;===&lt;/code&gt; with &lt;code&gt;typeof&lt;/code&gt; came from, and as a convention I see it used in many libraries, but the typeof operator returns a string literal, and we know that up front, so why would you also want to type check it too?</source>
          <target state="translated">Я не уверен, откуда взялся источник использования &lt;code&gt;===&lt;/code&gt; с &lt;code&gt;typeof&lt;/code&gt; , и как соглашение я вижу, что он используется во многих библиотеках, но оператор typeof возвращает строковый литерал, и мы знаем это заранее, так почему бы вам также хотите, чтобы проверить это тоже?</target>
        </trans-unit>
        <trans-unit id="6ef1c4a3ea0bc81cc7398a1d04f0515bcbd0fb86" translate="yes" xml:space="preserve">
          <source>If an object variable which have some properties you can use same thing like this:</source>
          <target state="translated">Если объектная переменная имеет некоторые свойства,то можно использовать то же самое:</target>
        </trans-unit>
        <trans-unit id="84c7f1a126730161309b91866d156c12a47d03cd" translate="yes" xml:space="preserve">
          <source>If the obj or obj.prop is undefined, null, or &quot;falsy&quot;, the if statement will not execute the code block. This is &lt;em&gt;usually&lt;/em&gt; the desired behavior in most code block statements (in JavaScript).</source>
          <target state="translated">Если obj или obj.prop не определены, имеют значение null или &amp;laquo;ложь&amp;raquo;, оператор if не выполнит блок кода. Это &lt;em&gt;обычно&lt;/em&gt; желаемое поведение в большинстве операторов блока кода (в JavaScript).</target>
        </trans-unit>
        <trans-unit id="0d8a3869bd9a3727544999c872ed66c32e2161a3" translate="yes" xml:space="preserve">
          <source>If the value of an object was never defined, this will prevent from returning &lt;code&gt;true&lt;/code&gt; if it is defined as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. This is helpful if you want true to be returned for values set as &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Если значение объекта никогда не определялось, это не позволит вернуть &lt;code&gt;true&lt;/code&gt; , если оно определено как &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Это полезно, если вы хотите, чтобы значение true возвращалось для значений, заданных как &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e37e4c8d75647a160e70f184781ee5d3320919a7" translate="yes" xml:space="preserve">
          <source>If you are using Angular:</source>
          <target state="translated">Если вы используете &quot;Угловой&quot;:</target>
        </trans-unit>
        <trans-unit id="38b2ee0e2820da1917baa311fe8dc70a8ba6eb39" translate="yes" xml:space="preserve">
          <source>If you are using jQuery Library then &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; will suffice for both cases,</source>
          <target state="translated">Если вы используете библиотеку jQuery, то &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; будет достаточно для обоих случаев,</target>
        </trans-unit>
        <trans-unit id="4a3f6705c1b3da9943592b3d90136b8c5856782d" translate="yes" xml:space="preserve">
          <source>If you check a property on an object and the object doesn't exist, will throw an error and stop the whole application running.</source>
          <target state="translated">Если вы проверите свойство на объекте,а объект не существует,то это приведет к ошибке и остановит работу всего приложения.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">Если ты это сделаешь</target>
        </trans-unit>
        <trans-unit id="efde9566bc6269c016eb40d2c931ee65be1256d5" translate="yes" xml:space="preserve">
          <source>If you want it to result as &lt;code&gt;true&lt;/code&gt; for values defined with the value of &lt;code&gt;undefined&lt;/code&gt;, or never defined, you can simply use &lt;code&gt;=== undefined&lt;/code&gt;</source>
          <target state="translated">Если вы хотите, чтобы оно получило значение &lt;code&gt;true&lt;/code&gt; для значений, определенных со значением &lt;code&gt;undefined&lt;/code&gt; или никогда не определенных, вы можете просто использовать &lt;code&gt;=== undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c710b9144a4a4de7a8033df9d90b0d520b9d93cc" translate="yes" xml:space="preserve">
          <source>In JavaScript there is &lt;strong&gt;null&lt;/strong&gt; and there is &lt;strong&gt;undefined&lt;/strong&gt;.  They have different meanings.</source>
          <target state="translated">В JavaScript есть &lt;strong&gt;ноль&lt;/strong&gt; и есть &lt;strong&gt;неопределенный&lt;/strong&gt; . У них разные значения.</target>
        </trans-unit>
        <trans-unit id="676832a5b39fcd247b5da8131c2bb20e3f4e6479" translate="yes" xml:space="preserve">
          <source>In js, optional parameter works when the input value is exactly &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">В js необязательный параметр работает, когда входное значение точно &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47b70d6bd5d7420590fbe686fa1aa65f6aff345c" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Exploring the Abyss of Null and Undefined in JavaScript &lt;/a&gt;&lt;/em&gt; I read that frameworks like &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; use this function:</source>
          <target state="translated">В статье &amp;laquo; &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Изучение бездны нуля и неопределенности в JavaScript&amp;raquo;&lt;/a&gt;&lt;/em&gt; я прочитал, что фреймворки, такие как &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js,&lt;/a&gt; используют эту функцию:</target>
        </trans-unit>
        <trans-unit id="d6f3fa461bad66e062e473e85ddb6843faa72ad8" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;o.a&lt;/code&gt; undefined? Yes! Its value is undefined. Is &lt;code&gt;o.b&lt;/code&gt; undefined? Sure! There is no property 'b' at all! OK, see now how different approaches behave in both situations:</source>
          <target state="translated">Не определено? Да! Его значение не определено. &lt;code&gt;o.b&lt;/code&gt; неопределен? Конечно! Нет свойства 'b' вообще! Хорошо, теперь посмотрим, как разные подходы ведут себя в обеих ситуациях:</target>
        </trans-unit>
        <trans-unit id="5fd8487b64efdd4bc0f74bc89dcb48fb3b637b18" translate="yes" xml:space="preserve">
          <source>It creates a LOCAL variable named &lt;code&gt;undefined&lt;/code&gt; which is initialized with the default value -- the real &lt;code&gt;undefined&lt;/code&gt;, then compares &lt;code&gt;value&lt;/code&gt; with the variable &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Он создает переменную LOCAL с именем &lt;code&gt;undefined&lt;/code&gt; , которая инициализируется значением по умолчанию - действительное значение &lt;code&gt;undefined&lt;/code&gt; , а затем сравнивает &lt;code&gt;value&lt;/code&gt; с переменной &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc7e62a0477f84c6e213a2a66a6810ed10b81109" translate="yes" xml:space="preserve">
          <source>It first detects that variable &lt;code&gt;abc&lt;/code&gt; is undefined and it is defined after initialization.</source>
          <target state="translated">Сначала он обнаруживает, что переменная &lt;code&gt;abc&lt;/code&gt; не определена, и определяется после инициализации.</target>
        </trans-unit>
        <trans-unit id="0a0f662835940c2e3dcfdd198a56eabd87b6dab3" translate="yes" xml:space="preserve">
          <source>It is always better to use the instance/object of the variable to check if it got a valid value. It is more stable and is a better way of programming.</source>
          <target state="translated">Всегда лучше использовать экземпляр-объект переменной для проверки,получил ли он правильное значение.Это более стабильно и является лучшим способом программирования.</target>
        </trans-unit>
        <trans-unit id="4d8fd1abf77f99fdff5448384c2ed4fee6e5c474" translate="yes" xml:space="preserve">
          <source>It is really universal! It works in new and old browsers.</source>
          <target state="translated">Это действительно универсально! Он работает в новых и старых браузерах.</target>
        </trans-unit>
        <trans-unit id="a3b4d7eb65e80473b0d023a35685a8a9cba1977e" translate="yes" xml:space="preserve">
          <source>It's a bit shorter and looks a bit prettier</source>
          <target state="translated">Немного короче и выглядит немного красивее.</target>
        </trans-unit>
        <trans-unit id="1f9e9fe4a20d8dcfcf0cd7dd398ac00aaebacdc0" translate="yes" xml:space="preserve">
          <source>It's not as verbose as &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</source>
          <target state="translated">Это не так многословно, как &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda34532c7ceeef815dfdb84a302308f13b1698b" translate="yes" xml:space="preserve">
          <source>It's suitable if you have a function, which receives an additional config property:</source>
          <target state="translated">Подходит,если у вас есть функция,которая получает дополнительное свойство конфигурации:</target>
        </trans-unit>
        <trans-unit id="90a5de8bf9ed40e458f73d3c2fa132d1f4efa842" translate="yes" xml:space="preserve">
          <source>Its worth noting that these tests are the same for &lt;code&gt;null&lt;/code&gt; entries too</source>
          <target state="translated">Стоит отметить, что эти тесты одинаковы и для &lt;code&gt;null&lt;/code&gt; записей</target>
        </trans-unit>
        <trans-unit id="cca12d9c31c7dc579429ae296a479d2f796bada7" translate="yes" xml:space="preserve">
          <source>JavaScript has &lt;code&gt;typeof&lt;/code&gt; which make it very easy to detect an undefined variable.</source>
          <target state="translated">В JavaScript есть &lt;code&gt;typeof&lt;/code&gt; , благодаря которому очень просто обнаружить неопределенную переменную.</target>
        </trans-unit>
        <trans-unit id="a82d750a33e643b1a8a39e0ebb43d3b5768eaffc" translate="yes" xml:space="preserve">
          <source>Marijn Haverbeke states, in his free, online book &quot;&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt;&quot; (emphasis mine):</source>
          <target state="translated">Марин Хавербеке в своей бесплатной онлайн-книге &amp;laquo; &lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Красноречивый JavaScript&lt;/a&gt; &amp;raquo; (выделено мной) утверждает:</target>
        </trans-unit>
        <trans-unit id="5f9f4ff7cb7c3bd40b09bbc0a21ff4e94114ed3a" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">Минусы &lt;code&gt;obj.prop === undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0671b57c33e2e288915d086d37cc882d4a48e654" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">Минусы &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6bea7aa73158aa827a9c1bea87ededed070dc457" translate="yes" xml:space="preserve">
          <source>Most likely you want &lt;code&gt;if (window.x)&lt;/code&gt;. This check is safe even if x hasn't been declared (&lt;code&gt;var x;&lt;/code&gt;) - browser doesn't throw an error.</source>
          <target state="translated">Скорее всего, вы хотите, &lt;code&gt;if (window.x)&lt;/code&gt; . Эта проверка безопасна, даже если x не был объявлен ( &lt;code&gt;var x;&lt;/code&gt; ) - браузер не выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="9b4b5105b3b3a13be5c61e3fa3df47a1366e4075" translate="yes" xml:space="preserve">
          <source>Never Defined</source>
          <target state="translated">Никогда не определено</target>
        </trans-unit>
        <trans-unit id="9484abb038e36cb0cd8cbbc623288ca1c4c7dc51" translate="yes" xml:space="preserve">
          <source>Node.js supports the global variable &lt;code&gt;undefined&lt;/code&gt; as &lt;code&gt;global.undefined&lt;/code&gt; (it can also be used without the 'global' prefix). I don't know about other implementations of server-side JavaScript.</source>
          <target state="translated">Node.js поддерживает глобальную переменную &lt;code&gt;undefined&lt;/code&gt; как &lt;code&gt;global.undefined&lt;/code&gt; (ее также можно использовать без префикса &amp;laquo;global&amp;raquo;). Я не знаю о других реализациях серверного JavaScript.</target>
        </trans-unit>
        <trans-unit id="25e7237d29d65a8052d28a50ad68997f82c2cf73" translate="yes" xml:space="preserve">
          <source>Note: The strict equality operator rather than the standard equality
  operator must be used here, because x == undefined also checks whether
  x is null, while strict equality doesn't. null is not equivalent to
  undefined. See comparison operators for details.</source>
          <target state="translated">Замечание:Здесь должен использоваться оператор строгого равенства,а не стандартный оператор равенства,потому что x ==undefined также проверяет,равен ли x нулю,а строгое равенство нет.null не эквивалентно undefined.Подробности смотрите в операторах сравнения.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="59c5fb8a80a77710fbcb25bc27178f51a4e9b105" translate="yes" xml:space="preserve">
          <source>Now executing</source>
          <target state="translated">Сейчас исполняющий</target>
        </trans-unit>
        <trans-unit id="b2491f157aee8344e47a52d1010d094626fad59f" translate="yes" xml:space="preserve">
          <source>One reason to use typeof is that it does not throw an error if the
  variable has not been declared.</source>
          <target state="translated">Одной из причин использования typeof является то,что он не бросает ошибку,если переменная не была объявлена.</target>
        </trans-unit>
        <trans-unit id="aeca9079848cd62aa72e0c9da1ae45fee2f68f0f" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">Плюсы &lt;code&gt;obj.prop === undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c47d4b2cec06b65e3df4b5dc37d83b7c1779a8b3" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">Плюсы &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab5bb084b0953bb529d05917ef5d0f8f02b4e552" translate="yes" xml:space="preserve">
          <source>Reading through this, I'm amazed I didn't see this. I have found multiple algorithms that would work for this.</source>
          <target state="translated">Читая это,я поражаюсь,что не видел этого.Я нашел несколько алгоритмов,которые бы сработали.</target>
        </trans-unit>
        <trans-unit id="bb5a0c2d5893ca1120918abd2e27fe466333b1bf" translate="yes" xml:space="preserve">
          <source>Returns false if variable is set, and true if is undefined.</source>
          <target state="translated">Возвращает false,если переменная установлена,и true,если неопределена.</target>
        </trans-unit>
        <trans-unit id="883a8c4f5ebd87c4fde0e73e9656f30546585657" translate="yes" xml:space="preserve">
          <source>Simply anything is not defined in JavaScript, is &lt;strong&gt;undefined&lt;/strong&gt;, doesn't matter if it's a property inside an &lt;strong&gt;Object/Array&lt;/strong&gt; or as just a simple variable...</source>
          <target state="translated">Просто что-то не определено в JavaScript, не &lt;strong&gt;определено&lt;/strong&gt; , не имеет значения, является ли оно свойством внутри &lt;strong&gt;Object / Array&lt;/strong&gt; или просто как переменная ...</target>
        </trans-unit>
        <trans-unit id="aedd3fc984632b50a483c5fe2c50d6f41d6d1779" translate="yes" xml:space="preserve">
          <source>Simply check if &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; and it will return a boolean.</source>
          <target state="translated">Просто проверьте, если &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; и он вернет логическое значение.</target>
        </trans-unit>
        <trans-unit id="f828f39971d418b0bc13a1d98409cc5e98730d01" translate="yes" xml:space="preserve">
          <source>So as you see the function receive a value, if that value is defined, it will return &lt;code&gt;false&lt;/code&gt;, otherwise for undefined values, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Таким образом, как вы видите, функция получает значение, если это значение определено, она вернет &lt;code&gt;false&lt;/code&gt; , в противном случае для неопределенных значений вернет &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="418ae1e2e0311d3d2c105a70491013660c6a928b" translate="yes" xml:space="preserve">
          <source>So let's have a look what gonna be the results when we passing values, including object properties like below, this is the list of variables we have:</source>
          <target state="translated">Итак,давайте посмотрим,какими будут результаты,когда мы передадим значения,включая свойства объектов,как показано ниже,это список переменных,которые у нас есть:</target>
        </trans-unit>
        <trans-unit id="26532241df6bb6d2e9b7919c8174d92f3c3e9956" translate="yes" xml:space="preserve">
          <source>So simple you can wrap inside an if statement like below:</source>
          <target state="translated">Настолько просто,что ты можешь завернуть внутрь заявление,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="c03f8753c6b8939bcb611d65d70cd9f2e93a2bf4" translate="yes" xml:space="preserve">
          <source>So unless you&amp;rsquo;re doing feature detection&amp;sup2;, where there&amp;rsquo;s uncertainty whether a given name will be in scope (like checking &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; as a step in code specific to a CommonJS environment), &lt;code&gt;typeof&lt;/code&gt; is a harmful choice when used on a variable, and the correct option is to compare the value directly:</source>
          <target state="translated">Так что, если вы не делаете обнаружение функций&amp;sup2;, где есть неопределенность, будет ли данное имя находиться в области (например, проверка &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; как шаг в коде, специфичном для среды CommonJS), &lt;code&gt;typeof&lt;/code&gt; является вредным выбором при использовании для переменной, и правильный вариант - сравнить значение напрямую:</target>
        </trans-unit>
        <trans-unit id="9e1c8c9a0796fba24c5ae142d24dc8713fd92971" translate="yes" xml:space="preserve">
          <source>So what to do?</source>
          <target state="translated">Так что же делать?</target>
        </trans-unit>
        <trans-unit id="c4de3d5c3b3ce53f18295c6866165a0b386a0cc6" translate="yes" xml:space="preserve">
          <source>So, I guess the best way to check if something was undefined would be:</source>
          <target state="translated">Так что,я думаю,лучший способ проверить,не определено ли что-нибудь:</target>
        </trans-unit>
        <trans-unit id="62861616fb8499b1333e632d8f4f8c9d96d9ca16" translate="yes" xml:space="preserve">
          <source>So, for anyone who pass by, I will give you undefineds for free!!</source>
          <target state="translated">Итак,для каждого,кто пройдет мимо,я дам вам неопределенное бесплатно!!!</target>
        </trans-unit>
        <trans-unit id="93c6077f6664588e7ec5fe7e874c0816d5e39229" translate="yes" xml:space="preserve">
          <source>Some common misconceptions about this include:</source>
          <target state="translated">Некоторые распространенные заблуждения по этому поводу включают в себя:</target>
        </trans-unit>
        <trans-unit id="141f21882b084552acee073fca83c3cc0c42e7c8" translate="yes" xml:space="preserve">
          <source>Some scenarios illustrating the results of the various answers:
&lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</source>
          <target state="translated">Некоторые сценарии, иллюстрирующие результаты различных ответов: &lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5e2bb80f10dad7f8c5f9960cd6007b457637109" translate="yes" xml:space="preserve">
          <source>Something else to consider when it comes to object properties is whether you really want to check for &lt;code&gt;undefined&lt;/code&gt; at all. A given property name can be absent on an object (producing the value &lt;code&gt;undefined&lt;/code&gt; when read), present on the object itself with the value &lt;code&gt;undefined&lt;/code&gt;, present on the object&amp;rsquo;s prototype with the value &lt;code&gt;undefined&lt;/code&gt;, or present on either of those with a non-&lt;code&gt;undefined&lt;/code&gt; value. &lt;code&gt;'key' in obj&lt;/code&gt; will tell you whether a key is anywhere on an object&amp;rsquo;s prototype chain, and &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; will tell you whether it&amp;rsquo;s directly on the object. I won&amp;rsquo;t go into detail in this answer about prototypes and using objects as string-keyed maps, though, because it&amp;rsquo;s mostly intended to counter all the bad advice in other answers irrespective of the possible interpretations of the original question. Read up on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;object prototypes on MDN&lt;/a&gt; for more!</source>
          <target state="translated">Когда дело доходит до свойств объекта, нужно учитывать и то, действительно ли вы хотите проверять наличие &lt;code&gt;undefined&lt;/code&gt; . Заданное имя свойства может отсутствовать в объекте (создавая значение &lt;code&gt;undefined&lt;/code&gt; при чтении), присутствовать в самом объекте со значением &lt;code&gt;undefined&lt;/code&gt; , присутствовать в прототипе объекта со значением &lt;code&gt;undefined&lt;/code&gt; или присутствовать в любом из них с &lt;code&gt;undefined&lt;/code&gt; значение. &lt;code&gt;'key' in obj&lt;/code&gt; сообщит вам, находится ли ключ где-либо в цепочке прототипов объекта, а &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; скажет, находится ли он непосредственно на объекте. Я не буду вдаваться в подробности в этом ответе о прототипах и использовании объектов в качестве карт со строковыми ключами, потому что он в основном предназначен для противодействия всем плохим советам в других ответах, независимо от возможных интерпретаций исходного вопроса. Читайте об &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;объектных прототипах на MDN&lt;/a&gt; для большего количества!</target>
        </trans-unit>
        <trans-unit id="09414607443b3c66a48d7b3cc8690784e89229ef" translate="yes" xml:space="preserve">
          <source>That's how the famous function &lt;code&gt;isUndefined()&lt;/code&gt; in AngularJs v.1x is written:</source>
          <target state="translated">Вот как &lt;code&gt;isUndefined()&lt;/code&gt; знаменитая функция isUndefined () в AngularJs v.1x:</target>
        </trans-unit>
        <trans-unit id="1d798e4166272be66a0741b99698bc5ab930a831" translate="yes" xml:space="preserve">
          <source>The JavaScript engine will give you an error if you have misspelled &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Движок JavaScript выдаст вам ошибку, если вы допустили ошибку с ошибкой</target>
        </trans-unit>
        <trans-unit id="656b5d05c99fef961580b61f3edcaf330a6d66b8" translate="yes" xml:space="preserve">
          <source>The global variable &lt;em&gt;myvar&lt;/em&gt; is the same as &lt;em&gt;window.myvar&lt;/em&gt; or &lt;em&gt;window['myvar']&lt;/em&gt;</source>
          <target state="translated">Глобальная переменная &lt;em&gt;myvar&lt;/em&gt; такая же, как &lt;em&gt;window.myvar&lt;/em&gt; или &lt;em&gt;window ['myvar']&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29914467b1012003b3afd9aaffdcc32d8b458da1" translate="yes" xml:space="preserve">
          <source>The issue boils down to three cases:</source>
          <target state="translated">Проблема сводится к трем делам:</target>
        </trans-unit>
        <trans-unit id="8f19ead080cc475b112d23d1a87b473d84ebf23e" translate="yes" xml:space="preserve">
          <source>The most robust way to perform this test is:</source>
          <target state="translated">Самый надежный способ провести это испытание:</target>
        </trans-unit>
        <trans-unit id="195e6d98a22addf60a5f15d53507e42b6d225705" translate="yes" xml:space="preserve">
          <source>The object does not have the property.</source>
          <target state="translated">Объект не обладает собственностью.</target>
        </trans-unit>
        <trans-unit id="af4e3304635702004a3bc294a84b85b272ed0251" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">У объекта есть свойство, и его значение не &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0000fbbbec8c44ca2bc7134d63869dbf22df5843" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is not &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">У объекта есть свойство, и его значение не &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f12e6a8e8479790bcfba92ce8e2bdb1c0b5a2c71" translate="yes" xml:space="preserve">
          <source>The question if a variable really exists doesn't matter, its value is incorrect. Otherwise, it is silly to initialize variables with undefined, and it is better use the value false to initialize. When you know that all variables that you declare are initialized with false, you can simply check its type or rely on &lt;code&gt;!window.myvar&lt;/code&gt; to check if it has a proper/valid value. So even when the variable is not defined then &lt;code&gt;!window.myvar&lt;/code&gt; is the same for &lt;code&gt;myvar = undefined&lt;/code&gt; or &lt;code&gt;myvar = false&lt;/code&gt; or &lt;code&gt;myvar = 0&lt;/code&gt;.</source>
          <target state="translated">Вопрос о том, действительно ли переменная существует, не имеет значения, ее значение неверно. В противном случае глупо инициализировать переменные с неопределенным, и лучше использовать значение false для инициализации. Когда вы знаете, что все переменные, которые вы объявляете, инициализируются с помощью false, вы можете просто проверить их тип или положиться на &lt;code&gt;!window.myvar&lt;/code&gt; чтобы проверить, имеет ли оно правильное / правильное значение. Таким образом, даже если переменная не определена, то &lt;code&gt;!window.myvar&lt;/code&gt; одинаково для &lt;code&gt;myvar = undefined&lt;/code&gt; или &lt;code&gt;myvar = false&lt;/code&gt; или &lt;code&gt;myvar = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c187da4b16a273b05320f38b78197032e5f666" translate="yes" xml:space="preserve">
          <source>The solution is incorrect. In JavaScript,</source>
          <target state="translated">Решение неверное.В JavaScript,</target>
        </trans-unit>
        <trans-unit id="99c5e812eeb793c06c61ae79d6ce567d31253c67" translate="yes" xml:space="preserve">
          <source>The void operator is a third alternative.</source>
          <target state="translated">Третья альтернатива-пустой оператор.</target>
        </trans-unit>
        <trans-unit id="2624b916bf01c722be8fb21993d9edd3842b5f8d" translate="yes" xml:space="preserve">
          <source>Then use:</source>
          <target state="translated">Тогда используй:</target>
        </trans-unit>
        <trans-unit id="c306c1e05cc386f4fb986ead9800e3cb51d7d7ac" translate="yes" xml:space="preserve">
          <source>There is a nice &amp;amp; elegant way to assign a defined property to a new variable if it is defined or assign a default value to it as a fallback if it&amp;acute;s undefined.</source>
          <target state="translated">Существует хороший и элегантный способ назначить определенное свойство новой переменной, если оно определено, или назначить ему значение по умолчанию в качестве запасного, если оно не определено.</target>
        </trans-unit>
        <trans-unit id="909331b017c727d6b638a10340bcfa91fc4e0156" translate="yes" xml:space="preserve">
          <source>There is also a similar value, null, whose meaning is 'this value is defined, but it does not have a value'. The difference in meaning between undefined and null is mostly academic, and usually not very interesting. &lt;strong&gt;In practical programs, it is often necessary to check whether something 'has a value'. In these cases, the expression something == undefined may be used, because, even though they are not exactly the same value, null == undefined will produce true.&lt;/strong&gt;</source>
          <target state="translated">Существует также аналогичное значение, нулевое, значение которого &amp;laquo;это значение определено, но оно не имеет значения&amp;raquo;. Разница в значении между неопределенным и нулевым является в основном академической и обычно не очень интересной. &lt;strong&gt;В практических программах часто необходимо проверить, имеет ли что-то значение.&lt;/strong&gt; &lt;strong&gt;В этих случаях может использоваться выражение что-то == undefined, поскольку, даже если они не совпадают по значению, null == undefined приведет к значению true.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="066374c5c4c92cd26ce46b50a318fdbc81da8197" translate="yes" xml:space="preserve">
          <source>There is one error I need to defend.
If the args to the rest call were incorrect as far as the user specifying the args wrong, the rest call comes back basically empty.</source>
          <target state="translated">Есть одна ошибка,которую я должен защитить.Если аргументы для оставшегося вызова были неправильными,поскольку пользователь указал аргументы неправильно,оставшийся вызов возвращается практически пустым.</target>
        </trans-unit>
        <trans-unit id="4a1c97843ddae12e312165772ba1724256c18040" translate="yes" xml:space="preserve">
          <source>This forbids anyone to change the &lt;code&gt;window.undefined&lt;/code&gt; value therefore destroying the code based on that variable. If using &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;, anything trying to change its value will end in error, otherwise it would be silently ignored.</source>
          <target state="translated">Это запрещает кому-либо изменять значение &lt;code&gt;window.undefined&lt;/code&gt; , поэтому уничтожает код, основанный на этой переменной. Если использовать &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; , все попытки изменить его значение приведут к ошибке, в противном случае это будет игнорироваться.</target>
        </trans-unit>
        <trans-unit id="206b6848288b0371c75a01e649b5ef1c02732df1" translate="yes" xml:space="preserve">
          <source>This tells us something I consider important:</source>
          <target state="translated">Это говорит нам о том,что я считаю важным:</target>
        </trans-unit>
        <trans-unit id="882cd19a028fc5fdf4ac576781232fd9fb438143" translate="yes" xml:space="preserve">
          <source>This will always return the correct result, and even handles the situation where &lt;code&gt;myVar&lt;/code&gt; is not declared.</source>
          <target state="translated">Это всегда будет возвращать правильный результат и даже обрабатывает ситуацию, когда &lt;code&gt;myVar&lt;/code&gt; не объявлен.</target>
        </trans-unit>
        <trans-unit id="65d3b63892021dfc610049dfe83bb84e542216eb" translate="yes" xml:space="preserve">
          <source>This worked for me while the others didn't.</source>
          <target state="translated">Это сработало со мной,в то время как другие нет.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="1156bb5b9c53b338e90526a8c3e0f9157c2cdd5d" translate="yes" xml:space="preserve">
          <source>To avoid errors to test when a global variable exists, you better use:</source>
          <target state="translated">Чтобы избежать ошибок при тестировании,когда глобальная переменная существует,лучше использовать:</target>
        </trans-unit>
        <trans-unit id="af5a50ed0ca791f35da42bf271615ae60f9119f4" translate="yes" xml:space="preserve">
          <source>To be bullet-proof, simply use:</source>
          <target state="translated">Чтобы быть пуленепробиваемым,просто используйте:</target>
        </trans-unit>
        <trans-unit id="a3733768c50f085f705798790041179dcb01dd51" translate="yes" xml:space="preserve">
          <source>Too bad that this been the right answer is buried in wrong answers &amp;gt;_&amp;lt;</source>
          <target state="translated">Жаль, что это был правильный ответ, похоронен в неправильных ответах&amp;gt; _ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2a836e46c13894957834965487f79f243bd458f6" translate="yes" xml:space="preserve">
          <source>Try to get a property of the input value, check the error message if it exists. If the input value is undefined, the error message would be &lt;em&gt;Uncaught TypeError: Cannot read property 'b' of undefined&lt;/em&gt;</source>
          <target state="translated">Попробуйте получить свойство входного значения, проверьте сообщение об ошибке, если оно существует. Если входное значение не определено, сообщение об ошибке будет &lt;em&gt;Uncaught TypeError: Невозможно прочитать свойство 'b' из неопределенного&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31c8242d038a57a98e29aa92351bb4eeba57a99f" translate="yes" xml:space="preserve">
          <source>Underscore.js:</source>
          <target state="translated">Underscore.js:</target>
        </trans-unit>
        <trans-unit id="624f88833e4aa36d20755eda53fb498e36cc6d82" translate="yes" xml:space="preserve">
          <source>Update (for server-side JavaScript):</source>
          <target state="translated">Обновление (для серверного JavaScript):</target>
        </trans-unit>
        <trans-unit id="0a8d800169d3f3a27add31e922bf0bca161dd01d" translate="yes" xml:space="preserve">
          <source>Update 9/9/2019</source>
          <target state="translated">Обновление 992019</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="ca3566d6d324a104499679565f550124050f47c6" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;undefined&lt;/code&gt; is a global variable (so actually it is &lt;code&gt;window.undefined&lt;/code&gt; in browsers). It has been supported since ECMAScript 1st Edition and since ECMAScript 5 it is &lt;strong&gt;read only&lt;/strong&gt;. So in modern browsers it can't be &lt;em&gt;redefined to true&lt;/em&gt; as many authors love to frighten us with, but this is still a true for older browsers.</source>
          <target state="translated">Переменная &lt;code&gt;undefined&lt;/code&gt; является глобальной переменной (так что на самом деле это &lt;code&gt;window.undefined&lt;/code&gt; в браузерах). Он поддерживается с ECMAScript 1st Edition, а с ECMAScript 5 - &lt;strong&gt;только для чтения&lt;/strong&gt; . Так что в современных браузерах это нельзя &lt;em&gt;переопределить&lt;/em&gt; как &lt;em&gt;истинное, так&lt;/em&gt; как многие авторы любят пугать нас, но это все еще верно для старых браузеров.</target>
        </trans-unit>
        <trans-unit id="aa644c9b6d28b03bec73d65a8433d912ec0dc967" translate="yes" xml:space="preserve">
          <source>We can clearly see that &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; and &lt;code&gt;obj.prop === undefined&lt;/code&gt; are equivalent, and they do not distinguish those different situations. And &lt;code&gt;'prop' in obj&lt;/code&gt; can detect the situation when a property hasn't been defined at all and doesn't pay attention to the property value which may be undefined.</source>
          <target state="translated">Мы ясно видим, что &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; и &lt;code&gt;obj.prop === undefined&lt;/code&gt; эквивалентны, и они не различают эти разные ситуации. И &lt;code&gt;'prop' in obj&lt;/code&gt; может обнаружить ситуацию, когда свойство вообще не было определено и не обращает внимания на значение свойства, которое может быть неопределенным.</target>
        </trans-unit>
        <trans-unit id="b4348ecc1522f37bea2a74798eccb1c698101bae" translate="yes" xml:space="preserve">
          <source>What I am saying is that for my situation, all the suggestions above in this post did not work.  I'm not saying I'm right and everyone is wrong.  I am not a JavaScript master at all, but hopefully this will help someone.</source>
          <target state="translated">Я говорю о том,что для моей ситуации все предложения,приведенные выше в этой должности,не сработали.Я не говорю,что я прав,а все ошибаются.Я вовсе не мастер JavaScript,но надеюсь,что это кому-нибудь поможет.</target>
        </trans-unit>
        <trans-unit id="6c6a10825c9a1a5ecbcd512402eb30eb39482e71" translate="yes" xml:space="preserve">
          <source>What does this mean: &lt;strong&gt;&quot;undefined object property&quot;&lt;/strong&gt;?</source>
          <target state="translated">Что это значит: &lt;strong&gt;&amp;laquo;неопределенное свойство объекта&amp;raquo;&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="86d7d00a77d485aef47636c622133ba6e079f28d" translate="yes" xml:space="preserve">
          <source>What's the best way of checking if an object property in JavaScript is &lt;code&gt;undefined&lt;/code&gt;?</source>
          <target state="translated">Как лучше всего проверить, не задано ли свойство объекта в JavaScript?</target>
        </trans-unit>
        <trans-unit id="6a44c70b62e1f951bfff4ad714a3bf6f9c36a141" translate="yes" xml:space="preserve">
          <source>When the first and simple condition is true, the interpreter skips the next tests.</source>
          <target state="translated">Когда первое и простое условие верно,интерпретатор пропускает следующие тесты.</target>
        </trans-unit>
        <trans-unit id="b7221864517c5c211586a94530d68cdcfc6ea425" translate="yes" xml:space="preserve">
          <source>When you expect a specific type, test the type of the variable. To speed up testing a condition you better do:</source>
          <target state="translated">Когда вы ожидаете определенного типа,проверьте тип переменной.Чтобы ускорить тестирование состояния,лучше всего это сделать:</target>
        </trans-unit>
        <trans-unit id="d60051b913c76582de7e88350c42134161b10c93" translate="yes" xml:space="preserve">
          <source>Which also equal to isDefined in Angular 1.x...</source>
          <target state="translated">Которое также равнозначно определенному в Угловом 1.x...</target>
        </trans-unit>
        <trans-unit id="88ec2543321a88029f849108c87daeb5587d1c2d" translate="yes" xml:space="preserve">
          <source>Which was clearer when written without a check for undefined.</source>
          <target state="translated">Что было понятнее,когда писалось без чеков на неопределенное.</target>
        </trans-unit>
        <trans-unit id="5b51b27fa3903d28d3f04b6c171ad09973278eb9" translate="yes" xml:space="preserve">
          <source>While using this post to help me defend against this, I tried this.</source>
          <target state="translated">Используя этот пост,чтобы помочь мне защититься от этого,я пытался это сделать.</target>
        </trans-unit>
        <trans-unit id="e71f039272b0f0e068195d6015ac5f2784fca83b" translate="yes" xml:space="preserve">
          <source>With how variables work out of the way, it&amp;rsquo;s time to address the actual question: object properties. There is no reason to ever use &lt;code&gt;typeof&lt;/code&gt; for object properties. The earlier exception regarding feature detection doesn&amp;rsquo;t apply here &amp;ndash; &lt;code&gt;typeof&lt;/code&gt; only has special behaviour on variables, and expressions that reference object properties are not variables.</source>
          <target state="translated">С тем, как переменные работают вне пути, пришло время обратиться к фактическому вопросу: свойствам объекта. Нет никаких причин использовать &lt;code&gt;typeof&lt;/code&gt; для свойств объекта. Предыдущее исключение, касающееся обнаружения признаков, здесь не применимо - &lt;code&gt;typeof&lt;/code&gt; имеет специальное поведение только для переменных, а выражения, которые ссылаются на свойства объекта, не являются переменными.</target>
        </trans-unit>
        <trans-unit id="fdb6add32a76812e71fb836b3a0175d29a715c41" translate="yes" xml:space="preserve">
          <source>You can get an array all undefined with path using the following code.</source>
          <target state="translated">С помощью следующего кода можно получить массив с неопределенным путем.</target>
        </trans-unit>
        <trans-unit id="fd195a5d241f7801da7590d49a101b3417b1d020" translate="yes" xml:space="preserve">
          <source>You can use undefined and the strict equality and inequality operators to determine whether a variable has
  a value. In the following code, the variable x is not defined, and the
  if statement evaluates to true.</source>
          <target state="translated">Вы можете использовать неопределенные и строгие операторы равенства и неравенства для определения того,имеет ли переменная значение.В следующем коде переменная x не определена,а оператор if вычисляет true.</target>
        </trans-unit>
        <trans-unit id="8bd945be1ad955926cb0576570ca86d427690000" translate="yes" xml:space="preserve">
          <source>You can't check an object and its property at the same time. For example, this &lt;code&gt;x.a === undefined&lt;/code&gt; or this &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; raises &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; if x is not defined.</source>
          <target state="translated">Вы не можете проверить объект и его свойства одновременно. Например, этот &lt;code&gt;x.a === undefined&lt;/code&gt; или этот &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; вызывает &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; если x не определен.</target>
        </trans-unit>
        <trans-unit id="afb57f9c5e1cd65cb89577ac225085a571888c95" translate="yes" xml:space="preserve">
          <source>and taking into account the advice above, to avoid confusing readers as to why you&amp;rsquo;re using &lt;code&gt;typeof&lt;/code&gt;, because it makes the most sense to use &lt;code&gt;===&lt;/code&gt; to check for equality, because it could be refactored to checking a variable&amp;rsquo;s value later, and because it just plain looks better, &lt;strong&gt;you should always use &lt;code&gt;=== undefined&lt;/code&gt;&amp;sup3; here as well&lt;/strong&gt;.</source>
          <target state="translated">и принимая во внимание приведенный выше совет, чтобы не вводить читателей в заблуждение относительно того, почему вы используете &lt;code&gt;typeof&lt;/code&gt; , потому что имеет смысл использовать &lt;code&gt;===&lt;/code&gt; для проверки на равенство, потому что это может быть реорганизовано для проверки значения переменной позже, и поскольку он выглядит просто лучше, &lt;strong&gt;вы также должны всегда использовать &lt;code&gt;=== undefined&lt;/code&gt; &amp;sup3; и здесь&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d105f7494e87ab388edea0f7b8c3a73720d04c6" translate="yes" xml:space="preserve">
          <source>and we check them as below, you can see the results in front of them as a comment:</source>
          <target state="translated">и мы проверяем их,как показано ниже,вы можете увидеть результаты перед ними в виде комментария:</target>
        </trans-unit>
        <trans-unit id="1a3490def710ea1d24edc82b74a46f9764b33bda" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;always exactly equivalent&lt;/em&gt; to this&amp;sup3;:</source>
          <target state="translated">&lt;em&gt;всегда точно соответствует&lt;/em&gt; этому:</target>
        </trans-unit>
        <trans-unit id="4778deb55d8cd5675a499ac484ad2ef5c74ec10c" translate="yes" xml:space="preserve">
          <source>isUndefined1:</source>
          <target state="translated">isUndefined1:</target>
        </trans-unit>
        <trans-unit id="15fa6dc48f1d00cd33b8f768892cc3b8131f1bbb" translate="yes" xml:space="preserve">
          <source>isUndefined2:</source>
          <target state="translated">isUndefined2:</target>
        </trans-unit>
        <trans-unit id="c871adbf9668a35abe539aa06d9c0dafaf3ce3ee" translate="yes" xml:space="preserve">
          <source>isUndefined3:</source>
          <target state="translated">isUndefined3:</target>
        </trans-unit>
        <trans-unit id="8ac534c595dd379491a89bb14380a533170408b9" translate="yes" xml:space="preserve">
          <source>it will fail when the variable &lt;code&gt;myvar&lt;/code&gt; does not exists, because myvar is not defined, so the script is broken and the test has no effect.</source>
          <target state="translated">произойдет сбой, когда переменная &lt;code&gt;myvar&lt;/code&gt; не существует, поскольку myvar не определена, поэтому скрипт не работает, и тест не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="985aa8a699702f412ce09aab8fceeb541def9317" translate="yes" xml:space="preserve">
          <source>more &amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">больше&amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b79ab4d893a4264fa8785737934a4d1503cc8e5" translate="yes" xml:space="preserve">
          <source>so you will use it like:</source>
          <target state="translated">так что ты будешь использовать его как:</target>
        </trans-unit>
        <trans-unit id="157d0448c1dd7a8c6cfeab738ffaa2775caae49d" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;undefined&lt;/code&gt; can be overwritten. There&amp;rsquo;s a lot more to this. &lt;code&gt;undefined&lt;/code&gt; is not a keyword in JavaScript. Instead, it&amp;rsquo;s a property on the global object with the Undefined value. However, since ES5, this property has been &lt;em&gt;read-only&lt;/em&gt; and &lt;em&gt;non-configurable&lt;/em&gt;. No modern browser will allow the &lt;code&gt;undefined&lt;/code&gt; property to be changed, and as of 2017 this has been the case for a long time. Lack of strict mode doesn&amp;rsquo;t affect &lt;code&gt;undefined&lt;/code&gt;&amp;rsquo;s behaviour either &amp;ndash; it just makes statements like &lt;code&gt;undefined = 5&lt;/code&gt; do nothing instead of throwing. Since it isn&amp;rsquo;t a keyword, though, you can &lt;em&gt;declare&lt;/em&gt; variables with the name &lt;code&gt;undefined&lt;/code&gt;, and those variables could be changed, making this once-common pattern:</source>
          <target state="translated">это &lt;code&gt;undefined&lt;/code&gt; может быть перезаписано. Это намного больше. &lt;code&gt;undefined&lt;/code&gt; не является ключевым словом в JavaScript. Вместо этого это свойство глобального объекта с неопределенным значением. Однако, начиная с ES5, это свойство доступно &lt;em&gt;только&lt;/em&gt; &lt;em&gt;для&lt;/em&gt; &lt;em&gt;чтения&lt;/em&gt; и &lt;em&gt;не настраивается&lt;/em&gt; . Ни один современный браузер не позволяет изменять &lt;code&gt;undefined&lt;/code&gt; свойство, и по состоянию на 2017 год это имело место в течение длительного времени. Отсутствие строгого режима также не влияет на поведение &lt;code&gt;undefined&lt;/code&gt; - оно просто заставляет операторы, подобные &lt;code&gt;undefined = 5&lt;/code&gt; , ничего не делать вместо броска. Так как это не ключевое слово, вы можете &lt;em&gt;объявить&lt;/em&gt; переменные с именем &lt;code&gt;undefined&lt;/code&gt; , и эти переменные можно изменить, сделав этот некогда общий шаблон:</target>
        </trans-unit>
        <trans-unit id="0793e2c88390a29b1957e9039867ab8ffb4111d4" translate="yes" xml:space="preserve">
          <source>that reading an &amp;ldquo;uninitialized&amp;rdquo; variable (&lt;code&gt;var foo&lt;/code&gt;) or parameter (&lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt;, called as &lt;code&gt;bar()&lt;/code&gt;) will fail. This is simply not true &amp;ndash; variables without explicit initialization and parameters that weren&amp;rsquo;t given values always become &lt;code&gt;undefined&lt;/code&gt;, and are always in scope.</source>
          <target state="translated">что чтение &amp;laquo;неинициализированной&amp;raquo; переменной ( &lt;code&gt;var foo&lt;/code&gt; ) или параметра ( &lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt; , называемого &lt;code&gt;bar()&lt;/code&gt; ) не удастся. Это просто неверно - переменные без явной инициализации и параметры, которым не были заданы значения, всегда становятся &lt;code&gt;undefined&lt;/code&gt; и всегда находятся в области видимости.</target>
        </trans-unit>
        <trans-unit id="36867f049a149d6504389c0dac25fc3f11212dfd" translate="yes" xml:space="preserve">
          <source>which is the identity operator...</source>
          <target state="translated">который является оператором идентификации...</target>
        </trans-unit>
        <trans-unit id="e0cafe396bcf72dbf7b9b4bc907e035155d2be4e" translate="yes" xml:space="preserve">
          <source>will return true, because they both are &quot;casted&quot; to a boolean and are false. The correct way would be to check</source>
          <target state="translated">вернётся истиной,потому что они оба &quot;брошены&quot; в булев и ложны.Правильным способом будет проверить</target>
        </trans-unit>
        <trans-unit id="786ca9a6ff480fa14542ee13006ae5e448160486" translate="yes" xml:space="preserve">
          <source>you can also use Proxy, it will work with nested calls, but will require one extra check:</source>
          <target state="translated">вы также можете использовать Proxy,он будет работать со вложенными звонками,но потребует одну дополнительную проверку:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
