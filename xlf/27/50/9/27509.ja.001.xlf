<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/27509">
    <body>
      <group id="27509">
        <trans-unit id="9b76c7ee3ed3b22fe6b40e7d1df6c18824b37a8f" translate="yes" xml:space="preserve">
          <source>'&lt;em&gt;if (window.x) { }&lt;/em&gt;' is error safe</source>
          <target state="translated">' &lt;em&gt;if（window.x）{}&lt;/em&gt; 'はエラーセーフです</target>
        </trans-unit>
        <trans-unit id="7afec1ce47ff900682bd7a527552baf0b3f48e7e" translate="yes" xml:space="preserve">
          <source>(y)</source>
          <target state="translated">(y)</target>
        </trans-unit>
        <trans-unit id="1963f681a0dc2983468889df82f1affdbe4cb8ed" translate="yes" xml:space="preserve">
          <source>1) You want to know if a property is undefined by either the first or second meaning (the most typical situation).</source>
          <target state="translated">1)プロパティが第1または第2の意味(最も典型的な状況)で未定義かどうかを知りたい。</target>
        </trans-unit>
        <trans-unit id="2eff931c0d1f6eda47f88e36e5e2ca665e39f0b0" translate="yes" xml:space="preserve">
          <source>2) You want to just know if object has some property and don't care about its value.</source>
          <target state="translated">2)オブジェクトが何らかのプロパティを持っているかどうかを知りたいだけで、その値は気にしない。</target>
        </trans-unit>
        <trans-unit id="d95915c48ebcaada4c615be17c20592ad7a87e7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt;リンク</target>
        </trans-unit>
        <trans-unit id="f3c686407b77ca61732d9533437b84cc6af2398a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'undefned'&lt;/code&gt; (&lt;em&gt;misspelled&lt;/em&gt;) here is just a string constant, so the JavaScript engine can't help you if you have misspelled it like I just did.</source>
          <target state="translated">&lt;code&gt;'undefned'&lt;/code&gt; （ &lt;em&gt;スペルミス&lt;/em&gt; ）は単なる文字列定数なので、JavaScriptエンジンは、私がしたようにスペルミスをした場合には役に立ちません。</target>
        </trans-unit>
        <trans-unit id="66262b2e58df668340e9c997b4fcbb22d477d689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; can be overridden in old browsers</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; は古いブラウザで上書きできます</target>
        </trans-unit>
        <trans-unit id="9c0eca093d608d52888040610ad0fea09fe42fae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Note that the use of &lt;code&gt;var&lt;/code&gt; for &lt;code&gt;in&lt;/code&gt; tests make a difference when in a scoped wrapper)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（テストでの &lt;code&gt;var&lt;/code&gt; の使用は、スコープ付きラッパーの場合に違いがあることに注意してください）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5812b0fa88241095ef998b82d3c2929c6f31055" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Specific to this question, see test cases with &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この質問に固有の、 &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt; テストケースを参照してください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b325ccf6a947861f6e178afd3921cc763cca384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;more&lt;/em&gt; dangerous than using the global &lt;code&gt;undefined&lt;/code&gt;. If you have to be ES3-compatible, replace &lt;code&gt;undefined&lt;/code&gt; with &lt;code&gt;void 0&lt;/code&gt; &amp;ndash; don&amp;rsquo;t resort to &lt;code&gt;typeof&lt;/code&gt;. (&lt;code&gt;void&lt;/code&gt; has always been a unary operator that evaluates to the Undefined value for any operand.)</source>
          <target state="translated">グローバル &lt;code&gt;undefined&lt;/code&gt; を使用するよりも危険です。 ES3互換にする必要がある場合は、 &lt;code&gt;undefined&lt;/code&gt; を &lt;code&gt;void 0&lt;/code&gt; に置き換えます。typeofを使用しないでください。 （ &lt;code&gt;void&lt;/code&gt; は常に、任意のオペランドのUndefined値に評価される単項演算子でした。）</target>
        </trans-unit>
        <trans-unit id="d6d59c5f807d7ec4a037b85ca3c5e7f05986ccb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; In response to your edit, object properties should work the same way.</source>
          <target state="translated">&lt;strong&gt;編集：編集に&lt;/strong&gt;応答して、オブジェクトのプロパティは同じように機能するはずです。</target>
        </trans-unit>
        <trans-unit id="19806bd40175fc10a877fea67f68c16ed7195667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strict equality and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;厳密な平等と未定義&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110d482d5dc176523e015517737b158007fd1e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is a difference between an undefined member and a defined member with an undefined value.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;未定義のメンバーと、未定義の値を持つ定義済みメンバーとの間には違いがあります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f031e352cc2a0b3518c3a7f16759780f937d7a44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typeof operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Typeof演算子および未定義&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36bde56374a3373b2f73b61dde0097263e17ddb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Void operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;void演算子と未定義&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d8f959e87c1d0dffd229886fa52757ad009bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;null&lt;/strong&gt; means that the variable value is defined and set to null (has no value).</source>
          <target state="translated">&lt;strong&gt;null&lt;/strong&gt;は、変数値が定義され、nullに設定されている（値がない）ことを意味します。</target>
        </trans-unit>
        <trans-unit id="bec2062ef6d9e093a5eeb78377aa98519f789843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined&lt;/strong&gt; means that the variable value has not been defined; it is not known what the value is.</source>
          <target state="translated">&lt;strong&gt;undefined&lt;/strong&gt;は、変数値が定義されていないことを意味します。 値が何であるかは不明です。</target>
        </trans-unit>
        <trans-unit id="7ef0f25ff59da22f20a9f581d372dd5532c68b8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;window&lt;/strong&gt; is an object which holds all global variables as its members, and it is legal to try to access a non-existing member. If &lt;strong&gt;x&lt;/strong&gt; hasn't been declared or hasn't been set then &lt;code&gt;window.x&lt;/code&gt; returns &lt;strong&gt;undefined&lt;/strong&gt;. &lt;strong&gt;undefined&lt;/strong&gt; leads to &lt;strong&gt;false&lt;/strong&gt; when &lt;strong&gt;if()&lt;/strong&gt; evaluates it.</source>
          <target state="translated">&lt;strong&gt;window&lt;/strong&gt;は、すべてのグローバル変数をメンバーとして保持するオブジェクトであり、存在しないメンバーにアクセスしようとすることは合法です。 &lt;strong&gt;x&lt;/strong&gt;が宣言されていないか、設定されていない場合、 &lt;code&gt;window.x&lt;/code&gt; は&lt;strong&gt;undefinedを&lt;/strong&gt;返します。 &lt;strong&gt;undefined&lt;/strong&gt;は、 &lt;strong&gt;if（）が&lt;/strong&gt;評価し&lt;strong&gt;た&lt;/strong&gt;ときに&lt;strong&gt;false&lt;/strong&gt;になります。</target>
        </trans-unit>
        <trans-unit id="f0196332640a9574b642791f69278e0108d64482" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup1; unusual choice of example variable name? this is real dead code from the NoScript extension for Firefox.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;例の変数名の変わった選択？&lt;/sub&gt; &lt;sub&gt;これは、FirefoxのNoScript拡張機能からの実際のデッドコードです。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="832763f5083c7d8a0f4ef0ca33f1a035e0a67dc1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup2; don&amp;rsquo;t assume that not knowing what&amp;rsquo;s in scope is okay in general, though. bonus vulnerability caused by abuse of dynamic scope: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup2;ただし、一般的には、対象範囲がわからなくても大丈夫だとは限りません。&lt;/sub&gt; &lt;sub&gt;ダイナミックスコープの悪用によるボーナスの脆弱性： &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="84456406b0e70016bbb43249541eb7f735f005f4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup3; once again assuming an ES5+ environment and that &lt;code&gt;undefined&lt;/code&gt; refers to the &lt;code&gt;undefined&lt;/code&gt; property of the global object. substitute &lt;code&gt;void 0&lt;/code&gt; otherwise.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup3;ES5 +環境を想定しており、その &lt;code&gt;undefined&lt;/code&gt; はグローバルオブジェクトの &lt;code&gt;undefined&lt;/code&gt; プロパティを参照します。&lt;/sub&gt; &lt;sub&gt;それ以外の場合は &lt;code&gt;void 0&lt;/code&gt; に置き換えます 。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="58cef43f9cc148fe201f6a40aa751b0117edb0fa" translate="yes" xml:space="preserve">
          <source>Actually it can mean two quite different things! First, it can mean &lt;em&gt;the property that has never been defined&lt;/em&gt; in the object and, second, it can mean the &lt;em&gt;property that has an undefined value&lt;/em&gt;. Let's look at this code:</source>
          <target state="translated">実際には、2つのまったく異なることを意味します。 1つ目は、オブジェクトで&lt;em&gt;定義さ&lt;/em&gt;れた&lt;em&gt;ことのないプロパティを&lt;/em&gt;意味&lt;em&gt;し&lt;/em&gt; 、2つ目&lt;em&gt;は、値が未定義のプロパティを&lt;/em&gt;意味し&lt;em&gt;ます&lt;/em&gt; 。 このコードを見てみましょう：</target>
        </trans-unit>
        <trans-unit id="349ce103efd4c2fadb9a858b41201bbd6794a393" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;myVar === undefined&lt;/code&gt; will raise an error in the situation where myVar is undeclared.</source>
          <target state="translated">さらに、 &lt;code&gt;myVar === undefined&lt;/code&gt; は、myVarが宣言されていない状況でエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="286d348194a35b840509a9c9d1227df8acbbd2ec" translate="yes" xml:space="preserve">
          <source>All the answers are incomplete. This is the right way of knowing that there is a property 'defined as undefined' :</source>
          <target state="translated">全ての答えが不完全なものになっています。これは、「未定義として定義された」プロパティがあることを知る正しい方法です。</target>
        </trans-unit>
        <trans-unit id="f10c4fd9df413d69738977ff9f171b41d4667fe1" translate="yes" xml:space="preserve">
          <source>Also one more thing, for checking property on an object in a real application which you not sure even the object exists or not, check if the object exists first.</source>
          <target state="translated">もう一つ、実際のアプリケーションでは、オブジェクトの存在すら分からないようなオブジェクトのプロパティを確認する場合は、まずオブジェクトが存在するかどうかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="219f34b6015e059105c29a26a98358fba3b56ee1" translate="yes" xml:space="preserve">
          <source>Also other javascript frameworks like underscore has similar defining check, but I recommend you use &lt;code&gt;typeof&lt;/code&gt; if you already not using any frameworks.</source>
          <target state="translated">また、アンダースコアなどの他のJavaScriptフレームワークにも同様の定義チェックがありますが、フレームワークをまだ使用していない場合は、 &lt;code&gt;typeof&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="791ed3302cfee030f9c8fa3bee23d8d3e1f0bc24" translate="yes" xml:space="preserve">
          <source>Alternatively, typeof can be used:</source>
          <target state="translated">また、typeofを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="63b964d88fc95bd706292cbaa247b9c16e2755e4" translate="yes" xml:space="preserve">
          <source>And results:</source>
          <target state="translated">そして結果。</target>
        </trans-unit>
        <trans-unit id="d83e8ed16ed58afb7ab32795cb6009ac31db06ab" translate="yes" xml:space="preserve">
          <source>As you see we can check anything with using something like this in our code, as mentioned you can simply use &lt;code&gt;typeof&lt;/code&gt; in your code, but if you are using it over and over, create a function like the angular sample which I share and keep reusing as following DRY code pattern.</source>
          <target state="translated">ご覧のとおり、コードでこのようなものを使用して何でもチェックできます。前述のように、コードで &lt;code&gt;typeof&lt;/code&gt; を使用できますが、何度も使用する場合は、角度サンプルのような関数を作成して共有し、再利用します。次のDRYコードパターンとして。</target>
        </trans-unit>
        <trans-unit id="87f10ffef733699e5454e0973b6bbcf28272a26a" translate="yes" xml:space="preserve">
          <source>Because the window object has a global scope (default object) outside a function, a declaration will be 'attached' to the window object.</source>
          <target state="translated">ウィンドウオブジェクトは関数の外にグローバルスコープ(デフォルトオブジェクト)を持っているので、宣言はウィンドウオブジェクトに「アタッチ」されます。</target>
        </trans-unit>
        <trans-unit id="2f6b520b68a6505ce09b8eb40967aa50ccdc1dcc" translate="yes" xml:space="preserve">
          <source>But as has been mentioned these are not exactly the same (but are more than good enough for my needs).</source>
          <target state="translated">しかし、これまで述べてきたように、これらは全く同じではありません(しかし、私のニーズには十分以上に適しています)。</target>
        </trans-unit>
        <trans-unit id="fcfbf2fbae71c2369946c84ef809e8845fa289d8" translate="yes" xml:space="preserve">
          <source>But unhappily &lt;code&gt;typeof obj.foo&lt;/code&gt; does not tell us which of the three cases we have. However we can combine this with &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; to distinguish the cases.</source>
          <target state="translated">しかし、 &lt;code&gt;typeof obj.foo&lt;/code&gt; は、3つのケースのどれが発生しているかを教えてくれません。 ただし、これを &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; と組み合わせて、ケースを区別できます。</target>
        </trans-unit>
        <trans-unit id="1daf4b17726ef0dab632dbab9c7df1fe0d5f44a0" translate="yes" xml:space="preserve">
          <source>Code for reference:</source>
          <target state="translated">参照用のコードです。</target>
        </trans-unit>
        <trans-unit id="fd83e3fc07c2d36f7a50c3554edc7779b39383e8" translate="yes" xml:space="preserve">
          <source>Commonly, people have asked me for an algorithm to figure out if a value is either falsy, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;. The following works.</source>
          <target state="translated">一般的に、値が偽、 &lt;code&gt;undefined&lt;/code&gt; 、または &lt;code&gt;null&lt;/code&gt; のいずれかであるかどうかを判別するアルゴリズムを求められます 。 以下の作品。</target>
        </trans-unit>
        <trans-unit id="40c624d52a56db62dd4208fe5347d5d97cd36d54" translate="yes" xml:space="preserve">
          <source>Compare with &lt;code&gt;void 0&lt;/code&gt;, for terseness.</source>
          <target state="translated">簡潔さについては、 &lt;code&gt;void 0&lt;/code&gt; と比較してください。</target>
        </trans-unit>
        <trans-unit id="3e55bf53313fd9840391bfd75f5d5b1153e71e7c" translate="yes" xml:space="preserve">
          <source>Convert input value to string to compare with &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; and ensure it's negative value.</source>
          <target state="translated">入力値を文字列に変換して &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; と比較し、負の値であることを確認します。</target>
        </trans-unit>
        <trans-unit id="e38b4ae3f7cb873e402c0c020e6e974a8e377719" translate="yes" xml:space="preserve">
          <source>Correct Code</source>
          <target state="translated">正しいコード</target>
        </trans-unit>
        <trans-unit id="bbf717127e889535958ab6c66e7ca4d538373008" translate="yes" xml:space="preserve">
          <source>Crossposting my &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;answer&lt;/a&gt; from related question &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;How to check for &quot;undefined&quot; in JavaScript?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;JavaScriptで「未定義」をチェックする方法&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e2c55e17d9d063d6e819462c4f293237ba47eba" translate="yes" xml:space="preserve">
          <source>Defined as a falsy value, undefined,null, or never defined.</source>
          <target state="translated">誤った値、未定義、NULL、または定義されていない値として定義されています。</target>
        </trans-unit>
        <trans-unit id="f4c589078846130bd5d8f8b014b127005e460131" translate="yes" xml:space="preserve">
          <source>Defined as undefined Or never Defined</source>
          <target state="translated">未定義と定義されている または定義されていない</target>
        </trans-unit>
        <trans-unit id="71177ce1bd442c1e211b610b3ce841a27b46d68f" translate="yes" xml:space="preserve">
          <source>Degenerate code. DO NOT USE.</source>
          <target state="translated">堕落したコード。使用しないでください。</target>
        </trans-unit>
        <trans-unit id="5e35f4620392124dd0fdbc52a3c5eb05fbd9f75d" translate="yes" xml:space="preserve">
          <source>Despite being vehemently recommended by many other answers here, &lt;code&gt;typeof&lt;/code&gt;&lt;em&gt;is a bad choice&lt;/em&gt;. It should never be used for checking whether variables have the value &lt;code&gt;undefined&lt;/code&gt;, because it acts as a combined check for the value &lt;code&gt;undefined&lt;/code&gt; and for whether a variable exists. In the vast majority of cases, you know when a variable exists, and &lt;code&gt;typeof&lt;/code&gt; will just introduce the potential for a silent failure if you make a typo in the variable name or in the string literal &lt;code&gt;'undefined'&lt;/code&gt;.</source>
          <target state="translated">ここで他の多くの回答によって激しく推奨されていますが、 &lt;code&gt;typeof&lt;/code&gt; &lt;em&gt;は悪い選択&lt;/em&gt;です。 値が &lt;code&gt;undefined&lt;/code&gt; かどうか、および変数が存在するかどうかの複合チェックとして機能するため、変数が値 &lt;code&gt;undefined&lt;/code&gt; を持っているかどうかのチェックには使用しないでください。 ほとんどの場合、変数がいつ存在するかがわかっているので、変数名または文字列リテラル &lt;code&gt;'undefined'&lt;/code&gt; にタイプミスをすると、 &lt;code&gt;typeof&lt;/code&gt; は単に静かな失敗の可能性をもたらします。</target>
        </trans-unit>
        <trans-unit id="09909cfd981fdef3626ccc9834d9448da9e9745f" translate="yes" xml:space="preserve">
          <source>Detecting an undefined object property</source>
          <target state="translated">未定義のオブジェクトプロパティの検出</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58abfcd5560647f71db6174e6dae2c1d7b00956b" translate="yes" xml:space="preserve">
          <source>Example: I want to know if my browser supports History API</source>
          <target state="translated">例をご紹介します。ブラウザがHistory APIをサポートしているかどうか知りたい</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="1cc20ab6bb45b09d067f86e897de287544ccc18a" translate="yes" xml:space="preserve">
          <source>Final fight: &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</source>
          <target state="translated">最終的な戦い： &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="a66f6d43d5e07190edcbfd047a24a1c644663c95" translate="yes" xml:space="preserve">
          <source>For example: I've just been refactoring a bunch of code that had a bunch of checks whether an object had a given property.</source>
          <target state="translated">例えば 私は、オブジェクトが与えられたプロパティを持っているかどうかをチェックするコードの束をリファクタリングしていました。</target>
        </trans-unit>
        <trans-unit id="11cb88bb285ee32166071503cea3f43fbd246c9f" translate="yes" xml:space="preserve">
          <source>For my situation, if restResult.data[0] === &quot;object&quot;, then I can safely start inspecting the rest of the members.  If undefined then throw the error as above.</source>
          <target state="translated">私の状況では、restResult.data[0]===&quot;object &quot;であれば、残りのメンバーの検査を安全に開始することができます。未定義の場合は、上記のようなエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="282a1a5fba1c9f99dd9c65da723cf7e6ca6d5c3b" translate="yes" xml:space="preserve">
          <source>From lodash.js.</source>
          <target state="translated">lodash.jsより。</target>
        </trans-unit>
        <trans-unit id="724505ac659cb61ec2ae6752fea94b6583d5c2e3" translate="yes" xml:space="preserve">
          <source>Going through the comments, for those who want to check both is it undefined or its value is null:</source>
          <target state="translated">コメントを通過すると、両方をチェックしたい人のために、それは未定義またはその値がnullです。</target>
        </trans-unit>
        <trans-unit id="12f327f57e715c27af2a0b9e2dc98dfb92d437ff" translate="yes" xml:space="preserve">
          <source>Here is my situation:</source>
          <target state="translated">私の状況はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">これが役に立つことを願っています</target>
        </trans-unit>
        <trans-unit id="21afb40540c44bc457dfbcf79a0414bc7750aa85" translate="yes" xml:space="preserve">
          <source>How this works:</source>
          <target state="translated">これがどう動くのか。</target>
        </trans-unit>
        <trans-unit id="5d0e7097fe8f3623c402467f8277e8158fe7d304" translate="yes" xml:space="preserve">
          <source>However, this kind of technique should be avoided. JavaScript is a
  statically scoped language, so knowing if a variable is declared can
  be read by seeing whether it is declared in an enclosing context. The
  only exception is the global scope, but the global scope is bound to
  the global object, so checking the existence of a variable in the
  global context can be done by checking the existence of a property on
  the global object (using the in operator, for instance).</source>
          <target state="translated">しかし、このようなテクニックは避けるべきです。JavaScriptは静的スコープ言語なので、変数が宣言されているかどうかを知ることは、変数が囲い込みコンテキストで宣言されているかどうかを見ることで読み取ることができます。唯一の例外はグローバルスコープですが、グローバルスコープはグローバルオブジェクトにバインドされているので、グローバルコンテキスト内の変数の存在を確認するには、グローバルオブジェクト上のプロパティの存在を確認することで行うことができます(例えば、in演算子を使用します)。</target>
        </trans-unit>
        <trans-unit id="6fecf04984cba74419822b109f93545b2cd336ab" translate="yes" xml:space="preserve">
          <source>I also add this section from MDN which has got useful information about typeof, undefined and void(0).</source>
          <target state="translated">また、typeof,undefined,void(0)について有用な情報を得たMDNからこのセクションを追加しました。</target>
        </trans-unit>
        <trans-unit id="ca90e82d4aa8f47040cff0d3ebf2778f42cec981" translate="yes" xml:space="preserve">
          <source>I am using the result of a REST call.
The result should be parsed from JSON to a JavaScript object.</source>
          <target state="translated">私はREST呼び出しの結果を使用しています。結果をJSONからJavaScriptオブジェクトにパースする必要があります。</target>
        </trans-unit>
        <trans-unit id="44d30a96fae36c5b6279d6d45740204cbf4ff5a0" translate="yes" xml:space="preserve">
          <source>I believe there are a number of incorrect answers to this topic. Contrary to common belief, &quot;undefined&quot; is &lt;strong&gt;not&lt;/strong&gt; a keyword in JavaScript and can in fact have a value assigned to it.</source>
          <target state="translated">このトピックには多くの不正解があると思います。 一般的な考えに反して、「未定義」はJavaScriptのキーワードでは&lt;strong&gt;なく&lt;/strong&gt; 、実際には値を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="b37013d283a8127b7370563a4c36a206388c33a2" translate="yes" xml:space="preserve">
          <source>I didn't see (hope I didn't miss it) anyone checking the object before the property. So, this is the shortest and most effective (though not necessarily the most clear):</source>
          <target state="translated">見逃していなければいいのですが)プロパティの前にオブジェクトをチェックしている人はいませんでした。なので、これが一番短くて効果的です(必ずしも一番わかりやすいとは限りませんが)。</target>
        </trans-unit>
        <trans-unit id="4358f6b4064ade07b2efbf8a21e0f4135f510c95" translate="yes" xml:space="preserve">
          <source>I found lodash updated its implementation. See &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;my issue&lt;/a&gt; and &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;the code&lt;/a&gt;.</source>
          <target state="translated">lodashがその実装を更新したことがわかりました。 &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;私の問題&lt;/a&gt;と&lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;コードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3a132ebdcb8942d7a076277423ad437744ce7794" translate="yes" xml:space="preserve">
          <source>I provide three ways here for those who expect weird answers:</source>
          <target state="translated">変な答えを期待している人のために、私はここで3つの方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="48e26ba605da52f2cf32ca734ac26d9e06215803" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;if (this.variable)&lt;/code&gt; to test if it is defined. Simple &lt;code&gt;if (variable)&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;recommended above&lt;/a&gt;, fails for me. It turns out that it works only when variable is a field of some object, &lt;code&gt;obj.someField&lt;/code&gt; to check if it is defined in the dictionary. But we can use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; as the dictionary object since any variable is a field in current window, as I understand it. Therefore here is a test</source>
          <target state="translated">&lt;code&gt;if (this.variable)&lt;/code&gt; を使用して、定義されているかどうかをテストします。 &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;上&lt;/a&gt;で推奨されている &lt;code&gt;if (variable)&lt;/code&gt; 単純に失敗します。 これは、variableがオブジェクトのフィールドである &lt;code&gt;obj.someField&lt;/code&gt; の場合にのみ機能し、辞書で定義されているかどうかを確認します。 しかし、私が理解しているように、どの変数も現在のウィンドウのフィールドであるため、 &lt;code&gt;this&lt;/code&gt; または &lt;code&gt;window&lt;/code&gt; を辞書オブジェクトとして使用できます。 したがって、ここにテストがあります</target>
        </trans-unit>
        <trans-unit id="9e125ebcc0697240332e778b82ebf4d7f9c17043" translate="yes" xml:space="preserve">
          <source>I would like to show you something I'm using in order to protect the &lt;code&gt;undefined&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 変数を保護するために使用しているものをお見せしたいと思います。</target>
        </trans-unit>
        <trans-unit id="d5a6d2b02368855c6fda929fd61af0ea56454c18" translate="yes" xml:space="preserve">
          <source>I'd argue that in some cases it makes more sense (and is clearer) to check whether the property is there, than checking whether it is undefined, and the only case where this check will be different is case 2, the rare case of an actual entry in the object with an undefined value.</source>
          <target state="translated">私は、いくつかのケースでは、未定義かどうかをチェックするよりも、プロパティがあるかどうかをチェックした方が理にかなっている(明確になっている)と主張したいと思います。</target>
        </trans-unit>
        <trans-unit id="7a7486fe538e6ce861baa007fbb0f526deff33d5" translate="yes" xml:space="preserve">
          <source>I'm not sure where the origin of using &lt;code&gt;===&lt;/code&gt; with &lt;code&gt;typeof&lt;/code&gt; came from, and as a convention I see it used in many libraries, but the typeof operator returns a string literal, and we know that up front, so why would you also want to type check it too?</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; で &lt;code&gt;===&lt;/code&gt; を使用する起源がどこから来たのかはわかりません。慣例として、多くのライブラリで使用されていると思いますが、typeof演算子は文字列リテラルを返します。タイプチェックもしたいですか？</target>
        </trans-unit>
        <trans-unit id="6ef1c4a3ea0bc81cc7398a1d04f0515bcbd0fb86" translate="yes" xml:space="preserve">
          <source>If an object variable which have some properties you can use same thing like this:</source>
          <target state="translated">プロパティを持つオブジェクト変数であれば、以下のように使用することができます。</target>
        </trans-unit>
        <trans-unit id="84c7f1a126730161309b91866d156c12a47d03cd" translate="yes" xml:space="preserve">
          <source>If the obj or obj.prop is undefined, null, or &quot;falsy&quot;, the if statement will not execute the code block. This is &lt;em&gt;usually&lt;/em&gt; the desired behavior in most code block statements (in JavaScript).</source>
          <target state="translated">objまたはobj.propが未定義、null、または「偽」である場合、ifステートメントはコードブロックを実行しません。 これは&lt;em&gt;通常&lt;/em&gt; 、（JavaScriptの）ほとんどのコードブロックステートメントで望ましい動作です。</target>
        </trans-unit>
        <trans-unit id="0d8a3869bd9a3727544999c872ed66c32e2161a3" translate="yes" xml:space="preserve">
          <source>If the value of an object was never defined, this will prevent from returning &lt;code&gt;true&lt;/code&gt; if it is defined as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. This is helpful if you want true to be returned for values set as &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">オブジェクトの値が定義されていなかった場合、これが &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; として定義されている場合に &lt;code&gt;true&lt;/code&gt; を返さなくなります 。 これは、 &lt;code&gt;undefined&lt;/code&gt; として設定された値に対してtrueが返されるようにする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="e37e4c8d75647a160e70f184781ee5d3320919a7" translate="yes" xml:space="preserve">
          <source>If you are using Angular:</source>
          <target state="translated">Angularを使っている場合。</target>
        </trans-unit>
        <trans-unit id="38b2ee0e2820da1917baa311fe8dc70a8ba6eb39" translate="yes" xml:space="preserve">
          <source>If you are using jQuery Library then &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; will suffice for both cases,</source>
          <target state="translated">jQuery Libraryを使用している場合は、どちらの場合も &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; で十分です。</target>
        </trans-unit>
        <trans-unit id="4a3f6705c1b3da9943592b3d90136b8c5856782d" translate="yes" xml:space="preserve">
          <source>If you check a property on an object and the object doesn't exist, will throw an error and stop the whole application running.</source>
          <target state="translated">オブジェクトのプロパティをチェックして、そのオブジェクトが存在しない場合は、エラーをスローしてアプリケーション全体の実行を停止します。</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">もし、あなたが</target>
        </trans-unit>
        <trans-unit id="efde9566bc6269c016eb40d2c931ee65be1256d5" translate="yes" xml:space="preserve">
          <source>If you want it to result as &lt;code&gt;true&lt;/code&gt; for values defined with the value of &lt;code&gt;undefined&lt;/code&gt;, or never defined, you can simply use &lt;code&gt;=== undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; の値で定義された値に対して &lt;code&gt;true&lt;/code&gt; にしたい場合、または定義されていない場合は、単に &lt;code&gt;=== undefined&lt;/code&gt; 使用できます</target>
        </trans-unit>
        <trans-unit id="c710b9144a4a4de7a8033df9d90b0d520b9d93cc" translate="yes" xml:space="preserve">
          <source>In JavaScript there is &lt;strong&gt;null&lt;/strong&gt; and there is &lt;strong&gt;undefined&lt;/strong&gt;.  They have different meanings.</source>
          <target state="translated">JavaScriptには&lt;strong&gt;null&lt;/strong&gt;と&lt;strong&gt;undefinedがあり&lt;/strong&gt;ます。 彼らは異なる意味を持っています。</target>
        </trans-unit>
        <trans-unit id="676832a5b39fcd247b5da8131c2bb20e3f4e6479" translate="yes" xml:space="preserve">
          <source>In js, optional parameter works when the input value is exactly &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">jsでは、オプションのパラメーターは、入力値が正確に &lt;code&gt;undefined&lt;/code&gt; の場合に機能します。</target>
        </trans-unit>
        <trans-unit id="47b70d6bd5d7420590fbe686fa1aa65f6aff345c" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Exploring the Abyss of Null and Undefined in JavaScript &lt;/a&gt;&lt;/em&gt; I read that frameworks like &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; use this function:</source>
          <target state="translated">記事「 &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;JavaScriptでNullと未定義の深淵を探索する」&lt;/a&gt;&lt;/em&gt;では、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.jsの&lt;/a&gt;ようなフレームワークがこの関数を使用することを読みました。</target>
        </trans-unit>
        <trans-unit id="d6f3fa461bad66e062e473e85ddb6843faa72ad8" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;o.a&lt;/code&gt; undefined? Yes! Its value is undefined. Is &lt;code&gt;o.b&lt;/code&gt; undefined? Sure! There is no property 'b' at all! OK, see now how different approaches behave in both situations:</source>
          <target state="translated">&lt;code&gt;o.a&lt;/code&gt; 未定義ですか？ はい！ その値は未定義です。 &lt;code&gt;o.b&lt;/code&gt; 未定義ですか？ 承知しました！ プロパティ 'b'はありません！ では、両方の状況で異なるアプローチがどのように動作するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5fd8487b64efdd4bc0f74bc89dcb48fb3b637b18" translate="yes" xml:space="preserve">
          <source>It creates a LOCAL variable named &lt;code&gt;undefined&lt;/code&gt; which is initialized with the default value -- the real &lt;code&gt;undefined&lt;/code&gt;, then compares &lt;code&gt;value&lt;/code&gt; with the variable &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;undefined&lt;/code&gt; という名前のLOCAL変数を作成します。この変数は、デフォルト値（実際の &lt;code&gt;undefined&lt;/code&gt; )で初期化され、 &lt;code&gt;value&lt;/code&gt; を変数 &lt;code&gt;undefined&lt;/code&gt; と比較します 。</target>
        </trans-unit>
        <trans-unit id="cc7e62a0477f84c6e213a2a66a6810ed10b81109" translate="yes" xml:space="preserve">
          <source>It first detects that variable &lt;code&gt;abc&lt;/code&gt; is undefined and it is defined after initialization.</source>
          <target state="translated">まず、変数 &lt;code&gt;abc&lt;/code&gt; が未定義であり、初期化後に定義されていることを検出します。</target>
        </trans-unit>
        <trans-unit id="0a0f662835940c2e3dcfdd198a56eabd87b6dab3" translate="yes" xml:space="preserve">
          <source>It is always better to use the instance/object of the variable to check if it got a valid value. It is more stable and is a better way of programming.</source>
          <target state="translated">変数が有効な値を持っているかどうかをチェックするには、常にその変数のインスタンスオブジェクトを使用する方が良いでしょう。その方が安定していて、より良いプログラミング方法です。</target>
        </trans-unit>
        <trans-unit id="4d8fd1abf77f99fdff5448384c2ed4fee6e5c474" translate="yes" xml:space="preserve">
          <source>It is really universal! It works in new and old browsers.</source>
          <target state="translated">それは本当に普遍的です!それは新しいブラウザでも古いブラウザでも動作します。新しいブラウザでも古いブラウザでも動作します。</target>
        </trans-unit>
        <trans-unit id="a3b4d7eb65e80473b0d023a35685a8a9cba1977e" translate="yes" xml:space="preserve">
          <source>It's a bit shorter and looks a bit prettier</source>
          <target state="translated">少し短めで可愛く見えます</target>
        </trans-unit>
        <trans-unit id="1f9e9fe4a20d8dcfcf0cd7dd398ac00aaebacdc0" translate="yes" xml:space="preserve">
          <source>It's not as verbose as &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt; ほど冗長ではありません。</target>
        </trans-unit>
        <trans-unit id="bda34532c7ceeef815dfdb84a302308f13b1698b" translate="yes" xml:space="preserve">
          <source>It's suitable if you have a function, which receives an additional config property:</source>
          <target state="translated">これは、追加のconfigプロパティを受け取る関数を持っている場合に適しています。</target>
        </trans-unit>
        <trans-unit id="90a5de8bf9ed40e458f73d3c2fa132d1f4efa842" translate="yes" xml:space="preserve">
          <source>Its worth noting that these tests are the same for &lt;code&gt;null&lt;/code&gt; entries too</source>
          <target state="translated">これらのテストは &lt;code&gt;null&lt;/code&gt; エントリでも同じであることは注目に値します</target>
        </trans-unit>
        <trans-unit id="cca12d9c31c7dc579429ae296a479d2f796bada7" translate="yes" xml:space="preserve">
          <source>JavaScript has &lt;code&gt;typeof&lt;/code&gt; which make it very easy to detect an undefined variable.</source>
          <target state="translated">JavaScriptには、未定義の変数を非常に簡単に検出できる &lt;code&gt;typeof&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="a82d750a33e643b1a8a39e0ebb43d3b5768eaffc" translate="yes" xml:space="preserve">
          <source>Marijn Haverbeke states, in his free, online book &quot;&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt;&quot; (emphasis mine):</source>
          <target state="translated">Marijn Haverbekeは、彼の無料のオンラインブック「 &lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt; 」（私の強調）で次のように述べています 。</target>
        </trans-unit>
        <trans-unit id="5f9f4ff7cb7c3bd40b09bbc0a21ff4e94114ed3a" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;obj.prop === undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0671b57c33e2e288915d086d37cc882d4a48e654" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6bea7aa73158aa827a9c1bea87ededed070dc457" translate="yes" xml:space="preserve">
          <source>Most likely you want &lt;code&gt;if (window.x)&lt;/code&gt;. This check is safe even if x hasn't been declared (&lt;code&gt;var x;&lt;/code&gt;) - browser doesn't throw an error.</source>
          <target state="translated">おそらく &lt;code&gt;if (window.x)&lt;/code&gt; が必要です。 このチェックは、xが宣言されていなくても安全 &lt;code&gt;var x;&lt;/code&gt; （ var x; ）-ブラウザはエラーをスローしません。</target>
        </trans-unit>
        <trans-unit id="9b4b5105b3b3a13be5c61e3fa3df47a1366e4075" translate="yes" xml:space="preserve">
          <source>Never Defined</source>
          <target state="translated">決して定義されていない</target>
        </trans-unit>
        <trans-unit id="9484abb038e36cb0cd8cbbc623288ca1c4c7dc51" translate="yes" xml:space="preserve">
          <source>Node.js supports the global variable &lt;code&gt;undefined&lt;/code&gt; as &lt;code&gt;global.undefined&lt;/code&gt; (it can also be used without the 'global' prefix). I don't know about other implementations of server-side JavaScript.</source>
          <target state="translated">Node.jsは、グローバル変数 &lt;code&gt;undefined&lt;/code&gt; を &lt;code&gt;global.undefined&lt;/code&gt; としてサポートします（「グローバル」接頭辞なしでも使用できます）。 サーバーサイドJavaScriptの他の実装については知りません。</target>
        </trans-unit>
        <trans-unit id="25e7237d29d65a8052d28a50ad68997f82c2cf73" translate="yes" xml:space="preserve">
          <source>Note: The strict equality operator rather than the standard equality
  operator must be used here, because x == undefined also checks whether
  x is null, while strict equality doesn't. null is not equivalent to
  undefined. See comparison operators for details.</source>
          <target state="translated">注意:ここでは、標準の等号演算子ではなく、厳密な等号演算子を使用しなければなりません。詳細は比較演算子を参照してください。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="59c5fb8a80a77710fbcb25bc27178f51a4e9b105" translate="yes" xml:space="preserve">
          <source>Now executing</source>
          <target state="translated">現在実行中</target>
        </trans-unit>
        <trans-unit id="b2491f157aee8344e47a52d1010d094626fad59f" translate="yes" xml:space="preserve">
          <source>One reason to use typeof is that it does not throw an error if the
  variable has not been declared.</source>
          <target state="translated">typeofを使用する理由の一つは、変数が宣言されていない場合にエラーが発生しないからです。</target>
        </trans-unit>
        <trans-unit id="aeca9079848cd62aa72e0c9da1ae45fee2f68f0f" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;obj.prop === undefined&lt;/code&gt; プラス：</target>
        </trans-unit>
        <trans-unit id="c47d4b2cec06b65e3df4b5dc37d83b7c1779a8b3" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; プラス：</target>
        </trans-unit>
        <trans-unit id="ab5bb084b0953bb529d05917ef5d0f8f02b4e552" translate="yes" xml:space="preserve">
          <source>Reading through this, I'm amazed I didn't see this. I have found multiple algorithms that would work for this.</source>
          <target state="translated">これを読んで、これに気づかなかったことに驚いています。これに効きそうなアルゴリズムを複数見つけました。</target>
        </trans-unit>
        <trans-unit id="bb5a0c2d5893ca1120918abd2e27fe466333b1bf" translate="yes" xml:space="preserve">
          <source>Returns false if variable is set, and true if is undefined.</source>
          <target state="translated">変数が設定されている場合は false、未定義の場合は true を返します。</target>
        </trans-unit>
        <trans-unit id="883a8c4f5ebd87c4fde0e73e9656f30546585657" translate="yes" xml:space="preserve">
          <source>Simply anything is not defined in JavaScript, is &lt;strong&gt;undefined&lt;/strong&gt;, doesn't matter if it's a property inside an &lt;strong&gt;Object/Array&lt;/strong&gt; or as just a simple variable...</source>
          <target state="translated">単に何かがJavaScriptで定義されていない、 &lt;strong&gt;未定義である&lt;/strong&gt; 、それが&lt;strong&gt;オブジェクト/配列&lt;/strong&gt;内のプロパティであるか、単純な変数であるかは関係ありません...</target>
        </trans-unit>
        <trans-unit id="aedd3fc984632b50a483c5fe2c50d6f41d6d1779" translate="yes" xml:space="preserve">
          <source>Simply check if &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; and it will return a boolean.</source>
          <target state="translated">&lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; かどうかを確認するだけでブール値が返されます。</target>
        </trans-unit>
        <trans-unit id="f828f39971d418b0bc13a1d98409cc5e98730d01" translate="yes" xml:space="preserve">
          <source>So as you see the function receive a value, if that value is defined, it will return &lt;code&gt;false&lt;/code&gt;, otherwise for undefined values, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">したがって、関数が値を受け取るのを見ると、その値が定義されている場合は &lt;code&gt;false&lt;/code&gt; が返され、それ以外の場合は未定義の値に対して &lt;code&gt;true&lt;/code&gt; が返されます 。</target>
        </trans-unit>
        <trans-unit id="418ae1e2e0311d3d2c105a70491013660c6a928b" translate="yes" xml:space="preserve">
          <source>So let's have a look what gonna be the results when we passing values, including object properties like below, this is the list of variables we have:</source>
          <target state="translated">では、以下のようなオブジェクトのプロパティを含めて、値を渡したときにどのような結果になるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="26532241df6bb6d2e9b7919c8174d92f3c3e9956" translate="yes" xml:space="preserve">
          <source>So simple you can wrap inside an if statement like below:</source>
          <target state="translated">簡単に言えば、以下のようにif文の中にラップを入れることができます。</target>
        </trans-unit>
        <trans-unit id="c03f8753c6b8939bcb611d65d70cd9f2e93a2bf4" translate="yes" xml:space="preserve">
          <source>So unless you&amp;rsquo;re doing feature detection&amp;sup2;, where there&amp;rsquo;s uncertainty whether a given name will be in scope (like checking &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; as a step in code specific to a CommonJS environment), &lt;code&gt;typeof&lt;/code&gt; is a harmful choice when used on a variable, and the correct option is to compare the value directly:</source>
          <target state="translated">したがって、特定の名前がスコープ内にあるかどうかが不明な機能検出 &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; （CommonJS環境に固有のコードのステップとしてtypeof module！== 'undefined'をチェックする場合など）を行わない限り、 &lt;code&gt;typeof&lt;/code&gt; は有害な選択です変数で、正しいオプションは値を直接比較することです：</target>
        </trans-unit>
        <trans-unit id="9e1c8c9a0796fba24c5ae142d24dc8713fd92971" translate="yes" xml:space="preserve">
          <source>So what to do?</source>
          <target state="translated">で、どうすればいいの?</target>
        </trans-unit>
        <trans-unit id="c4de3d5c3b3ce53f18295c6866165a0b386a0cc6" translate="yes" xml:space="preserve">
          <source>So, I guess the best way to check if something was undefined would be:</source>
          <target state="translated">だから、何かが未定義だったかどうかを確認するのに最適な方法は</target>
        </trans-unit>
        <trans-unit id="62861616fb8499b1333e632d8f4f8c9d96d9ca16" translate="yes" xml:space="preserve">
          <source>So, for anyone who pass by, I will give you undefineds for free!!</source>
          <target state="translated">ということで、通りかかった人には、未定義を無料でプレゼントします!</target>
        </trans-unit>
        <trans-unit id="93c6077f6664588e7ec5fe7e874c0816d5e39229" translate="yes" xml:space="preserve">
          <source>Some common misconceptions about this include:</source>
          <target state="translated">よくある誤解には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="141f21882b084552acee073fca83c3cc0c42e7c8" translate="yes" xml:space="preserve">
          <source>Some scenarios illustrating the results of the various answers:
&lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</source>
          <target state="translated">さまざまな回答の結果を示すいくつかのシナリオ： &lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/drzaus/UVjM4/</target>
        </trans-unit>
        <trans-unit id="e5e2bb80f10dad7f8c5f9960cd6007b457637109" translate="yes" xml:space="preserve">
          <source>Something else to consider when it comes to object properties is whether you really want to check for &lt;code&gt;undefined&lt;/code&gt; at all. A given property name can be absent on an object (producing the value &lt;code&gt;undefined&lt;/code&gt; when read), present on the object itself with the value &lt;code&gt;undefined&lt;/code&gt;, present on the object&amp;rsquo;s prototype with the value &lt;code&gt;undefined&lt;/code&gt;, or present on either of those with a non-&lt;code&gt;undefined&lt;/code&gt; value. &lt;code&gt;'key' in obj&lt;/code&gt; will tell you whether a key is anywhere on an object&amp;rsquo;s prototype chain, and &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; will tell you whether it&amp;rsquo;s directly on the object. I won&amp;rsquo;t go into detail in this answer about prototypes and using objects as string-keyed maps, though, because it&amp;rsquo;s mostly intended to counter all the bad advice in other answers irrespective of the possible interpretations of the original question. Read up on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;object prototypes on MDN&lt;/a&gt; for more!</source>
          <target state="translated">オブジェクトのプロパティに関して他に考慮すべきことは、本当に &lt;code&gt;undefined&lt;/code&gt; をチェックするかどうかです。 特定のプロパティ名は、オブジェクトに存在しない（読み取り時に値 &lt;code&gt;undefined&lt;/code&gt; を生成する）、値がundefinedのオブジェクト自体に存在する、値が &lt;code&gt;undefined&lt;/code&gt; のオブジェクトのプロトタイプに存在する、または &lt;code&gt;undefined&lt;/code&gt; 以外のオブジェクトのいずれかに存在する値。 &lt;code&gt;'key' in obj&lt;/code&gt; 、キーがオブジェクトのプロトタイプチェーンのどこかにあるかどうかを通知し、 &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; は、それがオブジェクトに直接存在するかどうかを通知します。 ただし、プロトタイプと文字列キーマップとしてのオブジェクトの使用については、この回答では詳しく説明しません。これは、元の質問の考えられる解釈に関係なく、他の回答のすべての悪いアドバイスに対抗することを主な目的としているためです。 詳細&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;については、MDNのオブジェクトプロトタイプ&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="09414607443b3c66a48d7b3cc8690784e89229ef" translate="yes" xml:space="preserve">
          <source>That's how the famous function &lt;code&gt;isUndefined()&lt;/code&gt; in AngularJs v.1x is written:</source>
          <target state="translated">これが、AngularJs v.1xの有名な関数 &lt;code&gt;isUndefined()&lt;/code&gt; の記述方法です。</target>
        </trans-unit>
        <trans-unit id="1d798e4166272be66a0741b99698bc5ab930a831" translate="yes" xml:space="preserve">
          <source>The JavaScript engine will give you an error if you have misspelled &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; スペルを間違えた場合、JavaScriptエンジンはエラーを表示します</target>
        </trans-unit>
        <trans-unit id="656b5d05c99fef961580b61f3edcaf330a6d66b8" translate="yes" xml:space="preserve">
          <source>The global variable &lt;em&gt;myvar&lt;/em&gt; is the same as &lt;em&gt;window.myvar&lt;/em&gt; or &lt;em&gt;window['myvar']&lt;/em&gt;</source>
          <target state="translated">グローバル変数&lt;em&gt;myvar&lt;/em&gt;は&lt;em&gt;window.myvar&lt;/em&gt;または&lt;em&gt;window ['myvar']&lt;/em&gt;と同じ&lt;em&gt;です&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29914467b1012003b3afd9aaffdcc32d8b458da1" translate="yes" xml:space="preserve">
          <source>The issue boils down to three cases:</source>
          <target state="translated">問題は3つのケースに集約されます。</target>
        </trans-unit>
        <trans-unit id="8f19ead080cc475b112d23d1a87b473d84ebf23e" translate="yes" xml:space="preserve">
          <source>The most robust way to perform this test is:</source>
          <target state="translated">このテストを行うための最も堅牢な方法は</target>
        </trans-unit>
        <trans-unit id="195e6d98a22addf60a5f15d53507e42b6d225705" translate="yes" xml:space="preserve">
          <source>The object does not have the property.</source>
          <target state="translated">オブジェクトはプロパティを持っていません。</target>
        </trans-unit>
        <trans-unit id="af4e3304635702004a3bc294a84b85b272ed0251" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">オブジェクトにはプロパティがあり、その値は &lt;code&gt;undefined&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0000fbbbec8c44ca2bc7134d63869dbf22df5843" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is not &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">オブジェクトにはプロパティがあり、その値は &lt;code&gt;undefined&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="f12e6a8e8479790bcfba92ce8e2bdb1c0b5a2c71" translate="yes" xml:space="preserve">
          <source>The question if a variable really exists doesn't matter, its value is incorrect. Otherwise, it is silly to initialize variables with undefined, and it is better use the value false to initialize. When you know that all variables that you declare are initialized with false, you can simply check its type or rely on &lt;code&gt;!window.myvar&lt;/code&gt; to check if it has a proper/valid value. So even when the variable is not defined then &lt;code&gt;!window.myvar&lt;/code&gt; is the same for &lt;code&gt;myvar = undefined&lt;/code&gt; or &lt;code&gt;myvar = false&lt;/code&gt; or &lt;code&gt;myvar = 0&lt;/code&gt;.</source>
          <target state="translated">変数が実際に存在するかどうかは問題ではなく、その値は正しくありません。 それ以外の場合、変数をundefinedで初期化するのはばかげています。値falseを使用して初期化することをお勧めします。 宣言するすべての変数がfalseで初期化されていることがわかっている場合は、その型を確認するか、 &lt;code&gt;!window.myvar&lt;/code&gt; を使用して、適切な値または有効な値があるかどうかを確認できます。 したがって、変数が定義されていない場合でも、 &lt;code&gt;!window.myvar&lt;/code&gt; は &lt;code&gt;myvar = undefined&lt;/code&gt; または &lt;code&gt;myvar = false&lt;/code&gt; または &lt;code&gt;myvar = 0&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="f6c187da4b16a273b05320f38b78197032e5f666" translate="yes" xml:space="preserve">
          <source>The solution is incorrect. In JavaScript,</source>
          <target state="translated">解答は正しくありません。JavaScriptで。</target>
        </trans-unit>
        <trans-unit id="99c5e812eeb793c06c61ae79d6ce567d31253c67" translate="yes" xml:space="preserve">
          <source>The void operator is a third alternative.</source>
          <target state="translated">void演算子は第三の選択肢です。</target>
        </trans-unit>
        <trans-unit id="2624b916bf01c722be8fb21993d9edd3842b5f8d" translate="yes" xml:space="preserve">
          <source>Then use:</source>
          <target state="translated">ならば使ってください。</target>
        </trans-unit>
        <trans-unit id="c306c1e05cc386f4fb986ead9800e3cb51d7d7ac" translate="yes" xml:space="preserve">
          <source>There is a nice &amp;amp; elegant way to assign a defined property to a new variable if it is defined or assign a default value to it as a fallback if it&amp;acute;s undefined.</source>
          <target state="translated">定義済みのプロパティが定義されている場合は、新しい変数に割り当てたり、未定義の場合はフォールバックとしてデフォルト値を割り当てたりするための便利な方法があります。</target>
        </trans-unit>
        <trans-unit id="909331b017c727d6b638a10340bcfa91fc4e0156" translate="yes" xml:space="preserve">
          <source>There is also a similar value, null, whose meaning is 'this value is defined, but it does not have a value'. The difference in meaning between undefined and null is mostly academic, and usually not very interesting. &lt;strong&gt;In practical programs, it is often necessary to check whether something 'has a value'. In these cases, the expression something == undefined may be used, because, even though they are not exactly the same value, null == undefined will produce true.&lt;/strong&gt;</source>
          <target state="translated">同様の値nullもあり、その意味は「この値は定義されていますが、値がありません」です。 undefinedとnullの意味の違いは、ほとんどが学術的なものであり、通常はそれほど興味深いものではありません。 &lt;strong&gt;実際のプログラムでは、何かが「値を持っている」かどうかを確認する必要があることがよくあります。&lt;/strong&gt; &lt;strong&gt;これらのケースでは、something == undefinedという式を使用できます。これは、それらがまったく同じ値でなくても、null == undefinedがtrueを生成するためです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="066374c5c4c92cd26ce46b50a318fdbc81da8197" translate="yes" xml:space="preserve">
          <source>There is one error I need to defend.
If the args to the rest call were incorrect as far as the user specifying the args wrong, the rest call comes back basically empty.</source>
          <target state="translated">1つだけ反省すべき点があります。ユーザが間違った引数を指定してしまった場合、レストコールは基本的に空になってしまいます。</target>
        </trans-unit>
        <trans-unit id="4a1c97843ddae12e312165772ba1724256c18040" translate="yes" xml:space="preserve">
          <source>This forbids anyone to change the &lt;code&gt;window.undefined&lt;/code&gt; value therefore destroying the code based on that variable. If using &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;, anything trying to change its value will end in error, otherwise it would be silently ignored.</source>
          <target state="translated">これにより、誰もが &lt;code&gt;window.undefined&lt;/code&gt; 値を変更できなくなり、その変数に基づくコードが破棄されます。 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 場合、その値を変更しようとするとエラーが発生して終了します。それ以外の場合は、黙って無視されます。</target>
        </trans-unit>
        <trans-unit id="206b6848288b0371c75a01e649b5ef1c02732df1" translate="yes" xml:space="preserve">
          <source>This tells us something I consider important:</source>
          <target state="translated">これは、私が重要だと考えていることを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="882cd19a028fc5fdf4ac576781232fd9fb438143" translate="yes" xml:space="preserve">
          <source>This will always return the correct result, and even handles the situation where &lt;code&gt;myVar&lt;/code&gt; is not declared.</source>
          <target state="translated">これにより常に正しい結果が返され、 &lt;code&gt;myVar&lt;/code&gt; が宣言されていない状況でも処理されます。</target>
        </trans-unit>
        <trans-unit id="65d3b63892021dfc610049dfe83bb84e542216eb" translate="yes" xml:space="preserve">
          <source>This worked for me while the others didn't.</source>
          <target state="translated">他の人はそうでないのに、私には効果がありました。</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="1156bb5b9c53b338e90526a8c3e0f9157c2cdd5d" translate="yes" xml:space="preserve">
          <source>To avoid errors to test when a global variable exists, you better use:</source>
          <target state="translated">グローバル変数が存在するかどうかをテストするためのエラーを避けるためには、より良い方法を使用してください。</target>
        </trans-unit>
        <trans-unit id="af5a50ed0ca791f35da42bf271615ae60f9119f4" translate="yes" xml:space="preserve">
          <source>To be bullet-proof, simply use:</source>
          <target state="translated">防弾のためには、単純に使用してください。</target>
        </trans-unit>
        <trans-unit id="a3733768c50f085f705798790041179dcb01dd51" translate="yes" xml:space="preserve">
          <source>Too bad that this been the right answer is buried in wrong answers &amp;gt;_&amp;lt;</source>
          <target state="translated">これが正しい答えであることは残念ですが、間違った答えに埋もれています&amp;gt; _ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2a836e46c13894957834965487f79f243bd458f6" translate="yes" xml:space="preserve">
          <source>Try to get a property of the input value, check the error message if it exists. If the input value is undefined, the error message would be &lt;em&gt;Uncaught TypeError: Cannot read property 'b' of undefined&lt;/em&gt;</source>
          <target state="translated">入力値のプロパティを取得してみてください。存在する場合はエラーメッセージを確認してください。 入力値が未定義の場合、エラーメッセージは&lt;em&gt;Uncaught TypeError：Undefinedプロパティ 'b'を読み取れません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31c8242d038a57a98e29aa92351bb4eeba57a99f" translate="yes" xml:space="preserve">
          <source>Underscore.js:</source>
          <target state="translated">Underscore.js:</target>
        </trans-unit>
        <trans-unit id="624f88833e4aa36d20755eda53fb498e36cc6d82" translate="yes" xml:space="preserve">
          <source>Update (for server-side JavaScript):</source>
          <target state="translated">更新(サーバーサイドJavaScript用)。</target>
        </trans-unit>
        <trans-unit id="0a8d800169d3f3a27add31e922bf0bca161dd01d" translate="yes" xml:space="preserve">
          <source>Update 9/9/2019</source>
          <target state="translated">992019を更新しました。</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="ca3566d6d324a104499679565f550124050f47c6" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;undefined&lt;/code&gt; is a global variable (so actually it is &lt;code&gt;window.undefined&lt;/code&gt; in browsers). It has been supported since ECMAScript 1st Edition and since ECMAScript 5 it is &lt;strong&gt;read only&lt;/strong&gt;. So in modern browsers it can't be &lt;em&gt;redefined to true&lt;/em&gt; as many authors love to frighten us with, but this is still a true for older browsers.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 変数はグローバル変数です（ &lt;code&gt;window.undefined&lt;/code&gt; 、実際にはブラウザーではwindow.undefinedです）。 ECMAScript 1st Edition以降、ECMAScript 5以降は&lt;strong&gt;読み取り専用で&lt;/strong&gt;サポートされています。 したがって、最近のブラウザーでは、多くの作成者が私たちを怖がらせたいので&lt;em&gt;、true&lt;/em&gt;に&lt;em&gt;再定義する&lt;/em&gt;ことはできませんが、これは古いブラウザーにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="aa644c9b6d28b03bec73d65a8433d912ec0dc967" translate="yes" xml:space="preserve">
          <source>We can clearly see that &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; and &lt;code&gt;obj.prop === undefined&lt;/code&gt; are equivalent, and they do not distinguish those different situations. And &lt;code&gt;'prop' in obj&lt;/code&gt; can detect the situation when a property hasn't been defined at all and doesn't pay attention to the property value which may be undefined.</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; と &lt;code&gt;obj.prop === undefined&lt;/code&gt; は同等であり、これらの異なる状況を区別しないことがはっきりとわかります。 また &lt;code&gt;'prop' in obj&lt;/code&gt; 、プロパティがまったく定義されていない場合や、定義されていない可能性があるプロパティ値に注意を払わない場合の状況を検出できます。</target>
        </trans-unit>
        <trans-unit id="b4348ecc1522f37bea2a74798eccb1c698101bae" translate="yes" xml:space="preserve">
          <source>What I am saying is that for my situation, all the suggestions above in this post did not work.  I'm not saying I'm right and everyone is wrong.  I am not a JavaScript master at all, but hopefully this will help someone.</source>
          <target state="translated">私が言っているのは、私の状況では、このポストの上のすべての提案はうまくいかなかったということです。私が正しいと言っているのではなく、誰もが間違っていると言っているわけではありません。私はJavaScriptの達人ではありませんが、これが誰かの助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="6c6a10825c9a1a5ecbcd512402eb30eb39482e71" translate="yes" xml:space="preserve">
          <source>What does this mean: &lt;strong&gt;&quot;undefined object property&quot;&lt;/strong&gt;?</source>
          <target state="translated">これはどういう意味ですか： &lt;strong&gt;「未定義のオブジェクトプロパティ」&lt;/strong&gt; ？</target>
        </trans-unit>
        <trans-unit id="86d7d00a77d485aef47636c622133ba6e079f28d" translate="yes" xml:space="preserve">
          <source>What's the best way of checking if an object property in JavaScript is &lt;code&gt;undefined&lt;/code&gt;?</source>
          <target state="translated">JavaScriptのオブジェクトプロパティが &lt;code&gt;undefined&lt;/code&gt; かどうかを確認する最良の方法は何ですか？</target>
        </trans-unit>
        <trans-unit id="6a44c70b62e1f951bfff4ad714a3bf6f9c36a141" translate="yes" xml:space="preserve">
          <source>When the first and simple condition is true, the interpreter skips the next tests.</source>
          <target state="translated">最初の単純な条件が真の場合、インタプリタは次のテストをスキップします。</target>
        </trans-unit>
        <trans-unit id="b7221864517c5c211586a94530d68cdcfc6ea425" translate="yes" xml:space="preserve">
          <source>When you expect a specific type, test the type of the variable. To speed up testing a condition you better do:</source>
          <target state="translated">特定の型を期待する場合は、変数の型をテストします。条件のテストを高速化するためには、以下のようにした方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="d60051b913c76582de7e88350c42134161b10c93" translate="yes" xml:space="preserve">
          <source>Which also equal to isDefined in Angular 1.x...</source>
          <target state="translated">これもAngular 1.xのisDefinedと同じです。</target>
        </trans-unit>
        <trans-unit id="88ec2543321a88029f849108c87daeb5587d1c2d" translate="yes" xml:space="preserve">
          <source>Which was clearer when written without a check for undefined.</source>
          <target state="translated">未定義のチェックがないと書かれていたのはどっちの方がわかりやすかったです。</target>
        </trans-unit>
        <trans-unit id="5b51b27fa3903d28d3f04b6c171ad09973278eb9" translate="yes" xml:space="preserve">
          <source>While using this post to help me defend against this, I tried this.</source>
          <target state="translated">この投稿を参考にしながら、私はこれを試してみました。</target>
        </trans-unit>
        <trans-unit id="e71f039272b0f0e068195d6015ac5f2784fca83b" translate="yes" xml:space="preserve">
          <source>With how variables work out of the way, it&amp;rsquo;s time to address the actual question: object properties. There is no reason to ever use &lt;code&gt;typeof&lt;/code&gt; for object properties. The earlier exception regarding feature detection doesn&amp;rsquo;t apply here &amp;ndash; &lt;code&gt;typeof&lt;/code&gt; only has special behaviour on variables, and expressions that reference object properties are not variables.</source>
          <target state="translated">変数がどのように機能するかについては、実際の問題であるオブジェクトプロパティに対処する時が来ました。 オブジェクトプロパティに &lt;code&gt;typeof&lt;/code&gt; を使用する理由はありません。 機能検出に関する以前の例外はここでは適用されません &lt;code&gt;typeof&lt;/code&gt; は変数に対して特別な動作を行うだけであり、オブジェクトプロパティを参照する式は変数ではありません。</target>
        </trans-unit>
        <trans-unit id="fdb6add32a76812e71fb836b3a0175d29a715c41" translate="yes" xml:space="preserve">
          <source>You can get an array all undefined with path using the following code.</source>
          <target state="translated">以下のコードを使用すると、すべての未定義の配列をパスで取得することができます。</target>
        </trans-unit>
        <trans-unit id="fd195a5d241f7801da7590d49a101b3417b1d020" translate="yes" xml:space="preserve">
          <source>You can use undefined and the strict equality and inequality operators to determine whether a variable has
  a value. In the following code, the variable x is not defined, and the
  if statement evaluates to true.</source>
          <target state="translated">変数が値を持つかどうかを判断するには、未定義演算子、厳密な等号演算子、不等号演算子を使用することができます。次のコードでは、変数 x は定義されておらず、if 文は真として評価されます。</target>
        </trans-unit>
        <trans-unit id="8bd945be1ad955926cb0576570ca86d427690000" translate="yes" xml:space="preserve">
          <source>You can't check an object and its property at the same time. For example, this &lt;code&gt;x.a === undefined&lt;/code&gt; or this &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; raises &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; if x is not defined.</source>
          <target state="translated">オブジェクトとそのプロパティを同時に確認することはできません。 たとえば、この &lt;code&gt;x.a === undefined&lt;/code&gt; またはthis &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; が発生します &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; 場合、xは定義されません。</target>
        </trans-unit>
        <trans-unit id="afb57f9c5e1cd65cb89577ac225085a571888c95" translate="yes" xml:space="preserve">
          <source>and taking into account the advice above, to avoid confusing readers as to why you&amp;rsquo;re using &lt;code&gt;typeof&lt;/code&gt;, because it makes the most sense to use &lt;code&gt;===&lt;/code&gt; to check for equality, because it could be refactored to checking a variable&amp;rsquo;s value later, and because it just plain looks better, &lt;strong&gt;you should always use &lt;code&gt;=== undefined&lt;/code&gt;&amp;sup3; here as well&lt;/strong&gt;.</source>
          <target state="translated">上記のアドバイスを考慮して、 &lt;code&gt;typeof&lt;/code&gt; を使用している理由について読者を混乱させないようにしてください。 &lt;code&gt;===&lt;/code&gt; を使用して等価性をチェックするのが最も理にかなっています。これは、後で変数の値をチェックするようにリファクタリングできるためです。単純に見た目が良いので、 &lt;strong&gt;ここでも常に &lt;code&gt;=== undefined&lt;/code&gt; alwaysを使用する必要があります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d105f7494e87ab388edea0f7b8c3a73720d04c6" translate="yes" xml:space="preserve">
          <source>and we check them as below, you can see the results in front of them as a comment:</source>
          <target state="translated">と下のようにチェックしていますが、その前にコメントとして結果を見ることができます。</target>
        </trans-unit>
        <trans-unit id="1a3490def710ea1d24edc82b74a46f9764b33bda" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;always exactly equivalent&lt;/em&gt; to this&amp;sup3;:</source>
          <target state="translated">これは&lt;em&gt;常にこれとまったく同じです&lt;/em&gt; &amp;sup3;：</target>
        </trans-unit>
        <trans-unit id="4778deb55d8cd5675a499ac484ad2ef5c74ec10c" translate="yes" xml:space="preserve">
          <source>isUndefined1:</source>
          <target state="translated">isUndefined1:</target>
        </trans-unit>
        <trans-unit id="15fa6dc48f1d00cd33b8f768892cc3b8131f1bbb" translate="yes" xml:space="preserve">
          <source>isUndefined2:</source>
          <target state="translated">isUndefined2:</target>
        </trans-unit>
        <trans-unit id="c871adbf9668a35abe539aa06d9c0dafaf3ce3ee" translate="yes" xml:space="preserve">
          <source>isUndefined3:</source>
          <target state="translated">isUndefined3:</target>
        </trans-unit>
        <trans-unit id="8ac534c595dd379491a89bb14380a533170408b9" translate="yes" xml:space="preserve">
          <source>it will fail when the variable &lt;code&gt;myvar&lt;/code&gt; does not exists, because myvar is not defined, so the script is broken and the test has no effect.</source>
          <target state="translated">myvarが定義されていないため、変数 &lt;code&gt;myvar&lt;/code&gt; が存在しない場合は失敗します。そのため、スクリプトは壊れ、テストは効果がありません。</target>
        </trans-unit>
        <trans-unit id="985aa8a699702f412ce09aab8fceeb541def9317" translate="yes" xml:space="preserve">
          <source>more &amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">もっと&amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;ここに&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b79ab4d893a4264fa8785737934a4d1503cc8e5" translate="yes" xml:space="preserve">
          <source>so you will use it like:</source>
          <target state="translated">のように使うことになります。</target>
        </trans-unit>
        <trans-unit id="157d0448c1dd7a8c6cfeab738ffaa2775caae49d" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;undefined&lt;/code&gt; can be overwritten. There&amp;rsquo;s a lot more to this. &lt;code&gt;undefined&lt;/code&gt; is not a keyword in JavaScript. Instead, it&amp;rsquo;s a property on the global object with the Undefined value. However, since ES5, this property has been &lt;em&gt;read-only&lt;/em&gt; and &lt;em&gt;non-configurable&lt;/em&gt;. No modern browser will allow the &lt;code&gt;undefined&lt;/code&gt; property to be changed, and as of 2017 this has been the case for a long time. Lack of strict mode doesn&amp;rsquo;t affect &lt;code&gt;undefined&lt;/code&gt;&amp;rsquo;s behaviour either &amp;ndash; it just makes statements like &lt;code&gt;undefined = 5&lt;/code&gt; do nothing instead of throwing. Since it isn&amp;rsquo;t a keyword, though, you can &lt;em&gt;declare&lt;/em&gt; variables with the name &lt;code&gt;undefined&lt;/code&gt;, and those variables could be changed, making this once-common pattern:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; は上書きできます。 これにはもっとたくさんあります。 &lt;code&gt;undefined&lt;/code&gt; はJavaScriptのキーワードではありません。 代わりに、未定義の値を持つグローバルオブジェクトのプロパティです。 ただし、ES5以降、このプロパティは&lt;em&gt;読み取り専用に&lt;/em&gt;なり、 &lt;em&gt;構成でき&lt;/em&gt; &lt;em&gt;なく&lt;/em&gt;なりました。 &lt;code&gt;undefined&lt;/code&gt; プロパティの変更を許可する最新のブラウザーはありません。2017年の時点で、これは長い間当てはまっていました。 strictモードがなくても、 &lt;code&gt;undefined&lt;/code&gt; の動作には影響しません。単に &lt;code&gt;undefined = 5&lt;/code&gt; ようなステートメントをスローするのではなく、何もしないようにします。 ただし、これはキーワードではないため、 &lt;code&gt;undefined&lt;/code&gt; という名前の変数を&lt;em&gt;宣言する&lt;/em&gt;ことができ、これらの変数を変更して、次のような一般的なパターンを作成できます。</target>
        </trans-unit>
        <trans-unit id="0793e2c88390a29b1957e9039867ab8ffb4111d4" translate="yes" xml:space="preserve">
          <source>that reading an &amp;ldquo;uninitialized&amp;rdquo; variable (&lt;code&gt;var foo&lt;/code&gt;) or parameter (&lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt;, called as &lt;code&gt;bar()&lt;/code&gt;) will fail. This is simply not true &amp;ndash; variables without explicit initialization and parameters that weren&amp;rsquo;t given values always become &lt;code&gt;undefined&lt;/code&gt;, and are always in scope.</source>
          <target state="translated">「初期化されていない」変数（ &lt;code&gt;var foo&lt;/code&gt; ）またはパラメーター（ &lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt; 、 &lt;code&gt;bar()&lt;/code&gt; と呼ばれる）の読み取りは失敗します。 これは単に真実ではありません。明示的な初期化のない変数と、値が指定されなかったパラメーターは常に &lt;code&gt;undefined&lt;/code&gt; になり、常にスコープ内にあります。</target>
        </trans-unit>
        <trans-unit id="36867f049a149d6504389c0dac25fc3f11212dfd" translate="yes" xml:space="preserve">
          <source>which is the identity operator...</source>
          <target state="translated">これは同一性演算子である...</target>
        </trans-unit>
        <trans-unit id="e0cafe396bcf72dbf7b9b4bc907e035155d2be4e" translate="yes" xml:space="preserve">
          <source>will return true, because they both are &quot;casted&quot; to a boolean and are false. The correct way would be to check</source>
          <target state="translated">は真を返しますが、これはどちらもbooleanに &quot;キャスト &quot;されていてfalseだからです。正しい方法は</target>
        </trans-unit>
        <trans-unit id="786ca9a6ff480fa14542ee13006ae5e448160486" translate="yes" xml:space="preserve">
          <source>you can also use Proxy, it will work with nested calls, but will require one extra check:</source>
          <target state="translated">Proxy を使うこともできますが、ネストされた呼び出しでも動作しますが、一つ余分なチェックが必要です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
