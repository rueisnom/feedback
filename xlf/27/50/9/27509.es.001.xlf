<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/27509">
    <body>
      <group id="27509">
        <trans-unit id="9b76c7ee3ed3b22fe6b40e7d1df6c18824b37a8f" translate="yes" xml:space="preserve">
          <source>'&lt;em&gt;if (window.x) { }&lt;/em&gt;' is error safe</source>
          <target state="translated">' &lt;em&gt;if (window.x) {}&lt;/em&gt; ' es a &lt;em&gt;prueba de&lt;/em&gt; errores</target>
        </trans-unit>
        <trans-unit id="7afec1ce47ff900682bd7a527552baf0b3f48e7e" translate="yes" xml:space="preserve">
          <source>(y)</source>
          <target state="translated">(y)</target>
        </trans-unit>
        <trans-unit id="1963f681a0dc2983468889df82f1affdbe4cb8ed" translate="yes" xml:space="preserve">
          <source>1) You want to know if a property is undefined by either the first or second meaning (the most typical situation).</source>
          <target state="translated">1)Quieres saber si una propiedad está indefinida por el primer o segundo significado (la situación más típica).</target>
        </trans-unit>
        <trans-unit id="2eff931c0d1f6eda47f88e36e5e2ca665e39f0b0" translate="yes" xml:space="preserve">
          <source>2) You want to just know if object has some property and don't care about its value.</source>
          <target state="translated">2)Sólo quieres saber si el objeto tiene alguna propiedad y no te importa su valor.</target>
        </trans-unit>
        <trans-unit id="d95915c48ebcaada4c615be17c20592ad7a87e7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">Enlace &lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3c686407b77ca61732d9533437b84cc6af2398a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'undefned'&lt;/code&gt; (&lt;em&gt;misspelled&lt;/em&gt;) here is just a string constant, so the JavaScript engine can't help you if you have misspelled it like I just did.</source>
          <target state="translated">&lt;code&gt;'undefned'&lt;/code&gt; ( &lt;em&gt;mal escrito&lt;/em&gt; ) aqu&amp;iacute; es solo una constante de cadena, por lo que el motor de JavaScript no puede ayudarlo si lo ha escrito mal como lo acabo de hacer.</target>
        </trans-unit>
        <trans-unit id="66262b2e58df668340e9c997b4fcbb22d477d689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; can be overridden in old browsers</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; se puede anular en los navegadores antiguos</target>
        </trans-unit>
        <trans-unit id="9c0eca093d608d52888040610ad0fea09fe42fae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Note that the use of &lt;code&gt;var&lt;/code&gt; for &lt;code&gt;in&lt;/code&gt; tests make a difference when in a scoped wrapper)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Tenga en cuenta que el uso de &lt;code&gt;var&lt;/code&gt; para pruebas hace la diferencia cuando est&amp;aacute; en un contenedor de &amp;aacute;mbito)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5812b0fa88241095ef998b82d3c2929c6f31055" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Specific to this question, see test cases with &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Espec&amp;iacute;fico a esta pregunta, vea los casos de prueba con &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b325ccf6a947861f6e178afd3921cc763cca384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;more&lt;/em&gt; dangerous than using the global &lt;code&gt;undefined&lt;/code&gt;. If you have to be ES3-compatible, replace &lt;code&gt;undefined&lt;/code&gt; with &lt;code&gt;void 0&lt;/code&gt; &amp;ndash; don&amp;rsquo;t resort to &lt;code&gt;typeof&lt;/code&gt;. (&lt;code&gt;void&lt;/code&gt; has always been a unary operator that evaluates to the Undefined value for any operand.)</source>
          <target state="translated">&lt;em&gt;m&amp;aacute;s&lt;/em&gt; peligroso que usar lo global &lt;code&gt;undefined&lt;/code&gt; . Si tiene que ser compatible con ES3, reemplace &lt;code&gt;undefined&lt;/code&gt; con &lt;code&gt;void 0&lt;/code&gt; ; no recurra a &lt;code&gt;typeof&lt;/code&gt; . ( &lt;code&gt;void&lt;/code&gt; siempre ha sido un operador unario que eval&amp;uacute;a el valor Indefinido para cualquier operando).</target>
        </trans-unit>
        <trans-unit id="d6d59c5f807d7ec4a037b85ca3c5e7f05986ccb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; In response to your edit, object properties should work the same way.</source>
          <target state="translated">&lt;strong&gt;Editar:&lt;/strong&gt; en respuesta a su edici&amp;oacute;n, las propiedades del objeto deber&amp;iacute;an funcionar de la misma manera.</target>
        </trans-unit>
        <trans-unit id="19806bd40175fc10a877fea67f68c16ed7195667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strict equality and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Igualdad estricta e indefinida&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110d482d5dc176523e015517737b158007fd1e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is a difference between an undefined member and a defined member with an undefined value.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hay una diferencia entre un miembro indefinido y un miembro definido con un valor indefinido.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f031e352cc2a0b3518c3a7f16759780f937d7a44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typeof operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tipo de operador e indefinido&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36bde56374a3373b2f73b61dde0097263e17ddb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Void operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Operador nulo e indefinido&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d8f959e87c1d0dffd229886fa52757ad009bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;null&lt;/strong&gt; means that the variable value is defined and set to null (has no value).</source>
          <target state="translated">&lt;strong&gt;nulo&lt;/strong&gt; significa que el valor de la variable est&amp;aacute; definido y establecido en nulo (no tiene valor).</target>
        </trans-unit>
        <trans-unit id="bec2062ef6d9e093a5eeb78377aa98519f789843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined&lt;/strong&gt; means that the variable value has not been defined; it is not known what the value is.</source>
          <target state="translated">&lt;strong&gt;indefinido&lt;/strong&gt; significa que el valor de la variable no se ha definido; No se sabe cu&amp;aacute;l es el valor.</target>
        </trans-unit>
        <trans-unit id="7ef0f25ff59da22f20a9f581d372dd5532c68b8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;window&lt;/strong&gt; is an object which holds all global variables as its members, and it is legal to try to access a non-existing member. If &lt;strong&gt;x&lt;/strong&gt; hasn't been declared or hasn't been set then &lt;code&gt;window.x&lt;/code&gt; returns &lt;strong&gt;undefined&lt;/strong&gt;. &lt;strong&gt;undefined&lt;/strong&gt; leads to &lt;strong&gt;false&lt;/strong&gt; when &lt;strong&gt;if()&lt;/strong&gt; evaluates it.</source>
          <target state="translated">&lt;strong&gt;La ventana&lt;/strong&gt; es un objeto que contiene todas las variables globales como sus miembros, y es legal intentar acceder a un miembro no existente. Si &lt;strong&gt;x&lt;/strong&gt; no se ha declarado o no se ha establecido, &lt;code&gt;window.x&lt;/code&gt; devuelve &lt;strong&gt;undefined&lt;/strong&gt; . &lt;strong&gt;undefined&lt;/strong&gt; conduce a &lt;strong&gt;falso&lt;/strong&gt; cuando &lt;strong&gt;if () lo&lt;/strong&gt; eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="f0196332640a9574b642791f69278e0108d64482" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup1; unusual choice of example variable name? this is real dead code from the NoScript extension for Firefox.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup1; elecci&amp;oacute;n inusual del nombre de la variable de ejemplo?&lt;/sub&gt; &lt;sub&gt;Este es un c&amp;oacute;digo muerto real de la extensi&amp;oacute;n NoScript para Firefox.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="832763f5083c7d8a0f4ef0ca33f1a035e0a67dc1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup2; don&amp;rsquo;t assume that not knowing what&amp;rsquo;s in scope is okay in general, though. bonus vulnerability caused by abuse of dynamic scope: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup2; Sin embargo, no asuma que no saber lo que est&amp;aacute; dentro del alcance est&amp;aacute; bien en general.&lt;/sub&gt; &lt;sub&gt;vulnerabilidad adicional causada por abuso de alcance din&amp;aacute;mico: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Proyecto Cero 1225&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="84456406b0e70016bbb43249541eb7f735f005f4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup3; once again assuming an ES5+ environment and that &lt;code&gt;undefined&lt;/code&gt; refers to the &lt;code&gt;undefined&lt;/code&gt; property of the global object. substitute &lt;code&gt;void 0&lt;/code&gt; otherwise.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup3; una vez m&amp;aacute;s asumiendo un entorno ES5 + y que &lt;code&gt;undefined&lt;/code&gt; refiere a la propiedad &lt;code&gt;undefined&lt;/code&gt; del objeto global.&lt;/sub&gt; &lt;sub&gt;sustituir &lt;code&gt;void 0&lt;/code&gt; contrario.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="58cef43f9cc148fe201f6a40aa751b0117edb0fa" translate="yes" xml:space="preserve">
          <source>Actually it can mean two quite different things! First, it can mean &lt;em&gt;the property that has never been defined&lt;/em&gt; in the object and, second, it can mean the &lt;em&gt;property that has an undefined value&lt;/em&gt;. Let's look at this code:</source>
          <target state="translated">&amp;iexcl;En realidad puede significar dos cosas muy diferentes! Primero, puede significar &lt;em&gt;la propiedad que nunca se ha definido&lt;/em&gt; en el objeto y, segundo, puede significar la &lt;em&gt;propiedad que tiene un valor indefinido&lt;/em&gt; . Veamos este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="349ce103efd4c2fadb9a858b41201bbd6794a393" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;myVar === undefined&lt;/code&gt; will raise an error in the situation where myVar is undeclared.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;myVar === undefined&lt;/code&gt; generar&amp;aacute; un error en la situaci&amp;oacute;n en la que myVar no est&amp;aacute; declarado.</target>
        </trans-unit>
        <trans-unit id="286d348194a35b840509a9c9d1227df8acbbd2ec" translate="yes" xml:space="preserve">
          <source>All the answers are incomplete. This is the right way of knowing that there is a property 'defined as undefined' :</source>
          <target state="translated">Todas las respuestas están incompletas.Esta es la forma correcta de saber que hay una propiedad &quot;definida como indefinida&quot;:</target>
        </trans-unit>
        <trans-unit id="f10c4fd9df413d69738977ff9f171b41d4667fe1" translate="yes" xml:space="preserve">
          <source>Also one more thing, for checking property on an object in a real application which you not sure even the object exists or not, check if the object exists first.</source>
          <target state="translated">También una cosa más,para comprobar la propiedad de un objeto en una aplicación real que no está seguro de que el objeto exista o no,compruebe primero si el objeto existe.</target>
        </trans-unit>
        <trans-unit id="219f34b6015e059105c29a26a98358fba3b56ee1" translate="yes" xml:space="preserve">
          <source>Also other javascript frameworks like underscore has similar defining check, but I recommend you use &lt;code&gt;typeof&lt;/code&gt; if you already not using any frameworks.</source>
          <target state="translated">Tambi&amp;eacute;n otros marcos de JavaScript como el subrayado tienen una verificaci&amp;oacute;n de definici&amp;oacute;n similar, pero le recomiendo que use &lt;code&gt;typeof&lt;/code&gt; si ya no est&amp;aacute; usando ning&amp;uacute;n marco.</target>
        </trans-unit>
        <trans-unit id="791ed3302cfee030f9c8fa3bee23d8d3e1f0bc24" translate="yes" xml:space="preserve">
          <source>Alternatively, typeof can be used:</source>
          <target state="translated">Alternativamente,se puede utilizar el tipo de</target>
        </trans-unit>
        <trans-unit id="63b964d88fc95bd706292cbaa247b9c16e2755e4" translate="yes" xml:space="preserve">
          <source>And results:</source>
          <target state="translated">Y los resultados:</target>
        </trans-unit>
        <trans-unit id="d83e8ed16ed58afb7ab32795cb6009ac31db06ab" translate="yes" xml:space="preserve">
          <source>As you see we can check anything with using something like this in our code, as mentioned you can simply use &lt;code&gt;typeof&lt;/code&gt; in your code, but if you are using it over and over, create a function like the angular sample which I share and keep reusing as following DRY code pattern.</source>
          <target state="translated">Como puede ver, podemos verificar cualquier cosa usando algo como esto en nuestro c&amp;oacute;digo, como se mencion&amp;oacute;, simplemente puede usar &lt;code&gt;typeof&lt;/code&gt; en su c&amp;oacute;digo, pero si lo est&amp;aacute; usando una y otra vez, cree una funci&amp;oacute;n como la muestra angular que comparto y sigo reutilizando como sigue el patr&amp;oacute;n de c&amp;oacute;digo DRY.</target>
        </trans-unit>
        <trans-unit id="87f10ffef733699e5454e0973b6bbcf28272a26a" translate="yes" xml:space="preserve">
          <source>Because the window object has a global scope (default object) outside a function, a declaration will be 'attached' to the window object.</source>
          <target state="translated">Debido a que el objeto ventana tiene un alcance global (objeto por defecto)fuera de una función,se &quot;adjuntará&quot; una declaración al objeto ventana.</target>
        </trans-unit>
        <trans-unit id="2f6b520b68a6505ce09b8eb40967aa50ccdc1dcc" translate="yes" xml:space="preserve">
          <source>But as has been mentioned these are not exactly the same (but are more than good enough for my needs).</source>
          <target state="translated">Pero como se ha mencionado,no son exactamente iguales (pero son más que suficientes para mis necesidades).</target>
        </trans-unit>
        <trans-unit id="fcfbf2fbae71c2369946c84ef809e8845fa289d8" translate="yes" xml:space="preserve">
          <source>But unhappily &lt;code&gt;typeof obj.foo&lt;/code&gt; does not tell us which of the three cases we have. However we can combine this with &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; to distinguish the cases.</source>
          <target state="translated">Pero infelizmente &lt;code&gt;typeof obj.foo&lt;/code&gt; no nos dice cu&amp;aacute;l de los tres casos tenemos. Sin embargo, podemos combinar esto con &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; para distinguir los casos.</target>
        </trans-unit>
        <trans-unit id="1daf4b17726ef0dab632dbab9c7df1fe0d5f44a0" translate="yes" xml:space="preserve">
          <source>Code for reference:</source>
          <target state="translated">Código de referencia:</target>
        </trans-unit>
        <trans-unit id="fd83e3fc07c2d36f7a50c3554edc7779b39383e8" translate="yes" xml:space="preserve">
          <source>Commonly, people have asked me for an algorithm to figure out if a value is either falsy, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;. The following works.</source>
          <target state="translated">Com&amp;uacute;nmente, la gente me ha pedido un algoritmo para determinar si un valor es falso, &lt;code&gt;undefined&lt;/code&gt; o &lt;code&gt;null&lt;/code&gt; . Los siguientes trabajos.</target>
        </trans-unit>
        <trans-unit id="40c624d52a56db62dd4208fe5347d5d97cd36d54" translate="yes" xml:space="preserve">
          <source>Compare with &lt;code&gt;void 0&lt;/code&gt;, for terseness.</source>
          <target state="translated">Compare con el &lt;code&gt;void 0&lt;/code&gt; , para ser conciso.</target>
        </trans-unit>
        <trans-unit id="3e55bf53313fd9840391bfd75f5d5b1153e71e7c" translate="yes" xml:space="preserve">
          <source>Convert input value to string to compare with &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; and ensure it's negative value.</source>
          <target state="translated">Convierta el valor de entrada a cadena para compararlo con &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; y aseg&amp;uacute;rese de que sea un valor negativo.</target>
        </trans-unit>
        <trans-unit id="e38b4ae3f7cb873e402c0c020e6e974a8e377719" translate="yes" xml:space="preserve">
          <source>Correct Code</source>
          <target state="translated">Código correcto</target>
        </trans-unit>
        <trans-unit id="bbf717127e889535958ab6c66e7ca4d538373008" translate="yes" xml:space="preserve">
          <source>Crossposting my &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;answer&lt;/a&gt; from related question &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;How to check for &quot;undefined&quot; in JavaScript?&lt;/a&gt;</source>
          <target state="translated">Cruzando mi &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;respuesta&lt;/a&gt; de una pregunta relacionada &amp;iquest; &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;C&amp;oacute;mo verificar &quot;indefinido&quot; en JavaScript?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e2c55e17d9d063d6e819462c4f293237ba47eba" translate="yes" xml:space="preserve">
          <source>Defined as a falsy value, undefined,null, or never defined.</source>
          <target state="translated">Definido como un valor falso,indefinido,nulo o nunca definido.</target>
        </trans-unit>
        <trans-unit id="f4c589078846130bd5d8f8b014b127005e460131" translate="yes" xml:space="preserve">
          <source>Defined as undefined Or never Defined</source>
          <target state="translated">Definido como indefinido o nunca definido</target>
        </trans-unit>
        <trans-unit id="71177ce1bd442c1e211b610b3ce841a27b46d68f" translate="yes" xml:space="preserve">
          <source>Degenerate code. DO NOT USE.</source>
          <target state="translated">Código degenerado.NO UTILIZAR.</target>
        </trans-unit>
        <trans-unit id="5e35f4620392124dd0fdbc52a3c5eb05fbd9f75d" translate="yes" xml:space="preserve">
          <source>Despite being vehemently recommended by many other answers here, &lt;code&gt;typeof&lt;/code&gt;&lt;em&gt;is a bad choice&lt;/em&gt;. It should never be used for checking whether variables have the value &lt;code&gt;undefined&lt;/code&gt;, because it acts as a combined check for the value &lt;code&gt;undefined&lt;/code&gt; and for whether a variable exists. In the vast majority of cases, you know when a variable exists, and &lt;code&gt;typeof&lt;/code&gt; will just introduce the potential for a silent failure if you make a typo in the variable name or in the string literal &lt;code&gt;'undefined'&lt;/code&gt;.</source>
          <target state="translated">A pesar de ser recomendado con vehemencia por muchas otras respuestas aqu&amp;iacute;, &lt;code&gt;typeof&lt;/code&gt; &lt;em&gt;es una mala elecci&amp;oacute;n&lt;/em&gt; . Nunca debe usarse para verificar si las variables tienen un valor &lt;code&gt;undefined&lt;/code&gt; , ya que act&amp;uacute;a como una verificaci&amp;oacute;n combinada del valor &lt;code&gt;undefined&lt;/code&gt; y si existe una variable. En la gran mayor&amp;iacute;a de los casos, sabe cu&amp;aacute;ndo existe una variable, y &lt;code&gt;typeof&lt;/code&gt; solo presentar&amp;aacute; el potencial de una falla silenciosa si comete un error tipogr&amp;aacute;fico en el nombre de la variable o en la cadena literal &lt;code&gt;'undefined'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09909cfd981fdef3626ccc9834d9448da9e9745f" translate="yes" xml:space="preserve">
          <source>Detecting an undefined object property</source>
          <target state="translated">Detección de una propiedad de objeto no definida</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58abfcd5560647f71db6174e6dae2c1d7b00956b" translate="yes" xml:space="preserve">
          <source>Example: I want to know if my browser supports History API</source>
          <target state="translated">Ejemplo:Quiero saber si mi navegador soporta la API de Historial</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="1cc20ab6bb45b09d067f86e897de287544ccc18a" translate="yes" xml:space="preserve">
          <source>Final fight: &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;obj.prop === undefined&lt;/code&gt; final: obj.prop === undefined vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a66f6d43d5e07190edcbfd047a24a1c644663c95" translate="yes" xml:space="preserve">
          <source>For example: I've just been refactoring a bunch of code that had a bunch of checks whether an object had a given property.</source>
          <target state="translated">Por ejemplo:Acabo de refactorizar un montón de código que tenía un montón de comprobaciones si un objeto tenía una propiedad determinada.</target>
        </trans-unit>
        <trans-unit id="11cb88bb285ee32166071503cea3f43fbd246c9f" translate="yes" xml:space="preserve">
          <source>For my situation, if restResult.data[0] === &quot;object&quot;, then I can safely start inspecting the rest of the members.  If undefined then throw the error as above.</source>
          <target state="translated">Para mi situación,si restResult.data[0]===&quot;objeto&quot;,entonces puedo empezar a inspeccionar con seguridad al resto de los miembros.Si no está definido,entonces arroja el error como arriba.</target>
        </trans-unit>
        <trans-unit id="282a1a5fba1c9f99dd9c65da723cf7e6ca6d5c3b" translate="yes" xml:space="preserve">
          <source>From lodash.js.</source>
          <target state="translated">De lodash.js.</target>
        </trans-unit>
        <trans-unit id="724505ac659cb61ec2ae6752fea94b6583d5c2e3" translate="yes" xml:space="preserve">
          <source>Going through the comments, for those who want to check both is it undefined or its value is null:</source>
          <target state="translated">Revisando los comentarios,para los que quieran comprobar tanto si está indefinido o su valor es nulo:</target>
        </trans-unit>
        <trans-unit id="12f327f57e715c27af2a0b9e2dc98dfb92d437ff" translate="yes" xml:space="preserve">
          <source>Here is my situation:</source>
          <target state="translated">Esta es mi situación:</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">¡Espero que esto ayude!</target>
        </trans-unit>
        <trans-unit id="21afb40540c44bc457dfbcf79a0414bc7750aa85" translate="yes" xml:space="preserve">
          <source>How this works:</source>
          <target state="translated">Cómo funciona esto:</target>
        </trans-unit>
        <trans-unit id="5d0e7097fe8f3623c402467f8277e8158fe7d304" translate="yes" xml:space="preserve">
          <source>However, this kind of technique should be avoided. JavaScript is a
  statically scoped language, so knowing if a variable is declared can
  be read by seeing whether it is declared in an enclosing context. The
  only exception is the global scope, but the global scope is bound to
  the global object, so checking the existence of a variable in the
  global context can be done by checking the existence of a property on
  the global object (using the in operator, for instance).</source>
          <target state="translated">Sin embargo,este tipo de técnica debe evitarse.El JavaScript es un lenguaje de alcance estático,por lo que saber si una variable se declara puede leerse viendo si se declara en un contexto cerrado.La única excepción es el alcance global,pero el alcance global está ligado al objeto global,por lo que la comprobación de la existencia de una variable en el contexto global puede hacerse comprobando la existencia de una propiedad en el objeto global (utilizando el operador in,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="6fecf04984cba74419822b109f93545b2cd336ab" translate="yes" xml:space="preserve">
          <source>I also add this section from MDN which has got useful information about typeof, undefined and void(0).</source>
          <target state="translated">También añado esta sección de la MDN que tiene información útil sobre el tipo de,indefinido y vacío(0).</target>
        </trans-unit>
        <trans-unit id="ca90e82d4aa8f47040cff0d3ebf2778f42cec981" translate="yes" xml:space="preserve">
          <source>I am using the result of a REST call.
The result should be parsed from JSON to a JavaScript object.</source>
          <target state="translated">Estoy usando el resultado de una llamada de REST.El resultado debe ser analizado desde JSON a un objeto de JavaScript.</target>
        </trans-unit>
        <trans-unit id="44d30a96fae36c5b6279d6d45740204cbf4ff5a0" translate="yes" xml:space="preserve">
          <source>I believe there are a number of incorrect answers to this topic. Contrary to common belief, &quot;undefined&quot; is &lt;strong&gt;not&lt;/strong&gt; a keyword in JavaScript and can in fact have a value assigned to it.</source>
          <target state="translated">Creo que hay varias respuestas incorrectas a este tema. Contrariamente a la creencia com&amp;uacute;n, &quot;indefinido&quot; &lt;strong&gt;no&lt;/strong&gt; es una palabra clave en JavaScript y, de hecho, puede tener un valor asignado.</target>
        </trans-unit>
        <trans-unit id="b37013d283a8127b7370563a4c36a206388c33a2" translate="yes" xml:space="preserve">
          <source>I didn't see (hope I didn't miss it) anyone checking the object before the property. So, this is the shortest and most effective (though not necessarily the most clear):</source>
          <target state="translated">No vi (espero no haberme equivocado)a nadie revisando el objeto antes de la propiedad.Por lo tanto,este es el más corto y efectivo (aunque no necesariamente el más claro):</target>
        </trans-unit>
        <trans-unit id="4358f6b4064ade07b2efbf8a21e0f4135f510c95" translate="yes" xml:space="preserve">
          <source>I found lodash updated its implementation. See &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;my issue&lt;/a&gt; and &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;the code&lt;/a&gt;.</source>
          <target state="translated">Encontr&amp;eacute; que Lodash actualiz&amp;oacute; su implementaci&amp;oacute;n. Vea &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;mi problema&lt;/a&gt; y &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;el c&amp;oacute;digo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a132ebdcb8942d7a076277423ad437744ce7794" translate="yes" xml:space="preserve">
          <source>I provide three ways here for those who expect weird answers:</source>
          <target state="translated">Aquí ofrezco tres maneras para aquellos que esperan respuestas extrañas:</target>
        </trans-unit>
        <trans-unit id="48e26ba605da52f2cf32ca734ac26d9e06215803" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;if (this.variable)&lt;/code&gt; to test if it is defined. Simple &lt;code&gt;if (variable)&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;recommended above&lt;/a&gt;, fails for me. It turns out that it works only when variable is a field of some object, &lt;code&gt;obj.someField&lt;/code&gt; to check if it is defined in the dictionary. But we can use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; as the dictionary object since any variable is a field in current window, as I understand it. Therefore here is a test</source>
          <target state="translated">Yo uso &lt;code&gt;if (this.variable)&lt;/code&gt; para probar si est&amp;aacute; definido. Simple &lt;code&gt;if (variable)&lt;/code&gt; , &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;recomendado anteriormente&lt;/a&gt; , falla para m&amp;iacute;. Resulta que funciona solo cuando variable es un campo de alg&amp;uacute;n objeto, &lt;code&gt;obj.someField&lt;/code&gt; para verificar si est&amp;aacute; definido en el diccionario. Pero podemos usar &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;window&lt;/code&gt; como objeto de diccionario, ya que cualquier variable es un campo en la ventana actual, seg&amp;uacute;n tengo entendido. Por lo tanto, aqu&amp;iacute; hay una prueba</target>
        </trans-unit>
        <trans-unit id="9e125ebcc0697240332e778b82ebf4d7f9c17043" translate="yes" xml:space="preserve">
          <source>I would like to show you something I'm using in order to protect the &lt;code&gt;undefined&lt;/code&gt; variable:</source>
          <target state="translated">Me gustar&amp;iacute;a mostrarle algo que estoy usando para proteger la variable &lt;code&gt;undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5a6d2b02368855c6fda929fd61af0ea56454c18" translate="yes" xml:space="preserve">
          <source>I'd argue that in some cases it makes more sense (and is clearer) to check whether the property is there, than checking whether it is undefined, and the only case where this check will be different is case 2, the rare case of an actual entry in the object with an undefined value.</source>
          <target state="translated">Yo diría que en algunos casos tiene más sentido (y es más claro)comprobar si la propiedad está ahí,que comprobar si está indefinida,y el único caso en que esta comprobación será diferente es el caso 2,el raro caso de una entrada real en el objeto con un valor indefinido.</target>
        </trans-unit>
        <trans-unit id="7a7486fe538e6ce861baa007fbb0f526deff33d5" translate="yes" xml:space="preserve">
          <source>I'm not sure where the origin of using &lt;code&gt;===&lt;/code&gt; with &lt;code&gt;typeof&lt;/code&gt; came from, and as a convention I see it used in many libraries, but the typeof operator returns a string literal, and we know that up front, so why would you also want to type check it too?</source>
          <target state="translated">No estoy seguro de d&amp;oacute;nde vino el origen del uso de &lt;code&gt;===&lt;/code&gt; con &lt;code&gt;typeof&lt;/code&gt; , y como convenci&amp;oacute;n veo que se usa en muchas bibliotecas, pero el operador typeof devuelve un literal de cadena, y lo sabemos por adelantado, entonces, &amp;iquest;por qu&amp;eacute; &amp;iquest;tambi&amp;eacute;n quieres escribir verificarlo tambi&amp;eacute;n?</target>
        </trans-unit>
        <trans-unit id="6ef1c4a3ea0bc81cc7398a1d04f0515bcbd0fb86" translate="yes" xml:space="preserve">
          <source>If an object variable which have some properties you can use same thing like this:</source>
          <target state="translated">Si una variable de objeto que tiene algunas propiedades se puede usar lo mismo que esto:</target>
        </trans-unit>
        <trans-unit id="84c7f1a126730161309b91866d156c12a47d03cd" translate="yes" xml:space="preserve">
          <source>If the obj or obj.prop is undefined, null, or &quot;falsy&quot;, the if statement will not execute the code block. This is &lt;em&gt;usually&lt;/em&gt; the desired behavior in most code block statements (in JavaScript).</source>
          <target state="translated">Si obj u obj.prop no est&amp;aacute; definido, es nulo o &quot;falso&quot;, la instrucci&amp;oacute;n if no ejecutar&amp;aacute; el bloque de c&amp;oacute;digo. Este suele &lt;em&gt;ser&lt;/em&gt; el comportamiento deseado en la mayor&amp;iacute;a de las declaraciones de bloque de c&amp;oacute;digo (en JavaScript).</target>
        </trans-unit>
        <trans-unit id="0d8a3869bd9a3727544999c872ed66c32e2161a3" translate="yes" xml:space="preserve">
          <source>If the value of an object was never defined, this will prevent from returning &lt;code&gt;true&lt;/code&gt; if it is defined as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. This is helpful if you want true to be returned for values set as &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Si el valor de un objeto nunca se defini&amp;oacute;, esto evitar&amp;aacute; que devuelva &lt;code&gt;true&lt;/code&gt; si se define como &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;undefined&lt;/code&gt; . Esto es &amp;uacute;til si desea que se devuelva true para valores establecidos como &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e37e4c8d75647a160e70f184781ee5d3320919a7" translate="yes" xml:space="preserve">
          <source>If you are using Angular:</source>
          <target state="translated">Si estás usando Angular:</target>
        </trans-unit>
        <trans-unit id="38b2ee0e2820da1917baa311fe8dc70a8ba6eb39" translate="yes" xml:space="preserve">
          <source>If you are using jQuery Library then &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; will suffice for both cases,</source>
          <target state="translated">Si est&amp;aacute; utilizando jQuery Library, &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; ser&amp;aacute; suficiente para ambos casos,</target>
        </trans-unit>
        <trans-unit id="4a3f6705c1b3da9943592b3d90136b8c5856782d" translate="yes" xml:space="preserve">
          <source>If you check a property on an object and the object doesn't exist, will throw an error and stop the whole application running.</source>
          <target state="translated">Si comprueba una propiedad de un objeto y el objeto no existe,arrojará un error e impedirá que se ejecute toda la aplicación.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">Si lo haces...</target>
        </trans-unit>
        <trans-unit id="efde9566bc6269c016eb40d2c931ee65be1256d5" translate="yes" xml:space="preserve">
          <source>If you want it to result as &lt;code&gt;true&lt;/code&gt; for values defined with the value of &lt;code&gt;undefined&lt;/code&gt;, or never defined, you can simply use &lt;code&gt;=== undefined&lt;/code&gt;</source>
          <target state="translated">Si desea que resulte &lt;code&gt;true&lt;/code&gt; para los valores definidos con el valor de &lt;code&gt;undefined&lt;/code&gt; , o nunca definido, simplemente puede usar &lt;code&gt;=== undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c710b9144a4a4de7a8033df9d90b0d520b9d93cc" translate="yes" xml:space="preserve">
          <source>In JavaScript there is &lt;strong&gt;null&lt;/strong&gt; and there is &lt;strong&gt;undefined&lt;/strong&gt;.  They have different meanings.</source>
          <target state="translated">En JavaScript hay &lt;strong&gt;nulo&lt;/strong&gt; y hay &lt;strong&gt;indefinido&lt;/strong&gt; . Tienen diferentes significados.</target>
        </trans-unit>
        <trans-unit id="676832a5b39fcd247b5da8131c2bb20e3f4e6479" translate="yes" xml:space="preserve">
          <source>In js, optional parameter works when the input value is exactly &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">En js, el par&amp;aacute;metro opcional funciona cuando el valor de entrada es exactamente &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47b70d6bd5d7420590fbe686fa1aa65f6aff345c" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Exploring the Abyss of Null and Undefined in JavaScript &lt;/a&gt;&lt;/em&gt; I read that frameworks like &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; use this function:</source>
          <target state="translated">En el art&amp;iacute;culo &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Explorando el abismo de nulo e indefinido en JavaScript&lt;/a&gt;&lt;/em&gt; , le&amp;iacute; que los marcos como &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; usan esta funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="d6f3fa461bad66e062e473e85ddb6843faa72ad8" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;o.a&lt;/code&gt; undefined? Yes! Its value is undefined. Is &lt;code&gt;o.b&lt;/code&gt; undefined? Sure! There is no property 'b' at all! OK, see now how different approaches behave in both situations:</source>
          <target state="translated">&amp;iquest;Est&amp;aacute; indefinido? &amp;iexcl;Si! Su valor es indefinido. &amp;iquest;Est&amp;aacute; &lt;code&gt;o.b&lt;/code&gt; indefinido? &amp;iexcl;Por supuesto! &amp;iexcl;No hay ninguna propiedad 'b' en absoluto! OK, vea ahora c&amp;oacute;mo se comportan los diferentes enfoques en ambas situaciones:</target>
        </trans-unit>
        <trans-unit id="5fd8487b64efdd4bc0f74bc89dcb48fb3b637b18" translate="yes" xml:space="preserve">
          <source>It creates a LOCAL variable named &lt;code&gt;undefined&lt;/code&gt; which is initialized with the default value -- the real &lt;code&gt;undefined&lt;/code&gt;, then compares &lt;code&gt;value&lt;/code&gt; with the variable &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Crea una variable LOCAL llamada &lt;code&gt;undefined&lt;/code&gt; que se inicializa con el valor predeterminado: el &lt;code&gt;undefined&lt;/code&gt; real, luego compara el &lt;code&gt;value&lt;/code&gt; con la variable &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc7e62a0477f84c6e213a2a66a6810ed10b81109" translate="yes" xml:space="preserve">
          <source>It first detects that variable &lt;code&gt;abc&lt;/code&gt; is undefined and it is defined after initialization.</source>
          <target state="translated">Primero detecta que la variable &lt;code&gt;abc&lt;/code&gt; no est&amp;aacute; definida y se define despu&amp;eacute;s de la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0a0f662835940c2e3dcfdd198a56eabd87b6dab3" translate="yes" xml:space="preserve">
          <source>It is always better to use the instance/object of the variable to check if it got a valid value. It is more stable and is a better way of programming.</source>
          <target state="translated">Siempre es mejor utilizar el objeto-iniciativa de la variable para comprobar si tiene un valor válido.Es más estable y es una mejor manera de programar.</target>
        </trans-unit>
        <trans-unit id="4d8fd1abf77f99fdff5448384c2ed4fee6e5c474" translate="yes" xml:space="preserve">
          <source>It is really universal! It works in new and old browsers.</source>
          <target state="translated">¡Es realmente universal! Funciona en navegadores nuevos y viejos.</target>
        </trans-unit>
        <trans-unit id="a3b4d7eb65e80473b0d023a35685a8a9cba1977e" translate="yes" xml:space="preserve">
          <source>It's a bit shorter and looks a bit prettier</source>
          <target state="translated">Es un poco más corto y se ve un poco más bonito</target>
        </trans-unit>
        <trans-unit id="1f9e9fe4a20d8dcfcf0cd7dd398ac00aaebacdc0" translate="yes" xml:space="preserve">
          <source>It's not as verbose as &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</source>
          <target state="translated">No es tan detallado como &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda34532c7ceeef815dfdb84a302308f13b1698b" translate="yes" xml:space="preserve">
          <source>It's suitable if you have a function, which receives an additional config property:</source>
          <target state="translated">Es adecuado si tienes una función,que recibe una propiedad de configuración adicional:</target>
        </trans-unit>
        <trans-unit id="90a5de8bf9ed40e458f73d3c2fa132d1f4efa842" translate="yes" xml:space="preserve">
          <source>Its worth noting that these tests are the same for &lt;code&gt;null&lt;/code&gt; entries too</source>
          <target state="translated">Vale la pena se&amp;ntilde;alar que estas pruebas son las mismas para entradas &lt;code&gt;null&lt;/code&gt; tambi&amp;eacute;n</target>
        </trans-unit>
        <trans-unit id="cca12d9c31c7dc579429ae296a479d2f796bada7" translate="yes" xml:space="preserve">
          <source>JavaScript has &lt;code&gt;typeof&lt;/code&gt; which make it very easy to detect an undefined variable.</source>
          <target state="translated">JavaScript tiene &lt;code&gt;typeof&lt;/code&gt; que hacen que sea muy f&amp;aacute;cil detectar una variable indefinida.</target>
        </trans-unit>
        <trans-unit id="a82d750a33e643b1a8a39e0ebb43d3b5768eaffc" translate="yes" xml:space="preserve">
          <source>Marijn Haverbeke states, in his free, online book &quot;&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt;&quot; (emphasis mine):</source>
          <target state="translated">Marijn Haverbeke declara, en su libro gratuito en l&amp;iacute;nea &quot; &lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt; &quot; (&amp;eacute;nfasis m&amp;iacute;o):</target>
        </trans-unit>
        <trans-unit id="5f9f4ff7cb7c3bd40b09bbc0a21ff4e94114ed3a" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">Desventajas de &lt;code&gt;obj.prop === undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0671b57c33e2e288915d086d37cc882d4a48e654" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">Desventajas de &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6bea7aa73158aa827a9c1bea87ededed070dc457" translate="yes" xml:space="preserve">
          <source>Most likely you want &lt;code&gt;if (window.x)&lt;/code&gt;. This check is safe even if x hasn't been declared (&lt;code&gt;var x;&lt;/code&gt;) - browser doesn't throw an error.</source>
          <target state="translated">Lo m&amp;aacute;s probable es que quieras &lt;code&gt;if (window.x)&lt;/code&gt; . Esta comprobaci&amp;oacute;n es segura incluso si no se ha declarado &lt;code&gt;var x;&lt;/code&gt; ( var x; ): el navegador no arroja un error.</target>
        </trans-unit>
        <trans-unit id="9b4b5105b3b3a13be5c61e3fa3df47a1366e4075" translate="yes" xml:space="preserve">
          <source>Never Defined</source>
          <target state="translated">Nunca definido</target>
        </trans-unit>
        <trans-unit id="9484abb038e36cb0cd8cbbc623288ca1c4c7dc51" translate="yes" xml:space="preserve">
          <source>Node.js supports the global variable &lt;code&gt;undefined&lt;/code&gt; as &lt;code&gt;global.undefined&lt;/code&gt; (it can also be used without the 'global' prefix). I don't know about other implementations of server-side JavaScript.</source>
          <target state="translated">Node.js admite la variable global &lt;code&gt;undefined&lt;/code&gt; como &lt;code&gt;global.undefined&lt;/code&gt; (tambi&amp;eacute;n se puede usar sin el prefijo 'global'). No s&amp;eacute; sobre otras implementaciones de JavaScript del lado del servidor.</target>
        </trans-unit>
        <trans-unit id="25e7237d29d65a8052d28a50ad68997f82c2cf73" translate="yes" xml:space="preserve">
          <source>Note: The strict equality operator rather than the standard equality
  operator must be used here, because x == undefined also checks whether
  x is null, while strict equality doesn't. null is not equivalent to
  undefined. See comparison operators for details.</source>
          <target state="translated">Nota:El operador de igualdad estricta en lugar del operador de igualdad estándar debe ser usado aquí,porque x ==indefinido también comprueba si x es nulo,mientras que la igualdad estricta no lo es.null no es equivalente a indefinido.Véase los operadores de comparación para más detalles.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="59c5fb8a80a77710fbcb25bc27178f51a4e9b105" translate="yes" xml:space="preserve">
          <source>Now executing</source>
          <target state="translated">Ahora ejecutando</target>
        </trans-unit>
        <trans-unit id="b2491f157aee8344e47a52d1010d094626fad59f" translate="yes" xml:space="preserve">
          <source>One reason to use typeof is that it does not throw an error if the
  variable has not been declared.</source>
          <target state="translated">Una razón para usar el typeof es que no arroja un error si la variable no ha sido declarada.</target>
        </trans-unit>
        <trans-unit id="aeca9079848cd62aa72e0c9da1ae45fee2f68f0f" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">Ventajas de &lt;code&gt;obj.prop === undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c47d4b2cec06b65e3df4b5dc37d83b7c1779a8b3" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">Ventajas de &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab5bb084b0953bb529d05917ef5d0f8f02b4e552" translate="yes" xml:space="preserve">
          <source>Reading through this, I'm amazed I didn't see this. I have found multiple algorithms that would work for this.</source>
          <target state="translated">Leyendo esto,me sorprende no haber visto esto.He encontrado múltiples algoritmos que podrían funcionar para esto.</target>
        </trans-unit>
        <trans-unit id="bb5a0c2d5893ca1120918abd2e27fe466333b1bf" translate="yes" xml:space="preserve">
          <source>Returns false if variable is set, and true if is undefined.</source>
          <target state="translated">Devuelve falso si la variable está establecida,y verdadero si no está definida.</target>
        </trans-unit>
        <trans-unit id="883a8c4f5ebd87c4fde0e73e9656f30546585657" translate="yes" xml:space="preserve">
          <source>Simply anything is not defined in JavaScript, is &lt;strong&gt;undefined&lt;/strong&gt;, doesn't matter if it's a property inside an &lt;strong&gt;Object/Array&lt;/strong&gt; or as just a simple variable...</source>
          <target state="translated">Simplemente cualquier cosa no est&amp;aacute; definida en JavaScript, est&amp;aacute; &lt;strong&gt;indefinida&lt;/strong&gt; , no importa si es una propiedad dentro de un &lt;strong&gt;objeto / matriz&lt;/strong&gt; o simplemente como una variable simple ...</target>
        </trans-unit>
        <trans-unit id="aedd3fc984632b50a483c5fe2c50d6f41d6d1779" translate="yes" xml:space="preserve">
          <source>Simply check if &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; and it will return a boolean.</source>
          <target state="translated">Simplemente verifique si &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; y devolver&amp;aacute; un valor booleano.</target>
        </trans-unit>
        <trans-unit id="f828f39971d418b0bc13a1d98409cc5e98730d01" translate="yes" xml:space="preserve">
          <source>So as you see the function receive a value, if that value is defined, it will return &lt;code&gt;false&lt;/code&gt;, otherwise for undefined values, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Entonces, como ve que la funci&amp;oacute;n recibe un valor, si ese valor est&amp;aacute; definido, devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; ; de lo contrario, para valores indefinidos, devolver&amp;aacute; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="418ae1e2e0311d3d2c105a70491013660c6a928b" translate="yes" xml:space="preserve">
          <source>So let's have a look what gonna be the results when we passing values, including object properties like below, this is the list of variables we have:</source>
          <target state="translated">Así que echemos un vistazo a los resultados cuando pasemos los valores,incluyendo las propiedades de los objetos,como abajo,esta es la lista de variables que tenemos:</target>
        </trans-unit>
        <trans-unit id="26532241df6bb6d2e9b7919c8174d92f3c3e9956" translate="yes" xml:space="preserve">
          <source>So simple you can wrap inside an if statement like below:</source>
          <target state="translated">Tan simple que puedes envolver dentro de una declaración como la de abajo:</target>
        </trans-unit>
        <trans-unit id="c03f8753c6b8939bcb611d65d70cd9f2e93a2bf4" translate="yes" xml:space="preserve">
          <source>So unless you&amp;rsquo;re doing feature detection&amp;sup2;, where there&amp;rsquo;s uncertainty whether a given name will be in scope (like checking &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; as a step in code specific to a CommonJS environment), &lt;code&gt;typeof&lt;/code&gt; is a harmful choice when used on a variable, and the correct option is to compare the value directly:</source>
          <target state="translated">Entonces, a menos que est&amp;eacute; haciendo la detecci&amp;oacute;n de caracter&amp;iacute;sticas&amp;sup2;, donde hay incertidumbre sobre si un nombre dado estar&amp;aacute; dentro del alcance (como verificar &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; como un paso en el c&amp;oacute;digo espec&amp;iacute;fico de un entorno CommonJS), &lt;code&gt;typeof&lt;/code&gt; es una elecci&amp;oacute;n da&amp;ntilde;ina cuando se usa en una variable, y la opci&amp;oacute;n correcta es comparar el valor directamente:</target>
        </trans-unit>
        <trans-unit id="9e1c8c9a0796fba24c5ae142d24dc8713fd92971" translate="yes" xml:space="preserve">
          <source>So what to do?</source>
          <target state="translated">Entonces,¿qué hacer?</target>
        </trans-unit>
        <trans-unit id="c4de3d5c3b3ce53f18295c6866165a0b386a0cc6" translate="yes" xml:space="preserve">
          <source>So, I guess the best way to check if something was undefined would be:</source>
          <target state="translated">Así que,supongo que la mejor manera de comprobar si algo estaba indefinido sería:</target>
        </trans-unit>
        <trans-unit id="62861616fb8499b1333e632d8f4f8c9d96d9ca16" translate="yes" xml:space="preserve">
          <source>So, for anyone who pass by, I will give you undefineds for free!!</source>
          <target state="translated">Así que,para cualquiera que pase por aquí,le daré indefinidamente gratis!!</target>
        </trans-unit>
        <trans-unit id="93c6077f6664588e7ec5fe7e874c0816d5e39229" translate="yes" xml:space="preserve">
          <source>Some common misconceptions about this include:</source>
          <target state="translated">Algunos conceptos erróneos comunes sobre esto incluyen:</target>
        </trans-unit>
        <trans-unit id="141f21882b084552acee073fca83c3cc0c42e7c8" translate="yes" xml:space="preserve">
          <source>Some scenarios illustrating the results of the various answers:
&lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</source>
          <target state="translated">Algunos escenarios que ilustran los resultados de varias respuestas: &lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5e2bb80f10dad7f8c5f9960cd6007b457637109" translate="yes" xml:space="preserve">
          <source>Something else to consider when it comes to object properties is whether you really want to check for &lt;code&gt;undefined&lt;/code&gt; at all. A given property name can be absent on an object (producing the value &lt;code&gt;undefined&lt;/code&gt; when read), present on the object itself with the value &lt;code&gt;undefined&lt;/code&gt;, present on the object&amp;rsquo;s prototype with the value &lt;code&gt;undefined&lt;/code&gt;, or present on either of those with a non-&lt;code&gt;undefined&lt;/code&gt; value. &lt;code&gt;'key' in obj&lt;/code&gt; will tell you whether a key is anywhere on an object&amp;rsquo;s prototype chain, and &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; will tell you whether it&amp;rsquo;s directly on the object. I won&amp;rsquo;t go into detail in this answer about prototypes and using objects as string-keyed maps, though, because it&amp;rsquo;s mostly intended to counter all the bad advice in other answers irrespective of the possible interpretations of the original question. Read up on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;object prototypes on MDN&lt;/a&gt; for more!</source>
          <target state="translated">Algo m&amp;aacute;s a tener en cuenta cuando se trata de propiedades de objeto es si realmente desea verificar si no est&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; . Un nombre de propiedad dado puede estar ausente en un objeto (produciendo el valor &lt;code&gt;undefined&lt;/code&gt; cuando se lee), presente en el objeto mismo con el valor &lt;code&gt;undefined&lt;/code&gt; , presente en el prototipo del objeto con el valor &lt;code&gt;undefined&lt;/code&gt; , o presente en cualquiera de aquellos con un no &lt;code&gt;undefined&lt;/code&gt; valor. &lt;code&gt;'key' in obj&lt;/code&gt; le dir&amp;aacute; si una clave est&amp;aacute; en alg&amp;uacute;n lugar de la cadena de prototipos de un objeto, y &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; le dir&amp;aacute; si est&amp;aacute; directamente en el objeto. Sin embargo, no entrar&amp;eacute; en detalles en esta respuesta sobre los prototipos y el uso de objetos como mapas con clave de cadena, porque est&amp;aacute; destinado principalmente a contrarrestar todos los malos consejos en otras respuestas, independientemente de las posibles interpretaciones de la pregunta original. &amp;iexcl;Lea m&amp;aacute;s sobre &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;prototipos de objetos en MDN&lt;/a&gt; para m&amp;aacute;s!</target>
        </trans-unit>
        <trans-unit id="09414607443b3c66a48d7b3cc8690784e89229ef" translate="yes" xml:space="preserve">
          <source>That's how the famous function &lt;code&gt;isUndefined()&lt;/code&gt; in AngularJs v.1x is written:</source>
          <target state="translated">As&amp;iacute; es como se &lt;code&gt;isUndefined()&lt;/code&gt; la famosa funci&amp;oacute;n Indefinida () en AngularJs v.1x:</target>
        </trans-unit>
        <trans-unit id="1d798e4166272be66a0741b99698bc5ab930a831" translate="yes" xml:space="preserve">
          <source>The JavaScript engine will give you an error if you have misspelled &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">El motor de JavaScript le dar&amp;aacute; un error si ha escrito mal &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="656b5d05c99fef961580b61f3edcaf330a6d66b8" translate="yes" xml:space="preserve">
          <source>The global variable &lt;em&gt;myvar&lt;/em&gt; is the same as &lt;em&gt;window.myvar&lt;/em&gt; or &lt;em&gt;window['myvar']&lt;/em&gt;</source>
          <target state="translated">La variable global &lt;em&gt;myvar&lt;/em&gt; es la misma que &lt;em&gt;window.myvar&lt;/em&gt; o &lt;em&gt;window ['myvar']&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29914467b1012003b3afd9aaffdcc32d8b458da1" translate="yes" xml:space="preserve">
          <source>The issue boils down to three cases:</source>
          <target state="translated">El asunto se reduce a tres casos:</target>
        </trans-unit>
        <trans-unit id="8f19ead080cc475b112d23d1a87b473d84ebf23e" translate="yes" xml:space="preserve">
          <source>The most robust way to perform this test is:</source>
          <target state="translated">La forma más robusta de realizar esta prueba es:</target>
        </trans-unit>
        <trans-unit id="195e6d98a22addf60a5f15d53507e42b6d225705" translate="yes" xml:space="preserve">
          <source>The object does not have the property.</source>
          <target state="translated">El objeto no tiene la propiedad.</target>
        </trans-unit>
        <trans-unit id="af4e3304635702004a3bc294a84b85b272ed0251" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">El objeto tiene la propiedad y su valor &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido .</target>
        </trans-unit>
        <trans-unit id="0000fbbbec8c44ca2bc7134d63869dbf22df5843" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is not &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">El objeto tiene la propiedad y su valor no est&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f12e6a8e8479790bcfba92ce8e2bdb1c0b5a2c71" translate="yes" xml:space="preserve">
          <source>The question if a variable really exists doesn't matter, its value is incorrect. Otherwise, it is silly to initialize variables with undefined, and it is better use the value false to initialize. When you know that all variables that you declare are initialized with false, you can simply check its type or rely on &lt;code&gt;!window.myvar&lt;/code&gt; to check if it has a proper/valid value. So even when the variable is not defined then &lt;code&gt;!window.myvar&lt;/code&gt; is the same for &lt;code&gt;myvar = undefined&lt;/code&gt; or &lt;code&gt;myvar = false&lt;/code&gt; or &lt;code&gt;myvar = 0&lt;/code&gt;.</source>
          <target state="translated">La pregunta si realmente existe una variable no importa, su valor es incorrecto. De lo contrario, es una tonter&amp;iacute;a inicializar variables con indefinido, y es mejor usar el valor falso para inicializar. Cuando sepa que todas las variables que declara se inicializan con falso, simplemente puede verificar su tipo o confiar en &lt;code&gt;!window.myvar&lt;/code&gt; para verificar si tiene un valor adecuado / v&amp;aacute;lido. Entonces, incluso cuando la variable no est&amp;aacute; definida &lt;code&gt;!window.myvar&lt;/code&gt; es igual para &lt;code&gt;myvar = undefined&lt;/code&gt; o &lt;code&gt;myvar = false&lt;/code&gt; o &lt;code&gt;myvar = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c187da4b16a273b05320f38b78197032e5f666" translate="yes" xml:space="preserve">
          <source>The solution is incorrect. In JavaScript,</source>
          <target state="translated">La solución es incorrecta.En JavaScript,</target>
        </trans-unit>
        <trans-unit id="99c5e812eeb793c06c61ae79d6ce567d31253c67" translate="yes" xml:space="preserve">
          <source>The void operator is a third alternative.</source>
          <target state="translated">El operador del vacío es una tercera alternativa.</target>
        </trans-unit>
        <trans-unit id="2624b916bf01c722be8fb21993d9edd3842b5f8d" translate="yes" xml:space="preserve">
          <source>Then use:</source>
          <target state="translated">Entonces úsalo:</target>
        </trans-unit>
        <trans-unit id="c306c1e05cc386f4fb986ead9800e3cb51d7d7ac" translate="yes" xml:space="preserve">
          <source>There is a nice &amp;amp; elegant way to assign a defined property to a new variable if it is defined or assign a default value to it as a fallback if it&amp;acute;s undefined.</source>
          <target state="translated">Hay una manera agradable y elegante de asignar una propiedad definida a una nueva variable si est&amp;aacute; definida o asignarle un valor predeterminado como reserva si no est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="909331b017c727d6b638a10340bcfa91fc4e0156" translate="yes" xml:space="preserve">
          <source>There is also a similar value, null, whose meaning is 'this value is defined, but it does not have a value'. The difference in meaning between undefined and null is mostly academic, and usually not very interesting. &lt;strong&gt;In practical programs, it is often necessary to check whether something 'has a value'. In these cases, the expression something == undefined may be used, because, even though they are not exactly the same value, null == undefined will produce true.&lt;/strong&gt;</source>
          <target state="translated">Tambi&amp;eacute;n hay un valor similar, nulo, cuyo significado es 'este valor est&amp;aacute; definido, pero no tiene un valor'. La diferencia de significado entre indefinido y nulo es principalmente acad&amp;eacute;mica, y generalmente no muy interesante. &lt;strong&gt;En los programas pr&amp;aacute;cticos, a menudo es necesario verificar si algo 'tiene un valor'.&lt;/strong&gt; &lt;strong&gt;En estos casos, se puede usar la expresi&amp;oacute;n algo == undefined, porque, aunque no son exactamente el mismo valor, null == undefined producir&amp;aacute; verdadero.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="066374c5c4c92cd26ce46b50a318fdbc81da8197" translate="yes" xml:space="preserve">
          <source>There is one error I need to defend.
If the args to the rest call were incorrect as far as the user specifying the args wrong, the rest call comes back basically empty.</source>
          <target state="translated">Hay un error que necesito defender.Si los args de la llamada de descanso eran incorrectos en cuanto al usuario que especificaba los args equivocados,la llamada de descanso vuelve básicamente vacía.</target>
        </trans-unit>
        <trans-unit id="4a1c97843ddae12e312165772ba1724256c18040" translate="yes" xml:space="preserve">
          <source>This forbids anyone to change the &lt;code&gt;window.undefined&lt;/code&gt; value therefore destroying the code based on that variable. If using &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;, anything trying to change its value will end in error, otherwise it would be silently ignored.</source>
          <target state="translated">Esto proh&amp;iacute;be que cualquiera cambie el valor de &lt;code&gt;window.undefined&lt;/code&gt; , por lo tanto, destruye el c&amp;oacute;digo basado en esa variable. Si usa &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; , cualquier cosa que intente cambiar su valor terminar&amp;aacute; en un error, de lo contrario ser&amp;iacute;a ignorado en silencio.</target>
        </trans-unit>
        <trans-unit id="206b6848288b0371c75a01e649b5ef1c02732df1" translate="yes" xml:space="preserve">
          <source>This tells us something I consider important:</source>
          <target state="translated">Esto nos dice algo que considero importante:</target>
        </trans-unit>
        <trans-unit id="882cd19a028fc5fdf4ac576781232fd9fb438143" translate="yes" xml:space="preserve">
          <source>This will always return the correct result, and even handles the situation where &lt;code&gt;myVar&lt;/code&gt; is not declared.</source>
          <target state="translated">Esto siempre devolver&amp;aacute; el resultado correcto e incluso maneja la situaci&amp;oacute;n en la que &lt;code&gt;myVar&lt;/code&gt; no se declara.</target>
        </trans-unit>
        <trans-unit id="65d3b63892021dfc610049dfe83bb84e542216eb" translate="yes" xml:space="preserve">
          <source>This worked for me while the others didn't.</source>
          <target state="translated">Esto funcionó para mí mientras que los otros no.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="1156bb5b9c53b338e90526a8c3e0f9157c2cdd5d" translate="yes" xml:space="preserve">
          <source>To avoid errors to test when a global variable exists, you better use:</source>
          <target state="translated">Para evitar errores al probar cuando existe una variable global,es mejor usar:</target>
        </trans-unit>
        <trans-unit id="af5a50ed0ca791f35da42bf271615ae60f9119f4" translate="yes" xml:space="preserve">
          <source>To be bullet-proof, simply use:</source>
          <target state="translated">Para ser a prueba de balas,simplemente use:</target>
        </trans-unit>
        <trans-unit id="a3733768c50f085f705798790041179dcb01dd51" translate="yes" xml:space="preserve">
          <source>Too bad that this been the right answer is buried in wrong answers &amp;gt;_&amp;lt;</source>
          <target state="translated">L&amp;aacute;stima que esta haya sido la respuesta correcta est&amp;aacute; enterrada en respuestas incorrectas&amp;gt; _ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2a836e46c13894957834965487f79f243bd458f6" translate="yes" xml:space="preserve">
          <source>Try to get a property of the input value, check the error message if it exists. If the input value is undefined, the error message would be &lt;em&gt;Uncaught TypeError: Cannot read property 'b' of undefined&lt;/em&gt;</source>
          <target state="translated">Intente obtener una propiedad del valor de entrada, verifique el mensaje de error si existe. Si el valor de entrada es indefinido, el mensaje de error ser&amp;iacute;a &lt;em&gt;Tipo de&lt;/em&gt; error no &lt;em&gt;capturado: no se puede leer la propiedad 'b' de indefinido&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31c8242d038a57a98e29aa92351bb4eeba57a99f" translate="yes" xml:space="preserve">
          <source>Underscore.js:</source>
          <target state="translated">Underscore.js:</target>
        </trans-unit>
        <trans-unit id="624f88833e4aa36d20755eda53fb498e36cc6d82" translate="yes" xml:space="preserve">
          <source>Update (for server-side JavaScript):</source>
          <target state="translated">Actualización (para JavaScript del lado del servidor):</target>
        </trans-unit>
        <trans-unit id="0a8d800169d3f3a27add31e922bf0bca161dd01d" translate="yes" xml:space="preserve">
          <source>Update 9/9/2019</source>
          <target state="translated">Actualización 992019</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="ca3566d6d324a104499679565f550124050f47c6" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;undefined&lt;/code&gt; is a global variable (so actually it is &lt;code&gt;window.undefined&lt;/code&gt; in browsers). It has been supported since ECMAScript 1st Edition and since ECMAScript 5 it is &lt;strong&gt;read only&lt;/strong&gt;. So in modern browsers it can't be &lt;em&gt;redefined to true&lt;/em&gt; as many authors love to frighten us with, but this is still a true for older browsers.</source>
          <target state="translated">La variable &lt;code&gt;undefined&lt;/code&gt; es una variable global (por lo que en realidad es &lt;code&gt;window.undefined&lt;/code&gt; en los navegadores). Se admite desde ECMAScript 1st Edition y desde ECMAScript 5 es de &lt;strong&gt;solo lectura&lt;/strong&gt; . Por lo tanto, en los navegadores modernos no se puede &lt;em&gt;redefinir&lt;/em&gt; como &lt;em&gt;verdadero,&lt;/em&gt; ya que a muchos autores les encanta asustarnos, pero esto sigue siendo cierto para los navegadores m&amp;aacute;s antiguos.</target>
        </trans-unit>
        <trans-unit id="aa644c9b6d28b03bec73d65a8433d912ec0dc967" translate="yes" xml:space="preserve">
          <source>We can clearly see that &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; and &lt;code&gt;obj.prop === undefined&lt;/code&gt; are equivalent, and they do not distinguish those different situations. And &lt;code&gt;'prop' in obj&lt;/code&gt; can detect the situation when a property hasn't been defined at all and doesn't pay attention to the property value which may be undefined.</source>
          <target state="translated">Podemos ver claramente que &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; y &lt;code&gt;obj.prop === undefined&lt;/code&gt; son equivalentes, y no distinguen esas diferentes situaciones. Y &lt;code&gt;'prop' in obj&lt;/code&gt; puede detectar la situaci&amp;oacute;n cuando una propiedad no se ha definido en absoluto y no presta atenci&amp;oacute;n al valor de la propiedad que puede estar indefinido.</target>
        </trans-unit>
        <trans-unit id="b4348ecc1522f37bea2a74798eccb1c698101bae" translate="yes" xml:space="preserve">
          <source>What I am saying is that for my situation, all the suggestions above in this post did not work.  I'm not saying I'm right and everyone is wrong.  I am not a JavaScript master at all, but hopefully this will help someone.</source>
          <target state="translated">Lo que estoy diciendo es que para mi situación,todas las sugerencias anteriores en este post no funcionaron.No estoy diciendo que yo tenga razón y que todos estén equivocados.No soy un maestro de JavaScript en absoluto,pero espero que esto ayude a alguien.</target>
        </trans-unit>
        <trans-unit id="6c6a10825c9a1a5ecbcd512402eb30eb39482e71" translate="yes" xml:space="preserve">
          <source>What does this mean: &lt;strong&gt;&quot;undefined object property&quot;&lt;/strong&gt;?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; significa esto: &lt;strong&gt;&quot;propiedad de objeto indefinido&quot;&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="86d7d00a77d485aef47636c622133ba6e079f28d" translate="yes" xml:space="preserve">
          <source>What's the best way of checking if an object property in JavaScript is &lt;code&gt;undefined&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la mejor manera de verificar si una propiedad de objeto en JavaScript &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definida ?</target>
        </trans-unit>
        <trans-unit id="6a44c70b62e1f951bfff4ad714a3bf6f9c36a141" translate="yes" xml:space="preserve">
          <source>When the first and simple condition is true, the interpreter skips the next tests.</source>
          <target state="translated">Cuando la primera y simple condición es cierta,el intérprete se salta las siguientes pruebas.</target>
        </trans-unit>
        <trans-unit id="b7221864517c5c211586a94530d68cdcfc6ea425" translate="yes" xml:space="preserve">
          <source>When you expect a specific type, test the type of the variable. To speed up testing a condition you better do:</source>
          <target state="translated">Cuando esperes un tipo específico,prueba el tipo de la variable.Para acelerar la prueba de una condición es mejor que lo hagas:</target>
        </trans-unit>
        <trans-unit id="d60051b913c76582de7e88350c42134161b10c93" translate="yes" xml:space="preserve">
          <source>Which also equal to isDefined in Angular 1.x...</source>
          <target state="translated">Que también es igual a la definición de Angular 1.x...</target>
        </trans-unit>
        <trans-unit id="88ec2543321a88029f849108c87daeb5587d1c2d" translate="yes" xml:space="preserve">
          <source>Which was clearer when written without a check for undefined.</source>
          <target state="translated">Lo cual era más claro cuando se escribía sin un cheque para lo indefinido.</target>
        </trans-unit>
        <trans-unit id="5b51b27fa3903d28d3f04b6c171ad09973278eb9" translate="yes" xml:space="preserve">
          <source>While using this post to help me defend against this, I tried this.</source>
          <target state="translated">Mientras usaba este poste para ayudarme a defenderme de esto,intenté esto.</target>
        </trans-unit>
        <trans-unit id="e71f039272b0f0e068195d6015ac5f2784fca83b" translate="yes" xml:space="preserve">
          <source>With how variables work out of the way, it&amp;rsquo;s time to address the actual question: object properties. There is no reason to ever use &lt;code&gt;typeof&lt;/code&gt; for object properties. The earlier exception regarding feature detection doesn&amp;rsquo;t apply here &amp;ndash; &lt;code&gt;typeof&lt;/code&gt; only has special behaviour on variables, and expressions that reference object properties are not variables.</source>
          <target state="translated">Con el funcionamiento de las variables, es hora de abordar la pregunta real: las propiedades del objeto. No hay raz&amp;oacute;n para usar &lt;code&gt;typeof&lt;/code&gt; para las propiedades del objeto. La excepci&amp;oacute;n anterior con respecto a la detecci&amp;oacute;n de caracter&amp;iacute;sticas no se aplica aqu&amp;iacute;: &lt;code&gt;typeof&lt;/code&gt; solo tiene un comportamiento especial en las variables, y las expresiones que hacen referencia a las propiedades del objeto no son variables.</target>
        </trans-unit>
        <trans-unit id="fdb6add32a76812e71fb836b3a0175d29a715c41" translate="yes" xml:space="preserve">
          <source>You can get an array all undefined with path using the following code.</source>
          <target state="translated">Puedes obtener una matriz toda indefinida con la ruta usando el siguiente código.</target>
        </trans-unit>
        <trans-unit id="fd195a5d241f7801da7590d49a101b3417b1d020" translate="yes" xml:space="preserve">
          <source>You can use undefined and the strict equality and inequality operators to determine whether a variable has
  a value. In the following code, the variable x is not defined, and the
  if statement evaluates to true.</source>
          <target state="translated">Puede utilizar los operadores de indefinición y los de igualdad y desigualdad estricta para determinar si una variable tiene un valor.En el siguiente código,la variable x no está definida,y la declaración if evalúa a true.</target>
        </trans-unit>
        <trans-unit id="8bd945be1ad955926cb0576570ca86d427690000" translate="yes" xml:space="preserve">
          <source>You can't check an object and its property at the same time. For example, this &lt;code&gt;x.a === undefined&lt;/code&gt; or this &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; raises &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; if x is not defined.</source>
          <target state="translated">No puede verificar un objeto y su propiedad al mismo tiempo. Por ejemplo, este &lt;code&gt;x.a === undefined&lt;/code&gt; o este tipo de &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; genera &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; si x no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="afb57f9c5e1cd65cb89577ac225085a571888c95" translate="yes" xml:space="preserve">
          <source>and taking into account the advice above, to avoid confusing readers as to why you&amp;rsquo;re using &lt;code&gt;typeof&lt;/code&gt;, because it makes the most sense to use &lt;code&gt;===&lt;/code&gt; to check for equality, because it could be refactored to checking a variable&amp;rsquo;s value later, and because it just plain looks better, &lt;strong&gt;you should always use &lt;code&gt;=== undefined&lt;/code&gt;&amp;sup3; here as well&lt;/strong&gt;.</source>
          <target state="translated">y teniendo en cuenta los consejos anteriores, para evitar confundir a los lectores en cuanto a por qu&amp;eacute; est&amp;aacute; usando &lt;code&gt;typeof&lt;/code&gt; , porque tiene m&amp;aacute;s sentido usar &lt;code&gt;===&lt;/code&gt; para verificar la igualdad, porque podr&amp;iacute;a refactorizarse para verificar el valor de una variable m&amp;aacute;s adelante, y porque simplemente se ve mejor, &lt;strong&gt;siempre debe usar &lt;code&gt;=== undefined&lt;/code&gt; &amp;sup3; aqu&amp;iacute; tambi&amp;eacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d105f7494e87ab388edea0f7b8c3a73720d04c6" translate="yes" xml:space="preserve">
          <source>and we check them as below, you can see the results in front of them as a comment:</source>
          <target state="translated">y los comprobamos como abajo,puedes ver los resultados delante de ellos como un comentario:</target>
        </trans-unit>
        <trans-unit id="1a3490def710ea1d24edc82b74a46f9764b33bda" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;always exactly equivalent&lt;/em&gt; to this&amp;sup3;:</source>
          <target state="translated">&lt;em&gt;siempre&lt;/em&gt; es &lt;em&gt;exactamente equivalente&lt;/em&gt; a esto&amp;sup3;:</target>
        </trans-unit>
        <trans-unit id="4778deb55d8cd5675a499ac484ad2ef5c74ec10c" translate="yes" xml:space="preserve">
          <source>isUndefined1:</source>
          <target state="translated">isUndefined1:</target>
        </trans-unit>
        <trans-unit id="15fa6dc48f1d00cd33b8f768892cc3b8131f1bbb" translate="yes" xml:space="preserve">
          <source>isUndefined2:</source>
          <target state="translated">isUndefined2:</target>
        </trans-unit>
        <trans-unit id="c871adbf9668a35abe539aa06d9c0dafaf3ce3ee" translate="yes" xml:space="preserve">
          <source>isUndefined3:</source>
          <target state="translated">isUndefined3:</target>
        </trans-unit>
        <trans-unit id="8ac534c595dd379491a89bb14380a533170408b9" translate="yes" xml:space="preserve">
          <source>it will fail when the variable &lt;code&gt;myvar&lt;/code&gt; does not exists, because myvar is not defined, so the script is broken and the test has no effect.</source>
          <target state="translated">fallar&amp;aacute; cuando la variable &lt;code&gt;myvar&lt;/code&gt; no exista, porque myvar no est&amp;aacute; definida, por lo que el script se rompe y la prueba no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="985aa8a699702f412ce09aab8fceeb541def9317" translate="yes" xml:space="preserve">
          <source>more &amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">m&amp;aacute;s&amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b79ab4d893a4264fa8785737934a4d1503cc8e5" translate="yes" xml:space="preserve">
          <source>so you will use it like:</source>
          <target state="translated">así que lo usarás como:</target>
        </trans-unit>
        <trans-unit id="157d0448c1dd7a8c6cfeab738ffaa2775caae49d" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;undefined&lt;/code&gt; can be overwritten. There&amp;rsquo;s a lot more to this. &lt;code&gt;undefined&lt;/code&gt; is not a keyword in JavaScript. Instead, it&amp;rsquo;s a property on the global object with the Undefined value. However, since ES5, this property has been &lt;em&gt;read-only&lt;/em&gt; and &lt;em&gt;non-configurable&lt;/em&gt;. No modern browser will allow the &lt;code&gt;undefined&lt;/code&gt; property to be changed, and as of 2017 this has been the case for a long time. Lack of strict mode doesn&amp;rsquo;t affect &lt;code&gt;undefined&lt;/code&gt;&amp;rsquo;s behaviour either &amp;ndash; it just makes statements like &lt;code&gt;undefined = 5&lt;/code&gt; do nothing instead of throwing. Since it isn&amp;rsquo;t a keyword, though, you can &lt;em&gt;declare&lt;/em&gt; variables with the name &lt;code&gt;undefined&lt;/code&gt;, and those variables could be changed, making this once-common pattern:</source>
          <target state="translated">eso &lt;code&gt;undefined&lt;/code&gt; puede sobrescribirse. Hay mucho m&amp;aacute;s en esto. &lt;code&gt;undefined&lt;/code&gt; no es una palabra clave en JavaScript. En cambio, es una propiedad en el objeto global con el valor Indefinido. Sin embargo, desde ES5, esta propiedad ha sido &lt;em&gt;de solo lectura&lt;/em&gt; y &lt;em&gt;no configurable&lt;/em&gt; . Ning&amp;uacute;n navegador moderno permitir&amp;aacute; cambiar la propiedad &lt;code&gt;undefined&lt;/code&gt; , y desde 2017 este ha sido el caso durante mucho tiempo. La falta de modo estricto tampoco afecta el comportamiento &lt;code&gt;undefined&lt;/code&gt; , solo hace que declaraciones como &lt;code&gt;undefined = 5&lt;/code&gt; no hagan nada en lugar de arrojar. Sin embargo, dado que no es una palabra clave, puede &lt;em&gt;declarar&lt;/em&gt; variables con el nombre &lt;code&gt;undefined&lt;/code&gt; , y esas variables podr&amp;iacute;an cambiarse, haciendo este patr&amp;oacute;n una vez com&amp;uacute;n:</target>
        </trans-unit>
        <trans-unit id="0793e2c88390a29b1957e9039867ab8ffb4111d4" translate="yes" xml:space="preserve">
          <source>that reading an &amp;ldquo;uninitialized&amp;rdquo; variable (&lt;code&gt;var foo&lt;/code&gt;) or parameter (&lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt;, called as &lt;code&gt;bar()&lt;/code&gt;) will fail. This is simply not true &amp;ndash; variables without explicit initialization and parameters that weren&amp;rsquo;t given values always become &lt;code&gt;undefined&lt;/code&gt;, and are always in scope.</source>
          <target state="translated">que la lectura de una variable &quot;no inicializada&quot; ( &lt;code&gt;var foo&lt;/code&gt; ) o par&amp;aacute;metro ( &lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt; , llamada como &lt;code&gt;bar()&lt;/code&gt; ) fallar&amp;aacute;. Esto simplemente no es cierto: las variables sin inicializaci&amp;oacute;n expl&amp;iacute;cita y los par&amp;aacute;metros a los que no se les dieron valores siempre se vuelven &lt;code&gt;undefined&lt;/code&gt; y siempre est&amp;aacute;n dentro del alcance.</target>
        </trans-unit>
        <trans-unit id="36867f049a149d6504389c0dac25fc3f11212dfd" translate="yes" xml:space="preserve">
          <source>which is the identity operator...</source>
          <target state="translated">que es el operador de identidad...</target>
        </trans-unit>
        <trans-unit id="e0cafe396bcf72dbf7b9b4bc907e035155d2be4e" translate="yes" xml:space="preserve">
          <source>will return true, because they both are &quot;casted&quot; to a boolean and are false. The correct way would be to check</source>
          <target state="translated">volverá verdadero,porque ambos están &quot;fundidos&quot; a un booleano y son falsos.La forma correcta sería comprobar</target>
        </trans-unit>
        <trans-unit id="786ca9a6ff480fa14542ee13006ae5e448160486" translate="yes" xml:space="preserve">
          <source>you can also use Proxy, it will work with nested calls, but will require one extra check:</source>
          <target state="translated">también puedes usar el Proxy,funcionará con llamadas anidadas,pero requerirá un cheque extra:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
