<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/27509">
    <body>
      <group id="27509">
        <trans-unit id="9b76c7ee3ed3b22fe6b40e7d1df6c18824b37a8f" translate="yes" xml:space="preserve">
          <source>'&lt;em&gt;if (window.x) { }&lt;/em&gt;' is error safe</source>
          <target state="translated">' &lt;em&gt;if (window.x) {}&lt;/em&gt; '는 오류 안전</target>
        </trans-unit>
        <trans-unit id="7afec1ce47ff900682bd7a527552baf0b3f48e7e" translate="yes" xml:space="preserve">
          <source>(y)</source>
          <target state="translated">(y)</target>
        </trans-unit>
        <trans-unit id="1963f681a0dc2983468889df82f1affdbe4cb8ed" translate="yes" xml:space="preserve">
          <source>1) You want to know if a property is undefined by either the first or second meaning (the most typical situation).</source>
          <target state="translated">1) 속성이 첫 번째 또는 두 번째 의미 (가장 일반적인 상황)에 의해 정의되지 않았는지 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="2eff931c0d1f6eda47f88e36e5e2ca665e39f0b0" translate="yes" xml:space="preserve">
          <source>2) You want to just know if object has some property and don't care about its value.</source>
          <target state="translated">2) 객체에 속성이 있고 그 값에 신경 쓰지 않는지 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="d95915c48ebcaada4c615be17c20592ad7a87e7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt; link</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/anoop26667/9XbEK/&quot;&gt;jsFiddle&lt;/a&gt; 링크</target>
        </trans-unit>
        <trans-unit id="f3c686407b77ca61732d9533437b84cc6af2398a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'undefned'&lt;/code&gt; (&lt;em&gt;misspelled&lt;/em&gt;) here is just a string constant, so the JavaScript engine can't help you if you have misspelled it like I just did.</source>
          <target state="translated">&lt;code&gt;'undefned'&lt;/code&gt; ( &lt;em&gt;철자가 틀린&lt;/em&gt; )는 문자열 상수이므로 방금했던 것처럼 철자가 틀린 경우 JavaScript 엔진이 도움을 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66262b2e58df668340e9c997b4fcbb22d477d689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; can be overridden in old browsers</source>
          <target state="translated">오래된 브라우저에서는 &lt;code&gt;undefined&lt;/code&gt; 를 무시할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9c0eca093d608d52888040610ad0fea09fe42fae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Note that the use of &lt;code&gt;var&lt;/code&gt; for &lt;code&gt;in&lt;/code&gt; tests make a difference when in a scoped wrapper)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(범위가 지정된 래퍼 &lt;code&gt;in&lt;/code&gt; 테스트 에서 &lt;code&gt;var&lt;/code&gt; 를 사용하면 차이가 있습니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5812b0fa88241095ef998b82d3c2929c6f31055" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Specific to this question, see test cases with &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 질문과 관련하여 &lt;code&gt;someObject.&amp;lt;whatever&amp;gt;&lt;/code&gt; 의 테스트 사례를 참조하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b325ccf6a947861f6e178afd3921cc763cca384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;more&lt;/em&gt; dangerous than using the global &lt;code&gt;undefined&lt;/code&gt;. If you have to be ES3-compatible, replace &lt;code&gt;undefined&lt;/code&gt; with &lt;code&gt;void 0&lt;/code&gt; &amp;ndash; don&amp;rsquo;t resort to &lt;code&gt;typeof&lt;/code&gt;. (&lt;code&gt;void&lt;/code&gt; has always been a unary operator that evaluates to the Undefined value for any operand.)</source>
          <target state="translated">전역 &lt;code&gt;undefined&lt;/code&gt; 를 사용하는 것보다 &lt;em&gt;더&lt;/em&gt; 위험합니다. ES3와 호환되어야한다면 &lt;code&gt;undefined&lt;/code&gt; 를 &lt;code&gt;void 0&lt;/code&gt; 으로 바꾸십시오 &amp;ndash; &lt;code&gt;typeof&lt;/code&gt; 에 의존하지 마십시오. &lt;code&gt;void&lt;/code&gt; 는 항상 피연산자에 대해 정의되지 않은 값으로 평가되는 단항 연산자였습니다.</target>
        </trans-unit>
        <trans-unit id="d6d59c5f807d7ec4a037b85ca3c5e7f05986ccb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; In response to your edit, object properties should work the same way.</source>
          <target state="translated">&lt;strong&gt;편집 : 편집에&lt;/strong&gt; 대한 응답으로 객체 속성이 같은 방식으로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="19806bd40175fc10a877fea67f68c16ed7195667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strict equality and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;엄격한 평등과 정의되지 않은&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110d482d5dc176523e015517737b158007fd1e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is a difference between an undefined member and a defined member with an undefined value.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정의되지 않은 멤버와 정의되지 않은 값을 가진 정의 된 멤버간에 차이가 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f031e352cc2a0b3518c3a7f16759780f937d7a44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typeof operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;연산자 유형 및 정의되지 않음&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36bde56374a3373b2f73b61dde0097263e17ddb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Void operator and undefined&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;무효 연산자 및 정의되지 않음&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="427d8f959e87c1d0dffd229886fa52757ad009bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;null&lt;/strong&gt; means that the variable value is defined and set to null (has no value).</source>
          <target state="translated">&lt;strong&gt;null&lt;/strong&gt; 은 변수 값이 정의되고 null로 설정됨을 의미합니다 (값 없음).</target>
        </trans-unit>
        <trans-unit id="bec2062ef6d9e093a5eeb78377aa98519f789843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined&lt;/strong&gt; means that the variable value has not been defined; it is not known what the value is.</source>
          <target state="translated">&lt;strong&gt;undefined&lt;/strong&gt; 는 변수 값이 &lt;strong&gt;정의되지 않았 음을&lt;/strong&gt; 의미합니다. 값이 무엇인지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ef0f25ff59da22f20a9f581d372dd5532c68b8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;window&lt;/strong&gt; is an object which holds all global variables as its members, and it is legal to try to access a non-existing member. If &lt;strong&gt;x&lt;/strong&gt; hasn't been declared or hasn't been set then &lt;code&gt;window.x&lt;/code&gt; returns &lt;strong&gt;undefined&lt;/strong&gt;. &lt;strong&gt;undefined&lt;/strong&gt; leads to &lt;strong&gt;false&lt;/strong&gt; when &lt;strong&gt;if()&lt;/strong&gt; evaluates it.</source>
          <target state="translated">&lt;strong&gt;window&lt;/strong&gt; 는 모든 전역 변수를 멤버로 보유하는 객체이며 존재하지 않는 멤버에 액세스하는 것은 합법적입니다. &lt;strong&gt;x&lt;/strong&gt; 가 선언되지 않았거나 설정 &lt;strong&gt;되지 않은&lt;/strong&gt; 경우 &lt;code&gt;window.x&lt;/code&gt; 는 &lt;strong&gt;undefined를&lt;/strong&gt; 반환합니다. &lt;strong&gt;undefined&lt;/strong&gt; 는 &lt;strong&gt;if ()가&lt;/strong&gt; 평가할 때 &lt;strong&gt;false&lt;/strong&gt; 가 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f0196332640a9574b642791f69278e0108d64482" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup1; unusual choice of example variable name? this is real dead code from the NoScript extension for Firefox.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup1; 예제 변수 이름의 특이한 선택?&lt;/sub&gt; &lt;sub&gt;이것은 Firefox 용 NoScript 확장 프로그램의 실제 죽은 코드입니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="832763f5083c7d8a0f4ef0ca33f1a035e0a67dc1" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup2; don&amp;rsquo;t assume that not knowing what&amp;rsquo;s in scope is okay in general, though. bonus vulnerability caused by abuse of dynamic scope: &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&amp;sup2; 범위가 무엇인지 모르는 것이 일반적으로 괜찮다고 가정하지 마십시오.&lt;/sub&gt; &lt;sub&gt;동적 범위 남용으로 인한 보너스 취약점 : &lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&amp;amp;desc=6&quot;&gt;Project Zero 1225&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="84456406b0e70016bbb43249541eb7f735f005f4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&amp;sup3; once again assuming an ES5+ environment and that &lt;code&gt;undefined&lt;/code&gt; refers to the &lt;code&gt;undefined&lt;/code&gt; property of the global object. substitute &lt;code&gt;void 0&lt;/code&gt; otherwise.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;ES5 + 환경을 가정하고 &lt;code&gt;undefined&lt;/code&gt; 않았다고 가정하면 전역 객체의 &lt;code&gt;undefined&lt;/code&gt; 속성을 나타냅니다.&lt;/sub&gt; &lt;sub&gt;그렇지 않으면 &lt;code&gt;void 0&lt;/code&gt; 을 대체하십시오.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="58cef43f9cc148fe201f6a40aa751b0117edb0fa" translate="yes" xml:space="preserve">
          <source>Actually it can mean two quite different things! First, it can mean &lt;em&gt;the property that has never been defined&lt;/em&gt; in the object and, second, it can mean the &lt;em&gt;property that has an undefined value&lt;/em&gt;. Let's look at this code:</source>
          <target state="translated">실제로 그것은 두 가지 다른 것을 의미 할 수 있습니다! 첫째, 객체 &lt;em&gt;에 정의되지 않은 속성을&lt;/em&gt; 의미 할 수 있고, 둘째, &lt;em&gt;정의되지 않은 값을 갖는 속성을&lt;/em&gt; 의미 할 수 있습니다. 이 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="349ce103efd4c2fadb9a858b41201bbd6794a393" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;myVar === undefined&lt;/code&gt; will raise an error in the situation where myVar is undeclared.</source>
          <target state="translated">또한 &lt;code&gt;myVar === undefined&lt;/code&gt; 는 myVar가 선언되지 않은 상황에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="286d348194a35b840509a9c9d1227df8acbbd2ec" translate="yes" xml:space="preserve">
          <source>All the answers are incomplete. This is the right way of knowing that there is a property 'defined as undefined' :</source>
          <target state="translated">모든 답변이 불완전합니다. 이것은 '정의되지 않은 것으로 정의 된'속성이 있음을 아는 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f10c4fd9df413d69738977ff9f171b41d4667fe1" translate="yes" xml:space="preserve">
          <source>Also one more thing, for checking property on an object in a real application which you not sure even the object exists or not, check if the object exists first.</source>
          <target state="translated">또한 실제 응용 프로그램에서 객체가 존재하는지 확실하지 않은 객체의 속성을 확인하려면 객체가 먼저 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="219f34b6015e059105c29a26a98358fba3b56ee1" translate="yes" xml:space="preserve">
          <source>Also other javascript frameworks like underscore has similar defining check, but I recommend you use &lt;code&gt;typeof&lt;/code&gt; if you already not using any frameworks.</source>
          <target state="translated">또한 밑줄과 같은 다른 자바 스크립트 프레임 워크에는 유사한 정의 검사가 있지만 프레임 워크를 아직 사용하지 않는 경우 &lt;code&gt;typeof&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="791ed3302cfee030f9c8fa3bee23d8d3e1f0bc24" translate="yes" xml:space="preserve">
          <source>Alternatively, typeof can be used:</source>
          <target state="translated">또는 typeof를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b964d88fc95bd706292cbaa247b9c16e2755e4" translate="yes" xml:space="preserve">
          <source>And results:</source>
          <target state="translated">그리고 결과 :</target>
        </trans-unit>
        <trans-unit id="d83e8ed16ed58afb7ab32795cb6009ac31db06ab" translate="yes" xml:space="preserve">
          <source>As you see we can check anything with using something like this in our code, as mentioned you can simply use &lt;code&gt;typeof&lt;/code&gt; in your code, but if you are using it over and over, create a function like the angular sample which I share and keep reusing as following DRY code pattern.</source>
          <target state="translated">보시다시피 코드에서 이와 같은 것을 사용하여 모든 것을 확인할 수 있습니다. 언급 한 것처럼 코드에서 단순히 &lt;code&gt;typeof&lt;/code&gt; 를 사용할 수 있지만 반복해서 사용하는 경우 공유하고 재사용하는 각도 샘플과 같은 함수를 만듭니다. 다음과 같은 DRY 코드 패턴.</target>
        </trans-unit>
        <trans-unit id="87f10ffef733699e5454e0973b6bbcf28272a26a" translate="yes" xml:space="preserve">
          <source>Because the window object has a global scope (default object) outside a function, a declaration will be 'attached' to the window object.</source>
          <target state="translated">창 개체는 함수 외부에 전역 범위 (기본 개체)가 있으므로 선언은 창 개체에 '첨부'됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6b520b68a6505ce09b8eb40967aa50ccdc1dcc" translate="yes" xml:space="preserve">
          <source>But as has been mentioned these are not exactly the same (but are more than good enough for my needs).</source>
          <target state="translated">그러나 언급했듯이 이것들은 정확히 동일하지는 않습니다 (그러나 내 필요에 충분합니다).</target>
        </trans-unit>
        <trans-unit id="fcfbf2fbae71c2369946c84ef809e8845fa289d8" translate="yes" xml:space="preserve">
          <source>But unhappily &lt;code&gt;typeof obj.foo&lt;/code&gt; does not tell us which of the three cases we have. However we can combine this with &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; to distinguish the cases.</source>
          <target state="translated">그러나 불행하게도 &lt;code&gt;typeof obj.foo&lt;/code&gt; 은 우리가 가지고있는 세 가지 경우를 알려주지 않습니다. 그러나 &lt;code&gt;&quot;foo&quot; in obj&lt;/code&gt; 이를 &quot;foo&quot; 와 결합하여 사례를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1daf4b17726ef0dab632dbab9c7df1fe0d5f44a0" translate="yes" xml:space="preserve">
          <source>Code for reference:</source>
          <target state="translated">참조 코드 :</target>
        </trans-unit>
        <trans-unit id="fd83e3fc07c2d36f7a50c3554edc7779b39383e8" translate="yes" xml:space="preserve">
          <source>Commonly, people have asked me for an algorithm to figure out if a value is either falsy, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;. The following works.</source>
          <target state="translated">일반적으로 사람들은 값이 falsy, &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 인지 알아낼 알고리즘을 요청했습니다. 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="40c624d52a56db62dd4208fe5347d5d97cd36d54" translate="yes" xml:space="preserve">
          <source>Compare with &lt;code&gt;void 0&lt;/code&gt;, for terseness.</source>
          <target state="translated">간결함을 위해 &lt;code&gt;void 0&lt;/code&gt; 과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="3e55bf53313fd9840391bfd75f5d5b1153e71e7c" translate="yes" xml:space="preserve">
          <source>Convert input value to string to compare with &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; and ensure it's negative value.</source>
          <target state="translated">&lt;code&gt;&quot;undefined&quot;&lt;/code&gt; 과 비교하기 위해 입력 값을 문자열로 변환하고 음수인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e38b4ae3f7cb873e402c0c020e6e974a8e377719" translate="yes" xml:space="preserve">
          <source>Correct Code</source>
          <target state="translated">올바른 코드</target>
        </trans-unit>
        <trans-unit id="bbf717127e889535958ab6c66e7ca4d538373008" translate="yes" xml:space="preserve">
          <source>Crossposting my &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;answer&lt;/a&gt; from related question &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;How to check for &quot;undefined&quot; in JavaScript?&lt;/a&gt;</source>
          <target state="translated">관련 질문에 대한 &lt;a href=&quot;https://stackoverflow.com/a/14305002/1037948&quot;&gt;답변&lt;/a&gt; 을 크로스 포스트 &lt;a href=&quot;https://stackoverflow.com/questions/3390396/how-to-check-for-undefined-in-javascript/&quot;&gt;하는 방법 JavaScript에서 &quot;정의되지 않음&quot;을 확인하는 방법은 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e2c55e17d9d063d6e819462c4f293237ba47eba" translate="yes" xml:space="preserve">
          <source>Defined as a falsy value, undefined,null, or never defined.</source>
          <target state="translated">허위 값, 정의되지 않음, 널 또는 절대 정의되지 않음으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f4c589078846130bd5d8f8b014b127005e460131" translate="yes" xml:space="preserve">
          <source>Defined as undefined Or never Defined</source>
          <target state="translated">정의되지 않은 또는 정의되지 않은 것으로 정의</target>
        </trans-unit>
        <trans-unit id="71177ce1bd442c1e211b610b3ce841a27b46d68f" translate="yes" xml:space="preserve">
          <source>Degenerate code. DO NOT USE.</source>
          <target state="translated">코드를 줄입니다. 사용하지 마세요.</target>
        </trans-unit>
        <trans-unit id="5e35f4620392124dd0fdbc52a3c5eb05fbd9f75d" translate="yes" xml:space="preserve">
          <source>Despite being vehemently recommended by many other answers here, &lt;code&gt;typeof&lt;/code&gt;&lt;em&gt;is a bad choice&lt;/em&gt;. It should never be used for checking whether variables have the value &lt;code&gt;undefined&lt;/code&gt;, because it acts as a combined check for the value &lt;code&gt;undefined&lt;/code&gt; and for whether a variable exists. In the vast majority of cases, you know when a variable exists, and &lt;code&gt;typeof&lt;/code&gt; will just introduce the potential for a silent failure if you make a typo in the variable name or in the string literal &lt;code&gt;'undefined'&lt;/code&gt;.</source>
          <target state="translated">여기에 많은 다른 답변이 강력하게 추천했지만 &lt;code&gt;typeof&lt;/code&gt; &lt;em&gt;는 나쁜 선택&lt;/em&gt; 입니다. 변수가 &lt;code&gt;undefined&lt;/code&gt; 값을 갖는지 여부를 확인하는 데 사용해서는 안됩니다. 변수가 undefined 값과 변수가 있는지 여부를 종합적으로 검사하는 역할을하기 때문입니다. 대부분의 경우 변수가 존재하는시기를 알고 있으며 변수 이름이나 문자열 리터럴 &lt;code&gt;'undefined'&lt;/code&gt; 에 오타를 입력하면 &lt;code&gt;typeof&lt;/code&gt; 가 자동 실패 가능성을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="09909cfd981fdef3626ccc9834d9448da9e9745f" translate="yes" xml:space="preserve">
          <source>Detecting an undefined object property</source>
          <target state="translated">정의되지 않은 객체 속성 감지</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="58abfcd5560647f71db6174e6dae2c1d7b00956b" translate="yes" xml:space="preserve">
          <source>Example: I want to know if my browser supports History API</source>
          <target state="translated">예 : 브라우저가 History API를 지원하는지 알고 싶습니다</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="1cc20ab6bb45b09d067f86e897de287544ccc18a" translate="yes" xml:space="preserve">
          <source>Final fight: &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</source>
          <target state="translated">최종 싸움 : &lt;code&gt;obj.prop === undefined&lt;/code&gt; vs &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a66f6d43d5e07190edcbfd047a24a1c644663c95" translate="yes" xml:space="preserve">
          <source>For example: I've just been refactoring a bunch of code that had a bunch of checks whether an object had a given property.</source>
          <target state="translated">예를 들어, 방금 객체에 주어진 속성이 있는지 확인하는 많은 코드를 리팩토링했습니다.</target>
        </trans-unit>
        <trans-unit id="11cb88bb285ee32166071503cea3f43fbd246c9f" translate="yes" xml:space="preserve">
          <source>For my situation, if restResult.data[0] === &quot;object&quot;, then I can safely start inspecting the rest of the members.  If undefined then throw the error as above.</source>
          <target state="translated">내 상황에서 restResult.data [0] === &quot;object&quot;이면 나머지 멤버를 안전하게 검사 할 수 있습니다. 정의되지 않은 경우 위와 같이 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="282a1a5fba1c9f99dd9c65da723cf7e6ca6d5c3b" translate="yes" xml:space="preserve">
          <source>From lodash.js.</source>
          <target state="translated">lodash.js에서.</target>
        </trans-unit>
        <trans-unit id="724505ac659cb61ec2ae6752fea94b6583d5c2e3" translate="yes" xml:space="preserve">
          <source>Going through the comments, for those who want to check both is it undefined or its value is null:</source>
          <target state="translated">주석을 살펴보면 둘 다 확인하려는 사람들이 정의되지 않았거나 값이 null인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="12f327f57e715c27af2a0b9e2dc98dfb92d437ff" translate="yes" xml:space="preserve">
          <source>Here is my situation:</source>
          <target state="translated">내 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">도움이 되었기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="21afb40540c44bc457dfbcf79a0414bc7750aa85" translate="yes" xml:space="preserve">
          <source>How this works:</source>
          <target state="translated">작동 원리 :</target>
        </trans-unit>
        <trans-unit id="5d0e7097fe8f3623c402467f8277e8158fe7d304" translate="yes" xml:space="preserve">
          <source>However, this kind of technique should be avoided. JavaScript is a
  statically scoped language, so knowing if a variable is declared can
  be read by seeing whether it is declared in an enclosing context. The
  only exception is the global scope, but the global scope is bound to
  the global object, so checking the existence of a variable in the
  global context can be done by checking the existence of a property on
  the global object (using the in operator, for instance).</source>
          <target state="translated">그러나 이런 종류의 기술은 피해야합니다. JavaScript는 정적으로 범위가 지정된 언어이므로 변수가 선언되어 있는지 아는 것은 주변 컨텍스트에서 선언되었는지 여부를 확인하여 읽을 수 있습니다. 유일한 예외는 전역 범위이지만 전역 범위는 전역 객체에 바인딩되므로 전역 컨텍스트에서 변수의 존재 여부를 확인하려면 전역 객체의 속성 존재 여부를 확인하면됩니다 (in 연산자, 예를 들어).</target>
        </trans-unit>
        <trans-unit id="6fecf04984cba74419822b109f93545b2cd336ab" translate="yes" xml:space="preserve">
          <source>I also add this section from MDN which has got useful information about typeof, undefined and void(0).</source>
          <target state="translated">또한 typeof, undefined 및 void (0)에 대한 유용한 정보가있는 MDN에서이 섹션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ca90e82d4aa8f47040cff0d3ebf2778f42cec981" translate="yes" xml:space="preserve">
          <source>I am using the result of a REST call.
The result should be parsed from JSON to a JavaScript object.</source>
          <target state="translated">REST 호출 결과를 사용하고 있습니다. 결과는 JSON에서 JavaScript 객체로 구문 분석되어야합니다.</target>
        </trans-unit>
        <trans-unit id="44d30a96fae36c5b6279d6d45740204cbf4ff5a0" translate="yes" xml:space="preserve">
          <source>I believe there are a number of incorrect answers to this topic. Contrary to common belief, &quot;undefined&quot; is &lt;strong&gt;not&lt;/strong&gt; a keyword in JavaScript and can in fact have a value assigned to it.</source>
          <target state="translated">이 주제에 대한 많은 잘못된 답변이 있다고 생각합니다. 일반적인 정의와 달리 &quot;정의되지 않은&quot;은 JavaScript의 키워드가 &lt;strong&gt;아니며&lt;/strong&gt; 실제로 값을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37013d283a8127b7370563a4c36a206388c33a2" translate="yes" xml:space="preserve">
          <source>I didn't see (hope I didn't miss it) anyone checking the object before the property. So, this is the shortest and most effective (though not necessarily the most clear):</source>
          <target state="translated">나는 재산 앞에 물건을 검사하는 사람을 보지 못했다. 따라서 가장 짧고 효과적입니다 (반드시 가장 명확하지는 않지만).</target>
        </trans-unit>
        <trans-unit id="4358f6b4064ade07b2efbf8a21e0f4135f510c95" translate="yes" xml:space="preserve">
          <source>I found lodash updated its implementation. See &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;my issue&lt;/a&gt; and &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;the code&lt;/a&gt;.</source>
          <target state="translated">lodash가 구현을 업데이트 한 것을 발견했습니다. &lt;a href=&quot;https://github.com/lodash/lodash/issues/4041&quot;&gt;내 문제&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/lodash/lodash/blob/4ea8c2ec249be046a0f4ae32539d652194caf74f/isUndefined.js#L17&quot;&gt;코드를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a132ebdcb8942d7a076277423ad437744ce7794" translate="yes" xml:space="preserve">
          <source>I provide three ways here for those who expect weird answers:</source>
          <target state="translated">나는 이상한 답변을 기대하는 사람들을 위해 여기에 세 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="48e26ba605da52f2cf32ca734ac26d9e06215803" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;if (this.variable)&lt;/code&gt; to test if it is defined. Simple &lt;code&gt;if (variable)&lt;/code&gt;, &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;recommended above&lt;/a&gt;, fails for me. It turns out that it works only when variable is a field of some object, &lt;code&gt;obj.someField&lt;/code&gt; to check if it is defined in the dictionary. But we can use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; as the dictionary object since any variable is a field in current window, as I understand it. Therefore here is a test</source>
          <target state="translated">&lt;code&gt;if (this.variable)&lt;/code&gt; 를 사용하여 정의되어 있는지 테스트합니다. &lt;a href=&quot;https://stackoverflow.com/a/12589152/4550451&quot;&gt;위에서 권장하는&lt;/a&gt; 간단한 &lt;code&gt;if (variable)&lt;/code&gt; 이 실패합니다. 변수가 일부 객체의 필드 인 &lt;code&gt;obj.someField&lt;/code&gt; 인 경우에만 작동하여 사전에 정의되어 있는지 확인합니다. 그러나 변수는 현재 창의 필드이므로 이해할 수 있듯이이 또는 &lt;code&gt;window&lt;/code&gt; 을 사전 객체로 사용할 수 있습니다. 따라서 여기에 테스트가 있습니다</target>
        </trans-unit>
        <trans-unit id="9e125ebcc0697240332e778b82ebf4d7f9c17043" translate="yes" xml:space="preserve">
          <source>I would like to show you something I'm using in order to protect the &lt;code&gt;undefined&lt;/code&gt; variable:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 변수를 보호하기 위해 사용중인 것을 보여주고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="d5a6d2b02368855c6fda929fd61af0ea56454c18" translate="yes" xml:space="preserve">
          <source>I'd argue that in some cases it makes more sense (and is clearer) to check whether the property is there, than checking whether it is undefined, and the only case where this check will be different is case 2, the rare case of an actual entry in the object with an undefined value.</source>
          <target state="translated">나는 어떤 경우에는 속성이 있는지 여부를 확인하는 것보다 속성이 있는지 여부를 확인하는 것이 더 합리적이며 더 명확하다고 주장합니다.이 확인이 다른 유일한 경우는 드문 경우입니다. 정의되지 않은 값을 가진 객체의 실제 항목</target>
        </trans-unit>
        <trans-unit id="7a7486fe538e6ce861baa007fbb0f526deff33d5" translate="yes" xml:space="preserve">
          <source>I'm not sure where the origin of using &lt;code&gt;===&lt;/code&gt; with &lt;code&gt;typeof&lt;/code&gt; came from, and as a convention I see it used in many libraries, but the typeof operator returns a string literal, and we know that up front, so why would you also want to type check it too?</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 와 함께 &lt;code&gt;===&lt;/code&gt; 를 사용하는 출처가 어디에서 왔는지 잘 모르겠으며, 많은 라이브러리에서 사용되는 것으로 보았지만 typeof 연산자는 문자열 리터럴을 반환합니다. 또한 그것을 입력하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="6ef1c4a3ea0bc81cc7398a1d04f0515bcbd0fb86" translate="yes" xml:space="preserve">
          <source>If an object variable which have some properties you can use same thing like this:</source>
          <target state="translated">속성이있는 객체 변수라면 다음과 같은 것을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="84c7f1a126730161309b91866d156c12a47d03cd" translate="yes" xml:space="preserve">
          <source>If the obj or obj.prop is undefined, null, or &quot;falsy&quot;, the if statement will not execute the code block. This is &lt;em&gt;usually&lt;/em&gt; the desired behavior in most code block statements (in JavaScript).</source>
          <target state="translated">obj 또는 obj.prop가 undefined, null 또는 &quot;falsy&quot;인 경우 if 문은 코드 블록을 실행하지 않습니다. 이것은 &lt;em&gt;일반적으로&lt;/em&gt; 대부분의 코드 블록 명령문 (JavaScript)에서 원하는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="0d8a3869bd9a3727544999c872ed66c32e2161a3" translate="yes" xml:space="preserve">
          <source>If the value of an object was never defined, this will prevent from returning &lt;code&gt;true&lt;/code&gt; if it is defined as &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. This is helpful if you want true to be returned for values set as &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">객체의 값이 정의 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;null&lt;/code&gt; 또는 undefined 로 정의 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환하지 않습니다 . &lt;code&gt;undefined&lt;/code&gt; 로 설정된 값에 대해 true를 반환하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e37e4c8d75647a160e70f184781ee5d3320919a7" translate="yes" xml:space="preserve">
          <source>If you are using Angular:</source>
          <target state="translated">Angular를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="38b2ee0e2820da1917baa311fe8dc70a8ba6eb39" translate="yes" xml:space="preserve">
          <source>If you are using jQuery Library then &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; will suffice for both cases,</source>
          <target state="translated">jQuery 라이브러리를 사용하는 경우 &lt;code&gt;jQuery.isEmptyObject()&lt;/code&gt; 는 두 경우 모두에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="4a3f6705c1b3da9943592b3d90136b8c5856782d" translate="yes" xml:space="preserve">
          <source>If you check a property on an object and the object doesn't exist, will throw an error and stop the whole application running.</source>
          <target state="translated">객체의 속성을 확인하고 객체가 존재하지 않으면 오류가 발생하고 전체 응용 프로그램 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">당신이 할 경우</target>
        </trans-unit>
        <trans-unit id="efde9566bc6269c016eb40d2c931ee65be1256d5" translate="yes" xml:space="preserve">
          <source>If you want it to result as &lt;code&gt;true&lt;/code&gt; for values defined with the value of &lt;code&gt;undefined&lt;/code&gt;, or never defined, you can simply use &lt;code&gt;=== undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 값으로 정의 되거나 절대 정의 되지 않은 값에 대해 &lt;code&gt;true&lt;/code&gt; 로 결과를 &lt;code&gt;=== undefined&lt;/code&gt; 려면 === undefined 를 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c710b9144a4a4de7a8033df9d90b0d520b9d93cc" translate="yes" xml:space="preserve">
          <source>In JavaScript there is &lt;strong&gt;null&lt;/strong&gt; and there is &lt;strong&gt;undefined&lt;/strong&gt;.  They have different meanings.</source>
          <target state="translated">JavaScript에는 &lt;strong&gt;null&lt;/strong&gt; 이 있으며 &lt;strong&gt;정의되지 않았습니다&lt;/strong&gt; . 그들은 다른 의미를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="676832a5b39fcd247b5da8131c2bb20e3f4e6479" translate="yes" xml:space="preserve">
          <source>In js, optional parameter works when the input value is exactly &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">js에서 입력 매개 변수가 정확히 &lt;code&gt;undefined&lt;/code&gt; 경우 선택적 매개 변수가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="47b70d6bd5d7420590fbe686fa1aa65f6aff345c" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;Exploring the Abyss of Null and Undefined in JavaScript &lt;/a&gt;&lt;/em&gt; I read that frameworks like &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; use this function:</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/&quot;&gt;JavaScript에서 Nby 및 Null의 심연 탐험&lt;/a&gt;&lt;/em&gt; 기사 &lt;em&gt;에서&lt;/em&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; 와 같은 프레임 워크 가이 함수를 사용한다는 것을 읽었습니다.</target>
        </trans-unit>
        <trans-unit id="d6f3fa461bad66e062e473e85ddb6843faa72ad8" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;o.a&lt;/code&gt; undefined? Yes! Its value is undefined. Is &lt;code&gt;o.b&lt;/code&gt; undefined? Sure! There is no property 'b' at all! OK, see now how different approaches behave in both situations:</source>
          <target state="translated">&lt;code&gt;o.a&lt;/code&gt; 정의되어 있지 않습니까? 예! 그 값은 정의되어 있지 않습니다. &lt;code&gt;o.b&lt;/code&gt; 정의되어 있지 않습니까? 확실한! 'b'속성이 전혀 없습니다! 두 상황에서 서로 다른 접근법이 어떻게 작동하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="5fd8487b64efdd4bc0f74bc89dcb48fb3b637b18" translate="yes" xml:space="preserve">
          <source>It creates a LOCAL variable named &lt;code&gt;undefined&lt;/code&gt; which is initialized with the default value -- the real &lt;code&gt;undefined&lt;/code&gt;, then compares &lt;code&gt;value&lt;/code&gt; with the variable &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 라는 LOCAL 변수를 작성합니다.이 변수는 기본값 (실제 &lt;code&gt;undefined&lt;/code&gt; ) 으로 초기화 된 다음 &lt;code&gt;value&lt;/code&gt; 와 변수 &lt;code&gt;undefined&lt;/code&gt; 를 비교 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc7e62a0477f84c6e213a2a66a6810ed10b81109" translate="yes" xml:space="preserve">
          <source>It first detects that variable &lt;code&gt;abc&lt;/code&gt; is undefined and it is defined after initialization.</source>
          <target state="translated">먼저 변수 &lt;code&gt;abc&lt;/code&gt; 가 정의되지 않았 음을 감지하고 초기화 후에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0f662835940c2e3dcfdd198a56eabd87b6dab3" translate="yes" xml:space="preserve">
          <source>It is always better to use the instance/object of the variable to check if it got a valid value. It is more stable and is a better way of programming.</source>
          <target state="translated">변수의 인스턴스 / 객체를 사용하여 유효한 값을 갖는지 확인하는 것이 좋습니다. 보다 안정적이며 프로그래밍 방법이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4d8fd1abf77f99fdff5448384c2ed4fee6e5c474" translate="yes" xml:space="preserve">
          <source>It is really universal! It works in new and old browsers.</source>
          <target state="translated">정말 보편적입니다! 새롭고 오래된 브라우저에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a3b4d7eb65e80473b0d023a35685a8a9cba1977e" translate="yes" xml:space="preserve">
          <source>It's a bit shorter and looks a bit prettier</source>
          <target state="translated">조금 더 짧고 조금 더 예쁘게 보입니다</target>
        </trans-unit>
        <trans-unit id="1f9e9fe4a20d8dcfcf0cd7dd398ac00aaebacdc0" translate="yes" xml:space="preserve">
          <source>It's not as verbose as &lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if (typeof foo !== 'undefined')&lt;/code&gt; 장황하지 않은 것처럼 (typeof foo! == 'undefined')</target>
        </trans-unit>
        <trans-unit id="bda34532c7ceeef815dfdb84a302308f13b1698b" translate="yes" xml:space="preserve">
          <source>It's suitable if you have a function, which receives an additional config property:</source>
          <target state="translated">추가 구성 속성을받는 함수가있는 경우 적합합니다.</target>
        </trans-unit>
        <trans-unit id="90a5de8bf9ed40e458f73d3c2fa132d1f4efa842" translate="yes" xml:space="preserve">
          <source>Its worth noting that these tests are the same for &lt;code&gt;null&lt;/code&gt; entries too</source>
          <target state="translated">이 테스트는 &lt;code&gt;null&lt;/code&gt; 항목에 대해서도 동일하다는 점에 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cca12d9c31c7dc579429ae296a479d2f796bada7" translate="yes" xml:space="preserve">
          <source>JavaScript has &lt;code&gt;typeof&lt;/code&gt; which make it very easy to detect an undefined variable.</source>
          <target state="translated">JavaScript에는 정의되지 않은 변수를 매우 쉽게 감지 할 수있는 &lt;code&gt;typeof&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82d750a33e643b1a8a39e0ebb43d3b5768eaffc" translate="yes" xml:space="preserve">
          <source>Marijn Haverbeke states, in his free, online book &quot;&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt;&quot; (emphasis mine):</source>
          <target state="translated">Marijn Haverbeke는 그의 무료 온라인 책 &quot; &lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt; &quot;(강조 광산)에서 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="5f9f4ff7cb7c3bd40b09bbc0a21ff4e94114ed3a" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">obj.prop의 &lt;code&gt;obj.prop === undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0671b57c33e2e288915d086d37cc882d4a48e654" translate="yes" xml:space="preserve">
          <source>Minuses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6bea7aa73158aa827a9c1bea87ededed070dc457" translate="yes" xml:space="preserve">
          <source>Most likely you want &lt;code&gt;if (window.x)&lt;/code&gt;. This check is safe even if x hasn't been declared (&lt;code&gt;var x;&lt;/code&gt;) - browser doesn't throw an error.</source>
          <target state="translated">&lt;code&gt;if (window.x)&lt;/code&gt; 원하는 경우가 많습니다 . 이 검사는 x가 선언되지 않은 경우에도 안전합니다 ( &lt;code&gt;var x;&lt;/code&gt; )-브라우저에서 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b4b5105b3b3a13be5c61e3fa3df47a1366e4075" translate="yes" xml:space="preserve">
          <source>Never Defined</source>
          <target state="translated">절대 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="9484abb038e36cb0cd8cbbc623288ca1c4c7dc51" translate="yes" xml:space="preserve">
          <source>Node.js supports the global variable &lt;code&gt;undefined&lt;/code&gt; as &lt;code&gt;global.undefined&lt;/code&gt; (it can also be used without the 'global' prefix). I don't know about other implementations of server-side JavaScript.</source>
          <target state="translated">Node.js는 전역 변수 &lt;code&gt;undefined&lt;/code&gt; 를 &lt;code&gt;global.undefined&lt;/code&gt; 로 지원합니다 ( 'global'접두어 없이도 사용할 수 있음). 서버 쪽 JavaScript의 다른 구현에 대해서는 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="25e7237d29d65a8052d28a50ad68997f82c2cf73" translate="yes" xml:space="preserve">
          <source>Note: The strict equality operator rather than the standard equality
  operator must be used here, because x == undefined also checks whether
  x is null, while strict equality doesn't. null is not equivalent to
  undefined. See comparison operators for details.</source>
          <target state="translated">참고 : 여기서 x == undefined는 x가 null인지 여부를 검사하지만 엄격한 같음은 그렇지 않으므로 표준 같음 연산자가 아닌 엄격한 같음 연산자를 사용해야합니다. null은 undefined와 동일하지 않습니다. 자세한 내용은 비교 연산자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="59c5fb8a80a77710fbcb25bc27178f51a4e9b105" translate="yes" xml:space="preserve">
          <source>Now executing</source>
          <target state="translated">지금 실행 중</target>
        </trans-unit>
        <trans-unit id="b2491f157aee8344e47a52d1010d094626fad59f" translate="yes" xml:space="preserve">
          <source>One reason to use typeof is that it does not throw an error if the
  variable has not been declared.</source>
          <target state="translated">typeof를 사용하는 한 가지 이유는 변수가 선언되지 않은 경우 오류가 발생하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="aeca9079848cd62aa72e0c9da1ae45fee2f68f0f" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;obj.prop === undefined&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;obj.prop === undefined&lt;/code&gt; 의 장점 === undefined :</target>
        </trans-unit>
        <trans-unit id="c47d4b2cec06b65e3df4b5dc37d83b7c1779a8b3" translate="yes" xml:space="preserve">
          <source>Pluses of &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab5bb084b0953bb529d05917ef5d0f8f02b4e552" translate="yes" xml:space="preserve">
          <source>Reading through this, I'm amazed I didn't see this. I have found multiple algorithms that would work for this.</source>
          <target state="translated">이것을 통해, 나는 이것을 보지 못해서 놀랐습니다. 나는 이것을 위해 작동하는 여러 알고리즘을 발견했다.</target>
        </trans-unit>
        <trans-unit id="bb5a0c2d5893ca1120918abd2e27fe466333b1bf" translate="yes" xml:space="preserve">
          <source>Returns false if variable is set, and true if is undefined.</source>
          <target state="translated">변수가 설정된 경우 false를, 정의되지 않은 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="883a8c4f5ebd87c4fde0e73e9656f30546585657" translate="yes" xml:space="preserve">
          <source>Simply anything is not defined in JavaScript, is &lt;strong&gt;undefined&lt;/strong&gt;, doesn't matter if it's a property inside an &lt;strong&gt;Object/Array&lt;/strong&gt; or as just a simple variable...</source>
          <target state="translated">단순히 JavaScript로 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 것이 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 것은 &lt;strong&gt;객체 / 배열&lt;/strong&gt; 내부의 속성인지 또는 단순한 변수인지는 중요하지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="aedd3fc984632b50a483c5fe2c50d6f41d6d1779" translate="yes" xml:space="preserve">
          <source>Simply check if &lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; and it will return a boolean.</source>
          <target state="translated">&lt;code&gt;typeof whatever === 'undefined'&lt;/code&gt; 인지 확인하면 부울 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f828f39971d418b0bc13a1d98409cc5e98730d01" translate="yes" xml:space="preserve">
          <source>So as you see the function receive a value, if that value is defined, it will return &lt;code&gt;false&lt;/code&gt;, otherwise for undefined values, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">함수가 값을받는 것을 볼 수 있듯이 해당 값이 정의되면 &lt;code&gt;false&lt;/code&gt; 를 리턴하고 그렇지 않으면 정의되지 않은 값에 대해서는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="418ae1e2e0311d3d2c105a70491013660c6a928b" translate="yes" xml:space="preserve">
          <source>So let's have a look what gonna be the results when we passing values, including object properties like below, this is the list of variables we have:</source>
          <target state="translated">아래와 같이 객체 속성을 포함하여 값을 전달할 때 결과가 어떻게 될지 살펴 보겠습니다. 이것은 우리가 가진 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="26532241df6bb6d2e9b7919c8174d92f3c3e9956" translate="yes" xml:space="preserve">
          <source>So simple you can wrap inside an if statement like below:</source>
          <target state="translated">다음과 같이 if 문을 감싸면 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c03f8753c6b8939bcb611d65d70cd9f2e93a2bf4" translate="yes" xml:space="preserve">
          <source>So unless you&amp;rsquo;re doing feature detection&amp;sup2;, where there&amp;rsquo;s uncertainty whether a given name will be in scope (like checking &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; as a step in code specific to a CommonJS environment), &lt;code&gt;typeof&lt;/code&gt; is a harmful choice when used on a variable, and the correct option is to compare the value directly:</source>
          <target state="translated">따라서 특정 이름이 범위 내에 있는지 여부가 확실하지 않은 기능 감지 &amp;sup2;를 수행하지 않는 한 (CommonJS 환경에 특정한 코드의 단계로 &lt;code&gt;typeof module !== 'undefined'&lt;/code&gt; 확인), &lt;code&gt;typeof&lt;/code&gt; 는 사용할 때 해로운 선택입니다. 변수에 대한 올바른 옵션은 값을 직접 비교하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e1c8c9a0796fba24c5ae142d24dc8713fd92971" translate="yes" xml:space="preserve">
          <source>So what to do?</source>
          <target state="translated">그래서 뭐 할까?</target>
        </trans-unit>
        <trans-unit id="c4de3d5c3b3ce53f18295c6866165a0b386a0cc6" translate="yes" xml:space="preserve">
          <source>So, I guess the best way to check if something was undefined would be:</source>
          <target state="translated">따라서 정의되지 않은 것이 있는지 확인하는 가장 좋은 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62861616fb8499b1333e632d8f4f8c9d96d9ca16" translate="yes" xml:space="preserve">
          <source>So, for anyone who pass by, I will give you undefineds for free!!</source>
          <target state="translated">그래서, 지나가는 사람을 위해 나는 당신에게 undefineds를 무료로 줄 것입니다!</target>
        </trans-unit>
        <trans-unit id="93c6077f6664588e7ec5fe7e874c0816d5e39229" translate="yes" xml:space="preserve">
          <source>Some common misconceptions about this include:</source>
          <target state="translated">이에 대한 몇 가지 일반적인 오해는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="141f21882b084552acee073fca83c3cc0c42e7c8" translate="yes" xml:space="preserve">
          <source>Some scenarios illustrating the results of the various answers:
&lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</source>
          <target state="translated">다양한 답변의 결과를 보여주는 일부 시나리오 : &lt;a href=&quot;http://jsfiddle.net/drzaus/UVjM4/&quot;&gt;http://jsfiddle.net/drzaus/UVjM4/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5e2bb80f10dad7f8c5f9960cd6007b457637109" translate="yes" xml:space="preserve">
          <source>Something else to consider when it comes to object properties is whether you really want to check for &lt;code&gt;undefined&lt;/code&gt; at all. A given property name can be absent on an object (producing the value &lt;code&gt;undefined&lt;/code&gt; when read), present on the object itself with the value &lt;code&gt;undefined&lt;/code&gt;, present on the object&amp;rsquo;s prototype with the value &lt;code&gt;undefined&lt;/code&gt;, or present on either of those with a non-&lt;code&gt;undefined&lt;/code&gt; value. &lt;code&gt;'key' in obj&lt;/code&gt; will tell you whether a key is anywhere on an object&amp;rsquo;s prototype chain, and &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; will tell you whether it&amp;rsquo;s directly on the object. I won&amp;rsquo;t go into detail in this answer about prototypes and using objects as string-keyed maps, though, because it&amp;rsquo;s mostly intended to counter all the bad advice in other answers irrespective of the possible interpretations of the original question. Read up on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;object prototypes on MDN&lt;/a&gt; for more!</source>
          <target state="translated">객체 속성과 관련하여 고려해야 할 또 다른 사항은 &lt;code&gt;undefined&lt;/code&gt; 것을 실제로 확인 하려는지 여부입니다. 주어진 속성 이름은 개체에 없거나 (읽을 때 &lt;code&gt;undefined&lt;/code&gt; 값을 생성) 개체 자체에 &lt;code&gt;undefined&lt;/code&gt; 값이 있거나 개체의 프로토 타입에 &lt;code&gt;undefined&lt;/code&gt; 값이 있거나 정의되지 않은 개체 중 하나에있을 수 있습니다. 값. &lt;code&gt;'key' in obj&lt;/code&gt; 는 키가 객체의 프로토 타입 체인에 있는지 여부를 알려주고 &lt;code&gt;Object.prototype.hasOwnProperty.call(obj, 'key')&lt;/code&gt; 는 키 가 객체에 직접 있는지 여부를 알려줍니다. 프로토 타입과 객체를 문자열 키 맵으로 사용하는 것에 대한이 답변에 대해서는 자세하게 설명하지 않겠습니다. 원래 질문에 대한 가능한 해석과 상관없이 다른 답변의 모든 나쁜 조언에 대항하기 때문입니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&quot;&gt;은 MDN의 객체 프로토 타입&lt;/a&gt; 을 참조하십시오!</target>
        </trans-unit>
        <trans-unit id="09414607443b3c66a48d7b3cc8690784e89229ef" translate="yes" xml:space="preserve">
          <source>That's how the famous function &lt;code&gt;isUndefined()&lt;/code&gt; in AngularJs v.1x is written:</source>
          <target state="translated">AngularJs v.1x의 유명한 함수 &lt;code&gt;isUndefined()&lt;/code&gt; 가 작성되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="1d798e4166272be66a0741b99698bc5ab930a831" translate="yes" xml:space="preserve">
          <source>The JavaScript engine will give you an error if you have misspelled &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 철자를 잘못 입력하면 JavaScript 엔진에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="656b5d05c99fef961580b61f3edcaf330a6d66b8" translate="yes" xml:space="preserve">
          <source>The global variable &lt;em&gt;myvar&lt;/em&gt; is the same as &lt;em&gt;window.myvar&lt;/em&gt; or &lt;em&gt;window['myvar']&lt;/em&gt;</source>
          <target state="translated">전역 변수 &lt;em&gt;myvar&lt;/em&gt; 은 &lt;em&gt;window.myvar&lt;/em&gt; 또는 &lt;em&gt;window [ 'myvar']와 같습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29914467b1012003b3afd9aaffdcc32d8b458da1" translate="yes" xml:space="preserve">
          <source>The issue boils down to three cases:</source>
          <target state="translated">이 문제는 다음 세 가지 사례로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="8f19ead080cc475b112d23d1a87b473d84ebf23e" translate="yes" xml:space="preserve">
          <source>The most robust way to perform this test is:</source>
          <target state="translated">이 테스트를 수행하는 가장 강력한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195e6d98a22addf60a5f15d53507e42b6d225705" translate="yes" xml:space="preserve">
          <source>The object does not have the property.</source>
          <target state="translated">개체에 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="af4e3304635702004a3bc294a84b85b272ed0251" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">객체는 속성을 가지며 그 값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0000fbbbec8c44ca2bc7134d63869dbf22df5843" translate="yes" xml:space="preserve">
          <source>The object has the property and its value is not &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">개체에 속성이 있으며 값이 &lt;code&gt;undefined&lt;/code&gt; 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="f12e6a8e8479790bcfba92ce8e2bdb1c0b5a2c71" translate="yes" xml:space="preserve">
          <source>The question if a variable really exists doesn't matter, its value is incorrect. Otherwise, it is silly to initialize variables with undefined, and it is better use the value false to initialize. When you know that all variables that you declare are initialized with false, you can simply check its type or rely on &lt;code&gt;!window.myvar&lt;/code&gt; to check if it has a proper/valid value. So even when the variable is not defined then &lt;code&gt;!window.myvar&lt;/code&gt; is the same for &lt;code&gt;myvar = undefined&lt;/code&gt; or &lt;code&gt;myvar = false&lt;/code&gt; or &lt;code&gt;myvar = 0&lt;/code&gt;.</source>
          <target state="translated">변수가 실제로 존재하는지에 대한 질문은 중요하지 않으며 값이 올바르지 않습니다. 그렇지 않으면 정의되지 않은 변수를 초기화하는 것은 어리석은 일이며 false 값을 사용하여 초기화하는 것이 좋습니다. 선언 한 모든 변수가 false로 초기화 된 것을 알면 단순히 형식을 확인하거나 &lt;code&gt;!window.myvar&lt;/code&gt; 를 사용하여 올바른 / 유효한 값이 있는지 확인할 수 있습니다. 따라서 변수가 정의되지 않은 경우에도 &lt;code&gt;!window.myvar&lt;/code&gt; 은 &lt;code&gt;myvar = undefined&lt;/code&gt; 또는 &lt;code&gt;myvar = false&lt;/code&gt; 또는 &lt;code&gt;myvar = 0&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f6c187da4b16a273b05320f38b78197032e5f666" translate="yes" xml:space="preserve">
          <source>The solution is incorrect. In JavaScript,</source>
          <target state="translated">해결책이 잘못되었습니다. 자바 스크립트에서</target>
        </trans-unit>
        <trans-unit id="99c5e812eeb793c06c61ae79d6ce567d31253c67" translate="yes" xml:space="preserve">
          <source>The void operator is a third alternative.</source>
          <target state="translated">void 연산자는 세 번째 대안입니다.</target>
        </trans-unit>
        <trans-unit id="2624b916bf01c722be8fb21993d9edd3842b5f8d" translate="yes" xml:space="preserve">
          <source>Then use:</source>
          <target state="translated">그런 다음 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c306c1e05cc386f4fb986ead9800e3cb51d7d7ac" translate="yes" xml:space="preserve">
          <source>There is a nice &amp;amp; elegant way to assign a defined property to a new variable if it is defined or assign a default value to it as a fallback if it&amp;acute;s undefined.</source>
          <target state="translated">정의 된 속성이 정의 된 경우 정의 된 속성을 새 변수에 할당하거나 정의되지 않은 경우 대체 값으로 기본값을 할당하는 좋은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="909331b017c727d6b638a10340bcfa91fc4e0156" translate="yes" xml:space="preserve">
          <source>There is also a similar value, null, whose meaning is 'this value is defined, but it does not have a value'. The difference in meaning between undefined and null is mostly academic, and usually not very interesting. &lt;strong&gt;In practical programs, it is often necessary to check whether something 'has a value'. In these cases, the expression something == undefined may be used, because, even though they are not exactly the same value, null == undefined will produce true.&lt;/strong&gt;</source>
          <target state="translated">비슷한 의미의 null도 있는데, 그 의미는 '이 값은 정의되어 있지만 값이 없습니다'입니다. undefined와 null의 의미 차이는 대부분 학문적이며 일반적으로별로 흥미롭지 않습니다. &lt;strong&gt;실제 프로그램에서는 종종 '가치'가 있는지 확인해야합니다.&lt;/strong&gt; &lt;strong&gt;이러한 경우, == undefined라는 표현식이 사용될 수 있는데, 이는 정확히 같은 값이 아니더라도 null == undefined가 true를 생성하기 때문입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="066374c5c4c92cd26ce46b50a318fdbc81da8197" translate="yes" xml:space="preserve">
          <source>There is one error I need to defend.
If the args to the rest call were incorrect as far as the user specifying the args wrong, the rest call comes back basically empty.</source>
          <target state="translated">방어해야 할 오류가 하나 있습니다. 사용자가 인수를 잘못 지정하는 한 나머지 통화에 대한 인수가 올바르지 않은 경우 나머지 통화는 기본적으로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1c97843ddae12e312165772ba1724256c18040" translate="yes" xml:space="preserve">
          <source>This forbids anyone to change the &lt;code&gt;window.undefined&lt;/code&gt; value therefore destroying the code based on that variable. If using &lt;code&gt;&quot;use strict&quot;&lt;/code&gt;, anything trying to change its value will end in error, otherwise it would be silently ignored.</source>
          <target state="translated">이것은 누구나 &lt;code&gt;window.undefined&lt;/code&gt; 값을 변경하는 것을 금지하므로 해당 변수를 기반으로 코드를 파괴합니다. &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 를 사용하면 값을 변경하려고 시도하면 오류가 발생하고 그렇지 않으면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="206b6848288b0371c75a01e649b5ef1c02732df1" translate="yes" xml:space="preserve">
          <source>This tells us something I consider important:</source>
          <target state="translated">이것은 내가 중요하다고 생각하는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="882cd19a028fc5fdf4ac576781232fd9fb438143" translate="yes" xml:space="preserve">
          <source>This will always return the correct result, and even handles the situation where &lt;code&gt;myVar&lt;/code&gt; is not declared.</source>
          <target state="translated">이것은 항상 올바른 결과를 반환하며 &lt;code&gt;myVar&lt;/code&gt; 가 선언되지 않은 상황도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="65d3b63892021dfc610049dfe83bb84e542216eb" translate="yes" xml:space="preserve">
          <source>This worked for me while the others didn't.</source>
          <target state="translated">다른 사람들은 그렇지 않은 동안 이것은 나를 위해 일했습니다.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="1156bb5b9c53b338e90526a8c3e0f9157c2cdd5d" translate="yes" xml:space="preserve">
          <source>To avoid errors to test when a global variable exists, you better use:</source>
          <target state="translated">전역 변수가 존재할 때 테스트 오류를 ​​피하려면 다음을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af5a50ed0ca791f35da42bf271615ae60f9119f4" translate="yes" xml:space="preserve">
          <source>To be bullet-proof, simply use:</source>
          <target state="translated">방탄하려면 간단히 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a3733768c50f085f705798790041179dcb01dd51" translate="yes" xml:space="preserve">
          <source>Too bad that this been the right answer is buried in wrong answers &amp;gt;_&amp;lt;</source>
          <target state="translated">이것이 정답이라는 것이 너무 안타까운 답변에 묻 힙니다.&amp;gt; _ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2a836e46c13894957834965487f79f243bd458f6" translate="yes" xml:space="preserve">
          <source>Try to get a property of the input value, check the error message if it exists. If the input value is undefined, the error message would be &lt;em&gt;Uncaught TypeError: Cannot read property 'b' of undefined&lt;/em&gt;</source>
          <target state="translated">입력 값의 속성을 얻으려고 시도하고 오류 메시지가 있는지 확인하십시오. 입력 값이 정의되지 않은 경우 오류 메시지는 &lt;em&gt;Uncaught TypeError : undefined의 'b'속성을 읽을 수 없습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="31c8242d038a57a98e29aa92351bb4eeba57a99f" translate="yes" xml:space="preserve">
          <source>Underscore.js:</source>
          <target state="translated">Underscore.js:</target>
        </trans-unit>
        <trans-unit id="624f88833e4aa36d20755eda53fb498e36cc6d82" translate="yes" xml:space="preserve">
          <source>Update (for server-side JavaScript):</source>
          <target state="translated">업데이트 (서버 측 JavaScript의 경우) :</target>
        </trans-unit>
        <trans-unit id="0a8d800169d3f3a27add31e922bf0bca161dd01d" translate="yes" xml:space="preserve">
          <source>Update 9/9/2019</source>
          <target state="translated">2019 년 9 월 9 일 업데이트</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="ca3566d6d324a104499679565f550124050f47c6" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;undefined&lt;/code&gt; is a global variable (so actually it is &lt;code&gt;window.undefined&lt;/code&gt; in browsers). It has been supported since ECMAScript 1st Edition and since ECMAScript 5 it is &lt;strong&gt;read only&lt;/strong&gt;. So in modern browsers it can't be &lt;em&gt;redefined to true&lt;/em&gt; as many authors love to frighten us with, but this is still a true for older browsers.</source>
          <target state="translated">변수 &lt;code&gt;undefined&lt;/code&gt; 는 전역 변수이므로 실제로는 브라우저에서 &lt;code&gt;window.undefined&lt;/code&gt; 입니다. ECMAScript 1st Edition부터 지원되었으며 ECMAScript 5부터는 &lt;strong&gt;읽기 전용&lt;/strong&gt; 입니다. 따라서 현대의 브라우저에서는 많은 저자가 우리를 놀라게하는 것을 좋아하므로 &lt;em&gt;진실로 재정의&lt;/em&gt; 할 수 없지만 오래된 브라우저의 경우 여전히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="aa644c9b6d28b03bec73d65a8433d912ec0dc967" translate="yes" xml:space="preserve">
          <source>We can clearly see that &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; and &lt;code&gt;obj.prop === undefined&lt;/code&gt; are equivalent, and they do not distinguish those different situations. And &lt;code&gt;'prop' in obj&lt;/code&gt; can detect the situation when a property hasn't been defined at all and doesn't pay attention to the property value which may be undefined.</source>
          <target state="translated">우리는 &lt;code&gt;typeof obj.prop == 'undefined'&lt;/code&gt; 와 &lt;code&gt;obj.prop === undefined&lt;/code&gt; 가 동일하다는 것을 분명히 알 수 있으며, 서로 다른 상황을 구별하지 않습니다. &lt;code&gt;'prop' in obj&lt;/code&gt; 는 속성이 전혀 정의되지 않은 경우 상황을 감지하고 정의되지 않은 속성 값에주의를 기울이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4348ecc1522f37bea2a74798eccb1c698101bae" translate="yes" xml:space="preserve">
          <source>What I am saying is that for my situation, all the suggestions above in this post did not work.  I'm not saying I'm right and everyone is wrong.  I am not a JavaScript master at all, but hopefully this will help someone.</source>
          <target state="translated">내가 말하는 것은 내 상황에 따라이 게시물의 위의 모든 제안이 효과가 없다는 것입니다. 나는 내가 옳다고 말하지 않고 모두가 틀렸다. 나는 전혀 JavaScript 마스터가 아니지만 희망적으로 이것이 누군가를 도울 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c6a10825c9a1a5ecbcd512402eb30eb39482e71" translate="yes" xml:space="preserve">
          <source>What does this mean: &lt;strong&gt;&quot;undefined object property&quot;&lt;/strong&gt;?</source>
          <target state="translated">이것이 의미하는 것은 &lt;strong&gt;&quot;undefined object property&quot;&lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="86d7d00a77d485aef47636c622133ba6e079f28d" translate="yes" xml:space="preserve">
          <source>What's the best way of checking if an object property in JavaScript is &lt;code&gt;undefined&lt;/code&gt;?</source>
          <target state="translated">JavaScript의 객체 속성이 &lt;code&gt;undefined&lt;/code&gt; 확인하는 가장 좋은 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6a44c70b62e1f951bfff4ad714a3bf6f9c36a141" translate="yes" xml:space="preserve">
          <source>When the first and simple condition is true, the interpreter skips the next tests.</source>
          <target state="translated">첫 번째 간단한 조건이 true이면 인터프리터는 다음 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="b7221864517c5c211586a94530d68cdcfc6ea425" translate="yes" xml:space="preserve">
          <source>When you expect a specific type, test the type of the variable. To speed up testing a condition you better do:</source>
          <target state="translated">특정 유형이 필요한 경우 변수 유형을 테스트하십시오. 조건 테스트 속도를 높이려면 다음을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d60051b913c76582de7e88350c42134161b10c93" translate="yes" xml:space="preserve">
          <source>Which also equal to isDefined in Angular 1.x...</source>
          <target state="translated">또한 Angular 1.x에서 isDefined와 동일합니다 ...</target>
        </trans-unit>
        <trans-unit id="88ec2543321a88029f849108c87daeb5587d1c2d" translate="yes" xml:space="preserve">
          <source>Which was clearer when written without a check for undefined.</source>
          <target state="translated">정의되지 않은 검사없이 작성되었을 때 더 명확했습니다.</target>
        </trans-unit>
        <trans-unit id="5b51b27fa3903d28d3f04b6c171ad09973278eb9" translate="yes" xml:space="preserve">
          <source>While using this post to help me defend against this, I tried this.</source>
          <target state="translated">이 게시물을 사용하여 이것을 방어하는 데 도움을 주면서 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="e71f039272b0f0e068195d6015ac5f2784fca83b" translate="yes" xml:space="preserve">
          <source>With how variables work out of the way, it&amp;rsquo;s time to address the actual question: object properties. There is no reason to ever use &lt;code&gt;typeof&lt;/code&gt; for object properties. The earlier exception regarding feature detection doesn&amp;rsquo;t apply here &amp;ndash; &lt;code&gt;typeof&lt;/code&gt; only has special behaviour on variables, and expressions that reference object properties are not variables.</source>
          <target state="translated">변수가 작동하지 않는 방식으로 실제 질문 인 객체 속성을 해결해야합니다. 객체 속성에 &lt;code&gt;typeof&lt;/code&gt; 를 사용할 이유가 없습니다. 기능 감지와 관련된 이전 예외는 여기에 적용되지 않습니다. &lt;code&gt;typeof&lt;/code&gt; 는 변수에 대한 특수한 동작 만 가지며 개체 속성을 참조하는 식은 변수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fdb6add32a76812e71fb836b3a0175d29a715c41" translate="yes" xml:space="preserve">
          <source>You can get an array all undefined with path using the following code.</source>
          <target state="translated">다음 코드를 사용하여 경로로 정의되지 않은 배열을 모두 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd195a5d241f7801da7590d49a101b3417b1d020" translate="yes" xml:space="preserve">
          <source>You can use undefined and the strict equality and inequality operators to determine whether a variable has
  a value. In the following code, the variable x is not defined, and the
  if statement evaluates to true.</source>
          <target state="translated">정의되지 않은 엄격한 동등성 및 부등식 연산자를 사용하여 변수에 값이 있는지 확인할 수 있습니다. 다음 코드에서 변수 x는 정의되어 있지 않으며 if 문은 true로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd945be1ad955926cb0576570ca86d427690000" translate="yes" xml:space="preserve">
          <source>You can't check an object and its property at the same time. For example, this &lt;code&gt;x.a === undefined&lt;/code&gt; or this &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; raises &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; if x is not defined.</source>
          <target state="translated">객체와 그 속성을 동시에 확인할 수는 없습니다. 예를 들어,이 &lt;code&gt;x.a === undefined&lt;/code&gt; 또는이 &lt;code&gt;typeof x.a == 'undefined'&lt;/code&gt; 은 &lt;code&gt;ReferenceError: x is not defined&lt;/code&gt; 시킵니다. x가 정의되지 않은 경우 x는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afb57f9c5e1cd65cb89577ac225085a571888c95" translate="yes" xml:space="preserve">
          <source>and taking into account the advice above, to avoid confusing readers as to why you&amp;rsquo;re using &lt;code&gt;typeof&lt;/code&gt;, because it makes the most sense to use &lt;code&gt;===&lt;/code&gt; to check for equality, because it could be refactored to checking a variable&amp;rsquo;s value later, and because it just plain looks better, &lt;strong&gt;you should always use &lt;code&gt;=== undefined&lt;/code&gt;&amp;sup3; here as well&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 를 사용하는 이유에 대해 혼란스러워하는 독자를 피하기 위해 위의 조언을 고려하십시오. &lt;code&gt;===&lt;/code&gt; 를 사용하여 평등을 확인하는 것이 가장 합리적입니다. 평범한 것이 더 좋아 보이기 때문에 &lt;strong&gt;항상 &lt;code&gt;=== undefined&lt;/code&gt; &amp;sup3;을 사용해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d105f7494e87ab388edea0f7b8c3a73720d04c6" translate="yes" xml:space="preserve">
          <source>and we check them as below, you can see the results in front of them as a comment:</source>
          <target state="translated">우리는 아래에서 결과를 확인하면 그 결과를 주석으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3490def710ea1d24edc82b74a46f9764b33bda" translate="yes" xml:space="preserve">
          <source>is &lt;em&gt;always exactly equivalent&lt;/em&gt; to this&amp;sup3;:</source>
          <target state="translated">&lt;em&gt;항상 다음과 정확히 일치&lt;/em&gt; 합니다 &amp;sup3; :</target>
        </trans-unit>
        <trans-unit id="4778deb55d8cd5675a499ac484ad2ef5c74ec10c" translate="yes" xml:space="preserve">
          <source>isUndefined1:</source>
          <target state="translated">isUndefined1:</target>
        </trans-unit>
        <trans-unit id="15fa6dc48f1d00cd33b8f768892cc3b8131f1bbb" translate="yes" xml:space="preserve">
          <source>isUndefined2:</source>
          <target state="translated">isUndefined2:</target>
        </trans-unit>
        <trans-unit id="c871adbf9668a35abe539aa06d9c0dafaf3ce3ee" translate="yes" xml:space="preserve">
          <source>isUndefined3:</source>
          <target state="translated">isUndefined3:</target>
        </trans-unit>
        <trans-unit id="8ac534c595dd379491a89bb14380a533170408b9" translate="yes" xml:space="preserve">
          <source>it will fail when the variable &lt;code&gt;myvar&lt;/code&gt; does not exists, because myvar is not defined, so the script is broken and the test has no effect.</source>
          <target state="translated">&lt;code&gt;myvar&lt;/code&gt; 이 정의 되지 않아서 myvar 변수가 존재하지 않으면 스크립트가 중단되고 테스트가 효과가 없으므로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="985aa8a699702f412ce09aab8fceeb541def9317" translate="yes" xml:space="preserve">
          <source>more &amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">더&amp;gt; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b79ab4d893a4264fa8785737934a4d1503cc8e5" translate="yes" xml:space="preserve">
          <source>so you will use it like:</source>
          <target state="translated">그래서 당신은 그것을 다음과 같이 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="157d0448c1dd7a8c6cfeab738ffaa2775caae49d" translate="yes" xml:space="preserve">
          <source>that &lt;code&gt;undefined&lt;/code&gt; can be overwritten. There&amp;rsquo;s a lot more to this. &lt;code&gt;undefined&lt;/code&gt; is not a keyword in JavaScript. Instead, it&amp;rsquo;s a property on the global object with the Undefined value. However, since ES5, this property has been &lt;em&gt;read-only&lt;/em&gt; and &lt;em&gt;non-configurable&lt;/em&gt;. No modern browser will allow the &lt;code&gt;undefined&lt;/code&gt; property to be changed, and as of 2017 this has been the case for a long time. Lack of strict mode doesn&amp;rsquo;t affect &lt;code&gt;undefined&lt;/code&gt;&amp;rsquo;s behaviour either &amp;ndash; it just makes statements like &lt;code&gt;undefined = 5&lt;/code&gt; do nothing instead of throwing. Since it isn&amp;rsquo;t a keyword, though, you can &lt;em&gt;declare&lt;/em&gt; variables with the name &lt;code&gt;undefined&lt;/code&gt;, and those variables could be changed, making this once-common pattern:</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 을 덮어 쓸 수 있습니다. 이것에 더 많은 것이 있습니다. &lt;code&gt;undefined&lt;/code&gt; 는 자바 스크립트에서 키워드가 아닙니다. 대신, 정의되지 않은 값을 가진 전역 객체의 속성입니다. 그러나 ES5 이후로이 특성은 &lt;em&gt;읽기 전용&lt;/em&gt; 이며 &lt;em&gt;구성 할 수 없습니다&lt;/em&gt; . 최신 브라우저는 &lt;code&gt;undefined&lt;/code&gt; 속성을 변경할 수 없으며 2017 년 현재 오랫동안 그렇게되었습니다. 엄격 모드의 부족은 &lt;code&gt;undefined&lt;/code&gt; 의 동작에도 영향을 미치지 않습니다. &lt;code&gt;undefined = 5&lt;/code&gt; 와 같은 명령문은 던지기 대신 아무것도하지 않습니다. 그러나 키워드가 아니기 때문에 이름이 &lt;code&gt;undefined&lt;/code&gt; 인 변수를 &lt;em&gt;선언&lt;/em&gt; 할 수 있으며 해당 변수를 변경하여 한 번만 일반적인 패턴을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0793e2c88390a29b1957e9039867ab8ffb4111d4" translate="yes" xml:space="preserve">
          <source>that reading an &amp;ldquo;uninitialized&amp;rdquo; variable (&lt;code&gt;var foo&lt;/code&gt;) or parameter (&lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt;, called as &lt;code&gt;bar()&lt;/code&gt;) will fail. This is simply not true &amp;ndash; variables without explicit initialization and parameters that weren&amp;rsquo;t given values always become &lt;code&gt;undefined&lt;/code&gt;, and are always in scope.</source>
          <target state="translated">&quot;초기화되지 않은&quot;변수 ( &lt;code&gt;var foo&lt;/code&gt; ) 또는 매개 변수 ( &lt;code&gt;bar()&lt;/code&gt; 로 불리는 &lt;code&gt;function bar(foo) { &amp;hellip; }&lt;/code&gt; 를 읽는 데 실패합니다. 명시 적으로 초기화되지 않은 변수와 값이 제공 &lt;code&gt;undefined&lt;/code&gt; 매개 변수는 항상 정의되지 않고 항상 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="36867f049a149d6504389c0dac25fc3f11212dfd" translate="yes" xml:space="preserve">
          <source>which is the identity operator...</source>
          <target state="translated">이것은 신원 연산자입니다 ...</target>
        </trans-unit>
        <trans-unit id="e0cafe396bcf72dbf7b9b4bc907e035155d2be4e" translate="yes" xml:space="preserve">
          <source>will return true, because they both are &quot;casted&quot; to a boolean and are false. The correct way would be to check</source>
          <target state="translated">둘 다 부울에 &quot;캐스트되고&quot;거짓이기 때문에 true를 리턴합니다. 올바른 방법은 확인하는 것입니다</target>
        </trans-unit>
        <trans-unit id="786ca9a6ff480fa14542ee13006ae5e448160486" translate="yes" xml:space="preserve">
          <source>you can also use Proxy, it will work with nested calls, but will require one extra check:</source>
          <target state="translated">당신은 또한 프록시를 사용할 수 있습니다, 그것은 중첩 된 호출과 함께 작동하지만 하나의 추가 검사가 필요합니다 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
