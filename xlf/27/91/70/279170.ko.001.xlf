<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/279170">
    <body>
      <group id="279170">
        <trans-unit id="06af4577aef7c6aa04de62a9e9affe6b5e40b70b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For HTML before HTML5 only&lt;/em&gt;: note that the W3C HTML spec says that clients &quot;should&quot; default to sending forms back to the server in whatever charset the server served, but this is apparently only a recommendation, hence the need for being explicit on every single &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;em&gt;HTML5 이전의 HTML에만 해당&lt;/em&gt; : W3C HTML 사양에 따르면 클라이언트는 서버가 제공 한 모든 문자 집합에서 서버로 양식을 다시 보내도록 기본적으로 설정해야하지만 이는 권장 사항 일 뿐이므로 모든 단일 항목에 대해 명시 적이어야 할 필요가 있습니다. &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그.</target>
        </trans-unit>
        <trans-unit id="63a5e5ecb09bd491d8a8810b798d6527433245c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;For HTML before HTML5 only&lt;/em&gt;: you want all data sent to you by browsers to be in UTF-8.  Unfortunately, if you go by the the only way to reliably do this is add the &lt;code&gt;accept-charset&lt;/code&gt; attribute to all your &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags: &lt;code&gt;&amp;lt;form ... accept-charset=&quot;UTF-8&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;HTML5 이전의 HTML 전용&lt;/em&gt; : 브라우저에서 전송 한 모든 데이터를 UTF-8로 만들려고합니다. 불행히도, 확실하게이 작업을 수행 할 수있는 유일한 방법은 &lt;code&gt;accept-charset&lt;/code&gt; 속성을 모든 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그에 추가하는 것입니다 : &lt;code&gt;&amp;lt;form ... accept-charset=&quot;UTF-8&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c51bc805d030d10018e00d31e67169a5f6f3c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DATABASES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DATABASES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b578f9568f5e971f11c2590a5e8ca72330cedc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data Access&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;데이터 액세스&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="6eaab0ed7f59813378f7ec1bba3510d7ed00e863" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data Storage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;데이터 저장&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0104b54fcea146c5135352deefd00773ae9075b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ICONV&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ICONV&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9faff448a1c9eb4a9b5e4cce892878666473b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INTL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;INTL&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1673cd90fc65534f0976e8f49b4fcd67b98478cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Input&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="fbe923d3cfa7af2e6086dda3a5d6845ee1e97481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other Code Considerations&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;다른 코드 고려 사항&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="226c6d195092d25e48f4779200988ceb25b71b01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d10301de7a9ca554fa4dac27ebbda55facc94927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP's built-in string operations are &lt;em&gt;not&lt;/em&gt; by default UTF-8 safe.&lt;/strong&gt;  There are some things you can safely do with normal PHP string operations (like concatenation), but for most things you should use the equivalent &lt;code&gt;mbstring&lt;/code&gt; function.</source>
          <target state="translated">&lt;strong&gt;PHP의 내장 문자열 연산은 기본적으로 UTF-8 안전 &lt;em&gt;하지 않습니다&lt;/em&gt; .&lt;/strong&gt; 연결과 같은 일반적인 PHP 문자열 작업으로 안전하게 할 수있는 것이 있지만 대부분의 경우 동등한 &lt;code&gt;mbstring&lt;/code&gt; 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bf5005644d67207d699204077f6491c88ae0c49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some other Gotchas&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 몇 가지&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="743f380d56d8b8ea4558c5433cb1e69cdffd790c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mb_string&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mb_string&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e6ba71b4dfcb183a9c30569388266d19535ac62" translate="yes" xml:space="preserve">
          <source>A good library to check into is &lt;a href=&quot;http://phputf8.sourceforge.net/&quot;&gt;phputf8&lt;/a&gt;. This rewrites all of the &quot;bad&quot; functions so you can safely work on UTF8 strings. There are extensions like the mbstring extension that try to do this for you, too, but I prefer using the library because it's more portable (but I write mass-market products, so that's important for me). But phputf8 can use mbstring behind the scenes, anyway, to increase performance.</source>
          <target state="translated">체크인하기에 좋은 라이브러리는 &lt;a href=&quot;http://phputf8.sourceforge.net/&quot;&gt;phputf8&lt;/a&gt; 입니다. 이것은 모든 &quot;나쁜&quot;기능을 다시 작성하므로 UTF8 문자열에서 안전하게 작업 할 수 있습니다. mbstring 확장과 같은 확장 기능도 있지만이를 위해 더 노력하기 때문에 라이브러리를 사용하는 것이 좋습니다 (그러나 대량 시장 제품을 작성하므로 나에게 중요합니다). 그러나 phputf8은 어쨌든 mbstring을 사용하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66be105f647b3b6d7fea9e91efdb0af8b57b0a5e" translate="yes" xml:space="preserve">
          <source>After adding  this line to my config file everything works fine!</source>
          <target state="translated">이 줄을 구성 파일에 추가하면 모든 것이 잘 작동합니다!</target>
        </trans-unit>
        <trans-unit id="ad2335ab936d79f64b8be9cdb644fc54d355f7e9" translate="yes" xml:space="preserve">
          <source>As a side note, I also discovered by running &lt;code&gt;mb_internal_encoding()&lt;/code&gt; that the internal encoding wasn't utf-8, and I changed that by running &lt;code&gt;mb_internal_encoding(&quot;UTF-8&quot;);&lt;/code&gt;.</source>
          <target state="translated">참고로, &lt;code&gt;mb_internal_encoding()&lt;/code&gt; 을 실행하여 내부 인코딩이 utf-8이 아님을 발견했으며 &lt;code&gt;mb_internal_encoding(&quot;UTF-8&quot;);&lt;/code&gt; 을 실행하여 이를 변경했습니다 . .</target>
        </trans-unit>
        <trans-unit id="b1ff57d696aa3ec09bd76c88944e1a7097ee37a3" translate="yes" xml:space="preserve">
          <source>Bad:</source>
          <target state="translated">Bad:</target>
        </trans-unit>
        <trans-unit id="50d0051ba372bbd20fb081fe3197142413d36a87" translate="yes" xml:space="preserve">
          <source>Calendars, dates, timezone and time</source>
          <target state="translated">달력, 날짜, 시간대 및 시간</target>
        </trans-unit>
        <trans-unit id="71fdd7641faff64b3e623e8dd14f6178bec7555d" translate="yes" xml:space="preserve">
          <source>Collation</source>
          <target state="translated">Collation</target>
        </trans-unit>
        <trans-unit id="d042e4b29618ce17f584c5ea070221c0f7d91503" translate="yes" xml:space="preserve">
          <source>Convertors</source>
          <target state="translated">Convertors</target>
        </trans-unit>
        <trans-unit id="3efa3f00ec81206e84b7d8365bbb3c2536320aa7" translate="yes" xml:space="preserve">
          <source>Currency formatting</source>
          <target state="translated">통화 형식</target>
        </trans-unit>
        <trans-unit id="d5bb76d4f2af1da73cdec9cd996d21666b8aaa4b" translate="yes" xml:space="preserve">
          <source>Declaring character encodings in HTML</source>
          <target state="translated">HTML에서 문자 인코딩 선언</target>
        </trans-unit>
        <trans-unit id="bb3692b8edda6477fc06e9567b300b75a2bba9f9" translate="yes" xml:space="preserve">
          <source>Does not support HTTP input output conversion</source>
          <target state="translated">HTTP 입력 출력 변환을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="794ecab07a1cf25661dcd00aef43b87b9493cf8b" translate="yes" xml:space="preserve">
          <source>Does not support function overloading</source>
          <target state="translated">기능 과부하를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7d6c707795a253449aa3897eabc13c82bba0f06d" translate="yes" xml:space="preserve">
          <source>Does not support zend_multibite</source>
          <target state="translated">zend_multibite를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="ac7607d30da804d7490261abc5759d7c4b829406" translate="yes" xml:space="preserve">
          <source>Don't forget the META tag either (like this, or &lt;a href=&quot;http://www.w3.org/International/questions/qa-html-encoding-declarations#quicklookup&quot;&gt;the HTML4 or XHTML version of it&lt;/a&gt;):</source>
          <target state="translated">META 태그를 잊지 마십시오 (예 : &lt;a href=&quot;http://www.w3.org/International/questions/qa-html-encoding-declarations#quicklookup&quot;&gt;HTML4 또는 XHTML 버전&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f7b323d49c49bf74f1433d88c9d3b49aa763eb8" translate="yes" xml:space="preserve">
          <source>Enables zend_multibyte support</source>
          <target state="translated">zend_multibyte 지원 가능</target>
        </trans-unit>
        <trans-unit id="06c4ea17f2f205a02094fcf1a8c86a4cab0b049c" translate="yes" xml:space="preserve">
          <source>FAQ: Changing (X)HTML page encoding to UTF-8</source>
          <target state="translated">FAQ : (X) HTML 페이지 인코딩을 UTF-8로 변경</target>
        </trans-unit>
        <trans-unit id="a6697dfee4d67a3e60a8f6e5b3ab085570c9806b" translate="yes" xml:space="preserve">
          <source>First of all if you are in &amp;lt; 5.3PHP then no. You've got a ton of problems to tackle.</source>
          <target state="translated">우선 &amp;lt;5.3PHP 인 경우 아니요. 해결해야 할 수많은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8948689b97542f60657f89c506bc510f2f9aa1ba" translate="yes" xml:space="preserve">
          <source>From my reading of the current &lt;a href=&quot;http://whatwg.org/html&quot;&gt;HTML spec&lt;/a&gt;, the following sub-bullets are not necessary or even valid anymore for modern HTML.  My understanding is that browsers will work with and submit data in the character set specified for the document.  However, if you're targeting older versions of HTML (XHTML, HTML4, etc.), these points may still be useful:</source>
          <target state="translated">현재 &lt;a href=&quot;http://whatwg.org/html&quot;&gt;HTML 사양을&lt;/a&gt; 읽었을 때 다음 하위 글 머리 기호는 더 이상 최신 HTML에 필요하지 않거나 더 이상 유효하지 않습니다. 브라우저가 문서에 지정된 문자 세트로 작업하고 데이터를 제출한다는 것을 이해합니다. 그러나 이전 버전의 HTML (XHTML, HTML4 등)을 타겟팅하는 경우 다음 사항이 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="b79d7de20905687ddf09552514a209f7642eb172" translate="yes" xml:space="preserve">
          <source>Graphemes</source>
          <target state="translated">Graphemes</target>
        </trans-unit>
        <trans-unit id="a47ced5ebf103e6f29aef86c197000fed6c93968" translate="yes" xml:space="preserve">
          <source>I am surprised that none has mentioned the &lt;a href=&quot;http://php.net/intl&quot;&gt;&lt;strong&gt;intl&lt;/strong&gt;&lt;/a&gt; library, the one that has good support for &lt;strong&gt;unicode&lt;/strong&gt;, &lt;strong&gt;graphemes&lt;/strong&gt;, &lt;strong&gt;string operations&lt;/strong&gt; , &lt;strong&gt;localisation&lt;/strong&gt; and many more, see below.</source>
          <target state="translated">&lt;strong&gt;unicode&lt;/strong&gt; , &lt;strong&gt;graphemes&lt;/strong&gt; , &lt;strong&gt;string operation&lt;/strong&gt; , &lt;strong&gt;localization&lt;/strong&gt; 등을 잘 지원하는 &lt;a href=&quot;http://php.net/intl&quot;&gt;&lt;strong&gt;intl&lt;/strong&gt;&lt;/a&gt; 라이브러리를 언급 한 사람이 아무도 없습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63a7aca8ab1413b2b54336381660a056df51aae1" translate="yes" xml:space="preserve">
          <source>I changed all my file encoding to UTF8 then the default encoding on my connection. This solved all the problems.</source>
          <target state="translated">모든 파일 인코딩을 UTF8로 변경 한 다음 연결의 기본 인코딩을 변경했습니다. 이것은 모든 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="7d04fad80998f11575c6ef10a584a7f72a849404" translate="yes" xml:space="preserve">
          <source>I found an issue with someone using PDO and the answer was to use this for the PDO connection string:</source>
          <target state="translated">PDO를 사용하는 사람과 관련된 문제를 발견했으며 PDO 연결 문자열에이를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="adf8e4bcbc3f4fb1f02131328680ee49d7ad4623" translate="yes" xml:space="preserve">
          <source>I found this solution &lt;a href=&quot;https://www.w3schools.com/PHP/func_mysqli_set_charset.asp&quot;&gt;https://www.w3schools.com/PHP/func_mysqli_set_charset.asp&lt;/a&gt; when i was looking to solve a insert from html query</source>
          <target state="translated">html 쿼리에서 삽입을 해결하려고 할 때이 솔루션 &lt;a href=&quot;https://www.w3schools.com/PHP/func_mysqli_set_charset.asp&quot;&gt;https://www.w3schools.com/PHP/func_mysqli_set_charset.asp를&lt;/a&gt; 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="3712718493dedcde16dfe00371c49ad1e75c3d08" translate="yes" xml:space="preserve">
          <source>I have just went through the same issue and found a good solution at PHP manuals.</source>
          <target state="translated">방금 동일한 문제를 겪고 PHP 매뉴얼에서 좋은 해결책을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="cbe87772a90cce5e56d7f7bcd63502aa95584759" translate="yes" xml:space="preserve">
          <source>I ll update this answer in case things change features added and so on.</source>
          <target state="translated">기능 변경 등이 추가되는 경우이 답변을 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="03011cd320b77197c5142401ea09ade77de5ac83" translate="yes" xml:space="preserve">
          <source>I recently discovered that using &lt;code&gt;strtolower()&lt;/code&gt; can cause issues where the data is truncated after a special character.</source>
          <target state="translated">최근에 &lt;code&gt;strtolower()&lt;/code&gt; 를 사용하면 특수 문자 다음에 데이터가 잘리는 문제가 발생할 수 있음을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="21120a9ba534d136733cce10663a538aca732686" translate="yes" xml:space="preserve">
          <source>I was doing everything right; the database, database connection and Content-Type HTTP header were all set to UTF-8, and it worked fine in all other browsers, but Internet Explorer still insisted on using the &quot;Western European&quot; encoding.</source>
          <target state="translated">나는 모든 일을 올바르게하고있었습니다. 데이터베이스, 데이터베이스 연결 및 Content-Type HTTP 헤더는 모두 UTF-8로 설정되었으며 다른 모든 브라우저에서 제대로 작동했지만 Internet Explorer는 여전히 &quot;서유럽 어&quot;인코딩 사용을 주장했습니다.</target>
        </trans-unit>
        <trans-unit id="f3f6cf01462325f4e47dbce87e5164dfc905c429" translate="yes" xml:space="preserve">
          <source>I will quote some information about unicode support in PHP by &lt;strong&gt;Elizabeth Smith's&lt;/strong&gt;&lt;a href=&quot;http://www.slideshare.net/auroraeosrose/using-unicode-with-php&quot;&gt;slides&lt;/a&gt; at &lt;strong&gt;PHPBenelux'14&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHPBenelux'14&lt;/strong&gt; 에서 &lt;strong&gt;Elizabeth Smith의&lt;/strong&gt; &lt;a href=&quot;http://www.slideshare.net/auroraeosrose/using-unicode-with-php&quot;&gt;슬라이드&lt;/a&gt; 를 &lt;strong&gt;통해&lt;/strong&gt; PHP에서 유니 코드 지원에 대한 정보를 인용 &lt;strong&gt;하겠습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="770525ab9fd169302211602b74e1ddefc1417f52" translate="yes" xml:space="preserve">
          <source>I'd like to add one thing to &lt;a href=&quot;https://stackoverflow.com/questions/279170/utf-8-all-the-way-through#279279&quot;&gt;chazomaticus' excellent answer&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/279170/utf-8-all-the-way-through#279279&quot;&gt;chazomaticus의 훌륭한 답변에&lt;/a&gt; 한 가지를 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="c0a702df3182396e3f9bc9b7512198794c576da5" translate="yes" xml:space="preserve">
          <source>I'm setting up a new server and want to support UTF-8 fully in my web application. I have tried this in the past on existing servers and always seem to end up having to fall back to ISO-8859-1.</source>
          <target state="translated">새 서버를 설정하고 있으며 웹 응용 프로그램에서 UTF-8을 완전히 지원하려고합니다. 나는 과거에 기존 서버에서 이것을 시도했으며 항상 ISO-8859-1로 돌아 가야하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="35d3d2d3404abeb8346dba6488194ef8d13aafd7" translate="yes" xml:space="preserve">
          <source>IDN support</source>
          <target state="translated">IDN 지원</target>
        </trans-unit>
        <trans-unit id="682b756eeb7b8de097992166c3aca915f1ccf3b0" translate="yes" xml:space="preserve">
          <source>If the driver does not provide its own mechanism for setting the connection character set, you may have to issue a query to tell MySQL how your application expects data on the connection to be encoded: &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-connection.html&quot;&gt;&lt;code&gt;SET NAMES 'utf8mb4'&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">드라이버가 연결 문자 세트를 설정하기위한 자체 메커니즘을 제공하지 않는 경우, 애플리케이션이 연결의 데이터가 인코딩 될 것으로 예상하는 방법을 MySQL에 알리기 위해 쿼리를 발행해야 할 수도 있습니다. &lt;a href=&quot;http://dev.mysql.com/doc/en/charset-connection.html&quot;&gt; &lt;code&gt;SET NAMES 'utf8mb4'&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfe4b018ffc2451f02a8054a2d60f5a06e25c89b" translate="yes" xml:space="preserve">
          <source>If you want MySQL server to decide character set, and not PHP as a client (old behaviour; preferred, in my opinion), try adding &lt;code&gt;skip-character-set-client-handshake&lt;/code&gt; to your &lt;code&gt;my.cnf&lt;/code&gt;, under &lt;code&gt;[mysqld]&lt;/code&gt;, and restart &lt;code&gt;mysql&lt;/code&gt;.</source>
          <target state="translated">MySQL 서버가 클라이언트로 PHP가 아닌 문자 세트를 결정하도록하려면 (오래된 행동; 선호하는 경우 내 의견으로는) &lt;code&gt;skip-character-set-client-handshake&lt;/code&gt; 를 &lt;code&gt;my.cnf&lt;/code&gt; 의 &lt;code&gt;[mysqld]&lt;/code&gt; 아래에 추가하십시오. &lt;code&gt;mysql&lt;/code&gt; 을 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b48374e9bd1777c30f301bbd9674e2da8787a738" translate="yes" xml:space="preserve">
          <source>If you're stuck with plain &lt;a href=&quot;http://php.net/manual/en/book.mysql.php&quot;&gt;mysql&lt;/a&gt; but happen to be running PHP &amp;ge; 5.2.3, you can call &lt;a href=&quot;http://php.net/manual/en/function.mysql-set-charset.php&quot;&gt;&lt;code&gt;mysql_set_charset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 &lt;a href=&quot;http://php.net/manual/en/book.mysql.php&quot;&gt;mysql&lt;/a&gt; 이 붙어 있지만 PHP &amp;ge; 5.2.3을 실행하는 경우 &lt;a href=&quot;http://php.net/manual/en/function.mysql-set-charset.php&quot;&gt; &lt;code&gt;mysql_set_charset&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9335d436ae15d41a84ad0b6a7a0f197c72f6f00b" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;http://www.php.net/manual/en/book.mysqli.php&quot;&gt;mysqli&lt;/a&gt;, you can call &lt;a href=&quot;http://php.net/manual/en/mysqli.set-charset.php&quot;&gt;&lt;code&gt;set_charset()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/book.mysqli.php&quot;&gt;mysqli를&lt;/a&gt; 사용하는 경우 &lt;a href=&quot;http://php.net/manual/en/mysqli.set-charset.php&quot;&gt; &lt;code&gt;set_charset()&lt;/code&gt; &lt;/a&gt; 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fefe169ac2e400b0fc6ab51769c9866a48bc28e9" translate="yes" xml:space="preserve">
          <source>If you're using the &lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; abstraction layer with PHP &amp;ge; 5.3.6, you can specify &lt;code&gt;charset&lt;/code&gt; in the &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;DSN&lt;/a&gt;:</source>
          <target state="translated">PHP &amp;ge; 5.3.6에서 &lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; 추상화 계층을 사용하는 경우 &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;DSN&lt;/a&gt; 에서 &lt;code&gt;charset&lt;/code&gt; 를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1898bc147327787e953f78d4016b5c48e60e87ad" translate="yes" xml:space="preserve">
          <source>If your application transmits text to other systems, they will also need to be informed of the character encoding.  With web applications, the browser must be informed of the encoding in which data is sent (through HTTP response headers or &lt;a href=&quot;https://stackoverflow.com/q/4696499&quot;&gt;HTML metadata&lt;/a&gt;).</source>
          <target state="translated">응용 프로그램이 다른 시스템으로 텍스트를 전송하는 경우 문자 인코딩에 대해서도 알려야합니다. 웹 애플리케이션을 사용하면 브라우저에 HTTP 응답 헤더 또는 &lt;a href=&quot;https://stackoverflow.com/q/4696499&quot;&gt;HTML 메타 데이터를&lt;/a&gt; 통해 데이터가 전송되는 인코딩을 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="a129ed10d5f803fb83e471303457dc258c00ea47" translate="yes" xml:space="preserve">
          <source>In PHP, you can use the &lt;a href=&quot;http://www.php.net/manual/en/ini.core.php#ini.default-charset&quot;&gt;&lt;code&gt;default_charset&lt;/code&gt;&lt;/a&gt; php.ini option, or manually issue the &lt;code&gt;Content-Type&lt;/code&gt; MIME header yourself, which is just more work but has the same effect.</source>
          <target state="translated">PHP에서는 &lt;a href=&quot;http://www.php.net/manual/en/ini.core.php#ini.default-charset&quot;&gt; &lt;code&gt;default_charset&lt;/code&gt; &lt;/a&gt; php.ini 옵션을 사용하거나 직접 &lt;code&gt;Content-Type&lt;/code&gt; MIME 헤더를 직접 발행 할 수 있습니다. 이는 더 많은 작업이지만 효과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f8b2b69a6838665fed13eb36c4fcec2f4b757c01" translate="yes" xml:space="preserve">
          <source>In PHP, you'll need to either use the &lt;a href=&quot;http://us2.php.net/manual/en/ref.mbstring.php&quot;&gt;multibyte functions&lt;/a&gt;, or turn on &lt;a href=&quot;http://us2.php.net/manual/en/mbstring.configuration.php&quot;&gt;mbstring.func_overload&lt;/a&gt;. That way things like strlen will work if you have characters that take more than one byte.</source>
          <target state="translated">PHP에서는 &lt;a href=&quot;http://us2.php.net/manual/en/ref.mbstring.php&quot;&gt;멀티 바이트 함수&lt;/a&gt; 를 사용하거나 &lt;a href=&quot;http://us2.php.net/manual/en/mbstring.configuration.php&quot;&gt;mbstring.func_overload를&lt;/a&gt; 켜야합니다. 그렇게하면 1 바이트 이상을 차지하는 문자가 있으면 strlen과 같은 것이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fd2b6ceb2f874d60fca2e4bd22ed6eeb8d7bd6c0" translate="yes" xml:space="preserve">
          <source>In addition to setting &lt;code&gt;default_charset&lt;/code&gt; in php.ini, you can send the correct charset using &lt;code&gt;header()&lt;/code&gt; from within your code, before any output:</source>
          <target state="translated">php.ini에서 &lt;code&gt;default_charset&lt;/code&gt; 을 설정하는 것 외에도, 출력 전에 코드 내에서 &lt;code&gt;header()&lt;/code&gt; 를 사용하여 올바른 문자 세트를 보낼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe91ce9865b5ecd79f40561addba9ba37c3cced6" translate="yes" xml:space="preserve">
          <source>In my case, I was using &lt;code&gt;mb_split&lt;/code&gt;, which uses regex.  Therefore I also had to manually make sure the regex encoding was utf-8 by doing &lt;code&gt;mb_regex_encoding('UTF-8');&lt;/code&gt;</source>
          <target state="translated">필자의 경우 정규식을 사용하는 &lt;code&gt;mb_split&lt;/code&gt; 을 사용하고 있었습니다 . 따라서 &lt;code&gt;mb_regex_encoding('UTF-8');&lt;/code&gt; 을 수행하여 정규식 인코딩이 utf-8인지 수동으로 확인해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="632241254f08ee5d73bd409b1d0c460dc9788224" translate="yes" xml:space="preserve">
          <source>In older versions of MySQL (&amp;lt; 5.5.3), you'll unfortunately be forced to use simply &lt;code&gt;utf8&lt;/code&gt;, which only supports a subset of Unicode characters.  I wish I were kidding.</source>
          <target state="translated">이전 버전의 MySQL (&amp;lt;5.5.3)에서는 불행히도 유니 코드 문자의 하위 집합 만 지원하는 단순히 &lt;code&gt;utf8&lt;/code&gt; 을 사용해야합니다. 농담하길 바래</target>
        </trans-unit>
        <trans-unit id="912a06bcfd3e9f52c102e2c87f7a921de2afc61b" translate="yes" xml:space="preserve">
          <source>In your application code (e.g. PHP), in whatever DB access method you use, you'll need to set the connection charset to &lt;code&gt;utf8mb4&lt;/code&gt;.  This way, MySQL does no conversion from its native UTF-8 when it hands data off to your application and vice versa.</source>
          <target state="translated">애플리케이션 코드 (예 : PHP)에서 사용하는 DB 액세스 방법에 관계없이 연결 문자셋을 &lt;code&gt;utf8mb4&lt;/code&gt; 로 설정해야합니다. 이런 식으로 MySQL은 데이터를 응용 프로그램에 전달하거나 그 반대로 전달할 때 기본 UTF-8에서 변환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0172cb92edbbc5688d0590b316c09f7a6bbc4e25" translate="yes" xml:space="preserve">
          <source>It turned out the page was missing the META tag. Adding that solved the problem.</source>
          <target state="translated">페이지에 META 태그가 누락되었습니다. 그것을 추가하면 문제가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="85cccc55a91ff650683ca4dcbe18b519c3e551fa" translate="yes" xml:space="preserve">
          <source>Just a note:</source>
          <target state="translated">참고 사항 :</target>
        </trans-unit>
        <trans-unit id="cb62b45096d74bf04e878b551336ed27b3e70bfb" translate="yes" xml:space="preserve">
          <source>Message formatting (replaces gettext)</source>
          <target state="translated">메시지 형식 (gettext를 대체 함)</target>
        </trans-unit>
        <trans-unit id="2918c4d5af1ec648f31fc83cb72666722f8d463c" translate="yes" xml:space="preserve">
          <source>Number formatting</source>
          <target state="translated">숫자 서식</target>
        </trans-unit>
        <trans-unit id="c2e15a99804f3111c87710df5b8bbc36c1b58676" translate="yes" xml:space="preserve">
          <source>Obviously enough, all files you'll be serving (PHP, HTML, JavaScript, etc.) should be encoded in valid UTF-8.</source>
          <target state="translated">분명히 제공 할 모든 파일 (PHP, HTML, JavaScript 등)은 유효한 UTF-8로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a5f4b2172d0ba6cdfc6374714fe97f6276fa2ba" translate="yes" xml:space="preserve">
          <source>Output buffer handler</source>
          <target state="translated">출력 버퍼 핸들러</target>
        </trans-unit>
        <trans-unit id="26f5d9263b944f4ffea960d76ef426383723d981" translate="yes" xml:space="preserve">
          <source>Plain text is not plain text, files have encodings</source>
          <target state="translated">일반 텍스트는 일반 텍스트가 아니며 파일에는 인코딩이 있습니다.</target>
        </trans-unit>
        <trans-unit id="224f0139fffbe62aa800883b0c73169a34b8189f" translate="yes" xml:space="preserve">
          <source>Primary for charset conversion</source>
          <target state="translated">문자셋 변환의 기본</target>
        </trans-unit>
        <trans-unit id="3c79dbd6ac5538d78945198363b90c930673b12a" translate="yes" xml:space="preserve">
          <source>Provides some wrappers for funtionallity such as strtoupper</source>
          <target state="translated">strtoupper와 같은 기능을위한 래퍼를 제공합니다</target>
        </trans-unit>
        <trans-unit id="02be837b723fb590d4a8ea4f2058a4f78cd91434" translate="yes" xml:space="preserve">
          <source>Resource bundles</source>
          <target state="translated">리소스 번들</target>
        </trans-unit>
        <trans-unit id="a37fde2217f946af090ae60ac59301f33e9bece6" translate="yes" xml:space="preserve">
          <source>Send everything in ASCII if you are using exec, proc_open and other command line calls</source>
          <target state="translated">exec, proc_open 및 기타 명령 줄 호출을 사용하는 경우 ASCII로 모든 것을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="65ad3613d563f20af3dd93010f55f976016b3a60" translate="yes" xml:space="preserve">
          <source>Setting the HTTP charset parameter</source>
          <target state="translated">HTTP 문자 세트 매개 변수 설정</target>
        </trans-unit>
        <trans-unit id="637e537c6a0662f94014b3a6e3ff7ff53ba32088" translate="yes" xml:space="preserve">
          <source>Some drivers provide their own mechanism for configuring the connection character set, which both updates its own internal state and informs MySQL of the encoding to be used on the connection&amp;mdash;this is usually the preferred approach.   In PHP:</source>
          <target state="translated">일부 드라이버는 자체 내부 상태를 업데이트하고 연결에 사용될 인코딩을 MySQL에 알리는 연결 문자 세트 구성을위한 자체 메커니즘을 제공합니다. 이는 일반적으로 선호되는 방법입니다. PHP에서 :</target>
        </trans-unit>
        <trans-unit id="207a48134f0b853aa739eb8c5d3372fb7a7e2ef7" translate="yes" xml:space="preserve">
          <source>Sometime ago i had someone ask me to add utf8 support for a php/mysql application designed by someone else, i noticed that all files were encoded in ANSI, so I had to use ICONV to convert all files, change the database tables to use the utf8 charset and utf8_general_ci collate, add 'SET NAMES utf8' to the database abstraction layer after the connection (if using 5.3.6 or earlier otherwise you have to use charset=utf8 in the connection string) and change string functions to use the php multibyte string functions equivalent.</source>
          <target state="translated">언젠가 누군가 누군가가 디자인 한 php / mysql 응용 프로그램에 대해 utf8 지원을 추가하도록 요청했습니다. 모든 파일이 ANSI로 인코딩 된 것을 알았으므로 ICONV를 사용하여 모든 파일을 변환하고 데이터베이스 테이블을 사용하도록 변경해야했습니다. utf8 문자셋과 utf8_general_ci 조합, 연결 후 데이터베이스 추상화 계층에 'SET NAMES utf8'을 추가하고 (5.3.6 이하를 사용하는 경우 연결 문자열에 charset = utf8을 사용해야 함) php 멀티 바이트를 사용하도록 문자열 함수를 변경하십시오. 문자열 함수에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b7ca532411e2a0f37bc7c62898bcacc6895fc8b7" translate="yes" xml:space="preserve">
          <source>Specify the &lt;code&gt;utf8mb4&lt;/code&gt; character set on all tables and text columns in your database.  This makes MySQL physically store and retrieve values encoded natively in UTF-8.  Note that MySQL will implicitly use &lt;code&gt;utf8mb4&lt;/code&gt; encoding if a &lt;code&gt;utf8mb4_*&lt;/code&gt; collation is specified (without any explicit character set).</source>
          <target state="translated">데이터베이스의 모든 테이블 및 텍스트 열에 &lt;code&gt;utf8mb4&lt;/code&gt; 문자 세트를 지정하십시오. 따라서 MySQL은 기본적으로 UTF-8로 인코딩 된 값을 실제로 저장하고 검색합니다. MySQL은 &lt;code&gt;utf8mb4_*&lt;/code&gt; 데이터 정렬이 명시 적 문자 집합없이 지정된 경우 암시 적으로 &lt;code&gt;utf8mb4&lt;/code&gt; 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="01ef8e43542fd0225f4be2d16d90a14a1985274c" translate="yes" xml:space="preserve">
          <source>Spoofchecker</source>
          <target state="translated">Spoofchecker</target>
        </trans-unit>
        <trans-unit id="b7adc98398543c6ac7fdfa87ff652b753458844a" translate="yes" xml:space="preserve">
          <source>Standardised locales, set locale per script</source>
          <target state="translated">표준화 된 로캘, 스크립트 당 로캘 설정</target>
        </trans-unit>
        <trans-unit id="9cef3ed7b1d2767b1b75b7e0cfa79ac5b57098ba" translate="yes" xml:space="preserve">
          <source>Stream Filter &lt;code&gt;stream_filter_append($fp, 'convert.iconv.ISO-2022-JP/EUC-JP')&lt;/code&gt;</source>
          <target state="translated">스트림 필터 &lt;code&gt;stream_filter_append($fp, 'convert.iconv.ISO-2022-JP/EUC-JP')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f5b5d04b61b87167f4ce215be3349bb000ca275" translate="yes" xml:space="preserve">
          <source>Supports transparent HTTP in/out encoding</source>
          <target state="translated">투명한 HTTP 인 / 아웃 인코딩 지원</target>
        </trans-unit>
        <trans-unit id="582d3a55d7d8925dbd67239e75e1aca1a73af2a6" translate="yes" xml:space="preserve">
          <source>That is mostly because you are testing on &lt;strong&gt;your old data&lt;/strong&gt; which has been inserted to the database using the wrong charset and got converted and stored to actually the question mark characters &lt;code&gt;?&lt;/code&gt;. Which means you lost your original text forever and no matter what you try you will get &lt;code&gt;???????&lt;/code&gt;.</source>
          <target state="translated">잘못된 문자셋을 사용하여 데이터베이스에 삽입되어 실제로 물음표 문자로 변환되어 저장된 &lt;strong&gt;오래된 데이터&lt;/strong&gt; 를 테스트하기 때문입니다 &lt;code&gt;?&lt;/code&gt; . 그것은 당신이 당신의 원본 텍스트를 영원히 잃어버린 것을 의미하며 당신이 무엇을 시도하든 당신은 &lt;code&gt;???????&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f9a141ac6949a7ea66b109b173df0117edc8e5e" translate="yes" xml:space="preserve">
          <source>That seems trivial, but IE7 has given me problems with that before.</source>
          <target state="translated">그것은 사소한 것처럼 보이지만 IE7은 이전에 그 문제를 겪었습니다.</target>
        </trans-unit>
        <trans-unit id="10b31519efe292a65c45c4715e1cf4bb614c331d" translate="yes" xml:space="preserve">
          <source>The W3C actually has a rather large &lt;a href=&quot;http://www.w3.org/International/&quot;&gt;section dedicated to I18N&lt;/a&gt;. They have a number of articles related to this issue &amp;ndash; describing the HTTP, (X)HTML and CSS side of things:</source>
          <target state="translated">W3C는 실제로 &lt;a href=&quot;http://www.w3.org/International/&quot;&gt;I18N 전용&lt;/a&gt; 의 상당히 큰 섹션을 가지고 있습니다. HTTP, (X) HTML 및 CSS 측면을 설명하는이 문제와 관련된 많은 기사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f49ce6fbca1578d556973165019742531ed7c7a" translate="yes" xml:space="preserve">
          <source>The easy part is just specifying the charset in HTTP headers and in the database and such, but none of that matters if your PHP code doesn't output valid UTF8. That's the hard part, and PHP gives you virtually no help there. (I think PHP6 is supposed to fix the worst of this, but that's still a while away)</source>
          <target state="translated">쉬운 부분은 HTTP 헤더와 데이터베이스 등에서 문자 세트를 지정하는 것입니다. 그러나 PHP 코드가 유효한 UTF8을 출력하지 않는 경우에는 아무 문제가 없습니다. 어려운 부분이며, PHP는 거의 도움이되지 않습니다. (PHP6이 이것의 최악의 문제를 해결해야한다고 생각하지만, 아직 멀었습니다.)</target>
        </trans-unit>
        <trans-unit id="2eca6cfca3016461d976cf886468837372d8ba57" translate="yes" xml:space="preserve">
          <source>The only thing I would add to these amazing answers is to emphasize on saving your files in utf8 encoding, i have noticed that browsers accept this property over setting utf8 as your code encoding. Any decent text editor will show you this, for example Notepad++ has a menu option for file enconding, it shows you the current encoding and enables you to change it. For all my php files I use utf8 without BOM.</source>
          <target state="translated">이 놀라운 답변에 추가 할 수있는 유일한 것은 utf8 인코딩으로 파일을 저장하는 것을 강조하는 것입니다. 브라우저는 utf8을 코드 인코딩으로 설정하는 것보다 브라우저 가이 속성을 허용한다는 것을 알았습니다. 예를 들어 메모장 ++에는 파일 인코딩을위한 메뉴 옵션이 있으며 현재 인코딩을 보여주고 변경할 수 있습니다. 모든 PHP 파일에는 BOM없이 utf8을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aabb4fa7740be048d6bc94be8a99701c67c6887f" translate="yes" xml:space="preserve">
          <source>The same consideration regarding &lt;code&gt;utf8mb4&lt;/code&gt;/&lt;code&gt;utf8&lt;/code&gt; applies as above.</source>
          <target state="translated">&lt;code&gt;utf8mb4&lt;/code&gt; / &lt;code&gt;utf8&lt;/code&gt; 에 대한 동일한 고려 사항이 위와 같이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d3149418384152b6a8646b1e2c84fb2829d07735" translate="yes" xml:space="preserve">
          <source>The site I took this from is down, but I was able to get it using the Google cache, luckily.</source>
          <target state="translated">내가 가져온 사이트는 다운되었지만 운 좋게도 Google 캐시를 사용하여 얻을 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="de921e19c600d4a63955aee66d84ee2993f8c2d6" translate="yes" xml:space="preserve">
          <source>The solution was to use</source>
          <target state="translated">해결책은</target>
        </trans-unit>
        <trans-unit id="8d7f8223526b4dbca13f549494d81749c27ce04c" translate="yes" xml:space="preserve">
          <source>The top answer is excellent. Here is what I had to on a regular debian/php/mysql setup:</source>
          <target state="translated">최고 답변이 우수합니다. 다음은 일반적인 데비안 / php / mysql 설정에서해야 할 일입니다.</target>
        </trans-unit>
        <trans-unit id="2fcce31f6cb0431af1d8ba6779198785476b7250" translate="yes" xml:space="preserve">
          <source>They recommend using both the HTTP header and HTML meta tag (or XML declaration in case of XHTML served as XML).</source>
          <target state="translated">HTTP 헤더와 HTML 메타 태그 (또는 XHTML이 XML로 제공되는 경우 XML 선언)를 모두 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e4ad4bf1f1a927d88ec22e472c9e6b3808e51204" translate="yes" xml:space="preserve">
          <source>This is for a new Linux server, running MySQL 5, PHP, 5 and Apache 2.</source>
          <target state="translated">MySQL 5, PHP, 5 및 Apache 2를 실행하는 새로운 Linux 서버용입니다.</target>
        </trans-unit>
        <trans-unit id="8fa896fbfc35af84e91997a19fde7a200f6410dd" translate="yes" xml:space="preserve">
          <source>This may cause troubles in case you're using anything other than UTF8.</source>
          <target state="translated">UTF8 이외의 것을 사용하는 경우 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a622fad92083ea56438e393bc329df640736daa" translate="yes" xml:space="preserve">
          <source>To know what you're doing (read: not mess it up), you really need to know UTF-8 and how it works on the lowest possible level.  Check out any of the links from &lt;a href=&quot;http://www.utf8.com/&quot;&gt;utf8.com&lt;/a&gt; for some good resources to learn everything you need to know.</source>
          <target state="translated">무엇을하고 있는지 (읽기 : 엉망으로 만들지 않기) 위해서는 UTF-8과 그것이 가능한 최저 수준에서 어떻게 작동하는지 알아야합니다. &lt;a href=&quot;http://www.utf8.com/&quot;&gt;utf8.com&lt;/a&gt; 의 링크를 확인하여 알아야 할 모든 것을 배울 수있는 유용한 자료를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="ba455ba021d7ce65308fca89d0584483a47a8d4e" translate="yes" xml:space="preserve">
          <source>Transliterator</source>
          <target state="translated">Transliterator</target>
        </trans-unit>
        <trans-unit id="efa99878bac8950b369b416ed67b7da66d18ad86" translate="yes" xml:space="preserve">
          <source>Tutorial: Character sets &amp;amp; encodings in XHTML, HTML and CSS</source>
          <target state="translated">학습서 : XHTML, HTML 및 CSS의 문자 세트 및 인코딩</target>
        </trans-unit>
        <trans-unit id="1a737ada225b54daf9665a302016b367189c3214" translate="yes" xml:space="preserve">
          <source>UTF-8 all the way through</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="4f626a9b47979a2a7f85ee3a003879389665a7e2" translate="yes" xml:space="preserve">
          <source>Unfortunately, you should verify every received string as being valid UTF-8 before you try to store it or use it anywhere.  PHP's &lt;a href=&quot;http://php.net/manual/en/function.mb-check-encoding.php&quot;&gt;&lt;code&gt;mb_check_encoding()&lt;/code&gt;&lt;/a&gt; does the trick, but you have to use it religiously.  There's really no way around this, as malicious clients can submit data in whatever encoding they want, and I haven't found a trick to get PHP to do this for you reliably.</source>
          <target state="translated">불행히도, 수신 한 모든 문자열을 저장하거나 어디서나 사용하기 전에 유효한 UTF-8인지 확인해야합니다. PHP의 &lt;a href=&quot;http://php.net/manual/en/function.mb-check-encoding.php&quot;&gt; &lt;code&gt;mb_check_encoding()&lt;/code&gt; &lt;/a&gt; 이 트릭을 수행하지만 종교적으로 사용해야합니다. 악의적 인 클라이언트가 원하는 인코딩으로 데이터를 제출할 수 있기 때문에이 문제를 해결할 방법이 없습니다. PHP가이 작업을 확실하게 수행 할 수있는 방법을 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="bbbae2a97b532d10d05a657f576cdb6b71bc1b68" translate="yes" xml:space="preserve">
          <source>Unicode support in PHP is still a huge mess. While it's capable of converting an ISO8859 string (which it uses internally) to utf8, it lacks the capability to work with unicode strings natively, which means all the string processing functions will mangle and corrupt your strings. So you have to either use a separate library for proper utf8 support, or rewrite all the string handling functions yourself.</source>
          <target state="translated">PHP에서의 유니 코드 지원은 여전히 ​​엉망입니다. 내부적으로 사용되는 ISO8859 문자열을 utf8로 변환 할 수는 있지만 유니 코드 문자열을 기본적으로 사용할 수있는 기능이 없기 때문에 모든 문자열 처리 기능이 문자열을 엉망으로 만들 수 있습니다. 따라서 적절한 utf8 지원을 위해 별도의 라이브러리를 사용하거나 모든 문자열 처리 기능을 직접 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="accd4b912118c7e4a7de25740b3e4c5a2c86712e" translate="yes" xml:space="preserve">
          <source>View Source</source>
          <target state="translated">소스보기</target>
        </trans-unit>
        <trans-unit id="48675f90267ddcde6fd852648cbdedc142bb7d96" translate="yes" xml:space="preserve">
          <source>When encoding the output using &lt;code&gt;json_encode()&lt;/code&gt;, add &lt;code&gt;JSON_UNESCAPED_UNICODE&lt;/code&gt; as a second parameter.</source>
          <target state="translated">&lt;code&gt;json_encode()&lt;/code&gt; 사용하여 출력을 인코딩 할 때 &lt;code&gt;JSON_UNESCAPED_UNICODE&lt;/code&gt; 를 두 번째 매개 변수로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="15727aa8a979f4b718bd9a96ec3508ca46061cc8" translate="yes" xml:space="preserve">
          <source>Where exactly do I need to set the encoding/charsets? I'm aware that I need to configure Apache, MySQL, and PHP to do this &amp;mdash; is there some standard checklist I can follow, or perhaps troubleshoot where the mismatches occur?</source>
          <target state="translated">인코딩 / 문자 세트를 정확히 어디에 설정해야합니까? 이를 위해 Apache, MySQL 및 PHP를 구성해야한다는 것을 알고 있습니다. 따라야 할 표준 체크리스트가 있습니까?</target>
        </trans-unit>
        <trans-unit id="cbbf06985cb0082a248a4aaa3458b7838a14f917" translate="yes" xml:space="preserve">
          <source>Working with Unicode in PHP is easy as long as you realize that most of the &lt;strong&gt;string functions don't work with Unicode, and some might mangle strings completely&lt;/strong&gt;. PHP considers &quot;characters&quot; to be 1 byte long. Sometimes this is okay (for example, &lt;code&gt;explode()&lt;/code&gt; only looks for a byte sequence and uses it as a separator -- so it doesn't matter what actual characters you look for). But other times, when the function is actually designed to work on &lt;em&gt;characters&lt;/em&gt;, PHP has no idea that your text has multi-byte characters that are found with Unicode.</source>
          <target state="translated">대부분의 &lt;strong&gt;문자열 함수가 유니 코드에서 작동하지 않으며 일부는 문자열을 완전히 엉망&lt;/strong&gt; 으로 만들 수 있다는 점을 알고 있다면 PHP에서 유니 코드로 작업하는 것은 쉽습니다. PHP는 &quot;문자&quot;가 1 바이트 길이 인 것으로 간주합니다. 때때로 이것은 괜찮습니다 (예를 들어, &lt;code&gt;explode()&lt;/code&gt; 는 바이트 시퀀스 만 찾아서 분리 자로 사용하므로 실제 문자는 중요하지 않습니다). 그러나 다른 경우에, 함수가 실제로 &lt;em&gt;문자&lt;/em&gt; 에서 작동하도록 설계되었을 때, PHP는 텍스트에 유니 코드로 찾은 멀티 바이트 문자가 있다는 것을 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="6655db021e6fed68cec4c59ba76e1b3c487b6f57" translate="yes" xml:space="preserve">
          <source>Wrapper around ICU library</source>
          <target state="translated">ICU 라이브러리를 감싸는 래퍼</target>
        </trans-unit>
        <trans-unit id="2ae0ed48e37f2e02e46f33b03b7510c47ed8cefa" translate="yes" xml:space="preserve">
          <source>You are facing the problem of your non-latin characters is showing as &lt;code&gt;?????????&lt;/code&gt; , you asked a question, and it got closed with a reference to this canonical question, you tried everything and no matter what you do you still get &lt;code&gt;??????????&lt;/code&gt; from &lt;code&gt;MySQL&lt;/code&gt;.</source>
          <target state="translated">비 라틴 문자의 문제가 &lt;code&gt;?????????&lt;/code&gt; , 질문을했는데,이 정식 질문에 대한 참조로 닫혔습니다. 무엇을하든 상관없이 모든 것을 시도했습니다. &lt;code&gt;MySQL&lt;/code&gt; 에서 .</target>
        </trans-unit>
        <trans-unit id="5b164784fa8f261338cec31e801b8e72a1828dc7" translate="yes" xml:space="preserve">
          <source>You can convert files on the fly with the iconv filter</source>
          <target state="translated">iconv 필터를 사용하여 파일을 즉석에서 변환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d403e71451a2f19d8575749fcd05090e7e348288" translate="yes" xml:space="preserve">
          <source>You cannot use unicode filenames with PHP and windows unless you use a 3rd part extension.</source>
          <target state="translated">세 번째 부분 확장명을 사용하지 않으면 PHP 및 창에서 유니 코드 파일 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b37a9d9e415bc8221c1b11d04ca54c6a6648f23" translate="yes" xml:space="preserve">
          <source>You need to make sure that every time you process a UTF-8 string, you do so safely.  This is, unfortunately, the hard part.  You'll probably want to make extensive use of PHP's &lt;a href=&quot;http://www.php.net/manual/en/book.mbstring.php&quot;&gt;&lt;code&gt;mbstring&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">UTF-8 문자열을 처리 할 때마다 안전하게 처리해야합니다. 불행히도 이것은 어려운 부분입니다. PHP의 &lt;a href=&quot;http://www.php.net/manual/en/book.mbstring.php&quot;&gt; &lt;code&gt;mbstring&lt;/code&gt; &lt;/a&gt; 확장을 광범위하게 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="48f40e3284384ba88de282b171078281c9e11cac" translate="yes" xml:space="preserve">
          <source>You'll also need to identify the character set of your responses. You can either use AddDefaultCharset, as above, or write PHP code that returns the header. (Or you can add a META tag to your HTML documents.)</source>
          <target state="translated">응답의 문자 세트를 식별해야합니다. 위와 같이 AddDefaultCharset을 사용하거나 헤더를 반환하는 PHP 코드를 작성할 수 있습니다. 또는 HTML 문서에 META 태그를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21faa67da1fdbfe3a5a17ee67b0e79f4017e8bfc" translate="yes" xml:space="preserve">
          <source>conversion</source>
          <target state="translated">conversion</target>
        </trans-unit>
        <trans-unit id="d6b88f784ad82597b546d77bd5d819d1ae014a0d" translate="yes" xml:space="preserve">
          <source>good luck!</source>
          <target state="translated">행운을 빕니다!</target>
        </trans-unit>
        <trans-unit id="dc7ad30ba9ebdea9c06f78450dfe81e3e379c9e9" translate="yes" xml:space="preserve">
          <source>if you want a mysql solution,  I had similar issues with 2 of my projects, after a server migration. After searching and trying a lot of solutions i came across with this one /nothing before this one worked):</source>
          <target state="translated">mysql 솔루션을 원한다면 서버 마이그레이션 후 2 개의 프로젝트와 비슷한 문제가 있습니다. 많은 솔루션을 검색하고 시도한 후이 솔루션을 사용하기 전에이 솔루션을 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="5858c8fc80c96241aabb9bf1ac3cedfc7e5fde56" translate="yes" xml:space="preserve">
          <source>mb_ uses MultiByte. It supports more characters but in general is a little slower.</source>
          <target state="translated">mb_는 멀티 바이트를 사용합니다. 더 많은 문자를 지원하지만 일반적으로 조금 느립니다.</target>
        </trans-unit>
        <trans-unit id="ca9725ab9df433013617c6d2b1f80b15fec7783f" translate="yes" xml:space="preserve">
          <source>mime encoding functionality</source>
          <target state="translated">마임 인코딩 기능</target>
        </trans-unit>
        <trans-unit id="6753bf8acd23a41246a8480a0f2c510fcd3782e5" translate="yes" xml:space="preserve">
          <source>mysql: Charset and collation on tables and on connection (not the collation). Also don't use mysql - msqli or PDO</source>
          <target state="translated">mysql : 테이블과 연결시 문자셋과 콜 레이션 (콜 레이션이 아님). 또한 MySQL을 사용하지 마십시오-msqli 또는 PDO</target>
        </trans-unit>
        <trans-unit id="72878135f7c3cf76c8c397477c2b790c3bfe5f9a" translate="yes" xml:space="preserve">
          <source>postgresql: pg_set_client_encoding</source>
          <target state="translated">postgresql : pg_set_client_encoding</target>
        </trans-unit>
        <trans-unit id="e75417cec808d303c6a86e1996166bafc1abc546" translate="yes" xml:space="preserve">
          <source>re applying what you have learned from the answers of this question on a fresh data could solve your problem.</source>
          <target state="translated">이 질문에 대한 답변에서 얻은 내용을 새로운 데이터에 다시 적용하면 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6333cd52beca5bbacde284512084b655544c695" translate="yes" xml:space="preserve">
          <source>some string helpers (len, substr, strpos, strrpos)</source>
          <target state="translated">일부 문자열 도우미 (len, substr, strpos, strrpos)</target>
        </trans-unit>
        <trans-unit id="ef364574a8f0d1be78900349f12be514ef88db95" translate="yes" xml:space="preserve">
          <source>sqlite(3): Make sure it was compiled with unicode and intl support</source>
          <target state="translated">sqlite (3) : 유니 코드 및 국제 지원으로 컴파일되었는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="2f27ef05bfa13338492e0888a52b4b98262e6258" translate="yes" xml:space="preserve">
          <source>that was all !</source>
          <target state="translated">그게 전부였다 !</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
