<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/7244321">
    <body>
      <group id="7244321">
        <trans-unit id="837239dc1752aa33767206805faadce95726829a" translate="yes" xml:space="preserve">
          <source>(I use Android Studio 3.0 with &quot;Git integration&quot; and &quot;GitHub&quot; plugins.)</source>
          <target state="translated">&quot;Git 통합&quot;및 &quot;GitHub&quot;플러그인과 함께 Android Studio 3.0을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f7bddf7f104c215149d89a27e04f9f82c5bdae57" translate="yes" xml:space="preserve">
          <source>, all commits will be made &quot;with&quot; you, the original PRs will link to your PR, and GitHub will display &lt;code&gt;This branch is X commits ahead, Y commits behind &amp;lt;original fork&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">, 모든 커밋이 &quot;함께&quot;이루어지고, 원래 PR이 PR에 연결되며, GitHub에이 &lt;code&gt;This branch is X commits ahead, Y commits behind &amp;lt;original fork&amp;gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="fa18006684a6730be7d42134f2ce945e1ca9dfd5" translate="yes" xml:space="preserve">
          <source>, but don't click anything yet.</source>
          <target state="translated">을 클릭하지만 아직 아무것도 클릭하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aed7f30b6eec6bdad869eaf0cc6d252d35ce10dd" translate="yes" xml:space="preserve">
          <source>. By default, GitHub will compare the original with your fork, and there shouldn't be anything to compare if you didn't make any changes.</source>
          <target state="translated">. 기본적으로 GitHub는 원본을 포크와 비교하므로 변경하지 않은 경우 비교할 내용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e288959c997c74dcab4f214316ce37256bb0e82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Create Pull Request&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;풀 요청 생성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dec1ee12cc0ee47690f681d5af701402e2a059e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rebase my GitHub fork&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;내 GitHub 포크 리베이스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c23532b197c28f5e2c167d5de1d1410ac36f24a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tip: If you want to update your repository on GitHub, follow the instructions &lt;a href=&quot;https://help.github.com/articles/pushing-to-a-remote#pushing-a-branch&quot;&gt;here&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;팁 : GitHub에서 리포지토리를 업데이트하려면 &lt;a href=&quot;https://help.github.com/articles/pushing-to-a-remote#pushing-a-branch&quot;&gt;여기&lt;/a&gt; 지침을 따르십시오&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ef67562961602cb5e06540f46c6ad69d781b01e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tip: Syncing your fork only updates your local copy of the repository; it does not update your repository on GitHub.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;팁 : 포크를 동기화하면 저장소의 로컬 사본 만 업데이트됩니다.&lt;/em&gt; &lt;em&gt;GitHub에서 리포지토리를 업데이트하지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091a67df8cb7e3a2e39438a2304cecc9cfcd7fa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Create the branches&lt;/strong&gt; from the fork master and &lt;strong&gt;do changes there&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; 포크 마스터에서 &lt;strong&gt;분기&lt;/strong&gt; 를 &lt;strong&gt;작성하고&lt;/strong&gt; &lt;strong&gt;변경하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ace59f481ab2e485809074bf3421337f65d1e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Create a scheduled job&lt;/strong&gt; for the fork master to &lt;strong&gt;do update automatically&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; 포크 마스터가 &lt;strong&gt;자동으로 갱신&lt;/strong&gt; 되도록 &lt;strong&gt;스케줄 된 작업&lt;/strong&gt; 을 &lt;strong&gt;작성하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8c6ef361872ea9dca75b25f08ab190d9ab77471d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Checkout to your branch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지점으로 결제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cba2c022702bc7188073aa3405c4473f2a91a47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; git checkout master</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 자식 체크 아웃 마스터</target>
        </trans-unit>
        <trans-unit id="d2f1180576dd05c72a3829a89721f20a338e1252" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&quot;&gt;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&lt;/a&gt; BRANCH_NAME</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&quot;&gt;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&lt;/a&gt; BRANCH_NAME</target>
        </trans-unit>
        <trans-unit id="038223c0b4eee8eb40e89e3334da6a52eeaaf53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Foreword:&lt;/strong&gt; Your fork is the &quot;origin&quot; and the repository you forked from is the &quot;upstream&quot;.</source>
          <target state="translated">&lt;strong&gt;서문 :&lt;/strong&gt; 포크는 &quot;원본&quot;이고 포크 한 저장소는 &quot;업스트림&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="83675adcd63528ba85b7735bf175b9ad961c21e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If that is given then you need to continue in this order:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그것이 주어지면 다음 순서로 계속 진행해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d7bc8b4919bc01d463826deb19d44e1b4e26951" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the meantime, GitHub user bardiharborow has created a tool to do just this:&lt;/strong&gt;&lt;a href=&quot;https://upriver.github.io/&quot;&gt;https://upriver.github.io/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;한편, GitHub 사용자 bardiharborow는&lt;/strong&gt; &lt;a href=&quot;https://upriver.github.io/&quot;&gt;https://upriver.github.io/&lt;/a&gt; &lt;strong&gt;를 수행하기위한 도구를 만들었습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c53483308246ab7077bf1fbd5790e40c6ffb4674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pull source repository branch for getting the latest code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;최신 코드를 얻기위한 풀 소스 리포지토리 분기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39f7deb9c8e2585fec4fb5fb5b57b3fefb8ec63d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax:&lt;/strong&gt; git branch yourDevelopmentBranch</source>
          <target state="translated">&lt;strong&gt;구문 :&lt;/strong&gt; 자식 분기 yourDevelopmentBranch</target>
        </trans-unit>
        <trans-unit id="30519498f0f744e1c306f5deb9b11dd9dc3422bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax:&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/tastejs/awesome-app-ideas&quot;&gt;https://github.com/tastejs/awesome-app-ideas&lt;/a&gt; master</source>
          <target state="translated">&lt;strong&gt;구문 :&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/tastejs/awesome-app-ideas&quot;&gt;https://github.com/tastejs/awesome-app-ideas&lt;/a&gt; master</target>
        </trans-unit>
        <trans-unit id="c22468d3a019b313d1bce8c15882b7e2dc72ab9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This branch is even with &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt;:master&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;이 분기에는 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; : master도&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="836dd07f6d51bd7c72878311bf22a4ef9c537100" translate="yes" xml:space="preserve">
          <source>A few days later another change was made by another contributor. So my fork doesn't contain that change.</source>
          <target state="translated">며칠 후 다른 기고자가 다른 변경을가했습니다. 그래서 내 포크에는 그 변화가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d111dda0df7611e4a760ea8349943d255c38c603" translate="yes" xml:space="preserve">
          <source>A lot of answers end up moving your fork &lt;strong&gt;one commit ahead&lt;/strong&gt; of the parent repository. This answer summarizes the steps found &lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;here&lt;/a&gt; which will &lt;strong&gt;move your fork to the same commit as the parent&lt;/strong&gt;.</source>
          <target state="translated">많은 답변이 부모 저장소 &lt;strong&gt;보다 한 번 커밋을&lt;/strong&gt; 포크로 이동시킵니다. 이 답변은 &lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;여기&lt;/a&gt; 에서 찾은 단계를 요약 &lt;strong&gt;하여 포크를 부모와 같은 커밋으로 이동시킵니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a571dcfb301530d4534f671f455e5eca37543f4b" translate="yes" xml:space="preserve">
          <source>Actually, it is possible to create a branch in your fork from any commit of the upstream in the browser:</source>
          <target state="translated">실제로 브라우저의 업스트림 커밋에서 분기에 분기를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f88b6685a748abb35be251ed6735d785185f6ea" translate="yes" xml:space="preserve">
          <source>Add the &quot;upstream&quot; to your cloned repository (&quot;origin&quot;):</source>
          <target state="translated">&quot;업스트림&quot;을 복제 된 저장소 ( &quot;origin&quot;)에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5a08ed9da2ad311b22c813f50ad5770b2a215a0a" translate="yes" xml:space="preserve">
          <source>Add the parent as a remote repository, &lt;code&gt;git remote add upstream &amp;lt;repo-location&amp;gt;&lt;/code&gt;</source>
          <target state="translated">부모를 원격 저장소로 추가하십시오 &lt;code&gt;git remote add upstream &amp;lt;repo-location&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a67e617a769c44bdd8f8d877909cfd92bf6f9b61" translate="yes" xml:space="preserve">
          <source>And pay attention to the two last popup menu items:</source>
          <target state="translated">마지막 두 팝업 메뉴 항목에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="77b29e62e23f78b86305bbbc7a82f5e4ee0b7dd6" translate="yes" xml:space="preserve">
          <source>And there you are good to go. All updated changes in the main repository will be pushed into your fork repository.</source>
          <target state="translated">그리고 당신은 갈 수 있습니다. 기본 저장소에서 업데이트 된 모든 변경 사항이 포크 저장소로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="735bbd6e19a781c73f9b39e632cb76b45edb8e9a" translate="yes" xml:space="preserve">
          <source>Android Studio now has learned to work with GitHub fork repositories (you don't even have to add &quot;upstream&quot; remote repository by console command).</source>
          <target state="translated">Android Studio는 이제 GitHub 포크 리포지토리를 사용하는 방법을 배웠습니다 (콘솔 명령으로 &quot;업스트림&quot;원격 리포지토리를 추가 할 필요조차 없음).</target>
        </trans-unit>
        <trans-unit id="b862909c99578f4b84baffee2fcba870c7bb3d2b" translate="yes" xml:space="preserve">
          <source>Any of these branch sync commands may fail for one of two reasons: either the &lt;em&gt;upstream&lt;/em&gt; branch have been rewritten, or you have pushed commits on that branch to your fork. In the first case where you haven't committed anything to the branch on your fork it is safe to push forcefully (Add the &lt;strong&gt;-f&lt;/strong&gt; switch; i.e. &lt;code&gt;git push -f&lt;/code&gt; in the command above). In the other case this is normal as your fork branch have diverged and you can't expect the sync command to work until your commits have been merged back into &lt;em&gt;upstream&lt;/em&gt;.</source>
          <target state="translated">이러한 분기 동기화 명령은 다음 두 가지 이유 중 하나로 실패 할 수 있습니다. &lt;em&gt;업스트림&lt;/em&gt; 분기가 다시 작성되었거나 해당 분기의 커밋을 분기로 푸시했습니다. 포크의 브랜치에 아무것도 커밋하지 않은 첫 번째 경우 강제로 푸시하는 것이 안전합니다 (위의 명령에서 &lt;strong&gt;-f&lt;/strong&gt; 스위치, 즉 &lt;code&gt;git push -f&lt;/code&gt; 추가). 다른 경우에는 분기가 분기되어 커밋이 다시 &lt;em&gt;업스트림&lt;/em&gt; 으로 병합 될 때까지 sync 명령이 작동 할 것으로 예상 할 때 이는 정상입니다.</target>
        </trans-unit>
        <trans-unit id="2bc1aaa72c608f4cf6f7c42e3a16c71cd5f587a7" translate="yes" xml:space="preserve">
          <source>As a complement to this answer, I was looking for a way to update all remote branches of my cloned repo (&lt;em&gt;origin&lt;/em&gt;) from &lt;em&gt;upstream&lt;/em&gt; branches in one go. This is how I did it.</source>
          <target state="translated">이 답변을 보완하기 위해 &lt;em&gt;업스트림&lt;/em&gt; 브랜치에서 복제 된 리포지토리 ( &lt;em&gt;원점&lt;/em&gt; )의 모든 원격 브랜치를 한 번에 업데이트하는 방법을 찾고있었습니다. 이것이 내가 한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a9b4790fc412d85990b1d6a052f870d7a70a17fe" translate="yes" xml:space="preserve">
          <source>As of the date of this answer, GitHub has not (&lt;a href=&quot;https://github.com/blog/266-fast-forward-your-fork&quot;&gt;or shall I say no longer?&lt;/a&gt;) this feature in the web interface. You can, however, ask &lt;code&gt;support@github.com&lt;/code&gt; to add your vote for that.</source>
          <target state="translated">이 답변 날짜 현재 GitHub는 웹 인터페이스에서이 기능을 사용하지 않습니다 ( &lt;a href=&quot;https://github.com/blog/266-fast-forward-your-fork&quot;&gt;또는 더 이상 말하지 않겠습니까?&lt;/a&gt; ). 그러나 &lt;code&gt;support@github.com&lt;/code&gt; 에 투표를 추가하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1adc04b7dba016a901bd1df1b78a3ab6cd41900e" translate="yes" xml:space="preserve">
          <source>Assuming you never committed anything on master yourself you should be done already. Now you can push your local master to your origin remote GitHub fork. You could also rebase your development branch on your now up-to-date local master.</source>
          <target state="translated">마스터 자신에게 아무것도 약속하지 않았다고 가정하면 이미 완료해야합니다. 이제 로컬 마스터를 오리진 원격 GitHub 포크로 푸시 할 수 있습니다. 또한 최신 로컬 마스터에 개발 브랜치를 리베이스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e2084f9d86a95da2e8d3b95a5ce00601649747" translate="yes" xml:space="preserve">
          <source>At this stage you check that commits what will be merged by typing &lt;code&gt;git status&lt;/code&gt;</source>
          <target state="translated">이 단계에서 &lt;code&gt;git status&lt;/code&gt; 를 입력하여 병합 할 내용을 커밋했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b9ae2528623f4113c5de53633d5a27b55e035549" translate="yes" xml:space="preserve">
          <source>Before you can sync, you need to add a remote that points to the upstream repository. You may have done this when you originally forked.</source>
          <target state="translated">동기화하기 전에 업스트림 저장소를 가리키는 리모트를 추가해야합니다. 원래 분기했을 때이 작업을 수행했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e8690455bc45922966085b3d33db413219f0a2" translate="yes" xml:space="preserve">
          <source>Change directory to your local repository.</source>
          <target state="translated">디렉토리를 로컬 저장소로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="3fd8a96d486985aff675e7a9223f2ee169b4d761" translate="yes" xml:space="preserve">
          <source>Check your forked repository. From time to time it will always show this notification:</source>
          <target state="translated">갈래 저장소를 확인하십시오. 때때로 항상 다음과 같은 알림이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="79cbc5eb672a54c2b82572afd52f2a6a4f85e598" translate="yes" xml:space="preserve">
          <source>Click</source>
          <target state="translated">Click</target>
        </trans-unit>
        <trans-unit id="071cff0034f6979c282cf4b38b624dc0f9e36bf0" translate="yes" xml:space="preserve">
          <source>Click &quot;Update from user/branch&quot; button the top.</source>
          <target state="translated">상단의 &quot;사용자 / 지점에서 업데이트&quot;버튼을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="ca543cc44bf3a211828d947a183b294a7e9af7ad" translate="yes" xml:space="preserve">
          <source>Click on</source>
          <target state="translated">클릭</target>
        </trans-unit>
        <trans-unit id="3332bb0a8aaeddbc5c4c764802dab7eac1b229dd" translate="yes" xml:space="preserve">
          <source>Click on the &quot;Tree: ....&quot; button.</source>
          <target state="translated">&quot;Tree : ....&quot;버튼을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="f15f54a10c34d555b72ff683c2e2ac900e98d76a" translate="yes" xml:space="preserve">
          <source>Create pull request</source>
          <target state="translated">풀 요청 생성</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="5b40a987f771c491468f8d2c27086ff8829378a5" translate="yes" xml:space="preserve">
          <source>Fetch the commits (and branches) from the &quot;upstream&quot;:</source>
          <target state="translated">&quot;업스트림&quot;에서 커밋 (및 분기)을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8794810c9e1140dda7a53c49126aeec77324d72d" translate="yes" xml:space="preserve">
          <source>Fetching</source>
          <target state="translated">Fetching</target>
        </trans-unit>
        <trans-unit id="de8ecbd3f82de881ecb335599deb8883e5dcdb55" translate="yes" xml:space="preserve">
          <source>Fetching from the remote repository will bring in its branches and their respective commits. These are stored in your local repository under special branches.</source>
          <target state="translated">원격 저장소에서 가져 오면 브랜치와 해당 커밋이 발생합니다. 이들은 특수 저장소 아래의 로컬 저장소에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ad5e28ad709967562cc9a234219d9cd5ce08ca14" translate="yes" xml:space="preserve">
          <source>Follow the below steps. I tried them and it helped me.</source>
          <target state="translated">아래 단계를 따르십시오. 나는 그들을 시험해 보았고 그것은 나를 도왔다.</target>
        </trans-unit>
        <trans-unit id="aac6c9184d41f07130651418971dab1ad3bb3d7a" translate="yes" xml:space="preserve">
          <source>For more information about these commands, refer to &lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;step 3&lt;/a&gt;.</source>
          <target state="translated">이 명령에 대한 자세한 정보는 &lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;3 단계를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4daf005c65a6710994eea45279ec8f0858cdce7c" translate="yes" xml:space="preserve">
          <source>From the local clone of your fork, create your upstream remote. You only need to do that once:</source>
          <target state="translated">포크의 로컬 클론에서 업스트림 리모컨을 만듭니다. 한 번만 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7e8949b82184a3f3fa7e043499748855d5ab06a6" translate="yes" xml:space="preserve">
          <source>Get back your stashed changes (if any)</source>
          <target state="translated">숨겨둔 변경 사항을 다시 가져옵니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="0af551dae4561b188cfce1916f265f84a1900eff" translate="yes" xml:space="preserve">
          <source>GitHub also provides instructions for this topic: &lt;a href=&quot;https://help.github.com/articles/syncing-a-fork/&quot;&gt;Syncing a fork&lt;/a&gt;</source>
          <target state="translated">GitHub는이 주제에 대한 지침도 제공합니다 &lt;a href=&quot;https://help.github.com/articles/syncing-a-fork/&quot;&gt;. 포크 동기화&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e718004f95ed97d308f5c3b90b16f79859f4e3a" translate="yes" xml:space="preserve">
          <source>Here is GitHub's official document on &lt;a href=&quot;https://help.github.com/articles/syncing-a-fork&quot;&gt;Syncing a fork&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://help.github.com/articles/syncing-a-fork&quot;&gt;포크 동기화에 대한&lt;/a&gt; GitHub 공식 문서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b2ec29532190fe18af38b3ec081dc17c3f39aab" translate="yes" xml:space="preserve">
          <source>Here two &lt;code&gt;mergemethods&lt;/code&gt; are into play, one is &lt;code&gt;hardreset&lt;/code&gt; which helps force sync changes in the &lt;code&gt;master&lt;/code&gt; branch of the forked repo with the parent repo and the other method is &lt;code&gt;merge&lt;/code&gt;. This method is used to merge changes done by you in the &lt;code&gt;feature&lt;/code&gt; branch and changes done due to force sync in the &lt;code&gt;master&lt;/code&gt; branch. In case of merge conflict, the pull app will allow you to choose the next course of action during the pull request.</source>
          <target state="translated">여기서 두 가지 &lt;code&gt;mergemethods&lt;/code&gt; 가 사용됩니다. 하나는 &lt;code&gt;hardreset&lt;/code&gt; 로 포크 리포지토리 의 &lt;code&gt;master&lt;/code&gt; 브랜치에서 부모 리포지토리 와 동기화 변경을 강제하는 데 도움이되며 다른 방법은 &lt;code&gt;merge&lt;/code&gt; 입니다. 이 방법은 &lt;code&gt;feature&lt;/code&gt; 분기에서 사용자가 수행 한 변경 사항과 &lt;code&gt;master&lt;/code&gt; 분기에서 강제 동기화로 인해 수행 된 변경 사항을 병합하는 데 사용됩니다. 병합 충돌의 경우 풀 앱을 사용하여 풀 요청 중 다음 작업 과정을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5feec425815667dd7926e4b4daeaf95a1186782" translate="yes" xml:space="preserve">
          <source>How can I get that change into my fork? Do I need to delete and re-create my fork when I have further changes to contribute? Or is there an update button?</source>
          <target state="translated">포크로 바꾸려면 어떻게해야합니까? 기여할 추가 변경 사항이있을 때 포크를 삭제하고 다시 작성해야합니까? 아니면 업데이트 버튼이 있습니까?</target>
        </trans-unit>
        <trans-unit id="df3f50d03f3257c40379dd4c99a541c8b77c103e" translate="yes" xml:space="preserve">
          <source>How do I update a GitHub forked repository</source>
          <target state="translated">GitHub 분기 저장소를 업데이트하는 방법</target>
        </trans-unit>
        <trans-unit id="2a343e9b11ae32ded7d0e7a5911f54356160ee28" translate="yes" xml:space="preserve">
          <source>How it works (it is a guess, I don't know how exactly GitHub does it): forks share object storage and use &lt;a href=&quot;https://git-scm.com/docs/gitnamespaces&quot;&gt;namespaces&lt;/a&gt; to separate users' references. So you can access all commits through your fork, even if they did not exist by the time of forking.</source>
          <target state="translated">작동 방식 (추측, GitHub가 정확히 어떻게하는지 모르겠습니다) : 포크는 객체 스토리지를 공유하고 &lt;a href=&quot;https://git-scm.com/docs/gitnamespaces&quot;&gt;네임 스페이스&lt;/a&gt; 를 사용하여 사용자 참조를 분리합니다. 따라서 포크 시점에 존재하지 않더라도 포크를 통해 모든 커밋에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a6d461704fadab40e3cbdcaa120b732e90a03d" translate="yes" xml:space="preserve">
          <source>I am currently using this configuration in my forked repo &lt;a href=&quot;https://github.com/Saurabh702/notepad-plus-plus&quot;&gt;here&lt;/a&gt; to make sure an enhancement requested &lt;a href=&quot;https://stackoverflow.com/q/20700696/10155936&quot;&gt;here&lt;/a&gt; stays updated.</source>
          <target state="translated">현재 포크 구성 리포지토리에서이 구성을 사용하여 &lt;a href=&quot;https://github.com/Saurabh702/notepad-plus-plus&quot;&gt;여기&lt;/a&gt; 에서 요청한 개선 사항이 업데이트되도록합니다.</target>
        </trans-unit>
        <trans-unit id="78d7a9033ce91a4b7b3a7701acdd5a29798f8a71" translate="yes" xml:space="preserve">
          <source>I recently forked a project and applied several fixes. I then created a pull request which was then accepted.</source>
          <target state="translated">나는 최근에 프로젝트를 포크하고 몇 가지 수정 사항을 적용했습니다. 그런 다음 풀 요청을 작성하여 수락했습니다.</target>
        </trans-unit>
        <trans-unit id="b68acdee24b57f33bdc001ed632493c5aacf71af" translate="yes" xml:space="preserve">
          <source>I update my forked repos with this one line:</source>
          <target state="translated">이 한 줄로 포크 리포지를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="3d1755748b7a1f154a7eb20aaa1e789b4626379d" translate="yes" xml:space="preserve">
          <source>I would like to add on to &lt;a href=&quot;https://stackoverflow.com/users/946850/krlmlr&quot;&gt;@krlmlr's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/58965171/10155936&quot;&gt;answer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/946850/krlmlr&quot;&gt;@ krlmlr 's&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/58965171/10155936&quot;&gt;answer&lt;/a&gt; 에 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="71af5f6a415612676d1ad958b19ac1026d89b7ad" translate="yes" xml:space="preserve">
          <source>If it's quite a big repository you may have wanted to manage it in a special way (e.g. drop history). Basically, you can get differences between current and upstream versions, commit them and then cherry pick back to master.</source>
          <target state="translated">매우 큰 저장소라면 특별한 방법으로 관리하고 싶을 수도 있습니다 (예 : 드롭 기록). 기본적으로 현재 버전과 업스트림 버전 간의 차이점을 확인하고 커밋 한 다음 다시 마스터로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f360336737f9708dddf596319f29f29ec83c7e7f" translate="yes" xml:space="preserve">
          <source>If you are using GitHub for Windows or Mac then now they have a one-click feature to update forks:</source>
          <target state="translated">Windows 또는 Mac 용 GitHub를 사용하는 경우 이제 포크를 업데이트하는 원 클릭 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d583b891b833ad9366a05e0e74488e8f90cc70ea" translate="yes" xml:space="preserve">
          <source>If you click</source>
          <target state="translated">클릭하면</target>
        </trans-unit>
        <trans-unit id="8cd173ef4abf2972ff0859ffa0e0e3238865ce10" translate="yes" xml:space="preserve">
          <source>If you click the dropdown and choose &quot;Squash and merge&quot;, all intervening commits will be squashed into one. This is most often something you don't want.</source>
          <target state="translated">드롭 다운을 클릭하고 &quot;스쿼시 및 병합&quot;을 선택하면 모든 중간 커밋이 하나로 스쿼시됩니다. 이것은 대부분 원하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="90d18659a140ac7f945393381c5f3b9ca34813b7" translate="yes" xml:space="preserve">
          <source>If you don't want to rewrite the history of your master branch, (for example because other people may have cloned it) then you should replace the last command with &lt;code&gt;git merge upstream/master&lt;/code&gt;.  However, for making further pull requests that are as clean as possible, it's probably better to rebase.</source>
          <target state="translated">마스터 브랜치의 히스토리를 다시 작성하지 않으려면 (예 : 다른 사람들이이를 복제했을 수 있음) 마지막 명령을 &lt;code&gt;git merge upstream/master&lt;/code&gt; 로 바꾸어야 합니다. 그러나 최대한 깔끔한 추가 풀 요청을 만들려면 리베이스하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f776089b6ff08edf49e6864a333020e225edb195" translate="yes" xml:space="preserve">
          <source>If you set your upstream. Check with &lt;code&gt;git remote -v&lt;/code&gt;, then this will suffice.</source>
          <target state="translated">업스트림을 설정 한 경우 &lt;code&gt;git remote -v&lt;/code&gt; 확인하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="eecc136151fb2163383b33ace6b3000a063ca69a" translate="yes" xml:space="preserve">
          <source>If you want the forked repository to be in sync with the parent repository, you could set up a config file(&lt;code&gt;pull.yml&lt;/code&gt;) for the &lt;a href=&quot;https://github.com/apps/pull&quot;&gt;Pull app&lt;/a&gt; (&lt;em&gt;in the feature branch&lt;/em&gt;), like this:</source>
          <target state="translated">분기 저장소가 상위 저장소와 동기화되도록 &lt;em&gt;하려면 기능 분기에서&lt;/em&gt; &lt;a href=&quot;https://github.com/apps/pull&quot;&gt;Pull 앱에&lt;/a&gt; 대한 구성 파일 ( &lt;code&gt;pull.yml&lt;/code&gt; )을 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77060506139f0b51bcc1b4098f77874ee60d9177" translate="yes" xml:space="preserve">
          <source>If you've rebased your branch onto &lt;code&gt;upstream/master&lt;/code&gt; you may need to force the push in order to push it to your own forked repository on GitHub.  You'd do that with:</source>
          <target state="translated">지점을 &lt;code&gt;upstream/master&lt;/code&gt; 에 리베이스 한 경우 GitHub의 자체 분기 저장소로 푸시하려면 푸시를 강제로 수행해야 할 수 있습니다. 당신은 그것을 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="000a1d52ae55ce4b3bb388299603fc6d81fc1724" translate="yes" xml:space="preserve">
          <source>If your local branch didn't have any unique commits, git will instead perform a &quot;fast-forward&quot;:</source>
          <target state="translated">로컬 브랜치에 고유 한 커밋이 없으면 git은 대신 &quot;빨리 감기&quot;를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d61bf845eb2e03fe01a1bce8c1c5087cb5e173fb" translate="yes" xml:space="preserve">
          <source>If, like me, you &lt;strong&gt;never commit anything directly to master&lt;/strong&gt;, which you should really, you can do the following.</source>
          <target state="translated">나와 같이 &lt;strong&gt;master에 직접 아무것도 커밋하지&lt;/strong&gt; 않으면 실제로 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba7ece19362b2a8c4dc2565657e3511e377c5240" translate="yes" xml:space="preserve">
          <source>In your local clone of your forked repository, you can add the original GitHub repository as a &quot;remote&quot;.  (&quot;Remotes&quot; are like nicknames for the URLs of repositories - &lt;code&gt;origin&lt;/code&gt; is one, for example.)  Then you can fetch all the branches from that upstream repository, and rebase your work to continue working on the upstream version.  In terms of commands that might look like:</source>
          <target state="translated">분기 저장소의 로컬 복제에서 원래 GitHub 저장소를 &quot;원격&quot;으로 추가 할 수 있습니다. ( &quot;원격&quot;은 리포지토리의 URL에 대한 별명과 같습니다. &lt;code&gt;origin&lt;/code&gt; 은 하나입니다.) 그런 다음 해당 업스트림 리포지토리에서 모든 브랜치를 가져오고 업스트림 버전 작업을 계속하기 위해 작업을 리베이스 할 수 있습니다. 다음과 같은 명령 측면에서 :</target>
        </trans-unit>
        <trans-unit id="4f76a37b2e9c82019debf694fc201830d540f64f" translate="yes" xml:space="preserve">
          <source>Initially, the forked repository has one branch named : &lt;code&gt;master&lt;/code&gt;. If you are working on a new feature or a fix, you would generally create a new branch &lt;code&gt;feature&lt;/code&gt; and make the changes.</source>
          <target state="translated">처음에는 분기 저장소에 &lt;code&gt;master&lt;/code&gt; 라는 하나의 분기가 있습니다. 새 기능 또는 수정 사항을 작업중인 경우 일반적으로 새 분기 &lt;code&gt;feature&lt;/code&gt; 을 작성하고 변경합니다.</target>
        </trans-unit>
        <trans-unit id="567aa3a9c463f855ebdc229f01b738038656dcf5" translate="yes" xml:space="preserve">
          <source>Issue &lt;code&gt;git fetch upstream&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git fetch upstream&lt;/code&gt; 문제</target>
        </trans-unit>
        <trans-unit id="2904cebb10ab5eec224d68ccddd840625ed8a542" translate="yes" xml:space="preserve">
          <source>Issue &lt;code&gt;git push origin master&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git push origin master&lt;/code&gt; 문제</target>
        </trans-unit>
        <trans-unit id="a713068b13d135dfba7a6c9428bd80843ed4c780" translate="yes" xml:space="preserve">
          <source>Issue &lt;code&gt;git rebase upstream/master&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git rebase upstream/master&lt;/code&gt; 문제</target>
        </trans-unit>
        <trans-unit id="19c5df0feb2b0529669b5279411c78a559c787e9" translate="yes" xml:space="preserve">
          <source>Let's assume that you cloned already your fork to your computer with a command like this:</source>
          <target state="translated">다음과 같은 명령으로 이미 포크를 컴퓨터에 복제했다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a456f552d2cbe2b0b026d5f4dc290bf6543ca035" translate="yes" xml:space="preserve">
          <source>Merge pull request</source>
          <target state="translated">풀 요청 병합</target>
        </trans-unit>
        <trans-unit id="1504d9472f1d9c97375340082225d911a0b0b19e" translate="yes" xml:space="preserve">
          <source>Merge the changes from the &quot;master&quot; branch of the &quot;upstream&quot; into your the &quot;master&quot; branch of your &quot;origin&quot;:</source>
          <target state="translated">&quot;업스트림&quot;의 &quot;마스터&quot;브랜치에서 &quot;원본&quot;의 &quot;마스터&quot;브랜치로 변경 사항을 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="c46dcb747276ef7e8abc1bb08d26a98e6491aa62" translate="yes" xml:space="preserve">
          <source>New Pull Request</source>
          <target state="translated">새로운 풀 요청</target>
        </trans-unit>
        <trans-unit id="7fb9ddf13694977e0cf256f6247e6abd2cc1d409" translate="yes" xml:space="preserve">
          <source>Note: Since the feature request is unofficial it is also advisable to contact &lt;code&gt;support@github.com&lt;/code&gt; to add your support for a feature like this to be implemented. The unofficial feature request above could be used as evidence of the amount of interest in this being implemented.</source>
          <target state="translated">참고 : 기능 요청은 비공식적이므로 구현 될 기능에 대한 지원을 추가하려면 &lt;code&gt;support@github.com&lt;/code&gt; 에 문의하는 것이 좋습니다. 위의 비공식 기능 요청은이 구현에 대한 관심의 증거로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ec6d50e987929ac6a45b7b32db268e747b1c74" translate="yes" xml:space="preserve">
          <source>Now that we have fetched the upstream repository, we want to merge its changes into our local branch. This will bring that branch into sync with the upstream, without losing our local changes.</source>
          <target state="translated">업스트림 리포지토리를 가져 왔으므로 변경 사항을 로컬 지점에 병합하려고합니다. 이렇게하면 로컬 변경 사항을 잃지 않고 해당 지점이 업스트림과 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="fd009286901c837efdaef58b7a10f3197c9d3276" translate="yes" xml:space="preserve">
          <source>Now you have three options, but each will lead to a less-than-clean commit history.</source>
          <target state="translated">이제 세 가지 옵션이 있지만 각 옵션은 명확하지 않은 커밋 기록으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="8bf2ab2b4594a56cd8b9fb6f9bdbeec3bb92f849" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;https://github.com/&amp;lt;repo&amp;gt;/commits/&amp;lt;hash&amp;gt;&lt;/code&gt;, where &lt;em&gt;repo&lt;/em&gt; is your fork, and &lt;em&gt;hash&lt;/em&gt; is full hash of commit which you can find in the upstream web interface. For example, I can open &lt;a href=&quot;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&quot;&gt;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&lt;/a&gt;, which points to &lt;code&gt;linux&lt;/code&gt;&lt;code&gt;master&lt;/code&gt; as time of writing.</source>
          <target state="translated">&lt;code&gt;https://github.com/&amp;lt;repo&amp;gt;/commits/&amp;lt;hash&amp;gt;&lt;/code&gt; 를 엽니 다. 여기서 &lt;em&gt;repo&lt;/em&gt; 는 포크이고 &lt;em&gt;hash&lt;/em&gt; 는 커밋의 전체 해시로, 업스트림 웹 인터페이스에서 찾을 수 있습니다. 예를 들어 &lt;a href=&quot;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&quot;&gt;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&lt;/a&gt; 을 열 수 있습니다. 이는 쓰기 시점으로 &lt;code&gt;linux&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="bf7747d9aa574b4704007bf15ba2ed436f66d151" translate="yes" xml:space="preserve">
          <source>Open menu &lt;em&gt;VCS&lt;/em&gt; &amp;rarr; &lt;em&gt;Git&lt;/em&gt;</source>
          <target state="translated">메뉴 열기 &lt;em&gt;VCS&lt;/em&gt; &amp;rarr; &lt;em&gt;Git&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234ae272ca6f312c89a8e8df6909fdfb0acb3451" translate="yes" xml:space="preserve">
          <source>Open your fork on GitHub.</source>
          <target state="translated">GitHub에서 포크를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="27ac6148008f56cd689f0438348c712daa89325f" translate="yes" xml:space="preserve">
          <source>Past the initial upstream setup and master checkout, all you need to do is run the following command to sync your master with upstream: &lt;strong&gt;git pull upstream master&lt;/strong&gt;.</source>
          <target state="translated">초기 업스트림 설정 및 마스터 체크 아웃을 지나면 다음 명령을 실행하여 마스터를 업스트림과 동기화하기 만하면됩니다. &lt;strong&gt;git pull upstream master&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="30ab8d084e2209d47a1dc198c8de1e251f390a94" translate="yes" xml:space="preserve">
          <source>Pull Requests</source>
          <target state="translated">풀 요청</target>
        </trans-unit>
        <trans-unit id="ae6fc052a45c770a9169a7ab638bc505e00bb03c" translate="yes" xml:space="preserve">
          <source>Push the changes to your fork</source>
          <target state="translated">포크로 변경 사항을 푸시</target>
        </trans-unit>
        <trans-unit id="5693314a70b827fd392394697ad3e48be809f455" translate="yes" xml:space="preserve">
          <source>Rebase and merge</source>
          <target state="translated">리베이스 및 병합</target>
        </trans-unit>
        <trans-unit id="2be8b8a63ab459b9cea7716971f0b489291f8f7d" translate="yes" xml:space="preserve">
          <source>Resolve merge conflicts if any and commit your merge</source>
          <target state="translated">병합 충돌이 있으면 해결하고 병합을 커밋</target>
        </trans-unit>
        <trans-unit id="d4af81a4796c3cb95c1f56e0df4695725005f254" translate="yes" xml:space="preserve">
          <source>Scroll down to</source>
          <target state="translated">아래로 스크롤</target>
        </trans-unit>
        <trans-unit id="d61c5e591073d46124cf6b9aecef7a23df6ba7fd" translate="yes" xml:space="preserve">
          <source>Select the repository in the UI.</source>
          <target state="translated">UI에서 저장소를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e7e619212ed526f7f497ba569b8215af3e6930ce" translate="yes" xml:space="preserve">
          <source>Since November 2013 there has been an unofficial feature request open with GitHub to ask them to add a very simple and intuitive method to keep a local fork in sync with upstream:</source>
          <target state="translated">2013 년 11 월부터 GitHub에서 비공식 기능 요청을 통해 로컬 포크를 업스트림과 동기화 할 수있는 매우 간단하고 직관적 인 방법을 추가하도록 요청했습니다.</target>
        </trans-unit>
        <trans-unit id="7471ffd6ac4a8061b4408edaa480bb1bc093a600" translate="yes" xml:space="preserve">
          <source>So when your &lt;em&gt;Pull Request&lt;/em&gt; is accepted then you can safely delete the branch as your contributed code will be then live in your master of your forked repository when you update it with the upstream. By this your master will always be in clean condition to create a new branch to do another change.</source>
          <target state="translated">따라서 &lt;em&gt;풀 요청&lt;/em&gt; 이 수락되면 업스트림으로 업데이트 할 때 기여 코드가 분기 저장소의 마스터에 라이브되므로 분기를 안전하게 삭제할 수 있습니다. 이를 통해 마스터는 항상 새로운 상태를 유지하여 다른 변경을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde179cf043a598d6ebae765e11145b2713e12da" translate="yes" xml:space="preserve">
          <source>So yes, you can keep your repo updated with its upstream using the GitHub web UI, but doing so will sully your commit history. Stick to &lt;a href=&quot;https://stackoverflow.com/questions/7244321/how-do-i-update-a-github-forked-repository/7244456#7244456&quot;&gt;the command line&lt;/a&gt; instead - it's easy.</source>
          <target state="translated">따라서 GitHub 웹 UI를 사용하여 리포를 업스트림으로 업데이트 할 수 있지만 그렇게하면 커밋 기록이 완전히 바뀌게됩니다. 대신 &lt;a href=&quot;https://stackoverflow.com/questions/7244321/how-do-i-update-a-github-forked-repository/7244456#7244456&quot;&gt;명령 행을&lt;/a&gt; 고수하십시오-쉽습니다.</target>
        </trans-unit>
        <trans-unit id="af3d4309c9cbe26ad276b210691bac0fd29af135" translate="yes" xml:space="preserve">
          <source>Source is here: &lt;a href=&quot;https://github.com/upriver/upriver.github.io&quot;&gt;https://github.com/upriver/upriver.github.io&lt;/a&gt;</source>
          <target state="translated">출처는 다음과 같습니다 : &lt;a href=&quot;https://github.com/upriver/upriver.github.io&quot;&gt;https://github.com/upriver/upriver.github.io&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2b25a8ecb73ab17a486ebf26f4dc535e692fd1d" translate="yes" xml:space="preserve">
          <source>Starting in May 2014, it is possible to update a fork directly from GitHub. This still works as of September 2017, &lt;strong&gt;BUT&lt;/strong&gt; it will lead to a dirty commit history.</source>
          <target state="translated">2014 년 5 월부터 GitHub에서 직접 포크를 업데이트 할 수 있습니다. 이것은 여전히 ​​2017 년 9 월 현재 작동 &lt;strong&gt;하지만&lt;/strong&gt; 더티 커밋 기록으로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="94232c5c336a258f43a35d0ed1f8564a260b87f4" translate="yes" xml:space="preserve">
          <source>Stash the changes of your &quot;master&quot; branch:</source>
          <target state="translated">&quot;마스터&quot;지사의 변경 사항을 정리하십시오 :</target>
        </trans-unit>
        <trans-unit id="00b47bb1619911e7792fe20f714c21d2a1fc7eab" translate="yes" xml:space="preserve">
          <source>Switch to master branch if you are not &lt;code&gt;git checkout master&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git checkout master&lt;/code&gt; 가 아닌 경우 master 브랜치로 전환</target>
        </trans-unit>
        <trans-unit id="550dbb15410741b3ec255e0399965d535e2b1607" translate="yes" xml:space="preserve">
          <source>Switch to the &quot;master&quot; branch of your fork (&quot;origin&quot;):</source>
          <target state="translated">포크의 &quot;마스터&quot;분기 ( &quot;origin&quot;)로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="a95b37b3017effb7b215d767ac0e2211e6aa724b" translate="yes" xml:space="preserve">
          <source>Syncing a fork</source>
          <target state="translated">포크 동기화</target>
        </trans-unit>
        <trans-unit id="f6cab97732eaeae1f3f5633b252cbea26c2cada7" translate="yes" xml:space="preserve">
          <source>That depends on the size of your repository and how you forked it.</source>
          <target state="translated">이는 저장소의 크기와 분기 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5dc7ae634569e14ec7d42e039a67f21cd21cbe73" translate="yes" xml:space="preserve">
          <source>The &quot;fetch&quot; command is indispensable for staying up-to-date in a project: only when performing a &quot;git fetch&quot; will you be informed about the changes your colleagues pushed to the remote server.</source>
          <target state="translated">&quot;fetch&quot;명령은 프로젝트에서 최신 상태를 유지하는 데 반드시 필요합니다. &quot;git fetch&quot;를 수행 할 때만 동료가 원격 서버에 푸시 한 변경 사항에 대한 정보가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="aaf533ccf7e6caa9b7b03a28b06c9bac28a5ee27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/apps/pull&quot;&gt;&quot;Pull&quot; app&lt;/a&gt; is an automatic set-up-and-forget solution. It will sync the default branch of your fork with the upstream repository.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apps/pull&quot;&gt;&quot;풀&quot;앱&lt;/a&gt; 은 자동 설정 및 잊어 버린 솔루션입니다. 포크의 기본 브랜치를 업스트림 저장소와 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="0b41a8d83b439c9b4f4885f64b9339a1c1d30a13" translate="yes" xml:space="preserve">
          <source>The Setup</source>
          <target state="translated">설정</target>
        </trans-unit>
        <trans-unit id="264bd0e9406f8519a0848bd766d97c323e32936c" translate="yes" xml:space="preserve">
          <source>The branch is updated once per hour directly on GitHub, on your local machine you need to pull the master branch to ensure that your local copy is in sync.</source>
          <target state="translated">지점은 GitHub에서 시간당 한 번 직접 업데이트되며 로컬 시스템에서는 로컬 사본이 동기화되도록 마스터 지점을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="8f7c026574a5c8cfd1326e6ff76ca5c776670d83" translate="yes" xml:space="preserve">
          <source>The default will create an ugly merge commit.</source>
          <target state="translated">기본적으로 못생긴 병합 커밋이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="6f1ebfb3019b0fae6470df879b3b87ef304817de" translate="yes" xml:space="preserve">
          <source>The first part of this command lists all heads in the &lt;em&gt;upstream&lt;/em&gt; remote repo and removes the SHA-1 followed by &lt;code&gt;refs/heads/&lt;/code&gt; branch name prefix.</source>
          <target state="translated">이 명령의 첫 번째 부분은 &lt;em&gt;업스트림&lt;/em&gt; 원격 저장소의 모든 헤드를 나열하고 &lt;code&gt;refs/heads/&lt;/code&gt; branch name 접두어가 뒤에 오는 SHA-1을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0fd61e5b8cc0dcec4af47834c1c482a521206bf7" translate="yes" xml:space="preserve">
          <source>Then for each of these branches, it pushes the local copy of the &lt;em&gt;upstream&lt;/em&gt; remote tracking branch (&lt;code&gt;refs/remotes/upstream/&amp;lt;branch&amp;gt;&lt;/code&gt; on local side) directly to the remote branch on &lt;em&gt;origin&lt;/em&gt; (&lt;code&gt;refs/heads/&amp;lt;branch&amp;gt;&lt;/code&gt; on remote side).</source>
          <target state="translated">그런 다음 각 분기에 대해 &lt;em&gt;업스트림&lt;/em&gt; 원격 추적 분기의 로컬 사본 (로컬 &lt;em&gt;측의&lt;/em&gt; &lt;code&gt;refs/remotes/upstream/&amp;lt;branch&amp;gt;&lt;/code&gt; )을 &lt;em&gt;원점&lt;/em&gt; 의 원격 브랜치 (원격 측의 &lt;code&gt;refs/heads/&amp;lt;branch&amp;gt;&lt;/code&gt; )로 직접 푸시합니다. ).</target>
        </trans-unit>
        <trans-unit id="c40a11b834f4f1e641021d97be329e8b5d0b544e" translate="yes" xml:space="preserve">
          <source>Then run:</source>
          <target state="translated">그런 다음 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4e3c3ccfe5c2a2ebf037580df28bcb9fb26dc642" translate="yes" xml:space="preserve">
          <source>Then whenever you want to catch up with the upstream repository master branch you need to:</source>
          <target state="translated">그런 다음 업스트림 리포지토리 마스터 브랜치를 따라 잡을 때마다 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="55f2ca371ae7e64950478e9d947b56fc79a8fc12" translate="yes" xml:space="preserve">
          <source>There are two main things on keeping a forked repository always update for good.</source>
          <target state="translated">분기 저장소를 항상 최신 상태로 유지하려면 두 가지 주요 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b85c401196c95bfb03457e3a7d6a5d80620657f" translate="yes" xml:space="preserve">
          <source>There are two steps required to sync your repository with the upstream: first you must fetch from the remote, then you must merge the desired branch into your local branch.</source>
          <target state="translated">리포지토리를 업스트림과 동기화하는 데 필요한 두 단계가 있습니다. 먼저 원격에서 가져 와서 원하는 분기를 로컬 분기로 병합해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c4a41363b12f65f41188e7ab9b8178b65cd6f00" translate="yes" xml:space="preserve">
          <source>This assumes you have already configured an &lt;em&gt;upstream&lt;/em&gt; remote pointing at the source repository (where &lt;em&gt;origin&lt;/em&gt; was forked from) and have synced it with &lt;code&gt;git fetch upstream&lt;/code&gt;.</source>
          <target state="translated">이것은 소스 저장소 ( &lt;em&gt;원점&lt;/em&gt; 이 포크 된)를 가리키는 &lt;em&gt;업스트림&lt;/em&gt; 원격을 이미 구성하고 &lt;code&gt;git fetch upstream&lt;/code&gt; 과 동기화 한 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d3f73d1133e9c4aa6c1cb82052b4e208866b9e1e" translate="yes" xml:space="preserve">
          <source>This can be done with &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot;&gt;cron&lt;/a&gt;&lt;/em&gt;. Here is for an example code if you do it in linux.</source>
          <target state="translated">이것은 &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot;&gt;cron&lt;/a&gt;&lt;/em&gt; 으로 수행 할 수 있습니다. 다음은 리눅스에서 코드를 작성하는 예제 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3c04d0e03a98055770769ef6c37adf6dffe58c36" translate="yes" xml:space="preserve">
          <source>This keeps the &lt;code&gt;master&lt;/code&gt; branch of the forked repo up-to-date with the parent repo.  It keeps the &lt;code&gt;feature&lt;/code&gt; branch of the forked repo updated via the &lt;code&gt;master&lt;/code&gt; branch of the forked repo by merging the same. This assumes that the &lt;code&gt;feature&lt;/code&gt; branch is the default branch which contains the config file.</source>
          <target state="translated">그러면 포크 리포지토리의 &lt;code&gt;master&lt;/code&gt; 브랜치가 상위 리포지토리와 함께 최신 상태로 유지됩니다. 분기 리포지토리의 &lt;code&gt;feature&lt;/code&gt; 분기를 분기 리포지토리의 &lt;code&gt;master&lt;/code&gt; 분기를 통해 업데이트하여 유지합니다. 이는 &lt;code&gt;feature&lt;/code&gt; 분기가 구성 파일을 포함하는 기본 분기라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ab33c2f98bee89af79c24e3347a9eca7e1e6213d" translate="yes" xml:space="preserve">
          <source>Try reading &lt;a href=&quot;https://www.atlassian.com/blog/git/handle-big-repositories-git&quot;&gt;this one&lt;/a&gt;. It describes how to handle big Git repositories and how to upstream them with latest changes.</source>
          <target state="translated">&lt;a href=&quot;https://www.atlassian.com/blog/git/handle-big-repositories-git&quot;&gt;이것을&lt;/a&gt; 읽어보십시오. 또한 큰 Git 리포지토리를 처리하는 방법과 최신 변경 사항으로 업스트림을 처리하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7348e561a5ae9cb8353b257c56d9e4058e561c43" translate="yes" xml:space="preserve">
          <source>Try them. I use the first one to synchronize my local repository. Anyway the branches from the parent remote repository (&quot;upstream&quot;) will be accessible in Android Studio after you click &quot;Rebase my GitHub fork&quot;, and you will be able to operate with them easily.</source>
          <target state="translated">사용해보십시오. 로컬 저장소를 동기화하기 위해 첫 번째를 사용합니다. 어쨌든 &quot;GitHub 포크 리베이스&quot;를 클릭하면 Android Studio에서 상위 원격 저장소 ( &quot;업스트림&quot;)의 브랜치에 액세스 할 수 있으며이를 사용하여 쉽게 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05a79fa3f7b71ff3af83543b0a99f9e7dc46d22d" translate="yes" xml:space="preserve">
          <source>Type name of the new branch and press</source>
          <target state="translated">새 지점의 이름을 입력하고</target>
        </trans-unit>
        <trans-unit id="48d7f3aad1014aaefe582d965a38754ca3c81e6d" translate="yes" xml:space="preserve">
          <source>Use these commands (in lucky case)</source>
          <target state="translated">이 명령을 사용하십시오 (행운의 경우)</target>
        </trans-unit>
        <trans-unit id="c958a967cc046028cbaa999ed165b1df294e56ca" translate="yes" xml:space="preserve">
          <source>Use this if you dont want to add another remote endpoint to your project, as other solutions posted here.</source>
          <target state="translated">다른 솔루션이 여기에 게시 된 것처럼 프로젝트에 다른 원격 엔드 포인트를 추가하지 않으려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="113dabb069eb5c3615ca09078051fb9bfe028789" translate="yes" xml:space="preserve">
          <source>Visit the URL, click the green &quot;Install&quot; button and select the repositories where you want to enable automatic synchronization.</source>
          <target state="translated">URL을 방문하여 녹색 &quot;설치&quot;단추를 클릭 한 후 자동 동기화를 사용하려는 저장소를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="9e41c53b0c9e900eb8c17dcec719e6c5e2cda65e" translate="yes" xml:space="preserve">
          <source>We now have the upstream's master branch stored in a local branch, upstream/master</source>
          <target state="translated">이제 업스트림의 마스터 브랜치를 업스트림 / 마스터의 로컬 브랜치에 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="70996155aeb81fb8f674121234ed3c2b155fbcc6" translate="yes" xml:space="preserve">
          <source>When you have cloned your forked repository, go to the directory path where your clone resides and the few lines in your Git Bash Terminal.</source>
          <target state="translated">분기 저장소를 복제했으면 복제본이있는 디렉토리 경로와 Git Bash 터미널의 몇 줄로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="b4273e60bfcbcab2ec3724e77b23410fb74fa6aa" translate="yes" xml:space="preserve">
          <source>You can read about basic and advanced configs and various &lt;code&gt;mergemethods&lt;/code&gt;&lt;a href=&quot;https://github.com/wei/pull/#getting-started&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">기본 및 고급 구성 및 다양한 &lt;code&gt;mergemethods&lt;/code&gt; 에 대한 내용은 &lt;a href=&quot;https://github.com/wei/pull/#getting-started&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a7f7e1f68353d42fb1d08559607349859cb7d0" translate="yes" xml:space="preserve">
          <source>You can still visit &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote/&quot;&gt;here&lt;/a&gt; for further queries</source>
          <target state="translated">추가 질문이 있으시면 &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote/&quot;&gt;여기&lt;/a&gt; 를 방문 하십시오</target>
        </trans-unit>
        <trans-unit id="ff6f510068911753cb9bd5368c75b45cf289df57" translate="yes" xml:space="preserve">
          <source>You can then fetch that branch to your local clone, and you won't have to push all that data back to GitHub when you push edits on top of that commit. Or use the web interface to change something in that branch.</source>
          <target state="translated">그런 다음 해당 분기를 로컬 클론으로 가져올 수 있으며 해당 커밋 위에 편집 내용을 푸시 할 때 해당 데이터를 모두 GitHub로 다시 푸시하지 않아도됩니다. 또는 웹 인터페이스를 사용하여 해당 분기에서 무언가를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="39a2962d24c5da003463d40c3ba453db9e711b97" translate="yes" xml:space="preserve">
          <source>You only need to use the &lt;code&gt;-f&lt;/code&gt; the first time after you've rebased.</source>
          <target state="translated">리베이스 한 후 처음으로 &lt;code&gt;-f&lt;/code&gt; 만 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c434032ffe13d43d03ab1c4fccc8af93e0a936ea" translate="yes" xml:space="preserve">
          <source>You're done! Congratulations!</source>
          <target state="translated">끝났습니다! 축하합니다!</target>
        </trans-unit>
        <trans-unit id="a746abb742e0859202204870a3d7b7c8a1cc09c0" translate="yes" xml:space="preserve">
          <source>and assign a predictable name to your pull request (e.g., &lt;code&gt;Update from original&lt;/code&gt;).</source>
          <target state="translated">풀 요청에 예측 가능한 이름을 지정하십시오 (예 : &lt;code&gt;Update from original&lt;/code&gt; 에서 업데이트 ).</target>
        </trans-unit>
        <trans-unit id="df21a3d2fd99b84fa7cb13ec4ad8cb363da327a4" translate="yes" xml:space="preserve">
          <source>base fork</source>
          <target state="translated">베이스 포크</target>
        </trans-unit>
        <trans-unit id="532f130ef6fb0e430af8a5beabc44c9f973fffb7" translate="yes" xml:space="preserve">
          <source>drop down to your fork, and the</source>
          <target state="translated">포크로 내려 가면</target>
        </trans-unit>
        <trans-unit id="2fea52e0bcab5f5be75f35cc928f2d5d550f6363" translate="yes" xml:space="preserve">
          <source>head fork</source>
          <target state="translated">헤드 포크</target>
        </trans-unit>
        <trans-unit id="adddb4502940da2585c73da6895d602125b04b64" translate="yes" xml:space="preserve">
          <source>if you see that link. Otherwise, manually set the</source>
          <target state="translated">그 링크가 보이면 그렇지 않으면 수동으로</target>
        </trans-unit>
        <trans-unit id="4f4d58ad0cad805b755078913c2a8c10b63617f7" translate="yes" xml:space="preserve">
          <source>put this code on the &lt;code&gt;crontab file&lt;/code&gt; to execute the job in hourly basis.</source>
          <target state="translated">이 코드를 &lt;code&gt;crontab file&lt;/code&gt; 에 두어 시간 단위로 작업을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2b5782d6a2c529fd97cbf05eb0094e6162849111" translate="yes" xml:space="preserve">
          <source>switching the base</source>
          <target state="translated">베이스 전환</target>
        </trans-unit>
        <trans-unit id="d057e0f6d02a5d2cb09ee3e8d5bcb43e5378e0b5" translate="yes" xml:space="preserve">
          <source>then create the &lt;code&gt;cron.sh&lt;/code&gt; script file and a &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/56304600/4058484&quot;&gt;git interaction&lt;/a&gt;&lt;/em&gt; with &lt;em&gt;&lt;a href=&quot;https://www.ssh.com/ssh/agent&quot;&gt;ssh-agent&lt;/a&gt;&lt;/em&gt; and/or &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/55779022/4058484&quot;&gt;expect&lt;/a&gt;&lt;/em&gt; as below</source>
          <target state="translated">그런 다음 &lt;code&gt;cron.sh&lt;/code&gt; 스크립트 파일과 &lt;em&gt;&lt;a href=&quot;https://www.ssh.com/ssh/agent&quot;&gt;ssh-agent&lt;/a&gt;&lt;/em&gt; 와의 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/56304600/4058484&quot;&gt;git 상호 작용&lt;/a&gt;&lt;/em&gt; 을 만들고 다음과 같이 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/55779022/4058484&quot;&gt;기대하십시오.&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e94efa29d42e9ae0e72fe4835a46e739de853f87" translate="yes" xml:space="preserve">
          <source>to the upstream. Now GitHub will compare your fork with the original, and you should see all the latest changes.</source>
          <target state="translated">상류에. 이제 GitHub는 포크와 원본을 비교할 것이며 모든 최신 변경 사항을 볼 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
