<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/7244321">
    <body>
      <group id="7244321">
        <trans-unit id="837239dc1752aa33767206805faadce95726829a" translate="yes" xml:space="preserve">
          <source>(I use Android Studio 3.0 with &quot;Git integration&quot; and &quot;GitHub&quot; plugins.)</source>
          <target state="translated">(我使用的是Android Studio 3.0的 &quot;Git集成 &quot;和 &quot;GitHub &quot;插件)。</target>
        </trans-unit>
        <trans-unit id="f7bddf7f104c215149d89a27e04f9f82c5bdae57" translate="yes" xml:space="preserve">
          <source>, all commits will be made &quot;with&quot; you, the original PRs will link to your PR, and GitHub will display &lt;code&gt;This branch is X commits ahead, Y commits behind &amp;lt;original fork&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">，所有提交将与您一起进行，原始PR将链接到您的PR，并且GitHub将显示 &lt;code&gt;This branch is X commits ahead, Y commits behind &amp;lt;original fork&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa18006684a6730be7d42134f2ce945e1ca9dfd5" translate="yes" xml:space="preserve">
          <source>, but don't click anything yet.</source>
          <target state="translated">,但不要点击任何东西。</target>
        </trans-unit>
        <trans-unit id="aed7f30b6eec6bdad869eaf0cc6d252d35ce10dd" translate="yes" xml:space="preserve">
          <source>. By default, GitHub will compare the original with your fork, and there shouldn't be anything to compare if you didn't make any changes.</source>
          <target state="translated">.默认情况下,GitHub会将原版与你的fork进行比较,如果你没有做任何修改,应该不会有什么可比较的地方。</target>
        </trans-unit>
        <trans-unit id="9e288959c997c74dcab4f214316ce37256bb0e82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Create Pull Request&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;创建请求请求&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dec1ee12cc0ee47690f681d5af701402e2a059e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rebase my GitHub fork&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;重新整理我的GitHub fork&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c23532b197c28f5e2c167d5de1d1410ac36f24a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tip: If you want to update your repository on GitHub, follow the instructions &lt;a href=&quot;https://help.github.com/articles/pushing-to-a-remote#pushing-a-branch&quot;&gt;here&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;提示：如果要在GitHub上更新存储库，请按照&lt;a href=&quot;https://help.github.com/articles/pushing-to-a-remote#pushing-a-branch&quot;&gt;此处&lt;/a&gt;的说明进行操作&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ef67562961602cb5e06540f46c6ad69d781b01e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tip: Syncing your fork only updates your local copy of the repository; it does not update your repository on GitHub.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;提示：同步fork只会更新存储库的本地副本。&lt;/em&gt; &lt;em&gt;它不会在GitHub上更新您的存储库。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091a67df8cb7e3a2e39438a2304cecc9cfcd7fa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Create the branches&lt;/strong&gt; from the fork master and &lt;strong&gt;do changes there&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;从fork master &lt;strong&gt;创建分支&lt;/strong&gt; ，然后在其中&lt;strong&gt;进行更改&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace59f481ab2e485809074bf3421337f65d1e484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Create a scheduled job&lt;/strong&gt; for the fork master to &lt;strong&gt;do update automatically&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;2.创建一个计划任务，&lt;/strong&gt;以供fork主服务器&lt;strong&gt;自动更新&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c6ef361872ea9dca75b25f08ab190d9ab77471d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Checkout to your branch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;结帐到您的分支&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cba2c022702bc7188073aa3405c4473f2a91a47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; git checkout master</source>
          <target state="translated">&lt;strong&gt;示例：&lt;/strong&gt; git checkout master</target>
        </trans-unit>
        <trans-unit id="d2f1180576dd05c72a3829a89721f20a338e1252" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&quot;&gt;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&lt;/a&gt; BRANCH_NAME</source>
          <target state="translated">&lt;strong&gt;示例：&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&quot;&gt;https://github.com/ORIGINAL_OWNER/ORIGINAL_REPO.git&lt;/a&gt; BRANCH_NAME</target>
        </trans-unit>
        <trans-unit id="038223c0b4eee8eb40e89e3334da6a52eeaaf53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Foreword:&lt;/strong&gt; Your fork is the &quot;origin&quot; and the repository you forked from is the &quot;upstream&quot;.</source>
          <target state="translated">&lt;strong&gt;前言：&lt;/strong&gt;您的fork是&amp;ldquo;源&amp;rdquo;，而您从其派生的存储库是&amp;ldquo;上游&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="83675adcd63528ba85b7735bf175b9ad961c21e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If that is given then you need to continue in this order:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果给出了，则需要按此顺序继续：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d7bc8b4919bc01d463826deb19d44e1b4e26951" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the meantime, GitHub user bardiharborow has created a tool to do just this:&lt;/strong&gt;&lt;a href=&quot;https://upriver.github.io/&quot;&gt;https://upriver.github.io/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;同时，GitHub用户bardiharborow创建了一个工具来执行此操作：&lt;/strong&gt; &lt;a href=&quot;https://upriver.github.io/&quot;&gt;https&lt;/a&gt; &lt;strong&gt;://upriver.github.io/&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c53483308246ab7077bf1fbd5790e40c6ffb4674" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pull source repository branch for getting the latest code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;拉源存储库分支以获取最新代码&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39f7deb9c8e2585fec4fb5fb5b57b3fefb8ec63d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax:&lt;/strong&gt; git branch yourDevelopmentBranch</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt; git branch yourDevelopmentBranch</target>
        </trans-unit>
        <trans-unit id="30519498f0f744e1c306f5deb9b11dd9dc3422bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax:&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/tastejs/awesome-app-ideas&quot;&gt;https://github.com/tastejs/awesome-app-ideas&lt;/a&gt; master</source>
          <target state="translated">&lt;strong&gt;语法：&lt;/strong&gt; git pull &lt;a href=&quot;https://github.com/tastejs/awesome-app-ideas&quot;&gt;https://github.com/tastejs/awesome-app-ideas&lt;/a&gt; master</target>
        </trans-unit>
        <trans-unit id="c22468d3a019b313d1bce8c15882b7e2dc72ab9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This branch is even with &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt;:master&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;该分支甚至使用 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; ：master&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="836dd07f6d51bd7c72878311bf22a4ef9c537100" translate="yes" xml:space="preserve">
          <source>A few days later another change was made by another contributor. So my fork doesn't contain that change.</source>
          <target state="translated">几天后,另一个贡献者又做了一个改动。所以我的叉子里没有这个改动。</target>
        </trans-unit>
        <trans-unit id="d111dda0df7611e4a760ea8349943d255c38c603" translate="yes" xml:space="preserve">
          <source>A lot of answers end up moving your fork &lt;strong&gt;one commit ahead&lt;/strong&gt; of the parent repository. This answer summarizes the steps found &lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;here&lt;/a&gt; which will &lt;strong&gt;move your fork to the same commit as the parent&lt;/strong&gt;.</source>
          <target state="translated">许多答案最终导致将叉子&lt;strong&gt;一次提交&lt;/strong&gt;移到父存储库之前。 该答案总结了&lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;此处&lt;/a&gt;找到的步骤，这些步骤会将&lt;strong&gt;您的fork移至与父代相同的提交&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a571dcfb301530d4534f671f455e5eca37543f4b" translate="yes" xml:space="preserve">
          <source>Actually, it is possible to create a branch in your fork from any commit of the upstream in the browser:</source>
          <target state="translated">其实,在浏览器中的上游的任何一个提交,都可以在你的fork中创建一个分支。</target>
        </trans-unit>
        <trans-unit id="5f88b6685a748abb35be251ed6735d785185f6ea" translate="yes" xml:space="preserve">
          <source>Add the &quot;upstream&quot; to your cloned repository (&quot;origin&quot;):</source>
          <target state="translated">将 &quot;上游 &quot;添加到你的克隆存储库中(&quot;原点&quot;)。</target>
        </trans-unit>
        <trans-unit id="5a08ed9da2ad311b22c813f50ad5770b2a215a0a" translate="yes" xml:space="preserve">
          <source>Add the parent as a remote repository, &lt;code&gt;git remote add upstream &amp;lt;repo-location&amp;gt;&lt;/code&gt;</source>
          <target state="translated">将父级添加为远程存储库， &lt;code&gt;git remote add upstream &amp;lt;repo-location&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a67e617a769c44bdd8f8d877909cfd92bf6f9b61" translate="yes" xml:space="preserve">
          <source>And pay attention to the two last popup menu items:</source>
          <target state="translated">并注意最后两个弹出的菜单项目。</target>
        </trans-unit>
        <trans-unit id="77b29e62e23f78b86305bbbc7a82f5e4ee0b7dd6" translate="yes" xml:space="preserve">
          <source>And there you are good to go. All updated changes in the main repository will be pushed into your fork repository.</source>
          <target state="translated">然后你就可以开始了。所有在主库中更新的修改都会被推送到你的fork库中。</target>
        </trans-unit>
        <trans-unit id="735bbd6e19a781c73f9b39e632cb76b45edb8e9a" translate="yes" xml:space="preserve">
          <source>Android Studio now has learned to work with GitHub fork repositories (you don't even have to add &quot;upstream&quot; remote repository by console command).</source>
          <target state="translated">Android Studio 现在已经学会了使用 GitHub fork 仓库(你甚至不需要通过控制台命令添加 &quot;上游 &quot;远程仓库)。</target>
        </trans-unit>
        <trans-unit id="b862909c99578f4b84baffee2fcba870c7bb3d2b" translate="yes" xml:space="preserve">
          <source>Any of these branch sync commands may fail for one of two reasons: either the &lt;em&gt;upstream&lt;/em&gt; branch have been rewritten, or you have pushed commits on that branch to your fork. In the first case where you haven't committed anything to the branch on your fork it is safe to push forcefully (Add the &lt;strong&gt;-f&lt;/strong&gt; switch; i.e. &lt;code&gt;git push -f&lt;/code&gt; in the command above). In the other case this is normal as your fork branch have diverged and you can't expect the sync command to work until your commits have been merged back into &lt;em&gt;upstream&lt;/em&gt;.</source>
          <target state="translated">这些分支同步命令中的任何一个都可能由于以下两个原因之一而失败： &lt;em&gt;上游&lt;/em&gt;分支已被重写，或者您已将该分支上的提交推送到派生。 在第一种情况下，您没有向fork上的分支提交任何内容，可以强制强制执行安全操作（添加&lt;strong&gt;-f&lt;/strong&gt;开关；即上面命令中的 &lt;code&gt;git push -f&lt;/code&gt; ）。 在另一种情况下，这是正常的，因为您的fork分支已经分叉了，您不能期望sync命令起作用，直到您的提交被合并回&lt;em&gt;上游&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bc1aaa72c608f4cf6f7c42e3a16c71cd5f587a7" translate="yes" xml:space="preserve">
          <source>As a complement to this answer, I was looking for a way to update all remote branches of my cloned repo (&lt;em&gt;origin&lt;/em&gt;) from &lt;em&gt;upstream&lt;/em&gt; branches in one go. This is how I did it.</source>
          <target state="translated">作为此答案的补充，我正在寻找一种方法，可以一口气从&lt;em&gt;上游&lt;/em&gt;分支更新克隆的回购（ &lt;em&gt;源&lt;/em&gt; ）的所有远程分支。 这就是我的方法。</target>
        </trans-unit>
        <trans-unit id="a9b4790fc412d85990b1d6a052f870d7a70a17fe" translate="yes" xml:space="preserve">
          <source>As of the date of this answer, GitHub has not (&lt;a href=&quot;https://github.com/blog/266-fast-forward-your-fork&quot;&gt;or shall I say no longer?&lt;/a&gt;) this feature in the web interface. You can, however, ask &lt;code&gt;support@github.com&lt;/code&gt; to add your vote for that.</source>
          <target state="translated">截至本答案发布之日，GitHub在Web界面中尚未（ &lt;a href=&quot;https://github.com/blog/266-fast-forward-your-fork&quot;&gt;或我不再说吗？&lt;/a&gt; ）此功能。 但是，您可以要求 &lt;code&gt;support@github.com&lt;/code&gt; 对此进行投票。</target>
        </trans-unit>
        <trans-unit id="1adc04b7dba016a901bd1df1b78a3ab6cd41900e" translate="yes" xml:space="preserve">
          <source>Assuming you never committed anything on master yourself you should be done already. Now you can push your local master to your origin remote GitHub fork. You could also rebase your development branch on your now up-to-date local master.</source>
          <target state="translated">假设你从未在master上提交过任何东西,你应该已经完成了。现在你可以把你的本地主站推送到你的远程 GitHub 分叉上。你也可以将你的开发分支重新建立在最新的本地主站上。</target>
        </trans-unit>
        <trans-unit id="07e2084f9d86a95da2e8d3b95a5ce00601649747" translate="yes" xml:space="preserve">
          <source>At this stage you check that commits what will be merged by typing &lt;code&gt;git status&lt;/code&gt;</source>
          <target state="translated">在此阶段，您可以通过键入 &lt;code&gt;git status&lt;/code&gt; 来确认将要合并的内容</target>
        </trans-unit>
        <trans-unit id="b9ae2528623f4113c5de53633d5a27b55e035549" translate="yes" xml:space="preserve">
          <source>Before you can sync, you need to add a remote that points to the upstream repository. You may have done this when you originally forked.</source>
          <target state="translated">在同步之前,你需要添加一个指向上游版本库的远程。你可能在最初分叉时就已经这样做了。</target>
        </trans-unit>
        <trans-unit id="47e8690455bc45922966085b3d33db413219f0a2" translate="yes" xml:space="preserve">
          <source>Change directory to your local repository.</source>
          <target state="translated">更改目录到你的本地版本库。</target>
        </trans-unit>
        <trans-unit id="3fd8a96d486985aff675e7a9223f2ee169b4d761" translate="yes" xml:space="preserve">
          <source>Check your forked repository. From time to time it will always show this notification:</source>
          <target state="translated">检查你的分叉仓库。不时地,它总是会显示这个通知。</target>
        </trans-unit>
        <trans-unit id="79cbc5eb672a54c2b82572afd52f2a6a4f85e598" translate="yes" xml:space="preserve">
          <source>Click</source>
          <target state="translated">Click</target>
        </trans-unit>
        <trans-unit id="071cff0034f6979c282cf4b38b624dc0f9e36bf0" translate="yes" xml:space="preserve">
          <source>Click &quot;Update from user/branch&quot; button the top.</source>
          <target state="translated">点击顶部的 &quot;从用户支行更新 &quot;按钮。</target>
        </trans-unit>
        <trans-unit id="ca543cc44bf3a211828d947a183b294a7e9af7ad" translate="yes" xml:space="preserve">
          <source>Click on</source>
          <target state="translated">点击</target>
        </trans-unit>
        <trans-unit id="3332bb0a8aaeddbc5c4c764802dab7eac1b229dd" translate="yes" xml:space="preserve">
          <source>Click on the &quot;Tree: ....&quot; button.</source>
          <target state="translated">点击 &quot;树:.....&quot;按钮。</target>
        </trans-unit>
        <trans-unit id="f15f54a10c34d555b72ff683c2e2ac900e98d76a" translate="yes" xml:space="preserve">
          <source>Create pull request</source>
          <target state="translated">创建pull请求</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="5b40a987f771c491468f8d2c27086ff8829378a5" translate="yes" xml:space="preserve">
          <source>Fetch the commits (and branches) from the &quot;upstream&quot;:</source>
          <target state="translated">从 &quot;上游 &quot;中获取提交(和分支)。</target>
        </trans-unit>
        <trans-unit id="8794810c9e1140dda7a53c49126aeec77324d72d" translate="yes" xml:space="preserve">
          <source>Fetching</source>
          <target state="translated">Fetching</target>
        </trans-unit>
        <trans-unit id="de8ecbd3f82de881ecb335599deb8883e5dcdb55" translate="yes" xml:space="preserve">
          <source>Fetching from the remote repository will bring in its branches and their respective commits. These are stored in your local repository under special branches.</source>
          <target state="translated">从远程版本库中提取会带来它的分支和各自的提交。这些分支被存储在你的本地版本库的特殊分支下。</target>
        </trans-unit>
        <trans-unit id="ad5e28ad709967562cc9a234219d9cd5ce08ca14" translate="yes" xml:space="preserve">
          <source>Follow the below steps. I tried them and it helped me.</source>
          <target state="translated">按照下面的步骤来做。我试了一下,对我有帮助。</target>
        </trans-unit>
        <trans-unit id="aac6c9184d41f07130651418971dab1ad3bb3d7a" translate="yes" xml:space="preserve">
          <source>For more information about these commands, refer to &lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;step 3&lt;/a&gt;.</source>
          <target state="translated">有关这些命令的更多信息，请参阅&lt;a href=&quot;http://2buntu.com/articles/1459/keeping-your-forked-repo-synced-with-the-upstream-source/&quot;&gt;步骤3&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4daf005c65a6710994eea45279ec8f0858cdce7c" translate="yes" xml:space="preserve">
          <source>From the local clone of your fork, create your upstream remote. You only need to do that once:</source>
          <target state="translated">从你的叉子的本地克隆中,创建你的上游远程。你只需要做一次就可以了。</target>
        </trans-unit>
        <trans-unit id="7e8949b82184a3f3fa7e043499748855d5ab06a6" translate="yes" xml:space="preserve">
          <source>Get back your stashed changes (if any)</source>
          <target state="translated">拿回你藏起来的零钱(如果有的话)</target>
        </trans-unit>
        <trans-unit id="0af551dae4561b188cfce1916f265f84a1900eff" translate="yes" xml:space="preserve">
          <source>GitHub also provides instructions for this topic: &lt;a href=&quot;https://help.github.com/articles/syncing-a-fork/&quot;&gt;Syncing a fork&lt;/a&gt;</source>
          <target state="translated">GitHub还提供了有关该主题的说明： &lt;a href=&quot;https://help.github.com/articles/syncing-a-fork/&quot;&gt;同步fork&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e718004f95ed97d308f5c3b90b16f79859f4e3a" translate="yes" xml:space="preserve">
          <source>Here is GitHub's official document on &lt;a href=&quot;https://help.github.com/articles/syncing-a-fork&quot;&gt;Syncing a fork&lt;/a&gt;:</source>
          <target state="translated">这是GitHub上有关&lt;a href=&quot;https://help.github.com/articles/syncing-a-fork&quot;&gt;同步fork&lt;/a&gt;的官方文档：</target>
        </trans-unit>
        <trans-unit id="9b2ec29532190fe18af38b3ec081dc17c3f39aab" translate="yes" xml:space="preserve">
          <source>Here two &lt;code&gt;mergemethods&lt;/code&gt; are into play, one is &lt;code&gt;hardreset&lt;/code&gt; which helps force sync changes in the &lt;code&gt;master&lt;/code&gt; branch of the forked repo with the parent repo and the other method is &lt;code&gt;merge&lt;/code&gt;. This method is used to merge changes done by you in the &lt;code&gt;feature&lt;/code&gt; branch and changes done due to force sync in the &lt;code&gt;master&lt;/code&gt; branch. In case of merge conflict, the pull app will allow you to choose the next course of action during the pull request.</source>
          <target state="translated">这里有两种 &lt;code&gt;mergemethods&lt;/code&gt; 方法，一种是硬重置 ，这可以帮助强制分叉的repo的 &lt;code&gt;master&lt;/code&gt; 分支与父repo进行同步更改，另一种方法是 &lt;code&gt;merge&lt;/code&gt; 。 此方法用于合并您在 &lt;code&gt;feature&lt;/code&gt; 分支中所做的更改和在 &lt;code&gt;master&lt;/code&gt; 分支中由于强制同步而完成的更改。 如果发生合并冲突，则拉应用程序将允许您在拉请求期间选择下一个操作过程。</target>
        </trans-unit>
        <trans-unit id="b5feec425815667dd7926e4b4daeaf95a1186782" translate="yes" xml:space="preserve">
          <source>How can I get that change into my fork? Do I need to delete and re-create my fork when I have further changes to contribute? Or is there an update button?</source>
          <target state="translated">我怎样才能把这个改动放到我的分叉中?当我有进一步的改动要贡献时,我需要删除并重新创建我的分叉吗?还是有一个更新按钮?</target>
        </trans-unit>
        <trans-unit id="df3f50d03f3257c40379dd4c99a541c8b77c103e" translate="yes" xml:space="preserve">
          <source>How do I update a GitHub forked repository</source>
          <target state="translated">如何更新GitHub forked版本库?</target>
        </trans-unit>
        <trans-unit id="2a343e9b11ae32ded7d0e7a5911f54356160ee28" translate="yes" xml:space="preserve">
          <source>How it works (it is a guess, I don't know how exactly GitHub does it): forks share object storage and use &lt;a href=&quot;https://git-scm.com/docs/gitnamespaces&quot;&gt;namespaces&lt;/a&gt; to separate users' references. So you can access all commits through your fork, even if they did not exist by the time of forking.</source>
          <target state="translated">它是如何工作的（猜测，我不知道GitHub是如何做到的）：fork共享对象存储并使用&lt;a href=&quot;https://git-scm.com/docs/gitnamespaces&quot;&gt;命名空间&lt;/a&gt;来分隔用户的引用。 因此，即使在派生时它们不存在，您也可以通过分支访问所有提交。</target>
        </trans-unit>
        <trans-unit id="a7a6d461704fadab40e3cbdcaa120b732e90a03d" translate="yes" xml:space="preserve">
          <source>I am currently using this configuration in my forked repo &lt;a href=&quot;https://github.com/Saurabh702/notepad-plus-plus&quot;&gt;here&lt;/a&gt; to make sure an enhancement requested &lt;a href=&quot;https://stackoverflow.com/q/20700696/10155936&quot;&gt;here&lt;/a&gt; stays updated.</source>
          <target state="translated">我目前在&lt;a href=&quot;https://github.com/Saurabh702/notepad-plus-plus&quot;&gt;此处的&lt;/a&gt;分叉存储库中使用此配置，以确保&lt;a href=&quot;https://stackoverflow.com/q/20700696/10155936&quot;&gt;此处&lt;/a&gt;请求的增强功能保持更新。</target>
        </trans-unit>
        <trans-unit id="78d7a9033ce91a4b7b3a7701acdd5a29798f8a71" translate="yes" xml:space="preserve">
          <source>I recently forked a project and applied several fixes. I then created a pull request which was then accepted.</source>
          <target state="translated">我最近分叉了一个项目,并应用了几个修复方案。然后我创建了一个拉动请求,然后被接受了。</target>
        </trans-unit>
        <trans-unit id="b68acdee24b57f33bdc001ed632493c5aacf71af" translate="yes" xml:space="preserve">
          <source>I update my forked repos with this one line:</source>
          <target state="translated">我用这一句话更新了我的分叉仓库。</target>
        </trans-unit>
        <trans-unit id="3d1755748b7a1f154a7eb20aaa1e789b4626379d" translate="yes" xml:space="preserve">
          <source>I would like to add on to &lt;a href=&quot;https://stackoverflow.com/users/946850/krlmlr&quot;&gt;@krlmlr's&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/58965171/10155936&quot;&gt;answer&lt;/a&gt;.</source>
          <target state="translated">我想补充&lt;a href=&quot;https://stackoverflow.com/users/946850/krlmlr&quot;&gt;@krlmlr的&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/58965171/10155936&quot;&gt;答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="71af5f6a415612676d1ad958b19ac1026d89b7ad" translate="yes" xml:space="preserve">
          <source>If it's quite a big repository you may have wanted to manage it in a special way (e.g. drop history). Basically, you can get differences between current and upstream versions, commit them and then cherry pick back to master.</source>
          <target state="translated">如果它是一个相当大的版本库,你可能想用一种特殊的方式来管理它(比如说删除历史记录)。基本上,你可以得到当前版本和上游版本之间的差异,提交它们,然后再挑回主版本。</target>
        </trans-unit>
        <trans-unit id="f360336737f9708dddf596319f29f29ec83c7e7f" translate="yes" xml:space="preserve">
          <source>If you are using GitHub for Windows or Mac then now they have a one-click feature to update forks:</source>
          <target state="translated">如果你正在使用GitHub for Windows或Mac,那么现在他们有一个一键更新叉子的功能。</target>
        </trans-unit>
        <trans-unit id="d583b891b833ad9366a05e0e74488e8f90cc70ea" translate="yes" xml:space="preserve">
          <source>If you click</source>
          <target state="translated">如果您点击</target>
        </trans-unit>
        <trans-unit id="8cd173ef4abf2972ff0859ffa0e0e3238865ce10" translate="yes" xml:space="preserve">
          <source>If you click the dropdown and choose &quot;Squash and merge&quot;, all intervening commits will be squashed into one. This is most often something you don't want.</source>
          <target state="translated">如果你点击下拉菜单,选择 &quot;挤压和合并&quot;,那么所有中间的提交都会被挤压成一个。这往往是你最不希望看到的。</target>
        </trans-unit>
        <trans-unit id="90d18659a140ac7f945393381c5f3b9ca34813b7" translate="yes" xml:space="preserve">
          <source>If you don't want to rewrite the history of your master branch, (for example because other people may have cloned it) then you should replace the last command with &lt;code&gt;git merge upstream/master&lt;/code&gt;.  However, for making further pull requests that are as clean as possible, it's probably better to rebase.</source>
          <target state="translated">如果您不想重写master分支的历史记录（例如，因为其他人可能已经克隆了它），则应将最后一个命令替换为 &lt;code&gt;git merge upstream/master&lt;/code&gt; 。 但是，为了发出更多尽可能干净的拉取请求，最好重新设置基准。</target>
        </trans-unit>
        <trans-unit id="f776089b6ff08edf49e6864a333020e225edb195" translate="yes" xml:space="preserve">
          <source>If you set your upstream. Check with &lt;code&gt;git remote -v&lt;/code&gt;, then this will suffice.</source>
          <target state="translated">如果您设置上游。 用 &lt;code&gt;git remote -v&lt;/code&gt; 检查，就足够了。</target>
        </trans-unit>
        <trans-unit id="eecc136151fb2163383b33ace6b3000a063ca69a" translate="yes" xml:space="preserve">
          <source>If you want the forked repository to be in sync with the parent repository, you could set up a config file(&lt;code&gt;pull.yml&lt;/code&gt;) for the &lt;a href=&quot;https://github.com/apps/pull&quot;&gt;Pull app&lt;/a&gt; (&lt;em&gt;in the feature branch&lt;/em&gt;), like this:</source>
          <target state="translated">如果希望分支的存储库与父存储库同步， &lt;code&gt;pull.yml&lt;/code&gt; 以为&lt;a href=&quot;https://github.com/apps/pull&quot;&gt;Pull应用程序&lt;/a&gt; （ &lt;em&gt;在功能分支中&lt;/em&gt; ）设置一个配置文件（ pull.yml ），如下所示：</target>
        </trans-unit>
        <trans-unit id="77060506139f0b51bcc1b4098f77874ee60d9177" translate="yes" xml:space="preserve">
          <source>If you've rebased your branch onto &lt;code&gt;upstream/master&lt;/code&gt; you may need to force the push in order to push it to your own forked repository on GitHub.  You'd do that with:</source>
          <target state="translated">如果您已将分支重新建立到 &lt;code&gt;upstream/master&lt;/code&gt; ，则可能需要强制执行推送才能将其推送到GitHub上自己的分叉存储库中。 您可以这样做：</target>
        </trans-unit>
        <trans-unit id="000a1d52ae55ce4b3bb388299603fc6d81fc1724" translate="yes" xml:space="preserve">
          <source>If your local branch didn't have any unique commits, git will instead perform a &quot;fast-forward&quot;:</source>
          <target state="translated">如果你的本地分支没有任何独特的提交,git会执行 &quot;快进&quot;。</target>
        </trans-unit>
        <trans-unit id="d61bf845eb2e03fe01a1bce8c1c5087cb5e173fb" translate="yes" xml:space="preserve">
          <source>If, like me, you &lt;strong&gt;never commit anything directly to master&lt;/strong&gt;, which you should really, you can do the following.</source>
          <target state="translated">如果像我一样，您&lt;strong&gt;从未将任何事情直接提交给master&lt;/strong&gt; ，那么您应该执行以下操作。</target>
        </trans-unit>
        <trans-unit id="ba7ece19362b2a8c4dc2565657e3511e377c5240" translate="yes" xml:space="preserve">
          <source>In your local clone of your forked repository, you can add the original GitHub repository as a &quot;remote&quot;.  (&quot;Remotes&quot; are like nicknames for the URLs of repositories - &lt;code&gt;origin&lt;/code&gt; is one, for example.)  Then you can fetch all the branches from that upstream repository, and rebase your work to continue working on the upstream version.  In terms of commands that might look like:</source>
          <target state="translated">在您的分支存储库的本地克隆中，您可以将原始GitHub存储库添加为&amp;ldquo;远程&amp;rdquo;。 （&amp;ldquo; Remotes&amp;rdquo;就像是存储库URL的昵称-例如， &lt;code&gt;origin&lt;/code&gt; 是一个。）然后，您可以从该上游存储库中获取所有分支，并重新整理工作以继续使用上游版本。 在如下命令中：</target>
        </trans-unit>
        <trans-unit id="4f76a37b2e9c82019debf694fc201830d540f64f" translate="yes" xml:space="preserve">
          <source>Initially, the forked repository has one branch named : &lt;code&gt;master&lt;/code&gt;. If you are working on a new feature or a fix, you would generally create a new branch &lt;code&gt;feature&lt;/code&gt; and make the changes.</source>
          <target state="translated">最初，分叉的存储库具有一个名为： &lt;code&gt;master&lt;/code&gt; 的分支。 如果您正在使用新功能或修订，则通常会创建一个新的分支 &lt;code&gt;feature&lt;/code&gt; 并进行更改。</target>
        </trans-unit>
        <trans-unit id="567aa3a9c463f855ebdc229f01b738038656dcf5" translate="yes" xml:space="preserve">
          <source>Issue &lt;code&gt;git fetch upstream&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git fetch upstream&lt;/code&gt; 发出git fetch</target>
        </trans-unit>
        <trans-unit id="2904cebb10ab5eec224d68ccddd840625ed8a542" translate="yes" xml:space="preserve">
          <source>Issue &lt;code&gt;git push origin master&lt;/code&gt;</source>
          <target state="translated">发行 &lt;code&gt;git push origin master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a713068b13d135dfba7a6c9428bd80843ed4c780" translate="yes" xml:space="preserve">
          <source>Issue &lt;code&gt;git rebase upstream/master&lt;/code&gt;</source>
          <target state="translated">发行 &lt;code&gt;git rebase upstream/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19c5df0feb2b0529669b5279411c78a559c787e9" translate="yes" xml:space="preserve">
          <source>Let's assume that you cloned already your fork to your computer with a command like this:</source>
          <target state="translated">让我们假设你已经用这样的命令克隆了你的分叉到你的电脑上。</target>
        </trans-unit>
        <trans-unit id="a456f552d2cbe2b0b026d5f4dc290bf6543ca035" translate="yes" xml:space="preserve">
          <source>Merge pull request</source>
          <target state="translated">合并拉取请求</target>
        </trans-unit>
        <trans-unit id="1504d9472f1d9c97375340082225d911a0b0b19e" translate="yes" xml:space="preserve">
          <source>Merge the changes from the &quot;master&quot; branch of the &quot;upstream&quot; into your the &quot;master&quot; branch of your &quot;origin&quot;:</source>
          <target state="translated">将 &quot;上游 &quot;的 &quot;主 &quot;分支的变化合并到你的 &quot;原点 &quot;的 &quot;主 &quot;分支中。</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="c46dcb747276ef7e8abc1bb08d26a98e6491aa62" translate="yes" xml:space="preserve">
          <source>New Pull Request</source>
          <target state="translated">新的拉动请求</target>
        </trans-unit>
        <trans-unit id="7fb9ddf13694977e0cf256f6247e6abd2cc1d409" translate="yes" xml:space="preserve">
          <source>Note: Since the feature request is unofficial it is also advisable to contact &lt;code&gt;support@github.com&lt;/code&gt; to add your support for a feature like this to be implemented. The unofficial feature request above could be used as evidence of the amount of interest in this being implemented.</source>
          <target state="translated">注意：由于功能请求是非官方的，因此建议也联系 &lt;code&gt;support@github.com&lt;/code&gt; ,以添加对要实现的功能的支持。 上面的非官方功能请求可以用作对此实施过程感兴趣的证据。</target>
        </trans-unit>
        <trans-unit id="90ec6d50e987929ac6a45b7b32db268e747b1c74" translate="yes" xml:space="preserve">
          <source>Now that we have fetched the upstream repository, we want to merge its changes into our local branch. This will bring that branch into sync with the upstream, without losing our local changes.</source>
          <target state="translated">现在我们已经获取了上游版本库,我们要把它的修改合并到我们的本地分支中。这将使该分支与上游分支同步,而不会丢失我们的本地变化。</target>
        </trans-unit>
        <trans-unit id="fd009286901c837efdaef58b7a10f3197c9d3276" translate="yes" xml:space="preserve">
          <source>Now you have three options, but each will lead to a less-than-clean commit history.</source>
          <target state="translated">现在你有三个选项,但每个选项都会导致不那么干净的提交历史。</target>
        </trans-unit>
        <trans-unit id="8bf2ab2b4594a56cd8b9fb6f9bdbeec3bb92f849" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;https://github.com/&amp;lt;repo&amp;gt;/commits/&amp;lt;hash&amp;gt;&lt;/code&gt;, where &lt;em&gt;repo&lt;/em&gt; is your fork, and &lt;em&gt;hash&lt;/em&gt; is full hash of commit which you can find in the upstream web interface. For example, I can open &lt;a href=&quot;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&quot;&gt;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&lt;/a&gt;, which points to &lt;code&gt;linux&lt;/code&gt;&lt;code&gt;master&lt;/code&gt; as time of writing.</source>
          <target state="translated">打开 &lt;code&gt;https://github.com/&amp;lt;repo&amp;gt;/commits/&amp;lt;hash&amp;gt;&lt;/code&gt; ，其中&lt;em&gt;repo&lt;/em&gt;是您的fork，而&lt;em&gt;hash&lt;/em&gt;是您可以在上游Web界面中找到的完全提交的哈希。 例如，我可以打开&lt;a href=&quot;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&quot;&gt;https://github.com/max630/linux/commits/0aa0313f9d576affd7747cc3f179feb097d28990&lt;/a&gt; ，它在撰写本文时指向 &lt;code&gt;linux&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf7747d9aa574b4704007bf15ba2ed436f66d151" translate="yes" xml:space="preserve">
          <source>Open menu &lt;em&gt;VCS&lt;/em&gt; &amp;rarr; &lt;em&gt;Git&lt;/em&gt;</source>
          <target state="translated">打开菜单&lt;em&gt;VCS&lt;/em&gt; &amp;rarr; &lt;em&gt;Git&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234ae272ca6f312c89a8e8df6909fdfb0acb3451" translate="yes" xml:space="preserve">
          <source>Open your fork on GitHub.</source>
          <target state="translated">在GitHub上打开你的叉子。</target>
        </trans-unit>
        <trans-unit id="27ac6148008f56cd689f0438348c712daa89325f" translate="yes" xml:space="preserve">
          <source>Past the initial upstream setup and master checkout, all you need to do is run the following command to sync your master with upstream: &lt;strong&gt;git pull upstream master&lt;/strong&gt;.</source>
          <target state="translated">在完成初始上游设置和master检出之后，您所需要做的就是运行以下命令将您的master与上游同步： &lt;strong&gt;git pull上游master&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="30ab8d084e2209d47a1dc198c8de1e251f390a94" translate="yes" xml:space="preserve">
          <source>Pull Requests</source>
          <target state="translated">拉动请求</target>
        </trans-unit>
        <trans-unit id="ae6fc052a45c770a9169a7ab638bc505e00bb03c" translate="yes" xml:space="preserve">
          <source>Push the changes to your fork</source>
          <target state="translated">将变化推送到你的货叉上</target>
        </trans-unit>
        <trans-unit id="5693314a70b827fd392394697ad3e48be809f455" translate="yes" xml:space="preserve">
          <source>Rebase and merge</source>
          <target state="translated">重打基础和合并</target>
        </trans-unit>
        <trans-unit id="2be8b8a63ab459b9cea7716971f0b489291f8f7d" translate="yes" xml:space="preserve">
          <source>Resolve merge conflicts if any and commit your merge</source>
          <target state="translated">如果有合并冲突,请解决合并冲突,并提交您的合并。</target>
        </trans-unit>
        <trans-unit id="d4af81a4796c3cb95c1f56e0df4695725005f254" translate="yes" xml:space="preserve">
          <source>Scroll down to</source>
          <target state="translated">向下滚动到</target>
        </trans-unit>
        <trans-unit id="d61c5e591073d46124cf6b9aecef7a23df6ba7fd" translate="yes" xml:space="preserve">
          <source>Select the repository in the UI.</source>
          <target state="translated">在UI中选择存储库。</target>
        </trans-unit>
        <trans-unit id="e7e619212ed526f7f497ba569b8215af3e6930ce" translate="yes" xml:space="preserve">
          <source>Since November 2013 there has been an unofficial feature request open with GitHub to ask them to add a very simple and intuitive method to keep a local fork in sync with upstream:</source>
          <target state="translated">从2013年11月开始,就有一个非官方的功能请求开放给GitHub,要求他们增加一个非常简单直观的方法,让本地叉子与上游同步。</target>
        </trans-unit>
        <trans-unit id="7471ffd6ac4a8061b4408edaa480bb1bc093a600" translate="yes" xml:space="preserve">
          <source>So when your &lt;em&gt;Pull Request&lt;/em&gt; is accepted then you can safely delete the branch as your contributed code will be then live in your master of your forked repository when you update it with the upstream. By this your master will always be in clean condition to create a new branch to do another change.</source>
          <target state="translated">因此，当您的&lt;em&gt;请求请求&lt;/em&gt;被接受时，您可以安全地删除分支，因为当您使用上游更新它时，您贡献的代码将保存在您的分支存储库的主目录中。 这样，您的主控将始终处于干净状态，以创建新分支来进行其他更改。</target>
        </trans-unit>
        <trans-unit id="bde179cf043a598d6ebae765e11145b2713e12da" translate="yes" xml:space="preserve">
          <source>So yes, you can keep your repo updated with its upstream using the GitHub web UI, but doing so will sully your commit history. Stick to &lt;a href=&quot;https://stackoverflow.com/questions/7244321/how-do-i-update-a-github-forked-repository/7244456#7244456&quot;&gt;the command line&lt;/a&gt; instead - it's easy.</source>
          <target state="translated">因此，可以，您可以使用GitHub Web UI对其仓库进行上游更新，但是这样做可以确保提交历史记录。 坚持&lt;a href=&quot;https://stackoverflow.com/questions/7244321/how-do-i-update-a-github-forked-repository/7244456#7244456&quot;&gt;使用命令行&lt;/a&gt; -这很容易。</target>
        </trans-unit>
        <trans-unit id="af3d4309c9cbe26ad276b210691bac0fd29af135" translate="yes" xml:space="preserve">
          <source>Source is here: &lt;a href=&quot;https://github.com/upriver/upriver.github.io&quot;&gt;https://github.com/upriver/upriver.github.io&lt;/a&gt;</source>
          <target state="translated">来源在这里： &lt;a href=&quot;https://github.com/upriver/upriver.github.io&quot;&gt;https&lt;/a&gt; : //github.com/upriver/upriver.github.io</target>
        </trans-unit>
        <trans-unit id="b2b25a8ecb73ab17a486ebf26f4dc535e692fd1d" translate="yes" xml:space="preserve">
          <source>Starting in May 2014, it is possible to update a fork directly from GitHub. This still works as of September 2017, &lt;strong&gt;BUT&lt;/strong&gt; it will lead to a dirty commit history.</source>
          <target state="translated">从2014年5月开始，可以直接从GitHub更新fork。 到2017年9月，它仍然有效， &lt;strong&gt;但是&lt;/strong&gt;会导致肮脏的提交历史。</target>
        </trans-unit>
        <trans-unit id="94232c5c336a258f43a35d0ed1f8564a260b87f4" translate="yes" xml:space="preserve">
          <source>Stash the changes of your &quot;master&quot; branch:</source>
          <target state="translated">把你的 &quot;主子 &quot;分支的变化储存起来。</target>
        </trans-unit>
        <trans-unit id="00b47bb1619911e7792fe20f714c21d2a1fc7eab" translate="yes" xml:space="preserve">
          <source>Switch to master branch if you are not &lt;code&gt;git checkout master&lt;/code&gt;</source>
          <target state="translated">如果您不是 &lt;code&gt;git checkout master&lt;/code&gt; ,请切换到master分支</target>
        </trans-unit>
        <trans-unit id="550dbb15410741b3ec255e0399965d535e2b1607" translate="yes" xml:space="preserve">
          <source>Switch to the &quot;master&quot; branch of your fork (&quot;origin&quot;):</source>
          <target state="translated">切换到你叉子的 &quot;主 &quot;分支(&quot;起源&quot;)。</target>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="a95b37b3017effb7b215d767ac0e2211e6aa724b" translate="yes" xml:space="preserve">
          <source>Syncing a fork</source>
          <target state="translated">同步分叉</target>
        </trans-unit>
        <trans-unit id="f6cab97732eaeae1f3f5633b252cbea26c2cada7" translate="yes" xml:space="preserve">
          <source>That depends on the size of your repository and how you forked it.</source>
          <target state="translated">这取决于你的存储库的大小和你如何分叉。</target>
        </trans-unit>
        <trans-unit id="5dc7ae634569e14ec7d42e039a67f21cd21cbe73" translate="yes" xml:space="preserve">
          <source>The &quot;fetch&quot; command is indispensable for staying up-to-date in a project: only when performing a &quot;git fetch&quot; will you be informed about the changes your colleagues pushed to the remote server.</source>
          <target state="translated">在一个项目中,&quot;fetch &quot;命令对于保持项目的最新状态是必不可少的:只有在执行 &quot;git fetch &quot;命令时,你才会被告知你的同事推送到远程服务器上的更改。</target>
        </trans-unit>
        <trans-unit id="aaf533ccf7e6caa9b7b03a28b06c9bac28a5ee27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/apps/pull&quot;&gt;&quot;Pull&quot; app&lt;/a&gt; is an automatic set-up-and-forget solution. It will sync the default branch of your fork with the upstream repository.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apps/pull&quot;&gt;&amp;ldquo;拉&amp;rdquo;应用程序&lt;/a&gt;是一种自动设置和忘记的解决方案。 它将把fork的默认分支与上游存储库同步。</target>
        </trans-unit>
        <trans-unit id="0b41a8d83b439c9b4f4885f64b9339a1c1d30a13" translate="yes" xml:space="preserve">
          <source>The Setup</source>
          <target state="translated">设置</target>
        </trans-unit>
        <trans-unit id="264bd0e9406f8519a0848bd766d97c323e32936c" translate="yes" xml:space="preserve">
          <source>The branch is updated once per hour directly on GitHub, on your local machine you need to pull the master branch to ensure that your local copy is in sync.</source>
          <target state="translated">该分支每小时直接在GitHub上更新一次,在你的本地机器上,你需要拉出主分支以确保你的本地副本是同步的。</target>
        </trans-unit>
        <trans-unit id="8f7c026574a5c8cfd1326e6ff76ca5c776670d83" translate="yes" xml:space="preserve">
          <source>The default will create an ugly merge commit.</source>
          <target state="translated">默认会创建一个丑陋的合并提交。</target>
        </trans-unit>
        <trans-unit id="6f1ebfb3019b0fae6470df879b3b87ef304817de" translate="yes" xml:space="preserve">
          <source>The first part of this command lists all heads in the &lt;em&gt;upstream&lt;/em&gt; remote repo and removes the SHA-1 followed by &lt;code&gt;refs/heads/&lt;/code&gt; branch name prefix.</source>
          <target state="translated">该命令的第一部分列出了&lt;em&gt;上游&lt;/em&gt;远程回购中的所有头，并删除了SHA-1，后跟 &lt;code&gt;refs/heads/&lt;/code&gt; 分支名称前缀。</target>
        </trans-unit>
        <trans-unit id="0fd61e5b8cc0dcec4af47834c1c482a521206bf7" translate="yes" xml:space="preserve">
          <source>Then for each of these branches, it pushes the local copy of the &lt;em&gt;upstream&lt;/em&gt; remote tracking branch (&lt;code&gt;refs/remotes/upstream/&amp;lt;branch&amp;gt;&lt;/code&gt; on local side) directly to the remote branch on &lt;em&gt;origin&lt;/em&gt; (&lt;code&gt;refs/heads/&amp;lt;branch&amp;gt;&lt;/code&gt; on remote side).</source>
          <target state="translated">然后，对于这些分支中的每一个，它将&lt;em&gt;上游&lt;/em&gt;远程跟踪分支的本地副本（本地端的 &lt;code&gt;refs/remotes/upstream/&amp;lt;branch&amp;gt;&lt;/code&gt; ）直接推到&lt;em&gt;原始&lt;/em&gt;端的远程分支（远程端的 &lt;code&gt;refs/heads/&amp;lt;branch&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c40a11b834f4f1e641021d97be329e8b5d0b544e" translate="yes" xml:space="preserve">
          <source>Then run:</source>
          <target state="translated">那就跑吧。</target>
        </trans-unit>
        <trans-unit id="4e3c3ccfe5c2a2ebf037580df28bcb9fb26dc642" translate="yes" xml:space="preserve">
          <source>Then whenever you want to catch up with the upstream repository master branch you need to:</source>
          <target state="translated">那么每当你想赶上上游资源库主分支,你需要。</target>
        </trans-unit>
        <trans-unit id="55f2ca371ae7e64950478e9d947b56fc79a8fc12" translate="yes" xml:space="preserve">
          <source>There are two main things on keeping a forked repository always update for good.</source>
          <target state="translated">关于保持分叉仓库永远更新,主要有两点。</target>
        </trans-unit>
        <trans-unit id="8b85c401196c95bfb03457e3a7d6a5d80620657f" translate="yes" xml:space="preserve">
          <source>There are two steps required to sync your repository with the upstream: first you must fetch from the remote, then you must merge the desired branch into your local branch.</source>
          <target state="translated">有两个步骤需要将你的仓库与上游同步:首先你必须从远程获取,然后你必须将所需的分支合并到本地分支。</target>
        </trans-unit>
        <trans-unit id="8c4a41363b12f65f41188e7ab9b8178b65cd6f00" translate="yes" xml:space="preserve">
          <source>This assumes you have already configured an &lt;em&gt;upstream&lt;/em&gt; remote pointing at the source repository (where &lt;em&gt;origin&lt;/em&gt; was forked from) and have synced it with &lt;code&gt;git fetch upstream&lt;/code&gt;.</source>
          <target state="translated">假设您已经配置了一个指向源存储库（从中派生&lt;em&gt;原始&lt;/em&gt;源）的&lt;em&gt;上游&lt;/em&gt;远程服务器，并且已将其与 &lt;code&gt;git fetch upstream&lt;/code&gt; 同步。</target>
        </trans-unit>
        <trans-unit id="d3f73d1133e9c4aa6c1cb82052b4e208866b9e1e" translate="yes" xml:space="preserve">
          <source>This can be done with &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot;&gt;cron&lt;/a&gt;&lt;/em&gt;. Here is for an example code if you do it in linux.</source>
          <target state="translated">这可以使用&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cron&quot;&gt;cron&lt;/a&gt;&lt;/em&gt;完成。 如果您在linux中进行操作，这是示例代码。</target>
        </trans-unit>
        <trans-unit id="3c04d0e03a98055770769ef6c37adf6dffe58c36" translate="yes" xml:space="preserve">
          <source>This keeps the &lt;code&gt;master&lt;/code&gt; branch of the forked repo up-to-date with the parent repo.  It keeps the &lt;code&gt;feature&lt;/code&gt; branch of the forked repo updated via the &lt;code&gt;master&lt;/code&gt; branch of the forked repo by merging the same. This assumes that the &lt;code&gt;feature&lt;/code&gt; branch is the default branch which contains the config file.</source>
          <target state="translated">这样可以使分叉存储库的 &lt;code&gt;master&lt;/code&gt; 分支与父存储库保持最新。 通过合并叉化仓库的 &lt;code&gt;master&lt;/code&gt; 分支，它可以使叉化仓库的 &lt;code&gt;feature&lt;/code&gt; 分支保持更新。 假定 &lt;code&gt;feature&lt;/code&gt; 分支是包含配置文件的默认分支。</target>
        </trans-unit>
        <trans-unit id="ab33c2f98bee89af79c24e3347a9eca7e1e6213d" translate="yes" xml:space="preserve">
          <source>Try reading &lt;a href=&quot;https://www.atlassian.com/blog/git/handle-big-repositories-git&quot;&gt;this one&lt;/a&gt;. It describes how to handle big Git repositories and how to upstream them with latest changes.</source>
          <target state="translated">尝试阅读&lt;a href=&quot;https://www.atlassian.com/blog/git/handle-big-repositories-git&quot;&gt;这一本&lt;/a&gt; 。 它描述了如何处理大型Git存储库以及如何通过最新更改将其上游。</target>
        </trans-unit>
        <trans-unit id="7348e561a5ae9cb8353b257c56d9e4058e561c43" translate="yes" xml:space="preserve">
          <source>Try them. I use the first one to synchronize my local repository. Anyway the branches from the parent remote repository (&quot;upstream&quot;) will be accessible in Android Studio after you click &quot;Rebase my GitHub fork&quot;, and you will be able to operate with them easily.</source>
          <target state="translated">试试他们。我用第一个来同步我的本地版本库。总之,在点击 &quot;Rebase my GitHub fork &quot;后,在Android Studio中就可以访问到来自于父级远程仓库(&quot;上游&quot;)的分支,这样你就可以很容易地使用它们进行操作。</target>
        </trans-unit>
        <trans-unit id="05a79fa3f7b71ff3af83543b0a99f9e7dc46d22d" translate="yes" xml:space="preserve">
          <source>Type name of the new branch and press</source>
          <target state="translated">键入新分支的名称,然后按</target>
        </trans-unit>
        <trans-unit id="48d7f3aad1014aaefe582d965a38754ca3c81e6d" translate="yes" xml:space="preserve">
          <source>Use these commands (in lucky case)</source>
          <target state="translated">使用这些命令(在幸运的情况下</target>
        </trans-unit>
        <trans-unit id="c958a967cc046028cbaa999ed165b1df294e56ca" translate="yes" xml:space="preserve">
          <source>Use this if you dont want to add another remote endpoint to your project, as other solutions posted here.</source>
          <target state="translated">如果你不想在你的项目中添加另一个远程端点,请使用这个,就像这里发布的其他解决方案一样。</target>
        </trans-unit>
        <trans-unit id="113dabb069eb5c3615ca09078051fb9bfe028789" translate="yes" xml:space="preserve">
          <source>Visit the URL, click the green &quot;Install&quot; button and select the repositories where you want to enable automatic synchronization.</source>
          <target state="translated">访问URL,点击绿色的 &quot;安装 &quot;按钮,选择要启用自动同步的资源库。</target>
        </trans-unit>
        <trans-unit id="9e41c53b0c9e900eb8c17dcec719e6c5e2cda65e" translate="yes" xml:space="preserve">
          <source>We now have the upstream's master branch stored in a local branch, upstream/master</source>
          <target state="translated">我们现在将上游的主分支存储在本地分支上流master</target>
        </trans-unit>
        <trans-unit id="70996155aeb81fb8f674121234ed3c2b155fbcc6" translate="yes" xml:space="preserve">
          <source>When you have cloned your forked repository, go to the directory path where your clone resides and the few lines in your Git Bash Terminal.</source>
          <target state="translated">当你克隆了你的分叉仓库后,到你的分叉仓库所在的目录路径和 Git Bash 终端中的几行代码。</target>
        </trans-unit>
        <trans-unit id="b4273e60bfcbcab2ec3724e77b23410fb74fa6aa" translate="yes" xml:space="preserve">
          <source>You can read about basic and advanced configs and various &lt;code&gt;mergemethods&lt;/code&gt;&lt;a href=&quot;https://github.com/wei/pull/#getting-started&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以&lt;a href=&quot;https://github.com/wei/pull/#getting-started&quot;&gt;在此处&lt;/a&gt;阅读有关基本和高级配置以及各种 &lt;code&gt;mergemethods&lt;/code&gt; 信息 。</target>
        </trans-unit>
        <trans-unit id="a5a7f7e1f68353d42fb1d08559607349859cb7d0" translate="yes" xml:space="preserve">
          <source>You can still visit &lt;a href=&quot;https://help.github.com/articles/fetching-a-remote/&quot;&gt;here&lt;/a&gt; for further queries</source>
          <target state="translated">您仍然可以访问&lt;a href=&quot;https://help.github.com/articles/fetching-a-remote/&quot;&gt;此处&lt;/a&gt;进行进一步查询</target>
        </trans-unit>
        <trans-unit id="ff6f510068911753cb9bd5368c75b45cf289df57" translate="yes" xml:space="preserve">
          <source>You can then fetch that branch to your local clone, and you won't have to push all that data back to GitHub when you push edits on top of that commit. Or use the web interface to change something in that branch.</source>
          <target state="translated">然后,你可以将该分支获取到你的本地克隆,这样当你在提交的基础上推送编辑时,就不用再将所有的数据推送回GitHub。或者使用 Web 界面来修改该分支中的内容。</target>
        </trans-unit>
        <trans-unit id="39a2962d24c5da003463d40c3ba453db9e711b97" translate="yes" xml:space="preserve">
          <source>You only need to use the &lt;code&gt;-f&lt;/code&gt; the first time after you've rebased.</source>
          <target state="translated">重新设定基准后，您只需要在第一次使用 &lt;code&gt;-f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c434032ffe13d43d03ab1c4fccc8af93e0a936ea" translate="yes" xml:space="preserve">
          <source>You're done! Congratulations!</source>
          <target state="translated">你成功了!恭喜你!</target>
        </trans-unit>
        <trans-unit id="a746abb742e0859202204870a3d7b7c8a1cc09c0" translate="yes" xml:space="preserve">
          <source>and assign a predictable name to your pull request (e.g., &lt;code&gt;Update from original&lt;/code&gt;).</source>
          <target state="translated">并为您的提取请求分配一个可预测的名称（例如， &lt;code&gt;Update from original&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df21a3d2fd99b84fa7cb13ec4ad8cb363da327a4" translate="yes" xml:space="preserve">
          <source>base fork</source>
          <target state="translated">底叉</target>
        </trans-unit>
        <trans-unit id="532f130ef6fb0e430af8a5beabc44c9f973fffb7" translate="yes" xml:space="preserve">
          <source>drop down to your fork, and the</source>
          <target state="translated">降到你的叉子上,然后</target>
        </trans-unit>
        <trans-unit id="2fea52e0bcab5f5be75f35cc928f2d5d550f6363" translate="yes" xml:space="preserve">
          <source>head fork</source>
          <target state="translated">头叉</target>
        </trans-unit>
        <trans-unit id="adddb4502940da2585c73da6895d602125b04b64" translate="yes" xml:space="preserve">
          <source>if you see that link. Otherwise, manually set the</source>
          <target state="translated">如果你看到那个链接。否则,手动设置</target>
        </trans-unit>
        <trans-unit id="4f4d58ad0cad805b755078913c2a8c10b63617f7" translate="yes" xml:space="preserve">
          <source>put this code on the &lt;code&gt;crontab file&lt;/code&gt; to execute the job in hourly basis.</source>
          <target state="translated">将此代码放在 &lt;code&gt;crontab file&lt;/code&gt; ，以每小时执行一次作业。</target>
        </trans-unit>
        <trans-unit id="2b5782d6a2c529fd97cbf05eb0094e6162849111" translate="yes" xml:space="preserve">
          <source>switching the base</source>
          <target state="translated">调换底座</target>
        </trans-unit>
        <trans-unit id="d057e0f6d02a5d2cb09ee3e8d5bcb43e5378e0b5" translate="yes" xml:space="preserve">
          <source>then create the &lt;code&gt;cron.sh&lt;/code&gt; script file and a &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/56304600/4058484&quot;&gt;git interaction&lt;/a&gt;&lt;/em&gt; with &lt;em&gt;&lt;a href=&quot;https://www.ssh.com/ssh/agent&quot;&gt;ssh-agent&lt;/a&gt;&lt;/em&gt; and/or &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/55779022/4058484&quot;&gt;expect&lt;/a&gt;&lt;/em&gt; as below</source>
          <target state="translated">然后创建 &lt;code&gt;cron.sh&lt;/code&gt; 脚本文件和与&lt;em&gt;&lt;a href=&quot;https://www.ssh.com/ssh/agent&quot;&gt;ssh-agent&lt;/a&gt;&lt;/em&gt;的&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/56304600/4058484&quot;&gt;git交互&lt;/a&gt;&lt;/em&gt;和/或&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/55779022/4058484&quot;&gt;期望&lt;/a&gt;&lt;/em&gt;如下</target>
        </trans-unit>
        <trans-unit id="e94efa29d42e9ae0e72fe4835a46e739de853f87" translate="yes" xml:space="preserve">
          <source>to the upstream. Now GitHub will compare your fork with the original, and you should see all the latest changes.</source>
          <target state="translated">到上游。现在GitHub会把你的fork和原版进行比较,你应该可以看到所有最新的变化。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
