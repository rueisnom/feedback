<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/728360">
    <body>
      <group id="728360">
        <trans-unit id="5fff870d002057a570c5f54f6e0583f072249e21" translate="yes" xml:space="preserve">
          <source>... and you see, it didn't work with the nested structure inside.</source>
          <target state="translated">....而你看,里面的嵌套结构没有用。</target>
        </trans-unit>
        <trans-unit id="fdf1515d42ec5590b0b9470e710e5a34edb33d3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="f8d42eb23fc0b5363fad3b52a8388240db181867" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clone with references on second level:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;克隆二级引用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cea8c7ca59555849767060049632be16cd783d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete clone:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;完整克隆：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6966d0f501ab4b788d3ea14f276d58f9c181e993" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; imagine you have this object below and you want to clone it:</source>
          <target state="translated">&lt;strong&gt;好的，&lt;/strong&gt;假设您在下面有这个对象并且想要克隆它：</target>
        </trans-unit>
        <trans-unit id="22efe12cc8badd5b62cb63cbb32d48a03bfc69b9" translate="yes" xml:space="preserve">
          <source>A good reference is here:
&lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</source>
          <target state="translated">一个很好的参考在这里： &lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https&lt;/a&gt; : //googlechrome.github.io/samples/object-assign-es6/</target>
        </trans-unit>
        <trans-unit id="31e2fbcb0256c7808f1ca3a03007c73a654f8c07" translate="yes" xml:space="preserve">
          <source>A.Levy's answer is almost complete, here is my little contribution: &lt;strong&gt;there is a way how to handle recursive references&lt;/strong&gt;, see this line</source>
          <target state="translated">答：Levy的答案几乎是完整的，这是我的一点贡献： &lt;strong&gt;有一种方法可以处理递归引用&lt;/strong&gt; ，请参见此行</target>
        </trans-unit>
        <trans-unit id="75589da17d1b2a78b18aaddcd6a610f24da00c24" translate="yes" xml:space="preserve">
          <source>After arguing with my co-worker, my boss asked us what happened, and he found a simple &lt;em&gt;solution&lt;/em&gt; after some googling. It's called &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">与我的同事吵架后，我的老板问我们发生了什么，经过一番谷歌搜索，他找到了一个简单的&lt;em&gt;解决方案&lt;/em&gt; 。 它称为 &lt;code&gt;Object.create&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba29de559b1bb261e25a1d12df67e7d242566aa7" translate="yes" xml:space="preserve">
          <source>Although this question has many answers, I hope this one helps too.</source>
          <target state="translated">虽然这个问题有很多答案,但我希望这个问题也能帮到你。</target>
        </trans-unit>
        <trans-unit id="af28336e40dc39e63a92abf858f8c6ab4d67e567" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object.assign&lt;/code&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; 方法是ECMAScript 2015（ES6）标准的一部分，可以完全满足您的需求。</target>
        </trans-unit>
        <trans-unit id="32bfe9e918d4b868492fa92e62f1c551337c8c70" translate="yes" xml:space="preserve">
          <source>An elegant way to clone a Javascript object in one line of code</source>
          <target state="translated">在一行代码中克隆一个Javascript对象的优雅方法</target>
        </trans-unit>
        <trans-unit id="896435d8badf2f411e99791401b27e88034dbb6f" translate="yes" xml:space="preserve">
          <source>And keep the methods alive on cloned object.</source>
          <target state="translated">并在克隆对象上保持方法的活力。</target>
        </trans-unit>
        <trans-unit id="a19d0a3bf30a88c3fd9012682cd0067268b19a91" translate="yes" xml:space="preserve">
          <source>And let's have a look at the output...</source>
          <target state="translated">让我们来看看输出......</target>
        </trans-unit>
        <trans-unit id="11f375141a5034d16664f0e54b2f1c0b28910f53" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;strong&gt;nested objects&lt;/strong&gt; are still copied &lt;strong&gt;as a reference.&lt;/strong&gt;</source>
          <target state="translated">请注意， &lt;strong&gt;嵌套对象&lt;/strong&gt;仍将被复制&lt;strong&gt;为参考。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56ecbf1b8827336c51f8306fdb107ae1b4c8f121" translate="yes" xml:space="preserve">
          <source>But be aware that nested objects are still copied as reference.</source>
          <target state="translated">但要注意的是,嵌套对象仍然是作为引用被复制。</target>
        </trans-unit>
        <trans-unit id="44d9c60e7ecbda7adb322596b936906b1dded999" translate="yes" xml:space="preserve">
          <source>But if you using &lt;code&gt;ES5&lt;/code&gt;, you can use few methods, but the &lt;code&gt;JSON.stringify&lt;/code&gt;, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:</source>
          <target state="translated">但是，如果使用 &lt;code&gt;ES5&lt;/code&gt; ，则可以使用几种方法，但是可以使用 &lt;code&gt;JSON.stringify&lt;/code&gt; ，只需确保不使用大量数据进行复制即可，但是在许多情况下，这可能是一种方便的方式，如下所示：</target>
        </trans-unit>
        <trans-unit id="95088399458c196785b80f328382de6f8fa6da7f" translate="yes" xml:space="preserve">
          <source>Don't waste too much time on it, you'll get &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt;.</source>
          <target state="translated">不要浪费太多时间，您会得到 &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d2b7b729fd7dfac409f1f5c4781cdc32d799528" translate="yes" xml:space="preserve">
          <source>ES6 solution if you want to (shallow) clone a &lt;strong&gt;class instance&lt;/strong&gt; and not just a property object.</source>
          <target state="translated">ES6解决方案，如果您想（浅）克隆一个&lt;strong&gt;类实例&lt;/strong&gt; ，而不仅仅是一个属性对象。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="9d4b3583c599fafbba741d166652892841a76ea3" translate="yes" xml:space="preserve">
          <source>Following is the implementation:</source>
          <target state="translated">以下是执行情况:</target>
        </trans-unit>
        <trans-unit id="6dcc05bb82ad169b245a024fa2181e38169796be" translate="yes" xml:space="preserve">
          <source>For &quot;deep&quot; copy, use &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</source>
          <target state="translated">对于&amp;ldquo;深层&amp;rdquo;副本，请使用 &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24a73f09717e6302b4ae5cfc392955d30204cefd" translate="yes" xml:space="preserve">
          <source>For a deep copy and clone, JSON.stringify then JSON.parse the object:</source>
          <target state="translated">对于深度复制和克隆,JSON.stringify,然后JSON.parse对象。</target>
        </trans-unit>
        <trans-unit id="fbe99868375178cc499070d97ef9839eb868985f" translate="yes" xml:space="preserve">
          <source>For browsers / engines that do not currently support Object.create you can use this polyfill:</source>
          <target state="translated">对于目前不支持Object.create的浏览器引擎,你可以使用这个polyfill。</target>
        </trans-unit>
        <trans-unit id="fdfee069d3a9f22467239d1a5c249362ba8bfbc8" translate="yes" xml:space="preserve">
          <source>For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.</source>
          <target state="translated">对于使用AngularJS的人来说,这个库中的对象也有直接的克隆或扩展方法。</target>
        </trans-unit>
        <trans-unit id="bf4ec4c0c298b2a0248ed16c560cae0cb2b2f354" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;How to copy arrays and objects in Javascript&lt;/a&gt; by Brian Huisman:</source>
          <target state="translated">摘自本文：Brian Huisman的《 &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;如何在Javascript中复制数组和对象》&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="73f8555ab7993eb62a7bb80980e5decb72448c9b" translate="yes" xml:space="preserve">
          <source>Here is a function you can use.</source>
          <target state="translated">这里有一个功能,你可以使用。</target>
        </trans-unit>
        <trans-unit id="4631d41b7b36fb799786f4a214099e57e5620b0e" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object</source>
          <target state="translated">如何正确克隆一个JavaScript对象</target>
        </trans-unit>
        <trans-unit id="743e0eea187a855a15b0996e0b65671bfbe4b6c9" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object?</source>
          <target state="translated">如何正确克隆一个JavaScript对象?</target>
        </trans-unit>
        <trans-unit id="001d1eefeee3ed1b4eb51c735f2abbe94cdc6856" translate="yes" xml:space="preserve">
          <source>I have an object, &lt;code&gt;x&lt;/code&gt;. I'd like to copy it as object &lt;code&gt;y&lt;/code&gt;, such that changes to &lt;code&gt;y&lt;/code&gt; do not modify &lt;code&gt;x&lt;/code&gt;. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn't a problem, since I'm copying one of my own literal-constructed objects.</source>
          <target state="translated">我有一个对象 &lt;code&gt;x&lt;/code&gt; 。 我想将其复制为对象 &lt;code&gt;y&lt;/code&gt; ，以使对 &lt;code&gt;y&lt;/code&gt; 的更改不会修改 &lt;code&gt;x&lt;/code&gt; 。 我意识到，复制从内置JavaScript对象派生的对象将导致额外的不需要的属性。 这不是问题，因为我正在复制自己的文字构造对象之一。</target>
        </trans-unit>
        <trans-unit id="6a18864f24ad3607c14646fe8b7ea199e0cfa3b2" translate="yes" xml:space="preserve">
          <source>I just wanted to add to all the &lt;code&gt;Object.create&lt;/code&gt; solutions in this post, that this does not work in the desired way with nodejs.</source>
          <target state="translated">我只是想在这篇文章中添加到所有 &lt;code&gt;Object.create&lt;/code&gt; 解决方案中，以至于Nodejs无法以所需的方式工作。</target>
        </trans-unit>
        <trans-unit id="0e8d9e15a95057e936855612d02338a65a9ae821" translate="yes" xml:space="preserve">
          <source>I think there is a simple and working answer. In deep copying there are two concerns:</source>
          <target state="translated">我认为有一个简单可行的答案。在深度复制中,有两个问题需要关注。</target>
        </trans-unit>
        <trans-unit id="941624dec0eec1e76a1ffed0d1cbb9418daa899a" translate="yes" xml:space="preserve">
          <source>I want to &lt;strong&gt;deep-copy&lt;/strong&gt; a Javascript &lt;code&gt;Object&lt;/code&gt; with all of its children and their children and so on. But since I'm not kind of a normal developer, my &lt;code&gt;Object&lt;/code&gt; has &lt;em&gt;normal&lt;/em&gt;&lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and even &lt;code&gt;nested objects&lt;/code&gt;.</source>
          <target state="translated">我想&lt;strong&gt;复制&lt;/strong&gt;一个Javascript &lt;code&gt;Object&lt;/code&gt; 及其所有子对象及其子对象 ，依此类推。 但是由于我不是普通的开发人员，所以我的 &lt;code&gt;Object&lt;/code&gt; 具有&lt;em&gt;正常的&lt;/em&gt; &lt;code&gt;properties&lt;/code&gt; ， &lt;code&gt;circular structures&lt;/code&gt; 甚至 &lt;code&gt;nested objects&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="492eceb4047550ce310e991adf6cd7624ed3faaa" translate="yes" xml:space="preserve">
          <source>I've put &lt;code&gt;F&lt;/code&gt; outside the scope so we can have a look at what &lt;code&gt;instanceof&lt;/code&gt; tells us.</source>
          <target state="translated">我将 &lt;code&gt;F&lt;/code&gt; 放在范围之外，因此我们可以看看 &lt;code&gt;instanceof&lt;/code&gt; 告诉我们什么。</target>
        </trans-unit>
        <trans-unit id="a429ab5caa7c00e09548791ed612fdfcc5894e19" translate="yes" xml:space="preserve">
          <source>I've written my own implementation. Not sure if it counts as a better solution:</source>
          <target state="translated">我自己写了一个实施方案。不知道这算不算是一个比较好的解决方案。</target>
        </trans-unit>
        <trans-unit id="dafdc35a46a4c2d0195d973a1d3318e6698831c0" translate="yes" xml:space="preserve">
          <source>If the object is XML DOM element, we must use &lt;strong&gt;cloneNode&lt;/strong&gt; instead</source>
          <target state="translated">如果对象是XML DOM元素，则必须改用&lt;strong&gt;cloneNode&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae8354bc788c660711b68a4fa1e2850f3185cab9" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, undefined, regExp or Infinity within your object, a very simple one liner is &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt;:</source>
          <target state="translated">如果您在对象内未使用 &lt;code&gt;Date&lt;/code&gt; ，函数，未定义，regExp或Infinity，则一个非常简单的衬里是 &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bfd3f2d16bba73dae97290f3a239238665ccfc4c" translate="yes" xml:space="preserve">
          <source>If you want shallow copy, use &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</source>
          <target state="translated">如果要浅拷贝，请使用 &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253989d793a4111415e3d9230d7ab2071f59e3ac" translate="yes" xml:space="preserve">
          <source>If you're okay with a shallow copy, the underscore.js library has a &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">如果您可以使用浅表副本，那么underscore.js库提供了一个&lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4bf6911de6ff08405b3d088604f2d3601613b4cb" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2018</source>
          <target state="translated">在ECMAScript 2018中</target>
        </trans-unit>
        <trans-unit id="1defc59fd72a11aff1734e0a2e2a22f0a4abab4d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 6 there is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method, which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">在ECMAScript 6中，存在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt;方法，该方法将所有可枚举的自身属性的值从一个对象复制到另一个对象。 例如：</target>
        </trans-unit>
        <trans-unit id="f304990021e58b1d1ff5e13fb83eed4bf99dd0d2" translate="yes" xml:space="preserve">
          <source>In ES-6 you can simply use Object.assign(...).
Ex:</source>
          <target state="translated">在ES-6中,你可以简单地使用Object.assign(...)。例如。</target>
        </trans-unit>
        <trans-unit id="2c92ac88d5767f5e56ba7636924db58532bd9c70" translate="yes" xml:space="preserve">
          <source>In Firefox the result of</source>
          <target state="translated">在Firefox中的结果是</target>
        </trans-unit>
        <trans-unit id="3c2ea368e40e7bb729de18cbee756fb95f6ea1f5" translate="yes" xml:space="preserve">
          <source>In addition to non-enumerable attributes, you'll encounter a tougher problem when you try to copy objects that have hidden properties. For example, &lt;code&gt;prototype&lt;/code&gt; is a hidden property of a function. Also, an object's prototype is referenced with the attribute &lt;code&gt;__proto__&lt;/code&gt;, which is also hidden, and will not be copied by a for/in loop iterating over the source object's attributes. I think &lt;code&gt;__proto__&lt;/code&gt; might be specific to Firefox's JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don't know of any way to discover it automatically.</source>
          <target state="translated">除了不可枚举的属性外，当您尝试复制具有隐藏属性的对象时，还会遇到更棘手的问题。 例如， &lt;code&gt;prototype&lt;/code&gt; 是函数的隐藏属性。 而且，对象的原型使用属性 &lt;code&gt;__proto__&lt;/code&gt; 引用，该属性也被隐藏，并且不会通过在源对象的属性上进行迭代的for / in循环进行复制。 我认为 &lt;code&gt;__proto__&lt;/code&gt; 可能特定于Firefox的JavaScript解释器，并且在其他浏览器中可能有所不同，但是您可以理解。 并不是所有的东西都可以枚举。 如果知道隐藏属性的名称，则可以复制它，但是我不知道有什么方法可以自动发现它。</target>
        </trans-unit>
        <trans-unit id="af3b62758b3b5aad9f8bb2a67a63a6b1276c2744" translate="yes" xml:space="preserve">
          <source>In nodejs it is</source>
          <target state="translated">在nodejs中,它是</target>
        </trans-unit>
        <trans-unit id="8070d65a107f7a0001017aa494dfb78ff6d01341" translate="yes" xml:space="preserve">
          <source>Inspired by A.Levy's exhaustive study and Calvin's prototyping approach, I offer this solution:</source>
          <target state="translated">受A.Levy的详尽研究和Calvin的原型设计方法的启发,我提供了这个解决方案。</target>
        </trans-unit>
        <trans-unit id="9bfe4aadd640d727c541e4a74de4c537bf9603c9" translate="yes" xml:space="preserve">
          <source>Interested in cloning simple objects:</source>
          <target state="translated">对简单物体的克隆感兴趣。</target>
        </trans-unit>
        <trans-unit id="06837f1236b49354891013f198510b9ba4fc2ab5" translate="yes" xml:space="preserve">
          <source>It will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don't assume that it will just work for anything you throw at it.</source>
          <target state="translated">它将无法处理任何JavaScript对象,但只要你不认为它只是对你扔给它的任何东西都能正常工作,它可能就足够了。</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c5f79a04d00332bcef73e7c25ac76cc77265d5d3" translate="yes" xml:space="preserve">
          <source>JavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:</source>
          <target state="translated">实际上JavaScript原生不支持深度克隆。使用一个实用函数。比如说Ramda。</target>
        </trans-unit>
        <trans-unit id="6c8086021c6a372b4809189f81b1a61b9f2eeea4" translate="yes" xml:space="preserve">
          <source>JavaScript keeps evolving.</source>
          <target state="translated">JavaScript不断发展。</target>
        </trans-unit>
        <trans-unit id="898c396720398ab086b937719a5cb546261e8435" translate="yes" xml:space="preserve">
          <source>Keep properties independent to each other.</source>
          <target state="translated">保持属性之间相互独立。</target>
        </trans-unit>
        <trans-unit id="f9cd6e333924ef28d1cf1cb192e551179543718e" translate="yes" xml:space="preserve">
          <source>Let's bring everything together in an &lt;code&gt;Object&lt;/code&gt; named &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">让我们将所有内容汇总到一个名为 &lt;code&gt;a&lt;/code&gt; 的 &lt;code&gt;Object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8aaf1df286d5ef5e319286978f2d4a622c5dd52" translate="yes" xml:space="preserve">
          <source>Let's have a look at the accepted answer.</source>
          <target state="translated">我们来看看公认的答案。</target>
        </trans-unit>
        <trans-unit id="3440d2c76fb94711deb530c695895ec6080f7195" translate="yes" xml:space="preserve">
          <source>Looks good, heh? It's a recursive copy of the object and handles other types as well, like &lt;code&gt;Date&lt;/code&gt;, but that wasn't a requirement.</source>
          <target state="translated">看起来不错吧？ 它是对象的递归副本，还可以处理其他类型，例如 &lt;code&gt;Date&lt;/code&gt; ，但这不是必需的。</target>
        </trans-unit>
        <trans-unit id="4401b855280cd9542719b7c0ccaf34205cee9587" translate="yes" xml:space="preserve">
          <source>More in angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;documentation&lt;/a&gt;...</source>
          <target state="translated">更多angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;文档&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="dade8dcd2b43a64b756eff141607bc6874a514ce" translate="yes" xml:space="preserve">
          <source>New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt;, it's easy.</source>
          <target state="translated">旧问题的新答案！ 如果您高兴地将ECMAScript 2016（ES6）与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax一起使用&lt;/a&gt; ，这很容易。</target>
        </trans-unit>
        <trans-unit id="13e3b18e3972aab20fc4c36853cd1d0b35875d96" translate="yes" xml:space="preserve">
          <source>Next, we want to copy &lt;code&gt;a&lt;/code&gt; into a variable named &lt;code&gt;b&lt;/code&gt; and mutate it.</source>
          <target state="translated">接下来，我们要将 &lt;code&gt;a&lt;/code&gt; 复制到名为 &lt;code&gt;b&lt;/code&gt; 的变量中并对其进行突变。</target>
        </trans-unit>
        <trans-unit id="dc14249af7e109f4fde91ed60eb8e84255d155bd" translate="yes" xml:space="preserve">
          <source>Now let's find a solution.</source>
          <target state="translated">现在,让我们来想办法解决。</target>
        </trans-unit>
        <trans-unit id="4d1dae1e39568ce239fd2a7fc3a8cf3c550df25c" translate="yes" xml:space="preserve">
          <source>Of course, functions do not belong in JSON, so this only works for objects without member methods.</source>
          <target state="translated">当然,函数不属于JSON,所以这只对没有成员方法的对象有效。</target>
        </trans-unit>
        <trans-unit id="2366061f7e9ccde0f6899dd5905d19be0299833f" translate="yes" xml:space="preserve">
          <source>One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.</source>
          <target state="translated">一个特别不靠谱的解决方案是使用JSON编码来对没有成员方法的对象进行深度复制。其方法是将目标对象进行JSON编码,然后通过解码,得到你要找的副本。你可以根据自己的需要,进行多少次解码,就可以制作多少个副本。</target>
        </trans-unit>
        <trans-unit id="b5e7cf65ae4060f78ce8aa1b4ed6c66bf3442b4e" translate="yes" xml:space="preserve">
          <source>Or to make a &lt;strong&gt;deep copy&lt;/strong&gt;:</source>
          <target state="translated">或进行&lt;strong&gt;深复制&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="c5035e794e31882d47ef1d6b8595571334a62a63" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">每个&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">阅读更多.....</target>
        </trans-unit>
        <trans-unit id="b70d8b981e5c20ee4900b1d547ab578ea9f8c800" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;code&gt;circular structures&lt;/code&gt; doesn't work well together... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</source>
          <target state="translated">递归和 &lt;code&gt;circular structures&lt;/code&gt; 不能很好地协同工作... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f0db5294c0b0127ed78e8534a588a4da9a4ea8" translate="yes" xml:space="preserve">
          <source>Recursive copy &lt;em&gt;(the accepted &quot;answer&quot;)&lt;/em&gt;</source>
          <target state="translated">递归副本&lt;em&gt;（可接受的&amp;ldquo;答案&amp;rdquo;）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461c16fdd9cf991abb778545c3d4ab00c017168c" translate="yes" xml:space="preserve">
          <source>Same problem as the &lt;em&gt;native solution&lt;/em&gt;, but a little bit worse output.</source>
          <target state="translated">与本&lt;em&gt;机解决方案&lt;/em&gt;相同的问题，但输出会差一些。</target>
        </trans-unit>
        <trans-unit id="796baa07c71d736d03895eacc42e11d3d30a4b20" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;this article about the structured clone algorithm of browsers&lt;/a&gt; which is used when posting messages to and from a worker. It also contains a function for deep cloning.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;本文有关浏览器的结构化克隆算法的文章，该算法&lt;/a&gt;在与工作人员之间发布消息时使用。 它还包含用于深度克隆的功能。</target>
        </trans-unit>
        <trans-unit id="b3ee3c57fb439d18c03172ee7afacf0e99f6105f" translate="yes" xml:space="preserve">
          <source>See also Andy Burke's note in the answers.</source>
          <target state="translated">另见答案中的安迪-伯克的注释。</target>
        </trans-unit>
        <trans-unit id="454f14f00bca91bc2a843967363a76e24887bba3" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; stated that the object to be cloned is a 'literal-constructed' object, a solution might be to simply &lt;em&gt;generate&lt;/em&gt; the object multiple times rather than cloning an instance of the object:</source>
          <target state="translated">由于&lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt;指出要克隆的对象是&amp;ldquo;文字构造的&amp;rdquo;对象，因此一种解决方案可能是简单地多次&lt;em&gt;生成&lt;/em&gt;该对象，而不是克隆该对象的实例：</target>
        </trans-unit>
        <trans-unit id="7073615569ad59804a8d64877706cc2ee7c1a1ec" translate="yes" xml:space="preserve">
          <source>So I think one simple solution will be to first serialize and deserialize and then do an assign on it to copy functions too.</source>
          <target state="translated">所以我认为一个简单的解决方案就是先进行序列化和反序列化,然后在上面做一个assign,把函数也复制过来。</target>
        </trans-unit>
        <trans-unit id="b77e5c1be59f320b6042fdf12c140f63ab1a4003" translate="yes" xml:space="preserve">
          <source>So let's create a &lt;code&gt;circular structure&lt;/code&gt; and a &lt;code&gt;nested object&lt;/code&gt; first.</source>
          <target state="translated">因此，让我们首先创建一个 &lt;code&gt;circular structure&lt;/code&gt; 和一个 &lt;code&gt;nested object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1e5d5e7a575e6d613efa42edbbd2bd59577f137" translate="yes" xml:space="preserve">
          <source>Some quick tests</source>
          <target state="translated">一些快速测试</target>
        </trans-unit>
        <trans-unit id="1ad81ed3b31b89f94fdfb8b814a7b408c0ce4ac4" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;How to copy JavaScript object to new variable NOT by reference?&lt;/a&gt;</source>
          <target state="translated">源： &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;如何不通过引用将JavaScript对象复制到新变量？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">支持旧版浏览器的&lt;strong&gt;polyfill&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">Object.assign()方法用于将一个或多个源对象中的所有可枚举的自身属性的值复制到目标对象中。</target>
        </trans-unit>
        <trans-unit id="8a4308022632fbf96a189f60d4c089e47657082a" translate="yes" xml:space="preserve">
          <source>The above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn't more than one reference to the same data in the object. For example:</source>
          <target state="translated">只要对象和数组中的数据形成一个树状结构,上述函数就能充分满足我提到的6种简单类型的要求。也就是说,在对象中对同一数据的引用不超过一个。举例来说</target>
        </trans-unit>
        <trans-unit id="032b503078d9391f3f083e20a6246421123e2d8b" translate="yes" xml:space="preserve">
          <source>The date string for &lt;code&gt;d1&lt;/code&gt; will be 5 seconds behind that of &lt;code&gt;d2&lt;/code&gt;. A way to make one &lt;code&gt;Date&lt;/code&gt; the same as another is by calling the &lt;code&gt;setTime&lt;/code&gt; method, but that is specific to the &lt;code&gt;Date&lt;/code&gt; class. I don't think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!</source>
          <target state="translated">&lt;code&gt;d1&lt;/code&gt; 的日期字符串将比 &lt;code&gt;d2&lt;/code&gt; 的日期字符串晚5秒。 使一个 &lt;code&gt;Date&lt;/code&gt; 与另一个Date相同的方法是调用 &lt;code&gt;setTime&lt;/code&gt; 方法，但这特定于 &lt;code&gt;Date&lt;/code&gt; 类。 我不认为该问题有防弹的一般解决方案，尽管我很高兴会犯错！</target>
        </trans-unit>
        <trans-unit id="043746030e244c05064aabe5e6c53eb1b00a3576" translate="yes" xml:space="preserve">
          <source>The first attempt I tried was using &lt;code&gt;JSON&lt;/code&gt;.</source>
          <target state="translated">我尝试的第一次尝试是使用 &lt;code&gt;JSON&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f000a225c9b05dc90c944d0aaba92c15349755d" translate="yes" xml:space="preserve">
          <source>The last solution using recursion and a cache, may not be the best, but it's a &lt;strong&gt;real&lt;/strong&gt; deep-copy of the object. It handles simple &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and &lt;code&gt;nested object&lt;/code&gt;, but it will mess up the instance of them while cloning.</source>
          <target state="translated">最后一种使用递归和缓存的解决方案可能不是最好的，但它是对象的&lt;strong&gt;真正的&lt;/strong&gt;深层复制。 它处理简单的 &lt;code&gt;properties&lt;/code&gt; ， &lt;code&gt;circular structures&lt;/code&gt; 和 &lt;code&gt;nested object&lt;/code&gt; ，但在克隆时会弄乱它们的实例。</target>
        </trans-unit>
        <trans-unit id="d2e920fb16fae1fedca17a36ec3baa9202cbb72d" translate="yes" xml:space="preserve">
          <source>The requirements are matched, but there are still some smaller issues, including changing the &lt;code&gt;instance&lt;/code&gt; of &lt;code&gt;nested&lt;/code&gt; and &lt;code&gt;circ&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">满足了这些要求，但是仍然存在一些较小的问题，包括将 &lt;code&gt;nested&lt;/code&gt; 和 &lt;code&gt;circ&lt;/code&gt; 的 &lt;code&gt;instance&lt;/code&gt; 更改为 &lt;code&gt;Object&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29a4e57a808e70c1984cd4b7435f7b3b8f879529" translate="yes" xml:space="preserve">
          <source>The structure of trees that share a leaf won't be copied, they will become two independent leaves:</source>
          <target state="translated">共享一片叶子的树的结构不会被复制,它们会变成两片独立的叶子。</target>
        </trans-unit>
        <trans-unit id="13a953842279c7fd9c49eb420b7ea3060cfc3c9f" translate="yes" xml:space="preserve">
          <source>There are many answers, but none that mentions &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.</source>
          <target state="translated">有很多答案，但是没有一个提到ECMAScript 5中的&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; ，它当然不能提供确切的副本，但是会将源设置为新对象的原型。</target>
        </trans-unit>
        <trans-unit id="cc7af0c92f6e6c0d9df4aaa342be3e26c98b8b64" translate="yes" xml:space="preserve">
          <source>There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn't be accepted.</source>
          <target state="translated">网络上大多数的解决方案都有几个问题。所以我决定做一个跟踪,内容包括,为什么不应该接受的答案。</target>
        </trans-unit>
        <trans-unit id="2138887f9e1a5984c4ac16aa3859fe4f272a050d" translate="yes" xml:space="preserve">
          <source>There is no need for external libraries but you need to check &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;browser compatibility first&lt;/a&gt;.</source>
          <target state="translated">不需要外部库，但您需要首先检查&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;浏览器的兼容性&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6df6c28aa1c494acefc67b48ca65405704b89a2" translate="yes" xml:space="preserve">
          <source>There's a polyfill for &lt;code&gt;Object.create&lt;/code&gt; in the older browser just like the IE 8. It's something like recommended by Mozilla, and of course, it's not perfect and results in the same problem as the &lt;em&gt;native solution&lt;/em&gt;.</source>
          <target state="translated">就像IE 8一样，在较旧的浏览器中还有一个针对 &lt;code&gt;Object.create&lt;/code&gt; 的polyfill。这有点像Mozilla的建议，当然，它并不完美，并且会导致与&lt;em&gt;本地解决方案&lt;/em&gt;相同的问题。</target>
        </trans-unit>
        <trans-unit id="257b97895de4343bd020da12619838edee113900" translate="yes" xml:space="preserve">
          <source>This is an adaptation of A. Levy's code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)</source>
          <target state="translated">这是对A.Levy代码的改编,也可以处理函数的克隆和多环引用--这意味着如果被克隆的对象树中的两个属性是同一个对象的引用,那么被克隆的对象树就会有这些属性指向同一个被引用对象的同一个克隆。这也解决了循环依赖的情况,如果不处理,会导致无限循环。该算法的复杂度为O(n)</target>
        </trans-unit>
        <trans-unit id="3aeab4233dd61158490346563a83710fdb174f9f" translate="yes" xml:space="preserve">
          <source>This methodology was perfect for my use case, since I'm storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.</source>
          <target state="translated">这种方法对于我的用例来说是完美的,因为我将JSON blobs存储在一个键值存储中,当它们作为对象在JavaScript API中暴露出来时,每个对象实际上都包含了对象的原始状态的副本,所以我们可以在调用者对暴露的对象进行突变后计算delta。</target>
        </trans-unit>
        <trans-unit id="270c07e5aba6d333e589186ebce926ac9488ae45" translate="yes" xml:space="preserve">
          <source>This provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.</source>
          <target state="translated">这为一个对象的浅层复制提供了一个干净的方法。制作一个深度复制,即对每个递归嵌套对象中的每一个值进行一个新的复制,这就需要用上面较重的方法来解决。</target>
        </trans-unit>
        <trans-unit id="c3d98944d47265d765fc5c22fd2d0a49ddc89117" translate="yes" xml:space="preserve">
          <source>This solution was added to Javascript some time ago and even handles &lt;code&gt;circular structure&lt;/code&gt;.</source>
          <target state="translated">该解决方案是在一段时间之前添加到Javascript的，甚至可以处理 &lt;code&gt;circular structure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d709893b9322713175a8239aabd951c8aa101e46" translate="yes" xml:space="preserve">
          <source>This works for all kind of objects containing objects, arrays, strings, booleans and numbers.</source>
          <target state="translated">这适用于所有类型的对象,包括对象、数组、字符串、布尔和数字。</target>
        </trans-unit>
        <trans-unit id="be7e283523bee098c95fbd259fdb185444007880" translate="yes" xml:space="preserve">
          <source>Thus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:</source>
          <target state="translated">因此,这并不是一个确切的答案,但它是单行的解决方案,因此很优雅。而且它最适合2种情况。</target>
        </trans-unit>
        <trans-unit id="b36783ae8f97bf075d43eb8bdee3e68cae031c5d" translate="yes" xml:space="preserve">
          <source>To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object's prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a &lt;code&gt;clone&lt;/code&gt; method to &lt;code&gt;Object.prototype&lt;/code&gt;, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to &lt;code&gt;Object.prototype&lt;/code&gt;, or other intermediate prototypes, that you don't know about? In that case, you will copy attributes you shouldn't, so you need to detect unforeseen, non-local attributes with the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">在JavaScript中对任何对象执行此操作都不是简单或直接的。 您将遇到错误地从对象的原型中获取应该留在原型中而不应复制到新实例的属性的问题。 例如，如果要向 &lt;code&gt;Object.prototype&lt;/code&gt; 添加一个 &lt;code&gt;clone&lt;/code&gt; 方法（如某些答案所示），则需要显式跳过该属性。 但是，如果还有其他您不知道的其他方法添加到 &lt;code&gt;Object.prototype&lt;/code&gt; 或其他中间原型，该怎么办？ 在这种情况下，您将复制不应复制的属性，因此需要使用&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;hasOwnProperty&lt;/code&gt; &lt;/a&gt;方法检测无法预见的非本地属性。</target>
        </trans-unit>
        <trans-unit id="a913fb7183b6fb881c9a823ab39998ee4aa93f87" translate="yes" xml:space="preserve">
          <source>Using Lodash:</source>
          <target state="translated">使用Lodash。</target>
        </trans-unit>
        <trans-unit id="ca5a4f97de6e6ecec887d15f3ba764fe9304dac1" translate="yes" xml:space="preserve">
          <source>When I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; would also be one of the 6 simple types in that list. This can be accomplished with code like the following:</source>
          <target state="translated">当我不得不实现常规的深层复制时，我以只需要复制一个简单的 &lt;code&gt;Object&lt;/code&gt; ， &lt;code&gt;Array&lt;/code&gt; ， &lt;code&gt;Date&lt;/code&gt; ， &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;Number&lt;/code&gt; 或 &lt;code&gt;Boolean&lt;/code&gt; 的方式来妥协。 后三种类型是不可变的，因此我可以执行浅表复制，而不必担心它会更改。 我进一步假设 &lt;code&gt;Object&lt;/code&gt; 或 &lt;code&gt;Array&lt;/code&gt; 包含的任何元素也将是该列表中6个简单类型之一。 这可以通过如下代码完成：</target>
        </trans-unit>
        <trans-unit id="456e0fb41b68296ae4fca0c5da8c6c8c99b050d9" translate="yes" xml:space="preserve">
          <source>When digging around, I found a similar question (&lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;In Javascript, when performing a deep copy, how do I avoid a cycle, due to a property being &quot;this&quot;?&lt;/a&gt;) to this one, but with a way better solution.</source>
          <target state="translated">进行深入研究时，我发现了与此问题类似的问题（ &lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;在Javascript中，当执行深度复制时，由于属性为&amp;ldquo; this&amp;rdquo;，如何避免循环？&lt;/a&gt; ），但有一个更好的解决方案。</target>
        </trans-unit>
        <trans-unit id="a9252c930b2a9734d9944f251662812bcd0d5878" translate="yes" xml:space="preserve">
          <source>Where such inheritance is useful (duh!)</source>
          <target state="translated">在这种继承是有用的地方(duh!)</target>
        </trans-unit>
        <trans-unit id="f3f6684c458c70cb9d8e7a984298d711252184ac" translate="yes" xml:space="preserve">
          <source>Where the source object won't be modified, thus making the relation between the 2 objects a non issue.</source>
          <target state="translated">其中源对象不会被修改,从而使2个对象之间的关系成为非问题。</target>
        </trans-unit>
        <trans-unit id="2735aa18f20ac2191686e23824f2e5be39288c5c" translate="yes" xml:space="preserve">
          <source>Why do I consider this solution to be superior? It's native, thus no looping, no recursion. However, older browsers will need a polyfill.</source>
          <target state="translated">为什么我认为这个方案更优越?它是原生的,因此没有循环,没有递归。但是,老的浏览器会需要一个polyfill。</target>
        </trans-unit>
        <trans-unit id="c4313b8450309f35ea2494e7d2513a055de02aeb" translate="yes" xml:space="preserve">
          <source>With jQuery, you can &lt;strong&gt;shallow copy&lt;/strong&gt; with &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;:</source>
          <target state="translated">使用jQuery，您可以使用&lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;进行&lt;strong&gt;浅表复制&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="dc955433235b02b7f40b76eb1d7dfddf892c4a6e" translate="yes" xml:space="preserve">
          <source>Yet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object's prototype is &lt;code&gt;Object&lt;/code&gt;, then simply creating a new general object with &lt;code&gt;{}&lt;/code&gt; will work, but if the source's prototype is some descendant of &lt;code&gt;Object&lt;/code&gt;, then you are going to be missing the additional members from that prototype which you skipped using the &lt;code&gt;hasOwnProperty&lt;/code&gt; filter, or which were in the prototype, but weren't enumerable in the first place. One solution might be to call the source object's &lt;code&gt;constructor&lt;/code&gt; property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object stores its data as a hidden member:</source>
          <target state="translated">寻求优雅解决方案的另一个障碍是正确设置原型继承的问题。 如果源对象的原型是 &lt;code&gt;Object&lt;/code&gt; ，那么只需使用 &lt;code&gt;{}&lt;/code&gt; 创建一个新的通用对象即可，但是如果源对象的原型是Object的某个后代，那么您将丢失该原型中使用跳过的其他成员。 &lt;code&gt;hasOwnProperty&lt;/code&gt; 过滤器，或者在原型中，但是首先不能枚举。 一种解决方案可能是调用源对象的 &lt;code&gt;constructor&lt;/code&gt; 属性来获取初始复制对象，然后在属性上进行复制，但是这样您仍然不会获得不可枚举的属性。 例如， &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;对象将其数据存储为隐藏成员：</target>
        </trans-unit>
        <trans-unit id="f6ada691f9c830b134d1063e166e1d147221dcb3" translate="yes" xml:space="preserve">
          <source>You can clone an object and remove any reference from the previous one using a single line of code. Simply do:</source>
          <target state="translated">你可以用一行代码克隆一个对象并删除前一个对象的任何引用。只需这样做。</target>
        </trans-unit>
        <trans-unit id="2fb59e1d6040b949307491685dc51fd64aac4887" translate="yes" xml:space="preserve">
          <source>You can simply use a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;spread property&lt;/a&gt; to copy an object without references. But be careful (see comments), the 'copy' is just on the lowest object/array level. Nested properties are still references!</source>
          <target state="translated">您可以简单地使用&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;传播属性&lt;/a&gt;复制没有引用的对象。 但是要小心（请参阅注释），&amp;ldquo;副本&amp;rdquo;仅位于最低的对象/数组级别。 嵌套属性仍然是参考！</target>
        </trans-unit>
        <trans-unit id="9abb2632977048faaf1083e1bdfe1addfa67decb" translate="yes" xml:space="preserve">
          <source>You know what happened here because if not you wouldn't even land on this great question.</source>
          <target state="translated">你知道这里发生了什么事,因为如果不知道的话,你甚至不会在这个伟大的问题上落地。</target>
        </trans-unit>
        <trans-unit id="6a38a38f03e4ff5839ba4a879178cce5bc42666b" translate="yes" xml:space="preserve">
          <source>conclusion</source>
          <target state="translated">conclusion</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="716e96afcc9beb903225a881db7f167667cc2eb3" translate="yes" xml:space="preserve">
          <source>jsfiddle</source>
          <target state="translated">jsfiddle</target>
        </trans-unit>
        <trans-unit id="352f260ed32601f2720cbdef8b42f9882a4102af" translate="yes" xml:space="preserve">
          <source>native solution</source>
          <target state="translated">原生解决方案</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="c5b130d2294080fe3f54b6ede9cb6c33d3a49d6b" translate="yes" xml:space="preserve">
          <source>or using spread operator like this:</source>
          <target state="translated">或使用像这样的差分运算器。</target>
        </trans-unit>
        <trans-unit id="82ae245159e159776ea37d68d57ddfa387a83600" translate="yes" xml:space="preserve">
          <source>or you can extend it like</source>
          <target state="translated">或者你可以像</target>
        </trans-unit>
        <trans-unit id="3e0bf88b357a046b4e7659fed6103de63a9734cd" translate="yes" xml:space="preserve">
          <source>polyfill for the native solution</source>
          <target state="translated">原生溶液用的聚能填充物</target>
        </trans-unit>
        <trans-unit id="55d9bbd3efbab583726fcd7c3ad976b8129b76ee" translate="yes" xml:space="preserve">
          <source>starting situation</source>
          <target state="translated">开局</target>
        </trans-unit>
        <trans-unit id="a5f7a257ae51fb7db8f01b3b457418d96c6a2a00" translate="yes" xml:space="preserve">
          <source>subsequent changes to the &lt;code&gt;copiedObject&lt;/code&gt; will not affect the &lt;code&gt;originalObject&lt;/code&gt;, and vice versa.</source>
          <target state="translated">随后对 &lt;code&gt;copiedObject&lt;/code&gt; 更改将不会影响 &lt;code&gt;originalObject&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="2ba1210fdf174274ea55c483bb6ade889c52e126" translate="yes" xml:space="preserve">
          <source>the answer is mainly depeneds on which &lt;strong&gt;ECMAscript&lt;/strong&gt; you using, in &lt;code&gt;ES6+&lt;/code&gt;, you can simply use &lt;code&gt;Object.assign&lt;/code&gt; to do the clone:</source>
          <target state="translated">答案主要取决于您使用的&lt;strong&gt;ECMAscript&lt;/strong&gt; ，在 &lt;code&gt;ES6+&lt;/code&gt; ，您可以简单地使用 &lt;code&gt;Object.assign&lt;/code&gt; 进行克隆：</target>
        </trans-unit>
        <trans-unit id="522547b9c4325ca856f8c4192d0ad23de9c33613" translate="yes" xml:space="preserve">
          <source>the better (but not perfect) solution</source>
          <target state="translated">较好(但不完美)的解决方案</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
