<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/728360">
    <body>
      <group id="728360">
        <trans-unit id="5fff870d002057a570c5f54f6e0583f072249e21" translate="yes" xml:space="preserve">
          <source>... and you see, it didn't work with the nested structure inside.</source>
          <target state="translated">... 내부 중첩 구조에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdf1515d42ec5590b0b9470e710e5a34edb33d3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="f8d42eb23fc0b5363fad3b52a8388240db181867" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clone with references on second level:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;두 번째 수준에서 참조가있는 복제 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cea8c7ca59555849767060049632be16cd783d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete clone:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;완전한 클론 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6966d0f501ab4b788d3ea14f276d58f9c181e993" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; imagine you have this object below and you want to clone it:</source>
          <target state="translated">&lt;strong&gt;자,&lt;/strong&gt; 아래에이 객체가 있고 그것을 복제하려고한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="22efe12cc8badd5b62cb63cbb32d48a03bfc69b9" translate="yes" xml:space="preserve">
          <source>A good reference is here:
&lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31e2fbcb0256c7808f1ca3a03007c73a654f8c07" translate="yes" xml:space="preserve">
          <source>A.Levy's answer is almost complete, here is my little contribution: &lt;strong&gt;there is a way how to handle recursive references&lt;/strong&gt;, see this line</source>
          <target state="translated">A. Levy의 대답은 거의 완벽합니다. 여기에 약간의 기여 &lt;strong&gt;가 있습니다. 재귀 참조를 처리하는 방법&lt;/strong&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75589da17d1b2a78b18aaddcd6a610f24da00c24" translate="yes" xml:space="preserve">
          <source>After arguing with my co-worker, my boss asked us what happened, and he found a simple &lt;em&gt;solution&lt;/em&gt; after some googling. It's called &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">내 동료와 말다툼을 한 후, 상사는 우리에게 무슨 일이 있었는지 물었고, 인터넷 검색 후 간단한 &lt;em&gt;해결책&lt;/em&gt; 을 찾았습니다. &lt;code&gt;Object.create&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="ba29de559b1bb261e25a1d12df67e7d242566aa7" translate="yes" xml:space="preserve">
          <source>Although this question has many answers, I hope this one helps too.</source>
          <target state="translated">이 질문에 많은 답변이 있지만이 질문에도 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="af28336e40dc39e63a92abf858f8c6ab4d67e567" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object.assign&lt;/code&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; 메서드는 ECMAScript 2015 (ES6) 표준의 일부이며 필요한 것을 정확하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="32bfe9e918d4b868492fa92e62f1c551337c8c70" translate="yes" xml:space="preserve">
          <source>An elegant way to clone a Javascript object in one line of code</source>
          <target state="translated">한 줄의 코드로 Javascript 객체를 복제하는 우아한 방법</target>
        </trans-unit>
        <trans-unit id="896435d8badf2f411e99791401b27e88034dbb6f" translate="yes" xml:space="preserve">
          <source>And keep the methods alive on cloned object.</source>
          <target state="translated">그리고 복제 된 객체에 메소드를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="a19d0a3bf30a88c3fd9012682cd0067268b19a91" translate="yes" xml:space="preserve">
          <source>And let's have a look at the output...</source>
          <target state="translated">그리고 출력을 보자 ...</target>
        </trans-unit>
        <trans-unit id="11f375141a5034d16664f0e54b2f1c0b28910f53" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;strong&gt;nested objects&lt;/strong&gt; are still copied &lt;strong&gt;as a reference.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중첩 된 객체&lt;/strong&gt; 는 여전히 &lt;strong&gt;참조로&lt;/strong&gt; 복사 &lt;strong&gt;됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56ecbf1b8827336c51f8306fdb107ae1b4c8f121" translate="yes" xml:space="preserve">
          <source>But be aware that nested objects are still copied as reference.</source>
          <target state="translated">그러나 중첩 된 개체는 여전히 참조로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="44d9c60e7ecbda7adb322596b936906b1dded999" translate="yes" xml:space="preserve">
          <source>But if you using &lt;code&gt;ES5&lt;/code&gt;, you can use few methods, but the &lt;code&gt;JSON.stringify&lt;/code&gt;, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:</source>
          <target state="translated">그러나 &lt;code&gt;ES5&lt;/code&gt; 를 사용하는 경우 몇 가지 방법을 사용할 수 있지만 &lt;code&gt;JSON.stringify&lt;/code&gt; 는 많은 양의 데이터를 복사하는 데 사용하지 않아야하지만 많은 경우 한 줄 편리한 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95088399458c196785b80f328382de6f8fa6da7f" translate="yes" xml:space="preserve">
          <source>Don't waste too much time on it, you'll get &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt;.</source>
          <target state="translated">너무 많은 시간을 낭비하지 않으면 &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9d2b7b729fd7dfac409f1f5c4781cdc32d799528" translate="yes" xml:space="preserve">
          <source>ES6 solution if you want to (shallow) clone a &lt;strong&gt;class instance&lt;/strong&gt; and not just a property object.</source>
          <target state="translated">속성 객체뿐만 아니라 &lt;strong&gt;클래스 인스턴스&lt;/strong&gt; 를 (얕게) 복제하려는 경우 ES6 솔루션.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="9d4b3583c599fafbba741d166652892841a76ea3" translate="yes" xml:space="preserve">
          <source>Following is the implementation:</source>
          <target state="translated">다음은 구현입니다.</target>
        </trans-unit>
        <trans-unit id="6dcc05bb82ad169b245a024fa2181e38169796be" translate="yes" xml:space="preserve">
          <source>For &quot;deep&quot; copy, use &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</source>
          <target state="translated">&quot;심층&quot;복사의 경우 &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24a73f09717e6302b4ae5cfc392955d30204cefd" translate="yes" xml:space="preserve">
          <source>For a deep copy and clone, JSON.stringify then JSON.parse the object:</source>
          <target state="translated">딥 카피 및 복제의 경우 JSON.stringify를 선택한 다음 JSON.parse 객체를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="fbe99868375178cc499070d97ef9839eb868985f" translate="yes" xml:space="preserve">
          <source>For browsers / engines that do not currently support Object.create you can use this polyfill:</source>
          <target state="translated">현재 Object.create를 지원하지 않는 브라우저 / 엔진의 경우이 polyfill을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdfee069d3a9f22467239d1a5c249362ba8bfbc8" translate="yes" xml:space="preserve">
          <source>For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.</source>
          <target state="translated">AngularJS를 사용하는 사람들에게는이 라이브러리의 객체를 복제하거나 확장하는 직접적인 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf4ec4c0c298b2a0248ed16c560cae0cb2b2f354" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;How to copy arrays and objects in Javascript&lt;/a&gt; by Brian Huisman:</source>
          <target state="translated">이 기사에서 : Brian Huisman이 &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;자바 스크립트&lt;/a&gt; 로 배열과 객체를 복사하는 방법 :</target>
        </trans-unit>
        <trans-unit id="73f8555ab7993eb62a7bb80980e5decb72448c9b" translate="yes" xml:space="preserve">
          <source>Here is a function you can use.</source>
          <target state="translated">사용할 수있는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4631d41b7b36fb799786f4a214099e57e5620b0e" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object</source>
          <target state="translated">JavaScript 객체를 올바르게 복제하는 방법</target>
        </trans-unit>
        <trans-unit id="743e0eea187a855a15b0996e0b65671bfbe4b6c9" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object?</source>
          <target state="translated">JavaScript 객체를 올바르게 복제하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="001d1eefeee3ed1b4eb51c735f2abbe94cdc6856" translate="yes" xml:space="preserve">
          <source>I have an object, &lt;code&gt;x&lt;/code&gt;. I'd like to copy it as object &lt;code&gt;y&lt;/code&gt;, such that changes to &lt;code&gt;y&lt;/code&gt; do not modify &lt;code&gt;x&lt;/code&gt;. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn't a problem, since I'm copying one of my own literal-constructed objects.</source>
          <target state="translated">객체 &lt;code&gt;x&lt;/code&gt; 가 있습니다. &lt;code&gt;y&lt;/code&gt; 로 변경해도 &lt;code&gt;x&lt;/code&gt; 가 수정되지 않도록 객체 y 로 복사하고 싶습니다. 내장 JavaScript 객체에서 파생 된 객체를 복사하면 원치 않는 속성이 추가로 생성됩니다. 나는 문자 그대로 구성된 객체 중 하나를 복사하기 때문에 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a18864f24ad3607c14646fe8b7ea199e0cfa3b2" translate="yes" xml:space="preserve">
          <source>I just wanted to add to all the &lt;code&gt;Object.create&lt;/code&gt; solutions in this post, that this does not work in the desired way with nodejs.</source>
          <target state="translated">이 게시물의 모든 &lt;code&gt;Object.create&lt;/code&gt; 솔루션에 추가하고 싶었지만 nodejs에서 원하는 방식으로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e8d9e15a95057e936855612d02338a65a9ae821" translate="yes" xml:space="preserve">
          <source>I think there is a simple and working answer. In deep copying there are two concerns:</source>
          <target state="translated">나는 간단하고 효과적인 답변이 있다고 생각합니다. 딥 카피에는 두 가지 우려가 있습니다.</target>
        </trans-unit>
        <trans-unit id="941624dec0eec1e76a1ffed0d1cbb9418daa899a" translate="yes" xml:space="preserve">
          <source>I want to &lt;strong&gt;deep-copy&lt;/strong&gt; a Javascript &lt;code&gt;Object&lt;/code&gt; with all of its children and their children and so on. But since I'm not kind of a normal developer, my &lt;code&gt;Object&lt;/code&gt; has &lt;em&gt;normal&lt;/em&gt;&lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and even &lt;code&gt;nested objects&lt;/code&gt;.</source>
          <target state="translated">모든 자식과 자식 등으로 Javascript &lt;code&gt;Object&lt;/code&gt; 를 &lt;strong&gt;딥 카피&lt;/strong&gt; 하고 싶습니다. 그러나 나는 정상적인 개발자가 아니기 때문에 내 &lt;code&gt;Object&lt;/code&gt; 에는 &lt;em&gt;일반&lt;/em&gt; &lt;code&gt;properties&lt;/code&gt; , &lt;code&gt;circular structures&lt;/code&gt; 및 심지어 &lt;code&gt;nested objects&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="492eceb4047550ce310e991adf6cd7624ed3faaa" translate="yes" xml:space="preserve">
          <source>I've put &lt;code&gt;F&lt;/code&gt; outside the scope so we can have a look at what &lt;code&gt;instanceof&lt;/code&gt; tells us.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 를 스코프 밖에 두어 &lt;code&gt;instanceof&lt;/code&gt; 가 알려주는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a429ab5caa7c00e09548791ed612fdfcc5894e19" translate="yes" xml:space="preserve">
          <source>I've written my own implementation. Not sure if it counts as a better solution:</source>
          <target state="translated">내 자신의 구현을 작성했습니다. 더 나은 솔루션으로 계산되는지 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dafdc35a46a4c2d0195d973a1d3318e6698831c0" translate="yes" xml:space="preserve">
          <source>If the object is XML DOM element, we must use &lt;strong&gt;cloneNode&lt;/strong&gt; instead</source>
          <target state="translated">객체가 XML DOM 요소 인 경우 대신 &lt;strong&gt;cloneNode&lt;/strong&gt; 를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="ae8354bc788c660711b68a4fa1e2850f3185cab9" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, undefined, regExp or Infinity within your object, a very simple one liner is &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt;:</source>
          <target state="translated">객체 내에서 &lt;code&gt;Date&lt;/code&gt; , 함수, undefined, regExp 또는 Infinity를 사용하지 않는 경우 매우 간단한 라이너는 &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd3f2d16bba73dae97290f3a239238665ccfc4c" translate="yes" xml:space="preserve">
          <source>If you want shallow copy, use &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</source>
          <target state="translated">얕은 복사를 원하면 &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253989d793a4111415e3d9230d7ab2071f59e3ac" translate="yes" xml:space="preserve">
          <source>If you're okay with a shallow copy, the underscore.js library has a &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">얕게 복사해도 괜찮다면 underscore.js 라이브러리에는 &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;복제&lt;/a&gt; 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bf6911de6ff08405b3d088604f2d3601613b4cb" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2018</source>
          <target state="translated">ECMAScript 2018에서</target>
        </trans-unit>
        <trans-unit id="1defc59fd72a11aff1734e0a2e2a22f0a4abab4d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 6 there is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method, which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">ECMAScript 6에는 열거 가능한 모든 자체 속성 값을 한 객체에서 다른 객체로 복사하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; 메소드가 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f304990021e58b1d1ff5e13fb83eed4bf99dd0d2" translate="yes" xml:space="preserve">
          <source>In ES-6 you can simply use Object.assign(...).
Ex:</source>
          <target state="translated">ES-6에서는 간단하게 Object.assign (...)을 사용할 수 있습니다. 전의:</target>
        </trans-unit>
        <trans-unit id="2c92ac88d5767f5e56ba7636924db58532bd9c70" translate="yes" xml:space="preserve">
          <source>In Firefox the result of</source>
          <target state="translated">Firefox에서 다음의 결과</target>
        </trans-unit>
        <trans-unit id="3c2ea368e40e7bb729de18cbee756fb95f6ea1f5" translate="yes" xml:space="preserve">
          <source>In addition to non-enumerable attributes, you'll encounter a tougher problem when you try to copy objects that have hidden properties. For example, &lt;code&gt;prototype&lt;/code&gt; is a hidden property of a function. Also, an object's prototype is referenced with the attribute &lt;code&gt;__proto__&lt;/code&gt;, which is also hidden, and will not be copied by a for/in loop iterating over the source object's attributes. I think &lt;code&gt;__proto__&lt;/code&gt; might be specific to Firefox's JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don't know of any way to discover it automatically.</source>
          <target state="translated">열거 할 수없는 속성 외에도 숨겨진 속성이있는 객체를 복사하려고하면 더 어려운 문제가 발생합니다. 예를 들어, &lt;code&gt;prototype&lt;/code&gt; 은 함수의 숨겨진 속성입니다. 또한 객체의 프로토 타입은 &lt;code&gt;__proto__&lt;/code&gt; 속성으로 참조 되며이 속성은 숨겨져 있으며 소스 객체의 속성을 반복하는 for / in 루프에 의해 복사되지 않습니다. &lt;code&gt;__proto__&lt;/code&gt; 는 Firefox의 JavaScript 인터프리터와 관련이있을 수 있으며 다른 브라우저에서는 다를 수 있지만 그림이 나타납니다. 모든 것이 열거 가능한 것은 아닙니다. 숨겨진 속성의 이름을 알고 있으면 복사 할 수 있지만 자동으로 검색하는 방법은 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="af3b62758b3b5aad9f8bb2a67a63a6b1276c2744" translate="yes" xml:space="preserve">
          <source>In nodejs it is</source>
          <target state="translated">nodejs에서는</target>
        </trans-unit>
        <trans-unit id="8070d65a107f7a0001017aa494dfb78ff6d01341" translate="yes" xml:space="preserve">
          <source>Inspired by A.Levy's exhaustive study and Calvin's prototyping approach, I offer this solution:</source>
          <target state="translated">A.Levy의 철저한 연구와 Calvin의 프로토 타이핑 접근법에서 영감을 얻은이 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9bfe4aadd640d727c541e4a74de4c537bf9603c9" translate="yes" xml:space="preserve">
          <source>Interested in cloning simple objects:</source>
          <target state="translated">간단한 객체 복제에 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06837f1236b49354891013f198510b9ba4fc2ab5" translate="yes" xml:space="preserve">
          <source>It will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don't assume that it will just work for anything you throw at it.</source>
          <target state="translated">JavaScript 객체를 처리 할 수는 없지만 던질 때만 작동한다고 가정하지 않는 한 많은 목적으로 충분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c5f79a04d00332bcef73e7c25ac76cc77265d5d3" translate="yes" xml:space="preserve">
          <source>JavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:</source>
          <target state="translated">JavaScript는 실제로 기본적으로 딥 클론을 지원하지 않습니다. 유틸리티 기능을 사용하십시오. 예를 들어 Ramda :</target>
        </trans-unit>
        <trans-unit id="6c8086021c6a372b4809189f81b1a61b9f2eeea4" translate="yes" xml:space="preserve">
          <source>JavaScript keeps evolving.</source>
          <target state="translated">자바 스크립트는 계속 발전하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="898c396720398ab086b937719a5cb546261e8435" translate="yes" xml:space="preserve">
          <source>Keep properties independent to each other.</source>
          <target state="translated">속성을 서로 독립적으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f9cd6e333924ef28d1cf1cb192e551179543718e" translate="yes" xml:space="preserve">
          <source>Let's bring everything together in an &lt;code&gt;Object&lt;/code&gt; named &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;a&lt;/code&gt; 인 &lt;code&gt;Object&lt;/code&gt; 에 모든 것을 모아 봅시다.</target>
        </trans-unit>
        <trans-unit id="b8aaf1df286d5ef5e319286978f2d4a622c5dd52" translate="yes" xml:space="preserve">
          <source>Let's have a look at the accepted answer.</source>
          <target state="translated">허용되는 답변을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3440d2c76fb94711deb530c695895ec6080f7195" translate="yes" xml:space="preserve">
          <source>Looks good, heh? It's a recursive copy of the object and handles other types as well, like &lt;code&gt;Date&lt;/code&gt;, but that wasn't a requirement.</source>
          <target state="translated">좋아 보인다? 객체의 재귀 복사본이며 &lt;code&gt;Date&lt;/code&gt; 와 같은 다른 유형도 처리하지만 필수 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4401b855280cd9542719b7c0ccaf34205cee9587" translate="yes" xml:space="preserve">
          <source>More in angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;documentation&lt;/a&gt;...</source>
          <target state="translated">angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;문서&lt;/a&gt; 에 대한 추가 정보 ...</target>
        </trans-unit>
        <trans-unit id="dade8dcd2b43a64b756eff141607bc6874a514ce" translate="yes" xml:space="preserve">
          <source>New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt;, it's easy.</source>
          <target state="translated">오래된 질문에 대한 새로운 답변! &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt; 와 함께 ECMAScript 2016 (ES6)을 사용하는 것이 즐겁다면 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="13e3b18e3972aab20fc4c36853cd1d0b35875d96" translate="yes" xml:space="preserve">
          <source>Next, we want to copy &lt;code&gt;a&lt;/code&gt; into a variable named &lt;code&gt;b&lt;/code&gt; and mutate it.</source>
          <target state="translated">다음으로 a를 &lt;code&gt;b&lt;/code&gt; 라는 변수에 복사하고 변경합니다.</target>
        </trans-unit>
        <trans-unit id="dc14249af7e109f4fde91ed60eb8e84255d155bd" translate="yes" xml:space="preserve">
          <source>Now let's find a solution.</source>
          <target state="translated">이제 해결책을 찾아 보자.</target>
        </trans-unit>
        <trans-unit id="4d1dae1e39568ce239fd2a7fc3a8cf3c550df25c" translate="yes" xml:space="preserve">
          <source>Of course, functions do not belong in JSON, so this only works for objects without member methods.</source>
          <target state="translated">물론 함수는 JSON에 속하지 않으므로 멤버 메소드가없는 객체에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2366061f7e9ccde0f6899dd5905d19be0299833f" translate="yes" xml:space="preserve">
          <source>One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.</source>
          <target state="translated">특히 우아하지 않은 솔루션 중 하나는 JSON 인코딩을 사용하여 멤버 메소드가없는 오브젝트의 깊은 사본을 작성하는 것입니다. 방법론은 대상 객체를 JSON으로 인코딩 한 다음 디코딩하여 찾고있는 사본을 얻는 것입니다. 필요한만큼 사본을 만들려는 횟수만큼 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e7cf65ae4060f78ce8aa1b4ed6c66bf3442b4e" translate="yes" xml:space="preserve">
          <source>Or to make a &lt;strong&gt;deep copy&lt;/strong&gt;:</source>
          <target state="translated">또는 &lt;strong&gt;깊은 사본&lt;/strong&gt; 을 만들려면 :</target>
        </trans-unit>
        <trans-unit id="c5035e794e31882d47ef1d6b8595571334a62a63" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt; 당 :</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">더 읽어보기 ...</target>
        </trans-unit>
        <trans-unit id="b70d8b981e5c20ee4900b1d547ab578ea9f8c800" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;code&gt;circular structures&lt;/code&gt; doesn't work well together... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</source>
          <target state="translated">재귀와 &lt;code&gt;circular structures&lt;/code&gt; 가 함께 작동하지 않습니다 ... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f0db5294c0b0127ed78e8534a588a4da9a4ea8" translate="yes" xml:space="preserve">
          <source>Recursive copy &lt;em&gt;(the accepted &quot;answer&quot;)&lt;/em&gt;</source>
          <target state="translated">재귀 사본 &lt;em&gt;(허용 된 &quot;답변&quot;)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461c16fdd9cf991abb778545c3d4ab00c017168c" translate="yes" xml:space="preserve">
          <source>Same problem as the &lt;em&gt;native solution&lt;/em&gt;, but a little bit worse output.</source>
          <target state="translated">&lt;em&gt;기본 솔루션&lt;/em&gt; 과 동일한 문제이지만 약간 더 나쁜 출력입니다.</target>
        </trans-unit>
        <trans-unit id="796baa07c71d736d03895eacc42e11d3d30a4b20" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;this article about the structured clone algorithm of browsers&lt;/a&gt; which is used when posting messages to and from a worker. It also contains a function for deep cloning.</source>
          <target state="translated">작업자와 메시지를 게시 할 때 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;브라우저의 구조화 된 클론 알고리즘에 대한이 기사를&lt;/a&gt; 참조하십시오. 또한 심층 복제 기능도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b3ee3c57fb439d18c03172ee7afacf0e99f6105f" translate="yes" xml:space="preserve">
          <source>See also Andy Burke's note in the answers.</source>
          <target state="translated">답변에서 Andy Burke의 메모를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="454f14f00bca91bc2a843967363a76e24887bba3" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; stated that the object to be cloned is a 'literal-constructed' object, a solution might be to simply &lt;em&gt;generate&lt;/em&gt; the object multiple times rather than cloning an instance of the object:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; 는 복제 될 객체가 'literal-constructed'객체라고 언급 했으므로 , 객체의 인스턴스를 복제하는 대신 객체를 여러 번 &lt;em&gt;생성&lt;/em&gt; 하는 것이 해결책 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7073615569ad59804a8d64877706cc2ee7c1a1ec" translate="yes" xml:space="preserve">
          <source>So I think one simple solution will be to first serialize and deserialize and then do an assign on it to copy functions too.</source>
          <target state="translated">그래서 하나의 간단한 해결책은 먼저 직렬화 및 역 직렬화 한 다음 함수를 복사하기 위해 할당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b77e5c1be59f320b6042fdf12c140f63ab1a4003" translate="yes" xml:space="preserve">
          <source>So let's create a &lt;code&gt;circular structure&lt;/code&gt; and a &lt;code&gt;nested object&lt;/code&gt; first.</source>
          <target state="translated">먼저 &lt;code&gt;circular structure&lt;/code&gt; 와 &lt;code&gt;nested object&lt;/code&gt; 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="a1e5d5e7a575e6d613efa42edbbd2bd59577f137" translate="yes" xml:space="preserve">
          <source>Some quick tests</source>
          <target state="translated">몇 가지 빠른 테스트</target>
        </trans-unit>
        <trans-unit id="1ad81ed3b31b89f94fdfb8b814a7b408c0ce4ac4" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;How to copy JavaScript object to new variable NOT by reference?&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;JavaScript 객체를 참조가 아닌 새로운 변수에 복사하는 방법은 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">구형 브라우저를 지원하는 &lt;strong&gt;폴리 필&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">Object.assign () 메소드는 열거 가능한 모든 고유 특성의 값을 하나 이상의 소스 오브젝트에서 대상 오브젝트로 복사하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a4308022632fbf96a189f60d4c089e47657082a" translate="yes" xml:space="preserve">
          <source>The above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn't more than one reference to the same data in the object. For example:</source>
          <target state="translated">위의 함수는 객체와 배열의 데이터가 트리 구조를 형성하는 한 위에서 언급 한 6 가지 간단한 유형에 적절하게 작동합니다. 즉, 객체에 동일한 데이터에 대한 참조가 두 개 이상 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="032b503078d9391f3f083e20a6246421123e2d8b" translate="yes" xml:space="preserve">
          <source>The date string for &lt;code&gt;d1&lt;/code&gt; will be 5 seconds behind that of &lt;code&gt;d2&lt;/code&gt;. A way to make one &lt;code&gt;Date&lt;/code&gt; the same as another is by calling the &lt;code&gt;setTime&lt;/code&gt; method, but that is specific to the &lt;code&gt;Date&lt;/code&gt; class. I don't think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!</source>
          <target state="translated">&lt;code&gt;d1&lt;/code&gt; 의 날짜 문자열은 d2 의 날짜 문자열보다 5 초 &lt;code&gt;d2&lt;/code&gt; . 한 &lt;code&gt;Date&lt;/code&gt; 를 다른 Date 와 동일하게 만드는 방법은 &lt;code&gt;setTime&lt;/code&gt; 메서드를 호출하는 것이지만 &lt;code&gt;Date&lt;/code&gt; 클래스에만 적용됩니다. 나는이 문제에 대한 방탄적인 일반적인 해결책이 없다고 생각하지만 잘못되어 기쁠 것입니다!</target>
        </trans-unit>
        <trans-unit id="043746030e244c05064aabe5e6c53eb1b00a3576" translate="yes" xml:space="preserve">
          <source>The first attempt I tried was using &lt;code&gt;JSON&lt;/code&gt;.</source>
          <target state="translated">내가 시도한 첫 번째 시도는 &lt;code&gt;JSON&lt;/code&gt; 이었습니다.</target>
        </trans-unit>
        <trans-unit id="9f000a225c9b05dc90c944d0aaba92c15349755d" translate="yes" xml:space="preserve">
          <source>The last solution using recursion and a cache, may not be the best, but it's a &lt;strong&gt;real&lt;/strong&gt; deep-copy of the object. It handles simple &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and &lt;code&gt;nested object&lt;/code&gt;, but it will mess up the instance of them while cloning.</source>
          <target state="translated">재귀와 캐시를 사용하는 마지막 솔루션은 최고는 아니지만 객체의 &lt;strong&gt;실제&lt;/strong&gt; 깊은 복사입니다. 간단한 &lt;code&gt;properties&lt;/code&gt; , &lt;code&gt;circular structures&lt;/code&gt; 및 &lt;code&gt;nested object&lt;/code&gt; 를 처리하지만 복제하는 동안 인스턴스를 엉망으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d2e920fb16fae1fedca17a36ec3baa9202cbb72d" translate="yes" xml:space="preserve">
          <source>The requirements are matched, but there are still some smaller issues, including changing the &lt;code&gt;instance&lt;/code&gt; of &lt;code&gt;nested&lt;/code&gt; and &lt;code&gt;circ&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">요구 사항이 일치하지만 &lt;code&gt;nested&lt;/code&gt; 및 &lt;code&gt;circ&lt;/code&gt; &lt;code&gt;instance&lt;/code&gt; 를 &lt;code&gt;Object&lt;/code&gt; 로 변경하는 것을 포함하여 더 작은 문제가 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a4e57a808e70c1984cd4b7435f7b3b8f879529" translate="yes" xml:space="preserve">
          <source>The structure of trees that share a leaf won't be copied, they will become two independent leaves:</source>
          <target state="translated">나뭇잎을 공유하는 나무의 구조는 복사되지 않으며 두 개의 독립적 인 나뭇잎이됩니다.</target>
        </trans-unit>
        <trans-unit id="13a953842279c7fd9c49eb420b7ea3060cfc3c9f" translate="yes" xml:space="preserve">
          <source>There are many answers, but none that mentions &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.</source>
          <target state="translated">많은 답변이 있지만 ECMAScript 5의 &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create에&lt;/a&gt; 대해서는 언급하지 않았지만 정확한 사본을 제공하지는 않지만 소스를 새 객체의 프로토 타입으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cc7af0c92f6e6c0d9df4aaa342be3e26c98b8b64" translate="yes" xml:space="preserve">
          <source>There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn't be accepted.</source>
          <target state="translated">인터넷에서 대부분의 솔루션에는 몇 가지 문제가 있습니다. 그래서 나는 후속 답변을하기로 결정했는데, 여기에는 왜 받아 들여진 대답을 받아들이지 않아야하는지 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2138887f9e1a5984c4ac16aa3859fe4f272a050d" translate="yes" xml:space="preserve">
          <source>There is no need for external libraries but you need to check &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;browser compatibility first&lt;/a&gt;.</source>
          <target state="translated">외부 라이브러리는 필요하지 않지만 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;먼저 브라우저 호환성&lt;/a&gt; 을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6df6c28aa1c494acefc67b48ca65405704b89a2" translate="yes" xml:space="preserve">
          <source>There's a polyfill for &lt;code&gt;Object.create&lt;/code&gt; in the older browser just like the IE 8. It's something like recommended by Mozilla, and of course, it's not perfect and results in the same problem as the &lt;em&gt;native solution&lt;/em&gt;.</source>
          <target state="translated">IE 8과 같이 이전 브라우저에는 &lt;code&gt;Object.create&lt;/code&gt; 에 대한 polyfill이 있습니다. Mozilla에서 권장하는 것과 같으며 물론 완벽하지 않으며 &lt;em&gt;기본 솔루션&lt;/em&gt; 과 동일한 문제가 발생 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="257b97895de4343bd020da12619838edee113900" translate="yes" xml:space="preserve">
          <source>This is an adaptation of A. Levy's code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)</source>
          <target state="translated">이것은 A. Levy의 코드를 수정하여 함수 및 다중 / 순환 참조의 복제도 처리합니다. 즉, 복제 된 트리의 두 속성이 동일한 객체의 참조 인 경우 복제 된 객체 트리는 속성은 참조 된 객체의 동일한 복제본을 가리 킵니다. 이것은 또한 처리되지 않은 채로 있으면 무한 루프로 이어지는 순환 종속성의 경우를 해결합니다. 알고리즘의 복잡성은 O (n)입니다.</target>
        </trans-unit>
        <trans-unit id="3aeab4233dd61158490346563a83710fdb174f9f" translate="yes" xml:space="preserve">
          <source>This methodology was perfect for my use case, since I'm storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.</source>
          <target state="translated">이 방법론은 JSON 값을 키-값 저장소에 저장하고 JavaScript API에서 객체로 노출 될 때 각 객체는 실제로 객체의 원래 상태 사본을 포함하므로 사용 사례에 완벽했습니다. 호출자가 노출 된 객체를 변경 한 후 델타를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270c07e5aba6d333e589186ebce926ac9488ae45" translate="yes" xml:space="preserve">
          <source>This provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.</source>
          <target state="translated">이것은 객체의 얕은 사본을위한 깨끗한 방법을 제공합니다. 딥 카피를 만들려면 모든 재귀 적으로 중첩 된 객체의 모든 값에 대한 새로운 카피를 작성해야합니다. 위의 더 무거운 솔루션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c3d98944d47265d765fc5c22fd2d0a49ddc89117" translate="yes" xml:space="preserve">
          <source>This solution was added to Javascript some time ago and even handles &lt;code&gt;circular structure&lt;/code&gt;.</source>
          <target state="translated">이 솔루션은 얼마 전에 Javascript에 추가되었으며 심지어 &lt;code&gt;circular structure&lt;/code&gt; 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d709893b9322713175a8239aabd951c8aa101e46" translate="yes" xml:space="preserve">
          <source>This works for all kind of objects containing objects, arrays, strings, booleans and numbers.</source>
          <target state="translated">이것은 객체, 배열, 문자열, 부울 및 숫자를 포함하는 모든 종류의 객체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="be7e283523bee098c95fbd259fdb185444007880" translate="yes" xml:space="preserve">
          <source>Thus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:</source>
          <target state="translated">따라서 이것은 질문에 대한 정확한 대답은 아니지만 단선 솔루션이므로 우아합니다. 그리고 두 가지 경우에 가장 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="b36783ae8f97bf075d43eb8bdee3e68cae031c5d" translate="yes" xml:space="preserve">
          <source>To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object's prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a &lt;code&gt;clone&lt;/code&gt; method to &lt;code&gt;Object.prototype&lt;/code&gt;, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to &lt;code&gt;Object.prototype&lt;/code&gt;, or other intermediate prototypes, that you don't know about? In that case, you will copy attributes you shouldn't, so you need to detect unforeseen, non-local attributes with the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">JavaScript의 객체에 대해이 작업을 수행하는 것은 간단하거나 간단하지 않습니다. 프로토 타입에 남겨두고 새 인스턴스로 복사하지 않아야하는 객체의 프로토 타입에서 속성을 잘못 선택하는 문제가 발생합니다. 예를 들어 &lt;code&gt;Object.prototype&lt;/code&gt; 에 &lt;code&gt;clone&lt;/code&gt; 방법을 추가하는 경우 일부 답변에서 볼 수 있듯이 해당 속성을 명시 적으로 건너 뛸 필요가 있습니다. 그러나 &lt;code&gt;Object.prototype&lt;/code&gt; 또는 다른 중간 프로토 타입에 추가 된 다른 추가 방법이없는 경우 어떻게해야합니까? 이 경우, 사용하지 말아야 할 속성을 복사하므로 &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;hasOwnProperty&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 예기치 않은 로컬이 아닌 속성을 감지해야합니다.</target>
        </trans-unit>
        <trans-unit id="a913fb7183b6fb881c9a823ab39998ee4aa93f87" translate="yes" xml:space="preserve">
          <source>Using Lodash:</source>
          <target state="translated">Lodash 사용하기 :</target>
        </trans-unit>
        <trans-unit id="ca5a4f97de6e6ecec887d15f3ba764fe9304dac1" translate="yes" xml:space="preserve">
          <source>When I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; would also be one of the 6 simple types in that list. This can be accomplished with code like the following:</source>
          <target state="translated">일반 딥 카피를 구현해야 할 때 일반 &lt;code&gt;Object&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 또는 &lt;code&gt;Boolean&lt;/code&gt; 만 복사하면된다고 가정하여 타협했습니다. 마지막 3 가지 유형은 변경할 수 없으므로 얕은 복사를 수행 할 수 있으며 변경에 대해 걱정할 필요가 없습니다. 또한 &lt;code&gt;Object&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; 에 포함 된 모든 요소가 해당 목록의 6 가지 간단한 유형 중 하나라고 가정했습니다. 이것은 다음과 같은 코드로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="456e0fb41b68296ae4fca0c5da8c6c8c99b050d9" translate="yes" xml:space="preserve">
          <source>When digging around, I found a similar question (&lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;In Javascript, when performing a deep copy, how do I avoid a cycle, due to a property being &quot;this&quot;?&lt;/a&gt;) to this one, but with a way better solution.</source>
          <target state="translated">발굴 할 때 비슷한 질문 ( &lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;자바 스크립트에서 딥 카피를 수행 할 때 속성이 &quot;this&quot;이기 때문에 어떻게 사이클을 피할 수 있습니까?&lt;/a&gt; )과 더 나은 해결책을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="a9252c930b2a9734d9944f251662812bcd0d5878" translate="yes" xml:space="preserve">
          <source>Where such inheritance is useful (duh!)</source>
          <target state="translated">그러한 상속이 유용한 곳 (duh!)</target>
        </trans-unit>
        <trans-unit id="f3f6684c458c70cb9d8e7a984298d711252184ac" translate="yes" xml:space="preserve">
          <source>Where the source object won't be modified, thus making the relation between the 2 objects a non issue.</source>
          <target state="translated">소스 객체가 수정되지 않는 경우 두 객체 간의 관계가 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2735aa18f20ac2191686e23824f2e5be39288c5c" translate="yes" xml:space="preserve">
          <source>Why do I consider this solution to be superior? It's native, thus no looping, no recursion. However, older browsers will need a polyfill.</source>
          <target state="translated">왜이 솔루션이 우수하다고 생각합니까? 그것은 네이티브이므로 반복도없고 재귀도 없습니다. 그러나 오래된 브라우저에는 폴리 필이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c4313b8450309f35ea2494e7d2513a055de02aeb" translate="yes" xml:space="preserve">
          <source>With jQuery, you can &lt;strong&gt;shallow copy&lt;/strong&gt; with &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;:</source>
          <target state="translated">jQuery를 사용하면 &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend로&lt;/a&gt; &lt;strong&gt;얕은 복사&lt;/strong&gt; 를 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc955433235b02b7f40b76eb1d7dfddf892c4a6e" translate="yes" xml:space="preserve">
          <source>Yet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object's prototype is &lt;code&gt;Object&lt;/code&gt;, then simply creating a new general object with &lt;code&gt;{}&lt;/code&gt; will work, but if the source's prototype is some descendant of &lt;code&gt;Object&lt;/code&gt;, then you are going to be missing the additional members from that prototype which you skipped using the &lt;code&gt;hasOwnProperty&lt;/code&gt; filter, or which were in the prototype, but weren't enumerable in the first place. One solution might be to call the source object's &lt;code&gt;constructor&lt;/code&gt; property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object stores its data as a hidden member:</source>
          <target state="translated">우아한 솔루션을 찾는 또 다른 걸림돌은 프로토 타입 상속을 올바르게 설정하는 문제입니다. 소스 객체의 프로토 타입이 &lt;code&gt;Object&lt;/code&gt; 이면 &lt;code&gt;{}&lt;/code&gt; 을 사용하여 새 일반 객체를 만들면됩니다. 그러나 소스의 프로토 타입이 &lt;code&gt;Object&lt;/code&gt; 의 자손 인 경우 해당 프로토 타입에서 추가 멤버가 누락됩니다. &lt;code&gt;hasOwnProperty&lt;/code&gt; 필터 또는 프로토 타입에 있었지만 처음에는 열거 할 수 없었습니다. 한 가지 해결책은 소스 객체의 &lt;code&gt;constructor&lt;/code&gt; 속성을 호출하여 초기 복사 객체를 가져온 다음 속성을 복사하는 것이지만 열거 할 수없는 속성은 얻지 못할 수 있습니다. 예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체는 데이터를 숨겨진 멤버로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f6ada691f9c830b134d1063e166e1d147221dcb3" translate="yes" xml:space="preserve">
          <source>You can clone an object and remove any reference from the previous one using a single line of code. Simply do:</source>
          <target state="translated">한 줄의 코드를 사용하여 객체를 복제하고 이전 객체에서 참조를 제거 할 수 있습니다. 간단히 :</target>
        </trans-unit>
        <trans-unit id="2fb59e1d6040b949307491685dc51fd64aac4887" translate="yes" xml:space="preserve">
          <source>You can simply use a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;spread property&lt;/a&gt; to copy an object without references. But be careful (see comments), the 'copy' is just on the lowest object/array level. Nested properties are still references!</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;스프레드 속성&lt;/a&gt; 을 사용하여 참조없이 객체를 복사 할 수 있습니다. 그러나 '복사'는 객체 / 배열 수준이 가장 낮습니다. 중첩 속성은 여전히 ​​참조입니다!</target>
        </trans-unit>
        <trans-unit id="9abb2632977048faaf1083e1bdfe1addfa67decb" translate="yes" xml:space="preserve">
          <source>You know what happened here because if not you wouldn't even land on this great question.</source>
          <target state="translated">그렇지 않다면이 위대한 질문에 부딪치지 않기 때문에 여기서 무슨 일이 있었는지 알 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a38a38f03e4ff5839ba4a879178cce5bc42666b" translate="yes" xml:space="preserve">
          <source>conclusion</source>
          <target state="translated">conclusion</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="716e96afcc9beb903225a881db7f167667cc2eb3" translate="yes" xml:space="preserve">
          <source>jsfiddle</source>
          <target state="translated">jsfiddle</target>
        </trans-unit>
        <trans-unit id="352f260ed32601f2720cbdef8b42f9882a4102af" translate="yes" xml:space="preserve">
          <source>native solution</source>
          <target state="translated">기본 솔루션</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="c5b130d2294080fe3f54b6ede9cb6c33d3a49d6b" translate="yes" xml:space="preserve">
          <source>or using spread operator like this:</source>
          <target state="translated">또는 다음과 같이 스프레드 연산자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82ae245159e159776ea37d68d57ddfa387a83600" translate="yes" xml:space="preserve">
          <source>or you can extend it like</source>
          <target state="translated">또는 당신은 그것을 확장 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3e0bf88b357a046b4e7659fed6103de63a9734cd" translate="yes" xml:space="preserve">
          <source>polyfill for the native solution</source>
          <target state="translated">기본 솔루션을위한 폴리 필</target>
        </trans-unit>
        <trans-unit id="55d9bbd3efbab583726fcd7c3ad976b8129b76ee" translate="yes" xml:space="preserve">
          <source>starting situation</source>
          <target state="translated">시작 상황</target>
        </trans-unit>
        <trans-unit id="a5f7a257ae51fb7db8f01b3b457418d96c6a2a00" translate="yes" xml:space="preserve">
          <source>subsequent changes to the &lt;code&gt;copiedObject&lt;/code&gt; will not affect the &lt;code&gt;originalObject&lt;/code&gt;, and vice versa.</source>
          <target state="translated">&lt;code&gt;copiedObject&lt;/code&gt; 에 대한 후속 변경 사항은 &lt;code&gt;originalObject&lt;/code&gt; 에 영향을 미치지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="2ba1210fdf174274ea55c483bb6ade889c52e126" translate="yes" xml:space="preserve">
          <source>the answer is mainly depeneds on which &lt;strong&gt;ECMAscript&lt;/strong&gt; you using, in &lt;code&gt;ES6+&lt;/code&gt;, you can simply use &lt;code&gt;Object.assign&lt;/code&gt; to do the clone:</source>
          <target state="translated">대답은 주로 사용하는 &lt;strong&gt;ECMAscript&lt;/strong&gt; 에 따라 달라집니다. &lt;code&gt;ES6+&lt;/code&gt; 에서는 단순히 &lt;code&gt;Object.assign&lt;/code&gt; 을 사용하여 복제를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="522547b9c4325ca856f8c4192d0ad23de9c33613" translate="yes" xml:space="preserve">
          <source>the better (but not perfect) solution</source>
          <target state="translated">더 나은 (그러나 완벽하지는 않은) 솔루션</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
