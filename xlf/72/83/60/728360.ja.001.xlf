<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/728360">
    <body>
      <group id="728360">
        <trans-unit id="5fff870d002057a570c5f54f6e0583f072249e21" translate="yes" xml:space="preserve">
          <source>... and you see, it didn't work with the nested structure inside.</source>
          <target state="translated">...で、見ての通り、中の入れ子構造ではうまくいかなかった。</target>
        </trans-unit>
        <trans-unit id="fdf1515d42ec5590b0b9470e710e5a34edb33d3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="f8d42eb23fc0b5363fad3b52a8388240db181867" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clone with references on second level:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;第2レベルの参照を持つクローン：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cea8c7ca59555849767060049632be16cd783d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete clone:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;完全なクローン：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6966d0f501ab4b788d3ea14f276d58f9c181e993" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; imagine you have this object below and you want to clone it:</source>
          <target state="translated">&lt;strong&gt;OK、&lt;/strong&gt;下にこのオブジェクトがあり、それを複製したいとします。</target>
        </trans-unit>
        <trans-unit id="22efe12cc8badd5b62cb63cbb32d48a03bfc69b9" translate="yes" xml:space="preserve">
          <source>A good reference is here:
&lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</source>
          <target state="translated">良いリファレンスはこちらです： &lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https&lt;/a&gt; : //googlechrome.github.io/samples/object-assign-es6/</target>
        </trans-unit>
        <trans-unit id="31e2fbcb0256c7808f1ca3a03007c73a654f8c07" translate="yes" xml:space="preserve">
          <source>A.Levy's answer is almost complete, here is my little contribution: &lt;strong&gt;there is a way how to handle recursive references&lt;/strong&gt;, see this line</source>
          <target state="translated">A.Levyの答えはほぼ完成です。これが私の小さな貢献です。 &lt;strong&gt;再帰的な参照を処理する方法があり&lt;/strong&gt;ます。この行を参照してください</target>
        </trans-unit>
        <trans-unit id="75589da17d1b2a78b18aaddcd6a610f24da00c24" translate="yes" xml:space="preserve">
          <source>After arguing with my co-worker, my boss asked us what happened, and he found a simple &lt;em&gt;solution&lt;/em&gt; after some googling. It's called &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">同僚と話し合った後、上司から何が起こったのかと尋ねられました。 これは &lt;code&gt;Object.create&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ba29de559b1bb261e25a1d12df67e7d242566aa7" translate="yes" xml:space="preserve">
          <source>Although this question has many answers, I hope this one helps too.</source>
          <target state="translated">この質問には多くの回答がありますが、こちらも参考になれば幸いです。</target>
        </trans-unit>
        <trans-unit id="af28336e40dc39e63a92abf858f8c6ab4d67e567" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object.assign&lt;/code&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; メソッドはECMAScript 2015（ES6）標準の一部であり、必要なことを正確に実行します。</target>
        </trans-unit>
        <trans-unit id="32bfe9e918d4b868492fa92e62f1c551337c8c70" translate="yes" xml:space="preserve">
          <source>An elegant way to clone a Javascript object in one line of code</source>
          <target state="translated">1 行のコードで Javascript オブジェクトをクローンするエレガントな方法</target>
        </trans-unit>
        <trans-unit id="896435d8badf2f411e99791401b27e88034dbb6f" translate="yes" xml:space="preserve">
          <source>And keep the methods alive on cloned object.</source>
          <target state="translated">そして、クローンされたオブジェクト上でメソッドを生きたままにしておきます。</target>
        </trans-unit>
        <trans-unit id="a19d0a3bf30a88c3fd9012682cd0067268b19a91" translate="yes" xml:space="preserve">
          <source>And let's have a look at the output...</source>
          <target state="translated">そして、出力を見てみましょう...。</target>
        </trans-unit>
        <trans-unit id="11f375141a5034d16664f0e54b2f1c0b28910f53" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;strong&gt;nested objects&lt;/strong&gt; are still copied &lt;strong&gt;as a reference.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ネストされたオブジェクト&lt;/strong&gt;は&lt;strong&gt;参照として&lt;/strong&gt;コピーさ&lt;strong&gt;れる&lt;/strong&gt;ことに注意してください&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56ecbf1b8827336c51f8306fdb107ae1b4c8f121" translate="yes" xml:space="preserve">
          <source>But be aware that nested objects are still copied as reference.</source>
          <target state="translated">しかし、入れ子になったオブジェクトは参照としてコピーされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="44d9c60e7ecbda7adb322596b936906b1dded999" translate="yes" xml:space="preserve">
          <source>But if you using &lt;code&gt;ES5&lt;/code&gt;, you can use few methods, but the &lt;code&gt;JSON.stringify&lt;/code&gt;, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:</source>
          <target state="translated">しかし、 &lt;code&gt;ES5&lt;/code&gt; を使用する場合、いくつかのメソッドを使用できますが、 &lt;code&gt;JSON.stringify&lt;/code&gt; は 、コピーするデータの大きなチャンクに使用しないことを確認しますが、多くの場合、次のように1行で便利です。</target>
        </trans-unit>
        <trans-unit id="95088399458c196785b80f328382de6f8fa6da7f" translate="yes" xml:space="preserve">
          <source>Don't waste too much time on it, you'll get &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt;.</source>
          <target state="translated">あまり時間を無駄にしないでください &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d2b7b729fd7dfac409f1f5c4781cdc32d799528" translate="yes" xml:space="preserve">
          <source>ES6 solution if you want to (shallow) clone a &lt;strong&gt;class instance&lt;/strong&gt; and not just a property object.</source>
          <target state="translated">プロパティオブジェクトだけでなく、 &lt;strong&gt;クラスインスタンス&lt;/strong&gt;を（浅く）複製する場合のES6ソリューション。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="9d4b3583c599fafbba741d166652892841a76ea3" translate="yes" xml:space="preserve">
          <source>Following is the implementation:</source>
          <target state="translated">以下、実施の様子をご紹介します。</target>
        </trans-unit>
        <trans-unit id="6dcc05bb82ad169b245a024fa2181e38169796be" translate="yes" xml:space="preserve">
          <source>For &quot;deep&quot; copy, use &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</source>
          <target state="translated">「深い」コピーには、 &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="24a73f09717e6302b4ae5cfc392955d30204cefd" translate="yes" xml:space="preserve">
          <source>For a deep copy and clone, JSON.stringify then JSON.parse the object:</source>
          <target state="translated">深いコピーとクローンの場合は、JSON.stringifyしてからJSON.parseします。</target>
        </trans-unit>
        <trans-unit id="fbe99868375178cc499070d97ef9839eb868985f" translate="yes" xml:space="preserve">
          <source>For browsers / engines that do not currently support Object.create you can use this polyfill:</source>
          <target state="translated">現在 Object.create をサポートしていないブラウザエンジンでは、このポリフィルを使用することができます。</target>
        </trans-unit>
        <trans-unit id="fdfee069d3a9f22467239d1a5c249362ba8bfbc8" translate="yes" xml:space="preserve">
          <source>For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.</source>
          <target state="translated">AngularJSを使用している人のために、このライブラリのオブジェクトのクローンや拡張を直接行う方法もあります。</target>
        </trans-unit>
        <trans-unit id="bf4ec4c0c298b2a0248ed16c560cae0cb2b2f354" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;How to copy arrays and objects in Javascript&lt;/a&gt; by Brian Huisman:</source>
          <target state="translated">この記事から：Brian Huismanによる&lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;JavaScriptで配列とオブジェクトをコピーする方法&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="73f8555ab7993eb62a7bb80980e5decb72448c9b" translate="yes" xml:space="preserve">
          <source>Here is a function you can use.</source>
          <target state="translated">使える関数を紹介します。</target>
        </trans-unit>
        <trans-unit id="4631d41b7b36fb799786f4a214099e57e5620b0e" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object</source>
          <target state="translated">JavaScriptオブジェクトを正しくクローンするには</target>
        </trans-unit>
        <trans-unit id="743e0eea187a855a15b0996e0b65671bfbe4b6c9" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object?</source>
          <target state="translated">JavaScriptオブジェクトを正しくクローンするには?</target>
        </trans-unit>
        <trans-unit id="001d1eefeee3ed1b4eb51c735f2abbe94cdc6856" translate="yes" xml:space="preserve">
          <source>I have an object, &lt;code&gt;x&lt;/code&gt;. I'd like to copy it as object &lt;code&gt;y&lt;/code&gt;, such that changes to &lt;code&gt;y&lt;/code&gt; do not modify &lt;code&gt;x&lt;/code&gt;. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn't a problem, since I'm copying one of my own literal-constructed objects.</source>
          <target state="translated">オブジェクト &lt;code&gt;x&lt;/code&gt; があります。 それをオブジェクト &lt;code&gt;y&lt;/code&gt; としてコピーし、 yを変更しても &lt;code&gt;y&lt;/code&gt; が変更されないようにします。 組み込みのJavaScriptオブジェクトから派生したオブジェクトをコピーすると、余分な不要なプロパティが発生することに気付きました。 私は自分のリテラルで構成されたオブジェクトの1つをコピーしているので、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="6a18864f24ad3607c14646fe8b7ea199e0cfa3b2" translate="yes" xml:space="preserve">
          <source>I just wanted to add to all the &lt;code&gt;Object.create&lt;/code&gt; solutions in this post, that this does not work in the desired way with nodejs.</source>
          <target state="translated">この投稿のすべての &lt;code&gt;Object.create&lt;/code&gt; ソリューションに追加したかったのは、これがnodejsで希望どおりに機能しないことです。</target>
        </trans-unit>
        <trans-unit id="0e8d9e15a95057e936855612d02338a65a9ae821" translate="yes" xml:space="preserve">
          <source>I think there is a simple and working answer. In deep copying there are two concerns:</source>
          <target state="translated">シンプルで実用的な答えがあると思います。ディープコピーでは2つの懸念があります。</target>
        </trans-unit>
        <trans-unit id="941624dec0eec1e76a1ffed0d1cbb9418daa899a" translate="yes" xml:space="preserve">
          <source>I want to &lt;strong&gt;deep-copy&lt;/strong&gt; a Javascript &lt;code&gt;Object&lt;/code&gt; with all of its children and their children and so on. But since I'm not kind of a normal developer, my &lt;code&gt;Object&lt;/code&gt; has &lt;em&gt;normal&lt;/em&gt;&lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and even &lt;code&gt;nested objects&lt;/code&gt;.</source>
          <target state="translated">すべての子とその子などを含むJavascript &lt;code&gt;Object&lt;/code&gt; を&lt;strong&gt;ディープコピーし&lt;/strong&gt;たい。 しかし、私は普通の開発者ではないので、私の &lt;code&gt;Object&lt;/code&gt; は&lt;em&gt;通常の&lt;/em&gt; &lt;code&gt;properties&lt;/code&gt; 、 &lt;code&gt;circular structures&lt;/code&gt; 、さらには &lt;code&gt;nested objects&lt;/code&gt; さえ含まれています 。</target>
        </trans-unit>
        <trans-unit id="492eceb4047550ce310e991adf6cd7624ed3faaa" translate="yes" xml:space="preserve">
          <source>I've put &lt;code&gt;F&lt;/code&gt; outside the scope so we can have a look at what &lt;code&gt;instanceof&lt;/code&gt; tells us.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; をスコープの外に置いたので、 &lt;code&gt;instanceof&lt;/code&gt; が何を伝えているかを確認できます 。</target>
        </trans-unit>
        <trans-unit id="a429ab5caa7c00e09548791ed612fdfcc5894e19" translate="yes" xml:space="preserve">
          <source>I've written my own implementation. Not sure if it counts as a better solution:</source>
          <target state="translated">私自身の実装を書いてみました。それがより良い解決策としてカウントされるかどうかはわかりません。</target>
        </trans-unit>
        <trans-unit id="dafdc35a46a4c2d0195d973a1d3318e6698831c0" translate="yes" xml:space="preserve">
          <source>If the object is XML DOM element, we must use &lt;strong&gt;cloneNode&lt;/strong&gt; instead</source>
          <target state="translated">オブジェクトがXML DOM要素の場合、代わりに&lt;strong&gt;cloneNode&lt;/strong&gt;を使用する&lt;strong&gt;必要が&lt;/strong&gt;あります</target>
        </trans-unit>
        <trans-unit id="ae8354bc788c660711b68a4fa1e2850f3185cab9" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, undefined, regExp or Infinity within your object, a very simple one liner is &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt;:</source>
          <target state="translated">オブジェクト内で &lt;code&gt;Date&lt;/code&gt; 、functions、undefined、regExp、またはInfinityを使用しない場合、非常に単純な1つのライナーは &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bfd3f2d16bba73dae97290f3a239238665ccfc4c" translate="yes" xml:space="preserve">
          <source>If you want shallow copy, use &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</source>
          <target state="translated">浅いコピーが必要な場合は、 &lt;code&gt;Object.assign({}, a)&lt;/code&gt; 使用します</target>
        </trans-unit>
        <trans-unit id="253989d793a4111415e3d9230d7ab2071f59e3ac" translate="yes" xml:space="preserve">
          <source>If you're okay with a shallow copy, the underscore.js library has a &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">浅いコピーで問題がない場合は、underscore.jsライブラリに&lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt;メソッドがあります。</target>
        </trans-unit>
        <trans-unit id="4bf6911de6ff08405b3d088604f2d3601613b4cb" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2018</source>
          <target state="translated">ECMAScript 2018では</target>
        </trans-unit>
        <trans-unit id="1defc59fd72a11aff1734e0a2e2a22f0a4abab4d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 6 there is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method, which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">ECMAScript 6には、列挙可能なすべての独自のプロパティの値を1つのオブジェクトから別のオブジェクトにコピーする&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt;メソッドがあります。 例えば：</target>
        </trans-unit>
        <trans-unit id="f304990021e58b1d1ff5e13fb83eed4bf99dd0d2" translate="yes" xml:space="preserve">
          <source>In ES-6 you can simply use Object.assign(...).
Ex:</source>
          <target state="translated">ES-6では、Object.assign(...)を使用することができます。例:Object.assign(...)を使用します。</target>
        </trans-unit>
        <trans-unit id="2c92ac88d5767f5e56ba7636924db58532bd9c70" translate="yes" xml:space="preserve">
          <source>In Firefox the result of</source>
          <target state="translated">Firefoxでは</target>
        </trans-unit>
        <trans-unit id="3c2ea368e40e7bb729de18cbee756fb95f6ea1f5" translate="yes" xml:space="preserve">
          <source>In addition to non-enumerable attributes, you'll encounter a tougher problem when you try to copy objects that have hidden properties. For example, &lt;code&gt;prototype&lt;/code&gt; is a hidden property of a function. Also, an object's prototype is referenced with the attribute &lt;code&gt;__proto__&lt;/code&gt;, which is also hidden, and will not be copied by a for/in loop iterating over the source object's attributes. I think &lt;code&gt;__proto__&lt;/code&gt; might be specific to Firefox's JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don't know of any way to discover it automatically.</source>
          <target state="translated">列挙できない属性に加えて、非表示のプロパティを持つオブジェクトをコピーしようとすると、より困難な問題が発生します。 たとえば、 &lt;code&gt;prototype&lt;/code&gt; は関数の隠しプロパティです。 また、オブジェクトのプロトタイプは属性 &lt;code&gt;__proto__&lt;/code&gt; で参照されますが、これも非表示であり、ソースオブジェクトの属性を反復するfor / inループによってコピーされません。 &lt;code&gt;__proto__&lt;/code&gt; は、FirefoxのJavaScriptインタープリターに固有のものであり、他のブラウザーでは異なるものと思われるかもしれませんが、状況はわかります。 すべてが列挙可能というわけではありません。 非表示の属性は、名前がわかっていればコピーできますが、自動的に検出する方法はわかりません。</target>
        </trans-unit>
        <trans-unit id="af3b62758b3b5aad9f8bb2a67a63a6b1276c2744" translate="yes" xml:space="preserve">
          <source>In nodejs it is</source>
          <target state="translated">nodejsでは</target>
        </trans-unit>
        <trans-unit id="8070d65a107f7a0001017aa494dfb78ff6d01341" translate="yes" xml:space="preserve">
          <source>Inspired by A.Levy's exhaustive study and Calvin's prototyping approach, I offer this solution:</source>
          <target state="translated">A.Levyの徹底的な研究とCalvinのプロトタイピングのアプローチに触発されて、私はこの解決策を提案します。</target>
        </trans-unit>
        <trans-unit id="9bfe4aadd640d727c541e4a74de4c537bf9603c9" translate="yes" xml:space="preserve">
          <source>Interested in cloning simple objects:</source>
          <target state="translated">単純なオブジェクトのクローニングに興味がある。</target>
        </trans-unit>
        <trans-unit id="06837f1236b49354891013f198510b9ba4fc2ab5" translate="yes" xml:space="preserve">
          <source>It will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don't assume that it will just work for anything you throw at it.</source>
          <target state="translated">どんなJavaScriptオブジェクトでも扱えるわけではありませんが、何を投げても動作すると決めつけない限り、多くの目的には十分かもしれません。</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c5f79a04d00332bcef73e7c25ac76cc77265d5d3" translate="yes" xml:space="preserve">
          <source>JavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:</source>
          <target state="translated">JavaScriptは実はディープクローンをネイティブにサポートしていません。ユーティリティ関数を使用してください。例えばRamda。</target>
        </trans-unit>
        <trans-unit id="6c8086021c6a372b4809189f81b1a61b9f2eeea4" translate="yes" xml:space="preserve">
          <source>JavaScript keeps evolving.</source>
          <target state="translated">進化し続けるJavaScript。</target>
        </trans-unit>
        <trans-unit id="898c396720398ab086b937719a5cb546261e8435" translate="yes" xml:space="preserve">
          <source>Keep properties independent to each other.</source>
          <target state="translated">プロパティはお互いに独立したものにしておきましょう。</target>
        </trans-unit>
        <trans-unit id="f9cd6e333924ef28d1cf1cb192e551179543718e" translate="yes" xml:space="preserve">
          <source>Let's bring everything together in an &lt;code&gt;Object&lt;/code&gt; named &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">という名前 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;Object&lt;/code&gt; すべてをまとめましょう。</target>
        </trans-unit>
        <trans-unit id="b8aaf1df286d5ef5e319286978f2d4a622c5dd52" translate="yes" xml:space="preserve">
          <source>Let's have a look at the accepted answer.</source>
          <target state="translated">受け入れられた答えを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3440d2c76fb94711deb530c695895ec6080f7195" translate="yes" xml:space="preserve">
          <source>Looks good, heh? It's a recursive copy of the object and handles other types as well, like &lt;code&gt;Date&lt;/code&gt;, but that wasn't a requirement.</source>
          <target state="translated">よさそうですね これはオブジェクトの再帰的なコピーであり、 &lt;code&gt;Date&lt;/code&gt; などの他のタイプも処理しますが、これは必須ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="4401b855280cd9542719b7c0ccaf34205cee9587" translate="yes" xml:space="preserve">
          <source>More in angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;documentation&lt;/a&gt;...</source>
          <target state="translated">angular.copyの&lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;ドキュメントの&lt;/a&gt;詳細...</target>
        </trans-unit>
        <trans-unit id="dade8dcd2b43a64b756eff141607bc6874a514ce" translate="yes" xml:space="preserve">
          <source>New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt;, it's easy.</source>
          <target state="translated">古い質問への新しい答え！ ECMAScript 2016（ES6）を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt;で使用する喜びがあれば、それは簡単です。</target>
        </trans-unit>
        <trans-unit id="13e3b18e3972aab20fc4c36853cd1d0b35875d96" translate="yes" xml:space="preserve">
          <source>Next, we want to copy &lt;code&gt;a&lt;/code&gt; into a variable named &lt;code&gt;b&lt;/code&gt; and mutate it.</source>
          <target state="translated">次に、 &lt;code&gt;b&lt;/code&gt; という名前の変数にコピー &lt;code&gt;a&lt;/code&gt; て変更します。</target>
        </trans-unit>
        <trans-unit id="dc14249af7e109f4fde91ed60eb8e84255d155bd" translate="yes" xml:space="preserve">
          <source>Now let's find a solution.</source>
          <target state="translated">では、解決策を探してみましょう。</target>
        </trans-unit>
        <trans-unit id="4d1dae1e39568ce239fd2a7fc3a8cf3c550df25c" translate="yes" xml:space="preserve">
          <source>Of course, functions do not belong in JSON, so this only works for objects without member methods.</source>
          <target state="translated">もちろん、関数はJSONには属していないので、これはメンバーメソッドを持たないオブジェクトに対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="2366061f7e9ccde0f6899dd5905d19be0299833f" translate="yes" xml:space="preserve">
          <source>One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.</source>
          <target state="translated">特に不合理な解決策としては、JSONエンコーディングを使用して、メンバーメソッドを持たないオブジェクトの深いコピーを作成することです。その方法論は、ターゲットのオブジェクトをJSONエンコードし、それをデコードすることで、探しているコピーを得るというものです。必要な数だけコピーを作るために、何度でもデコードすることができます。</target>
        </trans-unit>
        <trans-unit id="b5e7cf65ae4060f78ce8aa1b4ed6c66bf3442b4e" translate="yes" xml:space="preserve">
          <source>Or to make a &lt;strong&gt;deep copy&lt;/strong&gt;:</source>
          <target state="translated">または、 &lt;strong&gt;深いコピーを作成するには&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="c5035e794e31882d47ef1d6b8595571334a62a63" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt;ごと：</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">読んでみてください...続きを読む</target>
        </trans-unit>
        <trans-unit id="b70d8b981e5c20ee4900b1d547ab578ea9f8c800" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;code&gt;circular structures&lt;/code&gt; doesn't work well together... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</source>
          <target state="translated">再帰と &lt;code&gt;circular structures&lt;/code&gt; が一緒に機能しない... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f0db5294c0b0127ed78e8534a588a4da9a4ea8" translate="yes" xml:space="preserve">
          <source>Recursive copy &lt;em&gt;(the accepted &quot;answer&quot;)&lt;/em&gt;</source>
          <target state="translated">再帰コピー&lt;em&gt;（受け入れられた「回答」）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461c16fdd9cf991abb778545c3d4ab00c017168c" translate="yes" xml:space="preserve">
          <source>Same problem as the &lt;em&gt;native solution&lt;/em&gt;, but a little bit worse output.</source>
          <target state="translated">&lt;em&gt;ネイティブソリューション&lt;/em&gt;と同じ問題&lt;em&gt;です&lt;/em&gt;が、出力は少し悪いです。</target>
        </trans-unit>
        <trans-unit id="796baa07c71d736d03895eacc42e11d3d30a4b20" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;this article about the structured clone algorithm of browsers&lt;/a&gt; which is used when posting messages to and from a worker. It also contains a function for deep cloning.</source>
          <target state="translated">ワーカーとの間でメッセージを投稿するときに使用される&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;ブラウザーの構造化クローンアルゴリズムに関するこの記事&lt;/a&gt;も参照してください。 また、ディープクローニング用の関数も含まれています。</target>
        </trans-unit>
        <trans-unit id="b3ee3c57fb439d18c03172ee7afacf0e99f6105f" translate="yes" xml:space="preserve">
          <source>See also Andy Burke's note in the answers.</source>
          <target state="translated">アンディ・バークさんの回答のメモも参照してください。</target>
        </trans-unit>
        <trans-unit id="454f14f00bca91bc2a843967363a76e24887bba3" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; stated that the object to be cloned is a 'literal-constructed' object, a solution might be to simply &lt;em&gt;generate&lt;/em&gt; the object multiple times rather than cloning an instance of the object:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt;は、複製されるオブジェクトは「リテラル構築された」オブジェクトであると述べたので、解決策は、オブジェクトのインスタンスを複製するのではなく、単にオブジェクトを複数回&lt;em&gt;生成する&lt;/em&gt;ことかもしれません：</target>
        </trans-unit>
        <trans-unit id="7073615569ad59804a8d64877706cc2ee7c1a1ec" translate="yes" xml:space="preserve">
          <source>So I think one simple solution will be to first serialize and deserialize and then do an assign on it to copy functions too.</source>
          <target state="translated">そこで、私が考える簡単な解決策は、最初にシリアライズしてデシリアライズして、関数をコピーするために代入を行うことだと思います。</target>
        </trans-unit>
        <trans-unit id="b77e5c1be59f320b6042fdf12c140f63ab1a4003" translate="yes" xml:space="preserve">
          <source>So let's create a &lt;code&gt;circular structure&lt;/code&gt; and a &lt;code&gt;nested object&lt;/code&gt; first.</source>
          <target state="translated">それでは、最初に &lt;code&gt;circular structure&lt;/code&gt; と &lt;code&gt;nested object&lt;/code&gt; 作成しましょう。</target>
        </trans-unit>
        <trans-unit id="a1e5d5e7a575e6d613efa42edbbd2bd59577f137" translate="yes" xml:space="preserve">
          <source>Some quick tests</source>
          <target state="translated">いくつかの迅速なテスト</target>
        </trans-unit>
        <trans-unit id="1ad81ed3b31b89f94fdfb8b814a7b408c0ce4ac4" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;How to copy JavaScript object to new variable NOT by reference?&lt;/a&gt;</source>
          <target state="translated">ソース： &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;JavaScriptオブジェクトを参照ではなく新しい変数にコピーする方法は？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">古いブラウザをサポートするための&lt;strong&gt;ポリフィル&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">Object.assign()メソッドは、列挙可能なすべての自身のプロパティの値を、1 つ以上のソース・オブジェクトからターゲット・オブジェクトにコピーするために使用されます。</target>
        </trans-unit>
        <trans-unit id="8a4308022632fbf96a189f60d4c089e47657082a" translate="yes" xml:space="preserve">
          <source>The above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn't more than one reference to the same data in the object. For example:</source>
          <target state="translated">上記の関数は、オブジェクトと配列のデータがツリー構造を形成している限り、私が挙げた6つの単純な型に対しては十分に機能します。つまり、オブジェクト内の同じデータへの参照が複数存在しないということです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="032b503078d9391f3f083e20a6246421123e2d8b" translate="yes" xml:space="preserve">
          <source>The date string for &lt;code&gt;d1&lt;/code&gt; will be 5 seconds behind that of &lt;code&gt;d2&lt;/code&gt;. A way to make one &lt;code&gt;Date&lt;/code&gt; the same as another is by calling the &lt;code&gt;setTime&lt;/code&gt; method, but that is specific to the &lt;code&gt;Date&lt;/code&gt; class. I don't think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!</source>
          <target state="translated">&lt;code&gt;d1&lt;/code&gt; の日付文字列は、 &lt;code&gt;d2&lt;/code&gt; の日付文字列より5秒遅れます。 1つの &lt;code&gt;Date&lt;/code&gt; を別の日付と同じにする方法は、 &lt;code&gt;setTime&lt;/code&gt; メソッドを呼び出すことですが、これは &lt;code&gt;Date&lt;/code&gt; クラスに固有です。 私は間違っていても大丈夫ですが、この問題に対する防弾総合的な解決策はないと思います！</target>
        </trans-unit>
        <trans-unit id="043746030e244c05064aabe5e6c53eb1b00a3576" translate="yes" xml:space="preserve">
          <source>The first attempt I tried was using &lt;code&gt;JSON&lt;/code&gt;.</source>
          <target state="translated">私が試した最初の試みは &lt;code&gt;JSON&lt;/code&gt; を使用することでした。</target>
        </trans-unit>
        <trans-unit id="9f000a225c9b05dc90c944d0aaba92c15349755d" translate="yes" xml:space="preserve">
          <source>The last solution using recursion and a cache, may not be the best, but it's a &lt;strong&gt;real&lt;/strong&gt; deep-copy of the object. It handles simple &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and &lt;code&gt;nested object&lt;/code&gt;, but it will mess up the instance of them while cloning.</source>
          <target state="translated">再帰とキャッシュを使用する最後のソリューションは最善ではないかもしれませんが、それはオブジェクトの&lt;strong&gt;実際の&lt;/strong&gt;ディープコピーです。 単純な &lt;code&gt;properties&lt;/code&gt; 、 &lt;code&gt;circular structures&lt;/code&gt; 、 &lt;code&gt;nested object&lt;/code&gt; 処理しますが、複製中にそれらのインスタンスを混乱させます。</target>
        </trans-unit>
        <trans-unit id="d2e920fb16fae1fedca17a36ec3baa9202cbb72d" translate="yes" xml:space="preserve">
          <source>The requirements are matched, but there are still some smaller issues, including changing the &lt;code&gt;instance&lt;/code&gt; of &lt;code&gt;nested&lt;/code&gt; and &lt;code&gt;circ&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">要件は一致してい &lt;code&gt;instance&lt;/code&gt; 、 &lt;code&gt;nested&lt;/code&gt; たインスタンスと &lt;code&gt;circ&lt;/code&gt; の インスタンスを &lt;code&gt;Object&lt;/code&gt; に変更するなど、まだいくつかの小さな問題があります 。</target>
        </trans-unit>
        <trans-unit id="29a4e57a808e70c1984cd4b7435f7b3b8f879529" translate="yes" xml:space="preserve">
          <source>The structure of trees that share a leaf won't be copied, they will become two independent leaves:</source>
          <target state="translated">葉を共有する木の構造はコピーされず、独立した2枚の葉になります。</target>
        </trans-unit>
        <trans-unit id="13a953842279c7fd9c49eb420b7ea3060cfc3c9f" translate="yes" xml:space="preserve">
          <source>There are many answers, but none that mentions &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.</source>
          <target state="translated">多くの答えがありますが、ECMAScript 5の&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt;について言及しているものはありません。確かに正確なコピーは提供されませんが、新しいオブジェクトのプロトタイプとしてソースが設定されます。</target>
        </trans-unit>
        <trans-unit id="cc7af0c92f6e6c0d9df4aaa342be3e26c98b8b64" translate="yes" xml:space="preserve">
          <source>There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn't be accepted.</source>
          <target state="translated">ネット上のほとんどの解答にはいくつかの問題があります。そこで私は、なぜ受け入れられた答えが受け入れられてはいけないのかを含めて、フォローアップをすることにしました。</target>
        </trans-unit>
        <trans-unit id="2138887f9e1a5984c4ac16aa3859fe4f272a050d" translate="yes" xml:space="preserve">
          <source>There is no need for external libraries but you need to check &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;browser compatibility first&lt;/a&gt;.</source>
          <target state="translated">外部ライブラリは必要ありませんが、 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;最初にブラウザの互換性&lt;/a&gt;を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="f6df6c28aa1c494acefc67b48ca65405704b89a2" translate="yes" xml:space="preserve">
          <source>There's a polyfill for &lt;code&gt;Object.create&lt;/code&gt; in the older browser just like the IE 8. It's something like recommended by Mozilla, and of course, it's not perfect and results in the same problem as the &lt;em&gt;native solution&lt;/em&gt;.</source>
          <target state="translated">IE 8と同じように、古いブラウザーには &lt;code&gt;Object.create&lt;/code&gt; のポリフィルがあります。これは、Mozillaが推奨するようなものです。もちろん、完璧ではなく、 &lt;em&gt;ネイティブソリューション&lt;/em&gt;と同じ問題が発生し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="257b97895de4343bd020da12619838edee113900" translate="yes" xml:space="preserve">
          <source>This is an adaptation of A. Levy's code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)</source>
          <target state="translated">これは、A.Levyのコードを適応させて、関数の複製と複数の環状参照を扱うようにしたものです。これが意味するのは、複製されるツリー内の2つのプロパティが同じオブジェクトの参照である場合、複製されるオブジェクトツリーは、これらのプロパティが参照されるオブジェクトの1つの同じ複製を指すようになるということです。これはまた、処理されないままにしておくと無限ループになる周期的な依存性のケースを解決します。アルゴリズムの複雑さはO(n)</target>
        </trans-unit>
        <trans-unit id="3aeab4233dd61158490346563a83710fdb174f9f" translate="yes" xml:space="preserve">
          <source>This methodology was perfect for my use case, since I'm storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.</source>
          <target state="translated">この方法論は私のユースケースにぴったりでした。なぜなら、JSON blobをキー値ストアに保存しているからで、JavaScript APIでオブジェクトとして公開されたときに、各オブジェクトにはオブジェクトの元の状態のコピーが含まれているので、呼び出し元が公開されたオブジェクトを変異させた後にデルタを計算することができます。</target>
        </trans-unit>
        <trans-unit id="270c07e5aba6d333e589186ebce926ac9488ae45" translate="yes" xml:space="preserve">
          <source>This provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.</source>
          <target state="translated">これは、オブジェクトの浅いコピーのためのクリーンなメソッドを提供します。深いコピーを作成する、つまり再帰的に入れ子になっているオブジェクトのすべての値の新しいコピーを作成するには、上記のより重い解決策が必要です。</target>
        </trans-unit>
        <trans-unit id="c3d98944d47265d765fc5c22fd2d0a49ddc89117" translate="yes" xml:space="preserve">
          <source>This solution was added to Javascript some time ago and even handles &lt;code&gt;circular structure&lt;/code&gt;.</source>
          <target state="translated">このソリューションは少し前にJavaScriptに追加され、 &lt;code&gt;circular structure&lt;/code&gt; も処理します。</target>
        </trans-unit>
        <trans-unit id="d709893b9322713175a8239aabd951c8aa101e46" translate="yes" xml:space="preserve">
          <source>This works for all kind of objects containing objects, arrays, strings, booleans and numbers.</source>
          <target state="translated">これは、オブジェクト、配列、文字列、ブーリアン、数値を含むすべての種類のオブジェクトで動作します。</target>
        </trans-unit>
        <trans-unit id="be7e283523bee098c95fbd259fdb185444007880" translate="yes" xml:space="preserve">
          <source>Thus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:</source>
          <target state="translated">このように、これは厳密な答えではありませんが、一行で解答できるのでエレガントです。そして、それは2つのケースに最適に働きます。</target>
        </trans-unit>
        <trans-unit id="b36783ae8f97bf075d43eb8bdee3e68cae031c5d" translate="yes" xml:space="preserve">
          <source>To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object's prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a &lt;code&gt;clone&lt;/code&gt; method to &lt;code&gt;Object.prototype&lt;/code&gt;, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to &lt;code&gt;Object.prototype&lt;/code&gt;, or other intermediate prototypes, that you don't know about? In that case, you will copy attributes you shouldn't, so you need to detect unforeseen, non-local attributes with the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">JavaScriptのオブジェクトに対してこれを行うのは、単純でも簡単でもありません。 プロトタイプに残しておき、新しいインスタンスにコピーしてはならないオブジェクトのプロトタイプから誤って属性を取得する問題に遭遇します。 たとえば、 &lt;code&gt;Object.prototype&lt;/code&gt; に &lt;code&gt;clone&lt;/code&gt; メソッドを追加する場合、いくつかの回答が示すように、その属性を明示的にスキップする必要があります。 しかし、 &lt;code&gt;Object.prototype&lt;/code&gt; や他の中間プロトタイプに、知らない他のメソッドが追加されているとしたらどうでしょうか。 その場合は、不要な属性をコピーするので、 &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;hasOwnProperty&lt;/code&gt; &lt;/a&gt;メソッドを使用して、予期しないローカルでない属性を検出する必要があります。</target>
        </trans-unit>
        <trans-unit id="a913fb7183b6fb881c9a823ab39998ee4aa93f87" translate="yes" xml:space="preserve">
          <source>Using Lodash:</source>
          <target state="translated">ローダッシュを使って</target>
        </trans-unit>
        <trans-unit id="ca5a4f97de6e6ecec887d15f3ba764fe9304dac1" translate="yes" xml:space="preserve">
          <source>When I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; would also be one of the 6 simple types in that list. This can be accomplished with code like the following:</source>
          <target state="translated">一般的なディープコピーを実装する必要があったとき、単純な &lt;code&gt;Object&lt;/code&gt; 、 &lt;code&gt;Array&lt;/code&gt; 、 &lt;code&gt;Date&lt;/code&gt; 、 &lt;code&gt;String&lt;/code&gt; 、 &lt;code&gt;Number&lt;/code&gt; 、または &lt;code&gt;Boolean&lt;/code&gt; のみをコピーする必要があると想定して、妥協してしまいました。 最後の3つのタイプは不変なので、浅いコピーを実行でき、変更が心配されません。 さらに、 &lt;code&gt;Object&lt;/code&gt; または &lt;code&gt;Array&lt;/code&gt; に含まれるすべての要素も、そのリストの6つの単純な型の1つであると想定しました。 これは、次のようなコードで実現できます。</target>
        </trans-unit>
        <trans-unit id="456e0fb41b68296ae4fca0c5da8c6c8c99b050d9" translate="yes" xml:space="preserve">
          <source>When digging around, I found a similar question (&lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;In Javascript, when performing a deep copy, how do I avoid a cycle, due to a property being &quot;this&quot;?&lt;/a&gt;) to this one, but with a way better solution.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;調べて&lt;/a&gt;みると、これに似た質問（ Javascriptでは、深いコピーを実行するときに、プロパティが「これ」であるためにサイクルを回避するにはどうすればよいですか？ ）</target>
        </trans-unit>
        <trans-unit id="a9252c930b2a9734d9944f251662812bcd0d5878" translate="yes" xml:space="preserve">
          <source>Where such inheritance is useful (duh!)</source>
          <target state="translated">そんな相続が役に立つところ(ダッ!)。</target>
        </trans-unit>
        <trans-unit id="f3f6684c458c70cb9d8e7a984298d711252184ac" translate="yes" xml:space="preserve">
          <source>Where the source object won't be modified, thus making the relation between the 2 objects a non issue.</source>
          <target state="translated">ソースオブジェクトが変更されないところでは、2つのオブジェクト間の関係は問題になりません。</target>
        </trans-unit>
        <trans-unit id="2735aa18f20ac2191686e23824f2e5be39288c5c" translate="yes" xml:space="preserve">
          <source>Why do I consider this solution to be superior? It's native, thus no looping, no recursion. However, older browsers will need a polyfill.</source>
          <target state="translated">なぜこのソリューションが優れていると思うのか?ネイティブなので、ループや再帰がありません。しかし、古いブラウザではポリフィルが必要になります。</target>
        </trans-unit>
        <trans-unit id="c4313b8450309f35ea2494e7d2513a055de02aeb" translate="yes" xml:space="preserve">
          <source>With jQuery, you can &lt;strong&gt;shallow copy&lt;/strong&gt; with &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;:</source>
          <target state="translated">jQueryでは、 &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;を使用して&lt;strong&gt;浅いコピー&lt;/strong&gt;を&lt;strong&gt;作成&lt;/strong&gt;できます。</target>
        </trans-unit>
        <trans-unit id="dc955433235b02b7f40b76eb1d7dfddf892c4a6e" translate="yes" xml:space="preserve">
          <source>Yet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object's prototype is &lt;code&gt;Object&lt;/code&gt;, then simply creating a new general object with &lt;code&gt;{}&lt;/code&gt; will work, but if the source's prototype is some descendant of &lt;code&gt;Object&lt;/code&gt;, then you are going to be missing the additional members from that prototype which you skipped using the &lt;code&gt;hasOwnProperty&lt;/code&gt; filter, or which were in the prototype, but weren't enumerable in the first place. One solution might be to call the source object's &lt;code&gt;constructor&lt;/code&gt; property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object stores its data as a hidden member:</source>
          <target state="translated">エレガントなソリューションを求めるもう1つの問題は、プロトタイプ継承を正しく設定する問題です。 ソースオブジェクトのプロトタイプが &lt;code&gt;Object&lt;/code&gt; の場合、 &lt;code&gt;{}&lt;/code&gt; を使用して新しい一般オブジェクトを作成するだけで機能しますが、ソースのプロトタイプが &lt;code&gt;Object&lt;/code&gt; の子孫である場合は、そのプロトタイプから、使用してスキップした追加のメンバーが失われます。 &lt;code&gt;hasOwnProperty&lt;/code&gt; フィルター、またはプロトタイプにありましたが、最初は列挙できませんでした。 1つの解決策は、ソースオブジェクトの &lt;code&gt;constructor&lt;/code&gt; プロパティを呼び出して初期コピーオブジェクトを取得してから属性をコピーすることですが、それでも列挙できない属性は取得されません。 たとえば、 &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;オブジェクトはそのデータを非表示のメンバーとして保存します。</target>
        </trans-unit>
        <trans-unit id="f6ada691f9c830b134d1063e166e1d147221dcb3" translate="yes" xml:space="preserve">
          <source>You can clone an object and remove any reference from the previous one using a single line of code. Simply do:</source>
          <target state="translated">オブジェクトのクローンを作成して、一行のコードで前のオブジェクトから参照を削除することができます。単純に実行してください。</target>
        </trans-unit>
        <trans-unit id="2fb59e1d6040b949307491685dc51fd64aac4887" translate="yes" xml:space="preserve">
          <source>You can simply use a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;spread property&lt;/a&gt; to copy an object without references. But be careful (see comments), the 'copy' is just on the lowest object/array level. Nested properties are still references!</source>
          <target state="translated">単純に、 &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;spreadプロパティ&lt;/a&gt;を使用して、参照なしでオブジェクトをコピーできます。 ただし、注意してください（コメントを参照）。「コピー」はオブジェクト/配列の最下位レベルにあります。 ネストされたプロパティはまだ参照です！</target>
        </trans-unit>
        <trans-unit id="9abb2632977048faaf1083e1bdfe1addfa67decb" translate="yes" xml:space="preserve">
          <source>You know what happened here because if not you wouldn't even land on this great question.</source>
          <target state="translated">ここで何があったか知っているだろう、そうでなければ、この偉大な質問にさえ着地しなかっただろうから。</target>
        </trans-unit>
        <trans-unit id="6a38a38f03e4ff5839ba4a879178cce5bc42666b" translate="yes" xml:space="preserve">
          <source>conclusion</source>
          <target state="translated">conclusion</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="716e96afcc9beb903225a881db7f167667cc2eb3" translate="yes" xml:space="preserve">
          <source>jsfiddle</source>
          <target state="translated">jsfiddle</target>
        </trans-unit>
        <trans-unit id="352f260ed32601f2720cbdef8b42f9882a4102af" translate="yes" xml:space="preserve">
          <source>native solution</source>
          <target state="translated">ネイティブソリューション</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="c5b130d2294080fe3f54b6ede9cb6c33d3a49d6b" translate="yes" xml:space="preserve">
          <source>or using spread operator like this:</source>
          <target state="translated">のようにスプレッド演算子を使用したりします。</target>
        </trans-unit>
        <trans-unit id="82ae245159e159776ea37d68d57ddfa387a83600" translate="yes" xml:space="preserve">
          <source>or you can extend it like</source>
          <target state="translated">のように拡張することもできます。</target>
        </trans-unit>
        <trans-unit id="3e0bf88b357a046b4e7659fed6103de63a9734cd" translate="yes" xml:space="preserve">
          <source>polyfill for the native solution</source>
          <target state="translated">ネイティブソリューション用のポリフィル</target>
        </trans-unit>
        <trans-unit id="55d9bbd3efbab583726fcd7c3ad976b8129b76ee" translate="yes" xml:space="preserve">
          <source>starting situation</source>
          <target state="translated">しょじょじょうたい</target>
        </trans-unit>
        <trans-unit id="a5f7a257ae51fb7db8f01b3b457418d96c6a2a00" translate="yes" xml:space="preserve">
          <source>subsequent changes to the &lt;code&gt;copiedObject&lt;/code&gt; will not affect the &lt;code&gt;originalObject&lt;/code&gt;, and vice versa.</source>
          <target state="translated">以降の &lt;code&gt;copiedObject&lt;/code&gt; されたオブジェクトへの変更は、 元のオブジェクトには影響しません。逆も同様です。</target>
        </trans-unit>
        <trans-unit id="2ba1210fdf174274ea55c483bb6ade889c52e126" translate="yes" xml:space="preserve">
          <source>the answer is mainly depeneds on which &lt;strong&gt;ECMAscript&lt;/strong&gt; you using, in &lt;code&gt;ES6+&lt;/code&gt;, you can simply use &lt;code&gt;Object.assign&lt;/code&gt; to do the clone:</source>
          <target state="translated">答えは主に、使用する &lt;code&gt;Object.assign&lt;/code&gt; します。ES6 &lt;code&gt;ES6+&lt;/code&gt; では、 Object.assignを使用してクローンを作成できます。</target>
        </trans-unit>
        <trans-unit id="522547b9c4325ca856f8c4192d0ad23de9c33613" translate="yes" xml:space="preserve">
          <source>the better (but not perfect) solution</source>
          <target state="translated">ベターソリューション</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
