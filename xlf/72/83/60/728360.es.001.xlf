<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/728360">
    <body>
      <group id="728360">
        <trans-unit id="5fff870d002057a570c5f54f6e0583f072249e21" translate="yes" xml:space="preserve">
          <source>... and you see, it didn't work with the nested structure inside.</source>
          <target state="translated">...y verás,no funcionó con la estructura anidada en el interior.</target>
        </trans-unit>
        <trans-unit id="fdf1515d42ec5590b0b9470e710e5a34edb33d3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="f8d42eb23fc0b5363fad3b52a8388240db181867" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clone with references on second level:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Clon con referencias en segundo nivel:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cea8c7ca59555849767060049632be16cd783d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete clone:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Clon completo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6966d0f501ab4b788d3ea14f276d58f9c181e993" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; imagine you have this object below and you want to clone it:</source>
          <target state="translated">&lt;strong&gt;OK,&lt;/strong&gt; imagina que tienes este objeto a continuaci&amp;oacute;n y quieres clonarlo:</target>
        </trans-unit>
        <trans-unit id="22efe12cc8badd5b62cb63cbb32d48a03bfc69b9" translate="yes" xml:space="preserve">
          <source>A good reference is here:
&lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</source>
          <target state="translated">Una buena referencia est&amp;aacute; aqu&amp;iacute;: &lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31e2fbcb0256c7808f1ca3a03007c73a654f8c07" translate="yes" xml:space="preserve">
          <source>A.Levy's answer is almost complete, here is my little contribution: &lt;strong&gt;there is a way how to handle recursive references&lt;/strong&gt;, see this line</source>
          <target state="translated">La respuesta de R. Levy est&amp;aacute; casi completa, aqu&amp;iacute; est&amp;aacute; mi peque&amp;ntilde;a contribuci&amp;oacute;n: &lt;strong&gt;hay una manera de manejar referencias recursivas&lt;/strong&gt; , vea esta l&amp;iacute;nea</target>
        </trans-unit>
        <trans-unit id="75589da17d1b2a78b18aaddcd6a610f24da00c24" translate="yes" xml:space="preserve">
          <source>After arguing with my co-worker, my boss asked us what happened, and he found a simple &lt;em&gt;solution&lt;/em&gt; after some googling. It's called &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de discutir con mi compa&amp;ntilde;ero de trabajo, mi jefe nos pregunt&amp;oacute; qu&amp;eacute; pas&amp;oacute; y encontr&amp;oacute; una &lt;em&gt;soluci&amp;oacute;n&lt;/em&gt; simple despu&amp;eacute;s de buscar en Google. Se llama &lt;code&gt;Object.create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba29de559b1bb261e25a1d12df67e7d242566aa7" translate="yes" xml:space="preserve">
          <source>Although this question has many answers, I hope this one helps too.</source>
          <target state="translated">Aunque esta pregunta tiene muchas respuestas,espero que ésta también ayude.</target>
        </trans-unit>
        <trans-unit id="af28336e40dc39e63a92abf858f8c6ab4d67e567" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object.assign&lt;/code&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">Un m&amp;eacute;todo &lt;code&gt;Object.assign&lt;/code&gt; es parte del est&amp;aacute;ndar ECMAScript 2015 (ES6) y hace exactamente lo que necesita.</target>
        </trans-unit>
        <trans-unit id="32bfe9e918d4b868492fa92e62f1c551337c8c70" translate="yes" xml:space="preserve">
          <source>An elegant way to clone a Javascript object in one line of code</source>
          <target state="translated">Una forma elegante de clonar un objeto Javascript en una línea de código</target>
        </trans-unit>
        <trans-unit id="896435d8badf2f411e99791401b27e88034dbb6f" translate="yes" xml:space="preserve">
          <source>And keep the methods alive on cloned object.</source>
          <target state="translated">Y mantener los métodos vivos en el objeto clonado.</target>
        </trans-unit>
        <trans-unit id="a19d0a3bf30a88c3fd9012682cd0067268b19a91" translate="yes" xml:space="preserve">
          <source>And let's have a look at the output...</source>
          <target state="translated">Y echemos un vistazo a la salida...</target>
        </trans-unit>
        <trans-unit id="11f375141a5034d16664f0e54b2f1c0b28910f53" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;strong&gt;nested objects&lt;/strong&gt; are still copied &lt;strong&gt;as a reference.&lt;/strong&gt;</source>
          <target state="translated">Tenga en cuenta que los &lt;strong&gt;objetos anidados&lt;/strong&gt; todav&amp;iacute;a se copian &lt;strong&gt;como referencia.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56ecbf1b8827336c51f8306fdb107ae1b4c8f121" translate="yes" xml:space="preserve">
          <source>But be aware that nested objects are still copied as reference.</source>
          <target state="translated">Pero tened en cuenta que los objetos anidados siguen copiándose como referencia.</target>
        </trans-unit>
        <trans-unit id="44d9c60e7ecbda7adb322596b936906b1dded999" translate="yes" xml:space="preserve">
          <source>But if you using &lt;code&gt;ES5&lt;/code&gt;, you can use few methods, but the &lt;code&gt;JSON.stringify&lt;/code&gt;, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:</source>
          <target state="translated">Pero si usa &lt;code&gt;ES5&lt;/code&gt; , puede usar algunos m&amp;eacute;todos, pero &lt;code&gt;JSON.stringify&lt;/code&gt; , solo aseg&amp;uacute;rese de no usar una gran cantidad de datos para copiar, pero podr&amp;iacute;a ser una forma pr&amp;aacute;ctica de l&amp;iacute;nea en muchos casos, algo como esto:</target>
        </trans-unit>
        <trans-unit id="95088399458c196785b80f328382de6f8fa6da7f" translate="yes" xml:space="preserve">
          <source>Don't waste too much time on it, you'll get &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt;.</source>
          <target state="translated">No pierdas demasiado tiempo, obtendr&amp;aacute;s &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2b7b729fd7dfac409f1f5c4781cdc32d799528" translate="yes" xml:space="preserve">
          <source>ES6 solution if you want to (shallow) clone a &lt;strong&gt;class instance&lt;/strong&gt; and not just a property object.</source>
          <target state="translated">Soluci&amp;oacute;n ES6 si desea clonar (superficialmente) una &lt;strong&gt;instancia de clase&lt;/strong&gt; y no solo un objeto de propiedad.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="9d4b3583c599fafbba741d166652892841a76ea3" translate="yes" xml:space="preserve">
          <source>Following is the implementation:</source>
          <target state="translated">Lo que sigue es la aplicación:</target>
        </trans-unit>
        <trans-unit id="6dcc05bb82ad169b245a024fa2181e38169796be" translate="yes" xml:space="preserve">
          <source>For &quot;deep&quot; copy, use &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</source>
          <target state="translated">Para una copia &quot;profunda&quot;, use &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24a73f09717e6302b4ae5cfc392955d30204cefd" translate="yes" xml:space="preserve">
          <source>For a deep copy and clone, JSON.stringify then JSON.parse the object:</source>
          <target state="translated">Para una copia y clonación profunda,JSON.stringify y luego JSON.parse el objeto:</target>
        </trans-unit>
        <trans-unit id="fbe99868375178cc499070d97ef9839eb868985f" translate="yes" xml:space="preserve">
          <source>For browsers / engines that do not currently support Object.create you can use this polyfill:</source>
          <target state="translated">Para los motores de los navegadores que actualmente no soportan Object.create puedes usar este polyfill:</target>
        </trans-unit>
        <trans-unit id="fdfee069d3a9f22467239d1a5c249362ba8bfbc8" translate="yes" xml:space="preserve">
          <source>For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.</source>
          <target state="translated">Para aquellos que usan AngularJS,también hay un método directo para clonar o extender los objetos de esta biblioteca.</target>
        </trans-unit>
        <trans-unit id="bf4ec4c0c298b2a0248ed16c560cae0cb2b2f354" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;How to copy arrays and objects in Javascript&lt;/a&gt; by Brian Huisman:</source>
          <target state="translated">De este art&amp;iacute;culo: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;C&amp;oacute;mo copiar matrices y objetos en Javascript&lt;/a&gt; por Brian Huisman:</target>
        </trans-unit>
        <trans-unit id="73f8555ab7993eb62a7bb80980e5decb72448c9b" translate="yes" xml:space="preserve">
          <source>Here is a function you can use.</source>
          <target state="translated">Aquí hay una función que puede utilizar.</target>
        </trans-unit>
        <trans-unit id="4631d41b7b36fb799786f4a214099e57e5620b0e" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object</source>
          <target state="translated">¿Cómo clono correctamente un objeto JavaScript</target>
        </trans-unit>
        <trans-unit id="743e0eea187a855a15b0996e0b65671bfbe4b6c9" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object?</source>
          <target state="translated">¿Cómo clono correctamente un objeto JavaScript?</target>
        </trans-unit>
        <trans-unit id="001d1eefeee3ed1b4eb51c735f2abbe94cdc6856" translate="yes" xml:space="preserve">
          <source>I have an object, &lt;code&gt;x&lt;/code&gt;. I'd like to copy it as object &lt;code&gt;y&lt;/code&gt;, such that changes to &lt;code&gt;y&lt;/code&gt; do not modify &lt;code&gt;x&lt;/code&gt;. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn't a problem, since I'm copying one of my own literal-constructed objects.</source>
          <target state="translated">Tengo un objeto, &lt;code&gt;x&lt;/code&gt; . Me gustar&amp;iacute;a copiarlo como objeto &lt;code&gt;y&lt;/code&gt; , de modo que los cambios en &lt;code&gt;y&lt;/code&gt; no modifiquen &lt;code&gt;x&lt;/code&gt; . Me di cuenta de que copiar objetos derivados de objetos JavaScript incorporados dar&amp;aacute; como resultado propiedades adicionales no deseadas. Esto no es un problema, ya que estoy copiando uno de mis propios objetos construidos literalmente.</target>
        </trans-unit>
        <trans-unit id="6a18864f24ad3607c14646fe8b7ea199e0cfa3b2" translate="yes" xml:space="preserve">
          <source>I just wanted to add to all the &lt;code&gt;Object.create&lt;/code&gt; solutions in this post, that this does not work in the desired way with nodejs.</source>
          <target state="translated">Solo quer&amp;iacute;a agregar a todas las soluciones &lt;code&gt;Object.create&lt;/code&gt; en esta publicaci&amp;oacute;n, que esto no funciona de la manera deseada con nodejs.</target>
        </trans-unit>
        <trans-unit id="0e8d9e15a95057e936855612d02338a65a9ae821" translate="yes" xml:space="preserve">
          <source>I think there is a simple and working answer. In deep copying there are two concerns:</source>
          <target state="translated">Creo que hay una respuesta simple y funcional.En la copia profunda hay dos preocupaciones:</target>
        </trans-unit>
        <trans-unit id="941624dec0eec1e76a1ffed0d1cbb9418daa899a" translate="yes" xml:space="preserve">
          <source>I want to &lt;strong&gt;deep-copy&lt;/strong&gt; a Javascript &lt;code&gt;Object&lt;/code&gt; with all of its children and their children and so on. But since I'm not kind of a normal developer, my &lt;code&gt;Object&lt;/code&gt; has &lt;em&gt;normal&lt;/em&gt;&lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and even &lt;code&gt;nested objects&lt;/code&gt;.</source>
          <target state="translated">Quiero &lt;strong&gt;copiar&lt;/strong&gt; en &lt;strong&gt;profundidad&lt;/strong&gt; un &lt;code&gt;Object&lt;/code&gt; Javascript con todos sus elementos secundarios y sus elementos secundarios, etc. Pero como no soy un desarrollador normal, mi &lt;code&gt;Object&lt;/code&gt; tiene &lt;code&gt;properties&lt;/code&gt; &lt;em&gt;normales&lt;/em&gt; , &lt;code&gt;circular structures&lt;/code&gt; e incluso &lt;code&gt;nested objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="492eceb4047550ce310e991adf6cd7624ed3faaa" translate="yes" xml:space="preserve">
          <source>I've put &lt;code&gt;F&lt;/code&gt; outside the scope so we can have a look at what &lt;code&gt;instanceof&lt;/code&gt; tells us.</source>
          <target state="translated">Puse a &lt;code&gt;F&lt;/code&gt; fuera del alcance para que podamos ver qu&amp;eacute; &lt;code&gt;instanceof&lt;/code&gt; nos dice.</target>
        </trans-unit>
        <trans-unit id="a429ab5caa7c00e09548791ed612fdfcc5894e19" translate="yes" xml:space="preserve">
          <source>I've written my own implementation. Not sure if it counts as a better solution:</source>
          <target state="translated">He escrito mi propia implementación.No estoy seguro de que cuente como una solución mejor:</target>
        </trans-unit>
        <trans-unit id="dafdc35a46a4c2d0195d973a1d3318e6698831c0" translate="yes" xml:space="preserve">
          <source>If the object is XML DOM element, we must use &lt;strong&gt;cloneNode&lt;/strong&gt; instead</source>
          <target state="translated">Si el objeto es un elemento DOM XML, debemos usar &lt;strong&gt;cloneNode&lt;/strong&gt; en &lt;strong&gt;su&lt;/strong&gt; lugar</target>
        </trans-unit>
        <trans-unit id="ae8354bc788c660711b68a4fa1e2850f3185cab9" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, undefined, regExp or Infinity within your object, a very simple one liner is &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt;:</source>
          <target state="translated">Si no utiliza &lt;code&gt;Date&lt;/code&gt; s, funciones, undefined, regExp o Infinity dentro de su objeto, un revestimiento muy simple es &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfd3f2d16bba73dae97290f3a239238665ccfc4c" translate="yes" xml:space="preserve">
          <source>If you want shallow copy, use &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</source>
          <target state="translated">Si desea una copia superficial, use &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253989d793a4111415e3d9230d7ab2071f59e3ac" translate="yes" xml:space="preserve">
          <source>If you're okay with a shallow copy, the underscore.js library has a &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">Si est&amp;aacute; de acuerdo con una copia superficial, la biblioteca underscore.js tiene un m&amp;eacute;todo de &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clonaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bf6911de6ff08405b3d088604f2d3601613b4cb" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2018</source>
          <target state="translated">En ECMAScript 2018</target>
        </trans-unit>
        <trans-unit id="1defc59fd72a11aff1734e0a2e2a22f0a4abab4d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 6 there is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method, which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">En ECMAScript 6 existe el m&amp;eacute;todo &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; , que copia los valores de todas las propiedades propias enumerables de un objeto a otro. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f304990021e58b1d1ff5e13fb83eed4bf99dd0d2" translate="yes" xml:space="preserve">
          <source>In ES-6 you can simply use Object.assign(...).
Ex:</source>
          <target state="translated">En ES-6 puedes usar simplemente Object.assign(...).Ej:</target>
        </trans-unit>
        <trans-unit id="2c92ac88d5767f5e56ba7636924db58532bd9c70" translate="yes" xml:space="preserve">
          <source>In Firefox the result of</source>
          <target state="translated">En Firefox el resultado de</target>
        </trans-unit>
        <trans-unit id="3c2ea368e40e7bb729de18cbee756fb95f6ea1f5" translate="yes" xml:space="preserve">
          <source>In addition to non-enumerable attributes, you'll encounter a tougher problem when you try to copy objects that have hidden properties. For example, &lt;code&gt;prototype&lt;/code&gt; is a hidden property of a function. Also, an object's prototype is referenced with the attribute &lt;code&gt;__proto__&lt;/code&gt;, which is also hidden, and will not be copied by a for/in loop iterating over the source object's attributes. I think &lt;code&gt;__proto__&lt;/code&gt; might be specific to Firefox's JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don't know of any way to discover it automatically.</source>
          <target state="translated">Adem&amp;aacute;s de los atributos no enumerables, encontrar&amp;aacute; un problema m&amp;aacute;s dif&amp;iacute;cil cuando intente copiar objetos que tienen propiedades ocultas. Por ejemplo, el &lt;code&gt;prototype&lt;/code&gt; es una propiedad oculta de una funci&amp;oacute;n. Adem&amp;aacute;s, se hace referencia al prototipo de un objeto con el atributo &lt;code&gt;__proto__&lt;/code&gt; , que tambi&amp;eacute;n est&amp;aacute; oculto, y no se copiar&amp;aacute; mediante un bucle for / in iterando sobre los atributos del objeto de origen. Creo que &lt;code&gt;__proto__&lt;/code&gt; podr&amp;iacute;a ser espec&amp;iacute;fico para el int&amp;eacute;rprete de JavaScript de Firefox y puede ser algo diferente en otros navegadores, pero entiendes la imagen. No todo es enumerable. Puede copiar un atributo oculto si conoce su nombre, pero no conozco ninguna forma de descubrirlo autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="af3b62758b3b5aad9f8bb2a67a63a6b1276c2744" translate="yes" xml:space="preserve">
          <source>In nodejs it is</source>
          <target state="translated">En los nodejs es</target>
        </trans-unit>
        <trans-unit id="8070d65a107f7a0001017aa494dfb78ff6d01341" translate="yes" xml:space="preserve">
          <source>Inspired by A.Levy's exhaustive study and Calvin's prototyping approach, I offer this solution:</source>
          <target state="translated">Inspirado por el exhaustivo estudio de A.Levy y el enfoque del prototipo de Calvin,ofrezco esta solución:</target>
        </trans-unit>
        <trans-unit id="9bfe4aadd640d727c541e4a74de4c537bf9603c9" translate="yes" xml:space="preserve">
          <source>Interested in cloning simple objects:</source>
          <target state="translated">Interesado en la clonación de objetos simples:</target>
        </trans-unit>
        <trans-unit id="06837f1236b49354891013f198510b9ba4fc2ab5" translate="yes" xml:space="preserve">
          <source>It will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don't assume that it will just work for anything you throw at it.</source>
          <target state="translated">No podrá manejar ningún objeto de JavaScript,pero puede ser suficiente para muchos propósitos siempre y cuando no se asuma que funcionará para cualquier cosa que se le lance.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c5f79a04d00332bcef73e7c25ac76cc77265d5d3" translate="yes" xml:space="preserve">
          <source>JavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:</source>
          <target state="translated">En realidad,JavaScript no soporta los clones profundos de forma nativa.Usa una función de utilidad.Por ejemplo,Ramda:</target>
        </trans-unit>
        <trans-unit id="6c8086021c6a372b4809189f81b1a61b9f2eeea4" translate="yes" xml:space="preserve">
          <source>JavaScript keeps evolving.</source>
          <target state="translated">El JavaScript sigue evolucionando.</target>
        </trans-unit>
        <trans-unit id="898c396720398ab086b937719a5cb546261e8435" translate="yes" xml:space="preserve">
          <source>Keep properties independent to each other.</source>
          <target state="translated">Mantener las propiedades independientes entre sí.</target>
        </trans-unit>
        <trans-unit id="f9cd6e333924ef28d1cf1cb192e551179543718e" translate="yes" xml:space="preserve">
          <source>Let's bring everything together in an &lt;code&gt;Object&lt;/code&gt; named &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Reunamos todo en un &lt;code&gt;Object&lt;/code&gt; llamado &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8aaf1df286d5ef5e319286978f2d4a622c5dd52" translate="yes" xml:space="preserve">
          <source>Let's have a look at the accepted answer.</source>
          <target state="translated">Echemos un vistazo a la respuesta aceptada.</target>
        </trans-unit>
        <trans-unit id="3440d2c76fb94711deb530c695895ec6080f7195" translate="yes" xml:space="preserve">
          <source>Looks good, heh? It's a recursive copy of the object and handles other types as well, like &lt;code&gt;Date&lt;/code&gt;, but that wasn't a requirement.</source>
          <target state="translated">Se ve bien, &amp;iquest;eh? Es una copia recursiva del objeto y tambi&amp;eacute;n maneja otros tipos, como &lt;code&gt;Date&lt;/code&gt; , pero eso no era un requisito.</target>
        </trans-unit>
        <trans-unit id="4401b855280cd9542719b7c0ccaf34205cee9587" translate="yes" xml:space="preserve">
          <source>More in angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;documentation&lt;/a&gt;...</source>
          <target state="translated">M&amp;aacute;s en la &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;documentaci&amp;oacute;n de&lt;/a&gt; angular.copy ...</target>
        </trans-unit>
        <trans-unit id="dade8dcd2b43a64b756eff141607bc6874a514ce" translate="yes" xml:space="preserve">
          <source>New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt;, it's easy.</source>
          <target state="translated">Nueva respuesta a una vieja pregunta! Si tiene el placer de usar ECMAScript 2016 (ES6) con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt; , es f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="13e3b18e3972aab20fc4c36853cd1d0b35875d96" translate="yes" xml:space="preserve">
          <source>Next, we want to copy &lt;code&gt;a&lt;/code&gt; into a variable named &lt;code&gt;b&lt;/code&gt; and mutate it.</source>
          <target state="translated">A continuaci&amp;oacute;n, queremos copiar &lt;code&gt;a&lt;/code&gt; en una variable llamada &lt;code&gt;b&lt;/code&gt; y mutarla.</target>
        </trans-unit>
        <trans-unit id="dc14249af7e109f4fde91ed60eb8e84255d155bd" translate="yes" xml:space="preserve">
          <source>Now let's find a solution.</source>
          <target state="translated">Ahora encontremos una solución.</target>
        </trans-unit>
        <trans-unit id="4d1dae1e39568ce239fd2a7fc3a8cf3c550df25c" translate="yes" xml:space="preserve">
          <source>Of course, functions do not belong in JSON, so this only works for objects without member methods.</source>
          <target state="translated">Por supuesto,las funciones no pertenecen a JSON,así que esto sólo funciona para los objetos sin métodos de miembros.</target>
        </trans-unit>
        <trans-unit id="2366061f7e9ccde0f6899dd5905d19be0299833f" translate="yes" xml:space="preserve">
          <source>One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.</source>
          <target state="translated">Una solución particularmente inelegante es usar la codificación JSON para hacer copias profundas de objetos que no tienen métodos de miembros.La metodología consiste en codificar JSON el objeto objetivo,luego al decodificarlo,se obtiene la copia que se busca.Puedes decodificar tantas veces como quieras para hacer tantas copias como necesites.</target>
        </trans-unit>
        <trans-unit id="b5e7cf65ae4060f78ce8aa1b4ed6c66bf3442b4e" translate="yes" xml:space="preserve">
          <source>Or to make a &lt;strong&gt;deep copy&lt;/strong&gt;:</source>
          <target state="translated">O para hacer una &lt;strong&gt;copia profunda&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c5035e794e31882d47ef1d6b8595571334a62a63" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">Por &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">Leer más...</target>
        </trans-unit>
        <trans-unit id="b70d8b981e5c20ee4900b1d547ab578ea9f8c800" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;code&gt;circular structures&lt;/code&gt; doesn't work well together... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</source>
          <target state="translated">La recursi&amp;oacute;n y &lt;code&gt;circular structures&lt;/code&gt; no funcionan bien juntas ... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f0db5294c0b0127ed78e8534a588a4da9a4ea8" translate="yes" xml:space="preserve">
          <source>Recursive copy &lt;em&gt;(the accepted &quot;answer&quot;)&lt;/em&gt;</source>
          <target state="translated">Copia recursiva &lt;em&gt;(la &quot;respuesta&quot; aceptada)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461c16fdd9cf991abb778545c3d4ab00c017168c" translate="yes" xml:space="preserve">
          <source>Same problem as the &lt;em&gt;native solution&lt;/em&gt;, but a little bit worse output.</source>
          <target state="translated">Mismo problema que la &lt;em&gt;soluci&amp;oacute;n nativa&lt;/em&gt; , pero un poco peor de salida.</target>
        </trans-unit>
        <trans-unit id="796baa07c71d736d03895eacc42e11d3d30a4b20" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;this article about the structured clone algorithm of browsers&lt;/a&gt; which is used when posting messages to and from a worker. It also contains a function for deep cloning.</source>
          <target state="translated">Consulte tambi&amp;eacute;n &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;este art&amp;iacute;culo sobre el algoritmo de clonaci&amp;oacute;n estructurado de los navegadores&lt;/a&gt; que se utiliza al publicar mensajes desde y hacia un trabajador. Tambi&amp;eacute;n contiene una funci&amp;oacute;n para la clonaci&amp;oacute;n profunda.</target>
        </trans-unit>
        <trans-unit id="b3ee3c57fb439d18c03172ee7afacf0e99f6105f" translate="yes" xml:space="preserve">
          <source>See also Andy Burke's note in the answers.</source>
          <target state="translated">Vea también la nota de Andy Burke en las respuestas.</target>
        </trans-unit>
        <trans-unit id="454f14f00bca91bc2a843967363a76e24887bba3" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; stated that the object to be cloned is a 'literal-constructed' object, a solution might be to simply &lt;em&gt;generate&lt;/em&gt; the object multiple times rather than cloning an instance of the object:</source>
          <target state="translated">Como &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; declar&amp;oacute; que el objeto que se va a clonar es un objeto 'construido literalmente', una soluci&amp;oacute;n podr&amp;iacute;a ser simplemente &lt;em&gt;generar&lt;/em&gt; el objeto varias veces en lugar de clonar una instancia del objeto:</target>
        </trans-unit>
        <trans-unit id="7073615569ad59804a8d64877706cc2ee7c1a1ec" translate="yes" xml:space="preserve">
          <source>So I think one simple solution will be to first serialize and deserialize and then do an assign on it to copy functions too.</source>
          <target state="translated">Así que creo que una solución simple será primero serializar y deserializar y luego hacer una asignación de funciones de copia también.</target>
        </trans-unit>
        <trans-unit id="b77e5c1be59f320b6042fdf12c140f63ab1a4003" translate="yes" xml:space="preserve">
          <source>So let's create a &lt;code&gt;circular structure&lt;/code&gt; and a &lt;code&gt;nested object&lt;/code&gt; first.</source>
          <target state="translated">As&amp;iacute; que &lt;code&gt;nested object&lt;/code&gt; primero una &lt;code&gt;circular structure&lt;/code&gt; y un objeto anidado .</target>
        </trans-unit>
        <trans-unit id="a1e5d5e7a575e6d613efa42edbbd2bd59577f137" translate="yes" xml:space="preserve">
          <source>Some quick tests</source>
          <target state="translated">Algunas pruebas rápidas</target>
        </trans-unit>
        <trans-unit id="1ad81ed3b31b89f94fdfb8b814a7b408c0ce4ac4" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;How to copy JavaScript object to new variable NOT by reference?&lt;/a&gt;</source>
          <target state="translated">Fuente: &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;&amp;iquest;C&amp;oacute;mo copiar un objeto JavaScript a una nueva variable NO por referencia?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">El &lt;strong&gt;polyfill&lt;/strong&gt; para admitir navegadores antiguos:</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">El método Object.assign()se utiliza para copiar los valores de todas las propiedades propias enumerables de uno o más objetos de origen a un objeto de destino.</target>
        </trans-unit>
        <trans-unit id="8a4308022632fbf96a189f60d4c089e47657082a" translate="yes" xml:space="preserve">
          <source>The above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn't more than one reference to the same data in the object. For example:</source>
          <target state="translated">La función anterior funcionará adecuadamente para los 6 tipos simples que mencioné,siempre y cuando los datos de los objetos y matrices formen una estructura de árbol.Es decir,no hay más de una referencia a los mismos datos en el objeto.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="032b503078d9391f3f083e20a6246421123e2d8b" translate="yes" xml:space="preserve">
          <source>The date string for &lt;code&gt;d1&lt;/code&gt; will be 5 seconds behind that of &lt;code&gt;d2&lt;/code&gt;. A way to make one &lt;code&gt;Date&lt;/code&gt; the same as another is by calling the &lt;code&gt;setTime&lt;/code&gt; method, but that is specific to the &lt;code&gt;Date&lt;/code&gt; class. I don't think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!</source>
          <target state="translated">La cadena de fecha para &lt;code&gt;d1&lt;/code&gt; estar&amp;aacute; 5 segundos detr&amp;aacute;s de la de &lt;code&gt;d2&lt;/code&gt; . Una forma de hacer que una &lt;code&gt;Date&lt;/code&gt; igual a otra es llamar al m&amp;eacute;todo &lt;code&gt;setTime&lt;/code&gt; , pero eso es espec&amp;iacute;fico de la clase &lt;code&gt;Date&lt;/code&gt; . No creo que haya una soluci&amp;oacute;n general a prueba de balas para este problema, &amp;iexcl;aunque estar&amp;iacute;a feliz de estar equivocado!</target>
        </trans-unit>
        <trans-unit id="043746030e244c05064aabe5e6c53eb1b00a3576" translate="yes" xml:space="preserve">
          <source>The first attempt I tried was using &lt;code&gt;JSON&lt;/code&gt;.</source>
          <target state="translated">El primer intento que intent&amp;eacute; fue usar &lt;code&gt;JSON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f000a225c9b05dc90c944d0aaba92c15349755d" translate="yes" xml:space="preserve">
          <source>The last solution using recursion and a cache, may not be the best, but it's a &lt;strong&gt;real&lt;/strong&gt; deep-copy of the object. It handles simple &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and &lt;code&gt;nested object&lt;/code&gt;, but it will mess up the instance of them while cloning.</source>
          <target state="translated">La &amp;uacute;ltima soluci&amp;oacute;n que utiliza recursividad y un cach&amp;eacute;, puede no ser la mejor, pero es una copia profunda &lt;strong&gt;real&lt;/strong&gt; del objeto. Maneja &lt;code&gt;properties&lt;/code&gt; simples, &lt;code&gt;circular structures&lt;/code&gt; y &lt;code&gt;nested object&lt;/code&gt; , pero estropear&amp;aacute; la instancia de ellos durante la clonaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d2e920fb16fae1fedca17a36ec3baa9202cbb72d" translate="yes" xml:space="preserve">
          <source>The requirements are matched, but there are still some smaller issues, including changing the &lt;code&gt;instance&lt;/code&gt; of &lt;code&gt;nested&lt;/code&gt; and &lt;code&gt;circ&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">Los requisitos coinciden, pero todav&amp;iacute;a hay algunos problemas menores, incluido el cambio de la &lt;code&gt;instance&lt;/code&gt; de &lt;code&gt;nested&lt;/code&gt; y &lt;code&gt;circ&lt;/code&gt; a &lt;code&gt;Object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29a4e57a808e70c1984cd4b7435f7b3b8f879529" translate="yes" xml:space="preserve">
          <source>The structure of trees that share a leaf won't be copied, they will become two independent leaves:</source>
          <target state="translated">La estructura de los árboles que comparten una hoja no se copiará,se convertirán en dos hojas independientes:</target>
        </trans-unit>
        <trans-unit id="13a953842279c7fd9c49eb420b7ea3060cfc3c9f" translate="yes" xml:space="preserve">
          <source>There are many answers, but none that mentions &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.</source>
          <target state="translated">Hay muchas respuestas, pero ninguna que menciona &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; de ECMAScript 5, que ciertamente no le da una copia exacta, pero establece la fuente como el prototipo del nuevo objeto.</target>
        </trans-unit>
        <trans-unit id="cc7af0c92f6e6c0d9df4aaa342be3e26c98b8b64" translate="yes" xml:space="preserve">
          <source>There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn't be accepted.</source>
          <target state="translated">Hay varios problemas con la mayoría de las soluciones en Internet.Así que decidí hacer un seguimiento,que incluye,por qué la respuesta aceptada no debe ser aceptada.</target>
        </trans-unit>
        <trans-unit id="2138887f9e1a5984c4ac16aa3859fe4f272a050d" translate="yes" xml:space="preserve">
          <source>There is no need for external libraries but you need to check &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;browser compatibility first&lt;/a&gt;.</source>
          <target state="translated">No hay necesidad de bibliotecas externas, pero &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;primero&lt;/a&gt; debe verificar la compatibilidad del navegador .</target>
        </trans-unit>
        <trans-unit id="f6df6c28aa1c494acefc67b48ca65405704b89a2" translate="yes" xml:space="preserve">
          <source>There's a polyfill for &lt;code&gt;Object.create&lt;/code&gt; in the older browser just like the IE 8. It's something like recommended by Mozilla, and of course, it's not perfect and results in the same problem as the &lt;em&gt;native solution&lt;/em&gt;.</source>
          <target state="translated">Hay un polyfill para &lt;code&gt;Object.create&lt;/code&gt; en el navegador anterior al igual que el IE 8. Es algo como lo recomendado por Mozilla, y por supuesto, no es perfecto y da como resultado el mismo problema que la &lt;em&gt;soluci&amp;oacute;n nativa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="257b97895de4343bd020da12619838edee113900" translate="yes" xml:space="preserve">
          <source>This is an adaptation of A. Levy's code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)</source>
          <target state="translated">Esta es una adaptación del código de A.Levy para manejar también la clonación de funciones y referencias multiplicadoras-lo que significa que si dos propiedades del árbol que se clona son referencias del mismo objeto,el árbol de objetos clonados tendrá estas propiedades apuntando al mismo clon del objeto referenciado.Esto también resuelve el caso de las dependencias cíclicas que,si se dejan sin manejar,conducen a un bucle infinito.La complejidad del algoritmo es O(n)</target>
        </trans-unit>
        <trans-unit id="3aeab4233dd61158490346563a83710fdb174f9f" translate="yes" xml:space="preserve">
          <source>This methodology was perfect for my use case, since I'm storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.</source>
          <target state="translated">Esta metodología fue perfecta para mi caso de uso,ya que estoy almacenando los blobs de JSON en un almacén de valores clave,y cuando se exponen como objetos en una API de JavaScript,cada objeto contiene en realidad una copia del estado original del objeto para que podamos calcular el delta después de que el llamador haya mutado el objeto expuesto.</target>
        </trans-unit>
        <trans-unit id="270c07e5aba6d333e589186ebce926ac9488ae45" translate="yes" xml:space="preserve">
          <source>This provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.</source>
          <target state="translated">Esto proporciona un método limpio para una copia superficial de un objeto.Hacer una copia profunda,es decir,hacer una nueva copia de cada valor en cada objeto anidado recursivamente,requiere una de las soluciones más pesadas de arriba.</target>
        </trans-unit>
        <trans-unit id="c3d98944d47265d765fc5c22fd2d0a49ddc89117" translate="yes" xml:space="preserve">
          <source>This solution was added to Javascript some time ago and even handles &lt;code&gt;circular structure&lt;/code&gt;.</source>
          <target state="translated">Esta soluci&amp;oacute;n se agreg&amp;oacute; a Javascript hace alg&amp;uacute;n tiempo e incluso maneja la &lt;code&gt;circular structure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d709893b9322713175a8239aabd951c8aa101e46" translate="yes" xml:space="preserve">
          <source>This works for all kind of objects containing objects, arrays, strings, booleans and numbers.</source>
          <target state="translated">Esto funciona para todo tipo de objetos que contengan objetos,matrices,cuerdas,booleanos y números.</target>
        </trans-unit>
        <trans-unit id="be7e283523bee098c95fbd259fdb185444007880" translate="yes" xml:space="preserve">
          <source>Thus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:</source>
          <target state="translated">Por lo tanto,esta no es una respuesta exacta a la pregunta,pero es una solución de una sola línea y por lo tanto elegante.Y funciona mejor en dos casos:</target>
        </trans-unit>
        <trans-unit id="b36783ae8f97bf075d43eb8bdee3e68cae031c5d" translate="yes" xml:space="preserve">
          <source>To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object's prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a &lt;code&gt;clone&lt;/code&gt; method to &lt;code&gt;Object.prototype&lt;/code&gt;, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to &lt;code&gt;Object.prototype&lt;/code&gt;, or other intermediate prototypes, that you don't know about? In that case, you will copy attributes you shouldn't, so you need to detect unforeseen, non-local attributes with the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Hacer esto para cualquier objeto en JavaScript no ser&amp;aacute; simple o directo. Te encontrar&amp;aacute;s con el problema de recoger err&amp;oacute;neamente atributos del prototipo del objeto que deber&amp;iacute;an dejarse en el prototipo y no copiarse en la nueva instancia. Si, por ejemplo, est&amp;aacute; agregando un m&amp;eacute;todo de &lt;code&gt;clone&lt;/code&gt; a &lt;code&gt;Object.prototype&lt;/code&gt; , como muestran algunas respuestas, deber&amp;aacute; omitir expl&amp;iacute;citamente ese atributo. Pero, &amp;iquest;qu&amp;eacute; &lt;code&gt;Object.prototype&lt;/code&gt; si hay otros m&amp;eacute;todos adicionales agregados a Object.prototype u otros prototipos intermedios que no conoce? En ese caso, copiar&amp;aacute; los atributos que no deber&amp;iacute;a, por lo que debe detectar atributos no locales imprevistos con el m&amp;eacute;todo &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;hasOwnProperty&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a913fb7183b6fb881c9a823ab39998ee4aa93f87" translate="yes" xml:space="preserve">
          <source>Using Lodash:</source>
          <target state="translated">Usando a Lodash:</target>
        </trans-unit>
        <trans-unit id="ca5a4f97de6e6ecec887d15f3ba764fe9304dac1" translate="yes" xml:space="preserve">
          <source>When I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; would also be one of the 6 simple types in that list. This can be accomplished with code like the following:</source>
          <target state="translated">Cuando tuve que implementar una copia profunda general, termin&amp;eacute; comprometi&amp;eacute;ndome asumiendo que solo necesitar&amp;iacute;a copiar un &lt;code&gt;Object&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; o &lt;code&gt;Boolean&lt;/code&gt; . Los &amp;uacute;ltimos 3 tipos son inmutables, por lo que podr&amp;iacute;a realizar una copia superficial y no preocuparme de que cambie. Adem&amp;aacute;s supuse que cualquier elemento contenido en &lt;code&gt;Object&lt;/code&gt; o &lt;code&gt;Array&lt;/code&gt; tambi&amp;eacute;n ser&amp;iacute;a uno de los 6 tipos simples en esa lista. Esto se puede lograr con un c&amp;oacute;digo como el siguiente:</target>
        </trans-unit>
        <trans-unit id="456e0fb41b68296ae4fca0c5da8c6c8c99b050d9" translate="yes" xml:space="preserve">
          <source>When digging around, I found a similar question (&lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;In Javascript, when performing a deep copy, how do I avoid a cycle, due to a property being &quot;this&quot;?&lt;/a&gt;) to this one, but with a way better solution.</source>
          <target state="translated">Al investigar, encontr&amp;eacute; una pregunta similar ( &lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;en Javascript, al realizar una copia profunda, &amp;iquest;c&amp;oacute;mo evito un ciclo, debido a que una propiedad es &quot;esto&quot;?&lt;/a&gt; ) A esta, pero con una soluci&amp;oacute;n mucho mejor.</target>
        </trans-unit>
        <trans-unit id="a9252c930b2a9734d9944f251662812bcd0d5878" translate="yes" xml:space="preserve">
          <source>Where such inheritance is useful (duh!)</source>
          <target state="translated">Donde tal herencia es útil (duh!)</target>
        </trans-unit>
        <trans-unit id="f3f6684c458c70cb9d8e7a984298d711252184ac" translate="yes" xml:space="preserve">
          <source>Where the source object won't be modified, thus making the relation between the 2 objects a non issue.</source>
          <target state="translated">Donde el objeto fuente no será modificado,haciendo así que la relación entre los 2 objetos no sea un problema.</target>
        </trans-unit>
        <trans-unit id="2735aa18f20ac2191686e23824f2e5be39288c5c" translate="yes" xml:space="preserve">
          <source>Why do I consider this solution to be superior? It's native, thus no looping, no recursion. However, older browsers will need a polyfill.</source>
          <target state="translated">¿Por qué considero que esta solución es superior? Es nativo,por lo tanto no hay bucles,no hay recursividad.Sin embargo,los navegadores más antiguos necesitarán un polifilamento.</target>
        </trans-unit>
        <trans-unit id="c4313b8450309f35ea2494e7d2513a055de02aeb" translate="yes" xml:space="preserve">
          <source>With jQuery, you can &lt;strong&gt;shallow copy&lt;/strong&gt; with &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;:</source>
          <target state="translated">Con jQuery, puede &lt;strong&gt;copiar superficialmente&lt;/strong&gt; con &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc955433235b02b7f40b76eb1d7dfddf892c4a6e" translate="yes" xml:space="preserve">
          <source>Yet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object's prototype is &lt;code&gt;Object&lt;/code&gt;, then simply creating a new general object with &lt;code&gt;{}&lt;/code&gt; will work, but if the source's prototype is some descendant of &lt;code&gt;Object&lt;/code&gt;, then you are going to be missing the additional members from that prototype which you skipped using the &lt;code&gt;hasOwnProperty&lt;/code&gt; filter, or which were in the prototype, but weren't enumerable in the first place. One solution might be to call the source object's &lt;code&gt;constructor&lt;/code&gt; property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object stores its data as a hidden member:</source>
          <target state="translated">Otro inconveniente en la b&amp;uacute;squeda de una soluci&amp;oacute;n elegante es el problema de configurar la herencia del prototipo correctamente. Si el prototipo de su objeto de origen es &lt;code&gt;Object&lt;/code&gt; , entonces simplemente crear un nuevo objeto general con &lt;code&gt;{}&lt;/code&gt; funcionar&amp;aacute;, pero si el prototipo de la fuente es un descendiente de &lt;code&gt;Object&lt;/code&gt; , entonces faltar&amp;aacute;n los miembros adicionales de ese prototipo que omiti&amp;oacute; usando el filtro &lt;code&gt;hasOwnProperty&lt;/code&gt; , o que estaban en el prototipo, pero no eran enumerables en primer lugar. Una soluci&amp;oacute;n podr&amp;iacute;a ser llamar a la propiedad del &lt;code&gt;constructor&lt;/code&gt; del objeto fuente para obtener el objeto de copia inicial y luego copiar los atributos, pero a&amp;uacute;n as&amp;iacute; no obtendr&amp;aacute; atributos no enumerables. Por ejemplo, un objeto &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; almacena sus datos como un miembro oculto:</target>
        </trans-unit>
        <trans-unit id="f6ada691f9c830b134d1063e166e1d147221dcb3" translate="yes" xml:space="preserve">
          <source>You can clone an object and remove any reference from the previous one using a single line of code. Simply do:</source>
          <target state="translated">Puedes clonar un objeto y eliminar cualquier referencia del anterior usando una sola línea de código.Simplemente hazlo:</target>
        </trans-unit>
        <trans-unit id="2fb59e1d6040b949307491685dc51fd64aac4887" translate="yes" xml:space="preserve">
          <source>You can simply use a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;spread property&lt;/a&gt; to copy an object without references. But be careful (see comments), the 'copy' is just on the lowest object/array level. Nested properties are still references!</source>
          <target state="translated">Simplemente puede usar una &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;propiedad de propagaci&amp;oacute;n&lt;/a&gt; para copiar un objeto sin referencias. Pero tenga cuidado (vea los comentarios), la 'copia' est&amp;aacute; justo en el nivel m&amp;aacute;s bajo de objeto / matriz. &amp;iexcl;Las propiedades anidadas siguen siendo referencias!</target>
        </trans-unit>
        <trans-unit id="9abb2632977048faaf1083e1bdfe1addfa67decb" translate="yes" xml:space="preserve">
          <source>You know what happened here because if not you wouldn't even land on this great question.</source>
          <target state="translated">Sabes lo que pasó aquí,porque si no,ni siquiera te darías cuenta de esta gran pregunta.</target>
        </trans-unit>
        <trans-unit id="6a38a38f03e4ff5839ba4a879178cce5bc42666b" translate="yes" xml:space="preserve">
          <source>conclusion</source>
          <target state="translated">conclusion</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="716e96afcc9beb903225a881db7f167667cc2eb3" translate="yes" xml:space="preserve">
          <source>jsfiddle</source>
          <target state="translated">jsfiddle</target>
        </trans-unit>
        <trans-unit id="352f260ed32601f2720cbdef8b42f9882a4102af" translate="yes" xml:space="preserve">
          <source>native solution</source>
          <target state="translated">solución nativa</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="c5b130d2294080fe3f54b6ede9cb6c33d3a49d6b" translate="yes" xml:space="preserve">
          <source>or using spread operator like this:</source>
          <target state="translated">o usando un operador de difusión como este:</target>
        </trans-unit>
        <trans-unit id="82ae245159e159776ea37d68d57ddfa387a83600" translate="yes" xml:space="preserve">
          <source>or you can extend it like</source>
          <target state="translated">o puedes extenderlo como</target>
        </trans-unit>
        <trans-unit id="3e0bf88b357a046b4e7659fed6103de63a9734cd" translate="yes" xml:space="preserve">
          <source>polyfill for the native solution</source>
          <target state="translated">polyfill para la solución nativa</target>
        </trans-unit>
        <trans-unit id="55d9bbd3efbab583726fcd7c3ad976b8129b76ee" translate="yes" xml:space="preserve">
          <source>starting situation</source>
          <target state="translated">situación inicial</target>
        </trans-unit>
        <trans-unit id="a5f7a257ae51fb7db8f01b3b457418d96c6a2a00" translate="yes" xml:space="preserve">
          <source>subsequent changes to the &lt;code&gt;copiedObject&lt;/code&gt; will not affect the &lt;code&gt;originalObject&lt;/code&gt;, and vice versa.</source>
          <target state="translated">Los cambios posteriores al objeto &lt;code&gt;copiedObject&lt;/code&gt; no afectar&amp;aacute;n al objeto &lt;code&gt;originalObject&lt;/code&gt; , y viceversa.</target>
        </trans-unit>
        <trans-unit id="2ba1210fdf174274ea55c483bb6ade889c52e126" translate="yes" xml:space="preserve">
          <source>the answer is mainly depeneds on which &lt;strong&gt;ECMAscript&lt;/strong&gt; you using, in &lt;code&gt;ES6+&lt;/code&gt;, you can simply use &lt;code&gt;Object.assign&lt;/code&gt; to do the clone:</source>
          <target state="translated">la respuesta depende principalmente de qu&amp;eacute; &lt;strong&gt;ECMAscript&lt;/strong&gt; est&amp;aacute; usando, en &lt;code&gt;ES6+&lt;/code&gt; , simplemente puede usar &lt;code&gt;Object.assign&lt;/code&gt; para hacer el clon:</target>
        </trans-unit>
        <trans-unit id="522547b9c4325ca856f8c4192d0ad23de9c33613" translate="yes" xml:space="preserve">
          <source>the better (but not perfect) solution</source>
          <target state="translated">la mejor (pero no perfecta)solución</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
