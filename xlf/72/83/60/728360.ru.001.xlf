<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/728360">
    <body>
      <group id="728360">
        <trans-unit id="5fff870d002057a570c5f54f6e0583f072249e21" translate="yes" xml:space="preserve">
          <source>... and you see, it didn't work with the nested structure inside.</source>
          <target state="translated">...и,видите ли,это не сработало с вложенной структурой внутри.</target>
        </trans-unit>
        <trans-unit id="fdf1515d42ec5590b0b9470e710e5a34edb33d3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{test:&quot;test&quot;}&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="f8d42eb23fc0b5363fad3b52a8388240db181867" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clone with references on second level:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Клон со ссылками на второй уровень:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cea8c7ca59555849767060049632be16cd783d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complete clone:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Полный клон:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6966d0f501ab4b788d3ea14f276d58f9c181e993" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; imagine you have this object below and you want to clone it:</source>
          <target state="translated">&lt;strong&gt;Хорошо,&lt;/strong&gt; представьте, что у вас есть этот объект ниже, и вы хотите его клонировать:</target>
        </trans-unit>
        <trans-unit id="22efe12cc8badd5b62cb63cbb32d48a03bfc69b9" translate="yes" xml:space="preserve">
          <source>A good reference is here:
&lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</source>
          <target state="translated">Хорошая ссылка здесь: &lt;a href=&quot;https://googlechrome.github.io/samples/object-assign-es6/&quot;&gt;https://googlechrome.github.io/samples/object-assign-es6/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31e2fbcb0256c7808f1ca3a03007c73a654f8c07" translate="yes" xml:space="preserve">
          <source>A.Levy's answer is almost complete, here is my little contribution: &lt;strong&gt;there is a way how to handle recursive references&lt;/strong&gt;, see this line</source>
          <target state="translated">Ответ А. Леви почти полный, вот мой маленький вклад: &lt;strong&gt;есть способ, как обрабатывать рекурсивные ссылки&lt;/strong&gt; , см. Эту строку</target>
        </trans-unit>
        <trans-unit id="75589da17d1b2a78b18aaddcd6a610f24da00c24" translate="yes" xml:space="preserve">
          <source>After arguing with my co-worker, my boss asked us what happened, and he found a simple &lt;em&gt;solution&lt;/em&gt; after some googling. It's called &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">После спора с моим коллегой, мой начальник спросил нас, что случилось, и он нашел простое &lt;em&gt;решение&lt;/em&gt; после некоторого поиска в Google. Это называется &lt;code&gt;Object.create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba29de559b1bb261e25a1d12df67e7d242566aa7" translate="yes" xml:space="preserve">
          <source>Although this question has many answers, I hope this one helps too.</source>
          <target state="translated">Хотя на этот вопрос есть много ответов,я надеюсь,что этот тоже поможет.</target>
        </trans-unit>
        <trans-unit id="af28336e40dc39e63a92abf858f8c6ab4d67e567" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Object.assign&lt;/code&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">Метод &lt;code&gt;Object.assign&lt;/code&gt; является частью стандарта ECMAScript 2015 (ES6) и делает именно то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="32bfe9e918d4b868492fa92e62f1c551337c8c70" translate="yes" xml:space="preserve">
          <source>An elegant way to clone a Javascript object in one line of code</source>
          <target state="translated">Элегантный способ клонирования объекта Javascript в одной строке кода.</target>
        </trans-unit>
        <trans-unit id="896435d8badf2f411e99791401b27e88034dbb6f" translate="yes" xml:space="preserve">
          <source>And keep the methods alive on cloned object.</source>
          <target state="translated">И держать методы живыми на клонированном объекте.</target>
        </trans-unit>
        <trans-unit id="a19d0a3bf30a88c3fd9012682cd0067268b19a91" translate="yes" xml:space="preserve">
          <source>And let's have a look at the output...</source>
          <target state="translated">И давайте посмотрим на результат...</target>
        </trans-unit>
        <trans-unit id="11f375141a5034d16664f0e54b2f1c0b28910f53" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;strong&gt;nested objects&lt;/strong&gt; are still copied &lt;strong&gt;as a reference.&lt;/strong&gt;</source>
          <target state="translated">Помните, что &lt;strong&gt;вложенные объекты&lt;/strong&gt; по-прежнему копируются &lt;strong&gt;в качестве ссылки.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56ecbf1b8827336c51f8306fdb107ae1b4c8f121" translate="yes" xml:space="preserve">
          <source>But be aware that nested objects are still copied as reference.</source>
          <target state="translated">Но имейте в виду,что вложенные объекты все равно копируются как ссылка.</target>
        </trans-unit>
        <trans-unit id="44d9c60e7ecbda7adb322596b936906b1dded999" translate="yes" xml:space="preserve">
          <source>But if you using &lt;code&gt;ES5&lt;/code&gt;, you can use few methods, but the &lt;code&gt;JSON.stringify&lt;/code&gt;, just make sure you not using for a big chunk of data to copy, but it could be one line handy way in many cases, something like this:</source>
          <target state="translated">Но если вы используете &lt;code&gt;ES5&lt;/code&gt; , вы можете использовать несколько методов, кроме &lt;code&gt;JSON.stringify&lt;/code&gt; , просто убедитесь, что вы не используете большой кусок данных для копирования, но во многих случаях это может быть удобная однострочная строка, например, так:</target>
        </trans-unit>
        <trans-unit id="95088399458c196785b80f328382de6f8fa6da7f" translate="yes" xml:space="preserve">
          <source>Don't waste too much time on it, you'll get &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt;.</source>
          <target state="translated">Не тратьте на это слишком много времени, вы получите &lt;code&gt;TypeError: Converting circular structure to JSON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2b7b729fd7dfac409f1f5c4781cdc32d799528" translate="yes" xml:space="preserve">
          <source>ES6 solution if you want to (shallow) clone a &lt;strong&gt;class instance&lt;/strong&gt; and not just a property object.</source>
          <target state="translated">Решение ES6, если вы хотите (поверхностно) клонировать &lt;strong&gt;экземпляр класса,&lt;/strong&gt; а не просто объект свойства.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="9d4b3583c599fafbba741d166652892841a76ea3" translate="yes" xml:space="preserve">
          <source>Following is the implementation:</source>
          <target state="translated">Далее следует реализация:</target>
        </trans-unit>
        <trans-unit id="6dcc05bb82ad169b245a024fa2181e38169796be" translate="yes" xml:space="preserve">
          <source>For &quot;deep&quot; copy, use &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</source>
          <target state="translated">Для &amp;laquo;глубокой&amp;raquo; копии используйте &lt;code&gt;JSON.parse(JSON.stringify(a))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24a73f09717e6302b4ae5cfc392955d30204cefd" translate="yes" xml:space="preserve">
          <source>For a deep copy and clone, JSON.stringify then JSON.parse the object:</source>
          <target state="translated">Для глубокой копии и клонирования,JSON.stringify затем JSON.parse объекта:</target>
        </trans-unit>
        <trans-unit id="fbe99868375178cc499070d97ef9839eb868985f" translate="yes" xml:space="preserve">
          <source>For browsers / engines that do not currently support Object.create you can use this polyfill:</source>
          <target state="translated">Для браузеров,которые в настоящее время не поддерживают Object.create,вы можете использовать этот полифиль:</target>
        </trans-unit>
        <trans-unit id="fdfee069d3a9f22467239d1a5c249362ba8bfbc8" translate="yes" xml:space="preserve">
          <source>For those using AngularJS, there is also direct method for cloning or extending of the objects in this library.</source>
          <target state="translated">Для тех,кто использует AngularJS,в этой библиотеке есть также прямой метод клонирования или расширения объектов.</target>
        </trans-unit>
        <trans-unit id="bf4ec4c0c298b2a0248ed16c560cae0cb2b2f354" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;How to copy arrays and objects in Javascript&lt;/a&gt; by Brian Huisman:</source>
          <target state="translated">Из этой статьи: &lt;a href=&quot;https://greywyvern.com/?post=363&quot;&gt;Как скопировать массивы и объекты в Javascript&lt;/a&gt; от Брайана Хьюсмана:</target>
        </trans-unit>
        <trans-unit id="73f8555ab7993eb62a7bb80980e5decb72448c9b" translate="yes" xml:space="preserve">
          <source>Here is a function you can use.</source>
          <target state="translated">Вот функция,которую вы можете использовать.</target>
        </trans-unit>
        <trans-unit id="4631d41b7b36fb799786f4a214099e57e5620b0e" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object</source>
          <target state="translated">Как правильно клонировать объект JavaScript.</target>
        </trans-unit>
        <trans-unit id="743e0eea187a855a15b0996e0b65671bfbe4b6c9" translate="yes" xml:space="preserve">
          <source>How do I correctly clone a JavaScript object?</source>
          <target state="translated">Как правильно клонировать объект JavaScript?</target>
        </trans-unit>
        <trans-unit id="001d1eefeee3ed1b4eb51c735f2abbe94cdc6856" translate="yes" xml:space="preserve">
          <source>I have an object, &lt;code&gt;x&lt;/code&gt;. I'd like to copy it as object &lt;code&gt;y&lt;/code&gt;, such that changes to &lt;code&gt;y&lt;/code&gt; do not modify &lt;code&gt;x&lt;/code&gt;. I realized that copying objects derived from built-in JavaScript objects will result in extra, unwanted properties. This isn't a problem, since I'm copying one of my own literal-constructed objects.</source>
          <target state="translated">У меня есть объект, &lt;code&gt;x&lt;/code&gt; . Я хотел бы скопировать его как объект &lt;code&gt;y&lt;/code&gt; , чтобы изменения &lt;code&gt;y&lt;/code&gt; не изменяли &lt;code&gt;x&lt;/code&gt; . Я понял, что копирование объектов, полученных из встроенных объектов JavaScript, приведет к появлению дополнительных нежелательных свойств. Это не проблема, так как я копирую один из своих собственных объектов, созданных в буквальном смысле.</target>
        </trans-unit>
        <trans-unit id="6a18864f24ad3607c14646fe8b7ea199e0cfa3b2" translate="yes" xml:space="preserve">
          <source>I just wanted to add to all the &lt;code&gt;Object.create&lt;/code&gt; solutions in this post, that this does not work in the desired way with nodejs.</source>
          <target state="translated">Я просто хотел добавить ко всем решениям &lt;code&gt;Object.create&lt;/code&gt; в этом посте, что это не работает желаемым образом с nodejs.</target>
        </trans-unit>
        <trans-unit id="0e8d9e15a95057e936855612d02338a65a9ae821" translate="yes" xml:space="preserve">
          <source>I think there is a simple and working answer. In deep copying there are two concerns:</source>
          <target state="translated">Я думаю,что есть простой и рабочий ответ.В глубоком копировании есть две проблемы:</target>
        </trans-unit>
        <trans-unit id="941624dec0eec1e76a1ffed0d1cbb9418daa899a" translate="yes" xml:space="preserve">
          <source>I want to &lt;strong&gt;deep-copy&lt;/strong&gt; a Javascript &lt;code&gt;Object&lt;/code&gt; with all of its children and their children and so on. But since I'm not kind of a normal developer, my &lt;code&gt;Object&lt;/code&gt; has &lt;em&gt;normal&lt;/em&gt;&lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and even &lt;code&gt;nested objects&lt;/code&gt;.</source>
          <target state="translated">Я хочу &lt;strong&gt;глубоко скопировать&lt;/strong&gt; Javascript &lt;code&gt;Object&lt;/code&gt; со всеми его потомками и их потомками и так далее. Но так как я не нормальный разработчик, у моего &lt;code&gt;Object&lt;/code&gt; есть &lt;em&gt;нормальные&lt;/em&gt; &lt;code&gt;properties&lt;/code&gt; , &lt;code&gt;circular structures&lt;/code&gt; и даже &lt;code&gt;nested objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="492eceb4047550ce310e991adf6cd7624ed3faaa" translate="yes" xml:space="preserve">
          <source>I've put &lt;code&gt;F&lt;/code&gt; outside the scope so we can have a look at what &lt;code&gt;instanceof&lt;/code&gt; tells us.</source>
          <target state="translated">Я поместил &lt;code&gt;F&lt;/code&gt; вне области видимости, чтобы мы могли посмотреть, что нам говорит &lt;code&gt;instanceof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a429ab5caa7c00e09548791ed612fdfcc5894e19" translate="yes" xml:space="preserve">
          <source>I've written my own implementation. Not sure if it counts as a better solution:</source>
          <target state="translated">Я написал свою собственную имплементацию.Не уверен,что это будет лучшим решением:</target>
        </trans-unit>
        <trans-unit id="dafdc35a46a4c2d0195d973a1d3318e6698831c0" translate="yes" xml:space="preserve">
          <source>If the object is XML DOM element, we must use &lt;strong&gt;cloneNode&lt;/strong&gt; instead</source>
          <target state="translated">Если объект является XML-элементом DOM, мы должны использовать вместо него &lt;strong&gt;cloneNode&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae8354bc788c660711b68a4fa1e2850f3185cab9" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, undefined, regExp or Infinity within your object, a very simple one liner is &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt;:</source>
          <target state="translated">Если вы не используете &lt;code&gt;Date&lt;/code&gt; s, функции, undefined, regExp или Infinity в вашем объекте, очень простой однострочник - это &lt;code&gt;JSON.parse(JSON.stringify(object))&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfd3f2d16bba73dae97290f3a239238665ccfc4c" translate="yes" xml:space="preserve">
          <source>If you want shallow copy, use &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</source>
          <target state="translated">Если вам нужна мелкая копия, используйте &lt;code&gt;Object.assign({}, a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253989d793a4111415e3d9230d7ab2071f59e3ac" translate="yes" xml:space="preserve">
          <source>If you're okay with a shallow copy, the underscore.js library has a &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">Если у вас все в порядке с мелкой копией, в библиотеке underscore.js есть метод &lt;a href=&quot;http://underscorejs.org/#clone&quot;&gt;clone&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bf6911de6ff08405b3d088604f2d3601613b4cb" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2018</source>
          <target state="translated">В ECMAScript 2018</target>
        </trans-unit>
        <trans-unit id="1defc59fd72a11aff1734e0a2e2a22f0a4abab4d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 6 there is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method, which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">В ECMAScript 6 есть метод &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; , который копирует значения всех перечисляемых собственных свойств из одного объекта в другой. Например:</target>
        </trans-unit>
        <trans-unit id="f304990021e58b1d1ff5e13fb83eed4bf99dd0d2" translate="yes" xml:space="preserve">
          <source>In ES-6 you can simply use Object.assign(...).
Ex:</source>
          <target state="translated">В ES-6 можно просто использовать Object.assign(...).Ex:</target>
        </trans-unit>
        <trans-unit id="2c92ac88d5767f5e56ba7636924db58532bd9c70" translate="yes" xml:space="preserve">
          <source>In Firefox the result of</source>
          <target state="translated">В Firefox результат</target>
        </trans-unit>
        <trans-unit id="3c2ea368e40e7bb729de18cbee756fb95f6ea1f5" translate="yes" xml:space="preserve">
          <source>In addition to non-enumerable attributes, you'll encounter a tougher problem when you try to copy objects that have hidden properties. For example, &lt;code&gt;prototype&lt;/code&gt; is a hidden property of a function. Also, an object's prototype is referenced with the attribute &lt;code&gt;__proto__&lt;/code&gt;, which is also hidden, and will not be copied by a for/in loop iterating over the source object's attributes. I think &lt;code&gt;__proto__&lt;/code&gt; might be specific to Firefox's JavaScript interpreter and it may be something different in other browsers, but you get the picture. Not everything is enumerable. You can copy a hidden attribute if you know its name, but I don't know of any way to discover it automatically.</source>
          <target state="translated">Помимо неперечислимых атрибутов, вы столкнетесь с более сложной проблемой, когда попытаетесь скопировать объекты со скрытыми свойствами. Например, &lt;code&gt;prototype&lt;/code&gt; является скрытым свойством функции. Кроме того, на прототип объекта ссылается атрибут &lt;code&gt;__proto__&lt;/code&gt; , который также скрыт и не будет скопирован циклом for / in, повторяющимся по атрибутам исходного объекта. Я думаю, что &lt;code&gt;__proto__&lt;/code&gt; может быть специфичным для интерпретатора JavaScript Firefox, и это может быть что-то другое в других браузерах, но вы получите представление. Не все перечисляемо. Вы можете скопировать скрытый атрибут, если знаете его имя, но я не знаю, как его обнаружить автоматически.</target>
        </trans-unit>
        <trans-unit id="af3b62758b3b5aad9f8bb2a67a63a6b1276c2744" translate="yes" xml:space="preserve">
          <source>In nodejs it is</source>
          <target state="translated">В узлах это</target>
        </trans-unit>
        <trans-unit id="8070d65a107f7a0001017aa494dfb78ff6d01341" translate="yes" xml:space="preserve">
          <source>Inspired by A.Levy's exhaustive study and Calvin's prototyping approach, I offer this solution:</source>
          <target state="translated">Вдохновленный исчерпывающим исследованием А.Леви и подходом Кальвина к прототипированию,я предлагаю это решение:</target>
        </trans-unit>
        <trans-unit id="9bfe4aadd640d727c541e4a74de4c537bf9603c9" translate="yes" xml:space="preserve">
          <source>Interested in cloning simple objects:</source>
          <target state="translated">Интересуется клонированием простых объектов:</target>
        </trans-unit>
        <trans-unit id="06837f1236b49354891013f198510b9ba4fc2ab5" translate="yes" xml:space="preserve">
          <source>It will not be able to handle any JavaScript object, but it may be sufficient for many purposes as long as you don't assume that it will just work for anything you throw at it.</source>
          <target state="translated">Он не сможет работать с любым объектом JavaScript,но этого может быть достаточно для многих целей,если вы не предполагаете,что он будет работать только для того,что вы в него бросите.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c5f79a04d00332bcef73e7c25ac76cc77265d5d3" translate="yes" xml:space="preserve">
          <source>JavaScript actually does not support deep clones natively. Use an utility function. For example Ramda:</source>
          <target state="translated">JavaScript на самом деле не поддерживает глубокие клоны нативно.Используйте функцию утилиты.Например,Ramda:</target>
        </trans-unit>
        <trans-unit id="6c8086021c6a372b4809189f81b1a61b9f2eeea4" translate="yes" xml:space="preserve">
          <source>JavaScript keeps evolving.</source>
          <target state="translated">JavaScript продолжает развиваться.</target>
        </trans-unit>
        <trans-unit id="898c396720398ab086b937719a5cb546261e8435" translate="yes" xml:space="preserve">
          <source>Keep properties independent to each other.</source>
          <target state="translated">Сохраняйте свойства независимыми друг от друга.</target>
        </trans-unit>
        <trans-unit id="f9cd6e333924ef28d1cf1cb192e551179543718e" translate="yes" xml:space="preserve">
          <source>Let's bring everything together in an &lt;code&gt;Object&lt;/code&gt; named &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Давайте соберем все вместе в &lt;code&gt;Object&lt;/code&gt; именем.</target>
        </trans-unit>
        <trans-unit id="b8aaf1df286d5ef5e319286978f2d4a622c5dd52" translate="yes" xml:space="preserve">
          <source>Let's have a look at the accepted answer.</source>
          <target state="translated">Давайте посмотрим на принятый ответ.</target>
        </trans-unit>
        <trans-unit id="3440d2c76fb94711deb530c695895ec6080f7195" translate="yes" xml:space="preserve">
          <source>Looks good, heh? It's a recursive copy of the object and handles other types as well, like &lt;code&gt;Date&lt;/code&gt;, but that wasn't a requirement.</source>
          <target state="translated">Хорошо выглядит, а? Это рекурсивная копия объекта и также обрабатывает другие типы, такие как &lt;code&gt;Date&lt;/code&gt; , но это не было обязательным требованием.</target>
        </trans-unit>
        <trans-unit id="4401b855280cd9542719b7c0ccaf34205cee9587" translate="yes" xml:space="preserve">
          <source>More in angular.copy &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;documentation&lt;/a&gt;...</source>
          <target state="translated">Больше в &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;документации&lt;/a&gt; angular.copy ...</target>
        </trans-unit>
        <trans-unit id="dade8dcd2b43a64b756eff141607bc6874a514ce" translate="yes" xml:space="preserve">
          <source>New answer to an old question!  If you have the pleasure of having using ECMAScript 2016 (ES6) with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;Spread Syntax&lt;/a&gt;, it's easy.</source>
          <target state="translated">Новый ответ на старый вопрос! Если вы имеете удовольствие от использования ECMAScript 2016 (ES6) с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;синтаксисом распространения&lt;/a&gt; , это легко.</target>
        </trans-unit>
        <trans-unit id="13e3b18e3972aab20fc4c36853cd1d0b35875d96" translate="yes" xml:space="preserve">
          <source>Next, we want to copy &lt;code&gt;a&lt;/code&gt; into a variable named &lt;code&gt;b&lt;/code&gt; and mutate it.</source>
          <target state="translated">Далее мы хотим скопировать &lt;code&gt;a&lt;/code&gt; в переменную с именем &lt;code&gt;b&lt;/code&gt; и изменить ее.</target>
        </trans-unit>
        <trans-unit id="dc14249af7e109f4fde91ed60eb8e84255d155bd" translate="yes" xml:space="preserve">
          <source>Now let's find a solution.</source>
          <target state="translated">Теперь давайте найдем решение.</target>
        </trans-unit>
        <trans-unit id="4d1dae1e39568ce239fd2a7fc3a8cf3c550df25c" translate="yes" xml:space="preserve">
          <source>Of course, functions do not belong in JSON, so this only works for objects without member methods.</source>
          <target state="translated">Конечно,функции в JSON не принадлежат,так что это работает только для объектов без методов членства.</target>
        </trans-unit>
        <trans-unit id="2366061f7e9ccde0f6899dd5905d19be0299833f" translate="yes" xml:space="preserve">
          <source>One particularly inelegant solution is to use JSON encoding to make deep copies of objects that do not have member methods. The methodology is to JSON encode your target object, then by decoding it, you get the copy you are looking for.  You can decode as many times as you want to make as many copies as you need.</source>
          <target state="translated">Одним из особенно непривлекательных решений является использование кодировки JSON для создания глубоких копий объектов,не имеющих методов членства.Методология заключается в JSON кодировании целевого объекта,затем,декодируя его,вы получаете копию,которую ищете.Вы можете декодировать столько раз,сколько вам нужно,чтобы сделать столько копий,сколько вам нужно.</target>
        </trans-unit>
        <trans-unit id="b5e7cf65ae4060f78ce8aa1b4ed6c66bf3442b4e" translate="yes" xml:space="preserve">
          <source>Or to make a &lt;strong&gt;deep copy&lt;/strong&gt;:</source>
          <target state="translated">Или сделать &lt;strong&gt;глубокую копию&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c5035e794e31882d47ef1d6b8595571334a62a63" translate="yes" xml:space="preserve">
          <source>Per &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt;:</source>
          <target state="translated">За &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Deep_Clone&quot;&gt;MDN&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">Подробнее...</target>
        </trans-unit>
        <trans-unit id="b70d8b981e5c20ee4900b1d547ab578ea9f8c800" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;code&gt;circular structures&lt;/code&gt; doesn't work well together... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</source>
          <target state="translated">Рекурсия и &lt;code&gt;circular structures&lt;/code&gt; не работают вместе ... &lt;code&gt;RangeError: Maximum call stack size exceeded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3f0db5294c0b0127ed78e8534a588a4da9a4ea8" translate="yes" xml:space="preserve">
          <source>Recursive copy &lt;em&gt;(the accepted &quot;answer&quot;)&lt;/em&gt;</source>
          <target state="translated">Рекурсивная копия &lt;em&gt;(принятый &amp;laquo;ответ&amp;raquo;)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461c16fdd9cf991abb778545c3d4ab00c017168c" translate="yes" xml:space="preserve">
          <source>Same problem as the &lt;em&gt;native solution&lt;/em&gt;, but a little bit worse output.</source>
          <target state="translated">Та же проблема, что и у &lt;em&gt;нативного решения&lt;/em&gt; , но немного худший результат.</target>
        </trans-unit>
        <trans-unit id="796baa07c71d736d03895eacc42e11d3d30a4b20" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;this article about the structured clone algorithm of browsers&lt;/a&gt; which is used when posting messages to and from a worker. It also contains a function for deep cloning.</source>
          <target state="translated">См. Также &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm&quot;&gt;эту статью о алгоритме структурированного клонирования браузеров,&lt;/a&gt; который используется при отправке сообщений сотруднику и от него. Он также содержит функцию для глубокого клонирования.</target>
        </trans-unit>
        <trans-unit id="b3ee3c57fb439d18c03172ee7afacf0e99f6105f" translate="yes" xml:space="preserve">
          <source>See also Andy Burke's note in the answers.</source>
          <target state="translated">Смотри также записку Энди Берка в ответах.</target>
        </trans-unit>
        <trans-unit id="454f14f00bca91bc2a843967363a76e24887bba3" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; stated that the object to be cloned is a 'literal-constructed' object, a solution might be to simply &lt;em&gt;generate&lt;/em&gt; the object multiple times rather than cloning an instance of the object:</source>
          <target state="translated">Поскольку &lt;a href=&quot;https://stackoverflow.com/users/49695/mindeavor&quot;&gt;mindeavor&lt;/a&gt; заявил, что клонируемый объект является &amp;laquo;буквально сконструированным&amp;raquo; объектом, решение может состоять в том, чтобы просто &lt;em&gt;генерировать&lt;/em&gt; объект несколько раз, а не клонировать экземпляр объекта:</target>
        </trans-unit>
        <trans-unit id="7073615569ad59804a8d64877706cc2ee7c1a1ec" translate="yes" xml:space="preserve">
          <source>So I think one simple solution will be to first serialize and deserialize and then do an assign on it to copy functions too.</source>
          <target state="translated">Поэтому я думаю,что одним из простых решений будет сначала сериализовать и десериализовать,а затем назначить на него функции копирования.</target>
        </trans-unit>
        <trans-unit id="b77e5c1be59f320b6042fdf12c140f63ab1a4003" translate="yes" xml:space="preserve">
          <source>So let's create a &lt;code&gt;circular structure&lt;/code&gt; and a &lt;code&gt;nested object&lt;/code&gt; first.</source>
          <target state="translated">Итак, давайте сначала создадим &lt;code&gt;circular structure&lt;/code&gt; и &lt;code&gt;nested object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1e5d5e7a575e6d613efa42edbbd2bd59577f137" translate="yes" xml:space="preserve">
          <source>Some quick tests</source>
          <target state="translated">Некоторые быстрые тесты</target>
        </trans-unit>
        <trans-unit id="1ad81ed3b31b89f94fdfb8b814a7b408c0ce4ac4" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;How to copy JavaScript object to new variable NOT by reference?&lt;/a&gt;</source>
          <target state="translated">Источник: &lt;a href=&quot;https://stackoverflow.com/questions/18359093/how-to-copy-javascript-object-to-new-variable-not-by-reference?answertab=votes#tab-top&quot;&gt;Как скопировать объект JavaScript в новую переменную НЕ по ссылке?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">&lt;strong&gt;Polyfill&lt;/strong&gt; для поддержки старых браузеров:</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">Метод Object.assign()используется для копирования значений всех бесчисленных собственных свойств из одного или нескольких исходных объектов в целевой объект.</target>
        </trans-unit>
        <trans-unit id="8a4308022632fbf96a189f60d4c089e47657082a" translate="yes" xml:space="preserve">
          <source>The above function will work adequately for the 6 simple types I mentioned, as long as the data in the objects and arrays form a tree structure. That is, there isn't more than one reference to the same data in the object. For example:</source>
          <target state="translated">Вышеуказанная функция будет адекватно работать для 6 простых типов,о которых я говорил,до тех пор,пока данные в объектах и массивах образуют древовидную структуру.То есть в объекте не более одной ссылки на одни и те же данные.Например:</target>
        </trans-unit>
        <trans-unit id="032b503078d9391f3f083e20a6246421123e2d8b" translate="yes" xml:space="preserve">
          <source>The date string for &lt;code&gt;d1&lt;/code&gt; will be 5 seconds behind that of &lt;code&gt;d2&lt;/code&gt;. A way to make one &lt;code&gt;Date&lt;/code&gt; the same as another is by calling the &lt;code&gt;setTime&lt;/code&gt; method, but that is specific to the &lt;code&gt;Date&lt;/code&gt; class. I don't think there is a bullet-proof general solution to this problem, though I would be happy to be wrong!</source>
          <target state="translated">Строка даты для &lt;code&gt;d1&lt;/code&gt; будет на 5 секунд меньше, чем для &lt;code&gt;d2&lt;/code&gt; . Один из способов сделать одну и ту же &lt;code&gt;Date&lt;/code&gt; другим - вызвать метод &lt;code&gt;setTime&lt;/code&gt; , но это характерно для класса &lt;code&gt;Date&lt;/code&gt; . Я не думаю, что есть пуленепробиваемое общее решение этой проблемы, хотя я был бы рад ошибаться!</target>
        </trans-unit>
        <trans-unit id="043746030e244c05064aabe5e6c53eb1b00a3576" translate="yes" xml:space="preserve">
          <source>The first attempt I tried was using &lt;code&gt;JSON&lt;/code&gt;.</source>
          <target state="translated">Первая попытка, которую я попробовал, была с использованием &lt;code&gt;JSON&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f000a225c9b05dc90c944d0aaba92c15349755d" translate="yes" xml:space="preserve">
          <source>The last solution using recursion and a cache, may not be the best, but it's a &lt;strong&gt;real&lt;/strong&gt; deep-copy of the object. It handles simple &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;circular structures&lt;/code&gt; and &lt;code&gt;nested object&lt;/code&gt;, but it will mess up the instance of them while cloning.</source>
          <target state="translated">Последнее решение, использующее рекурсию и кеш, может быть не лучшим, но это &lt;strong&gt;настоящая&lt;/strong&gt; глубокая копия объекта. Он обрабатывает простые &lt;code&gt;properties&lt;/code&gt; , &lt;code&gt;circular structures&lt;/code&gt; и &lt;code&gt;nested object&lt;/code&gt; , но при их клонировании испортит их экземпляр.</target>
        </trans-unit>
        <trans-unit id="d2e920fb16fae1fedca17a36ec3baa9202cbb72d" translate="yes" xml:space="preserve">
          <source>The requirements are matched, but there are still some smaller issues, including changing the &lt;code&gt;instance&lt;/code&gt; of &lt;code&gt;nested&lt;/code&gt; and &lt;code&gt;circ&lt;/code&gt; to &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">Требования соответствуют, но все еще есть некоторые меньшие проблемы, включая изменение &lt;code&gt;instance&lt;/code&gt; &lt;code&gt;nested&lt;/code&gt; и &lt;code&gt;circ&lt;/code&gt; на &lt;code&gt;Object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29a4e57a808e70c1984cd4b7435f7b3b8f879529" translate="yes" xml:space="preserve">
          <source>The structure of trees that share a leaf won't be copied, they will become two independent leaves:</source>
          <target state="translated">Структура деревьев,которые делят лист,не будет скопирована,они станут двумя независимыми листьями:</target>
        </trans-unit>
        <trans-unit id="13a953842279c7fd9c49eb420b7ea3060cfc3c9f" translate="yes" xml:space="preserve">
          <source>There are many answers, but none that mentions &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; from ECMAScript 5, which admittedly does not give you an exact copy, but sets the source as the prototype of the new object.</source>
          <target state="translated">Есть много ответов, но ни один из них не упоминает &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create&lt;/a&gt; из ECMAScript 5, который, по общему признанию, не дает точной копии, но устанавливает источник в качестве прототипа нового объекта.</target>
        </trans-unit>
        <trans-unit id="cc7af0c92f6e6c0d9df4aaa342be3e26c98b8b64" translate="yes" xml:space="preserve">
          <source>There are several issues with most solutions on the internet. So I decided to make a follow-up, which includes, why the accepted answer shouldn't be accepted.</source>
          <target state="translated">Есть несколько вопросов с большинством решений в Интернете.Поэтому я решил сделать последующий шаг,который включает в себя,почему принятый ответ не должен быть принят.</target>
        </trans-unit>
        <trans-unit id="2138887f9e1a5984c4ac16aa3859fe4f272a050d" translate="yes" xml:space="preserve">
          <source>There is no need for external libraries but you need to check &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;browser compatibility first&lt;/a&gt;.</source>
          <target state="translated">Нет необходимости во внешних библиотеках, но &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility&quot;&gt;сначала&lt;/a&gt; нужно проверить совместимость браузера .</target>
        </trans-unit>
        <trans-unit id="f6df6c28aa1c494acefc67b48ca65405704b89a2" translate="yes" xml:space="preserve">
          <source>There's a polyfill for &lt;code&gt;Object.create&lt;/code&gt; in the older browser just like the IE 8. It's something like recommended by Mozilla, and of course, it's not perfect and results in the same problem as the &lt;em&gt;native solution&lt;/em&gt;.</source>
          <target state="translated">В старом браузере есть полифил для &lt;code&gt;Object.create&lt;/code&gt; , такой же как IE 8. Это что-то вроде рекомендованного Mozilla, и, конечно, оно не идеально и приводит к той же проблеме, что и &lt;em&gt;нативное решение&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="257b97895de4343bd020da12619838edee113900" translate="yes" xml:space="preserve">
          <source>This is an adaptation of A. Levy's code to also handle the cloning of functions and multiple/cyclic references - what this means is that if two properties in the tree which is cloned are references of the same object, the cloned object tree will have these properties point to one and the same clone of the referenced object. This also solves the case of cyclic dependencies which, if left unhandled, leads to an infinite loop. The complexity of the algorithm is O(n)</source>
          <target state="translated">Это-адаптация кода А.Леви для работы с клонированием функций и мультиплексическими ссылками-это означает,что если два свойства в дереве,которое клонируется,являются ссылками одного и того же объекта,то клонированное дерево объектов будет иметь эти свойства,указывающие на один и тот же клон ссылающегося объекта.Это также решает случай циклических зависимостей,который,если его оставить необработанным,приводит к бесконечному циклу.Сложность алгоритма O(n)</target>
        </trans-unit>
        <trans-unit id="3aeab4233dd61158490346563a83710fdb174f9f" translate="yes" xml:space="preserve">
          <source>This methodology was perfect for my use case, since I'm storing JSON blobs in a key-value store, and when they are exposed as objects in a JavaScript API, each object actually contains a copy of the original state of the object so we can calculate the delta after the caller has mutated the exposed object.</source>
          <target state="translated">Эта методология идеально подходит для моего случая использования,так как я храню JSON-блоки в хранилище значений ключей,и когда они выставляются как объекты в JavaScript API,каждый объект на самом деле содержит копию исходного состояния объекта,так что мы можем вычислить дельту после того,как вызывающий абонент мутировал выставленный объект.</target>
        </trans-unit>
        <trans-unit id="270c07e5aba6d333e589186ebce926ac9488ae45" translate="yes" xml:space="preserve">
          <source>This provides a clean method for a shallow copy of an object.  Making a deep copy, meaning makign a new copy of every value in every recursively nested object, requires on of the heavier solutions above.</source>
          <target state="translated">Это обеспечивает чистый метод для неглубокой копии объекта.Сделать глубокую копию,то есть создать новую копию каждого значения в каждом рекурсивно вложенном объекте,требует более тяжелых решений,чем указано выше.</target>
        </trans-unit>
        <trans-unit id="c3d98944d47265d765fc5c22fd2d0a49ddc89117" translate="yes" xml:space="preserve">
          <source>This solution was added to Javascript some time ago and even handles &lt;code&gt;circular structure&lt;/code&gt;.</source>
          <target state="translated">Это решение было добавлено в Javascript некоторое время назад и даже обрабатывает &lt;code&gt;circular structure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d709893b9322713175a8239aabd951c8aa101e46" translate="yes" xml:space="preserve">
          <source>This works for all kind of objects containing objects, arrays, strings, booleans and numbers.</source>
          <target state="translated">Это работает для всех видов объектов,содержащих объекты,массивы,строки,булеры и числа.</target>
        </trans-unit>
        <trans-unit id="be7e283523bee098c95fbd259fdb185444007880" translate="yes" xml:space="preserve">
          <source>Thus, this is not an exact answer to the question, but it is a one-line solution and thus elegant. And it works best for 2 cases:</source>
          <target state="translated">Таким образом,это не точный ответ на вопрос,а однолинейное решение,а значит,элегантное.И оно лучше всего работает в 2-х случаях:</target>
        </trans-unit>
        <trans-unit id="b36783ae8f97bf075d43eb8bdee3e68cae031c5d" translate="yes" xml:space="preserve">
          <source>To do this for any object in JavaScript will not be simple or straightforward. You will run into the problem of erroneously picking up attributes from the object's prototype that should be left in the prototype and not copied to the new instance. If, for instance, you are adding a &lt;code&gt;clone&lt;/code&gt; method to &lt;code&gt;Object.prototype&lt;/code&gt;, as some answers depict, you will need to explicitly skip that attribute. But what if there are other additional methods added to &lt;code&gt;Object.prototype&lt;/code&gt;, or other intermediate prototypes, that you don't know about? In that case, you will copy attributes you shouldn't, so you need to detect unforeseen, non-local attributes with the &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Сделать это для любого объекта в JavaScript не будет просто или просто. Вы столкнетесь с проблемой ошибочного выбора атрибутов из прототипа объекта, которые следует оставить в прототипе и не копировать в новый экземпляр. Например, если вы добавляете метод &lt;code&gt;clone&lt;/code&gt; в &lt;code&gt;Object.prototype&lt;/code&gt; , как показывают некоторые ответы, вам необходимо явно пропустить этот атрибут. Но что, если есть другие дополнительные методы, добавленные в &lt;code&gt;Object.prototype&lt;/code&gt; или другие промежуточные прототипы, о которых вы не знаете? В этом случае вы скопируете атрибуты, которые не следует делать, поэтому вам нужно обнаружить непредвиденные нелокальные атрибуты с &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;hasOwnProperty&lt;/code&gt; &lt;/a&gt; метода hasOwnProperty .</target>
        </trans-unit>
        <trans-unit id="a913fb7183b6fb881c9a823ab39998ee4aa93f87" translate="yes" xml:space="preserve">
          <source>Using Lodash:</source>
          <target state="translated">Используя Лодаш:</target>
        </trans-unit>
        <trans-unit id="ca5a4f97de6e6ecec887d15f3ba764fe9304dac1" translate="yes" xml:space="preserve">
          <source>When I had to implement general deep copying I ended up compromising by assuming that I would only need to copy a plain &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Boolean&lt;/code&gt;. The last 3 types are immutable, so I could perform a shallow copy and not worry about it changing. I further assumed that any elements contained in &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt; would also be one of the 6 simple types in that list. This can be accomplished with code like the following:</source>
          <target state="translated">Когда мне пришлось реализовать общее глубокое копирование, я в итоге пошел на компромисс, предполагая, что мне нужно будет только скопировать простой &lt;code&gt;Object&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; или &lt;code&gt;Boolean&lt;/code&gt; . Последние 3 типа являются неизменяемыми, поэтому я мог выполнять поверхностное копирование и не беспокоиться о его изменении. Я также предположил, что любые элементы, содержащиеся в &lt;code&gt;Object&lt;/code&gt; или &lt;code&gt;Array&lt;/code&gt; , также будут одним из 6 простых типов в этом списке. Это может быть выполнено с помощью кода, подобного следующему:</target>
        </trans-unit>
        <trans-unit id="456e0fb41b68296ae4fca0c5da8c6c8c99b050d9" translate="yes" xml:space="preserve">
          <source>When digging around, I found a similar question (&lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;In Javascript, when performing a deep copy, how do I avoid a cycle, due to a property being &quot;this&quot;?&lt;/a&gt;) to this one, but with a way better solution.</source>
          <target state="translated">Копаясь, я нашел похожий вопрос ( &lt;a href=&quot;https://stackoverflow.com/questions/10728412/in-javascript-when-performing-a-deep-copy-how-do-i-avoid-a-cycle-due-to-a-pro&quot;&gt;в Javascript, когда я выполняю глубокое копирование, как мне избежать цикла из-за свойства &amp;laquo;this&amp;raquo;?&lt;/a&gt; ) На этот, но с более лучшим решением.</target>
        </trans-unit>
        <trans-unit id="a9252c930b2a9734d9944f251662812bcd0d5878" translate="yes" xml:space="preserve">
          <source>Where such inheritance is useful (duh!)</source>
          <target state="translated">Где такое наследование полезно (ду!).</target>
        </trans-unit>
        <trans-unit id="f3f6684c458c70cb9d8e7a984298d711252184ac" translate="yes" xml:space="preserve">
          <source>Where the source object won't be modified, thus making the relation between the 2 objects a non issue.</source>
          <target state="translated">Где исходный объект не будет изменен,что делает отношения между двумя объектами несущественными.</target>
        </trans-unit>
        <trans-unit id="2735aa18f20ac2191686e23824f2e5be39288c5c" translate="yes" xml:space="preserve">
          <source>Why do I consider this solution to be superior? It's native, thus no looping, no recursion. However, older browsers will need a polyfill.</source>
          <target state="translated">Почему я считаю это решение превосходящим? Оно родное,поэтому ни петли,ни рекурсии.Однако,старым браузерам понадобится полифайл.</target>
        </trans-unit>
        <trans-unit id="c4313b8450309f35ea2494e7d2513a055de02aeb" translate="yes" xml:space="preserve">
          <source>With jQuery, you can &lt;strong&gt;shallow copy&lt;/strong&gt; with &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;extend&lt;/a&gt;:</source>
          <target state="translated">С помощью jQuery вы можете &lt;strong&gt;копировать&lt;/strong&gt; с &lt;a href=&quot;http://api.jquery.com/jQuery.extend&quot;&gt;расширением&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc955433235b02b7f40b76eb1d7dfddf892c4a6e" translate="yes" xml:space="preserve">
          <source>Yet another snag in the quest for an elegant solution is the problem of setting up the prototype inheritance correctly. If your source object's prototype is &lt;code&gt;Object&lt;/code&gt;, then simply creating a new general object with &lt;code&gt;{}&lt;/code&gt; will work, but if the source's prototype is some descendant of &lt;code&gt;Object&lt;/code&gt;, then you are going to be missing the additional members from that prototype which you skipped using the &lt;code&gt;hasOwnProperty&lt;/code&gt; filter, or which were in the prototype, but weren't enumerable in the first place. One solution might be to call the source object's &lt;code&gt;constructor&lt;/code&gt; property to get the initial copy object and then copy over the attributes, but then you still will not get non-enumerable attributes. For example, a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object stores its data as a hidden member:</source>
          <target state="translated">Еще одним препятствием в поиске элегантного решения является проблема правильной настройки наследования прототипа. Если прототипом вашего исходного объекта является &lt;code&gt;Object&lt;/code&gt; , тогда будет работать просто создание нового общего объекта с помощью &lt;code&gt;{}&lt;/code&gt; , но если прототип исходного &lt;code&gt;Object&lt;/code&gt; является неким потомком Object , то вы пропустите дополнительные члены из этого прототипа, который вы пропустили, используя Фильтр &lt;code&gt;hasOwnProperty&lt;/code&gt; , или который был в прототипе, но не был перечисляемым в первую очередь. Одним из решений может быть вызов свойства &lt;code&gt;constructor&lt;/code&gt; исходного объекта для получения исходного объекта копирования, а затем копирования атрибутов, но тогда вы все равно не получите неперечислимые атрибуты. Например, объект &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; сохраняет свои данные как скрытый член:</target>
        </trans-unit>
        <trans-unit id="f6ada691f9c830b134d1063e166e1d147221dcb3" translate="yes" xml:space="preserve">
          <source>You can clone an object and remove any reference from the previous one using a single line of code. Simply do:</source>
          <target state="translated">Вы можете клонировать объект и удалить любую ссылку с предыдущей,используя одну строку кода.Просто сделайте это:</target>
        </trans-unit>
        <trans-unit id="2fb59e1d6040b949307491685dc51fd64aac4887" translate="yes" xml:space="preserve">
          <source>You can simply use a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;spread property&lt;/a&gt; to copy an object without references. But be careful (see comments), the 'copy' is just on the lowest object/array level. Nested properties are still references!</source>
          <target state="translated">Вы можете просто использовать &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md&quot;&gt;свойство распространения,&lt;/a&gt; чтобы скопировать объект без ссылок. Но будьте осторожны (см. Комментарии), &amp;laquo;копия&amp;raquo; находится на самом низком уровне объекта / массива. Вложенные свойства все еще являются ссылками!</target>
        </trans-unit>
        <trans-unit id="9abb2632977048faaf1083e1bdfe1addfa67decb" translate="yes" xml:space="preserve">
          <source>You know what happened here because if not you wouldn't even land on this great question.</source>
          <target state="translated">Ты знаешь,что здесь произошло,потому что если бы не ты,то даже не приземлился бы на этот великий вопрос.</target>
        </trans-unit>
        <trans-unit id="6a38a38f03e4ff5839ba4a879178cce5bc42666b" translate="yes" xml:space="preserve">
          <source>conclusion</source>
          <target state="translated">conclusion</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716e96afcc9beb903225a881db7f167667cc2eb3" translate="yes" xml:space="preserve">
          <source>jsfiddle</source>
          <target state="translated">jsfiddle</target>
        </trans-unit>
        <trans-unit id="352f260ed32601f2720cbdef8b42f9882a4102af" translate="yes" xml:space="preserve">
          <source>native solution</source>
          <target state="translated">оригинальное решение</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="c5b130d2294080fe3f54b6ede9cb6c33d3a49d6b" translate="yes" xml:space="preserve">
          <source>or using spread operator like this:</source>
          <target state="translated">или используя такой оператор спреда:</target>
        </trans-unit>
        <trans-unit id="82ae245159e159776ea37d68d57ddfa387a83600" translate="yes" xml:space="preserve">
          <source>or you can extend it like</source>
          <target state="translated">или вы можете продлить его как</target>
        </trans-unit>
        <trans-unit id="3e0bf88b357a046b4e7659fed6103de63a9734cd" translate="yes" xml:space="preserve">
          <source>polyfill for the native solution</source>
          <target state="translated">полипропилен для натурального раствора</target>
        </trans-unit>
        <trans-unit id="55d9bbd3efbab583726fcd7c3ad976b8129b76ee" translate="yes" xml:space="preserve">
          <source>starting situation</source>
          <target state="translated">исходная ситуация</target>
        </trans-unit>
        <trans-unit id="a5f7a257ae51fb7db8f01b3b457418d96c6a2a00" translate="yes" xml:space="preserve">
          <source>subsequent changes to the &lt;code&gt;copiedObject&lt;/code&gt; will not affect the &lt;code&gt;originalObject&lt;/code&gt;, and vice versa.</source>
          <target state="translated">последующие изменения в &lt;code&gt;copiedObject&lt;/code&gt; не будут влиять на &lt;code&gt;originalObject&lt;/code&gt; , и наоборот.</target>
        </trans-unit>
        <trans-unit id="2ba1210fdf174274ea55c483bb6ade889c52e126" translate="yes" xml:space="preserve">
          <source>the answer is mainly depeneds on which &lt;strong&gt;ECMAscript&lt;/strong&gt; you using, in &lt;code&gt;ES6+&lt;/code&gt;, you can simply use &lt;code&gt;Object.assign&lt;/code&gt; to do the clone:</source>
          <target state="translated">Ответ в основном зависит от того, какой ECMA-скрипт вы используете, в &lt;code&gt;ES6+&lt;/code&gt; вы можете просто использовать &lt;code&gt;Object.assign&lt;/code&gt; , чтобы сделать клон:</target>
        </trans-unit>
        <trans-unit id="522547b9c4325ca856f8c4192d0ad23de9c33613" translate="yes" xml:space="preserve">
          <source>the better (but not perfect) solution</source>
          <target state="translated">лучшее (но не идеальное)решение</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
