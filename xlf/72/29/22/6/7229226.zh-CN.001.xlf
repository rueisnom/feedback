<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/7229226">
    <body>
      <group id="7229226">
        <trans-unit id="101513b86d72ed6fcdb26b5d3b3a91761a1a7eeb" translate="yes" xml:space="preserve">
          <source>(I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">我只能认为增加不同屏幕分辨率的系统之间的便携性)。</target>
        </trans-unit>
        <trans-unit id="f322b9e0be596ee0c12c766b6f6362bac3fda875" translate="yes" xml:space="preserve">
          <source>(The answer to 4 is &quot;no&quot;.)</source>
          <target state="translated">(4的答案是 &quot;不&quot;)。</target>
        </trans-unit>
        <trans-unit id="a62f3745308389d8190dd4aa927eccdaa9df3d4a" translate="yes" xml:space="preserve">
          <source>1) Should I completely avoid the use of those methods?</source>
          <target state="translated">1)我应该完全避免使用这些方法吗?</target>
        </trans-unit>
        <trans-unit id="9be06212edf76a1a8f22e4f87f620e98f3917e4f" translate="yes" xml:space="preserve">
          <source>2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</source>
          <target state="translated">2)方法的确定是有原因的。那么我应该在什么时候使用它们?在什么情况下使用?用来做什么用途?</target>
        </trans-unit>
        <trans-unit id="3129078a99b0f0599191614194a02dd301b6ef4c" translate="yes" xml:space="preserve">
          <source>3) What exactly are the negative consequences of using those methods?</source>
          <target state="translated">3)使用这些方法究竟有哪些不良后果?</target>
        </trans-unit>
        <trans-unit id="e4537f34f955a436cd38a10e8ea7eee57157f6f1" translate="yes" xml:space="preserve">
          <source>4) I don't think any LayoutManager can exactly satisfy all desired layout needs.</source>
          <target state="translated">4)我不认为任何一个LayoutManager可以完全满足所有想要的布局需求。</target>
        </trans-unit>
        <trans-unit id="a50e32a4d28ac833b32f3d7ebf4edda651c47cb3" translate="yes" xml:space="preserve">
          <source>5) If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">5)如果4的答案是 &quot;是的&quot;,那么这是否会导致LayoutManager类的激增,会不会导致LayoutManager类的泛滥,从而变得难以维护?</target>
        </trans-unit>
        <trans-unit id="9e4a5573061af9e7df2555b66d39ace412023fef" translate="yes" xml:space="preserve">
          <source>6) In a situation where I need to define proportions...</source>
          <target state="translated">6)在我需要定义比例的情况下......</target>
        </trans-unit>
        <trans-unit id="caae42b05fc60c9860a79b7d9ccb2ea61214c824" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JFrame&lt;/code&gt; does not enforce overriden &lt;code&gt;getMinimumSize()&lt;/code&gt; only calling &lt;code&gt;setMinimumSize(..)&lt;/code&gt; on its works</source>
          <target state="translated">&lt;code&gt;JFrame&lt;/code&gt; 不会在其工作中仅调用 &lt;code&gt;setMinimumSize(..)&lt;/code&gt; 来强制执行重写的 &lt;code&gt;getMinimumSize()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3647248e0173f71dd2355fcf20828a2dedaf8e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?&lt;/strong&gt; You shouldn't &quot;implement&quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they're hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never &quot;implement&quot; a layout manager. I just instantiate them.</source>
          <target state="translated">&lt;strong&gt;我认为任何LayoutManager都无法完全满足所有所需的布局需求。&lt;/strong&gt; &lt;strong&gt;我真的需要为我的布局中的每个小变化实现一个新的LayoutManager吗？&lt;/strong&gt; 您不应该&amp;ldquo;实现&amp;rdquo;新的LayoutManager。 您应该实例化现有的。 我经常在一个窗口中使用多个布局管理器。 每个JPanel将具有自己的布局管理器。 有些人不愿使用嵌套的布局，因为它们很难维护。 当我使用它们时，我给每个人自己的创建方法，以便更轻松地查看每个人的工作。 但是我从来没有&amp;ldquo;实现&amp;rdquo;布局管理器。 我只是实例化它们。</target>
        </trans-unit>
        <trans-unit id="edce1b4cb1e94b90bfc85934288d525da7af49fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?&lt;/strong&gt;
If you're implementing new layout manager classes for slight variations in layout, you're using them wrong. If you're just implementing new layout managers, you're probably doing something wrong. The only time I've extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.</source>
          <target state="translated">&lt;strong&gt;如果对4的回答为&amp;ldquo;是&amp;rdquo;，这是否会导致LayoutManager类的泛滥而使维护变得困难？&lt;/strong&gt; 如果您要实现新的布局管理器类以使布局略有变化，那么您将错误地使用它们。 如果您只是实施新的布局管理器，则可能是做错了什么。 我唯一的扩展LayoutManager类的方法是向JScrollPane添加缩放滑块。</target>
        </trans-unit>
        <trans-unit id="bac7ad7f05d5d55847b7fd4cc2f7ed1978917af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?&lt;/strong&gt;
The JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don't use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.</source>
          <target state="translated">&lt;strong&gt;在需要定义Component的子代之间比例的情况下（例如，child1应该使用10％的空间，child2 40％，child3 50％的空间），是否可以在不实现自定义LayoutManager的情况下实现？&lt;/strong&gt; JSplitPane有一种方法可以指定每个组件应获得的百分比。 默认情况下，分隔线是可移动的，但是您可以根据需要将其关闭。 我没有太多使用该功能。 我通常有一些组件会占据一定的大小，其余空间则由滚动窗格占据。 滚动窗格的大小将根据窗口大小进行调整。 如果有两个并排的滚动窗格，则可以将它们放在JSplitPane中，并在用户扩展和收缩窗口时指定分配给每个滚动窗格的新空间的百分比。</target>
        </trans-unit>
        <trans-unit id="2ef0079b6c8a172dd2c245d6fc600772f49ecf38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="253649f0361fd376d76e98ac2e931514bc001bdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Should I completely avoid the use of those methods?&lt;/strong&gt;
I wouldn't say &quot;avoid&quot; them. I'd say that if you think you need them, you're probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call &lt;code&gt;setSize()&lt;/code&gt;, and let that size determine the initial window size, by calling &lt;code&gt;JFrame.pack()&lt;/code&gt;. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don't do much good.</source>
          <target state="translated">&lt;strong&gt;我应该完全避免使用那些方法吗？&lt;/strong&gt; 我不会说&amp;ldquo;避免&amp;rdquo;它们。 我想说的是，如果您认为自己需要它们，那您可能做错了什么。 组件的大小取决于上下文。 例如，文本组件的大小由您指定的行数和列数以及您可能选择的字体决定。 如果设置了一个，则按钮和标签的大小将是图形的大小，或者是显示设置的文本所需的空间。 每个组件都有自然的大小，布局管理器将使用这些大小来布局所有内容，而无需指定大小。 主要的例外是JScrollPane，它的大小与其所包含的内容无关。 对于这些，有时我会调用 &lt;code&gt;setSize()&lt;/code&gt; ，并通过调用 &lt;code&gt;JFrame.pack()&lt;/code&gt; 来确定初始窗口的大小。 通常，我将让窗口大小确定JScrollPane的大小。 用户将确定窗口的大小。 无论如何，许多布局管理器都会忽略您设置的尺寸，因此它们通常做得不好。</target>
        </trans-unit>
        <trans-unit id="bb29b79b090f0d71d579ecfac48293fc02a91481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?&lt;/strong&gt;
I believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn't fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn't want to bother with learning a new paradigm. It's a terrible idea.</source>
          <target state="translated">&lt;strong&gt;出于某种原因定义了这些方法。&lt;/strong&gt; &lt;strong&gt;那么我什么时候应该使用它们呢？&lt;/strong&gt; &lt;strong&gt;在哪种情况下？&lt;/strong&gt; &lt;strong&gt;出于什么目的？&lt;/strong&gt; 我相信添加它们是为了向布局管理器提供提示。 他们之所以写是因为历史原因，因为布局经理是新来的，人们并不完全信任他们。 我知道一些开发人员避免布局管理器，而是手动放置所有内容，只是因为他们不想为学习新的范式而烦恼。 这是一个可怕的主意。</target>
        </trans-unit>
        <trans-unit id="f2a560db0d72f5a999aad79685126287e9f8c227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).&lt;/strong&gt;
They're ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.</source>
          <target state="translated">&lt;strong&gt;使用这些方法的负面后果到底是什么？&lt;/strong&gt; &lt;strong&gt;（我只能考虑在具有不同屏幕分辨率的系统之间增加可移植性）。&lt;/strong&gt; 它们效果不佳，并且布局不好，物体被挤压或拉伸到非自然尺寸。 而且布局会很脆弱。 更改窗口大小有时会破坏布局并将东西放置在错误的位置。</target>
        </trans-unit>
        <trans-unit id="75fd8314886af2005f7a571fef2f798a7e7172e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMaximumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMaximumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b11ddbbe6a3af1821698ada76274100c165c48cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMinimumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMinimumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89f81cef98f01aaa7c3a87a7392da5c9df43268c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setPreferredSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setPreferredSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8f222d9ad21513e10bd84b95b5bf37337e1762a" translate="yes" xml:space="preserve">
          <source>A few heuristics:</source>
          <target state="translated">几种启发式的方法。</target>
        </trans-unit>
        <trans-unit id="5ed3ba4403e948d10f0d964a8030523919a40837" translate="yes" xml:space="preserve">
          <source>All that said, you can certainly conceive of situations where these methods are justified. Again, they aren't inherently evil, but their usage is normally a &lt;strong&gt;big&lt;/strong&gt; red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.</source>
          <target state="translated">综上所述，您当然可以设想这些方法合理的情况。 同样，它们并不是天生的邪恶，但是它们的用法通常是一个&lt;strong&gt;大的&lt;/strong&gt;红旗，表明潜在的GUI问题。 只需确保您意识到使用并发症的高可能性，并始终尝试思考是否存在另一种与外观无关的解决方案，但往往会发现这些方法不是必需的。</target>
        </trans-unit>
        <trans-unit id="334e464b55e6cbe9ef940d5fd89ee52a5a006400" translate="yes" xml:space="preserve">
          <source>Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars. 
As opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).</source>
          <target state="translated">始终是这样的。当你创建一个组件时,根据该组件的用途,设置其实际的minpreferredmax大小。例如,如果你有一个JTextField用于输入国家符号,如英国,它的首选大小应尽可能的宽,以适应两个字符(用当前的字体等),但可能让它再大也没有意义。毕竟,国家符号是两个字符。反之,如果你有一个JTextField来输入例如客户的名字,它可以有一个类似于20个字符的像素大小,但是如果调整布局的大小,它可以变大,所以设置为最大的大小。同时,有一个0px宽的JTextField是没有意义的,所以要设置一个现实的最小尺寸(我会说是2个字符的像素大小)。</target>
        </trans-unit>
        <trans-unit id="82a3275f2c6e319fc8e6e971d584332b7226964d" translate="yes" xml:space="preserve">
          <source>Any of the Big-Three can, can't even GridBag (never bothered to really master, too much trouble for too little power).</source>
          <target state="translated">大三的任何一个都可以,连GridBag都做不到(从来没费心去真正的掌握,太麻烦了力量太小)。</target>
        </trans-unit>
        <trans-unit id="feada63cf7671891364a8ad7e4d18aec070ec6ec" translate="yes" xml:space="preserve">
          <source>As an example of this, try changing your application's default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.</source>
          <target state="translated">作为一个例子,尝试改变你的应用程序的默认外观和感觉。即使只是使用了你的平台上的可用选项,你可能会惊讶于渲染的结果有多差。</target>
        </trans-unit>
        <trans-unit id="e2f886c1766f46b82d763352fa65f26f99701edd" translate="yes" xml:space="preserve">
          <source>Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).</source>
          <target state="translated">基本上,一旦偏好的尺寸设置好了,你可能就不想做任何百分比的事情了。很简单,因为百分比是没有意义的(例如,JTextField是窗口大小的10%是没有意义的--因为你可以缩小窗口,使JTextField变成0px宽,或者在多显示器设置中,可以扩展窗口,使JTextField跨越两个显示器)。</target>
        </trans-unit>
        <trans-unit id="44d763212c6c3a8fea4302c81748f40a5af6a256" translate="yes" xml:space="preserve">
          <source>But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).</source>
          <target state="translated">但是,有时你可能会用百分比来控制你的gui中较大的积木(例如面板)的大小。</target>
        </trans-unit>
        <trans-unit id="78233fddc435250272d7f9a010e1be36ab861764" translate="yes" xml:space="preserve">
          <source>By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies' &lt;code&gt;FormLayout&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;http://www.miglayout.com/&quot;&gt;&lt;code&gt;MigLayout&lt;/code&gt;&lt;/a&gt;. Some GUI builders even have built-in support for third-party layout managers -- Eclipse's WindowBuilder GUI editor, for example, ships with support for &lt;code&gt;FormLayout&lt;/code&gt; and &lt;code&gt;MigLayout&lt;/code&gt;.</source>
          <target state="translated">顺便说一句，如果您发现自己对标准布局管理器感到沮丧，那么有很多不错的免费，开源的第三方管理器，例如&lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies的 &lt;code&gt;FormLayout&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://www.miglayout.com/&quot;&gt; &lt;code&gt;MigLayout&lt;/code&gt; &lt;/a&gt; 。 一些GUI生成器甚至内置了对第三方布局管理器的支持-例如，Eclipse的WindowBuilder GUI编辑器附带对 &lt;code&gt;FormLayout&lt;/code&gt; 和 &lt;code&gt;MigLayout&lt;/code&gt; 的支持。</target>
        </trans-unit>
        <trans-unit id="28464854017f94b9c9844769ee6144deaf548b29" translate="yes" xml:space="preserve">
          <source>Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;comments&lt;/a&gt;.</source>
          <target state="translated">如发现这些&lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;注释中&lt;/a&gt;所述，当您发现必须遍历许多组件以获得派生的大小时，请考虑使用备用布局或自定义布局。</target>
        </trans-unit>
        <trans-unit id="be6bbc414031de61f515ad578e905cd0b742227e" translate="yes" xml:space="preserve">
          <source>Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">我真的需要为我的布局上的每一个小变化实现一个新的LayoutManager吗?</target>
        </trans-unit>
        <trans-unit id="7cf1d64fab0d093b37c52e515ee1f02d1c34c796" translate="yes" xml:space="preserve">
          <source>Do use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; to derive post-&lt;code&gt;validate()&lt;/code&gt; geometry, as shown below and &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">一定要使用 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 来获取postvalid &lt;code&gt;validate()&lt;/code&gt; 几何，如下所示。</target>
        </trans-unit>
        <trans-unit id="157eda23f1458fbcc63f756b719fa42aa4d3266a" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you could rely on a component's carefully overridden &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt;, as shown &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt; and below.</source>
          <target state="translated">当您可以依赖组件精心重写的 &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt; ，请不要使用 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; ，如下所示。</target>
        </trans-unit>
        <trans-unit id="4546245bd9fc2988f588e0ddf7f4de2e035d8826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you really mean to override &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt;, as might be done in creating your own component, shown &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">当您确实要覆盖 &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt; ，请勿使用 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; （） ，如创建您自己的组件时所做的那样，如下所示。</target>
        </trans-unit>
        <trans-unit id="8858a12745633838c34a2266f3595b758ee64852" translate="yes" xml:space="preserve">
          <source>For example, the layout below:</source>
          <target state="translated">例如,下面的布局。</target>
        </trans-unit>
        <trans-unit id="0b5b0c3f88d9871a3e20dffd7b5aea8ad3241262" translate="yes" xml:space="preserve">
          <source>I am seeing it differenty than the accepted answer.</source>
          <target state="translated">我看到的是与接受的答案不同。</target>
        </trans-unit>
        <trans-unit id="c0e9dfc40abc06677021939bbd23ed04299fd51d" translate="yes" xml:space="preserve">
          <source>I don't know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. &quot;Slightly&quot;, because they should have implemented their needs with a custom LayoutManager.</source>
          <target state="translated">我不知道,我个人认为是API设计的意外。稍微是由于复合组件对子系统尺寸有特殊的想法而被迫的。&quot;略微&quot;,因为他们应该用自定义的LayoutManager来实现自己的需求。</target>
        </trans-unit>
        <trans-unit id="05debf8858189b34f73fdc5385802a59b437dec7" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout
  needs. Do I really need to implement a new LayoutManager for every
  little variation on my layout?</source>
          <target state="translated">我不认为任何一个LayoutManager都能完全满足所有想要的布局需求。我真的需要为我的布局的每一个小的变化实现一个新的LayoutManager吗?</target>
        </trans-unit>
        <trans-unit id="e293825a482ffdbc279a19695ddf553407dbbc00" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">我不认为任何一个LayoutManager可以完全满足所有的布局需求。我真的需要为我的布局的每一个小的变化实现一个新的LayoutManager吗?</target>
        </trans-unit>
        <trans-unit id="f03332e8b0533248fe9e9bec74b216b33f9c8672" translate="yes" xml:space="preserve">
          <source>I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.</source>
          <target state="translated">我已经写了8年多的Swing代码了,JDK中的布局管理器一直在满足我的需求。我从未需要过第三方布局管理器来实现我的布局。</target>
        </trans-unit>
        <trans-unit id="45e24a1aab4e46086de24e1bd00ae96195747270" translate="yes" xml:space="preserve">
          <source>I have searched the web a little bit, but I haven't found any comprehensive analysis of the subject. So I have the following questions:</source>
          <target state="translated">我在网上搜索了一下,但没有找到任何关于这个问题的综合分析。所以,我有以下几个问题。</target>
        </trans-unit>
        <trans-unit id="d19e84a41484b2716bcc34a770e49e845d1ffe27" translate="yes" xml:space="preserve">
          <source>I will say that you shouldn't try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.</source>
          <target state="translated">我想说的是,在你确定自己需要之前,你不应该尝试用这些方法给排版管理器提示。在不给任何尺寸提示的情况下进行排版(也就是说,让排版管理器完成它的工作),然后你可以在需要的时候做一些小的修改。</target>
        </trans-unit>
        <trans-unit id="4952d1d9c2545ce08ec8f0dfb48594021c83f640" translate="yes" xml:space="preserve">
          <source>If a component has no preferred size, e.g. &lt;code&gt;JDesktopPane&lt;/code&gt;, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.</source>
          <target state="translated">如果组件没有首选的大小，例如 &lt;code&gt;JDesktopPane&lt;/code&gt; ，则可能需要调整容器的大小，但是任何这样的选择都是任意的。 发表评论可能有助于澄清意图。</target>
        </trans-unit>
        <trans-unit id="1c43bb7e290acdfdc7dbe1b01a2c5332529346f1" translate="yes" xml:space="preserve">
          <source>If by implementing you mean using then yes. Not one &lt;code&gt;LayoutManger&lt;/code&gt; can handle everything, each &lt;code&gt;LayoutManager&lt;/code&gt; has its pros and cons thus each can be used together to produce the final layout.</source>
          <target state="translated">如果实现是指使用，则可以。 没有一个 &lt;code&gt;LayoutManger&lt;/code&gt; 可以处理所有事情，每个 &lt;code&gt;LayoutManager&lt;/code&gt; 都有其优缺点，因此可以一起使用以生成最终的布局。</target>
        </trans-unit>
        <trans-unit id="87d62286cfbf65303a6f848ee0864f361f380b7a" translate="yes" xml:space="preserve">
          <source>If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">如果4的答案是 &quot;是的&quot;,那么这是否会导致LayoutManager类的激增,从而导致LayoutManager类的维护变得困难?</target>
        </trans-unit>
        <trans-unit id="b063186389f8146493b73685b897b69952730e47" translate="yes" xml:space="preserve">
          <source>If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies &lt;code&gt;FormLayout&lt;/code&gt; provided freely as part of the Forms freeware library by Karsten Lentzsch &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">如果您在使用Java Swing中的布局时遇到麻烦，那么我强烈建议您在&lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;此处&lt;/a&gt;免费获得JGoodies &lt;code&gt;FormLayout&lt;/code&gt; ，它是Karsten Lentzsch作为Forms免费软件库的一部分免费提供的。</target>
        </trans-unit>
        <trans-unit id="d96461400848ad4f167b8f2e7b96036043cb5c45" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?</source>
          <target state="translated">在我需要定义一个组件中的子组件之间的比例(子组件1应该使用10%的空间,子组件2应该使用40%,子组件3应该使用50%)的情况下,是否可以在不实现自定义布局管理器的情况下实现?</target>
        </trans-unit>
        <trans-unit id="5063acd66afacb43577cb43e4e3c3bef2c93feea" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">在我需要定义一个组件的子组件之间的比例(例如,子组件1应该使用10%的空间,子组件2应该使用40%的空间,子组件3应该使用50%的空间)的情况下,是否可以在不实现自定义的LayoutManager的情况下实现?</target>
        </trans-unit>
        <trans-unit id="031cb987d53c63d3108a20db2267a8bb488faae2" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">在我需要定义一个组件的子组件之间的比例(例如,子组件1应该使用10%的空间,子组件2应该使用40%,子组件3应该使用50%)的情况下,是否可以在不实现自定义LayoutManager的情况下实现?</target>
        </trans-unit>
        <trans-unit id="8749b6c1a91e73f14a6ee417ecb38965be650eb9" translate="yes" xml:space="preserve">
          <source>Make sure that you really need to set the component's exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied &lt;em&gt;looks&lt;/em&gt; of the UI on different Systems</source>
          <target state="translated">确保您确实需要设置组件的确切大小。 每个Swing组件都有不同的首选大小，具体取决于它使用的字体以及外观。 因此，设置大小可能会在不同系统上产生不同的UI &lt;em&gt;外观&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83665a294fe3f65e2b8c5d56e4046be52e81d907" translate="yes" xml:space="preserve">
          <source>Many layout managers do not pay attention to a component's requested maximum size. However, &lt;code&gt;BoxLayout&lt;/code&gt; and &lt;code&gt;SpringLayout&lt;/code&gt; do. Furthermore, &lt;code&gt;GroupLayout&lt;/code&gt; provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.</source>
          <target state="translated">许多布局管理器并不关注组件所请求的最大大小。 但是， &lt;code&gt;BoxLayout&lt;/code&gt; 和 &lt;code&gt;SpringLayout&lt;/code&gt; 可以。 此外， &lt;code&gt;GroupLayout&lt;/code&gt; 提供了显式设置最小，首选或最大尺寸的功能，而无需接触组件。</target>
        </trans-unit>
        <trans-unit id="ab89da0d68317915b0b083e37c7f4c657b21e4bb" translate="yes" xml:space="preserve">
          <source>Maybe &lt;code&gt;GridBagLayout&lt;/code&gt; would satisfy your needs. Besides that, there's a ton of layout managers on the web, and I bet there's one that fits your requirements.</source>
          <target state="translated">也许 &lt;code&gt;GridBagLayout&lt;/code&gt; 可以满足您的需求。 除此之外，网络上还有大量的布局管理器，我敢打赌，这里有一款适合您的需求。</target>
        </trans-unit>
        <trans-unit id="5ec1d5cb339ea8bf28dabdc16b8ff8f4073ed0c4" translate="yes" xml:space="preserve">
          <source>Most importantly no matter how you specify your component's size, be sure that your component's container uses a layout manager that respects the requested size of the component.</source>
          <target state="translated">最重要的是,无论你如何指定你的组件的大小,都要确保你的组件的容器使用一个尊重组件所要求的大小的布局管理器。</target>
        </trans-unit>
        <trans-unit id="ec7904135c872d5504ba4625fa4861d3640b70e4" translate="yes" xml:space="preserve">
          <source>Never avoid! They're there to express the size constraints of your components to the layout manager. You can avoid using them if you're not using any layout manager and try to manage the visual layout on your own.</source>
          <target state="translated">千万不要回避! 它们的存在是为了向布局管理器表达你的组件的大小限制。如果你不使用任何布局管理器,并尝试自己管理视觉布局,你可以避免使用它们。</target>
        </trans-unit>
        <trans-unit id="019c97b9fc48d56cdc8c3608bba924a9b70932a7" translate="yes" xml:space="preserve">
          <source>No negative consequences. These are hints for the layout manager.</source>
          <target state="translated">不会产生不良后果。这些都是对版主的提示。</target>
        </trans-unit>
        <trans-unit id="5a8a6ea846414fc7b77ae01acccc90b507c47c69" translate="yes" xml:space="preserve">
          <source>No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.</source>
          <target state="translated">不,肯定不是。通常的做法是级联不同的基本布局者,如横向布局和纵向布局。</target>
        </trans-unit>
        <trans-unit id="67179a80aecf9f836727c57083425efcac33c312" translate="yes" xml:space="preserve">
          <source>No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt;.</source>
          <target state="translated">不可以，没有正式证据表明不允许调用或覆盖这些方法。 实际上，Oracle说这些方法用于给出大小提示： &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http&lt;/a&gt; : //docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment 。</target>
        </trans-unit>
        <trans-unit id="afc37620d6506412fbf52d3ba616d7a8da186c6c" translate="yes" xml:space="preserve">
          <source>No, you definitely shall not develop layout managers, unless you need something very special.</source>
          <target state="translated">不,你绝对不得开发布局经理,除非你需要很特别的东西。</target>
        </trans-unit>
        <trans-unit id="307ab8cb83f9ac27e039e7296b2b08390750ad96" translate="yes" xml:space="preserve">
          <source>Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you're about to develop anything serious.</source>
          <target state="translated">当然,这在现实生活中的布局可能会变得很棘手。因此,如果你要开发什么严肃的东西,像MigLayout这样的网格化布局管理器会好很多。</target>
        </trans-unit>
        <trans-unit id="0d7954ef62fba1a1c6c5f8eb49be84da9e19ef5e" translate="yes" xml:space="preserve">
          <source>Several times I've been criticized for having suggested the use of the following methods:</source>
          <target state="translated">有几次,我因为建议使用以下方法而受到批评。</target>
        </trans-unit>
        <trans-unit id="5159a31c0c57223db57d56c6afccc7b37ae7c0e4" translate="yes" xml:space="preserve">
          <source>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing</source>
          <target state="translated">Maximum</target>
        </trans-unit>
        <trans-unit id="24368ab382b57b4e51fbff30e82703ed71584963" translate="yes" xml:space="preserve">
          <source>Should I completely avoid the use of those methods?</source>
          <target state="translated">我应该完全避免使用这些方法吗?</target>
        </trans-unit>
        <trans-unit id="0e8b46b6e2690834b4abf89137b167ccb21005aa" translate="yes" xml:space="preserve">
          <source>So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.</source>
          <target state="translated">所以,为了让你的GUI在所有平台上保持功能和外观美观(记住,Java的主要优点之一就是跨平台),你应该依靠布局管理器等来自动调整你的组件的大小,使其在你的特定开发环境之外正确地渲染。</target>
        </trans-unit>
        <trans-unit id="1bd3d705c344338a8aad1a106bac39a04e05b944" translate="yes" xml:space="preserve">
          <source>Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Rules (hehe)&lt;/a&gt; or in the &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;link&lt;/a&gt; @bendicott found in his/her comment to &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;my answer&lt;/a&gt;. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.</source>
          <target state="translated">一些技术原因（不完整，不幸的是，由于SwingLabs迁移到java.net而导致链接断开），例如，在&lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;&amp;ldquo;规则&amp;rdquo;中&lt;/a&gt;提到了技术原因（在hehe中），或者在他/她对&lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;我的答案的&lt;/a&gt;评论中找到了@bendicott &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;链接&lt;/a&gt; 。 在社交上，将大量工作交给不幸的同事，他必须维护代码并必须查找损坏的布局。</target>
        </trans-unit>
        <trans-unit id="40f1d31b7c8dd444f50d98428b8cd8ccfaeafd52" translate="yes" xml:space="preserve">
          <source>The methods have been defined for a reason. So when should I use them?
  In which context? For what purposes?</source>
          <target state="translated">这些方法的定义是有原因的。那么,我应该在什么时候使用它们?在什么情况下使用?出于什么目的?</target>
        </trans-unit>
        <trans-unit id="540c4f65db18e1030a34da86ee391410c184bf1f" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I want to add a little more about the reasons &lt;em&gt;why&lt;/em&gt; you should normally avoid these (the question just came up again in a duplicate topic):</source>
          <target state="translated">这里有很多很好的答案，但是我想补充&lt;em&gt;说明一些&lt;/em&gt;您通常应该避免使用这些原因的&lt;em&gt;原因&lt;/em&gt; （问题只是在重复的主题中再次出现）：</target>
        </trans-unit>
        <trans-unit id="4f1c2750bb9a0c4dd1e3fb79014aa8f3f4f20030" translate="yes" xml:space="preserve">
          <source>These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:</source>
          <target state="translated">这些方法是大多数人不太了解的。你绝对不应该忽视这些方法。要看布局管理器是否尊重这些方法,这取决于他们是否尊重这些方法。这个页面有一个表格,显示了哪些排版经理尊重这些方法中的哪些方法。</target>
        </trans-unit>
        <trans-unit id="0a51f32acf1907b534bde7944ee38f8386d99137" translate="yes" xml:space="preserve">
          <source>They may also be overridden (which is the best practice for Swing) when &lt;em&gt;extending&lt;/em&gt; a Swing component (rather than calling the method on the custom component instance)</source>
          <target state="translated">在&lt;em&gt;扩展&lt;/em&gt; Swing组件时（而不是在自定义组件实例上调用方法），它们也可能被覆盖（这是Swing的最佳实践）。</target>
        </trans-unit>
        <trans-unit id="c1e85d170b014983936e8e2c4c7e900a35ffafa9" translate="yes" xml:space="preserve">
          <source>This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.</source>
          <target state="translated">这个非常流行的布局管理器非常灵活,可以开发出非常完善的Java UIs。</target>
        </trans-unit>
        <trans-unit id="1ec55556bdbbcf021c597b1ba85f53eae29d5d67" translate="yes" xml:space="preserve">
          <source>Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.</source>
          <target state="translated">遗憾的是,Swing没有自带合理的默认尺寸。但是,与其设置组件的尺寸,不如用合理的默认值来降下自己的组件,这样的OOP效果更好。在这种情况下,你可以在你的子类中调用setXXX);或者,你也可以覆盖getXXX方法来达到同样的效果。</target>
        </trans-unit>
        <trans-unit id="a0518f85937eecd914f0c447bc9b66e9a1efed65" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I
  can only think to add portability between systems with different
  screen resolution).</source>
          <target state="translated">使用这些方法到底有什么负面影响?我只能想到增加不同屏幕分辨率的系统之间的可移植性)。</target>
        </trans-unit>
        <trans-unit id="03be6972f5a871fb5126119ff2853a38a28c8c7e" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">使用这些方法到底有什么负面影响?我只能认为在不同屏幕分辨率的系统之间增加便携性)。</target>
        </trans-unit>
        <trans-unit id="7db7f6858afa5c9fac8e8b9fdc4da5e60b2f58b1" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)</source>
          <target state="translated">使用这些方法到底有什么负面影响?(我只能想到增加不同屏幕分辨率的系统之间的可移植性)。</target>
        </trans-unit>
        <trans-unit id="b4a11b0ef058755c0527df7e68585b1ac10c6518" translate="yes" xml:space="preserve">
          <source>When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well</source>
          <target state="translated">当你需要向容器布局管理器提供自定义的尺寸提示,以使组件的布局很好地完成。</target>
        </trans-unit>
        <trans-unit id="2744a93affacde93c2fe41cf485c4eb89f3e85ea" translate="yes" xml:space="preserve">
          <source>With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren't inherently evil, but the typical reasons for using them &lt;em&gt;are&lt;/em&gt;. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.</source>
          <target state="translated">除少数例外，如果您使用这些方法，则可能会在特定的外观（以及系统特定的设置，例如，首选的桌面字体等）上对GUI进行微调以使其看起来不错。 这些方法本身并不是天生的邪恶，但是使用它们的典型原因&lt;em&gt;是&lt;/em&gt; 。 在其他平台上，一旦开始调整布局中的像素位置和大小，就会冒着GUI断裂（或至少看起来很糟）的风险。</target>
        </trans-unit>
        <trans-unit id="181abc8f1431b3fc4b24b7ff7084f5997bf9d984" translate="yes" xml:space="preserve">
          <source>With layouts the answer is always the same: use a suitable
  LayoutManager</source>
          <target state="translated">对于布局,答案总是一样的:使用一个合适的LayoutManager。</target>
        </trans-unit>
        <trans-unit id="a18978692bb37ab6256c8c6714eeb798c4d51295" translate="yes" xml:space="preserve">
          <source>Yes for application code.</source>
          <target state="translated">是的,适用于应用代码。</target>
        </trans-unit>
        <trans-unit id="dac954ba2e6beb0d6c4bd134e2e18d3a82cfd388" translate="yes" xml:space="preserve">
          <source>Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to &quot;all layout needs&quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.</source>
          <target state="translated">是的,现在有强大的布局管理器,可以很好地满足 &quot;所有布局需求&quot;。三大类是JGoodies FormLayout、MigLayout、DesignGridLayout。所以不,在实践中,除了简单的高度专业化的环境,你很少写LayoutManagers。</target>
        </trans-unit>
        <trans-unit id="444042202368def5f8181a05aefd275a8d54be0c" translate="yes" xml:space="preserve">
          <source>You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.</source>
          <target state="translated">你可以使用JSplitPane,在这里你可以预先设置两边的比例。或者,你可以使用MigLayout,它允许你以百分比、像素和其他单位来设置这样的约束。</target>
        </trans-unit>
        <trans-unit id="f35a75cc4334792c6bc0ab1cd5a82739998fcbef" translate="yes" xml:space="preserve">
          <source>You'll find Karsten's documentation in &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;here&lt;/a&gt;, and some rather good documentation from eclipse &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;这里&lt;/a&gt;找到Karsten的文档，还可以在 eclipse上&lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;找到&lt;/a&gt;一些相当不错的文档。</target>
        </trans-unit>
        <trans-unit id="2893740bacbf2ae887be29e7602f37f93e33c2d4" translate="yes" xml:space="preserve">
          <source>between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">在一个组件的子项之间(例如,子项1应该使用10%的空间,子项2应该使用40%的空间,子项3应该使用50%的空间),是否有可能在不实现自定义LayoutManager的情况下实现?</target>
        </trans-unit>
        <trans-unit id="0886212cd9ad81c73e17959b2f0c7b17e6248ebc" translate="yes" xml:space="preserve">
          <source>is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.</source>
          <target state="translated">是有两个部分。左边和右边的部分是一个水平布局。右边的部分是在水平布局的基础上增加了一个JPanel,这个JPanel有一个垂直布局,垂直布局的按钮。</target>
        </trans-unit>
        <trans-unit id="d00a4682b9e06987369438cd97d3639a65d0178c" translate="yes" xml:space="preserve">
          <source>on &lt;code&gt;Swing&lt;/code&gt; components. I don't see any alternative to their use when I want to define proportions between displayed components. I have been told this:</source>
          <target state="translated">在 &lt;code&gt;Swing&lt;/code&gt; 组件上。 我想在显示的组件之间定义比例时，看不到任何替代方法。 有人告诉我：</target>
        </trans-unit>
        <trans-unit id="d8e8fbecb943993f987bc322df6b509bc6daa8b4" translate="yes" xml:space="preserve">
          <source>sometimes problems can be encountered with &lt;code&gt;GridBagLayout&lt;/code&gt; and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.</source>
          <target state="translated">有时， &lt;code&gt;GridBagLayout&lt;/code&gt; 和文本字段可能会遇到问题，其中，如果容器的大小小于首选大小，则会使用最小大小，这可能导致文本字段显着缩小。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
