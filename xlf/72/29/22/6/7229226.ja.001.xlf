<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/7229226">
    <body>
      <group id="7229226">
        <trans-unit id="101513b86d72ed6fcdb26b5d3b3a91761a1a7eeb" translate="yes" xml:space="preserve">
          <source>(I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">(画面解像度の異なるシステム間でのポータビリティを追加することしか考えられない)。</target>
        </trans-unit>
        <trans-unit id="f322b9e0be596ee0c12c766b6f6362bac3fda875" translate="yes" xml:space="preserve">
          <source>(The answer to 4 is &quot;no&quot;.)</source>
          <target state="translated">(4の答えは「いいえ」)。</target>
        </trans-unit>
        <trans-unit id="a62f3745308389d8190dd4aa927eccdaa9df3d4a" translate="yes" xml:space="preserve">
          <source>1) Should I completely avoid the use of those methods?</source>
          <target state="translated">1)それらの方法の使用は完全に避けるべきですか?</target>
        </trans-unit>
        <trans-unit id="9be06212edf76a1a8f22e4f87f620e98f3917e4f" translate="yes" xml:space="preserve">
          <source>2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</source>
          <target state="translated">2)メソッドは理由があって定義されています。では、いつ使うべきなのでしょうか?どのような文脈で?どのような目的のために?</target>
        </trans-unit>
        <trans-unit id="3129078a99b0f0599191614194a02dd301b6ef4c" translate="yes" xml:space="preserve">
          <source>3) What exactly are the negative consequences of using those methods?</source>
          <target state="translated">3)それらの方法を使用すると、具体的にどのような悪影響があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e4537f34f955a436cd38a10e8ea7eee57157f6f1" translate="yes" xml:space="preserve">
          <source>4) I don't think any LayoutManager can exactly satisfy all desired layout needs.</source>
          <target state="translated">4)どのLayoutManagerでも、希望するすべてのレイアウトニーズを正確に満たすことはできないと思います。</target>
        </trans-unit>
        <trans-unit id="a50e32a4d28ac833b32f3d7ebf4edda651c47cb3" translate="yes" xml:space="preserve">
          <source>5) If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">5)4 の答えが「はい」の場合、LayoutManager クラスが増殖してメンテナンスが困難になるのではないか?</target>
        </trans-unit>
        <trans-unit id="9e4a5573061af9e7df2555b66d39ace412023fef" translate="yes" xml:space="preserve">
          <source>6) In a situation where I need to define proportions...</source>
          <target state="translated">6)プロポーションを定義する必要がある状況では</target>
        </trans-unit>
        <trans-unit id="caae42b05fc60c9860a79b7d9ccb2ea61214c824" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JFrame&lt;/code&gt; does not enforce overriden &lt;code&gt;getMinimumSize()&lt;/code&gt; only calling &lt;code&gt;setMinimumSize(..)&lt;/code&gt; on its works</source>
          <target state="translated">&lt;code&gt;JFrame&lt;/code&gt; は、その作業で &lt;code&gt;setMinimumSize(..)&lt;/code&gt; を呼び出すだけで、オーバーライドされた &lt;code&gt;getMinimumSize()&lt;/code&gt; を強制しません。</target>
        </trans-unit>
        <trans-unit id="b3647248e0173f71dd2355fcf20828a2dedaf8e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?&lt;/strong&gt; You shouldn't &quot;implement&quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they're hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never &quot;implement&quot; a layout manager. I just instantiate them.</source>
          <target state="translated">&lt;strong&gt;どのLayoutManagerでも、必要なすべてのレイアウトニーズを正確に満たすことができるとは思いません。&lt;/strong&gt; &lt;strong&gt;レイアウトの小さなバリエーションごとに新しいLayoutManagerを実装する必要がありますか？&lt;/strong&gt; 新しいLayoutManagerを「実装」しないでください。 既存のものをインスタンス化する必要があります。 1つのウィンドウで複数のレイアウトマネージャを使用することがよくあります。 各JPanelには独自のレイアウトマネージャーがあります。 入れ子になったレイアウトを維持するのが難しいため、一部の人々は入れ子のレイアウトに悩んでいます。 それらを使用するときは、それぞれに独自の作成方法を与えて、それぞれが何をしているかを簡単に確認できるようにします。 しかし、レイアウトマネージャーを「実装」することはありません。 それらをインスタンス化するだけです。</target>
        </trans-unit>
        <trans-unit id="edce1b4cb1e94b90bfc85934288d525da7af49fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?&lt;/strong&gt;
If you're implementing new layout manager classes for slight variations in layout, you're using them wrong. If you're just implementing new layout managers, you're probably doing something wrong. The only time I've extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.</source>
          <target state="translated">&lt;strong&gt;4の答えが「はい」の場合、これは維持が困難になるLayoutManagerクラスの急増につながるのではないですか？&lt;/strong&gt; レイアウトのわずかなバリエーションに対して新しいレイアウトマネージャークラスを実装している場合、それらを間違って使用しています。 新しいレイアウトマネージャを実装しているだけなら、おそらく何かがおかしいでしょう。 私がLayoutManagerクラスを拡張したのは、JScrollPaneにズームスライダーを追加するときだけでした。</target>
        </trans-unit>
        <trans-unit id="bac7ad7f05d5d55847b7fd4cc2f7ed1978917af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?&lt;/strong&gt;
The JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don't use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.</source>
          <target state="translated">&lt;strong&gt;Componentの子間の比率を定義する必要がある場合（たとえば、child1は10％のスペースを使用し、child2 40％、child3 50％を使用する必要があります）、カスタムLayoutManagerを実装せずにそれを達成できますか？&lt;/strong&gt; JSplitPaneには、各コンポーネントが取得する必要があるパーセンテージを指定する方法があります。 デバイダーはデフォルトで移動可能ですが、必要に応じてオフにできます。 その機能はあまり使いません。 通常、設定されたサイズを占めるコンポーネントがいくつかあり、残りのスペースはスクロールペインによって占められます。 スクロールペインのサイズは、ウィンドウサイズに合わせて調整されます。 スクロールペインが2つ並んでいる場合は、それらをJSplitPaneに配置し、ユーザーがウィンドウを拡大または縮小するときに、それぞれに割り当てる新しいスペースの割合を指定できます。</target>
        </trans-unit>
        <trans-unit id="2ef0079b6c8a172dd2c245d6fc600772f49ecf38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="253649f0361fd376d76e98ac2e931514bc001bdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Should I completely avoid the use of those methods?&lt;/strong&gt;
I wouldn't say &quot;avoid&quot; them. I'd say that if you think you need them, you're probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call &lt;code&gt;setSize()&lt;/code&gt;, and let that size determine the initial window size, by calling &lt;code&gt;JFrame.pack()&lt;/code&gt;. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don't do much good.</source>
          <target state="translated">&lt;strong&gt;これらの方法の使用を完全に避けるべきですか？&lt;/strong&gt; 私はそれらを「避ける」とは言いません。 あなたがそれらが必要だと思うなら、あなたはおそらく何か間違ったことをしていると私は言うでしょう。 コンポーネントのサイズは状況に応じて決定されます。 たとえば、テキストコンポーネントのサイズは、指定した行と列の数と、選択したフォントとの組み合わせによって決まります。 ボタンとラベルのサイズは、設定した場合はグラフィックのサイズ、または設定したテキストを表示するために必要なスペースになります。 各コンポーネントには自然なサイズがあり、レイアウトマネージャはそれらを使用して、サイズを指定する必要なくすべてをレイアウトします。 主な例外はJScrollPaneで、JScrollPaneには含まれているものとは独立したサイズがあります。 それらのために、私は時々 &lt;code&gt;setSize()&lt;/code&gt; を呼び出し、そのサイズに &lt;code&gt;JFrame.pack()&lt;/code&gt; を呼び出すことによって初期ウィンドウサイズを決定させます。 通常は、ウィンドウサイズにJScrollPaneのサイズを決定させます。 ユーザーがウィンドウのサイズを決定します。 多くのレイアウトマネージャーは、設定したサイズを無視します。そのため、多くの場合、あまり効果がありません。</target>
        </trans-unit>
        <trans-unit id="bb29b79b090f0d71d579ecfac48293fc02a91481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?&lt;/strong&gt;
I believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn't fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn't want to bother with learning a new paradigm. It's a terrible idea.</source>
          <target state="translated">&lt;strong&gt;メソッドは理由のために定義されています。&lt;/strong&gt; &lt;strong&gt;では、いつそれらを使用すればよいですか？&lt;/strong&gt; &lt;strong&gt;どの文脈で？&lt;/strong&gt; &lt;strong&gt;何のために？&lt;/strong&gt; レイアウトマネージャーにヒントを提供するために追加されたと思います。 レイアウトマネージャーは新しいものであり、人々はそれらを完全に信頼していなかったため、これらは歴史的な理由で作成された可能性があります。 新しいパラダイムの学習に煩わされたくなかったからといって、レイアウトマネージャーを避けてすべてを手動で配置した開発者が何人かいます。 それはひどい考えです。</target>
        </trans-unit>
        <trans-unit id="f2a560db0d72f5a999aad79685126287e9f8c227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).&lt;/strong&gt;
They're ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.</source>
          <target state="translated">&lt;strong&gt;これらの方法を使用することの否定的な結果は正確には何ですか？&lt;/strong&gt; &lt;strong&gt;（私は、異なる画面解像度のシステム間で移植性を追加することしか考えられません）。&lt;/strong&gt; それらは効果がなく、オブジェクトのレイアウトが不自然になり、オブジェクトが非自然なサイズに圧縮または引き伸ばされます。 そして、レイアウトはもろくなります。 ウィンドウサイズを変更すると、レイアウトが壊れ、間違った場所に配置されることがあります。</target>
        </trans-unit>
        <trans-unit id="75fd8314886af2005f7a571fef2f798a7e7172e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMaximumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMaximumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b11ddbbe6a3af1821698ada76274100c165c48cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMinimumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMinimumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89f81cef98f01aaa7c3a87a7392da5c9df43268c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setPreferredSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setPreferredSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8f222d9ad21513e10bd84b95b5bf37337e1762a" translate="yes" xml:space="preserve">
          <source>A few heuristics:</source>
          <target state="translated">いくつかのヒューリスティック。</target>
        </trans-unit>
        <trans-unit id="5ed3ba4403e948d10f0d964a8030523919a40837" translate="yes" xml:space="preserve">
          <source>All that said, you can certainly conceive of situations where these methods are justified. Again, they aren't inherently evil, but their usage is normally a &lt;strong&gt;big&lt;/strong&gt; red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.</source>
          <target state="translated">そうは言っても、これらの方法が正当化される状況は確かに想像できます。 繰り返しますが、それらは本質的に悪ではありませんが、それらの使用法は通常、潜在的なGUIの問題を示す&lt;strong&gt;大きな&lt;/strong&gt;赤い旗です。 使用する場合は、合併症の可能性が高いことに注意し、問題に対するルックアンドフィールに依存しない別の解決策があるかどうかを常に考えて検討してください。メソッドは必要ありません。</target>
        </trans-unit>
        <trans-unit id="334e464b55e6cbe9ef940d5fd89ee52a5a006400" translate="yes" xml:space="preserve">
          <source>Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars. 
As opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).</source>
          <target state="translated">常に。コンポーネントを作成する際には、そのコンポーネントの用途に応じて、現実的なminpreferredmaxサイズを設定してください。例えば、UKなどの国名記号を入力するJTextFieldがある場合、その望ましいサイズは、(現在のフォントなどで)2文字に収まる幅でなければなりませんが、おそらくこれ以上大きくしても意味がありません。結局のところ、国名記号は2文字です。逆に、顧客名などを入力するJTextFieldがあれば、20文字分のピクセルサイズのように優先的にサイズを設定することができますが、レイアウトをリサイズすると大きくなる可能性があるので、最大サイズはそれ以上に設定します。同時に、0px幅のJTextFieldを持つことは無意味なので、現実的な最小サイズ(2文字のピクセルサイズとします)を設定します。</target>
        </trans-unit>
        <trans-unit id="82a3275f2c6e319fc8e6e971d584332b7226964d" translate="yes" xml:space="preserve">
          <source>Any of the Big-Three can, can't even GridBag (never bothered to really master, too much trouble for too little power).</source>
          <target state="translated">Big-Threeのどれもができる、GridBagでさえできない(本当にマスターするのに苦労したことがない、あまりにも小さい力のために面倒くさい)。</target>
        </trans-unit>
        <trans-unit id="feada63cf7671891364a8ad7e4d18aec070ec6ec" translate="yes" xml:space="preserve">
          <source>As an example of this, try changing your application's default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.</source>
          <target state="translated">この例として、アプリケーションのデフォルトのルックアンドフィールを変更してみてください。お使いのプラットフォームで利用できるオプションがあるだけでも、結果がこんなにも悪く表示されるのかと驚くかもしれません。</target>
        </trans-unit>
        <trans-unit id="e2f886c1766f46b82d763352fa65f26f99701edd" translate="yes" xml:space="preserve">
          <source>Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).</source>
          <target state="translated">基本的に、望ましいサイズが正しく設定されれば、パーセンテージで何かをする必要はないかもしれません。単純に、パーセンテージは無意味だからです(例えば、JTextFieldがウィンドウサイズの10%になるのは無意味です-JTextFieldが0px幅になるようにウィンドウを縮小したり、マルチディスプレイのセットアップでJTextFieldが2つのディスプレイにまたがるようにウィンドウを拡大することができるからです)。</target>
        </trans-unit>
        <trans-unit id="44d763212c6c3a8fea4302c81748f40a5af6a256" translate="yes" xml:space="preserve">
          <source>But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).</source>
          <target state="translated">しかし、時にはあなたのGUIの大きなビルディングブロック(例えばパネル)のサイズを制御するためにパーセンテージを使用することがあります。</target>
        </trans-unit>
        <trans-unit id="78233fddc435250272d7f9a010e1be36ab861764" translate="yes" xml:space="preserve">
          <source>By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies' &lt;code&gt;FormLayout&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;http://www.miglayout.com/&quot;&gt;&lt;code&gt;MigLayout&lt;/code&gt;&lt;/a&gt;. Some GUI builders even have built-in support for third-party layout managers -- Eclipse's WindowBuilder GUI editor, for example, ships with support for &lt;code&gt;FormLayout&lt;/code&gt; and &lt;code&gt;MigLayout&lt;/code&gt;.</source>
          <target state="translated">ちなみに、標準のレイアウトマネージャーに不満を感じている場合は、 &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodiesのFormLayout&lt;/a&gt;や&lt;a href=&quot;http://www.miglayout.com/&quot;&gt; &lt;code&gt;MigLayout&lt;/code&gt; &lt;/a&gt;など、無料のオープンソースのサードパーティ製のものがたくさんあります。 一部のGUIビルダーには、サードパーティのレイアウトマネージャーのサポートも &lt;code&gt;FormLayout&lt;/code&gt; てい &lt;code&gt;MigLayout&lt;/code&gt; 。たとえば、EclipseのWindowBuilder GUIエディターには、 FormLayoutとMigLayoutのサポートが同 梱されています。</target>
        </trans-unit>
        <trans-unit id="28464854017f94b9c9844769ee6144deaf548b29" translate="yes" xml:space="preserve">
          <source>Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;comments&lt;/a&gt;.</source>
          <target state="translated">これらの&lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;コメントに&lt;/a&gt;記載されているように、派生サイズを取得するために多くのコンポーネントをループ処理する必要がある場合は、代替レイアウトまたはカスタムレイアウトを検討してください。</target>
        </trans-unit>
        <trans-unit id="be6bbc414031de61f515ad578e905cd0b742227e" translate="yes" xml:space="preserve">
          <source>Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">レイアウトのちょっとしたバリエーションごとに新しい LayoutManager を実装する必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7cf1d64fab0d093b37c52e515ee1f02d1c34c796" translate="yes" xml:space="preserve">
          <source>Do use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; to derive post-&lt;code&gt;validate()&lt;/code&gt; geometry, as shown below and &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">以下と&lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;ここに&lt;/a&gt;示すように、 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; を使用してpost- &lt;code&gt;validate()&lt;/code&gt; ジオメトリを派生させてください 。</target>
        </trans-unit>
        <trans-unit id="157eda23f1458fbcc63f756b719fa42aa4d3266a" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you could rely on a component's carefully overridden &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt;, as shown &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt; and below.</source>
          <target state="translated">以下に示すように、コンポーネントの慎重にオーバーライドされた &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt; 信頼できる場合は、 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 使用しないでください。</target>
        </trans-unit>
        <trans-unit id="4546245bd9fc2988f588e0ddf7f4de2e035d8826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you really mean to override &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt;, as might be done in creating your own component, shown &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;ここ&lt;/a&gt;に示すように、独自のコンポーネントを作成する場合と同様に、 &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt; をオーバーライドするつもりである場合は、 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 使用しないでください。</target>
        </trans-unit>
        <trans-unit id="8858a12745633838c34a2266f3595b758ee64852" translate="yes" xml:space="preserve">
          <source>For example, the layout below:</source>
          <target state="translated">例えば、以下のようなレイアウトです。</target>
        </trans-unit>
        <trans-unit id="0b5b0c3f88d9871a3e20dffd7b5aea8ad3241262" translate="yes" xml:space="preserve">
          <source>I am seeing it differenty than the accepted answer.</source>
          <target state="translated">私はそれを受け入れられた答えとは異なるものとして見ています。</target>
        </trans-unit>
        <trans-unit id="c0e9dfc40abc06677021939bbd23ed04299fd51d" translate="yes" xml:space="preserve">
          <source>I don't know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. &quot;Slightly&quot;, because they should have implemented their needs with a custom LayoutManager.</source>
          <target state="translated">個人的にはAPI設計の事故だと思っています。複合コンポーネントが子サイズについて特別な考えを持っていたために、わずかに強制されたのです。&quot;わずかに &quot;というのは、カスタムの LayoutManager でニーズを実装するべきだったからです。</target>
        </trans-unit>
        <trans-unit id="05debf8858189b34f73fdc5385802a59b437dec7" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout
  needs. Do I really need to implement a new LayoutManager for every
  little variation on my layout?</source>
          <target state="translated">どのLayoutManagerでも、希望するレイアウトのニーズをすべて正確に満たすことはできないと思います。レイアウトのちょっとしたバリエーションごとに新しい LayoutManager を実装する必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e293825a482ffdbc279a19695ddf553407dbbc00" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">どのLayoutManagerでも、希望するレイアウトのニーズをすべて正確に満たすことはできないと思います。レイアウトのちょっとしたバリエーションごとに新しい LayoutManager を実装する必要があるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f03332e8b0533248fe9e9bec74b216b33f9c8672" translate="yes" xml:space="preserve">
          <source>I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.</source>
          <target state="translated">私は8年以上もSwingのコードを書いてきましたが、JDKに含まれているレイアウトマネージャは常に私のニーズに応えてくれました。自分のレイアウトを実現するためにサードパーティ製のレイアウト マネージャを必要としたことは一度もありません。</target>
        </trans-unit>
        <trans-unit id="45e24a1aab4e46086de24e1bd00ae96195747270" translate="yes" xml:space="preserve">
          <source>I have searched the web a little bit, but I haven't found any comprehensive analysis of the subject. So I have the following questions:</source>
          <target state="translated">少しウェブで検索してみましたが、総合的な分析対象は見つかりませんでした。そこで、次のような疑問があります。</target>
        </trans-unit>
        <trans-unit id="d19e84a41484b2716bcc34a770e49e845d1ffe27" translate="yes" xml:space="preserve">
          <source>I will say that you shouldn't try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.</source>
          <target state="translated">これらの方法でレイアウトマネージャにヒントを与えようとするのは、あなたがそれを必要としていることを確認するまではやめたほうがいいと言います。サイジングのヒントを与えずにレイアウトを行い(つまり、レイアウトマネージャにその仕事をさせてください)、必要に応じて細かい修正を行うことができます。</target>
        </trans-unit>
        <trans-unit id="4952d1d9c2545ce08ec8f0dfb48594021c83f640" translate="yes" xml:space="preserve">
          <source>If a component has no preferred size, e.g. &lt;code&gt;JDesktopPane&lt;/code&gt;, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.</source>
          <target state="translated">&lt;code&gt;JDesktopPane&lt;/code&gt; などのコンポーネントに適切なサイズがない場合は、コンテナのサイズを指定する必要がありますが、そのような選択は任意です。 コメントは意図を明確にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="1c43bb7e290acdfdc7dbe1b01a2c5332529346f1" translate="yes" xml:space="preserve">
          <source>If by implementing you mean using then yes. Not one &lt;code&gt;LayoutManger&lt;/code&gt; can handle everything, each &lt;code&gt;LayoutManager&lt;/code&gt; has its pros and cons thus each can be used together to produce the final layout.</source>
          <target state="translated">実装することで使用する場合は、はい。 1つの &lt;code&gt;LayoutManger&lt;/code&gt; がすべてを処理できるわけではなく、各 &lt;code&gt;LayoutManager&lt;/code&gt; には長所と短所があり、それぞれを一緒に使用して最終的なレイアウトを作成できます。</target>
        </trans-unit>
        <trans-unit id="87d62286cfbf65303a6f848ee0864f361f380b7a" translate="yes" xml:space="preserve">
          <source>If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">4の答えが「はい」だとすると、LayoutManagerクラスが増殖してメンテナンスが大変になるのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="b063186389f8146493b73685b897b69952730e47" translate="yes" xml:space="preserve">
          <source>If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies &lt;code&gt;FormLayout&lt;/code&gt; provided freely as part of the Forms freeware library by Karsten Lentzsch &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Java Swingでのレイアウトに問題がある場合は、 &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;ここ&lt;/a&gt; Karsten Lentzschが提供するFormsフリーウェアライブラリの一部として &lt;code&gt;FormLayout&lt;/code&gt; 提供されているJGoodies FormLayoutを強くお勧めします 。</target>
        </trans-unit>
        <trans-unit id="d96461400848ad4f167b8f2e7b96036043cb5c45" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?</source>
          <target state="translated">コンポーネントの子の間の比率を定義する必要がある場合(子1はスペースの10%、子2は40%、子3は50%のスペースを使用する必要があります)、カスタムレイアウトマネージャを実装せずにそれを実現することは可能ですか?</target>
        </trans-unit>
        <trans-unit id="5063acd66afacb43577cb43e4e3c3bef2c93feea" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">コンポーネントの子の間で比率を定義する必要がある場合(例えば、子1はスペースの10%、子2は40%、子3は50%を使用する必要があります)、カスタムのLayoutManagerを実装せずにそれを実現することは可能ですか?</target>
        </trans-unit>
        <trans-unit id="031cb987d53c63d3108a20db2267a8bb488faae2" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">コンポーネントの子の間で比率を定義する必要がある場合(例えば、子1はスペースの10%、子2は40%、子3は50%を使用する)、カスタムのLayoutManagerを実装せずにこれを実現することは可能ですか?</target>
        </trans-unit>
        <trans-unit id="8749b6c1a91e73f14a6ee417ecb38965be650eb9" translate="yes" xml:space="preserve">
          <source>Make sure that you really need to set the component's exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied &lt;em&gt;looks&lt;/em&gt; of the UI on different Systems</source>
          <target state="translated">コンポーネントの正確なサイズを設定する必要があることを確認してください。 各Swingコンポーネントには、使用するフォントとルックアンドフィールに応じて、異なる推奨サイズがあります。 したがって、サイズを設定すると、さまざまなシステムでUIの&lt;em&gt;外観&lt;/em&gt;が変化する可能性があり&lt;em&gt;ます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83665a294fe3f65e2b8c5d56e4046be52e81d907" translate="yes" xml:space="preserve">
          <source>Many layout managers do not pay attention to a component's requested maximum size. However, &lt;code&gt;BoxLayout&lt;/code&gt; and &lt;code&gt;SpringLayout&lt;/code&gt; do. Furthermore, &lt;code&gt;GroupLayout&lt;/code&gt; provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.</source>
          <target state="translated">多くのレイアウトマネージャーは、コンポーネントの要求された最大サイズに注意を払いません。 ただし、 &lt;code&gt;BoxLayout&lt;/code&gt; と &lt;code&gt;SpringLayout&lt;/code&gt; にはあります。 さらに、 &lt;code&gt;GroupLayout&lt;/code&gt; は、コンポーネントに触れることなく、最小、優先、または最大サイズを明示的に設定する機能を提供します。</target>
        </trans-unit>
        <trans-unit id="ab89da0d68317915b0b083e37c7f4c657b21e4bb" translate="yes" xml:space="preserve">
          <source>Maybe &lt;code&gt;GridBagLayout&lt;/code&gt; would satisfy your needs. Besides that, there's a ton of layout managers on the web, and I bet there's one that fits your requirements.</source>
          <target state="translated">多分 &lt;code&gt;GridBagLayout&lt;/code&gt; はあなたのニーズを満たすでしょう。 その上、ウェブ上にはたくさんのレイアウトマネージャーがあり、私はあなたの要件に合うものがあると思います。</target>
        </trans-unit>
        <trans-unit id="5ec1d5cb339ea8bf28dabdc16b8ff8f4073ed0c4" translate="yes" xml:space="preserve">
          <source>Most importantly no matter how you specify your component's size, be sure that your component's container uses a layout manager that respects the requested size of the component.</source>
          <target state="translated">最も重要なことは、コンポーネントのサイズをどのように指定するかに関わらず、コンポーネントのコンテナが、要求されたコンポーネントのサイズを尊重するレイアウト・マネージャを使用していることを確認することです。</target>
        </trans-unit>
        <trans-unit id="ec7904135c872d5504ba4625fa4861d3640b70e4" translate="yes" xml:space="preserve">
          <source>Never avoid! They're there to express the size constraints of your components to the layout manager. You can avoid using them if you're not using any layout manager and try to manage the visual layout on your own.</source>
          <target state="translated">絶対に避けてはいけません! コンポーネントのサイズの制約をレイアウトマネージャに表現するためのものです。レイアウトマネージャを使用しておらず、ビジュアルレイアウトを自分で管理しようとしている場合は、使用を避けることができます。</target>
        </trans-unit>
        <trans-unit id="019c97b9fc48d56cdc8c3608bba924a9b70932a7" translate="yes" xml:space="preserve">
          <source>No negative consequences. These are hints for the layout manager.</source>
          <target state="translated">否定的な結果にならないように。以上がレイアウト管理者のヒントです。</target>
        </trans-unit>
        <trans-unit id="5a8a6ea846414fc7b77ae01acccc90b507c47c69" translate="yes" xml:space="preserve">
          <source>No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.</source>
          <target state="translated">いや、間違いなくそうではありません。通常のアプローチは、水平レイアウトや垂直レイアウトなどの異なる基本的なレイアウトマンをカスケードすることです。</target>
        </trans-unit>
        <trans-unit id="67179a80aecf9f836727c57083425efcac33c312" translate="yes" xml:space="preserve">
          <source>No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt;.</source>
          <target state="translated">いいえ、これらのメソッドの呼び出しまたはオーバーライドが許可されていないことを示唆する正式な証拠はありません。 実際、オラクルはこれらのメソッドがサイズのヒントを与えるために使用されると言います： &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http&lt;/a&gt; : //docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment 。</target>
        </trans-unit>
        <trans-unit id="afc37620d6506412fbf52d3ba616d7a8da186c6c" translate="yes" xml:space="preserve">
          <source>No, you definitely shall not develop layout managers, unless you need something very special.</source>
          <target state="translated">いいえ、あなたは非常に特別な何かを必要としない限り、間違いなくレイアウトマネージャーを開発してはいけません。</target>
        </trans-unit>
        <trans-unit id="307ab8cb83f9ac27e039e7296b2b08390750ad96" translate="yes" xml:space="preserve">
          <source>Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you're about to develop anything serious.</source>
          <target state="translated">もちろん、これは実際のレイアウトでは厄介なことになります。したがって、本格的なレイアウトを開発する場合は、MigLayoutのようなグリッドベースのレイアウトマネージャの方がはるかに良いでしょう。</target>
        </trans-unit>
        <trans-unit id="0d7954ef62fba1a1c6c5f8eb49be84da9e19ef5e" translate="yes" xml:space="preserve">
          <source>Several times I've been criticized for having suggested the use of the following methods:</source>
          <target state="translated">を提案したことで批判されたことが何度かあります。</target>
        </trans-unit>
        <trans-unit id="5159a31c0c57223db57d56c6afccc7b37ae7c0e4" translate="yes" xml:space="preserve">
          <source>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing</source>
          <target state="translated">Maximum</target>
        </trans-unit>
        <trans-unit id="24368ab382b57b4e51fbff30e82703ed71584963" translate="yes" xml:space="preserve">
          <source>Should I completely avoid the use of those methods?</source>
          <target state="translated">それらの方法の使用は完全に避けるべきでしょうか?</target>
        </trans-unit>
        <trans-unit id="0e8b46b6e2690834b4abf89137b167ccb21005aa" translate="yes" xml:space="preserve">
          <source>So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.</source>
          <target state="translated">ですから、GUIをすべてのプラットフォーム上で機能的で見栄えの良いものに保つという名目で(Javaの主な利点の1つはクロスプラットフォームであることを覚えておいてください)、特定の開発環境の外で正しく表示されるように、コンポーネントのサイズを自動的に調整するレイアウト・マネージャなどに頼るべきです。</target>
        </trans-unit>
        <trans-unit id="1bd3d705c344338a8aad1a106bac39a04e05b944" translate="yes" xml:space="preserve">
          <source>Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Rules (hehe)&lt;/a&gt; or in the &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;link&lt;/a&gt; @bendicott found in his/her comment to &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;my answer&lt;/a&gt;. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.</source>
          <target state="translated">いくつかの（SwingLabsのjava.netへの移行により、リンクが不完全であり、残念ながらリンクが壊れています）技術的な理由は、たとえば、 &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;ルール（hehe）&lt;/a&gt;または&lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;私の回答&lt;/a&gt;への彼/彼女のコメントにある&lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;リンク&lt;/a&gt; @bendicottで言及されています 。 社会的には、コードを保守しなければならず、壊れたレイアウトを追跡しなければならない不運な仲間に大量の作業を課します。</target>
        </trans-unit>
        <trans-unit id="40f1d31b7c8dd444f50d98428b8cd8ccfaeafd52" translate="yes" xml:space="preserve">
          <source>The methods have been defined for a reason. So when should I use them?
  In which context? For what purposes?</source>
          <target state="translated">メソッドは理由があって定義されています。では、いつ使うべきなのでしょうか?どのような文脈で?どのような目的で?</target>
        </trans-unit>
        <trans-unit id="540c4f65db18e1030a34da86ee391410c184bf1f" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I want to add a little more about the reasons &lt;em&gt;why&lt;/em&gt; you should normally avoid these (the question just came up again in a duplicate topic):</source>
          <target state="translated">ここには良い答えがたくさんありますが、通常はこれらを避けなければならない理由&lt;em&gt;について&lt;/em&gt;もう少し追加したいと思います（質問は重複したトピックで再び出てきました）：</target>
        </trans-unit>
        <trans-unit id="4f1c2750bb9a0c4dd1e3fb79014aa8f3f4f20030" translate="yes" xml:space="preserve">
          <source>These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:</source>
          <target state="translated">これらの方法は、ほとんどの人に理解されていません。これらの方法を絶対に無視してはいけません。これらの方法を尊重するかどうかはレイアウト管理者次第です。このページでは、どのレイアウトマネージャーがこれらの方法のうち、どの方法を尊重しているかを示す表があります。</target>
        </trans-unit>
        <trans-unit id="0a51f32acf1907b534bde7944ee38f8386d99137" translate="yes" xml:space="preserve">
          <source>They may also be overridden (which is the best practice for Swing) when &lt;em&gt;extending&lt;/em&gt; a Swing component (rather than calling the method on the custom component instance)</source>
          <target state="translated">また、Swingコンポーネントを&lt;em&gt;拡張&lt;/em&gt;するとき&lt;em&gt;に&lt;/em&gt; （カスタムコンポーネントインスタンスでメソッドを呼び出すのではなく）オーバーライドすることもできます（これはSwingのベストプラクティスです）。</target>
        </trans-unit>
        <trans-unit id="c1e85d170b014983936e8e2c4c7e900a35ffafa9" translate="yes" xml:space="preserve">
          <source>This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.</source>
          <target state="translated">この非常に人気のあるレイアウトマネージャは非常に柔軟性が高く、非常に洗練されたJava UIを開発することができます。</target>
        </trans-unit>
        <trans-unit id="1ec55556bdbbcf021c597b1ba85f53eae29d5d67" translate="yes" xml:space="preserve">
          <source>Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.</source>
          <target state="translated">残念ながら、Swingには合理的なデフォルトの寸法が付属していません。しかし、コンポーネントの寸法を設定するのではなく、自分のコンポーネントを合理的なデフォルト値で降順させる方が、OOP的には良いでしょう(その場合は、子孫クラスでsetXXXを呼び出します)。(その場合は、子孫クラスで setXXX を呼び出します。)あるいは、同じ効果を得るために getXXX メソッドをオーバーライドすることもできます。</target>
        </trans-unit>
        <trans-unit id="a0518f85937eecd914f0c447bc9b66e9a1efed65" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I
  can only think to add portability between systems with different
  screen resolution).</source>
          <target state="translated">それらの方法を使用した場合、具体的にどのような悪影響があるのでしょうか?私は、異なる画面解像度を持つシステム間の移植性を追加することしか考えられません)。</target>
        </trans-unit>
        <trans-unit id="03be6972f5a871fb5126119ff2853a38a28c8c7e" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">それらの方法を使用した場合、具体的にどのような悪影響があるのでしょうか?私は、異なる画面解像度を持つシステム間の移植性を追加することしか考えられません)。</target>
        </trans-unit>
        <trans-unit id="7db7f6858afa5c9fac8e8b9fdc4da5e60b2f58b1" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)</source>
          <target state="translated">それらの方法を使用することで、具体的にどのような悪影響があるのでしょうか?(画面解像度の異なるシステム間でのポータビリティの追加くらいしか考えられない)。</target>
        </trans-unit>
        <trans-unit id="b4a11b0ef058755c0527df7e68585b1ac10c6518" translate="yes" xml:space="preserve">
          <source>When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well</source>
          <target state="translated">コンポーネントがうまくレイアウトされるように、コンテナのレイアウトマネージャにカスタマイズされたサイズのヒントを提供する必要がある場合</target>
        </trans-unit>
        <trans-unit id="2744a93affacde93c2fe41cf485c4eb89f3e85ea" translate="yes" xml:space="preserve">
          <source>With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren't inherently evil, but the typical reasons for using them &lt;em&gt;are&lt;/em&gt;. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.</source>
          <target state="translated">いくつかの例外はありますが、これらの方法を使用している場合は、GUIを微調整して、特定のルックアンドフィール（およびシステム固有の設定（好みのデスクトップフォントなど）で見栄えをよくする）にする必要があります。 メソッド自体は本質的に悪ではありませんが、それらを使用する一般的な理由&lt;em&gt;は&lt;/em&gt;です。 レイアウトでピクセルの位置とサイズの調整を始めるとすぐに、他のプラットフォームでGUIが壊れる（少なくとも、見た目が悪い）リスクがあります。</target>
        </trans-unit>
        <trans-unit id="181abc8f1431b3fc4b24b7ff7084f5997bf9d984" translate="yes" xml:space="preserve">
          <source>With layouts the answer is always the same: use a suitable
  LayoutManager</source>
          <target state="translated">レイアウトの場合、答えは常に同じです:適切なLayoutManagerを使用してください。</target>
        </trans-unit>
        <trans-unit id="a18978692bb37ab6256c8c6714eeb798c4d51295" translate="yes" xml:space="preserve">
          <source>Yes for application code.</source>
          <target state="translated">アプリケーションコードの場合はそうですね。</target>
        </trans-unit>
        <trans-unit id="dac954ba2e6beb0d6c4bd134e2e18d3a82cfd388" translate="yes" xml:space="preserve">
          <source>Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to &quot;all layout needs&quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.</source>
          <target state="translated">はい、「すべてのレイアウトニーズ」を満たすのに十分な強力なLayoutManagersがあります。JGoodies FormLayout,MigLayout,DesignGridLayout です。ですから、実際には、単純で高度に専門化された環境以外では、LayoutManager を書くことはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="444042202368def5f8181a05aefd275a8d54be0c" translate="yes" xml:space="preserve">
          <source>You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.</source>
          <target state="translated">2辺の比率をあらかじめ設定できるJSplitPaneを使うことができます。また、パーセンテージやピクセルなどの単位で制約を設定できるMigLayoutを使うこともできます。</target>
        </trans-unit>
        <trans-unit id="f35a75cc4334792c6bc0ab1cd5a82739998fcbef" translate="yes" xml:space="preserve">
          <source>You'll find Karsten's documentation in &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;here&lt;/a&gt;, and some rather good documentation from eclipse &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Karstenのドキュメントは&lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;ここ&lt;/a&gt;にあり、Eclipseのかなり良いドキュメントは&lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;ここにあります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2893740bacbf2ae887be29e7602f37f93e33c2d4" translate="yes" xml:space="preserve">
          <source>between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">コンポーネントの子の間で(例えば、子1は10%のスペースを使用し、子2は40%、子3は50%のスペースを使用する必要があります)、カスタムのLayoutManagerを実装せずにこれを実現することは可能ですか?</target>
        </trans-unit>
        <trans-unit id="0886212cd9ad81c73e17959b2f0c7b17e6248ebc" translate="yes" xml:space="preserve">
          <source>is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.</source>
          <target state="translated">は2つの部分を持っています。左右の部分は水平レイアウトです。右の部分は水平レイアウトにJPanelを追加したもので、このJPanelはボタンを縦にレイアウトしています。</target>
        </trans-unit>
        <trans-unit id="d00a4682b9e06987369438cd97d3639a65d0178c" translate="yes" xml:space="preserve">
          <source>on &lt;code&gt;Swing&lt;/code&gt; components. I don't see any alternative to their use when I want to define proportions between displayed components. I have been told this:</source>
          <target state="translated">&lt;code&gt;Swing&lt;/code&gt; コンポーネント。 表示されたコンポーネント間の比率を定義したい場合、それらの使用に代わるものはありません。 私はこれを言われました：</target>
        </trans-unit>
        <trans-unit id="d8e8fbecb943993f987bc322df6b509bc6daa8b4" translate="yes" xml:space="preserve">
          <source>sometimes problems can be encountered with &lt;code&gt;GridBagLayout&lt;/code&gt; and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.</source>
          <target state="translated">&lt;code&gt;GridBagLayout&lt;/code&gt; とテキストフィールドで問題が発生することがあります。コンテナのサイズが推奨サイズよりも小さい場合、最小サイズが使用され、テキストフィールドが大幅に縮小する可能性があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
