<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/7229226">
    <body>
      <group id="7229226">
        <trans-unit id="101513b86d72ed6fcdb26b5d3b3a91761a1a7eeb" translate="yes" xml:space="preserve">
          <source>(I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">(화면 해상도가 다른 시스템간에 이식성을 추가하는 것만 생각할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="f322b9e0be596ee0c12c766b6f6362bac3fda875" translate="yes" xml:space="preserve">
          <source>(The answer to 4 is &quot;no&quot;.)</source>
          <target state="translated">(4의 대답은 &quot;아니오&quot;입니다.)</target>
        </trans-unit>
        <trans-unit id="a62f3745308389d8190dd4aa927eccdaa9df3d4a" translate="yes" xml:space="preserve">
          <source>1) Should I completely avoid the use of those methods?</source>
          <target state="translated">1) 그 방법의 사용을 완전히 피해야합니까?</target>
        </trans-unit>
        <trans-unit id="9be06212edf76a1a8f22e4f87f620e98f3917e4f" translate="yes" xml:space="preserve">
          <source>2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</source>
          <target state="translated">2) 방법은 이유 때문에 정의되었습니다. 언제 사용해야합니까? 어떤 맥락에서? 어떤 목적으로?</target>
        </trans-unit>
        <trans-unit id="3129078a99b0f0599191614194a02dd301b6ef4c" translate="yes" xml:space="preserve">
          <source>3) What exactly are the negative consequences of using those methods?</source>
          <target state="translated">3) 이러한 방법을 사용하면 어떤 부정적인 결과가 발생합니까?</target>
        </trans-unit>
        <trans-unit id="e4537f34f955a436cd38a10e8ea7eee57157f6f1" translate="yes" xml:space="preserve">
          <source>4) I don't think any LayoutManager can exactly satisfy all desired layout needs.</source>
          <target state="translated">4) LayoutManager가 원하는 모든 레이아웃 요구를 정확하게 충족시킬 수 있다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a50e32a4d28ac833b32f3d7ebf4edda651c47cb3" translate="yes" xml:space="preserve">
          <source>5) If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">5) 4에 대한 대답이 &quot;예&quot;이면 LayoutManager 클래스가 확산되어 유지 관리가 어려워지지 않습니까?</target>
        </trans-unit>
        <trans-unit id="9e4a5573061af9e7df2555b66d39ace412023fef" translate="yes" xml:space="preserve">
          <source>6) In a situation where I need to define proportions...</source>
          <target state="translated">6) 비율을 정의 해야하는 상황에서 ...</target>
        </trans-unit>
        <trans-unit id="caae42b05fc60c9860a79b7d9ccb2ea61214c824" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JFrame&lt;/code&gt; does not enforce overriden &lt;code&gt;getMinimumSize()&lt;/code&gt; only calling &lt;code&gt;setMinimumSize(..)&lt;/code&gt; on its works</source>
          <target state="translated">&lt;code&gt;JFrame&lt;/code&gt; 은 작동시 &lt;code&gt;setMinimumSize(..)&lt;/code&gt; 만 호출하는 재정의 된 &lt;code&gt;getMinimumSize()&lt;/code&gt; 시행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b3647248e0173f71dd2355fcf20828a2dedaf8e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?&lt;/strong&gt; You shouldn't &quot;implement&quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they're hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never &quot;implement&quot; a layout manager. I just instantiate them.</source>
          <target state="translated">&lt;strong&gt;LayoutManager가 원하는 모든 레이아웃 요구를 정확하게 충족시킬 수 있다고 생각하지 않습니다.&lt;/strong&gt; &lt;strong&gt;레이아웃의 작은 변형마다 새로운 LayoutManager를 구현해야합니까?&lt;/strong&gt; 새로운 LayoutManager를 &quot;구현&quot;해서는 안됩니다. 기존 인스턴스를 인스턴스화해야합니다. 하나의 창에서 여러 레이아웃 관리자를 자주 사용합니다. 각 JPanel에는 자체 레이아웃 관리자가 있습니다. 일부 사람들은 유지 관리가 어렵 기 때문에 중첩 된 레이아웃을 사용합니다. 내가 그것을 사용할 때, 나는 각자가 무엇을하는지 더 쉽게 볼 수 있도록 각각의 고유 한 생성 방법을 제공합니다. 그러나 나는 결코 레이아웃 관리자를 &quot;구현&quot;하지 않습니다. 나는 단지 그들을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="edce1b4cb1e94b90bfc85934288d525da7af49fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?&lt;/strong&gt;
If you're implementing new layout manager classes for slight variations in layout, you're using them wrong. If you're just implementing new layout managers, you're probably doing something wrong. The only time I've extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.</source>
          <target state="translated">&lt;strong&gt;4에 대한 대답이 &quot;예&quot;이면, 유지 보수가 어려워지는 LayoutManager 클래스가 확산되지 않습니까?&lt;/strong&gt; 레이아웃의 약간의 변형을 위해 새로운 레이아웃 관리자 클래스를 구현하는 경우 잘못 사용하고 있습니다. 새로운 레이아웃 관리자를 구현하는 경우 무언가 잘못되었을 수 있습니다. LayoutManager 클래스를 확장 한 유일한 시점은 확대 / 축소 슬라이더를 JScrollPane에 추가하는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="bac7ad7f05d5d55847b7fd4cc2f7ed1978917af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?&lt;/strong&gt;
The JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don't use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.</source>
          <target state="translated">&lt;strong&gt;Component의 자식들 사이에 비율을 정의해야하는 상황에서 (예를 들어, child1은 공간의 10 %, child2 40 %, child3 50 %를 사용해야 함), 사용자 정의 LayoutManager를 구현하지 않고도 달성 할 수 있습니까?&lt;/strong&gt; JSplitPane에는 각 구성 요소의 백분율을 지정하는 방법이 있습니다. 디바이더는 기본적으로 움직일 수 있지만 원하는 경우 끌 수 있습니다. 나는 그 기능을 많이 사용하지 않습니다. 일반적으로 설정된 크기를 차지하는 일부 구성 요소가 있으며 나머지 공간은 스크롤 창에 의해 차지됩니다. 스크롤 창 크기는 창 크기에 따라 조정됩니다. 두 개의 스크롤 창이 나란히 있으면 JSplitPane에 배치하고 사용자가 창을 확장 및 축소 할 때 각각에 주어진 새 공간의 백분율을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef0079b6c8a172dd2c245d6fc600772f49ecf38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="253649f0361fd376d76e98ac2e931514bc001bdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Should I completely avoid the use of those methods?&lt;/strong&gt;
I wouldn't say &quot;avoid&quot; them. I'd say that if you think you need them, you're probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call &lt;code&gt;setSize()&lt;/code&gt;, and let that size determine the initial window size, by calling &lt;code&gt;JFrame.pack()&lt;/code&gt;. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don't do much good.</source>
          <target state="translated">&lt;strong&gt;그 방법의 사용을 완전히 피해야합니까?&lt;/strong&gt; 나는 그들을 &quot;피해야한다&quot;라고 말하지 않을 것이다. 당신이 필요하다고 생각한다면, 당신은 아마 뭔가 잘못하고 있다고 말하고 싶습니다. 구성 요소 크기는 상황에 따라 결정됩니다. 예를 들어, 텍스트 구성 요소 크기는 선택한 글꼴과 결합하여 지정한 행과 열 수에 따라 결정됩니다. 단추와 레이블 크기는 그래픽을 설정 한 경우 그래픽 크기이거나 설정 한 텍스트를 표시하는 데 필요한 공간이됩니다. 각 구성 요소의 크기는 자연스럽고 레이아웃 관리자는 크기를 지정하지 않고도 모든 구성 요소를 배치 할 수 있습니다. 주요 예외는 JScrollPane입니다. JScrollPane에는 크기에 관계없이 크기가 있습니다. 이를 위해 때로는 &lt;code&gt;setSize()&lt;/code&gt; 를 호출하고 &lt;code&gt;JFrame.pack()&lt;/code&gt; 을 호출하여 해당 크기가 초기 창 크기를 결정하도록합니다. 일반적으로 창 크기가 JScrollPane 크기를 결정하도록합니다. 사용자는 창의 크기를 결정할 것입니다. 많은 레이아웃 관리자는 어쨌든 설정 한 크기를 무시하므로 많은 일을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb29b79b090f0d71d579ecfac48293fc02a91481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?&lt;/strong&gt;
I believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn't fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn't want to bother with learning a new paradigm. It's a terrible idea.</source>
          <target state="translated">&lt;strong&gt;이 방법은 이유 때문에 정의되었습니다.&lt;/strong&gt; &lt;strong&gt;언제 사용해야합니까?&lt;/strong&gt; &lt;strong&gt;어떤 맥락에서?&lt;/strong&gt; &lt;strong&gt;어떤 목적으로?&lt;/strong&gt; 레이아웃 관리자에게 힌트를 제공하기 위해 추가되었다고 생각합니다. 레이아웃 관리자가 새롭고 사람들이 완전히 신뢰하지 않았기 때문에 역사적인 이유로 작성되었을 수 있습니다. 나는 새로운 패러다임을 배우고 싶지 않기 때문에 레이아웃 관리자를 피하고 모든 것을 수동으로 배치 한 소수의 개발자를 알고 있습니다. 끔찍한 생각입니다.</target>
        </trans-unit>
        <trans-unit id="f2a560db0d72f5a999aad79685126287e9f8c227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).&lt;/strong&gt;
They're ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.</source>
          <target state="translated">&lt;strong&gt;이러한 방법을 사용하면 어떤 부정적인 결과가 발생합니까?&lt;/strong&gt; &lt;strong&gt;(화면 해상도가 다른 시스템간에 이식성을 추가하는 것만 생각할 수 있습니다).&lt;/strong&gt; 그것들은 효과가 없으며, 객체가 압착되지 않거나 자연스럽지 않은 크기로 늘어나면서 잘못된 레이아웃을 생성합니다. 그리고 레이아웃이 부서지기 쉽습니다. 창 크기를 변경하면 레이아웃이 깨져서 잘못된 위치에 놓이는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75fd8314886af2005f7a571fef2f798a7e7172e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMaximumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMaximumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b11ddbbe6a3af1821698ada76274100c165c48cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMinimumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMinimumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89f81cef98f01aaa7c3a87a7392da5c9df43268c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setPreferredSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setPreferredSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8f222d9ad21513e10bd84b95b5bf37337e1762a" translate="yes" xml:space="preserve">
          <source>A few heuristics:</source>
          <target state="translated">몇 가지 휴리스틱 :</target>
        </trans-unit>
        <trans-unit id="5ed3ba4403e948d10f0d964a8030523919a40837" translate="yes" xml:space="preserve">
          <source>All that said, you can certainly conceive of situations where these methods are justified. Again, they aren't inherently evil, but their usage is normally a &lt;strong&gt;big&lt;/strong&gt; red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.</source>
          <target state="translated">그러나 이러한 방법이 정당화되는 상황을 확실히 생각할 수 있습니다. 다시 말하지만, 그들은 본질적으로 악하지는 않지만 일반적으로 잠재적 GUI 문제를 나타내는 &lt;strong&gt;큰&lt;/strong&gt; 적기입니다. 합병증을 사용하는 경우 합병증이 발생할 가능성이 높은지 항상 확인하고 문제에 대해 다른 모양과 느낌에 독립적 인 해결책이 있는지 항상 시도하고 생각하십시오. 방법이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="334e464b55e6cbe9ef940d5fd89ee52a5a006400" translate="yes" xml:space="preserve">
          <source>Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars. 
As opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).</source>
          <target state="translated">항상. 구성 요소를 작성할 때 해당 구성 요소의 사용에 따라 실제 최소 / 기본 / 최대 크기를 설정하십시오. 예를 들어 영국과 같은 국가 기호를 입력 할 수있는 JTextField가있는 경우 기본 크기는 두 문자 (현재 글꼴 등)에 맞도록 넓어야하지만 더 커질 수는 없습니다. 결국 국가 기호는 두 문자입니다. 반대로, 예를 들어 고객 이름을 입력하기위한 JTextField가있는 경우 20 자에 대한 픽셀 크기와 같은 크기를 선호하지만 레이아웃 크기를 조정하면 더 커질 수 있으므로 최대 크기를 더 많이 설정하십시오. 동시에 0px 너비의 JTextField를 갖는 것은 의미가 없으므로 현실적인 최소 크기를 설정하십시오 (픽셀 크기는 2 자라고 말하십시오).</target>
        </trans-unit>
        <trans-unit id="82a3275f2c6e319fc8e6e971d584332b7226964d" translate="yes" xml:space="preserve">
          <source>Any of the Big-Three can, can't even GridBag (never bothered to really master, too much trouble for too little power).</source>
          <target state="translated">모든 Big-Three는 GridBag조차도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="feada63cf7671891364a8ad7e4d18aec070ec6ec" translate="yes" xml:space="preserve">
          <source>As an example of this, try changing your application's default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.</source>
          <target state="translated">이에 대한 예로, 응용 프로그램의 기본 모양과 느낌을 변경해보십시오. 플랫폼에서 사용 가능한 옵션만으로도 결과가 얼마나 나빠질 수 있는지에 놀랄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f886c1766f46b82d763352fa65f26f99701edd" translate="yes" xml:space="preserve">
          <source>Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).</source>
          <target state="translated">기본적으로 원하는 크기를 설정 한 후에는 백분율로 아무것도하지 않을 수 있습니다. 단순히 백분율이 의미가 없기 때문에 (예를 들어, JTextField가 창 크기의 10 %를 갖는 것은 의미가 없습니다.) JTextField가 0px 너비가되도록 창을 축소하거나 JTextField가 다중 디스플레이 설정).</target>
        </trans-unit>
        <trans-unit id="44d763212c6c3a8fea4302c81748f40a5af6a256" translate="yes" xml:space="preserve">
          <source>But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).</source>
          <target state="translated">그러나 백분율을 사용하여 GUI의 더 큰 빌딩 블록 (예 : 패널)의 크기를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78233fddc435250272d7f9a010e1be36ab861764" translate="yes" xml:space="preserve">
          <source>By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies' &lt;code&gt;FormLayout&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;http://www.miglayout.com/&quot;&gt;&lt;code&gt;MigLayout&lt;/code&gt;&lt;/a&gt;. Some GUI builders even have built-in support for third-party layout managers -- Eclipse's WindowBuilder GUI editor, for example, ships with support for &lt;code&gt;FormLayout&lt;/code&gt; and &lt;code&gt;MigLayout&lt;/code&gt;.</source>
          <target state="translated">그건 그렇고, 표준 레이아웃 관리자에 불만이있는 경우 &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies ' &lt;code&gt;FormLayout&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://www.miglayout.com/&quot;&gt; &lt;code&gt;MigLayout&lt;/code&gt; 과 같은&lt;/a&gt; 무료 오픈 소스 타사가 많이 있습니다. 일부 GUI 빌더는 써드 파티 레이아웃 관리자 (예 : Eclipse의 WindowBuilder GUI 편집기)에 대한 내장 지원도 &lt;code&gt;FormLayout&lt;/code&gt; 및 &lt;code&gt;MigLayout&lt;/code&gt; 지원과 함께 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28464854017f94b9c9844769ee6144deaf548b29" translate="yes" xml:space="preserve">
          <source>Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;comments&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;주석&lt;/a&gt; 에서 언급 한 것처럼 파생 된 크기를 얻기 위해 많은 구성 요소를 반복해야하는 경우 대체 또는 사용자 정의 레이아웃을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="be6bbc414031de61f515ad578e905cd0b742227e" translate="yes" xml:space="preserve">
          <source>Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">레이아웃의 작은 변형마다 새로운 LayoutManager를 구현해야합니까?</target>
        </trans-unit>
        <trans-unit id="7cf1d64fab0d093b37c52e515ee1f02d1c34c796" translate="yes" xml:space="preserve">
          <source>Do use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; to derive post-&lt;code&gt;validate()&lt;/code&gt; geometry, as shown below and &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 를 사용하여 아래 및 &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;여기에&lt;/a&gt; 표시된대로 post- &lt;code&gt;validate()&lt;/code&gt; 지오메트리를 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="157eda23f1458fbcc63f756b719fa42aa4d3266a" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you could rely on a component's carefully overridden &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt;, as shown &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt; and below.</source>
          <target state="translated">구성 요소의 신중하게 재정의 된 &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt; 에 의존 할 수있는 경우 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 사용하지 마십시오 ( &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;여기&lt;/a&gt; 및 아래 참조).</target>
        </trans-unit>
        <trans-unit id="4546245bd9fc2988f588e0ddf7f4de2e035d8826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you really mean to override &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt;, as might be done in creating your own component, shown &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 를 재정의하려는 경우 &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; 사용하지 마십시오. &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;여기&lt;/a&gt; 에 표시된대로 고유 한 구성 요소를 만들 때처럼</target>
        </trans-unit>
        <trans-unit id="8858a12745633838c34a2266f3595b758ee64852" translate="yes" xml:space="preserve">
          <source>For example, the layout below:</source>
          <target state="translated">예를 들어 아래 레이아웃 :</target>
        </trans-unit>
        <trans-unit id="0b5b0c3f88d9871a3e20dffd7b5aea8ad3241262" translate="yes" xml:space="preserve">
          <source>I am seeing it differenty than the accepted answer.</source>
          <target state="translated">나는 그것이 받아 들인 대답과 다른 것을보고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e9dfc40abc06677021939bbd23ed04299fd51d" translate="yes" xml:space="preserve">
          <source>I don't know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. &quot;Slightly&quot;, because they should have implemented their needs with a custom LayoutManager.</source>
          <target state="translated">나는 개인적으로 그것을 API 디자인 사고라고 생각합니다. 어린이 크기에 대한 특별한 아이디어를 가진 복합 구성 요소에 의해 약간 강제됩니다. 사용자 정의 LayoutManager로 요구 사항을 구현 했어야했기 때문에 &quot;약간&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="05debf8858189b34f73fdc5385802a59b437dec7" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout
  needs. Do I really need to implement a new LayoutManager for every
  little variation on my layout?</source>
          <target state="translated">LayoutManager가 원하는 모든 레이아웃 요구를 정확하게 충족시킬 수 있다고 생각하지 않습니다. 레이아웃의 작은 변형마다 새로운 LayoutManager를 구현해야합니까?</target>
        </trans-unit>
        <trans-unit id="e293825a482ffdbc279a19695ddf553407dbbc00" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">LayoutManager가 원하는 모든 레이아웃 요구를 정확하게 충족시킬 수 있다고 생각하지 않습니다. 레이아웃의 작은 변형마다 새로운 LayoutManager를 구현해야합니까?</target>
        </trans-unit>
        <trans-unit id="f03332e8b0533248fe9e9bec74b216b33f9c8672" translate="yes" xml:space="preserve">
          <source>I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.</source>
          <target state="translated">8 년 이상 Swing 코드를 작성해 왔으며 JDK에 포함 된 레이아웃 관리자는 항상 내 요구에 부응했습니다. 레이아웃을 달성하기 위해 타사 레이아웃 관리자가 필요하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="45e24a1aab4e46086de24e1bd00ae96195747270" translate="yes" xml:space="preserve">
          <source>I have searched the web a little bit, but I haven't found any comprehensive analysis of the subject. So I have the following questions:</source>
          <target state="translated">웹을 조금 검색했지만 주제에 대한 포괄적 인 분석을 찾지 못했습니다. 그래서 다음과 같은 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19e84a41484b2716bcc34a770e49e845d1ffe27" translate="yes" xml:space="preserve">
          <source>I will say that you shouldn't try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.</source>
          <target state="translated">레이아웃 관리자가 필요할 때까지 이러한 방법으로 힌트를 제공해서는 안된다고 말할 것입니다. 크기 조정 힌트를 제공하지 않고 레이아웃을 수행 한 다음 (예 : 레이아웃 관리자가 작업을 수행하도록) 필요한 경우 사소한 수정을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4952d1d9c2545ce08ec8f0dfb48594021c83f640" translate="yes" xml:space="preserve">
          <source>If a component has no preferred size, e.g. &lt;code&gt;JDesktopPane&lt;/code&gt;, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.</source>
          <target state="translated">컴포넌트가 선호하는 크기가 아닌 경우 (예 : &lt;code&gt;JDesktopPane&lt;/code&gt; ) 컨테이너의 크기를 조정해야 할 수도 있지만 이러한 선택은 임의적입니다. 의견은 의도를 명확히하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c43bb7e290acdfdc7dbe1b01a2c5332529346f1" translate="yes" xml:space="preserve">
          <source>If by implementing you mean using then yes. Not one &lt;code&gt;LayoutManger&lt;/code&gt; can handle everything, each &lt;code&gt;LayoutManager&lt;/code&gt; has its pros and cons thus each can be used together to produce the final layout.</source>
          <target state="translated">구현하면 예를 사용하는 것을 의미합니다. 하나의 &lt;code&gt;LayoutManger&lt;/code&gt; 가 모든 것을 처리 할 수있는 것은 아니며, 각 &lt;code&gt;LayoutManager&lt;/code&gt; 에는 장단점이 있으므로 각각을 사용하여 최종 레이아웃을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d62286cfbf65303a6f848ee0864f361f380b7a" translate="yes" xml:space="preserve">
          <source>If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">4에 대한 대답이 &quot;예&quot;이면, 유지 보수가 어려워지는 LayoutManager 클래스가 확산되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="b063186389f8146493b73685b897b69952730e47" translate="yes" xml:space="preserve">
          <source>If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies &lt;code&gt;FormLayout&lt;/code&gt; provided freely as part of the Forms freeware library by Karsten Lentzsch &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Java Swing에서 레이아웃에 문제가있는 경우 Karsten Lentzsch의 Forms 프리웨어 라이브러리의 일부로 자유롭게 제공되는 JGoodies &lt;code&gt;FormLayout&lt;/code&gt; 을 여기에서 강력하게 추천 할 수 &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d96461400848ad4f167b8f2e7b96036043cb5c45" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?</source>
          <target state="translated">구성 요소의 자식 (자식 1은 공간의 10 %, 자식 2 40 %, 자식 3 50 %를 사용해야 함) 사이의 비율을 정의 해야하는 상황에서 사용자 정의 레이아웃 관리자를 구현하지 않고도 달성 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="5063acd66afacb43577cb43e4e3c3bef2c93feea" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">Component의 자식들 사이에 비율을 정의해야하는 상황에서 (예를 들어, child1은 공간의 10 %, child2 40 %, child3 50 %를 사용해야 함), 사용자 정의 LayoutManager를 구현하지 않고도 달성 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="031cb987d53c63d3108a20db2267a8bb488faae2" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">구성 요소의 자식 (예 : 자식 1은 공간의 10 %, 자식 2 40 %, 자식 3 50 %를 사용해야 함) 사이의 비율을 정의 해야하는 상황에서 사용자 정의 LayoutManager를 구현하지 않고도 달성 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8749b6c1a91e73f14a6ee417ecb38965be650eb9" translate="yes" xml:space="preserve">
          <source>Make sure that you really need to set the component's exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied &lt;em&gt;looks&lt;/em&gt; of the UI on different Systems</source>
          <target state="translated">구성 요소의 정확한 크기를 설정해야합니다. 각 Swing 구성 요소는 사용하는 글꼴과 모양과 느낌에 따라 선호하는 크기가 다릅니다. 따라서 설정된 크기가 있으면 다른 시스템에서 다양한 UI &lt;em&gt;모양&lt;/em&gt; 을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83665a294fe3f65e2b8c5d56e4046be52e81d907" translate="yes" xml:space="preserve">
          <source>Many layout managers do not pay attention to a component's requested maximum size. However, &lt;code&gt;BoxLayout&lt;/code&gt; and &lt;code&gt;SpringLayout&lt;/code&gt; do. Furthermore, &lt;code&gt;GroupLayout&lt;/code&gt; provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.</source>
          <target state="translated">많은 레이아웃 관리자는 구성 요소의 요청 된 최대 크기에주의를 기울이지 않습니다. 그러나 &lt;code&gt;BoxLayout&lt;/code&gt; 및 &lt;code&gt;SpringLayout&lt;/code&gt; 이 수행합니다. 또한 &lt;code&gt;GroupLayout&lt;/code&gt; 은 구성 요소를 건드리지 않고 최소, 기본 또는 최대 크기를 명시 적으로 설정할 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab89da0d68317915b0b083e37c7f4c657b21e4bb" translate="yes" xml:space="preserve">
          <source>Maybe &lt;code&gt;GridBagLayout&lt;/code&gt; would satisfy your needs. Besides that, there's a ton of layout managers on the web, and I bet there's one that fits your requirements.</source>
          <target state="translated">&lt;code&gt;GridBagLayout&lt;/code&gt; 이 귀하의 요구를 충족시킬 것입니다. 게다가 웹에는 수많은 레이아웃 관리자가 있으며 요구 사항에 맞는 레이아웃 관리자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec1d5cb339ea8bf28dabdc16b8ff8f4073ed0c4" translate="yes" xml:space="preserve">
          <source>Most importantly no matter how you specify your component's size, be sure that your component's container uses a layout manager that respects the requested size of the component.</source>
          <target state="translated">구성 요소의 크기를 어떻게 지정하더라도 구성 요소의 컨테이너는 요청 된 구성 요소의 크기를 고려한 레이아웃 관리자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec7904135c872d5504ba4625fa4861d3640b70e4" translate="yes" xml:space="preserve">
          <source>Never avoid! They're there to express the size constraints of your components to the layout manager. You can avoid using them if you're not using any layout manager and try to manage the visual layout on your own.</source>
          <target state="translated">절대 피하십시오! 레이아웃 관리자에게 컴포넌트의 크기 제약을 표현할 수 있습니다. 레이아웃 관리자를 사용하지 않고 시각적 레이아웃을 직접 관리하려고하면 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="019c97b9fc48d56cdc8c3608bba924a9b70932a7" translate="yes" xml:space="preserve">
          <source>No negative consequences. These are hints for the layout manager.</source>
          <target state="translated">부정적인 결과는 없습니다. 레이아웃 관리자를위한 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="5a8a6ea846414fc7b77ae01acccc90b507c47c69" translate="yes" xml:space="preserve">
          <source>No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.</source>
          <target state="translated">아뇨. 일반적인 접근 방식은 가로 및 세로 레이아웃과 같은 다른 기본 레이아웃 관리자를 계단식으로 배열하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="67179a80aecf9f836727c57083425efcac33c312" translate="yes" xml:space="preserve">
          <source>No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt;.</source>
          <target state="translated">아니요, 이러한 메소드를 호출하거나 재정의하는 것이 허용되지 않는다는 공식적인 증거는 없습니다. 실제로 오라클은 이러한 방법이 크기 힌트를 제공하는 데 사용된다고 말합니다 ( &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afc37620d6506412fbf52d3ba616d7a8da186c6c" translate="yes" xml:space="preserve">
          <source>No, you definitely shall not develop layout managers, unless you need something very special.</source>
          <target state="translated">매우 특별한 것이 필요하지 않으면 레이아웃 관리자를 개발하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="307ab8cb83f9ac27e039e7296b2b08390750ad96" translate="yes" xml:space="preserve">
          <source>Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you're about to develop anything serious.</source>
          <target state="translated">물론 이것은 실제 레이아웃으로 까다로워 질 수 있습니다. 따라서 MigLayout과 같은 그리드 기반 레이아웃 관리자는 심각한 것을 개발하려는 경우 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0d7954ef62fba1a1c6c5f8eb49be84da9e19ef5e" translate="yes" xml:space="preserve">
          <source>Several times I've been criticized for having suggested the use of the following methods:</source>
          <target state="translated">여러 번 다음 방법의 사용을 제안한 것에 대해 비판을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="5159a31c0c57223db57d56c6afccc7b37ae7c0e4" translate="yes" xml:space="preserve">
          <source>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing</source>
          <target state="translated">Java Swing에서 set (Preferred | Maximum | Minimum) Size 메서드를 사용하지 않아야합니다</target>
        </trans-unit>
        <trans-unit id="24368ab382b57b4e51fbff30e82703ed71584963" translate="yes" xml:space="preserve">
          <source>Should I completely avoid the use of those methods?</source>
          <target state="translated">그 방법의 사용을 완전히 피해야합니까?</target>
        </trans-unit>
        <trans-unit id="0e8b46b6e2690834b4abf89137b167ccb21005aa" translate="yes" xml:space="preserve">
          <source>So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.</source>
          <target state="translated">따라서 모든 플랫폼에서 GUI를 기능적이고 멋지게 유지하기 위해 (Java의 주요 이점 중 하나는 플랫폼 간이라는 점을 기억하십시오) 레이아웃 관리자 등에 의존하여 자동으로 크기를 조정해야합니다. 특정 개발 환경 외부에서 올바르게 렌더링되도록 구성 요소</target>
        </trans-unit>
        <trans-unit id="1bd3d705c344338a8aad1a106bac39a04e05b944" translate="yes" xml:space="preserve">
          <source>Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Rules (hehe)&lt;/a&gt; or in the &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;link&lt;/a&gt; @bendicott found in his/her comment to &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;my answer&lt;/a&gt;. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.</source>
          <target state="translated">일부 (불완전하고 불행하게도 SwingLabs를 java.net으로 마이그레이션하여 링크가 끊어짐) 기술적 이유는 예를 들어 &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;규칙 (hehe)&lt;/a&gt; 또는 &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;내 답변에 대한&lt;/a&gt; 의견에서 찾은 @bendicott &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;링크에&lt;/a&gt; 언급되어 있습니다. 사회적으로, 코드를 유지해야하며 깨진 레이아웃을 추적해야하는 불행한 동료에게 수많은 작업을합니다.</target>
        </trans-unit>
        <trans-unit id="40f1d31b7c8dd444f50d98428b8cd8ccfaeafd52" translate="yes" xml:space="preserve">
          <source>The methods have been defined for a reason. So when should I use them?
  In which context? For what purposes?</source>
          <target state="translated">이 방법은 이유 때문에 정의되었습니다. 언제 사용해야합니까? 어떤 맥락에서? 어떤 목적으로?</target>
        </trans-unit>
        <trans-unit id="540c4f65db18e1030a34da86ee391410c184bf1f" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I want to add a little more about the reasons &lt;em&gt;why&lt;/em&gt; you should normally avoid these (the question just came up again in a duplicate topic):</source>
          <target state="translated">여기에 좋은 답변이 많이 있지만 일반적으로 이러한 문제를 피해야하는 이유에 대해 조금 더 추가하고 싶습니다 (질문은 중복 주제로 다시 나타납니다).</target>
        </trans-unit>
        <trans-unit id="4f1c2750bb9a0c4dd1e3fb79014aa8f3f4f20030" translate="yes" xml:space="preserve">
          <source>These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:</source>
          <target state="translated">이러한 방법은 대부분의 사람들이 잘 이해하지 못합니다. 이러한 방법을 절대 무시해서는 안됩니다. 이러한 방법을 준수하는 경우 레이아웃 관리자가 결정합니다. 이 페이지에는 어떤 레이아웃 관리자가 어떤 방법을 사용하는지 보여주는 표가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a51f32acf1907b534bde7944ee38f8386d99137" translate="yes" xml:space="preserve">
          <source>They may also be overridden (which is the best practice for Swing) when &lt;em&gt;extending&lt;/em&gt; a Swing component (rather than calling the method on the custom component instance)</source>
          <target state="translated">사용자 지정 구성 요소 인스턴스에서 메서드를 호출하지 않고 Swing 구성 요소를 &lt;em&gt;확장&lt;/em&gt; 할 때 재정의 될 수도 있습니다 (Swing의 모범 사례).</target>
        </trans-unit>
        <trans-unit id="c1e85d170b014983936e8e2c4c7e900a35ffafa9" translate="yes" xml:space="preserve">
          <source>This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.</source>
          <target state="translated">이 인기있는 레이아웃 관리자는 매우 유연하여 매우 세련된 Java UI를 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec55556bdbbcf021c597b1ba85f53eae29d5d67" translate="yes" xml:space="preserve">
          <source>Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.</source>
          <target state="translated">불행히도 Swing에는 합리적인 기본 크기가 제공되지 않습니다. 그러나 구성 요소의 크기를 설정하는 대신 자신의 구성 요소를 합리적인 기본값으로 내림차순으로 만드는 것이 좋습니다. (이 경우 하위 클래스에서 setXXX를 호출합니다.) 또는 동일한 효과를 위해 getXXX 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0518f85937eecd914f0c447bc9b66e9a1efed65" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I
  can only think to add portability between systems with different
  screen resolution).</source>
          <target state="translated">이러한 방법을 사용하면 어떤 부정적인 결과가 발생합니까? (화면 해상도가 다른 시스템 사이에서만 이식성을 추가한다고 생각할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="03be6972f5a871fb5126119ff2853a38a28c8c7e" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">이러한 방법을 사용하면 어떤 부정적인 결과가 발생합니까? (화면 해상도가 다른 시스템간에 이식성을 추가하는 것만 생각할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="7db7f6858afa5c9fac8e8b9fdc4da5e60b2f58b1" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)</source>
          <target state="translated">이러한 방법을 사용하면 어떤 부정적인 결과가 발생합니까? (화면 해상도가 다른 시스템간에 이식성을 추가하는 것만 생각할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b4a11b0ef058755c0527df7e68585b1ac10c6518" translate="yes" xml:space="preserve">
          <source>When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well</source>
          <target state="translated">구성 요소가 잘 배치되도록 컨테이너 레이아웃 관리자에 사용자 정의 크기 힌트를 제공해야하는 경우</target>
        </trans-unit>
        <trans-unit id="2744a93affacde93c2fe41cf485c4eb89f3e85ea" translate="yes" xml:space="preserve">
          <source>With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren't inherently evil, but the typical reasons for using them &lt;em&gt;are&lt;/em&gt;. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.</source>
          <target state="translated">몇 가지 예외를 제외하고, 이러한 방법을 사용하는 경우 특정 모양과 느낌 (및 시스템 별 설정 (예 : 선호하는 데스크탑 글꼴 등)으로보기에 적합하도록 GUI를 미세 조정할 수 있습니다. 방법 자체는 본질적으로 악한 것이 아니지만 사용하는 일반적인 이유는 다음 &lt;em&gt;과 같습니다&lt;/em&gt; . 레이아웃에서 픽셀 위치 및 크기 조정을 시작하자마자 다른 플랫폼에서 GUI가 깨질 위험이 있습니다 (최소한 나빠 보일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="181abc8f1431b3fc4b24b7ff7084f5997bf9d984" translate="yes" xml:space="preserve">
          <source>With layouts the answer is always the same: use a suitable
  LayoutManager</source>
          <target state="translated">레이아웃의 대답은 항상 동일합니다. 적절한 LayoutManager를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a18978692bb37ab6256c8c6714eeb798c4d51295" translate="yes" xml:space="preserve">
          <source>Yes for application code.</source>
          <target state="translated">응용 프로그램 코드의 경우 예</target>
        </trans-unit>
        <trans-unit id="dac954ba2e6beb0d6c4bd134e2e18d3a82cfd388" translate="yes" xml:space="preserve">
          <source>Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to &quot;all layout needs&quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.</source>
          <target state="translated">예, &quot;모든 레이아웃 요구&quot;에 대한 아주 좋은 근사치를 충족 할 수있을만큼 강력한 LayoutManager가 있습니다. 큰 세 가지는 JGoodies FormLayout, MigLayout, DesignGridLayout입니다. 실제로 실제로 고도로 전문화 된 환경을 제외하고는 LayoutManager를 작성하는 경우가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="444042202368def5f8181a05aefd275a8d54be0c" translate="yes" xml:space="preserve">
          <source>You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.</source>
          <target state="translated">JSplitPane을 사용하여 두면의 비율을 미리 설정할 수 있습니다. 또는 MigLayout을 사용하여 백분율, 픽셀 및 기타 단위로 이러한 제약 조건을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35a75cc4334792c6bc0ab1cd5a82739998fcbef" translate="yes" xml:space="preserve">
          <source>You'll find Karsten's documentation in &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;here&lt;/a&gt;, and some rather good documentation from eclipse &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Karsten의 문서는 &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있고 Eclipse의 일부 좋은 문서는 여기 에서 찾을 수 &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2893740bacbf2ae887be29e7602f37f93e33c2d4" translate="yes" xml:space="preserve">
          <source>between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">구성 요소의 하위 (예 : child1은 공간의 10 %, child2 40 %, child3 50 %를 사용해야 함) 사이에 사용자 정의 LayoutManager를 구현하지 않고도 달성 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0886212cd9ad81c73e17959b2f0c7b17e6248ebc" translate="yes" xml:space="preserve">
          <source>is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.</source>
          <target state="translated">두 부분이 있습니다. 왼쪽과 오른쪽 부분은 가로 레이아웃입니다. 오른쪽 부분은 가로 레이아웃에 추가 된 JPanel이며이 JPanel에는 단추를 세로로 배치하는 세로 레이아웃이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00a4682b9e06987369438cd97d3639a65d0178c" translate="yes" xml:space="preserve">
          <source>on &lt;code&gt;Swing&lt;/code&gt; components. I don't see any alternative to their use when I want to define proportions between displayed components. I have been told this:</source>
          <target state="translated">&lt;code&gt;Swing&lt;/code&gt; 구성 요소에. 표시된 구성 요소 간의 비율을 정의하려는 경우 사용에 대한 대안이 없습니다. 나는 이것을 들었다 :</target>
        </trans-unit>
        <trans-unit id="d8e8fbecb943993f987bc322df6b509bc6daa8b4" translate="yes" xml:space="preserve">
          <source>sometimes problems can be encountered with &lt;code&gt;GridBagLayout&lt;/code&gt; and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.</source>
          <target state="translated">때때로 컨테이너 크기가 원하는 크기보다 작 으면 최소 크기가 사용되어 텍스트 필드가 상당히 줄어들 수있는 &lt;code&gt;GridBagLayout&lt;/code&gt; 및 텍스트 필드에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
