<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/7229226">
    <body>
      <group id="7229226">
        <trans-unit id="101513b86d72ed6fcdb26b5d3b3a91761a1a7eeb" translate="yes" xml:space="preserve">
          <source>(I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">(Могу только подумать о добавлении переносимости между системами с разным разрешением экрана).</target>
        </trans-unit>
        <trans-unit id="f322b9e0be596ee0c12c766b6f6362bac3fda875" translate="yes" xml:space="preserve">
          <source>(The answer to 4 is &quot;no&quot;.)</source>
          <target state="translated">(Ответ на 4-&quot;нет&quot;.)</target>
        </trans-unit>
        <trans-unit id="a62f3745308389d8190dd4aa927eccdaa9df3d4a" translate="yes" xml:space="preserve">
          <source>1) Should I completely avoid the use of those methods?</source>
          <target state="translated">1)Должен ли я полностью отказаться от использования этих методов?</target>
        </trans-unit>
        <trans-unit id="9be06212edf76a1a8f22e4f87f620e98f3917e4f" translate="yes" xml:space="preserve">
          <source>2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</source>
          <target state="translated">2)Методы были определены не случайно.Так когда я должен их использовать? В каком контексте? Для каких целей?</target>
        </trans-unit>
        <trans-unit id="3129078a99b0f0599191614194a02dd301b6ef4c" translate="yes" xml:space="preserve">
          <source>3) What exactly are the negative consequences of using those methods?</source>
          <target state="translated">3)Каковы именно негативные последствия использования этих методов?</target>
        </trans-unit>
        <trans-unit id="e4537f34f955a436cd38a10e8ea7eee57157f6f1" translate="yes" xml:space="preserve">
          <source>4) I don't think any LayoutManager can exactly satisfy all desired layout needs.</source>
          <target state="translated">4)Я не думаю,что любой LayoutManager может точно удовлетворить все желаемые потребности в макетах.</target>
        </trans-unit>
        <trans-unit id="a50e32a4d28ac833b32f3d7ebf4edda651c47cb3" translate="yes" xml:space="preserve">
          <source>5) If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">5)Если ответ на 4-&quot;да&quot;,не приведет ли это к распространению классов LayoutManager,которые будет трудно поддерживать?</target>
        </trans-unit>
        <trans-unit id="9e4a5573061af9e7df2555b66d39ace412023fef" translate="yes" xml:space="preserve">
          <source>6) In a situation where I need to define proportions...</source>
          <target state="translated">6)В ситуации,когда мне нужно определить пропорции...</target>
        </trans-unit>
        <trans-unit id="caae42b05fc60c9860a79b7d9ccb2ea61214c824" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JFrame&lt;/code&gt; does not enforce overriden &lt;code&gt;getMinimumSize()&lt;/code&gt; only calling &lt;code&gt;setMinimumSize(..)&lt;/code&gt; on its works</source>
          <target state="translated">&lt;code&gt;JFrame&lt;/code&gt; не &lt;code&gt;getMinimumSize()&lt;/code&gt; переопределенный метод getMinimumSize (), только вызывая &lt;code&gt;setMinimumSize(..)&lt;/code&gt; для своих работ</target>
        </trans-unit>
        <trans-unit id="b3647248e0173f71dd2355fcf20828a2dedaf8e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?&lt;/strong&gt; You shouldn't &quot;implement&quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they're hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never &quot;implement&quot; a layout manager. I just instantiate them.</source>
          <target state="translated">&lt;strong&gt;Я не думаю, что любой LayoutManager может точно удовлетворить все желаемые потребности макета.&lt;/strong&gt; &lt;strong&gt;Действительно ли мне нужно реализовывать новый LayoutManager для каждого небольшого изменения моего макета?&lt;/strong&gt; Вы не должны &amp;laquo;реализовывать&amp;raquo; новый LayoutManager. Вы должны создать экземпляр существующих. Я часто использую несколько менеджеров компоновки в одном окне. Каждый JPanel будет иметь свой собственный менеджер макета. Некоторые люди отказываются от вложенных макетов, потому что их сложно поддерживать. Когда я их использую, я даю каждому свой метод создания, чтобы было легче увидеть, что делает каждый. Но я никогда не &amp;laquo;внедряю&amp;raquo; менеджер раскладок. Я просто создаю их экземпляр.</target>
        </trans-unit>
        <trans-unit id="edce1b4cb1e94b90bfc85934288d525da7af49fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?&lt;/strong&gt;
If you're implementing new layout manager classes for slight variations in layout, you're using them wrong. If you're just implementing new layout managers, you're probably doing something wrong. The only time I've extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.</source>
          <target state="translated">&lt;strong&gt;Если ответ на 4 - &amp;laquo;да&amp;raquo;, не приведет ли это к увеличению числа классов LayoutManager, которое будет трудно поддерживать?&lt;/strong&gt; Если вы реализуете новые классы менеджера макета для небольших изменений в макете, вы используете их неправильно. Если вы просто внедряете новые менеджеры компоновки, вы, вероятно, делаете что-то не так. Единственный раз, когда я расширил класс LayoutManager, это было добавить ползунок масштабирования в JScrollPane.</target>
        </trans-unit>
        <trans-unit id="bac7ad7f05d5d55847b7fd4cc2f7ed1978917af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?&lt;/strong&gt;
The JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don't use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.</source>
          <target state="translated">&lt;strong&gt;В ситуации, когда мне нужно определить пропорции между дочерними элементами компонента (например, child1 должен использовать 10% пространства, child2 40%, child3 50%), возможно ли достичь этого без реализации пользовательского LayoutManager?&lt;/strong&gt; В JSplitPane есть способ указать процент, который должен получить каждый компонент. По умолчанию разделитель является подвижным, но вы можете отключить его, если хотите. Я не использую эту функцию много. У меня обычно есть некоторые компоненты, которые занимают заданный размер, а остальное пространство занимает область прокрутки. Размер области прокрутки будет регулироваться в зависимости от размера окна. Если у вас есть две панели прокрутки рядом, вы можете поместить их в JSplitPane и указать процент нового пространства, выделенного для каждой из них, когда пользователь расширяет и сжимает окна.</target>
        </trans-unit>
        <trans-unit id="2ef0079b6c8a172dd2c245d6fc600772f49ecf38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="253649f0361fd376d76e98ac2e931514bc001bdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Should I completely avoid the use of those methods?&lt;/strong&gt;
I wouldn't say &quot;avoid&quot; them. I'd say that if you think you need them, you're probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call &lt;code&gt;setSize()&lt;/code&gt;, and let that size determine the initial window size, by calling &lt;code&gt;JFrame.pack()&lt;/code&gt;. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don't do much good.</source>
          <target state="translated">&lt;strong&gt;Должен ли я полностью избегать использования этих методов?&lt;/strong&gt; Я бы не сказал &amp;laquo;избегать&amp;raquo; их. Я бы сказал, что если вы думаете, что они вам нужны, вы, вероятно, делаете что-то не так. Размеры компонентов определяются в контексте. Например, размеры текстового компонента определяются указанным количеством строк и столбцов в сочетании с выбранным вами шрифтом. Размер вашей кнопки и метки будет соответствовать размеру графического изображения, если вы его установили, или пространству, необходимому для отображения заданного вами текста. Каждый компонент имеет естественный размер, и менеджеры компоновки будут использовать его, чтобы выложить все без необходимости указывать размеры. Основным исключением является JScrollPane, размер которого не зависит от содержимого. Для этого я иногда вызываю &lt;code&gt;setSize()&lt;/code&gt; и позволяю этому размеру определять начальный размер окна, вызывая &lt;code&gt;JFrame.pack()&lt;/code&gt; . Обычно я позволяю размеру окна определять размер JScrollPane. Пользователь определит размер окна. Многие менеджеры компоновки игнорируют установленные вами размеры, поэтому они часто не приносят пользы.</target>
        </trans-unit>
        <trans-unit id="bb29b79b090f0d71d579ecfac48293fc02a91481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?&lt;/strong&gt;
I believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn't fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn't want to bother with learning a new paradigm. It's a terrible idea.</source>
          <target state="translated">&lt;strong&gt;Методы были определены по причине.&lt;/strong&gt; &lt;strong&gt;Так, когда я должен использовать их?&lt;/strong&gt; &lt;strong&gt;В каком контексте?&lt;/strong&gt; &lt;strong&gt;Для каких целей?&lt;/strong&gt; Я полагаю, что они были добавлены, чтобы предоставить подсказки менеджерам по расположению. Возможно, они были написаны по историческим причинам, потому что менеджеры по компоновке были новыми, и люди не доверяли им полностью. Я знаю нескольких разработчиков, которые избегали менеджеров компоновки и размещали все вручную, просто потому, что не хотели беспокоиться о изучении новой парадигмы. Это ужасная идея.</target>
        </trans-unit>
        <trans-unit id="f2a560db0d72f5a999aad79685126287e9f8c227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).&lt;/strong&gt;
They're ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.</source>
          <target state="translated">&lt;strong&gt;Каковы конкретно негативные последствия использования этих методов?&lt;/strong&gt; &lt;strong&gt;(Я могу только подумать о добавлении переносимости между системами с разным разрешением экрана).&lt;/strong&gt; Они неэффективны и создают плохие макеты, при этом объекты сжимаются или растягиваются до неестественных размеров. И макеты будут хрупкими. Изменения в размере окна иногда нарушают компоновку и помещают вещи в неправильные места.</target>
        </trans-unit>
        <trans-unit id="75fd8314886af2005f7a571fef2f798a7e7172e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMaximumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMaximumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b11ddbbe6a3af1821698ada76274100c165c48cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMinimumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMinimumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89f81cef98f01aaa7c3a87a7392da5c9df43268c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setPreferredSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setPreferredSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8f222d9ad21513e10bd84b95b5bf37337e1762a" translate="yes" xml:space="preserve">
          <source>A few heuristics:</source>
          <target state="translated">Несколько эвристик:</target>
        </trans-unit>
        <trans-unit id="5ed3ba4403e948d10f0d964a8030523919a40837" translate="yes" xml:space="preserve">
          <source>All that said, you can certainly conceive of situations where these methods are justified. Again, they aren't inherently evil, but their usage is normally a &lt;strong&gt;big&lt;/strong&gt; red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.</source>
          <target state="translated">Все это говорит о том, что вы, конечно, можете представить себе ситуации, когда эти методы оправданы. Опять же, они не являются по сути злыми, но их использование обычно представляет собой &lt;strong&gt;большой&lt;/strong&gt; красный флаг, указывающий на потенциальные проблемы с графическим интерфейсом. Просто убедитесь, что вы знаете о высоком потенциале осложнений, если / когда вы их используете, и всегда старайтесь думать о том, есть ли другое решение ваших проблем, не зависящее от внешнего вида - чаще всего вы обнаружите, что это методы не нужны.</target>
        </trans-unit>
        <trans-unit id="334e464b55e6cbe9ef940d5fd89ee52a5a006400" translate="yes" xml:space="preserve">
          <source>Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars. 
As opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).</source>
          <target state="translated">Всегда.При создании компонента установите его реалистичный размер minpreferredmax в соответствии с использованием этого компонента.Например,если у вас есть JTextField для ввода символов стран,таких как Великобритания,его предпочтительный размер должен быть таким же широким,чтобы поместиться в два символа (с текущим шрифтом и т.д.),но,вероятно,не имеет смысла позволять ему расти еще больше.В конце концов,символы стран-это два символа.Напротив,если у вас есть JTextField для ввода,например,имени клиента,он может иметь предпочтительный размер,например,пиксель для 20 символов,но может вырасти до большего,если размер макета изменен,поэтому установите максимальный размер на большее значение.В то же время,наличие JTextField шириной 0px не имеет смысла,поэтому установите реалистичный минимальный размер (я бы сказал,пиксельный размер 2 чар).</target>
        </trans-unit>
        <trans-unit id="82a3275f2c6e319fc8e6e971d584332b7226964d" translate="yes" xml:space="preserve">
          <source>Any of the Big-Three can, can't even GridBag (never bothered to really master, too much trouble for too little power).</source>
          <target state="translated">Любой из Big-Three может,не может даже GridBag (никогда не беспокоились,чтобы действительно овладеть,слишком много проблем для слишком малой мощности).</target>
        </trans-unit>
        <trans-unit id="feada63cf7671891364a8ad7e4d18aec070ec6ec" translate="yes" xml:space="preserve">
          <source>As an example of this, try changing your application's default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.</source>
          <target state="translated">В качестве примера попробуйте изменить внешний вид вашего приложения по умолчанию.Даже просто с опциями,доступными на вашей платформе,вы можете быть удивлены,насколько плохо могут быть отображены результаты.</target>
        </trans-unit>
        <trans-unit id="e2f886c1766f46b82d763352fa65f26f99701edd" translate="yes" xml:space="preserve">
          <source>Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).</source>
          <target state="translated">В принципе,как только предпочтительные размеры будут установлены правильно,вы можете не захотеть делать ничего в процентах.Просто потому,что проценты бессмысленны (например,бессмысленно иметь JTextField 10% от размера окна-так как можно уменьшить окно так,чтобы JTextField стал 0px шириной,или можно расширить окно так,чтобы JTextField был на двух дисплеях при настройке мультидисплея).</target>
        </trans-unit>
        <trans-unit id="44d763212c6c3a8fea4302c81748f40a5af6a256" translate="yes" xml:space="preserve">
          <source>But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).</source>
          <target state="translated">Но,может быть,вы используете проценты,чтобы контролировать размеры больших строительных блоков вашего gui (панели,например).</target>
        </trans-unit>
        <trans-unit id="78233fddc435250272d7f9a010e1be36ab861764" translate="yes" xml:space="preserve">
          <source>By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies' &lt;code&gt;FormLayout&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;http://www.miglayout.com/&quot;&gt;&lt;code&gt;MigLayout&lt;/code&gt;&lt;/a&gt;. Some GUI builders even have built-in support for third-party layout managers -- Eclipse's WindowBuilder GUI editor, for example, ships with support for &lt;code&gt;FormLayout&lt;/code&gt; and &lt;code&gt;MigLayout&lt;/code&gt;.</source>
          <target state="translated">Кстати, если вы разочаровались в стандартных менеджерах компоновки, есть много хороших бесплатных сторонних разработчиков с открытым исходным кодом, например &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies ' &lt;code&gt;FormLayout&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;http://www.miglayout.com/&quot;&gt; &lt;code&gt;MigLayout&lt;/code&gt; &lt;/a&gt; . Некоторые сборщики GUI даже имеют встроенную поддержку сторонних менеджеров компоновки - например, редактор графического интерфейса Eclipse WindowBuilder поставляется с поддержкой &lt;code&gt;FormLayout&lt;/code&gt; и &lt;code&gt;MigLayout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28464854017f94b9c9844769ee6144deaf548b29" translate="yes" xml:space="preserve">
          <source>Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;comments&lt;/a&gt;.</source>
          <target state="translated">Рассмотрите альтернативные или пользовательские макеты, когда вы обнаружите, что вам придется пройтись по многим компонентам, чтобы получить производные размеры, как упомянуто в этих &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;комментариях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be6bbc414031de61f515ad578e905cd0b742227e" translate="yes" xml:space="preserve">
          <source>Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">Действительно ли мне нужно внедрять новый LayoutManager для каждого небольшого изменения в моей компоновке?</target>
        </trans-unit>
        <trans-unit id="7cf1d64fab0d093b37c52e515ee1f02d1c34c796" translate="yes" xml:space="preserve">
          <source>Do use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; to derive post-&lt;code&gt;validate()&lt;/code&gt; geometry, as shown below and &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; для получения геометрии post- &lt;code&gt;validate()&lt;/code&gt; , как показано ниже и &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="157eda23f1458fbcc63f756b719fa42aa4d3266a" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you could rely on a component's carefully overridden &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt;, as shown &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt; and below.</source>
          <target state="translated">Не используйте &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; когда вы можете полагаться на тщательно переопределенный компонент &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt; , как показано &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;здесь&lt;/a&gt; и ниже.</target>
        </trans-unit>
        <trans-unit id="4546245bd9fc2988f588e0ddf7f4de2e035d8826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you really mean to override &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt;, as might be done in creating your own component, shown &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Не используйте &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; когда вы действительно хотите переопределить &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt; , как это может быть сделано при создании собственного компонента, показанного &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8858a12745633838c34a2266f3595b758ee64852" translate="yes" xml:space="preserve">
          <source>For example, the layout below:</source>
          <target state="translated">Например,схема ниже:</target>
        </trans-unit>
        <trans-unit id="0b5b0c3f88d9871a3e20dffd7b5aea8ad3241262" translate="yes" xml:space="preserve">
          <source>I am seeing it differenty than the accepted answer.</source>
          <target state="translated">Я вижу,что это отличается от принятого ответа.</target>
        </trans-unit>
        <trans-unit id="c0e9dfc40abc06677021939bbd23ed04299fd51d" translate="yes" xml:space="preserve">
          <source>I don't know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. &quot;Slightly&quot;, because they should have implemented their needs with a custom LayoutManager.</source>
          <target state="translated">Я не знаю,лично я думаю об этом,как о несчастном случае с API-дизайном.Слегка форсированный составными компонентами,имеющими особые представления о детских размерах.&quot;Слегка&quot;,потому что они должны были реализовать свои потребности с помощью пользовательского LayoutManager.</target>
        </trans-unit>
        <trans-unit id="05debf8858189b34f73fdc5385802a59b437dec7" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout
  needs. Do I really need to implement a new LayoutManager for every
  little variation on my layout?</source>
          <target state="translated">Я не думаю,что любой LayoutManager может точно удовлетворить все желаемые потребности в макетах.Действительно ли мне нужно внедрять новый LayoutManager для каждого небольшого изменения в моей компоновке?</target>
        </trans-unit>
        <trans-unit id="e293825a482ffdbc279a19695ddf553407dbbc00" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">Я не думаю,что любой LayoutManager может точно удовлетворить все желаемые потребности в макетах.Действительно ли мне нужно внедрять новый LayoutManager для каждого небольшого изменения в моей компоновке?</target>
        </trans-unit>
        <trans-unit id="f03332e8b0533248fe9e9bec74b216b33f9c8672" translate="yes" xml:space="preserve">
          <source>I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.</source>
          <target state="translated">Я пишу Swing код уже 8+лет,а менеджеры по верстке,входящие в JDK,всегда служили моим потребностям.Мне никогда не требовался сторонний менеджер макетов для достижения моих компоновок.</target>
        </trans-unit>
        <trans-unit id="45e24a1aab4e46086de24e1bd00ae96195747270" translate="yes" xml:space="preserve">
          <source>I have searched the web a little bit, but I haven't found any comprehensive analysis of the subject. So I have the following questions:</source>
          <target state="translated">Я немного покопался в Интернете,но не нашел полного анализа предмета.Поэтому у меня есть следующие вопросы:</target>
        </trans-unit>
        <trans-unit id="d19e84a41484b2716bcc34a770e49e845d1ffe27" translate="yes" xml:space="preserve">
          <source>I will say that you shouldn't try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.</source>
          <target state="translated">Я скажу,что не стоит пытаться дать подсказки менеджера компоновки с помощью этих методов,пока вы не будете уверены,что они вам нужны.Делайте разметку,не давая подсказок по размеру (т.е.позвольте менеджеру разметки делать свою работу),и тогда вы сможете вносить незначительные исправления,если вам это понадобится.</target>
        </trans-unit>
        <trans-unit id="4952d1d9c2545ce08ec8f0dfb48594021c83f640" translate="yes" xml:space="preserve">
          <source>If a component has no preferred size, e.g. &lt;code&gt;JDesktopPane&lt;/code&gt;, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.</source>
          <target state="translated">Если у компонента нет предпочтительного размера, например &lt;code&gt;JDesktopPane&lt;/code&gt; , вам может потребоваться определить размер контейнера, но любой такой выбор является произвольным. Комментарий может помочь уточнить намерения.</target>
        </trans-unit>
        <trans-unit id="1c43bb7e290acdfdc7dbe1b01a2c5332529346f1" translate="yes" xml:space="preserve">
          <source>If by implementing you mean using then yes. Not one &lt;code&gt;LayoutManger&lt;/code&gt; can handle everything, each &lt;code&gt;LayoutManager&lt;/code&gt; has its pros and cons thus each can be used together to produce the final layout.</source>
          <target state="translated">Если под реализацией вы подразумеваете использование, то да. Ни один &lt;code&gt;LayoutManger&lt;/code&gt; не может справиться со всем, у каждого &lt;code&gt;LayoutManager&lt;/code&gt; есть свои плюсы и минусы, поэтому каждый из них может использоваться вместе для создания окончательного макета.</target>
        </trans-unit>
        <trans-unit id="87d62286cfbf65303a6f848ee0864f361f380b7a" translate="yes" xml:space="preserve">
          <source>If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">Если ответ на 4-&quot;да&quot;,не приведет ли это к распространению классов LayoutManager,которые будет трудно поддерживать?</target>
        </trans-unit>
        <trans-unit id="b063186389f8146493b73685b897b69952730e47" translate="yes" xml:space="preserve">
          <source>If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies &lt;code&gt;FormLayout&lt;/code&gt; provided freely as part of the Forms freeware library by Karsten Lentzsch &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Если у вас возникли проблемы с макетами в Java Swing, я настоятельно рекомендую JGoodies &lt;code&gt;FormLayout&lt;/code&gt; , предоставляемый бесплатно как часть бесплатной библиотеки форм от Karsten Lentzsch.</target>
        </trans-unit>
        <trans-unit id="d96461400848ad4f167b8f2e7b96036043cb5c45" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?</source>
          <target state="translated">В ситуации,когда мне необходимо определить пропорции между детьми Компонента (ребенок 1 должен использовать 10% пространства,ребенок2 40%,ребенок3 50%),возможно ли достичь этого без реализации пользовательского менеджера компоновки?</target>
        </trans-unit>
        <trans-unit id="5063acd66afacb43577cb43e4e3c3bef2c93feea" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">В ситуации,когда мне необходимо определить пропорции между детьми Компонента (например,child1 должен использовать 10% пространства,child2 40%,child3 50%),возможно ли достичь этого без реализации пользовательского LayoutManager?</target>
        </trans-unit>
        <trans-unit id="031cb987d53c63d3108a20db2267a8bb488faae2" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">В ситуации,когда мне необходимо определить пропорции между детьми Компонента (например,ребенок 1 должен использовать 10% пространства,ребенок 2 40%,ребенок 3 50%),возможно ли достичь этого без реализации пользовательского LayoutManager?</target>
        </trans-unit>
        <trans-unit id="8749b6c1a91e73f14a6ee417ecb38965be650eb9" translate="yes" xml:space="preserve">
          <source>Make sure that you really need to set the component's exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied &lt;em&gt;looks&lt;/em&gt; of the UI on different Systems</source>
          <target state="translated">Убедитесь, что вам действительно нужно установить точный размер компонента. Каждый компонент Swing имеет свой предпочтительный размер в зависимости от используемого шрифта и внешнего вида. Таким образом, наличие установленного размера может привести к различному &lt;em&gt;виду&lt;/em&gt; пользовательского интерфейса в разных системах.</target>
        </trans-unit>
        <trans-unit id="83665a294fe3f65e2b8c5d56e4046be52e81d907" translate="yes" xml:space="preserve">
          <source>Many layout managers do not pay attention to a component's requested maximum size. However, &lt;code&gt;BoxLayout&lt;/code&gt; and &lt;code&gt;SpringLayout&lt;/code&gt; do. Furthermore, &lt;code&gt;GroupLayout&lt;/code&gt; provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.</source>
          <target state="translated">Многие менеджеры компоновки не обращают внимание на максимальный размер запрошенного компонента. Однако &lt;code&gt;BoxLayout&lt;/code&gt; и &lt;code&gt;SpringLayout&lt;/code&gt; делают. Кроме того, &lt;code&gt;GroupLayout&lt;/code&gt; предоставляет возможность явно установить минимальный, предпочтительный или максимальный размер, не касаясь компонента.</target>
        </trans-unit>
        <trans-unit id="ab89da0d68317915b0b083e37c7f4c657b21e4bb" translate="yes" xml:space="preserve">
          <source>Maybe &lt;code&gt;GridBagLayout&lt;/code&gt; would satisfy your needs. Besides that, there's a ton of layout managers on the web, and I bet there's one that fits your requirements.</source>
          <target state="translated">Возможно, &lt;code&gt;GridBagLayout&lt;/code&gt; удовлетворит ваши потребности. Кроме того, в сети есть куча менеджеров компоновки, и я уверен, что есть тот, который соответствует вашим требованиям.</target>
        </trans-unit>
        <trans-unit id="5ec1d5cb339ea8bf28dabdc16b8ff8f4073ed0c4" translate="yes" xml:space="preserve">
          <source>Most importantly no matter how you specify your component's size, be sure that your component's container uses a layout manager that respects the requested size of the component.</source>
          <target state="translated">Самое главное,независимо от того,как вы указываете размер компонента,убедитесь,что в контейнере вашего компонента используется менеджер верстки,который уважает запрашиваемый размер компонента.</target>
        </trans-unit>
        <trans-unit id="ec7904135c872d5504ba4625fa4861d3640b70e4" translate="yes" xml:space="preserve">
          <source>Never avoid! They're there to express the size constraints of your components to the layout manager. You can avoid using them if you're not using any layout manager and try to manage the visual layout on your own.</source>
          <target state="translated">Никогда не избегай! Они там,чтобы выразить ограничения по размеру ваших компонентов в менеджере компоновки.Вы можете избежать их использования,если не используете менеджер верстки и пытаетесь управлять визуальной версткой самостоятельно.</target>
        </trans-unit>
        <trans-unit id="019c97b9fc48d56cdc8c3608bba924a9b70932a7" translate="yes" xml:space="preserve">
          <source>No negative consequences. These are hints for the layout manager.</source>
          <target state="translated">Никаких негативных последствий.Это подсказки для менеджера по макету.</target>
        </trans-unit>
        <trans-unit id="5a8a6ea846414fc7b77ae01acccc90b507c47c69" translate="yes" xml:space="preserve">
          <source>No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.</source>
          <target state="translated">Нет,определенно нет.Обычный подход заключается в каскадировании различных базовых дилетантов,таких как горизонтальная и вертикальная компоновка.</target>
        </trans-unit>
        <trans-unit id="67179a80aecf9f836727c57083425efcac33c312" translate="yes" xml:space="preserve">
          <source>No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt;.</source>
          <target state="translated">Нет, нет никаких официальных доказательств того, что использование или переопределение этих методов запрещено. Фактически, Oracle говорит, что эти методы используются для предоставления подсказок по размеру: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afc37620d6506412fbf52d3ba616d7a8da186c6c" translate="yes" xml:space="preserve">
          <source>No, you definitely shall not develop layout managers, unless you need something very special.</source>
          <target state="translated">Нет,вы определенно не должны развивать менеджеров по макетированию,если только вам не нужно что-то очень особенное.</target>
        </trans-unit>
        <trans-unit id="307ab8cb83f9ac27e039e7296b2b08390750ad96" translate="yes" xml:space="preserve">
          <source>Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you're about to develop anything serious.</source>
          <target state="translated">Конечно,с реальной жизненной схемой это может стать сложным.Поэтому менеджерам по макетированию на основе сетки,таким как MigLayout,гораздо лучше,если вы собираетесь разработать что-то серьезное.</target>
        </trans-unit>
        <trans-unit id="0d7954ef62fba1a1c6c5f8eb49be84da9e19ef5e" translate="yes" xml:space="preserve">
          <source>Several times I've been criticized for having suggested the use of the following methods:</source>
          <target state="translated">Несколько раз меня критиковали за то,что я предложил использовать следующие методы:</target>
        </trans-unit>
        <trans-unit id="5159a31c0c57223db57d56c6afccc7b37ae7c0e4" translate="yes" xml:space="preserve">
          <source>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing</source>
          <target state="translated">Maximum</target>
        </trans-unit>
        <trans-unit id="24368ab382b57b4e51fbff30e82703ed71584963" translate="yes" xml:space="preserve">
          <source>Should I completely avoid the use of those methods?</source>
          <target state="translated">Должен ли я полностью отказаться от использования этих методов?</target>
        </trans-unit>
        <trans-unit id="0e8b46b6e2690834b4abf89137b167ccb21005aa" translate="yes" xml:space="preserve">
          <source>So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.</source>
          <target state="translated">Таким образом,во имя сохранения функциональности и привлекательного внешнего вида вашего GUI на всех платформах (помните,одним из основных преимуществ Java является его кросс-платформенность),вы должны полагаться на менеджеров макетов и т.д.,чтобы автоматически подогнать размеры ваших компонентов так,чтобы они корректно отображались вне вашей конкретной среды разработки.</target>
        </trans-unit>
        <trans-unit id="1bd3d705c344338a8aad1a106bac39a04e05b944" translate="yes" xml:space="preserve">
          <source>Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Rules (hehe)&lt;/a&gt; or in the &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;link&lt;/a&gt; @bendicott found in his/her comment to &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;my answer&lt;/a&gt;. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.</source>
          <target state="translated">Некоторые (неполные, и, к сожалению, ссылки не работают из-за миграции SwingLabs на java.net), технические причины, например, упомянуты в &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Правилах (хе-хе)&lt;/a&gt; или в &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;ссылке&lt;/a&gt; @bendicott, найденной в его / ее комментарии к &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;моему ответу&lt;/a&gt; . В социальном плане выкладываете кучу работы на вашего несчастного товарища, который должен поддерживать код и выискивать сломанный макет.</target>
        </trans-unit>
        <trans-unit id="40f1d31b7c8dd444f50d98428b8cd8ccfaeafd52" translate="yes" xml:space="preserve">
          <source>The methods have been defined for a reason. So when should I use them?
  In which context? For what purposes?</source>
          <target state="translated">Методы были определены не просто так.Так когда я должен их использовать? В каком контексте? Для каких целей?</target>
        </trans-unit>
        <trans-unit id="540c4f65db18e1030a34da86ee391410c184bf1f" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I want to add a little more about the reasons &lt;em&gt;why&lt;/em&gt; you should normally avoid these (the question just came up again in a duplicate topic):</source>
          <target state="translated">Здесь есть много хороших ответов, но я хочу добавить немного больше о причинах, по &lt;em&gt;которым&lt;/em&gt; вам следует избегать их (вопрос только что снова возник в дублирующей теме):</target>
        </trans-unit>
        <trans-unit id="4f1c2750bb9a0c4dd1e3fb79014aa8f3f4f20030" translate="yes" xml:space="preserve">
          <source>These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:</source>
          <target state="translated">Эти методы плохо изучены большинством людей.Вы абсолютно не должны игнорировать эти методы.Это зависит от менеджера по макетированию,если они уважают эти методы.На этой странице есть таблица,показывающая,какие из этих методов соблюдаются менеджерами по макетированию:</target>
        </trans-unit>
        <trans-unit id="0a51f32acf1907b534bde7944ee38f8386d99137" translate="yes" xml:space="preserve">
          <source>They may also be overridden (which is the best practice for Swing) when &lt;em&gt;extending&lt;/em&gt; a Swing component (rather than calling the method on the custom component instance)</source>
          <target state="translated">Они также могут быть переопределены (что является наилучшей практикой для Swing) при &lt;em&gt;расширении&lt;/em&gt; компонента Swing (вместо вызова метода в экземпляре пользовательского компонента)</target>
        </trans-unit>
        <trans-unit id="c1e85d170b014983936e8e2c4c7e900a35ffafa9" translate="yes" xml:space="preserve">
          <source>This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.</source>
          <target state="translated">Этот очень популярный менеджер верстки очень гибкий,позволяющий разрабатывать очень полированные интерфейсы Java.</target>
        </trans-unit>
        <trans-unit id="1ec55556bdbbcf021c597b1ba85f53eae29d5d67" translate="yes" xml:space="preserve">
          <source>Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.</source>
          <target state="translated">К сожалению,Swing не идет с разумными размерами по умолчанию.Однако,вместо того,чтобы задавать размеры компонента,лучше ООП спустить свой компонент с разумными значениями по умолчанию.(В этом случае вы вызываете setXXX в своем классе-потомке.)В качестве альтернативы,вы можете переопределить методы getXXX для того же эффекта.</target>
        </trans-unit>
        <trans-unit id="a0518f85937eecd914f0c447bc9b66e9a1efed65" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I
  can only think to add portability between systems with different
  screen resolution).</source>
          <target state="translated">Каковы именно негативные последствия использования этих методов? (Могу только подумать о том,чтобы добавить переносимость между системами с разным разрешением экрана).</target>
        </trans-unit>
        <trans-unit id="03be6972f5a871fb5126119ff2853a38a28c8c7e" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">Каковы именно негативные последствия использования этих методов? (Могу только подумать о добавлении переносимости между системами с разным разрешением экрана).</target>
        </trans-unit>
        <trans-unit id="7db7f6858afa5c9fac8e8b9fdc4da5e60b2f58b1" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)</source>
          <target state="translated">Каковы именно негативные последствия использования этих методов? (Могу только подумать о добавлении переносимости между системами с разным разрешением экрана).</target>
        </trans-unit>
        <trans-unit id="b4a11b0ef058755c0527df7e68585b1ac10c6518" translate="yes" xml:space="preserve">
          <source>When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well</source>
          <target state="translated">Когда вам нужно предоставить настраиваемые под размер подсказки для менеджера планировки контейнеров,чтобы компонент был хорошо разложен</target>
        </trans-unit>
        <trans-unit id="2744a93affacde93c2fe41cf485c4eb89f3e85ea" translate="yes" xml:space="preserve">
          <source>With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren't inherently evil, but the typical reasons for using them &lt;em&gt;are&lt;/em&gt;. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.</source>
          <target state="translated">За некоторыми исключениями, если вы используете эти методы, вы, вероятно, настраиваете свой графический интерфейс, чтобы он хорошо выглядел под определенный внешний вид (и с вашими системными настройками, например, предпочитаемым шрифтом рабочего стола и т. Д.). Сами методы не являются изначально злыми, но типичные причины их использования. Как только вы начинаете настраивать положения и размеры пикселей в макете, вы рискуете сломать графический интерфейс (или, как минимум, выглядеть плохо) на других платформах.</target>
        </trans-unit>
        <trans-unit id="181abc8f1431b3fc4b24b7ff7084f5997bf9d984" translate="yes" xml:space="preserve">
          <source>With layouts the answer is always the same: use a suitable
  LayoutManager</source>
          <target state="translated">При использовании макетов ответ всегда один и тот же:используйте подходящий LayoutManager</target>
        </trans-unit>
        <trans-unit id="a18978692bb37ab6256c8c6714eeb798c4d51295" translate="yes" xml:space="preserve">
          <source>Yes for application code.</source>
          <target state="translated">Да для кода приложения.</target>
        </trans-unit>
        <trans-unit id="dac954ba2e6beb0d6c4bd134e2e18d3a82cfd388" translate="yes" xml:space="preserve">
          <source>Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to &quot;all layout needs&quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.</source>
          <target state="translated">Да,есть LayoutManagers,достаточно мощные,чтобы удовлетворить очень хорошее приближение к &quot;всем потребностям макета&quot;.Большая тройка-JGoodies FormLayout,MigLayout,DesignGridLayout.Так что нет,на практике вы редко пишете LayoutManagers,за исключением простых узкоспециализированных сред.</target>
        </trans-unit>
        <trans-unit id="444042202368def5f8181a05aefd275a8d54be0c" translate="yes" xml:space="preserve">
          <source>You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.</source>
          <target state="translated">Вы можете использовать JSplitPane,где можно задать соотношение двух сторон.Или вы можете использовать MigLayout,который позволяет вам устанавливать такие ограничения в процентах,пикселях и других единицах.</target>
        </trans-unit>
        <trans-unit id="f35a75cc4334792c6bc0ab1cd5a82739998fcbef" translate="yes" xml:space="preserve">
          <source>You'll find Karsten's documentation in &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;here&lt;/a&gt;, and some rather good documentation from eclipse &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы найдете документацию Карстена &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;здесь&lt;/a&gt; , и некоторые довольно хорошие документы от затмения &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2893740bacbf2ae887be29e7602f37f93e33c2d4" translate="yes" xml:space="preserve">
          <source>between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">между детьми Компонента (например,ребенок1 должен использовать 10% пространства,ребенок2 40%,ребенок3 50%),возможно ли достичь этого без реализации пользовательского LayoutManager?</target>
        </trans-unit>
        <trans-unit id="0886212cd9ad81c73e17959b2f0c7b17e6248ebc" translate="yes" xml:space="preserve">
          <source>is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.</source>
          <target state="translated">состоит из двух частей.Левая и правая части расположены горизонтально.Правая часть-это JPanel,добавленная к горизонтальной раскладке,и эта JPanel имеет вертикальную раскладку,которая раскладывает кнопки по вертикали.</target>
        </trans-unit>
        <trans-unit id="d00a4682b9e06987369438cd97d3639a65d0178c" translate="yes" xml:space="preserve">
          <source>on &lt;code&gt;Swing&lt;/code&gt; components. I don't see any alternative to their use when I want to define proportions between displayed components. I have been told this:</source>
          <target state="translated">на &lt;code&gt;Swing&lt;/code&gt; Я не вижу альтернативы их использованию, когда я хочу определить пропорции между отображаемыми компонентами. Мне сказали это:</target>
        </trans-unit>
        <trans-unit id="d8e8fbecb943993f987bc322df6b509bc6daa8b4" translate="yes" xml:space="preserve">
          <source>sometimes problems can be encountered with &lt;code&gt;GridBagLayout&lt;/code&gt; and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.</source>
          <target state="translated">Иногда могут возникнуть проблемы с &lt;code&gt;GridBagLayout&lt;/code&gt; и текстовыми полями, в которых, если размер контейнера меньше предпочтительного размера, используется минимальный размер, что может привести к значительному сокращению текстовых полей.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
