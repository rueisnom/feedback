<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/7229226">
    <body>
      <group id="7229226">
        <trans-unit id="101513b86d72ed6fcdb26b5d3b3a91761a1a7eeb" translate="yes" xml:space="preserve">
          <source>(I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">(Sólo puedo pensar en añadir portabilidad entre sistemas con diferente resolución de pantalla).</target>
        </trans-unit>
        <trans-unit id="f322b9e0be596ee0c12c766b6f6362bac3fda875" translate="yes" xml:space="preserve">
          <source>(The answer to 4 is &quot;no&quot;.)</source>
          <target state="translated">(La respuesta a la 4 es &quot;no&quot;.)</target>
        </trans-unit>
        <trans-unit id="a62f3745308389d8190dd4aa927eccdaa9df3d4a" translate="yes" xml:space="preserve">
          <source>1) Should I completely avoid the use of those methods?</source>
          <target state="translated">1)¿Debo evitar completamente el uso de esos métodos?</target>
        </trans-unit>
        <trans-unit id="9be06212edf76a1a8f22e4f87f620e98f3917e4f" translate="yes" xml:space="preserve">
          <source>2) The methods have been defined for a reason. So when should I use them? In which context? For what purposes?</source>
          <target state="translated">2)Los métodos se han definido por una razón.Entonces,¿cuándo debo usarlos? ¿En qué contexto? ¿Con qué propósito?</target>
        </trans-unit>
        <trans-unit id="3129078a99b0f0599191614194a02dd301b6ef4c" translate="yes" xml:space="preserve">
          <source>3) What exactly are the negative consequences of using those methods?</source>
          <target state="translated">3)¿Cuáles son exactamente las consecuencias negativas de la utilización de esos métodos?</target>
        </trans-unit>
        <trans-unit id="e4537f34f955a436cd38a10e8ea7eee57157f6f1" translate="yes" xml:space="preserve">
          <source>4) I don't think any LayoutManager can exactly satisfy all desired layout needs.</source>
          <target state="translated">4)No creo que ningún LayoutManager pueda satisfacer exactamente todas las necesidades de diseño deseadas.</target>
        </trans-unit>
        <trans-unit id="a50e32a4d28ac833b32f3d7ebf4edda651c47cb3" translate="yes" xml:space="preserve">
          <source>5) If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">5)Si la respuesta a la pregunta 4 es &quot;sí&quot;,¿no llevará esto a una proliferación de clases de LayoutManager que será difícil de mantener?</target>
        </trans-unit>
        <trans-unit id="9e4a5573061af9e7df2555b66d39ace412023fef" translate="yes" xml:space="preserve">
          <source>6) In a situation where I need to define proportions...</source>
          <target state="translated">6)En una situación en la que necesito definir las proporciones...</target>
        </trans-unit>
        <trans-unit id="caae42b05fc60c9860a79b7d9ccb2ea61214c824" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JFrame&lt;/code&gt; does not enforce overriden &lt;code&gt;getMinimumSize()&lt;/code&gt; only calling &lt;code&gt;setMinimumSize(..)&lt;/code&gt; on its works</source>
          <target state="translated">&lt;code&gt;JFrame&lt;/code&gt; no impone &lt;code&gt;getMinimumSize()&lt;/code&gt; &lt;code&gt;setMinimumSize(..)&lt;/code&gt; solo llamando a setMinimumSize (..) en sus trabajos</target>
        </trans-unit>
        <trans-unit id="b3647248e0173f71dd2355fcf20828a2dedaf8e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?&lt;/strong&gt; You shouldn't &quot;implement&quot; a new LayoutManager. You should instantiate existing ones. I often use several layout managers in a single window. Each JPanel will have its own layout manager. Some people balk at nested layouts, because they're hard to maintain. When I use them, I give each one its own creation method to make it easier to see what each one does. But I never &quot;implement&quot; a layout manager. I just instantiate them.</source>
          <target state="translated">&lt;strong&gt;No creo que ning&amp;uacute;n LayoutManager pueda satisfacer exactamente todas las necesidades de dise&amp;ntilde;o deseadas.&lt;/strong&gt; &lt;strong&gt;&amp;iquest;Realmente necesito implementar un nuevo LayoutManager para cada peque&amp;ntilde;a variaci&amp;oacute;n en mi dise&amp;ntilde;o?&lt;/strong&gt; No debe &quot;implementar&quot; un nuevo LayoutManager. Debe crear instancias de las existentes. A menudo uso varios administradores de dise&amp;ntilde;o en una sola ventana. Cada JPanel tendr&amp;aacute; su propio administrador de dise&amp;ntilde;o. Algunas personas se resisten a los dise&amp;ntilde;os anidados, porque son dif&amp;iacute;ciles de mantener. Cuando los uso, le doy a cada uno su propio m&amp;eacute;todo de creaci&amp;oacute;n para que sea m&amp;aacute;s f&amp;aacute;cil ver lo que hace cada uno. Pero nunca &quot;implemento&quot; un administrador de dise&amp;ntilde;o. Yo solo los instancia.</target>
        </trans-unit>
        <trans-unit id="edce1b4cb1e94b90bfc85934288d525da7af49fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?&lt;/strong&gt;
If you're implementing new layout manager classes for slight variations in layout, you're using them wrong. If you're just implementing new layout managers, you're probably doing something wrong. The only time I've extended a LayoutManager class, it was to add a zoom slider to a JScrollPane.</source>
          <target state="translated">&lt;strong&gt;Si la respuesta a 4 es &quot;s&amp;iacute;&quot;, &amp;iquest;esto no conducir&amp;aacute; a una proliferaci&amp;oacute;n de clases LayoutManager que ser&amp;aacute; dif&amp;iacute;cil de mantener?&lt;/strong&gt; Si est&amp;aacute; implementando nuevas clases de administrador de dise&amp;ntilde;o para ligeras variaciones en el dise&amp;ntilde;o, las est&amp;aacute; usando mal. Si solo est&amp;aacute; implementando nuevos administradores de dise&amp;ntilde;o, probablemente est&amp;eacute; haciendo algo mal. La &amp;uacute;nica vez que extend&amp;iacute; una clase LayoutManager fue para agregar un control deslizante de zoom a un JScrollPane.</target>
        </trans-unit>
        <trans-unit id="bac7ad7f05d5d55847b7fd4cc2f7ed1978917af5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?&lt;/strong&gt;
The JSplitPane has a way of specifying the percentage each component should get. The divider is movable by default, but you can turn that off if you want. I don't use that feature much. I usually have some components that take up a set size, and the rest of the space is taken up by a scroll pane. The scroll pane size will adjust with the window size. If you have two scroll panes side by side, you can put them in a JSplitPane and specify the percentage of new space given to each one as the user expands and contracts the windows.</source>
          <target state="translated">&lt;strong&gt;En una situaci&amp;oacute;n en la que necesito definir proporciones entre los hijos de un Componente (p. Ej., Child1 deber&amp;iacute;a usar el 10% del espacio, child2 40%, child3 50%), &amp;iquest;es posible lograrlo sin implementar un LayoutManager personalizado?&lt;/strong&gt; JSplitPane tiene una forma de especificar el porcentaje que debe obtener cada componente. El divisor se puede mover de forma predeterminada, pero puede desactivarlo si lo desea. No uso mucho esa funci&amp;oacute;n. Por lo general, tengo algunos componentes que ocupan un tama&amp;ntilde;o establecido, y el resto del espacio lo ocupa un panel de desplazamiento. El tama&amp;ntilde;o del panel de desplazamiento se ajustar&amp;aacute; con el tama&amp;ntilde;o de la ventana. Si tiene dos paneles de desplazamiento uno al lado del otro, puede colocarlos en un JSplitPane y especificar el porcentaje de espacio nuevo asignado a cada uno a medida que el usuario expande y contrae las ventanas.</target>
        </trans-unit>
        <trans-unit id="2ef0079b6c8a172dd2c245d6fc600772f49ecf38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reference:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="253649f0361fd376d76e98ac2e931514bc001bdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Should I completely avoid the use of those methods?&lt;/strong&gt;
I wouldn't say &quot;avoid&quot; them. I'd say that if you think you need them, you're probably doing something wrong. Component sizes are determined in context. For example, Text component sizes are determined by the number of rows and columns you specify, combined with the font you may have chosen. Your button and label size will be the size of the graphic, if you set one, or the space needed to display the text you set. Each component has a natural size, and the layout managers will use those to lay everything out without you needing to specify sizes. The main exception is the JScrollPane, which has a size independent of whatever it contains. For those, I will sometimes call &lt;code&gt;setSize()&lt;/code&gt;, and let that size determine the initial window size, by calling &lt;code&gt;JFrame.pack()&lt;/code&gt;. Usually, I will let the window size determine the JScrollPane size. The user will determine the size of the window. Many layout managers ignore the sizes you set anyway, so they often don't do much good.</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Debo evitar por completo el uso de esos m&amp;eacute;todos?&lt;/strong&gt; Yo no dir&amp;iacute;a &quot;evitarlos&quot;. Dir&amp;iacute;a que si crees que los necesitas, probablemente est&amp;eacute;s haciendo algo mal. Los tama&amp;ntilde;os de los componentes se determinan en contexto. Por ejemplo, los tama&amp;ntilde;os de los componentes de texto est&amp;aacute;n determinados por la cantidad de filas y columnas que especifique, combinadas con la fuente que haya elegido. El tama&amp;ntilde;o de su bot&amp;oacute;n y etiqueta ser&amp;aacute; el tama&amp;ntilde;o del gr&amp;aacute;fico, si configura uno, o el espacio necesario para mostrar el texto que configur&amp;oacute;. Cada componente tiene un tama&amp;ntilde;o natural, y los administradores de dise&amp;ntilde;o los usar&amp;aacute;n para dise&amp;ntilde;ar todo sin necesidad de especificar tama&amp;ntilde;os. La excepci&amp;oacute;n principal es JScrollPane, que tiene un tama&amp;ntilde;o independiente de lo que contenga. Para ellos, a veces llamar&amp;eacute; a &lt;code&gt;setSize()&lt;/code&gt; , y dejar&amp;eacute; que ese tama&amp;ntilde;o determine el tama&amp;ntilde;o inicial de la ventana, llamando a &lt;code&gt;JFrame.pack()&lt;/code&gt; . Por lo general, dejar&amp;eacute; que el tama&amp;ntilde;o de la ventana determine el tama&amp;ntilde;o de JScrollPane. El usuario determinar&amp;aacute; el tama&amp;ntilde;o de la ventana. Muchos administradores de dise&amp;ntilde;o ignoran los tama&amp;ntilde;os que configura de todos modos, por lo que a menudo no hacen mucho bien.</target>
        </trans-unit>
        <trans-unit id="bb29b79b090f0d71d579ecfac48293fc02a91481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The methods have been defined for a reason. So when should I use them? In which context? For what purposes?&lt;/strong&gt;
I believe they were added to provide hints to the layout managers. They may have been written for historical reasons, because layout managers were new, and people didn't fully trust them. I know a few developers who avoided layout managers and placed everything manually, just because they didn't want to bother with learning a new paradigm. It's a terrible idea.</source>
          <target state="translated">&lt;strong&gt;Los m&amp;eacute;todos han sido definidos por una raz&amp;oacute;n.&lt;/strong&gt; &lt;strong&gt;Entonces, &amp;iquest;cu&amp;aacute;ndo debo usarlos?&lt;/strong&gt; &lt;strong&gt;&amp;iquest;En que contexto?&lt;/strong&gt; &lt;strong&gt;&amp;iquest;Para que fines?&lt;/strong&gt; Creo que se agregaron para proporcionar pistas a los gerentes de dise&amp;ntilde;o. Es posible que se hayan escrito por razones hist&amp;oacute;ricas, porque los administradores de dise&amp;ntilde;o eran nuevos y la gente no confiaba plenamente en ellos. Conozco algunos desarrolladores que evitaron los administradores de dise&amp;ntilde;o y colocaron todo manualmente, solo porque no quer&amp;iacute;an molestarse en aprender un nuevo paradigma. Es una idea terrible.</target>
        </trans-unit>
        <trans-unit id="f2a560db0d72f5a999aad79685126287e9f8c227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).&lt;/strong&gt;
They're ineffective, and they produce bad layouts, with objects getting squeezed or stretched to non-natural sizes. And the layouts will be brittle. Changes to the window size will sometimes break the layout and put things in the wrong places.</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;les son exactamente las consecuencias negativas de usar esos m&amp;eacute;todos?&lt;/strong&gt; &lt;strong&gt;(Solo puedo pensar en agregar portabilidad entre sistemas con diferente resoluci&amp;oacute;n de pantalla).&lt;/strong&gt; Son ineficaces y producen dise&amp;ntilde;os malos, con objetos que se exprimen o estiran a tama&amp;ntilde;os no naturales. Y los dise&amp;ntilde;os ser&amp;aacute;n fr&amp;aacute;giles. Los cambios en el tama&amp;ntilde;o de la ventana a veces romper&amp;aacute;n el dise&amp;ntilde;o y colocar&amp;aacute;n las cosas en lugares incorrectos.</target>
        </trans-unit>
        <trans-unit id="75fd8314886af2005f7a571fef2f798a7e7172e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMaximumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMaximumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b11ddbbe6a3af1821698ada76274100c165c48cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setMinimumSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setMinimumSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89f81cef98f01aaa7c3a87a7392da5c9df43268c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;setPreferredSize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;setPreferredSize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8f222d9ad21513e10bd84b95b5bf37337e1762a" translate="yes" xml:space="preserve">
          <source>A few heuristics:</source>
          <target state="translated">Unas cuantas heurísticas:</target>
        </trans-unit>
        <trans-unit id="5ed3ba4403e948d10f0d964a8030523919a40837" translate="yes" xml:space="preserve">
          <source>All that said, you can certainly conceive of situations where these methods are justified. Again, they aren't inherently evil, but their usage is normally a &lt;strong&gt;big&lt;/strong&gt; red flag indicating potential GUI issues. Just make sure you are aware of the high potential for complications if/when you use them, and always try and think if there is another look-and-feel-independent solution to your problems -- more often than not you will find that these methods are not necessary.</source>
          <target state="translated">Dicho todo esto, ciertamente puede concebir situaciones en las que estos m&amp;eacute;todos est&amp;eacute;n justificados. Una vez m&amp;aacute;s, no son intr&amp;iacute;nsecamente malvados, pero su uso es normalmente una &lt;strong&gt;gran&lt;/strong&gt; se&amp;ntilde;al de alerta que indica posibles problemas de GUI. Solo aseg&amp;uacute;rese de estar al tanto del alto potencial de complicaciones si / cuando las usa, y siempre trate de pensar si hay otra soluci&amp;oacute;n independiente de la apariencia y la sensaci&amp;oacute;n para sus problemas; la mayor&amp;iacute;a de las veces encontrar&amp;aacute; que estos Los m&amp;eacute;todos no son necesarios.</target>
        </trans-unit>
        <trans-unit id="334e464b55e6cbe9ef940d5fd89ee52a5a006400" translate="yes" xml:space="preserve">
          <source>Always. When you create a component, set its realistic min/preferred/max size according to the use of that component. For example, if you have a JTextField for entering country symbols such as UK, its preferred size shall be as wide to fit two chars (with the current font, etc.) but probably it is meaningless to let it grow any bigger. After all, country symbols are two chars. 
As opposite, if you have a JTextField for entering e.g. a customer name, it can have a preferred size for like the pixel size for 20 chars, but can grow to bigger if the layout is resized, so set the maximum size to more. At the same time, having a 0px wide JTextField is pointless, so set a realistic minimum size (I would say the pixel size of 2 chars).</source>
          <target state="translated">Siempre.Cuando cree un componente,fije su tamaño realista minpreferredmax de acuerdo con el uso de ese componente.Por ejemplo,si tienes un campo de texto JTextField para introducir símbolos de países como el Reino Unido,su tamaño preferido será tan amplio como para que quepan dos caracteres (con la fuente actual,etc.)pero probablemente no tenga sentido dejarlo crecer más.Después de todo,los símbolos de país son de dos caracteres.Por el contrario,si se tiene un campo de texto para introducir,por ejemplo,un nombre de cliente,puede tener un tamaño preferido como el tamaño del píxel para 20 caracteres,pero puede crecer a mayor tamaño si se cambia el tamaño de la disposición,por lo que se debe establecer el tamaño máximo a mayor.Al mismo tiempo,tener un Campo de Texto de 0px de ancho no tiene sentido,por lo que hay que establecer un tamaño mínimo realista (yo diría que el tamaño de píxel de 2 caracteres).</target>
        </trans-unit>
        <trans-unit id="82a3275f2c6e319fc8e6e971d584332b7226964d" translate="yes" xml:space="preserve">
          <source>Any of the Big-Three can, can't even GridBag (never bothered to really master, too much trouble for too little power).</source>
          <target state="translated">Cualquiera de los Tres Grandes puede,no puede ni siquiera GridBag (nunca se molestó en dominar realmente,demasiados problemas para muy poco poder).</target>
        </trans-unit>
        <trans-unit id="feada63cf7671891364a8ad7e4d18aec070ec6ec" translate="yes" xml:space="preserve">
          <source>As an example of this, try changing your application's default look-and-feel. Even just with the options available on your platform, you may be surprised at how poorly the results can be rendered.</source>
          <target state="translated">Como ejemplo de esto,intenta cambiar el aspecto predeterminado de tu aplicación.Incluso con las opciones disponibles en su plataforma,puede sorprenderse de lo mal que se pueden obtener los resultados.</target>
        </trans-unit>
        <trans-unit id="e2f886c1766f46b82d763352fa65f26f99701edd" translate="yes" xml:space="preserve">
          <source>Basically, once the preferred sizes are set right, you may not want to do anything in percentage. Simply, because percentages are pointless (e.g. it is pointless to have a JTextField 10% of the window size - since one can shrink the window so that JTextField becomes 0px wide, or can expand the window so that the JTextField is across two displays on a multi-display setup).</source>
          <target state="translated">Básicamente,una vez que los tamaños preferidos se establecen correctamente,es posible que no quieras hacer nada en porcentaje.Simplemente,porque los porcentajes no tienen sentido (por ejemplo,no tiene sentido tener un JTextField del 10% del tamaño de la ventana-ya que se puede reducir la ventana para que JTextField tenga 0px de ancho,o se puede expandir la ventana para que el JTextField esté a través de dos pantallas en una configuración de múltiples pantallas).</target>
        </trans-unit>
        <trans-unit id="44d763212c6c3a8fea4302c81748f40a5af6a256" translate="yes" xml:space="preserve">
          <source>But, may times you may use the percentages to control sizes of bigger building blocks of your gui (panels, for example).</source>
          <target state="translated">Pero,muchas veces puedes usar los porcentajes para controlar el tamaño de los bloques de construcción más grandes de tu guía (paneles,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="78233fddc435250272d7f9a010e1be36ab861764" translate="yes" xml:space="preserve">
          <source>By the way, if you find yourself getting frustrated with standard layout managers, there are a lot of good free, open-source third-party ones, for example &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies' &lt;code&gt;FormLayout&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;http://www.miglayout.com/&quot;&gt;&lt;code&gt;MigLayout&lt;/code&gt;&lt;/a&gt;. Some GUI builders even have built-in support for third-party layout managers -- Eclipse's WindowBuilder GUI editor, for example, ships with support for &lt;code&gt;FormLayout&lt;/code&gt; and &lt;code&gt;MigLayout&lt;/code&gt;.</source>
          <target state="translated">Por cierto, si te sientes frustrado con los administradores de dise&amp;ntilde;o est&amp;aacute;ndar, hay muchos otros buenos y gratuitos de c&amp;oacute;digo abierto de terceros, por ejemplo &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;JGoodies ' &lt;code&gt;FormLayout&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;http://www.miglayout.com/&quot;&gt; &lt;code&gt;MigLayout&lt;/code&gt; &lt;/a&gt; . Algunos constructores de GUI incluso tienen soporte incorporado para administradores de dise&amp;ntilde;o de terceros: el editor de GUI WindowBuilder de Eclipse, por ejemplo, se entrega con soporte para &lt;code&gt;FormLayout&lt;/code&gt; y &lt;code&gt;MigLayout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28464854017f94b9c9844769ee6144deaf548b29" translate="yes" xml:space="preserve">
          <source>Consider alternate or custom layouts when you find that you would have to loop through many components to obtain derived sizes, as mentioned in these &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;comments&lt;/a&gt;.</source>
          <target state="translated">Considere dise&amp;ntilde;os alternativos o personalizados cuando descubra que tendr&amp;iacute;a que recorrer muchos componentes para obtener tama&amp;ntilde;os derivados, como se menciona en estos &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;comentarios&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be6bbc414031de61f515ad578e905cd0b742227e" translate="yes" xml:space="preserve">
          <source>Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">¿Realmente necesito implementar un nuevo Administrador de Diseño para cada pequeña variación en mi diseño?</target>
        </trans-unit>
        <trans-unit id="7cf1d64fab0d093b37c52e515ee1f02d1c34c796" translate="yes" xml:space="preserve">
          <source>Do use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; to derive post-&lt;code&gt;validate()&lt;/code&gt; geometry, as shown below and &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Utilice &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; para obtener la geometr&amp;iacute;a post- &lt;code&gt;validate()&lt;/code&gt; , como se muestra a continuaci&amp;oacute;n y &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="157eda23f1458fbcc63f756b719fa42aa4d3266a" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you could rely on a component's carefully overridden &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt;, as shown &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;here&lt;/a&gt; and below.</source>
          <target state="translated">No utilice el &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; cuando pueda confiar en el &lt;code&gt;getPreferred|Maximum|Minimum]Size&lt;/code&gt; un componente cuidadosamente anulado, como se muestra &lt;a href=&quot;https://stackoverflow.com/questions/3174765/variable-layout-in-swing/3175280#3175280&quot;&gt;aqu&amp;iacute;&lt;/a&gt; y a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4546245bd9fc2988f588e0ddf7f4de2e035d8826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; when you really mean to override &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt;, as might be done in creating your own component, shown &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">No utilice el &lt;code&gt;set[Preferred|Maximum|Minimum]Size()&lt;/code&gt; cuando realmente quiera anular &lt;code&gt;get[Preferred|Maximum|Minimum]Size()&lt;/code&gt; , como podr&amp;iacute;a hacerse al crear su propio componente, como se muestra &lt;a href=&quot;https://stackoverflow.com/a/10110232/230513&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8858a12745633838c34a2266f3595b758ee64852" translate="yes" xml:space="preserve">
          <source>For example, the layout below:</source>
          <target state="translated">Por ejemplo,el diseño de abajo:</target>
        </trans-unit>
        <trans-unit id="0b5b0c3f88d9871a3e20dffd7b5aea8ad3241262" translate="yes" xml:space="preserve">
          <source>I am seeing it differenty than the accepted answer.</source>
          <target state="translated">Lo veo diferente a la respuesta aceptada.</target>
        </trans-unit>
        <trans-unit id="c0e9dfc40abc06677021939bbd23ed04299fd51d" translate="yes" xml:space="preserve">
          <source>I don't know, personally I think of it as an API design accident. Slightly forced by compound components having special ideas about child sizes. &quot;Slightly&quot;, because they should have implemented their needs with a custom LayoutManager.</source>
          <target state="translated">No lo sé,personalmente pienso en ello como un accidente de diseño de la API.Ligeramente forzado por componentes compuestos que tienen ideas especiales sobre el tamaño de los niños.&quot;Ligeramente&quot;,porque deberían haber implementado sus necesidades con un LayoutManager personalizado.</target>
        </trans-unit>
        <trans-unit id="05debf8858189b34f73fdc5385802a59b437dec7" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout
  needs. Do I really need to implement a new LayoutManager for every
  little variation on my layout?</source>
          <target state="translated">No creo que ningún administrador de diseño pueda satisfacer exactamente todas las necesidades de diseño deseadas.¿Realmente necesito implementar un nuevo Administrador de Planos para cada pequeña variación en mi diseño?</target>
        </trans-unit>
        <trans-unit id="e293825a482ffdbc279a19695ddf553407dbbc00" translate="yes" xml:space="preserve">
          <source>I don't think any LayoutManager can exactly satisfy all desired layout needs. Do I really need to implement a new LayoutManager for every little variation on my layout ?</source>
          <target state="translated">No creo que ningún administrador de diseño pueda satisfacer exactamente todas las necesidades de diseño deseadas.¿Realmente necesito implementar un nuevo Administrador de Planos para cada pequeña variación en mi diseño?</target>
        </trans-unit>
        <trans-unit id="f03332e8b0533248fe9e9bec74b216b33f9c8672" translate="yes" xml:space="preserve">
          <source>I have been writing Swing code for 8+ years and the layout managers included in the JDK have always served my needs. I have never needed a 3rd party layout manager to achieve my layouts.</source>
          <target state="translated">He estado escribiendo el código Swing por más de 8 años y los gerentes de diseño incluidos en el JDK siempre han servido a mis necesidades.Nunca he necesitado un tercero para lograr mis diseños.</target>
        </trans-unit>
        <trans-unit id="45e24a1aab4e46086de24e1bd00ae96195747270" translate="yes" xml:space="preserve">
          <source>I have searched the web a little bit, but I haven't found any comprehensive analysis of the subject. So I have the following questions:</source>
          <target state="translated">He buscado un poco en la web,pero no he encontrado ningún análisis exhaustivo del tema.Así que tengo las siguientes preguntas:</target>
        </trans-unit>
        <trans-unit id="d19e84a41484b2716bcc34a770e49e845d1ffe27" translate="yes" xml:space="preserve">
          <source>I will say that you shouldn't try to give the layout manager hints with these methods until you are sure you need them. Do your layout without giving any sizing hints (i.e. let the layout manager do its job) and then you can make minor corrections if you need to.</source>
          <target state="translated">Le diré que no debería intentar darle al jefe de diseño pistas con estos métodos hasta que esté seguro de que los necesita.Haga su diseño sin dar ninguna pista de tamaño (es decir,deje que el jefe de diseño haga su trabajo)y luego puede hacer pequeñas correcciones si es necesario.</target>
        </trans-unit>
        <trans-unit id="4952d1d9c2545ce08ec8f0dfb48594021c83f640" translate="yes" xml:space="preserve">
          <source>If a component has no preferred size, e.g. &lt;code&gt;JDesktopPane&lt;/code&gt;, you may have to size the container, but any such choice is arbitrary. A comment may help clarify the intent.</source>
          <target state="translated">Si un componente no tiene un tama&amp;ntilde;o preferido, por ejemplo, &lt;code&gt;JDesktopPane&lt;/code&gt; , puede que tenga que cambiar el tama&amp;ntilde;o del contenedor, pero cualquier elecci&amp;oacute;n es arbitraria. Un comentario puede ayudar a aclarar la intenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1c43bb7e290acdfdc7dbe1b01a2c5332529346f1" translate="yes" xml:space="preserve">
          <source>If by implementing you mean using then yes. Not one &lt;code&gt;LayoutManger&lt;/code&gt; can handle everything, each &lt;code&gt;LayoutManager&lt;/code&gt; has its pros and cons thus each can be used together to produce the final layout.</source>
          <target state="translated">Si por implementar te refieres a usar, entonces s&amp;iacute;. Ning&amp;uacute;n &lt;code&gt;LayoutManger&lt;/code&gt; puede manejar todo, cada &lt;code&gt;LayoutManager&lt;/code&gt; tiene sus pros y sus contras, por lo tanto, cada uno puede usarse en conjunto para producir el dise&amp;ntilde;o final.</target>
        </trans-unit>
        <trans-unit id="87d62286cfbf65303a6f848ee0864f361f380b7a" translate="yes" xml:space="preserve">
          <source>If the answer to 4 is &quot;yes&quot;, won't this lead to a proliferation of LayoutManager classes which will become difficult to maintain?</source>
          <target state="translated">Si la respuesta a la pregunta 4 es &quot;sí&quot;,¿no llevará esto a una proliferación de clases de LayoutManager que será difícil de mantener?</target>
        </trans-unit>
        <trans-unit id="b063186389f8146493b73685b897b69952730e47" translate="yes" xml:space="preserve">
          <source>If you are having trouble with layouts in Java Swing, then I can highly recommend the JGoodies &lt;code&gt;FormLayout&lt;/code&gt; provided freely as part of the Forms freeware library by Karsten Lentzsch &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Si tiene problemas con los dise&amp;ntilde;os en Java Swing, le recomiendo encarecidamente el JGoodies &lt;code&gt;FormLayout&lt;/code&gt; que Karsten Lentzsch proporciona gratuitamente como parte de la biblioteca gratuita de Formularios &lt;a href=&quot;http://www.jgoodies.com/freeware/libraries/forms/&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d96461400848ad4f167b8f2e7b96036043cb5c45" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (child 1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom layout manager?</source>
          <target state="translated">En una situación en la que necesito definir las proporciones entre los niños de un Componente (el niño 1 debe usar el 10% del espacio,el niño 2 el 40%,el niño 3 el 50%),¿es posible lograrlo sin implementar un administrador de diseño personalizado?</target>
        </trans-unit>
        <trans-unit id="5063acd66afacb43577cb43e4e3c3bef2c93feea" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">En una situación en la que necesito definir las proporciones entre los niños de un Componente (por ejemplo,el niño1 debe usar el 10% del espacio,el niño2 el 40%,el niño3 el 50%),¿es posible lograr eso sin implementar un Administrador de Diseño personalizado?</target>
        </trans-unit>
        <trans-unit id="031cb987d53c63d3108a20db2267a8bb488faae2" translate="yes" xml:space="preserve">
          <source>In a situation where I need to define proportions between children of a Component (for example, child 1 should use 10% of space, child 2 40%, child 3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">En una situación en la que necesito definir proporciones entre los niños de un Componente (por ejemplo,el niño 1 debe usar el 10% del espacio,el niño 2 el 40%,el niño 3 el 50%),¿es posible lograr eso sin implementar un Administrador de Diseño personalizado?</target>
        </trans-unit>
        <trans-unit id="8749b6c1a91e73f14a6ee417ecb38965be650eb9" translate="yes" xml:space="preserve">
          <source>Make sure that you really need to set the component's exact size. Each Swing component has a different preferred size, depending on the font it uses and the look and feel. Thus having a set size might produce varied &lt;em&gt;looks&lt;/em&gt; of the UI on different Systems</source>
          <target state="translated">Aseg&amp;uacute;rese de que realmente necesita establecer el tama&amp;ntilde;o exacto del componente. Cada componente Swing tiene un tama&amp;ntilde;o preferido diferente, dependiendo de la fuente que usa y el aspecto. Por lo tanto, tener un tama&amp;ntilde;o establecido puede producir una &lt;em&gt;apariencia&lt;/em&gt; variada de la interfaz de usuario en diferentes sistemas</target>
        </trans-unit>
        <trans-unit id="83665a294fe3f65e2b8c5d56e4046be52e81d907" translate="yes" xml:space="preserve">
          <source>Many layout managers do not pay attention to a component's requested maximum size. However, &lt;code&gt;BoxLayout&lt;/code&gt; and &lt;code&gt;SpringLayout&lt;/code&gt; do. Furthermore, &lt;code&gt;GroupLayout&lt;/code&gt; provides the ability to set the minimum, preferred or maximum size explicitly, without touching the component.</source>
          <target state="translated">Muchos administradores de dise&amp;ntilde;o no prestan atenci&amp;oacute;n al tama&amp;ntilde;o m&amp;aacute;ximo solicitado de un componente. Sin embargo, &lt;code&gt;BoxLayout&lt;/code&gt; y &lt;code&gt;SpringLayout&lt;/code&gt; lo hacen. Adem&amp;aacute;s, &lt;code&gt;GroupLayout&lt;/code&gt; proporciona la capacidad de establecer el tama&amp;ntilde;o m&amp;iacute;nimo, preferido o m&amp;aacute;ximo de forma expl&amp;iacute;cita, sin tocar el componente.</target>
        </trans-unit>
        <trans-unit id="ab89da0d68317915b0b083e37c7f4c657b21e4bb" translate="yes" xml:space="preserve">
          <source>Maybe &lt;code&gt;GridBagLayout&lt;/code&gt; would satisfy your needs. Besides that, there's a ton of layout managers on the web, and I bet there's one that fits your requirements.</source>
          <target state="translated">Quiz&amp;aacute;s &lt;code&gt;GridBagLayout&lt;/code&gt; satisfar&amp;iacute;a sus necesidades. Adem&amp;aacute;s de eso, hay un mont&amp;oacute;n de administradores de dise&amp;ntilde;o en la web, y apuesto a que hay uno que se ajusta a sus requisitos.</target>
        </trans-unit>
        <trans-unit id="5ec1d5cb339ea8bf28dabdc16b8ff8f4073ed0c4" translate="yes" xml:space="preserve">
          <source>Most importantly no matter how you specify your component's size, be sure that your component's container uses a layout manager that respects the requested size of the component.</source>
          <target state="translated">Lo más importante,independientemente de cómo especifique el tamaño de su componente,asegúrese de que el contenedor de su componente utilice un gestor de diseño que respete el tamaño solicitado del componente.</target>
        </trans-unit>
        <trans-unit id="ec7904135c872d5504ba4625fa4861d3640b70e4" translate="yes" xml:space="preserve">
          <source>Never avoid! They're there to express the size constraints of your components to the layout manager. You can avoid using them if you're not using any layout manager and try to manage the visual layout on your own.</source>
          <target state="translated">¡Nunca lo evites! Están ahí para expresar las limitaciones de tamaño de sus componentes al jefe de diseño.Puedes evitar usarlos si no usas ningún administrador de diseño e intentar manejar el diseño visual por tu cuenta.</target>
        </trans-unit>
        <trans-unit id="019c97b9fc48d56cdc8c3608bba924a9b70932a7" translate="yes" xml:space="preserve">
          <source>No negative consequences. These are hints for the layout manager.</source>
          <target state="translated">No hay consecuencias negativas.Estos son consejos para el encargado del diseño.</target>
        </trans-unit>
        <trans-unit id="5a8a6ea846414fc7b77ae01acccc90b507c47c69" translate="yes" xml:space="preserve">
          <source>No, definitely not. The usual approach is to cascade different basic layoutmanagers such as horizontal and vertical layout.</source>
          <target state="translated">No,definitivamente no.El enfoque habitual es hacer una cascada de diferentes trazados básicos como el horizontal y el vertical.</target>
        </trans-unit>
        <trans-unit id="67179a80aecf9f836727c57083425efcac33c312" translate="yes" xml:space="preserve">
          <source>No, there is no formal evidence to suggest calling or overriding these methods is not allowed. In fact, Oracle says these methods are used for giving size hints: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt;.</source>
          <target state="translated">No, no hay evidencia formal que sugiera que llamar o anular estos m&amp;eacute;todos no est&amp;eacute; permitido. De hecho, Oracle dice que estos m&amp;eacute;todos se utilizan para dar pistas sobre el tama&amp;ntilde;o: &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&quot;&gt;http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html#sizealignment&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afc37620d6506412fbf52d3ba616d7a8da186c6c" translate="yes" xml:space="preserve">
          <source>No, you definitely shall not develop layout managers, unless you need something very special.</source>
          <target state="translated">No,definitivamente no desarrollarás gerentes de diseño,a menos que necesites algo muy especial.</target>
        </trans-unit>
        <trans-unit id="307ab8cb83f9ac27e039e7296b2b08390750ad96" translate="yes" xml:space="preserve">
          <source>Of course, this can grow tricky with a real life layout. Therefore grid-based layout managers such as MigLayout are much better if you're about to develop anything serious.</source>
          <target state="translated">Por supuesto,esto puede volverse difícil con un diseño de la vida real.Por lo tanto,los administradores de diseños basados en cuadrículas como MigLayout son mucho mejores si estás a punto de desarrollar algo serio.</target>
        </trans-unit>
        <trans-unit id="0d7954ef62fba1a1c6c5f8eb49be84da9e19ef5e" translate="yes" xml:space="preserve">
          <source>Several times I've been criticized for having suggested the use of the following methods:</source>
          <target state="translated">Varias veces me han criticado por haber sugerido el uso de los siguientes métodos:</target>
        </trans-unit>
        <trans-unit id="5159a31c0c57223db57d56c6afccc7b37ae7c0e4" translate="yes" xml:space="preserve">
          <source>Should I avoid the use of set(Preferred|Maximum|Minimum)Size methods in Java Swing</source>
          <target state="translated">Maximum</target>
        </trans-unit>
        <trans-unit id="24368ab382b57b4e51fbff30e82703ed71584963" translate="yes" xml:space="preserve">
          <source>Should I completely avoid the use of those methods?</source>
          <target state="translated">¿Debería evitar completamente el uso de esos métodos?</target>
        </trans-unit>
        <trans-unit id="0e8b46b6e2690834b4abf89137b167ccb21005aa" translate="yes" xml:space="preserve">
          <source>So, in the name of keeping your GUI functional and nice-looking on all platforms (remember, one of the major benefits of Java is its cross-platformness), you should rely on layout managers, etc., to automatically adjust the sizes of your components so that it renders correctly outside of your specific development environment.</source>
          <target state="translated">Por lo tanto,con el fin de mantener su GUI funcional y de buen aspecto en todas las plataformas (recuerde,uno de los principales beneficios de Java es su multiplataforma),debe confiar en los administradores de diseño,etc.,para ajustar automáticamente los tamaños de sus componentes para que se renderice correctamente fuera de su entorno de desarrollo específico.</target>
        </trans-unit>
        <trans-unit id="1bd3d705c344338a8aad1a106bac39a04e05b944" translate="yes" xml:space="preserve">
          <source>Some (incomplete, and unfortunately the links are broken due to migration of SwingLabs to java.net) technical reasons are for instance mentioned in the &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Rules (hehe)&lt;/a&gt; or in the &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;link&lt;/a&gt; @bendicott found in his/her comment to &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;my answer&lt;/a&gt;. Socially, posing tons of work onto your unfortunate fellow who has to maintain the code and has to track down a broken layout.</source>
          <target state="translated">Algunos (incompletos, y desafortunadamente los enlaces est&amp;aacute;n rotos debido a la migraci&amp;oacute;n de SwingLabs a java.net), por ejemplo, las razones t&amp;eacute;cnicas se mencionan en las &lt;a href=&quot;http://web.archive.org/web/20110614145256/http://wiki.java.net/twiki/bin/view/Javadesktop/SwingLabsImperialRules?TWIKISID=e1a6667476691b56753dc9b0744828c6#Do_not_use_component_setXXSize&quot;&gt;Reglas (jeje)&lt;/a&gt; o en el &lt;a href=&quot;http://web.archive.org/web/20100207211337/http://www.jguru.com/faq/view.jsp?EID=237070&quot;&gt;enlace&lt;/a&gt; @bendicott que se encuentra en su comentario a &lt;a href=&quot;https://stackoverflow.com/questions/7074514/images-in-jtable-cells-off-by-one-pixel&quot;&gt;mi respuesta&lt;/a&gt; . Socialmente, presentando toneladas de trabajo a su desafortunado compa&amp;ntilde;ero que tiene que mantener el c&amp;oacute;digo y tiene que rastrear un dise&amp;ntilde;o roto.</target>
        </trans-unit>
        <trans-unit id="40f1d31b7c8dd444f50d98428b8cd8ccfaeafd52" translate="yes" xml:space="preserve">
          <source>The methods have been defined for a reason. So when should I use them?
  In which context? For what purposes?</source>
          <target state="translated">Los métodos se han definido por una razón.Entonces,¿cuándo debería usarlos? ¿En qué contexto? ¿Con qué propósito?</target>
        </trans-unit>
        <trans-unit id="540c4f65db18e1030a34da86ee391410c184bf1f" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I want to add a little more about the reasons &lt;em&gt;why&lt;/em&gt; you should normally avoid these (the question just came up again in a duplicate topic):</source>
          <target state="translated">Aqu&amp;iacute; hay muchas buenas respuestas, pero quiero agregar un poco m&amp;aacute;s sobre las razones &lt;em&gt;por las&lt;/em&gt; que normalmente deber&amp;iacute;a evitarlas (la pregunta surgi&amp;oacute; nuevamente en un tema duplicado):</target>
        </trans-unit>
        <trans-unit id="4f1c2750bb9a0c4dd1e3fb79014aa8f3f4f20030" translate="yes" xml:space="preserve">
          <source>These methods are poorly understood by most people. You should absolutely not ignore these methods. It is up to the layout manager if they honor these methods. This page has a table that shows which layout managers honor which of those methods:</source>
          <target state="translated">La mayoría de la gente no entiende bien estos métodos.No deberías ignorar estos métodos en absoluto.Depende del gerente de diseño si honran estos métodos.Esta página tiene una tabla que muestra qué gerentes de maquetación respetan cada uno de esos métodos:</target>
        </trans-unit>
        <trans-unit id="0a51f32acf1907b534bde7944ee38f8386d99137" translate="yes" xml:space="preserve">
          <source>They may also be overridden (which is the best practice for Swing) when &lt;em&gt;extending&lt;/em&gt; a Swing component (rather than calling the method on the custom component instance)</source>
          <target state="translated">Tambi&amp;eacute;n pueden anularse (que es la mejor pr&amp;aacute;ctica para Swing) al &lt;em&gt;extender&lt;/em&gt; un componente Swing (en lugar de llamar al m&amp;eacute;todo en la instancia del componente personalizado)</target>
        </trans-unit>
        <trans-unit id="c1e85d170b014983936e8e2c4c7e900a35ffafa9" translate="yes" xml:space="preserve">
          <source>This very popular layout manager is extremely flexible, allowing for very polished Java UIs to be developed.</source>
          <target state="translated">Este popular administrador de diseño es extremadamente flexible,permitiendo el desarrollo de interfaces Java muy pulidas.</target>
        </trans-unit>
        <trans-unit id="1ec55556bdbbcf021c597b1ba85f53eae29d5d67" translate="yes" xml:space="preserve">
          <source>Unfortunately, Swing is not coming with reasonable default dimensions. However, instead of setting the dimensions of a component, it is better OOP to descend your own component with reasonable defaults. (In that case you call setXXX in your descendant class.) Alternatively, you can override the getXXX methods for the same effect.</source>
          <target state="translated">Desafortunadamente,Swing no viene con dimensiones predeterminadas razonables.Sin embargo,en lugar de establecer las dimensiones de un componente,es mejor OOP descender su propio componente con valores por defecto razonables.(En ese caso se llama setXXX en su clase descendiente.)Alternativamente,puede anular los métodos getXXX para el mismo efecto.</target>
        </trans-unit>
        <trans-unit id="a0518f85937eecd914f0c447bc9b66e9a1efed65" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I
  can only think to add portability between systems with different
  screen resolution).</source>
          <target state="translated">¿Cuáles son exactamente las consecuencias negativas de la utilización de esos métodos? (Sólo se me ocurre añadir la portabilidad entre sistemas con diferente resolución de pantalla).</target>
        </trans-unit>
        <trans-unit id="03be6972f5a871fb5126119ff2853a38a28c8c7e" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution).</source>
          <target state="translated">¿Cuáles son exactamente las consecuencias negativas de la utilización de esos métodos? (Sólo puedo pensar en añadir la portabilidad entre sistemas con diferente resolución de pantalla).</target>
        </trans-unit>
        <trans-unit id="7db7f6858afa5c9fac8e8b9fdc4da5e60b2f58b1" translate="yes" xml:space="preserve">
          <source>What exactly are the negative consequences of using those methods? (I can only think adding portability between systems with different screen resolution.)</source>
          <target state="translated">¿Cuáles son exactamente las consecuencias negativas de la utilización de esos métodos? (Sólo puedo pensar en añadir portabilidad entre sistemas con diferente resolución de pantalla.)</target>
        </trans-unit>
        <trans-unit id="b4a11b0ef058755c0527df7e68585b1ac10c6518" translate="yes" xml:space="preserve">
          <source>When you need to provide customized size hints to the containers Layout manager so that the component will be laid out well</source>
          <target state="translated">Cuando necesites dar consejos sobre el tamaño de los contenedores al administrador de diseño para que el componente esté bien distribuido...</target>
        </trans-unit>
        <trans-unit id="2744a93affacde93c2fe41cf485c4eb89f3e85ea" translate="yes" xml:space="preserve">
          <source>With few exceptions, if you are using these methods you are probably fine-tuning your GUI to look good on a specific look-and-feel (and with your system-specific settings, e.g. your preferred desktop font, etc.). The methods themselves aren't inherently evil, but the typical reasons for using them &lt;em&gt;are&lt;/em&gt;. As soon as you start tuning pixel positions and sizes in a layout you run the risk of your GUI breaking (or at minimum, looking bad), on other platforms.</source>
          <target state="translated">Con pocas excepciones, si est&amp;aacute; utilizando estos m&amp;eacute;todos, probablemente est&amp;eacute; ajustando su GUI para que se vea bien en un aspecto espec&amp;iacute;fico (y con la configuraci&amp;oacute;n espec&amp;iacute;fica de su sistema, por ejemplo, su fuente de escritorio preferida, etc.). Los m&amp;eacute;todos en s&amp;iacute; mismos no son inherentemente malos, pero las razones t&amp;iacute;picas para usarlos s&amp;iacute; lo &lt;em&gt;son&lt;/em&gt; . Tan pronto como comience a ajustar las posiciones y tama&amp;ntilde;os de p&amp;iacute;xeles en un dise&amp;ntilde;o, corre el riesgo de que su GUI se rompa (o como m&amp;iacute;nimo, se vea mal) en otras plataformas.</target>
        </trans-unit>
        <trans-unit id="181abc8f1431b3fc4b24b7ff7084f5997bf9d984" translate="yes" xml:space="preserve">
          <source>With layouts the answer is always the same: use a suitable
  LayoutManager</source>
          <target state="translated">Con las maquetas la respuesta es siempre la misma:usar un LayoutManager adecuado</target>
        </trans-unit>
        <trans-unit id="a18978692bb37ab6256c8c6714eeb798c4d51295" translate="yes" xml:space="preserve">
          <source>Yes for application code.</source>
          <target state="translated">Sí para el código de aplicación.</target>
        </trans-unit>
        <trans-unit id="dac954ba2e6beb0d6c4bd134e2e18d3a82cfd388" translate="yes" xml:space="preserve">
          <source>Yes, there are LayoutManagers powerful enough to satisfy a very good approximation to &quot;all layout needs&quot;. The big three are JGoodies FormLayout, MigLayout, DesignGridLayout. So no, in practice, you rarely write LayoutManagers except for simple highly specialized environments.</source>
          <target state="translated">Sí,hay LayoutManagers lo suficientemente poderosos para satisfacer una muy buena aproximación a &quot;todas las necesidades de diseño&quot;.Los tres grandes son JGoodies FormLayout,MigLayout,DesignGridLayout.Así que no,en la práctica,raramente se escriben LayoutManagers excepto para entornos simples altamente especializados.</target>
        </trans-unit>
        <trans-unit id="444042202368def5f8181a05aefd275a8d54be0c" translate="yes" xml:space="preserve">
          <source>You can use JSplitPane where you can pre-set the ratio of the two sides. Or, you can use MigLayout which allows you to set such constraints in percentage, pixels, and other units.</source>
          <target state="translated">Puedes usar el JSplitPane donde puedes preestablecer la proporción de los dos lados.O,puedes usar MigLayout que te permite establecer tales restricciones en porcentaje,píxeles y otras unidades.</target>
        </trans-unit>
        <trans-unit id="f35a75cc4334792c6bc0ab1cd5a82739998fcbef" translate="yes" xml:space="preserve">
          <source>You'll find Karsten's documentation in &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;here&lt;/a&gt;, and some rather good documentation from eclipse &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Encontrar&amp;aacute; la documentaci&amp;oacute;n de Karsten &lt;a href=&quot;http://manual.openestate.org/extern/forms-1.2.1/tutorial/introduction.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; , y una documentaci&amp;oacute;n bastante buena de eclipse &lt;a href=&quot;http://help.eclipse.org/oxygen/topic/org.eclipse.wb.swing.doc.user/html/layoutmanagers/swing/jgoodies_formlayout.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2893740bacbf2ae887be29e7602f37f93e33c2d4" translate="yes" xml:space="preserve">
          <source>between children of a Component (eg, child1 should use 10% of space, child2 40% ,child3 50%), is it possible to achieve that without implementing a custom LayoutManager?</source>
          <target state="translated">entre los niños de un Componente (por ejemplo,el niño1 debe usar el 10% del espacio,el niño2 el 40%,el niño3 el 50%),¿es posible lograr eso sin implementar un Administrador de Diseño personalizado?</target>
        </trans-unit>
        <trans-unit id="0886212cd9ad81c73e17959b2f0c7b17e6248ebc" translate="yes" xml:space="preserve">
          <source>is having two parts. The left and right parts are a horizontal layout. The right part is a JPanel added to the horizontal layout, and this JPanel is having a vertical layout which lays out the buttons vertically.</source>
          <target state="translated">tiene dos partes.La parte izquierda y la derecha son una disposición horizontal.La parte derecha es un JPanel añadido a la disposición horizontal,y este JPanel tiene una disposición vertical que dispone los botones verticalmente.</target>
        </trans-unit>
        <trans-unit id="d00a4682b9e06987369438cd97d3639a65d0178c" translate="yes" xml:space="preserve">
          <source>on &lt;code&gt;Swing&lt;/code&gt; components. I don't see any alternative to their use when I want to define proportions between displayed components. I have been told this:</source>
          <target state="translated">en componentes &lt;code&gt;Swing&lt;/code&gt; . No veo ninguna alternativa a su uso cuando quiero definir proporciones entre los componentes mostrados. Me han dicho esto:</target>
        </trans-unit>
        <trans-unit id="d8e8fbecb943993f987bc322df6b509bc6daa8b4" translate="yes" xml:space="preserve">
          <source>sometimes problems can be encountered with &lt;code&gt;GridBagLayout&lt;/code&gt; and text fields, wherein if the size of the container is smaller than the preferred size, the minimum size gets used, which can cause text fields to shrink quite substantially.</source>
          <target state="translated">a veces se pueden encontrar problemas con &lt;code&gt;GridBagLayout&lt;/code&gt; y los campos de texto, en los que si el tama&amp;ntilde;o del contenedor es m&amp;aacute;s peque&amp;ntilde;o que el tama&amp;ntilde;o preferido, se usa el tama&amp;ntilde;o m&amp;iacute;nimo, lo que puede hacer que los campos de texto se reduzcan considerablemente.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
