<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2450954">
    <body>
      <group id="2450954">
        <trans-unit id="5b4de5962782bc4dba7619a5d62839da95307be6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; shuffle in javascript. I'm posting this here because the use of two utility functions (swap and randInt) clarifies the algorithm compared to the other answers here.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Фишер-Йейтс&lt;/a&gt; перемешивает в javascript. Я публикую это здесь, потому что использование двух служебных функций (swap и randInt) проясняет алгоритм по сравнению с другими ответами здесь.</target>
        </trans-unit>
        <trans-unit id="6f72bfd2d0eaf3c52394f01b95e8da43b9dc6959" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Here's a jsfiddle showing it in use&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Вот jsfiddle, показывающий это в использовании&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5936fd39163329c308f94ca03a104dbcbfc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random() - 0.5&lt;/code&gt; is a random number that may be positive or
  negative, so the sorting function reorders elements randomly.</source>
          <target state="translated">&lt;code&gt;Math.random() - 0.5&lt;/code&gt; - это случайное число, которое может быть положительным или отрицательным, поэтому функция сортировки переупорядочивает элементы случайным образом.</target>
        </trans-unit>
        <trans-unit id="2c2961d2433bea415e1715c6b35944f5d33c907f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(for educational purposes)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(для образовательных целей)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e26209b267ddcc3725cc70e5f78d02ae5945a0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*faster probably on all browsers except chrome.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* быстрее, вероятно, во всех браузерах, кроме Chrome.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51bd7b31f0ce02507256038b5ff757141dd144ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EDIT:&lt;/em&gt; Updating to ES6 / ECMAScript 2015</source>
          <target state="translated">&lt;em&gt;РЕДАКТИРОВАТЬ:&lt;/em&gt; Обновление до ES6 / ECMAScript 2015</target>
        </trans-unit>
        <trans-unit id="8efaa9ada1da4cff6fcad7c371f1d42d0b400a3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Original answer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Оригинальный ответ:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e8cccd85d7f62c7d24c722685e575057ebcd542" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shuffling logic&lt;/em&gt;: pick up a random index, then add the corresponding element to the &lt;em&gt;result array&lt;/em&gt; and delete it from the &lt;em&gt;source array copy&lt;/em&gt;. Repeat this action until the source array gets &lt;em&gt;empty&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Логика перемешивания&lt;/em&gt; : выберите случайный индекс, затем добавьте соответствующий элемент в &lt;em&gt;массив результатов&lt;/em&gt; и удалите его из &lt;em&gt;копии исходного массива&lt;/em&gt; . Повторяйте это действие, пока исходный массив не станет &lt;em&gt;пустым&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="efb894bf2af625d5e7007fcadf92a7611c6daea0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt;: Here I'm suggesting a relatively &lt;strong&gt;simple&lt;/strong&gt; (not from &lt;em&gt;complexity&lt;/em&gt; perspective) and &lt;strong&gt;short&lt;/strong&gt; algorithm that will do just fine with small sized arrays, but it's definitely going to cost a lot more than the classic &lt;em&gt;Durstenfeld&lt;/em&gt; algorithm when you deal with huge arrays. You can find the &lt;em&gt;Durstenfeld&lt;/em&gt; in one of the top replies to this question.</source>
          <target state="translated">&lt;em&gt;Обновление&lt;/em&gt; : здесь я предлагаю относительно &lt;strong&gt;простой&lt;/strong&gt; (не с точки зрения &lt;em&gt;сложности&lt;/em&gt; ) и &lt;strong&gt;короткий&lt;/strong&gt; алгоритм, который отлично подойдет для небольших массивов, но он определенно будет стоить намного дороже, чем классический алгоритм &lt;em&gt;Дюрстенфельда&lt;/em&gt; , когда вы имеете дело с огромными массивами. Вы можете найти &lt;em&gt;Дурстенфельд&lt;/em&gt; в одном из лучших ответов на этот вопрос.</target>
        </trans-unit>
        <trans-unit id="96b6fd7744ca19d4236a9277778b98f0def04eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dee253cdbadca71dde01a92342a8c21696a687fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt; 
There was a calculation in excess (don't need --c+1) &lt;em&gt;and noone noticed&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ&lt;/strong&gt; Был расчет в избытке (не нужно --c + 1), &lt;em&gt;и никто не заметил&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d26d57bf090dbc8f995db9e4efe14b2f99fd8e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.map&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure с использованием array.map&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a963a20e28355edbebbcb98adcb09596e71f7ee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.reduce&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure с использованием array.reduce&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcbf09b9d5cdb75de80f70be8b7b663000db8c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Iterative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Чистый, итеративный&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cff150316022043341bac9d4f6efd812bc0091d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Recursive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Чистый, Рекурсивный&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57d86292367c88ac6937c2d5f8b933e395d3768b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit: This answer is incorrect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Редактировать: этот ответ неверный&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7a1442dc364db9decbad3a8478fdd0d9216bda0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; The above code is O(n^2) due to the employment of &lt;code&gt;.splice()&lt;/code&gt; but we can eliminate splice and shuffle in O(n) by the swap trick.</source>
          <target state="translated">&lt;strong&gt;Изменить:&lt;/strong&gt; приведенный выше код O (n ^ 2) из-за использования &lt;code&gt;.splice()&lt;/code&gt; но мы можем устранить сплайс и тасование в O (n) с помощью трюка подкачки.</target>
        </trans-unit>
        <trans-unit id="5d2b7cbc8216667f5c5cc93d5fbe14fd7b76925a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: as pointed out by @gregers, the compare function is called with values rather than indices, which is why you need to use &lt;code&gt;indexOf&lt;/code&gt;. Note that this change makes the code less suitable for larger arrays as &lt;code&gt;indexOf&lt;/code&gt; runs in O(n) time.</source>
          <target state="translated">&lt;strong&gt;Редактировать&lt;/strong&gt; : как указано @gregers, функция сравнения вызывается со значениями, а не с индексами, поэтому вам нужно использовать &lt;code&gt;indexOf&lt;/code&gt; . Обратите внимание, что это изменение делает код менее подходящим для больших массивов, так как &lt;code&gt;indexOf&lt;/code&gt; выполняется за O (n).</target>
        </trans-unit>
        <trans-unit id="cd1897aa30d21aecd738588f517034caeeea8705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modern short inline solution using ES6 features:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Современное короткое встроенное решение с использованием функций ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bcbf182d2c9f7baf0d1228ed1b2f3c14a66432c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d48760d5688f610b7bd932d6ce59fc0e830bb9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Readable version&lt;/strong&gt; (use the original version. this is slower, vars are useless, like the closures &amp;amp; &quot;;&quot;, the code itself is also shorter ... maybe read this &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;How to 'minify' Javascript code&lt;/a&gt; , btw you are not able to compress the following code in a javascript minifiers like the above one.)</source>
          <target state="translated">&lt;strong&gt;Читаемая версия&lt;/strong&gt; (используйте оригинальную версию. Это медленнее, переменные бесполезны, как замыкания &amp;amp; &quot;;&quot;, сам код также короче ... возможно, прочитайте это &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;Как &quot;минимизировать&quot; код Javascript&lt;/a&gt; , кстати, вы не можете сжать следующий код в миниатюрах javascript, как указано выше.)</target>
        </trans-unit>
        <trans-unit id="1c4379a4d4426412c390aa432f8600adaf810b14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorter &amp;amp; probably *faster Fisher-Yates shuffle algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Короче и, вероятно, * быстрее алгоритм Фишера-Йейтса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cd816d4d50b745090fe63c80545160ad88627b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shuffle Array In place&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Перестановка массива на месте&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4fe6bb18531c0b16a4ac27e9d0bc5314577bf89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Speed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Speed&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba847e347088b75956742f58468d69a72e790bf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc572b1e8fa73691c1a2f268fe0819446c547699" translate="yes" xml:space="preserve">
          <source>A recursive solution:</source>
          <target state="translated">Рекурсивное решение:</target>
        </trans-unit>
        <trans-unit id="d87908291510ce7aacbd6c9c630475506c98bfdb" translate="yes" xml:space="preserve">
          <source>A simple modification of CoolAJ86's &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;answer&lt;/a&gt; that does not modify the original array:</source>
          <target state="translated">Простая модификация &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;ответа&lt;/a&gt; CoolAJ86, которая не изменяет исходный массив:</target>
        </trans-unit>
        <trans-unit id="293d042470d40411ccc70692c51d611ac7e7db1a" translate="yes" xml:space="preserve">
          <source>A very simple way for small arrays is simply this:</source>
          <target state="translated">Очень простой способ для маленьких массивов-это просто так:</target>
        </trans-unit>
        <trans-unit id="fd6c0330ee7aa8770c86a59555809d125e83952d" translate="yes" xml:space="preserve">
          <source>Actually random</source>
          <target state="translated">На самом деле случайный</target>
        </trans-unit>
        <trans-unit id="906af1739f79bc70c9973540b1aeaa064030d5be" translate="yes" xml:space="preserve">
          <source>Adding to @Laurens Holsts answer.  This is 50% compressed.</source>
          <target state="translated">Добавление в @Laurens Holsts ответ.Это 50% сжато.</target>
        </trans-unit>
        <trans-unit id="6db86a3835a9089c53be7e4ab53e72e289b0e742" translate="yes" xml:space="preserve">
          <source>Algorithm runtime is &lt;code&gt;O(n)&lt;/code&gt;. &lt;strong&gt;Note&lt;/strong&gt; that the shuffle is done in-place so if you don't want to modify the original array, first make a copy of it with &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;&lt;code&gt;.slice(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Время выполнения алгоритма - &lt;code&gt;O(n)&lt;/code&gt; . &lt;strong&gt;Обратите внимание,&lt;/strong&gt; что перемешивание выполняется на месте, поэтому, если вы не хотите изменять исходный массив, сначала сделайте его копию с помощью &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt; &lt;code&gt;.slice(0)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29deda6f213fd21db50fee872cbe7bd9a47fe007" translate="yes" xml:space="preserve">
          <source>All the other answers are based on Math.random() which is fast but not suitable for cryptgraphic level randomization.</source>
          <target state="translated">Все остальные ответы основаны на методе Math.random(),который является быстрым,но не подходит для криптографической рандомизации уровня.</target>
        </trans-unit>
        <trans-unit id="7924e36bb8b15e369e65d0080b8819419232c254" translate="yes" xml:space="preserve">
          <source>And if you really want it short, here's how far I could get:</source>
          <target state="translated">И если ты действительно хочешь,чтобы это было коротко,вот как далеко я могу зайти:</target>
        </trans-unit>
        <trans-unit id="5e7fae630e452b3fae47afe81da828d93b9f1443" translate="yes" xml:space="preserve">
          <source>As you can see in this page, there have been incorrect solutions offered here in the past. I wrote and have used the following function to test any pure (no side effects) array randomizing functions.</source>
          <target state="translated">Как видно на этой странице,в прошлом здесь предлагались неверные решения.Я написал и использовал следующую функцию для проверки любых чистых (без побочных эффектов)функций рандомизации массивов.</target>
        </trans-unit>
        <trans-unit id="44707dcfe46333c094f687b61e202b216454bb97" translate="yes" xml:space="preserve">
          <source>Caching somewhere else &lt;code&gt;var rnd=Math.random&lt;/code&gt; and then use &lt;code&gt;rnd()&lt;/code&gt; would also increase slightly the performance on big arrays.</source>
          <target state="translated">Кэширование в другом месте &lt;code&gt;var rnd=Math.random&lt;/code&gt; , а затем использование &lt;code&gt;rnd()&lt;/code&gt; также немного увеличит производительность больших массивов.</target>
        </trans-unit>
        <trans-unit id="c3cddda7fb17e16b2062db130bd1a65b7c0ef0c1" translate="yes" xml:space="preserve">
          <source>Edit: This answer is incorrect</source>
          <target state="translated">Редактирование:Этот ответ неверен</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="a42a5dd86e1515ccf60f677d0c43d4a244ec07a7" translate="yes" xml:space="preserve">
          <source>First of all, have a look &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;here&lt;/a&gt; for a great visual comparison of different sorting methods in javascript.</source>
          <target state="translated">Прежде всего, обратите внимание на отличное визуальное сравнение различных методов сортировки в javascript.</target>
        </trans-unit>
        <trans-unit id="62cd1f392b8ea498402c5d176e812c491931cf19" translate="yes" xml:space="preserve">
          <source>From ChristopheD:</source>
          <target state="translated">От Кристофа Ди:</target>
        </trans-unit>
        <trans-unit id="119f5affc9b4bccbfa35a16ac979913a87667c1b" translate="yes" xml:space="preserve">
          <source>From a theoretical point of view, the most elegant way of doing it, in my humble opinion, is to get a &lt;em&gt;single&lt;/em&gt; random number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;n!-1&lt;/em&gt; and to compute a one to one mapping from &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; to all permutations of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt;. As long as you can use a (pseudo-)random generator reliable enough for getting such a number without any significant bias, you have enough information in it for achieving what you want without needing several other random numbers.</source>
          <target state="translated">С теоретической точки зрения самый элегантный способ сделать это, по моему скромному мнению, это получить &lt;em&gt;одно&lt;/em&gt; случайное число от &lt;em&gt;0&lt;/em&gt; до &lt;em&gt;n! -1&lt;/em&gt; и вычислить отображение один в один из &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; для всех перестановок &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; . Пока вы можете использовать (псевдо) генератор случайных чисел, достаточно надежный для получения такого числа без какого-либо существенного смещения, у вас будет достаточно информации для достижения того, что вы хотите, без необходимости использования нескольких других случайных чисел.</target>
        </trans-unit>
        <trans-unit id="490da622cd663c86273367e7042a11c19785eddb" translate="yes" xml:space="preserve">
          <source>Funny enough there was no non mutating recursive answer:</source>
          <target state="translated">Забавно,что не было не мутирующего рекурсивного ответа:</target>
        </trans-unit>
        <trans-unit id="7985aa6e1818a6f446bbd8db04378dd6b08c7b4e" translate="yes" xml:space="preserve">
          <source>Here's a JavaScript implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt;, an optimized version of Fisher-Yates:</source>
          <target state="translated">Вот реализация JavaScript &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt; , оптимизированной версии Fisher-Yates:</target>
        </trans-unit>
        <trans-unit id="5c4a47a7bb2e4d4b06d049c2e910ebf3e74af15a" translate="yes" xml:space="preserve">
          <source>How can I randomize / shuffle it?</source>
          <target state="translated">Как я могу перетасовать его в случайном порядке?</target>
        </trans-unit>
        <trans-unit id="4ab6a5b825f2780444712bcf5651612afe7a0f32" translate="yes" xml:space="preserve">
          <source>How to randomize (shuffle) a JavaScript array</source>
          <target state="translated">Как рандомизировать (тасовать)массив JavaScript</target>
        </trans-unit>
        <trans-unit id="8e003d8524a462a0f826612e31e2fe8a771ebcae" translate="yes" xml:space="preserve">
          <source>I found this variant hanging out in the &quot;deleted by author&quot; answers on a duplicate of this question. Unlike some of the other answers that have many upvotes already, this is:</source>
          <target state="translated">Я нашел этот вариант в ответах &quot;удалено автором&quot; на дубликат этого вопроса.В отличие от некоторых других ответов,которые уже имеют много upvotes,это так:</target>
        </trans-unit>
        <trans-unit id="e49480fdbe90571097565eed3fe6b5f973ebd696" translate="yes" xml:space="preserve">
          <source>I have an array like this:</source>
          <target state="translated">У меня есть такой массив:</target>
        </trans-unit>
        <trans-unit id="9d0a31eb8f7a7f14043dca0cebb8a6b62db867b9" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;don't wish&lt;/em&gt; your shuffle function to mutate the &lt;strong&gt;source array&lt;/strong&gt;, you can copy it to a local variable, then do the rest with a simple &lt;em&gt;shuffling logic&lt;/em&gt;.</source>
          <target state="translated">Если вы &lt;em&gt;не хотите, чтобы&lt;/em&gt; функция shuffle изменяла &lt;strong&gt;исходный массив&lt;/strong&gt; , вы можете скопировать его в локальную переменную, а затем сделать все остальное с помощью простой &lt;em&gt;логики перемешивания&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36a607745abf0fb5784e3061c8c5b90b7f5e372c" translate="yes" xml:space="preserve">
          <source>If you have any questions just ask.</source>
          <target state="translated">Если у вас есть вопросы,просто задайте их.</target>
        </trans-unit>
        <trans-unit id="151bf418710eddce1cf0effa70940dbec87d44fa" translate="yes" xml:space="preserve">
          <source>It picks a random element for each original array element, and excludes it from the next draw, like picking randomly from a deck of cards.</source>
          <target state="translated">Он выбирает случайный элемент для каждого исходного элемента массива и исключает его из следующей ничьи,как и случайный выбор из колоды карт.</target>
        </trans-unit>
        <trans-unit id="87535ca09b0d3d83bbb3da0becfd0a4d6503a7b4" translate="yes" xml:space="preserve">
          <source>It should work for up to 16 elements with a little theoretical bias (though unnoticeable from a practical point of view); it can be seen as fully usable for 15 elements; with arrays containing less than 14 elements, you can safely consider there will be absolutely no bias.</source>
          <target state="translated">Он должен работать до 16 элементов с небольшим теоретическим смещением (хотя и незаметным с практической точки зрения);его можно рассматривать как полностью используемый для 15 элементов;в массивах,содержащих менее 14 элементов,можно смело считать,что никакого смещения не будет.</target>
        </trans-unit>
        <trans-unit id="1430642f79d43cc2db87a235c3474e0af8edb038" translate="yes" xml:space="preserve">
          <source>It's probably not very efficient, but for small arrays this works just fine. Here's an example so you can see how random (or not) it is, and whether it fits your usecase or not.</source>
          <target state="translated">Вероятно,это не очень эффективно,но для маленьких массивов это работает просто отлично.Вот пример,чтобы вы могли увидеть,насколько это случайно (или нет),и подходит ли это к вашему случаю или нет.</target>
        </trans-unit>
        <trans-unit id="b21d4f8d057efae539ed23ef586ac940cdd1ce22" translate="yes" xml:space="preserve">
          <source>Just to have a finger in the pie. Here i present a recursive implementation of Fisher Yates shuffle (i think). It gives uniform randomness.</source>
          <target state="translated">Просто чтобы палец был в пироге.Здесь я представляю рекурсивное воплощение тасовки Фишера Йейтса (я думаю).Это дает равномерную случайность.</target>
        </trans-unit>
        <trans-unit id="de5caf69e6bd2f9be2350f47acc50e9839bf6aad" translate="yes" xml:space="preserve">
          <source>NEW!</source>
          <target state="translated">NEW!</target>
        </trans-unit>
        <trans-unit id="5bf4a9cc98b9cf85df301bd0ac8de42aec0caec7" translate="yes" xml:space="preserve">
          <source>Not already present here with multiple variants</source>
          <target state="translated">Здесь уже нет нескольких вариантов</target>
        </trans-unit>
        <trans-unit id="d5afcead952a7a1a1617786d3878a9d67d4f1cad" translate="yes" xml:space="preserve">
          <source>Not in-place (hence the &lt;code&gt;shuffled&lt;/code&gt; name rather than &lt;code&gt;shuffle&lt;/code&gt;)</source>
          <target state="translated">Не на месте (следовательно, &lt;code&gt;shuffled&lt;/code&gt; имя, а не &lt;code&gt;shuffle&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="59c22528b1553e334b98831cb29d93e9c242a6bb" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;~~&lt;/code&gt; (double tilde operator) is in fact behaves like &lt;code&gt;Math.floor()&lt;/code&gt; for positive real numbers. Just a short cut it is.</source>
          <target state="translated">Примечание: &lt;code&gt;~~&lt;/code&gt; (оператор двойной тильды) на самом деле ведет себя как &lt;code&gt;Math.floor()&lt;/code&gt; для положительных действительных чисел. Это просто короткий путь.</target>
        </trans-unit>
        <trans-unit id="281343a71cbc74da1fa9ae9cb60112499481dee5" translate="yes" xml:space="preserve">
          <source>Now, what you want merely is:</source>
          <target state="translated">Теперь ты просто хочешь:</target>
        </trans-unit>
        <trans-unit id="05a30fe28c0384a67145436f9b19385d61c2a7f3" translate="yes" xml:space="preserve">
          <source>One could (or should) use it as a protoype from Array:</source>
          <target state="translated">Его можно (или следует)использовать в качестве прототипа из массива:</target>
        </trans-unit>
        <trans-unit id="02a48c36f8633f74bcf21915df7e57e9aacfd49e" translate="yes" xml:space="preserve">
          <source>Other Solutions</source>
          <target state="translated">Другие решения</target>
        </trans-unit>
        <trans-unit id="0f41147bbe611ff022208da6476ba7ea02349389" translate="yes" xml:space="preserve">
          <source>Other solutions just for fun.</source>
          <target state="translated">Другие решения просто для удовольствия.</target>
        </trans-unit>
        <trans-unit id="187d5329025b3a25d74d96c670d7f926ba1230b1" translate="yes" xml:space="preserve">
          <source>Please reference at &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Sorting Arrays&lt;/a&gt;</source>
          <target state="translated">Пожалуйста, ссылки на &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Сортировка массивов&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e68a97c48d4bacb3f09e61dd50a7e19926ed9853" translate="yes" xml:space="preserve">
          <source>Reliability and Performance Test</source>
          <target state="translated">Тест на надежность и производительность</target>
        </trans-unit>
        <trans-unit id="157d6201b2ac3fe0ab015a60e32bbeec8276f242" translate="yes" xml:space="preserve">
          <source>Reliable, Effecient, Short</source>
          <target state="translated">Надежный,эффективный,короткий</target>
        </trans-unit>
        <trans-unit id="f535eb18ddbb2f6d8f98f7d768521dca2bef7bcd" translate="yes" xml:space="preserve">
          <source>Secondly, if you have a quick look at the link above you'll find that the &lt;code&gt;random order&lt;/code&gt; sort seems to perform relatively well compared to the other methods, while being extremely easy and fast to implement as shown below:</source>
          <target state="translated">Во-вторых, если вы быстро посмотрите на приведенную выше ссылку, вы обнаружите, что сортировка по &lt;code&gt;random order&lt;/code&gt; видимому, работает относительно хорошо по сравнению с другими методами, и при этом чрезвычайно проста и быстра для реализации, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="e73ef6160dacf45888e9f4cf8013bc207bf467fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</source>
          <target state="translated">Смотрите &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="376cd4a087bf2a3f30e26253860cff0979202d0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">См. &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;Https://stackoverflow.com/a/18650169/28234&lt;/a&gt; . Это оставлено здесь для справки, потому что идея не редка.</target>
        </trans-unit>
        <trans-unit id="972dfa82e5e7596b3e5d296e882e60afb7f81205" translate="yes" xml:space="preserve">
          <source>See comments and &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">Смотрите комментарии и &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt; . Это оставлено здесь для справки, потому что идея не редка.</target>
        </trans-unit>
        <trans-unit id="98bd03b500f02811b64f750f8b4a4138b59dec79" translate="yes" xml:space="preserve">
          <source>Since the elements are sorted against consistent keys that are not regenerated each iteration, and each comparison pulls from the same distribution, any non-randomness in the distribution of Math.random is canceled out.</source>
          <target state="translated">Поскольку элементы отсортированы по последовательным ключам,которые не регенерируются в каждой итерации,и каждое сравнение извлекается из одного и того же распределения,любая неслучайность в распределении Math.random отменяется.</target>
        </trans-unit>
        <trans-unit id="16b7ffe2af3bc450e245042dd9946320c60307b2" translate="yes" xml:space="preserve">
          <source>Some more info &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;about the algorithm&lt;/a&gt; used.</source>
          <target state="translated">Еще немного информации &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;об используемом алгоритме&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81f118136d9e225898d71bda98047702661efe4d" translate="yes" xml:space="preserve">
          <source>Some solutions on this page aren't reliable (they only partially randomise the array). Other solutions are significantly less effecient. With &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (see below) we can test array shuffling functions for reliability and performance. 
The following solutions are: reliable, effecient and short (using ES6 syntax)</source>
          <target state="translated">Некоторые решения на этой странице не являются надежными (они только частично рандомизируют массив). Другие решения значительно менее эффективны. С помощью &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (см. Ниже) мы можем проверить функции перемешивания массива на надежность и производительность. Следующие решения: надежные, эффективные и короткие (с использованием синтаксиса ES6)</target>
        </trans-unit>
        <trans-unit id="a8a53b3371544e4c20126e1c9e3349051905705d" translate="yes" xml:space="preserve">
          <source>The below code is using the well known &lt;code&gt;Fisher-Yates&lt;/code&gt; algorithm while utilizing &lt;code&gt;Web Cryptography API&lt;/code&gt; for &lt;strong&gt;cryptographic level of randomization&lt;/strong&gt;.</source>
          <target state="translated">Приведенный ниже код использует хорошо известный алгоритм &lt;code&gt;Fisher-Yates&lt;/code&gt; , в то же время используя &lt;code&gt;Web Cryptography API&lt;/code&gt; &lt;strong&gt;криптографии&lt;/strong&gt; для &lt;strong&gt;криптографического уровня рандомизации&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="61fbaa8f9450f0cf39662d39a156aa2bd1444d47" translate="yes" xml:space="preserve">
          <source>The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.</source>
          <target state="translated">Де-факто беспристрастным алгоритмом шарканья является шарканье Фишера-Йатса (он же Кнут).</target>
        </trans-unit>
        <trans-unit id="249b6e44421a088f52be0945aad986d2df59977f" translate="yes" xml:space="preserve">
          <source>The following function will not be used, but I give it anyway; it returns the index of a given permutation of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; according to the one to one mapping used in this message (the most natural one when enumerating permuations); it is intended to work with up to 16 elements:</source>
          <target state="translated">Следующая функция не будет использоваться, но я все равно дам ее; он возвращает индекс заданной перестановки &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; соответствии с отображением &amp;laquo;один к одному&amp;raquo;, используемым в этом сообщении (наиболее естественным при перечислении перестановок); он предназначен для работы с 16 элементами:</target>
        </trans-unit>
        <trans-unit id="b1dc2fb3b4532b7fa4c34753dd7c2f6ed847862a" translate="yes" xml:space="preserve">
          <source>The new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.</source>
          <target state="translated">Новая ES6 позволяет присваивать две переменные одновременно.Это особенно удобно,когда мы хотим поменять значения двух переменных,так как мы можем сделать это в одной строке кода.Вот более короткая форма одной и той же функции,использующей эту возможность.</target>
        </trans-unit>
        <trans-unit id="fed07e4940354c7a1e8ac12c85932a93dcc58c34" translate="yes" xml:space="preserve">
          <source>The problem is, JS can not coop on with big recursions. In this particular case you array size is limited with like 3000~7000 depending on your browser engine and some unknown facts.</source>
          <target state="translated">Проблема в том,что JS не может сотрудничать с большими рецидивами.В данном конкретном случае размер массива ограничен 3000~7000 в зависимости от движка вашего браузера и некоторых неизвестных фактов.</target>
        </trans-unit>
        <trans-unit id="fa07c8700123d14185fdff2c5baeb9dcd4c3901c" translate="yes" xml:space="preserve">
          <source>The reciprocal of the previous function (required for your own question) is below; it is intended to work with up to 16 elements; it returns the permutation of order &lt;em&gt;n&lt;/em&gt; of &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt;:</source>
          <target state="translated">Обратная функция предыдущей функции (требуется для вашего собственного вопроса) приведена ниже; он предназначен для работы до 16 элементов; он возвращает перестановку порядка &lt;em&gt;n&lt;/em&gt; из &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5c18f5c02b633fe05311d86bfbcfbc9d5c1ad7cd" translate="yes" xml:space="preserve">
          <source>The use of this algorithm is &lt;strong&gt;not recommended&lt;/strong&gt;, because it is &lt;strong&gt;inefficient&lt;/strong&gt; and &lt;strong&gt;strongly biased&lt;/strong&gt;; see comments. It is being left here for future reference, because the idea is not that rare.</source>
          <target state="translated">Использование этого алгоритма &lt;strong&gt;не рекомендуется&lt;/strong&gt; , потому что он &lt;strong&gt;неэффективен&lt;/strong&gt; и &lt;strong&gt;сильно смещен&lt;/strong&gt; ; смотрите комментарии. Он оставлен здесь для дальнейшего использования, потому что идея не такая уж редкая.</target>
        </trans-unit>
        <trans-unit id="f0cacae56825070769eaf606992d6e807bd3cf8b" translate="yes" xml:space="preserve">
          <source>This clever exclusion swaps the picked element with the current one, then picks the next random element from the remainder, looping backwards for optimal efficiency, ensuring the random pick is simplified (it can always start at 0), and thereby skipping the final element.</source>
          <target state="translated">Это умное исключение заменяет пикируемый элемент на текущий,затем пикирует следующий случайный элемент из оставшегося,петляя назад для оптимальной эффективности,обеспечивая упрощение пикировки случайных элементов (она всегда может начинаться с 0),и таким образом пропуская конечный элемент.</target>
        </trans-unit>
        <trans-unit id="dd8a3223dfe4968add4c7e42201681618a84f0d4" translate="yes" xml:space="preserve">
          <source>Though there are a number of implementations already advised but I feel we can make it shorter and easier using forEach loop, so we don't need to worry about calculating array length and also we can safely avoid using a temporary variable.</source>
          <target state="translated">Хотя есть несколько реализаций,которые уже были рекомендованы,но я считаю,что мы можем сделать цикл forEach более коротким и легким,так что нам не нужно беспокоиться о вычислении длины массива,а также мы можем безопасно избежать использования временной переменной.</target>
        </trans-unit>
        <trans-unit id="0ddaff04c667b8cad39e34a4186431500f596af0" translate="yes" xml:space="preserve">
          <source>Time complexity is O(N log N), same as quick sort. Space complexity is O(N). This is not as efficient as a Fischer Yates shuffle but, in my opinion, the code is significantly shorter and more functional. If you have a large array you should certainly use Fischer Yates. If you have a small array with a few hundred items, you might do this.</source>
          <target state="translated">Сложность во времени-O(N лог N),как и быстрая сортировка.Пространственная сложность-O(N).Это не так эффективно,как тасование Фишера Йейтса,но,на мой взгляд,код значительно короче и функциональнее.Если у вас большой массив,то обязательно используйте Фишера Йейтса.Если у вас маленький массив с несколькими сотнями элементов,то вы можете это сделать.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="3787f3835a2fd1f1bc17f81e0a5ee6c1516e0a37" translate="yes" xml:space="preserve">
          <source>Use the underscore.js library. The method &lt;code&gt;_.shuffle()&lt;/code&gt; is nice for this case.
Here is an example with the method:</source>
          <target state="translated">Используйте библиотеку underscore.js. Метод &lt;code&gt;_.shuffle()&lt;/code&gt; хорош для этого случая. Вот пример с методом:</target>
        </trans-unit>
        <trans-unit id="e982465409324de04153cd5c52ee341a1e0c33f9" translate="yes" xml:space="preserve">
          <source>We put each element in the array in an object, and give it a random sort key</source>
          <target state="translated">Мы помещаем каждый элемент массива в объект и присваиваем ему ключ случайной сортировки</target>
        </trans-unit>
        <trans-unit id="37c9a8233642b266d81593dc8d16fee23c6ff921" translate="yes" xml:space="preserve">
          <source>We sort using the random key</source>
          <target state="translated">Мы сортируем с помощью случайного ключа</target>
        </trans-unit>
        <trans-unit id="d6afc2bcb349e90081d50a88919a7d7354197158" translate="yes" xml:space="preserve">
          <source>We unmap to get the original objects</source>
          <target state="translated">Мы разворачиваем карту,чтобы получить оригинальные объекты</target>
        </trans-unit>
        <trans-unit id="fa70411d3fe5f5f40d139c572f62e4cb144a088b" translate="yes" xml:space="preserve">
          <source>When computing with IEEE754 double precision floating numbers, you can expect your random generator to provide about 15 decimals. Since you have &lt;em&gt;15!=1,307,674,368,000&lt;/em&gt; (with 13 digits), you can use the following functions with arrays containing up to 15 elements and assume there will be no significant bias with arrays containing up to 14 elements. If you work on a fixed-size problem requiring to compute many times this shuffle operation, you may want to try the following code which &lt;em&gt;may&lt;/em&gt; be faster than other codes since it uses &lt;code&gt;Math.random&lt;/code&gt; only once (it involves several copy operations however).</source>
          <target state="translated">При вычислении с плавающими числами двойной точности IEEE754 вы можете ожидать, что ваш генератор случайных чисел предоставит около 15 десятичных знаков. Поскольку у вас &lt;em&gt;15! = 1 307 674 368 000&lt;/em&gt; (с 13 цифрами), вы можете использовать следующие функции с массивами, содержащими до 15 элементов, и предполагать, что не будет существенного смещения с массивами, содержащими до 14 элементов. Если вы работаете с проблемой фиксированного размера, требующей многократного вычисления этой операции тасования, вы можете попробовать следующий код, который &lt;em&gt;может&lt;/em&gt; быть быстрее других кодов, поскольку он использует &lt;code&gt;Math.random&lt;/code&gt; только один раз (однако он включает несколько операций копирования).</target>
        </trans-unit>
        <trans-unit id="ac812b0a196ffcf1ada365b6be5a7c7f0f2c1ae9" translate="yes" xml:space="preserve">
          <source>With ES2015 you can use this one:</source>
          <target state="translated">С ES2015 вы можете использовать эту:</target>
        </trans-unit>
        <trans-unit id="9bda77affb36f55fffd0079cb167c23b57c503a1" translate="yes" xml:space="preserve">
          <source>You can do it easily with map and sort:</source>
          <target state="translated">Это легко сделать с помощью карты и сортировки:</target>
        </trans-unit>
        <trans-unit id="0bd7627872f884699658169c2436dcdecd7197ea" translate="yes" xml:space="preserve">
          <source>You can do it easily with:</source>
          <target state="translated">С этим легко справиться:</target>
        </trans-unit>
        <trans-unit id="a7d34d88cd56ff8410463b8f789e7edda9d26b00" translate="yes" xml:space="preserve">
          <source>You can see a &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;great visualization here&lt;/a&gt; (and the original post &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;linked to this&lt;/a&gt;)</source>
          <target state="translated">Вы можете увидеть &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;отличную визуализацию здесь&lt;/a&gt; (и оригинальный пост, &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;связанный с этим&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="db43e778b685a829c5fa7d3b2857f1cbc7c9dfec" translate="yes" xml:space="preserve">
          <source>You can shuffle polymorphic arrays, and the sort is as random as Math.random, which is good enough for most purposes.</source>
          <target state="translated">Можно перетасовывать полиморфные массивы,а сорт случайный,как и Math.random,что достаточно хорошо для большинства целей.</target>
        </trans-unit>
        <trans-unit id="41f2e5a2df3900f50dd0bc1a1fd8b451e58f16da" translate="yes" xml:space="preserve">
          <source>[Comparison tests were done using &lt;code&gt;testShuffleArrayFun&lt;/code&gt; against other solutions, in Google Chrome]</source>
          <target state="translated">[Сравнительные тесты проводились с использованием &lt;code&gt;testShuffleArrayFun&lt;/code&gt; с другими решениями в Google Chrome]</target>
        </trans-unit>
        <trans-unit id="14236c02e628eaa55439674b94dfa1eec350021f" translate="yes" xml:space="preserve">
          <source>a shuffle function that doesn't change the source array</source>
          <target state="translated">тасовка функции,которая не изменяет исходный массив</target>
        </trans-unit>
        <trans-unit id="66c531dd89d3a2bb546b62f5e8a08723322f6e1c" translate="yes" xml:space="preserve">
          <source>bitwise to floor (numbers up to 10 decimal digits (32bit))</source>
          <target state="translated">от битовой до напольной (числа до 10 десятичных цифр (32 бит)).</target>
        </trans-unit>
        <trans-unit id="d25e649970e6fdedcd9efdc5002ea1b93e971620" translate="yes" xml:space="preserve">
          <source>it uses while---</source>
          <target state="translated">он использует в то время как...</target>
        </trans-unit>
        <trans-unit id="68340861fed2ccc0703bd6ad39a67953febe7878" translate="yes" xml:space="preserve">
          <source>removed unecessary closures &amp;amp; other stuff</source>
          <target state="translated">удалены ненужные затворы и прочее</target>
        </trans-unit>
        <trans-unit id="a40e5dc89de6414f6b7c4790ca64ea34f10dcb3f" translate="yes" xml:space="preserve">
          <source>script size (with fy as function name): 90bytes</source>
          <target state="translated">размер скрипта (с именем функции fy):90байт</target>
        </trans-unit>
        <trans-unit id="2d86563e6b1bdb64dd3a50cdf0529b14eae84135" translate="yes" xml:space="preserve">
          <source>shorter(4bytes)&amp;amp;faster(test it!).</source>
          <target state="translated">короче (4 байта) и быстрее (протестируйте!).</target>
        </trans-unit>
        <trans-unit id="ab0874c3f73b2ecdaab7f1d46c567cffea1594bb" translate="yes" xml:space="preserve">
          <source>the shortest &lt;code&gt;arrayShuffle&lt;/code&gt; function</source>
          <target state="translated">самая короткая функция &lt;code&gt;arrayShuffle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55ee529bcb360882189f97174d46ceaad11eab66" translate="yes" xml:space="preserve">
          <source>using the top voted functions.</source>
          <target state="translated">с использованием функций,проголосовавших сверху.</target>
        </trans-unit>
        <trans-unit id="63fbcfc569baf433216f5dc54bf2974616aa7d6c" translate="yes" xml:space="preserve">
          <source>yes it is faster</source>
          <target state="translated">да,быстрее</target>
        </trans-unit>
        <trans-unit id="f64996142b0f5ac8ca17c305fb58363a0af6ad3f" translate="yes" xml:space="preserve">
          <source>yet another implementation of Fisher-Yates, using strict mode:</source>
          <target state="translated">еще одна реализация Фишера-Йейтса,использующая строгий режим:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
