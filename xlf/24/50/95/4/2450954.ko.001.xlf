<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2450954">
    <body>
      <group id="2450954">
        <trans-unit id="5b4de5962782bc4dba7619a5d62839da95307be6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; shuffle in javascript. I'm posting this here because the use of two utility functions (swap and randInt) clarifies the algorithm compared to the other answers here.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; 는 자바 스크립트에서 섞습니다. 두 개의 유틸리티 함수 (swap 및 randInt)를 사용하면 다른 답변과 비교하여 알고리즘이 명확 해지기 때문에 여기에 게시하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f72bfd2d0eaf3c52394f01b95e8da43b9dc6959" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Here's a jsfiddle showing it in use&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;여기에 사용중인 jsfiddle이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5936fd39163329c308f94ca03a104dbcbfc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random() - 0.5&lt;/code&gt; is a random number that may be positive or
  negative, so the sorting function reorders elements randomly.</source>
          <target state="translated">&lt;code&gt;Math.random() - 0.5&lt;/code&gt; 는 양수이거나 음수 일 수있는 난수이므로 정렬 함수는 요소를 무작위로 재정렬합니다.</target>
        </trans-unit>
        <trans-unit id="2c2961d2433bea415e1715c6b35944f5d33c907f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(for educational purposes)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(교육 목적으로)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e26209b267ddcc3725cc70e5f78d02ae5945a0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*faster probably on all browsers except chrome.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* 크롬을 제외한 모든 브라우저에서 더 빠를 것입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51bd7b31f0ce02507256038b5ff757141dd144ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EDIT:&lt;/em&gt; Updating to ES6 / ECMAScript 2015</source>
          <target state="translated">&lt;em&gt;편집 :&lt;/em&gt; ES6 / ECMAScript 2015로 업데이트</target>
        </trans-unit>
        <trans-unit id="8efaa9ada1da4cff6fcad7c371f1d42d0b400a3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Original answer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;원래 답변 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e8cccd85d7f62c7d24c722685e575057ebcd542" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shuffling logic&lt;/em&gt;: pick up a random index, then add the corresponding element to the &lt;em&gt;result array&lt;/em&gt; and delete it from the &lt;em&gt;source array copy&lt;/em&gt;. Repeat this action until the source array gets &lt;em&gt;empty&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;셔플 링 로직&lt;/em&gt; : 랜덤 인덱스를 선택한 다음 해당하는 요소를 &lt;em&gt;결과 배열에&lt;/em&gt; 추가하고 &lt;em&gt;소스 배열 복사본&lt;/em&gt; 에서 삭제합니다. 소스 배열이 &lt;em&gt;비워&lt;/em&gt; 질 때까지이 동작을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="efb894bf2af625d5e7007fcadf92a7611c6daea0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt;: Here I'm suggesting a relatively &lt;strong&gt;simple&lt;/strong&gt; (not from &lt;em&gt;complexity&lt;/em&gt; perspective) and &lt;strong&gt;short&lt;/strong&gt; algorithm that will do just fine with small sized arrays, but it's definitely going to cost a lot more than the classic &lt;em&gt;Durstenfeld&lt;/em&gt; algorithm when you deal with huge arrays. You can find the &lt;em&gt;Durstenfeld&lt;/em&gt; in one of the top replies to this question.</source>
          <target state="translated">&lt;em&gt;업데이트&lt;/em&gt; : 여기에서는 작은 크기의 배열에서 잘 작동하는 비교적 &lt;strong&gt;간단한&lt;/strong&gt; ( &lt;em&gt;복잡성&lt;/em&gt; 관점이 아닌) &lt;strong&gt;짧은&lt;/strong&gt; 알고리즘을 제안하지만 거대한 배열을 처리 할 때 고전적인 &lt;em&gt;Durstenfeld&lt;/em&gt; 알고리즘보다 훨씬 많은 비용이 &lt;em&gt;듭니다&lt;/em&gt; . &lt;em&gt;Durstenfeld&lt;/em&gt; 는이 질문에 대한 최고의 답변 중 하나에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b6fd7744ca19d4236a9277778b98f0def04eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dee253cdbadca71dde01a92342a8c21696a687fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt; 
There was a calculation in excess (don't need --c+1) &lt;em&gt;and noone noticed&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;편집&lt;/strong&gt; 초과 계산이 있었으며 (-c + 1 필요 없음) &lt;em&gt;아무도 눈치 채지&lt;/em&gt; 못했습니다.</target>
        </trans-unit>
        <trans-unit id="d26d57bf090dbc8f995db9e4efe14b2f99fd8e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.map&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array.map을 사용하는 ES6 Pure&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a963a20e28355edbebbcb98adcb09596e71f7ee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.reduce&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array.reduce를 사용하는 ES6 Pure&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcbf09b9d5cdb75de80f70be8b7b663000db8c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Iterative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 순수 반복&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cff150316022043341bac9d4f6efd812bc0091d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Recursive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 순수 재귀&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57d86292367c88ac6937c2d5f8b933e395d3768b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit: This answer is incorrect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집 :이 답변이 잘못되었습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7a1442dc364db9decbad3a8478fdd0d9216bda0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; The above code is O(n^2) due to the employment of &lt;code&gt;.splice()&lt;/code&gt; but we can eliminate splice and shuffle in O(n) by the swap trick.</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 위의 코드는 &lt;code&gt;.splice()&lt;/code&gt; 를 사용하여 O (n ^ 2 ) 이지만 스왑 트릭으로 O (n)에서 스플 라이스와 셔플을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d2b7cbc8216667f5c5cc93d5fbe14fd7b76925a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: as pointed out by @gregers, the compare function is called with values rather than indices, which is why you need to use &lt;code&gt;indexOf&lt;/code&gt;. Note that this change makes the code less suitable for larger arrays as &lt;code&gt;indexOf&lt;/code&gt; runs in O(n) time.</source>
          <target state="translated">&lt;strong&gt;편집&lt;/strong&gt; : @gregers가 지적한 것처럼 비교 함수는 인덱스가 아닌 값으로 호출되므로 &lt;code&gt;indexOf&lt;/code&gt; 를 사용해야합니다. 이 변경으로 &lt;code&gt;indexOf&lt;/code&gt; 가 O (n) 시간에 실행되므로 더 큰 배열에는 코드가 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd1897aa30d21aecd738588f517034caeeea8705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modern short inline solution using ES6 features:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 기능을 사용하는 최신 짧은 인라인 솔루션 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bcbf182d2c9f7baf0d1228ed1b2f3c14a66432c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d48760d5688f610b7bd932d6ce59fc0e830bb9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Readable version&lt;/strong&gt; (use the original version. this is slower, vars are useless, like the closures &amp;amp; &quot;;&quot;, the code itself is also shorter ... maybe read this &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;How to 'minify' Javascript code&lt;/a&gt; , btw you are not able to compress the following code in a javascript minifiers like the above one.)</source>
          <target state="translated">&lt;strong&gt;읽을 수있는 버전&lt;/strong&gt; (원래 버전을 사용하십시오. 이것은 느리고, vars는 클로저 &amp;amp; &quot;;&quot;와 같이 쓸모가 없습니다. 코드 자체도 짧습니다 ... &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;어떻게&lt;/a&gt; 읽을 수 있습니까? 위의 코드와 같은 자바 스크립트 축소 기에서 다음 코드를 압축하십시오.)</target>
        </trans-unit>
        <trans-unit id="1c4379a4d4426412c390aa432f8600adaf810b14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorter &amp;amp; probably *faster Fisher-Yates shuffle algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 짧고 아마도 더 빠른 Fisher-Yates shuffle 알고리즘&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cd816d4d50b745090fe63c80545160ad88627b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shuffle Array In place&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열 셔플&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4fe6bb18531c0b16a4ac27e9d0bc5314577bf89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Speed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Speed&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba847e347088b75956742f58468d69a72e790bf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc572b1e8fa73691c1a2f268fe0819446c547699" translate="yes" xml:space="preserve">
          <source>A recursive solution:</source>
          <target state="translated">재귀 솔루션 :</target>
        </trans-unit>
        <trans-unit id="d87908291510ce7aacbd6c9c630475506c98bfdb" translate="yes" xml:space="preserve">
          <source>A simple modification of CoolAJ86's &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;answer&lt;/a&gt; that does not modify the original array:</source>
          <target state="translated">원래 배열을 수정하지 않는 CoolAJ86의 간단한 &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;대답&lt;/a&gt; 수정 :</target>
        </trans-unit>
        <trans-unit id="293d042470d40411ccc70692c51d611ac7e7db1a" translate="yes" xml:space="preserve">
          <source>A very simple way for small arrays is simply this:</source>
          <target state="translated">작은 배열을위한 매우 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd6c0330ee7aa8770c86a59555809d125e83952d" translate="yes" xml:space="preserve">
          <source>Actually random</source>
          <target state="translated">실제로 무작위</target>
        </trans-unit>
        <trans-unit id="906af1739f79bc70c9973540b1aeaa064030d5be" translate="yes" xml:space="preserve">
          <source>Adding to @Laurens Holsts answer.  This is 50% compressed.</source>
          <target state="translated">@Laurens Holsts에 추가하십시오. 이 압축률은 50 %입니다.</target>
        </trans-unit>
        <trans-unit id="6db86a3835a9089c53be7e4ab53e72e289b0e742" translate="yes" xml:space="preserve">
          <source>Algorithm runtime is &lt;code&gt;O(n)&lt;/code&gt;. &lt;strong&gt;Note&lt;/strong&gt; that the shuffle is done in-place so if you don't want to modify the original array, first make a copy of it with &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;&lt;code&gt;.slice(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">알고리즘 런타임은 &lt;code&gt;O(n)&lt;/code&gt; 입니다. 셔플은 제자리에서 수행되므로 원래 배열을 수정하지 않으려면 먼저 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt; &lt;code&gt;.slice(0)&lt;/code&gt; &lt;/a&gt; 으로 복사본을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="29deda6f213fd21db50fee872cbe7bd9a47fe007" translate="yes" xml:space="preserve">
          <source>All the other answers are based on Math.random() which is fast but not suitable for cryptgraphic level randomization.</source>
          <target state="translated">다른 모든 답변은 Math.random () 기반으로 빠르지 만 암호화 수준 무작위 화에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7924e36bb8b15e369e65d0080b8819419232c254" translate="yes" xml:space="preserve">
          <source>And if you really want it short, here's how far I could get:</source>
          <target state="translated">그리고 당신이 정말로 그것을 짧게 원한다면, 내가 얻을 수있는 거리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e7fae630e452b3fae47afe81da828d93b9f1443" translate="yes" xml:space="preserve">
          <source>As you can see in this page, there have been incorrect solutions offered here in the past. I wrote and have used the following function to test any pure (no side effects) array randomizing functions.</source>
          <target state="translated">이 페이지에서 볼 수 있듯이 과거에 잘못된 솔루션이 제공되었습니다. 순수하고 부작용이없는 배열 임의 화 함수를 테스트하기 위해 다음 함수를 작성하고 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="44707dcfe46333c094f687b61e202b216454bb97" translate="yes" xml:space="preserve">
          <source>Caching somewhere else &lt;code&gt;var rnd=Math.random&lt;/code&gt; and then use &lt;code&gt;rnd()&lt;/code&gt; would also increase slightly the performance on big arrays.</source>
          <target state="translated">다른 곳에서 &lt;code&gt;var rnd=Math.random&lt;/code&gt; 을 캐싱 한 다음 &lt;code&gt;rnd()&lt;/code&gt; 를 사용하면 큰 배열의 성능이 약간 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="c3cddda7fb17e16b2062db130bd1a65b7c0ef0c1" translate="yes" xml:space="preserve">
          <source>Edit: This answer is incorrect</source>
          <target state="translated">편집 :이 답변이 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="a42a5dd86e1515ccf60f677d0c43d4a244ec07a7" translate="yes" xml:space="preserve">
          <source>First of all, have a look &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;here&lt;/a&gt; for a great visual comparison of different sorting methods in javascript.</source>
          <target state="translated">우선, 자바 스크립트에서 다른 정렬 방법을 시각적으로 비교하는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="62cd1f392b8ea498402c5d176e812c491931cf19" translate="yes" xml:space="preserve">
          <source>From ChristopheD:</source>
          <target state="translated">ChristopheD에서 :</target>
        </trans-unit>
        <trans-unit id="119f5affc9b4bccbfa35a16ac979913a87667c1b" translate="yes" xml:space="preserve">
          <source>From a theoretical point of view, the most elegant way of doing it, in my humble opinion, is to get a &lt;em&gt;single&lt;/em&gt; random number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;n!-1&lt;/em&gt; and to compute a one to one mapping from &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; to all permutations of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt;. As long as you can use a (pseudo-)random generator reliable enough for getting such a number without any significant bias, you have enough information in it for achieving what you want without needing several other random numbers.</source>
          <target state="translated">이론적으로 볼 때, 가장 겸손한 견해로는 &lt;em&gt;0&lt;/em&gt; 과 &lt;em&gt;n&lt;/em&gt; 사이의 &lt;em&gt;단일&lt;/em&gt; 난수를 가져 와서 &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; 에서 일대일 매핑을 계산하는 것이 가장 우아한 방법입니다 &lt;em&gt;.&lt;/em&gt; n! -1} 을 &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; 모든 순열에 적용합니다. 큰 편견없이 그러한 숫자를 얻을 수있을만큼 신뢰할 수있는 (의사) 난수 생성기를 사용할 수 있다면, 다른 임의의 숫자 없이도 원하는 것을 달성 할 수있는 충분한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="490da622cd663c86273367e7042a11c19785eddb" translate="yes" xml:space="preserve">
          <source>Funny enough there was no non mutating recursive answer:</source>
          <target state="translated">재밌지 않은 재귀 응답이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="7985aa6e1818a6f446bbd8db04378dd6b08c7b4e" translate="yes" xml:space="preserve">
          <source>Here's a JavaScript implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt;, an optimized version of Fisher-Yates:</source>
          <target state="translated">Fisher-Yates의 최적화 된 버전 인 &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt; 의 JavaScript 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c4a47a7bb2e4d4b06d049c2e910ebf3e74af15a" translate="yes" xml:space="preserve">
          <source>How can I randomize / shuffle it?</source>
          <target state="translated">어떻게 무작위 / 셔플 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4ab6a5b825f2780444712bcf5651612afe7a0f32" translate="yes" xml:space="preserve">
          <source>How to randomize (shuffle) a JavaScript array</source>
          <target state="translated">JavaScript 배열을 무작위 화 (셔플)하는 방법</target>
        </trans-unit>
        <trans-unit id="8e003d8524a462a0f826612e31e2fe8a771ebcae" translate="yes" xml:space="preserve">
          <source>I found this variant hanging out in the &quot;deleted by author&quot; answers on a duplicate of this question. Unlike some of the other answers that have many upvotes already, this is:</source>
          <target state="translated">이 질문의 복제본에 대한 &quot;저자에 의해 삭제됨&quot;답변에서이 변형이 발견되었습니다. 이미 많은 의견을 가진 다른 답변들과 달리, 이것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="e49480fdbe90571097565eed3fe6b5f973ebd696" translate="yes" xml:space="preserve">
          <source>I have an array like this:</source>
          <target state="translated">다음과 같은 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d0a31eb8f7a7f14043dca0cebb8a6b62db867b9" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;don't wish&lt;/em&gt; your shuffle function to mutate the &lt;strong&gt;source array&lt;/strong&gt;, you can copy it to a local variable, then do the rest with a simple &lt;em&gt;shuffling logic&lt;/em&gt;.</source>
          <target state="translated">셔플 기능으로 &lt;strong&gt;소스 배열&lt;/strong&gt; 을 변경 &lt;em&gt;하지 않으&lt;/em&gt; 려면 로컬 &lt;strong&gt;배열&lt;/strong&gt; 에 복사 한 다음 간단한 &lt;em&gt;셔플 링 논리를 사용&lt;/em&gt; 하여 나머지를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36a607745abf0fb5784e3061c8c5b90b7f5e372c" translate="yes" xml:space="preserve">
          <source>If you have any questions just ask.</source>
          <target state="translated">궁금한 점이 있으면 물어보십시오.</target>
        </trans-unit>
        <trans-unit id="151bf418710eddce1cf0effa70940dbec87d44fa" translate="yes" xml:space="preserve">
          <source>It picks a random element for each original array element, and excludes it from the next draw, like picking randomly from a deck of cards.</source>
          <target state="translated">각 원본 배열 요소에 대해 임의의 요소를 선택하고 카드 덱에서 무작위로 선택하는 것처럼 다음 추첨에서 제외합니다.</target>
        </trans-unit>
        <trans-unit id="87535ca09b0d3d83bbb3da0becfd0a4d6503a7b4" translate="yes" xml:space="preserve">
          <source>It should work for up to 16 elements with a little theoretical bias (though unnoticeable from a practical point of view); it can be seen as fully usable for 15 elements; with arrays containing less than 14 elements, you can safely consider there will be absolutely no bias.</source>
          <target state="translated">이론적 인 편견이 거의없는 최대 16 개의 요소에 대해 작동해야합니다 (실제적인 관점에서는 눈에 띄지 않지만). 15 개의 요소에 대해 완전히 사용 가능한 것으로 볼 수 있습니다. 14 개 미만의 요소를 포함하는 배열을 사용하면 치우침이 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="1430642f79d43cc2db87a235c3474e0af8edb038" translate="yes" xml:space="preserve">
          <source>It's probably not very efficient, but for small arrays this works just fine. Here's an example so you can see how random (or not) it is, and whether it fits your usecase or not.</source>
          <target state="translated">아마 효율적이지 않을 수도 있지만 작은 배열의 경우에는 잘 작동합니다. 다음은 그 예가 임의적이든 아니든, 사용 사례에 맞는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21d4f8d057efae539ed23ef586ac940cdd1ce22" translate="yes" xml:space="preserve">
          <source>Just to have a finger in the pie. Here i present a recursive implementation of Fisher Yates shuffle (i think). It gives uniform randomness.</source>
          <target state="translated">파이에 손가락을 넣는 것만으로 여기에 Fisher Yates shuffle의 재귀 구현을 제시합니다 (생각합니다). 균일 한 무작위성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="de5caf69e6bd2f9be2350f47acc50e9839bf6aad" translate="yes" xml:space="preserve">
          <source>NEW!</source>
          <target state="translated">NEW!</target>
        </trans-unit>
        <trans-unit id="5bf4a9cc98b9cf85df301bd0ac8de42aec0caec7" translate="yes" xml:space="preserve">
          <source>Not already present here with multiple variants</source>
          <target state="translated">여기에 여러 변형이 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d5afcead952a7a1a1617786d3878a9d67d4f1cad" translate="yes" xml:space="preserve">
          <source>Not in-place (hence the &lt;code&gt;shuffled&lt;/code&gt; name rather than &lt;code&gt;shuffle&lt;/code&gt;)</source>
          <target state="translated">제자리에 있지 않음 (따라서 &lt;code&gt;shuffled&lt;/code&gt; 대신 셔플 이름)</target>
        </trans-unit>
        <trans-unit id="59c22528b1553e334b98831cb29d93e9c242a6bb" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;~~&lt;/code&gt; (double tilde operator) is in fact behaves like &lt;code&gt;Math.floor()&lt;/code&gt; for positive real numbers. Just a short cut it is.</source>
          <target state="translated">참고 : &lt;code&gt;~~&lt;/code&gt; (이중 물결표 연산자)는 실제로 양의 실수 인 경우 &lt;code&gt;Math.floor()&lt;/code&gt; 와 같이 동작합니다. 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="281343a71cbc74da1fa9ae9cb60112499481dee5" translate="yes" xml:space="preserve">
          <source>Now, what you want merely is:</source>
          <target state="translated">이제 원하는 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05a30fe28c0384a67145436f9b19385d61c2a7f3" translate="yes" xml:space="preserve">
          <source>One could (or should) use it as a protoype from Array:</source>
          <target state="translated">Array의 protoype로 사용할 수 있거나 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="02a48c36f8633f74bcf21915df7e57e9aacfd49e" translate="yes" xml:space="preserve">
          <source>Other Solutions</source>
          <target state="translated">다른 솔루션</target>
        </trans-unit>
        <trans-unit id="0f41147bbe611ff022208da6476ba7ea02349389" translate="yes" xml:space="preserve">
          <source>Other solutions just for fun.</source>
          <target state="translated">재미를위한 다른 솔루션.</target>
        </trans-unit>
        <trans-unit id="187d5329025b3a25d74d96c670d7f926ba1230b1" translate="yes" xml:space="preserve">
          <source>Please reference at &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Sorting Arrays&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript 정렬 배열을&lt;/a&gt; 참조하십시오</target>
        </trans-unit>
        <trans-unit id="e68a97c48d4bacb3f09e61dd50a7e19926ed9853" translate="yes" xml:space="preserve">
          <source>Reliability and Performance Test</source>
          <target state="translated">신뢰성 및 성능 테스트</target>
        </trans-unit>
        <trans-unit id="157d6201b2ac3fe0ab015a60e32bbeec8276f242" translate="yes" xml:space="preserve">
          <source>Reliable, Effecient, Short</source>
          <target state="translated">안정적이고 효율적이며 짧음</target>
        </trans-unit>
        <trans-unit id="f535eb18ddbb2f6d8f98f7d768521dca2bef7bcd" translate="yes" xml:space="preserve">
          <source>Secondly, if you have a quick look at the link above you'll find that the &lt;code&gt;random order&lt;/code&gt; sort seems to perform relatively well compared to the other methods, while being extremely easy and fast to implement as shown below:</source>
          <target state="translated">둘째, 위의 링크를 빠르게 살펴보면 &lt;code&gt;random order&lt;/code&gt; 정렬이 다른 방법에 비해 상대적으로 잘 수행되는 것처럼 보이지만 아래 그림과 같이 구현하기가 매우 쉽고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e73ef6160dacf45888e9f4cf8013bc207bf467fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="376cd4a087bf2a3f30e26253860cff0979202d0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234를&lt;/a&gt; 참조 하십시오 . 아이디어가 드물지 않기 때문에 참조를 위해 여기에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="972dfa82e5e7596b3e5d296e882e60afb7f81205" translate="yes" xml:space="preserve">
          <source>See comments and &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">의견 및 &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234를 참조하십시오&lt;/a&gt; . 아이디어가 드물지 않기 때문에 참조를 위해 여기에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="98bd03b500f02811b64f750f8b4a4138b59dec79" translate="yes" xml:space="preserve">
          <source>Since the elements are sorted against consistent keys that are not regenerated each iteration, and each comparison pulls from the same distribution, any non-randomness in the distribution of Math.random is canceled out.</source>
          <target state="translated">요소는 각 반복을 재생성하지 않는 일관된 키에 대해 정렬되고 각 비교는 동일한 분포에서 가져 오기 때문에 Math.random 분포의 비 랜덤 성은 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="16b7ffe2af3bc450e245042dd9946320c60307b2" translate="yes" xml:space="preserve">
          <source>Some more info &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;about the algorithm&lt;/a&gt; used.</source>
          <target state="translated">사용 &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;된 알고리즘에 대한&lt;/a&gt; 추가 정보</target>
        </trans-unit>
        <trans-unit id="81f118136d9e225898d71bda98047702661efe4d" translate="yes" xml:space="preserve">
          <source>Some solutions on this page aren't reliable (they only partially randomise the array). Other solutions are significantly less effecient. With &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (see below) we can test array shuffling functions for reliability and performance. 
The following solutions are: reliable, effecient and short (using ES6 syntax)</source>
          <target state="translated">이 페이지의 일부 솔루션은 신뢰할 수 없습니다 (어레이의 일부만 무작위 화). 다른 솔루션은 효율성이 크게 떨어집니다. &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (아래 참조)을 통해 어레이 셔플 기능을 테스트하여 안정성과 성능을 확인할 수 있습니다. 신뢰할 수 있고 효율적이며 짧은 솔루션 (ES6 구문 사용)</target>
        </trans-unit>
        <trans-unit id="a8a53b3371544e4c20126e1c9e3349051905705d" translate="yes" xml:space="preserve">
          <source>The below code is using the well known &lt;code&gt;Fisher-Yates&lt;/code&gt; algorithm while utilizing &lt;code&gt;Web Cryptography API&lt;/code&gt; for &lt;strong&gt;cryptographic level of randomization&lt;/strong&gt;.</source>
          <target state="translated">아래 코드는 잘 알려진 &lt;code&gt;Fisher-Yates&lt;/code&gt; 알고리즘을 사용하면서 &lt;strong&gt;암호화 수준의 무작위 화를&lt;/strong&gt; 위해 &lt;code&gt;Web Cryptography API&lt;/code&gt; 를 &lt;strong&gt;사용합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="61fbaa8f9450f0cf39662d39a156aa2bd1444d47" translate="yes" xml:space="preserve">
          <source>The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.</source>
          <target state="translated">사실상의 비 편향 셔플 알고리즘은 Fisher-Yates (일명 Knuth) 셔플입니다.</target>
        </trans-unit>
        <trans-unit id="249b6e44421a088f52be0945aad986d2df59977f" translate="yes" xml:space="preserve">
          <source>The following function will not be used, but I give it anyway; it returns the index of a given permutation of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; according to the one to one mapping used in this message (the most natural one when enumerating permuations); it is intended to work with up to 16 elements:</source>
          <target state="translated">다음 함수는 사용되지 않지만 어쨌든 제공합니다. 이 메시지에 사용 된 일대일 매핑에 따라 &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; 의 주어진 순열 인덱스를 반환합니다 (퍼머 레이션을 열거 할 때 가장 자연스러운 것). 최대 16 개의 요소로 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b1dc2fb3b4532b7fa4c34753dd7c2f6ed847862a" translate="yes" xml:space="preserve">
          <source>The new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.</source>
          <target state="translated">새로운 ES6을 사용하면 두 개의 변수를 한 번에 할당 할 수 있습니다. 이것은 한 줄의 코드로 할 수 있기 때문에 두 변수의 값을 바꾸고 싶을 때 특히 유용합니다. 이 기능을 사용하는 동일한 기능의 짧은 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fed07e4940354c7a1e8ac12c85932a93dcc58c34" translate="yes" xml:space="preserve">
          <source>The problem is, JS can not coop on with big recursions. In this particular case you array size is limited with like 3000~7000 depending on your browser engine and some unknown facts.</source>
          <target state="translated">문제는 JS가 큰 재귀를 처리 할 수 ​​없다는 것입니다. 이 특정 경우 배열 크기는 브라우저 엔진 및 일부 알 수없는 사실에 따라 3000 ~ 7000과 같이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="fa07c8700123d14185fdff2c5baeb9dcd4c3901c" translate="yes" xml:space="preserve">
          <source>The reciprocal of the previous function (required for your own question) is below; it is intended to work with up to 16 elements; it returns the permutation of order &lt;em&gt;n&lt;/em&gt; of &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt;:</source>
          <target state="translated">이전 함수의 역수 (자신의 질문에 필요함)는 다음과 같습니다. 최대 16 개의 요소로 작업하도록되어 있습니다. &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt; 의 차수 &lt;em&gt;n&lt;/em&gt; 의 순열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c18f5c02b633fe05311d86bfbcfbc9d5c1ad7cd" translate="yes" xml:space="preserve">
          <source>The use of this algorithm is &lt;strong&gt;not recommended&lt;/strong&gt;, because it is &lt;strong&gt;inefficient&lt;/strong&gt; and &lt;strong&gt;strongly biased&lt;/strong&gt;; see comments. It is being left here for future reference, because the idea is not that rare.</source>
          <target state="translated">이 알고리즘은 &lt;strong&gt;비효율적&lt;/strong&gt; 이고 &lt;strong&gt;강력하게 편향되어&lt;/strong&gt; 있으므로 사용 &lt;strong&gt;하지 않는 것이 좋습니다&lt;/strong&gt; . 의견을 참조하십시오. 아이디어가 그렇게 드물지 않기 때문에 나중에 참조하기 위해 여기에 남겨두고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cacae56825070769eaf606992d6e807bd3cf8b" translate="yes" xml:space="preserve">
          <source>This clever exclusion swaps the picked element with the current one, then picks the next random element from the remainder, looping backwards for optimal efficiency, ensuring the random pick is simplified (it can always start at 0), and thereby skipping the final element.</source>
          <target state="translated">이 영리한 제외는 선택한 요소를 현재 요소와 교체 한 다음 나머지 요소에서 다음 임의 요소를 선택하여 최적의 효율성을 위해 뒤로 반복하여 임의 선택을 단순화하고 (항상 0에서 시작할 수 있음) 최종 요소를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="dd8a3223dfe4968add4c7e42201681618a84f0d4" translate="yes" xml:space="preserve">
          <source>Though there are a number of implementations already advised but I feel we can make it shorter and easier using forEach loop, so we don't need to worry about calculating array length and also we can safely avoid using a temporary variable.</source>
          <target state="translated">이미 많은 구현이 권장되었지만 forEach 루프를 사용하면 더 짧고 쉽게 만들 수 있다고 생각하므로 배열 길이 계산에 대해 걱정할 필요가 없으며 임시 변수 사용을 안전하게 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddaff04c667b8cad39e34a4186431500f596af0" translate="yes" xml:space="preserve">
          <source>Time complexity is O(N log N), same as quick sort. Space complexity is O(N). This is not as efficient as a Fischer Yates shuffle but, in my opinion, the code is significantly shorter and more functional. If you have a large array you should certainly use Fischer Yates. If you have a small array with a few hundred items, you might do this.</source>
          <target state="translated">시간 복잡도는 빠른 정렬과 마찬가지로 O (N log N)입니다. 공간 복잡도는 O (N)입니다. 이것은 Fischer Yates shuffle만큼 효율적이지 않지만 제 의견으로는 코드가 훨씬 짧고 기능적입니다. 배열이 큰 경우에는 Fischer Yates를 사용해야합니다. 수백 개의 항목이있는 작은 배열이있는 경우이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="3787f3835a2fd1f1bc17f81e0a5ee6c1516e0a37" translate="yes" xml:space="preserve">
          <source>Use the underscore.js library. The method &lt;code&gt;_.shuffle()&lt;/code&gt; is nice for this case.
Here is an example with the method:</source>
          <target state="translated">underscore.js 라이브러리를 사용하십시오. 이 경우 &lt;code&gt;_.shuffle()&lt;/code&gt; 메소드가 좋습니다. 다음은 그 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="e982465409324de04153cd5c52ee341a1e0c33f9" translate="yes" xml:space="preserve">
          <source>We put each element in the array in an object, and give it a random sort key</source>
          <target state="translated">배열의 각 요소를 객체에 넣고 임의 정렬 키를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37c9a8233642b266d81593dc8d16fee23c6ff921" translate="yes" xml:space="preserve">
          <source>We sort using the random key</source>
          <target state="translated">우리는 임의의 키를 사용하여 정렬</target>
        </trans-unit>
        <trans-unit id="d6afc2bcb349e90081d50a88919a7d7354197158" translate="yes" xml:space="preserve">
          <source>We unmap to get the original objects</source>
          <target state="translated">원래 객체를 얻기 위해 매핑을 해제합니다</target>
        </trans-unit>
        <trans-unit id="fa70411d3fe5f5f40d139c572f62e4cb144a088b" translate="yes" xml:space="preserve">
          <source>When computing with IEEE754 double precision floating numbers, you can expect your random generator to provide about 15 decimals. Since you have &lt;em&gt;15!=1,307,674,368,000&lt;/em&gt; (with 13 digits), you can use the following functions with arrays containing up to 15 elements and assume there will be no significant bias with arrays containing up to 14 elements. If you work on a fixed-size problem requiring to compute many times this shuffle operation, you may want to try the following code which &lt;em&gt;may&lt;/em&gt; be faster than other codes since it uses &lt;code&gt;Math.random&lt;/code&gt; only once (it involves several copy operations however).</source>
          <target state="translated">IEEE754 배정 밀도 부동 숫자로 계산할 때 임의 생성기가 약 15 진수를 제공 할 것으로 예상 할 수 있습니다. &lt;em&gt;15! = 1,307,674,368,000&lt;/em&gt; (13 자리 숫자)이 있으므로 최대 15 개의 요소를 포함하는 배열에 다음 함수를 사용할 수 있으며 최대 14 개의 요소를 포함하는 배열에는 큰 편향이 없다고 가정합니다. 이 셔플 연산을 여러 번 계산해야하는 고정 크기 문제에 대해 작업하는 &lt;em&gt;경우&lt;/em&gt; &lt;code&gt;Math.random&lt;/code&gt; 을 한 번만 사용하기 때문에 다른 코드보다 더 빠를 &lt;em&gt;수&lt;/em&gt; 있는 다음 코드를 시도 할 &lt;em&gt;수&lt;/em&gt; 있습니다 (여러 복사 작업이 포함됨).</target>
        </trans-unit>
        <trans-unit id="ac812b0a196ffcf1ada365b6be5a7c7f0f2c1ae9" translate="yes" xml:space="preserve">
          <source>With ES2015 you can use this one:</source>
          <target state="translated">ES2015를 사용하면 다음 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bda77affb36f55fffd0079cb167c23b57c503a1" translate="yes" xml:space="preserve">
          <source>You can do it easily with map and sort:</source>
          <target state="translated">맵과 정렬로 쉽게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bd7627872f884699658169c2436dcdecd7197ea" translate="yes" xml:space="preserve">
          <source>You can do it easily with:</source>
          <target state="translated">당신은 쉽게 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a7d34d88cd56ff8410463b8f789e7edda9d26b00" translate="yes" xml:space="preserve">
          <source>You can see a &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;great visualization here&lt;/a&gt; (and the original post &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;linked to this&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;여기&lt;/a&gt; 에서 훌륭한 시각화를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db43e778b685a829c5fa7d3b2857f1cbc7c9dfec" translate="yes" xml:space="preserve">
          <source>You can shuffle polymorphic arrays, and the sort is as random as Math.random, which is good enough for most purposes.</source>
          <target state="translated">다형성 배열을 섞을 수 있으며 정렬은 Math.random만큼 임의적이며 대부분의 목적에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="41f2e5a2df3900f50dd0bc1a1fd8b451e58f16da" translate="yes" xml:space="preserve">
          <source>[Comparison tests were done using &lt;code&gt;testShuffleArrayFun&lt;/code&gt; against other solutions, in Google Chrome]</source>
          <target state="translated">[Google 크롬의 다른 솔루션에 대해 &lt;code&gt;testShuffleArrayFun&lt;/code&gt; 을 사용하여 비교 테스트를 수행함 ]</target>
        </trans-unit>
        <trans-unit id="14236c02e628eaa55439674b94dfa1eec350021f" translate="yes" xml:space="preserve">
          <source>a shuffle function that doesn't change the source array</source>
          <target state="translated">소스 배열을 바꾸지 않는 셔플 기능</target>
        </trans-unit>
        <trans-unit id="66c531dd89d3a2bb546b62f5e8a08723322f6e1c" translate="yes" xml:space="preserve">
          <source>bitwise to floor (numbers up to 10 decimal digits (32bit))</source>
          <target state="translated">비트 단위부터 바닥까지 (십진수 10 자리 (32 비트)까지)</target>
        </trans-unit>
        <trans-unit id="d25e649970e6fdedcd9efdc5002ea1b93e971620" translate="yes" xml:space="preserve">
          <source>it uses while---</source>
          <target state="translated">그것은 동안 사용합니다 ---</target>
        </trans-unit>
        <trans-unit id="68340861fed2ccc0703bd6ad39a67953febe7878" translate="yes" xml:space="preserve">
          <source>removed unecessary closures &amp;amp; other stuff</source>
          <target state="translated">불필요한 폐쇄 및 기타 물건 제거</target>
        </trans-unit>
        <trans-unit id="a40e5dc89de6414f6b7c4790ca64ea34f10dcb3f" translate="yes" xml:space="preserve">
          <source>script size (with fy as function name): 90bytes</source>
          <target state="translated">스크립트 크기 (함수 이름으로 fy) : 90 바이트</target>
        </trans-unit>
        <trans-unit id="2d86563e6b1bdb64dd3a50cdf0529b14eae84135" translate="yes" xml:space="preserve">
          <source>shorter(4bytes)&amp;amp;faster(test it!).</source>
          <target state="translated">더 짧고 (4 바이트) 더 빠릅니다 (테스트 해보세요!).</target>
        </trans-unit>
        <trans-unit id="ab0874c3f73b2ecdaab7f1d46c567cffea1594bb" translate="yes" xml:space="preserve">
          <source>the shortest &lt;code&gt;arrayShuffle&lt;/code&gt; function</source>
          <target state="translated">가장 짧은 &lt;code&gt;arrayShuffle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55ee529bcb360882189f97174d46ceaad11eab66" translate="yes" xml:space="preserve">
          <source>using the top voted functions.</source>
          <target state="translated">최고 투표 기능 사용.</target>
        </trans-unit>
        <trans-unit id="63fbcfc569baf433216f5dc54bf2974616aa7d6c" translate="yes" xml:space="preserve">
          <source>yes it is faster</source>
          <target state="translated">네 빠릅니다</target>
        </trans-unit>
        <trans-unit id="f64996142b0f5ac8ca17c305fb58363a0af6ad3f" translate="yes" xml:space="preserve">
          <source>yet another implementation of Fisher-Yates, using strict mode:</source>
          <target state="translated">엄격 모드를 사용하는 Fisher-Yates의 또 다른 구현 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
