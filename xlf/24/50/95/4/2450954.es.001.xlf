<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2450954">
    <body>
      <group id="2450954">
        <trans-unit id="5b4de5962782bc4dba7619a5d62839da95307be6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; shuffle in javascript. I'm posting this here because the use of two utility functions (swap and randInt) clarifies the algorithm compared to the other answers here.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; baraja en javascript. Estoy publicando esto aqu&amp;iacute; porque el uso de dos funciones de utilidad (swap y randInt) aclara el algoritmo en comparaci&amp;oacute;n con las otras respuestas aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="6f72bfd2d0eaf3c52394f01b95e8da43b9dc6959" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Here's a jsfiddle showing it in use&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Aqu&amp;iacute; hay un jsfiddle que lo muestra en uso&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5936fd39163329c308f94ca03a104dbcbfc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random() - 0.5&lt;/code&gt; is a random number that may be positive or
  negative, so the sorting function reorders elements randomly.</source>
          <target state="translated">&lt;code&gt;Math.random() - 0.5&lt;/code&gt; es un n&amp;uacute;mero aleatorio que puede ser positivo o negativo, por lo que la funci&amp;oacute;n de clasificaci&amp;oacute;n reordena los elementos al azar.</target>
        </trans-unit>
        <trans-unit id="2c2961d2433bea415e1715c6b35944f5d33c907f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(for educational purposes)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(con fines educativos)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e26209b267ddcc3725cc70e5f78d02ae5945a0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*faster probably on all browsers except chrome.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;* probablemente m&amp;aacute;s r&amp;aacute;pido en todos los navegadores, excepto Chrome.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51bd7b31f0ce02507256038b5ff757141dd144ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EDIT:&lt;/em&gt; Updating to ES6 / ECMAScript 2015</source>
          <target state="translated">&lt;em&gt;EDITAR:&lt;/em&gt; Actualizaci&amp;oacute;n a ES6 / ECMAScript 2015</target>
        </trans-unit>
        <trans-unit id="8efaa9ada1da4cff6fcad7c371f1d42d0b400a3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Original answer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Respuesta original:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e8cccd85d7f62c7d24c722685e575057ebcd542" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shuffling logic&lt;/em&gt;: pick up a random index, then add the corresponding element to the &lt;em&gt;result array&lt;/em&gt; and delete it from the &lt;em&gt;source array copy&lt;/em&gt;. Repeat this action until the source array gets &lt;em&gt;empty&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;L&amp;oacute;gica aleatoria&lt;/em&gt; : seleccione un &amp;iacute;ndice aleatorio, luego agregue el elemento correspondiente a la &lt;em&gt;matriz de resultados&lt;/em&gt; y elim&amp;iacute;nelo de la &lt;em&gt;copia de la matriz de origen&lt;/em&gt; . Repita esta acci&amp;oacute;n hasta que la matriz de origen se &lt;em&gt;vac&amp;iacute;e&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="efb894bf2af625d5e7007fcadf92a7611c6daea0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt;: Here I'm suggesting a relatively &lt;strong&gt;simple&lt;/strong&gt; (not from &lt;em&gt;complexity&lt;/em&gt; perspective) and &lt;strong&gt;short&lt;/strong&gt; algorithm that will do just fine with small sized arrays, but it's definitely going to cost a lot more than the classic &lt;em&gt;Durstenfeld&lt;/em&gt; algorithm when you deal with huge arrays. You can find the &lt;em&gt;Durstenfeld&lt;/em&gt; in one of the top replies to this question.</source>
          <target state="translated">&lt;em&gt;Actualizaci&amp;oacute;n&lt;/em&gt; : Aqu&amp;iacute; estoy sugiriendo un algoritmo relativamente &lt;strong&gt;simple&lt;/strong&gt; (no desde una perspectiva de &lt;em&gt;complejidad&lt;/em&gt; ) y &lt;strong&gt;corto&lt;/strong&gt; que funcionar&amp;aacute; bien con matrices de peque&amp;ntilde;o tama&amp;ntilde;o, pero definitivamente va a costar mucho m&amp;aacute;s que el algoritmo cl&amp;aacute;sico de &lt;em&gt;Durstenfeld&lt;/em&gt; cuando se trata de matrices enormes. Puede encontrar el &lt;em&gt;Durstenfeld&lt;/em&gt; en una de las principales respuestas a esta pregunta.</target>
        </trans-unit>
        <trans-unit id="96b6fd7744ca19d4236a9277778b98f0def04eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dee253cdbadca71dde01a92342a8c21696a687fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt; 
There was a calculation in excess (don't need --c+1) &lt;em&gt;and noone noticed&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;EDITAR&lt;/strong&gt; Hubo un c&amp;aacute;lculo en exceso (no necesita --c + 1) &lt;em&gt;y nadie se dio cuenta&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d26d57bf090dbc8f995db9e4efe14b2f99fd8e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.map&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure usando array.map&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a963a20e28355edbebbcb98adcb09596e71f7ee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.reduce&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure usando array.reduce&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcbf09b9d5cdb75de80f70be8b7b663000db8c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Iterative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 puro, iterativo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cff150316022043341bac9d4f6efd812bc0091d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Recursive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 puro, recursivo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57d86292367c88ac6937c2d5f8b933e395d3768b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit: This answer is incorrect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Editar: esta respuesta es incorrecta&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7a1442dc364db9decbad3a8478fdd0d9216bda0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; The above code is O(n^2) due to the employment of &lt;code&gt;.splice()&lt;/code&gt; but we can eliminate splice and shuffle in O(n) by the swap trick.</source>
          <target state="translated">&lt;strong&gt;Editar:&lt;/strong&gt; El c&amp;oacute;digo anterior es O (n ^ 2) debido al empleo de &lt;code&gt;.splice()&lt;/code&gt; pero podemos eliminar el empalme y la mezcla en O (n) mediante el truco de intercambio.</target>
        </trans-unit>
        <trans-unit id="5d2b7cbc8216667f5c5cc93d5fbe14fd7b76925a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: as pointed out by @gregers, the compare function is called with values rather than indices, which is why you need to use &lt;code&gt;indexOf&lt;/code&gt;. Note that this change makes the code less suitable for larger arrays as &lt;code&gt;indexOf&lt;/code&gt; runs in O(n) time.</source>
          <target state="translated">&lt;strong&gt;Editar&lt;/strong&gt; : como se&amp;ntilde;al&amp;oacute; @gregers, la funci&amp;oacute;n de comparaci&amp;oacute;n se llama con valores en lugar de &amp;iacute;ndices, por lo que debe usar &lt;code&gt;indexOf&lt;/code&gt; . Tenga en cuenta que este cambio hace que el c&amp;oacute;digo sea menos adecuado para matrices m&amp;aacute;s grandes, ya que &lt;code&gt;indexOf&lt;/code&gt; se ejecuta en tiempo O (n).</target>
        </trans-unit>
        <trans-unit id="cd1897aa30d21aecd738588f517034caeeea8705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modern short inline solution using ES6 features:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n moderna en l&amp;iacute;nea corta que utiliza las funciones de ES6:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bcbf182d2c9f7baf0d1228ed1b2f3c14a66432c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d48760d5688f610b7bd932d6ce59fc0e830bb9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Readable version&lt;/strong&gt; (use the original version. this is slower, vars are useless, like the closures &amp;amp; &quot;;&quot;, the code itself is also shorter ... maybe read this &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;How to 'minify' Javascript code&lt;/a&gt; , btw you are not able to compress the following code in a javascript minifiers like the above one.)</source>
          <target state="translated">&lt;strong&gt;Versi&amp;oacute;n legible&lt;/strong&gt; (use la versi&amp;oacute;n original. Esto es m&amp;aacute;s lento, los vars son in&amp;uacute;tiles, como los cierres &amp;amp; &quot;;&quot;, el c&amp;oacute;digo en s&amp;iacute; tambi&amp;eacute;n es m&amp;aacute;s corto ... tal vez lea esto &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;C&amp;oacute;mo 'minificar' el c&amp;oacute;digo Javascript&lt;/a&gt; , por cierto no puede comprima el siguiente c&amp;oacute;digo en un minifier javascript como el anterior).</target>
        </trans-unit>
        <trans-unit id="1c4379a4d4426412c390aa432f8600adaf810b14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorter &amp;amp; probably *faster Fisher-Yates shuffle algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Algoritmo aleatorio Fisher-Yates m&amp;aacute;s corto y probablemente * m&amp;aacute;s r&amp;aacute;pido&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cd816d4d50b745090fe63c80545160ad88627b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shuffle Array In place&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Mezclar matriz en su lugar&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4fe6bb18531c0b16a4ac27e9d0bc5314577bf89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Speed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Speed&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba847e347088b75956742f58468d69a72e790bf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc572b1e8fa73691c1a2f268fe0819446c547699" translate="yes" xml:space="preserve">
          <source>A recursive solution:</source>
          <target state="translated">Una solución recursiva:</target>
        </trans-unit>
        <trans-unit id="d87908291510ce7aacbd6c9c630475506c98bfdb" translate="yes" xml:space="preserve">
          <source>A simple modification of CoolAJ86's &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;answer&lt;/a&gt; that does not modify the original array:</source>
          <target state="translated">Una modificaci&amp;oacute;n simple de la &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;respuesta&lt;/a&gt; de CoolAJ86 que no modifica la matriz original:</target>
        </trans-unit>
        <trans-unit id="293d042470d40411ccc70692c51d611ac7e7db1a" translate="yes" xml:space="preserve">
          <source>A very simple way for small arrays is simply this:</source>
          <target state="translated">Una forma muy simple para los conjuntos pequeños es simplemente esto:</target>
        </trans-unit>
        <trans-unit id="fd6c0330ee7aa8770c86a59555809d125e83952d" translate="yes" xml:space="preserve">
          <source>Actually random</source>
          <target state="translated">En realidad,al azar</target>
        </trans-unit>
        <trans-unit id="906af1739f79bc70c9973540b1aeaa064030d5be" translate="yes" xml:space="preserve">
          <source>Adding to @Laurens Holsts answer.  This is 50% compressed.</source>
          <target state="translated">Añadiendo a la respuesta de @Laurens Holsts.Esto está comprimido al 50%.</target>
        </trans-unit>
        <trans-unit id="6db86a3835a9089c53be7e4ab53e72e289b0e742" translate="yes" xml:space="preserve">
          <source>Algorithm runtime is &lt;code&gt;O(n)&lt;/code&gt;. &lt;strong&gt;Note&lt;/strong&gt; that the shuffle is done in-place so if you don't want to modify the original array, first make a copy of it with &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;&lt;code&gt;.slice(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tiempo de ejecuci&amp;oacute;n del algoritmo es &lt;code&gt;O(n)&lt;/code&gt; . &lt;strong&gt;Tenga en cuenta&lt;/strong&gt; que la combinaci&amp;oacute;n aleatoria se realiza in situ, por lo que si no desea modificar la matriz original, primero haga una copia con &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt; &lt;code&gt;.slice(0)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29deda6f213fd21db50fee872cbe7bd9a47fe007" translate="yes" xml:space="preserve">
          <source>All the other answers are based on Math.random() which is fast but not suitable for cryptgraphic level randomization.</source>
          <target state="translated">Todas las demás respuestas se basan en Math.random()que es rápido pero no adecuado para la aleatorización a nivel criptográfico.</target>
        </trans-unit>
        <trans-unit id="7924e36bb8b15e369e65d0080b8819419232c254" translate="yes" xml:space="preserve">
          <source>And if you really want it short, here's how far I could get:</source>
          <target state="translated">Y si realmente lo quieres corto,esto es lo más lejos que puedo llegar:</target>
        </trans-unit>
        <trans-unit id="5e7fae630e452b3fae47afe81da828d93b9f1443" translate="yes" xml:space="preserve">
          <source>As you can see in this page, there have been incorrect solutions offered here in the past. I wrote and have used the following function to test any pure (no side effects) array randomizing functions.</source>
          <target state="translated">Como pueden ver en esta página,ha habido soluciones incorrectas ofrecidas aquí en el pasado.Escribí y he usado la siguiente función para probar cualquier función de aleatorización de matriz pura (sin efectos secundarios).</target>
        </trans-unit>
        <trans-unit id="44707dcfe46333c094f687b61e202b216454bb97" translate="yes" xml:space="preserve">
          <source>Caching somewhere else &lt;code&gt;var rnd=Math.random&lt;/code&gt; and then use &lt;code&gt;rnd()&lt;/code&gt; would also increase slightly the performance on big arrays.</source>
          <target state="translated">El almacenamiento en cach&amp;eacute; en otro lugar &lt;code&gt;var rnd=Math.random&lt;/code&gt; y luego usar &lt;code&gt;rnd()&lt;/code&gt; tambi&amp;eacute;n aumentar&amp;iacute;a ligeramente el rendimiento en grandes matrices.</target>
        </trans-unit>
        <trans-unit id="c3cddda7fb17e16b2062db130bd1a65b7c0ef0c1" translate="yes" xml:space="preserve">
          <source>Edit: This answer is incorrect</source>
          <target state="translated">Editar:Esta respuesta es incorrecta</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="a42a5dd86e1515ccf60f677d0c43d4a244ec07a7" translate="yes" xml:space="preserve">
          <source>First of all, have a look &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;here&lt;/a&gt; for a great visual comparison of different sorting methods in javascript.</source>
          <target state="translated">En primer lugar, eche un vistazo &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; para ver una excelente comparaci&amp;oacute;n visual de diferentes m&amp;eacute;todos de clasificaci&amp;oacute;n en javascript.</target>
        </trans-unit>
        <trans-unit id="62cd1f392b8ea498402c5d176e812c491931cf19" translate="yes" xml:space="preserve">
          <source>From ChristopheD:</source>
          <target state="translated">De ChristopheD:</target>
        </trans-unit>
        <trans-unit id="119f5affc9b4bccbfa35a16ac979913a87667c1b" translate="yes" xml:space="preserve">
          <source>From a theoretical point of view, the most elegant way of doing it, in my humble opinion, is to get a &lt;em&gt;single&lt;/em&gt; random number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;n!-1&lt;/em&gt; and to compute a one to one mapping from &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; to all permutations of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt;. As long as you can use a (pseudo-)random generator reliable enough for getting such a number without any significant bias, you have enough information in it for achieving what you want without needing several other random numbers.</source>
          <target state="translated">Desde un punto de vista te&amp;oacute;rico, la forma m&amp;aacute;s elegante de hacerlo, en mi humilde opini&amp;oacute;n, es obtener un &lt;em&gt;&amp;uacute;nico&lt;/em&gt; n&amp;uacute;mero aleatorio entre &lt;em&gt;0&lt;/em&gt; y &lt;em&gt;n! -1&lt;/em&gt; y calcular un mapeo uno a uno desde &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; a todas las permutaciones de &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; . Siempre que pueda usar un generador (pseudo-) aleatorio lo suficientemente confiable como para obtener dicho n&amp;uacute;mero sin ning&amp;uacute;n sesgo significativo, tendr&amp;aacute; suficiente informaci&amp;oacute;n para lograr lo que desea sin necesidad de varios otros n&amp;uacute;meros aleatorios.</target>
        </trans-unit>
        <trans-unit id="490da622cd663c86273367e7042a11c19785eddb" translate="yes" xml:space="preserve">
          <source>Funny enough there was no non mutating recursive answer:</source>
          <target state="translated">Es curioso que no haya habido una respuesta recursiva no mutante:</target>
        </trans-unit>
        <trans-unit id="7985aa6e1818a6f446bbd8db04378dd6b08c7b4e" translate="yes" xml:space="preserve">
          <source>Here's a JavaScript implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt;, an optimized version of Fisher-Yates:</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n de JavaScript del &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt; , una versi&amp;oacute;n optimizada de Fisher-Yates:</target>
        </trans-unit>
        <trans-unit id="5c4a47a7bb2e4d4b06d049c2e910ebf3e74af15a" translate="yes" xml:space="preserve">
          <source>How can I randomize / shuffle it?</source>
          <target state="translated">¿Cómo puedo aleatorizarlo?</target>
        </trans-unit>
        <trans-unit id="4ab6a5b825f2780444712bcf5651612afe7a0f32" translate="yes" xml:space="preserve">
          <source>How to randomize (shuffle) a JavaScript array</source>
          <target state="translated">Cómo aleatorizar (barajar)un arreglo de JavaScript</target>
        </trans-unit>
        <trans-unit id="8e003d8524a462a0f826612e31e2fe8a771ebcae" translate="yes" xml:space="preserve">
          <source>I found this variant hanging out in the &quot;deleted by author&quot; answers on a duplicate of this question. Unlike some of the other answers that have many upvotes already, this is:</source>
          <target state="translated">Encontré esta variante colgando en las respuestas &quot;borradas por el autor&quot; en un duplicado de esta pregunta.A diferencia de algunas de las otras respuestas que ya tienen muchos votos a favor,esta es:</target>
        </trans-unit>
        <trans-unit id="e49480fdbe90571097565eed3fe6b5f973ebd696" translate="yes" xml:space="preserve">
          <source>I have an array like this:</source>
          <target state="translated">Tengo un arreglo como este:</target>
        </trans-unit>
        <trans-unit id="9d0a31eb8f7a7f14043dca0cebb8a6b62db867b9" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;don't wish&lt;/em&gt; your shuffle function to mutate the &lt;strong&gt;source array&lt;/strong&gt;, you can copy it to a local variable, then do the rest with a simple &lt;em&gt;shuffling logic&lt;/em&gt;.</source>
          <target state="translated">Si &lt;em&gt;no desea que&lt;/em&gt; su funci&amp;oacute;n aleatoria mute la &lt;strong&gt;matriz fuente&lt;/strong&gt; , puede copiarla en una variable local y luego hacer el resto con una simple &lt;em&gt;l&amp;oacute;gica aleatoria&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36a607745abf0fb5784e3061c8c5b90b7f5e372c" translate="yes" xml:space="preserve">
          <source>If you have any questions just ask.</source>
          <target state="translated">Si tienes alguna pregunta,sólo hazla.</target>
        </trans-unit>
        <trans-unit id="151bf418710eddce1cf0effa70940dbec87d44fa" translate="yes" xml:space="preserve">
          <source>It picks a random element for each original array element, and excludes it from the next draw, like picking randomly from a deck of cards.</source>
          <target state="translated">Elige un elemento al azar para cada elemento de la matriz original,y lo excluye del próximo sorteo,como si lo eligiera al azar de una baraja de cartas.</target>
        </trans-unit>
        <trans-unit id="87535ca09b0d3d83bbb3da0becfd0a4d6503a7b4" translate="yes" xml:space="preserve">
          <source>It should work for up to 16 elements with a little theoretical bias (though unnoticeable from a practical point of view); it can be seen as fully usable for 15 elements; with arrays containing less than 14 elements, you can safely consider there will be absolutely no bias.</source>
          <target state="translated">Debería funcionar para hasta 16 elementos con un poco de sesgo teórico (aunque imperceptible desde el punto de vista práctico);se puede considerar totalmente utilizable para 15 elementos;con matrices que contengan menos de 14 elementos,se puede considerar con seguridad que no habrá absolutamente ningún sesgo.</target>
        </trans-unit>
        <trans-unit id="1430642f79d43cc2db87a235c3474e0af8edb038" translate="yes" xml:space="preserve">
          <source>It's probably not very efficient, but for small arrays this works just fine. Here's an example so you can see how random (or not) it is, and whether it fits your usecase or not.</source>
          <target state="translated">Probablemente no sea muy eficiente,pero para conjuntos pequeños esto funciona muy bien.Aquí hay un ejemplo para que puedas ver lo aleatorio (o no)que es,y si se ajusta a tu caso de uso o no.</target>
        </trans-unit>
        <trans-unit id="b21d4f8d057efae539ed23ef586ac940cdd1ce22" translate="yes" xml:space="preserve">
          <source>Just to have a finger in the pie. Here i present a recursive implementation of Fisher Yates shuffle (i think). It gives uniform randomness.</source>
          <target state="translated">Sólo para tener un dedo en el pastel.Aquí presento una implementación recursiva del barajado de Fisher Yates (creo).Da una aleatoriedad uniforme.</target>
        </trans-unit>
        <trans-unit id="de5caf69e6bd2f9be2350f47acc50e9839bf6aad" translate="yes" xml:space="preserve">
          <source>NEW!</source>
          <target state="translated">NEW!</target>
        </trans-unit>
        <trans-unit id="5bf4a9cc98b9cf85df301bd0ac8de42aec0caec7" translate="yes" xml:space="preserve">
          <source>Not already present here with multiple variants</source>
          <target state="translated">No está ya presente aquí con múltiples variantes</target>
        </trans-unit>
        <trans-unit id="d5afcead952a7a1a1617786d3878a9d67d4f1cad" translate="yes" xml:space="preserve">
          <source>Not in-place (hence the &lt;code&gt;shuffled&lt;/code&gt; name rather than &lt;code&gt;shuffle&lt;/code&gt;)</source>
          <target state="translated">No en el lugar (de ah&amp;iacute; el nombre &lt;code&gt;shuffle&lt;/code&gt; lugar de aleatorio )</target>
        </trans-unit>
        <trans-unit id="59c22528b1553e334b98831cb29d93e9c242a6bb" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;~~&lt;/code&gt; (double tilde operator) is in fact behaves like &lt;code&gt;Math.floor()&lt;/code&gt; for positive real numbers. Just a short cut it is.</source>
          <target state="translated">Nota: El &lt;code&gt;~~&lt;/code&gt; (operador de doble tilde) de hecho se comporta como &lt;code&gt;Math.floor()&lt;/code&gt; para n&amp;uacute;meros reales positivos. Solo un atajo es.</target>
        </trans-unit>
        <trans-unit id="281343a71cbc74da1fa9ae9cb60112499481dee5" translate="yes" xml:space="preserve">
          <source>Now, what you want merely is:</source>
          <target state="translated">Ahora,lo que quieres simplemente es:</target>
        </trans-unit>
        <trans-unit id="05a30fe28c0384a67145436f9b19385d61c2a7f3" translate="yes" xml:space="preserve">
          <source>One could (or should) use it as a protoype from Array:</source>
          <target state="translated">Se podría (o debería)usar como un prototipo de Array:</target>
        </trans-unit>
        <trans-unit id="02a48c36f8633f74bcf21915df7e57e9aacfd49e" translate="yes" xml:space="preserve">
          <source>Other Solutions</source>
          <target state="translated">Otras soluciones</target>
        </trans-unit>
        <trans-unit id="0f41147bbe611ff022208da6476ba7ea02349389" translate="yes" xml:space="preserve">
          <source>Other solutions just for fun.</source>
          <target state="translated">Otras soluciones sólo por diversión.</target>
        </trans-unit>
        <trans-unit id="187d5329025b3a25d74d96c670d7f926ba1230b1" translate="yes" xml:space="preserve">
          <source>Please reference at &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Sorting Arrays&lt;/a&gt;</source>
          <target state="translated">Por favor, consulte en &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript ordenando matrices&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e68a97c48d4bacb3f09e61dd50a7e19926ed9853" translate="yes" xml:space="preserve">
          <source>Reliability and Performance Test</source>
          <target state="translated">Prueba de fiabilidad y rendimiento</target>
        </trans-unit>
        <trans-unit id="157d6201b2ac3fe0ab015a60e32bbeec8276f242" translate="yes" xml:space="preserve">
          <source>Reliable, Effecient, Short</source>
          <target state="translated">Confiable,eficiente,corto</target>
        </trans-unit>
        <trans-unit id="f535eb18ddbb2f6d8f98f7d768521dca2bef7bcd" translate="yes" xml:space="preserve">
          <source>Secondly, if you have a quick look at the link above you'll find that the &lt;code&gt;random order&lt;/code&gt; sort seems to perform relatively well compared to the other methods, while being extremely easy and fast to implement as shown below:</source>
          <target state="translated">En segundo lugar, si echas un vistazo r&amp;aacute;pido al enlace de arriba, ver&amp;aacute;s que el &lt;code&gt;random order&lt;/code&gt; parece funcionar relativamente bien en comparaci&amp;oacute;n con los otros m&amp;eacute;todos, mientras que es extremadamente f&amp;aacute;cil y r&amp;aacute;pido de implementar como se muestra a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e73ef6160dacf45888e9f4cf8013bc207bf467fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</source>
          <target state="translated">Ver &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="376cd4a087bf2a3f30e26253860cff0979202d0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">Ver &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt; . Se deja aqu&amp;iacute; como referencia porque la idea no es rara.</target>
        </trans-unit>
        <trans-unit id="972dfa82e5e7596b3e5d296e882e60afb7f81205" translate="yes" xml:space="preserve">
          <source>See comments and &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">Ver comentarios y &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt; . Se deja aqu&amp;iacute; como referencia porque la idea no es rara.</target>
        </trans-unit>
        <trans-unit id="98bd03b500f02811b64f750f8b4a4138b59dec79" translate="yes" xml:space="preserve">
          <source>Since the elements are sorted against consistent keys that are not regenerated each iteration, and each comparison pulls from the same distribution, any non-randomness in the distribution of Math.random is canceled out.</source>
          <target state="translated">Dado que los elementos se clasifican con claves consistentes que no se regeneran en cada iteración,y que cada comparación procede de la misma distribución,cualquier falta de aleatoriedad en la distribución de Math.random queda anulada.</target>
        </trans-unit>
        <trans-unit id="16b7ffe2af3bc450e245042dd9946320c60307b2" translate="yes" xml:space="preserve">
          <source>Some more info &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;about the algorithm&lt;/a&gt; used.</source>
          <target state="translated">M&amp;aacute;s informaci&amp;oacute;n &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;sobre el algoritmo&lt;/a&gt; utilizado.</target>
        </trans-unit>
        <trans-unit id="81f118136d9e225898d71bda98047702661efe4d" translate="yes" xml:space="preserve">
          <source>Some solutions on this page aren't reliable (they only partially randomise the array). Other solutions are significantly less effecient. With &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (see below) we can test array shuffling functions for reliability and performance. 
The following solutions are: reliable, effecient and short (using ES6 syntax)</source>
          <target state="translated">Algunas soluciones en esta p&amp;aacute;gina no son confiables (solo aleatorizan parcialmente la matriz). Otras soluciones son significativamente menos eficientes. Con &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (ver m&amp;aacute;s abajo) podemos probar las funciones de combinaci&amp;oacute;n aleatoria de la matriz para garantizar la fiabilidad y el rendimiento. Las siguientes soluciones son: confiables, eficientes y cortas (usando la sintaxis ES6)</target>
        </trans-unit>
        <trans-unit id="a8a53b3371544e4c20126e1c9e3349051905705d" translate="yes" xml:space="preserve">
          <source>The below code is using the well known &lt;code&gt;Fisher-Yates&lt;/code&gt; algorithm while utilizing &lt;code&gt;Web Cryptography API&lt;/code&gt; for &lt;strong&gt;cryptographic level of randomization&lt;/strong&gt;.</source>
          <target state="translated">El siguiente c&amp;oacute;digo utiliza el conocido algoritmo &lt;code&gt;Fisher-Yates&lt;/code&gt; mientras utiliza la &lt;code&gt;Web Cryptography API&lt;/code&gt; de &lt;strong&gt;criptograf&amp;iacute;a&lt;/strong&gt; web para el &lt;strong&gt;nivel criptogr&amp;aacute;fico de aleatorizaci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="61fbaa8f9450f0cf39662d39a156aa2bd1444d47" translate="yes" xml:space="preserve">
          <source>The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.</source>
          <target state="translated">El algoritmo de barajar sin prejuicios es el barajado Fisher-Yates (alias Knuth).</target>
        </trans-unit>
        <trans-unit id="249b6e44421a088f52be0945aad986d2df59977f" translate="yes" xml:space="preserve">
          <source>The following function will not be used, but I give it anyway; it returns the index of a given permutation of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; according to the one to one mapping used in this message (the most natural one when enumerating permuations); it is intended to work with up to 16 elements:</source>
          <target state="translated">La siguiente funci&amp;oacute;n no se utilizar&amp;aacute;, pero la doy de todos modos; devuelve el &amp;iacute;ndice de una permutaci&amp;oacute;n dada de &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; acuerdo con el mapeo uno a uno utilizado en este mensaje (el m&amp;aacute;s natural al enumerar permutaciones); Est&amp;aacute; dise&amp;ntilde;ado para trabajar con hasta 16 elementos:</target>
        </trans-unit>
        <trans-unit id="b1dc2fb3b4532b7fa4c34753dd7c2f6ed847862a" translate="yes" xml:space="preserve">
          <source>The new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.</source>
          <target state="translated">El nuevo ES6 nos permite asignar dos variables a la vez.Esto es especialmente útil cuando queremos intercambiar los valores de dos variables,ya que podemos hacerlo en una línea de código.Aquí hay una forma más corta de la misma función,usando esta característica.</target>
        </trans-unit>
        <trans-unit id="fed07e4940354c7a1e8ac12c85932a93dcc58c34" translate="yes" xml:space="preserve">
          <source>The problem is, JS can not coop on with big recursions. In this particular case you array size is limited with like 3000~7000 depending on your browser engine and some unknown facts.</source>
          <target state="translated">El problema es que JS no puede cooperar con grandes recurrencias.En este caso en particular el tamaño de la matriz está limitado con unos 3000~7000 dependiendo del motor de tu navegador y algunos datos desconocidos.</target>
        </trans-unit>
        <trans-unit id="fa07c8700123d14185fdff2c5baeb9dcd4c3901c" translate="yes" xml:space="preserve">
          <source>The reciprocal of the previous function (required for your own question) is below; it is intended to work with up to 16 elements; it returns the permutation of order &lt;em&gt;n&lt;/em&gt; of &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt;:</source>
          <target state="translated">El rec&amp;iacute;proco de la funci&amp;oacute;n anterior (requerido para su propia pregunta) est&amp;aacute; abajo; est&amp;aacute; dise&amp;ntilde;ado para trabajar con hasta 16 elementos; devuelve la permutaci&amp;oacute;n de orden &lt;em&gt;n&lt;/em&gt; de &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5c18f5c02b633fe05311d86bfbcfbc9d5c1ad7cd" translate="yes" xml:space="preserve">
          <source>The use of this algorithm is &lt;strong&gt;not recommended&lt;/strong&gt;, because it is &lt;strong&gt;inefficient&lt;/strong&gt; and &lt;strong&gt;strongly biased&lt;/strong&gt;; see comments. It is being left here for future reference, because the idea is not that rare.</source>
          <target state="translated">No se recomienda el uso de este algoritmo, ya que es &lt;strong&gt;ineficiente&lt;/strong&gt; y &lt;strong&gt;muy sesgado&lt;/strong&gt; ; ver comentarios. Se deja aqu&amp;iacute; para referencia futura, porque la idea no es tan rara.</target>
        </trans-unit>
        <trans-unit id="f0cacae56825070769eaf606992d6e807bd3cf8b" translate="yes" xml:space="preserve">
          <source>This clever exclusion swaps the picked element with the current one, then picks the next random element from the remainder, looping backwards for optimal efficiency, ensuring the random pick is simplified (it can always start at 0), and thereby skipping the final element.</source>
          <target state="translated">Esta inteligente exclusión intercambia el elemento elegido con el actual,y luego elige el siguiente elemento aleatorio del resto,haciendo un bucle hacia atrás para una eficiencia óptima,asegurando que la elección aleatoria se simplifique (siempre puede comenzar en 0),y por lo tanto saltándose el elemento final.</target>
        </trans-unit>
        <trans-unit id="dd8a3223dfe4968add4c7e42201681618a84f0d4" translate="yes" xml:space="preserve">
          <source>Though there are a number of implementations already advised but I feel we can make it shorter and easier using forEach loop, so we don't need to worry about calculating array length and also we can safely avoid using a temporary variable.</source>
          <target state="translated">Aunque ya se han aconsejado varias implementaciones pero creo que podemos hacerlo más corto y fácil usando para cada bucle,así que no tenemos que preocuparnos de calcular la longitud de la matriz y también podemos evitar con seguridad el uso de una variable temporal.</target>
        </trans-unit>
        <trans-unit id="0ddaff04c667b8cad39e34a4186431500f596af0" translate="yes" xml:space="preserve">
          <source>Time complexity is O(N log N), same as quick sort. Space complexity is O(N). This is not as efficient as a Fischer Yates shuffle but, in my opinion, the code is significantly shorter and more functional. If you have a large array you should certainly use Fischer Yates. If you have a small array with a few hundred items, you might do this.</source>
          <target state="translated">La complejidad del tiempo es O(N log N),igual que la clasificación rápida.La complejidad espacial es O(N).Esto no es tan eficiente como una barajadura de Fischer Yates pero,en mi opinión,el código es significativamente más corto y más funcional.Si tienes un gran conjunto,ciertamente deberías usar Fischer Yates.Si tienes una pequeña matriz con unos pocos cientos de elementos,podrías hacer esto.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="3787f3835a2fd1f1bc17f81e0a5ee6c1516e0a37" translate="yes" xml:space="preserve">
          <source>Use the underscore.js library. The method &lt;code&gt;_.shuffle()&lt;/code&gt; is nice for this case.
Here is an example with the method:</source>
          <target state="translated">Use la biblioteca underscore.js. El m&amp;eacute;todo &lt;code&gt;_.shuffle()&lt;/code&gt; es bueno para este caso. Aqu&amp;iacute; hay un ejemplo con el m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="e982465409324de04153cd5c52ee341a1e0c33f9" translate="yes" xml:space="preserve">
          <source>We put each element in the array in an object, and give it a random sort key</source>
          <target state="translated">Ponemos cada elemento de la matriz en un objeto,y le damos una clave de clasificación aleatoria</target>
        </trans-unit>
        <trans-unit id="37c9a8233642b266d81593dc8d16fee23c6ff921" translate="yes" xml:space="preserve">
          <source>We sort using the random key</source>
          <target state="translated">Clasificamos usando la clave aleatoria</target>
        </trans-unit>
        <trans-unit id="d6afc2bcb349e90081d50a88919a7d7354197158" translate="yes" xml:space="preserve">
          <source>We unmap to get the original objects</source>
          <target state="translated">Descartamos el mapa para obtener los objetos originales</target>
        </trans-unit>
        <trans-unit id="fa70411d3fe5f5f40d139c572f62e4cb144a088b" translate="yes" xml:space="preserve">
          <source>When computing with IEEE754 double precision floating numbers, you can expect your random generator to provide about 15 decimals. Since you have &lt;em&gt;15!=1,307,674,368,000&lt;/em&gt; (with 13 digits), you can use the following functions with arrays containing up to 15 elements and assume there will be no significant bias with arrays containing up to 14 elements. If you work on a fixed-size problem requiring to compute many times this shuffle operation, you may want to try the following code which &lt;em&gt;may&lt;/em&gt; be faster than other codes since it uses &lt;code&gt;Math.random&lt;/code&gt; only once (it involves several copy operations however).</source>
          <target state="translated">Al calcular con n&amp;uacute;meros flotantes de precisi&amp;oacute;n doble IEEE754, puede esperar que su generador aleatorio proporcione aproximadamente 15 decimales. Como tiene &lt;em&gt;15! = 1,307,674,368,000&lt;/em&gt; (con 13 d&amp;iacute;gitos), puede usar las siguientes funciones con matrices que contienen hasta 15 elementos y asumir que no habr&amp;aacute; sesgo significativo con matrices que contengan hasta 14 elementos. Si trabaja en un problema de tama&amp;ntilde;o fijo que requiere calcular muchas veces esta operaci&amp;oacute;n aleatoria, es posible que desee probar el siguiente c&amp;oacute;digo, que &lt;em&gt;puede&lt;/em&gt; ser m&amp;aacute;s r&amp;aacute;pido que otros c&amp;oacute;digos ya que usa &lt;code&gt;Math.random&lt;/code&gt; solo una vez (sin embargo, implica varias operaciones de copia).</target>
        </trans-unit>
        <trans-unit id="ac812b0a196ffcf1ada365b6be5a7c7f0f2c1ae9" translate="yes" xml:space="preserve">
          <source>With ES2015 you can use this one:</source>
          <target state="translated">Con ES2015 puedes usar este:</target>
        </trans-unit>
        <trans-unit id="9bda77affb36f55fffd0079cb167c23b57c503a1" translate="yes" xml:space="preserve">
          <source>You can do it easily with map and sort:</source>
          <target state="translated">Puedes hacerlo fácilmente con el mapa y la clasificación:</target>
        </trans-unit>
        <trans-unit id="0bd7627872f884699658169c2436dcdecd7197ea" translate="yes" xml:space="preserve">
          <source>You can do it easily with:</source>
          <target state="translated">Puedes hacerlo fácilmente con:</target>
        </trans-unit>
        <trans-unit id="a7d34d88cd56ff8410463b8f789e7edda9d26b00" translate="yes" xml:space="preserve">
          <source>You can see a &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;great visualization here&lt;/a&gt; (and the original post &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;linked to this&lt;/a&gt;)</source>
          <target state="translated">Puedes ver una &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;gran visualizaci&amp;oacute;n aqu&amp;iacute;&lt;/a&gt; (y la publicaci&amp;oacute;n original &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;vinculada a esto&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="db43e778b685a829c5fa7d3b2857f1cbc7c9dfec" translate="yes" xml:space="preserve">
          <source>You can shuffle polymorphic arrays, and the sort is as random as Math.random, which is good enough for most purposes.</source>
          <target state="translated">Puedes mezclar matrices polimórficas,y el tipo es tan aleatorio como las matemáticas,lo que es suficiente para la mayoría de los propósitos.</target>
        </trans-unit>
        <trans-unit id="41f2e5a2df3900f50dd0bc1a1fd8b451e58f16da" translate="yes" xml:space="preserve">
          <source>[Comparison tests were done using &lt;code&gt;testShuffleArrayFun&lt;/code&gt; against other solutions, in Google Chrome]</source>
          <target state="translated">[Las pruebas de comparaci&amp;oacute;n se realizaron usando &lt;code&gt;testShuffleArrayFun&lt;/code&gt; contra otras soluciones, en Google Chrome]</target>
        </trans-unit>
        <trans-unit id="14236c02e628eaa55439674b94dfa1eec350021f" translate="yes" xml:space="preserve">
          <source>a shuffle function that doesn't change the source array</source>
          <target state="translated">una función de barajado que no cambia el conjunto de la fuente</target>
        </trans-unit>
        <trans-unit id="66c531dd89d3a2bb546b62f5e8a08723322f6e1c" translate="yes" xml:space="preserve">
          <source>bitwise to floor (numbers up to 10 decimal digits (32bit))</source>
          <target state="translated">bitwise al suelo (números de hasta 10 dígitos decimales (32bit))</target>
        </trans-unit>
        <trans-unit id="d25e649970e6fdedcd9efdc5002ea1b93e971620" translate="yes" xml:space="preserve">
          <source>it uses while---</source>
          <target state="translated">que usa mientras...</target>
        </trans-unit>
        <trans-unit id="68340861fed2ccc0703bd6ad39a67953febe7878" translate="yes" xml:space="preserve">
          <source>removed unecessary closures &amp;amp; other stuff</source>
          <target state="translated">se eliminaron cierres innecesarios y otras cosas</target>
        </trans-unit>
        <trans-unit id="a40e5dc89de6414f6b7c4790ca64ea34f10dcb3f" translate="yes" xml:space="preserve">
          <source>script size (with fy as function name): 90bytes</source>
          <target state="translated">Tamaño del guión (con fy como nombre de la función):90 bytes</target>
        </trans-unit>
        <trans-unit id="2d86563e6b1bdb64dd3a50cdf0529b14eae84135" translate="yes" xml:space="preserve">
          <source>shorter(4bytes)&amp;amp;faster(test it!).</source>
          <target state="translated">m&amp;aacute;s corto (4bytes) y m&amp;aacute;s r&amp;aacute;pido (&amp;iexcl;pru&amp;eacute;balo!).</target>
        </trans-unit>
        <trans-unit id="ab0874c3f73b2ecdaab7f1d46c567cffea1594bb" translate="yes" xml:space="preserve">
          <source>the shortest &lt;code&gt;arrayShuffle&lt;/code&gt; function</source>
          <target state="translated">la funci&amp;oacute;n &lt;code&gt;arrayShuffle&lt;/code&gt; m&amp;aacute;s corta</target>
        </trans-unit>
        <trans-unit id="55ee529bcb360882189f97174d46ceaad11eab66" translate="yes" xml:space="preserve">
          <source>using the top voted functions.</source>
          <target state="translated">usando las funciones más votadas.</target>
        </trans-unit>
        <trans-unit id="63fbcfc569baf433216f5dc54bf2974616aa7d6c" translate="yes" xml:space="preserve">
          <source>yes it is faster</source>
          <target state="translated">Sí,es más rápido.</target>
        </trans-unit>
        <trans-unit id="f64996142b0f5ac8ca17c305fb58363a0af6ad3f" translate="yes" xml:space="preserve">
          <source>yet another implementation of Fisher-Yates, using strict mode:</source>
          <target state="translated">otra implementación de Fisher-Yates,usando el modo estricto:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
