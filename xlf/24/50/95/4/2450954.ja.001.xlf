<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2450954">
    <body>
      <group id="2450954">
        <trans-unit id="5b4de5962782bc4dba7619a5d62839da95307be6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; shuffle in javascript. I'm posting this here because the use of two utility functions (swap and randInt) clarifies the algorithm compared to the other answers here.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;フィッシャーイェーツ&lt;/a&gt;がJavaScriptでシャッフルします。 2つのユーティリティ関数（swapとrandInt）を使用すると、ここで他の回答と比較してアルゴリズムが明確になるため、これをここに投稿します。</target>
        </trans-unit>
        <trans-unit id="6f72bfd2d0eaf3c52394f01b95e8da43b9dc6959" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Here's a jsfiddle showing it in use&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;これが使用中のjsfiddle&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="7a5936fd39163329c308f94ca03a104dbcbfc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random() - 0.5&lt;/code&gt; is a random number that may be positive or
  negative, so the sorting function reorders elements randomly.</source>
          <target state="translated">&lt;code&gt;Math.random() - 0.5&lt;/code&gt; は正または負の乱数なので、並べ替え関数は要素をランダムに並べ替えます。</target>
        </trans-unit>
        <trans-unit id="2c2961d2433bea415e1715c6b35944f5d33c907f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(for educational purposes)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（教育目的のため）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e26209b267ddcc3725cc70e5f78d02ae5945a0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*faster probably on all browsers except chrome.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*おそらくクロムを除くすべてのブラウザでより高速です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51bd7b31f0ce02507256038b5ff757141dd144ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EDIT:&lt;/em&gt; Updating to ES6 / ECMAScript 2015</source>
          <target state="translated">&lt;em&gt;編集：&lt;/em&gt; ES6 / ECMAScript 2015への更新</target>
        </trans-unit>
        <trans-unit id="8efaa9ada1da4cff6fcad7c371f1d42d0b400a3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Original answer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;元の答え：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e8cccd85d7f62c7d24c722685e575057ebcd542" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shuffling logic&lt;/em&gt;: pick up a random index, then add the corresponding element to the &lt;em&gt;result array&lt;/em&gt; and delete it from the &lt;em&gt;source array copy&lt;/em&gt;. Repeat this action until the source array gets &lt;em&gt;empty&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;シャッフルロジック&lt;/em&gt; ：ランダムなインデックスを&lt;em&gt;取得し&lt;/em&gt; 、対応する要素を&lt;em&gt;結果の配列に&lt;/em&gt;追加して、 &lt;em&gt;ソース配列のコピー&lt;/em&gt;から削除し&lt;em&gt;ます&lt;/em&gt; 。 ソースアレイが&lt;em&gt;空に&lt;/em&gt;なるまで、このアクションを繰り返し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="efb894bf2af625d5e7007fcadf92a7611c6daea0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt;: Here I'm suggesting a relatively &lt;strong&gt;simple&lt;/strong&gt; (not from &lt;em&gt;complexity&lt;/em&gt; perspective) and &lt;strong&gt;short&lt;/strong&gt; algorithm that will do just fine with small sized arrays, but it's definitely going to cost a lot more than the classic &lt;em&gt;Durstenfeld&lt;/em&gt; algorithm when you deal with huge arrays. You can find the &lt;em&gt;Durstenfeld&lt;/em&gt; in one of the top replies to this question.</source>
          <target state="translated">&lt;em&gt;更新&lt;/em&gt; ：ここでは、比較的&lt;strong&gt;単純な&lt;/strong&gt; （ &lt;em&gt;複雑さの&lt;/em&gt;観点からではなく） &lt;strong&gt;短い&lt;/strong&gt;アルゴリズムを提案し&lt;em&gt;ます&lt;/em&gt; 。このアルゴリズムは、サイズの小さい配列で&lt;em&gt;うまく&lt;/em&gt;機能しますが、巨大な配列を扱う場合は、従来の&lt;em&gt;Durstenfeld&lt;/em&gt;アルゴリズムよりも&lt;em&gt;明らか&lt;/em&gt;にコストが高くなります。 &lt;em&gt;Durstenfeld&lt;/em&gt;は、この質問に対する上位の回答の1つにあります。</target>
        </trans-unit>
        <trans-unit id="96b6fd7744ca19d4236a9277778b98f0def04eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dee253cdbadca71dde01a92342a8c21696a687fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt; 
There was a calculation in excess (don't need --c+1) &lt;em&gt;and noone noticed&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;編集&lt;/strong&gt;過剰な計算があり（--c + 1は必要ありません） &lt;em&gt;、&lt;/em&gt;誰も気づきませんでし&lt;em&gt;た&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d26d57bf090dbc8f995db9e4efe14b2f99fd8e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.map&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array.mapを使用したES6 Pure&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a963a20e28355edbebbcb98adcb09596e71f7ee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.reduce&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array.reduceを使用したES6 Pure&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcbf09b9d5cdb75de80f70be8b7b663000db8c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Iterative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6純粋、反復&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cff150316022043341bac9d4f6efd812bc0091d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Recursive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6純粋、再帰的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57d86292367c88ac6937c2d5f8b933e395d3768b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit: This answer is incorrect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集：この答えは正しくありません&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7a1442dc364db9decbad3a8478fdd0d9216bda0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; The above code is O(n^2) due to the employment of &lt;code&gt;.splice()&lt;/code&gt; but we can eliminate splice and shuffle in O(n) by the swap trick.</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt; &lt;code&gt;.splice()&lt;/code&gt; を使用しているため、上記のコードはO（n ^ 2 ）ですが、スワップトリックによってO（n）のスプライスとシャッフルを排除できます。</target>
        </trans-unit>
        <trans-unit id="5d2b7cbc8216667f5c5cc93d5fbe14fd7b76925a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: as pointed out by @gregers, the compare function is called with values rather than indices, which is why you need to use &lt;code&gt;indexOf&lt;/code&gt;. Note that this change makes the code less suitable for larger arrays as &lt;code&gt;indexOf&lt;/code&gt; runs in O(n) time.</source>
          <target state="translated">&lt;strong&gt;編集&lt;/strong&gt; ：@gregersで指摘されているように、compare関数はインデックスではなく値で呼び出されます。そのため、 &lt;code&gt;indexOf&lt;/code&gt; を使用する必要があります。 この変更により、 &lt;code&gt;indexOf&lt;/code&gt; がO（n）時間で実行されるため、コードが大きな配列に適さなくなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd1897aa30d21aecd738588f517034caeeea8705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modern short inline solution using ES6 features:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6機能を使用した最新の短いインラインソリューション：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bcbf182d2c9f7baf0d1228ed1b2f3c14a66432c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d48760d5688f610b7bd932d6ce59fc0e830bb9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Readable version&lt;/strong&gt; (use the original version. this is slower, vars are useless, like the closures &amp;amp; &quot;;&quot;, the code itself is also shorter ... maybe read this &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;How to 'minify' Javascript code&lt;/a&gt; , btw you are not able to compress the following code in a javascript minifiers like the above one.)</source>
          <target state="translated">&lt;strong&gt;読み取り可能なバージョン&lt;/strong&gt; （元のバージョンを使用してください。これは遅く、varsは役に立たないので、クロージャ＆ &quot;;&quot;のように、コード自体も短くなっています...多分これを読んでください&lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;Javascriptコードを「縮小」する方法&lt;/a&gt;次のコードを上記のようなJavaScriptミニファイアで圧縮します。）</target>
        </trans-unit>
        <trans-unit id="1c4379a4d4426412c390aa432f8600adaf810b14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorter &amp;amp; probably *faster Fisher-Yates shuffle algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;より短く、おそらく*より速いフィッシャーイェイツのシャッフルアルゴリズム&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cd816d4d50b745090fe63c80545160ad88627b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shuffle Array In place&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;配列をシャッフルする&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4fe6bb18531c0b16a4ac27e9d0bc5314577bf89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Speed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Speed&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba847e347088b75956742f58468d69a72e790bf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc572b1e8fa73691c1a2f268fe0819446c547699" translate="yes" xml:space="preserve">
          <source>A recursive solution:</source>
          <target state="translated">再帰的な解決策。</target>
        </trans-unit>
        <trans-unit id="d87908291510ce7aacbd6c9c630475506c98bfdb" translate="yes" xml:space="preserve">
          <source>A simple modification of CoolAJ86's &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;answer&lt;/a&gt; that does not modify the original array:</source>
          <target state="translated">元の配列を変更しないCoolAJ86の&lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;回答の&lt;/a&gt;簡単な変更：</target>
        </trans-unit>
        <trans-unit id="293d042470d40411ccc70692c51d611ac7e7db1a" translate="yes" xml:space="preserve">
          <source>A very simple way for small arrays is simply this:</source>
          <target state="translated">小さな配列のための非常にシンプルな方法は、これだけです。</target>
        </trans-unit>
        <trans-unit id="fd6c0330ee7aa8770c86a59555809d125e83952d" translate="yes" xml:space="preserve">
          <source>Actually random</source>
          <target state="translated">実際にはランダム</target>
        </trans-unit>
        <trans-unit id="906af1739f79bc70c9973540b1aeaa064030d5be" translate="yes" xml:space="preserve">
          <source>Adding to @Laurens Holsts answer.  This is 50% compressed.</source>
          <target state="translated">@Laurens Holstsの回答に追加します。これは50%圧縮されています。</target>
        </trans-unit>
        <trans-unit id="6db86a3835a9089c53be7e4ab53e72e289b0e742" translate="yes" xml:space="preserve">
          <source>Algorithm runtime is &lt;code&gt;O(n)&lt;/code&gt;. &lt;strong&gt;Note&lt;/strong&gt; that the shuffle is done in-place so if you don't want to modify the original array, first make a copy of it with &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;&lt;code&gt;.slice(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">アルゴリズムのランタイムは &lt;code&gt;O(n)&lt;/code&gt; です。 シャッフルはインプレースで行われるため、元の配列を変更したくない場合は、最初に&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt; &lt;code&gt;.slice(0)&lt;/code&gt; &lt;/a&gt;を使用してその配列をコピーしてください 。</target>
        </trans-unit>
        <trans-unit id="29deda6f213fd21db50fee872cbe7bd9a47fe007" translate="yes" xml:space="preserve">
          <source>All the other answers are based on Math.random() which is fast but not suitable for cryptgraphic level randomization.</source>
          <target state="translated">他の回答はすべてMath.random()に基づいていますが、これは高速ですが、暗号レベルのランダム化には適していません。</target>
        </trans-unit>
        <trans-unit id="7924e36bb8b15e369e65d0080b8819419232c254" translate="yes" xml:space="preserve">
          <source>And if you really want it short, here's how far I could get:</source>
          <target state="translated">どうしても短くしたいならここまでにしてくれ</target>
        </trans-unit>
        <trans-unit id="5e7fae630e452b3fae47afe81da828d93b9f1443" translate="yes" xml:space="preserve">
          <source>As you can see in this page, there have been incorrect solutions offered here in the past. I wrote and have used the following function to test any pure (no side effects) array randomizing functions.</source>
          <target state="translated">このページにあるように、過去にここで提供された不正確な解答がありました。私は以下の関数を書いて、純粋な(副作用のない)配列ランダム化関数をテストするために使用したことがあります。</target>
        </trans-unit>
        <trans-unit id="44707dcfe46333c094f687b61e202b216454bb97" translate="yes" xml:space="preserve">
          <source>Caching somewhere else &lt;code&gt;var rnd=Math.random&lt;/code&gt; and then use &lt;code&gt;rnd()&lt;/code&gt; would also increase slightly the performance on big arrays.</source>
          <target state="translated">&lt;code&gt;var rnd=Math.random&lt;/code&gt; を他の場所にキャッシュしてから &lt;code&gt;rnd()&lt;/code&gt; を使用すると、大きな配列のパフォーマンスがわずかに向上します。</target>
        </trans-unit>
        <trans-unit id="c3cddda7fb17e16b2062db130bd1a65b7c0ef0c1" translate="yes" xml:space="preserve">
          <source>Edit: This answer is incorrect</source>
          <target state="translated">編集:この答えは間違っています</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="a42a5dd86e1515ccf60f677d0c43d4a244ec07a7" translate="yes" xml:space="preserve">
          <source>First of all, have a look &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;here&lt;/a&gt; for a great visual comparison of different sorting methods in javascript.</source>
          <target state="translated">まず、JavaScriptでのさまざまな並べ替え方法の視覚的な比較について、 &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;こちら&lt;/a&gt;をご覧ください 。</target>
        </trans-unit>
        <trans-unit id="62cd1f392b8ea498402c5d176e812c491931cf19" translate="yes" xml:space="preserve">
          <source>From ChristopheD:</source>
          <target state="translated">ChristopheDさんより</target>
        </trans-unit>
        <trans-unit id="119f5affc9b4bccbfa35a16ac979913a87667c1b" translate="yes" xml:space="preserve">
          <source>From a theoretical point of view, the most elegant way of doing it, in my humble opinion, is to get a &lt;em&gt;single&lt;/em&gt; random number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;n!-1&lt;/em&gt; and to compute a one to one mapping from &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; to all permutations of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt;. As long as you can use a (pseudo-)random generator reliable enough for getting such a number without any significant bias, you have enough information in it for achieving what you want without needing several other random numbers.</source>
          <target state="translated">理論的な観点から見ると、私の考えでは、最もエレガントな方法は、 &lt;em&gt;0&lt;/em&gt;と&lt;em&gt;n！-1の&lt;/em&gt;間の&lt;em&gt;単一の&lt;/em&gt;乱数を取得し、 &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; から1対1のマッピングを計算することです。 n！-1}を &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; すべての順列に。 （疑似）乱数発生器を使用して、大きなバイアスなしにそのような数値を取得するのに十分な信頼性がある限り、他のいくつかの乱数を必要とせずに目的を達成するための十分な情報があります。</target>
        </trans-unit>
        <trans-unit id="490da622cd663c86273367e7042a11c19785eddb" translate="yes" xml:space="preserve">
          <source>Funny enough there was no non mutating recursive answer:</source>
          <target state="translated">おかしなことに、非変異再帰的な答えはありませんでした。</target>
        </trans-unit>
        <trans-unit id="7985aa6e1818a6f446bbd8db04378dd6b08c7b4e" translate="yes" xml:space="preserve">
          <source>Here's a JavaScript implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt;, an optimized version of Fisher-Yates:</source>
          <target state="translated">以下は、Fisher-Yatesの最適化バージョンである&lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffleの&lt;/a&gt; JavaScript実装です。</target>
        </trans-unit>
        <trans-unit id="5c4a47a7bb2e4d4b06d049c2e910ebf3e74af15a" translate="yes" xml:space="preserve">
          <source>How can I randomize / shuffle it?</source>
          <target state="translated">ランダムにシャッフルするにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="4ab6a5b825f2780444712bcf5651612afe7a0f32" translate="yes" xml:space="preserve">
          <source>How to randomize (shuffle) a JavaScript array</source>
          <target state="translated">JavaScriptの配列をランダム化(シャッフル)する方法</target>
        </trans-unit>
        <trans-unit id="8e003d8524a462a0f826612e31e2fe8a771ebcae" translate="yes" xml:space="preserve">
          <source>I found this variant hanging out in the &quot;deleted by author&quot; answers on a duplicate of this question. Unlike some of the other answers that have many upvotes already, this is:</source>
          <target state="translated">私はこの質問の重複で「著者によって削除された」回答の中にこの変種がぶら下がっているのを見つけました。すでに多くのアップボイスを持っている他の回答のいくつかとは異なり、これは</target>
        </trans-unit>
        <trans-unit id="e49480fdbe90571097565eed3fe6b5f973ebd696" translate="yes" xml:space="preserve">
          <source>I have an array like this:</source>
          <target state="translated">こんな感じの配列を持っています。</target>
        </trans-unit>
        <trans-unit id="9d0a31eb8f7a7f14043dca0cebb8a6b62db867b9" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;don't wish&lt;/em&gt; your shuffle function to mutate the &lt;strong&gt;source array&lt;/strong&gt;, you can copy it to a local variable, then do the rest with a simple &lt;em&gt;shuffling logic&lt;/em&gt;.</source>
          <target state="translated">シャッフル関数で&lt;strong&gt;ソース配列&lt;/strong&gt;を変更&lt;em&gt;したくない&lt;/em&gt;場合は、それをローカル変数にコピーしてから、残りを単純な&lt;em&gt;シャッフルロジック&lt;/em&gt;で実行できます。</target>
        </trans-unit>
        <trans-unit id="36a607745abf0fb5784e3061c8c5b90b7f5e372c" translate="yes" xml:space="preserve">
          <source>If you have any questions just ask.</source>
          <target state="translated">何か質問があれば聞いてみてください。</target>
        </trans-unit>
        <trans-unit id="151bf418710eddce1cf0effa70940dbec87d44fa" translate="yes" xml:space="preserve">
          <source>It picks a random element for each original array element, and excludes it from the next draw, like picking randomly from a deck of cards.</source>
          <target state="translated">元の配列要素ごとにランダムな要素をピックし、カードの山札からランダムにピックするように、次のドローから除外します。</target>
        </trans-unit>
        <trans-unit id="87535ca09b0d3d83bbb3da0becfd0a4d6503a7b4" translate="yes" xml:space="preserve">
          <source>It should work for up to 16 elements with a little theoretical bias (though unnoticeable from a practical point of view); it can be seen as fully usable for 15 elements; with arrays containing less than 14 elements, you can safely consider there will be absolutely no bias.</source>
          <target state="translated">理論的には多少の偏りはありますが(実用的な観点からは気付かれませんが)、16要素までは動作するはずです;15要素では完全に使用可能と見ることができます;14要素以下の配列では、偏りは全くないと考えることができます。</target>
        </trans-unit>
        <trans-unit id="1430642f79d43cc2db87a235c3474e0af8edb038" translate="yes" xml:space="preserve">
          <source>It's probably not very efficient, but for small arrays this works just fine. Here's an example so you can see how random (or not) it is, and whether it fits your usecase or not.</source>
          <target state="translated">おそらくあまり効率的ではないでしょうが、小さな配列の場合はこれで十分です。ここに例を示しますので、どの程度のランダム性があるのか(あるいはないのか)、あなたの用途に合っているのかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="b21d4f8d057efae539ed23ef586ac940cdd1ce22" translate="yes" xml:space="preserve">
          <source>Just to have a finger in the pie. Here i present a recursive implementation of Fisher Yates shuffle (i think). It gives uniform randomness.</source>
          <target state="translated">パイの中に指を入れるだけです。ここでは、フィッシャー・イェーツ・シャッフルの再帰的な実装を紹介する(と思う)。これは一様なランダム性を与える。</target>
        </trans-unit>
        <trans-unit id="de5caf69e6bd2f9be2350f47acc50e9839bf6aad" translate="yes" xml:space="preserve">
          <source>NEW!</source>
          <target state="translated">NEW!</target>
        </trans-unit>
        <trans-unit id="5bf4a9cc98b9cf85df301bd0ac8de42aec0caec7" translate="yes" xml:space="preserve">
          <source>Not already present here with multiple variants</source>
          <target state="translated">複数のバリエーションでここには存在しない</target>
        </trans-unit>
        <trans-unit id="d5afcead952a7a1a1617786d3878a9d67d4f1cad" translate="yes" xml:space="preserve">
          <source>Not in-place (hence the &lt;code&gt;shuffled&lt;/code&gt; name rather than &lt;code&gt;shuffle&lt;/code&gt;)</source>
          <target state="translated">インプレースではない（したがって、 &lt;code&gt;shuffled&lt;/code&gt; ではなくシャッフルされた名前）</target>
        </trans-unit>
        <trans-unit id="59c22528b1553e334b98831cb29d93e9c242a6bb" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;~~&lt;/code&gt; (double tilde operator) is in fact behaves like &lt;code&gt;Math.floor()&lt;/code&gt; for positive real numbers. Just a short cut it is.</source>
          <target state="translated">注： &lt;code&gt;~~&lt;/code&gt; （二重チルド演算子）は、実際には正の実数に対して &lt;code&gt;Math.floor()&lt;/code&gt; のように動作します。 ちょうどそれがショートカットです。</target>
        </trans-unit>
        <trans-unit id="281343a71cbc74da1fa9ae9cb60112499481dee5" translate="yes" xml:space="preserve">
          <source>Now, what you want merely is:</source>
          <target state="translated">さて、あなたが望むものは、単にそれだけです。</target>
        </trans-unit>
        <trans-unit id="05a30fe28c0384a67145436f9b19385d61c2a7f3" translate="yes" xml:space="preserve">
          <source>One could (or should) use it as a protoype from Array:</source>
          <target state="translated">これをArrayのプロトタイプとして使用することができる(あるいは使用すべき)。</target>
        </trans-unit>
        <trans-unit id="02a48c36f8633f74bcf21915df7e57e9aacfd49e" translate="yes" xml:space="preserve">
          <source>Other Solutions</source>
          <target state="translated">その他のソリューション</target>
        </trans-unit>
        <trans-unit id="0f41147bbe611ff022208da6476ba7ea02349389" translate="yes" xml:space="preserve">
          <source>Other solutions just for fun.</source>
          <target state="translated">その他の解決策は遊びのためだけに。</target>
        </trans-unit>
        <trans-unit id="187d5329025b3a25d74d96c670d7f926ba1230b1" translate="yes" xml:space="preserve">
          <source>Please reference at &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Sorting Arrays&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Sorting Arraysで&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="e68a97c48d4bacb3f09e61dd50a7e19926ed9853" translate="yes" xml:space="preserve">
          <source>Reliability and Performance Test</source>
          <target state="translated">信頼性・性能試験</target>
        </trans-unit>
        <trans-unit id="157d6201b2ac3fe0ab015a60e32bbeec8276f242" translate="yes" xml:space="preserve">
          <source>Reliable, Effecient, Short</source>
          <target state="translated">信頼性の高い、便利な、短い</target>
        </trans-unit>
        <trans-unit id="f535eb18ddbb2f6d8f98f7d768521dca2bef7bcd" translate="yes" xml:space="preserve">
          <source>Secondly, if you have a quick look at the link above you'll find that the &lt;code&gt;random order&lt;/code&gt; sort seems to perform relatively well compared to the other methods, while being extremely easy and fast to implement as shown below:</source>
          <target state="translated">次に、上のリンクをざっと見てみると、 &lt;code&gt;random order&lt;/code&gt; 並べ替えは他のメソッドと比べて比較的うまく機能しているように見えますが、以下に示すように実装は非常に簡単で高速です。</target>
        </trans-unit>
        <trans-unit id="e73ef6160dacf45888e9f4cf8013bc207bf467fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffleを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="376cd4a087bf2a3f30e26253860cff0979202d0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234を&lt;/a&gt;参照してください 。 このアイデアは珍しいものではないので、参照用にここに残しています。</target>
        </trans-unit>
        <trans-unit id="972dfa82e5e7596b3e5d296e882e60afb7f81205" translate="yes" xml:space="preserve">
          <source>See comments and &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">コメントと&lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234を&lt;/a&gt;参照してください 。 このアイデアは珍しいものではないので、参照用にここに残しています。</target>
        </trans-unit>
        <trans-unit id="98bd03b500f02811b64f750f8b4a4138b59dec79" translate="yes" xml:space="preserve">
          <source>Since the elements are sorted against consistent keys that are not regenerated each iteration, and each comparison pulls from the same distribution, any non-randomness in the distribution of Math.random is canceled out.</source>
          <target state="translated">要素は、各反復ごとに再生成されない一貫したキーに対してソートされ、各比較は同じ分布から引き出されるので、Math.random の分布における非ランダム性はすべて打ち消されます。</target>
        </trans-unit>
        <trans-unit id="16b7ffe2af3bc450e245042dd9946320c60307b2" translate="yes" xml:space="preserve">
          <source>Some more info &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;about the algorithm&lt;/a&gt; used.</source>
          <target state="translated">使用され&lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;ているアルゴリズムについての&lt;/a&gt;詳細。</target>
        </trans-unit>
        <trans-unit id="81f118136d9e225898d71bda98047702661efe4d" translate="yes" xml:space="preserve">
          <source>Some solutions on this page aren't reliable (they only partially randomise the array). Other solutions are significantly less effecient. With &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (see below) we can test array shuffling functions for reliability and performance. 
The following solutions are: reliable, effecient and short (using ES6 syntax)</source>
          <target state="translated">このページの一部のソリューションは信頼できません（アレイを部分的にランダム化するだけです）。 その他のソリューションは、効率が大幅に低下します。 &lt;code&gt;testShuffleArrayFun&lt;/code&gt; （下記参照）を使用して、配列シャッフル関数の信頼性とパフォーマンスをテストできます。 次のソリューションは、信頼性が高く、効率的で、短いものです（ES6構文を使用）。</target>
        </trans-unit>
        <trans-unit id="a8a53b3371544e4c20126e1c9e3349051905705d" translate="yes" xml:space="preserve">
          <source>The below code is using the well known &lt;code&gt;Fisher-Yates&lt;/code&gt; algorithm while utilizing &lt;code&gt;Web Cryptography API&lt;/code&gt; for &lt;strong&gt;cryptographic level of randomization&lt;/strong&gt;.</source>
          <target state="translated">以下のコードは、 &lt;strong&gt;暗号化レベルのランダム化に&lt;/strong&gt; &lt;code&gt;Web Cryptography API&lt;/code&gt; を利用しながら、よく知られている &lt;code&gt;Fisher-Yates&lt;/code&gt; アルゴリズムを使用しています 。</target>
        </trans-unit>
        <trans-unit id="61fbaa8f9450f0cf39662d39a156aa2bd1444d47" translate="yes" xml:space="preserve">
          <source>The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.</source>
          <target state="translated">非事実上の不偏不党のシャッフルアルゴリズムは、Fisher-Yates (別名 Knuth)Shuffleです。</target>
        </trans-unit>
        <trans-unit id="249b6e44421a088f52be0945aad986d2df59977f" translate="yes" xml:space="preserve">
          <source>The following function will not be used, but I give it anyway; it returns the index of a given permutation of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; according to the one to one mapping used in this message (the most natural one when enumerating permuations); it is intended to work with up to 16 elements:</source>
          <target state="translated">次の関数は使用しませんが、とにかく与えます。 このメッセージで使用されている1対1のマッピング（順列を列挙するときに最も自然なもの &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; に従って、（0、1、2、&amp;hellip;、n-1）の所定の順列のインデックスを返します。 最大16個の要素を処理することを目的としています。</target>
        </trans-unit>
        <trans-unit id="b1dc2fb3b4532b7fa4c34753dd7c2f6ed847862a" translate="yes" xml:space="preserve">
          <source>The new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.</source>
          <target state="translated">新しいES6では、2つの変数を一度に代入できるようになりました。これは特に、2つの変数の値を入れ替えたいときに便利です。以下に、この機能を使った同じ関数の短い形式を示します。</target>
        </trans-unit>
        <trans-unit id="fed07e4940354c7a1e8ac12c85932a93dcc58c34" translate="yes" xml:space="preserve">
          <source>The problem is, JS can not coop on with big recursions. In this particular case you array size is limited with like 3000~7000 depending on your browser engine and some unknown facts.</source>
          <target state="translated">問題は、JS は大きな再帰との連携ができないことです。この場合、ブラウザのエンジンや未知の事実にもよりますが、配列のサイズは3000~7000程度に制限されています。</target>
        </trans-unit>
        <trans-unit id="fa07c8700123d14185fdff2c5baeb9dcd4c3901c" translate="yes" xml:space="preserve">
          <source>The reciprocal of the previous function (required for your own question) is below; it is intended to work with up to 16 elements; it returns the permutation of order &lt;em&gt;n&lt;/em&gt; of &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt;:</source>
          <target state="translated">前の関数の逆数（独自の質問に必要）は以下のとおりです。 最大16個の要素を処理することを目的としています。 &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt; の次数&lt;em&gt;n&lt;/em&gt;の順列を返します。</target>
        </trans-unit>
        <trans-unit id="5c18f5c02b633fe05311d86bfbcfbc9d5c1ad7cd" translate="yes" xml:space="preserve">
          <source>The use of this algorithm is &lt;strong&gt;not recommended&lt;/strong&gt;, because it is &lt;strong&gt;inefficient&lt;/strong&gt; and &lt;strong&gt;strongly biased&lt;/strong&gt;; see comments. It is being left here for future reference, because the idea is not that rare.</source>
          <target state="translated">このアルゴリズムの使用は&lt;strong&gt;非効率&lt;/strong&gt;で&lt;strong&gt;強くバイアスされる&lt;/strong&gt;ため、 &lt;strong&gt;お勧めできません&lt;/strong&gt; 。 コメントを参照してください。 このアイデアはそれほど珍しいものではないので、今後の参考のためにここに残しています。</target>
        </trans-unit>
        <trans-unit id="f0cacae56825070769eaf606992d6e807bd3cf8b" translate="yes" xml:space="preserve">
          <source>This clever exclusion swaps the picked element with the current one, then picks the next random element from the remainder, looping backwards for optimal efficiency, ensuring the random pick is simplified (it can always start at 0), and thereby skipping the final element.</source>
          <target state="translated">この巧妙な除外は、ピックされた要素を現在のものと入れ替え、残りの要素から次のランダムな要素をピックし、最適な効率を得るために逆方向にループします。</target>
        </trans-unit>
        <trans-unit id="dd8a3223dfe4968add4c7e42201681618a84f0d4" translate="yes" xml:space="preserve">
          <source>Though there are a number of implementations already advised but I feel we can make it shorter and easier using forEach loop, so we don't need to worry about calculating array length and also we can safely avoid using a temporary variable.</source>
          <target state="translated">すでにいくつかの実装がアドバイスされていますが、forEachループを使うことで、配列の長さを計算する必要がなくなり、一時変数を使わずに済むようになりました。</target>
        </trans-unit>
        <trans-unit id="0ddaff04c667b8cad39e34a4186431500f596af0" translate="yes" xml:space="preserve">
          <source>Time complexity is O(N log N), same as quick sort. Space complexity is O(N). This is not as efficient as a Fischer Yates shuffle but, in my opinion, the code is significantly shorter and more functional. If you have a large array you should certainly use Fischer Yates. If you have a small array with a few hundred items, you might do this.</source>
          <target state="translated">時間的な複雑さはクイックソートと同じO(N log N)です。空間の複雑さはO(N)です。これはFischer Yatesシャッフルほど効率的ではありませんが、私の考えでは、コードはかなり短く、より機能的です。大きな配列を持つ場合は、Fischer Yatesを使うべきです。数百項目の小さな配列であれば、これを使うとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="3787f3835a2fd1f1bc17f81e0a5ee6c1516e0a37" translate="yes" xml:space="preserve">
          <source>Use the underscore.js library. The method &lt;code&gt;_.shuffle()&lt;/code&gt; is nice for this case.
Here is an example with the method:</source>
          <target state="translated">underscore.jsライブラリーを使用します。 この場合、メソッド &lt;code&gt;_.shuffle()&lt;/code&gt; が適しています。 メソッドの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="e982465409324de04153cd5c52ee341a1e0c33f9" translate="yes" xml:space="preserve">
          <source>We put each element in the array in an object, and give it a random sort key</source>
          <target state="translated">配列の各要素をオブジェクトに入れ、ランダムなソートキーを与えます。</target>
        </trans-unit>
        <trans-unit id="37c9a8233642b266d81593dc8d16fee23c6ff921" translate="yes" xml:space="preserve">
          <source>We sort using the random key</source>
          <target state="translated">ランダムキーを使ってソートします</target>
        </trans-unit>
        <trans-unit id="d6afc2bcb349e90081d50a88919a7d7354197158" translate="yes" xml:space="preserve">
          <source>We unmap to get the original objects</source>
          <target state="translated">元のオブジェクトを取得するためにマップを解除します。</target>
        </trans-unit>
        <trans-unit id="fa70411d3fe5f5f40d139c572f62e4cb144a088b" translate="yes" xml:space="preserve">
          <source>When computing with IEEE754 double precision floating numbers, you can expect your random generator to provide about 15 decimals. Since you have &lt;em&gt;15!=1,307,674,368,000&lt;/em&gt; (with 13 digits), you can use the following functions with arrays containing up to 15 elements and assume there will be no significant bias with arrays containing up to 14 elements. If you work on a fixed-size problem requiring to compute many times this shuffle operation, you may want to try the following code which &lt;em&gt;may&lt;/em&gt; be faster than other codes since it uses &lt;code&gt;Math.random&lt;/code&gt; only once (it involves several copy operations however).</source>
          <target state="translated">IEEE754倍精度浮動小数点数で計算する場合、ランダムジェネレーターが約15の10進数を提供することを期待できます。 &lt;em&gt;15！= 1,307,674,368,000&lt;/em&gt; （13桁）があるので、最大15の要素を含む配列で次の関数を使用でき、最大14の要素を含む配列で大きなバイアスがないと想定できます。 このシャッフル操作を何度も計算する必要がある固定サイズの問題に取り組む場合、 &lt;code&gt;Math.random&lt;/code&gt; を 1回しか使用しないため、他のコードよりも高速な次のコードを試す&lt;em&gt;こと&lt;/em&gt;が&lt;em&gt;でき&lt;/em&gt;ます（ただし、いくつかのコピー操作が含まれます）。</target>
        </trans-unit>
        <trans-unit id="ac812b0a196ffcf1ada365b6be5a7c7f0f2c1ae9" translate="yes" xml:space="preserve">
          <source>With ES2015 you can use this one:</source>
          <target state="translated">ES2015があればこれを使えます。</target>
        </trans-unit>
        <trans-unit id="9bda77affb36f55fffd0079cb167c23b57c503a1" translate="yes" xml:space="preserve">
          <source>You can do it easily with map and sort:</source>
          <target state="translated">地図とソートで簡単にできます。</target>
        </trans-unit>
        <trans-unit id="0bd7627872f884699658169c2436dcdecd7197ea" translate="yes" xml:space="preserve">
          <source>You can do it easily with:</source>
          <target state="translated">で簡単にできます。</target>
        </trans-unit>
        <trans-unit id="a7d34d88cd56ff8410463b8f789e7edda9d26b00" translate="yes" xml:space="preserve">
          <source>You can see a &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;great visualization here&lt;/a&gt; (and the original post &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;linked to this&lt;/a&gt;)</source>
          <target state="translated">あなたは&lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;ここで素晴らしい視覚化&lt;/a&gt;を見ることができます （そして&lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;これにリンクされ&lt;/a&gt;た元の投稿）</target>
        </trans-unit>
        <trans-unit id="db43e778b685a829c5fa7d3b2857f1cbc7c9dfec" translate="yes" xml:space="preserve">
          <source>You can shuffle polymorphic arrays, and the sort is as random as Math.random, which is good enough for most purposes.</source>
          <target state="translated">多相配列をシャッフルすることができ、ソートはMath.randomと同じようにランダムで、ほとんどの目的にはこれで十分です。</target>
        </trans-unit>
        <trans-unit id="41f2e5a2df3900f50dd0bc1a1fd8b451e58f16da" translate="yes" xml:space="preserve">
          <source>[Comparison tests were done using &lt;code&gt;testShuffleArrayFun&lt;/code&gt; against other solutions, in Google Chrome]</source>
          <target state="translated">[Google Chromeで他のソリューションに対して &lt;code&gt;testShuffleArrayFun&lt;/code&gt; を使用して比較テストが行​​われました]</target>
        </trans-unit>
        <trans-unit id="14236c02e628eaa55439674b94dfa1eec350021f" translate="yes" xml:space="preserve">
          <source>a shuffle function that doesn't change the source array</source>
          <target state="translated">ソース配列を変更しないシャッフル関数</target>
        </trans-unit>
        <trans-unit id="66c531dd89d3a2bb546b62f5e8a08723322f6e1c" translate="yes" xml:space="preserve">
          <source>bitwise to floor (numbers up to 10 decimal digits (32bit))</source>
          <target state="translated">ビットからフロアへ(10進数10桁までの数値(32ビット</target>
        </trans-unit>
        <trans-unit id="d25e649970e6fdedcd9efdc5002ea1b93e971620" translate="yes" xml:space="preserve">
          <source>it uses while---</source>
          <target state="translated">使っているうちに</target>
        </trans-unit>
        <trans-unit id="68340861fed2ccc0703bd6ad39a67953febe7878" translate="yes" xml:space="preserve">
          <source>removed unecessary closures &amp;amp; other stuff</source>
          <target state="translated">不要な閉鎖やその他のものを削除</target>
        </trans-unit>
        <trans-unit id="a40e5dc89de6414f6b7c4790ca64ea34f10dcb3f" translate="yes" xml:space="preserve">
          <source>script size (with fy as function name): 90bytes</source>
          <target state="translated">スクリプトサイズ(関数名にfyを使用):90バイト</target>
        </trans-unit>
        <trans-unit id="2d86563e6b1bdb64dd3a50cdf0529b14eae84135" translate="yes" xml:space="preserve">
          <source>shorter(4bytes)&amp;amp;faster(test it!).</source>
          <target state="translated">短い（4バイト）＆速い（それをテストしてください！）。</target>
        </trans-unit>
        <trans-unit id="ab0874c3f73b2ecdaab7f1d46c567cffea1594bb" translate="yes" xml:space="preserve">
          <source>the shortest &lt;code&gt;arrayShuffle&lt;/code&gt; function</source>
          <target state="translated">最短の &lt;code&gt;arrayShuffle&lt;/code&gt; 関数</target>
        </trans-unit>
        <trans-unit id="55ee529bcb360882189f97174d46ceaad11eab66" translate="yes" xml:space="preserve">
          <source>using the top voted functions.</source>
          <target state="translated">上位投票で選ばれた機能を使って</target>
        </trans-unit>
        <trans-unit id="63fbcfc569baf433216f5dc54bf2974616aa7d6c" translate="yes" xml:space="preserve">
          <source>yes it is faster</source>
          <target state="translated">それはそうとして</target>
        </trans-unit>
        <trans-unit id="f64996142b0f5ac8ca17c305fb58363a0af6ad3f" translate="yes" xml:space="preserve">
          <source>yet another implementation of Fisher-Yates, using strict mode:</source>
          <target state="translated">厳密なモードを使用したフィッシャー・イェーツのもう一つの実装です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
