<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2450954">
    <body>
      <group id="2450954">
        <trans-unit id="5b4de5962782bc4dba7619a5d62839da95307be6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt; shuffle in javascript. I'm posting this here because the use of two utility functions (swap and randInt) clarifies the algorithm compared to the other answers here.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&quot;&gt;Fisher-Yates&lt;/a&gt;在javascript中随机播放。 我将其发布在这里是因为与此处的其他答案相比，使用两个实用程序功能（交换和randInt）使算法更清晰。</target>
        </trans-unit>
        <trans-unit id="6f72bfd2d0eaf3c52394f01b95e8da43b9dc6959" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;Here's a jsfiddle showing it in use&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/fmjL1eyL/&quot;&gt;这是一个使用中的jsfiddle&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a5936fd39163329c308f94ca03a104dbcbfc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Math.random() - 0.5&lt;/code&gt; is a random number that may be positive or
  negative, so the sorting function reorders elements randomly.</source>
          <target state="translated">&lt;code&gt;Math.random() - 0.5&lt;/code&gt; 是一个随机数，可以是正数或负数，因此排序功能会随机对元素进行重新排序。</target>
        </trans-unit>
        <trans-unit id="2c2961d2433bea415e1715c6b35944f5d33c907f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(for educational purposes)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（出于教育目的）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e26209b267ddcc3725cc70e5f78d02ae5945a0c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;*faster probably on all browsers except chrome.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;*在chrome以外的所有浏览器上可能更快。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51bd7b31f0ce02507256038b5ff757141dd144ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EDIT:&lt;/em&gt; Updating to ES6 / ECMAScript 2015</source>
          <target state="translated">&lt;em&gt;编辑：&lt;/em&gt;更新到ES6 / ECMAScript 2015</target>
        </trans-unit>
        <trans-unit id="8efaa9ada1da4cff6fcad7c371f1d42d0b400a3c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Original answer:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;原始答案：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5e8cccd85d7f62c7d24c722685e575057ebcd542" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shuffling logic&lt;/em&gt;: pick up a random index, then add the corresponding element to the &lt;em&gt;result array&lt;/em&gt; and delete it from the &lt;em&gt;source array copy&lt;/em&gt;. Repeat this action until the source array gets &lt;em&gt;empty&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;改组逻辑&lt;/em&gt; ：选择一个随机索引，然后将相应的元素添加到&lt;em&gt;结果数组中，&lt;/em&gt;并将其从&lt;em&gt;源数组副本中&lt;/em&gt;删除。 重复此操作，直到源数组变&lt;em&gt;空&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="efb894bf2af625d5e7007fcadf92a7611c6daea0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt;: Here I'm suggesting a relatively &lt;strong&gt;simple&lt;/strong&gt; (not from &lt;em&gt;complexity&lt;/em&gt; perspective) and &lt;strong&gt;short&lt;/strong&gt; algorithm that will do just fine with small sized arrays, but it's definitely going to cost a lot more than the classic &lt;em&gt;Durstenfeld&lt;/em&gt; algorithm when you deal with huge arrays. You can find the &lt;em&gt;Durstenfeld&lt;/em&gt; in one of the top replies to this question.</source>
          <target state="translated">&lt;em&gt;更新&lt;/em&gt; ：在这里，我建议一个相对&lt;strong&gt;简单的&lt;/strong&gt;算法（不是从&lt;em&gt;复杂性的&lt;/em&gt;角度来看），并且&lt;strong&gt;简短的&lt;/strong&gt;算法对小型数组也可以，但是在处理大型数组时，它的成本肯定比经典的&lt;em&gt;Durstenfeld&lt;/em&gt;算法高得多。 您可以在对此问题的最高答复之一中找到&lt;em&gt;Durstenfeld&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="96b6fd7744ca19d4236a9277778b98f0def04eae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;DEMO&lt;/strong&gt;&lt;a href=&quot;http://jsfiddle.net/vvpoma8w/&quot;&gt;http://jsfiddle.net/vvpoma8w/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dee253cdbadca71dde01a92342a8c21696a687fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt; 
There was a calculation in excess (don't need --c+1) &lt;em&gt;and noone noticed&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;编辑&lt;/strong&gt;有一个多余的计算（不需要--c + 1） &lt;em&gt;，没有人注意到&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d26d57bf090dbc8f995db9e4efe14b2f99fd8e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.map&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure使用array.map&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a963a20e28355edbebbcb98adcb09596e71f7ee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure using array.reduce&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure使用array.reduce&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcbf09b9d5cdb75de80f70be8b7b663000db8c59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Iterative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Pure，迭代式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cff150316022043341bac9d4f6efd812bc0091d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Pure, Recursive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6纯递归&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57d86292367c88ac6937c2d5f8b933e395d3768b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit: This answer is incorrect&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑：此答案不正确&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7a1442dc364db9decbad3a8478fdd0d9216bda0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; The above code is O(n^2) due to the employment of &lt;code&gt;.splice()&lt;/code&gt; but we can eliminate splice and shuffle in O(n) by the swap trick.</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;由于使用了 &lt;code&gt;.splice()&lt;/code&gt; ，以上代码为O（n ^ 2），但我们可以通过交换技巧消除O（n）中的拼接和混洗。</target>
        </trans-unit>
        <trans-unit id="5d2b7cbc8216667f5c5cc93d5fbe14fd7b76925a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;: as pointed out by @gregers, the compare function is called with values rather than indices, which is why you need to use &lt;code&gt;indexOf&lt;/code&gt;. Note that this change makes the code less suitable for larger arrays as &lt;code&gt;indexOf&lt;/code&gt; runs in O(n) time.</source>
          <target state="translated">&lt;strong&gt;编辑&lt;/strong&gt; ：正如@gregers所指出的，compare函数是使用值而不是索引来调用的，这就是为什么需要使用 &lt;code&gt;indexOf&lt;/code&gt; 的原因 。 注意，由于 &lt;code&gt;indexOf&lt;/code&gt; 以O（n）时间运行，因此此更改使代码不太适合较大的数组。</target>
        </trans-unit>
        <trans-unit id="cd1897aa30d21aecd738588f517034caeeea8705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modern short inline solution using ES6 features:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用ES6功能的现代短内联解决方案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bcbf182d2c9f7baf0d1228ed1b2f3c14a66432c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PERFORMANCE:&lt;/strong&gt;&lt;a href=&quot;http://jsperf.com/fyshuffle&quot;&gt;http://jsperf.com/fyshuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d48760d5688f610b7bd932d6ce59fc0e830bb9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Readable version&lt;/strong&gt; (use the original version. this is slower, vars are useless, like the closures &amp;amp; &quot;;&quot;, the code itself is also shorter ... maybe read this &lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;How to 'minify' Javascript code&lt;/a&gt; , btw you are not able to compress the following code in a javascript minifiers like the above one.)</source>
          <target state="translated">&lt;strong&gt;可读的版本&lt;/strong&gt; （使用原始版本。速度较慢，vars没用，就像闭包＆&amp;ldquo;;&amp;rdquo;一样，代码本身也更短...也许阅读此方法&lt;a href=&quot;https://stackoverflow.com/questions/1737388/how-to-minify-javascript-code/21353032#21353032&quot;&gt;如何&amp;ldquo;最小化&amp;rdquo; Javascript代码&lt;/a&gt; ，顺便说一下在类似上面的JavaScript缩小器中压缩以下代码。）</target>
        </trans-unit>
        <trans-unit id="1c4379a4d4426412c390aa432f8600adaf810b14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorter &amp;amp; probably *faster Fisher-Yates shuffle algorithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更短或更快速的Fisher-Yates随机算法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cd816d4d50b745090fe63c80545160ad88627b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shuffle Array In place&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;随机排列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4fe6bb18531c0b16a4ac27e9d0bc5314577bf89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Speed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Speed&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba847e347088b75956742f58468d69a72e790bf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc572b1e8fa73691c1a2f268fe0819446c547699" translate="yes" xml:space="preserve">
          <source>A recursive solution:</source>
          <target state="translated">递归式的解决方案。</target>
        </trans-unit>
        <trans-unit id="d87908291510ce7aacbd6c9c630475506c98bfdb" translate="yes" xml:space="preserve">
          <source>A simple modification of CoolAJ86's &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;answer&lt;/a&gt; that does not modify the original array:</source>
          <target state="translated">对CoolAJ86 &lt;a href=&quot;https://stackoverflow.com/a/2450976/1673761&quot;&gt;答案的&lt;/a&gt;简单修改，不会修改原始数组：</target>
        </trans-unit>
        <trans-unit id="293d042470d40411ccc70692c51d611ac7e7db1a" translate="yes" xml:space="preserve">
          <source>A very simple way for small arrays is simply this:</source>
          <target state="translated">对于小数组来说,一个非常简单的方法就是这样。</target>
        </trans-unit>
        <trans-unit id="fd6c0330ee7aa8770c86a59555809d125e83952d" translate="yes" xml:space="preserve">
          <source>Actually random</source>
          <target state="translated">其实是随机的</target>
        </trans-unit>
        <trans-unit id="906af1739f79bc70c9973540b1aeaa064030d5be" translate="yes" xml:space="preserve">
          <source>Adding to @Laurens Holsts answer.  This is 50% compressed.</source>
          <target state="translated">补充到@Laurens Holsts的回答。这是被压缩了50%。</target>
        </trans-unit>
        <trans-unit id="6db86a3835a9089c53be7e4ab53e72e289b0e742" translate="yes" xml:space="preserve">
          <source>Algorithm runtime is &lt;code&gt;O(n)&lt;/code&gt;. &lt;strong&gt;Note&lt;/strong&gt; that the shuffle is done in-place so if you don't want to modify the original array, first make a copy of it with &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;&lt;code&gt;.slice(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">算法运行时间为 &lt;code&gt;O(n)&lt;/code&gt; 。 &lt;strong&gt;请注意&lt;/strong&gt; ，随机播放是就地完成的，因此，如果您不想修改原始数组，请首先使用&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt; &lt;code&gt;.slice(0)&lt;/code&gt; &lt;/a&gt;对其进行复制。</target>
        </trans-unit>
        <trans-unit id="29deda6f213fd21db50fee872cbe7bd9a47fe007" translate="yes" xml:space="preserve">
          <source>All the other answers are based on Math.random() which is fast but not suitable for cryptgraphic level randomization.</source>
          <target state="translated">其他的答案都是基于Math.random(),虽然速度很快,但不适合密码级随机化。</target>
        </trans-unit>
        <trans-unit id="7924e36bb8b15e369e65d0080b8819419232c254" translate="yes" xml:space="preserve">
          <source>And if you really want it short, here's how far I could get:</source>
          <target state="translated">如果你真的想要短一点,这就是我能走多远。</target>
        </trans-unit>
        <trans-unit id="5e7fae630e452b3fae47afe81da828d93b9f1443" translate="yes" xml:space="preserve">
          <source>As you can see in this page, there have been incorrect solutions offered here in the past. I wrote and have used the following function to test any pure (no side effects) array randomizing functions.</source>
          <target state="translated">在这个页面中你可以看到,过去在这里提供了不正确的解决方案。我编写并使用了以下函数来测试任何纯粹(无副作用)的数组随机化函数。</target>
        </trans-unit>
        <trans-unit id="44707dcfe46333c094f687b61e202b216454bb97" translate="yes" xml:space="preserve">
          <source>Caching somewhere else &lt;code&gt;var rnd=Math.random&lt;/code&gt; and then use &lt;code&gt;rnd()&lt;/code&gt; would also increase slightly the performance on big arrays.</source>
          <target state="translated">缓存其他地方的 &lt;code&gt;var rnd=Math.random&lt;/code&gt; ，然后使用 &lt;code&gt;rnd()&lt;/code&gt; 也会稍微提高大数组的性能。</target>
        </trans-unit>
        <trans-unit id="c3cddda7fb17e16b2062db130bd1a65b7c0ef0c1" translate="yes" xml:space="preserve">
          <source>Edit: This answer is incorrect</source>
          <target state="translated">编辑:这个答案是错误的</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="a42a5dd86e1515ccf60f677d0c43d4a244ec07a7" translate="yes" xml:space="preserve">
          <source>First of all, have a look &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;here&lt;/a&gt; for a great visual comparison of different sorting methods in javascript.</source>
          <target state="translated">首先， &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/compare.html&quot;&gt;在这里&lt;/a&gt;查看一下javascript中不同排序方法的视觉效果。</target>
        </trans-unit>
        <trans-unit id="62cd1f392b8ea498402c5d176e812c491931cf19" translate="yes" xml:space="preserve">
          <source>From ChristopheD:</source>
          <target state="translated">来自ChristopheD:</target>
        </trans-unit>
        <trans-unit id="119f5affc9b4bccbfa35a16ac979913a87667c1b" translate="yes" xml:space="preserve">
          <source>From a theoretical point of view, the most elegant way of doing it, in my humble opinion, is to get a &lt;em&gt;single&lt;/em&gt; random number between &lt;em&gt;0&lt;/em&gt; and &lt;em&gt;n!-1&lt;/em&gt; and to compute a one to one mapping from &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; to all permutations of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt;. As long as you can use a (pseudo-)random generator reliable enough for getting such a number without any significant bias, you have enough information in it for achieving what you want without needing several other random numbers.</source>
          <target state="translated">从理论的角度来看，我拙见认为，最优雅的方法是获取&lt;em&gt;0&lt;/em&gt;到&lt;em&gt;n！-1&lt;/em&gt;之间的&lt;em&gt;单个&lt;/em&gt;随机数，并根据 &lt;code&gt;{0, 1, &amp;hellip;, n!-1}&lt;/code&gt; 计算一对一的映射， n！-1}到 &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; 所有排列。 只要您可以使用足够可靠的（伪）随机生成器来获得这样一个数字而没有任何明显的偏差，您就可以在其中获得足够的信息来实现所需的信息，而无需其他几个随机数。</target>
        </trans-unit>
        <trans-unit id="490da622cd663c86273367e7042a11c19785eddb" translate="yes" xml:space="preserve">
          <source>Funny enough there was no non mutating recursive answer:</source>
          <target state="translated">有意思的是,没有非突变递归的答案。</target>
        </trans-unit>
        <trans-unit id="7985aa6e1818a6f446bbd8db04378dd6b08c7b4e" translate="yes" xml:space="preserve">
          <source>Here's a JavaScript implementation of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt;, an optimized version of Fisher-Yates:</source>
          <target state="translated">这是&lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm&quot;&gt;Durstenfeld shuffle&lt;/a&gt;的JavaScript实现，它是Fisher-Yates的优化版本：</target>
        </trans-unit>
        <trans-unit id="5c4a47a7bb2e4d4b06d049c2e910ebf3e74af15a" translate="yes" xml:space="preserve">
          <source>How can I randomize / shuffle it?</source>
          <target state="translated">怎样才能随机洗牌?</target>
        </trans-unit>
        <trans-unit id="4ab6a5b825f2780444712bcf5651612afe7a0f32" translate="yes" xml:space="preserve">
          <source>How to randomize (shuffle) a JavaScript array</source>
          <target state="translated">如何随机化(洗牌)一个JavaScript数组</target>
        </trans-unit>
        <trans-unit id="8e003d8524a462a0f826612e31e2fe8a771ebcae" translate="yes" xml:space="preserve">
          <source>I found this variant hanging out in the &quot;deleted by author&quot; answers on a duplicate of this question. Unlike some of the other answers that have many upvotes already, this is:</source>
          <target state="translated">我发现这个变体挂在 &quot;作者删除 &quot;这个问题的重复回答中。不同于其他一些已经有很多人点赞的答案,这个是。</target>
        </trans-unit>
        <trans-unit id="e49480fdbe90571097565eed3fe6b5f973ebd696" translate="yes" xml:space="preserve">
          <source>I have an array like this:</source>
          <target state="translated">我有一个这样的数组。</target>
        </trans-unit>
        <trans-unit id="9d0a31eb8f7a7f14043dca0cebb8a6b62db867b9" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;don't wish&lt;/em&gt; your shuffle function to mutate the &lt;strong&gt;source array&lt;/strong&gt;, you can copy it to a local variable, then do the rest with a simple &lt;em&gt;shuffling logic&lt;/em&gt;.</source>
          <target state="translated">如果您&lt;em&gt;不希望&lt;/em&gt; shuffle函数更改&lt;strong&gt;源数组&lt;/strong&gt; ，则可以将其复制到局部变量，然后使用简单的&lt;em&gt;shuffling逻辑&lt;/em&gt;进行其余操作。</target>
        </trans-unit>
        <trans-unit id="36a607745abf0fb5784e3061c8c5b90b7f5e372c" translate="yes" xml:space="preserve">
          <source>If you have any questions just ask.</source>
          <target state="translated">如果您有任何问题,请直接询问。</target>
        </trans-unit>
        <trans-unit id="151bf418710eddce1cf0effa70940dbec87d44fa" translate="yes" xml:space="preserve">
          <source>It picks a random element for each original array element, and excludes it from the next draw, like picking randomly from a deck of cards.</source>
          <target state="translated">它为每一个原始数组元素选取一个随机元素,并将其排除在下一次抽签中,就像从一副扑克牌中随机抽取。</target>
        </trans-unit>
        <trans-unit id="87535ca09b0d3d83bbb3da0becfd0a4d6503a7b4" translate="yes" xml:space="preserve">
          <source>It should work for up to 16 elements with a little theoretical bias (though unnoticeable from a practical point of view); it can be seen as fully usable for 15 elements; with arrays containing less than 14 elements, you can safely consider there will be absolutely no bias.</source>
          <target state="translated">它应该对16个元素有一点理论上的偏差(虽然从实践的角度看是不明显的);对于15个元素,可以认为完全可以使用;对于包含不到14个元素的数组,可以放心地认为绝对不会有偏差。</target>
        </trans-unit>
        <trans-unit id="1430642f79d43cc2db87a235c3474e0af8edb038" translate="yes" xml:space="preserve">
          <source>It's probably not very efficient, but for small arrays this works just fine. Here's an example so you can see how random (or not) it is, and whether it fits your usecase or not.</source>
          <target state="translated">这可能不是很有效,但对于小数组来说,这个方法很好用。这里有一个例子,你可以看到它的随机性(或不随机),以及它是否适合你的使用情况。</target>
        </trans-unit>
        <trans-unit id="b21d4f8d057efae539ed23ef586ac940cdd1ce22" translate="yes" xml:space="preserve">
          <source>Just to have a finger in the pie. Here i present a recursive implementation of Fisher Yates shuffle (i think). It gives uniform randomness.</source>
          <target state="translated">只是想在这块蛋糕上沾点光。我在这里介绍一个递归实现的Fisher Yates洗牌(我想)。它给出了统一的随机性。</target>
        </trans-unit>
        <trans-unit id="de5caf69e6bd2f9be2350f47acc50e9839bf6aad" translate="yes" xml:space="preserve">
          <source>NEW!</source>
          <target state="translated">NEW!</target>
        </trans-unit>
        <trans-unit id="5bf4a9cc98b9cf85df301bd0ac8de42aec0caec7" translate="yes" xml:space="preserve">
          <source>Not already present here with multiple variants</source>
          <target state="translated">这里还没有出现多个变体</target>
        </trans-unit>
        <trans-unit id="d5afcead952a7a1a1617786d3878a9d67d4f1cad" translate="yes" xml:space="preserve">
          <source>Not in-place (hence the &lt;code&gt;shuffled&lt;/code&gt; name rather than &lt;code&gt;shuffle&lt;/code&gt;)</source>
          <target state="translated">不在原位（因此， &lt;code&gt;shuffled&lt;/code&gt; 名称而不是改组名称）</target>
        </trans-unit>
        <trans-unit id="59c22528b1553e334b98831cb29d93e9c242a6bb" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;~~&lt;/code&gt; (double tilde operator) is in fact behaves like &lt;code&gt;Math.floor()&lt;/code&gt; for positive real numbers. Just a short cut it is.</source>
          <target state="translated">注意：对于正实数， &lt;code&gt;~~&lt;/code&gt; （双波浪号运算符）实际上的行为类似于 &lt;code&gt;Math.floor()&lt;/code&gt; 。 只是一个捷径。</target>
        </trans-unit>
        <trans-unit id="281343a71cbc74da1fa9ae9cb60112499481dee5" translate="yes" xml:space="preserve">
          <source>Now, what you want merely is:</source>
          <target state="translated">现在,你想要的仅仅是:</target>
        </trans-unit>
        <trans-unit id="05a30fe28c0384a67145436f9b19385d61c2a7f3" translate="yes" xml:space="preserve">
          <source>One could (or should) use it as a protoype from Array:</source>
          <target state="translated">人们可以(或应该)用它作为Array的原生类型。</target>
        </trans-unit>
        <trans-unit id="02a48c36f8633f74bcf21915df7e57e9aacfd49e" translate="yes" xml:space="preserve">
          <source>Other Solutions</source>
          <target state="translated">其他解决方案</target>
        </trans-unit>
        <trans-unit id="0f41147bbe611ff022208da6476ba7ea02349389" translate="yes" xml:space="preserve">
          <source>Other solutions just for fun.</source>
          <target state="translated">其他的解决方案,只是为了好玩。</target>
        </trans-unit>
        <trans-unit id="187d5329025b3a25d74d96c670d7f926ba1230b1" translate="yes" xml:space="preserve">
          <source>Please reference at &lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript Sorting Arrays&lt;/a&gt;</source>
          <target state="translated">请参考&lt;a href=&quot;https://www.w3schools.com/js/js_array_sort.asp&quot;&gt;JavaScript排序数组&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e68a97c48d4bacb3f09e61dd50a7e19926ed9853" translate="yes" xml:space="preserve">
          <source>Reliability and Performance Test</source>
          <target state="translated">可靠性和性能测试</target>
        </trans-unit>
        <trans-unit id="157d6201b2ac3fe0ab015a60e32bbeec8276f242" translate="yes" xml:space="preserve">
          <source>Reliable, Effecient, Short</source>
          <target state="translated">可靠、方便、快捷</target>
        </trans-unit>
        <trans-unit id="f535eb18ddbb2f6d8f98f7d768521dca2bef7bcd" translate="yes" xml:space="preserve">
          <source>Secondly, if you have a quick look at the link above you'll find that the &lt;code&gt;random order&lt;/code&gt; sort seems to perform relatively well compared to the other methods, while being extremely easy and fast to implement as shown below:</source>
          <target state="translated">其次，如果您快速浏览了上面的链接，您会发现 &lt;code&gt;random order&lt;/code&gt; 排序似乎比其他方法表现更好，并且实现起来非常容易和快捷，如下所示：</target>
        </trans-unit>
        <trans-unit id="e73ef6160dacf45888e9f4cf8013bc207bf467fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</source>
          <target state="translated">参见&lt;a href=&quot;https://github.com/coolaj86/knuth-shuffle&quot;&gt;https://github.com/coolaj86/knuth-shuffle&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="376cd4a087bf2a3f30e26253860cff0979202d0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">参见&lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt; 。 它被留在这里作为参考，因为这个想法并不罕见。</target>
        </trans-unit>
        <trans-unit id="972dfa82e5e7596b3e5d296e882e60afb7f81205" translate="yes" xml:space="preserve">
          <source>See comments and &lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt;. It is being left here for reference because the idea isn't rare.</source>
          <target state="translated">请参阅评论和&lt;a href=&quot;https://stackoverflow.com/a/18650169/28234&quot;&gt;https://stackoverflow.com/a/18650169/28234&lt;/a&gt; 。 它被留在这里作为参考，因为这个想法并不罕见。</target>
        </trans-unit>
        <trans-unit id="98bd03b500f02811b64f750f8b4a4138b59dec79" translate="yes" xml:space="preserve">
          <source>Since the elements are sorted against consistent keys that are not regenerated each iteration, and each comparison pulls from the same distribution, any non-randomness in the distribution of Math.random is canceled out.</source>
          <target state="translated">因为每次迭代时,元素都是对照着不再生的一致键进行排序,而且每次比较都是从相同的分布中抽取,所以Math.random分布中的任何非随机性都会被取消。</target>
        </trans-unit>
        <trans-unit id="16b7ffe2af3bc450e245042dd9946320c60307b2" translate="yes" xml:space="preserve">
          <source>Some more info &lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;about the algorithm&lt;/a&gt; used.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Fisher-Yates_shuffle&quot;&gt;有关使用的算法的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="81f118136d9e225898d71bda98047702661efe4d" translate="yes" xml:space="preserve">
          <source>Some solutions on this page aren't reliable (they only partially randomise the array). Other solutions are significantly less effecient. With &lt;code&gt;testShuffleArrayFun&lt;/code&gt; (see below) we can test array shuffling functions for reliability and performance. 
The following solutions are: reliable, effecient and short (using ES6 syntax)</source>
          <target state="translated">此页面上的某些解决方案不可靠（它们只能部分随机化阵列）。 其他解决方案的效率大大降低。 使用 &lt;code&gt;testShuffleArrayFun&lt;/code&gt; （请参见下文），我们可以测试数组改组函数的可靠性和性能。 以下解决方案是：可靠，高效和简短（使用ES6语法）</target>
        </trans-unit>
        <trans-unit id="a8a53b3371544e4c20126e1c9e3349051905705d" translate="yes" xml:space="preserve">
          <source>The below code is using the well known &lt;code&gt;Fisher-Yates&lt;/code&gt; algorithm while utilizing &lt;code&gt;Web Cryptography API&lt;/code&gt; for &lt;strong&gt;cryptographic level of randomization&lt;/strong&gt;.</source>
          <target state="translated">以下代码使用了众所周知的 &lt;code&gt;Fisher-Yates&lt;/code&gt; 算法，同时利用 &lt;code&gt;Web Cryptography API&lt;/code&gt; 进行了&lt;strong&gt;加密级别的随机化&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="61fbaa8f9450f0cf39662d39a156aa2bd1444d47" translate="yes" xml:space="preserve">
          <source>The de-facto unbiased shuffle algorithm is the Fisher-Yates (aka Knuth) Shuffle.</source>
          <target state="translated">事实上,无偏见的洗牌算法是Fisher-Yates(又名Knuth)洗牌算法。</target>
        </trans-unit>
        <trans-unit id="249b6e44421a088f52be0945aad986d2df59977f" translate="yes" xml:space="preserve">
          <source>The following function will not be used, but I give it anyway; it returns the index of a given permutation of &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; according to the one to one mapping used in this message (the most natural one when enumerating permuations); it is intended to work with up to 16 elements:</source>
          <target state="translated">以下功能将不会使用，但是我还是给了它； 它根据此消息中使用的一对一映射（枚举置换时最自然的映射 &lt;code&gt;(0, 1, 2, &amp;hellip;, n-1)&lt;/code&gt; 返回给定置换（0，1，2，&amp;hellip;，n-1）的索引； 它旨在与多达16个元素一起使用：</target>
        </trans-unit>
        <trans-unit id="b1dc2fb3b4532b7fa4c34753dd7c2f6ed847862a" translate="yes" xml:space="preserve">
          <source>The new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.</source>
          <target state="translated">新的ES6允许我们同时分配两个变量。当我们想交换两个变量的值时,这一点特别方便,因为我们可以在一行代码中完成。下面是一个较短的形式,使用了这个功能的相同函数。</target>
        </trans-unit>
        <trans-unit id="fed07e4940354c7a1e8ac12c85932a93dcc58c34" translate="yes" xml:space="preserve">
          <source>The problem is, JS can not coop on with big recursions. In this particular case you array size is limited with like 3000~7000 depending on your browser engine and some unknown facts.</source>
          <target state="translated">问题是,JS不能与大的递归合作。在这种特殊情况下,你的数组的大小是有限的,比如3000~7000,这取决于你的浏览器引擎和一些未知的事实。</target>
        </trans-unit>
        <trans-unit id="fa07c8700123d14185fdff2c5baeb9dcd4c3901c" translate="yes" xml:space="preserve">
          <source>The reciprocal of the previous function (required for your own question) is below; it is intended to work with up to 16 elements; it returns the permutation of order &lt;em&gt;n&lt;/em&gt; of &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt;:</source>
          <target state="translated">前一个功能的倒数（您自己的问题要求）如下： 它旨在使用最多16个元素； 它返回 &lt;code&gt;(0, 1, 2, &amp;hellip;, s-1)&lt;/code&gt; &lt;em&gt;n&lt;/em&gt;阶排列：</target>
        </trans-unit>
        <trans-unit id="5c18f5c02b633fe05311d86bfbcfbc9d5c1ad7cd" translate="yes" xml:space="preserve">
          <source>The use of this algorithm is &lt;strong&gt;not recommended&lt;/strong&gt;, because it is &lt;strong&gt;inefficient&lt;/strong&gt; and &lt;strong&gt;strongly biased&lt;/strong&gt;; see comments. It is being left here for future reference, because the idea is not that rare.</source>
          <target state="translated">&lt;strong&gt;不建议&lt;/strong&gt;使用此算法，因为它&lt;strong&gt;效率低下&lt;/strong&gt;并且存在&lt;strong&gt;严重偏差&lt;/strong&gt; ； 看评论。 它被留在这里以备将来参考，因为这种想法并不罕见。</target>
        </trans-unit>
        <trans-unit id="f0cacae56825070769eaf606992d6e807bd3cf8b" translate="yes" xml:space="preserve">
          <source>This clever exclusion swaps the picked element with the current one, then picks the next random element from the remainder, looping backwards for optimal efficiency, ensuring the random pick is simplified (it can always start at 0), and thereby skipping the final element.</source>
          <target state="translated">这种巧妙的排除法将选中的元素与当前的元素交换,然后从剩余的元素中挑选下一个随机元素,向后循环,以达到最佳的效率,确保随机抽取的元素被简化(它可以一直从0开始),从而跳过最后一个元素。</target>
        </trans-unit>
        <trans-unit id="dd8a3223dfe4968add4c7e42201681618a84f0d4" translate="yes" xml:space="preserve">
          <source>Though there are a number of implementations already advised but I feel we can make it shorter and easier using forEach loop, so we don't need to worry about calculating array length and also we can safely avoid using a temporary variable.</source>
          <target state="translated">虽然已经有很多实现的建议,但我觉得我们可以用forEach循环让它变得更短更简单,这样我们就不需要担心计算数组长度,也可以安全地避免使用临时变量。</target>
        </trans-unit>
        <trans-unit id="0ddaff04c667b8cad39e34a4186431500f596af0" translate="yes" xml:space="preserve">
          <source>Time complexity is O(N log N), same as quick sort. Space complexity is O(N). This is not as efficient as a Fischer Yates shuffle but, in my opinion, the code is significantly shorter and more functional. If you have a large array you should certainly use Fischer Yates. If you have a small array with a few hundred items, you might do this.</source>
          <target state="translated">时间复杂度为O(N log N),与快速排序相同。空间复杂度为O(N)。这样的效率不如Fischer Yates洗牌,但在我看来,代码明显更短,功能更多。如果你有一个大数组,你当然应该使用Fischer Yates。如果你有一个几百个项目的小数组,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="3787f3835a2fd1f1bc17f81e0a5ee6c1516e0a37" translate="yes" xml:space="preserve">
          <source>Use the underscore.js library. The method &lt;code&gt;_.shuffle()&lt;/code&gt; is nice for this case.
Here is an example with the method:</source>
          <target state="translated">使用underscore.js库。 在这种情况下，方法 &lt;code&gt;_.shuffle()&lt;/code&gt; 很合适。 这是该方法的示例：</target>
        </trans-unit>
        <trans-unit id="e982465409324de04153cd5c52ee341a1e0c33f9" translate="yes" xml:space="preserve">
          <source>We put each element in the array in an object, and give it a random sort key</source>
          <target state="translated">我们把数组中的每个元素放在一个对象中,并给它一个随机的排序键</target>
        </trans-unit>
        <trans-unit id="37c9a8233642b266d81593dc8d16fee23c6ff921" translate="yes" xml:space="preserve">
          <source>We sort using the random key</source>
          <target state="translated">我们使用随机密钥进行排序</target>
        </trans-unit>
        <trans-unit id="d6afc2bcb349e90081d50a88919a7d7354197158" translate="yes" xml:space="preserve">
          <source>We unmap to get the original objects</source>
          <target state="translated">我们取消映射以获得原始对象</target>
        </trans-unit>
        <trans-unit id="fa70411d3fe5f5f40d139c572f62e4cb144a088b" translate="yes" xml:space="preserve">
          <source>When computing with IEEE754 double precision floating numbers, you can expect your random generator to provide about 15 decimals. Since you have &lt;em&gt;15!=1,307,674,368,000&lt;/em&gt; (with 13 digits), you can use the following functions with arrays containing up to 15 elements and assume there will be no significant bias with arrays containing up to 14 elements. If you work on a fixed-size problem requiring to compute many times this shuffle operation, you may want to try the following code which &lt;em&gt;may&lt;/em&gt; be faster than other codes since it uses &lt;code&gt;Math.random&lt;/code&gt; only once (it involves several copy operations however).</source>
          <target state="translated">使用IEEE754双精度浮点数进行计算时，可以期望随机生成器提供约15个小数。 由于您有&lt;em&gt;15！= 1,307,674,368,000&lt;/em&gt; （13位数字），因此可以对包含最多15个元素的数组使用以下函数，并假设包含最多14个元素的数组不会有明显的偏差。 如果您处理一个固定大小的问题，需要多次计算此随机操作，则可能需要尝试以下代码，该代码&lt;em&gt;可能&lt;/em&gt;比其他代码更快，因为它仅使用 &lt;code&gt;Math.random&lt;/code&gt; 一次（但是它涉及多个复制操作）。</target>
        </trans-unit>
        <trans-unit id="ac812b0a196ffcf1ada365b6be5a7c7f0f2c1ae9" translate="yes" xml:space="preserve">
          <source>With ES2015 you can use this one:</source>
          <target state="translated">有了ES2015,你可以用这个。</target>
        </trans-unit>
        <trans-unit id="9bda77affb36f55fffd0079cb167c23b57c503a1" translate="yes" xml:space="preserve">
          <source>You can do it easily with map and sort:</source>
          <target state="translated">你可以通过地图和排序来轻松完成。</target>
        </trans-unit>
        <trans-unit id="0bd7627872f884699658169c2436dcdecd7197ea" translate="yes" xml:space="preserve">
          <source>You can do it easily with:</source>
          <target state="translated">你可以轻松做到与。</target>
        </trans-unit>
        <trans-unit id="a7d34d88cd56ff8410463b8f789e7edda9d26b00" translate="yes" xml:space="preserve">
          <source>You can see a &lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;great visualization here&lt;/a&gt; (and the original post &lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;linked to this&lt;/a&gt;)</source>
          <target state="translated">您可以&lt;a href=&quot;http://bost.ocks.org/mike/shuffle/&quot;&gt;在此处&lt;/a&gt;看到出色的可视化效果 （以及&lt;a href=&quot;http://sedition.com/perl/javascript-fy.html&quot;&gt;与此链接相关&lt;/a&gt;的原始文章）</target>
        </trans-unit>
        <trans-unit id="db43e778b685a829c5fa7d3b2857f1cbc7c9dfec" translate="yes" xml:space="preserve">
          <source>You can shuffle polymorphic arrays, and the sort is as random as Math.random, which is good enough for most purposes.</source>
          <target state="translated">你可以对多态数组进行洗牌,排序就像Math.random一样随机,这对于大多数目的来说已经足够好了。</target>
        </trans-unit>
        <trans-unit id="41f2e5a2df3900f50dd0bc1a1fd8b451e58f16da" translate="yes" xml:space="preserve">
          <source>[Comparison tests were done using &lt;code&gt;testShuffleArrayFun&lt;/code&gt; against other solutions, in Google Chrome]</source>
          <target state="translated">[比较测试是使用 &lt;code&gt;testShuffleArrayFun&lt;/code&gt; 与其他解决方案在Google Chrome中进行的]</target>
        </trans-unit>
        <trans-unit id="14236c02e628eaa55439674b94dfa1eec350021f" translate="yes" xml:space="preserve">
          <source>a shuffle function that doesn't change the source array</source>
          <target state="translated">不改变源数组的洗牌函数</target>
        </trans-unit>
        <trans-unit id="66c531dd89d3a2bb546b62f5e8a08723322f6e1c" translate="yes" xml:space="preserve">
          <source>bitwise to floor (numbers up to 10 decimal digits (32bit))</source>
          <target state="translated">从位到底层(小数点后十位以内的数字(32位))</target>
        </trans-unit>
        <trans-unit id="d25e649970e6fdedcd9efdc5002ea1b93e971620" translate="yes" xml:space="preserve">
          <source>it uses while---</source>
          <target state="translated">它在使用的同时</target>
        </trans-unit>
        <trans-unit id="68340861fed2ccc0703bd6ad39a67953febe7878" translate="yes" xml:space="preserve">
          <source>removed unecessary closures &amp;amp; other stuff</source>
          <target state="translated">删除了不必要的关闭和其他内容</target>
        </trans-unit>
        <trans-unit id="a40e5dc89de6414f6b7c4790ca64ea34f10dcb3f" translate="yes" xml:space="preserve">
          <source>script size (with fy as function name): 90bytes</source>
          <target state="translated">脚本大小(以fy为函数名):90bytes</target>
        </trans-unit>
        <trans-unit id="2d86563e6b1bdb64dd3a50cdf0529b14eae84135" translate="yes" xml:space="preserve">
          <source>shorter(4bytes)&amp;amp;faster(test it!).</source>
          <target state="translated">更短（4字节）和更快（测试！）。</target>
        </trans-unit>
        <trans-unit id="ab0874c3f73b2ecdaab7f1d46c567cffea1594bb" translate="yes" xml:space="preserve">
          <source>the shortest &lt;code&gt;arrayShuffle&lt;/code&gt; function</source>
          <target state="translated">最短的 &lt;code&gt;arrayShuffle&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="55ee529bcb360882189f97174d46ceaad11eab66" translate="yes" xml:space="preserve">
          <source>using the top voted functions.</source>
          <target state="translated">使用顶部投票的功能。</target>
        </trans-unit>
        <trans-unit id="63fbcfc569baf433216f5dc54bf2974616aa7d6c" translate="yes" xml:space="preserve">
          <source>yes it is faster</source>
          <target state="translated">是的,比较快</target>
        </trans-unit>
        <trans-unit id="f64996142b0f5ac8ca17c305fb58363a0af6ad3f" translate="yes" xml:space="preserve">
          <source>yet another implementation of Fisher-Yates, using strict mode:</source>
          <target state="translated">Fisher-Yates的另一个实现,使用严格模式。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
