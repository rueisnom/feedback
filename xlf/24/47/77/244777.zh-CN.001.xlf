<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/244777">
    <body>
      <group id="244777">
        <trans-unit id="34fa93b53bbf246051102dca8baae329621c5691" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;hello base three&lt;/code&gt; in ASCII) But instead of 0 use space, for 1 use line feed and for 2 use carriage return.</source>
          <target state="translated">（ &lt;code&gt;hello base three&lt;/code&gt; 以ASCII为基数3 ），而不是0使用空格，1使用换行，2使用回车。</target>
        </trans-unit>
        <trans-unit id="7ebed1765dd7ccc7851e59bc0fdd628490f7bc7d" translate="yes" xml:space="preserve">
          <source>/* This is a</source>
          <target state="translated">/*这是个</target>
        </trans-unit>
        <trans-unit id="bf94bef709f46f7c7d68674f1bb8b200ac2da950" translate="yes" xml:space="preserve">
          <source>//&quot;id&quot;: int</source>
          <target state="translated">/&quot;id&quot;:int</target>
        </trans-unit>
        <trans-unit id="ba4a24b3c03e2ccb99980352a2dca68f0f6be621" translate="yes" xml:space="preserve">
          <source>//&quot;name&quot;: &quot;string&quot;</source>
          <target state="translated">/&quot;name&quot;:&quot;string&quot;:</target>
        </trans-unit>
        <trans-unit id="5b8cb63271630ae5f51e3cb3a0d8b27849d68701" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;RFC 4627&lt;/a&gt;:
The &lt;code&gt;application/json&lt;/code&gt; Media Type for JavaScript Object Notation (JSON)</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;RFC 4627&lt;/a&gt; ：JavaScript对象符号（JSON）的 &lt;code&gt;application/json&lt;/code&gt; 媒体类型</target>
        </trans-unit>
        <trans-unit id="5c2579c1b1b5cf890fcc4fa294fb6ce099d9d5e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.jsonlint.com&quot;&gt;jsonlint&lt;/a&gt; does not validate this. So comments are a parser specific extension and not standard.</source>
          <target state="translated">&lt;a href=&quot;http://www.jsonlint.com&quot;&gt;jsonlint&lt;/a&gt;不会对此进行验证。 因此，注释是解析器特定的扩展，而不是标准的。</target>
        </trans-unit>
        <trans-unit id="a702bc50d3f7b75690cde2a03af864243499a7c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tools.ietf.org/html/rfc8259&quot;&gt;RFC 8259&lt;/a&gt; The JavaScript Object Notation (JSON) Data Interchange Format (supercedes RFCs 4627, 7158, 7159)</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc8259&quot;&gt;RFC 8259&lt;/a&gt; JavaScript对象表示法（JSON）数据交换格式（取代RFC 4627、7158、7159）</target>
        </trans-unit>
        <trans-unit id="b13056f66ad1abc6e703073098bfef5dc8973dca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Additional note for people who can't think out of the box:&lt;/strong&gt; I use the JSON format for basic settings in an ASP.NET web application I made. I read the file, convert it into the settings object with the Newtonsoft library and use it when necessary.</source>
          <target state="translated">&lt;strong&gt;对于那些&lt;/strong&gt;想不开&lt;strong&gt;箱即&lt;/strong&gt;用的&lt;strong&gt;人的补充说明：&lt;/strong&gt;我将JSON格式用于我制作的ASP.NET Web应用程序中的基本设置。 我阅读了文件，并使用Newtonsoft库将其转换为设置对象，并在必要时使用它。</target>
        </trans-unit>
        <trans-unit id="d6943fb66cf79edcea0c8ade6aa8085a0f57a63a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt; It would be a one liner. If you do that then JSON files could be used as configuration files.</source>
          <target state="translated">&lt;strong&gt;答：&lt;/strong&gt;那将是一个班轮。 如果这样做，则可以将JSON文件用作配置文件。</target>
        </trans-unit>
        <trans-unit id="f4e7ab93def871696ab38f62d8d8428ce1283817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT&lt;/strong&gt; as the creator of JSON also observed, there has always been JS pipeline support for comments:</source>
          <target state="translated">&lt;strong&gt;但是&lt;/strong&gt;作为JSON的创建者，也观察到，一直有JS管道支持注释：</target>
        </trans-unit>
        <trans-unit id="a65128266d54c908b80eea5f1f75fb9bf5f72005" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you try to put comments in (using &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;/* */&lt;/code&gt; or &lt;code&gt;#&lt;/code&gt; for instance), then some parsers will fail because this is strictly not
  within the JSON specification. So you should &lt;em&gt;never&lt;/em&gt; do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果尝试放入注释（例如使用 &lt;code&gt;//&lt;/code&gt; 或 &lt;code&gt;/* */&lt;/code&gt; 或 &lt;code&gt;#&lt;/code&gt; ），则某些解析器将失败，因为这严格不在JSON规范之内。&lt;/strong&gt; &lt;strong&gt;因此，您&lt;em&gt;绝对&lt;/em&gt;不应该&lt;em&gt;那样&lt;/em&gt;做。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bd82eee1a265aa79aa470b1a4e82624e65cc313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Include comments if you choose; strip them out with a minifier before parsing or transmitting.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果选择，请添加评论；&lt;/strong&gt; &lt;strong&gt;在解析或传输之前，先用一个缩小器将它们剥离。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc137b23a988799b2cc6169d59beb9eb0dd347da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSON is not a framed protocol&lt;/strong&gt;. It is a &lt;em&gt;language free format&lt;/em&gt;. So a comment's format is not defined for JSON.</source>
          <target state="translated">&lt;strong&gt;JSON不是框架协议&lt;/strong&gt; 。 这是一种无&lt;em&gt;语言格式&lt;/em&gt; 。 因此，未为JSON定义注释的格式。</target>
        </trans-unit>
        <trans-unit id="a910cb594e2078fcfc6c4427443144218212267a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSON5 is a proposed extension to JSON&lt;/strong&gt; that aims to make it easier for humans to write and maintain by hand. It does this by adding some minimal syntax features directly from ECMAScript&amp;nbsp;5.</source>
          <target state="translated">&lt;strong&gt;JSON5是对JSON的拟议扩展&lt;/strong&gt; ，旨在使人类更容易手工编写和维护。 它通过直接从ECMAScript 5添加一些最小的语法功能来做到这一点。</target>
        </trans-unit>
        <trans-unit id="44752b4e59de8e3916a24c2afa669cadff40eaaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NO&lt;/strong&gt;. JSON used to support comments, but they were abused and removed from the standard.</source>
          <target state="translated">&lt;strong&gt;不行&lt;/strong&gt; JSON曾经支持注释，但是它们被滥用并从标准中删除。</target>
        </trans-unit>
        <trans-unit id="a1b2ad6f7fdad1b2c2a4e6520625509eaa2a7e34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No&lt;/strong&gt;, comments of the form &lt;code&gt;//&amp;hellip;&lt;/code&gt; or &lt;code&gt;/*&amp;hellip;*/&lt;/code&gt; are not allowed in JSON. This answer is based on:</source>
          <target state="translated">&lt;strong&gt;不可以&lt;/strong&gt; ，JSON中不允许格式为 &lt;code&gt;//&amp;hellip;&lt;/code&gt; 或/*...*/的注释。 该答案基于：</target>
        </trans-unit>
        <trans-unit id="fece5910c250a5de635eae9fb85c117466f1d727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PS:&lt;/strong&gt; Single-line comments are only supported with 6+ versions of Newtonsoft Json.</source>
          <target state="translated">&lt;strong&gt;PS：&lt;/strong&gt;单行注释仅在6+版本的Newtonsoft Json中受支持。</target>
        </trans-unit>
        <trans-unit id="93fc05c73cfe76d315f7daea63ad940357ab4955" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt;The RFC only states &quot;whitespace is allowed before or after any of the six structural characters&quot;, not explicitly mentioning strings, numbers, &quot;false&quot;, &quot;true&quot;, and &quot;null&quot;. This omission is ignored in ALL implementations.</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; RFC仅声明&amp;ldquo;在六个结构字符中的任何一个之前或之后都允许空白&amp;rdquo;，没有明确提及字符串，数字，&amp;ldquo; false&amp;rdquo;，&amp;ldquo; true&amp;rdquo;和&amp;ldquo; null&amp;rdquo;。 在所有实现中都会忽略此遗漏。</target>
        </trans-unit>
        <trans-unit id="b770de645eb5b5b5781f0cd67e201c2b8c143f4f" translate="yes" xml:space="preserve">
          <source>A further alternative is &lt;a href=&quot;https://www.npmjs.com/package/jsonc&quot;&gt;jsonc&lt;/a&gt;.</source>
          <target state="translated">另一个选择是&lt;a href=&quot;https://www.npmjs.com/package/jsonc&quot;&gt;jsonc&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ca275b07a1a3e03b4a693a00ced0e07a366f2a6" translate="yes" xml:space="preserve">
          <source>All that said, it's not the intention that the JSON file should contain comments in the traditional sense. It should just be the data.</source>
          <target state="translated">综上所述,JSON文件并不是要包含传统意义上的注释。它应该只是数据。</target>
        </trans-unit>
        <trans-unit id="c1fe2287a775f42989886308f53c46700329e39f" translate="yes" xml:space="preserve">
          <source>An alternative to JSON &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;TOML&lt;/a&gt;.</source>
          <target state="translated">JSON &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;TOML&lt;/a&gt;的替代方法。</target>
        </trans-unit>
        <trans-unit id="c9c7ef0ee577ad0ff1ae47bc8be67f3d6d0023ec" translate="yes" xml:space="preserve">
          <source>And yes, you could &lt;a href=&quot;https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr&quot;&gt;insert comments &lt;em&gt;around&lt;/em&gt; the JSON&lt;/a&gt;, which you could parse out.</source>
          <target state="translated">是的，您可以&lt;a href=&quot;https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr&quot;&gt;在JSON &lt;em&gt;周围&lt;/em&gt;插入注释&lt;/a&gt; ，然后将其解析出来。</target>
        </trans-unit>
        <trans-unit id="fbaba3137d3ba5b895b4df6e513c6af6b39a54f0" translate="yes" xml:space="preserve">
          <source>And you can also have comments starting with &lt;code&gt;#&lt;/code&gt; by setting:</source>
          <target state="translated">您还可以通过设置以下内容以 &lt;code&gt;#&lt;/code&gt; 开头的注释：</target>
        </trans-unit>
        <trans-unit id="c97099d81edd7356629b8e241277674d1b800eb6" translate="yes" xml:space="preserve">
          <source>Annotations would just make JSON make less interoperable. There is simply nothing else to add, unless what you really need is a markup language (XML), and don't care if your persisted data is easily parsed.</source>
          <target state="translated">注释只会让JSON的互操作性降低。除非你真正需要的是一种标记语言(XML),并且不在乎你的持久化数据是否容易被解析,否则根本就没有什么可添加的东西。</target>
        </trans-unit>
        <trans-unit id="50e05893022bff20ab64b80f36d87d25f4dc3a58" translate="yes" xml:space="preserve">
          <source>Another parser is &lt;a href=&quot;https://json5.org/&quot;&gt;JSON5&lt;/a&gt;.</source>
          <target state="translated">另一个解析器是&lt;a href=&quot;https://json5.org/&quot;&gt;JSON5&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fca6d7b54ebefddc6d345628fbf6404f43c423a1" translate="yes" xml:space="preserve">
          <source>Any platform can parse JSON with just a few lines of code. XML requires complex OO libraries that are not viable on many platforms.</source>
          <target state="translated">任何平台只需要几行代码就可以解析JSON。XML需要复杂的OO库,这在很多平台上是不可行的。</target>
        </trans-unit>
        <trans-unit id="16620e2b329b58753187ee6770d1cdd5badc76ed" translate="yes" xml:space="preserve">
          <source>Anyone who understands the &quot;has-a&quot; relationship of object orientation can understand any JSON structure - that is the whole point. It is just a  directed acyclic graph (DAG) with node tags (key/value pairs), which is a near universal data structure.</source>
          <target state="translated">任何理解对象定向的 &quot;has-a &quot;关系的人都可以理解任何JSON结构---这才是重点。它只是一个带有节点标签(key-value对)的有方向的无周期图(DAG),是一种近乎通用的数据结构。</target>
        </trans-unit>
        <trans-unit id="78fec86ef914ad2766fde71edbc09e36e9fdad94" translate="yes" xml:space="preserve">
          <source>As has been pointed out, this hack takes advantage of the implementation of the spec. Not all JSON parsers will understand this sort of JSON. Streaming parsers in particular will choke.</source>
          <target state="translated">正如已经指出的那样,这个黑客利用了规范的实现。不是所有的JSON解析器都能理解这种类型的JSON。特别是流式解析器会窒息。</target>
        </trans-unit>
        <trans-unit id="2e587a0976bd75a1ebdc07043907330c24061460" translate="yes" xml:space="preserve">
          <source>As many people have suggested, there are some tricks, for example, duplicate keys or a specific key &lt;code&gt;_comment&lt;/code&gt; that you can use. It's up to you.</source>
          <target state="translated">正如许多人建议的那样，有一些技巧，例如，可以使用重复键或特定键 &lt;code&gt;_comment&lt;/code&gt; 。 由你决定。</target>
        </trans-unit>
        <trans-unit id="07864e21cf41714a1a91b2e8dad908a165050270" translate="yes" xml:space="preserve">
          <source>But if you decided to:</source>
          <target state="translated">但如果你决定了,</target>
        </trans-unit>
        <trans-unit id="d188f07e39655751d2837cd85a91661937641375" translate="yes" xml:space="preserve">
          <source>But if you want a way of inserting and extracting arbitrary side-channel data to a valid JSON, here is an answer. We take advantage of the non-unique representation of data in a JSON encoding. This is allowed&lt;sup&gt;*&lt;/sup&gt; in section two of the RFC under &quot;whitespace is allowed before or after any of the six structural characters&quot;.</source>
          <target state="translated">但是，如果您想要一种将任意的旁通道数据插入和提取到有效JSON的方法，这是一个答案。 我们利用JSON编码中数据的非唯一表示形式。 &lt;sup&gt;*&lt;/sup&gt;在RFC的第二部分中&amp;ldquo;在六个结构字符中的任何一个之前或之后都允许空白&amp;rdquo;下是允许的。</target>
        </trans-unit>
        <trans-unit id="b61019c2a4e8ea6e3feb4f45256dda80cb9669bc" translate="yes" xml:space="preserve">
          <source>But in general (as answered before) the specification does not allow comments.</source>
          <target state="translated">但总的来说(如前回答)规范不允许评论。</target>
        </trans-unit>
        <trans-unit id="2ff9d4802c7bbadfbb8936642807401ba75f0f4b" translate="yes" xml:space="preserve">
          <source>Can I use comments inside a JSON file? If so, how?</source>
          <target state="translated">我可以在JSON文件中使用注释吗?如果可以,如何使用?</target>
        </trans-unit>
        <trans-unit id="3342eaaa081df635d86d4ed103ab827ef1d58839" translate="yes" xml:space="preserve">
          <source>Can comments be used in JSON</source>
          <target state="translated">注释可以在JSON中使用吗?</target>
        </trans-unit>
        <trans-unit id="1053334a01b155351dfa23e7c384060bf041ee69" translate="yes" xml:space="preserve">
          <source>Cf: &lt;a href=&quot;http://tech.groups.yahoo.com/group/json/message/152&quot;&gt;Douglas Crockford, author of JSON spec&lt;/a&gt;.</source>
          <target state="translated">cf： &lt;a href=&quot;http://tech.groups.yahoo.com/group/json/message/152&quot;&gt;JSON规范的作者Douglas Crockford&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f99350726de90bc5586ade4e2c17579ca266470" translate="yes" xml:space="preserve">
          <source>Comments are not an official standard, although some parsers support C++-style comments. One that I use is &lt;a href=&quot;https://github.com/open-source-parsers/jsoncpp&quot;&gt;JsonCpp&lt;/a&gt;. In the examples there is this one:</source>
          <target state="translated">注释不是官方标准，尽管某些解析器支持C ++样式的注释。 我使用的一个是&lt;a href=&quot;https://github.com/open-source-parsers/jsoncpp&quot;&gt;JsonCpp&lt;/a&gt; 。 在示例中有一个：</target>
        </trans-unit>
        <trans-unit id="df3317483190e8a9a8a35a37f3ab9c10bb8b0448" translate="yes" xml:space="preserve">
          <source>Comments should never be used to transmit anything meaningful. That is
  what JSON is for.</source>
          <target state="translated">注释永远不应该被用来传输任何有意义的东西。这就是JSON的作用。</target>
        </trans-unit>
        <trans-unit id="1fff50af10e5c930549993b32ac848df3e193e26" translate="yes" xml:space="preserve">
          <source>Comments were removed from JSON by design.</source>
          <target state="translated">注释被设计地从JSON中删除。</target>
        </trans-unit>
        <trans-unit id="df35e067e1b8ca2a8cc8d578088da211eae4be66" translate="yes" xml:space="preserve">
          <source>Consider using YAML. It's nearly a superset of JSON (virtually all valid JSON is valid YAML) and it allows comments.</source>
          <target state="translated">考虑使用YAML。它几乎是JSON的超级集(几乎所有有效的JSON都是有效的YAML),而且它允许注释。</target>
        </trans-unit>
        <trans-unit id="c2438b86a8a6c50714e0bad6f85dbf92921e8b73" translate="yes" xml:space="preserve">
          <source>DISCLAIMER: THIS IS SILLY</source>
          <target state="translated">免责声明:这很傻</target>
        </trans-unit>
        <trans-unit id="093ed9747fb50ad3ace5476606d705f02357276b" translate="yes" xml:space="preserve">
          <source>DISCLAIMER: YOUR WARRANTY IS VOID</source>
          <target state="translated">免责声明:您的担保无效</target>
        </trans-unit>
        <trans-unit id="9767d216f2b66254e1e20ca9a65631dbeaf4909d" translate="yes" xml:space="preserve">
          <source>Eventually I just sent a manual HTTP request to the address above and realized that the content-type was &lt;code&gt;text/javascript&lt;/code&gt; since, well, JSONP returns pure JavaScript. In this case comments &lt;em&gt;are allowed&lt;/em&gt;. But my application returned content-type &lt;code&gt;application/json&lt;/code&gt;, so I had to remove the comments.</source>
          <target state="translated">最终，我只是向上面的地址发送了一个手动HTTP请求，并意识到内容类型是 &lt;code&gt;text/javascript&lt;/code&gt; ,因为JSONP返回的是纯JavaScript。 在这种情况下&lt;em&gt;，允许&lt;/em&gt;注释。 但是我的应用程序返回了内容类型 &lt;code&gt;application/json&lt;/code&gt; ，所以我不得不删除注释。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="f90ab4f60b84ef4fb66542eacd1ad110a153f608" translate="yes" xml:space="preserve">
          <source>First, canonicalize your JSON by minifying it:</source>
          <target state="translated">首先,通过对JSON进行minifying,使其标准化。</target>
        </trans-unit>
        <trans-unit id="c1d409cd4a3403ed218ea6a70a0197bffe0ada5b" translate="yes" xml:space="preserve">
          <source>From the creator of JSON:</source>
          <target state="translated">来自于JSON的创造者。</target>
        </trans-unit>
        <trans-unit id="60985232aee64d7c83d248d5056a34cd0c5ac498" translate="yes" xml:space="preserve">
          <source>Go ahead and insert all the comments you like.
  Then pipe it through JSMin before handing it to your JSON parser. - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Douglas Crockford, 2012&lt;/a&gt;</source>
          <target state="translated">继续并插入您喜欢的所有评论。 然后将其通过JSMin传递给JSON解析器。 - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;道格拉斯&amp;middot;克罗克福德&lt;/a&gt; （ Douglas Crockford），2012年</target>
        </trans-unit>
        <trans-unit id="8d46840c80aa71753041fbcd5316414574c064b6" translate="yes" xml:space="preserve">
          <source>Happy hacking!</source>
          <target state="translated">愉快的黑客!</target>
        </trans-unit>
        <trans-unit id="945eb7b5688a55ae394939657b1e2ecbfa4c17cf" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;http://www.json.org/&quot;&gt;JSON website&lt;/a&gt; for more detail.</source>
          <target state="translated">请&lt;a href=&quot;http://www.json.org/&quot;&gt;访问JSON网站&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="02bd5637edeede78c6aebbc6aea95a4fa0b2aabe" translate="yes" xml:space="preserve">
          <source>Here is what I found in the &lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/js/client#configure_the_browser_to_receive_messages&quot;&gt;Google Firebase documentation&lt;/a&gt; that allows you to put comments in JSON:</source>
          <target state="translated">这是我在&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/js/client#configure_the_browser_to_receive_messages&quot;&gt;Google Firebase文档&lt;/a&gt;中找到的内容 ，可让您将注释放入JSON：</target>
        </trans-unit>
        <trans-unit id="8633550968c6c22f9e3fa9c75c6d80470c4d5f6f" translate="yes" xml:space="preserve">
          <source>Here is your output:</source>
          <target state="translated">这里是你的输出。</target>
        </trans-unit>
        <trans-unit id="33a36408989ced26dbe1cb1d8c0cabbfd8ac0f26" translate="yes" xml:space="preserve">
          <source>Here's a for instance, where my &lt;a href=&quot;http://fyngyrz.com/?p=3389&quot;&gt;image manipulation system&lt;/a&gt; has saved image notations and some basic formatted (comment) information relating to them (at the bottom):</source>
          <target state="translated">例如，在这里，我的&lt;a href=&quot;http://fyngyrz.com/?p=3389&quot;&gt;图像处理系统&lt;/a&gt;保存了图像符号和一些与它们有关的基本格式化（注释）信息（在底部）：</target>
        </trans-unit>
        <trans-unit id="0ec84d942319f4dcf466115b9620f8a176cce63e" translate="yes" xml:space="preserve">
          <source>Hjson is a configuration file format for humans. Relaxed syntax, fewer mistakes, more comments.</source>
          <target state="translated">Hjson是一种适合人类的配置文件格式。语法宽松,错误少,注释多。</target>
        </trans-unit>
        <trans-unit id="e2fe75cc6963d7dc30fb895561d3733408988e3f" translate="yes" xml:space="preserve">
          <source>Hopefully that's helpful to those who disagree with why &lt;strong&gt;JSON.minify()&lt;/strong&gt; could be useful.</source>
          <target state="translated">希望这对那些不同意为什么&lt;strong&gt;JSON.minify（）&lt;/strong&gt;有用的人有所帮助。</target>
        </trans-unit>
        <trans-unit id="129c794cca15aa9f2515c133cd4b997e4d5b6072" translate="yes" xml:space="preserve">
          <source>I guess one could use &lt;code&gt;&quot;#&quot;: &quot;comment&quot;&lt;/code&gt;, for &quot;valid&quot; JSON.</source>
          <target state="translated">我猜一个人可以对&amp;ldquo; valid&amp;rdquo; JSON使用 &lt;code&gt;&quot;#&quot;: &quot;comment&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8acdec3845099bb2522f4b3146c30f724004a565" translate="yes" xml:space="preserve">
          <source>I just encountering this for configuration files. I don't want to use &lt;strong&gt;XML&lt;/strong&gt; (verbose, graphically, ugly, hard to read), or &quot;ini&quot; format (no hierarchy, no real standard, etc.) or Java &quot;Properties&quot; format (like .ini).</source>
          <target state="translated">我只是在配置文件中遇到此问题。 我不想使用&lt;strong&gt;XML&lt;/strong&gt; （冗长，图形化，丑陋，难以阅读）或&amp;ldquo; ini&amp;rdquo;格式（无层次结构，没有真正的标准等）或Java&amp;ldquo;属性&amp;rdquo;格式（如.ini）。</target>
        </trans-unit>
        <trans-unit id="a1697c05a3ee803cc922d72d59e63f002d4870ae" translate="yes" xml:space="preserve">
          <source>I just released &lt;strong&gt;&lt;a href=&quot;http://github.com/getify/JSON.minify&quot;&gt;JSON.minify()&lt;/a&gt;&lt;/strong&gt; which strips out comments and whitespace from a block of JSON and makes it valid JSON that can be parsed. So, you might use it like:</source>
          <target state="translated">我刚刚发布了&lt;strong&gt;&lt;a href=&quot;http://github.com/getify/JSON.minify&quot;&gt;JSON.minify（）&lt;/a&gt;&lt;/strong&gt; ，它从JSON块中去除了注释和空格，并使之成为可以解析的有效JSON。 因此，您可以像这样使用它：</target>
        </trans-unit>
        <trans-unit id="71af10f1174fd98a85f027d4574894f58909f6f4" translate="yes" xml:space="preserve">
          <source>I never even tried this, for obvious reasons and neither should you.</source>
          <target state="translated">我从没试过这个,原因很明显,你也不应该。</target>
        </trans-unit>
        <trans-unit id="ab9b39900ac2db147c382ac4b6f657544f7a7c9b" translate="yes" xml:space="preserve">
          <source>I prefer writing comments about each individual setting in the JSON file itself, and I really don't care about the integrity of the JSON format as long as the library I use is OK with it.</source>
          <target state="translated">我更喜欢在JSON文件本身写上关于每个单独设置的注释,我真的不在乎JSON格式的完整性,只要我使用的库没有问题,我就不会在意JSON格式的完整性。</target>
        </trans-unit>
        <trans-unit id="0158a4d90f6b5efaece3cf3af780c9d4914ee6e9" translate="yes" xml:space="preserve">
          <source>I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability.  I know that the lack of comments makes some people sad, but it shouldn't.  - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Douglas Crockford, 2012&lt;/a&gt;</source>
          <target state="translated">我从JSON中删除了注释，因为我看到人们正在使用它们保留解析指令，这种做法会破坏互操作性。 我知道缺少评论会让某些人感到难过，但事实并非如此。 - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;道格拉斯&amp;middot;克罗克福德&lt;/a&gt; （ Douglas Crockford），2012年</target>
        </trans-unit>
        <trans-unit id="18b4204602681875e0e110a36d909f3158c98fcc" translate="yes" xml:space="preserve">
          <source>I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't.</source>
          <target state="translated">我删除了JSON中的注释,因为我看到人们用注释来举行解析指令,这种做法会破坏互操作性。我知道没有注释会让一些人伤心,但这不应该。</target>
        </trans-unit>
        <trans-unit id="437f278795b45207777b6b3f5cb628f7d85f92ee" translate="yes" xml:space="preserve">
          <source>I think this is an 'easier to use/understand' way than creating a separate 'settings.README' file and explaining the settings in it.</source>
          <target state="translated">我认为这是个 &quot;更容易理解的方法,比起创建一个单独的 &quot;settings.README &quot;文件,并在其中解释设置,更容易使用。</target>
        </trans-unit>
        <trans-unit id="09543815ee5f23cc6a834389eef600ba4052d1cc" translate="yes" xml:space="preserve">
          <source>I've found a little hack that allows you to place comments in a JSON file that will not affect the parsing, or alter the data being represented in any way.</source>
          <target state="translated">我发现了一个小黑客,它可以让你在JSON文件中放置注释,不会影响解析,也不会改变数据的表示方式。</target>
        </trans-unit>
        <trans-unit id="dbf85d530dd7056debad251a792f8faeead6d98e" translate="yes" xml:space="preserve">
          <source>If people have strong reasons against having comments in JSON when communicating data (whether valid or not), then possibly JSON could be split into two:</source>
          <target state="translated">如果人们在沟通数据时,有强烈的理由反对JSON中的注释(不管是否有效),那么可能JSON可以一分为二。</target>
        </trans-unit>
        <trans-unit id="c924e8002bdfd65f69ae7095656a4a4eeb004ed6" translate="yes" xml:space="preserve">
          <source>If we apply this technique, your commented JSON file might look like this:</source>
          <target state="translated">如果我们应用这个技术,你的注释的JSON文件可能是这样的。</target>
        </trans-unit>
        <trans-unit id="b9684a17485b0adbd8900445645c8a494c2755a3" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;Jackson&lt;/a&gt; as your JSON parser then this is how you enable it to allow comments:</source>
          <target state="translated">如果您将&lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;Jackson&lt;/a&gt;用作JSON解析器，则可以通过以下方式启用它以允许注释：</target>
        </trans-unit>
        <trans-unit id="3f8246d0d3adbf7a7389d705ede0a752c209ba38" translate="yes" xml:space="preserve">
          <source>If you are using the Newtonsoft.Json library with ASP.NET to read/deserialize you can use comments in the JSON content:</source>
          <target state="translated">如果你使用ASP.NET的Newtonsoft.Json库来读取deserialize,你可以在JSON内容中使用注释。</target>
        </trans-unit>
        <trans-unit id="cabeeb699eaf07605e124cb949346b747a7e0dac" translate="yes" xml:space="preserve">
          <source>If you follow the link, you will see</source>
          <target state="translated">如果你按照这个链接,你会看到</target>
        </trans-unit>
        <trans-unit id="a63e2953b6b28d01b6fab0cd0c69b99f6574c7de" translate="yes" xml:space="preserve">
          <source>If you have a problem with this kind of usage; sorry, the genie is out of the lamp. People would find other usages for JSON format, and there is nothing you can do about it.</source>
          <target state="translated">如果你对这种使用方式有问题;对不起,精灵已经熄灭了。人们会发现JSON格式的其他用法,而你也无能为力。</target>
        </trans-unit>
        <trans-unit id="812bab4dd7487fc279216059de97088cf84dae7a" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://json5.org/&quot;&gt;JSON5&lt;/a&gt; you can include comments.</source>
          <target state="translated">如果您使用&lt;a href=&quot;http://json5.org/&quot;&gt;JSON5&lt;/a&gt; ，则可以包含注释。</target>
        </trans-unit>
        <trans-unit id="b08db292e52b29c91db521bfa2b81efa3280057a" translate="yes" xml:space="preserve">
          <source>If your text file, which is a JSON string, is going to be read by some program, how difficult would it be to strip out either C or C++ style comments before using it?</source>
          <target state="translated">如果你的文本文件,是一个JSON字符串,要被一些程序读取,那么在使用之前,要把C或C++风格的注释剥离出来,有多难?</target>
        </trans-unit>
        <trans-unit id="8aa49e3c9f29fe5a6b28c93b5f1a19ce858cb803" translate="yes" xml:space="preserve">
          <source>In a hacky way, you can abuse this to add a comment. For instance: start and end your comment with a tab. Encode the comment in base3 and use the other whitespace characters to represent them. For instance.</source>
          <target state="translated">用黑客的方式,你可以滥用这个来添加评论。例如:在评论的开头和结尾都用一个tab来表示。用base3对评论进行编码,用其他的whitespace字符来表示。比如说。</target>
        </trans-unit>
        <trans-unit id="a5f24ec24556750ba15be59104e6be49937079bd" translate="yes" xml:space="preserve">
          <source>In my case, I need use comments for debug purposes, prior the output of the JSON structure. So I decided to use debug information in the HTTP header, to avoid breaking the client:</source>
          <target state="translated">在我的例子中,我需要使用注释来调试,之前输出的JSON结构。所以我决定在HTTP头中使用调试信息,以避免破坏客户端。</target>
        </trans-unit>
        <trans-unit id="276120a4bf34bb8429f2b43928b3a0e4c6821d79" translate="yes" xml:space="preserve">
          <source>Insignificant whitespace is allowed before or after any token.
  Whitespace is any sequence of one or more of the following code
  points: character tabulation (U+0009), line feed (U+000A), carriage
  return (U+000D), and space (U+0020).</source>
          <target state="translated">在任何令牌之前或之后都允许有不明显的留白空间。空格是以下一个或多个代码点的任意序列:字符制表符(U+0009)、换行符(U+000A)、回车符(U+000D)和空格(U+0020)。</target>
        </trans-unit>
        <trans-unit id="48b50f16ce601739669575140e95e21d988bae25" translate="yes" xml:space="preserve">
          <source>It appears that when declaring an object literal you can specify two values with the same key, and the last one takes precedence. Believe it or not, it turns out that JSON parsers work the same way. So we can use this to create comments in the source JSON that will not be present in a parsed object representation.</source>
          <target state="translated">看来,在声明一个对象字面意义的时候,你可以指定两个相同的键值,最后一个优先。不管你信不信,事实证明,JSON解析器的工作原理是一样的。所以我们可以用这个来创建源JSON中的注释,这些注释在解析后的对象表示中不会出现。</target>
        </trans-unit>
        <trans-unit id="82cd8d15b1bd8e199799380ad43d59ee9b5ba712" translate="yes" xml:space="preserve">
          <source>It depends on your JSON library. &lt;a href=&quot;https://github.com/JamesNK/Newtonsoft.Json&quot;&gt;Json.NET&lt;/a&gt; supports JavaScript-style comments, &lt;code&gt;/* commment */&lt;/code&gt;.</source>
          <target state="translated">这取决于您的JSON库。 &lt;a href=&quot;https://github.com/JamesNK/Newtonsoft.Json&quot;&gt;Json.NET&lt;/a&gt;支持JavaScript样式的注释 &lt;code&gt;/* commment */&lt;/code&gt; 注释* / 。</target>
        </trans-unit>
        <trans-unit id="6ff7ed3f3d0cb930680ea06a91bdd9f410385b49" translate="yes" xml:space="preserve">
          <source>It doesn't really allow for comments as such, however, passing a comment as one of the name/value pairs in the data would certainly work, although that data would obviously need to be ignored or handled specifically by the parsing code.</source>
          <target state="translated">它并不允许注释,但是,在数据中传递一个注释作为nameevalue对中的一个,当然也是可行的,尽管这个数据显然需要被忽略或被解析代码特别处理。</target>
        </trans-unit>
        <trans-unit id="8b19f596dc7224ce2f8d5b6d837618e59941abcb" translate="yes" xml:space="preserve">
          <source>It's an interesting curiosity, but you &lt;strong&gt;should really not be using it for anything at all&lt;/strong&gt;. Below is the original answer.</source>
          <target state="translated">这是一个有趣的好奇心，但是您&lt;strong&gt;真的不应该将它用于任何用途&lt;/strong&gt; 。 以下是原始答案。</target>
        </trans-unit>
        <trans-unit id="74a40f3578a3c42e743f19623deb9c7f5d776631" translate="yes" xml:space="preserve">
          <source>JSON by design is an easily reverse-engineered (human parsed) alternative to XML. It is simplified even to the point that annotations are unnecessary. It is not even a markup language. The goal is stability and  interoperablilty.</source>
          <target state="translated">JSON在设计上是一种易于逆向工程(人工解析)的XML的替代品。它甚至简化到不需要注释的程度。它甚至不是一种标记语言。它的目标是稳定性和互操作性。</target>
        </trans-unit>
        <trans-unit id="8398b2bb763389aa2a2ee5d9f2352ebd5b7accf0" translate="yes" xml:space="preserve">
          <source>JSON can do all they can do, but it is way less verbose and more human readable - and parsers are easy and ubiquitous in many languages. It's just a tree of data. But out-of-band comments are a necessity often to document &quot;default&quot; configurations and the like. Configurations are never to be &quot;full documents&quot;, but trees of saved data that can be human readable when needed.</source>
          <target state="translated">JSON可以做所有他们能做的事情,但它的字数少得多,而且更容易被人类读懂--而且解析器在很多语言中都很容易,无处不在。它只是一个数据树。但带外注释往往是记录 &quot;默认 &quot;配置之类的东西的必要条件。配置永远不应该是 &quot;完整的文档&quot;,而应该是保存的数据树,在需要的时候可以被人类读取。</target>
        </trans-unit>
        <trans-unit id="8c1993e45bffed1300c1dc50e5447b301e83790f" translate="yes" xml:space="preserve">
          <source>JSON does not have comments. A JSON encoder MUST NOT output comments.
  A JSON decoder MAY accept and ignore comments.</source>
          <target state="translated">JSON没有注释。JSON 编码器不能输出注释。JSON解码器可以接受并忽略注释。</target>
        </trans-unit>
        <trans-unit id="e2e64a9d1e8c5e44b330ca7a7b80a5418ba7d47d" translate="yes" xml:space="preserve">
          <source>JSON does not support comments natively, but you can make your own decoder or at least preprocessor to strip out comments, that's perfectly fine (as long as you just ignore comments and don't use them to guide how your application should process the JSON data).</source>
          <target state="translated">JSON不支持注释,但你可以自己做一个解码器或者至少是预处理器来剥离出注释,那是完全没问题的(只要你只是忽略注释,不要用它们来指导你的应用程序应该如何处理JSON数据)。</target>
        </trans-unit>
        <trans-unit id="726f133617e74aa8751821a42ceb51d521bc92cd" translate="yes" xml:space="preserve">
          <source>JSON does not support comments. It was also never intended to be used for configuration files where comments would be needed.</source>
          <target state="translated">JSON不支持注释。它也从未打算用于需要注释的配置文件。</target>
        </trans-unit>
        <trans-unit id="501bdc0f8fdf940649176ca24d143965cb8f6989" translate="yes" xml:space="preserve">
          <source>JSON doesn't allow comments, per se. The reasoning is utterly foolish, because you can use JSON &lt;em&gt;itself&lt;/em&gt; to create comments, which obviates the reasoning entirely, &lt;em&gt;and&lt;/em&gt; loads the parser data space for no good reason at all for &lt;em&gt;exactly&lt;/em&gt; the same result and potential issues, such as they are: a JSON file with comments.</source>
          <target state="translated">JSON本身不允许评论。 推理是完全愚蠢的，因为您可以使用JSON &lt;em&gt;本身&lt;/em&gt;创建注释，从而完全避免推理， &lt;em&gt;并且&lt;/em&gt;完全没有理由完全加载解析器数据空间，因为它们的结果和潜在问题&lt;em&gt;完全相同&lt;/em&gt; ，例如：JSON带有注释的文件。</target>
        </trans-unit>
        <trans-unit id="09c3b12a027d2dcd8c91b9b62b6f273b10bad380" translate="yes" xml:space="preserve">
          <source>JSON has its syntax visualized on that page. There isn't any note about comments.</source>
          <target state="translated">JSON在那个页面上有它的语法可视化。没有任何关于注释的说明。</target>
        </trans-unit>
        <trans-unit id="976fd2bc03bc2a22ff4f002d1679d2a1718f3011" translate="yes" xml:space="preserve">
          <source>JSON makes a lot of sense for config files and other local usage because it's ubiquitous and because it's much simpler than XML.</source>
          <target state="translated">JSON对于配置文件和其他本地使用有很大的意义,因为它无处不在,而且比XML简单得多。</target>
        </trans-unit>
        <trans-unit id="000792ec4997245cbcd13240bdaead6035bcfda0" translate="yes" xml:space="preserve">
          <source>JSON-COM: JSON on the wire, or rules that apply when communicating JSON data.</source>
          <target state="translated">JSON-COM:JSON线上的JSON,或者说JSON数据通信时适用的规则。</target>
        </trans-unit>
        <trans-unit id="48b52d89e7b207194b31e0efa96191605763a131" translate="yes" xml:space="preserve">
          <source>JSON-DOC will allow comments, and other minor differences might exist such as handling whitespace. Parsers can easily convert from one spec to the other.</source>
          <target state="translated">JSON-DOC将允许注释,其他的小差异可能存在,例如处理空白处。解析器可以轻松地从一种规范转换到另一种规范。</target>
        </trans-unit>
        <trans-unit id="6dbc0606e8c2b4a5f2222aeb77b6b7252bfd4168" translate="yes" xml:space="preserve">
          <source>JSON-DOC: JSON document, or JSON in files or locally. Rules that define a valid JSON document.</source>
          <target state="translated">JSON-DOC:JSON文档,或文件中的JSON或本地的JSON。定义有效的JSON文档的规则。</target>
        </trans-unit>
        <trans-unit id="b019fec79fce564e6a858d4135ba07c6e432fcf0" translate="yes" xml:space="preserve">
          <source>No, you shouldn't use duplicative object members to stuff side channel data into a JSON encoding. (See &quot;The names within an object SHOULD be unique&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;in the RFC&lt;/a&gt;).</source>
          <target state="translated">不，您不应该使用重复的对象成员将旁通道数据填充到JSON编码中。 （请参阅&lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC中的&lt;/a&gt; &amp;ldquo;对象内的名称应唯一&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="41f3445f00f7570dee2718e061446c8ba3e2c310" translate="yes" xml:space="preserve">
          <source>Other JavaScript toolkits may work similarly.</source>
          <target state="translated">其他的JavaScript工具箱可能会有类似的效果。</target>
        </trans-unit>
        <trans-unit id="d7e64daaa3f687a35f3ef2e5959e2d88a2537414" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://hjson.org&quot;&gt;hjson.org&lt;/a&gt; for JavaScript, Java, Python, PHP, Rust, Go, Ruby and C# libraries.</source>
          <target state="translated">有关JavaScript，Java，Python，PHP，Rust，Go，Ruby和C＃库的信息，请参见&lt;a href=&quot;http://hjson.org&quot;&gt;hjson.org&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfaf82f0dc0b49d0e045c25d554109dfb4f850f2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/10325432/166286&quot;&gt;another Stack&amp;nbsp;Overflow question&lt;/a&gt;.</source>
          <target state="translated">参见&lt;a href=&quot;https://stackoverflow.com/a/10325432/166286&quot;&gt;另一个堆栈溢出问题&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="073200acf99512df8130754287c73186048bb656" translate="yes" xml:space="preserve">
          <source>Simply &lt;code&gt;npm install --save strip-json-comments&lt;/code&gt; to install and use it like:</source>
          <target state="translated">只需 &lt;code&gt;npm install --save strip-json-comments&lt;/code&gt; 即可安装和使用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="f506a3540bd757d871fdaa0806e59e8449171ae5" translate="yes" xml:space="preserve">
          <source>Since I had a similar file in my local folder, there were no issues with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;Same-origin policy&lt;/a&gt;, so I decided to use pure JSON... and, of course, &lt;code&gt;$.getJSON&lt;/code&gt; was failing silently because of the comments.</source>
          <target state="translated">由于我的本地文件夹中有一个类似的文件，因此&lt;a href=&quot;http://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;Same-origin策略&lt;/a&gt;没有问题，因此我决定使用纯JSON ...，当然，由于注释， &lt;code&gt;$.getJSON&lt;/code&gt; 失败了。</target>
        </trans-unit>
        <trans-unit id="71afd90a6307c6c96cb48a0eb950d54ed21ba403" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://web.archive.org/web/20120507093915/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Public statement by Douglas Crockford on G+&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;https://web.archive.org/web/20120507093915/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;道格拉斯&amp;middot;克罗克福德（Douglas Crockford）关于G +的公开声明&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7597ad58479a9cadb8c485eff7b25f3dcde2534b" translate="yes" xml:space="preserve">
          <source>Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser.</source>
          <target state="translated">假设你正在使用JSON来保存配置文件,你想对其进行注释。去吧,插入所有你喜欢的注释。然后在交给JSON解析器之前,将其通过JSMin进行管理。</target>
        </trans-unit>
        <trans-unit id="95c4ec0c1f6b94f7fa15f8848f32685e381ea392" translate="yes" xml:space="preserve">
          <source>Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. - &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Douglas Crockford, 2012&lt;/a&gt;</source>
          <target state="translated">假设您使用JSON保留要注释的配置文件。 继续并插入您喜欢的所有评论。 然后将其通过JSMin传递给JSON解析器。 - &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;道格拉斯&amp;middot;克罗克福德&lt;/a&gt; （ Douglas Crockford），2012年</target>
        </trans-unit>
        <trans-unit id="a31010b229f5d5d38cb8460296b3ffc06502029e" translate="yes" xml:space="preserve">
          <source>Sure a JSON specific minify can be implemented in any language,
but standardize this so it becomes ubiquitous across parsers in all languages and platforms so people stop wasting their time lacking the feature because they have good use-cases for it, looking the issue up in online forums, and getting people telling them it's a bad idea or suggesting it's easy to implement stripping comments out of text files.</source>
          <target state="translated">当然,一个JSON特定的minify可以在任何语言中实现,但要将其标准化,使其在所有语言和平台上的解析器中变得无处不在,这样人们就不会再因为有好的用例而浪费时间,在网上论坛上寻找这个问题,让人们告诉他们这是个坏主意,或者说这很容易实现从文本文件中剥离注释。</target>
        </trans-unit>
        <trans-unit id="3e99e6da8be38fff3a522f1f23ad02df352466c2" translate="yes" xml:space="preserve">
          <source>The Dojo Toolkit JavaScript toolkit (at least as of version 1.4), allows you to include comments in your JSON. The comments can be of &lt;code&gt;/* */&lt;/code&gt; format. Dojo Toolkit consumes the JSON via the &lt;code&gt;dojo.xhrGet()&lt;/code&gt; call.</source>
          <target state="translated">Dojo Toolkit JavaScript工具箱（至少从1.4版开始）允许您在JSON中包含注释。 注释可以是 &lt;code&gt;/* */&lt;/code&gt; 格式。 Dojo Toolkit通过 &lt;code&gt;dojo.xhrGet()&lt;/code&gt; 调用使用JSON。</target>
        </trans-unit>
        <trans-unit id="506b87b707c634e0b2a9ca847a5419d0c97d6a4c" translate="yes" xml:space="preserve">
          <source>The JSON should all be data, and if you include a comment, then it will be data too.</source>
          <target state="translated">JSON应该都是数据,如果包含了注释,那么它也会是数据。</target>
        </trans-unit>
        <trans-unit id="29b2cd6789d0e06a6f2f17423431e5a7ccf21a24" translate="yes" xml:space="preserve">
          <source>The above code is &lt;a href=&quot;http://jsonlint.com/&quot;&gt;valid JSON&lt;/a&gt;. If you parse it, you'll get an object like this:</source>
          <target state="translated">上面的代码是&lt;a href=&quot;http://jsonlint.com/&quot;&gt;有效的JSON&lt;/a&gt; 。 如果您解析它，将得到一个这样的对象：</target>
        </trans-unit>
        <trans-unit id="b8f8fba45d519a650dd034779bb67724bec9b4eb" translate="yes" xml:space="preserve">
          <source>The idea behind JSON is to provide simple data exchange between applications. These are typically web based and the language is JavaScript.</source>
          <target state="translated">JSON背后的思想是提供应用程序之间的简单数据交换。这些应用通常是基于Web的,语言是JavaScript。</target>
        </trans-unit>
        <trans-unit id="118eacae6b4f733ba3d8e27073279fa7d6945aa8" translate="yes" xml:space="preserve">
          <source>The official JSON site is at &lt;a href=&quot;http://json.org&quot;&gt;JSON.org&lt;/a&gt;. JSON is defined as a &lt;a href=&quot;http://ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;standard&lt;/a&gt; by ECMA International. There is always a petition process to have standards revised. It is unlikely that annotations will be added to the JSON standard for several reasons.</source>
          <target state="translated">官方JSON网站位于&lt;a href=&quot;http://json.org&quot;&gt;JSON.org&lt;/a&gt; 。 JSON被ECMA International定义为&lt;a href=&quot;http://ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;标准&lt;/a&gt; 。 总有一个请愿程序来修改标准。 由于多种原因，注释不太可能被添加到JSON标准中。</target>
        </trans-unit>
        <trans-unit id="6de039dc41d4aabcce5230d7a4c62570374729b7" translate="yes" xml:space="preserve">
          <source>The other issue is interoperability. Suppose you have a library or API or any kind of subsystem which has some config or data files associated with it. And this subsystem is
to be accessed from different languages.  Then do you go about telling people: by the way
don't forget to strip out the comments from the JSON files before passing them to the parser!</source>
          <target state="translated">另一个问题是互操作性。假设你有一个库或API或任何类型的子系统,它有一些与之相关的配置文件或数据文件。而这个子系统要从不同的语言中访问。那么你会告诉人们:顺便说一下,在传递给解析器之前,不要忘了把JSON文件中的注释从JSON文件中剥离出来。</target>
        </trans-unit>
        <trans-unit id="d0841b7455110d89326e1a28a5e44e10c4570e5d" translate="yes" xml:space="preserve">
          <source>Then encode your comment in binary:</source>
          <target state="translated">然后把你的评论用二进制编码。</target>
        </trans-unit>
        <trans-unit id="cb80cdc45aa7b8b143f7abe549b0a2a38ef5ca01" translate="yes" xml:space="preserve">
          <source>Then steg your binary:</source>
          <target state="translated">那就把你的二进制的东西给拆了。</target>
        </trans-unit>
        <trans-unit id="93ae98bd84aa4fbc409553d7cab4dfbf8d06c00b" translate="yes" xml:space="preserve">
          <source>Then you can have comments like this:</source>
          <target state="translated">那么你可以有这样的评论。</target>
        </trans-unit>
        <trans-unit id="49db07c0eb71bb872bdde75cfbad8f1430e8e945" translate="yes" xml:space="preserve">
          <source>There is actually a way to add comments, and stay within the spec (no additional parser needed). It will not result into human-readable comments without any sort of parsing though.</source>
          <target state="translated">实际上,有一种方法可以添加注释,并且不需要额外的解析器(不需要额外的解析器)。但是,如果不经过任何形式的解析,它不会导致人类可读的注释。</target>
        </trans-unit>
        <trans-unit id="939c8690fd4debc3efc52fd16ff9fa763116587f" translate="yes" xml:space="preserve">
          <source>This can be helpful when experimenting with alternate data structures (or even data lists) before choosing a final option.</source>
          <target state="translated">这在选择最终方案之前,在尝试使用备用数据结构(甚至是数据列表)的时候会很有帮助。</target>
        </trans-unit>
        <trans-unit id="f64679fe6571746a9ba9e6ac37f387ce8686d481" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;&quot;can you&quot;&lt;/strong&gt; question. And here is a &lt;strong&gt;&quot;yes&quot;&lt;/strong&gt; answer.</source>
          <target state="translated">这是一个&lt;strong&gt;&amp;ldquo;可以&amp;rdquo;的&lt;/strong&gt;问题。 这是一个&lt;strong&gt;&amp;ldquo;是&amp;rdquo;的&lt;/strong&gt;答案。</target>
        </trans-unit>
        <trans-unit id="6fdccc472b5b375de3890696c9e5a380489af6fb" translate="yes" xml:space="preserve">
          <source>This only annotation required might be &quot;//These are DAG tags&quot;. The key names can be as informative as required, allowing arbitrary semantic arity.</source>
          <target state="translated">这唯一需要的注释可能是&quot;/这些是DAG标签&quot;。键名可以根据需要的信息量,允许任意的语义属性。</target>
        </trans-unit>
        <trans-unit id="c9b00a22cb69ded735c57bf505cdfefe076ebaa9" translate="yes" xml:space="preserve">
          <source>This will just leave you with a lot of unreadable whitespace (unless you make an IDE plugin to encode/decode it on the fly).</source>
          <target state="translated">这只会给你留下很多无法读取的空白空间(除非你做了一个IDE插件来对其进行编码)。</target>
        </trans-unit>
        <trans-unit id="388b829f16dd17f84ea2ba8d1476b6313b19ec03" translate="yes" xml:space="preserve">
          <source>To cut a JSON item into parts I add &quot;dummy comment&quot; lines:</source>
          <target state="translated">为了将JSON项切割成部分,我添加了 &quot;dummy comment &quot;行。</target>
        </trans-unit>
        <trans-unit id="c46c93b452125db5e01ac6f5b129d24508a4638b" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://github.com/sindresorhus/strip-json-comments&quot;&gt;&lt;code&gt;strip-json-comments&lt;/code&gt;&lt;/a&gt; for our project. It supports something like:</source>
          <target state="translated">我们正在为项目使用&lt;a href=&quot;https://github.com/sindresorhus/strip-json-comments&quot;&gt; &lt;code&gt;strip-json-comments&lt;/code&gt; &lt;/a&gt; 。 它支持类似：</target>
        </trans-unit>
        <trans-unit id="3541c15e44949bf6aaf515ad0f11200bb4b27c8a" translate="yes" xml:space="preserve">
          <source>We're talking about a generic config file issue (cross language/platform), and he's answering with a JS specific utility!</source>
          <target state="translated">我们说的是一个通用的配置文件问题(跨语言平台),他用一个JS专用的实用工具来回答!我们说的是一个通用的配置文件问题(跨语言平台)。</target>
        </trans-unit>
        <trans-unit id="40086162c11724bb65bc484b7a663182d4a0214f" translate="yes" xml:space="preserve">
          <source>When I released it, I got a huge backlash of people disagreeing with even the idea of it, so I decided that I'd write a comprehensive blog post on why &lt;a href=&quot;http://web.archive.org/web/20100629021329/http://blog.getify.com/2010/06/json-comments/&quot;&gt;comments make sense in JSON&lt;/a&gt;. It includes this notable comment from the creator of JSON:</source>
          <target state="translated">当我发布它时，我什至遭到了人们的强烈反对，甚至连想法都没有。所以我决定写一篇关于为什么&lt;a href=&quot;http://web.archive.org/web/20100629021329/http://blog.getify.com/2010/06/json-comments/&quot;&gt;在JSON中有意义的&lt;/a&gt;博客文章。 它包含JSON创建者的以下著名注释：</target>
        </trans-unit>
        <trans-unit id="98fd7e23dcf6f9b9b1816044ced909699b4c49f7" translate="yes" xml:space="preserve">
          <source>Which means there is no trace of the comments, and they won't have weird side-effects.</source>
          <target state="translated">也就是没有了评论的痕迹,不会有奇怪的副作用。</target>
        </trans-unit>
        <trans-unit id="c4cb6522fff6a5d557f0d476627f9ece04ec2cfd" translate="yes" xml:space="preserve">
          <source>With regards to the &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;remark&lt;/a&gt; made by Douglas Crockford on this issues (referenced by @Artur Czajka)</source>
          <target state="translated">关于道格拉斯&amp;middot;克罗克福德（Douglas Crockford）在此问题上的&lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;评论&lt;/a&gt; （@Artur Czajka引用）</target>
        </trans-unit>
        <trans-unit id="feaa09360dfd54411746acac2798b890bddec1c2" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; have comments in &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;, but not in pure JSON. I've just spent an hour trying to make my program work with this example from Highcharts: &lt;a href=&quot;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&quot;&gt;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&lt;/a&gt;</source>
          <target state="translated">您&lt;em&gt;可以&lt;/em&gt;在&lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP中添加&lt;/a&gt;注释，但不能在纯JSON中添加注释。 我只花了一个小时就试图使我的程序在Highcharts中使用此示例： &lt;a href=&quot;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&quot;&gt;http&lt;/a&gt; ://www.highcharts.com/samples/data/jsonp.php ? filename = aapl-c.json&amp;amp;callback =？</target>
        </trans-unit>
        <trans-unit id="1deff785b9f44f36c7ffb11fb73ab887e7163ffb" translate="yes" xml:space="preserve">
          <source>You can provide documentation by using the &lt;strong&gt;description&lt;/strong&gt; schema attribute.</source>
          <target state="translated">您可以通过使用&lt;strong&gt;描述&lt;/strong&gt;架构属性来提供文档。</target>
        </trans-unit>
        <trans-unit id="6321e0e7526a00ea19de7e51a8a6484deb9e4c60" translate="yes" xml:space="preserve">
          <source>You can't. At least that's my experience from a quick glance at &lt;a href=&quot;http://json.org&quot;&gt;json.org&lt;/a&gt;.</source>
          <target state="translated">你不能 至少快速浏览一下&lt;a href=&quot;http://json.org&quot;&gt;json.org&lt;/a&gt;是我的经验。</target>
        </trans-unit>
        <trans-unit id="a38662ff523b7d9c8a3a3c993706047579876c91" translate="yes" xml:space="preserve">
          <source>You could abuse the following:</source>
          <target state="translated">你可以滥用如下:</target>
        </trans-unit>
        <trans-unit id="1a3df4432a8595e033223ec8fe5e551c685694e2" translate="yes" xml:space="preserve">
          <source>You could have a designated data element called &lt;code&gt;&quot;_comment&quot;&lt;/code&gt; (or something) that would be ignored by apps that use the JSON data.</source>
          <target state="translated">您可能有一个名为 &lt;code&gt;&quot;_comment&quot;&lt;/code&gt; （或其他名称）的指定数据元素，使用JSON数据的应用程序会忽略该数据元素。</target>
        </trans-unit>
        <trans-unit id="7d1a793bb1b7d02580215fd79bb3a42efc2f9543" translate="yes" xml:space="preserve">
          <source>You should write a &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt; instead. JSON schema is currently a proposed Internet draft specification. Besides documentation, the schema can also be used for validating your JSON data.</source>
          <target state="translated">您应该改为编写&lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON模式&lt;/a&gt; 。 JSON模式是当前提议的Internet草案规范。 除了文档之外，该模式还可以用于验证JSON数据。</target>
        </trans-unit>
        <trans-unit id="5f1eb38f94b01dd40159fa9e41b98ceba4ac1117" translate="yes" xml:space="preserve">
          <source>You would probably be better having the comment in the processes that generates/receives the JSON, as they are supposed to know what the JSON data will be in advance, or at least the structure of it.</source>
          <target state="translated">你可能会在生成和接收JSON的过程中,让他们提前知道JSON数据是什么,或者至少知道它的结构。</target>
        </trans-unit>
        <trans-unit id="7e147e80eb87acbe7b929c746720cc66c49a3fae" translate="yes" xml:space="preserve">
          <source>comment example */</source>
          <target state="translated">评论范例*</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
