<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/244777">
    <body>
      <group id="244777">
        <trans-unit id="34fa93b53bbf246051102dca8baae329621c5691" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;hello base three&lt;/code&gt; in ASCII) But instead of 0 use space, for 1 use line feed and for 2 use carriage return.</source>
          <target state="translated">(ASCII에서 &lt;code&gt;hello base three&lt;/code&gt; ) 그러나 0 대신 스페이스를 사용하고 1은 줄 바꿈을 사용하고 2는 캐리지 리턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7ebed1765dd7ccc7851e59bc0fdd628490f7bc7d" translate="yes" xml:space="preserve">
          <source>/* This is a</source>
          <target state="translated">/* 이것은</target>
        </trans-unit>
        <trans-unit id="bf94bef709f46f7c7d68674f1bb8b200ac2da950" translate="yes" xml:space="preserve">
          <source>//&quot;id&quot;: int</source>
          <target state="translated">// &quot;id&quot;: int</target>
        </trans-unit>
        <trans-unit id="ba4a24b3c03e2ccb99980352a2dca68f0f6be621" translate="yes" xml:space="preserve">
          <source>//&quot;name&quot;: &quot;string&quot;</source>
          <target state="translated">// &quot;이름&quot;: &quot;문자열&quot;</target>
        </trans-unit>
        <trans-unit id="5b8cb63271630ae5f51e3cb3a0d8b27849d68701" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;RFC 4627&lt;/a&gt;:
The &lt;code&gt;application/json&lt;/code&gt; Media Type for JavaScript Object Notation (JSON)</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc4627.txt&quot;&gt;RFC 4627&lt;/a&gt; : JSON (JavaScript Object Notation) 용 &lt;code&gt;application/json&lt;/code&gt; 미디어 유형</target>
        </trans-unit>
        <trans-unit id="5c2579c1b1b5cf890fcc4fa294fb6ce099d9d5e2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.jsonlint.com&quot;&gt;jsonlint&lt;/a&gt; does not validate this. So comments are a parser specific extension and not standard.</source>
          <target state="translated">&lt;a href=&quot;http://www.jsonlint.com&quot;&gt;jsonlint&lt;/a&gt; 는 이것을 검증하지 않습니다. 따라서 주석은 파서 고유의 확장이며 표준이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a702bc50d3f7b75690cde2a03af864243499a7c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tools.ietf.org/html/rfc8259&quot;&gt;RFC 8259&lt;/a&gt; The JavaScript Object Notation (JSON) Data Interchange Format (supercedes RFCs 4627, 7158, 7159)</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc8259&quot;&gt;RFC 8259&lt;/a&gt; JSON (JavaScript Object Notation) 데이터 교환 형식 (RFC 4627, 7158, 7159)</target>
        </trans-unit>
        <trans-unit id="b13056f66ad1abc6e703073098bfef5dc8973dca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Additional note for people who can't think out of the box:&lt;/strong&gt; I use the JSON format for basic settings in an ASP.NET web application I made. I read the file, convert it into the settings object with the Newtonsoft library and use it when necessary.</source>
          <target state="translated">&lt;strong&gt;즉시&lt;/strong&gt; 사용할 &lt;strong&gt;수없는 사람들을위한 추가 참고 사항 :&lt;/strong&gt; 내가 만든 ASP.NET 웹 응용 프로그램의 기본 설정에는 JSON 형식을 사용합니다. 파일을 읽고 Newtonsoft 라이브러리를 사용하여 설정 객체로 변환하고 필요할 때 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d6943fb66cf79edcea0c8ade6aa8085a0f57a63a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt; It would be a one liner. If you do that then JSON files could be used as configuration files.</source>
          <target state="translated">&lt;strong&gt;답 :&lt;/strong&gt; 하나의 라이너 일 것입니다. 그렇게하면 JSON 파일을 구성 파일로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4e7ab93def871696ab38f62d8d8428ce1283817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT&lt;/strong&gt; as the creator of JSON also observed, there has always been JS pipeline support for comments:</source>
          <target state="translated">&lt;strong&gt;그러나&lt;/strong&gt; JSON 제작자가 관찰 한 것처럼 주석에 대한 JS 파이프 라인 지원은 항상있었습니다.</target>
        </trans-unit>
        <trans-unit id="a65128266d54c908b80eea5f1f75fb9bf5f72005" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you try to put comments in (using &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;/* */&lt;/code&gt; or &lt;code&gt;#&lt;/code&gt; for instance), then some parsers will fail because this is strictly not
  within the JSON specification. So you should &lt;em&gt;never&lt;/em&gt; do that.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;/* */&lt;/code&gt; 또는 &lt;code&gt;#&lt;/code&gt; 을 사용하여 주석을 넣으려고하면 JSON 사양에 엄격히 포함되지 않기 때문에 일부 파서가 실패합니다.&lt;/strong&gt; &lt;strong&gt;그러니 &lt;em&gt;절대&lt;/em&gt; 그렇게해서는 &lt;em&gt;안됩니다&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bd82eee1a265aa79aa470b1a4e82624e65cc313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Include comments if you choose; strip them out with a minifier before parsing or transmitting.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;원하는 경우 의견을 포함하십시오.&lt;/strong&gt; &lt;strong&gt;파싱하거나 전송하기 전에 축소기를 사용하여 제거하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc137b23a988799b2cc6169d59beb9eb0dd347da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSON is not a framed protocol&lt;/strong&gt;. It is a &lt;em&gt;language free format&lt;/em&gt;. So a comment's format is not defined for JSON.</source>
          <target state="translated">&lt;strong&gt;JSON은 프레임 프로토콜이 아닙니다&lt;/strong&gt; . &lt;em&gt;언어 무료 형식&lt;/em&gt; 입니다. 따라서 주석의 형식은 JSON에 대해 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a910cb594e2078fcfc6c4427443144218212267a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSON5 is a proposed extension to JSON&lt;/strong&gt; that aims to make it easier for humans to write and maintain by hand. It does this by adding some minimal syntax features directly from ECMAScript&amp;nbsp;5.</source>
          <target state="translated">&lt;strong&gt;JSON5는&lt;/strong&gt; 사람이 손으로 직접 작성하고 관리 할 수 ​​있도록 &lt;strong&gt;JSON에 제안 된 확장&lt;/strong&gt; 입니다. ECMAScript 5에서 직접 최소한의 구문 기능을 추가하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="44752b4e59de8e3916a24c2afa669cadff40eaaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NO&lt;/strong&gt;. JSON used to support comments, but they were abused and removed from the standard.</source>
          <target state="translated">&lt;strong&gt;아니요&lt;/strong&gt; . JSON은 주석을 지원하는 데 사용되었지만 표준에서 남용되어 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a1b2ad6f7fdad1b2c2a4e6520625509eaa2a7e34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No&lt;/strong&gt;, comments of the form &lt;code&gt;//&amp;hellip;&lt;/code&gt; or &lt;code&gt;/*&amp;hellip;*/&lt;/code&gt; are not allowed in JSON. This answer is based on:</source>
          <target state="translated">&lt;strong&gt;아니요&lt;/strong&gt; , &lt;code&gt;//&amp;hellip;&lt;/code&gt; 또는 &lt;code&gt;/*&amp;hellip;*/&lt;/code&gt; 형식의 주석은 JSON에서 허용되지 않습니다. 이 답변은 다음을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="fece5910c250a5de635eae9fb85c117466f1d727" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PS:&lt;/strong&gt; Single-line comments are only supported with 6+ versions of Newtonsoft Json.</source>
          <target state="translated">&lt;strong&gt;PS : 한&lt;/strong&gt; 줄 주석은 6 개 이상의 Newtonsoft Json 버전에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="93fc05c73cfe76d315f7daea63ad940357ab4955" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt;The RFC only states &quot;whitespace is allowed before or after any of the six structural characters&quot;, not explicitly mentioning strings, numbers, &quot;false&quot;, &quot;true&quot;, and &quot;null&quot;. This omission is ignored in ALL implementations.</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; RFC는 문자열, 숫자, &quot;false&quot;, &quot;true&quot;및 &quot;null&quot;을 명시 적으로 언급하지 않고 &quot;6 개의 구조 문자 앞뒤에 공백이 허용됨&quot;만 표시합니다. 이 구현은 모든 구현에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b770de645eb5b5b5781f0cd67e201c2b8c143f4f" translate="yes" xml:space="preserve">
          <source>A further alternative is &lt;a href=&quot;https://www.npmjs.com/package/jsonc&quot;&gt;jsonc&lt;/a&gt;.</source>
          <target state="translated">다른 대안은 &lt;a href=&quot;https://www.npmjs.com/package/jsonc&quot;&gt;jsonc&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ca275b07a1a3e03b4a693a00ced0e07a366f2a6" translate="yes" xml:space="preserve">
          <source>All that said, it's not the intention that the JSON file should contain comments in the traditional sense. It should just be the data.</source>
          <target state="translated">그러나 JSON 파일이 전통적인 의미로 주석을 포함해야한다는 의도는 아닙니다. 단지 데이터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c1fe2287a775f42989886308f53c46700329e39f" translate="yes" xml:space="preserve">
          <source>An alternative to JSON &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;TOML&lt;/a&gt;.</source>
          <target state="translated">JSON &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;TOML&lt;/a&gt; 의 대안입니다.</target>
        </trans-unit>
        <trans-unit id="c9c7ef0ee577ad0ff1ae47bc8be67f3d6d0023ec" translate="yes" xml:space="preserve">
          <source>And yes, you could &lt;a href=&quot;https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr&quot;&gt;insert comments &lt;em&gt;around&lt;/em&gt; the JSON&lt;/a&gt;, which you could parse out.</source>
          <target state="translated">그리고 네, &lt;a href=&quot;https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr&quot;&gt;JSON &lt;em&gt;주위&lt;/em&gt; 에 주석 &lt;em&gt;을&lt;/em&gt; 삽입하여&lt;/a&gt; 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbaba3137d3ba5b895b4df6e513c6af6b39a54f0" translate="yes" xml:space="preserve">
          <source>And you can also have comments starting with &lt;code&gt;#&lt;/code&gt; by setting:</source>
          <target state="translated">다음을 설정하여 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 주석을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c97099d81edd7356629b8e241277674d1b800eb6" translate="yes" xml:space="preserve">
          <source>Annotations would just make JSON make less interoperable. There is simply nothing else to add, unless what you really need is a markup language (XML), and don't care if your persisted data is easily parsed.</source>
          <target state="translated">주석을 사용하면 JSON이 상호 운용성이 떨어집니다. 실제로 필요한 것은 마크 업 언어 (XML)가 아니라면 추가 할 것이 없으며 지속되는 데이터가 쉽게 구문 분석되는지는 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50e05893022bff20ab64b80f36d87d25f4dc3a58" translate="yes" xml:space="preserve">
          <source>Another parser is &lt;a href=&quot;https://json5.org/&quot;&gt;JSON5&lt;/a&gt;.</source>
          <target state="translated">다른 파서는 &lt;a href=&quot;https://json5.org/&quot;&gt;JSON5&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fca6d7b54ebefddc6d345628fbf6404f43c423a1" translate="yes" xml:space="preserve">
          <source>Any platform can parse JSON with just a few lines of code. XML requires complex OO libraries that are not viable on many platforms.</source>
          <target state="translated">모든 플랫폼에서 단 몇 줄의 코드로 JSON을 구문 분석 할 수 있습니다. XML에는 많은 플랫폼에서 사용할 수없는 복잡한 OO 라이브러리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16620e2b329b58753187ee6770d1cdd5badc76ed" translate="yes" xml:space="preserve">
          <source>Anyone who understands the &quot;has-a&quot; relationship of object orientation can understand any JSON structure - that is the whole point. It is just a  directed acyclic graph (DAG) with node tags (key/value pairs), which is a near universal data structure.</source>
          <target state="translated">객체 지향의 &quot;has-a&quot;관계를 이해하는 사람은 모든 JSON 구조를 이해할 수 있습니다. 거의 보편적 인 데이터 구조 인 노드 태그 (키 / 값 쌍)가있는 DAG (directed acyclic graph) 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="78fec86ef914ad2766fde71edbc09e36e9fdad94" translate="yes" xml:space="preserve">
          <source>As has been pointed out, this hack takes advantage of the implementation of the spec. Not all JSON parsers will understand this sort of JSON. Streaming parsers in particular will choke.</source>
          <target state="translated">지적 된 바와 같이,이 핵은 사양의 구현을 이용한다. 모든 JSON 파서가 이러한 종류의 JSON을 이해하는 것은 아닙니다. 특히 스트리밍 파서는 질식합니다.</target>
        </trans-unit>
        <trans-unit id="2e587a0976bd75a1ebdc07043907330c24061460" translate="yes" xml:space="preserve">
          <source>As many people have suggested, there are some tricks, for example, duplicate keys or a specific key &lt;code&gt;_comment&lt;/code&gt; that you can use. It's up to you.</source>
          <target state="translated">많은 사람들이 제안했듯이 중복 키 또는 사용할 수있는 특정 키 &lt;code&gt;_comment&lt;/code&gt; 와 같은 몇 가지 트릭이 있습니다. 그것은 당신에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="07864e21cf41714a1a91b2e8dad908a165050270" translate="yes" xml:space="preserve">
          <source>But if you decided to:</source>
          <target state="translated">그러나 당신이 결정한 경우 :</target>
        </trans-unit>
        <trans-unit id="d188f07e39655751d2837cd85a91661937641375" translate="yes" xml:space="preserve">
          <source>But if you want a way of inserting and extracting arbitrary side-channel data to a valid JSON, here is an answer. We take advantage of the non-unique representation of data in a JSON encoding. This is allowed&lt;sup&gt;*&lt;/sup&gt; in section two of the RFC under &quot;whitespace is allowed before or after any of the six structural characters&quot;.</source>
          <target state="translated">그러나 임의의 사이드 채널 데이터를 유효한 JSON에 삽입하고 추출하는 방법을 원한다면 여기에 답이 있습니다. JSON 인코딩에서 고유하지 않은 데이터 표현을 활용합니다. RFC의 섹션 2에서 &quot;여백은 6 개의 구조 문자 중 하나 또는 그 이후에 공백이 허용됩니다&quot;에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b61019c2a4e8ea6e3feb4f45256dda80cb9669bc" translate="yes" xml:space="preserve">
          <source>But in general (as answered before) the specification does not allow comments.</source>
          <target state="translated">그러나 일반적으로 (앞서 답변 한대로) 사양에서는 주석을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ff9d4802c7bbadfbb8936642807401ba75f0f4b" translate="yes" xml:space="preserve">
          <source>Can I use comments inside a JSON file? If so, how?</source>
          <target state="translated">JSON 파일 내에서 주석을 사용할 수 있습니까? 그렇다면 어떻게?</target>
        </trans-unit>
        <trans-unit id="3342eaaa081df635d86d4ed103ab827ef1d58839" translate="yes" xml:space="preserve">
          <source>Can comments be used in JSON</source>
          <target state="translated">JSON에서 주석을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1053334a01b155351dfa23e7c384060bf041ee69" translate="yes" xml:space="preserve">
          <source>Cf: &lt;a href=&quot;http://tech.groups.yahoo.com/group/json/message/152&quot;&gt;Douglas Crockford, author of JSON spec&lt;/a&gt;.</source>
          <target state="translated">Cf : &lt;a href=&quot;http://tech.groups.yahoo.com/group/json/message/152&quot;&gt;Douglas Crockford, JSON spec의 저자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f99350726de90bc5586ade4e2c17579ca266470" translate="yes" xml:space="preserve">
          <source>Comments are not an official standard, although some parsers support C++-style comments. One that I use is &lt;a href=&quot;https://github.com/open-source-parsers/jsoncpp&quot;&gt;JsonCpp&lt;/a&gt;. In the examples there is this one:</source>
          <target state="translated">일부 파서는 C ++ 스타일의 주석을 지원하지만 주석은 공식 표준이 아닙니다. 내가 사용하는 것은 &lt;a href=&quot;https://github.com/open-source-parsers/jsoncpp&quot;&gt;JsonCpp&lt;/a&gt; 입니다. 예제에는 다음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3317483190e8a9a8a35a37f3ab9c10bb8b0448" translate="yes" xml:space="preserve">
          <source>Comments should never be used to transmit anything meaningful. That is
  what JSON is for.</source>
          <target state="translated">주석은 의미있는 것을 전달하는 데 사용해서는 안됩니다. 이것이 JSON입니다.</target>
        </trans-unit>
        <trans-unit id="1fff50af10e5c930549993b32ac848df3e193e26" translate="yes" xml:space="preserve">
          <source>Comments were removed from JSON by design.</source>
          <target state="translated">주석은 의도적으로 JSON에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="df35e067e1b8ca2a8cc8d578088da211eae4be66" translate="yes" xml:space="preserve">
          <source>Consider using YAML. It's nearly a superset of JSON (virtually all valid JSON is valid YAML) and it allows comments.</source>
          <target state="translated">YAML 사용을 고려하십시오. 거의 JSON의 수퍼 세트 (거의 모든 유효한 JSON은 유효한 YAML 임)이며 주석을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c2438b86a8a6c50714e0bad6f85dbf92921e8b73" translate="yes" xml:space="preserve">
          <source>DISCLAIMER: THIS IS SILLY</source>
          <target state="translated">면책 조항 : 이건 실로</target>
        </trans-unit>
        <trans-unit id="093ed9747fb50ad3ace5476606d705f02357276b" translate="yes" xml:space="preserve">
          <source>DISCLAIMER: YOUR WARRANTY IS VOID</source>
          <target state="translated">면책 조항 : 귀하의 보증은 무효입니다</target>
        </trans-unit>
        <trans-unit id="9767d216f2b66254e1e20ca9a65631dbeaf4909d" translate="yes" xml:space="preserve">
          <source>Eventually I just sent a manual HTTP request to the address above and realized that the content-type was &lt;code&gt;text/javascript&lt;/code&gt; since, well, JSONP returns pure JavaScript. In this case comments &lt;em&gt;are allowed&lt;/em&gt;. But my application returned content-type &lt;code&gt;application/json&lt;/code&gt;, so I had to remove the comments.</source>
          <target state="translated">결국 나는 위의 주소로 수동 HTTP 요청을 보냈고 JSONP는 순수한 JavaScript를 반환하기 때문에 내용 유형이 &lt;code&gt;text/javascript&lt;/code&gt; 라는 것을 깨달았습니다. 이 경우 의견 &lt;em&gt;이 허용&lt;/em&gt; 됩니다. 그러나 내 응용 프로그램은 content-type &lt;code&gt;application/json&lt;/code&gt; 을 반환 했으므로 주석을 제거해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="f90ab4f60b84ef4fb66542eacd1ad110a153f608" translate="yes" xml:space="preserve">
          <source>First, canonicalize your JSON by minifying it:</source>
          <target state="translated">먼저 JSON을 축소하여 JSON을 정규화하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d409cd4a3403ed218ea6a70a0197bffe0ada5b" translate="yes" xml:space="preserve">
          <source>From the creator of JSON:</source>
          <target state="translated">JSON 제작자 :</target>
        </trans-unit>
        <trans-unit id="60985232aee64d7c83d248d5056a34cd0c5ac498" translate="yes" xml:space="preserve">
          <source>Go ahead and insert all the comments you like.
  Then pipe it through JSMin before handing it to your JSON parser. - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Douglas Crockford, 2012&lt;/a&gt;</source>
          <target state="translated">계속해서 당신이 좋아하는 모든 의견을 삽입하십시오. 그런 다음 JSON 파서를 전달하기 전에 JSMin을 통해 파이프하십시오. - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;더글러스 크록 포드, 2012&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d46840c80aa71753041fbcd5316414574c064b6" translate="yes" xml:space="preserve">
          <source>Happy hacking!</source>
          <target state="translated">행복한 해킹!</target>
        </trans-unit>
        <trans-unit id="945eb7b5688a55ae394939657b1e2ecbfa4c17cf" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;http://www.json.org/&quot;&gt;JSON website&lt;/a&gt; for more detail.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.json.org/&quot;&gt;JSON 웹 사이트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02bd5637edeede78c6aebbc6aea95a4fa0b2aabe" translate="yes" xml:space="preserve">
          <source>Here is what I found in the &lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/js/client#configure_the_browser_to_receive_messages&quot;&gt;Google Firebase documentation&lt;/a&gt; that allows you to put comments in JSON:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/js/client#configure_the_browser_to_receive_messages&quot;&gt;Google Firebase 설명서&lt;/a&gt; 에서 JSON에 주석을 달 수있는 내용입니다.</target>
        </trans-unit>
        <trans-unit id="8633550968c6c22f9e3fa9c75c6d80470c4d5f6f" translate="yes" xml:space="preserve">
          <source>Here is your output:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33a36408989ced26dbe1cb1d8c0cabbfd8ac0f26" translate="yes" xml:space="preserve">
          <source>Here's a for instance, where my &lt;a href=&quot;http://fyngyrz.com/?p=3389&quot;&gt;image manipulation system&lt;/a&gt; has saved image notations and some basic formatted (comment) information relating to them (at the bottom):</source>
          <target state="translated">예를 들어 내 &lt;a href=&quot;http://fyngyrz.com/?p=3389&quot;&gt;이미지 조작 시스템&lt;/a&gt; 이 이미지 표기법과 이미지 형식과 관련된 기본 형식 (코멘트) 정보를 저장했습니다 (아래쪽).</target>
        </trans-unit>
        <trans-unit id="0ec84d942319f4dcf466115b9620f8a176cce63e" translate="yes" xml:space="preserve">
          <source>Hjson is a configuration file format for humans. Relaxed syntax, fewer mistakes, more comments.</source>
          <target state="translated">Hjson은 사람을위한 구성 파일 형식입니다. 편안한 구문, 적은 실수, 더 많은 주석.</target>
        </trans-unit>
        <trans-unit id="e2fe75cc6963d7dc30fb895561d3733408988e3f" translate="yes" xml:space="preserve">
          <source>Hopefully that's helpful to those who disagree with why &lt;strong&gt;JSON.minify()&lt;/strong&gt; could be useful.</source>
          <target state="translated">&lt;strong&gt;JSON.minify ()&lt;/strong&gt; 가 유용한 이유에 동의하지 않는 사람들에게 도움이 &lt;strong&gt;되기를 바랍니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="129c794cca15aa9f2515c133cd4b997e4d5b6072" translate="yes" xml:space="preserve">
          <source>I guess one could use &lt;code&gt;&quot;#&quot;: &quot;comment&quot;&lt;/code&gt;, for &quot;valid&quot; JSON.</source>
          <target state="translated">&quot;유효한&quot;JSON에 &lt;code&gt;&quot;#&quot;: &quot;comment&quot;&lt;/code&gt; 사용할 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="8acdec3845099bb2522f4b3146c30f724004a565" translate="yes" xml:space="preserve">
          <source>I just encountering this for configuration files. I don't want to use &lt;strong&gt;XML&lt;/strong&gt; (verbose, graphically, ugly, hard to read), or &quot;ini&quot; format (no hierarchy, no real standard, etc.) or Java &quot;Properties&quot; format (like .ini).</source>
          <target state="translated">구성 파일에 대해이 문제가 발생했습니다. &lt;strong&gt;XML&lt;/strong&gt; (자세한, 그래픽,보기 흉한, 읽기 어려운) 또는 &quot;ini&quot;형식 (계층 구조, 실제 표준 등 없음) 또는 Java &quot;속성&quot;형식 (.ini 등)을 사용하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1697c05a3ee803cc922d72d59e63f002d4870ae" translate="yes" xml:space="preserve">
          <source>I just released &lt;strong&gt;&lt;a href=&quot;http://github.com/getify/JSON.minify&quot;&gt;JSON.minify()&lt;/a&gt;&lt;/strong&gt; which strips out comments and whitespace from a block of JSON and makes it valid JSON that can be parsed. So, you might use it like:</source>
          <target state="translated">방금 JSON 블록에서 주석과 공백을 제거하고 구문 분석 할 수있는 유효한 JSON으로 만드는 &lt;strong&gt;&lt;a href=&quot;http://github.com/getify/JSON.minify&quot;&gt;JSON.minify ()&lt;/a&gt;&lt;/strong&gt; 를 릴리스했습니다. 따라서 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71af10f1174fd98a85f027d4574894f58909f6f4" translate="yes" xml:space="preserve">
          <source>I never even tried this, for obvious reasons and neither should you.</source>
          <target state="translated">나는 명백한 이유 때문에 이것을 시도조차하지 않았으며 당신도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="ab9b39900ac2db147c382ac4b6f657544f7a7c9b" translate="yes" xml:space="preserve">
          <source>I prefer writing comments about each individual setting in the JSON file itself, and I really don't care about the integrity of the JSON format as long as the library I use is OK with it.</source>
          <target state="translated">JSON 파일 자체의 각 개별 설정에 대한 의견을 작성하는 것을 선호하며 사용하는 라이브러리가 정상인 한 JSON 형식의 무결성에 대해서는 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0158a4d90f6b5efaece3cf3af780c9d4914ee6e9" translate="yes" xml:space="preserve">
          <source>I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability.  I know that the lack of comments makes some people sad, but it shouldn't.  - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Douglas Crockford, 2012&lt;/a&gt;</source>
          <target state="translated">사람들이 구문 분석 지시문을 유지하기 위해 주석을 사용하고 상호 운용성을 파괴하는 사례를 보았 기 때문에 JSON에서 주석을 제거했습니다. 의견이 없기 때문에 일부 사람들은 슬프다는 것을 알고 있지만 그렇게해서는 안됩니다. - &lt;a href=&quot;https://web.archive.org/web/20120506232618/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;더글러스 크록 포드, 2012&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="18b4204602681875e0e110a36d909f3158c98fcc" translate="yes" xml:space="preserve">
          <source>I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't.</source>
          <target state="translated">사람들이 구문 분석 지시문을 유지하기 위해 주석을 사용하고 상호 운용성을 파괴하는 사례를 보았 기 때문에 JSON에서 주석을 제거했습니다. 의견이 없기 때문에 일부 사람들은 슬프다는 것을 알고 있지만 그렇게해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="437f278795b45207777b6b3f5cb628f7d85f92ee" translate="yes" xml:space="preserve">
          <source>I think this is an 'easier to use/understand' way than creating a separate 'settings.README' file and explaining the settings in it.</source>
          <target state="translated">나는 이것이 별도의 'settings.README'파일을 만들고 그 설정을 설명하는 것보다 '사용하기 쉽고 이해하기 쉬운'방법이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="09543815ee5f23cc6a834389eef600ba4052d1cc" translate="yes" xml:space="preserve">
          <source>I've found a little hack that allows you to place comments in a JSON file that will not affect the parsing, or alter the data being represented in any way.</source>
          <target state="translated">파싱에 영향을 미치지 않는 JSON 파일에 주석을 넣거나 어떤 식 으로든 표현되는 데이터를 변경할 수있는 약간의 해킹을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="dbf85d530dd7056debad251a792f8faeead6d98e" translate="yes" xml:space="preserve">
          <source>If people have strong reasons against having comments in JSON when communicating data (whether valid or not), then possibly JSON could be split into two:</source>
          <target state="translated">사람들이 데이터를 통신 할 때 JSON에 주석을 달지 않는 강력한 이유가 있다면 (유효한지 여부와 상관없이) JSON을 두 가지로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c924e8002bdfd65f69ae7095656a4a4eeb004ed6" translate="yes" xml:space="preserve">
          <source>If we apply this technique, your commented JSON file might look like this:</source>
          <target state="translated">이 기술을 적용하면 주석 처리 된 JSON 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9684a17485b0adbd8900445645c8a494c2755a3" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;Jackson&lt;/a&gt; as your JSON parser then this is how you enable it to allow comments:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;Jackson&lt;/a&gt; 을 JSON 파서로 사용하는 경우 다음과 같이 주석을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8246d0d3adbf7a7389d705ede0a752c209ba38" translate="yes" xml:space="preserve">
          <source>If you are using the Newtonsoft.Json library with ASP.NET to read/deserialize you can use comments in the JSON content:</source>
          <target state="translated">ASP.NET과 함께 Newtonsoft.Json 라이브러리를 사용하여 읽고 / 직렬화하는 경우 JSON 컨텐츠에서 주석을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cabeeb699eaf07605e124cb949346b747a7e0dac" translate="yes" xml:space="preserve">
          <source>If you follow the link, you will see</source>
          <target state="translated">링크를 따라 가면</target>
        </trans-unit>
        <trans-unit id="a63e2953b6b28d01b6fab0cd0c69b99f6574c7de" translate="yes" xml:space="preserve">
          <source>If you have a problem with this kind of usage; sorry, the genie is out of the lamp. People would find other usages for JSON format, and there is nothing you can do about it.</source>
          <target state="translated">이런 종류의 사용법에 문제가있는 경우 죄송합니다. 지니가 램프를 벗어났습니다. 사람들은 JSON 형식에 대한 다른 사용법을 찾을 수 있으며 할 수있는 일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="812bab4dd7487fc279216059de97088cf84dae7a" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://json5.org/&quot;&gt;JSON5&lt;/a&gt; you can include comments.</source>
          <target state="translated">&lt;a href=&quot;http://json5.org/&quot;&gt;JSON5&lt;/a&gt; 를 사용하는 경우 주석을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b08db292e52b29c91db521bfa2b81efa3280057a" translate="yes" xml:space="preserve">
          <source>If your text file, which is a JSON string, is going to be read by some program, how difficult would it be to strip out either C or C++ style comments before using it?</source>
          <target state="translated">일부 프로그램에서 JSON 문자열 인 텍스트 파일을 읽을 경우 사용하기 전에 C 또는 C ++ 스타일 주석을 제거하는 것이 얼마나 어려울까요?</target>
        </trans-unit>
        <trans-unit id="8aa49e3c9f29fe5a6b28c93b5f1a19ce858cb803" translate="yes" xml:space="preserve">
          <source>In a hacky way, you can abuse this to add a comment. For instance: start and end your comment with a tab. Encode the comment in base3 and use the other whitespace characters to represent them. For instance.</source>
          <target state="translated">해킹 된 방식으로이를 악용하여 주석을 추가 할 수 있습니다. 예를 들어 : 탭으로 주석을 시작하고 종료하십시오. base3에 주석을 인코딩하고 다른 공백 문자를 사용하여 주석을 표시하십시오. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="a5f24ec24556750ba15be59104e6be49937079bd" translate="yes" xml:space="preserve">
          <source>In my case, I need use comments for debug purposes, prior the output of the JSON structure. So I decided to use debug information in the HTTP header, to avoid breaking the client:</source>
          <target state="translated">필자의 경우 JSON 구조의 출력 전에 디버그 목적으로 주석을 사용해야합니다. 따라서 클라이언트를 손상시키지 않기 위해 HTTP 헤더에 디버그 정보를 사용하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="276120a4bf34bb8429f2b43928b3a0e4c6821d79" translate="yes" xml:space="preserve">
          <source>Insignificant whitespace is allowed before or after any token.
  Whitespace is any sequence of one or more of the following code
  points: character tabulation (U+0009), line feed (U+000A), carriage
  return (U+000D), and space (U+0020).</source>
          <target state="translated">토큰 앞뒤에 중요하지 않은 공백이 허용됩니다. 공백은 문자 코드 (U + 0009), 줄 바꿈 (U + 000A), 캐리지 리턴 (U + 000D) 및 공백 (U + 0020) 중 하나 이상의 코드 포인트 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="48b50f16ce601739669575140e95e21d988bae25" translate="yes" xml:space="preserve">
          <source>It appears that when declaring an object literal you can specify two values with the same key, and the last one takes precedence. Believe it or not, it turns out that JSON parsers work the same way. So we can use this to create comments in the source JSON that will not be present in a parsed object representation.</source>
          <target state="translated">객체 리터럴을 선언 할 때 동일한 키로 두 개의 값을 지정할 수 있으며 마지막 값이 우선합니다. 믿거 나 말거나 JSON 파서는 같은 방식으로 작동합니다. 따라서이를 사용하여 구문 분석 된 객체 표현에 표시되지 않는 소스 JSON에서 주석을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82cd8d15b1bd8e199799380ad43d59ee9b5ba712" translate="yes" xml:space="preserve">
          <source>It depends on your JSON library. &lt;a href=&quot;https://github.com/JamesNK/Newtonsoft.Json&quot;&gt;Json.NET&lt;/a&gt; supports JavaScript-style comments, &lt;code&gt;/* commment */&lt;/code&gt;.</source>
          <target state="translated">JSON 라이브러리에 따라 다릅니다. &lt;a href=&quot;https://github.com/JamesNK/Newtonsoft.Json&quot;&gt;Json.NET&lt;/a&gt; 은 JavaScript 스타일 주석, &lt;code&gt;/* commment */&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6ff7ed3f3d0cb930680ea06a91bdd9f410385b49" translate="yes" xml:space="preserve">
          <source>It doesn't really allow for comments as such, however, passing a comment as one of the name/value pairs in the data would certainly work, although that data would obviously need to be ignored or handled specifically by the parsing code.</source>
          <target state="translated">실제로 주석을 허용하지는 않지만 데이터에서 이름 / 값 쌍 중 하나 인 주석을 전달하면 분명히 작동하지만 데이터는 구문 분석 코드에서 특별히 무시하거나 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b19f596dc7224ce2f8d5b6d837618e59941abcb" translate="yes" xml:space="preserve">
          <source>It's an interesting curiosity, but you &lt;strong&gt;should really not be using it for anything at all&lt;/strong&gt;. Below is the original answer.</source>
          <target state="translated">흥미로운 호기심이지만 &lt;strong&gt;실제로는 아무것도 사용해서는 안됩니다&lt;/strong&gt; . 아래는 원래 답변입니다.</target>
        </trans-unit>
        <trans-unit id="74a40f3578a3c42e743f19623deb9c7f5d776631" translate="yes" xml:space="preserve">
          <source>JSON by design is an easily reverse-engineered (human parsed) alternative to XML. It is simplified even to the point that annotations are unnecessary. It is not even a markup language. The goal is stability and  interoperablilty.</source>
          <target state="translated">JSON 설계는 XML에 대한 리버스 엔지니어링 (휴먼 파싱) 대안입니다. 주석이 불필요 할 정도로 단순화되었습니다. 마크 업 언어도 아닙니다. 목표는 안정성과 상호 운용성입니다.</target>
        </trans-unit>
        <trans-unit id="8398b2bb763389aa2a2ee5d9f2352ebd5b7accf0" translate="yes" xml:space="preserve">
          <source>JSON can do all they can do, but it is way less verbose and more human readable - and parsers are easy and ubiquitous in many languages. It's just a tree of data. But out-of-band comments are a necessity often to document &quot;default&quot; configurations and the like. Configurations are never to be &quot;full documents&quot;, but trees of saved data that can be human readable when needed.</source>
          <target state="translated">JSON은 할 수있는 모든 것을 할 수 있지만 덜 장황하고 사람이 읽을 수있는 방식입니다. 파서는 많은 언어로 쉽고 편재합니다. 데이터 트리 일뿐입니다. 그러나 &quot;기본&quot;구성 등을 문서화하려면 대역 외 주석이 종종 필요합니다. 구성은 &quot;전체 문서&quot;가 될 필요는 없지만 필요할 때 사람이 읽을 수있는 저장된 데이터 트리입니다.</target>
        </trans-unit>
        <trans-unit id="8c1993e45bffed1300c1dc50e5447b301e83790f" translate="yes" xml:space="preserve">
          <source>JSON does not have comments. A JSON encoder MUST NOT output comments.
  A JSON decoder MAY accept and ignore comments.</source>
          <target state="translated">JSON에는 주석이 없습니다. JSON 인코더는 주석을 출력해서는 안됩니다 (MUST NOT). JSON 디코더는 주석을 수락하고 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e64a9d1e8c5e44b330ca7a7b80a5418ba7d47d" translate="yes" xml:space="preserve">
          <source>JSON does not support comments natively, but you can make your own decoder or at least preprocessor to strip out comments, that's perfectly fine (as long as you just ignore comments and don't use them to guide how your application should process the JSON data).</source>
          <target state="translated">JSON은 기본적으로 주석을 지원하지 않지만 주석을 무시하고 응용 프로그램에서 JSON 데이터를 처리하는 방법을 안내하는 데 사용하지 않는 한 주석을 제거하기 위해 자체 디코더 또는 최소한 전처리기를 만들 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="726f133617e74aa8751821a42ceb51d521bc92cd" translate="yes" xml:space="preserve">
          <source>JSON does not support comments. It was also never intended to be used for configuration files where comments would be needed.</source>
          <target state="translated">JSON은 주석을 지원하지 않습니다. 주석이 필요한 구성 파일에도 사용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="501bdc0f8fdf940649176ca24d143965cb8f6989" translate="yes" xml:space="preserve">
          <source>JSON doesn't allow comments, per se. The reasoning is utterly foolish, because you can use JSON &lt;em&gt;itself&lt;/em&gt; to create comments, which obviates the reasoning entirely, &lt;em&gt;and&lt;/em&gt; loads the parser data space for no good reason at all for &lt;em&gt;exactly&lt;/em&gt; the same result and potential issues, such as they are: a JSON file with comments.</source>
          <target state="translated">JSON 자체는 주석을 허용하지 않습니다. JSON &lt;em&gt;자체&lt;/em&gt; 를 사용하여 주석을 작성하여 추론을 완전히 방지하고 파서 데이터 공간을 아무런 이유없이 전혀 동일한 결과 및 잠재적 문제 (예 : JSON)로로드 할 수 있기 때문에 추론은 완전히 어리 석습니다. 주석이 포함 된 파일.</target>
        </trans-unit>
        <trans-unit id="09c3b12a027d2dcd8c91b9b62b6f273b10bad380" translate="yes" xml:space="preserve">
          <source>JSON has its syntax visualized on that page. There isn't any note about comments.</source>
          <target state="translated">JSON은 해당 페이지에 구문이 시각화되어 있습니다. 댓글에 대한 메모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="976fd2bc03bc2a22ff4f002d1679d2a1718f3011" translate="yes" xml:space="preserve">
          <source>JSON makes a lot of sense for config files and other local usage because it's ubiquitous and because it's much simpler than XML.</source>
          <target state="translated">JSON은 구성 파일 및 기타 로컬 사용에 유비쿼터스이며 XML보다 훨씬 단순하기 때문에 많은 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="000792ec4997245cbcd13240bdaead6035bcfda0" translate="yes" xml:space="preserve">
          <source>JSON-COM: JSON on the wire, or rules that apply when communicating JSON data.</source>
          <target state="translated">JSON-COM : 유선상의 JSON 또는 JSON 데이터 통신시 적용되는 규칙</target>
        </trans-unit>
        <trans-unit id="48b52d89e7b207194b31e0efa96191605763a131" translate="yes" xml:space="preserve">
          <source>JSON-DOC will allow comments, and other minor differences might exist such as handling whitespace. Parsers can easily convert from one spec to the other.</source>
          <target state="translated">JSON-DOC는 주석을 허용하며 공백 처리와 같은 사소한 차이점이있을 수 있습니다. 파서는 한 스펙에서 다른 스펙으로 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dbc0606e8c2b4a5f2222aeb77b6b7252bfd4168" translate="yes" xml:space="preserve">
          <source>JSON-DOC: JSON document, or JSON in files or locally. Rules that define a valid JSON document.</source>
          <target state="translated">JSON-DOC : JSON 문서 또는 파일의 JSON 또는 로컬 유효한 JSON 문서를 정의하는 규칙</target>
        </trans-unit>
        <trans-unit id="b019fec79fce564e6a858d4135ba07c6e432fcf0" translate="yes" xml:space="preserve">
          <source>No, you shouldn't use duplicative object members to stuff side channel data into a JSON encoding. (See &quot;The names within an object SHOULD be unique&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;in the RFC&lt;/a&gt;).</source>
          <target state="translated">아니요, 중복 채널 멤버를 사용하여 사이드 채널 데이터를 JSON 인코딩에 넣지 않아야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7159&quot;&gt;RFC의&lt;/a&gt; &quot;객체 내의 이름은 고유해야합니다&quot; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8b9f1367ad6269845f5ec54d66262066092883f" translate="yes" xml:space="preserve">
          <source>No.</source>
          <target state="translated">No.</target>
        </trans-unit>
        <trans-unit id="41f3445f00f7570dee2718e061446c8ba3e2c310" translate="yes" xml:space="preserve">
          <source>Other JavaScript toolkits may work similarly.</source>
          <target state="translated">다른 JavaScript 툴킷도 비슷하게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e64daaa3f687a35f3ef2e5959e2d88a2537414" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://hjson.org&quot;&gt;hjson.org&lt;/a&gt; for JavaScript, Java, Python, PHP, Rust, Go, Ruby and C# libraries.</source>
          <target state="translated">JavaScript, Java, Python, PHP, Rust, Go, Ruby 및 C # 라이브러리에 대해서는 &lt;a href=&quot;http://hjson.org&quot;&gt;hjson.org&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dfaf82f0dc0b49d0e045c25d554109dfb4f850f2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/a/10325432/166286&quot;&gt;another Stack&amp;nbsp;Overflow question&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/10325432/166286&quot;&gt;다른 스택 오버플로 질문을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="073200acf99512df8130754287c73186048bb656" translate="yes" xml:space="preserve">
          <source>Simply &lt;code&gt;npm install --save strip-json-comments&lt;/code&gt; to install and use it like:</source>
          <target state="translated">간단히 &lt;code&gt;npm install --save strip-json-comments&lt;/code&gt; 를 저장하고 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f506a3540bd757d871fdaa0806e59e8449171ae5" translate="yes" xml:space="preserve">
          <source>Since I had a similar file in my local folder, there were no issues with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;Same-origin policy&lt;/a&gt;, so I decided to use pure JSON... and, of course, &lt;code&gt;$.getJSON&lt;/code&gt; was failing silently because of the comments.</source>
          <target state="translated">로컬 폴더에 비슷한 파일이 있었기 때문에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Same-origin_policy&quot;&gt;동일한 출처 정책에&lt;/a&gt; 문제가 없었으므로 순수한 JSON을 사용하기로 결정했으며 물론 주석 때문에 &lt;code&gt;$.getJSON&lt;/code&gt; 이 자동으로 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="71afd90a6307c6c96cb48a0eb950d54ed21ba403" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://web.archive.org/web/20120507093915/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Public statement by Douglas Crockford on G+&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://web.archive.org/web/20120507093915/https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;G +에 대한 Douglas Crockford의 공개 성명&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7597ad58479a9cadb8c485eff7b25f3dcde2534b" translate="yes" xml:space="preserve">
          <source>Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser.</source>
          <target state="translated">주석을 추가하려는 구성 파일을 유지하기 위해 JSON을 사용한다고 가정하십시오. 계속해서 당신이 좋아하는 모든 의견을 삽입하십시오. 그런 다음 JSON 파서를 전달하기 전에 JSMin을 통해 파이프하십시오.</target>
        </trans-unit>
        <trans-unit id="95c4ec0c1f6b94f7fa15f8848f32685e381ea392" translate="yes" xml:space="preserve">
          <source>Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. - &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;Douglas Crockford, 2012&lt;/a&gt;</source>
          <target state="translated">주석을 추가하려는 구성 파일을 유지하기 위해 JSON을 사용한다고 가정하십시오. 계속해서 당신이 좋아하는 모든 의견을 삽입하십시오. 그런 다음 JSON 파서를 전달하기 전에 JSMin을 통해 파이프하십시오. - &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;더글러스 크록 포드, 2012&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a31010b229f5d5d38cb8460296b3ffc06502029e" translate="yes" xml:space="preserve">
          <source>Sure a JSON specific minify can be implemented in any language,
but standardize this so it becomes ubiquitous across parsers in all languages and platforms so people stop wasting their time lacking the feature because they have good use-cases for it, looking the issue up in online forums, and getting people telling them it's a bad idea or suggesting it's easy to implement stripping comments out of text files.</source>
          <target state="translated">JSON 특정 축소는 모든 언어로 구현할 수 있지만이를 표준화하여 모든 언어와 플랫폼의 파서 전체에서 유비쿼터스 화되므로 사람들은 유용한 사용 사례가 있기 때문에 기능이 부족하여 시간을 낭비하지 않고 문제를 찾아냅니다. 온라인 포럼, 사람들에게 나쁜 생각을 말하거나 텍스트 파일에서 주석 제거를 쉽게 구현할 수 있다고 제안합니다.</target>
        </trans-unit>
        <trans-unit id="3e99e6da8be38fff3a522f1f23ad02df352466c2" translate="yes" xml:space="preserve">
          <source>The Dojo Toolkit JavaScript toolkit (at least as of version 1.4), allows you to include comments in your JSON. The comments can be of &lt;code&gt;/* */&lt;/code&gt; format. Dojo Toolkit consumes the JSON via the &lt;code&gt;dojo.xhrGet()&lt;/code&gt; call.</source>
          <target state="translated">Dojo 툴킷 JavaScript 툴킷 (최소한 버전 1.4 이상)을 사용하면 JSON에 주석을 포함 할 수 있습니다. 주석은 &lt;code&gt;/* */&lt;/code&gt; 형식 일 수 있습니다. Dojo 툴킷은 &lt;code&gt;dojo.xhrGet()&lt;/code&gt; 호출을 통해 JSON을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="506b87b707c634e0b2a9ca847a5419d0c97d6a4c" translate="yes" xml:space="preserve">
          <source>The JSON should all be data, and if you include a comment, then it will be data too.</source>
          <target state="translated">JSON은 모두 데이터 여야하며 주석을 포함하면 데이터이기도합니다.</target>
        </trans-unit>
        <trans-unit id="29b2cd6789d0e06a6f2f17423431e5a7ccf21a24" translate="yes" xml:space="preserve">
          <source>The above code is &lt;a href=&quot;http://jsonlint.com/&quot;&gt;valid JSON&lt;/a&gt;. If you parse it, you'll get an object like this:</source>
          <target state="translated">위의 코드는 &lt;a href=&quot;http://jsonlint.com/&quot;&gt;유효한 JSON&lt;/a&gt; 입니다. 구문 분석하면 다음과 같은 객체가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b8f8fba45d519a650dd034779bb67724bec9b4eb" translate="yes" xml:space="preserve">
          <source>The idea behind JSON is to provide simple data exchange between applications. These are typically web based and the language is JavaScript.</source>
          <target state="translated">JSON의 기본 개념은 응용 프로그램간에 간단한 데이터 교환을 제공하는 것입니다. 이들은 일반적으로 웹 기반이며 언어는 JavaScript입니다.</target>
        </trans-unit>
        <trans-unit id="118eacae6b4f733ba3d8e27073279fa7d6945aa8" translate="yes" xml:space="preserve">
          <source>The official JSON site is at &lt;a href=&quot;http://json.org&quot;&gt;JSON.org&lt;/a&gt;. JSON is defined as a &lt;a href=&quot;http://ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;standard&lt;/a&gt; by ECMA International. There is always a petition process to have standards revised. It is unlikely that annotations will be added to the JSON standard for several reasons.</source>
          <target state="translated">공식 JSON 사이트는 &lt;a href=&quot;http://json.org&quot;&gt;JSON.org&lt;/a&gt; 입니다. JSON은 ECMA International에서 &lt;a href=&quot;http://ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;표준&lt;/a&gt; 으로 정의합니다. 표준을 수정하는 탄원 절차는 항상 있습니다. 몇 가지 이유로 주석이 JSON 표준에 추가되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6de039dc41d4aabcce5230d7a4c62570374729b7" translate="yes" xml:space="preserve">
          <source>The other issue is interoperability. Suppose you have a library or API or any kind of subsystem which has some config or data files associated with it. And this subsystem is
to be accessed from different languages.  Then do you go about telling people: by the way
don't forget to strip out the comments from the JSON files before passing them to the parser!</source>
          <target state="translated">다른 문제는 상호 운용성입니다. 라이브러리 또는 API 또는 이와 관련된 일부 구성 또는 데이터 파일이있는 모든 종류의 서브 시스템이 있다고 가정하십시오. 이 하위 시스템은 다른 언어로 액세스해야합니다. 그런 다음 사람들에게 알려주십시오. 그런데 파서로 전달하기 전에 JSON 파일에서 주석을 제거하는 것을 잊지 마십시오!</target>
        </trans-unit>
        <trans-unit id="d0841b7455110d89326e1a28a5e44e10c4570e5d" translate="yes" xml:space="preserve">
          <source>Then encode your comment in binary:</source>
          <target state="translated">그런 다음 주석을 바이너리로 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="cb80cdc45aa7b8b143f7abe549b0a2a38ef5ca01" translate="yes" xml:space="preserve">
          <source>Then steg your binary:</source>
          <target state="translated">그런 다음 바이너리를 훔치십시오.</target>
        </trans-unit>
        <trans-unit id="93ae98bd84aa4fbc409553d7cab4dfbf8d06c00b" translate="yes" xml:space="preserve">
          <source>Then you can have comments like this:</source>
          <target state="translated">그러면 다음과 같은 의견을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49db07c0eb71bb872bdde75cfbad8f1430e8e945" translate="yes" xml:space="preserve">
          <source>There is actually a way to add comments, and stay within the spec (no additional parser needed). It will not result into human-readable comments without any sort of parsing though.</source>
          <target state="translated">실제로 의견을 추가하고 사양 내에 머무를 수있는 방법이 있습니다 (추가 파서가 필요 없음). 그래도 구문 분석이 없으면 사람이 읽을 수있는 주석이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="939c8690fd4debc3efc52fd16ff9fa763116587f" translate="yes" xml:space="preserve">
          <source>This can be helpful when experimenting with alternate data structures (or even data lists) before choosing a final option.</source>
          <target state="translated">최종 옵션을 선택하기 전에 대체 데이터 구조 (또는 데이터 목록)를 실험 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f64679fe6571746a9ba9e6ac37f387ce8686d481" translate="yes" xml:space="preserve">
          <source>This is a &lt;strong&gt;&quot;can you&quot;&lt;/strong&gt; question. And here is a &lt;strong&gt;&quot;yes&quot;&lt;/strong&gt; answer.</source>
          <target state="translated">이것은 &lt;strong&gt;&quot;당신&lt;/strong&gt; 이 &lt;strong&gt;할 수있는&quot;&lt;/strong&gt; 질문입니다. 그리고 여기 &lt;strong&gt;&quot;예&quot;가&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fdccc472b5b375de3890696c9e5a380489af6fb" translate="yes" xml:space="preserve">
          <source>This only annotation required might be &quot;//These are DAG tags&quot;. The key names can be as informative as required, allowing arbitrary semantic arity.</source>
          <target state="translated">필요한 주석은 &quot;// 이것은 DAG 태그&quot;일 수 있습니다. 키 이름은 필요에 따라 정보를 제공 할 수 있으므로 임의의 의미를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b00a22cb69ded735c57bf505cdfefe076ebaa9" translate="yes" xml:space="preserve">
          <source>This will just leave you with a lot of unreadable whitespace (unless you make an IDE plugin to encode/decode it on the fly).</source>
          <target state="translated">이것은 IDE를 플러그인하여 즉시 인코딩 / 디코딩하지 않는 한 읽을 수없는 많은 공백을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="388b829f16dd17f84ea2ba8d1476b6313b19ec03" translate="yes" xml:space="preserve">
          <source>To cut a JSON item into parts I add &quot;dummy comment&quot; lines:</source>
          <target state="translated">JSON 항목을 부분으로 자르려면 &quot;더미 주석&quot;줄을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c46c93b452125db5e01ac6f5b129d24508a4638b" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://github.com/sindresorhus/strip-json-comments&quot;&gt;&lt;code&gt;strip-json-comments&lt;/code&gt;&lt;/a&gt; for our project. It supports something like:</source>
          <target state="translated">우리는 프로젝트에 &lt;a href=&quot;https://github.com/sindresorhus/strip-json-comments&quot;&gt; &lt;code&gt;strip-json-comments&lt;/code&gt; &lt;/a&gt; 를 사용하고 있습니다. 그것은 다음과 같은 것을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="3541c15e44949bf6aaf515ad0f11200bb4b27c8a" translate="yes" xml:space="preserve">
          <source>We're talking about a generic config file issue (cross language/platform), and he's answering with a JS specific utility!</source>
          <target state="translated">우리는 일반적인 구성 파일 문제 (cross language / platform)에 대해 이야기하고 있으며 JS 특정 유틸리티로 응답하고 있습니다!</target>
        </trans-unit>
        <trans-unit id="40086162c11724bb65bc484b7a663182d4a0214f" translate="yes" xml:space="preserve">
          <source>When I released it, I got a huge backlash of people disagreeing with even the idea of it, so I decided that I'd write a comprehensive blog post on why &lt;a href=&quot;http://web.archive.org/web/20100629021329/http://blog.getify.com/2010/06/json-comments/&quot;&gt;comments make sense in JSON&lt;/a&gt;. It includes this notable comment from the creator of JSON:</source>
          <target state="translated">내가 그것을 발표했을 때, 나는 그것의 아이디어조차도 반대하는 사람들의 엄청난 반발을 얻었으므로 &lt;a href=&quot;http://web.archive.org/web/20100629021329/http://blog.getify.com/2010/06/json-comments/&quot;&gt;JSON에서 주석이&lt;/a&gt; 왜 합리적 인지에 대한 포괄적 인 블로그 게시물을 작성하기로 결정했습니다. JSON 작성자의 주목할만한 주석이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98fd7e23dcf6f9b9b1816044ced909699b4c49f7" translate="yes" xml:space="preserve">
          <source>Which means there is no trace of the comments, and they won't have weird side-effects.</source>
          <target state="translated">즉, 주석의 흔적이 없으며 이상한 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4cb6522fff6a5d557f0d476627f9ece04ec2cfd" translate="yes" xml:space="preserve">
          <source>With regards to the &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;remark&lt;/a&gt; made by Douglas Crockford on this issues (referenced by @Artur Czajka)</source>
          <target state="translated">이 문제에 대해 Douglas Crockford의 &lt;a href=&quot;https://plus.google.com/118095276221607585885/posts/RK8qyGVaGSr&quot;&gt;발언&lt;/a&gt; 과 관련하여 (@Artur Czajka가 참조)</target>
        </trans-unit>
        <trans-unit id="feaa09360dfd54411746acac2798b890bddec1c2" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;can&lt;/em&gt; have comments in &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;, but not in pure JSON. I've just spent an hour trying to make my program work with this example from Highcharts: &lt;a href=&quot;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&quot;&gt;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; 에는 주석을 &lt;em&gt;사용할 수&lt;/em&gt; 있지만 순수한 JSON에는 주석을 &lt;em&gt;사용할 수&lt;/em&gt; 없습니다. 방금 Highcharts 에서이 예제를 사용하여 프로그램을 작성하려고 한 시간을 보냈습니다. &lt;a href=&quot;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&quot;&gt;http://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;amp;callback=?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1deff785b9f44f36c7ffb11fb73ab887e7163ffb" translate="yes" xml:space="preserve">
          <source>You can provide documentation by using the &lt;strong&gt;description&lt;/strong&gt; schema attribute.</source>
          <target state="translated">&lt;strong&gt;설명&lt;/strong&gt; 스키마 속성을 사용하여 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6321e0e7526a00ea19de7e51a8a6484deb9e4c60" translate="yes" xml:space="preserve">
          <source>You can't. At least that's my experience from a quick glance at &lt;a href=&quot;http://json.org&quot;&gt;json.org&lt;/a&gt;.</source>
          <target state="translated">당신은 할 수 없습니다. 적어도 그것은 &lt;a href=&quot;http://json.org&quot;&gt;json.org&lt;/a&gt; 에서 한눈에 보는 나의 경험입니다.</target>
        </trans-unit>
        <trans-unit id="a38662ff523b7d9c8a3a3c993706047579876c91" translate="yes" xml:space="preserve">
          <source>You could abuse the following:</source>
          <target state="translated">다음을 남용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3df4432a8595e033223ec8fe5e551c685694e2" translate="yes" xml:space="preserve">
          <source>You could have a designated data element called &lt;code&gt;&quot;_comment&quot;&lt;/code&gt; (or something) that would be ignored by apps that use the JSON data.</source>
          <target state="translated">JSON 데이터를 사용하는 앱에서 무시할 &lt;code&gt;&quot;_comment&quot;&lt;/code&gt; (또는 무언가)라는 지정된 데이터 요소를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d1a793bb1b7d02580215fd79bb3a42efc2f9543" translate="yes" xml:space="preserve">
          <source>You should write a &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON schema&lt;/a&gt; instead. JSON schema is currently a proposed Internet draft specification. Besides documentation, the schema can also be used for validating your JSON data.</source>
          <target state="translated">대신 &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON 스키마&lt;/a&gt; 를 작성해야합니다. JSON 스키마는 현재 제안 된 인터넷 초안 사양입니다. 문서 외에도 스키마를 사용하여 JSON 데이터를 검증 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1eb38f94b01dd40159fa9e41b98ceba4ac1117" translate="yes" xml:space="preserve">
          <source>You would probably be better having the comment in the processes that generates/receives the JSON, as they are supposed to know what the JSON data will be in advance, or at least the structure of it.</source>
          <target state="translated">JSON을 생성 / 수신하는 프로세스에 JSON 데이터가 무엇인지 또는 적어도 구조가 무엇인지 알고 있어야하기 때문에 주석을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7e147e80eb87acbe7b929c746720cc66c49a3fae" translate="yes" xml:space="preserve">
          <source>comment example */</source>
          <target state="translated">주석 예 * /</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
