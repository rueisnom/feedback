<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/60174">
    <body>
      <group id="60174">
        <trans-unit id="28db4e540747091b7a00b15b115a95e87c6fb18f" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;$conn&lt;/code&gt; is a &lt;code&gt;PDO&lt;/code&gt; object)</source>
          <target state="translated">( &lt;code&gt;$conn&lt;/code&gt; является объектом &lt;code&gt;PDO&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7df4be97ec047ed1a29912298ea3b0fcbc7ed380" translate="yes" xml:space="preserve">
          <source>--- &lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">--- &lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="566ea8d89155c02c58ff63984dcd175883a55e5f" translate="yes" xml:space="preserve">
          <source>---- &lt;strong&gt;PDO&lt;/strong&gt;</source>
          <target state="translated">---- &lt;strong&gt;PDO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="16d6eec24d215237193fd125401ea3f72038ce7c" translate="yes" xml:space="preserve">
          <source>----- Named placeholders</source>
          <target state="translated">-----Названные плательщики</target>
        </trans-unit>
        <trans-unit id="6f87ec96d5b86996a40f5259f92fc7fad65ced43" translate="yes" xml:space="preserve">
          <source>----- No placeholders - ripe for SQL injection! &lt;strong&gt;It's bad&lt;/strong&gt;</source>
          <target state="translated">----- Нет заполнителей - созрели для SQL-инъекций! &lt;strong&gt;Это плохо&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcff74f12914fdb8c051ea2e336776fd176f90" translate="yes" xml:space="preserve">
          <source>----- Unnamed placeholders</source>
          <target state="translated">-----Неименованные владельцы</target>
        </trans-unit>
        <trans-unit id="c8f539c5cc020994d7d2752bb0266689882010b0" translate="yes" xml:space="preserve">
          <source>// Connect to MySQL</source>
          <target state="translated">/Подключиться к MySQL</target>
        </trans-unit>
        <trans-unit id="210d7dde35cddea92280995918b6bfd938945cd2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;Source&lt;/a&gt;: &lt;em&gt;The Unexpected SQL Injection (When Escaping Is Not Enough)&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;Источник&lt;/a&gt; : &lt;em&gt;Неожиданный SQL-инъекция (когда побега недостаточно)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fafbba6ac674ca8233b3bb137474220f54670c01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash; Escapes a string for use in a mysql_query</source>
          <target state="translated">&lt;code&gt;mysql_escape_string&lt;/code&gt; - экранирует строку для использования в mysql_query</target>
        </trans-unit>
        <trans-unit id="2acf2cfec503ef763160d951705f3dcc3dbb00be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; is deprecated as of PHP 5.5.0. Use either mysqli or PDO.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; PHP 5.5.0, mysql_real_escape_string () устарела. Используйте либо MySQL, либо PDO.</target>
        </trans-unit>
        <trans-unit id="ac2812cda025d0222eb136ebe05af667375a9255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string&lt;/code&gt; takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(') a user might enter with a MySQL-safe substitute, an escaped quote \'.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string&lt;/code&gt; принимает строку, которая будет использоваться в запросе MySQL, и возвращает ту же строку, если все попытки внедрения SQL были безопасно завершены. По сути, он заменит те неприятные кавычки ('), которые пользователь может ввести, заменой, безопасной для MySQL, - экранированной кавычкой \'.</target>
        </trans-unit>
        <trans-unit id="993cce94e6973d25742799e350d687c6d47eb565" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;What is SQL injection and how to prevent&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;Что такое SQL-инъекция и как ее предотвратить?&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eedc1ef7aa89311e0fab1b48d2dbf4f551aa710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;Microsoft explanation of SQL injection and prevention in PHP&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;Microsoft объяснение SQL инъекций и предотвращения в PHP&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09a2090f97db4e53860ae5ab475445cb9ea655d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;PHP manual for SQL injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;Руководство по PHP для внедрения SQL&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b6995e63bfc6f9fa8ec35b4a707089f01068f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And please test every query to your database - it's a better way to prevent injection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;И, пожалуйста, проверяйте каждый запрос к вашей базе данных - это лучший способ предотвратить инъекцию.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="881c07549030945c2309cee9e2e2ac2c9261312f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data filtering for (converting unsafe data to safe data)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Фильтрация данных для (преобразования небезопасных данных в безопасные данные)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b74390d8460cdf00400fa1ae06a8df3cec12865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;
  This answer's sample code (like the question's sample code) uses PHP's &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.</source>
          <target state="translated">&lt;strong&gt;Устаревшее предупреждение.&lt;/strong&gt; В примере кода этого ответа (например, в примере кода вопроса) используется расширение &lt;code&gt;MySQL&lt;/code&gt; от PHP, которое устарело в PHP 5.5.0 и полностью удалено в PHP 7.0.0.</target>
        </trans-unit>
        <trans-unit id="1051e53e86d6b39bb445cb5e011266551db0339e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning&lt;/strong&gt;: The mysql extension is deprecated at this time. we recommend using the &lt;em&gt;PDO extension&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Устаревшее предупреждение&lt;/strong&gt; : в настоящее время расширение mysql устарело. мы рекомендуем использовать &lt;em&gt;расширение PDO&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dda06a174f7dd5e74c8eabf80656879e8b1f296" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single column&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Я хочу одну колонку&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80c1cc3b7b50e8fd2aea1b4ca0b3b75408434e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single row result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Я хочу один результат строки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="024c9614f439c4a7911a75baa6232c91c34e16cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array of results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Я хочу массив результатов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4dc6dc4cb39edde6e4cb977be5a4e00bfee01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array(key =&amp;gt; value) results (i.e. for making a selectbox)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Я хочу, чтобы массив (ключ =&amp;gt; значение) результатов (т.е. для создания selectbox)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8052e9a559828f926aaf4cb0e3c1b2ca31046e95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IMPORTANT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cde4be58e6e2d465148f3e98b5727244f7a72453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Примеры библиотек:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e446408dbdb6997b7424912b8c1d79a1c5ab993b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23d6bf55f17ae053d22c5b227546c45610ff250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c585f3da07abdc2dcc052b0a31c75b51345fff8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; you must be connected to the database to use this function!</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ:&lt;/strong&gt; вы должны быть подключены к базе данных, чтобы использовать эту функцию!</target>
        </trans-unit>
        <trans-unit id="a67dc084aafad94a19d93929a672c4d8c26d1f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;P.S&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b10a86d4bbe9f0b1901a8bde6b52d5685220b62b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PDO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PDO:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3a71e18b47cb4549c122f88532d562818113692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Query Log:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Журнал запросов:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b772547fb5634e5dbe11cab975563db5faff2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RULE: do not create one database user for all privileges. For all SQL operations, you can create your scheme like (deluser, selectuser, updateuser) as usernames for easy usage.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ПРАВИЛО: не создавайте одного пользователя базы данных для всех привилегий.&lt;/strong&gt; &lt;strong&gt;Для всех операций SQL вы можете создать свою схему, такую ​​как (deluser, selectuser, updateuser) в качестве имен пользователей для простоты использования.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e3668d2a13faa5a6d222104bab0c82a2d2b1525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)</source>
          <target state="translated">&lt;strong&gt;Предупреждение безопасности&lt;/strong&gt; : этот ответ не соответствует рекомендациям по безопасности. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;Экранирование недостаточно для предотвращения внедрения SQL&lt;/a&gt; , вместо этого используйте &lt;em&gt;подготовленные операторы&lt;/em&gt; . Используйте изложенную ниже стратегию на свой страх и риск. (Кроме того, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; была удалена в PHP 7.)</target>
        </trans-unit>
        <trans-unit id="69b9b6580cb9915e7a2d71a41230225b3ca5ffb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UNHEX()&lt;/strong&gt; works on &lt;strong&gt;any&lt;/strong&gt; column; you do not have to worry about the empty string.</source>
          <target state="translated">&lt;strong&gt;UNHEX ()&lt;/strong&gt; работает на &lt;strong&gt;любом&lt;/strong&gt; столбце; вам не нужно беспокоиться о пустой строке.</target>
        </trans-unit>
        <trans-unit id="e7d6310b11ad04ede1d86386dd85ffa2b6b00627" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use prepared statements and parameterized queries.&lt;/strong&gt; These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.</source>
          <target state="translated">&lt;strong&gt;Используйте подготовленные операторы и параметризованные запросы.&lt;/strong&gt; Это операторы SQL, которые отправляются и анализируются сервером базы данных отдельно от любых параметров. Таким образом, злоумышленник не сможет внедрить вредоносный SQL.</target>
        </trans-unit>
        <trans-unit id="4b66375073c94d88e7cae14419ae8276f33a993c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning: the approach described in this answer only applies to very specific scenarios and isn't secure since SQL injection attacks do not only rely on being able to inject &lt;code&gt;X=Y&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Предупреждение: подход, описанный в этом ответе, применим только к очень конкретным сценариям и небезопасен, поскольку атаки с использованием SQL-инъекций основаны не только на возможности внедрения &lt;code&gt;X=Y&lt;/code&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="167a410708537f3843a1e61a18f3cd510d6bcd35" translate="yes" xml:space="preserve">
          <source>A few guidelines for escaping special characters in SQL statements.</source>
          <target state="translated">Несколько рекомендаций по экранированию специальных символов в SQL-операторах.</target>
        </trans-unit>
        <trans-unit id="260ac50ca6144215fd0045d1af48ccfa01e745f8" translate="yes" xml:space="preserve">
          <source>A good idea is to use an &lt;strong&gt;'object-relational mapper'&lt;/strong&gt; like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt;:</source>
          <target state="translated">Хорошая идея - использовать &lt;strong&gt;&amp;laquo;объектно-реляционный маппер&amp;raquo;,&lt;/strong&gt; такой как &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1f6d894b7333493ff06b2ed34e4c107a54abe2c5" translate="yes" xml:space="preserve">
          <source>A simple way would be to use a PHP framework like &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt; or &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; which have inbuilt features like filtering and active-record so that you don't have to worry about these nuances.</source>
          <target state="translated">Простой способ - использовать PHP-фреймворк, такой как &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt; или &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel,&lt;/a&gt; который имеет встроенные функции, такие как фильтрация и активная запись, так что вам не придется беспокоиться об этих нюансах.</target>
        </trans-unit>
        <trans-unit id="a4f547e2a90f5422256b70e6749192b1dc12e925" translate="yes" xml:space="preserve">
          <source>A user commented that this post is useless, OK! Here is what &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORG provided&lt;/a&gt;:</source>
          <target state="translated">Пользователь прокомментировал, что этот пост бесполезен, хорошо! Вот что &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;предоставил OWASP.ORG&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f8bcba9062fd4c5354b3fe7577630f1852a5a4f1" translate="yes" xml:space="preserve">
          <source>Additional defenses:</source>
          <target state="translated">Дополнительная защита:</target>
        </trans-unit>
        <trans-unit id="5a9a57fdfe801732160d7b653550c5f2e63ef2a2" translate="yes" xml:space="preserve">
          <source>Adopting the MVC pattern and a framework like &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt; or &lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter&lt;/a&gt; is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries.</source>
          <target state="translated">Принятие шаблона MVC и инфраструктуры, такой как &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt; или &lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter&lt;/a&gt; , вероятно, является правильным решением: общие задачи, такие как создание безопасных запросов к базе данных, были решены и централизованно реализованы в таких платформах. Они помогают разумно организовать ваше веб-приложение и заставляют думать больше о загрузке и сохранении объектов, чем о безопасном построении отдельных SQL-запросов.</target>
        </trans-unit>
        <trans-unit id="c8a14a30d16f16ac980bf356d9504fab38b7075b" translate="yes" xml:space="preserve">
          <source>Also Enforce: Least Privilege</source>
          <target state="translated">А также Enforce:Наименее привилегия</target>
        </trans-unit>
        <trans-unit id="1896c2015dcc61c975328aa2d6d19cd66a93eed3" translate="yes" xml:space="preserve">
          <source>Also Perform: White List Input Validation</source>
          <target state="translated">Играй:Белый список Валидация ввода</target>
        </trans-unit>
        <trans-unit id="a7a90d96967d5c49bc4afaed57e9dee54e4e9f9c" translate="yes" xml:space="preserve">
          <source>Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt;.</source>
          <target state="translated">Кроме того, как и предлагали другие, вам может оказаться полезным / проще увеличить уровень абстракции с помощью чего-то вроде &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c30cce0b8c2965ca51b265a25df9d3693f83528" translate="yes" xml:space="preserve">
          <source>Also, its use is a little complicated if you are about to insert an empty string. You'll have to entirely replace it with &lt;code&gt;''&lt;/code&gt;, or you'll get an error.</source>
          <target state="translated">Кроме того, его использование немного сложнее, если вы собираетесь вставить пустую строку. Вам придется полностью заменить его на &lt;code&gt;''&lt;/code&gt; , иначе вы получите ошибку.</target>
        </trans-unit>
        <trans-unit id="69c4f0f8d46827c16603dcdf21511ca657bcb9e9" translate="yes" xml:space="preserve">
          <source>Also, you can 'prepare' your arguments before preparing your query so that you can build dynamic queries and at the end have a fully prepared statements query. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">Кроме того, вы можете &amp;laquo;подготовить&amp;raquo; свои аргументы перед подготовкой запроса, чтобы вы могли строить динамические запросы и в конце получить полностью подготовленный запрос операторов. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;Уровень абстракции базы данных DALMP для MySQL с использованием PHP.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74d699a30675fa3d298fbab5df176b5b25503844" translate="yes" xml:space="preserve">
          <source>Although there is a general agreement on the best practices regarding SQL injection protection, there are &lt;strong&gt;still many bad practices as well.&lt;/strong&gt; And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) &lt;strong&gt;more than 80 deleted answers&lt;/strong&gt; - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of the bad answers aren't deleted, but rather prospering.</source>
          <target state="translated">Хотя существует общее согласие с лучшими практиками, касающимися защиты от SQL-инъекций, все &lt;strong&gt;еще существует много плохих практик.&lt;/strong&gt; И некоторые из них слишком глубоко укоренились в сознании пользователей PHP. Например, на этой самой странице (хотя и невидимо для большинства посетителей) &lt;strong&gt;более 80 удаленных ответов&lt;/strong&gt; - все они удалены сообществом из-за плохого качества или из-за пропаганды плохой и устаревшей практики. Хуже того, некоторые плохие ответы не удаляются, а процветают.</target>
        </trans-unit>
        <trans-unit id="eabd1c8f5b2f8e2b973f2b52cc71e91a5bb24985" translate="yes" xml:space="preserve">
          <source>Although you can set the &lt;code&gt;charset&lt;/code&gt; in the options of the constructor, it's important to note that 'older' versions of PHP (before 5.3.6) &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;silently ignored the charset parameter&lt;/a&gt; in the DSN.</source>
          <target state="translated">Хотя вы можете установить &lt;code&gt;charset&lt;/code&gt; в опциях конструктора, важно отметить, что &amp;laquo;старые&amp;raquo; версии PHP (до 5.3.6) &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;молча игнорировали параметр charset&lt;/a&gt; в DSN.</target>
        </trans-unit>
        <trans-unit id="89427a94f14d4db682ce047617bd39f90aeb83cc" translate="yes" xml:space="preserve">
          <source>An alternative to mysql_real_escape_string() is</source>
          <target state="translated">Альтернативой функции mysql_real_escape_string()является функция</target>
        </trans-unit>
        <trans-unit id="7bcc7fb301834a94c428663cf127b9d3c420bafb" translate="yes" xml:space="preserve">
          <source>And OWASP makes it even worse, stressing on escaping &lt;em&gt;user input&lt;/em&gt; which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It's the destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is &quot;safe&quot; or not) he/she takes his/her first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.</source>
          <target state="translated">И OWASP делает это еще хуже, подчеркивая необходимость избегать &lt;em&gt;пользовательского ввода,&lt;/em&gt; что является абсолютной чепухой: в контексте защиты от инъекций не должно быть таких слов. Каждая переменная потенциально опасна - независимо от источника! Или, другими словами - каждая переменная должна быть правильно отформатирована, чтобы ее можно было вставить в запрос - независимо от источника снова. Это пункт назначения, который имеет значение. В тот момент, когда разработчик начинает отделять овец от коз (думая, является ли какая-то конкретная переменная &amp;laquo;безопасной&amp;raquo; или нет), он / она делает свой первый шаг к катастрофе. Не говоря уже о том, что даже формулировка предполагает массовый выход в точке входа, напоминающий функцию очень волшебных кавычек - уже презирали, осуждали и удаляли.</target>
        </trans-unit>
        <trans-unit id="029c0a0374bedd82f613d03ef16978761b30cf7e" translate="yes" xml:space="preserve">
          <source>And by using PDO rather than &lt;code&gt;mysql_&lt;/code&gt;, &lt;code&gt;mysqli_&lt;/code&gt;, and &lt;code&gt;pgsql_&lt;/code&gt; functions, you make your application a little more abstracted from the database, in the rare occurrence that you have to switch database providers.</source>
          <target state="translated">И используя функции PDO, а не функции &lt;code&gt;mysql_&lt;/code&gt; , &lt;code&gt;mysqli_&lt;/code&gt; и &lt;code&gt;pgsql_&lt;/code&gt; , вы делаете свое приложение немного более абстрагированным от базы данных, в редких случаях, когда вам приходится переключать поставщиков баз данных.</target>
        </trans-unit>
        <trans-unit id="9b5ef3ee55266b405431414057f96c242ca0a3ea" translate="yes" xml:space="preserve">
          <source>And it is so much better to use those functions to check input data with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">И гораздо лучше использовать эти функции для проверки входных данных с помощью &lt;code&gt;mysql_real_escape_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6f9dd7708882555f93273050b2295e1ff50293" translate="yes" xml:space="preserve">
          <source>And prepared statements cover only two of them.</source>
          <target state="translated">И подготовленные заявления охватывают только два из них.</target>
        </trans-unit>
        <trans-unit id="9a818eb4d9f22f32e544143c95e4a338abac3b6a" translate="yes" xml:space="preserve">
          <source>And some other like &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;Preventing SQL injection with MySQL and PHP&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">И некоторые другие, такие как &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;предотвращение внедрения SQL с MySQL и PHP&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9c32269a2494bf681823b0f8ef4fe2f380c0b7" translate="yes" xml:space="preserve">
          <source>And the use of &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is a useful function when used properly, especially when combined with &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">И использование &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; для, как следует из названия, экранирования специальных символов в строке, поэтому оно не сделает целые числа безопасными. Цель этой функции - предотвратить разрыв строк в операторах SQL и повреждение базы данных, которое она может вызвать. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; - полезная функция при правильном использовании, особенно в сочетании с &lt;code&gt;sprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77fdc73c5a405950cdef3ff428d3bc7c8429a576" translate="yes" xml:space="preserve">
          <source>And then just select whatever data ones want. Isn't it cool?</source>
          <target state="translated">А потом просто выберите то,что нужно для данных.Разве это не круто?</target>
        </trans-unit>
        <trans-unit id="469e5ab140693a349e074c76557802c31c33fd02" translate="yes" xml:space="preserve">
          <source>Another benefit of using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.</source>
          <target state="translated">Еще одним преимуществом использования подготовленных операторов является то,что если вы выполните один и тот же оператор много раз в одной и той же сессии,то он будет разобран и скомпилирован только один раз,что даст вам некоторую прибавку в скорости.</target>
        </trans-unit>
        <trans-unit id="ac2632462245c897b1b550ec3d5bcf2e8b29db73" translate="yes" xml:space="preserve">
          <source>Any other query part, such as an SQL keyword, a table or a field name, or an operator - must be filtered through a white list.</source>
          <target state="translated">Любая другая часть запроса,например,ключевое слово SQL,имя таблицы,поля или оператора-должна быть отфильтрована через белый список.</target>
        </trans-unit>
        <trans-unit id="59ca1e0dddd5402d6c514f23b5ab618318bd9b52" translate="yes" xml:space="preserve">
          <source>Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the &lt;code&gt;$name&lt;/code&gt; variable contains &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; the result would simply be a search for the string &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt;, and you will not end up with &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;an empty table&lt;/a&gt;.</source>
          <target state="translated">Любые параметры, которые вы отправляете при использовании подготовленного оператора, будут просто обрабатываться как строки (хотя ядро ​​базы данных может выполнить некоторую оптимизацию, поэтому, конечно, параметры могут также оказаться числами). В приведенном выше примере, если переменная &lt;code&gt;$name&lt;/code&gt; содержит &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; УДАЛИТЬ ИЗ сотрудников. Результатом будет просто поиск строки &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt; , и вы не получите &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;пустую таблицу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="814927018a663b40d6800585c37e63752cd8b345" translate="yes" xml:space="preserve">
          <source>Any variable that represents an SQL data literal, (or, to put it simply - an SQL string, or a number) must be added through a prepared statement. No Exceptions.</source>
          <target state="translated">Любая переменная,представляющая собой литерал SQL-данных (или,проще говоря,SQL-строку или число),должна быть добавлена через подготовленный оператор.Никаких исключений.</target>
        </trans-unit>
        <trans-unit id="8f339838f01ea88e77c778fe86da6db1dbb6727f" translate="yes" xml:space="preserve">
          <source>As also mentioned in the above statement,</source>
          <target state="translated">Как также упоминалось в вышеуказанном заявлении,</target>
        </trans-unit>
        <trans-unit id="35a0aae8525a92229ff81ec077bfddd794e5ad1c" translate="yes" xml:space="preserve">
          <source>As you can see, people suggest you use prepared statements at the most. It's not wrong, but when your query is executed &lt;strong&gt;just once&lt;/strong&gt; per process, there would be a slight performance penalty.</source>
          <target state="translated">Как видите, люди советуют вам использовать максимально подготовленные высказывания. Это не так, но когда ваш запрос выполняется &lt;strong&gt;только один раз&lt;/strong&gt; за процесс, это может привести к небольшому снижению производительности.</target>
        </trans-unit>
        <trans-unit id="bd2cedbc3cba1b466c7ccb0d7d8ccb2234565bfd" translate="yes" xml:space="preserve">
          <source>As you may know, claiming an article should be supported by a valid argument, at least by one reference! Otherwise, it's considered as an attack and a bad claim!</source>
          <target state="translated">Как вы,возможно,знаете,утверждение,что статья должна быть подкреплена обоснованным аргументом,по крайней мере,одной ссылкой! В противном случае,это считается атакой и плохим утверждением!</target>
        </trans-unit>
        <trans-unit id="820ba4d63bbc346ca4423e23a1bea3ca67844669" translate="yes" xml:space="preserve">
          <source>Basically, read it &lt;a href=&quot;http://php.net/pdo&quot;&gt;while you read the manual&lt;/a&gt; to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format &lt;strong&gt;you&lt;/strong&gt; want.</source>
          <target state="translated">В основном, читайте его &lt;a href=&quot;http://php.net/pdo&quot;&gt;, читая руководство,&lt;/a&gt; чтобы узнать, как использовать функции PDO в реальной жизни, чтобы упростить хранение и получение значений в нужном формате.</target>
        </trans-unit>
        <trans-unit id="984f8b5a40d91fa830e321cc52151441d3cd3388" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;1=1&lt;/code&gt;, &lt;code&gt;2=2&lt;/code&gt;, &lt;code&gt;1=2&lt;/code&gt;, &lt;code&gt;2=1&lt;/code&gt;, &lt;code&gt;1+1=2&lt;/code&gt;, etc... are the common questions to an SQL database of an attacker. Maybe also it's used by many hacking applications.</source>
          <target state="translated">Поскольку &lt;code&gt;1=1&lt;/code&gt; , &lt;code&gt;2=2&lt;/code&gt; , &lt;code&gt;1=2&lt;/code&gt; , &lt;code&gt;2=1&lt;/code&gt; , &lt;code&gt;1+1=2&lt;/code&gt; и т. Д., - это общие вопросы для базы данных SQL злоумышленника. Возможно также он используется многими хакерскими приложениями.</target>
        </trans-unit>
        <trans-unit id="c0510df3f1d4695430a58920cd200e354ad3da70" translate="yes" xml:space="preserve">
          <source>Bound variables will be escaped automatically by the server. The
  server inserts their escaped values at the appropriate places into the
  statement template before execution. A hint must be provided to the
  server for the type of bound variable, to create an appropriate
  conversion. See the mysqli_stmt_bind_param() function for more
  information.</source>
          <target state="translated">Входящие переменные будут автоматически экранированы сервером.Сервер вставляет свои экранированные значения в соответствующих местах в шаблон оператора перед выполнением.Серверу должна быть предоставлена подсказка о типе связанной переменной,чтобы создать соответствующее преобразование.Дополнительную информацию смотрите в функции mysqli_stmt_bind_param().</target>
        </trans-unit>
        <trans-unit id="6c45ced87722560ce91bdb8d47661e48efa8ce64" translate="yes" xml:space="preserve">
          <source>But if the coder of an injectable site would hex it, no injection would be possible because the query would look like this: &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</source>
          <target state="translated">Но если кодировщик инъецируемого сайта закодирует его, внедрение не будет возможным, поскольку запрос будет выглядеть следующим образом: &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1130d41244662be40e74568e6d313b2aeba7a56" translate="yes" xml:space="preserve">
          <source>But sometimes we have to make our query even more dynamic, adding operators or identifiers as well.
So, we will need different protection techniques.</source>
          <target state="translated">Но иногда нам приходится делать наш запрос еще более динамичным,добавляя операторы или идентификаторы.Поэтому нам понадобятся различные методы защиты.</target>
        </trans-unit>
        <trans-unit id="388e5f4608b9c0c64a94caf6cb522f68f0b812be" translate="yes" xml:space="preserve">
          <source>But while both PDO and MySQLi are quite fast, MySQLi performs
insignificantly faster in benchmarks &amp;ndash; ~2.5% for non-prepared
statements, and ~6.5% for prepared ones.</source>
          <target state="translated">Но хотя PDO и MySQLi работают довольно быстро, MySQLi работает незначительно быстрее в тестах - ~ 2,5% для неподготовленных операторов и ~ 6,5% для подготовленных.</target>
        </trans-unit>
        <trans-unit id="11ae2ab8e554cd29a407caca0e6fabee0756957e" translate="yes" xml:space="preserve">
          <source>But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect &lt;em&gt;(it depends on you)&lt;/em&gt; that hacking-specific dynamic query string into a page that will store the attacker's &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP address&lt;/a&gt;, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.</source>
          <target state="translated">Но вы должны быть осторожны, чтобы не переписывать безопасный запрос с вашего сайта. Приведенный выше код дает вам подсказку переписать или перенаправить &lt;em&gt;(зависит от вас)&lt;/em&gt; эту строку динамического запроса, специфичную для взлома, на страницу, на которой будет храниться &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP-адрес&lt;/a&gt; злоумышленника, или ДАЖЕ ИХ КУКИ, историю, браузер или любой другой конфиденциальный информация, так что вы можете иметь дело с ними позже, забанив их учетную запись или связавшись с властями.</target>
        </trans-unit>
        <trans-unit id="c2424b0d28c65836412890f683090b9c10c2c3e2" translate="yes" xml:space="preserve">
          <source>Can prepared statements be used for dynamic queries?</source>
          <target state="translated">Могут ли подготовленные заявления быть использованы для динамических запросов?</target>
        </trans-unit>
        <trans-unit id="cc031d2a659335c48d55ac551c2a927f393178cf" translate="yes" xml:space="preserve">
          <source>Consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; are not available. How can you secure your application? Do you force me to use them? What about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border, not just for a specific language.</source>
          <target state="translated">Учтите, что &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; недоступны. Как вы можете защитить свое приложение? Вы заставляете меня использовать их? А как насчет других языков, кроме PHP? Я предпочитаю давать общие идеи, так как они могут быть использованы для более широкой границы, а не только для конкретного языка.</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">Рассмотрим следующий вопрос:</target>
        </trans-unit>
        <trans-unit id="6047ffa640b216365f3915cb1825dec617a4486c" translate="yes" xml:space="preserve">
          <source>Correctly setting up the connection</source>
          <target state="translated">Правильная настройка соединения</target>
        </trans-unit>
        <trans-unit id="a6b87d4687eee957fbc10c0728a5bff14a875b82" translate="yes" xml:space="preserve">
          <source>Data filtering: before building any query user input, it should be validated and filtered. For programmers, it's important to define some properties for each user-input variables:
&lt;strong&gt;data type, data pattern, and data length&lt;/strong&gt;. A field that is a number between (x and y) must be exactly validated using the exact rule, and for a field that is a string (text): pattern is the case, for example, a username must contain only some characters, let&amp;rsquo;s say [a-zA-Z0-9_-.]. The length varies between (x and n) where x and n (integers, x &amp;lt;=n).
&lt;strong&gt;Rule: creating exact filters and validation rules are best practices for me.&lt;/strong&gt;</source>
          <target state="translated">Фильтрация данных: перед созданием любого пользовательского ввода запроса его следует проверить и отфильтровать. Для программистов важно определить некоторые свойства для каждой пользовательской переменной: &lt;strong&gt;тип данных, шаблон данных и длина данных&lt;/strong&gt; . Поле, которое является числом между (x и y), должно быть точно проверено с использованием точного правила, а для поля, которое является строкой (текст): шаблон имеет место, например, имя пользователя должно содержать только несколько символов, давайте скажем [a-zA-Z0-9_-.]. Длина варьируется между (x и n), где x и n (целые числа, x &amp;lt;= n). &lt;strong&gt;Правило: создание точных фильтров и правил проверки - лучшие практики для меня.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac512b2277dc12fb253b90cadeff4b79f7f0c52d" translate="yes" xml:space="preserve">
          <source>Data validation</source>
          <target state="translated">Проверка данных</target>
        </trans-unit>
        <trans-unit id="bc11336395287ce262bd5113df8755daa9bf7976" translate="yes" xml:space="preserve">
          <source>Difference between UNHEX function and 0x prefix</source>
          <target state="translated">Разница между функцией UNHEX и префиксом 0x</target>
        </trans-unit>
        <trans-unit id="64fadb85f6f8e77597bc8111b879ba46ab913ae2" translate="yes" xml:space="preserve">
          <source>Don't use &lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt;. This extension is deprecated. Use &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; instead.</source>
          <target state="translated">Не используйте &lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt; . Это расширение устарело. Вместо этого используйте &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; или &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47070a639c03e8836d4eb1ec8798be8eba3ad73e" translate="yes" xml:space="preserve">
          <source>Don't worry about that the escaped string will have a 2x size of its original length because even if you use &lt;code&gt;mysql_real_escape_string&lt;/code&gt;, PHP has to allocate same capacity &lt;code&gt;((2*input_length)+1)&lt;/code&gt;, which is the same.</source>
          <target state="translated">Не беспокойтесь о том, что экранированная строка будет иметь 2- &lt;code&gt;mysql_real_escape_string&lt;/code&gt; размер по сравнению с первоначальной длиной, потому что даже если вы используете mysql_real_escape_string , PHP должен выделять такую же емкость &lt;code&gt;((2*input_length)+1)&lt;/code&gt; , которая одинакова.</target>
        </trans-unit>
        <trans-unit id="a8399b7eb2075e4b434c811aae00c5124b738ead" translate="yes" xml:space="preserve">
          <source>Escaping and SQL injection</source>
          <target state="translated">Эскапирование и SQL-инъекция</target>
        </trans-unit>
        <trans-unit id="f51a89736407728dd8dad04a11c2585ad6ed1ddc" translate="yes" xml:space="preserve">
          <source>Every answer here covers only part of the problem.
In fact, there are &lt;strong&gt;four&lt;/strong&gt; different query parts which we can add to SQL dynamically: -</source>
          <target state="translated">Каждый ответ здесь охватывает только часть проблемы. Фактически, есть &lt;strong&gt;четыре&lt;/strong&gt; различных части запроса, которые мы можем динамически добавить в SQL:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="7f33f9daadca6cb0086c1f093e4291fd8f752aed" translate="yes" xml:space="preserve">
          <source>Finally you get:</source>
          <target state="translated">Наконец-то ты получаешь:</target>
        </trans-unit>
        <trans-unit id="203bdc584486062bd9b0a868468cf5b0c6115900" translate="yes" xml:space="preserve">
          <source>Finally, let's consider that a user sends this text below instead of entering his/her username:</source>
          <target state="translated">Наконец,давайте рассмотрим,что пользователь посылает этот текст ниже,вместо того,чтобы вводить имя пользователя:</target>
        </trans-unit>
        <trans-unit id="4c529cebc105c5ddf809043dcd4cda22ee4366d8" translate="yes" xml:space="preserve">
          <source>For automatic escaping of values with prepared statements, use &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt;, and &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param&lt;/a&gt; where types for the corresponding bind variables must be provided for an appropriate conversion:</source>
          <target state="translated">Для автоматического экранирования значений с подготовленными инструкциями используйте &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt; и &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param,&lt;/a&gt; где для соответствующего преобразования должны быть предоставлены типы для соответствующих переменных связывания:</target>
        </trans-unit>
        <trans-unit id="263085c2dabdadf48b189f11fe3b9f44078570cc" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;there(1)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are(2)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still(3)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many(4)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;answers(5)&lt;/a&gt;, including the &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;second most upvoted answer&lt;/a&gt; suggesting you manual string escaping - an outdated approach that is proven to be insecure.</source>
          <target state="translated">Например, &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;(1)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;есть (2)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;еще (3)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;много (4)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;ответов (5)&lt;/a&gt; , включая &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;второй ответ с наибольшим количеством голосов,&lt;/a&gt; предлагающий вам ручное экранирование строк - устаревший подход, который, как доказывают, небезопасен.</target>
        </trans-unit>
        <trans-unit id="dd135ed1c5cdc625f86215a3d852d0a226ec19ca" translate="yes" xml:space="preserve">
          <source>For example, if you just do something like this:</source>
          <target state="translated">Например,если ты просто сделаешь что-то подобное:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="816ab6a230a5f009a780f99ed39f9fa8ad076a2f" translate="yes" xml:space="preserve">
          <source>For manually escaping special characters in a string you can use the &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt; function. The function will not work properly unless the correct character set is set with &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset&lt;/a&gt;.</source>
          <target state="translated">Для ручного экранирования специальных символов в строке вы можете использовать функцию &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt; . Функция не будет работать должным образом, если правильный набор символов не установлен с помощью &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6faf52c891f9ed8efba053050f428dfa69b63649" translate="yes" xml:space="preserve">
          <source>For more information, please read &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQL Injection Prevention Cheat Sheet&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации, пожалуйста, прочтите &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP Шпаргалку по предотвращению инъекций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d38e733b61cd3029c8e0a13aa3342ac97a1dd29" translate="yes" xml:space="preserve">
          <source>For more prevention, you can add at the end ...</source>
          <target state="translated">Для большей профилактики,вы можете добавить в конце...</target>
        </trans-unit>
        <trans-unit id="9b951568ae96d7b8f246820658eefa294ec054b6" translate="yes" xml:space="preserve">
          <source>For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.</source>
          <target state="translated">Для этих конкретных сценариев лучше всего использовать фильтр белого списка,который ограничивает возможные значения.</target>
        </trans-unit>
        <trans-unit id="3113d98fc6c4b79c794822624639f6af44b6df61" translate="yes" xml:space="preserve">
          <source>For those unsure of how to use PDO (coming from the &lt;code&gt;mysql_&lt;/code&gt; functions), I made a &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;very, very simple PDO wrapper&lt;/a&gt; that is a single file. It exists to show how easy it is to do all the common things applications need to be done. Works with PostgreSQL, MySQL, and SQLite.</source>
          <target state="translated">Для тех, кто не &lt;code&gt;mysql_&lt;/code&gt; как использовать PDO (исходя из функций mysql_ ), я сделал &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;очень, очень простую оболочку PDO,&lt;/a&gt; которая представляет собой один файл. Он существует, чтобы показать, как легко выполнять все обычные задачи, которые необходимо выполнять приложениям. Работает с PostgreSQL, MySQL и SQLite.</target>
        </trans-unit>
        <trans-unit id="31a94adfc6ded26176c675ac449c92a6685c5361" translate="yes" xml:space="preserve">
          <source>From the PHP manual, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP: Prepared Statements - Manual&lt;/a&gt;:</source>
          <target state="translated">Из руководства по PHP, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP: Подготовленные заявления - Руководство&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6e5468989f2e2437840e22ffb20130112517c2fc" translate="yes" xml:space="preserve">
          <source>Hex is the perfect escape. No way to inject.</source>
          <target state="translated">Гекс-идеальный выход.Нельзя сделать укол.</target>
        </trans-unit>
        <trans-unit id="1de0731dde0800e271064f5cf722c055c76cb148" translate="yes" xml:space="preserve">
          <source>Hex methods are often used as attacks</source>
          <target state="translated">Гекс-методы часто используются в качестве атак</target>
        </trans-unit>
        <trans-unit id="b62564667d0dfb9e44b590131236f464401bdd8b" translate="yes" xml:space="preserve">
          <source>How can I prevent SQL injection in PHP</source>
          <target state="translated">Как предотвратить SQL-инъекцию в PHP</target>
        </trans-unit>
        <trans-unit id="bd0deab6887a1354686773b46e00790e48d6fe0e" translate="yes" xml:space="preserve">
          <source>I created test cases for knowing how PDO and MySQLi send the query to the MySQL server when using a prepared statement:</source>
          <target state="translated">Я создал тестовые примеры,чтобы знать,как PDO и MySQLi посылают запрос на сервер MySQL при использовании подготовленного оператора:</target>
        </trans-unit>
        <trans-unit id="b9bbcd490604fe09b3cd1968bb6c6f7fa088e009" translate="yes" xml:space="preserve">
          <source>I favor &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;stored procedures&lt;/a&gt; (&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL has had stored procedures support since 5.0&lt;/a&gt;) from a security point of view - the advantages are -</source>
          <target state="translated">Я предпочитаю &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;хранимые процедуры&lt;/a&gt; ( &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL имеет поддержку хранимых процедур начиная с 5.0&lt;/a&gt; ) с точки зрения безопасности - преимущества -</target>
        </trans-unit>
        <trans-unit id="43758c0ba6ab9cf4ca9dc9ffd9fe8ff1ebfc4f99" translate="yes" xml:space="preserve">
          <source>I hope this will help you.</source>
          <target state="translated">Надеюсь,это тебе поможет.</target>
        </trans-unit>
        <trans-unit id="84a0fd31784433f7ef6a00aea8326647c9561507" translate="yes" xml:space="preserve">
          <source>I suggest, using PDO is the best option.</source>
          <target state="translated">Я предлагаю использовать PDO-лучший вариант.</target>
        </trans-unit>
        <trans-unit id="18aa4535a307c95c0ececdd0bfb8cd49698d9cca" translate="yes" xml:space="preserve">
          <source>I think if someone wants to use PHP and MySQL or some other dataBase server:</source>
          <target state="translated">Я думаю,если кто-то захочет использовать PHP и MySQL или какой-нибудь другой сервер базы данных:</target>
        </trans-unit>
        <trans-unit id="c95768ad26c493130f9d2b473fe6ef3eb215bddb" translate="yes" xml:space="preserve">
          <source>I think that all this because of one very old superstition, supported by such authorities like &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;the PHP manual&lt;/a&gt;, which proclaims equality between whatever &quot;escaping&quot; and protection from SQL injections.</source>
          <target state="translated">Я думаю, что все это из-за одного очень старого суеверия, поддерживаемого такими авторитетами, как &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt; или &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;руководство по PHP&lt;/a&gt; , которое провозглашает равенство между любыми &amp;laquo;выходами&amp;raquo; и защитой от SQL-инъекций.</target>
        </trans-unit>
        <trans-unit id="06f647de8211b09469d07c391ca6e9753993ee87" translate="yes" xml:space="preserve">
          <source>I use three different ways to prevent my web application from being vulnerable to SQL injection.</source>
          <target state="translated">Я использую три различных способа,чтобы предотвратить уязвимость моего веб-приложения к SQL инъекции.</target>
        </trans-unit>
        <trans-unit id="aa717e5dd178fdf0c4683b6d4ebda0dfe58dee0e" translate="yes" xml:space="preserve">
          <source>I was facing this issue, but I think I solved it in &lt;em&gt;very&lt;/em&gt; sophisticated way - the way hackers use to avoid using quotes. I used this in conjunction with emulated prepared statements. I use it to prevent &lt;em&gt;all&lt;/em&gt; kinds of possible SQL injection attacks.</source>
          <target state="translated">Я столкнулся с этой проблемой, но думаю, что решил ее &lt;em&gt;очень&lt;/em&gt; изощренным способом - способом, который используют хакеры, чтобы избежать использования кавычек. Я использовал это в сочетании с подготовленными утверждениями. Я использую его для предотвращения всевозможных атак с использованием SQL-инъекций.</target>
        </trans-unit>
        <trans-unit id="e5f69a8687e8ff3c1c4991d23a6d4ef4077382ba" translate="yes" xml:space="preserve">
          <source>I would like to let you know: Why do we try for preventing SQL injection with a short example below:</source>
          <target state="translated">Я бы хотел,чтобы ты знал:Почему мы пытаемся предотвратить SQL-инъекцию на коротком примере ниже:</target>
        </trans-unit>
        <trans-unit id="eba600f8bfb98c671cd997242fbcbddc9efa69ac" translate="yes" xml:space="preserve">
          <source>I'd recommend using &lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) to run parameterized SQL queries.</source>
          <target state="translated">Я бы рекомендовал использовать &lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (объекты данных PHP) для запуска параметризованных запросов SQL.</target>
        </trans-unit>
        <trans-unit id="40c2e08dff1fe6c1375d48a2c7cea92dc8a4069b" translate="yes" xml:space="preserve">
          <source>I've written this little function several years ago:</source>
          <target state="translated">Я написал эту маленькую функцию несколько лет назад:</target>
        </trans-unit>
        <trans-unit id="bd1f9c5fa454d3c00b06ea476a20111a54613929" translate="yes" xml:space="preserve">
          <source>If possible, cast the types of your parameters. But it's only working on simple types like int, bool, and float.</source>
          <target state="translated">Если это возможно,пролистайте типы ваших параметров.Но он работает только с простыми типами,такими как int,bool и float.</target>
        </trans-unit>
        <trans-unit id="5827c6c3a2418ad354c9d261967a8450348a74c1" translate="yes" xml:space="preserve">
          <source>If the attackers are trying to hack into the form via PHP's &lt;code&gt;$_GET&lt;/code&gt; variable or with the URL's query string, you would be able to catch them if they're not secure.</source>
          <target state="translated">Если злоумышленники попытаются взломать форму с помощью PHP-переменной &lt;code&gt;$_GET&lt;/code&gt; или строки запроса URL-адреса, вы сможете их перехватить, если они не защищены.</target>
        </trans-unit>
        <trans-unit id="e7511b2b136cd15346fc6c4ed024e6a28da03c3b" translate="yes" xml:space="preserve">
          <source>If user input is inserted without modification into an SQL query, then the application becomes vulnerable to &lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQL injection&lt;/a&gt;, like in the following example:</source>
          <target state="translated">Если пользовательский ввод вставляется без изменения в запрос SQL, приложение становится уязвимым для &lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;внедрения SQL&lt;/a&gt; , как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="252e57771708143a8a54033603a42c7a9528bde0" translate="yes" xml:space="preserve">
          <source>If you expect anything else from integer &lt;strong&gt;hex it&lt;/strong&gt;. If you hex it, you will perfectly escape all input. In C/C++ there's a function called &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt;&lt;code&gt;mysql_hex_string()&lt;/code&gt;&lt;/a&gt;, in PHP you can use &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt;&lt;code&gt;bin2hex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы ожидаете что-то еще от целого числа, &lt;strong&gt;заклейте его&lt;/strong&gt; . Если вы это сделаете, вы полностью избежите ввода. В C / C ++ есть функция &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt; &lt;code&gt;mysql_hex_string()&lt;/code&gt; &lt;/a&gt; , в PHP вы можете использовать &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt; &lt;code&gt;bin2hex()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0094481ec99be1c5a7d70dc70e550f643a741a7d" translate="yes" xml:space="preserve">
          <source>If you expect input to be integer make sure it's &lt;strong&gt;&lt;em&gt;really&lt;/em&gt;&lt;/strong&gt; integer. In a variable-type language like PHP it is this &lt;em&gt;very&lt;/em&gt; important. You can use for example this very simple but powerful solution: &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</source>
          <target state="translated">Если вы ожидаете, что ввод будет целочисленным, убедитесь, что он &lt;strong&gt;&lt;em&gt;действительно&lt;/em&gt;&lt;/strong&gt; целочисленный. В языке переменных типов, таких как PHP, это &lt;em&gt;очень&lt;/em&gt; важно. Например, вы можете использовать это очень простое, но мощное решение: &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="506301687174ad39af3412a5f9d9bf697ce6b22d" translate="yes" xml:space="preserve">
          <source>If you use integers from user input in a condition and take the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; approach, you will suffer from the problem described by &lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;Polynomial&lt;/a&gt; in the comments below. This case is trickier because integers would not be surrounded by quotes, so you could deal with by validating that the user input contains only digits.</source>
          <target state="translated">Если вы используете целые числа из пользовательского ввода в условии и используете подход &lt;code&gt;mysql_real_escape_string&lt;/code&gt; , вы будете страдать от проблемы, описанной &lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;Polynomial&lt;/a&gt; в комментариях ниже. Этот случай сложнее, потому что целые числа не будут заключены в кавычки, так что вы могли бы справиться, проверив, что пользовательский ввод содержит только цифры.</target>
        </trans-unit>
        <trans-unit id="98415529fb77c227add683c142b9927f11fa1d97" translate="yes" xml:space="preserve">
          <source>If you want to alter the structure of the SQL based on user input, parameterized queries are not going to help, and the escaping required is not covered by &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. In this kind of case, you would be better off passing the user's input through a whitelist to ensure only 'safe' values are allowed through.</source>
          <target state="translated">Если вы хотите изменить структуру SQL на основе пользовательского ввода, параметризованные запросы не помогут, и требуемый &lt;code&gt;mysql_real_escape_string&lt;/code&gt; не покрывается mysql_real_escape_string . В этом случае вам лучше передать ввод пользователя через белый список, чтобы обеспечить пропуск только &amp;laquo;безопасных&amp;raquo; значений.</target>
        </trans-unit>
        <trans-unit id="8785f3e80562fc002361ca18a095e5f516055181" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of cache engines, like &lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt;, maybe DALMP could be a choice. It uses pure &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;. Check this: &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">Если вы хотите использовать в своих интересах механизмы кэширования, такие как &lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt; или &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt; , возможно, DALMP может быть выбором. Он использует чистый &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; . Проверьте это: &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;Уровень абстракции базы данных DALMP для MySQL с использованием PHP.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a8e4204cd0dadf37e960ba81602dfdecab9d3" translate="yes" xml:space="preserve">
          <source>If you're connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (for example, &lt;code&gt;pg_prepare()&lt;/code&gt; and &lt;code&gt;pg_execute()&lt;/code&gt; for PostgreSQL). PDO is the universal option.</source>
          <target state="translated">Если вы подключаетесь к базе данных, отличной от MySQL, существует вторая опция для драйвера, к которой вы можете обратиться (например, &lt;code&gt;pg_prepare()&lt;/code&gt; и &lt;code&gt;pg_execute()&lt;/code&gt; для PostgreSQL). PDO - это универсальный вариант.</target>
        </trans-unit>
        <trans-unit id="d16f400a258fe645cbcf862d1cdacec8afcc86a4" translate="yes" xml:space="preserve">
          <source>If you're using a recent version of PHP, the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option outlined below will no longer be available (though &lt;code&gt;mysqli::escape_string&lt;/code&gt; is a modern equivalent). These days the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option would only make sense for legacy code on an old version of PHP.</source>
          <target state="translated">Если вы используете последнюю версию PHP, опция &lt;code&gt;mysql_real_escape_string&lt;/code&gt; , описанная ниже, больше не будет доступна (хотя &lt;code&gt;mysqli::escape_string&lt;/code&gt; является современным эквивалентом). В наши дни опция &lt;code&gt;mysql_real_escape_string&lt;/code&gt; имеет смысл только для устаревшего кода на старой версии PHP.</target>
        </trans-unit>
        <trans-unit id="a87d9bb2e1e1d38953625a44a667a275d119c139" translate="yes" xml:space="preserve">
          <source>In both cases, you can't use &lt;code&gt;'&lt;/code&gt; to protect the encapsulation.</source>
          <target state="translated">В обоих случаях вы не можете использовать &lt;code&gt;'&lt;/code&gt; для защиты инкапсуляции.</target>
        </trans-unit>
        <trans-unit id="bc303fbbb40874deaf199e9d6a1fad1eae12e122" translate="yes" xml:space="preserve">
          <source>In general, such a protection approach is based on &lt;em&gt;whitelisting&lt;/em&gt;.</source>
          <target state="translated">В общем, такой подход к защите основан на &lt;em&gt;белых списках&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7fca827b92ede4c4e14d63153d01c7f1f4172674" translate="yes" xml:space="preserve">
          <source>In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application's architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it's just a matter of time until you forget to correctly format your query at some point in your code.</source>
          <target state="translated">На мой взгляд,лучший способ вообще предотвратить SQL-инъекцию в PHP-приложение (или любое другое веб-приложение,если уж на то пошло)-это подумать об архитектуре вашего приложения.Если единственным способом защиты от SQL инъекции является помнить об использовании специального метода или функции,которая делает The Right Thing каждый раз,когда вы говорите с базой данных,вы делаете это неправильно.Таким образом,это всего лишь вопрос времени,пока вы не забудете правильно отформатировать запрос в какой-то момент в своем коде.</target>
        </trans-unit>
        <trans-unit id="65b6a7572f51598d01d28ef1ca6341d368dbf0b0" translate="yes" xml:space="preserve">
          <source>In the above example the error mode isn't strictly necessary, &lt;strong&gt;but it is advised to add it&lt;/strong&gt;. This way the script will not stop with a &lt;code&gt;Fatal Error&lt;/code&gt; when something goes wrong. And it gives the developer the chance to &lt;code&gt;catch&lt;/code&gt; any error(s) which are &lt;code&gt;throw&lt;/code&gt;n as &lt;code&gt;PDOException&lt;/code&gt;s.</source>
          <target state="translated">В приведенном выше примере режим ошибки не является строго необходимым, &lt;strong&gt;но рекомендуется добавить его&lt;/strong&gt; . Таким образом, скрипт не остановится с &lt;code&gt;Fatal Error&lt;/code&gt; если что-то пойдет не так. И это дает разработчику возможность &lt;code&gt;catch&lt;/code&gt; любую ошибку (ошибки), которые &lt;code&gt;throw&lt;/code&gt; как &lt;code&gt;PDOException&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="d2db286e4cb56e8b42ba950818e8b8f310b67a57" translate="yes" xml:space="preserve">
          <source>In this case, every dynamic parameter should be hardcoded in your script and chosen from that set.
For example, to do dynamic ordering:</source>
          <target state="translated">В этом случае каждый динамический параметр должен быть жестко закодирован в вашем скрипте и выбран из этого набора.Например,для выполнения динамического упорядочения:</target>
        </trans-unit>
        <trans-unit id="6b2d5fd11bcfa0af9c55f66b09eb36931b5296de" translate="yes" xml:space="preserve">
          <source>Information security</source>
          <target state="translated">Информационная безопасность</target>
        </trans-unit>
        <trans-unit id="7be8da2bc759d6b5b0023a64f7e97f8d22bcbce1" translate="yes" xml:space="preserve">
          <source>Injection prevention - &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string()&lt;/a&gt;</source>
          <target state="translated">Предотвращение инъекций - &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f5d58263c5f2019288630bda6ee4cb637fd37bd" translate="yes" xml:space="preserve">
          <source>It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is an invalid syntax.</source>
          <target state="translated">Он экранируется с учетом типа переменной.Если вы попытаетесь параметрировать имена таблиц,столбцов,то это будет неудачно,так как помещает каждую строку в кавычки,что является некорректным синтаксисом.</target>
        </trans-unit>
        <trans-unit id="e66723c3916c6792b6e9358bbc39573f7f203093" translate="yes" xml:space="preserve">
          <source>It not only saves you from SQL injections but from syntax errors too! Also Supports collections of models with method chaining to filter or apply actions to multiple results at once and multiple connections.</source>
          <target state="translated">Это не только спасает от SQL инъекций,но и от синтаксических ошибок! Также поддерживает коллекции моделей с методом цепочки для фильтрации или применения действий к нескольким результатам одновременно и нескольким соединениям.</target>
        </trans-unit>
        <trans-unit id="f53f074e916e32d9c9de79faceea3b3a0b1b8268" translate="yes" xml:space="preserve">
          <source>It's clear that a prepared statement is also escaping the data, nothing else.</source>
          <target state="translated">Понятно,что подготовленное заявление также ускользает от данных,больше ничего.</target>
        </trans-unit>
        <trans-unit id="066059abccc3bb425cd0e667ccb08532bb6fc8ca" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT&lt;/a&gt;.</source>
          <target state="translated">Узнайте больше о &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0dd15ea735ebf8e4f7aefab757f8823897465c" translate="yes" xml:space="preserve">
          <source>Most databases (including &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt;) enable user access to be restricted to executing stored procedures. The fine-grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.</source>
          <target state="translated">Большинство баз данных (включая &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt; ) позволяют ограничить доступ пользователей к выполнению хранимых процедур. Детальный контроль доступа безопасности полезен для предотвращения атак на повышение привилегий. Это препятствует тому, чтобы скомпрометированные приложения могли запускать SQL непосредственно против базы данных.</target>
        </trans-unit>
        <trans-unit id="cbc26a832cdcd4282066d905ed7a05f1fdc9ed21" translate="yes" xml:space="preserve">
          <source>My approach against SQL injection is: clearing user-input data before sending it to the database (before using it inside any query).</source>
          <target state="translated">Мой подход против SQL-инъекции заключается в:очистке данных,введенных пользователем,перед отправкой их в базу данных (перед использованием их внутри любого запроса).</target>
        </trans-unit>
        <trans-unit id="05f8f3c79f55806a7dcfe96187c4600251c00e11" translate="yes" xml:space="preserve">
          <source>My approach:</source>
          <target state="translated">Мой подход:</target>
        </trans-unit>
        <trans-unit id="4d52e8740d9df9e1c638ac50e30925e49fcd8e33" translate="yes" xml:space="preserve">
          <source>No matter if you use prepared statements or &lt;code&gt;mysqli_real_escape_string&lt;/code&gt;, you always have to know the type of input data you're working with.</source>
          <target state="translated">Независимо от того, используете ли вы подготовленные операторы или &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; , вы всегда должны знать тип входных данных, с которыми вы работаете.</target>
        </trans-unit>
        <trans-unit id="529ff19c5e6399e4d50652370e959d26daab503b" translate="yes" xml:space="preserve">
          <source>Not only does this protect against SQL injection, but it also speeds up queries.</source>
          <target state="translated">Это не только защищает от SQL инъекций,но и ускоряет запросы.</target>
        </trans-unit>
        <trans-unit id="ad07b10ae48ce9bcac4c0024173c1939bf2d4d50" translate="yes" xml:space="preserve">
          <source>Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. Then you can avoid the use of quotes.</source>
          <target state="translated">Обратите внимание, что этот шестнадцатеричный метод часто используется как атака SQL-инъекции, где целые числа похожи на строки и экранируются только с помощью &lt;code&gt;mysql_real_escape_string&lt;/code&gt; . Тогда вы можете избежать использования цитат.</target>
        </trans-unit>
        <trans-unit id="6bd876670bffa2dedbaa4302b16a1c84ee2ebe22" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;PDO&lt;/code&gt; to access a MySQL database &lt;em&gt;real&lt;/em&gt; prepared statements are &lt;strong&gt;not used by default&lt;/strong&gt;. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using PDO is:</source>
          <target state="translated">Обратите внимание, что при использовании &lt;code&gt;PDO&lt;/code&gt; для доступа к базе данных MySQL &lt;em&gt;реально&lt;/em&gt; подготовленные операторы &lt;strong&gt;не используются по умолчанию&lt;/strong&gt; . Чтобы это исправить, вы должны отключить эмуляцию подготовленных операторов. Пример создания соединения с использованием PDO:</target>
        </trans-unit>
        <trans-unit id="0281801c06d0ce9e250fd24a61b6b6723729516b" translate="yes" xml:space="preserve">
          <source>Now, &lt;strong&gt;why you do you need to prevent your query from SQL injection?&lt;/strong&gt;</source>
          <target state="translated">Теперь, &lt;strong&gt;почему вам нужно предотвратить ваш запрос от внедрения SQL?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26d705214b3428e5682f630c8e66663452ff37b5" translate="yes" xml:space="preserve">
          <source>Now, if someone (a hacker) puts</source>
          <target state="translated">Теперь,если кто-то (хакер)поставит</target>
        </trans-unit>
        <trans-unit id="66eb148a1111b249fa1c3f3a55a2330ca909715f" translate="yes" xml:space="preserve">
          <source>Now, if you are an advanced user, start using this defense as you like, but, for beginners, if they can't quickly implement a stored procedure and prepared the statement, it's better to filter input data as much they can.</source>
          <target state="translated">Теперь,если вы опытный пользователь,начните использовать эту защиту,как вам нравится,но для новичков,если они не могут быстро реализовать сохраненную процедуру и подготовить утверждение,лучше отфильтровать входные данные как можно больше.</target>
        </trans-unit>
        <trans-unit id="f64627235bbf5e10f0dda979a643fa08ab87651d" translate="yes" xml:space="preserve">
          <source>Now, our point is to prevent security threats such as SQL injection attacks, the question asking (how to prevent an SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? How do you secure your application?</source>
          <target state="translated">Теперь мы говорим о том,чтобы предотвратить угрозы безопасности,такие как атаки SQL инъекции,вопрос (как предотвратить атаку SQL инъекции с помощью PHP),быть более реалистичным,фильтрация данных или очистка входных данных в случае использования пользовательских данных внутри такого запроса,с использованием PHP или любого другого языка программирования,или,как рекомендует больше людей,чтобы использовать современные технологии,такие как подготовленные операторы или любые другие инструменты,которые в настоящее время поддерживает SQL инъекции предотвращения,считают,что эти инструменты больше не доступны? Как обезопасить ваше приложение?</target>
        </trans-unit>
        <trans-unit id="a2ebdce6e2debca99f4971e3f20fb7e609a0d677" translate="yes" xml:space="preserve">
          <source>Oh, and since you asked about how to do it for an insert, here's an example (using PDO):</source>
          <target state="translated">О,и поскольку вы спросили о том,как это сделать для вставки,вот пример (с использованием PDO):</target>
        </trans-unit>
        <trans-unit id="134949ae0b25999cca22947fe40274275ecfbf40" translate="yes" xml:space="preserve">
          <source>Option #1: Use of Prepared Statements (Parameterized Queries)</source>
          <target state="translated">Вариант № 1:Использование подготовленных операторов (Параметризированные запросы)</target>
        </trans-unit>
        <trans-unit id="5d2a8213d51185403db055f6aea59f59d1a24bff" translate="yes" xml:space="preserve">
          <source>Option #2: Use of Stored Procedures</source>
          <target state="translated">Вариант № 2:Использование хранимых процедур.</target>
        </trans-unit>
        <trans-unit id="ca0c50b92c49801edcf1ea0388797ec4f53add0c" translate="yes" xml:space="preserve">
          <source>Option #3: Escaping all User Supplied Input</source>
          <target state="translated">Вариант № 3:Спасение всех входов,поставляемых пользователем.</target>
        </trans-unit>
        <trans-unit id="1b175495915b9cebd7a4f0c7b63ed399ad461fb6" translate="yes" xml:space="preserve">
          <source>Or there is a slightly better answer that suggests just &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;another method of string formatting&lt;/a&gt; and even boasts it as the ultimate panacea. While of course, it is not. This method is no better than regular string formatting, yet it keeps all its drawbacks: it is applicable to strings only and, like any other manual formatting, it's essentially optional, non-obligatory measure, prone to human error of any sort.</source>
          <target state="translated">Или есть немного лучший ответ, который предлагает просто &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;другой метод форматирования строки&lt;/a&gt; и даже может похвастаться этим как окончательной панацеей. Хотя, конечно, это не так. Этот метод ничем не лучше обычного форматирования строк, но при этом он сохраняет все свои недостатки: он применим только к строкам и, как и любое другое ручное форматирование, по сути является необязательной, необязательной мерой, подверженной человеческим ошибкам любого рода.</target>
        </trans-unit>
        <trans-unit id="f0ded22686c7a01e80dd23bbdd785e9739881413" translate="yes" xml:space="preserve">
          <source>PDO wins this battle with ease. With support for twelve
different database drivers and named parameters, we can ignore the
small performance loss, and get used to its API. From a security
standpoint, both of them are safe as long as the developer uses them
the way they are supposed to be used</source>
          <target state="translated">PDO с легкостью побеждает в этой битве.Благодаря поддержке двенадцати различных драйверов баз данных и именованных параметров,мы можем игнорировать небольшие потери производительности и привыкнуть к его API.С точки зрения безопасности,оба драйвера безопасны,пока разработчик использует их так,как они должны использоваться.</target>
        </trans-unit>
        <trans-unit id="54e0d751e792502d244f26c003fbc0168957db96" translate="yes" xml:space="preserve">
          <source>PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">PHP имеет специально созданную функцию для предотвращения этих атак. Все, что вам нужно сделать, это использовать &lt;code&gt;mysql_real_escape_string&lt;/code&gt; набор функций mysql_real_escape_string .</target>
        </trans-unit>
        <trans-unit id="ccf9fc49cbe33f37545bdf96ec74793151180cf7" translate="yes" xml:space="preserve">
          <source>Parameterized query AND input validation is the way to go. There are many scenarios under which SQL injection may occur, even though &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; has been used.</source>
          <target state="translated">Параметризованный запрос И проверка ввода - это путь. Существует много сценариев, при которых может происходить внедрение SQL, даже если была использована &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9efa2dbb908a0d252e5cd2661bab4bcef31b8aec" translate="yes" xml:space="preserve">
          <source>Please note that the case you asked about is a fairly simple one and that more complex cases may require more complex approaches. In particular:</source>
          <target state="translated">Пожалуйста,обратите внимание,что дело,о котором вы спрашивали,довольно простое,и что более сложные дела могут потребовать более сложных подходов.В частности:</target>
        </trans-unit>
        <trans-unit id="bcf57ec934b9b4abfe2e011b6d61b8f3fe9b293d" translate="yes" xml:space="preserve">
          <source>Please see this question for more detail: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same result&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Пожалуйста, посмотрите этот вопрос для более подробной информации: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO отправляет необработанный запрос в MySQL, в то время как Mysqli отправляет подготовленный запрос, оба дают одинаковый результат.&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="253bf3e933bdeac3a809eb91c495e40d9d61fe9d" translate="yes" xml:space="preserve">
          <source>Primary defenses:</source>
          <target state="translated">Первичная защита:</target>
        </trans-unit>
        <trans-unit id="d52155a58f068ac65eaa3922fec6c4b67e140457" translate="yes" xml:space="preserve">
          <source>Query for login authentication match:</source>
          <target state="translated">Запрос на идентификацию логина:</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="058114cbca517a731cb958e54ea1701d36b6c3b4" translate="yes" xml:space="preserve">
          <source>Regarding many useful answers, I hope to add some value to this thread.</source>
          <target state="translated">Что касается многих полезных ответов,то я надеюсь добавить некоторую ценность этой теме.</target>
        </trans-unit>
        <trans-unit id="e096b01f49b6da8c19f1bffa18f6d83e4dd4871e" translate="yes" xml:space="preserve">
          <source>Regardless of what PHP manual said for ages, &lt;strong&gt;&lt;code&gt;*_escape_string&lt;/code&gt; by no means makes data safe&lt;/strong&gt; and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong, because it is manual as opposite to automated.</source>
          <target state="translated">Независимо от того, что руководство PHP говорило целую вечность, &lt;strong&gt; &lt;code&gt;*_escape_string&lt;/code&gt; ни в коем случае не делает данные безопасными&lt;/strong&gt; и никогда не предназначалось для них. Помимо бесполезности для любой части SQL, кроме строки, ручное экранирование является неправильным, потому что оно является ручным, а не автоматическим.</target>
        </trans-unit>
        <trans-unit id="4b26d7b5c670dfa0c5a71f99bb87ebad73afd959" translate="yes" xml:space="preserve">
          <source>SECURITY UPDATE: The previous &lt;code&gt;str_replace&lt;/code&gt; version allowed injections by adding {#} tokens into user data. This &lt;code&gt;preg_replace_callback&lt;/code&gt; version doesn't cause problems if the replacement contains these tokens.</source>
          <target state="translated">ОБНОВЛЕНИЕ БЕЗОПАСНОСТИ: Предыдущая версия &lt;code&gt;str_replace&lt;/code&gt; допускала инъекции, добавляя токены {#} в пользовательские данные. Эта версия &lt;code&gt;preg_replace_callback&lt;/code&gt; не вызывает проблем, если замена содержит эти токены.</target>
        </trans-unit>
        <trans-unit id="2248f755da0797902356c62702fce90dfe90f334" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = -1 &lt;strong&gt;объединить&lt;/strong&gt; все выбрать столбец_имя из information_schema.column, где &lt;strong&gt;имя_таблицы&lt;/strong&gt; = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ce3741372785fc3d1b9e81dc08822e0ee3697b" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = &lt;strong&gt;-1 union all select table_name from information_schema.tables&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = &lt;strong&gt;-1 объединить все выбрать имя таблицы из таблицы information_schema.tables&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2aaa640d6aff57cc99ee7b8f6b262da344d87124" translate="yes" xml:space="preserve">
          <source>SQL Injection</source>
          <target state="translated">SQL-инъекция</target>
        </trans-unit>
        <trans-unit id="aaae6cc0c6e64da88ddbf398d39cff7dd8d70208" translate="yes" xml:space="preserve">
          <source>SQL Injection Cheat Sheet</source>
          <target state="translated">SQL-инъекционный чит-лист</target>
        </trans-unit>
        <trans-unit id="df8511b36a40094461c2fa8100abbe0ef28e937c" translate="yes" xml:space="preserve">
          <source>SQL injection is an attack that can be done through user inputs (inputs that filled by a user and then used inside queries). The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, and we assume that there might be a bad person that try to get secret information (bypassing access control) that affect the three principles of security (confidentiality, integrity, and availability).</source>
          <target state="translated">SQL-инъекция-это атака,которая может быть осуществлена через пользовательские входы (входы,которые заполняются пользователем,а затем используются внутри запросов).Шаблоны SQL инъекции являются правильным синтаксисом запросов,в то время как мы можем назвать его:плохие запросы по плохим причинам,и мы предполагаем,что может быть плохой человек,который пытается получить секретную информацию (в обход контроля доступа),что влияет на три принципа безопасности (конфиденциальность,целостность и доступность).</target>
        </trans-unit>
        <trans-unit id="4c18831b8c7d74dba4d4cf532d188cd34482c6be" translate="yes" xml:space="preserve">
          <source>SQL user (limiting user privilege): most common SQL operations are (SELECT, UPDATE, INSERT), then, why give the UPDATE privilege to a user that does not require it? For example, &lt;strong&gt;login, and search pages&lt;/strong&gt; are only using SELECT, then, why use DB users in these pages with high privileges?</source>
          <target state="translated">Пользователь SQL (ограничение привилегий пользователя): наиболее распространенными операциями SQL являются (SELECT, UPDATE, INSERT), тогда зачем давать привилегию UPDATE пользователю, который в этом не нуждается? Например, &lt;strong&gt;страницы входа и поиска&lt;/strong&gt; используют только SELECT, тогда зачем использовать пользователей БД на этих страницах с высокими привилегиями?</target>
        </trans-unit>
        <trans-unit id="3c9750d49c83fa8a5b3a0075cee19045e8360352" translate="yes" xml:space="preserve">
          <source>Security Principles</source>
          <target state="translated">Принципы безопасности</target>
        </trans-unit>
        <trans-unit id="8a0ff19685c3593d2dd9348235796673a86f433d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;.</source>
          <target state="translated">Смотрите &lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;принцип наименьших привилегий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc5aad5e191c67a30c0d326b34a9e4894a1fec3" translate="yes" xml:space="preserve">
          <source>See also, the details of the &lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt;&lt;code&gt;mysql_real_escape_string&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Смотрите также подробности функции &lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt; &lt;code&gt;mysql_real_escape_string&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be33bd1eb7dbd848bc959ced6f1d33144f31d5c8" translate="yes" xml:space="preserve">
          <source>So if you use a prepared statement, you must specify the types of the variables for &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; function.</source>
          <target state="translated">Поэтому, если вы используете подготовленный оператор, вы должны указать типы переменных для функции &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7791c9096ecb3c52f38cfacf2ed5a600ac8ac03b" translate="yes" xml:space="preserve">
          <source>So, a general recommendation may be phrased as</source>
          <target state="translated">Таким образом,общая рекомендация может быть сформулирована как</target>
        </trans-unit>
        <trans-unit id="5b4eb875965dcbc46634a834943ce8fb7d495d10" translate="yes" xml:space="preserve">
          <source>So, for example, the query:</source>
          <target state="translated">Так,например,запрос:</target>
        </trans-unit>
        <trans-unit id="cfd8f629333fbfac1be3ab64cdcec4377eaa444d" translate="yes" xml:space="preserve">
          <source>So, unlike whatever &quot;escaping&quot;, prepared statements &lt;em&gt;is&lt;/em&gt; the measure that indeed protects from SQL injection (when applicable).</source>
          <target state="translated">Таким образом, в отличие от любого &amp;laquo;выхода&amp;raquo;, подготовленные операторы &lt;em&gt;-&lt;/em&gt; это мера, которая действительно защищает от внедрения SQL (когда это применимо).</target>
        </trans-unit>
        <trans-unit id="bdd6c788b4bc40941d92c120767a09a678ddf541" translate="yes" xml:space="preserve">
          <source>Still, there is an issue with SQL syntax keywords (such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and such), but white-listing seems the only approach in this case.</source>
          <target state="translated">Тем не менее, существует проблема с ключевыми словами синтаксиса SQL (такими как &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; и т. Д.), Но в этом случае единственным подходом является белый список.</target>
        </trans-unit>
        <trans-unit id="25fe63edd9746e4a688d1d2796a06118495eb155" translate="yes" xml:space="preserve">
          <source>That's because the user can input something like &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt;, and the query becomes:</source>
          <target state="translated">Это потому, что пользователь может ввести что-то вроде &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt; DROP TABLE table; - , и запрос становится:</target>
        </trans-unit>
        <trans-unit id="ea6f46a1818ef256a65fd25fce4ef5438834b53d" translate="yes" xml:space="preserve">
          <source>The ** 0x** prefix can only be used for data columns such as &lt;strong&gt;char, varchar, text, block, binary, etc&lt;/strong&gt;.</source>
          <target state="translated">Префикс ** 0x ** можно использовать только для столбцов данных, таких как &lt;strong&gt;char, varchar, text, block, binary и т&lt;/strong&gt; . Д.</target>
        </trans-unit>
        <trans-unit id="22493fd5585b849e0dfac158f0d91d71de2a9f53" translate="yes" xml:space="preserve">
          <source>The SQL statement you pass to &lt;code&gt;prepare&lt;/code&gt; is parsed and compiled by the database server. By specifying parameters (either a &lt;code&gt;?&lt;/code&gt; or a named parameter like &lt;code&gt;:name&lt;/code&gt; in the example above) you tell the database engine where you want to filter on. Then when you call &lt;code&gt;execute&lt;/code&gt;, the prepared statement is combined with the parameter values you specify.</source>
          <target state="translated">Оператор SQL, который вы передаете для &lt;code&gt;prepare&lt;/code&gt; , анализируется и компилируется сервером базы данных. Указывая параметры (или &lt;code&gt;?&lt;/code&gt; Или именованный параметр, такой как &lt;code&gt;:name&lt;/code&gt; в приведенном выше примере), вы указываете ядру базы данных, куда вы хотите фильтровать. Затем при вызове &lt;code&gt;execute&lt;/code&gt; подготовленный оператор объединяется с указанными вами значениями параметров.</target>
        </trans-unit>
        <trans-unit id="220daddb11e24bc5b6c1d64820ad3b7f7ddb93fa" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes
  considered a security feature to prevent SQL injection. The same
  degree of security can be achieved with non-prepared statements if
  input values are escaped correctly.</source>
          <target state="translated">Автоматическое экранирование значений внутри сервера иногда рассматривается как функция безопасности для предотвращения SQL инъекций.Такая же степень безопасности может быть достигнута при использовании неподготовленных заявлений,если входные значения экранируются корректно.</target>
        </trans-unit>
        <trans-unit id="8e19049bf34dbc02fad22f1e2a94559fad21acf0" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly</source>
          <target state="translated">Автоматическое экранирование значений внутри сервера иногда рассматривается как функция безопасности для предотвращения SQL инъекций.Такая же степень безопасности может быть достигнута при использовании неподготовленных заявлений,если входные значения экранируются правильно</target>
        </trans-unit>
        <trans-unit id="fdf65f1abe7fe4e3d2342b41af2f1116791c2af6" translate="yes" xml:space="preserve">
          <source>The best way to prevent SQL Injection is to use &lt;strong&gt;Prepared Statements&lt;/strong&gt;&lt;em&gt;instead of escaping&lt;/em&gt;, as &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;the accepted answer&lt;/a&gt; demonstrates.</source>
          <target state="translated">Лучший способ предотвратить инъекцию SQL - использовать &lt;strong&gt;подготовленные&lt;/strong&gt; операторы &lt;em&gt;вместо экранирования&lt;/em&gt; , как показывает &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;принятый ответ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc7e03df37b2e8c386abd1ebf523f1b7f2477d6" translate="yes" xml:space="preserve">
          <source>The disadvantages are -</source>
          <target state="translated">Недостатки -</target>
        </trans-unit>
        <trans-unit id="b02e13a130f7a3159e0982874d64e46b658e4a3d" translate="yes" xml:space="preserve">
          <source>The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn't intend.</source>
          <target state="translated">Здесь важно то,что значения параметров комбинируются с скомпилированным оператором,а не с SQL-строкой.SQL-инъекция работает путем обмана скрипта на включение вредоносных строк,когда он создает SQL для отправки в базу данных.Таким образом,отправляя фактический SQL отдельно от параметров,вы ограничиваете риск того,что в итоге получите что-то,чего не предполагали.</target>
        </trans-unit>
        <trans-unit id="f2ce25b2d0b72f92570aaba8ea168300f90b408b" translate="yes" xml:space="preserve">
          <source>The key function you'll want to read up on there would be &lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt;&lt;code&gt;mysqli::prepare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ключевой функцией, о которой вы захотите прочитать, будет &lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt; &lt;code&gt;mysqli::prepare&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8329b222e736716b29e6f8c8d1bf0eb05508d581" translate="yes" xml:space="preserve">
          <source>The last point is detecting unexpected behavior which requires more effort and complexity; it's not recommended for normal web applications.</source>
          <target state="translated">Последний момент-это обнаружение неожиданного поведения,которое требует больше усилий и сложности;это не рекомендуется для обычных веб-приложений.</target>
        </trans-unit>
        <trans-unit id="ec2ec032df8d4e54047d67def864e600f72c7368" translate="yes" xml:space="preserve">
          <source>The most advanced way is to use PDOs.</source>
          <target state="translated">Наиболее продвинутым способом является использование PDO.</target>
        </trans-unit>
        <trans-unit id="77a019a8e37c861117253efcafbe8b46c80d55cb" translate="yes" xml:space="preserve">
          <source>The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to log in as administrator without having his/her password. Now, he/she can do anything that the administrator/email person can do. See, it's very dangerous if SQL injection is not prevented.</source>
          <target state="translated">Другая часть будет выброшена.Так что же случится? Неавторизованный пользователь (хакер)сможет войти в систему как администратор,не имея своего пароля.Теперь он может делать все,что может сделать администратор.Видите ли,это очень опасно,если не предотвратить SQL инъекцию.</target>
        </trans-unit>
        <trans-unit id="caef473bbc5d786e58c45a04c732b8e95dae8488" translate="yes" xml:space="preserve">
          <source>The query will be parsed into the system only up to:</source>
          <target state="translated">Запрос будет разобран в системе только до:</target>
        </trans-unit>
        <trans-unit id="0600942d37431f06a2041faca7c57369364ca714" translate="yes" xml:space="preserve">
          <source>The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.
For example: if you are using a MySQL database then enter into the database through terminal or the UI provided and just follow this command:</source>
          <target state="translated">Простая альтернатива этой проблеме может быть решена путем предоставления соответствующих прав в самой БД.Например:если вы используете БД MySQL,то войдите в БД через терминал или предоставленный пользовательский интерфейс и просто следуйте данной команде:</target>
        </trans-unit>
        <trans-unit id="49869c7c4ee5782157501a3f5be9f08cda113757" translate="yes" xml:space="preserve">
          <source>There are libraries such as &lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt; and &lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt; that allow developers to use prepared statements easier. To learn more about why prepared statements are better at &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;stopping SQL injection&lt;/a&gt;, refer to &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;this &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; bypass&lt;/a&gt; and &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;recently fixed Unicode SQL Injection vulnerabilities in WordPress&lt;/a&gt;.</source>
          <target state="translated">Существуют библиотеки, такие как &lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt; и &lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB,&lt;/a&gt; которые позволяют разработчикам проще использовать подготовленные операторы. Чтобы узнать больше о том, почему подготовленные операторы лучше &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;останавливают инъекцию SQL&lt;/a&gt; , обратитесь к &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;этому &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;недавно исправленным уязвимостям Unicode SQL Injection в WordPress&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c789aef75c0a5b094c0f29903ad99459e880351c" translate="yes" xml:space="preserve">
          <source>There are likely other cases I'm not aware of. You might find &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;this&lt;/a&gt; is a useful resource on some of the more subtle problems you can encounter.</source>
          <target state="translated">Есть, вероятно, другие случаи, о которых я не знаю. Вы можете найти &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;это&lt;/a&gt; полезным ресурсом по некоторым из более тонких проблем, с которыми вы можете столкнуться.</target>
        </trans-unit>
        <trans-unit id="780ecc400391203ddd8ddd799d6ab422887cada5" translate="yes" xml:space="preserve">
          <source>There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course &lt;strong&gt;PDO is one of the good solutions.&lt;/strong&gt; But I would like to suggest you some good links prevention from SQL injection.</source>
          <target state="translated">Существует много способов предотвращения SQL-инъекций и других SQL-хаков. Вы можете легко найти его в Интернете (поиск Google). Конечно, &lt;strong&gt;PDO является одним из хороших решений.&lt;/strong&gt; Но я хотел бы предложить вам хорошую защиту ссылок от SQL-инъекций.</target>
        </trans-unit>
        <trans-unit id="218c170e6057412489f970c39cfe283ca621a4f8" translate="yes" xml:space="preserve">
          <source>There are more abilities to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also, it would be better to use these functions to check input data.</source>
          <target state="translated">Есть еще больше возможностей для предотвращения этого:например,идентификация-если входной сигнал является строкой,числом,char или массивом,то существует так много встроенных функций,которые могут это обнаружить.Также лучше использовать эти функции для проверки входных данных.</target>
        </trans-unit>
        <trans-unit id="830b53ae56caf2de4b110b5e5e28b176692222da" translate="yes" xml:space="preserve">
          <source>There are so many answers for &lt;strong&gt;PHP and MySQL&lt;/strong&gt;, but here is code for &lt;strong&gt;PHP and Oracle&lt;/strong&gt; for preventing SQL injection as well as regular use of oci8 drivers:</source>
          <target state="translated">Существует множество ответов на &lt;strong&gt;PHP и MySQL&lt;/strong&gt; , но вот код для &lt;strong&gt;PHP и Oracle&lt;/strong&gt; для предотвращения внедрения SQL, а также регулярное использование драйверов oci8:</target>
        </trans-unit>
        <trans-unit id="df8b9e7a092d7b299097fd0d02efb87caa3a7f13" translate="yes" xml:space="preserve">
          <source>There is another way to secure identifiers - escaping but I rather stick to whitelisting as a more robust and explicit approach. Yet as long as you have an identifier quoted, you can escape the quote character to make it safe. For example, by default for mysql you have to &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;double the quote character to escape it&lt;/a&gt;. For other other DBMS escaping rules would be different.</source>
          <target state="translated">Есть еще один способ защиты идентификаторов - экранирование, но я предпочитаю использовать белые списки как более надежный и явный подход. Тем не менее, пока у вас есть идентификатор в кавычках, вы можете избежать символа кавычки, чтобы сделать его безопасным. Например, по умолчанию для mysql вы должны &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;удвоить символ кавычки, чтобы избежать его&lt;/a&gt; . Для других других СУБД правила выхода будут другими.</target>
        </trans-unit>
        <trans-unit id="f884dfef89c26e94f34c8d0d17a3e45bfbc8acd8" translate="yes" xml:space="preserve">
          <source>There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:</source>
          <target state="translated">В комментариях была дискуссия,так что я,наконец,хочу прояснить ситуацию.Эти два подхода очень похожи,но они несколько отличаются друг от друга:</target>
        </trans-unit>
        <trans-unit id="224c361000365c82c6c9b9f7d7a6ec856e58482b" translate="yes" xml:space="preserve">
          <source>Therefore, this proves that data validation such as &lt;code&gt;intval()&lt;/code&gt; is a good idea for integer values before sending any query. In addition, preventing malicious user data before sending the query is &lt;strong&gt;a correct and valid approach&lt;/strong&gt;.</source>
          <target state="translated">Таким образом, это доказывает, что проверка данных, например &lt;code&gt;intval()&lt;/code&gt; является хорошей идеей для целочисленных значений перед отправкой любого запроса. Кроме того, предотвращение злонамеренных пользовательских данных перед отправкой запроса является &lt;strong&gt;правильным и корректным подходом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="82972fc3059a1c85c5e906a0ee53efee54cb0064" translate="yes" xml:space="preserve">
          <source>They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.</source>
          <target state="translated">Их (хранимые процедуры)трудно поддерживать и имеют тенденцию к очень быстрому размножению.Это делает управление ими проблемой.</target>
        </trans-unit>
        <trans-unit id="9db87902986489638b3a9991da4a7a39a2f10d0c" translate="yes" xml:space="preserve">
          <source>They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.</source>
          <target state="translated">Они абстрагируют сырой SQL-запрос от приложения,чтобы меньше информации о структуре базы данных было доступно приложению.Это затрудняет понимание людьми основной структуры БД и проектирование подходящих атак.</target>
        </trans-unit>
        <trans-unit id="63f9a45d5192235d9d02af20e18d0355ff4d3bbe" translate="yes" xml:space="preserve">
          <source>They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.</source>
          <target state="translated">Они принимают только параметры,поэтому преимущества параметризованных запросов есть.Конечно же-IMO вам все равно придется дезинфицировать входные данные-особенно если вы используете динамический SQL внутри хранимой процедуры.</target>
        </trans-unit>
        <trans-unit id="da88560285c94420f786914a9987bc73dbdb490a" translate="yes" xml:space="preserve">
          <source>They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.</source>
          <target state="translated">Они не очень подходят для динамических запросов-если они построены так,чтобы принимать динамический код в качестве параметров,то многие преимущества сводятся на нет.</target>
        </trans-unit>
        <trans-unit id="a718b71211da4fde3996aa73a97cdfec744e2e31" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;</source>
          <target state="translated">Подумайте об изучении &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bc28bb81fa5e19dbc4f90b70f46fd3864b30aac" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) &amp;ndash; it is a database access layer providing a uniform method of access to multiple databases.</source>
          <target state="translated">Подумайте об изучении &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) - это уровень доступа к базе данных, обеспечивающий единый метод доступа к нескольким базам данных.</target>
        </trans-unit>
        <trans-unit id="b269ba0fd879f3932b2b527ca85caeb00cf5ba6e" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;question&lt;/a&gt; has some good answers about this.</source>
          <target state="translated">Этот &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;вопрос&lt;/a&gt; имеет несколько хороших ответов об этом.</target>
        </trans-unit>
        <trans-unit id="92ad37abc91646ccd8977cbbc7608b0efd79be0e" translate="yes" xml:space="preserve">
          <source>This allows running statements in an one-liner C#-ish String.Format like:</source>
          <target state="translated">Это позволяет запускать операторы в одном лайнере на C#-ish String.Format типа:</target>
        </trans-unit>
        <trans-unit id="d422b5f7b27e73794ff7c5132ab85405bcfe5b91" translate="yes" xml:space="preserve">
          <source>This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with &lt;code&gt;0x&lt;/code&gt; or use the MySQL function &lt;code&gt;UNHEX&lt;/code&gt; instead.</source>
          <target state="translated">Этот шестнадцатеричный метод часто используется при передаче двоичных данных, но я не вижу причин, почему бы не использовать его для всех данных, чтобы предотвратить атаки с использованием SQL-инъекций. Обратите внимание, что вы должны добавлять данные к &lt;code&gt;0x&lt;/code&gt; или использовать функцию MySQL &lt;code&gt;UNHEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10c3b317d4690df3f686ef3a89e96ef8591796f2" translate="yes" xml:space="preserve">
          <source>This input can be checked early without any prepared statement and stored procedures, but to be on the safe side, using them starts after user-data filtering and validation.</source>
          <target state="translated">Этот вход может быть проверен на ранней стадии без каких-либо подготовленных утверждений и хранимых процедур,но,чтобы быть на всякий случай,их использование начинается после фильтрации и проверки пользовательских данных.</target>
        </trans-unit>
        <trans-unit id="93f5c7f0ce17d7d18825ad4c94168610dc65618a" translate="yes" xml:space="preserve">
          <source>This will restrict the user to only get confined with the specified query's only. Remove the delete permission and so the data would never get deleted from the query fired from the PHP page.
The second thing to do is to flush the privileges so that the MySQL refreshes the permissions and updates.</source>
          <target state="translated">Это ограничит пользователя только указанными запросами.Удалите разрешение на удаление,чтобы данные никогда не удалялись из запроса,выполняемого с PHP-страницы.Второе,что нужно сделать-это промыть привилегии так,чтобы MySQL обновил разрешения и обновления.</target>
        </trans-unit>
        <trans-unit id="fff7386dc03b73f854a16a474ef2b8c2fda58dc3" translate="yes" xml:space="preserve">
          <source>This won't solve every problem, but it's a very good stepping stone. I left out obvious items such as checking the variable's existence, format (numbers, letters, etc.).</source>
          <target state="translated">Это не решит каждой проблемы,но это очень хорошая ступенька.Я пропустил очевидные элементы,такие как проверка существования переменной,ее формата (числа,буквы и т.д.).</target>
        </trans-unit>
        <trans-unit id="16c9cc86f82e3a7c1ca1d9b3739a49f6e61d2e8e" translate="yes" xml:space="preserve">
          <source>Those examples are vulnerable to SQL injection:</source>
          <target state="translated">Эти примеры уязвимы для SQL-инъекций:</target>
        </trans-unit>
        <trans-unit id="8789487a1a2a5eb11f2a7cfa438ec136c375dc71" translate="yes" xml:space="preserve">
          <source>To ease the process I wrote a &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;whitelist helper function&lt;/a&gt; that does all the job in one line:</source>
          <target state="translated">Чтобы упростить процесс, я написал &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;вспомогательную функцию белого списка,&lt;/a&gt; которая выполняет всю работу в одной строке:</target>
        </trans-unit>
        <trans-unit id="fa14c04c76de2e2fab6840f10e0b4d476494ed7a" translate="yes" xml:space="preserve">
          <source>To see the current privileges for the user fire the following query.</source>
          <target state="translated">Чтобы увидеть текущие привилегии пользователя,выполните следующий запрос.</target>
        </trans-unit>
        <trans-unit id="b6cd0f951a947782e4aa09afbcf7e67bd3612b70" translate="yes" xml:space="preserve">
          <source>To use the parameterized query, you need to use &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; rather than the &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt; functions. To rewrite your example, we would need something like the following.</source>
          <target state="translated">Чтобы использовать параметризованный запрос, вам нужно использовать &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi,&lt;/a&gt; а не функции &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt; . Чтобы переписать ваш пример, нам нужно что-то вроде следующего.</target>
        </trans-unit>
        <trans-unit id="92ea56f2bcd611121ebf82d1bb94be8a12add9bd" translate="yes" xml:space="preserve">
          <source>UPDATE 1:</source>
          <target state="translated">ОБНАРУЖИВАНИЕ 1:</target>
        </trans-unit>
        <trans-unit id="f1e7ccfb017f1e9286a26f4401498e961fa8566b" translate="yes" xml:space="preserve">
          <source>Unexpected behavior in the above user input is SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, and root. Once these words detected, you can avoid the input.</source>
          <target state="translated">Неожиданным поведением в вышеприведенном пользовательском вводе является SELECT,UNION,IF,SUBSTRING,BENCHMARK,SHA и root.Как только эти слова будут обнаружены,вы сможете избежать ввода.</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="58b2e2813f252bd73c0a240fc752d08e7de81f2b" translate="yes" xml:space="preserve">
          <source>Update 2:</source>
          <target state="translated">Обновление 2:</target>
        </trans-unit>
        <trans-unit id="ab598eb253cb41b46f92f26312a455cadea5aee1" translate="yes" xml:space="preserve">
          <source>Update 3:</source>
          <target state="translated">Обновление 3:</target>
        </trans-unit>
        <trans-unit id="a097c6d2f311ec0bb34ee1571b93398b7da217e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;PDO&lt;/code&gt; and prepared queries.</source>
          <target state="translated">Используйте &lt;code&gt;PDO&lt;/code&gt; и подготовленные запросы.</target>
        </trans-unit>
        <trans-unit id="536e4e3355286cdf5ee35d48911488b38952ca82" translate="yes" xml:space="preserve">
          <source>Use native PHP functions like: &lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt;, &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string&lt;/a&gt; or if variable numeric, just &lt;code&gt;(int)$foo&lt;/code&gt;. Read more about type of variables in PHP &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;here&lt;/a&gt;. If you're using libraries such as PDO or MySQLi, always use &lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO::quote()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string()&lt;/a&gt;.</source>
          <target state="translated">Используйте собственные функции PHP, такие как: &lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt; , &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string&lt;/a&gt; или, если числовая переменная, просто &lt;code&gt;(int)$foo&lt;/code&gt; . Подробнее о типе переменных в PHP читайте &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;здесь&lt;/a&gt; . Если вы используете библиотеки, такие как PDO или MySQLi, всегда используйте &lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO :: quote ()&lt;/a&gt; и &lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d38f5f0dc278ebfe3743f0e9d9ad122b9d88ce8f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;, which is a pre-defined function in &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;, and this code add backslashes to the following characters: &lt;code&gt;\x00&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\x1a&lt;/code&gt;. Pass the input values as parameters to minimize the chance of SQL injection.</source>
          <target state="translated">Использование &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; , которая является предопределенной функцией в &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; , и этот код добавляет обратную косую черту к следующим символам: &lt;code&gt;\x00&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; и &lt;code&gt;\x1a&lt;/code&gt; . Передайте входные значения как параметры чтобы минимизировать вероятность внедрения SQL.</target>
        </trans-unit>
        <trans-unit id="56d170f163928a8c1fff4954924527fa155e8ca3" translate="yes" xml:space="preserve">
          <source>Use other tools: Here, I will also agree with you that a prepared statement (parametrized query) and stored procedures. The disadvantages here is these ways require advanced skills which do not exist for most users. The basic idea here is to distinguish between the SQL query and the data that is used inside. Both approaches can be used even with unsafe data, because the user-input data here does not add anything to the original query, such as (any or x=x).</source>
          <target state="translated">Используйте другие инструменты:Здесь я также соглашусь с тем,что подготовленное заявление (параметризованный запрос)и сохраненные процедуры.Недостатком здесь является то,что эти способы требуют продвинутых навыков,которых нет у большинства пользователей.Основная идея здесь заключается в том,чтобы отличить SQL-запрос от данных,которые используются внутри.Оба подхода могут использоваться даже с небезопасными данными,так как вводимые пользователем данные здесь ничего не добавляют к исходному запросу,например (любой или x=x).</target>
        </trans-unit>
        <trans-unit id="2ab1b2c4d270d99ef373efcd0f8b8574c802370d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt; is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to use</source>
          <target state="translated">Использование &lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt; и &lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt; - хорошая практика для предотвращения SQL-инъекций, но если вы действительно хотите работать с функциями и запросами MySQL, было бы лучше использовать</target>
        </trans-unit>
        <trans-unit id="38c0c660c5df9571196ca554badedbf16ace904b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; (for MySQL):</source>
          <target state="translated">Использование &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; (для MySQL):</target>
        </trans-unit>
        <trans-unit id="a4e7bd1b02d3303b9bd6d557965df01c324c3557" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (for any supported database driver):</source>
          <target state="translated">Использование &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (для любого поддерживаемого драйвера базы данных):</target>
        </trans-unit>
        <trans-unit id="64fd160974da8c9008dad32fa19315d8009920f4" translate="yes" xml:space="preserve">
          <source>Using this PHP function &lt;code&gt;mysql_escape_string()&lt;/code&gt; you can get a good prevention in a fast way.</source>
          <target state="translated">Используя эту функцию PHP &lt;code&gt;mysql_escape_string()&lt;/code&gt; вы можете быстро получить хорошее предупреждение.</target>
        </trans-unit>
        <trans-unit id="0d3a08ce38eb2066c704c7481d4b7d5c8f7699f5" translate="yes" xml:space="preserve">
          <source>We'll cover the lower impact string escaping one first.</source>
          <target state="translated">Сначала мы прикроем нижний ударный шнур,сбежавший один.</target>
        </trans-unit>
        <trans-unit id="b0ca7362248cae31401c4742155c18ebaa5ff23d" translate="yes" xml:space="preserve">
          <source>What can be done to prevent this from happening?</source>
          <target state="translated">Что можно сделать,чтобы этого не случилось?</target>
        </trans-unit>
        <trans-unit id="4ec900e30a04771ad57031ac632ba224fe5ec06c" translate="yes" xml:space="preserve">
          <source>What is &lt;strong&gt;mandatory&lt;/strong&gt;, however, is the first &lt;code&gt;setAttribute()&lt;/code&gt; line, which tells PDO to disable emulated prepared statements and use &lt;em&gt;real&lt;/em&gt; prepared statements. This makes sure the statement and the values aren't parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).</source>
          <target state="translated">Однако &lt;strong&gt;обязательна&lt;/strong&gt; первая &lt;code&gt;setAttribute()&lt;/code&gt; , которая указывает PDO отключить эмулированные подготовленные операторы и использовать &lt;em&gt;реально&lt;/em&gt; подготовленные операторы. Это гарантирует, что оператор и значения не будут проанализированы PHP перед отправкой его на сервер MySQL (не давая возможности злоумышленнику внедрить вредоносный SQL).</target>
        </trans-unit>
        <trans-unit id="4a061bb9449a7869b1bb6c140f6c244c24e19160" translate="yes" xml:space="preserve">
          <source>Whatever you do end up using, make sure that you check your input hasn't already been mangled by &lt;code&gt;magic_quotes&lt;/code&gt; or some other well-meaning rubbish, and if necessary, run it through &lt;code&gt;stripslashes&lt;/code&gt; or whatever to sanitize it.</source>
          <target state="translated">Что бы вы ни использовали в конечном итоге, убедитесь, что вы проверяете, что ваши входные данные еще не были искажены &lt;code&gt;magic_quotes&lt;/code&gt; или каким-либо другим благонамеренным мусором, и, если необходимо, пропустите их через &lt;code&gt;stripslashes&lt;/code&gt; или что- нибудь еще, чтобы очистить их.</target>
        </trans-unit>
        <trans-unit id="00f02bbdebbfdbc228c8163a6409202a17282e4d" translate="yes" xml:space="preserve">
          <source>While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.</source>
          <target state="translated">Несмотря на то,что для параметров запроса можно использовать подготовленные операторы,сама структура динамического запроса не может быть параметризована,а некоторые особенности запроса не могут быть параметризованы.</target>
        </trans-unit>
        <trans-unit id="1ac6d9646522fe48ad32b3fffb2a4692cff0ee0f" translate="yes" xml:space="preserve">
          <source>Will become:</source>
          <target state="translated">Станет:</target>
        </trans-unit>
        <trans-unit id="204b32dc579f45400949999976e4e7bd02995817" translate="yes" xml:space="preserve">
          <source>You basically have two options to achieve this:</source>
          <target state="translated">У тебя,по сути,есть два варианта достижения этого:</target>
        </trans-unit>
        <trans-unit id="ec00a1df9d6128980fc27b80f095461babcb7153" translate="yes" xml:space="preserve">
          <source>You can find more details in &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL - SQL Injection Prevention&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Вы можете найти более подробную информацию в &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL - SQL Injection Prevention&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b865044a62cd48efbfda9b53b850310ecec07a85" translate="yes" xml:space="preserve">
          <source>You could do something basic like this:</source>
          <target state="translated">Ты можешь сделать что-нибудь простое:</target>
        </trans-unit>
        <trans-unit id="0cff3e61f8aade5ced706b23961eeb5d59ba96ea" translate="yes" xml:space="preserve">
          <source>You've got two options - escaping the special characters in your &lt;code&gt;unsafe_variable&lt;/code&gt;, or using a parameterized query. Both would protect you from SQL injection. The parameterized query is considered the better practice but will require changing to a newer MySQL extension in PHP before you can use it.</source>
          <target state="translated">У вас есть два варианта - экранирование специальных символов в &lt;code&gt;unsafe_variable&lt;/code&gt; или использование параметризованного запроса. Оба защитят вас от внедрения SQL. Параметризованный запрос считается лучшей практикой, но перед его использованием потребуется перейти на более новое расширение MySQL в PHP.</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">число</target>
        </trans-unit>
        <trans-unit id="555d01e6c83266b3e9f92bd811905370caf62770" translate="yes" xml:space="preserve">
          <source>a string</source>
          <target state="translated">струна</target>
        </trans-unit>
        <trans-unit id="5bb5bc166d482477e7f41c8996346a70df7264aa" translate="yes" xml:space="preserve">
          <source>a syntax keyword</source>
          <target state="translated">синтаксическое ключевое слово</target>
        </trans-unit>
        <trans-unit id="415dd55dd005527a8b6d386ea933f1cb842449b8" translate="yes" xml:space="preserve">
          <source>an attack can inject you very &lt;em&gt;easily&lt;/em&gt;. Consider the following injected code returned from your script:</source>
          <target state="translated">атака может сделать вам инъекцию очень &lt;em&gt;легко&lt;/em&gt; . Рассмотрим следующий внедренный код, возвращаемый из вашего скрипта:</target>
        </trans-unit>
        <trans-unit id="eb4952e764d7c270f5b65eab412865f0e3d1e28d" translate="yes" xml:space="preserve">
          <source>an identifier</source>
          <target state="translated">идентификатор</target>
        </trans-unit>
        <trans-unit id="e371325eaf8cf1513b8fb5c935edacb07019dc53" translate="yes" xml:space="preserve">
          <source>and now just extract table structure:</source>
          <target state="translated">а теперь просто извлеките структуру стола:</target>
        </trans-unit>
        <trans-unit id="00a568b3ade5326f00d2f75efc890a8fa7d228a0" translate="yes" xml:space="preserve">
          <source>and password anything....</source>
          <target state="translated">и пароль на что угодно...</target>
        </trans-unit>
        <trans-unit id="dcdc68162ecd47207ad2d4500cb7f65ba1b2f599" translate="yes" xml:space="preserve">
          <source>is_numeric</source>
          <target state="translated">is_numeric</target>
        </trans-unit>
        <trans-unit id="b32f9e192cce5e6c514823660d6fc173cb3dd500" translate="yes" xml:space="preserve">
          <source>is_string</source>
          <target state="translated">is_string</target>
        </trans-unit>
        <trans-unit id="77064c82097c6f5dee58b4d6d530b90e598c4da1" translate="yes" xml:space="preserve">
          <source>more information about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;flush&lt;/a&gt;.</source>
          <target state="translated">больше информации о &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;флеше&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71d20c07a9f068a85df7519fb5b1a4e4eecf531f" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string</source>
          <target state="translated">mysql_real_escape_string</target>
        </trans-unit>
        <trans-unit id="6ccd64ba549314b5da86aaa89a6184349dcc2710" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string() will not protect here. If you use single quotes (' ') around your variables inside your query is what protects you against this. Here is an solution below for this:</source>
          <target state="translated">mysql_real_escape_string()здесь не будет защищать.Если вы используете одинарные кавычки (' ')вокруг переменных внутри запроса,то это то,что защищает вас от этого.Ниже приведено решение этой проблемы:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
