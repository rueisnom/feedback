<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/60174">
    <body>
      <group id="60174">
        <trans-unit id="28db4e540747091b7a00b15b115a95e87c6fb18f" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;$conn&lt;/code&gt; is a &lt;code&gt;PDO&lt;/code&gt; object)</source>
          <target state="translated">（ &lt;code&gt;$conn&lt;/code&gt; 是一个 &lt;code&gt;PDO&lt;/code&gt; 对象）</target>
        </trans-unit>
        <trans-unit id="7df4be97ec047ed1a29912298ea3b0fcbc7ed380" translate="yes" xml:space="preserve">
          <source>--- &lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;-MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="566ea8d89155c02c58ff63984dcd175883a55e5f" translate="yes" xml:space="preserve">
          <source>---- &lt;strong&gt;PDO&lt;/strong&gt;</source>
          <target state="translated">---- &lt;strong&gt;PDO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="16d6eec24d215237193fd125401ea3f72038ce7c" translate="yes" xml:space="preserve">
          <source>----- Named placeholders</source>
          <target state="translated">-----命名的占位符</target>
        </trans-unit>
        <trans-unit id="6f87ec96d5b86996a40f5259f92fc7fad65ced43" translate="yes" xml:space="preserve">
          <source>----- No placeholders - ripe for SQL injection! &lt;strong&gt;It's bad&lt;/strong&gt;</source>
          <target state="translated">-----没有占位符-可以进行SQL注入了！ &lt;strong&gt;这不好&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcff74f12914fdb8c051ea2e336776fd176f90" translate="yes" xml:space="preserve">
          <source>----- Unnamed placeholders</source>
          <target state="translated">-----未命名的占位符</target>
        </trans-unit>
        <trans-unit id="c8f539c5cc020994d7d2752bb0266689882010b0" translate="yes" xml:space="preserve">
          <source>// Connect to MySQL</source>
          <target state="translated">/连接到MySQL</target>
        </trans-unit>
        <trans-unit id="210d7dde35cddea92280995918b6bfd938945cd2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;Source&lt;/a&gt;: &lt;em&gt;The Unexpected SQL Injection (When Escaping Is Not Enough)&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;源&lt;/a&gt; ： &lt;em&gt;意外的SQL注入（当转义不够时）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fafbba6ac674ca8233b3bb137474220f54670c01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash; Escapes a string for use in a mysql_query</source>
          <target state="translated">&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash;转义要在mysql_query中使用的字符串</target>
        </trans-unit>
        <trans-unit id="2acf2cfec503ef763160d951705f3dcc3dbb00be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; is deprecated as of PHP 5.5.0. Use either mysqli or PDO.</source>
          <target state="translated">从PHP 5.5.0开始不推荐使用 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 。 使用mysqli或PDO。</target>
        </trans-unit>
        <trans-unit id="ac2812cda025d0222eb136ebe05af667375a9255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string&lt;/code&gt; takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(') a user might enter with a MySQL-safe substitute, an escaped quote \'.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string&lt;/code&gt; 接受将在MySQL查询中使用的字符串，并返回相同的字符串，并安全地转义了所有SQL注入尝试。 基本上，它将用MySQL安全的替代品（转义的引号\'）代替用户可能输入的那些麻烦的引号（'）。</target>
        </trans-unit>
        <trans-unit id="993cce94e6973d25742799e350d687c6d47eb565" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;What is SQL injection and how to prevent&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;什么是SQL注入以及如何防止&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eedc1ef7aa89311e0fab1b48d2dbf4f551aa710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;Microsoft explanation of SQL injection and prevention in PHP&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;Microsoft对PHP中SQL注入和预防的解释&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09a2090f97db4e53860ae5ab475445cb9ea655d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;PHP manual for SQL injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;PHP手册SQL注入&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b6995e63bfc6f9fa8ec35b4a707089f01068f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And please test every query to your database - it's a better way to prevent injection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;并且请测试对数据库的每个查询-这是防止注入的更好方法。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="881c07549030945c2309cee9e2e2ac2c9261312f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data filtering for (converting unsafe data to safe data)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;数据过滤（将不安全数据转换为安全数据）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b74390d8460cdf00400fa1ae06a8df3cec12865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;
  This answer's sample code (like the question's sample code) uses PHP's &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.</source>
          <target state="translated">&lt;strong&gt;不建议使用的警告：&lt;/strong&gt;此答案的示例代码（如问题的示例代码）使用PHP的 &lt;code&gt;MySQL&lt;/code&gt; 扩展，此扩展在PHP 5.5.0中已弃用，在PHP 7.0.0中已完全删除。</target>
        </trans-unit>
        <trans-unit id="1051e53e86d6b39bb445cb5e011266551db0339e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning&lt;/strong&gt;: The mysql extension is deprecated at this time. we recommend using the &lt;em&gt;PDO extension&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;不建议使用的警告&lt;/strong&gt; ：此时&lt;strong&gt;不建议使用&lt;/strong&gt; mysql扩展。 我们建议使用&lt;em&gt;PDO扩展&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dda06a174f7dd5e74c8eabf80656879e8b1f296" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single column&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我想要一个专栏&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80c1cc3b7b50e8fd2aea1b4ca0b3b75408434e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single row result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我想要单行结果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="024c9614f439c4a7911a75baa6232c91c34e16cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array of results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我想要一系列结果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4dc6dc4cb39edde6e4cb977be5a4e00bfee01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array(key =&amp;gt; value) results (i.e. for making a selectbox)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我想要一个数组（键=&amp;gt;值）结果（即用于创建选择框）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8052e9a559828f926aaf4cb0e3c1b2ca31046e95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IMPORTANT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cde4be58e6e2d465148f3e98b5727244f7a72453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;库示例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e446408dbdb6997b7424912b8c1d79a1c5ab993b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23d6bf55f17ae053d22c5b227546c45610ff250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c585f3da07abdc2dcc052b0a31c75b51345fff8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; you must be connected to the database to use this function!</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您必须连接到数据库才能使用此功能！</target>
        </trans-unit>
        <trans-unit id="a67dc084aafad94a19d93929a672c4d8c26d1f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;P.S&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b10a86d4bbe9f0b1901a8bde6b52d5685220b62b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PDO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PDO:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3a71e18b47cb4549c122f88532d562818113692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Query Log:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;查询日志：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b772547fb5634e5dbe11cab975563db5faff2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RULE: do not create one database user for all privileges. For all SQL operations, you can create your scheme like (deluser, selectuser, updateuser) as usernames for easy usage.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;规则：不要为所有特权创建一个数据库用户。&lt;/strong&gt; &lt;strong&gt;对于所有SQL操作，您都可以将方案（（deluser，selectuser，updateuser））创建为用户名，以便于使用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e3668d2a13faa5a6d222104bab0c82a2d2b1525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)</source>
          <target state="translated">&lt;strong&gt;安全警告&lt;/strong&gt; ：此答案与安全最佳做法不符。 &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;转义不足以防止SQL注入&lt;/a&gt; ，请改用&lt;em&gt;准备好的语句&lt;/em&gt; 。 使用以下概述的策略需要您自担风险。 （此外，在PHP 7中删除了 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="69b9b6580cb9915e7a2d71a41230225b3ca5ffb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UNHEX()&lt;/strong&gt; works on &lt;strong&gt;any&lt;/strong&gt; column; you do not have to worry about the empty string.</source>
          <target state="translated">&lt;strong&gt;UNHEX（）&lt;/strong&gt;可在&lt;strong&gt;任何&lt;/strong&gt;列上使用； 您不必担心空字符串。</target>
        </trans-unit>
        <trans-unit id="e7d6310b11ad04ede1d86386dd85ffa2b6b00627" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use prepared statements and parameterized queries.&lt;/strong&gt; These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.</source>
          <target state="translated">&lt;strong&gt;使用准备好的语句和参数化查询。&lt;/strong&gt; 这些是独立于任何参数发送到数据库服务器并由数据库服务器解析的SQL语句。 这样，攻击者就不可能注入恶意SQL。</target>
        </trans-unit>
        <trans-unit id="4b66375073c94d88e7cae14419ae8276f33a993c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning: the approach described in this answer only applies to very specific scenarios and isn't secure since SQL injection attacks do not only rely on being able to inject &lt;code&gt;X=Y&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;警告：此答案中描述的方法仅适用于非常特殊的情况，并且并不安全，因为SQL注入攻击不仅依赖于能够注入 &lt;code&gt;X=Y&lt;/code&gt; 。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="167a410708537f3843a1e61a18f3cd510d6bcd35" translate="yes" xml:space="preserve">
          <source>A few guidelines for escaping special characters in SQL statements.</source>
          <target state="translated">关于SQL语句中特殊字符转义的一些准则。</target>
        </trans-unit>
        <trans-unit id="260ac50ca6144215fd0045d1af48ccfa01e745f8" translate="yes" xml:space="preserve">
          <source>A good idea is to use an &lt;strong&gt;'object-relational mapper'&lt;/strong&gt; like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt;:</source>
          <target state="translated">一个好主意是使用像&lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt;这样的&lt;strong&gt;&amp;ldquo;对象关系映射器&amp;rdquo;&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f6d894b7333493ff06b2ed34e4c107a54abe2c5" translate="yes" xml:space="preserve">
          <source>A simple way would be to use a PHP framework like &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt; or &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; which have inbuilt features like filtering and active-record so that you don't have to worry about these nuances.</source>
          <target state="translated">一种简单的方法是使用像&lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt;或&lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt;这样的PHP框架，它们具有诸如过滤和活动记录之类的内置功能，因此您不必担心这些细微差别。</target>
        </trans-unit>
        <trans-unit id="a4f547e2a90f5422256b70e6749192b1dc12e925" translate="yes" xml:space="preserve">
          <source>A user commented that this post is useless, OK! Here is what &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORG provided&lt;/a&gt;:</source>
          <target state="translated">一位用户评论说，这篇文章没有用，好！ 这是&lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORG提供的&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="f8bcba9062fd4c5354b3fe7577630f1852a5a4f1" translate="yes" xml:space="preserve">
          <source>Additional defenses:</source>
          <target state="translated">额外的防御措施。</target>
        </trans-unit>
        <trans-unit id="5a9a57fdfe801732160d7b653550c5f2e63ef2a2" translate="yes" xml:space="preserve">
          <source>Adopting the MVC pattern and a framework like &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt; or &lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter&lt;/a&gt; is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries.</source>
          <target state="translated">采用MVC模式和&lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt;或&lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter之&lt;/a&gt;类的框架可能是正确的方法：诸如创建安全数据库查询之类的常见任务已在此类框架中得到解决和集中实现。 它们可帮助您以明智的方式组织Web应用程序，并使您更多地考虑加载和保存对象，而不是安全地构造单个SQL查询。</target>
        </trans-unit>
        <trans-unit id="c8a14a30d16f16ac980bf356d9504fab38b7075b" translate="yes" xml:space="preserve">
          <source>Also Enforce: Least Privilege</source>
          <target state="translated">同时执行。最低限度的特权</target>
        </trans-unit>
        <trans-unit id="1896c2015dcc61c975328aa2d6d19cd66a93eed3" translate="yes" xml:space="preserve">
          <source>Also Perform: White List Input Validation</source>
          <target state="translated">同时执行。白名单输入验证</target>
        </trans-unit>
        <trans-unit id="a7a90d96967d5c49bc4afaed57e9dee54e4e9f9c" translate="yes" xml:space="preserve">
          <source>Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt;.</source>
          <target state="translated">另外，正如其他人所建议的那样，您可能会发现有用/更容易地使用&lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO之类的&lt;/a&gt;东西来增强抽象层。</target>
        </trans-unit>
        <trans-unit id="2c30cce0b8c2965ca51b265a25df9d3693f83528" translate="yes" xml:space="preserve">
          <source>Also, its use is a little complicated if you are about to insert an empty string. You'll have to entirely replace it with &lt;code&gt;''&lt;/code&gt;, or you'll get an error.</source>
          <target state="translated">另外，如果您要插入一个空字符串，则它的使用会有些复杂。 您必须将其完全替换为 &lt;code&gt;''&lt;/code&gt; ，否则会出现错误。</target>
        </trans-unit>
        <trans-unit id="69c4f0f8d46827c16603dcdf21511ca657bcb9e9" translate="yes" xml:space="preserve">
          <source>Also, you can 'prepare' your arguments before preparing your query so that you can build dynamic queries and at the end have a fully prepared statements query. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">同样，您可以在准备查询之前&amp;ldquo;准备&amp;rdquo;参数，以便构建动态查询，最后进行充分准备的语句查询。 &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;使用PHP的MySQL DALMP数据库抽象层。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74d699a30675fa3d298fbab5df176b5b25503844" translate="yes" xml:space="preserve">
          <source>Although there is a general agreement on the best practices regarding SQL injection protection, there are &lt;strong&gt;still many bad practices as well.&lt;/strong&gt; And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) &lt;strong&gt;more than 80 deleted answers&lt;/strong&gt; - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of the bad answers aren't deleted, but rather prospering.</source>
          <target state="translated">尽管就SQL注入保护的最佳实践达成了普遍共识，但&lt;strong&gt;仍然存在许多不良实践。&lt;/strong&gt; 其中有些太扎根于PHP用户的思想中。 例如，在此页面上，（尽管对大多数访问者不可见） &lt;strong&gt;有80多个已删除的答案&lt;/strong&gt; -由于质量低劣或推广不良和过时的做法而被社区删除。 更糟糕的是，一些错误的答案并未被删除，反而会蒸蒸日上。</target>
        </trans-unit>
        <trans-unit id="eabd1c8f5b2f8e2b973f2b52cc71e91a5bb24985" translate="yes" xml:space="preserve">
          <source>Although you can set the &lt;code&gt;charset&lt;/code&gt; in the options of the constructor, it's important to note that 'older' versions of PHP (before 5.3.6) &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;silently ignored the charset parameter&lt;/a&gt; in the DSN.</source>
          <target state="translated">尽管可以在构造函数的选项中设置 &lt;code&gt;charset&lt;/code&gt; ，但要注意的一点是，PHP的&amp;ldquo;较旧&amp;rdquo;版本（5.3.6之前的版本）在DSN中&lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;默默地忽略了字符集参数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="89427a94f14d4db682ce047617bd39f90aeb83cc" translate="yes" xml:space="preserve">
          <source>An alternative to mysql_real_escape_string() is</source>
          <target state="translated">mysql_real_escape_string()的替代方案是</target>
        </trans-unit>
        <trans-unit id="7bcc7fb301834a94c428663cf127b9d3c420bafb" translate="yes" xml:space="preserve">
          <source>And OWASP makes it even worse, stressing on escaping &lt;em&gt;user input&lt;/em&gt; which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It's the destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is &quot;safe&quot; or not) he/she takes his/her first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.</source>
          <target state="translated">OWASP更加糟糕，它着重于逃避&lt;em&gt;用户输入&lt;/em&gt; ，这完全是胡说八道：在注入保护的上下文中，不应有这样的措辞。 每个变量都有潜在的危险-无论来源如何！ 或者，换句话说-每个变量都必须正确设置格式才能放入查询中-不管源是什么。 重要的是目的地。 当开发人员开始将绵羊与山羊分开时（考虑某些特定变量是否&amp;ldquo;安全&amp;rdquo;），他/她迈出了走向灾难的第一步。 更不用说即使是措辞也建议在入口点进行大量转义，类似于非常不可思议的引号功能-已被轻视，不推荐使用和删除。</target>
        </trans-unit>
        <trans-unit id="029c0a0374bedd82f613d03ef16978761b30cf7e" translate="yes" xml:space="preserve">
          <source>And by using PDO rather than &lt;code&gt;mysql_&lt;/code&gt;, &lt;code&gt;mysqli_&lt;/code&gt;, and &lt;code&gt;pgsql_&lt;/code&gt; functions, you make your application a little more abstracted from the database, in the rare occurrence that you have to switch database providers.</source>
          <target state="translated">而且通过使用PDO而不是 &lt;code&gt;mysql_&lt;/code&gt; ， &lt;code&gt;mysqli_&lt;/code&gt; 和 &lt;code&gt;pgsql_&lt;/code&gt; 函数，可以使您的应用程序从数据库中抽象一些，这种情况很少发生，您必须切换数据库提供程序。</target>
        </trans-unit>
        <trans-unit id="9b5ef3ee55266b405431414057f96c242ca0a3ea" translate="yes" xml:space="preserve">
          <source>And it is so much better to use those functions to check input data with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">使用这些函数通过 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 来检查输入数据要好得多。</target>
        </trans-unit>
        <trans-unit id="8b6f9dd7708882555f93273050b2295e1ff50293" translate="yes" xml:space="preserve">
          <source>And prepared statements cover only two of them.</source>
          <target state="translated">而准备好的报表只涉及其中的两个。</target>
        </trans-unit>
        <trans-unit id="9a818eb4d9f22f32e544143c95e4a338abac3b6a" translate="yes" xml:space="preserve">
          <source>And some other like &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;Preventing SQL injection with MySQL and PHP&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">以及其他一些诸如&lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;防止MySQL和PHP进行SQL注入&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a9c32269a2494bf681823b0f8ef4fe2f380c0b7" translate="yes" xml:space="preserve">
          <source>And the use of &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is a useful function when used properly, especially when combined with &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysqli_real_escape_string&lt;/code&gt; ， mysqli_real_escape_string的使用是为了在字符串中转义特殊字符，因此不会使整数安全。 此功能的目的是防止破坏SQL语句中的字符串以及可能导致的数据库损坏。 正确使用 &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; 是有用的函数，尤其是与 &lt;code&gt;sprintf&lt;/code&gt; 结合使用时。</target>
        </trans-unit>
        <trans-unit id="77fdc73c5a405950cdef3ff428d3bc7c8429a576" translate="yes" xml:space="preserve">
          <source>And then just select whatever data ones want. Isn't it cool?</source>
          <target state="translated">然后选择自己想要的数据就可以了。这不是很酷吗?</target>
        </trans-unit>
        <trans-unit id="469e5ab140693a349e074c76557802c31c33fd02" translate="yes" xml:space="preserve">
          <source>Another benefit of using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.</source>
          <target state="translated">使用准备好的语句的另一个好处是,如果你在同一个会话中多次执行相同的语句,它将只被解析和编译一次,给你带来一些速度上的提升。</target>
        </trans-unit>
        <trans-unit id="ac2632462245c897b1b550ec3d5bcf2e8b29db73" translate="yes" xml:space="preserve">
          <source>Any other query part, such as an SQL keyword, a table or a field name, or an operator - must be filtered through a white list.</source>
          <target state="translated">任何其他查询部分,如SQL关键字、表或字段名或操作符等,都必须通过白名单进行过滤。</target>
        </trans-unit>
        <trans-unit id="59ca1e0dddd5402d6c514f23b5ab618318bd9b52" translate="yes" xml:space="preserve">
          <source>Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the &lt;code&gt;$name&lt;/code&gt; variable contains &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; the result would simply be a search for the string &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt;, and you will not end up with &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;an empty table&lt;/a&gt;.</source>
          <target state="translated">使用预处理语句发送的任何参数都将被视为字符串（尽管数据库引擎可能会进行一些优化，因此参数最终也可能以数字结尾）。 在上面的示例中，如果 &lt;code&gt;$name&lt;/code&gt; 变量包含 &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; DELETE FROM employee的结果将只是搜索字符串 &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt; ，并且您最终不会得到&lt;a href=&quot;http://xkcd.com/327/&quot;&gt;一个空表&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="814927018a663b40d6800585c37e63752cd8b345" translate="yes" xml:space="preserve">
          <source>Any variable that represents an SQL data literal, (or, to put it simply - an SQL string, or a number) must be added through a prepared statement. No Exceptions.</source>
          <target state="translated">任何表示SQL数据字面意义的变量(或者简单地说,就是SQL字符串或数字)必须通过准备好的语句添加。没有例外。</target>
        </trans-unit>
        <trans-unit id="8f339838f01ea88e77c778fe86da6db1dbb6727f" translate="yes" xml:space="preserve">
          <source>As also mentioned in the above statement,</source>
          <target state="translated">上述声明中也提到:</target>
        </trans-unit>
        <trans-unit id="35a0aae8525a92229ff81ec077bfddd794e5ad1c" translate="yes" xml:space="preserve">
          <source>As you can see, people suggest you use prepared statements at the most. It's not wrong, but when your query is executed &lt;strong&gt;just once&lt;/strong&gt; per process, there would be a slight performance penalty.</source>
          <target state="translated">如您所见，人们建议您最多使用准备好的语句。 没错，但是当您的查询每个进程&lt;strong&gt;只&lt;/strong&gt;执行&lt;strong&gt;一次时&lt;/strong&gt; ，将会有轻微的性能损失。</target>
        </trans-unit>
        <trans-unit id="bd2cedbc3cba1b466c7ccb0d7d8ccb2234565bfd" translate="yes" xml:space="preserve">
          <source>As you may know, claiming an article should be supported by a valid argument, at least by one reference! Otherwise, it's considered as an attack and a bad claim!</source>
          <target state="translated">你可能知道,声称一篇文章应该有一个有效的论证,至少要有一个参考文献的支持! 否则,会被认为是一种攻击,是一种不好的主张!</target>
        </trans-unit>
        <trans-unit id="820ba4d63bbc346ca4423e23a1bea3ca67844669" translate="yes" xml:space="preserve">
          <source>Basically, read it &lt;a href=&quot;http://php.net/pdo&quot;&gt;while you read the manual&lt;/a&gt; to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format &lt;strong&gt;you&lt;/strong&gt; want.</source>
          <target state="translated">基本上，请&lt;a href=&quot;http://php.net/pdo&quot;&gt;在阅读手册的同时&lt;/a&gt;阅读它，以了解如何在现实生活中使用PDO函数，以使其易于以所需的格式存储和检索值。</target>
        </trans-unit>
        <trans-unit id="984f8b5a40d91fa830e321cc52151441d3cd3388" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;1=1&lt;/code&gt;, &lt;code&gt;2=2&lt;/code&gt;, &lt;code&gt;1=2&lt;/code&gt;, &lt;code&gt;2=1&lt;/code&gt;, &lt;code&gt;1+1=2&lt;/code&gt;, etc... are the common questions to an SQL database of an attacker. Maybe also it's used by many hacking applications.</source>
          <target state="translated">因为 &lt;code&gt;1=1&lt;/code&gt; &lt;code&gt;2=2&lt;/code&gt; &lt;code&gt;1=2&lt;/code&gt; &lt;code&gt;2=1&lt;/code&gt; &lt;code&gt;1+1=2&lt;/code&gt; 等是攻击者的SQL数据库的常见问题。 也许它也被许多黑客应用程序所使用。</target>
        </trans-unit>
        <trans-unit id="c0510df3f1d4695430a58920cd200e354ad3da70" translate="yes" xml:space="preserve">
          <source>Bound variables will be escaped automatically by the server. The
  server inserts their escaped values at the appropriate places into the
  statement template before execution. A hint must be provided to the
  server for the type of bound variable, to create an appropriate
  conversion. See the mysqli_stmt_bind_param() function for more
  information.</source>
          <target state="translated">绑定的变量将被服务器自动转义。服务器会在执行前将其转义值插入到语句模板的适当位置。必须为绑定变量的类型向服务器提供一个提示,以创建适当的转换。更多信息请参见 mysqli_stmt_bind_param()函数。</target>
        </trans-unit>
        <trans-unit id="6c45ced87722560ce91bdb8d47661e48efa8ce64" translate="yes" xml:space="preserve">
          <source>But if the coder of an injectable site would hex it, no injection would be possible because the query would look like this: &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</source>
          <target state="translated">但是，如果可注入站点的编码器将其十六进制，则不可能进行注入，因为查询将如下所示： &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1130d41244662be40e74568e6d313b2aeba7a56" translate="yes" xml:space="preserve">
          <source>But sometimes we have to make our query even more dynamic, adding operators or identifiers as well.
So, we will need different protection techniques.</source>
          <target state="translated">但是有时候我们要让我们的查询更加动态,添加操作符或标识符也是如此。所以,我们会需要不同的保护技术。</target>
        </trans-unit>
        <trans-unit id="388e5f4608b9c0c64a94caf6cb522f68f0b812be" translate="yes" xml:space="preserve">
          <source>But while both PDO and MySQLi are quite fast, MySQLi performs
insignificantly faster in benchmarks &amp;ndash; ~2.5% for non-prepared
statements, and ~6.5% for prepared ones.</source>
          <target state="translated">但是，尽管PDO和MySQLi都相当快，但MySQLi在基准测试中的执行速度却微不足道-未准备好的语句约为2.5％，而准备好的语句约为6.5％。</target>
        </trans-unit>
        <trans-unit id="11ae2ab8e554cd29a407caca0e6fabee0756957e" translate="yes" xml:space="preserve">
          <source>But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect &lt;em&gt;(it depends on you)&lt;/em&gt; that hacking-specific dynamic query string into a page that will store the attacker's &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP address&lt;/a&gt;, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.</source>
          <target state="translated">但是您必须小心，不要从站点重写安全的查询。 上面的代码为您提供了一个技巧，将特定&lt;em&gt;于&lt;/em&gt;黑客的动态查询字符串重写或重定向&lt;em&gt;（取决于您）&lt;/em&gt;到一个页面中，该页面将存储攻击者的&lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP地址&lt;/a&gt; ，甚至他们的菜谱，历史记录，浏览器或任何其他敏感信息信息，因此您以后可以通过禁止他们的帐户或与当局联系来与他们打交道。</target>
        </trans-unit>
        <trans-unit id="c2424b0d28c65836412890f683090b9c10c2c3e2" translate="yes" xml:space="preserve">
          <source>Can prepared statements be used for dynamic queries?</source>
          <target state="translated">准备好的语句能否用于动态查询?</target>
        </trans-unit>
        <trans-unit id="cc031d2a659335c48d55ac551c2a927f393178cf" translate="yes" xml:space="preserve">
          <source>Consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; are not available. How can you secure your application? Do you force me to use them? What about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border, not just for a specific language.</source>
          <target state="translated">考虑到&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;不可用。 您如何保护您的应用程序？ 你强迫我使用它们吗？ 除了PHP以外的其他语言呢？ 我倾向于提供一般性的想法，因为它不仅可以用于特定的语言，而且可以用于更广泛的边界。</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">请考虑以下问题:</target>
        </trans-unit>
        <trans-unit id="6047ffa640b216365f3915cb1825dec617a4486c" translate="yes" xml:space="preserve">
          <source>Correctly setting up the connection</source>
          <target state="translated">正确设置连接</target>
        </trans-unit>
        <trans-unit id="a6b87d4687eee957fbc10c0728a5bff14a875b82" translate="yes" xml:space="preserve">
          <source>Data filtering: before building any query user input, it should be validated and filtered. For programmers, it's important to define some properties for each user-input variables:
&lt;strong&gt;data type, data pattern, and data length&lt;/strong&gt;. A field that is a number between (x and y) must be exactly validated using the exact rule, and for a field that is a string (text): pattern is the case, for example, a username must contain only some characters, let&amp;rsquo;s say [a-zA-Z0-9_-.]. The length varies between (x and n) where x and n (integers, x &amp;lt;=n).
&lt;strong&gt;Rule: creating exact filters and validation rules are best practices for me.&lt;/strong&gt;</source>
          <target state="translated">数据过滤：在建立任何查询用户输入之前，应先对其进行验证和过滤。 对于程序员来说，为每个用户输入变量定义一些属性很重要： &lt;strong&gt;数据类型，数据模式和数据长度&lt;/strong&gt; 。 （x和y）之间的数字的字段必须使用确切的规则进行严格验证，对于字符串（文本）的字段，则必须使用模式：pattern是这种情况，例如，用户名只能包含一些字符，让我们说[a-zA-Z0-9_-。]。 长度在（x和n）之间变化，其中x和n（整数，x &amp;lt;= n）。 &lt;strong&gt;规则：创建精确的过滤器和验证规则对我来说是最佳做法。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac512b2277dc12fb253b90cadeff4b79f7f0c52d" translate="yes" xml:space="preserve">
          <source>Data validation</source>
          <target state="translated">数据验证</target>
        </trans-unit>
        <trans-unit id="bc11336395287ce262bd5113df8755daa9bf7976" translate="yes" xml:space="preserve">
          <source>Difference between UNHEX function and 0x prefix</source>
          <target state="translated">UNHEX函数与0x前缀的区别</target>
        </trans-unit>
        <trans-unit id="64fadb85f6f8e77597bc8111b879ba46ab913ae2" translate="yes" xml:space="preserve">
          <source>Don't use &lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt;. This extension is deprecated. Use &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; instead.</source>
          <target state="translated">不要使用&lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt; 。 此扩展名已弃用。 改用&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt;或&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="47070a639c03e8836d4eb1ec8798be8eba3ad73e" translate="yes" xml:space="preserve">
          <source>Don't worry about that the escaped string will have a 2x size of its original length because even if you use &lt;code&gt;mysql_real_escape_string&lt;/code&gt;, PHP has to allocate same capacity &lt;code&gt;((2*input_length)+1)&lt;/code&gt;, which is the same.</source>
          <target state="translated">不必担心转义的字符串将是其原始长度的 &lt;code&gt;((2*input_length)+1)&lt;/code&gt; ，因为即使您使用 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; ，PHP也必须分配相同的容量（（2 * input_length）+1） ，这是相同的。</target>
        </trans-unit>
        <trans-unit id="a8399b7eb2075e4b434c811aae00c5124b738ead" translate="yes" xml:space="preserve">
          <source>Escaping and SQL injection</source>
          <target state="translated">逃逸和SQL注入</target>
        </trans-unit>
        <trans-unit id="f51a89736407728dd8dad04a11c2585ad6ed1ddc" translate="yes" xml:space="preserve">
          <source>Every answer here covers only part of the problem.
In fact, there are &lt;strong&gt;four&lt;/strong&gt; different query parts which we can add to SQL dynamically: -</source>
          <target state="translated">这里的每个答案仅涵盖部分问题。 实际上，可以将&lt;strong&gt;四个&lt;/strong&gt;查询部分动态添加到SQL中：-</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="7f33f9daadca6cb0086c1f093e4291fd8f752aed" translate="yes" xml:space="preserve">
          <source>Finally you get:</source>
          <target state="translated">你终于得到了。</target>
        </trans-unit>
        <trans-unit id="203bdc584486062bd9b0a868468cf5b0c6115900" translate="yes" xml:space="preserve">
          <source>Finally, let's consider that a user sends this text below instead of entering his/her username:</source>
          <target state="translated">最后,让我们考虑一下,用户在下面发送这个文本,而不是输入他的用户名。</target>
        </trans-unit>
        <trans-unit id="4c529cebc105c5ddf809043dcd4cda22ee4366d8" translate="yes" xml:space="preserve">
          <source>For automatic escaping of values with prepared statements, use &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt;, and &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param&lt;/a&gt; where types for the corresponding bind variables must be provided for an appropriate conversion:</source>
          <target state="translated">为了使用准备好的语句自动转义值，请使用&lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt;和&lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param&lt;/a&gt; ，其中必须提供相应绑定变量的类型以进行适当的转换：</target>
        </trans-unit>
        <trans-unit id="263085c2dabdadf48b189f11fe3b9f44078570cc" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;there(1)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are(2)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still(3)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many(4)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;answers(5)&lt;/a&gt;, including the &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;second most upvoted answer&lt;/a&gt; suggesting you manual string escaping - an outdated approach that is proven to be insecure.</source>
          <target state="translated">例如， &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;There&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;（1）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;有（2）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still（3）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many（4）个&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;答案（5）&lt;/a&gt; ，其中第二个最重要的答案是建议您手动转义字符串-一种已被证明不安全的过时方法。</target>
        </trans-unit>
        <trans-unit id="dd135ed1c5cdc625f86215a3d852d0a226ec19ca" translate="yes" xml:space="preserve">
          <source>For example, if you just do something like this:</source>
          <target state="translated">比如说,如果你只是做这样的事情。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="816ab6a230a5f009a780f99ed39f9fa8ad076a2f" translate="yes" xml:space="preserve">
          <source>For manually escaping special characters in a string you can use the &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt; function. The function will not work properly unless the correct character set is set with &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset&lt;/a&gt;.</source>
          <target state="translated">要手动转义字符串中的特殊字符，可以使用&lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt;函数。 除非使用&lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset&lt;/a&gt;设置了正确的字符集，否则该功能将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="6faf52c891f9ed8efba053050f428dfa69b63649" translate="yes" xml:space="preserve">
          <source>For more information, please read &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQL Injection Prevention Cheat Sheet&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请阅读&lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQL预防注入备忘单&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d38e733b61cd3029c8e0a13aa3342ac97a1dd29" translate="yes" xml:space="preserve">
          <source>For more prevention, you can add at the end ...</source>
          <target state="translated">为了更多的预防,你可以在最后添加.....</target>
        </trans-unit>
        <trans-unit id="9b951568ae96d7b8f246820658eefa294ec054b6" translate="yes" xml:space="preserve">
          <source>For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.</source>
          <target state="translated">对于这些特殊情况,最好的办法是使用白名单过滤器来限制可能的值。</target>
        </trans-unit>
        <trans-unit id="3113d98fc6c4b79c794822624639f6af44b6df61" translate="yes" xml:space="preserve">
          <source>For those unsure of how to use PDO (coming from the &lt;code&gt;mysql_&lt;/code&gt; functions), I made a &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;very, very simple PDO wrapper&lt;/a&gt; that is a single file. It exists to show how easy it is to do all the common things applications need to be done. Works with PostgreSQL, MySQL, and SQLite.</source>
          <target state="translated">对于那些不确定如何使用PDO（来自 &lt;code&gt;mysql_&lt;/code&gt; 函数）的人，我做了一个&lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;非常非常简单的PDO包装器&lt;/a&gt; ，它是一个文件。 它的存在表明执行应用程序需要完成的所有普通操作是多么容易。 适用于PostgreSQL，MySQL和SQLite。</target>
        </trans-unit>
        <trans-unit id="31a94adfc6ded26176c675ac449c92a6685c5361" translate="yes" xml:space="preserve">
          <source>From the PHP manual, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP: Prepared Statements - Manual&lt;/a&gt;:</source>
          <target state="translated">在PHP手册中， &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP：Prepared Statements-Manual&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e5468989f2e2437840e22ffb20130112517c2fc" translate="yes" xml:space="preserve">
          <source>Hex is the perfect escape. No way to inject.</source>
          <target state="translated">Hex是完美的逃避。没有办法注入。</target>
        </trans-unit>
        <trans-unit id="1de0731dde0800e271064f5cf722c055c76cb148" translate="yes" xml:space="preserve">
          <source>Hex methods are often used as attacks</source>
          <target state="translated">六角法经常被用来作为攻击手段</target>
        </trans-unit>
        <trans-unit id="b62564667d0dfb9e44b590131236f464401bdd8b" translate="yes" xml:space="preserve">
          <source>How can I prevent SQL injection in PHP</source>
          <target state="translated">如何防止PHP中的SQL注入</target>
        </trans-unit>
        <trans-unit id="bd0deab6887a1354686773b46e00790e48d6fe0e" translate="yes" xml:space="preserve">
          <source>I created test cases for knowing how PDO and MySQLi send the query to the MySQL server when using a prepared statement:</source>
          <target state="translated">我创建了测试用例来了解PDO和MySQLi在使用准备好的语句时如何将查询发送到MySQL服务器。</target>
        </trans-unit>
        <trans-unit id="b9bbcd490604fe09b3cd1968bb6c6f7fa088e009" translate="yes" xml:space="preserve">
          <source>I favor &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;stored procedures&lt;/a&gt; (&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL has had stored procedures support since 5.0&lt;/a&gt;) from a security point of view - the advantages are -</source>
          <target state="translated">从安全的角度来看，我赞成&lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;存储过程&lt;/a&gt; （ &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL从5.0开始就支持存储过程&lt;/a&gt; ）-优点是-</target>
        </trans-unit>
        <trans-unit id="43758c0ba6ab9cf4ca9dc9ffd9fe8ff1ebfc4f99" translate="yes" xml:space="preserve">
          <source>I hope this will help you.</source>
          <target state="translated">希望对你有所帮助。</target>
        </trans-unit>
        <trans-unit id="84a0fd31784433f7ef6a00aea8326647c9561507" translate="yes" xml:space="preserve">
          <source>I suggest, using PDO is the best option.</source>
          <target state="translated">我建议,使用PDO是最好的选择。</target>
        </trans-unit>
        <trans-unit id="18aa4535a307c95c0ececdd0bfb8cd49698d9cca" translate="yes" xml:space="preserve">
          <source>I think if someone wants to use PHP and MySQL or some other dataBase server:</source>
          <target state="translated">我想如果有人想用PHP和MySQL或者其他一些dataBase服务器,。</target>
        </trans-unit>
        <trans-unit id="c95768ad26c493130f9d2b473fe6ef3eb215bddb" translate="yes" xml:space="preserve">
          <source>I think that all this because of one very old superstition, supported by such authorities like &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;the PHP manual&lt;/a&gt;, which proclaims equality between whatever &quot;escaping&quot; and protection from SQL injections.</source>
          <target state="translated">我认为所有这些都是由于一种非常古老的迷信，并得到诸如&lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt;或&lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;PHP手册之&lt;/a&gt;类的权威的支持，该权威宣称在&amp;ldquo;转义&amp;rdquo;和保护免受SQL注入之间是平等的。</target>
        </trans-unit>
        <trans-unit id="06f647de8211b09469d07c391ca6e9753993ee87" translate="yes" xml:space="preserve">
          <source>I use three different ways to prevent my web application from being vulnerable to SQL injection.</source>
          <target state="translated">我使用了三种不同的方法来防止我的Web应用程序受到SQL注入的影响。</target>
        </trans-unit>
        <trans-unit id="aa717e5dd178fdf0c4683b6d4ebda0dfe58dee0e" translate="yes" xml:space="preserve">
          <source>I was facing this issue, but I think I solved it in &lt;em&gt;very&lt;/em&gt; sophisticated way - the way hackers use to avoid using quotes. I used this in conjunction with emulated prepared statements. I use it to prevent &lt;em&gt;all&lt;/em&gt; kinds of possible SQL injection attacks.</source>
          <target state="translated">我当时面对这个问题，但我想我以&lt;em&gt;非常&lt;/em&gt;复杂的方式解决了该问题-黑客用来避免使用引号的方式。 我将其与模拟的准备好的语句结合使用。 我用它来防止各种可能的SQL注入攻击。</target>
        </trans-unit>
        <trans-unit id="e5f69a8687e8ff3c1c4991d23a6d4ef4077382ba" translate="yes" xml:space="preserve">
          <source>I would like to let you know: Why do we try for preventing SQL injection with a short example below:</source>
          <target state="translated">我想让大家知道。为什么我们要用下面这个简单的例子来防止SQL注入呢?</target>
        </trans-unit>
        <trans-unit id="eba600f8bfb98c671cd997242fbcbddc9efa69ac" translate="yes" xml:space="preserve">
          <source>I'd recommend using &lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) to run parameterized SQL queries.</source>
          <target state="translated">我建议使用&lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; （PHP数据对象）运行参数化的SQL查询。</target>
        </trans-unit>
        <trans-unit id="40c2e08dff1fe6c1375d48a2c7cea92dc8a4069b" translate="yes" xml:space="preserve">
          <source>I've written this little function several years ago:</source>
          <target state="translated">几年前,我就写过这个小功能。</target>
        </trans-unit>
        <trans-unit id="bd1f9c5fa454d3c00b06ea476a20111a54613929" translate="yes" xml:space="preserve">
          <source>If possible, cast the types of your parameters. But it's only working on simple types like int, bool, and float.</source>
          <target state="translated">如果可能的话,把你的参数的类型投给它。但它只对int、bool和float等简单的类型起作用。</target>
        </trans-unit>
        <trans-unit id="5827c6c3a2418ad354c9d261967a8450348a74c1" translate="yes" xml:space="preserve">
          <source>If the attackers are trying to hack into the form via PHP's &lt;code&gt;$_GET&lt;/code&gt; variable or with the URL's query string, you would be able to catch them if they're not secure.</source>
          <target state="translated">如果攻击者试图通过PHP的 &lt;code&gt;$_GET&lt;/code&gt; 变量或URL的查询字符串来入侵表单，则在它们不安全的情况下，您将能够捕获它们。</target>
        </trans-unit>
        <trans-unit id="e7511b2b136cd15346fc6c4ed024e6a28da03c3b" translate="yes" xml:space="preserve">
          <source>If user input is inserted without modification into an SQL query, then the application becomes vulnerable to &lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQL injection&lt;/a&gt;, like in the following example:</source>
          <target state="translated">如果将用户输入未经修改地插入到SQL查询中，则该应用程序容易受到&lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQL注入的&lt;/a&gt;攻击，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="252e57771708143a8a54033603a42c7a9528bde0" translate="yes" xml:space="preserve">
          <source>If you expect anything else from integer &lt;strong&gt;hex it&lt;/strong&gt;. If you hex it, you will perfectly escape all input. In C/C++ there's a function called &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt;&lt;code&gt;mysql_hex_string()&lt;/code&gt;&lt;/a&gt;, in PHP you can use &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt;&lt;code&gt;bin2hex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您期望整数&lt;strong&gt;十六进制&lt;/strong&gt;还有其他内容， &lt;strong&gt;则为&lt;/strong&gt; 。 如果您将其十六进制化，则可以完全避免所有输入。 在C / C ++中，有一个名为&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt; &lt;code&gt;mysql_hex_string()&lt;/code&gt; &lt;/a&gt;的函数，在PHP中，您可以使用&lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt; &lt;code&gt;bin2hex()&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0094481ec99be1c5a7d70dc70e550f643a741a7d" translate="yes" xml:space="preserve">
          <source>If you expect input to be integer make sure it's &lt;strong&gt;&lt;em&gt;really&lt;/em&gt;&lt;/strong&gt; integer. In a variable-type language like PHP it is this &lt;em&gt;very&lt;/em&gt; important. You can use for example this very simple but powerful solution: &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</source>
          <target state="translated">如果您希望输入是整数，请确保它&lt;strong&gt;&lt;em&gt;确实是&lt;/em&gt;&lt;/strong&gt;整数。 在像PHP这样的变量类型语言中，这是&lt;em&gt;非常&lt;/em&gt;重要的。 例如，您可以使用一个非常简单但功能强大的解决方案： &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="506301687174ad39af3412a5f9d9bf697ce6b22d" translate="yes" xml:space="preserve">
          <source>If you use integers from user input in a condition and take the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; approach, you will suffer from the problem described by &lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;Polynomial&lt;/a&gt; in the comments below. This case is trickier because integers would not be surrounded by quotes, so you could deal with by validating that the user input contains only digits.</source>
          <target state="translated">如果您在某种情况下使用用户输入中的整数并采用 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 方法，则将遭受以下&lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;多项式&lt;/a&gt;中描述的多项式描述的问题。 这种情况比较棘手，因为整数不会被引号引起来，因此可以通过验证用户输入仅包含数字来进行处理。</target>
        </trans-unit>
        <trans-unit id="98415529fb77c227add683c142b9927f11fa1d97" translate="yes" xml:space="preserve">
          <source>If you want to alter the structure of the SQL based on user input, parameterized queries are not going to help, and the escaping required is not covered by &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. In this kind of case, you would be better off passing the user's input through a whitelist to ensure only 'safe' values are allowed through.</source>
          <target state="translated">如果要基于用户输入更改SQL的结构，则参数化查询将无济于事，并且 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 不能涵盖所需的转义。 在这种情况下，最好将用户的输入通过白名单，以确保仅允许&amp;ldquo;安全&amp;rdquo;值通过。</target>
        </trans-unit>
        <trans-unit id="8785f3e80562fc002361ca18a095e5f516055181" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of cache engines, like &lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt;, maybe DALMP could be a choice. It uses pure &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;. Check this: &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">如果您想利用&lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt;或&lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached之&lt;/a&gt;类的缓存引擎，也许DALMP是一个选择。 它使用纯&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; 。 检查以下内容： &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;使用PHP的MySQL DALMP数据库抽象层。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a8e4204cd0dadf37e960ba81602dfdecab9d3" translate="yes" xml:space="preserve">
          <source>If you're connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (for example, &lt;code&gt;pg_prepare()&lt;/code&gt; and &lt;code&gt;pg_execute()&lt;/code&gt; for PostgreSQL). PDO is the universal option.</source>
          <target state="translated">如果要连接到MySQL以外的数据库，则可以引用特定于驱动程序的第二个选项（例如，PostgreSQL的 &lt;code&gt;pg_prepare()&lt;/code&gt; 和 &lt;code&gt;pg_execute()&lt;/code&gt; ）。 PDO是通用选项。</target>
        </trans-unit>
        <trans-unit id="d16f400a258fe645cbcf862d1cdacec8afcc86a4" translate="yes" xml:space="preserve">
          <source>If you're using a recent version of PHP, the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option outlined below will no longer be available (though &lt;code&gt;mysqli::escape_string&lt;/code&gt; is a modern equivalent). These days the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option would only make sense for legacy code on an old version of PHP.</source>
          <target state="translated">如果您使用的是最新版本的PHP，则下面概述的 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 选项将不再可用（尽管 &lt;code&gt;mysqli::escape_string&lt;/code&gt; 是现代的等效项）。 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 选项仅对旧版本PHP上的旧代码有意义。</target>
        </trans-unit>
        <trans-unit id="a87d9bb2e1e1d38953625a44a667a275d119c139" translate="yes" xml:space="preserve">
          <source>In both cases, you can't use &lt;code&gt;'&lt;/code&gt; to protect the encapsulation.</source>
          <target state="translated">在两种情况下，都不能使用 &lt;code&gt;'&lt;/code&gt; 保护封装。</target>
        </trans-unit>
        <trans-unit id="bc303fbbb40874deaf199e9d6a1fad1eae12e122" translate="yes" xml:space="preserve">
          <source>In general, such a protection approach is based on &lt;em&gt;whitelisting&lt;/em&gt;.</source>
          <target state="translated">通常，这种保护方法基于&lt;em&gt;白名单&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fca827b92ede4c4e14d63153d01c7f1f4172674" translate="yes" xml:space="preserve">
          <source>In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application's architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it's just a matter of time until you forget to correctly format your query at some point in your code.</source>
          <target state="translated">在我看来,一般来说,在你的PHP应用(或者任何Web应用,也可以说是任何Web应用)中防止SQL注入的最好方法是思考你的应用架构。如果防止SQL注入的唯一方法是记住每次与数据库对话时都要使用一个特殊的方法或函数来做The Right Thing,那么你的做法是错误的。这样的话,直到你在代码的某个时刻忘记了正确格式化你的查询,这只是时间问题。</target>
        </trans-unit>
        <trans-unit id="65b6a7572f51598d01d28ef1ca6341d368dbf0b0" translate="yes" xml:space="preserve">
          <source>In the above example the error mode isn't strictly necessary, &lt;strong&gt;but it is advised to add it&lt;/strong&gt;. This way the script will not stop with a &lt;code&gt;Fatal Error&lt;/code&gt; when something goes wrong. And it gives the developer the chance to &lt;code&gt;catch&lt;/code&gt; any error(s) which are &lt;code&gt;throw&lt;/code&gt;n as &lt;code&gt;PDOException&lt;/code&gt;s.</source>
          <target state="translated">在上面的示例中，错误模式不是严格必需的， &lt;strong&gt;但建议添加它&lt;/strong&gt; 。 这样，当出现问题时，脚本不会因 &lt;code&gt;Fatal Error&lt;/code&gt; 而停止。 并且它为开发人员提供了 &lt;code&gt;catch&lt;/code&gt; 作为 &lt;code&gt;PDOException&lt;/code&gt; &lt;code&gt;throw&lt;/code&gt; n的任何错误的机会。</target>
        </trans-unit>
        <trans-unit id="d2db286e4cb56e8b42ba950818e8b8f310b67a57" translate="yes" xml:space="preserve">
          <source>In this case, every dynamic parameter should be hardcoded in your script and chosen from that set.
For example, to do dynamic ordering:</source>
          <target state="translated">在这种情况下,每一个动态参数都应该在你的脚本中硬编码,并从该集中选择。比如说,要做动态排序。</target>
        </trans-unit>
        <trans-unit id="6b2d5fd11bcfa0af9c55f66b09eb36931b5296de" translate="yes" xml:space="preserve">
          <source>Information security</source>
          <target state="translated">信息安全</target>
        </trans-unit>
        <trans-unit id="7be8da2bc759d6b5b0023a64f7e97f8d22bcbce1" translate="yes" xml:space="preserve">
          <source>Injection prevention - &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string()&lt;/a&gt;</source>
          <target state="translated">预防注入&lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;-mysql_real_escape_string（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f5d58263c5f2019288630bda6ee4cb637fd37bd" translate="yes" xml:space="preserve">
          <source>It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is an invalid syntax.</source>
          <target state="translated">考虑到变量类型,它就会转义。如果你试图对表、列名进行参数化,它将会失败,因为它把每个字符串都加了引号,这是一个无效的语法。</target>
        </trans-unit>
        <trans-unit id="e66723c3916c6792b6e9358bbc39573f7f203093" translate="yes" xml:space="preserve">
          <source>It not only saves you from SQL injections but from syntax errors too! Also Supports collections of models with method chaining to filter or apply actions to multiple results at once and multiple connections.</source>
          <target state="translated">它不仅可以避免SQL注入,还可以避免语法错误! 同时支持模型的集合与方法链,可以一次过滤或应用到多个结果和多个连接的操作。</target>
        </trans-unit>
        <trans-unit id="f53f074e916e32d9c9de79faceea3b3a0b1b8268" translate="yes" xml:space="preserve">
          <source>It's clear that a prepared statement is also escaping the data, nothing else.</source>
          <target state="translated">很显然,准备好的报表也是在逃避数据,没有别的。</target>
        </trans-unit>
        <trans-unit id="066059abccc3bb425cd0e667ccb08532bb6fc8ca" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT&lt;/a&gt;.</source>
          <target state="translated">了解有关&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="ed0dd15ea735ebf8e4f7aefab757f8823897465c" translate="yes" xml:space="preserve">
          <source>Most databases (including &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt;) enable user access to be restricted to executing stored procedures. The fine-grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.</source>
          <target state="translated">大多数数据库（包括&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt; ）使用户访问仅限于执行存储过程。 细粒度的安全访问控制对于防止特权攻击升级很有用。 这样可以防止受感染的应用程序直接对数据库运行SQL。</target>
        </trans-unit>
        <trans-unit id="cbc26a832cdcd4282066d905ed7a05f1fdc9ed21" translate="yes" xml:space="preserve">
          <source>My approach against SQL injection is: clearing user-input data before sending it to the database (before using it inside any query).</source>
          <target state="translated">我反对SQL注入的方法是:在向数据库发送用户输入数据之前,先清除用户输入数据(在任何查询中使用之前)。</target>
        </trans-unit>
        <trans-unit id="05f8f3c79f55806a7dcfe96187c4600251c00e11" translate="yes" xml:space="preserve">
          <source>My approach:</source>
          <target state="translated">我的做法是:</target>
        </trans-unit>
        <trans-unit id="4d52e8740d9df9e1c638ac50e30925e49fcd8e33" translate="yes" xml:space="preserve">
          <source>No matter if you use prepared statements or &lt;code&gt;mysqli_real_escape_string&lt;/code&gt;, you always have to know the type of input data you're working with.</source>
          <target state="translated">无论使用预处理语句还是 &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; ，您始终必须知道要使用的输入数据的类型。</target>
        </trans-unit>
        <trans-unit id="529ff19c5e6399e4d50652370e959d26daab503b" translate="yes" xml:space="preserve">
          <source>Not only does this protect against SQL injection, but it also speeds up queries.</source>
          <target state="translated">这不仅可以防止SQL注入,还可以加快查询速度。</target>
        </trans-unit>
        <trans-unit id="ad07b10ae48ce9bcac4c0024173c1939bf2d4d50" translate="yes" xml:space="preserve">
          <source>Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. Then you can avoid the use of quotes.</source>
          <target state="translated">请注意，此十六进制方法通常用作SQL注入攻击，其中整数就像字符串一样，仅通过 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 进行转义。 这样就可以避免使用引号。</target>
        </trans-unit>
        <trans-unit id="6bd876670bffa2dedbaa4302b16a1c84ee2ebe22" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;PDO&lt;/code&gt; to access a MySQL database &lt;em&gt;real&lt;/em&gt; prepared statements are &lt;strong&gt;not used by default&lt;/strong&gt;. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using PDO is:</source>
          <target state="translated">请注意，使用 &lt;code&gt;PDO&lt;/code&gt; 访问MySQL数据库时&lt;strong&gt;，默认情况下不使用&lt;/strong&gt; &lt;em&gt;实际的&lt;/em&gt;预处理语句。 要解决此问题，您必须禁用对准备好的语句的仿真。 使用PDO创建连接的示例如下：</target>
        </trans-unit>
        <trans-unit id="0281801c06d0ce9e250fd24a61b6b6723729516b" translate="yes" xml:space="preserve">
          <source>Now, &lt;strong&gt;why you do you need to prevent your query from SQL injection?&lt;/strong&gt;</source>
          <target state="translated">现在， &lt;strong&gt;为什么需要阻止查询从SQL注入？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26d705214b3428e5682f630c8e66663452ff37b5" translate="yes" xml:space="preserve">
          <source>Now, if someone (a hacker) puts</source>
          <target state="translated">现在,如果有人(黑客)把</target>
        </trans-unit>
        <trans-unit id="66eb148a1111b249fa1c3f3a55a2330ca909715f" translate="yes" xml:space="preserve">
          <source>Now, if you are an advanced user, start using this defense as you like, but, for beginners, if they can't quickly implement a stored procedure and prepared the statement, it's better to filter input data as much they can.</source>
          <target state="translated">现在,如果你是一个高级用户,开始使用这个防御就可以了,但是,对于初学者来说,如果不能快速实现存储过程并准备好语句,还是尽量过滤输入数据为好。</target>
        </trans-unit>
        <trans-unit id="f64627235bbf5e10f0dda979a643fa08ab87651d" translate="yes" xml:space="preserve">
          <source>Now, our point is to prevent security threats such as SQL injection attacks, the question asking (how to prevent an SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? How do you secure your application?</source>
          <target state="translated">现在,我们的观点是防止SQL注入攻击等安全威胁,问的问题是(如何使用PHP防止SQL注入攻击),说得现实一点,数据过滤或清除输入数据是在使用用户输入数据的时候,使用PHP或任何其他编程语言的情况下,这样的查询是没有的,还是像更多的人建议使用现代技术如prepare statement或其他任何目前支持SQL注入预防的工具,考虑这些工具是不是已经不可用了?如何保障你的应用安全?</target>
        </trans-unit>
        <trans-unit id="a2ebdce6e2debca99f4971e3f20fb7e609a0d677" translate="yes" xml:space="preserve">
          <source>Oh, and since you asked about how to do it for an insert, here's an example (using PDO):</source>
          <target state="translated">哦,既然你问到了如何做一个插入的问题,这里有一个例子(使用PDO)。</target>
        </trans-unit>
        <trans-unit id="134949ae0b25999cca22947fe40274275ecfbf40" translate="yes" xml:space="preserve">
          <source>Option #1: Use of Prepared Statements (Parameterized Queries)</source>
          <target state="translated">选项1:使用准备好的语句(参数化查询)。</target>
        </trans-unit>
        <trans-unit id="5d2a8213d51185403db055f6aea59f59d1a24bff" translate="yes" xml:space="preserve">
          <source>Option #2: Use of Stored Procedures</source>
          <target state="translated">选项2:使用储存程序</target>
        </trans-unit>
        <trans-unit id="ca0c50b92c49801edcf1ea0388797ec4f53add0c" translate="yes" xml:space="preserve">
          <source>Option #3: Escaping all User Supplied Input</source>
          <target state="translated">选项3:逃避所有用户提供的输入。</target>
        </trans-unit>
        <trans-unit id="1b175495915b9cebd7a4f0c7b63ed399ad461fb6" translate="yes" xml:space="preserve">
          <source>Or there is a slightly better answer that suggests just &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;another method of string formatting&lt;/a&gt; and even boasts it as the ultimate panacea. While of course, it is not. This method is no better than regular string formatting, yet it keeps all its drawbacks: it is applicable to strings only and, like any other manual formatting, it's essentially optional, non-obligatory measure, prone to human error of any sort.</source>
          <target state="translated">或者有一个更好的答案，它暗示&lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;了字符串格式化的另一种方法，&lt;/a&gt;甚至声称它是最终的灵丹妙药。 当然不是。 此方法并不比常规的字符串格式好，但它保留了所有缺点：它仅适用于字符串，并且像其他任何手动格式一样，它本质上是可选的，非强制性的措施，容易出现任何类型的人为错误。</target>
        </trans-unit>
        <trans-unit id="f0ded22686c7a01e80dd23bbdd785e9739881413" translate="yes" xml:space="preserve">
          <source>PDO wins this battle with ease. With support for twelve
different database drivers and named parameters, we can ignore the
small performance loss, and get used to its API. From a security
standpoint, both of them are safe as long as the developer uses them
the way they are supposed to be used</source>
          <target state="translated">PDO轻松地赢得了这场战斗。由于支持十二种不同的数据库驱动和命名参数,我们可以忽略掉性能上的小损失,习惯了它的API。从安全的角度来看,只要开发者按照它的使用方式来使用,这两个都是安全的。</target>
        </trans-unit>
        <trans-unit id="54e0d751e792502d244f26c003fbc0168957db96" translate="yes" xml:space="preserve">
          <source>PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">PHP具有防止这些攻击的特制功能。 您需要做的就是使用一个函数 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccf9fc49cbe33f37545bdf96ec74793151180cf7" translate="yes" xml:space="preserve">
          <source>Parameterized query AND input validation is the way to go. There are many scenarios under which SQL injection may occur, even though &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; has been used.</source>
          <target state="translated">参数化查询和输入验证是必经之路。 即使使用了 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; ，在许多情况下也可能发生SQL注入。</target>
        </trans-unit>
        <trans-unit id="9efa2dbb908a0d252e5cd2661bab4bcef31b8aec" translate="yes" xml:space="preserve">
          <source>Please note that the case you asked about is a fairly simple one and that more complex cases may require more complex approaches. In particular:</source>
          <target state="translated">请注意,你所问的案例是一个相当简单的案例,更复杂的案例可能需要更复杂的方法。特别是:</target>
        </trans-unit>
        <trans-unit id="bcf57ec934b9b4abfe2e011b6d61b8f3fe9b293d" translate="yes" xml:space="preserve">
          <source>Please see this question for more detail: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same result&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">请查看此问题以获取更多详细信息： &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO将原始查询发送到MySQL，而Mysqli发送预准备的查询，两者都会产生相同的结果&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="253bf3e933bdeac3a809eb91c495e40d9d61fe9d" translate="yes" xml:space="preserve">
          <source>Primary defenses:</source>
          <target state="translated">初级防御。</target>
        </trans-unit>
        <trans-unit id="d52155a58f068ac65eaa3922fec6c4b67e140457" translate="yes" xml:space="preserve">
          <source>Query for login authentication match:</source>
          <target state="translated">查询登录认证匹配。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="058114cbca517a731cb958e54ea1701d36b6c3b4" translate="yes" xml:space="preserve">
          <source>Regarding many useful answers, I hope to add some value to this thread.</source>
          <target state="translated">关于许多有用的答案,我希望能给这一线程增添一些价值。</target>
        </trans-unit>
        <trans-unit id="e096b01f49b6da8c19f1bffa18f6d83e4dd4871e" translate="yes" xml:space="preserve">
          <source>Regardless of what PHP manual said for ages, &lt;strong&gt;&lt;code&gt;*_escape_string&lt;/code&gt; by no means makes data safe&lt;/strong&gt; and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong, because it is manual as opposite to automated.</source>
          <target state="translated">不管PHP手册使用了多&lt;strong&gt; &lt;code&gt;*_escape_string&lt;/code&gt; &lt;/strong&gt; ， &lt;strong&gt;* _ escape_string都不会使数据安全&lt;/strong&gt; ，也永远不会&lt;strong&gt;使数据安全&lt;/strong&gt; 。 除了对于字符串以外的任何SQL部分都没有用之外，手动转义是错误的，因为它与自动相反，它是手动的。</target>
        </trans-unit>
        <trans-unit id="4b26d7b5c670dfa0c5a71f99bb87ebad73afd959" translate="yes" xml:space="preserve">
          <source>SECURITY UPDATE: The previous &lt;code&gt;str_replace&lt;/code&gt; version allowed injections by adding {#} tokens into user data. This &lt;code&gt;preg_replace_callback&lt;/code&gt; version doesn't cause problems if the replacement contains these tokens.</source>
          <target state="translated">安全性更新：先前的 &lt;code&gt;str_replace&lt;/code&gt; 版本允许通过向用户数据中添加{＃}令牌来进行注入。 如果替换版本包含这些令牌，则此 &lt;code&gt;preg_replace_callback&lt;/code&gt; 版本不会引起问题。</target>
        </trans-unit>
        <trans-unit id="2248f755da0797902356c62702fce90dfe90f334" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = -1 union都从information_schema.column中选择column_name，其中table_name = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ce3741372785fc3d1b9e81dc08822e0ee3697b" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = &lt;strong&gt;-1 union all select table_name from information_schema.tables&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE ID = &lt;strong&gt;-1并全部从information_schema.tables中选择table_name&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2aaa640d6aff57cc99ee7b8f6b262da344d87124" translate="yes" xml:space="preserve">
          <source>SQL Injection</source>
          <target state="translated">SQL注入</target>
        </trans-unit>
        <trans-unit id="aaae6cc0c6e64da88ddbf398d39cff7dd8d70208" translate="yes" xml:space="preserve">
          <source>SQL Injection Cheat Sheet</source>
          <target state="translated">注入SQL的技巧表</target>
        </trans-unit>
        <trans-unit id="df8511b36a40094461c2fa8100abbe0ef28e937c" translate="yes" xml:space="preserve">
          <source>SQL injection is an attack that can be done through user inputs (inputs that filled by a user and then used inside queries). The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, and we assume that there might be a bad person that try to get secret information (bypassing access control) that affect the three principles of security (confidentiality, integrity, and availability).</source>
          <target state="translated">SQL注入是一种通过用户输入(用户填写的输入,然后在查询中使用)来进行的攻击。SQL注入的模式是正确的查询语法,而我们可以称之为:坏查询的原因是坏查询,我们假设可能有坏人试图获取秘密信息(绕过访问控制),影响安全三原则(保密性、完整性和可用性)。</target>
        </trans-unit>
        <trans-unit id="4c18831b8c7d74dba4d4cf532d188cd34482c6be" translate="yes" xml:space="preserve">
          <source>SQL user (limiting user privilege): most common SQL operations are (SELECT, UPDATE, INSERT), then, why give the UPDATE privilege to a user that does not require it? For example, &lt;strong&gt;login, and search pages&lt;/strong&gt; are only using SELECT, then, why use DB users in these pages with high privileges?</source>
          <target state="translated">SQL用户（限制用户特权）：最常见的SQL操作是（SELECT，UPDATE，INSERT），那么，为什么将UPDATE特权赋予不需要的用户呢？ 例如， &lt;strong&gt;登录和搜索页面&lt;/strong&gt;仅使用SELECT，那么，为什么在这些页面中以高特权使用DB用户？</target>
        </trans-unit>
        <trans-unit id="3c9750d49c83fa8a5b3a0075cee19045e8360352" translate="yes" xml:space="preserve">
          <source>Security Principles</source>
          <target state="translated">安全原则</target>
        </trans-unit>
        <trans-unit id="8a0ff19685c3593d2dd9348235796673a86f433d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;最低特权原则&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bc5aad5e191c67a30c0d326b34a9e4894a1fec3" translate="yes" xml:space="preserve">
          <source>See also, the details of the &lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt;&lt;code&gt;mysql_real_escape_string&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">另请参见&lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt; &lt;code&gt;mysql_real_escape_string&lt;/code&gt; &lt;/a&gt;函数的详细信息。</target>
        </trans-unit>
        <trans-unit id="be33bd1eb7dbd848bc959ced6f1d33144f31d5c8" translate="yes" xml:space="preserve">
          <source>So if you use a prepared statement, you must specify the types of the variables for &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; function.</source>
          <target state="translated">因此，如果使用准备好的语句，则必须为 &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; 函数指定变量的类型。</target>
        </trans-unit>
        <trans-unit id="7791c9096ecb3c52f38cfacf2ed5a600ac8ac03b" translate="yes" xml:space="preserve">
          <source>So, a general recommendation may be phrased as</source>
          <target state="translated">所以,一般的建议可以表述为</target>
        </trans-unit>
        <trans-unit id="5b4eb875965dcbc46634a834943ce8fb7d495d10" translate="yes" xml:space="preserve">
          <source>So, for example, the query:</source>
          <target state="translated">所以,比如说,查询。</target>
        </trans-unit>
        <trans-unit id="cfd8f629333fbfac1be3ab64cdcec4377eaa444d" translate="yes" xml:space="preserve">
          <source>So, unlike whatever &quot;escaping&quot;, prepared statements &lt;em&gt;is&lt;/em&gt; the measure that indeed protects from SQL injection (when applicable).</source>
          <target state="translated">因此，与任何&amp;ldquo;转义&amp;rdquo;不同，准备好的语句实际上是防止SQL注入的措施（适用时）。</target>
        </trans-unit>
        <trans-unit id="bdd6c788b4bc40941d92c120767a09a678ddf541" translate="yes" xml:space="preserve">
          <source>Still, there is an issue with SQL syntax keywords (such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and such), but white-listing seems the only approach in this case.</source>
          <target state="translated">但是，SQL语法关键字（例如 &lt;code&gt;AND&lt;/code&gt; ， &lt;code&gt;DESC&lt;/code&gt; 等）仍然存在问题，但是在这种情况下，白名单似乎是唯一的方法。</target>
        </trans-unit>
        <trans-unit id="25fe63edd9746e4a688d1d2796a06118495eb155" translate="yes" xml:space="preserve">
          <source>That's because the user can input something like &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt;, and the query becomes:</source>
          <target state="translated">这是因为用户可以输入类似 &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt; DROP TABLE表；- ，查询变为：</target>
        </trans-unit>
        <trans-unit id="ea6f46a1818ef256a65fd25fce4ef5438834b53d" translate="yes" xml:space="preserve">
          <source>The ** 0x** prefix can only be used for data columns such as &lt;strong&gt;char, varchar, text, block, binary, etc&lt;/strong&gt;.</source>
          <target state="translated">** 0x **前缀只能用于数据列，例如&lt;strong&gt;char，varchar，text，block，binary等&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="22493fd5585b849e0dfac158f0d91d71de2a9f53" translate="yes" xml:space="preserve">
          <source>The SQL statement you pass to &lt;code&gt;prepare&lt;/code&gt; is parsed and compiled by the database server. By specifying parameters (either a &lt;code&gt;?&lt;/code&gt; or a named parameter like &lt;code&gt;:name&lt;/code&gt; in the example above) you tell the database engine where you want to filter on. Then when you call &lt;code&gt;execute&lt;/code&gt;, the prepared statement is combined with the parameter values you specify.</source>
          <target state="translated">您 &lt;code&gt;prepare&lt;/code&gt; 传递的SQL语句由数据库服务器解析和编译。 通过指定参数（在上面的示例中为 &lt;code&gt;?&lt;/code&gt; 或诸如 &lt;code&gt;:name&lt;/code&gt; 之类的命名参数），您可以告诉数据库引擎要在何处进行过滤。 然后，当您调用 &lt;code&gt;execute&lt;/code&gt; 时 ，准备好的语句将与您指定的参数值组合在一起。</target>
        </trans-unit>
        <trans-unit id="220daddb11e24bc5b6c1d64820ad3b7f7ddb93fa" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes
  considered a security feature to prevent SQL injection. The same
  degree of security can be achieved with non-prepared statements if
  input values are escaped correctly.</source>
          <target state="translated">服务器内的值自动转义有时被认为是防止SQL注入的安全功能。如果输入值的转义正确,非准备好的语句也可以达到同样的安全程度。</target>
        </trans-unit>
        <trans-unit id="8e19049bf34dbc02fad22f1e2a94559fad21acf0" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly</source>
          <target state="translated">服务器内的值自动转义有时被认为是防止SQL注入的安全功能。如果输入值被正确地转义,非准备好的语句也可以达到同样的安全程度。</target>
        </trans-unit>
        <trans-unit id="fdf65f1abe7fe4e3d2342b41af2f1116791c2af6" translate="yes" xml:space="preserve">
          <source>The best way to prevent SQL Injection is to use &lt;strong&gt;Prepared Statements&lt;/strong&gt;&lt;em&gt;instead of escaping&lt;/em&gt;, as &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;the accepted answer&lt;/a&gt; demonstrates.</source>
          <target state="translated">如&lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;公认的答案&lt;/a&gt;所示，防止SQL注入的最佳方法是使用&lt;strong&gt;Prepared Statements&lt;/strong&gt; &lt;em&gt;而不是escaping&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc7e03df37b2e8c386abd1ebf523f1b7f2477d6" translate="yes" xml:space="preserve">
          <source>The disadvantages are -</source>
          <target state="translated">其缺点是 --</target>
        </trans-unit>
        <trans-unit id="b02e13a130f7a3159e0982874d64e46b658e4a3d" translate="yes" xml:space="preserve">
          <source>The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn't intend.</source>
          <target state="translated">这里重要的是,参数值与编译后的语句相结合,而不是SQL字符串。SQL注入的工作原理是,当脚本创建SQL发送至数据库时,欺骗脚本包含恶意字符串。因此,通过将实际的SQL与参数分开发送,你就可以限制到最终使用你不打算使用的东西的风险。</target>
        </trans-unit>
        <trans-unit id="f2ce25b2d0b72f92570aaba8ea168300f90b408b" translate="yes" xml:space="preserve">
          <source>The key function you'll want to read up on there would be &lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt;&lt;code&gt;mysqli::prepare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您将要阅读的关键功能是&lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt; &lt;code&gt;mysqli::prepare&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8329b222e736716b29e6f8c8d1bf0eb05508d581" translate="yes" xml:space="preserve">
          <source>The last point is detecting unexpected behavior which requires more effort and complexity; it's not recommended for normal web applications.</source>
          <target state="translated">最后一点是检测意外行为,这需要更多的精力和复杂度;对于普通的Web应用,不建议使用。</target>
        </trans-unit>
        <trans-unit id="ec2ec032df8d4e54047d67def864e600f72c7368" translate="yes" xml:space="preserve">
          <source>The most advanced way is to use PDOs.</source>
          <target state="translated">最先进的方法是使用PDO。</target>
        </trans-unit>
        <trans-unit id="77a019a8e37c861117253efcafbe8b46c80d55cb" translate="yes" xml:space="preserve">
          <source>The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to log in as administrator without having his/her password. Now, he/she can do anything that the administrator/email person can do. See, it's very dangerous if SQL injection is not prevented.</source>
          <target state="translated">另一部分将被丢弃。那么,会发生什么?一个非授权用户(黑客)将可以在没有他的密码的情况下,以管理员的身份登录。现在,他可以做任何管理员能做的事情。你看,如果不防止SQL注入,那是非常危险的。</target>
        </trans-unit>
        <trans-unit id="caef473bbc5d786e58c45a04c732b8e95dae8488" translate="yes" xml:space="preserve">
          <source>The query will be parsed into the system only up to:</source>
          <target state="translated">查询将被解析到系统中,只有到。</target>
        </trans-unit>
        <trans-unit id="0600942d37431f06a2041faca7c57369364ca714" translate="yes" xml:space="preserve">
          <source>The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.
For example: if you are using a MySQL database then enter into the database through terminal or the UI provided and just follow this command:</source>
          <target state="translated">这个问题的简单替代方案可以通过在数据库本身授予适当的权限来解决。例如:如果你使用的是MySQL数据库,那么通过终端或提供的用户界面进入数据库,然后按照这个命令操作即可。</target>
        </trans-unit>
        <trans-unit id="49869c7c4ee5782157501a3f5be9f08cda113757" translate="yes" xml:space="preserve">
          <source>There are libraries such as &lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt; and &lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt; that allow developers to use prepared statements easier. To learn more about why prepared statements are better at &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;stopping SQL injection&lt;/a&gt;, refer to &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;this &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; bypass&lt;/a&gt; and &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;recently fixed Unicode SQL Injection vulnerabilities in WordPress&lt;/a&gt;.</source>
          <target state="translated">有一些库，例如&lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt;和&lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt; ，使开发人员可以更轻松地使用准备好的语句。 要了解更多有关为何准备好的语句更好地&lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;停止SQL注入的信息&lt;/a&gt; ，请参考&lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt; &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 旁路&lt;/a&gt;和&lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;最近在WordPress中修复的Unicode SQL注入漏洞&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c789aef75c0a5b094c0f29903ad99459e880351c" translate="yes" xml:space="preserve">
          <source>There are likely other cases I'm not aware of. You might find &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;this&lt;/a&gt; is a useful resource on some of the more subtle problems you can encounter.</source>
          <target state="translated">可能还有其他我不知道的情况。 您可能会发现&lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;这&lt;/a&gt;是一些有用的资源，可解决您可能遇到的一些更细微的问题。</target>
        </trans-unit>
        <trans-unit id="780ecc400391203ddd8ddd799d6ab422887cada5" translate="yes" xml:space="preserve">
          <source>There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course &lt;strong&gt;PDO is one of the good solutions.&lt;/strong&gt; But I would like to suggest you some good links prevention from SQL injection.</source>
          <target state="translated">有很多方法可以防止SQL注入和其他SQL hack。 您可以在Internet（Google搜索）上轻松找到它。 当然， &lt;strong&gt;PDO是很好的解决方案之一。&lt;/strong&gt; 但我想向您建议一些防止SQL注入的链接。</target>
        </trans-unit>
        <trans-unit id="218c170e6057412489f970c39cfe283ca621a4f8" translate="yes" xml:space="preserve">
          <source>There are more abilities to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also, it would be better to use these functions to check input data.</source>
          <target state="translated">有更多的能力来防止这种情况的发生:比如识别--如果输入是字符串、数字、char或数组,有这么多的内置函数来检测。另外,最好是用这些函数来检查输入数据。</target>
        </trans-unit>
        <trans-unit id="830b53ae56caf2de4b110b5e5e28b176692222da" translate="yes" xml:space="preserve">
          <source>There are so many answers for &lt;strong&gt;PHP and MySQL&lt;/strong&gt;, but here is code for &lt;strong&gt;PHP and Oracle&lt;/strong&gt; for preventing SQL injection as well as regular use of oci8 drivers:</source>
          <target state="translated">&lt;strong&gt;PHP和MySQL&lt;/strong&gt;有很多答案，但是这里有&lt;strong&gt;PHP和Oracle的&lt;/strong&gt;代码用于防止SQL注入以及oci8驱动程序的常规使用：</target>
        </trans-unit>
        <trans-unit id="df8b9e7a092d7b299097fd0d02efb87caa3a7f13" translate="yes" xml:space="preserve">
          <source>There is another way to secure identifiers - escaping but I rather stick to whitelisting as a more robust and explicit approach. Yet as long as you have an identifier quoted, you can escape the quote character to make it safe. For example, by default for mysql you have to &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;double the quote character to escape it&lt;/a&gt;. For other other DBMS escaping rules would be different.</source>
          <target state="translated">还有另一种保护标识符的方法-转义，但我宁愿坚持将白名单作为一种更健壮和明确的方法。 但是，只要您带引号的标识符，就可以转义引号字符以使其安全。 例如，默认情况下，对于mysql，您必须&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;将引号字符加倍以对其进行转义&lt;/a&gt; 。 对于其他其他DBMS，转义规则将有所不同。</target>
        </trans-unit>
        <trans-unit id="f884dfef89c26e94f34c8d0d17a3e45bfbc8acd8" translate="yes" xml:space="preserve">
          <source>There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:</source>
          <target state="translated">评论里有一些讨论,所以我最后想说清楚。这两种方法很相似,但在某些方面又有一点不同。</target>
        </trans-unit>
        <trans-unit id="224c361000365c82c6c9b9f7d7a6ec856e58482b" translate="yes" xml:space="preserve">
          <source>Therefore, this proves that data validation such as &lt;code&gt;intval()&lt;/code&gt; is a good idea for integer values before sending any query. In addition, preventing malicious user data before sending the query is &lt;strong&gt;a correct and valid approach&lt;/strong&gt;.</source>
          <target state="translated">因此，这证明在发送任何查询之前，诸如 &lt;code&gt;intval()&lt;/code&gt; 之类的数据验证是整数值的好主意。 另外，在发送查询之前防止恶意用户数据是&lt;strong&gt;正确有效的方法&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="82972fc3059a1c85c5e906a0ee53efee54cb0064" translate="yes" xml:space="preserve">
          <source>They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.</source>
          <target state="translated">它们(存储过程)很难维护,而且往往会迅速增加。这使得管理它们成为一个问题。</target>
        </trans-unit>
        <trans-unit id="9db87902986489638b3a9991da4a7a39a2f10d0c" translate="yes" xml:space="preserve">
          <source>They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.</source>
          <target state="translated">它们将原始的SQL查询从应用程序中抽象出来,因此应用程序可以获得的数据库结构信息较少。这使得人们更难理解数据库的底层结构,设计出合适的攻击方式。</target>
        </trans-unit>
        <trans-unit id="63f9a45d5192235d9d02af20e18d0355ff4d3bbe" translate="yes" xml:space="preserve">
          <source>They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.</source>
          <target state="translated">它们只接受参数,所以参数化查询的优势是存在的。当然-IMO你仍然需要对你的输入进行消毒处理-特别是当你在存储过程中使用动态SQL的时候。</target>
        </trans-unit>
        <trans-unit id="da88560285c94420f786914a9987bc73dbdb490a" translate="yes" xml:space="preserve">
          <source>They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.</source>
          <target state="translated">它们并不是很适合动态查询---如果它们是为了接受动态代码作为参数而构建的,那么很多优势就被否定了。</target>
        </trans-unit>
        <trans-unit id="a718b71211da4fde3996aa73a97cdfec744e2e31" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;</source>
          <target state="translated">考虑学习&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bc28bb81fa5e19dbc4f90b70f46fd3864b30aac" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) &amp;ndash; it is a database access layer providing a uniform method of access to multiple databases.</source>
          <target state="translated">考虑学习&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; （PHP数据对象）&amp;ndash;它是数据库访问层，提供访问多个数据库的统一方法。</target>
        </trans-unit>
        <trans-unit id="b269ba0fd879f3932b2b527ca85caeb00cf5ba6e" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;question&lt;/a&gt; has some good answers about this.</source>
          <target state="translated">这个&lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;问题&lt;/a&gt;对此有一些很好的答案。</target>
        </trans-unit>
        <trans-unit id="92ad37abc91646ccd8977cbbc7608b0efd79be0e" translate="yes" xml:space="preserve">
          <source>This allows running statements in an one-liner C#-ish String.Format like:</source>
          <target state="translated">这样就可以在单行的C#类似String.Format的String.Format中运行语句。</target>
        </trans-unit>
        <trans-unit id="d422b5f7b27e73794ff7c5132ab85405bcfe5b91" translate="yes" xml:space="preserve">
          <source>This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with &lt;code&gt;0x&lt;/code&gt; or use the MySQL function &lt;code&gt;UNHEX&lt;/code&gt; instead.</source>
          <target state="translated">当您传输二进制数据时，经常使用此十六进制方法，但是我认为没有理由不对所有数据使用它来防止SQL注入攻击。 请注意，您必须在数据前添加 &lt;code&gt;0x&lt;/code&gt; 或使用MySQL函数 &lt;code&gt;UNHEX&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="10c3b317d4690df3f686ef3a89e96ef8591796f2" translate="yes" xml:space="preserve">
          <source>This input can be checked early without any prepared statement and stored procedures, but to be on the safe side, using them starts after user-data filtering and validation.</source>
          <target state="translated">这种输入可以在没有任何准备好的语句和存储过程的情况下提前检查,但为了安全起见,在用户数据过滤和验证后开始使用它们。</target>
        </trans-unit>
        <trans-unit id="93f5c7f0ce17d7d18825ad4c94168610dc65618a" translate="yes" xml:space="preserve">
          <source>This will restrict the user to only get confined with the specified query's only. Remove the delete permission and so the data would never get deleted from the query fired from the PHP page.
The second thing to do is to flush the privileges so that the MySQL refreshes the permissions and updates.</source>
          <target state="translated">这将限制用户只能被限制在指定的查询中。移除删除权限,所以数据永远不会从PHP页面中的查询中被删除。第二件事就是刷新权限,这样MySQL会刷新权限并更新。</target>
        </trans-unit>
        <trans-unit id="fff7386dc03b73f854a16a474ef2b8c2fda58dc3" translate="yes" xml:space="preserve">
          <source>This won't solve every problem, but it's a very good stepping stone. I left out obvious items such as checking the variable's existence, format (numbers, letters, etc.).</source>
          <target state="translated">这不会解决所有问题,但这是个很好的垫脚石。我省略了一些明显的项目,比如检查变量的存在、格式(数字、字母等)。</target>
        </trans-unit>
        <trans-unit id="16c9cc86f82e3a7c1ca1d9b3739a49f6e61d2e8e" translate="yes" xml:space="preserve">
          <source>Those examples are vulnerable to SQL injection:</source>
          <target state="translated">这些例子很容易被SQL注入。</target>
        </trans-unit>
        <trans-unit id="8789487a1a2a5eb11f2a7cfa438ec136c375dc71" translate="yes" xml:space="preserve">
          <source>To ease the process I wrote a &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;whitelist helper function&lt;/a&gt; that does all the job in one line:</source>
          <target state="translated">为了简化此过程，我编写了一个&lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;白名单帮助程序函数&lt;/a&gt; ，该函数可以在一行中完成所有工作：</target>
        </trans-unit>
        <trans-unit id="fa14c04c76de2e2fab6840f10e0b4d476494ed7a" translate="yes" xml:space="preserve">
          <source>To see the current privileges for the user fire the following query.</source>
          <target state="translated">要查看该用户的当前权限,启动以下查询。</target>
        </trans-unit>
        <trans-unit id="b6cd0f951a947782e4aa09afbcf7e67bd3612b70" translate="yes" xml:space="preserve">
          <source>To use the parameterized query, you need to use &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; rather than the &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt; functions. To rewrite your example, we would need something like the following.</source>
          <target state="translated">要使用参数化查询，您需要使用&lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt;而不是&lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt;函数。 要重写您的示例，我们将需要以下内容。</target>
        </trans-unit>
        <trans-unit id="92ea56f2bcd611121ebf82d1bb94be8a12add9bd" translate="yes" xml:space="preserve">
          <source>UPDATE 1:</source>
          <target state="translated">更新1:</target>
        </trans-unit>
        <trans-unit id="f1e7ccfb017f1e9286a26f4401498e961fa8566b" translate="yes" xml:space="preserve">
          <source>Unexpected behavior in the above user input is SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, and root. Once these words detected, you can avoid the input.</source>
          <target state="translated">在上述用户输入中出现的意外行为是SELECT、UNION、IF、SUBSTRING、BENCHMARK、SHA和根。一旦检测到这些词,就可以避免输入。</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="58b2e2813f252bd73c0a240fc752d08e7de81f2b" translate="yes" xml:space="preserve">
          <source>Update 2:</source>
          <target state="translated">更新2:</target>
        </trans-unit>
        <trans-unit id="ab598eb253cb41b46f92f26312a455cadea5aee1" translate="yes" xml:space="preserve">
          <source>Update 3:</source>
          <target state="translated">更新3:</target>
        </trans-unit>
        <trans-unit id="a097c6d2f311ec0bb34ee1571b93398b7da217e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;PDO&lt;/code&gt; and prepared queries.</source>
          <target state="translated">使用 &lt;code&gt;PDO&lt;/code&gt; 和准备好的查询。</target>
        </trans-unit>
        <trans-unit id="536e4e3355286cdf5ee35d48911488b38952ca82" translate="yes" xml:space="preserve">
          <source>Use native PHP functions like: &lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt;, &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string&lt;/a&gt; or if variable numeric, just &lt;code&gt;(int)$foo&lt;/code&gt;. Read more about type of variables in PHP &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;here&lt;/a&gt;. If you're using libraries such as PDO or MySQLi, always use &lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO::quote()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string()&lt;/a&gt;.</source>
          <target state="translated">使用本机PHP函数，例如： &lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt; ， &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string，&lt;/a&gt;或者如果变量数值为 &lt;code&gt;(int)$foo&lt;/code&gt; 。 在&lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;此处&lt;/a&gt;阅读有关PHP中变量类型的更多信息。 如果您使用的是PDO或MySQLi之类的库，请始终使用&lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO :: quote（）&lt;/a&gt;和&lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string（）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="d38f5f0dc278ebfe3743f0e9d9ad122b9d88ce8f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;, which is a pre-defined function in &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;, and this code add backslashes to the following characters: &lt;code&gt;\x00&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\x1a&lt;/code&gt;. Pass the input values as parameters to minimize the chance of SQL injection.</source>
          <target state="translated">使用 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; （这是&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP中&lt;/a&gt;的预定义函数），此代码将反斜杠添加到以下字符： &lt;code&gt;\x00&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; ， &lt;code&gt;\r&lt;/code&gt; ， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;'&lt;/code&gt; ， &lt;code&gt;&quot;&lt;/code&gt; 和 &lt;code&gt;\x1a&lt;/code&gt; 。将输入值作为参数传递以最大程度地减少SQL注入的机会。</target>
        </trans-unit>
        <trans-unit id="56d170f163928a8c1fff4954924527fa155e8ca3" translate="yes" xml:space="preserve">
          <source>Use other tools: Here, I will also agree with you that a prepared statement (parametrized query) and stored procedures. The disadvantages here is these ways require advanced skills which do not exist for most users. The basic idea here is to distinguish between the SQL query and the data that is used inside. Both approaches can be used even with unsafe data, because the user-input data here does not add anything to the original query, such as (any or x=x).</source>
          <target state="translated">使用其他工具。在这里,我也同意你的观点,准备好的语句(参数化查询)和存储过程。这里的缺点是这些方式需要高级技能,而这些技能对于大多数用户来说是不存在的。这里的基本思路是区分SQL查询和里面使用的数据。这两种方法即使是不安全的数据也可以使用,因为这里的用户输入的数据并没有给原来的查询增加任何东西,比如(any或x=x)。</target>
        </trans-unit>
        <trans-unit id="2ab1b2c4d270d99ef373efcd0f8b8574c802370d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt; is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to use</source>
          <target state="translated">使用&lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt;和&lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt;是防止SQL注入的好方法，但是如果您真的想使用MySQL函数和查询，则最好使用</target>
        </trans-unit>
        <trans-unit id="38c0c660c5df9571196ca554badedbf16ace904b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; (for MySQL):</source>
          <target state="translated">使用&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; （对于MySQL）：</target>
        </trans-unit>
        <trans-unit id="a4e7bd1b02d3303b9bd6d557965df01c324c3557" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (for any supported database driver):</source>
          <target state="translated">使用&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; （对于任何受支持的数据库驱动程序）：</target>
        </trans-unit>
        <trans-unit id="64fd160974da8c9008dad32fa19315d8009920f4" translate="yes" xml:space="preserve">
          <source>Using this PHP function &lt;code&gt;mysql_escape_string()&lt;/code&gt; you can get a good prevention in a fast way.</source>
          <target state="translated">使用此PHP函数 &lt;code&gt;mysql_escape_string()&lt;/code&gt; 可以快速获得良好的预防。</target>
        </trans-unit>
        <trans-unit id="0d3a08ce38eb2066c704c7481d4b7d5c8f7699f5" translate="yes" xml:space="preserve">
          <source>We'll cover the lower impact string escaping one first.</source>
          <target state="translated">我们先来说说下冲击力较低的字符串逃过一劫。</target>
        </trans-unit>
        <trans-unit id="b0ca7362248cae31401c4742155c18ebaa5ff23d" translate="yes" xml:space="preserve">
          <source>What can be done to prevent this from happening?</source>
          <target state="translated">如何才能避免这种情况的发生?</target>
        </trans-unit>
        <trans-unit id="4ec900e30a04771ad57031ac632ba224fe5ec06c" translate="yes" xml:space="preserve">
          <source>What is &lt;strong&gt;mandatory&lt;/strong&gt;, however, is the first &lt;code&gt;setAttribute()&lt;/code&gt; line, which tells PDO to disable emulated prepared statements and use &lt;em&gt;real&lt;/em&gt; prepared statements. This makes sure the statement and the values aren't parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).</source>
          <target state="translated">但是， &lt;strong&gt;强制性的&lt;/strong&gt;是第一行 &lt;code&gt;setAttribute()&lt;/code&gt; ，它告诉PDO禁用模拟的准备好的语句并使用&lt;em&gt;实际的&lt;/em&gt;准备好的语句。 这可以确保在将语句和值发送到MySQL服务器之前，不会对PHP进行解析（这使可能的攻击者没有机会注入恶意SQL）。</target>
        </trans-unit>
        <trans-unit id="4a061bb9449a7869b1bb6c140f6c244c24e19160" translate="yes" xml:space="preserve">
          <source>Whatever you do end up using, make sure that you check your input hasn't already been mangled by &lt;code&gt;magic_quotes&lt;/code&gt; or some other well-meaning rubbish, and if necessary, run it through &lt;code&gt;stripslashes&lt;/code&gt; or whatever to sanitize it.</source>
          <target state="translated">无论您最终使用什么，请确保您没有检查输入内容是否已被 &lt;code&gt;magic_quotes&lt;/code&gt; 或其他一些好听的垃圾弄乱了，如果有必要，请通过 &lt;code&gt;stripslashes&lt;/code&gt; 或其他方式对其进行清理。</target>
        </trans-unit>
        <trans-unit id="00f02bbdebbfdbc228c8163a6409202a17282e4d" translate="yes" xml:space="preserve">
          <source>While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.</source>
          <target state="translated">虽然仍然可以使用准备好的语句进行查询参数,但动态查询本身的结构不能被参数化,某些查询功能也不能被参数化。</target>
        </trans-unit>
        <trans-unit id="1ac6d9646522fe48ad32b3fffb2a4692cff0ee0f" translate="yes" xml:space="preserve">
          <source>Will become:</source>
          <target state="translated">将成为。</target>
        </trans-unit>
        <trans-unit id="204b32dc579f45400949999976e4e7bd02995817" translate="yes" xml:space="preserve">
          <source>You basically have two options to achieve this:</source>
          <target state="translated">你基本上有两个选择来实现这个目标。</target>
        </trans-unit>
        <trans-unit id="ec00a1df9d6128980fc27b80f095461babcb7153" translate="yes" xml:space="preserve">
          <source>You can find more details in &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL - SQL Injection Prevention&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">您可以在&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL-SQL注入预防中&lt;/a&gt;&lt;/em&gt;找到更多详细信息。</target>
        </trans-unit>
        <trans-unit id="b865044a62cd48efbfda9b53b850310ecec07a85" translate="yes" xml:space="preserve">
          <source>You could do something basic like this:</source>
          <target state="translated">你可以做一些像这样基本的事情。</target>
        </trans-unit>
        <trans-unit id="0cff3e61f8aade5ced706b23961eeb5d59ba96ea" translate="yes" xml:space="preserve">
          <source>You've got two options - escaping the special characters in your &lt;code&gt;unsafe_variable&lt;/code&gt;, or using a parameterized query. Both would protect you from SQL injection. The parameterized query is considered the better practice but will require changing to a newer MySQL extension in PHP before you can use it.</source>
          <target state="translated">您有两个选择-在 &lt;code&gt;unsafe_variable&lt;/code&gt; 中转义特殊字符，或使用参数化查询。 两者都可以保护您免受SQL注入的侵害。 参数化查询被认为是更好的做法，但是在使用它之前，需要先在PHP中更改为更新的MySQL扩展。</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">若干</target>
        </trans-unit>
        <trans-unit id="555d01e6c83266b3e9f92bd811905370caf62770" translate="yes" xml:space="preserve">
          <source>a string</source>
          <target state="translated">一串</target>
        </trans-unit>
        <trans-unit id="5bb5bc166d482477e7f41c8996346a70df7264aa" translate="yes" xml:space="preserve">
          <source>a syntax keyword</source>
          <target state="translated">句法关键词</target>
        </trans-unit>
        <trans-unit id="415dd55dd005527a8b6d386ea933f1cb842449b8" translate="yes" xml:space="preserve">
          <source>an attack can inject you very &lt;em&gt;easily&lt;/em&gt;. Consider the following injected code returned from your script:</source>
          <target state="translated">攻击可以很&lt;em&gt;容易&lt;/em&gt;注入你的&lt;em&gt;精力&lt;/em&gt; 。 考虑从脚本返回的以下注入代码：</target>
        </trans-unit>
        <trans-unit id="eb4952e764d7c270f5b65eab412865f0e3d1e28d" translate="yes" xml:space="preserve">
          <source>an identifier</source>
          <target state="translated">识别器</target>
        </trans-unit>
        <trans-unit id="e371325eaf8cf1513b8fb5c935edacb07019dc53" translate="yes" xml:space="preserve">
          <source>and now just extract table structure:</source>
          <target state="translated">而现在只是提取表结构。</target>
        </trans-unit>
        <trans-unit id="00a568b3ade5326f00d2f75efc890a8fa7d228a0" translate="yes" xml:space="preserve">
          <source>and password anything....</source>
          <target state="translated">和密码什么的......</target>
        </trans-unit>
        <trans-unit id="dcdc68162ecd47207ad2d4500cb7f65ba1b2f599" translate="yes" xml:space="preserve">
          <source>is_numeric</source>
          <target state="translated">is_numeric</target>
        </trans-unit>
        <trans-unit id="b32f9e192cce5e6c514823660d6fc173cb3dd500" translate="yes" xml:space="preserve">
          <source>is_string</source>
          <target state="translated">is_string</target>
        </trans-unit>
        <trans-unit id="77064c82097c6f5dee58b4d6d530b90e598c4da1" translate="yes" xml:space="preserve">
          <source>more information about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;flush&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;冲洗的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="71d20c07a9f068a85df7519fb5b1a4e4eecf531f" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string</source>
          <target state="translated">mysql_real_escape_string</target>
        </trans-unit>
        <trans-unit id="6ccd64ba549314b5da86aaa89a6184349dcc2710" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string() will not protect here. If you use single quotes (' ') around your variables inside your query is what protects you against this. Here is an solution below for this:</source>
          <target state="translated">mysql_real_escape_string()在这里不会保护。如果你在你的查询中使用单引号(''')周围的变量是保护你免受这个问题。下面是一个解决这个问题的方法。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
