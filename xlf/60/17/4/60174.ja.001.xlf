<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/60174">
    <body>
      <group id="60174">
        <trans-unit id="28db4e540747091b7a00b15b115a95e87c6fb18f" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;$conn&lt;/code&gt; is a &lt;code&gt;PDO&lt;/code&gt; object)</source>
          <target state="translated">（ &lt;code&gt;$conn&lt;/code&gt; は &lt;code&gt;PDO&lt;/code&gt; オブジェクトです）</target>
        </trans-unit>
        <trans-unit id="7df4be97ec047ed1a29912298ea3b0fcbc7ed380" translate="yes" xml:space="preserve">
          <source>--- &lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">--- &lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="566ea8d89155c02c58ff63984dcd175883a55e5f" translate="yes" xml:space="preserve">
          <source>---- &lt;strong&gt;PDO&lt;/strong&gt;</source>
          <target state="translated">---- &lt;strong&gt;PDO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="16d6eec24d215237193fd125401ea3f72038ce7c" translate="yes" xml:space="preserve">
          <source>----- Named placeholders</source>
          <target state="translated">-----名前付きプレースホルダ</target>
        </trans-unit>
        <trans-unit id="6f87ec96d5b86996a40f5259f92fc7fad65ced43" translate="yes" xml:space="preserve">
          <source>----- No placeholders - ripe for SQL injection! &lt;strong&gt;It's bad&lt;/strong&gt;</source>
          <target state="translated">-----プレースホルダーはありません-SQLインジェクションの準備ができています！ &lt;strong&gt;悪いです&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcff74f12914fdb8c051ea2e336776fd176f90" translate="yes" xml:space="preserve">
          <source>----- Unnamed placeholders</source>
          <target state="translated">-----名前のないプレースホルダ</target>
        </trans-unit>
        <trans-unit id="c8f539c5cc020994d7d2752bb0266689882010b0" translate="yes" xml:space="preserve">
          <source>// Connect to MySQL</source>
          <target state="translated">/MySQLに接続する</target>
        </trans-unit>
        <trans-unit id="210d7dde35cddea92280995918b6bfd938945cd2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;Source&lt;/a&gt;: &lt;em&gt;The Unexpected SQL Injection (When Escaping Is Not Enough)&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;ソース&lt;/a&gt; ： &lt;em&gt;予期しないSQLインジェクション（エスケープでは不十分）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fafbba6ac674ca8233b3bb137474220f54670c01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash; Escapes a string for use in a mysql_query</source>
          <target state="translated">&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash; mysql_queryで使用するために文字列をエスケープする</target>
        </trans-unit>
        <trans-unit id="2acf2cfec503ef763160d951705f3dcc3dbb00be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; is deprecated as of PHP 5.5.0. Use either mysqli or PDO.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; は、PHP 5.5.0以降では非推奨です。 mysqliまたはPDOを使用します。</target>
        </trans-unit>
        <trans-unit id="ac2812cda025d0222eb136ebe05af667375a9255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string&lt;/code&gt; takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(') a user might enter with a MySQL-safe substitute, an escaped quote \'.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string&lt;/code&gt; は、MySQLクエリで使用される文字列を取り、すべてのSQLインジェクション試行が安全にエスケープされた同じ文字列を返します。 基本的に、ユーザーが入力する可能性のある厄介な引用符（ '）を、MySQLセーフな代替であるエスケープされた引用\'に置き換えます。</target>
        </trans-unit>
        <trans-unit id="993cce94e6973d25742799e350d687c6d47eb565" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;What is SQL injection and how to prevent&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;SQLインジェクションとは何か、およびその防止方法&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eedc1ef7aa89311e0fab1b48d2dbf4f551aa710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;Microsoft explanation of SQL injection and prevention in PHP&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;PHPでのSQLインジェクションと防止に関するMicrosoftの説明&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09a2090f97db4e53860ae5ab475445cb9ea655d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;PHP manual for SQL injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;SQLインジェクションのPHPマニュアル&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b6995e63bfc6f9fa8ec35b4a707089f01068f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And please test every query to your database - it's a better way to prevent injection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;そして、データベースへのすべてのクエリをテストしてください-インジェクションを防ぐためのより良い方法です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="881c07549030945c2309cee9e2e2ac2c9261312f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data filtering for (converting unsafe data to safe data)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;データのフィルタリング（安全でないデータを安全なデータに変換）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b74390d8460cdf00400fa1ae06a8df3cec12865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;
  This answer's sample code (like the question's sample code) uses PHP's &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.</source>
          <target state="translated">&lt;strong&gt;非推奨の警告：&lt;/strong&gt;この回答のサンプルコード（質問のサンプルコードと同様）は、PHP 5.5.0で非推奨となり、PHP 7.0.0で完全に削除されたPHPの &lt;code&gt;MySQL&lt;/code&gt; 拡張を使用します。</target>
        </trans-unit>
        <trans-unit id="1051e53e86d6b39bb445cb5e011266551db0339e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning&lt;/strong&gt;: The mysql extension is deprecated at this time. we recommend using the &lt;em&gt;PDO extension&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;非推奨の警告&lt;/strong&gt; ：mysql拡張は現在非推奨です。 &lt;em&gt;PDO拡張機能の&lt;/em&gt;使用をお勧めします</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dda06a174f7dd5e74c8eabf80656879e8b1f296" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single column&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;単一の列が欲しい&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80c1cc3b7b50e8fd2aea1b4ca0b3b75408434e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single row result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;単一行の結果が欲しい&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="024c9614f439c4a7911a75baa6232c91c34e16cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array of results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;結果の配列が欲しい&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4dc6dc4cb39edde6e4cb977be5a4e00bfee01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array(key =&amp;gt; value) results (i.e. for making a selectbox)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;配列（キー=&amp;gt;値）の結果（つまり、selectboxを作成するため）が欲しい&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8052e9a559828f926aaf4cb0e3c1b2ca31046e95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IMPORTANT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cde4be58e6e2d465148f3e98b5727244f7a72453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ライブラリの例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e446408dbdb6997b7424912b8c1d79a1c5ab993b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23d6bf55f17ae053d22c5b227546c45610ff250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c585f3da07abdc2dcc052b0a31c75b51345fff8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; you must be connected to the database to use this function!</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この機能を使用するには、データベースに接続している必要があります。</target>
        </trans-unit>
        <trans-unit id="a67dc084aafad94a19d93929a672c4d8c26d1f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;P.S&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b10a86d4bbe9f0b1901a8bde6b52d5685220b62b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PDO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PDO:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3a71e18b47cb4549c122f88532d562818113692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Query Log:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クエリログ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b772547fb5634e5dbe11cab975563db5faff2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RULE: do not create one database user for all privileges. For all SQL operations, you can create your scheme like (deluser, selectuser, updateuser) as usernames for easy usage.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ルール：すべての権限に対して1人のデータベースユーザーを作成しないでください。&lt;/strong&gt; &lt;strong&gt;すべてのSQL操作で、ユーザー名として（deluser、selectuser、updateuser）のようなスキームを作成して、簡単に使用できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e3668d2a13faa5a6d222104bab0c82a2d2b1525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)</source>
          <target state="translated">&lt;strong&gt;セキュリティ警告&lt;/strong&gt; ：この回答は、セキュリティのベストプラクティスと一致していません。 &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;エスケープはSQLインジェクションを防ぐには不十分&lt;/a&gt;です。代わりに&lt;em&gt;準備されたステートメント&lt;/em&gt;を使用&lt;em&gt;してください&lt;/em&gt; 。 以下に概説する戦略は、自己責任で使用してください。 （また、 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; はPHP 7で削除されました。）</target>
        </trans-unit>
        <trans-unit id="69b9b6580cb9915e7a2d71a41230225b3ca5ffb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UNHEX()&lt;/strong&gt; works on &lt;strong&gt;any&lt;/strong&gt; column; you do not have to worry about the empty string.</source>
          <target state="translated">&lt;strong&gt;UNHEX（）&lt;/strong&gt;は&lt;strong&gt;任意の&lt;/strong&gt;列で機能します。 空の文字列を気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="e7d6310b11ad04ede1d86386dd85ffa2b6b00627" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use prepared statements and parameterized queries.&lt;/strong&gt; These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.</source>
          <target state="translated">&lt;strong&gt;準備されたステートメントとパラメーター化されたクエリを使用します。&lt;/strong&gt; これらは、データベースサーバーに送信され、パラメーターとは別にデータベースサーバーによって解析されるSQLステートメントです。 このように、攻撃者が悪意のあるSQLを挿入することは不可能です。</target>
        </trans-unit>
        <trans-unit id="4b66375073c94d88e7cae14419ae8276f33a993c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning: the approach described in this answer only applies to very specific scenarios and isn't secure since SQL injection attacks do not only rely on being able to inject &lt;code&gt;X=Y&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;警告：この回答で説明されているアプローチは非常に特定のシナリオにのみ適用され、安全ではありません。SQLインジェクション攻撃は &lt;code&gt;X=Y&lt;/code&gt; をインジェクトでき​​ることに依存しているだけではないためです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="167a410708537f3843a1e61a18f3cd510d6bcd35" translate="yes" xml:space="preserve">
          <source>A few guidelines for escaping special characters in SQL statements.</source>
          <target state="translated">SQL文で特殊文字をエスケープするためのいくつかのガイドライン。</target>
        </trans-unit>
        <trans-unit id="260ac50ca6144215fd0045d1af48ccfa01e745f8" translate="yes" xml:space="preserve">
          <source>A good idea is to use an &lt;strong&gt;'object-relational mapper'&lt;/strong&gt; like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt; &lt;strong&gt;の&lt;/strong&gt;ような&lt;strong&gt;「オブジェクトリレーショナルマッパー」&lt;/strong&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1f6d894b7333493ff06b2ed34e4c107a54abe2c5" translate="yes" xml:space="preserve">
          <source>A simple way would be to use a PHP framework like &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt; or &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; which have inbuilt features like filtering and active-record so that you don't have to worry about these nuances.</source>
          <target state="translated">簡単な方法は、フィルタリングやアクティブレコードなどの組み込み機能を備えた&lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt;や&lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt;などのPHPフレームワークを使用して、これらのニュアンスを気にする必要がないようにすることです。</target>
        </trans-unit>
        <trans-unit id="a4f547e2a90f5422256b70e6749192b1dc12e925" translate="yes" xml:space="preserve">
          <source>A user commented that this post is useless, OK! Here is what &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORG provided&lt;/a&gt;:</source>
          <target state="translated">ユーザーがこの投稿は役に立たないとコメントしました、OK！ &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORGが提供する&lt;/a&gt;ものは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f8bcba9062fd4c5354b3fe7577630f1852a5a4f1" translate="yes" xml:space="preserve">
          <source>Additional defenses:</source>
          <target state="translated">追加の防御。</target>
        </trans-unit>
        <trans-unit id="5a9a57fdfe801732160d7b653550c5f2e63ef2a2" translate="yes" xml:space="preserve">
          <source>Adopting the MVC pattern and a framework like &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt; or &lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter&lt;/a&gt; is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries.</source>
          <target state="translated">MVCパターンと&lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt;や&lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniterの&lt;/a&gt;ようなフレームワークを採用することはおそらく正しい方法です。安全なデータベースクエリの作成などの一般的なタスクが解決され、そのようなフレームワークに一元的に実装されました。 これらは、Webアプリケーションを賢明な方法で整理し、単一のSQLクエリを安全に構築することよりも、オブジェクトをロードおよび保存することについて考えるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c8a14a30d16f16ac980bf356d9504fab38b7075b" translate="yes" xml:space="preserve">
          <source>Also Enforce: Least Privilege</source>
          <target state="translated">施行します。最小特権</target>
        </trans-unit>
        <trans-unit id="1896c2015dcc61c975328aa2d6d19cd66a93eed3" translate="yes" xml:space="preserve">
          <source>Also Perform: White List Input Validation</source>
          <target state="translated">また、実行します。ホワイトリスト入力検証</target>
        </trans-unit>
        <trans-unit id="a7a90d96967d5c49bc4afaed57e9dee54e4e9f9c" translate="yes" xml:space="preserve">
          <source>Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt;.</source>
          <target state="translated">また、他の人が示唆しているように、 &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDOの&lt;/a&gt;ようなもので抽象化のレイヤーをステップアップするのが便利/簡単な場合もあります。</target>
        </trans-unit>
        <trans-unit id="2c30cce0b8c2965ca51b265a25df9d3693f83528" translate="yes" xml:space="preserve">
          <source>Also, its use is a little complicated if you are about to insert an empty string. You'll have to entirely replace it with &lt;code&gt;''&lt;/code&gt;, or you'll get an error.</source>
          <target state="translated">また、空の文字列を挿入する場合、その使用法は少し複雑になります。 完全に &lt;code&gt;''&lt;/code&gt; に置き換える必要があります。そうしないと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="69c4f0f8d46827c16603dcdf21511ca657bcb9e9" translate="yes" xml:space="preserve">
          <source>Also, you can 'prepare' your arguments before preparing your query so that you can build dynamic queries and at the end have a fully prepared statements query. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">また、クエリを準備する前に引数を「準備」して、動的クエリを作成し、最後に完全に準備されたステートメントクエリを作成できます。 &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;PHPを使用したMySQL用のDALMPデータベース抽象化レイヤー。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74d699a30675fa3d298fbab5df176b5b25503844" translate="yes" xml:space="preserve">
          <source>Although there is a general agreement on the best practices regarding SQL injection protection, there are &lt;strong&gt;still many bad practices as well.&lt;/strong&gt; And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) &lt;strong&gt;more than 80 deleted answers&lt;/strong&gt; - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of the bad answers aren't deleted, but rather prospering.</source>
          <target state="translated">SQLインジェクション保護に関するベストプラクティスについては一般的な合意がありますが、 &lt;strong&gt;それでも多くの悪いプラクティスがあります。&lt;/strong&gt; そして、それらのいくつかは、PHPユーザーの心に深く根ざしすぎています。 たとえば、このページには（ほとんどの訪問者には&lt;strong&gt;表示されませんが&lt;/strong&gt; ） &lt;strong&gt;削除された回答が80以上あり&lt;/strong&gt;ます。品質が悪い、または古くて古い慣行を推進しているため、コミュニティによってすべて削除されました。 さらに悪いことに、いくつかの悪い答えは削除されず、むしろ繁栄しています。</target>
        </trans-unit>
        <trans-unit id="eabd1c8f5b2f8e2b973f2b52cc71e91a5bb24985" translate="yes" xml:space="preserve">
          <source>Although you can set the &lt;code&gt;charset&lt;/code&gt; in the options of the constructor, it's important to note that 'older' versions of PHP (before 5.3.6) &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;silently ignored the charset parameter&lt;/a&gt; in the DSN.</source>
          <target state="translated">コンストラクターのオプションで &lt;code&gt;charset&lt;/code&gt; を設定できますが、PHPの「古い」バージョン（5.3.6より前）はDSNの&lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;文字セットパラメーターを暗黙的に無視する&lt;/a&gt;ことに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="89427a94f14d4db682ce047617bd39f90aeb83cc" translate="yes" xml:space="preserve">
          <source>An alternative to mysql_real_escape_string() is</source>
          <target state="translated">mysql_real_escape_string()の代替として</target>
        </trans-unit>
        <trans-unit id="7bcc7fb301834a94c428663cf127b9d3c420bafb" translate="yes" xml:space="preserve">
          <source>And OWASP makes it even worse, stressing on escaping &lt;em&gt;user input&lt;/em&gt; which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It's the destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is &quot;safe&quot; or not) he/she takes his/her first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.</source>
          <target state="translated">そして、OWASPはさらに悪いことに、まったく無意味な&lt;em&gt;ユーザー入力の&lt;/em&gt;エスケープに重点を置き&lt;em&gt;ます&lt;/em&gt; 。注入保護のコンテキストではそのような言葉はありません。 すべての変数は潜在的に危険です-ソースに関係なく！ または、言い換えると、ソースに関係なく、すべての変数を適切にフォーマットしてクエリに入れる必要があります。 重要なのは目的地です。 開発者が羊を山羊から分離し始めた瞬間（特定の変数が「安全」であるかどうかを考える）、彼/彼女は災害に向けて彼/彼女の最初のステップを踏み出します。 言い回しでさえ、非常に魔法の引用機能に似ている、エントリポイントでの一括エスケープを示唆していることは言うまでもありません-すでに軽視され、非推奨になり、削除されました。</target>
        </trans-unit>
        <trans-unit id="029c0a0374bedd82f613d03ef16978761b30cf7e" translate="yes" xml:space="preserve">
          <source>And by using PDO rather than &lt;code&gt;mysql_&lt;/code&gt;, &lt;code&gt;mysqli_&lt;/code&gt;, and &lt;code&gt;pgsql_&lt;/code&gt; functions, you make your application a little more abstracted from the database, in the rare occurrence that you have to switch database providers.</source>
          <target state="translated">また、 &lt;code&gt;mysql_&lt;/code&gt; 、 &lt;code&gt;mysqli_&lt;/code&gt; 、および &lt;code&gt;pgsql_&lt;/code&gt; 関数ではなくPDOを使用することで、データベースプロバイダーを切り替える必要があるというまれな事態で、アプリケーションをデータベースから少し抽象化します。</target>
        </trans-unit>
        <trans-unit id="9b5ef3ee55266b405431414057f96c242ca0a3ea" translate="yes" xml:space="preserve">
          <source>And it is so much better to use those functions to check input data with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">そして、これらの関数を使用して &lt;code&gt;mysql_real_escape_string&lt;/code&gt; で入力データをチェックする方がはるかに優れています。</target>
        </trans-unit>
        <trans-unit id="8b6f9dd7708882555f93273050b2295e1ff50293" translate="yes" xml:space="preserve">
          <source>And prepared statements cover only two of them.</source>
          <target state="translated">そして、準備されたステートメントは、そのうちの2つだけをカバーしています。</target>
        </trans-unit>
        <trans-unit id="9a818eb4d9f22f32e544143c95e4a338abac3b6a" translate="yes" xml:space="preserve">
          <source>And some other like &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;Preventing SQL injection with MySQL and PHP&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">そして&lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;、MySQLとPHPを使用したSQLインジェクションの防止など&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a9c32269a2494bf681823b0f8ef4fe2f380c0b7" translate="yes" xml:space="preserve">
          <source>And the use of &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is a useful function when used properly, especially when combined with &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; の使用は、名前が示すように、文字列内の特殊文字をエスケープするためのものであり、整数を安全にすることはできません。 この関数の目的は、SQLステートメントの文字列を壊すこと、およびそれが引き起こす可能性のあるデータベースへの損傷を防ぐことです。 &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; は、適切に使用した場合、特に &lt;code&gt;sprintf&lt;/code&gt; と組み合わせた場合に便利な関数です。</target>
        </trans-unit>
        <trans-unit id="77fdc73c5a405950cdef3ff428d3bc7c8429a576" translate="yes" xml:space="preserve">
          <source>And then just select whatever data ones want. Isn't it cool?</source>
          <target state="translated">あとは好きなデータを選択するだけ。かっこいいと思いませんか?</target>
        </trans-unit>
        <trans-unit id="469e5ab140693a349e074c76557802c31c33fd02" translate="yes" xml:space="preserve">
          <source>Another benefit of using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.</source>
          <target state="translated">準備されたステートメントを使用するもう一つの利点は、同じセッションで同じステートメントを何度も実行した場合、解析とコンパイルが一度だけになり、速度が向上することです。</target>
        </trans-unit>
        <trans-unit id="ac2632462245c897b1b550ec3d5bcf2e8b29db73" translate="yes" xml:space="preserve">
          <source>Any other query part, such as an SQL keyword, a table or a field name, or an operator - must be filtered through a white list.</source>
          <target state="translated">SQLキーワード、テーブルやフィールド名、演算子など、その他のクエリ部分は、ホワイトリストでフィルタリングする必要があります。</target>
        </trans-unit>
        <trans-unit id="59ca1e0dddd5402d6c514f23b5ab618318bd9b52" translate="yes" xml:space="preserve">
          <source>Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the &lt;code&gt;$name&lt;/code&gt; variable contains &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; the result would simply be a search for the string &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt;, and you will not end up with &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;an empty table&lt;/a&gt;.</source>
          <target state="translated">準備されたステートメントを使用するときに送信するパラメーターはすべて、文字列として扱われます（もちろん、データベースエンジンが最適化を行う場合があるため、パラメーターが数値になる場合もあります）。 上記の例では、 &lt;code&gt;$name&lt;/code&gt; 変数に &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; が含まれている場合、 DELETE FROM employeesの結果は、単に文字列 &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt; 検索であり&lt;a href=&quot;http://xkcd.com/327/&quot;&gt;、空のテーブルに&lt;/a&gt;なることはありません。</target>
        </trans-unit>
        <trans-unit id="814927018a663b40d6800585c37e63752cd8b345" translate="yes" xml:space="preserve">
          <source>Any variable that represents an SQL data literal, (or, to put it simply - an SQL string, or a number) must be added through a prepared statement. No Exceptions.</source>
          <target state="translated">SQLデータリテラルを表す変数(簡単に言えば、SQL文字列や数値)は、準備されたステートメントを使って追加しなければなりません。例外はありません。</target>
        </trans-unit>
        <trans-unit id="8f339838f01ea88e77c778fe86da6db1dbb6727f" translate="yes" xml:space="preserve">
          <source>As also mentioned in the above statement,</source>
          <target state="translated">前述のとおりである。</target>
        </trans-unit>
        <trans-unit id="35a0aae8525a92229ff81ec077bfddd794e5ad1c" translate="yes" xml:space="preserve">
          <source>As you can see, people suggest you use prepared statements at the most. It's not wrong, but when your query is executed &lt;strong&gt;just once&lt;/strong&gt; per process, there would be a slight performance penalty.</source>
          <target state="translated">ご覧のとおり、多くの場合、準備されたステートメントを使用することをお勧めします。 間違いではありませんが、クエリがプロセスごとに1 &lt;strong&gt;回だけ&lt;/strong&gt;実行されると、パフォーマンスがわずかに低下します。</target>
        </trans-unit>
        <trans-unit id="bd2cedbc3cba1b466c7ccb0d7d8ccb2234565bfd" translate="yes" xml:space="preserve">
          <source>As you may know, claiming an article should be supported by a valid argument, at least by one reference! Otherwise, it's considered as an attack and a bad claim!</source>
          <target state="translated">ご存知かもしれませんが、記事を主張することは、少なくとも1つの参考文献によって、有効な議論によってサポートされている必要があります!それ以外の場合は、攻撃であり、悪い主張とみなされます。そうでなければ、それは攻撃と悪い主張とみなされます!</target>
        </trans-unit>
        <trans-unit id="820ba4d63bbc346ca4423e23a1bea3ca67844669" translate="yes" xml:space="preserve">
          <source>Basically, read it &lt;a href=&quot;http://php.net/pdo&quot;&gt;while you read the manual&lt;/a&gt; to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format &lt;strong&gt;you&lt;/strong&gt; want.</source>
          <target state="translated">基本的に、 &lt;a href=&quot;http://php.net/pdo&quot;&gt;マニュアル&lt;/a&gt;を読みながら PDO関数を実際に使用して、必要な形式で値を簡単に格納および取得する方法を確認するために読んでください。</target>
        </trans-unit>
        <trans-unit id="984f8b5a40d91fa830e321cc52151441d3cd3388" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;1=1&lt;/code&gt;, &lt;code&gt;2=2&lt;/code&gt;, &lt;code&gt;1=2&lt;/code&gt;, &lt;code&gt;2=1&lt;/code&gt;, &lt;code&gt;1+1=2&lt;/code&gt;, etc... are the common questions to an SQL database of an attacker. Maybe also it's used by many hacking applications.</source>
          <target state="translated">&lt;code&gt;1=1&lt;/code&gt; &lt;code&gt;2=2&lt;/code&gt; &lt;code&gt;1=2&lt;/code&gt; &lt;code&gt;1+1=2&lt;/code&gt; などは、攻撃者のSQLデータベースに対する一般的な質問であるためです。 多分それはまた、多くのハッキングアプリケーションで使用されています。</target>
        </trans-unit>
        <trans-unit id="c0510df3f1d4695430a58920cd200e354ad3da70" translate="yes" xml:space="preserve">
          <source>Bound variables will be escaped automatically by the server. The
  server inserts their escaped values at the appropriate places into the
  statement template before execution. A hint must be provided to the
  server for the type of bound variable, to create an appropriate
  conversion. See the mysqli_stmt_bind_param() function for more
  information.</source>
          <target state="translated">バウンド変数はサーバによって自動的にエスケープされます。サーバは、そのエスケープされた値を、実行前にステートメントテンプレートの適切な場所に挿入します。適切な変換を行うには、バウンド変数の型のヒントをサーバに提供する必要があります。詳細は mysqli_stmt_bind_param()関数を参照ください。</target>
        </trans-unit>
        <trans-unit id="6c45ced87722560ce91bdb8d47661e48efa8ce64" translate="yes" xml:space="preserve">
          <source>But if the coder of an injectable site would hex it, no injection would be possible because the query would look like this: &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</source>
          <target state="translated">しかし、注入可能なサイトのコーダーがそれを16進数にする場合、クエリは次のようになるため、注入は不可能です &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1130d41244662be40e74568e6d313b2aeba7a56" translate="yes" xml:space="preserve">
          <source>But sometimes we have to make our query even more dynamic, adding operators or identifiers as well.
So, we will need different protection techniques.</source>
          <target state="translated">しかし、時には演算子や識別子を追加して、より動的なクエリにしなければならないこともあります。そのため、さまざまな保護技術が必要になります。</target>
        </trans-unit>
        <trans-unit id="388e5f4608b9c0c64a94caf6cb522f68f0b812be" translate="yes" xml:space="preserve">
          <source>But while both PDO and MySQLi are quite fast, MySQLi performs
insignificantly faster in benchmarks &amp;ndash; ~2.5% for non-prepared
statements, and ~6.5% for prepared ones.</source>
          <target state="translated">しかし、PDOとMySQLiはどちらも非常に高速ですが、MySQLiはベンチマークでわずかに高速で実行されます。準備されていないステートメントでは〜2.5％、準備されたステートメントでは〜6.5％です。</target>
        </trans-unit>
        <trans-unit id="11ae2ab8e554cd29a407caca0e6fabee0756957e" translate="yes" xml:space="preserve">
          <source>But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect &lt;em&gt;(it depends on you)&lt;/em&gt; that hacking-specific dynamic query string into a page that will store the attacker's &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP address&lt;/a&gt;, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.</source>
          <target state="translated">ただし、サイトからの安全なクエリを書き換えないように注意する必要があります。 上記のコードは、ハッキングに固有の動的クエリ文字列を、攻撃者の&lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IPアドレス&lt;/a&gt; 、またはクッキー、履歴、ブラウザ、その他の機密情報を格納するページに書き換えたりリダイレクトしたりするためのヒントを提供しています。情報を提供するため、後でアカウントを禁止したり、当局に連絡したりして対処できます。</target>
        </trans-unit>
        <trans-unit id="c2424b0d28c65836412890f683090b9c10c2c3e2" translate="yes" xml:space="preserve">
          <source>Can prepared statements be used for dynamic queries?</source>
          <target state="translated">準備されたステートメントは動的クエリに使用できますか?</target>
        </trans-unit>
        <trans-unit id="cc031d2a659335c48d55ac551c2a927f393178cf" translate="yes" xml:space="preserve">
          <source>Consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; are not available. How can you secure your application? Do you force me to use them? What about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border, not just for a specific language.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt;と&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;が利用できないことを考慮してください。 アプリケーションをどのように保護できますか？ それらを使用するように強制しますか？ PHP以外の他の言語についてはどうですか？ 特定の言語だけでなく、より広い境界で使用できるため、私は一般的なアイデアを提供することを好みます。</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">次のクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="6047ffa640b216365f3915cb1825dec617a4486c" translate="yes" xml:space="preserve">
          <source>Correctly setting up the connection</source>
          <target state="translated">正しい接続設定</target>
        </trans-unit>
        <trans-unit id="a6b87d4687eee957fbc10c0728a5bff14a875b82" translate="yes" xml:space="preserve">
          <source>Data filtering: before building any query user input, it should be validated and filtered. For programmers, it's important to define some properties for each user-input variables:
&lt;strong&gt;data type, data pattern, and data length&lt;/strong&gt;. A field that is a number between (x and y) must be exactly validated using the exact rule, and for a field that is a string (text): pattern is the case, for example, a username must contain only some characters, let&amp;rsquo;s say [a-zA-Z0-9_-.]. The length varies between (x and n) where x and n (integers, x &amp;lt;=n).
&lt;strong&gt;Rule: creating exact filters and validation rules are best practices for me.&lt;/strong&gt;</source>
          <target state="translated">データのフィルタリング：クエリのユーザー入力を作成する前に、検証とフィルタリングを行う必要があります。 プログラマーにとって、ユーザー入力変数ごとにいくつかのプロパティを定義することが重要です： &lt;strong&gt;データ型、データパターン、データ長&lt;/strong&gt; 。 （xとy）の間の数値であるフィールドは、正確なルールを使用して正確に検証する必要があります。文字列（テキスト）であるフィールドの場合：パターンが当てはまる場合、たとえば、ユーザー名に一部の文字のみを含める必要があります。 [a-zA-Z0-9_-。]と言います。 長さは（xとn）の間で変化します。ここで、xとn（整数、x &amp;lt;= n）です。 &lt;strong&gt;ルール：正確なフィルターと検証ルールを作成することが私にとってのベストプラクティスです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac512b2277dc12fb253b90cadeff4b79f7f0c52d" translate="yes" xml:space="preserve">
          <source>Data validation</source>
          <target state="translated">データの検証</target>
        </trans-unit>
        <trans-unit id="bc11336395287ce262bd5113df8755daa9bf7976" translate="yes" xml:space="preserve">
          <source>Difference between UNHEX function and 0x prefix</source>
          <target state="translated">UNHEX関数と0xプレフィックスの違い</target>
        </trans-unit>
        <trans-unit id="64fadb85f6f8e77597bc8111b879ba46ab913ae2" translate="yes" xml:space="preserve">
          <source>Don't use &lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt;. This extension is deprecated. Use &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt;は使用しないでください。 この拡張は廃止されました。 代わりに&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt;または&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDOを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="47070a639c03e8836d4eb1ec8798be8eba3ad73e" translate="yes" xml:space="preserve">
          <source>Don't worry about that the escaped string will have a 2x size of its original length because even if you use &lt;code&gt;mysql_real_escape_string&lt;/code&gt;, PHP has to allocate same capacity &lt;code&gt;((2*input_length)+1)&lt;/code&gt;, which is the same.</source>
          <target state="translated">エスケープされた文字列が元の長さの2倍のサイズになることを心配しないでください &lt;code&gt;mysql_real_escape_string&lt;/code&gt; を使用しても、PHPは同じ容量 &lt;code&gt;((2*input_length)+1)&lt;/code&gt; を割り当てる必要があるためです。</target>
        </trans-unit>
        <trans-unit id="a8399b7eb2075e4b434c811aae00c5124b738ead" translate="yes" xml:space="preserve">
          <source>Escaping and SQL injection</source>
          <target state="translated">エスケープとSQLインジェクション</target>
        </trans-unit>
        <trans-unit id="f51a89736407728dd8dad04a11c2585ad6ed1ddc" translate="yes" xml:space="preserve">
          <source>Every answer here covers only part of the problem.
In fact, there are &lt;strong&gt;four&lt;/strong&gt; different query parts which we can add to SQL dynamically: -</source>
          <target state="translated">ここでのすべての回答は、問題の一部のみをカバーしています。 実際、SQLに動的に追加できる&lt;strong&gt;4つの&lt;/strong&gt;異なるクエリ部分があります。-</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="7f33f9daadca6cb0086c1f093e4291fd8f752aed" translate="yes" xml:space="preserve">
          <source>Finally you get:</source>
          <target state="translated">やっと手に入れることができました。</target>
        </trans-unit>
        <trans-unit id="203bdc584486062bd9b0a868468cf5b0c6115900" translate="yes" xml:space="preserve">
          <source>Finally, let's consider that a user sends this text below instead of entering his/her username:</source>
          <target state="translated">最後に、ユーザが自分のユーザ名を入力せずに以下のテキストを送信した場合を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4c529cebc105c5ddf809043dcd4cda22ee4366d8" translate="yes" xml:space="preserve">
          <source>For automatic escaping of values with prepared statements, use &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt;, and &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param&lt;/a&gt; where types for the corresponding bind variables must be provided for an appropriate conversion:</source>
          <target state="translated">準備済みステートメントで値を自動エスケープするには、 &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt;および&lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_paramを&lt;/a&gt;使用します。対応するバインド変数の型を適切な変換のために提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="263085c2dabdadf48b189f11fe3b9f44078570cc" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;there(1)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are(2)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still(3)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many(4)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;answers(5)&lt;/a&gt;, including the &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;second most upvoted answer&lt;/a&gt; suggesting you manual string escaping - an outdated approach that is proven to be insecure.</source>
          <target state="translated">たとえば、 &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;there（1）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are（2）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still（3）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many（4）&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;Answers&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;（5）には&lt;/a&gt; 、手動で文字列をエスケープすることを示唆する2番目に多い回答が含まれています。これは、安全でないことが証明されている古いアプローチです。</target>
        </trans-unit>
        <trans-unit id="dd135ed1c5cdc625f86215a3d852d0a226ec19ca" translate="yes" xml:space="preserve">
          <source>For example, if you just do something like this:</source>
          <target state="translated">例えば、こんなことをするだけでも</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="816ab6a230a5f009a780f99ed39f9fa8ad076a2f" translate="yes" xml:space="preserve">
          <source>For manually escaping special characters in a string you can use the &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt; function. The function will not work properly unless the correct character set is set with &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset&lt;/a&gt;.</source>
          <target state="translated">文字列内の特殊文字を手動でエスケープするには、 &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt;関数を使用できます。 &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charsetで&lt;/a&gt;正しい文字セットが設定されていないと、この関数は正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="6faf52c891f9ed8efba053050f428dfa69b63649" translate="yes" xml:space="preserve">
          <source>For more information, please read &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQL Injection Prevention Cheat Sheet&lt;/a&gt;.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQLインジェクション防止に関するチートシート&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="4d38e733b61cd3029c8e0a13aa3342ac97a1dd29" translate="yes" xml:space="preserve">
          <source>For more prevention, you can add at the end ...</source>
          <target state="translated">より多くの予防のために、あなたは最後に追加することができます...</target>
        </trans-unit>
        <trans-unit id="9b951568ae96d7b8f246820658eefa294ec054b6" translate="yes" xml:space="preserve">
          <source>For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.</source>
          <target state="translated">これらの特定のシナリオのために、可能な値を制限するホワイトリストフィルタを使用するのが最善の方法です。</target>
        </trans-unit>
        <trans-unit id="3113d98fc6c4b79c794822624639f6af44b6df61" translate="yes" xml:space="preserve">
          <source>For those unsure of how to use PDO (coming from the &lt;code&gt;mysql_&lt;/code&gt; functions), I made a &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;very, very simple PDO wrapper&lt;/a&gt; that is a single file. It exists to show how easy it is to do all the common things applications need to be done. Works with PostgreSQL, MySQL, and SQLite.</source>
          <target state="translated">（ &lt;code&gt;mysql_&lt;/code&gt; 関数からの）PDOの使用方法がわからない人のために、単一のファイル&lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;である非常に単純なPDOラッパー&lt;/a&gt;を作成しました。 アプリケーションを実行するために必要なすべての一般的なことを簡単に実行できることを示すために存在します。 PostgreSQL、MySQL、SQLiteで動作します。</target>
        </trans-unit>
        <trans-unit id="31a94adfc6ded26176c675ac449c92a6685c5361" translate="yes" xml:space="preserve">
          <source>From the PHP manual, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP: Prepared Statements - Manual&lt;/a&gt;:</source>
          <target state="translated">PHPマニュアル、 &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP：Prepared Statements-Manualから&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e5468989f2e2437840e22ffb20130112517c2fc" translate="yes" xml:space="preserve">
          <source>Hex is the perfect escape. No way to inject.</source>
          <target state="translated">ヘックスは完璧な逃げ道です。注射の仕方がない。</target>
        </trans-unit>
        <trans-unit id="1de0731dde0800e271064f5cf722c055c76cb148" translate="yes" xml:space="preserve">
          <source>Hex methods are often used as attacks</source>
          <target state="translated">ヘックス法は攻撃としてよく使われる</target>
        </trans-unit>
        <trans-unit id="b62564667d0dfb9e44b590131236f464401bdd8b" translate="yes" xml:space="preserve">
          <source>How can I prevent SQL injection in PHP</source>
          <target state="translated">PHPでSQLインジェクションを防ぐには</target>
        </trans-unit>
        <trans-unit id="bd0deab6887a1354686773b46e00790e48d6fe0e" translate="yes" xml:space="preserve">
          <source>I created test cases for knowing how PDO and MySQLi send the query to the MySQL server when using a prepared statement:</source>
          <target state="translated">PDOとMySQLiが準備されたステートメントを使用した場合に、どのようにMySQLサーバにクエリを送信するかを知るためのテストケースを作成しました。</target>
        </trans-unit>
        <trans-unit id="b9bbcd490604fe09b3cd1968bb6c6f7fa088e009" translate="yes" xml:space="preserve">
          <source>I favor &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;stored procedures&lt;/a&gt; (&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL has had stored procedures support since 5.0&lt;/a&gt;) from a security point of view - the advantages are -</source>
          <target state="translated">セキュリティの観点から、私は&lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;ストアドプロシージャ&lt;/a&gt; （ &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQLは5.0以降、ストアドプロシージャをサポートしてきました&lt;/a&gt; ）を支持しています-利点は-</target>
        </trans-unit>
        <trans-unit id="43758c0ba6ab9cf4ca9dc9ffd9fe8ff1ebfc4f99" translate="yes" xml:space="preserve">
          <source>I hope this will help you.</source>
          <target state="translated">お役に立てれば幸いです。</target>
        </trans-unit>
        <trans-unit id="84a0fd31784433f7ef6a00aea8326647c9561507" translate="yes" xml:space="preserve">
          <source>I suggest, using PDO is the best option.</source>
          <target state="translated">私は、PDOを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="18aa4535a307c95c0ececdd0bfb8cd49698d9cca" translate="yes" xml:space="preserve">
          <source>I think if someone wants to use PHP and MySQL or some other dataBase server:</source>
          <target state="translated">PHPとMySQLとかのデータベースサーバーを使いたい人がいたら、と思います。</target>
        </trans-unit>
        <trans-unit id="c95768ad26c493130f9d2b473fe6ef3eb215bddb" translate="yes" xml:space="preserve">
          <source>I think that all this because of one very old superstition, supported by such authorities like &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;the PHP manual&lt;/a&gt;, which proclaims equality between whatever &quot;escaping&quot; and protection from SQL injections.</source>
          <target state="translated">これはすべて、 &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt;や&lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;PHPマニュアル&lt;/a&gt;などの当局によってサポートされている非常に古い迷信によるもので、SQLのインジェクションからの「エスケープ」と保護の平等を宣言していると思います。</target>
        </trans-unit>
        <trans-unit id="06f647de8211b09469d07c391ca6e9753993ee87" translate="yes" xml:space="preserve">
          <source>I use three different ways to prevent my web application from being vulnerable to SQL injection.</source>
          <target state="translated">私は、WebアプリケーションがSQLインジェクションに脆弱な状態になるのを防ぐために、3つの方法を使い分けています。</target>
        </trans-unit>
        <trans-unit id="aa717e5dd178fdf0c4683b6d4ebda0dfe58dee0e" translate="yes" xml:space="preserve">
          <source>I was facing this issue, but I think I solved it in &lt;em&gt;very&lt;/em&gt; sophisticated way - the way hackers use to avoid using quotes. I used this in conjunction with emulated prepared statements. I use it to prevent &lt;em&gt;all&lt;/em&gt; kinds of possible SQL injection attacks.</source>
          <target state="translated">私はこの問題に直面していましたが、 &lt;em&gt;非常に&lt;/em&gt;洗練された方法で解決したと思います。ハッカーが引用符を使用しないようにする方法です。 これを、エミュレートされた準備済みステートメントと組み合わせて使用​​しました。 &lt;em&gt;あらゆる&lt;/em&gt;種類のSQLインジェクション攻撃を防ぐために使用しています。</target>
        </trans-unit>
        <trans-unit id="e5f69a8687e8ff3c1c4991d23a6d4ef4077382ba" translate="yes" xml:space="preserve">
          <source>I would like to let you know: Why do we try for preventing SQL injection with a short example below:</source>
          <target state="translated">ということをお伝えしたいと思います。なぜ我々は以下の短い例でSQLインジェクションを防止するために試してみてください。</target>
        </trans-unit>
        <trans-unit id="eba600f8bfb98c671cd997242fbcbddc9efa69ac" translate="yes" xml:space="preserve">
          <source>I'd recommend using &lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) to run parameterized SQL queries.</source>
          <target state="translated">&lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; （PHP Data Objects）を使用してパラメーター化されたSQLクエリを実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="40c2e08dff1fe6c1375d48a2c7cea92dc8a4069b" translate="yes" xml:space="preserve">
          <source>I've written this little function several years ago:</source>
          <target state="translated">数年前にこの小さな関数を書いたことがあります。</target>
        </trans-unit>
        <trans-unit id="bd1f9c5fa454d3c00b06ea476a20111a54613929" translate="yes" xml:space="preserve">
          <source>If possible, cast the types of your parameters. But it's only working on simple types like int, bool, and float.</source>
          <target state="translated">可能であれば、パラメータの型をキャストしてください。しかし、int、bool、floatのような単純な型でしか動作しません。</target>
        </trans-unit>
        <trans-unit id="5827c6c3a2418ad354c9d261967a8450348a74c1" translate="yes" xml:space="preserve">
          <source>If the attackers are trying to hack into the form via PHP's &lt;code&gt;$_GET&lt;/code&gt; variable or with the URL's query string, you would be able to catch them if they're not secure.</source>
          <target state="translated">攻撃者がPHPの &lt;code&gt;$_GET&lt;/code&gt; 変数を介して、またはURLのクエリ文字列を使用してフォームにハッキングしようとしている場合、安全でない場合、それらを捕まえることができます。</target>
        </trans-unit>
        <trans-unit id="e7511b2b136cd15346fc6c4ed024e6a28da03c3b" translate="yes" xml:space="preserve">
          <source>If user input is inserted without modification into an SQL query, then the application becomes vulnerable to &lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQL injection&lt;/a&gt;, like in the following example:</source>
          <target state="translated">ユーザー入力を変更せずにSQLクエリに挿入すると、次の例のように、アプリケーションが&lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQLインジェクション&lt;/a&gt;に対して脆弱になります。</target>
        </trans-unit>
        <trans-unit id="252e57771708143a8a54033603a42c7a9528bde0" translate="yes" xml:space="preserve">
          <source>If you expect anything else from integer &lt;strong&gt;hex it&lt;/strong&gt;. If you hex it, you will perfectly escape all input. In C/C++ there's a function called &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt;&lt;code&gt;mysql_hex_string()&lt;/code&gt;&lt;/a&gt;, in PHP you can use &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt;&lt;code&gt;bin2hex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">整数&lt;strong&gt;16進数&lt;/strong&gt;からそれ以外のものを期待する場合。 16進数にすると、すべての入力を完全にエスケープします。 C / C ++には&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt; &lt;code&gt;mysql_hex_string()&lt;/code&gt; &lt;/a&gt;という関数があり、PHPでは&lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt; &lt;code&gt;bin2hex()&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="0094481ec99be1c5a7d70dc70e550f643a741a7d" translate="yes" xml:space="preserve">
          <source>If you expect input to be integer make sure it's &lt;strong&gt;&lt;em&gt;really&lt;/em&gt;&lt;/strong&gt; integer. In a variable-type language like PHP it is this &lt;em&gt;very&lt;/em&gt; important. You can use for example this very simple but powerful solution: &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</source>
          <target state="translated">入力が整数であることが予想される場合は、それが&lt;strong&gt;&lt;em&gt;本当に&lt;/em&gt;&lt;/strong&gt;整数であることを確認してください。 PHPのような変数型言語では、これは&lt;em&gt;非常に&lt;/em&gt;重要です。 たとえば、次の非常にシンプルで強力なソリューションを使用できます &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="506301687174ad39af3412a5f9d9bf697ce6b22d" translate="yes" xml:space="preserve">
          <source>If you use integers from user input in a condition and take the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; approach, you will suffer from the problem described by &lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;Polynomial&lt;/a&gt; in the comments below. This case is trickier because integers would not be surrounded by quotes, so you could deal with by validating that the user input contains only digits.</source>
          <target state="translated">条件でユーザー入力からの整数を使用し、 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; アプローチを取る場合、以下のコメントで&lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;多項式&lt;/a&gt;によって説明されている問題に苦しむことになります。 整数は引用符で囲まれないため、この場合はトリッキーです。ユーザー入力に数字のみが含まれていることを検証することで対処できます。</target>
        </trans-unit>
        <trans-unit id="98415529fb77c227add683c142b9927f11fa1d97" translate="yes" xml:space="preserve">
          <source>If you want to alter the structure of the SQL based on user input, parameterized queries are not going to help, and the escaping required is not covered by &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. In this kind of case, you would be better off passing the user's input through a whitelist to ensure only 'safe' values are allowed through.</source>
          <target state="translated">ユーザー入力に基づいてSQLの構造を変更する場合、パラメーター化されたクエリは &lt;code&gt;mysql_real_escape_string&lt;/code&gt; ず、必要なエスケープはmysql_real_escape_stringではカバーされません。 このような場合は、ユーザーの入力をホワイトリストに渡して、「安全な」値のみが通過できるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8785f3e80562fc002361ca18a095e5f516055181" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of cache engines, like &lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt;, maybe DALMP could be a choice. It uses pure &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;. Check this: &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt;や&lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt;などのキャッシュエンジンを利用したい場合は、DALMPを選択することをお勧めします。 純粋な&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLiを&lt;/a&gt;使用します。 これをチェックしてください： &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;PHPを使用したMySQLのDALMPデータベース抽象化レイヤー。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb7a8e4204cd0dadf37e960ba81602dfdecab9d3" translate="yes" xml:space="preserve">
          <source>If you're connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (for example, &lt;code&gt;pg_prepare()&lt;/code&gt; and &lt;code&gt;pg_execute()&lt;/code&gt; for PostgreSQL). PDO is the universal option.</source>
          <target state="translated">MySQL以外のデータベースに接続している場合、参照できるドライバ固有の2番目のオプションがあります（たとえば、PostgreSQLの &lt;code&gt;pg_execute()&lt;/code&gt; およびpg_execute（） ）。 PDOは汎用オプションです。</target>
        </trans-unit>
        <trans-unit id="d16f400a258fe645cbcf862d1cdacec8afcc86a4" translate="yes" xml:space="preserve">
          <source>If you're using a recent version of PHP, the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option outlined below will no longer be available (though &lt;code&gt;mysqli::escape_string&lt;/code&gt; is a modern equivalent). These days the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option would only make sense for legacy code on an old version of PHP.</source>
          <target state="translated">最近のバージョンのPHPを使用している場合、以下に概説されている &lt;code&gt;mysql_real_escape_string&lt;/code&gt; オプションは使用できなくなります（ただし、 &lt;code&gt;mysqli::escape_string&lt;/code&gt; は同等の機能です）。 最近の &lt;code&gt;mysql_real_escape_string&lt;/code&gt; オプションは、古いバージョンのPHPのレガシーコードに対してのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="a87d9bb2e1e1d38953625a44a667a275d119c139" translate="yes" xml:space="preserve">
          <source>In both cases, you can't use &lt;code&gt;'&lt;/code&gt; to protect the encapsulation.</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;'&lt;/code&gt; を使用してカプセル化を保護することはできません。</target>
        </trans-unit>
        <trans-unit id="bc303fbbb40874deaf199e9d6a1fad1eae12e122" translate="yes" xml:space="preserve">
          <source>In general, such a protection approach is based on &lt;em&gt;whitelisting&lt;/em&gt;.</source>
          <target state="translated">一般に、このような保護アプローチは&lt;em&gt;ホワイトリストに&lt;/em&gt;基づいてい&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fca827b92ede4c4e14d63153d01c7f1f4172674" translate="yes" xml:space="preserve">
          <source>In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application's architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it's just a matter of time until you forget to correctly format your query at some point in your code.</source>
          <target state="translated">私の考えでは、PHPアプリケーション(あるいはどんなWebアプリケーションであっても)におけるSQLインジェクションを一般的に防ぐ最善の方法は、アプリケーションのアーキテクチャについて考えることです。SQLインジェクションを防ぐ唯一の方法が、データベースに接続するたびにThe Right Thingを行う特別なメソッドや関数を使用することを覚えておくことだとしたら、それは間違ったことをしていることになります。そうすれば、コードのどこかの時点でクエリを正しくフォーマットすることを忘れてしまうのは時間の問題です。</target>
        </trans-unit>
        <trans-unit id="65b6a7572f51598d01d28ef1ca6341d368dbf0b0" translate="yes" xml:space="preserve">
          <source>In the above example the error mode isn't strictly necessary, &lt;strong&gt;but it is advised to add it&lt;/strong&gt;. This way the script will not stop with a &lt;code&gt;Fatal Error&lt;/code&gt; when something goes wrong. And it gives the developer the chance to &lt;code&gt;catch&lt;/code&gt; any error(s) which are &lt;code&gt;throw&lt;/code&gt;n as &lt;code&gt;PDOException&lt;/code&gt;s.</source>
          <target state="translated">上記の例では、エラーモードは必ずしも必要ではありません&lt;strong&gt;が、追加することをお勧めし&lt;/strong&gt;ます。 このようにすると、スクリプトは、問題が発生したときに &lt;code&gt;Fatal Error&lt;/code&gt; 停止しません。 また、 &lt;code&gt;PDOException&lt;/code&gt; として &lt;code&gt;throw&lt;/code&gt; エラーを &lt;code&gt;catch&lt;/code&gt; する機会を開発者に与えます。</target>
        </trans-unit>
        <trans-unit id="d2db286e4cb56e8b42ba950818e8b8f310b67a57" translate="yes" xml:space="preserve">
          <source>In this case, every dynamic parameter should be hardcoded in your script and chosen from that set.
For example, to do dynamic ordering:</source>
          <target state="translated">この場合、すべての動的パラメータはスクリプト内でハードコードされ、そのセットから選択されなければなりません。例えば、動的な順序付けを行うには</target>
        </trans-unit>
        <trans-unit id="6b2d5fd11bcfa0af9c55f66b09eb36931b5296de" translate="yes" xml:space="preserve">
          <source>Information security</source>
          <target state="translated">情報セキュリティ</target>
        </trans-unit>
        <trans-unit id="7be8da2bc759d6b5b0023a64f7e97f8d22bcbce1" translate="yes" xml:space="preserve">
          <source>Injection prevention - &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string()&lt;/a&gt;</source>
          <target state="translated">インジェクション防止&lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;-mysql_real_escape_string（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f5d58263c5f2019288630bda6ee4cb637fd37bd" translate="yes" xml:space="preserve">
          <source>It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is an invalid syntax.</source>
          <target state="translated">変数の型を考慮するとエスケープされます。テーブルやカラム名をパラメータ化しようとすると、すべての文字列を引用符で囲むので失敗します。</target>
        </trans-unit>
        <trans-unit id="e66723c3916c6792b6e9358bbc39573f7f203093" translate="yes" xml:space="preserve">
          <source>It not only saves you from SQL injections but from syntax errors too! Also Supports collections of models with method chaining to filter or apply actions to multiple results at once and multiple connections.</source>
          <target state="translated">SQLインジェクションだけでなく、構文エラーからも解放されます。また、メソッドチェインでモデルのコレクションをサポートしており、一度に複数の結果や複数の接続をフィルタリングしたり、アクションを適用したりすることができます。</target>
        </trans-unit>
        <trans-unit id="f53f074e916e32d9c9de79faceea3b3a0b1b8268" translate="yes" xml:space="preserve">
          <source>It's clear that a prepared statement is also escaping the data, nothing else.</source>
          <target state="translated">用意された文もデータをエスケープしているのは明らかで、それ以外の何物でもありません。</target>
        </trans-unit>
        <trans-unit id="066059abccc3bb425cd0e667ccb08532bb6fc8ca" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANTの&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="ed0dd15ea735ebf8e4f7aefab757f8823897465c" translate="yes" xml:space="preserve">
          <source>Most databases (including &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt;) enable user access to be restricted to executing stored procedures. The fine-grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.</source>
          <target state="translated">ほとんどのデータベース（ &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt;を含む）では、ユーザーアクセスをストアドプロシージャの実行に制限できます。 きめ細かなセキュリティアクセスコントロールは、特権攻撃の昇格を防ぐのに役立ちます。 これにより、侵害されたアプリケーションがデータベースに対して直接SQLを実行することができなくなります。</target>
        </trans-unit>
        <trans-unit id="cbc26a832cdcd4282066d905ed7a05f1fdc9ed21" translate="yes" xml:space="preserve">
          <source>My approach against SQL injection is: clearing user-input data before sending it to the database (before using it inside any query).</source>
          <target state="translated">SQLインジェクションに対する私のアプローチは、データベースに送信する前に(クエリの中で使用する前に)ユーザー入力データをクリアすることです。</target>
        </trans-unit>
        <trans-unit id="05f8f3c79f55806a7dcfe96187c4600251c00e11" translate="yes" xml:space="preserve">
          <source>My approach:</source>
          <target state="translated">私のアプローチ。</target>
        </trans-unit>
        <trans-unit id="4d52e8740d9df9e1c638ac50e30925e49fcd8e33" translate="yes" xml:space="preserve">
          <source>No matter if you use prepared statements or &lt;code&gt;mysqli_real_escape_string&lt;/code&gt;, you always have to know the type of input data you're working with.</source>
          <target state="translated">準備されたステートメントまたは &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; を使用するかどうかに関係なく 、作業している入力データのタイプを常に知る必要があります。</target>
        </trans-unit>
        <trans-unit id="529ff19c5e6399e4d50652370e959d26daab503b" translate="yes" xml:space="preserve">
          <source>Not only does this protect against SQL injection, but it also speeds up queries.</source>
          <target state="translated">SQLインジェクションからの保護だけでなく、クエリの高速化も実現しています。</target>
        </trans-unit>
        <trans-unit id="ad07b10ae48ce9bcac4c0024173c1939bf2d4d50" translate="yes" xml:space="preserve">
          <source>Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. Then you can avoid the use of quotes.</source>
          <target state="translated">この16進数メソッドは、SQLインジェクション攻撃としてよく使用され、整数は文字列のようになり、 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; でエスケープされることに注意してください。 その後、引用符の使用を回避できます。</target>
        </trans-unit>
        <trans-unit id="6bd876670bffa2dedbaa4302b16a1c84ee2ebe22" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;PDO&lt;/code&gt; to access a MySQL database &lt;em&gt;real&lt;/em&gt; prepared statements are &lt;strong&gt;not used by default&lt;/strong&gt;. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using PDO is:</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; を使用してMySQLデータベースにアクセスする場合、 &lt;em&gt;実際の&lt;/em&gt;準備済みステートメントは&lt;strong&gt;デフォルトでは使用されない&lt;/strong&gt;ことに注意してください。 これを修正するには、準備済みステートメントのエミュレーションを無効にする必要があります。 PDOを使用して接続を作成する例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0281801c06d0ce9e250fd24a61b6b6723729516b" translate="yes" xml:space="preserve">
          <source>Now, &lt;strong&gt;why you do you need to prevent your query from SQL injection?&lt;/strong&gt;</source>
          <target state="translated">では、 &lt;strong&gt;なぜSQLインジェクションからクエリを防ぐ必要があるのでしょうか。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26d705214b3428e5682f630c8e66663452ff37b5" translate="yes" xml:space="preserve">
          <source>Now, if someone (a hacker) puts</source>
          <target state="translated">さて、もし誰か(ハッカー)が</target>
        </trans-unit>
        <trans-unit id="66eb148a1111b249fa1c3f3a55a2330ca909715f" translate="yes" xml:space="preserve">
          <source>Now, if you are an advanced user, start using this defense as you like, but, for beginners, if they can't quickly implement a stored procedure and prepared the statement, it's better to filter input data as much they can.</source>
          <target state="translated">さて、上級者であれば、この防御策を好きなように使い始めればいいのですが、初心者の方は、ストアドプロシージャをすぐに実装して、ステートメントを用意できない場合は、入力データをフィルタリングして、できる限りのことをした方がいいと思います。</target>
        </trans-unit>
        <trans-unit id="f64627235bbf5e10f0dda979a643fa08ab87651d" translate="yes" xml:space="preserve">
          <source>Now, our point is to prevent security threats such as SQL injection attacks, the question asking (how to prevent an SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? How do you secure your application?</source>
          <target state="translated">さて、私たちのポイントは、SQLインジェクション攻撃などのセキュリティ脅威を防ぐために、質問を(どのようにPHPを使用してSQLインジェクション攻撃を防ぐために)、より現実的である、データフィルタリングやクリア入力データを使用して、このようなクエリ内のユーザー入力データを使用する場合は、PHPまたは他のプログラミング言語を使用して、ケースではありませんが、またはより多くの人々によって推奨されるように、現在、SQLインジェクション防止をサポートする任意の他のツールを準備文などの現代的な技術を使用して、これらのツールは、もう利用できないことを考慮してください?どのようにあなたのアプリケーションを保護するのですか?</target>
        </trans-unit>
        <trans-unit id="a2ebdce6e2debca99f4971e3f20fb7e609a0d677" translate="yes" xml:space="preserve">
          <source>Oh, and since you asked about how to do it for an insert, here's an example (using PDO):</source>
          <target state="translated">あ、それと、インサートの場合はどうすればいいのかという質問があったので、ここでは(PDOを使った)例を紹介します。</target>
        </trans-unit>
        <trans-unit id="134949ae0b25999cca22947fe40274275ecfbf40" translate="yes" xml:space="preserve">
          <source>Option #1: Use of Prepared Statements (Parameterized Queries)</source>
          <target state="translated">選択肢1:プリペアド ステートメントの使用 (パラメータ化されたクエリ)</target>
        </trans-unit>
        <trans-unit id="5d2a8213d51185403db055f6aea59f59d1a24bff" translate="yes" xml:space="preserve">
          <source>Option #2: Use of Stored Procedures</source>
          <target state="translated">選択肢2:ストアドプロシージャの使用</target>
        </trans-unit>
        <trans-unit id="ca0c50b92c49801edcf1ea0388797ec4f53add0c" translate="yes" xml:space="preserve">
          <source>Option #3: Escaping all User Supplied Input</source>
          <target state="translated">オプション #3:すべてのユーザ供給入力をエスケープする</target>
        </trans-unit>
        <trans-unit id="1b175495915b9cebd7a4f0c7b63ed399ad461fb6" translate="yes" xml:space="preserve">
          <source>Or there is a slightly better answer that suggests just &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;another method of string formatting&lt;/a&gt; and even boasts it as the ultimate panacea. While of course, it is not. This method is no better than regular string formatting, yet it keeps all its drawbacks: it is applicable to strings only and, like any other manual formatting, it's essentially optional, non-obligatory measure, prone to human error of any sort.</source>
          <target state="translated">または&lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;、文字列の書式設定のもう1つの方法&lt;/a&gt;を示唆し、究極の万能薬としてそれを誇示する少し良い答えがあります 。 もちろん、そうではありません。 この方法は通常の文字列フォーマットと同じですが、すべての欠点を保持しています。文字列にのみ適用でき、他の手動フォーマットと同様に、本質的にオプションであり、義務的ではなく、あらゆる種類の人為的エラーが発生しやすくなります。</target>
        </trans-unit>
        <trans-unit id="f0ded22686c7a01e80dd23bbdd785e9739881413" translate="yes" xml:space="preserve">
          <source>PDO wins this battle with ease. With support for twelve
different database drivers and named parameters, we can ignore the
small performance loss, and get used to its API. From a security
standpoint, both of them are safe as long as the developer uses them
the way they are supposed to be used</source>
          <target state="translated">PDO はこの戦いに簡単に勝利します。12 種類の異なるデータベースドライバと名前付きパラメータをサポートしているので、 パフォーマンスの低下は無視して、その API に慣れることができます。セキュリティの観点から見ても、開発者が想定された方法で使用する限り、どちらも安全です。</target>
        </trans-unit>
        <trans-unit id="54e0d751e792502d244f26c003fbc0168957db96" translate="yes" xml:space="preserve">
          <source>PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">PHPには、これらの攻撃を防ぐために特別に作られた機能があります。 やらなければならないことは、一口の関数 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; を使用することだけです。</target>
        </trans-unit>
        <trans-unit id="ccf9fc49cbe33f37545bdf96ec74793151180cf7" translate="yes" xml:space="preserve">
          <source>Parameterized query AND input validation is the way to go. There are many scenarios under which SQL injection may occur, even though &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; has been used.</source>
          <target state="translated">パラメーター化されたクエリと入力の検証は、進むべき道です。 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; が使用されている場合でも、SQLインジェクションが発生するシナリオは多数あります。</target>
        </trans-unit>
        <trans-unit id="9efa2dbb908a0d252e5cd2661bab4bcef31b8aec" translate="yes" xml:space="preserve">
          <source>Please note that the case you asked about is a fairly simple one and that more complex cases may require more complex approaches. In particular:</source>
          <target state="translated">ご質問のケースはかなりシンプルなもので、複雑なケースほど複雑なアプローチが必要になる場合がありますので、ご注意ください。特に</target>
        </trans-unit>
        <trans-unit id="bcf57ec934b9b4abfe2e011b6d61b8f3fe9b293d" translate="yes" xml:space="preserve">
          <source>Please see this question for more detail: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same result&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">詳細については、この質問を参照してください： &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDOは生のクエリをMySQLに送信し、Mysqliは準備済みクエリを送信します。どちらも同じ結果を生成します。&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="253bf3e933bdeac3a809eb91c495e40d9d61fe9d" translate="yes" xml:space="preserve">
          <source>Primary defenses:</source>
          <target state="translated">一次防御。</target>
        </trans-unit>
        <trans-unit id="d52155a58f068ac65eaa3922fec6c4b67e140457" translate="yes" xml:space="preserve">
          <source>Query for login authentication match:</source>
          <target state="translated">ログイン認証に一致するかどうかのクエリです。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="058114cbca517a731cb958e54ea1701d36b6c3b4" translate="yes" xml:space="preserve">
          <source>Regarding many useful answers, I hope to add some value to this thread.</source>
          <target state="translated">多くの有益な回答について、私はこのスレッドに何らかの価値を付加したいと考えています。</target>
        </trans-unit>
        <trans-unit id="e096b01f49b6da8c19f1bffa18f6d83e4dd4871e" translate="yes" xml:space="preserve">
          <source>Regardless of what PHP manual said for ages, &lt;strong&gt;&lt;code&gt;*_escape_string&lt;/code&gt; by no means makes data safe&lt;/strong&gt; and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong, because it is manual as opposite to automated.</source>
          <target state="translated">PHPマニュアルで古くから言われていることに関係なく、 &lt;strong&gt; &lt;code&gt;*_escape_string&lt;/code&gt; &lt;/strong&gt;は決して&lt;strong&gt;データを安全にするもの&lt;/strong&gt;ではなく、意図されたこともありません。 文字列以外のSQL部分には役に立たないだけでなく、自動エスケープとは対照的に手動エスケープは手動です。</target>
        </trans-unit>
        <trans-unit id="4b26d7b5c670dfa0c5a71f99bb87ebad73afd959" translate="yes" xml:space="preserve">
          <source>SECURITY UPDATE: The previous &lt;code&gt;str_replace&lt;/code&gt; version allowed injections by adding {#} tokens into user data. This &lt;code&gt;preg_replace_callback&lt;/code&gt; version doesn't cause problems if the replacement contains these tokens.</source>
          <target state="translated">セキュリティ更新：以前のバージョンの &lt;code&gt;str_replace&lt;/code&gt; では 、ユーザーデータに{＃}トークンを追加することでインジェクションが可能でした。 この &lt;code&gt;preg_replace_callback&lt;/code&gt; バージョンでは、置換にこれらのトークンが含まれていても問題は発生しません。</target>
        </trans-unit>
        <trans-unit id="2248f755da0797902356c62702fce90dfe90f334" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ce3741372785fc3d1b9e81dc08822e0ee3697b" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = &lt;strong&gt;-1 union all select table_name from information_schema.tables&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = &lt;strong&gt;-1 union all select table_name from information_schema.tables&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2aaa640d6aff57cc99ee7b8f6b262da344d87124" translate="yes" xml:space="preserve">
          <source>SQL Injection</source>
          <target state="translated">SQLインジェクション</target>
        </trans-unit>
        <trans-unit id="aaae6cc0c6e64da88ddbf398d39cff7dd8d70208" translate="yes" xml:space="preserve">
          <source>SQL Injection Cheat Sheet</source>
          <target state="translated">SQLインジェクションチートシート</target>
        </trans-unit>
        <trans-unit id="df8511b36a40094461c2fa8100abbe0ef28e937c" translate="yes" xml:space="preserve">
          <source>SQL injection is an attack that can be done through user inputs (inputs that filled by a user and then used inside queries). The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, and we assume that there might be a bad person that try to get secret information (bypassing access control) that affect the three principles of security (confidentiality, integrity, and availability).</source>
          <target state="translated">SQLインジェクションは、ユーザーの入力(ユーザーが入力して、クエリの内部で使用される入力)を介して行うことができる攻撃です。SQLインジェクションのパターンは、我々はそれを呼び出すことができますが、正しいクエリの構文です:悪い理由のために悪いクエリ、我々は、セキュリティの3つの原則(機密性、整合性、可用性)に影響を与える秘密情報(アクセス制御をバイパス)を取得しようとする悪い人があるかもしれないと仮定しています。</target>
        </trans-unit>
        <trans-unit id="4c18831b8c7d74dba4d4cf532d188cd34482c6be" translate="yes" xml:space="preserve">
          <source>SQL user (limiting user privilege): most common SQL operations are (SELECT, UPDATE, INSERT), then, why give the UPDATE privilege to a user that does not require it? For example, &lt;strong&gt;login, and search pages&lt;/strong&gt; are only using SELECT, then, why use DB users in these pages with high privileges?</source>
          <target state="translated">SQLユーザー（ユーザー特権の制限）：最も一般的なSQL操作は（SELECT、UPDATE、INSERT）ですが、なぜそれを必要としないユーザーにUPDATE特権を与えるのでしょうか。 たとえば、 &lt;strong&gt;ログインページと検索ページで&lt;/strong&gt; SELECTのみを使用しているのに、これらのページで高い特権でDBユーザーを使用するのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="3c9750d49c83fa8a5b3a0075cee19045e8360352" translate="yes" xml:space="preserve">
          <source>Security Principles</source>
          <target state="translated">セキュリティ原則</target>
        </trans-unit>
        <trans-unit id="8a0ff19685c3593d2dd9348235796673a86f433d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;最小特権の原則を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3bc5aad5e191c67a30c0d326b34a9e4894a1fec3" translate="yes" xml:space="preserve">
          <source>See also, the details of the &lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt;&lt;code&gt;mysql_real_escape_string&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt; &lt;code&gt;mysql_real_escape_string&lt;/code&gt; &lt;/a&gt;関数の詳細もご覧ください。</target>
        </trans-unit>
        <trans-unit id="be33bd1eb7dbd848bc959ced6f1d33144f31d5c8" translate="yes" xml:space="preserve">
          <source>So if you use a prepared statement, you must specify the types of the variables for &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; function.</source>
          <target state="translated">したがって、準備済みステートメントを使用する場合は、 &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; 関数の変数のタイプを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="7791c9096ecb3c52f38cfacf2ed5a600ac8ac03b" translate="yes" xml:space="preserve">
          <source>So, a general recommendation may be phrased as</source>
          <target state="translated">そのため、一般的な推奨事項は次のように言い換えることができます。</target>
        </trans-unit>
        <trans-unit id="5b4eb875965dcbc46634a834943ce8fb7d495d10" translate="yes" xml:space="preserve">
          <source>So, for example, the query:</source>
          <target state="translated">なので、例えば、クエリ</target>
        </trans-unit>
        <trans-unit id="cfd8f629333fbfac1be3ab64cdcec4377eaa444d" translate="yes" xml:space="preserve">
          <source>So, unlike whatever &quot;escaping&quot;, prepared statements &lt;em&gt;is&lt;/em&gt; the measure that indeed protects from SQL injection (when applicable).</source>
          <target state="translated">したがって、「エスケープ」するものとは異なり、準備されたステートメント&lt;em&gt;は&lt;/em&gt; 、SQLインジェクション（該当する場合）から実際に保護する手段です。</target>
        </trans-unit>
        <trans-unit id="bdd6c788b4bc40941d92c120767a09a678ddf541" translate="yes" xml:space="preserve">
          <source>Still, there is an issue with SQL syntax keywords (such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and such), but white-listing seems the only approach in this case.</source>
          <target state="translated">それでも、SQL構文キーワード（ &lt;code&gt;AND&lt;/code&gt; や &lt;code&gt;DESC&lt;/code&gt; など）には問題がありますが、この場合はホワイトリストが唯一のアプローチのようです。</target>
        </trans-unit>
        <trans-unit id="25fe63edd9746e4a688d1d2796a06118495eb155" translate="yes" xml:space="preserve">
          <source>That's because the user can input something like &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt;, and the query becomes:</source>
          <target state="translated">これは、ユーザーが &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt; ようなものを入力できるためです '）; DROP TABLE table;- 、クエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ea6f46a1818ef256a65fd25fce4ef5438834b53d" translate="yes" xml:space="preserve">
          <source>The ** 0x** prefix can only be used for data columns such as &lt;strong&gt;char, varchar, text, block, binary, etc&lt;/strong&gt;.</source>
          <target state="translated">** 0x **プレフィックスは、 &lt;strong&gt;char、varchar、text、block、binary&lt;/strong&gt;などのデータ列にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="22493fd5585b849e0dfac158f0d91d71de2a9f53" translate="yes" xml:space="preserve">
          <source>The SQL statement you pass to &lt;code&gt;prepare&lt;/code&gt; is parsed and compiled by the database server. By specifying parameters (either a &lt;code&gt;?&lt;/code&gt; or a named parameter like &lt;code&gt;:name&lt;/code&gt; in the example above) you tell the database engine where you want to filter on. Then when you call &lt;code&gt;execute&lt;/code&gt;, the prepared statement is combined with the parameter values you specify.</source>
          <target state="translated">&lt;code&gt;prepare&lt;/code&gt; 渡すSQL文は、データベースサーバーによって解析およびコンパイルされます。 パラメーター（ &lt;code&gt;?&lt;/code&gt; または上記の例の &lt;code&gt;:name&lt;/code&gt; のような名前付きパラメーター）を指定することにより、フィルター処理する場所をデータベースエンジンに指示します。 次に、 &lt;code&gt;execute&lt;/code&gt; を呼び出すと、準備されたステートメントが指定したパラメーター値と結合されます。</target>
        </trans-unit>
        <trans-unit id="220daddb11e24bc5b6c1d64820ad3b7f7ddb93fa" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes
  considered a security feature to prevent SQL injection. The same
  degree of security can be achieved with non-prepared statements if
  input values are escaped correctly.</source>
          <target state="translated">サーバー内での値の自動エスケープは、SQLインジェクションを防ぐためのセキュリティ機能と考えられることがあります。入力値が正しくエスケープされていれば、準備されていないステートメントでも同じ程度のセキュリティを達成することができます。</target>
        </trans-unit>
        <trans-unit id="8e19049bf34dbc02fad22f1e2a94559fad21acf0" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly</source>
          <target state="translated">サーバー内での値の自動エスケープは、SQLインジェクションを防ぐためのセキュリティ機能と考えられることがあります。入力値が正しくエスケープされていれば、準備されていない文でも同じ程度のセキュリティを達成することができます。</target>
        </trans-unit>
        <trans-unit id="fdf65f1abe7fe4e3d2342b41af2f1116791c2af6" translate="yes" xml:space="preserve">
          <source>The best way to prevent SQL Injection is to use &lt;strong&gt;Prepared Statements&lt;/strong&gt;&lt;em&gt;instead of escaping&lt;/em&gt;, as &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;the accepted answer&lt;/a&gt; demonstrates.</source>
          <target state="translated">SQLインジェクションを防ぐ最善の方法は&lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;、受け入れられた回答が&lt;/a&gt;示すように、 &lt;em&gt;エスケープする代わりに&lt;/em&gt; &lt;strong&gt;プリペアドステートメント&lt;/strong&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="7cc7e03df37b2e8c386abd1ebf523f1b7f2477d6" translate="yes" xml:space="preserve">
          <source>The disadvantages are -</source>
          <target state="translated">デメリットは-。</target>
        </trans-unit>
        <trans-unit id="b02e13a130f7a3159e0982874d64e46b658e4a3d" translate="yes" xml:space="preserve">
          <source>The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn't intend.</source>
          <target state="translated">ここで重要なのは、パラメータ値がSQL文字列ではなく、コンパイルされた文と結合されていることです。SQLインジェクションは、スクリプトがデータベースに送信するSQLを作成する際に悪意のある文字列を含むようにスクリプトを騙すことで動作します。そのため、実際のSQLをパラメータとは別に送信することで、意図しない結果になるリスクを抑えることができます。</target>
        </trans-unit>
        <trans-unit id="f2ce25b2d0b72f92570aaba8ea168300f90b408b" translate="yes" xml:space="preserve">
          <source>The key function you'll want to read up on there would be &lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt;&lt;code&gt;mysqli::prepare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ここで読みたい主要な関数は&lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt; &lt;code&gt;mysqli::prepare&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="8329b222e736716b29e6f8c8d1bf0eb05508d581" translate="yes" xml:space="preserve">
          <source>The last point is detecting unexpected behavior which requires more effort and complexity; it's not recommended for normal web applications.</source>
          <target state="translated">最後のポイントは、より多くの労力と複雑さを必要とする予期せぬ動作を検出することです。</target>
        </trans-unit>
        <trans-unit id="ec2ec032df8d4e54047d67def864e600f72c7368" translate="yes" xml:space="preserve">
          <source>The most advanced way is to use PDOs.</source>
          <target state="translated">最も先進的な方法は、PDOを使用することです。</target>
        </trans-unit>
        <trans-unit id="77a019a8e37c861117253efcafbe8b46c80d55cb" translate="yes" xml:space="preserve">
          <source>The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to log in as administrator without having his/her password. Now, he/she can do anything that the administrator/email person can do. See, it's very dangerous if SQL injection is not prevented.</source>
          <target state="translated">他の部分は捨てられてしまいます。では、どうなるのでしょうか?権限のないユーザ(ハッカー)がパスワードを持たずに管理者としてログインできるようになります。これで、管理者メールの人ができることは何でもできるようになります。見ての通り、SQLインジェクションを防がないと非常に危険です。</target>
        </trans-unit>
        <trans-unit id="caef473bbc5d786e58c45a04c732b8e95dae8488" translate="yes" xml:space="preserve">
          <source>The query will be parsed into the system only up to:</source>
          <target state="translated">クエリはシステムまでしか解析されません。</target>
        </trans-unit>
        <trans-unit id="0600942d37431f06a2041faca7c57369364ca714" translate="yes" xml:space="preserve">
          <source>The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.
For example: if you are using a MySQL database then enter into the database through terminal or the UI provided and just follow this command:</source>
          <target state="translated">この問題の簡単な代替案は、データベース自体に適切な権限を与えることで解決できます。例えば、MySQLデータベースを使用している場合は、ターミナルまたはUIからデータベースに入り、以下のコマンドに従ってください。</target>
        </trans-unit>
        <trans-unit id="49869c7c4ee5782157501a3f5be9f08cda113757" translate="yes" xml:space="preserve">
          <source>There are libraries such as &lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt; and &lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt; that allow developers to use prepared statements easier. To learn more about why prepared statements are better at &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;stopping SQL injection&lt;/a&gt;, refer to &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;this &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; bypass&lt;/a&gt; and &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;recently fixed Unicode SQL Injection vulnerabilities in WordPress&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt;や&lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt;などのライブラリがあり、開発者は準備済みステートメントをより簡単に使用できます。 準備されたステートメントが&lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;SQLインジェクションの停止に&lt;/a&gt;優れている理由の詳細については、 &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;この &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; バイパス&lt;/a&gt;と&lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;、WordPressで最近修正されたUnicode SQLインジェクションの脆弱性を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c789aef75c0a5b094c0f29903ad99459e880351c" translate="yes" xml:space="preserve">
          <source>There are likely other cases I'm not aware of. You might find &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;this&lt;/a&gt; is a useful resource on some of the more subtle problems you can encounter.</source>
          <target state="translated">私が気づいていない他のケースがおそらくあります。 &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;これ&lt;/a&gt;は、遭遇する可能性のある微妙な問題のいくつかに関する有用なリソースである場合があります。</target>
        </trans-unit>
        <trans-unit id="780ecc400391203ddd8ddd799d6ab422887cada5" translate="yes" xml:space="preserve">
          <source>There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course &lt;strong&gt;PDO is one of the good solutions.&lt;/strong&gt; But I would like to suggest you some good links prevention from SQL injection.</source>
          <target state="translated">SQLインジェクションやその他のSQLハッキングを防ぐ方法はたくさんあります。 インターネット（Google検索）で簡単に見つけることができます。 もちろん、 &lt;strong&gt;PDOは優れたソリューションの1つです。&lt;/strong&gt; しかし、SQLインジェクションからのいくつかの良いリンク防止を提案したいと思います。</target>
        </trans-unit>
        <trans-unit id="218c170e6057412489f970c39cfe283ca621a4f8" translate="yes" xml:space="preserve">
          <source>There are more abilities to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also, it would be better to use these functions to check input data.</source>
          <target state="translated">これを防ぐためにはもっと多くの機能があります:例えば、識別-入力が文字列、数値、文字、配列の場合、これを検出するための非常に多くの関数が組み込まれています。また、これらの関数を使って入力データをチェックするのも良いでしょう。</target>
        </trans-unit>
        <trans-unit id="830b53ae56caf2de4b110b5e5e28b176692222da" translate="yes" xml:space="preserve">
          <source>There are so many answers for &lt;strong&gt;PHP and MySQL&lt;/strong&gt;, but here is code for &lt;strong&gt;PHP and Oracle&lt;/strong&gt; for preventing SQL injection as well as regular use of oci8 drivers:</source>
          <target state="translated">&lt;strong&gt;PHPとMySQL&lt;/strong&gt;には非常に多くの答えが&lt;strong&gt;ありますが&lt;/strong&gt; 、SQLインジェクションとoci8ドライバーの定期的な使用を防ぐための&lt;strong&gt;PHPとOracleの&lt;/strong&gt;コードを次に示します。</target>
        </trans-unit>
        <trans-unit id="df8b9e7a092d7b299097fd0d02efb87caa3a7f13" translate="yes" xml:space="preserve">
          <source>There is another way to secure identifiers - escaping but I rather stick to whitelisting as a more robust and explicit approach. Yet as long as you have an identifier quoted, you can escape the quote character to make it safe. For example, by default for mysql you have to &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;double the quote character to escape it&lt;/a&gt;. For other other DBMS escaping rules would be different.</source>
          <target state="translated">識別子を保護する別の方法があります-エスケープしますが、より堅牢で明示的なアプローチとして、ホワイトリストに固執します。 ただし、識別子を引用符で囲んでいる限り、引用符をエスケープして安全にすることができます。 たとえば、mysqlのデフォルトで&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;は、引用符文字を二重にエスケープする必要があり&lt;/a&gt;ます。 他のDBMSでは、エスケープルールは異なります。</target>
        </trans-unit>
        <trans-unit id="f884dfef89c26e94f34c8d0d17a3e45bfbc8acd8" translate="yes" xml:space="preserve">
          <source>There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:</source>
          <target state="translated">コメントでも議論があったので、最後にはっきりさせておきたいと思います。この2つのアプローチは非常に似ていますが、少し違う部分もあります。</target>
        </trans-unit>
        <trans-unit id="224c361000365c82c6c9b9f7d7a6ec856e58482b" translate="yes" xml:space="preserve">
          <source>Therefore, this proves that data validation such as &lt;code&gt;intval()&lt;/code&gt; is a good idea for integer values before sending any query. In addition, preventing malicious user data before sending the query is &lt;strong&gt;a correct and valid approach&lt;/strong&gt;.</source>
          <target state="translated">したがって、これは、 &lt;code&gt;intval()&lt;/code&gt; などのデータ検証が、クエリを送信する前の整数値に適していることを証明します。 さらに、クエリを送信する前に悪意のあるユーザーデータを防ぐことは&lt;strong&gt;、正しい有効なアプローチ&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="82972fc3059a1c85c5e906a0ee53efee54cb0064" translate="yes" xml:space="preserve">
          <source>They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.</source>
          <target state="translated">それら(ストアドプロシージャ)は維持するのが難しく、非常に早く増殖する傾向があります。そのため、それらの管理が問題となります。</target>
        </trans-unit>
        <trans-unit id="9db87902986489638b3a9991da4a7a39a2f10d0c" translate="yes" xml:space="preserve">
          <source>They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.</source>
          <target state="translated">アプリケーションから生の SQL クエリを抽象化するので、アプリケーションが利用できるデータベース構造の情報が少なくなります。これにより、データベースの基本的な構造を理解し、適切な攻撃を設計することが難しくなります。</target>
        </trans-unit>
        <trans-unit id="63f9a45d5192235d9d02af20e18d0355ff4d3bbe" translate="yes" xml:space="preserve">
          <source>They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.</source>
          <target state="translated">パラメータのみを受け付けるので、パラメータ化されたクエリの利点があります。もちろん、特にストアドプロシージャの中で動的SQLを使用している場合は、入力をサニタイズする必要があります。</target>
        </trans-unit>
        <trans-unit id="da88560285c94420f786914a9987bc73dbdb490a" translate="yes" xml:space="preserve">
          <source>They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.</source>
          <target state="translated">動的なクエリにはあまり適していません。動的なコードをパラメータとして受け入れるように作られている場合、多くの利点が否定されてしまいます。</target>
        </trans-unit>
        <trans-unit id="a718b71211da4fde3996aa73a97cdfec744e2e31" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLiの&lt;/a&gt;学習について考える</target>
        </trans-unit>
        <trans-unit id="4bc28bb81fa5e19dbc4f90b70f46fd3864b30aac" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) &amp;ndash; it is a database access layer providing a uniform method of access to multiple databases.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; （PHP Data Objects）の学習について考えてください。これは、複数のデータベースへのアクセスの統一された方法を提供するデータベースアクセスレイヤーです。</target>
        </trans-unit>
        <trans-unit id="b269ba0fd879f3932b2b527ca85caeb00cf5ba6e" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;question&lt;/a&gt; has some good answers about this.</source>
          <target state="translated">この&lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;質問に&lt;/a&gt;は、これについていくつかの良い答えがあります。</target>
        </trans-unit>
        <trans-unit id="92ad37abc91646ccd8977cbbc7608b0efd79be0e" translate="yes" xml:space="preserve">
          <source>This allows running statements in an one-liner C#-ish String.Format like:</source>
          <target state="translated">これにより、ステートメントをC#風のString.Formatのような1行で実行することができます。</target>
        </trans-unit>
        <trans-unit id="d422b5f7b27e73794ff7c5132ab85405bcfe5b91" translate="yes" xml:space="preserve">
          <source>This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with &lt;code&gt;0x&lt;/code&gt; or use the MySQL function &lt;code&gt;UNHEX&lt;/code&gt; instead.</source>
          <target state="translated">この16進数の方法は、バイナリデータを転送するときによく使用されますが、SQLインジェクション攻撃を防ぐためにすべてのデータで使用しない理由はわかりません。 データの &lt;code&gt;UNHEX&lt;/code&gt; に &lt;code&gt;0x&lt;/code&gt; を 付けるか、代わりにMySQL関数UNHEXを使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="10c3b317d4690df3f686ef3a89e96ef8591796f2" translate="yes" xml:space="preserve">
          <source>This input can be checked early without any prepared statement and stored procedures, but to be on the safe side, using them starts after user-data filtering and validation.</source>
          <target state="translated">この入力は、準備されたステートメントやストアドプロシージャがなくても早期にチェックすることができますが、安全のためには、ユーザーデータのフィルタリングとバリデーションの後に使用を開始します。</target>
        </trans-unit>
        <trans-unit id="93f5c7f0ce17d7d18825ad4c94168610dc65618a" translate="yes" xml:space="preserve">
          <source>This will restrict the user to only get confined with the specified query's only. Remove the delete permission and so the data would never get deleted from the query fired from the PHP page.
The second thing to do is to flush the privileges so that the MySQL refreshes the permissions and updates.</source>
          <target state="translated">これは、ユーザーが指定されたクエリのみに限定されるように制限されます。削除権限を削除すると、データはPHPページから発射されたクエリから削除されることはありませんので。MySQLは、権限と更新を更新するように権限をフラッシュすることです。</target>
        </trans-unit>
        <trans-unit id="fff7386dc03b73f854a16a474ef2b8c2fda58dc3" translate="yes" xml:space="preserve">
          <source>This won't solve every problem, but it's a very good stepping stone. I left out obvious items such as checking the variable's existence, format (numbers, letters, etc.).</source>
          <target state="translated">これで全ての問題が解決するわけではありませんが、非常に良い足がかりになります。変数の存在を確認したり、フォーマット(数字や文字など)を確認したりと、明らかな項目は省きました。</target>
        </trans-unit>
        <trans-unit id="16c9cc86f82e3a7c1ca1d9b3739a49f6e61d2e8e" translate="yes" xml:space="preserve">
          <source>Those examples are vulnerable to SQL injection:</source>
          <target state="translated">これらの例はSQLインジェクションに対して脆弱です。</target>
        </trans-unit>
        <trans-unit id="8789487a1a2a5eb11f2a7cfa438ec136c375dc71" translate="yes" xml:space="preserve">
          <source>To ease the process I wrote a &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;whitelist helper function&lt;/a&gt; that does all the job in one line:</source>
          <target state="translated">プロセスを簡単にするために、すべての作業を1行で行う&lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;ホワイトリストヘルパー関数&lt;/a&gt;を作成しました。</target>
        </trans-unit>
        <trans-unit id="fa14c04c76de2e2fab6840f10e0b4d476494ed7a" translate="yes" xml:space="preserve">
          <source>To see the current privileges for the user fire the following query.</source>
          <target state="translated">ユーザーの現在の権限を確認するには、以下のクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="b6cd0f951a947782e4aa09afbcf7e67bd3612b70" translate="yes" xml:space="preserve">
          <source>To use the parameterized query, you need to use &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; rather than the &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt; functions. To rewrite your example, we would need something like the following.</source>
          <target state="translated">パラメータ化されたクエリを使用するには、 &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt;関数ではなく&lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt;を使用する必要があります。 例を書き直すには、次のようなものが必要です。</target>
        </trans-unit>
        <trans-unit id="92ea56f2bcd611121ebf82d1bb94be8a12add9bd" translate="yes" xml:space="preserve">
          <source>UPDATE 1:</source>
          <target state="translated">UPDATE 1.</target>
        </trans-unit>
        <trans-unit id="f1e7ccfb017f1e9286a26f4401498e961fa8566b" translate="yes" xml:space="preserve">
          <source>Unexpected behavior in the above user input is SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, and root. Once these words detected, you can avoid the input.</source>
          <target state="translated">上記のユーザ入力における予期せぬ動作は、SELECT、UNION、IF、SUBSTRING、BENCHMARK、SHA、ROOTです。これらの単語が検出されれば、入力を回避することができます。</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="58b2e2813f252bd73c0a240fc752d08e7de81f2b" translate="yes" xml:space="preserve">
          <source>Update 2:</source>
          <target state="translated">更新2.</target>
        </trans-unit>
        <trans-unit id="ab598eb253cb41b46f92f26312a455cadea5aee1" translate="yes" xml:space="preserve">
          <source>Update 3:</source>
          <target state="translated">更新3.</target>
        </trans-unit>
        <trans-unit id="a097c6d2f311ec0bb34ee1571b93398b7da217e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;PDO&lt;/code&gt; and prepared queries.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; と準備されたクエリを使用します。</target>
        </trans-unit>
        <trans-unit id="536e4e3355286cdf5ee35d48911488b38952ca82" translate="yes" xml:space="preserve">
          <source>Use native PHP functions like: &lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt;, &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string&lt;/a&gt; or if variable numeric, just &lt;code&gt;(int)$foo&lt;/code&gt;. Read more about type of variables in PHP &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;here&lt;/a&gt;. If you're using libraries such as PDO or MySQLi, always use &lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO::quote()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt; 、 &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_stringの&lt;/a&gt;ようなネイティブのPHP関数を使用します。変数が数値の場合は &lt;code&gt;(int)$foo&lt;/code&gt; だけを使用します。 PHPの変数の型について詳しくは、 &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;こちらをご覧ください&lt;/a&gt; 。 PDOやMySQLiなどのライブラリを使用している場合は、常に&lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO :: quote（）&lt;/a&gt;および&lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string（）を使用してください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="d38f5f0dc278ebfe3743f0e9d9ad122b9d88ce8f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;, which is a pre-defined function in &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;, and this code add backslashes to the following characters: &lt;code&gt;\x00&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\x1a&lt;/code&gt;. Pass the input values as parameters to minimize the chance of SQL injection.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;で事前定義された関数である &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; の使用と、このコードは、 &lt;code&gt;\x00&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;'&lt;/code&gt; 、 &lt;code&gt;&quot;&lt;/code&gt; 、および &lt;code&gt;\x1a&lt;/code&gt; バックスラッシュを追加します。入力値をパラメーターとして渡しますSQLインジェクションの可能性を最小限に抑えるため。</target>
        </trans-unit>
        <trans-unit id="56d170f163928a8c1fff4954924527fa155e8ca3" translate="yes" xml:space="preserve">
          <source>Use other tools: Here, I will also agree with you that a prepared statement (parametrized query) and stored procedures. The disadvantages here is these ways require advanced skills which do not exist for most users. The basic idea here is to distinguish between the SQL query and the data that is used inside. Both approaches can be used even with unsafe data, because the user-input data here does not add anything to the original query, such as (any or x=x).</source>
          <target state="translated">他のツールを使う。ここでは、準備された文(パラメトリッククエリ)とストアドプロシージャにも同意します。ここでの欠点は、これらの方法は、ほとんどのユーザーのために存在しない高度なスキルを必要とすることです。ここでの基本的な考え方は、SQLクエリと内部で使用されるデータを区別することです。どちらの方法も、安全でないデータでも使用できます。なぜなら、ここでのユーザ入力データは、(anyやx=x)のように、元のクエリに何も追加しないからです。</target>
        </trans-unit>
        <trans-unit id="2ab1b2c4d270d99ef373efcd0f8b8574c802370d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt; is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to use</source>
          <target state="translated">&lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt;と&lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt;を使用することは、SQLインジェクションを防ぐための良い方法ですが、MySQLの関数とクエリを実際に使用したい場合は、</target>
        </trans-unit>
        <trans-unit id="38c0c660c5df9571196ca554badedbf16ace904b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; (for MySQL):</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; （MySQLの場合）の使用：</target>
        </trans-unit>
        <trans-unit id="a4e7bd1b02d3303b9bd6d557965df01c324c3557" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (for any supported database driver):</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDOの&lt;/a&gt;使用（サポートされているデータベースドライバーの場合）：</target>
        </trans-unit>
        <trans-unit id="64fd160974da8c9008dad32fa19315d8009920f4" translate="yes" xml:space="preserve">
          <source>Using this PHP function &lt;code&gt;mysql_escape_string()&lt;/code&gt; you can get a good prevention in a fast way.</source>
          <target state="translated">このPHP関数 &lt;code&gt;mysql_escape_string()&lt;/code&gt; を使用すると、適切な方法で迅速に防止できます。</target>
        </trans-unit>
        <trans-unit id="0d3a08ce38eb2066c704c7481d4b7d5c8f7699f5" translate="yes" xml:space="preserve">
          <source>We'll cover the lower impact string escaping one first.</source>
          <target state="translated">まずは下段のインパクトのあるストリングが1つ逃げているところをカバーします。</target>
        </trans-unit>
        <trans-unit id="b0ca7362248cae31401c4742155c18ebaa5ff23d" translate="yes" xml:space="preserve">
          <source>What can be done to prevent this from happening?</source>
          <target state="translated">そうならないためにはどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4ec900e30a04771ad57031ac632ba224fe5ec06c" translate="yes" xml:space="preserve">
          <source>What is &lt;strong&gt;mandatory&lt;/strong&gt;, however, is the first &lt;code&gt;setAttribute()&lt;/code&gt; line, which tells PDO to disable emulated prepared statements and use &lt;em&gt;real&lt;/em&gt; prepared statements. This makes sure the statement and the values aren't parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).</source>
          <target state="translated">ただし、 &lt;strong&gt;必須&lt;/strong&gt;であるのは、最初の &lt;code&gt;setAttribute()&lt;/code&gt; 行です。これは、エミュレートされた準備済みステートメントを無効にし、 &lt;em&gt;実際の&lt;/em&gt;準備済みステートメントを使用するようにPDOに指示します。 これにより、ステートメントと値がMySQLサーバーに送信される前にPHPによって解析されないようになります（攻撃者に悪意のあるSQLを挿入する機会を与えません）。</target>
        </trans-unit>
        <trans-unit id="4a061bb9449a7869b1bb6c140f6c244c24e19160" translate="yes" xml:space="preserve">
          <source>Whatever you do end up using, make sure that you check your input hasn't already been mangled by &lt;code&gt;magic_quotes&lt;/code&gt; or some other well-meaning rubbish, and if necessary, run it through &lt;code&gt;stripslashes&lt;/code&gt; or whatever to sanitize it.</source>
          <target state="translated">最終的に何を使用する場合でも、入力が &lt;code&gt;magic_quotes&lt;/code&gt; やその他の意味のあるゴミによって既に破壊されていないことを確認し、必要に応じて、 &lt;code&gt;stripslashes&lt;/code&gt; などを実行してサニタイズします。</target>
        </trans-unit>
        <trans-unit id="00f02bbdebbfdbc228c8163a6409202a17282e4d" translate="yes" xml:space="preserve">
          <source>While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.</source>
          <target state="translated">クエリパラメータに準備された文を使用することはできますが、動的クエリの構造自体をパラメトリック化することはできず、特定のクエリ機能をパラメトリック化することはできません。</target>
        </trans-unit>
        <trans-unit id="1ac6d9646522fe48ad32b3fffb2a4692cff0ee0f" translate="yes" xml:space="preserve">
          <source>Will become:</source>
          <target state="translated">そうなるだろう。</target>
        </trans-unit>
        <trans-unit id="204b32dc579f45400949999976e4e7bd02995817" translate="yes" xml:space="preserve">
          <source>You basically have two options to achieve this:</source>
          <target state="translated">基本的には2つの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="ec00a1df9d6128980fc27b80f095461babcb7153" translate="yes" xml:space="preserve">
          <source>You can find more details in &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL - SQL Injection Prevention&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">詳細については、 &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL-SQLインジェクション防止を&lt;/a&gt;&lt;/em&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="b865044a62cd48efbfda9b53b850310ecec07a85" translate="yes" xml:space="preserve">
          <source>You could do something basic like this:</source>
          <target state="translated">こんな感じで基本的なことができます。</target>
        </trans-unit>
        <trans-unit id="0cff3e61f8aade5ced706b23961eeb5d59ba96ea" translate="yes" xml:space="preserve">
          <source>You've got two options - escaping the special characters in your &lt;code&gt;unsafe_variable&lt;/code&gt;, or using a parameterized query. Both would protect you from SQL injection. The parameterized query is considered the better practice but will require changing to a newer MySQL extension in PHP before you can use it.</source>
          <target state="translated">&lt;code&gt;unsafe_variable&lt;/code&gt; で特殊文字をエスケープする方法と、パラメーター化されたクエリを使用する方法の2つがあります。 どちらもSQLインジェクションから保護します。 パラメータ化されたクエリはより良いプラクティスと考えられていますが、使用する前にPHPで新しいMySQL拡張に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">すうすう</target>
        </trans-unit>
        <trans-unit id="555d01e6c83266b3e9f92bd811905370caf62770" translate="yes" xml:space="preserve">
          <source>a string</source>
          <target state="translated">一列</target>
        </trans-unit>
        <trans-unit id="5bb5bc166d482477e7f41c8996346a70df7264aa" translate="yes" xml:space="preserve">
          <source>a syntax keyword</source>
          <target state="translated">構文キーワード</target>
        </trans-unit>
        <trans-unit id="415dd55dd005527a8b6d386ea933f1cb842449b8" translate="yes" xml:space="preserve">
          <source>an attack can inject you very &lt;em&gt;easily&lt;/em&gt;. Consider the following injected code returned from your script:</source>
          <target state="translated">攻撃は非常に&lt;em&gt;簡単に&lt;/em&gt;あなたを注入することができます。 スクリプトから返された次の挿入されたコードについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="eb4952e764d7c270f5b65eab412865f0e3d1e28d" translate="yes" xml:space="preserve">
          <source>an identifier</source>
          <target state="translated">識別子</target>
        </trans-unit>
        <trans-unit id="e371325eaf8cf1513b8fb5c935edacb07019dc53" translate="yes" xml:space="preserve">
          <source>and now just extract table structure:</source>
          <target state="translated">そして今はテーブル構造を抽出するだけです。</target>
        </trans-unit>
        <trans-unit id="00a568b3ade5326f00d2f75efc890a8fa7d228a0" translate="yes" xml:space="preserve">
          <source>and password anything....</source>
          <target state="translated">とパスワードは何でもいいのですが...。</target>
        </trans-unit>
        <trans-unit id="dcdc68162ecd47207ad2d4500cb7f65ba1b2f599" translate="yes" xml:space="preserve">
          <source>is_numeric</source>
          <target state="translated">is_numeric</target>
        </trans-unit>
        <trans-unit id="b32f9e192cce5e6c514823660d6fc173cb3dd500" translate="yes" xml:space="preserve">
          <source>is_string</source>
          <target state="translated">is_string</target>
        </trans-unit>
        <trans-unit id="77064c82097c6f5dee58b4d6d530b90e598c4da1" translate="yes" xml:space="preserve">
          <source>more information about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;flush&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;フラッシュ&lt;/a&gt;に関する詳細。</target>
        </trans-unit>
        <trans-unit id="71d20c07a9f068a85df7519fb5b1a4e4eecf531f" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string</source>
          <target state="translated">mysql_real_escape_string</target>
        </trans-unit>
        <trans-unit id="6ccd64ba549314b5da86aaa89a6184349dcc2710" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string() will not protect here. If you use single quotes (' ') around your variables inside your query is what protects you against this. Here is an solution below for this:</source>
          <target state="translated">mysql_real_escape_string()はここを保護しません。あなたのクエリ内の変数の周りに単一引用符(' ')を使用している場合は、これに対してあなたを保護するものです。これに対する解決策を以下に示します。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
