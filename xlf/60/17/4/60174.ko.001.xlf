<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/60174">
    <body>
      <group id="60174">
        <trans-unit id="28db4e540747091b7a00b15b115a95e87c6fb18f" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;$conn&lt;/code&gt; is a &lt;code&gt;PDO&lt;/code&gt; object)</source>
          <target state="translated">( &lt;code&gt;$conn&lt;/code&gt; 은 &lt;code&gt;PDO&lt;/code&gt; 객체입니다)</target>
        </trans-unit>
        <trans-unit id="7df4be97ec047ed1a29912298ea3b0fcbc7ed380" translate="yes" xml:space="preserve">
          <source>--- &lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">--- &lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="566ea8d89155c02c58ff63984dcd175883a55e5f" translate="yes" xml:space="preserve">
          <source>---- &lt;strong&gt;PDO&lt;/strong&gt;</source>
          <target state="translated">---- &lt;strong&gt;PDO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="16d6eec24d215237193fd125401ea3f72038ce7c" translate="yes" xml:space="preserve">
          <source>----- Named placeholders</source>
          <target state="translated">----- 명명 된 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="6f87ec96d5b86996a40f5259f92fc7fad65ced43" translate="yes" xml:space="preserve">
          <source>----- No placeholders - ripe for SQL injection! &lt;strong&gt;It's bad&lt;/strong&gt;</source>
          <target state="translated">----- 자리 표시 자 없음-SQL 주입에 적합합니다! &lt;strong&gt;그것은 나쁜&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9fcff74f12914fdb8c051ea2e336776fd176f90" translate="yes" xml:space="preserve">
          <source>----- Unnamed placeholders</source>
          <target state="translated">----- 이름이없는 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="c8f539c5cc020994d7d2752bb0266689882010b0" translate="yes" xml:space="preserve">
          <source>// Connect to MySQL</source>
          <target state="translated">// MySQL에 연결</target>
        </trans-unit>
        <trans-unit id="210d7dde35cddea92280995918b6bfd938945cd2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;Source&lt;/a&gt;: &lt;em&gt;The Unexpected SQL Injection (When Escaping Is Not Enough)&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.webappsec.org/projects/articles/091007.txt&quot;&gt;출처&lt;/a&gt; : &lt;em&gt;예기치 않은 SQL 주입 (이스케이프가 충분하지 않은 경우)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fafbba6ac674ca8233b3bb137474220f54670c01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash; Escapes a string for use in a mysql_query</source>
          <target state="translated">&lt;code&gt;mysql_escape_string&lt;/code&gt; &amp;mdash; mysql_query에서 사용하기 위해 문자열을 이스케이프</target>
        </trans-unit>
        <trans-unit id="2acf2cfec503ef763160d951705f3dcc3dbb00be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; is deprecated as of PHP 5.5.0. Use either mysqli or PDO.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 은 PHP 5.5.0부터 더 이상 사용되지 않습니다. mysqli 또는 PDO를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac2812cda025d0222eb136ebe05af667375a9255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_real_escape_string&lt;/code&gt; takes a string that is going to be used in a MySQL query and return the same string with all SQL injection attempts safely escaped. Basically, it will replace those troublesome quotes(') a user might enter with a MySQL-safe substitute, an escaped quote \'.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string&lt;/code&gt; 은 MySQL 쿼리에서 사용될 문자열을 취하고 모든 SQL 주입 시도가 안전하게 이스케이프 된 동일한 문자열을 반환합니다. 기본적으로 사용자가 입력 할 수있는 귀찮은 따옴표 ( ')를 MySQL 안전 대체 문자 인 이스케이프 따옴표 \'로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="993cce94e6973d25742799e350d687c6d47eb565" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;What is SQL injection and how to prevent&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;SQL 주입이란 무엇이며 방지하는 방법&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eedc1ef7aa89311e0fab1b48d2dbf4f551aa710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;Microsoft explanation of SQL injection and prevention in PHP&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-gb/archive/blogs/brian_swan/whats-the-right-way-to-prevent-sql-injection-in-php-scripts&quot;&gt;PHP에서의 SQL 삽입 및 예방에 대한 Microsoft 설명&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f09a2090f97db4e53860ae5ab475445cb9ea655d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;PHP manual for SQL injection&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://php.net/manual/en/security.database.sql-injection.php&quot;&gt;SQL 주입을위한 PHP 매뉴얼&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12b6995e63bfc6f9fa8ec35b4a707089f01068f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And please test every query to your database - it's a better way to prevent injection.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그리고 데이터베이스에 대한 모든 쿼리를 테스트하십시오. 주입을 방지하는 더 좋은 방법입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="881c07549030945c2309cee9e2e2ac2c9261312f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data filtering for (converting unsafe data to safe data)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;데이터 필터링 (안전하지 않은 데이터를 안전한 데이터로 변환)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b74390d8460cdf00400fa1ae06a8df3cec12865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning:&lt;/strong&gt;
  This answer's sample code (like the question's sample code) uses PHP's &lt;code&gt;MySQL&lt;/code&gt; extension, which was deprecated in PHP 5.5.0 and removed entirely in PHP 7.0.0.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않는 경고 :&lt;/strong&gt; 이 답변의 샘플 코드 (질문의 샘플 코드와 같은)는 PHP 5.5.0에서 더 이상 사용되지 않고 PHP 7.0.0에서 완전히 제거 된 PHP의 &lt;code&gt;MySQL&lt;/code&gt; 확장을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1051e53e86d6b39bb445cb5e011266551db0339e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated Warning&lt;/strong&gt;: The mysql extension is deprecated at this time. we recommend using the &lt;em&gt;PDO extension&lt;/em&gt;</source>
          <target state="translated">더 이상 사용되지 &lt;strong&gt;않는 경고&lt;/strong&gt; : 현재 mysql 확장은 더 이상 사용되지 않습니다. &lt;em&gt;PDO 확장을&lt;/em&gt; 사용하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dda06a174f7dd5e74c8eabf80656879e8b1f296" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single column&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;나는 단 하나의 열을 원한다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80c1cc3b7b50e8fd2aea1b4ca0b3b75408434e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want a single row result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;단일 행 결과를 원합니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="024c9614f439c4a7911a75baa6232c91c34e16cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array of results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;결과 배열을 원합니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff4dc6dc4cb39edde6e4cb977be5a4e00bfee01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I want an array(key =&amp;gt; value) results (i.e. for making a selectbox)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열 (키 =&amp;gt; 값) 결과를 원합니다 (즉, 선택 상자 만들기)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8052e9a559828f926aaf4cb0e3c1b2ca31046e95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IMPORTANT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cde4be58e6e2d465148f3e98b5727244f7a72453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;라이브러리 예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e446408dbdb6997b7424912b8c1d79a1c5ab993b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23d6bf55f17ae053d22c5b227546c45610ff250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c585f3da07abdc2dcc052b0a31c75b51345fff8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; you must be connected to the database to use this function!</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능을 사용하려면 데이터베이스에 연결되어 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="a67dc084aafad94a19d93929a672c4d8c26d1f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;P.S&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b10a86d4bbe9f0b1901a8bde6b52d5685220b62b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PDO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PDO:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3a71e18b47cb4549c122f88532d562818113692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Query Log:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;쿼리 로그 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3b772547fb5634e5dbe11cab975563db5faff2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RULE: do not create one database user for all privileges. For all SQL operations, you can create your scheme like (deluser, selectuser, updateuser) as usernames for easy usage.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;규칙 : 모든 권한에 대해 하나의 데이터베이스 사용자를 작성하지 마십시오.&lt;/strong&gt; &lt;strong&gt;모든 SQL 작업에서 (deluser, selectuser, updateuser)와 같은 체계를 사용자 이름으로 만들어 쉽게 사용할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e3668d2a13faa5a6d222104bab0c82a2d2b1525" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Security Warning&lt;/strong&gt;: This answer is not in line with security best practices. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;Escaping is inadequate to prevent SQL injection&lt;/a&gt;, use &lt;em&gt;prepared statements&lt;/em&gt; instead. Use the strategy outlined below at your own risk. (Also, &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; was removed in PHP 7.)</source>
          <target state="translated">&lt;strong&gt;보안 경고&lt;/strong&gt; :이 답변은 보안 모범 사례와 일치하지 않습니다. &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;이스케이프는 SQL 삽입을 방지하기에 적절하지 않으므로&lt;/a&gt; 대신 &lt;em&gt;준비된 명령문을&lt;/em&gt; 사용하십시오. 아래에 요약 된 전략을 사용하십시오. (또한 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 은 PHP 7에서 제거되었습니다.)</target>
        </trans-unit>
        <trans-unit id="69b9b6580cb9915e7a2d71a41230225b3ca5ffb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UNHEX()&lt;/strong&gt; works on &lt;strong&gt;any&lt;/strong&gt; column; you do not have to worry about the empty string.</source>
          <target state="translated">&lt;strong&gt;UNHEX ()&lt;/strong&gt; 는 &lt;strong&gt;모든&lt;/strong&gt; 열에서 작동합니다. 빈 문자열에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7d6310b11ad04ede1d86386dd85ffa2b6b00627" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use prepared statements and parameterized queries.&lt;/strong&gt; These are SQL statements that are sent to and parsed by the database server separately from any parameters. This way it is impossible for an attacker to inject malicious SQL.</source>
          <target state="translated">&lt;strong&gt;준비된 명령문과 매개 변수화 된 쿼리를 사용하십시오.&lt;/strong&gt; 이는 데이터베이스 서버에서 매개 변수와 별도로 보내거나 구문 분석하는 SQL 문입니다. 이런 식으로 공격자가 악의적 인 SQL을 주입하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="4b66375073c94d88e7cae14419ae8276f33a993c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning: the approach described in this answer only applies to very specific scenarios and isn't secure since SQL injection attacks do not only rely on being able to inject &lt;code&gt;X=Y&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;경고 :이 답변에 설명 된 방법은 매우 특정한 시나리오에만 적용되며 SQL 주입 공격은 &lt;code&gt;X=Y&lt;/code&gt; 주입에만 의존하지 않기 때문에 안전하지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="167a410708537f3843a1e61a18f3cd510d6bcd35" translate="yes" xml:space="preserve">
          <source>A few guidelines for escaping special characters in SQL statements.</source>
          <target state="translated">SQL 문에서 특수 문자를 이스케이프하기위한 몇 가지 지침.</target>
        </trans-unit>
        <trans-unit id="260ac50ca6144215fd0045d1af48ccfa01e745f8" translate="yes" xml:space="preserve">
          <source>A good idea is to use an &lt;strong&gt;'object-relational mapper'&lt;/strong&gt; like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt;:</source>
          <target state="translated">좋은 아이디어는 &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Idiorm&lt;/a&gt; 과 같은 &lt;strong&gt;'객체 관계 맵퍼'&lt;/strong&gt; 를 사용하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="1f6d894b7333493ff06b2ed34e4c107a54abe2c5" translate="yes" xml:space="preserve">
          <source>A simple way would be to use a PHP framework like &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt; or &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; which have inbuilt features like filtering and active-record so that you don't have to worry about these nuances.</source>
          <target state="translated">간단한 방법은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Codeigniter#CodeIgniter&quot;&gt;CodeIgniter&lt;/a&gt; 또는 &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; 과 같은 PHP 프레임 워크를 사용하여 필터링 및 활성 레코드와 같은 기능이 내장되어 있으므로 이러한 뉘앙스에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4f547e2a90f5422256b70e6749192b1dc12e925" translate="yes" xml:space="preserve">
          <source>A user commented that this post is useless, OK! Here is what &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORG provided&lt;/a&gt;:</source>
          <target state="translated">사용자가이 게시물이 쓸모 없다고 댓글을 달았습니다. &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_3:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP.ORG가 제공 한&lt;/a&gt; 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8bcba9062fd4c5354b3fe7577630f1852a5a4f1" translate="yes" xml:space="preserve">
          <source>Additional defenses:</source>
          <target state="translated">추가 방어 :</target>
        </trans-unit>
        <trans-unit id="5a9a57fdfe801732160d7b653550c5f2e63ef2a2" translate="yes" xml:space="preserve">
          <source>Adopting the MVC pattern and a framework like &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt; or &lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter&lt;/a&gt; is probably the right way to go: Common tasks like creating secure database queries have been solved and centrally implemented in such frameworks. They help you to organize your web application in a sensible way and make you think more about loading and saving objects than about securely constructing single SQL queries.</source>
          <target state="translated">MVC 패턴과 &lt;a href=&quot;http://cakephp.org/&quot;&gt;CakePHP&lt;/a&gt; 또는 &lt;a href=&quot;http://codeigniter.com/&quot;&gt;CodeIgniter&lt;/a&gt; 와 같은 프레임 워크를 채택하는 것이 올바른 방법 일 것입니다. 안전한 데이터베이스 쿼리 생성과 같은 일반적인 작업이 해결되어 중앙에서 구현되었습니다. 웹 응용 프로그램을 합리적인 방식으로 구성하고 단일 SQL 쿼리를 안전하게 구성하는 것보다 객체를로드하고 저장하는 것에 대해 더 많이 생각하도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="c8a14a30d16f16ac980bf356d9504fab38b7075b" translate="yes" xml:space="preserve">
          <source>Also Enforce: Least Privilege</source>
          <target state="translated">또한 시행 : 최소 권한</target>
        </trans-unit>
        <trans-unit id="1896c2015dcc61c975328aa2d6d19cd66a93eed3" translate="yes" xml:space="preserve">
          <source>Also Perform: White List Input Validation</source>
          <target state="translated">또한 수행 : 화이트리스트 입력 검증</target>
        </trans-unit>
        <trans-unit id="a7a90d96967d5c49bc4afaed57e9dee54e4e9f9c" translate="yes" xml:space="preserve">
          <source>Also, as others have suggested, you may find it useful/easier to step up a layer of abstraction with something like &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt;.</source>
          <target state="translated">또한 다른 사람들이 제안했듯이 &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt; 와 같은 추상화 계층을 강화하는 것이 유용하거나 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c30cce0b8c2965ca51b265a25df9d3693f83528" translate="yes" xml:space="preserve">
          <source>Also, its use is a little complicated if you are about to insert an empty string. You'll have to entirely replace it with &lt;code&gt;''&lt;/code&gt;, or you'll get an error.</source>
          <target state="translated">또한 빈 문자열을 삽입하려는 경우 사용이 약간 복잡합니다. 완전히 &lt;code&gt;''&lt;/code&gt; 로 바꾸어야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69c4f0f8d46827c16603dcdf21511ca657bcb9e9" translate="yes" xml:space="preserve">
          <source>Also, you can 'prepare' your arguments before preparing your query so that you can build dynamic queries and at the end have a fully prepared statements query. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">또한 쿼리를 준비하기 전에 인수를 '준비'하여 동적 쿼리를 작성할 수 있고 결국에는 완전히 준비된 명령문 쿼리를 가질 수 있습니다. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/Prepare.html&quot;&gt;PHP를 사용하는 MySQL 용 DALMP 데이터베이스 추상화 계층.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74d699a30675fa3d298fbab5df176b5b25503844" translate="yes" xml:space="preserve">
          <source>Although there is a general agreement on the best practices regarding SQL injection protection, there are &lt;strong&gt;still many bad practices as well.&lt;/strong&gt; And some of them too deeply rooted in the minds of PHP users. For instance, on this very page there are (although invisible to most visitors) &lt;strong&gt;more than 80 deleted answers&lt;/strong&gt; - all removed by the community due to bad quality or promoting bad and outdated practices. Worse yet, some of the bad answers aren't deleted, but rather prospering.</source>
          <target state="translated">SQL 주입 보호와 관련된 모범 사례에 대한 일반적인 합의가 &lt;strong&gt;있지만 여전히 많은 나쁜 사례가 있습니다.&lt;/strong&gt; 그리고 그들 중 일부는 PHP 사용자의 마음에 너무 뿌리를두고 있습니다. 예를 들어,이 페이지 바로 위에 (대부분의 방문객에게는 보이지는 않지만) &lt;strong&gt;80 개가 넘는 삭제 된 답변이 있습니다&lt;/strong&gt; . 모두 나쁜 품질로 인해 또는 커뮤니티에서 좋지 않은 구식을 홍보하여 ​​삭제되었습니다. 더 나쁜 것은, 잘못된 답변 중 일부는 삭제되지 않고 오히려 번영한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eabd1c8f5b2f8e2b973f2b52cc71e91a5bb24985" translate="yes" xml:space="preserve">
          <source>Although you can set the &lt;code&gt;charset&lt;/code&gt; in the options of the constructor, it's important to note that 'older' versions of PHP (before 5.3.6) &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;silently ignored the charset parameter&lt;/a&gt; in the DSN.</source>
          <target state="translated">생성자의 옵션에서 &lt;code&gt;charset&lt;/code&gt; 을 설정할 수 있지만, PHP의 '이전'버전 (5.3.6 이전)은 DSN &lt;a href=&quot;http://php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;의 문자셋 매개 변수&lt;/a&gt; 를 자동으로 무시했습니다 .</target>
        </trans-unit>
        <trans-unit id="89427a94f14d4db682ce047617bd39f90aeb83cc" translate="yes" xml:space="preserve">
          <source>An alternative to mysql_real_escape_string() is</source>
          <target state="translated">mysql_real_escape_string ()의 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bcc7fb301834a94c428663cf127b9d3c420bafb" translate="yes" xml:space="preserve">
          <source>And OWASP makes it even worse, stressing on escaping &lt;em&gt;user input&lt;/em&gt; which is an utter nonsense: there should be no such words in the context of injection protection. Every variable is potentially dangerous - no matter the source! Or, in other words - every variable has to be properly formatted to be put into a query - no matter the source again. It's the destination that matters. The moment a developer starts to separate the sheep from the goats (thinking whether some particular variable is &quot;safe&quot; or not) he/she takes his/her first step towards disaster. Not to mention that even the wording suggests bulk escaping at the entry point, resembling the very magic quotes feature - already despised, deprecated and removed.</source>
          <target state="translated">그리고 OWASP는 전혀 말도 안되는 &lt;em&gt;사용자 입력&lt;/em&gt; 을 피하는 데 중점을두고 있습니다. 주입 보호와 관련하여 그러한 단어가 없어야합니다. 모든 변수는 소스에 관계없이 잠재적으로 위험합니다! 즉, 소스에 관계없이 모든 변수는 쿼리에 들어가도록 올바르게 형식화되어야합니다. 중요한 목적지입니다. 개발자가 양을 염소와 분리하기 시작하는 순간 (특정 변수가 &quot;안전한지&quot;생각하는 것) 재난을 향한 첫 걸음을 내딛습니다. 말할 것도없이, 문구조차도 엔트리 포인트에서 대량 이스케이프 처리를 제안하며 이미 멸시, 더 이상 사용되지 않고 제거 된 매우 따옴표 기능과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="029c0a0374bedd82f613d03ef16978761b30cf7e" translate="yes" xml:space="preserve">
          <source>And by using PDO rather than &lt;code&gt;mysql_&lt;/code&gt;, &lt;code&gt;mysqli_&lt;/code&gt;, and &lt;code&gt;pgsql_&lt;/code&gt; functions, you make your application a little more abstracted from the database, in the rare occurrence that you have to switch database providers.</source>
          <target state="translated">또한 &lt;code&gt;mysql_&lt;/code&gt; , &lt;code&gt;mysqli_&lt;/code&gt; 및 &lt;code&gt;pgsql_&lt;/code&gt; 함수 대신 PDO를 사용하면 데이터베이스 공급자를 전환해야하는 경우가 드물게 데이터베이스에서 응용 프로그램을 좀 더 추상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5ef3ee55266b405431414057f96c242ca0a3ea" translate="yes" xml:space="preserve">
          <source>And it is so much better to use those functions to check input data with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">그리고 이러한 함수를 사용하여 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 으로 입력 데이터를 확인하는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8b6f9dd7708882555f93273050b2295e1ff50293" translate="yes" xml:space="preserve">
          <source>And prepared statements cover only two of them.</source>
          <target state="translated">그리고 준비된 진술은 그 중 두 가지만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9a818eb4d9f22f32e544143c95e4a338abac3b6a" translate="yes" xml:space="preserve">
          <source>And some other like &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;Preventing SQL injection with MySQL and PHP&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">그리고 &lt;em&gt;&lt;a href=&quot;https://web.archive.org/web/20190221025712/http://www.digifuzz.net/archives/2007/07/preventing-sql-injection-with-php/&quot;&gt;MySQL과 PHP로 SQL 주입 방지&lt;/a&gt;&lt;/em&gt; 와 같은 다른 &lt;em&gt;것들도&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a9c32269a2494bf681823b0f8ef4fe2f380c0b7" translate="yes" xml:space="preserve">
          <source>And the use of &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is for, as the name says, escaping special characters in a string, so it will not make integers safe. The purpose of this function is to prevent breaking the strings in SQL statements, and the damage to the database that it could cause. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; is a useful function when used properly, especially when combined with &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysqli_real_escape_string&lt;/code&gt; 은 이름에서 알 수 있듯이 문자열에서 특수 문자를 이스케이프 처리하기 때문에 정수를 안전하게 만들지 않습니다. 이 함수의 목적은 SQL 문에서 문자열이 깨지거나 데이터베이스가 손상 될 수있는 것을 방지하기위한 것입니다. &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; 은 적절하게 사용될 때, 특히 &lt;code&gt;sprintf&lt;/code&gt; 와 결합 될 때 유용한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="77fdc73c5a405950cdef3ff428d3bc7c8429a576" translate="yes" xml:space="preserve">
          <source>And then just select whatever data ones want. Isn't it cool?</source>
          <target state="translated">그런 다음 원하는 데이터를 선택하십시오. 멋지지 않습니까?</target>
        </trans-unit>
        <trans-unit id="469e5ab140693a349e074c76557802c31c33fd02" translate="yes" xml:space="preserve">
          <source>Another benefit of using prepared statements is that if you execute the same statement many times in the same session it will only be parsed and compiled once, giving you some speed gains.</source>
          <target state="translated">준비된 명령문을 사용하면 얻을 수있는 또 다른 이점은 동일한 세션에서 동일한 명령문을 여러 번 실행하면 구문 분석 및 컴파일이 한 번만 수행되므로 속도가 향상된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac2632462245c897b1b550ec3d5bcf2e8b29db73" translate="yes" xml:space="preserve">
          <source>Any other query part, such as an SQL keyword, a table or a field name, or an operator - must be filtered through a white list.</source>
          <target state="translated">SQL 키워드, 테이블 또는 필드 이름 또는 연산자와 같은 다른 쿼리 부분은 화이트리스트를 통해 필터링해야합니다.</target>
        </trans-unit>
        <trans-unit id="59ca1e0dddd5402d6c514f23b5ab618318bd9b52" translate="yes" xml:space="preserve">
          <source>Any parameters you send when using a prepared statement will just be treated as strings (although the database engine may do some optimization so parameters may end up as numbers too, of course). In the example above, if the &lt;code&gt;$name&lt;/code&gt; variable contains &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; the result would simply be a search for the string &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt;, and you will not end up with &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;an empty table&lt;/a&gt;.</source>
          <target state="translated">준비된 명령문을 사용할 때 전송하는 모든 매개 변수는 문자열로 취급됩니다 (데이터베이스 엔진은 일부 최적화를 수행하여 매개 변수도 물론 숫자로 끝날 수 있음). 위의 예에서 &lt;code&gt;$name&lt;/code&gt; 변수에 &lt;code&gt;'Sarah'; DELETE FROM employees&lt;/code&gt; 가 포함되어 있으면 ; 직원 에서 삭제 결과는 단순히 문자열 &lt;code&gt;&quot;'Sarah'; DELETE FROM employees&quot;&lt;/code&gt; 검색 &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;하면 빈 테이블로&lt;/a&gt; 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="814927018a663b40d6800585c37e63752cd8b345" translate="yes" xml:space="preserve">
          <source>Any variable that represents an SQL data literal, (or, to put it simply - an SQL string, or a number) must be added through a prepared statement. No Exceptions.</source>
          <target state="translated">SQL 데이터 리터럴을 나타내는 변수 (또는 간단히 말해서 SQL 문자열 또는 숫자)는 준비된 명령문을 통해 추가해야합니다. 예외 없음.</target>
        </trans-unit>
        <trans-unit id="8f339838f01ea88e77c778fe86da6db1dbb6727f" translate="yes" xml:space="preserve">
          <source>As also mentioned in the above statement,</source>
          <target state="translated">위의 진술에서 언급했듯이</target>
        </trans-unit>
        <trans-unit id="35a0aae8525a92229ff81ec077bfddd794e5ad1c" translate="yes" xml:space="preserve">
          <source>As you can see, people suggest you use prepared statements at the most. It's not wrong, but when your query is executed &lt;strong&gt;just once&lt;/strong&gt; per process, there would be a slight performance penalty.</source>
          <target state="translated">보시다시피 사람들은 준비된 진술을 최대한 사용하는 것이 좋습니다. 잘못된 것은 아니지만 쿼리가 프로세스 당 &lt;strong&gt;한 번만&lt;/strong&gt; 실행 &lt;strong&gt;되면&lt;/strong&gt; 약간의 성능 저하가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd2cedbc3cba1b466c7ccb0d7d8ccb2234565bfd" translate="yes" xml:space="preserve">
          <source>As you may know, claiming an article should be supported by a valid argument, at least by one reference! Otherwise, it's considered as an attack and a bad claim!</source>
          <target state="translated">아시다시피, 기사를 주장하는 것은 적어도 하나의 참조로 유효한 주장에 의해 뒷받침되어야합니다! 그렇지 않으면 공격과 나쁜 주장으로 간주됩니다!</target>
        </trans-unit>
        <trans-unit id="820ba4d63bbc346ca4423e23a1bea3ca67844669" translate="yes" xml:space="preserve">
          <source>Basically, read it &lt;a href=&quot;http://php.net/pdo&quot;&gt;while you read the manual&lt;/a&gt; to see how to put the PDO functions to use in real life to make it simple to store and retrieve values in the format &lt;strong&gt;you&lt;/strong&gt; want.</source>
          <target state="translated">기본적으로 PDO 기능을 실제로 사용하여 원하는 형식으로 값을 저장하고 검색하는 방법을 알아 보려면 &lt;a href=&quot;http://php.net/pdo&quot;&gt;설명서&lt;/a&gt; 를 읽는 동안 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="984f8b5a40d91fa830e321cc52151441d3cd3388" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;1=1&lt;/code&gt;, &lt;code&gt;2=2&lt;/code&gt;, &lt;code&gt;1=2&lt;/code&gt;, &lt;code&gt;2=1&lt;/code&gt;, &lt;code&gt;1+1=2&lt;/code&gt;, etc... are the common questions to an SQL database of an attacker. Maybe also it's used by many hacking applications.</source>
          <target state="translated">&lt;code&gt;1=1&lt;/code&gt; , &lt;code&gt;2=2&lt;/code&gt; , &lt;code&gt;1=2&lt;/code&gt; , &lt;code&gt;2=1&lt;/code&gt; , &lt;code&gt;1+1=2&lt;/code&gt; 등이 공격자의 SQL 데이터베이스에 대한 일반적인 질문이기 때문에. 또한 많은 해킹 응용 프로그램에서 사용되기도합니다.</target>
        </trans-unit>
        <trans-unit id="c0510df3f1d4695430a58920cd200e354ad3da70" translate="yes" xml:space="preserve">
          <source>Bound variables will be escaped automatically by the server. The
  server inserts their escaped values at the appropriate places into the
  statement template before execution. A hint must be provided to the
  server for the type of bound variable, to create an appropriate
  conversion. See the mysqli_stmt_bind_param() function for more
  information.</source>
          <target state="translated">바운드 변수는 서버에 의해 자동으로 이스케이프됩니다. 서버는 실행 전에 적절한 위치에서 이스케이프 된 값을 명령문 템플리트에 삽입합니다. 적절한 변환을 작성하려면 바운드 변수 유형에 대한 힌트를 서버에 제공해야합니다. 자세한 내용은 mysqli_stmt_bind_param () 함수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c45ced87722560ce91bdb8d47661e48efa8ce64" translate="yes" xml:space="preserve">
          <source>But if the coder of an injectable site would hex it, no injection would be possible because the query would look like this: &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</source>
          <target state="translated">그러나 주입 가능한 사이트의 코더가 16 진수라면 쿼리는 다음과 같이 표시되므로 주입이 불가능합니다. &lt;code&gt;SELECT ... WHERE id = UNHEX('2d312075...3635')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1130d41244662be40e74568e6d313b2aeba7a56" translate="yes" xml:space="preserve">
          <source>But sometimes we have to make our query even more dynamic, adding operators or identifiers as well.
So, we will need different protection techniques.</source>
          <target state="translated">그러나 때로는 연산자 나 식별자를 추가하여 쿼리를 더욱 역동적으로 만들어야합니다. 따라서 다른 보호 기술이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="388e5f4608b9c0c64a94caf6cb522f68f0b812be" translate="yes" xml:space="preserve">
          <source>But while both PDO and MySQLi are quite fast, MySQLi performs
insignificantly faster in benchmarks &amp;ndash; ~2.5% for non-prepared
statements, and ~6.5% for prepared ones.</source>
          <target state="translated">그러나 PDO와 MySQLi는 상당히 빠르지 만, MySQLi는 벤치 마크에서 매우 빠릅니다. 준비되지 않은 문장의 경우 ~ 2.5 %, 준비된 문장의 경우 ~ 6.5 %입니다.</target>
        </trans-unit>
        <trans-unit id="11ae2ab8e554cd29a407caca0e6fabee0756957e" translate="yes" xml:space="preserve">
          <source>But you must be careful, that you must not rewrite a safe query from your site. The code above is giving you a tip, to rewrite or redirect &lt;em&gt;(it depends on you)&lt;/em&gt; that hacking-specific dynamic query string into a page that will store the attacker's &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP address&lt;/a&gt;, or EVEN THEIR COOKIES, history, browser, or any other sensitive information, so you can deal with them later by banning their account or contacting authorities.</source>
          <target state="translated">그러나 사이트에서 안전한 쿼리를 다시 작성해서는 안됩니다. 위의 코드는 해킹 관련 동적 쿼리 문자열을 공격자의 &lt;a href=&quot;http://en.wikipedia.org/wiki/IP_address&quot;&gt;IP 주소&lt;/a&gt; 또는 쿠키, 히스토리, 브라우저 또는 기타 민감한 정보를 저장하는 페이지로 다시 작성하거나 리디렉션 &lt;em&gt;(사용자에 따라 다름)&lt;/em&gt; 할 수있는 팁을 제공합니다. 나중에 계정을 차단하거나 당국에 연락하여 정보를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="c2424b0d28c65836412890f683090b9c10c2c3e2" translate="yes" xml:space="preserve">
          <source>Can prepared statements be used for dynamic queries?</source>
          <target state="translated">준비된 명령문을 동적 쿼리에 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cc031d2a659335c48d55ac551c2a927f393178cf" translate="yes" xml:space="preserve">
          <source>Consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; are not available. How can you secure your application? Do you force me to use them? What about other languages other than PHP? I prefer to provide general ideas as it can be used for wider border, not just for a specific language.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP#History&quot;&gt;PDO&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; 를 사용할 수 없다는 것을 고려하십시오. 애플리케이션을 어떻게 보호 할 수 있습니까? 내가 그들을 사용하도록 강요합니까? PHP 이외의 다른 언어는 어떻습니까? 나는 특정 언어뿐만 아니라 더 넓은 국경에 사용될 수있는 일반적인 아이디어를 선호한다.</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6047ffa640b216365f3915cb1825dec617a4486c" translate="yes" xml:space="preserve">
          <source>Correctly setting up the connection</source>
          <target state="translated">연결을 올바르게 설정</target>
        </trans-unit>
        <trans-unit id="a6b87d4687eee957fbc10c0728a5bff14a875b82" translate="yes" xml:space="preserve">
          <source>Data filtering: before building any query user input, it should be validated and filtered. For programmers, it's important to define some properties for each user-input variables:
&lt;strong&gt;data type, data pattern, and data length&lt;/strong&gt;. A field that is a number between (x and y) must be exactly validated using the exact rule, and for a field that is a string (text): pattern is the case, for example, a username must contain only some characters, let&amp;rsquo;s say [a-zA-Z0-9_-.]. The length varies between (x and n) where x and n (integers, x &amp;lt;=n).
&lt;strong&gt;Rule: creating exact filters and validation rules are best practices for me.&lt;/strong&gt;</source>
          <target state="translated">데이터 필터링 : 쿼리 사용자 입력을 작성하기 전에 유효성을 검사하고 필터링해야합니다. 프로그래머의 경우 각 사용자 입력 변수에 대한 일부 속성 ( &lt;strong&gt;데이터 유형, 데이터 패턴 및 데이터 길이)&lt;/strong&gt; 을 정의하는 것이 중요합니다. (x와 y) 사이의 숫자 인 필드는 정확한 규칙을 사용하고 문자열 (텍스트) 인 필드에 대해 정확하게 유효성을 검사해야합니다. 예를 들어, 사용자 이름은 일부 문자 만 포함해야합니다. [a-zA-Z0-9_-.]라고 말합니다. 길이는 (x와 n)에서 x와 n (정수, x &amp;lt;= n)입니다. &lt;strong&gt;규칙 : 정확한 필터 및 유효성 검사 규칙을 만드는 것이 가장 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ac512b2277dc12fb253b90cadeff4b79f7f0c52d" translate="yes" xml:space="preserve">
          <source>Data validation</source>
          <target state="translated">데이터 유효성 검사</target>
        </trans-unit>
        <trans-unit id="bc11336395287ce262bd5113df8755daa9bf7976" translate="yes" xml:space="preserve">
          <source>Difference between UNHEX function and 0x prefix</source>
          <target state="translated">UNHEX 함수와 0x 접두사의 차이점</target>
        </trans-unit>
        <trans-unit id="64fadb85f6f8e77597bc8111b879ba46ab913ae2" translate="yes" xml:space="preserve">
          <source>Don't use &lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL&lt;/a&gt;. This extension is deprecated. Use &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/intro.mysql.php&quot;&gt;MySQL을&lt;/a&gt; 사용하지 마십시오. 이 확장은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; 또는 &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="47070a639c03e8836d4eb1ec8798be8eba3ad73e" translate="yes" xml:space="preserve">
          <source>Don't worry about that the escaped string will have a 2x size of its original length because even if you use &lt;code&gt;mysql_real_escape_string&lt;/code&gt;, PHP has to allocate same capacity &lt;code&gt;((2*input_length)+1)&lt;/code&gt;, which is the same.</source>
          <target state="translated">&lt;code&gt;mysql_real_escape_string&lt;/code&gt; 을 사용하더라도 PHP가 동일한 용량 &lt;code&gt;((2*input_length)+1)&lt;/code&gt; 을 할당해야하기 때문에 이스케이프 된 문자열의 원래 길이가 2 배 크기라는 것에 대해 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a8399b7eb2075e4b434c811aae00c5124b738ead" translate="yes" xml:space="preserve">
          <source>Escaping and SQL injection</source>
          <target state="translated">이스케이프 및 SQL 인젝션</target>
        </trans-unit>
        <trans-unit id="f51a89736407728dd8dad04a11c2585ad6ed1ddc" translate="yes" xml:space="preserve">
          <source>Every answer here covers only part of the problem.
In fact, there are &lt;strong&gt;four&lt;/strong&gt; different query parts which we can add to SQL dynamically: -</source>
          <target state="translated">여기에있는 모든 답변은 문제의 일부만을 다루고 있습니다. 실제로, 우리는 SQL에 동적으로 추가 할 수있는 &lt;strong&gt;네&lt;/strong&gt; 가지 쿼리 부분이 있습니다 :-</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="7f33f9daadca6cb0086c1f093e4291fd8f752aed" translate="yes" xml:space="preserve">
          <source>Finally you get:</source>
          <target state="translated">마지막으로 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="203bdc584486062bd9b0a868468cf5b0c6115900" translate="yes" xml:space="preserve">
          <source>Finally, let's consider that a user sends this text below instead of entering his/her username:</source>
          <target state="translated">마지막으로, 사용자가 자신의 사용자 이름을 입력하는 대신 아래에이 텍스트를 전송한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4c529cebc105c5ddf809043dcd4cda22ee4366d8" translate="yes" xml:space="preserve">
          <source>For automatic escaping of values with prepared statements, use &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt;, and &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param&lt;/a&gt; where types for the corresponding bind variables must be provided for an appropriate conversion:</source>
          <target state="translated">준비된 명령문으로 값을 자동 이스케이프하려면 &lt;a href=&quot;http://www.php.net/manual/en/mysqli.prepare.php&quot;&gt;mysqli_prepare&lt;/a&gt; 및 &lt;a href=&quot;http://www.php.net/manual/en/mysqli-stmt.bind-param.php&quot;&gt;mysqli_stmt_bind_param을 사용하십시오.&lt;/a&gt; 여기서 적절한 바인드 변수에 대한 유형을 적절하게 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="263085c2dabdadf48b189f11fe3b9f44078570cc" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;there(1)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are(2)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still(3)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many(4)&lt;/a&gt;&lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;answers(5)&lt;/a&gt;, including the &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;second most upvoted answer&lt;/a&gt; suggesting you manual string escaping - an outdated approach that is proven to be insecure.</source>
          <target state="translated">예를 들어, 수동 문자열 이스케이프를 제안하는 &lt;a href=&quot;https://stackoverflow.com/a/60442&quot;&gt;두 번째로 많이 답변 된 답변을&lt;/a&gt; 포함하여 &lt;a href=&quot;https://stackoverflow.com/a/11802479&quot;&gt;(1)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/6381189&quot;&gt;are (2)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/60195/&quot;&gt;still (3)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/12426697/&quot;&gt;many (4)&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/21179234&quot;&gt;답변 (5)&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd135ed1c5cdc625f86215a3d852d0a226ec19ca" translate="yes" xml:space="preserve">
          <source>For example, if you just do something like this:</source>
          <target state="translated">예를 들어 다음과 같이하면 :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="816ab6a230a5f009a780f99ed39f9fa8ad076a2f" translate="yes" xml:space="preserve">
          <source>For manually escaping special characters in a string you can use the &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt; function. The function will not work properly unless the correct character set is set with &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset&lt;/a&gt;.</source>
          <target state="translated">문자열에서 특수 문자를 수동으로 이스케이프 처리하려면 &lt;a href=&quot;http://www.php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string&lt;/a&gt; 함수를 사용할 수 있습니다. &lt;a href=&quot;http://www.php.net/manual/en/mysqli.set-charset.php&quot;&gt;mysqli_set_charset으로&lt;/a&gt; 올바른 문자 세트를 설정하지 않으면 함수가 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6faf52c891f9ed8efba053050f428dfa69b63649" translate="yes" xml:space="preserve">
          <source>For more information, please read &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQL Injection Prevention Cheat Sheet&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet&quot;&gt;OWASP SQL 인젝션 방지 치트 시트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d38e733b61cd3029c8e0a13aa3342ac97a1dd29" translate="yes" xml:space="preserve">
          <source>For more prevention, you can add at the end ...</source>
          <target state="translated">더 많은 예방을 위해 끝에 추가 할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="9b951568ae96d7b8f246820658eefa294ec054b6" translate="yes" xml:space="preserve">
          <source>For these specific scenarios, the best thing to do is use a whitelist filter that restricts the possible values.</source>
          <target state="translated">이러한 특정 시나리오의 경우 가장 좋은 방법은 가능한 값을 제한하는 화이트리스트 필터를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3113d98fc6c4b79c794822624639f6af44b6df61" translate="yes" xml:space="preserve">
          <source>For those unsure of how to use PDO (coming from the &lt;code&gt;mysql_&lt;/code&gt; functions), I made a &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;very, very simple PDO wrapper&lt;/a&gt; that is a single file. It exists to show how easy it is to do all the common things applications need to be done. Works with PostgreSQL, MySQL, and SQLite.</source>
          <target state="translated">PDO를 사용하는 방법을 모르는 사람들을 위해 ( &lt;code&gt;mysql_&lt;/code&gt; 함수에서 오는) 단일 파일 &lt;a href=&quot;https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php&quot;&gt;인 매우 간단한 PDO 래퍼&lt;/a&gt; 를 만들었습니다. 응용 프로그램이 수행해야하는 모든 일반적인 작업을 수행하는 것이 얼마나 쉬운지를 보여주기 위해 존재합니다. PostgreSQL, MySQL 및 SQLite와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="31a94adfc6ded26176c675ac449c92a6685c5361" translate="yes" xml:space="preserve">
          <source>From the PHP manual, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP: Prepared Statements - Manual&lt;/a&gt;:</source>
          <target state="translated">PHP 매뉴얼, &lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;PHP : Prepared Statements-Manual&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6e5468989f2e2437840e22ffb20130112517c2fc" translate="yes" xml:space="preserve">
          <source>Hex is the perfect escape. No way to inject.</source>
          <target state="translated">16 진수는 완벽한 탈출입니다. 주사 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1de0731dde0800e271064f5cf722c055c76cb148" translate="yes" xml:space="preserve">
          <source>Hex methods are often used as attacks</source>
          <target state="translated">16 진 방법은 종종 공격으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="b62564667d0dfb9e44b590131236f464401bdd8b" translate="yes" xml:space="preserve">
          <source>How can I prevent SQL injection in PHP</source>
          <target state="translated">PHP에서 SQL 삽입을 방지하는 방법</target>
        </trans-unit>
        <trans-unit id="bd0deab6887a1354686773b46e00790e48d6fe0e" translate="yes" xml:space="preserve">
          <source>I created test cases for knowing how PDO and MySQLi send the query to the MySQL server when using a prepared statement:</source>
          <target state="translated">준비된 명령문을 사용할 때 PDO 및 MySQLi가 쿼리를 MySQL 서버에 보내는 방법을 알기위한 테스트 사례를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="b9bbcd490604fe09b3cd1968bb6c6f7fa088e009" translate="yes" xml:space="preserve">
          <source>I favor &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;stored procedures&lt;/a&gt; (&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL has had stored procedures support since 5.0&lt;/a&gt;) from a security point of view - the advantages are -</source>
          <target state="translated">보안 관점에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;저장 프로 시저&lt;/a&gt; ( &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-syntax.html&quot;&gt;MySQL은 5.0 이후 저장 프로 시저를 지원 했음)를&lt;/a&gt; 선호합니다. 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43758c0ba6ab9cf4ca9dc9ffd9fe8ff1ebfc4f99" translate="yes" xml:space="preserve">
          <source>I hope this will help you.</source>
          <target state="translated">이것이 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="84a0fd31784433f7ef6a00aea8326647c9561507" translate="yes" xml:space="preserve">
          <source>I suggest, using PDO is the best option.</source>
          <target state="translated">PDO를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="18aa4535a307c95c0ececdd0bfb8cd49698d9cca" translate="yes" xml:space="preserve">
          <source>I think if someone wants to use PHP and MySQL or some other dataBase server:</source>
          <target state="translated">누군가 PHP와 MySQL 또는 다른 데이터베이스 서버를 사용하고 싶다면 :</target>
        </trans-unit>
        <trans-unit id="c95768ad26c493130f9d2b473fe6ef3eb215bddb" translate="yes" xml:space="preserve">
          <source>I think that all this because of one very old superstition, supported by such authorities like &lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;the PHP manual&lt;/a&gt;, which proclaims equality between whatever &quot;escaping&quot; and protection from SQL injections.</source>
          <target state="translated">&lt;a href=&quot;https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet#Defense_Option_4:_Escaping_All_User_Supplied_Input&quot;&gt;OWASP&lt;/a&gt; 또는 &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php#refsect1-function.mysql-real-escape-string-description&quot;&gt;PHP manual&lt;/a&gt; 과 같은 기관에서 지원하는 매우 오래된 미신으로 인해이 모든 것이 &quot;탈출&quot;과 SQL 주입으로부터의 보호 사이의 평등을 보장한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="06f647de8211b09469d07c391ca6e9753993ee87" translate="yes" xml:space="preserve">
          <source>I use three different ways to prevent my web application from being vulnerable to SQL injection.</source>
          <target state="translated">웹 응용 프로그램이 SQL 주입에 취약하지 않도록 세 가지 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aa717e5dd178fdf0c4683b6d4ebda0dfe58dee0e" translate="yes" xml:space="preserve">
          <source>I was facing this issue, but I think I solved it in &lt;em&gt;very&lt;/em&gt; sophisticated way - the way hackers use to avoid using quotes. I used this in conjunction with emulated prepared statements. I use it to prevent &lt;em&gt;all&lt;/em&gt; kinds of possible SQL injection attacks.</source>
          <target state="translated">나는이 문제에 직면했지만 해커가 따옴표를 사용하지 않는 방법과 같이 &lt;em&gt;매우&lt;/em&gt; 정교한 방식으로 해결했다고 생각합니다. 나는 이것을 에뮬레이트 된 준비된 진술과 함께 사용했습니다. 가능한 &lt;em&gt;모든&lt;/em&gt; 종류의 SQL 주입 공격을 방지하기 위해 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e5f69a8687e8ff3c1c4991d23a6d4ef4077382ba" translate="yes" xml:space="preserve">
          <source>I would like to let you know: Why do we try for preventing SQL injection with a short example below:</source>
          <target state="translated">다음과 같은 간단한 예를 통해 왜 SQL 주입을 방지하려고합니까?</target>
        </trans-unit>
        <trans-unit id="eba600f8bfb98c671cd997242fbcbddc9efa69ac" translate="yes" xml:space="preserve">
          <source>I'd recommend using &lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) to run parameterized SQL queries.</source>
          <target state="translated">&lt;a href=&quot;http://ca3.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects)를 사용하여 매개 변수화 된 SQL 쿼리를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="40c2e08dff1fe6c1375d48a2c7cea92dc8a4069b" translate="yes" xml:space="preserve">
          <source>I've written this little function several years ago:</source>
          <target state="translated">몇 년 전에이 작은 기능을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="bd1f9c5fa454d3c00b06ea476a20111a54613929" translate="yes" xml:space="preserve">
          <source>If possible, cast the types of your parameters. But it's only working on simple types like int, bool, and float.</source>
          <target state="translated">가능하면 매개 변수 유형을 캐스트하십시오. 그러나 int, bool 및 float와 같은 간단한 유형에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5827c6c3a2418ad354c9d261967a8450348a74c1" translate="yes" xml:space="preserve">
          <source>If the attackers are trying to hack into the form via PHP's &lt;code&gt;$_GET&lt;/code&gt; variable or with the URL's query string, you would be able to catch them if they're not secure.</source>
          <target state="translated">공격자가 PHP의 &lt;code&gt;$_GET&lt;/code&gt; 변수를 통해 또는 URL의 쿼리 문자열을 사용하여 양식을 해킹하려는 경우 안전하지 않은 경우이를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7511b2b136cd15346fc6c4ed024e6a28da03c3b" translate="yes" xml:space="preserve">
          <source>If user input is inserted without modification into an SQL query, then the application becomes vulnerable to &lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQL injection&lt;/a&gt;, like in the following example:</source>
          <target state="translated">사용자 입력이 수정없이 SQL 쿼리에 삽입되면 다음 예제와 같이 응용 프로그램이 &lt;a href=&quot;https://stackoverflow.com/a/332367/&quot;&gt;SQL 주입에&lt;/a&gt; 취약 해집니다.</target>
        </trans-unit>
        <trans-unit id="252e57771708143a8a54033603a42c7a9528bde0" translate="yes" xml:space="preserve">
          <source>If you expect anything else from integer &lt;strong&gt;hex it&lt;/strong&gt;. If you hex it, you will perfectly escape all input. In C/C++ there's a function called &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt;&lt;code&gt;mysql_hex_string()&lt;/code&gt;&lt;/a&gt;, in PHP you can use &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt;&lt;code&gt;bin2hex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 &lt;strong&gt;16 진수&lt;/strong&gt; 에서 다른 것을 기대 &lt;strong&gt;하면&lt;/strong&gt; . 16 진수라면 모든 입력을 완벽하게 피할 수 있습니다. C / C ++에는 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/mysql-hex-string.html&quot;&gt; &lt;code&gt;mysql_hex_string()&lt;/code&gt; &lt;/a&gt; 이라는 함수가 있으며 , PHP에서는 &lt;a href=&quot;http://www.php.net/manual/en/function.bin2hex.php&quot;&gt; &lt;code&gt;bin2hex()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0094481ec99be1c5a7d70dc70e550f643a741a7d" translate="yes" xml:space="preserve">
          <source>If you expect input to be integer make sure it's &lt;strong&gt;&lt;em&gt;really&lt;/em&gt;&lt;/strong&gt; integer. In a variable-type language like PHP it is this &lt;em&gt;very&lt;/em&gt; important. You can use for example this very simple but powerful solution: &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt;</source>
          <target state="translated">입력이 정수가 될 것으로 예상되면 &lt;strong&gt;&lt;em&gt;실제로&lt;/em&gt;&lt;/strong&gt; 정수인지 확인하십시오. PHP와 같은 변수형 언어에서는 이것이 &lt;em&gt;매우&lt;/em&gt; 중요합니다. 예를 &lt;code&gt;sprintf(&quot;SELECT 1,2,3 FROM table WHERE 4 = %u&quot;, $input);&lt;/code&gt; 매우 간단하지만 강력한 솔루션을 사용할 수 있습니다. sprintf ( &quot;SELECT 1,2,3 FROM table WHERE 4 = % u&quot;, $ input);</target>
        </trans-unit>
        <trans-unit id="506301687174ad39af3412a5f9d9bf697ce6b22d" translate="yes" xml:space="preserve">
          <source>If you use integers from user input in a condition and take the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; approach, you will suffer from the problem described by &lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;Polynomial&lt;/a&gt; in the comments below. This case is trickier because integers would not be surrounded by quotes, so you could deal with by validating that the user input contains only digits.</source>
          <target state="translated">조건에서 사용자 입력의 정수를 사용하고 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 접근법을 사용하면 아래 주석에서 &lt;a href=&quot;https://stackoverflow.com/users/978756/polynomial&quot;&gt;다항식&lt;/a&gt; 에 설명 된 문제가 발생합니다. 정수가 따옴표로 묶이지 않기 때문에이 경우는 더 까다롭기 때문에 사용자 입력에 숫자 만 포함되어 있는지 확인하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="98415529fb77c227add683c142b9927f11fa1d97" translate="yes" xml:space="preserve">
          <source>If you want to alter the structure of the SQL based on user input, parameterized queries are not going to help, and the escaping required is not covered by &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. In this kind of case, you would be better off passing the user's input through a whitelist to ensure only 'safe' values are allowed through.</source>
          <target state="translated">사용자 입력을 기반으로 SQL 구조를 변경하려는 경우 매개 변수화 된 쿼리가 도움이되지 않으며 필요한 이스케이프는 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 에 포함되지 않습니다. 이런 경우에는 '안전한'값만 허용되도록 화이트리스트를 통해 사용자 입력을 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8785f3e80562fc002361ca18a095e5f516055181" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of cache engines, like &lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt;, maybe DALMP could be a choice. It uses pure &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;. Check this: &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;DALMP Database Abstraction Layer for MySQL using PHP.&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Redis_%28data_store%29&quot;&gt;Redis&lt;/a&gt; 또는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Memcached&quot;&gt;Memcached&lt;/a&gt; 와 같은 캐시 엔진을 활용하려면 DALMP가 선택 될 수 있습니다. 순수한 &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi를&lt;/a&gt; 사용합니다. &lt;a href=&quot;http://dalmp.readthedocs.org/en/latest/database/PExecute.html&quot;&gt;PHP를 사용하는 MySQL 용 DALMP Database Abstraction Layer를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb7a8e4204cd0dadf37e960ba81602dfdecab9d3" translate="yes" xml:space="preserve">
          <source>If you're connecting to a database other than MySQL, there is a driver-specific second option that you can refer to (for example, &lt;code&gt;pg_prepare()&lt;/code&gt; and &lt;code&gt;pg_execute()&lt;/code&gt; for PostgreSQL). PDO is the universal option.</source>
          <target state="translated">MySQL 이외의 데이터베이스에 연결하는 경우 참조 할 수있는 드라이버 별 두 번째 옵션이 있습니다 (예 : PostgreSQL의 경우 &lt;code&gt;pg_prepare()&lt;/code&gt; 및 &lt;code&gt;pg_execute()&lt;/code&gt; ). PDO는 보편적 인 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="d16f400a258fe645cbcf862d1cdacec8afcc86a4" translate="yes" xml:space="preserve">
          <source>If you're using a recent version of PHP, the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option outlined below will no longer be available (though &lt;code&gt;mysqli::escape_string&lt;/code&gt; is a modern equivalent). These days the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; option would only make sense for legacy code on an old version of PHP.</source>
          <target state="translated">최신 버전의 PHP를 사용하는 경우 아래에 설명 된 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 옵션을 더 이상 사용할 수 없습니다 ( &lt;code&gt;mysqli::escape_string&lt;/code&gt; 은 최신 버전입니다). 요즘 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 옵션은 이전 버전의 PHP에서 레거시 코드에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="a87d9bb2e1e1d38953625a44a667a275d119c139" translate="yes" xml:space="preserve">
          <source>In both cases, you can't use &lt;code&gt;'&lt;/code&gt; to protect the encapsulation.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;'&lt;/code&gt; 를 사용하여 캡슐화를 보호 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc303fbbb40874deaf199e9d6a1fad1eae12e122" translate="yes" xml:space="preserve">
          <source>In general, such a protection approach is based on &lt;em&gt;whitelisting&lt;/em&gt;.</source>
          <target state="translated">일반적으로 이러한 보호 방법은 &lt;em&gt;허용 목록을&lt;/em&gt; 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="7fca827b92ede4c4e14d63153d01c7f1f4172674" translate="yes" xml:space="preserve">
          <source>In my opinion, the best way to generally prevent SQL injection in your PHP application (or any web application, for that matter) is to think about your application's architecture. If the only way to protect against SQL injection is to remember to use a special method or function that does The Right Thing every time you talk to the database, you are doing it wrong. That way, it's just a matter of time until you forget to correctly format your query at some point in your code.</source>
          <target state="translated">필자의 의견으로는 PHP 응용 프로그램 (또는 모든 웹 응용 프로그램)에서 SQL 삽입을 일반적으로 방지하는 가장 좋은 방법은 응용 프로그램의 아키텍처에 대해 생각하는 것입니다. SQL 인젝션으로부터 보호하는 유일한 방법은 데이터베이스와 대화 할 때마다 올바른 것을 수행하는 특수한 방법이나 함수를 사용하는 것을 기억하는 것입니다. 그렇게하면 코드의 특정 시점에서 쿼리의 형식을 올바르게 잊어 버릴 때까지 시간 문제입니다.</target>
        </trans-unit>
        <trans-unit id="65b6a7572f51598d01d28ef1ca6341d368dbf0b0" translate="yes" xml:space="preserve">
          <source>In the above example the error mode isn't strictly necessary, &lt;strong&gt;but it is advised to add it&lt;/strong&gt;. This way the script will not stop with a &lt;code&gt;Fatal Error&lt;/code&gt; when something goes wrong. And it gives the developer the chance to &lt;code&gt;catch&lt;/code&gt; any error(s) which are &lt;code&gt;throw&lt;/code&gt;n as &lt;code&gt;PDOException&lt;/code&gt;s.</source>
          <target state="translated">위의 예에서 오류 모드는 꼭 필요한 것은 아니지만 &lt;strong&gt;추가하는 것이 좋습니다&lt;/strong&gt; . 이렇게하면 문제가 발생해도 스크립트가 &lt;code&gt;Fatal Error&lt;/code&gt; 중지되지 않습니다. 또한 개발자는 &lt;code&gt;PDOException&lt;/code&gt; 으로 발생하는 모든 오류를 &lt;code&gt;catch&lt;/code&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2db286e4cb56e8b42ba950818e8b8f310b67a57" translate="yes" xml:space="preserve">
          <source>In this case, every dynamic parameter should be hardcoded in your script and chosen from that set.
For example, to do dynamic ordering:</source>
          <target state="translated">이 경우 모든 동적 매개 변수는 스크립트에서 하드 코딩되고 해당 세트에서 선택되어야합니다. 예를 들어, 동적 순서를 수행하려면</target>
        </trans-unit>
        <trans-unit id="6b2d5fd11bcfa0af9c55f66b09eb36931b5296de" translate="yes" xml:space="preserve">
          <source>Information security</source>
          <target state="translated">정보 보안</target>
        </trans-unit>
        <trans-unit id="7be8da2bc759d6b5b0023a64f7e97f8d22bcbce1" translate="yes" xml:space="preserve">
          <source>Injection prevention - &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string()&lt;/a&gt;</source>
          <target state="translated">주입 방지 &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;-mysql_real_escape_string ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f5d58263c5f2019288630bda6ee4cb637fd37bd" translate="yes" xml:space="preserve">
          <source>It escapes considering the variable type. If you try to parameterize table, column names, it would fail as it puts every string in quotes which is an invalid syntax.</source>
          <target state="translated">변수 유형을 고려하여 이스케이프됩니다. 테이블, 열 이름을 매개 변수화하려고하면 모든 문자열을 따옴표로 묶어 유효하지 않은 구문이므로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e66723c3916c6792b6e9358bbc39573f7f203093" translate="yes" xml:space="preserve">
          <source>It not only saves you from SQL injections but from syntax errors too! Also Supports collections of models with method chaining to filter or apply actions to multiple results at once and multiple connections.</source>
          <target state="translated">SQL 인젝션뿐만 아니라 구문 오류도 방지합니다! 또한 메소드 체인을 통해 모델 모음을 지원하여 한 번에 여러 연결에서 여러 결과에 조치를 필터링하거나 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f53f074e916e32d9c9de79faceea3b3a0b1b8268" translate="yes" xml:space="preserve">
          <source>It's clear that a prepared statement is also escaping the data, nothing else.</source>
          <target state="translated">준비된 진술이 데이터를 빠져 나가는 것이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="066059abccc3bb425cd0e667ccb08532bb6fc8ca" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/grant.html&quot;&gt;GRANT에&lt;/a&gt; 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="ed0dd15ea735ebf8e4f7aefab757f8823897465c" translate="yes" xml:space="preserve">
          <source>Most databases (including &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL&lt;/a&gt;) enable user access to be restricted to executing stored procedures. The fine-grained security access control is useful to prevent escalation of privileges attacks. This prevents compromised applications from being able to run SQL directly against the database.</source>
          <target state="translated">&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/stored-routines-privileges.html&quot;&gt;MySQL을&lt;/a&gt; 포함한 대부분의 데이터베이스는 사용자 액세스가 저장 프로 시저 실행으로 제한되도록합니다. 세분화 된 보안 액세스 제어는 권한 공격의 확대를 방지하는 데 유용합니다. 이렇게하면 손상된 응용 프로그램이 데이터베이스에 대해 SQL을 직접 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbc26a832cdcd4282066d905ed7a05f1fdc9ed21" translate="yes" xml:space="preserve">
          <source>My approach against SQL injection is: clearing user-input data before sending it to the database (before using it inside any query).</source>
          <target state="translated">SQL 주입에 대한 나의 접근 방식은 사용자 입력 데이터를 데이터베이스로 보내기 전에 (쿼리 내에서 사용하기 전에) 지우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="05f8f3c79f55806a7dcfe96187c4600251c00e11" translate="yes" xml:space="preserve">
          <source>My approach:</source>
          <target state="translated">내 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="4d52e8740d9df9e1c638ac50e30925e49fcd8e33" translate="yes" xml:space="preserve">
          <source>No matter if you use prepared statements or &lt;code&gt;mysqli_real_escape_string&lt;/code&gt;, you always have to know the type of input data you're working with.</source>
          <target state="translated">준비된 명령문이나 &lt;code&gt;mysqli_real_escape_string&lt;/code&gt; 을 사용하더라도 작업중인 입력 데이터의 유형을 항상 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="529ff19c5e6399e4d50652370e959d26daab503b" translate="yes" xml:space="preserve">
          <source>Not only does this protect against SQL injection, but it also speeds up queries.</source>
          <target state="translated">이를 통해 SQL 삽입을 방지 할뿐만 아니라 쿼리 속도도 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="ad07b10ae48ce9bcac4c0024173c1939bf2d4d50" translate="yes" xml:space="preserve">
          <source>Note that this hex method is often used as an SQL injection attack where integers are just like strings and escaped just with &lt;code&gt;mysql_real_escape_string&lt;/code&gt;. Then you can avoid the use of quotes.</source>
          <target state="translated">이 16 진 방법은 종종 정수가 문자열과 같고 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 으로 이스케이프되는 SQL 주입 공격으로 사용됩니다. 그런 다음 따옴표 사용을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd876670bffa2dedbaa4302b16a1c84ee2ebe22" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;PDO&lt;/code&gt; to access a MySQL database &lt;em&gt;real&lt;/em&gt; prepared statements are &lt;strong&gt;not used by default&lt;/strong&gt;. To fix this you have to disable the emulation of prepared statements. An example of creating a connection using PDO is:</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 를 사용하여 MySQL 데이터베이스에 액세스 할 때 &lt;em&gt;실제&lt;/em&gt; 준비된 명령문은 &lt;strong&gt;기본적으로 사용되지 않습니다&lt;/strong&gt; . 이 문제를 해결하려면 준비된 명령문의 에뮬레이션을 비활성화해야합니다. PDO를 사용하여 연결을 작성하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0281801c06d0ce9e250fd24a61b6b6723729516b" translate="yes" xml:space="preserve">
          <source>Now, &lt;strong&gt;why you do you need to prevent your query from SQL injection?&lt;/strong&gt;</source>
          <target state="translated">이제 &lt;strong&gt;왜 쿼리를 SQL 삽입하지 못하게해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26d705214b3428e5682f630c8e66663452ff37b5" translate="yes" xml:space="preserve">
          <source>Now, if someone (a hacker) puts</source>
          <target state="translated">이제 누군가 (해커)가</target>
        </trans-unit>
        <trans-unit id="66eb148a1111b249fa1c3f3a55a2330ca909715f" translate="yes" xml:space="preserve">
          <source>Now, if you are an advanced user, start using this defense as you like, but, for beginners, if they can't quickly implement a stored procedure and prepared the statement, it's better to filter input data as much they can.</source>
          <target state="translated">이제 고급 사용자라면 원하는대로이 방어를 사용하기 시작하지만 초보자는 저장 프로 시저를 빠르게 구현하고 명령문을 준비 할 수 없으면 입력 데이터를 최대한 필터링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f64627235bbf5e10f0dda979a643fa08ab87651d" translate="yes" xml:space="preserve">
          <source>Now, our point is to prevent security threats such as SQL injection attacks, the question asking (how to prevent an SQL injection attack using PHP), be more realistic, data filtering or clearing input data is the case when using user-input data inside such query, using PHP or any other programming language is not the case, or as recommended by more people to use modern technology such as prepared statement or any other tools that currently supporting SQL injection prevention, consider that these tools not available anymore? How do you secure your application?</source>
          <target state="translated">이제 우리의 요점은 SQL 주입 공격과 같은 보안 위협, PHP (SQL을 사용하여 SQL 주입 공격을 방지하는 방법), 더 현실적인 데이터 필터링 또는 입력 데이터 지우기가 내부에서 사용자 입력 데이터를 사용할 때의 경우와 같은 보안 위협을 방지하는 것입니다 PHP 나 다른 프로그래밍 언어를 사용한 쿼리는 그렇지 않거나, 더 많은 사람들이 준비된 명령문이나 현재 SQL 주입 방지를 지원하는 다른 도구와 같은 최신 기술을 사용하도록 권장하는 경우 이러한 도구를 더 이상 사용할 수 없다고 생각하십니까? 애플리케이션을 어떻게 보호합니까?</target>
        </trans-unit>
        <trans-unit id="a2ebdce6e2debca99f4971e3f20fb7e609a0d677" translate="yes" xml:space="preserve">
          <source>Oh, and since you asked about how to do it for an insert, here's an example (using PDO):</source>
          <target state="translated">아, 그리고 당신은 삽입을 위해 그것을하는 방법에 대해 물었으므로 다음은 PDO를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="134949ae0b25999cca22947fe40274275ecfbf40" translate="yes" xml:space="preserve">
          <source>Option #1: Use of Prepared Statements (Parameterized Queries)</source>
          <target state="translated">옵션 # 1 : 준비된 명령문 사용 (매개 변수화 된 쿼리)</target>
        </trans-unit>
        <trans-unit id="5d2a8213d51185403db055f6aea59f59d1a24bff" translate="yes" xml:space="preserve">
          <source>Option #2: Use of Stored Procedures</source>
          <target state="translated">옵션 # 2 : 저장 프로 시저 사용</target>
        </trans-unit>
        <trans-unit id="ca0c50b92c49801edcf1ea0388797ec4f53add0c" translate="yes" xml:space="preserve">
          <source>Option #3: Escaping all User Supplied Input</source>
          <target state="translated">옵션 # 3 : 모든 사용자 제공 입력 이스케이프</target>
        </trans-unit>
        <trans-unit id="1b175495915b9cebd7a4f0c7b63ed399ad461fb6" translate="yes" xml:space="preserve">
          <source>Or there is a slightly better answer that suggests just &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;another method of string formatting&lt;/a&gt; and even boasts it as the ultimate panacea. While of course, it is not. This method is no better than regular string formatting, yet it keeps all its drawbacks: it is applicable to strings only and, like any other manual formatting, it's essentially optional, non-obligatory measure, prone to human error of any sort.</source>
          <target state="translated">또는 &lt;a href=&quot;https://stackoverflow.com/a/12710285&quot;&gt;문자열 형식화의 또 다른 방법&lt;/a&gt; 을 제안하고 궁극적 인 만병 통치약으로 자랑하는 약간 더 나은 대답이 있습니다. 물론 그렇지 않습니다. 이 방법은 일반 문자열 형식보다 낫지는 않지만 모든 단점을 유지합니다. 문자열에만 적용 할 수 있으며 다른 수동 형식과 마찬가지로 본질적으로 선택적이고 의무적 인 조치이며 모든 종류의 사람의 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f0ded22686c7a01e80dd23bbdd785e9739881413" translate="yes" xml:space="preserve">
          <source>PDO wins this battle with ease. With support for twelve
different database drivers and named parameters, we can ignore the
small performance loss, and get used to its API. From a security
standpoint, both of them are safe as long as the developer uses them
the way they are supposed to be used</source>
          <target state="translated">PDO는이 전투에서 쉽게 승리합니다. 12 개의 서로 다른 데이터베이스 드라이버와 명명 된 매개 변수를 지원함으로써 작은 성능 손실을 무시하고 API에 익숙해 질 수 있습니다. 보안 관점에서 개발자가 사용 방식을 사용하는 한 두 가지 모두 안전합니다.</target>
        </trans-unit>
        <trans-unit id="54e0d751e792502d244f26c003fbc0168957db96" translate="yes" xml:space="preserve">
          <source>PHP has a specially-made function to prevent these attacks. All you need to do is use the mouthful of a function, &lt;code&gt;mysql_real_escape_string&lt;/code&gt;.</source>
          <target state="translated">PHP는 이러한 공격을 방지하기 위해 특수 제작 된 기능을 가지고 있습니다. &lt;code&gt;mysql_real_escape_string&lt;/code&gt; 함수를 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ccf9fc49cbe33f37545bdf96ec74793151180cf7" translate="yes" xml:space="preserve">
          <source>Parameterized query AND input validation is the way to go. There are many scenarios under which SQL injection may occur, even though &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; has been used.</source>
          <target state="translated">매개 변수화 된 쿼리 및 입력 유효성 검사가 진행됩니다. &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 이 사용되었지만 SQL 삽입이 발생할 수있는 많은 시나리오가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9efa2dbb908a0d252e5cd2661bab4bcef31b8aec" translate="yes" xml:space="preserve">
          <source>Please note that the case you asked about is a fairly simple one and that more complex cases may require more complex approaches. In particular:</source>
          <target state="translated">귀하가 요청한 사례는 매우 간단한 사례이며 더 복잡한 사례는 더 복잡한 접근법이 필요할 수 있습니다. 특히:</target>
        </trans-unit>
        <trans-unit id="bcf57ec934b9b4abfe2e011b6d61b8f3fe9b293d" translate="yes" xml:space="preserve">
          <source>Please see this question for more detail: &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO sends raw query to MySQL while Mysqli sends prepared query, both produce the same result&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">자세한 내용은이 질문을 참조하십시오 : &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18026088/pdo-sends-raw-query-to-mysql-while-mysqli-sends-prepared-query-both-produce-the&quot;&gt;PDO는 원시 쿼리를 MySQL로 보내고 Mysqli는 준비된 쿼리를 보냅니다. 둘 다 동일한 결과를 생성합니다&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="253bf3e933bdeac3a809eb91c495e40d9d61fe9d" translate="yes" xml:space="preserve">
          <source>Primary defenses:</source>
          <target state="translated">기본 방어 :</target>
        </trans-unit>
        <trans-unit id="d52155a58f068ac65eaa3922fec6c4b67e140457" translate="yes" xml:space="preserve">
          <source>Query for login authentication match:</source>
          <target state="translated">로그인 인증 일치 쿼리 :</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="058114cbca517a731cb958e54ea1701d36b6c3b4" translate="yes" xml:space="preserve">
          <source>Regarding many useful answers, I hope to add some value to this thread.</source>
          <target state="translated">많은 유용한 답변과 관련 하여이 스레드에 가치를 더하기를 희망합니다.</target>
        </trans-unit>
        <trans-unit id="e096b01f49b6da8c19f1bffa18f6d83e4dd4871e" translate="yes" xml:space="preserve">
          <source>Regardless of what PHP manual said for ages, &lt;strong&gt;&lt;code&gt;*_escape_string&lt;/code&gt; by no means makes data safe&lt;/strong&gt; and never has been intended to. Besides being useless for any SQL part other than string, manual escaping is wrong, because it is manual as opposite to automated.</source>
          <target state="translated">PHP 매뉴얼이 오래 &lt;strong&gt; &lt;code&gt;*_escape_string&lt;/code&gt; &lt;/strong&gt; 말한 것에 상관없이, &lt;strong&gt;* _escape_string 은&lt;/strong&gt; 결코 &lt;strong&gt;데이터를 안전하게&lt;/strong&gt; 만들지 않으며 결코 의도 된 적이 없습니다. 문자열 이외의 SQL 부분에는 쓸모가 없지만 수동 이스케이프는 자동이 아닌 수동이기 때문에 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b26d7b5c670dfa0c5a71f99bb87ebad73afd959" translate="yes" xml:space="preserve">
          <source>SECURITY UPDATE: The previous &lt;code&gt;str_replace&lt;/code&gt; version allowed injections by adding {#} tokens into user data. This &lt;code&gt;preg_replace_callback&lt;/code&gt; version doesn't cause problems if the replacement contains these tokens.</source>
          <target state="translated">보안 업데이트 : 이전 &lt;code&gt;str_replace&lt;/code&gt; 버전은 사용자 데이터에 {#} 토큰을 추가하여 주입을 허용했습니다. 이 &lt;code&gt;preg_replace_callback&lt;/code&gt; 버전은 교체에 이러한 토큰이 포함되어 있으면 문제를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2248f755da0797902356c62702fce90dfe90f334" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = -1 union all select column_name from information_schema.column where table_name = &lt;strong&gt;0x61727469636c65&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = -1 table_name = &lt;strong&gt;0x61727469636c65 인&lt;/strong&gt; information_schema.column에서 모든 select column_name을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="72ce3741372785fc3d1b9e81dc08822e0ee3697b" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE id = &lt;strong&gt;-1 union all select table_name from information_schema.tables&lt;/strong&gt;</source>
          <target state="translated">SELECT ... WHERE id = &lt;strong&gt;-1 information_schema.tables에서 모든 select table_name을 통합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2aaa640d6aff57cc99ee7b8f6b262da344d87124" translate="yes" xml:space="preserve">
          <source>SQL Injection</source>
          <target state="translated">SQL 인젝션</target>
        </trans-unit>
        <trans-unit id="aaae6cc0c6e64da88ddbf398d39cff7dd8d70208" translate="yes" xml:space="preserve">
          <source>SQL Injection Cheat Sheet</source>
          <target state="translated">SQL 인젝션 치트 시트</target>
        </trans-unit>
        <trans-unit id="df8511b36a40094461c2fa8100abbe0ef28e937c" translate="yes" xml:space="preserve">
          <source>SQL injection is an attack that can be done through user inputs (inputs that filled by a user and then used inside queries). The SQL injection patterns are correct query syntax while we can call it: bad queries for bad reasons, and we assume that there might be a bad person that try to get secret information (bypassing access control) that affect the three principles of security (confidentiality, integrity, and availability).</source>
          <target state="translated">SQL 주입은 사용자 입력 (사용자가 입력 한 다음 쿼리 내부에서 사용하는 입력)을 통해 수행 할 수있는 공격입니다. SQL 인젝션 패턴은 올바른 쿼리 구문이지만 호출 할 수 있습니다. 나쁜 이유는 잘못된 쿼리이며 보안의 세 가지 원칙 (기밀성)에 영향을주는 비밀 정보를 얻는 (액세스 제어 무시) 나쁜 사람이 있다고 가정합니다. , 무결성 및 가용성).</target>
        </trans-unit>
        <trans-unit id="4c18831b8c7d74dba4d4cf532d188cd34482c6be" translate="yes" xml:space="preserve">
          <source>SQL user (limiting user privilege): most common SQL operations are (SELECT, UPDATE, INSERT), then, why give the UPDATE privilege to a user that does not require it? For example, &lt;strong&gt;login, and search pages&lt;/strong&gt; are only using SELECT, then, why use DB users in these pages with high privileges?</source>
          <target state="translated">SQL 사용자 (제한된 사용자 권한) : 가장 일반적인 SQL 작업은 (SELECT, UPDATE, INSERT)인데, 왜 필요하지 않은 사용자에게 UPDATE 권한을 부여합니까? 예를 들어, &lt;strong&gt;로그인 및 검색 페이지&lt;/strong&gt; 는 SELECT 만 사용하는 경우 높은 권한을 가진이 페이지에서 DB 사용자를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3c9750d49c83fa8a5b3a0075cee19045e8360352" translate="yes" xml:space="preserve">
          <source>Security Principles</source>
          <target state="translated">보안 원칙</target>
        </trans-unit>
        <trans-unit id="8a0ff19685c3593d2dd9348235796673a86f433d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;최소 권한 원칙을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3bc5aad5e191c67a30c0d326b34a9e4894a1fec3" translate="yes" xml:space="preserve">
          <source>See also, the details of the &lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt;&lt;code&gt;mysql_real_escape_string&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/mysql_real_escape_string&quot;&gt; &lt;code&gt;mysql_real_escape_string&lt;/code&gt; &lt;/a&gt; 함수의 세부 사항도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be33bd1eb7dbd848bc959ced6f1d33144f31d5c8" translate="yes" xml:space="preserve">
          <source>So if you use a prepared statement, you must specify the types of the variables for &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; function.</source>
          <target state="translated">따라서 준비된 명령문을 사용하는 경우 &lt;code&gt;mysqli_stmt_bind_param&lt;/code&gt; 함수의 변수 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7791c9096ecb3c52f38cfacf2ed5a600ac8ac03b" translate="yes" xml:space="preserve">
          <source>So, a general recommendation may be phrased as</source>
          <target state="translated">따라서 일반적인 권장 사항은 다음과 같이 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4eb875965dcbc46634a834943ce8fb7d495d10" translate="yes" xml:space="preserve">
          <source>So, for example, the query:</source>
          <target state="translated">예를 들어 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfd8f629333fbfac1be3ab64cdcec4377eaa444d" translate="yes" xml:space="preserve">
          <source>So, unlike whatever &quot;escaping&quot;, prepared statements &lt;em&gt;is&lt;/em&gt; the measure that indeed protects from SQL injection (when applicable).</source>
          <target state="translated">따라서 &quot;이스케이프 처리&quot;와 달리 준비된 명령문 &lt;em&gt;은&lt;/em&gt; 실제로 SQL 삽입 (해당되는 경우)으로부터 보호하는 측정입니다.</target>
        </trans-unit>
        <trans-unit id="bdd6c788b4bc40941d92c120767a09a678ddf541" translate="yes" xml:space="preserve">
          <source>Still, there is an issue with SQL syntax keywords (such as &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt; and such), but white-listing seems the only approach in this case.</source>
          <target state="translated">여전히 SQL 구문 키워드 (예 : &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; 등)에 문제가 있지만이 경우에는 화이트 리스팅이 유일한 방법으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="25fe63edd9746e4a688d1d2796a06118495eb155" translate="yes" xml:space="preserve">
          <source>That's because the user can input something like &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt;, and the query becomes:</source>
          <target state="translated">사용자가 &lt;code&gt;value'); DROP TABLE table;--&lt;/code&gt; 와 같은 것을 입력 할 수 있기 때문입니다 . '); DROP TABLE 테이블;- 이며 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea6f46a1818ef256a65fd25fce4ef5438834b53d" translate="yes" xml:space="preserve">
          <source>The ** 0x** prefix can only be used for data columns such as &lt;strong&gt;char, varchar, text, block, binary, etc&lt;/strong&gt;.</source>
          <target state="translated">** 0x ** 접두사는 &lt;strong&gt;char, varchar, text, block, binary&lt;/strong&gt; 등과 같은 데이터 열에 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22493fd5585b849e0dfac158f0d91d71de2a9f53" translate="yes" xml:space="preserve">
          <source>The SQL statement you pass to &lt;code&gt;prepare&lt;/code&gt; is parsed and compiled by the database server. By specifying parameters (either a &lt;code&gt;?&lt;/code&gt; or a named parameter like &lt;code&gt;:name&lt;/code&gt; in the example above) you tell the database engine where you want to filter on. Then when you call &lt;code&gt;execute&lt;/code&gt;, the prepared statement is combined with the parameter values you specify.</source>
          <target state="translated">&lt;code&gt;prepare&lt;/code&gt; 하기 위해 전달한 SQL 문은 데이터베이스 서버에 의해 구문 분석되고 컴파일됩니다. 매개 변수 (위의 예에서 &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;:name&lt;/code&gt; 과 같은 명명 된 매개 변수)를 지정하여 데이터베이스 엔진에 필터링 할 위치를 알려줍니다. 그런 다음 &lt;code&gt;execute&lt;/code&gt; 를 호출하면 준비된 명령문이 지정한 매개 변수 값과 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="220daddb11e24bc5b6c1d64820ad3b7f7ddb93fa" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes
  considered a security feature to prevent SQL injection. The same
  degree of security can be achieved with non-prepared statements if
  input values are escaped correctly.</source>
          <target state="translated">서버 내에서 자동으로 값을 이스케이프 처리하는 것은 SQL 삽입을 방지하기위한 보안 기능으로 간주됩니다. 입력 값이 올바르게 이스케이프되면 준비되지 않은 명령문으로 동일한 보안 수준을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e19049bf34dbc02fad22f1e2a94559fad21acf0" translate="yes" xml:space="preserve">
          <source>The automatic escaping of values within the server is sometimes considered a security feature to prevent SQL injection. The same degree of security can be achieved with non-prepared statements, if input values are escaped correctly</source>
          <target state="translated">서버 내에서 자동으로 값을 이스케이프 처리하는 것은 SQL 삽입을 방지하기위한 보안 기능으로 간주됩니다. 입력 값이 올바르게 이스케이프되면 준비되지 않은 명령문으로 동일한 보안 수준을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf65f1abe7fe4e3d2342b41af2f1116791c2af6" translate="yes" xml:space="preserve">
          <source>The best way to prevent SQL Injection is to use &lt;strong&gt;Prepared Statements&lt;/strong&gt;&lt;em&gt;instead of escaping&lt;/em&gt;, as &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;the accepted answer&lt;/a&gt; demonstrates.</source>
          <target state="translated">SQL 주입을 방지하는 가장 좋은 방법 &lt;a href=&quot;https://stackoverflow.com/a/60496/2224584&quot;&gt;은 허용되는 답변&lt;/a&gt; 에서 알 수 있듯이 &lt;em&gt;이스케이프 대신&lt;/em&gt; &lt;strong&gt;준비된 문&lt;/strong&gt; 을 사용하는 &lt;em&gt;것입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc7e03df37b2e8c386abd1ebf523f1b7f2477d6" translate="yes" xml:space="preserve">
          <source>The disadvantages are -</source>
          <target state="translated">단점은-</target>
        </trans-unit>
        <trans-unit id="b02e13a130f7a3159e0982874d64e46b658e4a3d" translate="yes" xml:space="preserve">
          <source>The important thing here is that the parameter values are combined with the compiled statement, not an SQL string. SQL injection works by tricking the script into including malicious strings when it creates SQL to send to the database. So by sending the actual SQL separately from the parameters, you limit the risk of ending up with something you didn't intend.</source>
          <target state="translated">여기서 중요한 것은 매개 변수 값이 SQL 문자열이 아니라 컴파일 된 명령문과 결합된다는 것입니다. SQL 삽입은 데이터베이스에 보낼 SQL을 생성 할 때 악성 문자열을 포함하도록 스크립트를 속이는 방식으로 작동합니다. 따라서 실제 SQL을 매개 변수와 별도로 보내서 원하지 않는 것으로 끝나는 위험을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2ce25b2d0b72f92570aaba8ea168300f90b408b" translate="yes" xml:space="preserve">
          <source>The key function you'll want to read up on there would be &lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt;&lt;code&gt;mysqli::prepare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">읽으려는 주요 기능은 &lt;a href=&quot;http://php.net/mysqli.prepare&quot;&gt; &lt;code&gt;mysqli::prepare&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8329b222e736716b29e6f8c8d1bf0eb05508d581" translate="yes" xml:space="preserve">
          <source>The last point is detecting unexpected behavior which requires more effort and complexity; it's not recommended for normal web applications.</source>
          <target state="translated">마지막 요점은 더 많은 노력과 복잡성이 필요한 예기치 않은 동작을 감지하는 것입니다. 일반적인 웹 애플리케이션에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec2ec032df8d4e54047d67def864e600f72c7368" translate="yes" xml:space="preserve">
          <source>The most advanced way is to use PDOs.</source>
          <target state="translated">가장 진보 된 방법은 PDO를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="77a019a8e37c861117253efcafbe8b46c80d55cb" translate="yes" xml:space="preserve">
          <source>The other part will be discarded. So, what will happen? A non-authorized user (hacker) will be able to log in as administrator without having his/her password. Now, he/she can do anything that the administrator/email person can do. See, it's very dangerous if SQL injection is not prevented.</source>
          <target state="translated">다른 부분은 폐기됩니다. 그래서 어떻게 될까요? 권한이없는 사용자 (해커)는 비밀번호없이 관리자로 로그인 할 수 있습니다. 이제 관리자 / 이메일 담당자가 할 수있는 모든 작업을 수행 할 수 있습니다. SQL 주입이 방지되지 않으면 매우 위험합니다.</target>
        </trans-unit>
        <trans-unit id="caef473bbc5d786e58c45a04c732b8e95dae8488" translate="yes" xml:space="preserve">
          <source>The query will be parsed into the system only up to:</source>
          <target state="translated">쿼리는 다음과 같은 경우에만 시스템으로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="0600942d37431f06a2041faca7c57369364ca714" translate="yes" xml:space="preserve">
          <source>The simple alternative to this problem could be solved by granting appropriate permissions in the database itself.
For example: if you are using a MySQL database then enter into the database through terminal or the UI provided and just follow this command:</source>
          <target state="translated">이 문제에 대한 간단한 대안은 데이터베이스 자체에 적절한 권한을 부여하여 해결할 수 있습니다. 예를 들어, MySQL 데이터베이스를 사용하는 경우 제공된 터미널 또는 UI를 통해 데이터베이스에 입력하고 다음 명령을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="49869c7c4ee5782157501a3f5be9f08cda113757" translate="yes" xml:space="preserve">
          <source>There are libraries such as &lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt; and &lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt; that allow developers to use prepared statements easier. To learn more about why prepared statements are better at &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;stopping SQL injection&lt;/a&gt;, refer to &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;this &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; bypass&lt;/a&gt; and &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;recently fixed Unicode SQL Injection vulnerabilities in WordPress&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/auraphp/Aura.Sql&quot;&gt;Aura.Sql&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/paragonie/easydb&quot;&gt;EasyDB&lt;/a&gt; 와 같은 라이브러리가있어 개발자가 준비된 명령문을보다 쉽게 ​​사용할 수 있습니다. 준비된 명령문이 &lt;a href=&quot;https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide&quot;&gt;SQL 삽입&lt;/a&gt; 을 중지 하는 데 왜 더 좋은지에 대한 자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/a/12118602/2224584&quot;&gt;이 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 바이 패스&lt;/a&gt; 및 &lt;a href=&quot;https://kraft.im/2015/05/how-emoji-saved-your-sites-hide/&quot;&gt;최근에 수정 된 WordPress의 유니 코드 SQL 주입 취약점을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c789aef75c0a5b094c0f29903ad99459e880351c" translate="yes" xml:space="preserve">
          <source>There are likely other cases I'm not aware of. You might find &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;this&lt;/a&gt; is a useful resource on some of the more subtle problems you can encounter.</source>
          <target state="translated">내가 모르는 다른 경우가있을 수 있습니다. &lt;a href=&quot;http://webappsec.org/projects/articles/091007.txt&quot;&gt;이&lt;/a&gt; 문제는 발생할 수있는보다 미묘한 문제 중 일부에 대한 유용한 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="780ecc400391203ddd8ddd799d6ab422887cada5" translate="yes" xml:space="preserve">
          <source>There are many ways of preventing SQL injections and other SQL hacks. You can easily find it on the Internet (Google Search). Of course &lt;strong&gt;PDO is one of the good solutions.&lt;/strong&gt; But I would like to suggest you some good links prevention from SQL injection.</source>
          <target state="translated">SQL 삽입 및 기타 SQL 해킹을 방지하는 방법에는 여러 가지가 있습니다. 인터넷 (Google 검색)에서 쉽게 찾을 수 있습니다. 물론 &lt;strong&gt;PDO는 좋은 솔루션 중 하나입니다.&lt;/strong&gt; 그러나 SQL 인젝션으로부터 좋은 링크 방지를 제안하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="218c170e6057412489f970c39cfe283ca621a4f8" translate="yes" xml:space="preserve">
          <source>There are more abilities to prevent this: like identify - if the input is a string, number, char or array, there are so many inbuilt functions to detect this. Also, it would be better to use these functions to check input data.</source>
          <target state="translated">이를 방지하는 더 많은 기능이 있습니다. 식별과 같이-입력이 문자열, 숫자, 문자 또는 배열 인 경우이를 감지하는 내장 함수가 너무 많습니다. 또한이 기능을 사용하여 입력 데이터를 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="830b53ae56caf2de4b110b5e5e28b176692222da" translate="yes" xml:space="preserve">
          <source>There are so many answers for &lt;strong&gt;PHP and MySQL&lt;/strong&gt;, but here is code for &lt;strong&gt;PHP and Oracle&lt;/strong&gt; for preventing SQL injection as well as regular use of oci8 drivers:</source>
          <target state="translated">&lt;strong&gt;PHP와 MySQL에&lt;/strong&gt; 대한 많은 답변이 있지만 다음은 SQL 인젝션을 방지하고 정기적으로 oci8 드라이버를 사용하는 &lt;strong&gt;PHP 및 Oracle&lt;/strong&gt; 코드입니다.</target>
        </trans-unit>
        <trans-unit id="df8b9e7a092d7b299097fd0d02efb87caa3a7f13" translate="yes" xml:space="preserve">
          <source>There is another way to secure identifiers - escaping but I rather stick to whitelisting as a more robust and explicit approach. Yet as long as you have an identifier quoted, you can escape the quote character to make it safe. For example, by default for mysql you have to &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;double the quote character to escape it&lt;/a&gt;. For other other DBMS escaping rules would be different.</source>
          <target state="translated">식별자를 보호하는 또 다른 방법이 있습니다-이스케이프하지만 더 강력하고 명시적인 접근 방식으로 화이트리스트를 고수합니다. 그러나 인용 부호가있는 한 인용 부호 문자를 이스케이프 처리하여 안전하게 만들 수 있습니다. 예를 들어, mysql의 경우 기본적으로 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/identifiers.html&quot;&gt;따옴표 문자를 두 배로 사용하여 이스케이프 처리해야합니다&lt;/a&gt; . 다른 DBMS 탈출 규칙은 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f884dfef89c26e94f34c8d0d17a3e45bfbc8acd8" translate="yes" xml:space="preserve">
          <source>There was some discussion in comments, so I finally want to make it clear. These two approaches are very similar, but they are a little different in some ways:</source>
          <target state="translated">의견에 대한 토론이 있었으므로 마침내 분명히하고 싶습니다. 이 두 가지 접근 방식은 매우 유사하지만 몇 가지면에서 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="224c361000365c82c6c9b9f7d7a6ec856e58482b" translate="yes" xml:space="preserve">
          <source>Therefore, this proves that data validation such as &lt;code&gt;intval()&lt;/code&gt; is a good idea for integer values before sending any query. In addition, preventing malicious user data before sending the query is &lt;strong&gt;a correct and valid approach&lt;/strong&gt;.</source>
          <target state="translated">따라서 이것은 &lt;code&gt;intval()&lt;/code&gt; 과 같은 데이터 유효성 검사가 쿼리를 보내기 전에 정수 값에 대한 좋은 아이디어임을 증명합니다. 또한 쿼리를 보내기 전에 악의적 인 사용자 데이터를 방지 &lt;strong&gt;하는 것이 정확하고 올바른 방법&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82972fc3059a1c85c5e906a0ee53efee54cb0064" translate="yes" xml:space="preserve">
          <source>They (stored procedures) are tough to maintain and tend to multiply very quickly. This makes managing them an issue.</source>
          <target state="translated">그것들은 (저장된 절차) 유지하기가 어렵고 매우 빠르게 번식하는 경향이 있습니다. 이것은 그들을 관리하는 것을 문제로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9db87902986489638b3a9991da4a7a39a2f10d0c" translate="yes" xml:space="preserve">
          <source>They abstract the raw SQL query from the application so less information of the database structure is available to the application. This makes it harder for people to understand the underlying structure of the database and design suitable attacks.</source>
          <target state="translated">이들은 응용 프로그램에서 원시 SQL 조회를 추상화하므로 응용 프로그램에 사용 가능한 데이터베이스 구조 정보가 적습니다. 따라서 사람들은 데이터베이스의 기본 구조를 이해하고 적절한 공격을 설계하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="63f9a45d5192235d9d02af20e18d0355ff4d3bbe" translate="yes" xml:space="preserve">
          <source>They accept only parameters, so the advantages of parameterized queries are there. Of course - IMO you still need to sanitize your input - especially if you are using dynamic SQL inside the stored procedure.</source>
          <target state="translated">매개 변수 만 허용하므로 매개 변수화 된 쿼리의 장점이 있습니다. 물론 IMO는 특히 저장 프로 시저 내에서 동적 SQL을 사용하는 경우 입력을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="da88560285c94420f786914a9987bc73dbdb490a" translate="yes" xml:space="preserve">
          <source>They are not very suitable for dynamic queries - if they are built to accept dynamic code as parameters then a lot of the advantages are negated.</source>
          <target state="translated">동적 쿼리에는 적합하지 않습니다. 동적 코드를 매개 변수로 받아들이도록 만들어지면 많은 장점이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a718b71211da4fde3996aa73a97cdfec744e2e31" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/MySQLi&quot;&gt;MySQLi&lt;/a&gt; 학습에 대해 생각하십시오</target>
        </trans-unit>
        <trans-unit id="4bc28bb81fa5e19dbc4f90b70f46fd3864b30aac" translate="yes" xml:space="preserve">
          <source>Think about learning &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) &amp;ndash; it is a database access layer providing a uniform method of access to multiple databases.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (PHP Data Objects) 학습에 대해 생각해보십시오. PDO (PHP Data Objects)는 여러 데이터베이스에 대한 균일 한 액세스 방법을 제공하는 데이터베이스 액세스 계층입니다.</target>
        </trans-unit>
        <trans-unit id="b269ba0fd879f3932b2b527ca85caeb00cf5ba6e" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;question&lt;/a&gt; has some good answers about this.</source>
          <target state="translated">이 &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;질문&lt;/a&gt; 에는 이것에 대한 좋은 대답이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ad37abc91646ccd8977cbbc7608b0efd79be0e" translate="yes" xml:space="preserve">
          <source>This allows running statements in an one-liner C#-ish String.Format like:</source>
          <target state="translated">이를 통해 한 줄짜리 C # -ish String에서 명령문을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d422b5f7b27e73794ff7c5132ab85405bcfe5b91" translate="yes" xml:space="preserve">
          <source>This hex method is often used when you transfer binary data, but I see no reason why not use it on all data to prevent SQL injection attacks. Note that you have to prepend data with &lt;code&gt;0x&lt;/code&gt; or use the MySQL function &lt;code&gt;UNHEX&lt;/code&gt; instead.</source>
          <target state="translated">이 16 진 방법은 이진 데이터를 전송할 때 종종 사용되지만 SQL 주입 공격을 방지하기 위해 모든 데이터에 사용하지 않는 이유는 없습니다. &lt;code&gt;0x&lt;/code&gt; 로 데이터를 추가하거나 대신 MySQL 함수 &lt;code&gt;UNHEX&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="10c3b317d4690df3f686ef3a89e96ef8591796f2" translate="yes" xml:space="preserve">
          <source>This input can be checked early without any prepared statement and stored procedures, but to be on the safe side, using them starts after user-data filtering and validation.</source>
          <target state="translated">이 입력은 준비된 명령문 및 스토어드 프로 시저없이 조기에 점검 할 수 있지만 사용자 데이터 필터링 및 유효성 검증 후에 시작하여 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f5c7f0ce17d7d18825ad4c94168610dc65618a" translate="yes" xml:space="preserve">
          <source>This will restrict the user to only get confined with the specified query's only. Remove the delete permission and so the data would never get deleted from the query fired from the PHP page.
The second thing to do is to flush the privileges so that the MySQL refreshes the permissions and updates.</source>
          <target state="translated">이것은 사용자가 지정된 쿼리에만 제한되도록 제한합니다. 삭제 권한을 제거하면 PHP 페이지에서 실행 된 쿼리에서 데이터가 삭제되지 않습니다. 두 번째로해야 할 일은 MySQL이 권한과 업데이트를 새로 고치도록 권한을 플러시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fff7386dc03b73f854a16a474ef2b8c2fda58dc3" translate="yes" xml:space="preserve">
          <source>This won't solve every problem, but it's a very good stepping stone. I left out obvious items such as checking the variable's existence, format (numbers, letters, etc.).</source>
          <target state="translated">이것은 모든 문제를 해결하지는 못하지만 매우 훌륭한 디딤돌입니다. 변수의 존재, 형식 (숫자, 문자 등)을 확인하는 것과 같은 명백한 항목을 제외했습니다.</target>
        </trans-unit>
        <trans-unit id="16c9cc86f82e3a7c1ca1d9b3739a49f6e61d2e8e" translate="yes" xml:space="preserve">
          <source>Those examples are vulnerable to SQL injection:</source>
          <target state="translated">이러한 예제는 SQL 삽입에 취약합니다.</target>
        </trans-unit>
        <trans-unit id="8789487a1a2a5eb11f2a7cfa438ec136c375dc71" translate="yes" xml:space="preserve">
          <source>To ease the process I wrote a &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;whitelist helper function&lt;/a&gt; that does all the job in one line:</source>
          <target state="translated">프로세스를 쉽게하기 위해 한 줄에 모든 작업을 수행하는 &lt;a href=&quot;https://phpdelusions.net/pdo_examples/order_by&quot;&gt;화이트리스트 도우미 기능&lt;/a&gt; 을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="fa14c04c76de2e2fab6840f10e0b4d476494ed7a" translate="yes" xml:space="preserve">
          <source>To see the current privileges for the user fire the following query.</source>
          <target state="translated">사용자에 대한 현재 권한을 보려면 다음 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b6cd0f951a947782e4aa09afbcf7e67bd3612b70" translate="yes" xml:space="preserve">
          <source>To use the parameterized query, you need to use &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; rather than the &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt; functions. To rewrite your example, we would need something like the following.</source>
          <target state="translated">파라미터 화 된 쿼리를 사용하려면 &lt;a href=&quot;http://php.net/mysql&quot;&gt;MySQL&lt;/a&gt; 함수 대신 &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; 를 사용해야합니다. 예제를 다시 작성하려면 다음과 같은 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92ea56f2bcd611121ebf82d1bb94be8a12add9bd" translate="yes" xml:space="preserve">
          <source>UPDATE 1:</source>
          <target state="translated">업데이트 1 :</target>
        </trans-unit>
        <trans-unit id="f1e7ccfb017f1e9286a26f4401498e961fa8566b" translate="yes" xml:space="preserve">
          <source>Unexpected behavior in the above user input is SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA, and root. Once these words detected, you can avoid the input.</source>
          <target state="translated">위의 사용자 입력에서 예기치 않은 동작은 SELECT, UNION, IF, SUBSTRING, BENCHMARK, SHA 및 root입니다. 이러한 단어가 감지되면 입력을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="58b2e2813f252bd73c0a240fc752d08e7de81f2b" translate="yes" xml:space="preserve">
          <source>Update 2:</source>
          <target state="translated">업데이트 2 :</target>
        </trans-unit>
        <trans-unit id="ab598eb253cb41b46f92f26312a455cadea5aee1" translate="yes" xml:space="preserve">
          <source>Update 3:</source>
          <target state="translated">업데이트 3 :</target>
        </trans-unit>
        <trans-unit id="a097c6d2f311ec0bb34ee1571b93398b7da217e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;PDO&lt;/code&gt; and prepared queries.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 및 준비된 쿼리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="536e4e3355286cdf5ee35d48911488b38952ca82" translate="yes" xml:space="preserve">
          <source>Use native PHP functions like: &lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt;, &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string&lt;/a&gt; or if variable numeric, just &lt;code&gt;(int)$foo&lt;/code&gt;. Read more about type of variables in PHP &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;here&lt;/a&gt;. If you're using libraries such as PDO or MySQLi, always use &lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO::quote()&lt;/a&gt; and &lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strip-tags.php&quot;&gt;strip_tags&lt;/a&gt; , &lt;a href=&quot;http://php.net/manual/en/function.mysql-real-escape-string.php&quot;&gt;mysql_real_escape_string&lt;/a&gt; 과 같은 고유 PHP 함수를 사용하거나 변수 숫자 인 경우 &lt;code&gt;(int)$foo&lt;/code&gt; . PHP의 변수 유형에 대한 자세한 내용은 &lt;a href=&quot;http://php.net/manual/en/language.types.php&quot;&gt;여기를 참조하십시오&lt;/a&gt; . PDO 또는 MySQLi와 같은 라이브러리를 사용하는 경우 항상 &lt;a href=&quot;http://php.net/manual/en/pdo.quote.php&quot;&gt;PDO :: quote ()&lt;/a&gt; 및 &lt;a href=&quot;http://php.net/manual/en/mysqli.real-escape-string.php&quot;&gt;mysqli_real_escape_string ()을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d38f5f0dc278ebfe3743f0e9d9ad122b9d88ce8f" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;, which is a pre-defined function in &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;, and this code add backslashes to the following characters: &lt;code&gt;\x00&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\x1a&lt;/code&gt;. Pass the input values as parameters to minimize the chance of SQL injection.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; 에서 사전 정의 된 함수 인 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 사용 및이 코드는 &lt;code&gt;\x00&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; 및 &lt;code&gt;\x1a&lt;/code&gt; 문자에 백 슬래시를 추가합니다. 입력 값을 매개 변수로 전달하십시오. SQL 삽입 가능성을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="56d170f163928a8c1fff4954924527fa155e8ca3" translate="yes" xml:space="preserve">
          <source>Use other tools: Here, I will also agree with you that a prepared statement (parametrized query) and stored procedures. The disadvantages here is these ways require advanced skills which do not exist for most users. The basic idea here is to distinguish between the SQL query and the data that is used inside. Both approaches can be used even with unsafe data, because the user-input data here does not add anything to the original query, such as (any or x=x).</source>
          <target state="translated">다른 도구를 사용하십시오. 여기서는 준비된 문 (매개 변수화 된 쿼리) 및 저장 프로 시저에 동의합니다. 여기서 단점은 이러한 방식에는 대부분의 사용자에게는 존재하지 않는 고급 기술이 필요하다는 것입니다. 여기서 기본 아이디어는 SQL 쿼리와 내부에서 사용되는 데이터를 구별하는 것입니다. 여기서 사용자 입력 데이터는 (any 또는 x = x)와 같이 원래 쿼리에 아무것도 추가하지 않기 때문에 안전하지 않은 데이터에서도 두 방법을 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab1b2c4d270d99ef373efcd0f8b8574c802370d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt; and &lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi&lt;/a&gt; is a good practice to prevent SQL injections, but if you really want to work with MySQL functions and queries, it would be better to use</source>
          <target state="translated">&lt;a href=&quot;http://in3.php.net/pdo&quot;&gt;PDO&lt;/a&gt; 및 &lt;a href=&quot;http://in3.php.net/mysqli&quot;&gt;MYSQLi를&lt;/a&gt; 사용하는 것은 SQL 삽입을 방지하는 좋은 방법이지만 실제로 MySQL 함수 및 쿼리로 작업하려면 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="38c0c660c5df9571196ca554badedbf16ace904b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; (for MySQL):</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; 사용 (MySQL의 경우) :</target>
        </trans-unit>
        <trans-unit id="a4e7bd1b02d3303b9bd6d557965df01c324c3557" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; (for any supported database driver):</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; 사용 (지원되는 모든 데이터베이스 드라이버) :</target>
        </trans-unit>
        <trans-unit id="64fd160974da8c9008dad32fa19315d8009920f4" translate="yes" xml:space="preserve">
          <source>Using this PHP function &lt;code&gt;mysql_escape_string()&lt;/code&gt; you can get a good prevention in a fast way.</source>
          <target state="translated">이 PHP 함수 &lt;code&gt;mysql_escape_string()&lt;/code&gt; 을 사용하면 빠른 방법으로 좋은 예방을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a08ce38eb2066c704c7481d4b7d5c8f7699f5" translate="yes" xml:space="preserve">
          <source>We'll cover the lower impact string escaping one first.</source>
          <target state="translated">먼저 영향을 줄이는 낮은 문자열을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0ca7362248cae31401c4742155c18ebaa5ff23d" translate="yes" xml:space="preserve">
          <source>What can be done to prevent this from happening?</source>
          <target state="translated">이 문제가 발생하지 않도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4ec900e30a04771ad57031ac632ba224fe5ec06c" translate="yes" xml:space="preserve">
          <source>What is &lt;strong&gt;mandatory&lt;/strong&gt;, however, is the first &lt;code&gt;setAttribute()&lt;/code&gt; line, which tells PDO to disable emulated prepared statements and use &lt;em&gt;real&lt;/em&gt; prepared statements. This makes sure the statement and the values aren't parsed by PHP before sending it to the MySQL server (giving a possible attacker no chance to inject malicious SQL).</source>
          <target state="translated">그러나 &lt;strong&gt;필수 사항&lt;/strong&gt; 은 첫 번째 &lt;code&gt;setAttribute()&lt;/code&gt; 행으로, PDO에 에뮬레이트 된 준비된 명령문을 비활성화하고 &lt;em&gt;실제&lt;/em&gt; 준비된 명령문을 사용하도록 지시합니다. 이를 통해 PHP가 명령문과 값을 구문 분석하지 않고이를 MySQL 서버로 전송합니다 (가능한 공격자에게 악의적 인 SQL을 삽입 할 기회를주지 않음).</target>
        </trans-unit>
        <trans-unit id="4a061bb9449a7869b1bb6c140f6c244c24e19160" translate="yes" xml:space="preserve">
          <source>Whatever you do end up using, make sure that you check your input hasn't already been mangled by &lt;code&gt;magic_quotes&lt;/code&gt; or some other well-meaning rubbish, and if necessary, run it through &lt;code&gt;stripslashes&lt;/code&gt; or whatever to sanitize it.</source>
          <target state="translated">결국 사용하는 것이 무엇이든, 입력이 &lt;code&gt;magic_quotes&lt;/code&gt; 또는 다른 의미있는 쓰레기에 의해 이미 엉망이되지 않았는지 확인하고 필요한 경우 &lt;code&gt;stripslashes&lt;/code&gt; 또는 위생 처리를 통해 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="00f02bbdebbfdbc228c8163a6409202a17282e4d" translate="yes" xml:space="preserve">
          <source>While you can still use prepared statements for the query parameters, the structure of the dynamic query itself cannot be parametrized and certain query features cannot be parametrized.</source>
          <target state="translated">쿼리 매개 변수에 준비된 문을 계속 사용할 수는 있지만 동적 쿼리 자체의 구조를 매개 변수화 할 수 없으며 특정 쿼리 기능을 매개 변수화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ac6d9646522fe48ad32b3fffb2a4692cff0ee0f" translate="yes" xml:space="preserve">
          <source>Will become:</source>
          <target state="translated">될 것입니다:</target>
        </trans-unit>
        <trans-unit id="204b32dc579f45400949999976e4e7bd02995817" translate="yes" xml:space="preserve">
          <source>You basically have two options to achieve this:</source>
          <target state="translated">기본적으로이를 달성하기위한 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec00a1df9d6128980fc27b80f095461babcb7153" translate="yes" xml:space="preserve">
          <source>You can find more details in &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL - SQL Injection Prevention&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">자세한 내용은 &lt;em&gt;&lt;a href=&quot;http://www.tizag.com/mysqlTutorial/mysql-php-sql-injection.php&quot;&gt;MySQL-SQL 주입 방지&lt;/a&gt;&lt;/em&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b865044a62cd48efbfda9b53b850310ecec07a85" translate="yes" xml:space="preserve">
          <source>You could do something basic like this:</source>
          <target state="translated">다음과 같은 기본적인 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cff3e61f8aade5ced706b23961eeb5d59ba96ea" translate="yes" xml:space="preserve">
          <source>You've got two options - escaping the special characters in your &lt;code&gt;unsafe_variable&lt;/code&gt;, or using a parameterized query. Both would protect you from SQL injection. The parameterized query is considered the better practice but will require changing to a newer MySQL extension in PHP before you can use it.</source>
          <target state="translated">&lt;code&gt;unsafe_variable&lt;/code&gt; 의 특수 문자를 이스케이프 처리하거나 매개 변수화 된 쿼리를 사용하는 두 가지 옵션이 있습니다. 둘 다 SQL 인젝션으로부터 보호합니다. 파라미터 화 된 쿼리는 더 나은 방법으로 간주되지만 PHP에서 새로운 MySQL 확장으로 변경해야 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">숫자</target>
        </trans-unit>
        <trans-unit id="555d01e6c83266b3e9f92bd811905370caf62770" translate="yes" xml:space="preserve">
          <source>a string</source>
          <target state="translated">줄</target>
        </trans-unit>
        <trans-unit id="5bb5bc166d482477e7f41c8996346a70df7264aa" translate="yes" xml:space="preserve">
          <source>a syntax keyword</source>
          <target state="translated">구문 키워드</target>
        </trans-unit>
        <trans-unit id="415dd55dd005527a8b6d386ea933f1cb842449b8" translate="yes" xml:space="preserve">
          <source>an attack can inject you very &lt;em&gt;easily&lt;/em&gt;. Consider the following injected code returned from your script:</source>
          <target state="translated">공격은 매우 &lt;em&gt;쉽게&lt;/em&gt; 주사 할 &lt;em&gt;수 있습니다&lt;/em&gt; . 스크립트에서 반환 된 다음과 같은 삽입 된 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="eb4952e764d7c270f5b65eab412865f0e3d1e28d" translate="yes" xml:space="preserve">
          <source>an identifier</source>
          <target state="translated">식별자</target>
        </trans-unit>
        <trans-unit id="e371325eaf8cf1513b8fb5c935edacb07019dc53" translate="yes" xml:space="preserve">
          <source>and now just extract table structure:</source>
          <target state="translated">이제 테이블 구조를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="00a568b3ade5326f00d2f75efc890a8fa7d228a0" translate="yes" xml:space="preserve">
          <source>and password anything....</source>
          <target state="translated">그리고 무엇이든 암호 ....</target>
        </trans-unit>
        <trans-unit id="dcdc68162ecd47207ad2d4500cb7f65ba1b2f599" translate="yes" xml:space="preserve">
          <source>is_numeric</source>
          <target state="translated">is_numeric</target>
        </trans-unit>
        <trans-unit id="b32f9e192cce5e6c514823660d6fc173cb3dd500" translate="yes" xml:space="preserve">
          <source>is_string</source>
          <target state="translated">is_string</target>
        </trans-unit>
        <trans-unit id="77064c82097c6f5dee58b4d6d530b90e598c4da1" translate="yes" xml:space="preserve">
          <source>more information about &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;flush&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/flush.html&quot;&gt;flush&lt;/a&gt; 에 대한 추가 정보.</target>
        </trans-unit>
        <trans-unit id="71d20c07a9f068a85df7519fb5b1a4e4eecf531f" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string</source>
          <target state="translated">mysql_real_escape_string</target>
        </trans-unit>
        <trans-unit id="6ccd64ba549314b5da86aaa89a6184349dcc2710" translate="yes" xml:space="preserve">
          <source>mysql_real_escape_string() will not protect here. If you use single quotes (' ') around your variables inside your query is what protects you against this. Here is an solution below for this:</source>
          <target state="translated">mysql_real_escape_string ()은 여기서 보호하지 않습니다. 쿼리 내부의 변수 주위에 작은 따옴표 ( '')를 사용하면이를 방지 할 수 있습니다. 이에 대한 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
