<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/605845">
    <body>
      <group id="605845">
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">&amp;mdash;字符类型。</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash;与对象的有效类型兼容的类型的限定版本，</target>
        </trans-unit>
        <trans-unit id="e44f2c14403ad448407e98ab24bfdee66bfa24a3" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash;与对象的有效类型兼容的类型，</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,</source>
          <target state="translated">&amp;mdash;一种类型，是与对象的有效类型的限定版本相对应的有符号或无符号类型，</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the
  object,</source>
          <target state="translated">&amp;mdash;一个类型，它是与对象的有效类型相对应的有符号或无符号类型，</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">&amp;mdash;集合或联合类型，其成员中包括上述类型之一（递归地包括子集合或包含的联合的成员），或</target>
        </trans-unit>
        <trans-unit id="ae7e0cdae2ac7249d987bff149081b201e3a0fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;malloc&lt;/code&gt; was not declared within this scope</source>
          <target state="translated">未在此范围内声明 &lt;code&gt;malloc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5f928812738db0ec93ccf2bf989d2ddde07c40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in the case of C.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 将自动安全地提升为任何其他指针类型。</target>
        </trans-unit>
        <trans-unit id="a391dd112c4d19334c4d2262800b52d709ef87f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;铸造的优势&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70e320e2947eef2af5ecd6ba7d5df9624b0e3047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;铸造的缺点&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2846f9a1c6a1377c632edfa1214b7fc3a69f21f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;铸造有一定意义。 当您使用数组表示法时，生成的代码必须知道要到达下一个元素的开头要前进多少个内存位置，这是通过强制转换实现的。 这样一来，您就知道双精度字要比前面多8个字节，而int型字要比前面多4个字节，依此类推。 因此，如果使用指针表示法则没有任何效果，而在数组表示法中则很有必要。</target>
        </trans-unit>
        <trans-unit id="ecf1f68c1a0bb45cb2b18963cb8bbc692db8e531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No&lt;/strong&gt;; you &lt;em&gt;don't&lt;/em&gt; cast the result, since:</source>
          <target state="translated">&lt;strong&gt;没有&lt;/strong&gt; 您&lt;em&gt;不&lt;/em&gt;投放结果，因为：</target>
        </trans-unit>
        <trans-unit id="f479abc04339b7f7648e42d0dcae330fdbce9d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The casting of malloc is unnecessary in C but mandatory in C++.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc的强制转换在C中是不必要的，但在C ++中是强制性的。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="05ecd5960f9d99ecd5ac614c91583260f522bd42" translate="yes" xml:space="preserve">
          <source>A typical reason given for not doing so is that failure to &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; could go unnoticed. This isn't an issue anymore for a long time now as C99 made &lt;em&gt;implicit function declarations&lt;/em&gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.</source>
          <target state="translated">给出的不这样做的典型原因是，可能导致 &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 的失败被忽略。 由于C99将&lt;em&gt;隐式函数声明定为&lt;/em&gt;非法，因此现在不再是一个问题了，因此，如果您的编译器至少符合C99，您将收到诊断消息。</target>
        </trans-unit>
        <trans-unit id="2a368dec1332cfeb0f803131ba36c04da26e07ad" translate="yes" xml:space="preserve">
          <source>A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).</source>
          <target state="translated">void 指针可以从任何其他的指针类型转换为其他的指针类型,而不需要显式铸造(C11 6.3.2.3和6.5.16.1)。</target>
        </trans-unit>
        <trans-unit id="0471ce3799acd66098fce34b5150690360d1c931" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">void指针是一种通用的对象指针,C语言支持将void指针类型隐式转换为其他类型,因此不需要显式地将其类型化。</target>
        </trans-unit>
        <trans-unit id="a26d186fb3412a6fc71664243f45c9e7df4a5f6e" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">void指针是一个通用指针,C语言支持从void指针类型到其他类型的隐式转换,因此不需要显式地将其类型化。</target>
        </trans-unit>
        <trans-unit id="d2e4fe0f4f3fae71f095a8f015fe0d1094245585" translate="yes" xml:space="preserve">
          <source>Adding the cast may mask failure to include the header &lt;em&gt;stdlib.h&lt;/em&gt;, in
  which the prototype for malloc is found. In the absence of a
  prototype for malloc, the standard requires that the C compiler
  assume malloc returns an int. If there is no cast, a warning is
  issued when this integer is assigned to the pointer; however, with
  the cast, this warning is not produced, hiding a bug. On certain
  architectures and data models (such as LP64 on 64-bit systems, where
  long and pointers are 64-bit and int is 32-bit), this error can
  actually result in undefined behaviour, as the implicitly declared
  malloc returns a 32-bit value whereas the actually defined function
  returns a 64-bit value. Depending on calling conventions and memory
  layout, this may result in stack smashing. This issue is less likely
  to go unnoticed in modern compilers, as they uniformly produce
  warnings that an undeclared function has been used, so a warning will
  still appear. For example, GCC's default behaviour is to show a
  warning that reads &quot;incompatible implicit declaration of built-in
  function&quot; regardless of whether the cast is present or not.</source>
          <target state="translated">添加强制类型转换可能会掩盖未能包含标头&lt;em&gt;stdlib.h的&lt;/em&gt;失败，在标头中找到了malloc的原型。 在没有malloc原型的情况下，该标准要求C编译器假定malloc返回一个int。 如果没有强制转换，则在将此整数分配给指针时发出警告；否则，将发出警告。 但是，使用强制转换时，不会产生此警告，从而隐藏了错误。 在某些体系结构和数据模型（例如long和指针为64位而int为32位的64位系统上的LP64）上，此错误实际上可能导致未定义的行为，因为隐式声明的malloc返回32-位值，而实际定义的函数返回64位值。 根据调用约定和内存布局，这可能会导致堆栈崩溃。 在现代编译器中，此问题不太可能被忽略，因为它们会统一生成警告，表明已使用未声明的函数，因此仍会出现警告。 例如，GCC的默认行为是显示一条警告，显示&amp;ldquo;内置函数的不兼容隐式声明&amp;rdquo;，而不管是否存在强制转换。</target>
        </trans-unit>
        <trans-unit id="330de36771a8855149af70009a392efe7137c117" translate="yes" xml:space="preserve">
          <source>Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.</source>
          <target state="translated">另外要注意的是,正如评论家们所指出的,上面说的是直接的C语言,而不是C++。我非常坚定地认为C和C++是不同的语言。</target>
        </trans-unit>
        <trans-unit id="49b4f10f65b03b7676c9928862b57a7bb5936eaa" translate="yes" xml:space="preserve">
          <source>Although &lt;strong&gt;malloc without casting is preferred method and most experienced programmers choose it&lt;/strong&gt;, you should use whichever you like having aware of the issues.</source>
          <target state="translated">尽管&lt;strong&gt;不进行强制转换的malloc是首选方法，并且大多数有经验的程序员都选择它&lt;/strong&gt; ，但是您应该使用任何了解问题的方法。</target>
        </trans-unit>
        <trans-unit id="82b3b63ccc5e46c358ff4d906c737902b003bf00" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:</source>
          <target state="translated">对象的存储值只能由具有以下类型之一的lvalue表达式访问。</target>
        </trans-unit>
        <trans-unit id="415ebcd3f0d0eb14cdd2373b4ef70b900e3218af" translate="yes" xml:space="preserve">
          <source>And indeed the &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11 standard&lt;/a&gt; (p347) says so:</source>
          <target state="translated">实际上， &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11标准&lt;/a&gt; （p347）表示：</target>
        </trans-unit>
        <trans-unit id="106cd39a268698352cf10943c417d2f7799f7985" translate="yes" xml:space="preserve">
          <source>And, sometimes surprisingly, the following is as well:</source>
          <target state="translated">而且,有时出人意料的是,下面也是如此。</target>
        </trans-unit>
        <trans-unit id="98cee4f987282b9a2bc48df1269201546773ac75" translate="yes" xml:space="preserve">
          <source>As a clarification, note that I said &quot;you don't cast&quot;, not &quot;you don't &lt;em&gt;need&lt;/em&gt; to cast&quot;. In my opinion, it's a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don't know about the risks.</source>
          <target state="translated">为了澄清起见，请注意我说的是&amp;ldquo;您不要投&amp;rdquo;，而不是&amp;ldquo;您&lt;em&gt;不需要&lt;/em&gt;投&amp;rdquo;。 我认为，即使您没做错，也不能包括演员表。 这样做根本没有任何好处，但是有很多潜在风险，包括强制转换说明您并不了解这些风险。</target>
        </trans-unit>
        <trans-unit id="52d6db561d5a32a930d6064e45cfff6f3d42fec9" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++.</source>
          <target state="translated">正如其他人所言,对于C语言来说,不需要,但对于C++来说,却不需要。</target>
        </trans-unit>
        <trans-unit id="d1b5b1727f0d804cd9571ddd5eeac48d6b713bf5" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++. If you think you are going to compile your C code with a C++ compiler, for which reasons ever, you can use a macro instead, like:</source>
          <target state="translated">正如其他人所说的那样,C语言不需要它,而C++则不需要。如果你认为你要用C++编译器来编译你的C语言代码,出于什么原因,你可以用宏来代替,比如。</target>
        </trans-unit>
        <trans-unit id="336cb3d7090a86262459260c2cb734602c2436e0" translate="yes" xml:space="preserve">
          <source>Because &lt;strong&gt;stdlib.h&lt;/strong&gt; contains the prototype for malloc is found. In the
absence of a prototype for malloc, the standard requires that the C
compiler assumes malloc returns an int. If there is no cast, a
warning is issued when this integer is assigned to the pointer;
however, with the cast, this warning is not produced, hiding a bug.</source>
          <target state="translated">因为&lt;strong&gt;stdlib.h&lt;/strong&gt;包含找到malloc的原型。 在没有malloc原型的情况下，该标准要求C编译器假定malloc返回一个int。 如果没有强制转换，则在将此整数分配给指针时发出警告；否则，将发出警告。 但是，使用强制转换时，不会产生此警告，从而隐藏了错误。</target>
        </trans-unit>
        <trans-unit id="bdc72cf404853fbac86b2c23dcbbf0c9e530081f" translate="yes" xml:space="preserve">
          <source>But if you cast then, it can hide an error if you forgot to include
&lt;strong&gt;stdlib.h&lt;/strong&gt;. This can cause crashes (or, worse, not cause a crash
until way later in some totally different part of the code).</source>
          <target state="translated">但是，如果您进行强制转换，那么如果忘记包括&lt;strong&gt;stdlib.h&lt;/strong&gt; ，它可能会隐藏错误。 这可能会导致崩溃（或更糟糕的是，直到稍后在代码的某些完全不同的部分中才导致崩溃）。</target>
        </trans-unit>
        <trans-unit id="607d50bbf8a35ccb5efb5dcb48502884b9e0b8a2" translate="yes" xml:space="preserve">
          <source>But that is really a non-issue. You aren't using a 25 years old computer, so why would you use a 25 years old compiler?</source>
          <target state="translated">但这真的是个不重要的问题。你用的又不是25年的电脑,为什么要用25年的编译器?</target>
        </trans-unit>
        <trans-unit id="944b838189a9bff8c526a212fceaae45ebfd75be" translate="yes" xml:space="preserve">
          <source>But there's a &lt;strong&gt;much stronger reason&lt;/strong&gt; not to introduce unnecessary pointer casts:</source>
          <target state="translated">但是有一个&lt;strong&gt;更强烈的理由&lt;/strong&gt;不引入不必要的指针强制转换：</target>
        </trans-unit>
        <trans-unit id="478bb2a442cb08ae6c0bbcddf6fd2f695a1f51d8" translate="yes" xml:space="preserve">
          <source>C has a well specified ABI</source>
          <target state="translated">C有一个明确的ABI</target>
        </trans-unit>
        <trans-unit id="944a73e911447184dc231ecc770caa2caeec4d8e" translate="yes" xml:space="preserve">
          <source>C++ may generate more code [exceptions, RTTI, templates, &lt;em&gt;runtime&lt;/em&gt; polymorphism]</source>
          <target state="translated">C ++可能会生成更多代码[异常，RTTI，模板， &lt;em&gt;运行时&lt;/em&gt;多态性]</target>
        </trans-unit>
        <trans-unit id="ff9f56607dcdf5bb324bf522b13344b0a6d2e767" translate="yes" xml:space="preserve">
          <source>C++ will however not allow an implicit cast between &lt;code&gt;void*&lt;/code&gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use &lt;code&gt;new&lt;/code&gt; and not malloc(). And you should never compile C code using a C++ compiler.</source>
          <target state="translated">但是，C ++不允许在 &lt;code&gt;void*&lt;/code&gt; 和其他指针类型之间进行隐式转换。 因此，在C ++中，强制转换将是正确的。 但是，如果您使用C ++编程，则应使用 &lt;code&gt;new&lt;/code&gt; 而不是malloc（）。 而且，您永远不要使用C ++编译器来编译C代码。</target>
        </trans-unit>
        <trans-unit id="78057e43e77bcc9e1b0e757fb0b316b966566195" translate="yes" xml:space="preserve">
          <source>Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).</source>
          <target state="translated">如果目标指针类型发生变化,铸造可以帮助开发者识别类型大小的不一致,特别是当指针被声明为远离malloc()调用的时候(尽管现代编译器和静态分析器可以在不要求铸造的情况下对这种行为发出警告)。</target>
        </trans-unit>
        <trans-unit id="3a2d7a3d4e4dd946e19f2db024674b8a866ed8cf" translate="yes" xml:space="preserve">
          <source>Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.</source>
          <target state="translated">如果你使用的是C++编译器,你最好改成C编译器。</target>
        </trans-unit>
        <trans-unit id="78ef6be30b2521065f2a740c15e9efe938dca1d7" translate="yes" xml:space="preserve">
          <source>Casting is unnecessary in C because of:</source>
          <target state="translated">在C语言中,铸造是没有必要的,因为。</target>
        </trans-unit>
        <trans-unit id="b42fae74757338a083888cbb30e027c6114dbcf5" translate="yes" xml:space="preserve">
          <source>Casting the value returned by &lt;code&gt;malloc()&lt;/code&gt; is not necessary now, but I'd like to add one point that seems no one has pointed out:</source>
          <target state="translated">现在不需要 &lt;code&gt;malloc()&lt;/code&gt; 返回的值，但是我想补充一点，似乎没有人指出：</target>
        </trans-unit>
        <trans-unit id="5dc2c2dd9de34c36ad74f0a09bd8fa0995f45367" translate="yes" xml:space="preserve">
          <source>Casts are bad, as people have pointed out. Specially pointer casts.</source>
          <target state="translated">铸造是不好的,正如人们所指出的那样。特别是指针式铸造。</target>
        </trans-unit>
        <trans-unit id="346818851b71e2b51b940fdbcd739e7bed8a4685" translate="yes" xml:space="preserve">
          <source>Compare: &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; the second may overflow the &lt;code&gt;length * width&lt;/code&gt; when &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are smaller types than &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">比较： &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; 当 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;length&lt;/code&gt; 是小于 &lt;code&gt;size_t&lt;/code&gt; 的类型时，秒可能会溢出 &lt;code&gt;length * width&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92a59634a691e677f0f3007226a9b9924a1c7ae0" translate="yes" xml:space="preserve">
          <source>Do I cast the result of malloc</source>
          <target state="translated">我是否投了malloc的结果</target>
        </trans-unit>
        <trans-unit id="9a415f9c8b3c43f63b86077e60ea92ecb549f584" translate="yes" xml:space="preserve">
          <source>Failing to do so &lt;strong&gt;can hide an error&lt;/strong&gt;: note all the SO examples of confusing when to write &lt;code&gt;type *&lt;/code&gt; versus &lt;code&gt;type **&lt;/code&gt;.</source>
          <target state="translated">否则， &lt;strong&gt;可能会隐藏一个错误&lt;/strong&gt; ：请注意所有SO示例，它们混淆了何时编写 &lt;code&gt;type *&lt;/code&gt; 与 &lt;code&gt;type **&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2178cbc15519aa10d900c715292a6bb33865e63" translate="yes" xml:space="preserve">
          <source>For me, the take home and conclusion here is that casting &lt;code&gt;malloc&lt;/code&gt; in C is totally NOT necessary but if you however cast, it wont affect &lt;code&gt;malloc&lt;/code&gt; as &lt;code&gt;malloc&lt;/code&gt; will still allocate to you your requested blessed memory space.
Another take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.</source>
          <target state="translated">对我来说，这里的结论是完全不需要在C中强制转换 &lt;code&gt;malloc&lt;/code&gt; ，但是如果您强制转换，它将不会影响 &lt;code&gt;malloc&lt;/code&gt; ,因为 &lt;code&gt;malloc&lt;/code&gt; 仍将为您分配您所请求的祝福内存空间。 另一个原因是人们进行强制转换的原因或原因之一，这是使他们能够使用C或C ++编译同一程序。</target>
        </trans-unit>
        <trans-unit id="9a6ca1a7645efee702ad8b765fe9acc8115a216a" translate="yes" xml:space="preserve">
          <source>For non-dynamic arrays, the third must-have function macro is</source>
          <target state="translated">对于非动态数组,第三个必须的函数宏是</target>
        </trans-unit>
        <trans-unit id="e5e168dace40a1a84f885ba2ab5051ce961fb7af" translate="yes" xml:space="preserve">
          <source>For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type</source>
          <target state="translated">对于那些觉得C++严格规则不方便的人来说,我们可以使用C++11的特性,用推理类型</target>
        </trans-unit>
        <trans-unit id="aa1ec3f6766ce7c0a977b7f1dcad4b9a5591083b" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;Wikipedia&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;维基百科&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="d392caebbb009ac1a9c6b77c7ec1500ff9e46c8b" translate="yes" xml:space="preserve">
          <source>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</source>
          <target state="translated">但是,如果你想让同样的代码在不支持隐式转换的C++平台上完美兼容,就需要进行类型化,所以这一切都取决于可用性。</target>
        </trans-unit>
        <trans-unit id="380ef8a6f771b5ae1e081f919a36b6a9c2179d06" translate="yes" xml:space="preserve">
          <source>I have been pretty horrified over the years by the staggeringly aged compilers I've been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even &lt;em&gt;test&lt;/em&gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you're coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.</source>
          <target state="translated">多年来，我一直被要求使用的陈旧的编译器吓坏了。 公司和经理通常会采用超保守的方法来更改编译器，甚至不会&lt;em&gt;测试&lt;/em&gt;是否有新的编译器（具有更好的标准合规性和代码优化功能）可以在其系统中工作。 对于正在工作的开发人员来说，实际的现实情况是，在编写代码时，您需要覆盖基础知识，并且不幸的是，如果无法控制将哪种编译器应用于代码，则强制转换malloc是一个好习惯。</target>
        </trans-unit>
        <trans-unit id="0a9910af5e1d18f3c2c4a89ac01f4df8104d0369" translate="yes" xml:space="preserve">
          <source>I prefer to do the cast, but not manually. My favorite is using &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt;, you would get an error. &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; both take the same arguments, unlike &lt;code&gt;malloc&lt;/code&gt; that takes fewer arguments than &lt;code&gt;calloc&lt;/code&gt;. Just add &lt;code&gt;0&lt;/code&gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.</source>
          <target state="translated">我更喜欢进行演员表转换，而不是手动进行。 我最喜欢的是使用来自glib的 &lt;code&gt;g_new&lt;/code&gt; 和 &lt;code&gt;g_new0&lt;/code&gt; 宏。 如果不使用glib，我将添加类似的宏。 这些宏在不影响类型安全的情况下减少了代码重复。 如果错误输入类型，则会在非空指针之间进行隐式转换，这将导致警告（C ++中的错误）。 如果忘记包含定义 &lt;code&gt;g_new&lt;/code&gt; 和 &lt;code&gt;g_new0&lt;/code&gt; 的标头，则会出现错误。 &lt;code&gt;g_new&lt;/code&gt; 和 &lt;code&gt;g_new0&lt;/code&gt; 都接受相同的参数，这与 &lt;code&gt;malloc&lt;/code&gt; 相比 &lt;code&gt;calloc&lt;/code&gt; 接受更少的参数不同。 只需加 &lt;code&gt;0&lt;/code&gt; 即可获得零初始化内存。 该代码可以使用C ++编译器进行编译而无需更改。</target>
        </trans-unit>
        <trans-unit id="7a0d0fc82cd9dea6a8c022c171d7eeb4643d5033" translate="yes" xml:space="preserve">
          <source>I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:</source>
          <target state="translated">我放入 cast 只是为了表示不赞成类型系统中的丑陋的漏洞,它允许像下面这样的代码在没有诊断的情况下进行编译,即使没有使用 cast 来带来不好的转换。</target>
        </trans-unit>
        <trans-unit id="e084e2204e0fd41e68fb321510dcda59220f10db" translate="yes" xml:space="preserve">
          <source>I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you've not included stdlib.h then you've &lt;em&gt;way&lt;/em&gt; more problems than casting malloc ! ).</source>
          <target state="translated">我倾向于将malloc转换为一种防御性操作。 不漂亮，不完美，但总体上是安全的。 （老实说，如果您没有包括stdlib.h，那么比强制转换malloc还要麻烦得多。）</target>
        </trans-unit>
        <trans-unit id="a082eae6a8d0490ecb7ed60105f751966f9d8c0c" translate="yes" xml:space="preserve">
          <source>I wish that didn't exist (and it doesn't in C++) and so I cast. It represents my taste, and my programming politics. I'm not only casting a pointer, but effectively, casting a ballot, and &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;casting out demons of stupidity&lt;/a&gt;. If I can't &lt;em&gt;actually&lt;/em&gt;&lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;cast out stupidity&lt;/a&gt;, then at least let me express the wish to do so with a gesture of protest.</source>
          <target state="translated">我希望它不存在（并且在C ++中不存在），所以我进行了转换。 它代表了我的品味和我的编程政治。 我不仅在投下指针，而且在有效地投下选票，并&lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;投出愚蠢的恶魔&lt;/a&gt; 。 如果我不能&lt;em&gt;真正&lt;/em&gt; &lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;消除愚蠢&lt;/a&gt; ，那么至少让我表达抗议的意愿。</target>
        </trans-unit>
        <trans-unit id="be1a978a33b721660c705d3cb5ac611abd6a2873" translate="yes" xml:space="preserve">
          <source>I would also suggest that many organizations apply a coding standard of their own and that &lt;em&gt;that&lt;/em&gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.</source>
          <target state="translated">我还建议许多组织采用自己的编码标准，这是人们定义后应该遵循的方法。 在没有明确指导的情况下，我倾向于最有可能在任何地方进行编译，而不是勉强遵守标准。</target>
        </trans-unit>
        <trans-unit id="63aba8e191469bdf847cbb632a77ed2a7d0526f5" translate="yes" xml:space="preserve">
          <source>If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; that's no biggie, you won't be able to build your program.</source>
          <target state="translated">如果C编译器由于忘记了包含标头而无法找到函数，则会出现有关该标头的编译器/链接器错误。 因此，如果您忘记包含 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; ，那不是什么大问题，那么您将无法构建程序。</target>
        </trans-unit>
        <trans-unit id="94a20e630767a5b13c70ee7de6feee73b37a4ac4" translate="yes" xml:space="preserve">
          <source>If pointers and integers are differently sized, then you're hiding a warning by casting and might lose bits of your returned address.</source>
          <target state="translated">如果指针和整数的大小不同,那么你通过铸造隐藏了一个警告,可能会丢失你的返回地址中的位数。</target>
        </trans-unit>
        <trans-unit id="65a75eb3940c4c479252444c653d371d024274a3" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may
  also, need to change all lines where malloc is called and cast.</source>
          <target state="translated">如果在声明中改变了指针的类型,那么可能还需要改变malloc被调用和铸造的所有行。</target>
        </trans-unit>
        <trans-unit id="df36036f7f3128303dea4303afa83edbcf774e7f" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may also need to change all lines where &lt;code&gt;malloc&lt;/code&gt; is called and cast.</source>
          <target state="translated">如果指针的类型在声明时更改，则可能还需要更改调用 &lt;code&gt;malloc&lt;/code&gt; 并强制转换的所有行。</target>
        </trans-unit>
        <trans-unit id="6bcac15068f3bb62943c1a0a7f50cfe6b4f3ff96" translate="yes" xml:space="preserve">
          <source>If you adhere to these macros, then a simple &lt;code&gt;grep&lt;/code&gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.</source>
          <target state="translated">如果坚持使用这些宏，则对代码库进行简单的 &lt;code&gt;grep&lt;/code&gt; 搜索以查找这些标识符将为您显示所有强制类型转换的位置，因此您可以查看其中是否有错误。</target>
        </trans-unit>
        <trans-unit id="38906a251997aa3b8616c404232d137ef1fa9d7d" translate="yes" xml:space="preserve">
          <source>If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.</source>
          <target state="translated">如果你需要用相同的源码支持C和C++两种语言标准,请使用编译器开关来标记两者的区别。不要试图用相同的代码同时支持两种语言标准,因为它们是不兼容的。</target>
        </trans-unit>
        <trans-unit id="7d3ac445fa31b61523e6e62450fd24ba439b4dfa" translate="yes" xml:space="preserve">
          <source>If your C code compiles as C++, you can use this &lt;code&gt;-Wold-style-cast&lt;/code&gt; option to find out all occurrences of the &lt;code&gt;(type)&lt;/code&gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).</source>
          <target state="translated">如果您的C代码编译为C ++，则可以使用 &lt;code&gt;-Wold-style-cast&lt;/code&gt; 选项查找可能会渗入代码的所有 &lt;code&gt;(type)&lt;/code&gt; 强制转换语法，并通过将其替换为适当的内容来进行这些诊断从上述宏中进行选择（或在必要时进行组合）。</target>
        </trans-unit>
        <trans-unit id="a1ec8dc8e827dcddaf1ac66310df0ab7f63c0d88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;this question&lt;/a&gt;, someone suggested in a &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;comment&lt;/a&gt; that I should &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; cast the result of &lt;code&gt;malloc&lt;/code&gt;, i.e.</source>
          <target state="translated">在&lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;这个问题中&lt;/a&gt; ，有人在&lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;评论&lt;/a&gt;中建议我不应该转换 &lt;code&gt;malloc&lt;/code&gt; 的结果，即</target>
        </trans-unit>
        <trans-unit id="b3a9cebe6da5e7431620120cb56c6c593d67810c" translate="yes" xml:space="preserve">
          <source>In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.</source>
          <target state="translated">在C语言中是没有必要的,因为void *会自动安全地升级为任何其他指针类型。</target>
        </trans-unit>
        <trans-unit id="c3a26193ac8cf855c86ef90718a310c04be870e5" translate="yes" xml:space="preserve">
          <source>In C you can implicitly convert a void pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.</source>
          <target state="translated">在C语言中,你可以将void指针隐式地转换为任何其他类型的指针,所以没有必要使用 cast。使用一个,可能会给不经意的观察者暗示,为什么需要一个,这可能会造成误导。</target>
        </trans-unit>
        <trans-unit id="0e2c913a047567f896a4a85cdc21e25cc2d0c7db" translate="yes" xml:space="preserve">
          <source>In C you get an implicit conversion from &lt;code&gt;void*&lt;/code&gt; to any other (data) pointer.</source>
          <target state="translated">在C语言中，您将获得从 &lt;code&gt;void*&lt;/code&gt; 到任何其他（数据）指针的隐式转换。</target>
        </trans-unit>
        <trans-unit id="124df7e4df177a7e9968fd6be1560944643fd8df" translate="yes" xml:space="preserve">
          <source>In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from &lt;code&gt;void *&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implicit. C++ has a whole set of different flavors of casting.</source>
          <target state="translated">在C ++中，情况有所不同。 处理派生类的对象时，强制转换指针类型在某种程度上是常见的（并且是正确的）。 因此，在C ++中，与 &lt;code&gt;void *&lt;/code&gt; 之间的转换&lt;strong&gt;不是&lt;/strong&gt;隐式的，这是有道理的。 C ++具有一整套不同的铸造风格。</target>
        </trans-unit>
        <trans-unit id="10a5ed8bd778002e10989f9f97e0681982b277e7" translate="yes" xml:space="preserve">
          <source>In C, a &lt;strong&gt;pointer cast is almost always an error&lt;/strong&gt;. This is because of the following rule (&lt;strong&gt;&amp;sect;6.5 p7&lt;/strong&gt; in N1570, the latest draft for C11):</source>
          <target state="translated">在C语言中， &lt;strong&gt;指针强制转换几乎总是错误&lt;/strong&gt; 。 这是因为以下规则（ &lt;strong&gt;N1570&lt;/strong&gt;中的第&lt;strong&gt;6.5节p7&lt;/strong&gt; ，C11的最新草案）：</target>
        </trans-unit>
        <trans-unit id="93b491dccf959abfcaab359525161959ceec4cb9" translate="yes" xml:space="preserve">
          <source>In C, you don't need to cast the return value of &lt;code&gt;malloc&lt;/code&gt;. The pointer to void returned by &lt;code&gt;malloc&lt;/code&gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:</source>
          <target state="translated">在C语言中，您无需 &lt;code&gt;malloc&lt;/code&gt; 的返回值。 &lt;code&gt;malloc&lt;/code&gt; 返回的指向void的指针自动转换为正确的类型。 但是，如果希望代码使用C ++编译器进行编译，则需要进行强制转换。 社区中首选的替代方法是使用以下方法：</target>
        </trans-unit>
        <trans-unit id="8d2b0038978d4b2837d991cc706ee1d4bd7ec268" translate="yes" xml:space="preserve">
          <source>In a nutshell: Because in C, &lt;strong&gt;any&lt;/strong&gt; occurrence of a &lt;em&gt;pointer cast&lt;/em&gt; should raise a red flag for code requiring special attention, you should never write &lt;em&gt;unnecessary&lt;/em&gt; pointer casts.</source>
          <target state="translated">简而言之：因为在C中， &lt;strong&gt;任何&lt;/strong&gt;出现的指针强制转换都应该为需要特别注意的代码引发一个红旗，因此您永远不应编写&lt;em&gt;不必要的&lt;/em&gt;指针强制转换。</target>
        </trans-unit>
        <trans-unit id="f72796a47c4da0050142849a0a239342b6c889b7" translate="yes" xml:space="preserve">
          <source>In fact, a good practice is to wrap &lt;code&gt;malloc&lt;/code&gt; (and friends) with functions that return &lt;code&gt;unsigned char *&lt;/code&gt;, and basically never to use &lt;code&gt;void *&lt;/code&gt; in your code.  If you need a generic pointer-to-any-object, use a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;unsigned char *&lt;/code&gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like &lt;code&gt;memset&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; without casts.</source>
          <target state="translated">实际上，一个好的做法是使用返回 &lt;code&gt;unsigned char *&lt;/code&gt; 的函数包装 &lt;code&gt;malloc&lt;/code&gt; （和朋友），并且基本上不要在代码中使用 &lt;code&gt;void *&lt;/code&gt; 。 如果需要通用的指向任何对象的指针，请使用 &lt;code&gt;char *&lt;/code&gt; 或 &lt;code&gt;unsigned char *&lt;/code&gt; ，并在两个方向上进行强制转换。 可以放纵的一种放松也许是使用诸如 &lt;code&gt;memset&lt;/code&gt; 和 &lt;code&gt;memcpy&lt;/code&gt; 之类的函数而无需强制转换。</target>
        </trans-unit>
        <trans-unit id="b825dc3705674b4d779a4cf9b27487a2abaa1c23" translate="yes" xml:space="preserve">
          <source>In general, you &lt;strong&gt;don't cast to or from &lt;code&gt;void *&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">通常，您&lt;strong&gt;不会强制转换为 &lt;code&gt;void *&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fbe94d1061df0a0af541802fb33ece0468f3940" translate="yes" xml:space="preserve">
          <source>In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want &quot;type safe&quot; allocation, I can recommend the following macro functions, which I always use in my C projects:</source>
          <target state="translated">在C语言中,void指针可以分配给任何指针,这就是为什么你不应该使用类型铸造的原因。如果你想要 &quot;类型安全 &quot;分配,我可以推荐以下宏函数,我在C语言项目中经常使用。</target>
        </trans-unit>
        <trans-unit id="58f485ca9c16f19d61d27f9da6f8f8aadd049c0b" translate="yes" xml:space="preserve">
          <source>In the ancient days, that is, before &lt;strong&gt;ANSI C&lt;/strong&gt; provides the &lt;code&gt;void *&lt;/code&gt; as the generic type of pointers, &lt;code&gt;char *&lt;/code&gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.</source>
          <target state="translated">在远古时代，也就是说，在&lt;strong&gt;ANSI C&lt;/strong&gt;提供 &lt;code&gt;void *&lt;/code&gt; 作为指针的通用类型之前， &lt;code&gt;char *&lt;/code&gt; 是此类用法的类型。 在这种情况下，强制转换可以关闭编译器警告。</target>
        </trans-unit>
        <trans-unit id="7e73547744432a5c3e5cd36995aa06c8a9413ed0" translate="yes" xml:space="preserve">
          <source>Including the cast may allow a C program or function to compile as C++.</source>
          <target state="translated">加入 cast,可以让C语言程序或函数编译成C++。</target>
        </trans-unit>
        <trans-unit id="b8f9ba5f633406eee7f889296c7a7219db4f7a2e" translate="yes" xml:space="preserve">
          <source>It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).</source>
          <target state="translated">它增加了代码的杂乱性,CAST不容易读懂(特别是当指针类型是长的时候)。</target>
        </trans-unit>
        <trans-unit id="870023467a1d4925f143d3d61e6c60413492cb7a" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes (or, worse, &lt;em&gt;not&lt;/em&gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you're hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there's no automatic assumption that undeclared functions return &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">如果您忘记包含 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; ,它可能会隐藏错误。 这可能会导致崩溃（或更糟糕的是，直到稍后在代码的某些完全不同的部分中才导致崩溃）。 考虑一下如果指针和整数的大小不同会怎样？ 那么您将通过投射隐藏警告，并可能丢失返回地址的一部分。 注意：从C99开始，隐式函数不再使用C，这一点不再相关，因为没有自动假设未声明的函数返回 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a275723f60a0b42b3396018cbbac4f68a95ffd86" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes.</source>
          <target state="translated">如果您忘记包含 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; ,它可能会隐藏错误。 这可能导致崩溃。</target>
        </trans-unit>
        <trans-unit id="ba6c240782a51eb4cc2e1cddaefc3c7e3ed8dde5" translate="yes" xml:space="preserve">
          <source>It depends on the programming language and compiler. If you use &lt;code&gt;malloc&lt;/code&gt; in C there is no need to type cast it, as it will automatically type cast, However if your using C++ then you should type cast because &lt;code&gt;malloc&lt;/code&gt; will return a &lt;code&gt;void*&lt;/code&gt; type.</source>
          <target state="translated">这取决于编程语言和编译器。 如果在C中使用 &lt;code&gt;malloc&lt;/code&gt; ，则无需键入强制转换，因为它将自动键入强制转换。但是，如果您使用C ++，则应键入强制转换，因为 &lt;code&gt;malloc&lt;/code&gt; 将返回 &lt;code&gt;void*&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="6794ae23413780fefc55f46bbeacf139ac860cbb" translate="yes" xml:space="preserve">
          <source>It forces an &lt;strong&gt;extra cognitive cross-check&lt;/strong&gt;. It puts the (alleged) desired type right next to the arithmetic you're doing for the raw size of that variable. I bet you could do an SO study that shows that &lt;code&gt;malloc()&lt;/code&gt; bugs are caught much faster when there's a cast. As with assertions, annotations that reveal intent decrease bugs.</source>
          <target state="translated">它迫使进行&lt;strong&gt;额外的认知交叉检查&lt;/strong&gt; 。 它将（指定的）所需的类型放在要对该变量的原始大小执行的算术旁边。 我敢打赌，您可以进行SO研究，该研究表明在进行强制转换时， &lt;code&gt;malloc()&lt;/code&gt; 错误的捕获速度更快。 与断言一样，揭示意图的注释会减少错误。</target>
        </trans-unit>
        <trans-unit id="89402a760239fb0d292e8e281d0c2cb9fb56bd70" translate="yes" xml:space="preserve">
          <source>It is not mandatory to cast the results of &lt;code&gt;malloc&lt;/code&gt;, since it returns &lt;code&gt;void*&lt;/code&gt; , and a &lt;code&gt;void*&lt;/code&gt; can be pointed to any datatype.</source>
          <target state="translated">强制转换 &lt;code&gt;malloc&lt;/code&gt; 的结果不是强制性的，因为它返回 &lt;code&gt;void*&lt;/code&gt; ，并且 &lt;code&gt;void*&lt;/code&gt; 可以指向任何数据类型。</target>
        </trans-unit>
        <trans-unit id="6e5afe0ad6c9ac54a0f00b1936fe1beb836fed49" translate="yes" xml:space="preserve">
          <source>It is unnecessary, as &lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in this case.</source>
          <target state="translated">这是不必要的，因为在这种情况下， &lt;code&gt;void *&lt;/code&gt; 会自动安全地提升为任何其他指针类型。</target>
        </trans-unit>
        <trans-unit id="58da5d50b5f49af45e54e7443828c3d89f115f36" translate="yes" xml:space="preserve">
          <source>It makes you repeat yourself, which is generally bad.</source>
          <target state="translated">这会让你重复自己,这一般是不好的。</target>
        </trans-unit>
        <trans-unit id="0bed687df391f9e44c4a7612a09f35920968a326" translate="yes" xml:space="preserve">
          <source>It makes your code &lt;strong&gt;more portable&lt;/strong&gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).</source>
          <target state="translated">它使您的代码在C和C ++之间&lt;strong&gt;更易于移植&lt;/strong&gt; ，并且正如SO经验所表明的那样，许多程序员声称他们实际上是在用C ++（或C加本地编译器扩展）编写时才用C编写。</target>
        </trans-unit>
        <trans-unit id="9815dbbf9f559686ae80a3f22cf2a01f2a14f9f3" translate="yes" xml:space="preserve">
          <source>Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.</source>
          <target state="translated">只是补充一下我的经验,学计算机工程的,我见过的两三位教授都是用C语言写的,都是 cast malloc,然而我问过的那位教授(履历丰富,对C语言的理解也很深刻)告诉我,绝对没有必要,只是用来绝对具体的,让学生进入绝对具体的心态。从本质上来说,铸造不会改变它的工作方式,它完全按照它说的那样做,分配内存,铸造不会影响到它,你得到的内存是一样的,即使你把它误投到别的东西上(不知怎么躲过了编译器的错误),C也会以同样的方式访问它。</target>
        </trans-unit>
        <trans-unit id="0bff15a7d248d16466f2ec04acb6217150b312d2" translate="yes" xml:space="preserve">
          <source>Make sure there are no variables declared as &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">确保没有任何变量声明为 &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28b75c4f7d75c381d47362b41c7d2dc7264fc67f" translate="yes" xml:space="preserve">
          <source>Make your program compile through a C compiler with all warnings turned on &lt;code&gt;-Wall&lt;/code&gt; and fix all errors and warnings</source>
          <target state="translated">在打开所有警告的情况下，使您的程序通过C编译器进行编译 &lt;code&gt;-Wall&lt;/code&gt; 并修复所有错误和警告</target>
        </trans-unit>
        <trans-unit id="7f8e8015eabf551886df6e32673d5bd7e6acb193" translate="yes" xml:space="preserve">
          <source>No, you don't cast the result of &lt;code&gt;malloc()&lt;/code&gt;.</source>
          <target state="translated">不，您不 &lt;code&gt;malloc()&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="fcc3f1618153ed78f1a42b8c3a2643297139152b" translate="yes" xml:space="preserve">
          <source>Notice that the second cons should in the ideal case disappear when using the subset common to C together with the &lt;em&gt;static&lt;/em&gt; polymorphic feature.</source>
          <target state="translated">请注意，在理想情况下，将C公用的子集与&lt;em&gt;静态&lt;/em&gt;多态特征一起使用时，第二个缺点应该消失。</target>
        </trans-unit>
        <trans-unit id="7cee94d571455fbb9d3fed6656eb5b047a324b4c" translate="yes" xml:space="preserve">
          <source>Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.</source>
          <target state="translated">现在再次使用 C 编译器进行编译。你的程序现在应该在没有任何警告的情况下编译,并且包含较少的bug。</target>
        </trans-unit>
        <trans-unit id="66b2bc6a1bd3edda594e285fc1aff85a54ceee08" translate="yes" xml:space="preserve">
          <source>On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to &lt;code&gt;int&lt;/code&gt;. Casting the result from malloc explicitly would then hide away this bug.</source>
          <target state="translated">在遵循超过25年的标准版本的古老编译器上，忘记包含 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 可能会导致危险的行为。 因为在那个古老的标准中，没有可见原型的函数将返回类型隐式转换为 &lt;code&gt;int&lt;/code&gt; 。 显式地从malloc转换结果将隐藏此错误。</target>
        </trans-unit>
        <trans-unit id="bfeed771bd20c1b4da4b2efa7a63dcac68154c3a" translate="yes" xml:space="preserve">
          <source>On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.</source>
          <target state="translated">另一方面,铸造可能会增加程序的可移植性,也就是说,它允许将C程序或函数编译成C++。</target>
        </trans-unit>
        <trans-unit id="ba2e33a9bf914822832f2f444dd3ff0f0627ac9c" translate="yes" xml:space="preserve">
          <source>On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you &lt;em&gt;have to&lt;/em&gt; cast the return value of &lt;code&gt;malloc&lt;/code&gt; when assigning it to something other than &lt;code&gt;void *&lt;/code&gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:</source>
          <target state="translated">关于强制转换和C ++兼容性，如果您编写代码以使其同时作为C和C ++进行编译（在这种情况下&lt;em&gt;，&lt;/em&gt;将 &lt;code&gt;malloc&lt;/code&gt; 的返回值分配给 &lt;code&gt;void *&lt;/code&gt; 以外的其他值时， &lt;em&gt;必须&lt;/em&gt;强制转换）对您自己来说非常有用的事情：您可以使用宏进行转换，将宏转换为C ++时转换为C ++样式转换，但当转换为C时则转换为C转换：</target>
        </trans-unit>
        <trans-unit id="979716fcac00ca0824baf8e472028097ea147365" translate="yes" xml:space="preserve">
          <source>People used to GCC and Clang are spoiled.  It's not all that good out there.</source>
          <target state="translated">看惯了GCC和Clang的人都被宠坏了。外面的情况并不都是那么好。</target>
        </trans-unit>
        <trans-unit id="3d20bd7e564692465d39c6283102bcfeaf2f188b" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C FAQ&lt;/a&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C常见问题解答&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="913b8c72c65c6f2c696ebd2645ce6fe63ffd34ca" translate="yes" xml:space="preserve">
          <source>Repeating yourself in a way that the machine can check is often a &lt;strong&gt;great&lt;/strong&gt; idea. In fact, that's what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.</source>
          <target state="translated">以机器可以检查的方式重复自己通常是个&lt;strong&gt;好&lt;/strong&gt;主意。 实际上，这就是一个断言，而对cast的这种使用就是一个断言。 断言仍然是我们获得正确代码的最通用技术，因为Turing早在多年前就提出了这个想法。</target>
        </trans-unit>
        <trans-unit id="eeb9da9341aff1229aac0eeb3d8f1a6873b9e49d" translate="yes" xml:space="preserve">
          <source>Side notes:</source>
          <target state="translated">侧面说明:</target>
        </trans-unit>
        <trans-unit id="e07ca56cc28cf07f0e7efd4adeef84b39f654a4d" translate="yes" xml:space="preserve">
          <source>Since keeping the &lt;code&gt;sizeof&lt;/code&gt; first, in this case, ensures multiplication is done with at least &lt;code&gt;size_t&lt;/code&gt; math.</source>
          <target state="translated">由于在这种情况下，先保持 &lt;code&gt;sizeof&lt;/code&gt; ，确保至少用 &lt;code&gt;size_t&lt;/code&gt; 数学进行乘法。</target>
        </trans-unit>
        <trans-unit id="ac0ad68dd4aefb4ac26bf0c5e2facd9461dc449e" translate="yes" xml:space="preserve">
          <source>Some comments:</source>
          <target state="translated">一些评论:</target>
        </trans-unit>
        <trans-unit id="c9afff0f26991110c2bc5c4c2920c45f8f9e49f9" translate="yes" xml:space="preserve">
          <source>Sometimes, you &lt;strong&gt;do&lt;/strong&gt; need to cast pointers, but given the &lt;em&gt;strict aliasing rule&lt;/em&gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you &lt;strong&gt;have to double-check for its validity&lt;/strong&gt;. Therefore, you never write an unnecessary pointer cast.</source>
          <target state="translated">有时，您&lt;strong&gt;确实&lt;/strong&gt;需要强制转换指针，但是鉴于&lt;em&gt;严格的别名规则&lt;/em&gt; ，您必须非常小心。 因此，任何在代码中强制转换指针的地方都是您&lt;strong&gt;必须仔细检查其有效性的地方&lt;/strong&gt; 。 因此，您永远不会编写不必要的指针强制转换。</target>
        </trans-unit>
        <trans-unit id="348a3fbc26f2688c8530060e66a13437b015bb1b" translate="yes" xml:space="preserve">
          <source>That way you can still write it in a very compact way:</source>
          <target state="translated">这样一来,你还是可以把它写得很紧凑。</target>
        </trans-unit>
        <trans-unit id="7c11a87c54fbc0d09c65c5842cdeb16fbf6ce8d2" translate="yes" xml:space="preserve">
          <source>The argument that it's not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call &quot;local management's reality field&quot;.  And that's bent and twisted more than space time ever was. :-)</source>
          <target state="translated">有人说,在现行标准下没有必要,这种说法很有道理。但这个论点忽略了现实世界的实际情况。我们并不是在一个完全由当时的标准统治的世界里进行编码,而是由我喜欢的 &quot;地方管理的现实领域 &quot;的实际情况所决定的。而这一点比空间时间的弯曲和扭曲更多。 :-)</target>
        </trans-unit>
        <trans-unit id="cf7a2c5002660ed9183a2da4a4f0f11caa52353d" translate="yes" xml:space="preserve">
          <source>The best thing to do when programming in C whenever it is possible:</source>
          <target state="translated">在C语言编程时,只要有可能,最好的事情就是用C语言编程。</target>
        </trans-unit>
        <trans-unit id="8e6a11c3b2030400be409620a47673e0ff112fad" translate="yes" xml:space="preserve">
          <source>The cast allows for pre-1989 versions of malloc that originally returned a char *.</source>
          <target state="translated">该 cast 允许在1989年以前的malloc版本中,最初返回一个char *。</target>
        </trans-unit>
        <trans-unit id="998ffdec25506c948a2e362fe99f1587650eba18" translate="yes" xml:space="preserve">
          <source>The cast is necessary here, because &lt;code&gt;printf()&lt;/code&gt; is a variadic function, so implicit conversions don't work.</source>
          <target state="translated">这里必须进行强制类型转换，因为 &lt;code&gt;printf()&lt;/code&gt; 是可变参数，因此隐式转换不起作用。</target>
        </trans-unit>
        <trans-unit id="a53090f29cc6f3d564bf1c8d0a4c07064105db01" translate="yes" xml:space="preserve">
          <source>The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging</source>
          <target state="translated">void 指针背后的概念是,它可以被铸造成任何数据类型,这就是为什么 malloc 会返回 void。另外,你必须注意到自动类型化。所以,尽管你必须这样做,但并不是一定要铸造指针。它有助于保持代码的干净,有助于调试。</target>
        </trans-unit>
        <trans-unit id="26a10d066398b061801f974a2a5ece03f6f54619" translate="yes" xml:space="preserve">
          <source>The idea that it keeps you from noticing you failed to &lt;code&gt;#include&lt;/code&gt; an appropriate header file misses &lt;strong&gt;the forest for the trees&lt;/strong&gt;. It's the same as saying &quot;don't worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!&quot;</source>
          <target state="translated">它使您无法注意到您未能 &lt;code&gt;#include&lt;/code&gt; 适当的头文件的想法错过&lt;strong&gt;了树木的森林&lt;/strong&gt; 。 就像说&amp;ldquo;不必担心您没有要求编译器抱怨没有看到原型的事实-讨厌的stdlib.h是要记住的真正重要的事情！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7affa9334d50427587a11f830fa868eb1953cbca" translate="yes" xml:space="preserve">
          <source>The most common reason why people cast the result of malloc is because they are unsure about how the C language works. That's a warning sign: if you don't know how a particular language mechanism works, then &lt;em&gt;don't&lt;/em&gt; take a guess. Look it up or ask on Stack Overflow.</source>
          <target state="translated">人们使用malloc结果的最常见原因是因为他们不确定C语言的工作方式。 这是一个警告信号：如果您不知道特定语言机制的工作原理， &lt;em&gt;请不要&lt;/em&gt;猜测。 查找它或询问堆栈溢出。</target>
        </trans-unit>
        <trans-unit id="56afad940865bfcbe28c291e24c2bdf0ea7f35b5" translate="yes" xml:space="preserve">
          <source>The only benefits from writing in C instead of C++ I can find are</source>
          <target state="translated">我用C语言编写而不是C++的唯一好处是</target>
        </trans-unit>
        <trans-unit id="006baad78c74403e4762e856f8320bbf41a3f370" translate="yes" xml:space="preserve">
          <source>The pointer returned if the allocation succeeds is suitably aligned so
  that it may be assigned to a pointer to any type of object with a
  fundamental alignment requirement and then used to access such an
  object or an array of such objects in the space allocated (until the
  space is explicitly deallocated)</source>
          <target state="translated">如果分配成功,返回的指针会被适当地对齐,这样,它可以被分配给任何类型的对象的指针,并被分配给有基本对齐要求的对象,然后用来访问这样的对象或分配空间中的对象数组(直到空间被明确地重新分配为止)</target>
        </trans-unit>
        <trans-unit id="b3c30a12e0dff950c02a5280e6432480b9bd8396" translate="yes" xml:space="preserve">
          <source>The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.</source>
          <target state="translated">返回的类型是void*,可以将其投射到所需的数据指针类型,以便可以去掉引用。</target>
        </trans-unit>
        <trans-unit id="711c8a89d3f2be83e87fab517121c689d0361a34" translate="yes" xml:space="preserve">
          <source>Then compile it using a C++ compiler with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-std=c++11&lt;/code&gt;. Fix all errors and warnings.</source>
          <target state="translated">然后使用带有 &lt;code&gt;-Wall&lt;/code&gt; 和 &lt;code&gt;-std=c++11&lt;/code&gt; 的C ++编译器对其进行编译。 修复所有错误和警告。</target>
        </trans-unit>
        <trans-unit id="b833fdcd9601eb781a63d97976bc2af1531deb0f" translate="yes" xml:space="preserve">
          <source>Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use &lt;code&gt;strip_qual&lt;/code&gt; just to remove a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.</source>
          <target state="translated">然后，如果您定期使用C ++编译代码，它将强制使用适当的强制转换。 例如，如果仅使用 &lt;code&gt;strip_qual&lt;/code&gt; 删除 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;volatile&lt;/code&gt; ，但是程序以某种方式更改，现在涉及类型转换，则将得到诊断，并且必须使用强制类型转换的组合来获取所需的转换。</target>
        </trans-unit>
        <trans-unit id="d4e668d4c1ef3d785a282afa7e0b53c99ffaf425" translate="yes" xml:space="preserve">
          <source>There are cases where you actually &lt;em&gt;need&lt;/em&gt; a cast to &lt;code&gt;void *&lt;/code&gt;, e.g. if you want to print a pointer:</source>
          <target state="translated">在某些情况下，您实际上&lt;em&gt;需要&lt;/em&gt;强制转换为 &lt;code&gt;void *&lt;/code&gt; ，例如，如果要打印指针：</target>
        </trans-unit>
        <trans-unit id="6ee851d6bd4c154373eb426a6cf77ad29b6c76b9" translate="yes" xml:space="preserve">
          <source>There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.</source>
          <target state="translated">也许还有其他原因,但其他原因,几乎可以肯定,迟早会让你陷入严重的麻烦。</target>
        </trans-unit>
        <trans-unit id="186638c0a67a1197f7cd4cae91b6dbb0d0ea92b8" translate="yes" xml:space="preserve">
          <source>This also moves the &lt;code&gt;length&lt;/code&gt; to the front for increased visibility, and drops the redundant parentheses with &lt;code&gt;sizeof&lt;/code&gt;; they &lt;em&gt;are only needed&lt;/em&gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: &lt;code&gt;sizeof&lt;/code&gt; is not a function! :)</source>
          <target state="translated">这也将 &lt;code&gt;length&lt;/code&gt; 移到前面以增加可见性，并用 &lt;code&gt;sizeof&lt;/code&gt; 删除多余的括号。 &lt;em&gt;仅&lt;/em&gt;当参数为类型名称&lt;em&gt;时才需要&lt;/em&gt;使用它们。 许多人似乎不知道（或忽略）这一点，这会使他们的代码更加冗长。 切记： &lt;code&gt;sizeof&lt;/code&gt; 不是函数！ :)</target>
        </trans-unit>
        <trans-unit id="78ccd0f84465d8f80acc739eeb1edc6c075d1c6d" translate="yes" xml:space="preserve">
          <source>This is also known as the &lt;em&gt;strict aliasing rule&lt;/em&gt;. So the following code is &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">这也称为&lt;em&gt;严格别名规则&lt;/em&gt; 。 所以下面的代码是&lt;em&gt;未定义的行为&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="2e07b201f2cd09204952f0ea2a8352e94d8350f8" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;The GNU C Library Reference&lt;/a&gt; manual says:</source>
          <target state="translated">这就是&lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;《 GNU C库参考》&lt;/a&gt;手册所说的内容：</target>
        </trans-unit>
        <trans-unit id="2612aa90747c8f2cdc6c4aacf3c9fc773e8c9fc1" translate="yes" xml:space="preserve">
          <source>This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include &lt;code&gt;stdlib.h&lt;/code&gt;or you will get</source>
          <target state="translated">此过程使您可以利用C ++严格类型检查，从而减少错误的数量。 特别是，此过程会强制您包含 &lt;code&gt;stdlib.h&lt;/code&gt; ,否则您将获得</target>
        </trans-unit>
        <trans-unit id="f2cce072b4fc94a737199982264f4a8e1b007734" translate="yes" xml:space="preserve">
          <source>This treatment of conversions is the single largest standalone technical justification for working in a &quot;Clean C&quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">这种对转换的处理是在&amp;ldquo; Clean C&amp;rdquo;中工作的最大的独立技术理由：C和C ++的组合方言，这又在技术上证明了强制转换 &lt;code&gt;malloc&lt;/code&gt; 的返回值是正确的。</target>
        </trans-unit>
        <trans-unit id="6c17a9be57ef9ca7cd3adf5ee8b5ef9628a4d46a" translate="yes" xml:space="preserve">
          <source>To add further, your code needlessly repeats the type information (&lt;code&gt;int&lt;/code&gt;) which can cause errors. It's better to de-reference the pointer being used to store the return value, to &quot;lock&quot; the two together:</source>
          <target state="translated">要进一步添加，您的代码不必要地重复可能导致错误的类型信息（ &lt;code&gt;int&lt;/code&gt; ）。 最好取消引用用于存储返回值的指针，以将两者&amp;ldquo;锁定&amp;rdquo;在一起：</target>
        </trans-unit>
        <trans-unit id="81eed5fc51c3e3b44fa0ef9d4d25cef34a474770" translate="yes" xml:space="preserve">
          <source>To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.</source>
          <target state="translated">为了帮助你遵守这些宏,GNU C++(不是C!)编译器有一个很好的功能:一个可选的诊断功能,它可以对所有出现的C风格的cast进行诊断。</target>
        </trans-unit>
        <trans-unit id="ca84b5f4a5ac7139271f3940379fb2cf0336ee9f" translate="yes" xml:space="preserve">
          <source>Under the ANSI C standard, the cast is redundant.</source>
          <target state="translated">在ANSI C标准下,铸造是多余的。</target>
        </trans-unit>
        <trans-unit id="e8ec134ac31640fb573e0e153c5725b4e050b271" translate="yes" xml:space="preserve">
          <source>While moving &lt;code&gt;length&lt;/code&gt; to the front &lt;em&gt;may&lt;/em&gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:</source>
          <target state="translated">尽管在少数情况下将 &lt;code&gt;length&lt;/code&gt; 移到最前面&lt;em&gt;可能会&lt;/em&gt;增加可见性，但也应注意，在一般情况下，将表达式写为：</target>
        </trans-unit>
        <trans-unit id="9ee85b34131db60fdfd151a81fdc887dd4fcd22a" translate="yes" xml:space="preserve">
          <source>Why would this be the case?</source>
          <target state="translated">为什么会出现这种情况?</target>
        </trans-unit>
        <trans-unit id="01acdaf9e307b1e0a0b814ed27a2ec340c2e2c33" translate="yes" xml:space="preserve">
          <source>With these in place you can simply say</source>
          <target state="translated">有了这些,你可以简单地说</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="e0ed2586aa5abd52d3b653c0086a309021a02618" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;do&lt;/strong&gt; cast, because:</source>
          <target state="translated">您&lt;strong&gt;进行&lt;/strong&gt;强制转换是因为：</target>
        </trans-unit>
        <trans-unit id="79486d2c3a27f80999f77ddcc416d8f23c32e95a" translate="yes" xml:space="preserve">
          <source>You can store the result of &lt;code&gt;malloc&lt;/code&gt; into any pointer variable without a
  cast, because ISO C automatically converts the type &lt;code&gt;void *&lt;/code&gt; to another
  type of pointer when necessary. But the cast is necessary in contexts
  other than assignment operators or if you might want your code to run
  in traditional C.</source>
          <target state="translated">您可以将 &lt;code&gt;malloc&lt;/code&gt; 的结果存储到任何指针变量中而无需进行强制转换，因为ISO C在必要时会自动将 &lt;code&gt;void *&lt;/code&gt; 类型转换为另一种指针类型。 但是，在除赋值运算符之外的其他上下文中，或者如果您希望代码在传统C语言中运行，则强制转换是必需的。</target>
        </trans-unit>
        <trans-unit id="64d12490b03733be1bf0ccdb5177f441ae3b32a3" translate="yes" xml:space="preserve">
          <source>You don't cast the result of malloc, because doing so adds pointless clutter to your code.</source>
          <target state="translated">你不投malloc的结果,因为这样做会给你的代码增加无意义的杂乱。</target>
        </trans-unit>
        <trans-unit id="719d41b4076bc570c545a47f1031a67ded961c28" translate="yes" xml:space="preserve">
          <source>and also forces you to cast the result of &lt;code&gt;malloc&lt;/code&gt; or you will get</source>
          <target state="translated">并迫使您强制转换 &lt;code&gt;malloc&lt;/code&gt; 的结果，否则您将得到</target>
        </trans-unit>
        <trans-unit id="542161e54ecd4adeeeb635a9cdad11414084409e" translate="yes" xml:space="preserve">
          <source>and it will compile for C and C++.</source>
          <target state="translated">而且它可以编译为C和C++。</target>
        </trans-unit>
        <trans-unit id="64083eb0fbc1cccbe1930ff6c0eb620b8e9c0cc1" translate="yes" xml:space="preserve">
          <source>i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">即：如果需要将C程序编译为C ++（尽管这是一种独立的语言），则必须强制转换use &lt;code&gt;malloc&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="7feac0152fbb8ddbd92237edaa50e15426a689c0" translate="yes" xml:space="preserve">
          <source>invalid conversion from &lt;code&gt;void*&lt;/code&gt; to &lt;code&gt;T*&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;void*&lt;/code&gt; 到 &lt;code&gt;T*&lt;/code&gt; 无效转换</target>
        </trans-unit>
        <trans-unit id="d4336376d32d8dd4374715878d5ec2aff3007481" translate="yes" xml:space="preserve">
          <source>or what ever your target type is.</source>
          <target state="translated">或任何你的目标类型是什么。</target>
        </trans-unit>
        <trans-unit id="82b524d90dbcf160ddb4a560d1503123520ae7c4" translate="yes" xml:space="preserve">
          <source>rather than:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="6ef706998cf17ef7293cdb6fad421229fb5f8d93" translate="yes" xml:space="preserve">
          <source>tl;dr</source>
          <target state="translated">tl;dr</target>
        </trans-unit>
        <trans-unit id="0b710aa273bfb4642bf11423f66ee900b109348f" translate="yes" xml:space="preserve">
          <source>which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of &lt;code&gt;sieve&lt;/code&gt;.</source>
          <target state="translated">如果您更改了 &lt;code&gt;sieve&lt;/code&gt; 的类型，这还使您不必担心更改表达式的右侧。</target>
        </trans-unit>
        <trans-unit id="56cf084c8081e52c77e6553b2ba637aae876ab2f" translate="yes" xml:space="preserve">
          <source>which makes array loops safer and more convenient:</source>
          <target state="translated">这使得阵列循环更安全、更方便。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
