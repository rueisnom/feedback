<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/605845">
    <body>
      <group id="605845">
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">&amp;mdash; 문자 유형.</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash; 유효 객체 유형과 호환되는 유형의 정규화 된 버전</target>
        </trans-unit>
        <trans-unit id="e44f2c14403ad448407e98ab24bfdee66bfa24a3" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash; 유효 객체 유형과 호환되는 유형</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,</source>
          <target state="translated">&amp;mdash; 객체의 유효 유형의 정규화 된 버전에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the
  object,</source>
          <target state="translated">&amp;mdash; 객체의 유효 유형에 해당하는 부호있는 유형 또는 부호없는 유형 인 유형</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">-구성원들 중에서 상기 언급 된 유형 중 하나를 포함하는 집합 또는 조합 유형 (재귀 적으로 하위 집합 또는 포함 된 연합의 구성원 포함) 또는</target>
        </trans-unit>
        <trans-unit id="ae7e0cdae2ac7249d987bff149081b201e3a0fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;malloc&lt;/code&gt; was not declared within this scope</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; 이이 범위 내에서 선언되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="0e5f928812738db0ec93ccf2bf989d2ddde07c40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in the case of C.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 는 C의 경우 다른 포인터 유형으로 자동으로 안전하게 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="a391dd112c4d19334c4d2262800b52d709ef87f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;주조의 장점&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70e320e2947eef2af5ecd6ba7d5df9624b0e3047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;캐스팅의 단점&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2846f9a1c6a1377c632edfa1214b7fc3a69f21f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 캐스팅에는 특정 포인트가 있습니다. 배열 표기법을 사용할 때 생성 된 코드는 다음 요소의 시작 부분에 도달하기 위해 얼마나 많은 메모리 위치를 가져와야하는지 알아야합니다. 이는 캐스팅을 통해 달성됩니다. 이 방법을 사용하면 double의 경우 8 바이트가 앞당겨지고 int의 경우 4가됩니다. 따라서 포인터 표기법을 사용하면 효과가 없으며 배열 표기법에서는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ecf1f68c1a0bb45cb2b18963cb8bbc692db8e531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No&lt;/strong&gt;; you &lt;em&gt;don't&lt;/em&gt; cast the result, since:</source>
          <target state="translated">&lt;strong&gt;아니요&lt;/strong&gt; ; 다음과 같은 이유로 결과를 캐스트 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f479abc04339b7f7648e42d0dcae330fdbce9d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The casting of malloc is unnecessary in C but mandatory in C++.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;malloc의 캐스팅은 C에서는 불필요하지만 C ++에서는 필수입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="05ecd5960f9d99ecd5ac614c91583260f522bd42" translate="yes" xml:space="preserve">
          <source>A typical reason given for not doing so is that failure to &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; could go unnoticed. This isn't an issue anymore for a long time now as C99 made &lt;em&gt;implicit function declarations&lt;/em&gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.</source>
          <target state="translated">그렇게하지 않는 일반적인 이유는 &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 실패가 눈에 띄지 않을 수 있기 때문입니다. C99가 &lt;em&gt;암시 적 함수 선언을&lt;/em&gt; 불법으로 만들었으므로 이제는 더 이상 문제가되지 않으므로 컴파일러가 C99 이상을 준수하면 진단 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a368dec1332cfeb0f803131ba36c04da26e07ad" translate="yes" xml:space="preserve">
          <source>A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).</source>
          <target state="translated">빈 포인터는 명시 적 캐스트 (C11 6.3.2.3 및 6.5.16.1)없이 다른 포인터 유형과 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0471ce3799acd66098fce34b5150690360d1c931" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">void 포인터는 일반적인 객체 포인터이며 C는 void 포인터 형식에서 다른 형식으로의 암시 적 변환을 지원하므로 명시 적으로 형식을 변환 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a26d186fb3412a6fc71664243f45c9e7df4a5f6e" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">void 포인터는 일반 포인터이며 C는 void 포인터 형식에서 다른 형식으로의 암시 적 변환을 지원하므로 명시 적으로 형식을 변환 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2e4fe0f4f3fae71f095a8f015fe0d1094245585" translate="yes" xml:space="preserve">
          <source>Adding the cast may mask failure to include the header &lt;em&gt;stdlib.h&lt;/em&gt;, in
  which the prototype for malloc is found. In the absence of a
  prototype for malloc, the standard requires that the C compiler
  assume malloc returns an int. If there is no cast, a warning is
  issued when this integer is assigned to the pointer; however, with
  the cast, this warning is not produced, hiding a bug. On certain
  architectures and data models (such as LP64 on 64-bit systems, where
  long and pointers are 64-bit and int is 32-bit), this error can
  actually result in undefined behaviour, as the implicitly declared
  malloc returns a 32-bit value whereas the actually defined function
  returns a 64-bit value. Depending on calling conventions and memory
  layout, this may result in stack smashing. This issue is less likely
  to go unnoticed in modern compilers, as they uniformly produce
  warnings that an undeclared function has been used, so a warning will
  still appear. For example, GCC's default behaviour is to show a
  warning that reads &quot;incompatible implicit declaration of built-in
  function&quot; regardless of whether the cast is present or not.</source>
          <target state="translated">캐스트를 추가하면 malloc의 프로토 타입이있는 &lt;em&gt;stdlib.h&lt;/em&gt; 헤더를 포함하지 &lt;em&gt;못하도록&lt;/em&gt; 마스크 할 수 있습니다. malloc에 ​​대한 프로토 타입이없는 경우, 표준은 C 컴파일러가 malloc이 int를 리턴한다고 가정해야합니다. 캐스트가 없으면이 정수가 포인터에 지정 될 때 경고가 발행됩니다. 그러나 캐스트와 함께이 경고가 생성되지 않아 버그가 숨겨집니다. 특정 아키텍처 및 데이터 모델 (예 : 64 비트 시스템의 LP64, 길고 포인터가 64 비트이고 int가 32 비트 인 경우)에서이 오류는 암시 적으로 선언 된 malloc이 32를 반환하므로 실제로 정의되지 않은 동작을 초래할 수 있습니다. 실제로 정의 된 함수는 64 비트 값을 반환하지만 비트 값은 호출 규칙 및 메모리 레이아웃에 따라 스택 스매싱이 발생할 수 있습니다. 이 문제는 선언되지 않은 함수가 사용되었다는 경고를 균일하게 생성하므로 경고가 계속 표시되므로 최신 컴파일러에서는 눈에 띄지 않을 것입니다. 예를 들어 GCC의 기본 동작은 캐스트가 있는지 여부에 관계없이 &quot;내장 함수의 암시 적 선언이 호환되지 않는다&quot;는 경고를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="330de36771a8855149af70009a392efe7137c117" translate="yes" xml:space="preserve">
          <source>Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.</source>
          <target state="translated">또한 주석가들이 지적했듯이 위의 내용은 C ++이 아닌 C에 대해 이야기합니다. 나는 C와 C ++를 별도의 언어로 굳게 믿고 있습니다.</target>
        </trans-unit>
        <trans-unit id="49b4f10f65b03b7676c9928862b57a7bb5936eaa" translate="yes" xml:space="preserve">
          <source>Although &lt;strong&gt;malloc without casting is preferred method and most experienced programmers choose it&lt;/strong&gt;, you should use whichever you like having aware of the issues.</source>
          <target state="translated">&lt;strong&gt;캐스팅이없는 malloc이 선호되는 방법이고 대부분의 숙련 된 프로그래머가이 방법을 선택하지만&lt;/strong&gt; 문제를 알고 싶은 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82b3b63ccc5e46c358ff4d906c737902b003bf00" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:</source>
          <target state="translated">객체는 다음 유형 중 하나를 갖는 lvalue 표현식으로 만 저장된 값에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="415ebcd3f0d0eb14cdd2373b4ef70b900e3218af" translate="yes" xml:space="preserve">
          <source>And indeed the &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11 standard&lt;/a&gt; (p347) says so:</source>
          <target state="translated">실제로 &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11 표준&lt;/a&gt; (p347)은 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="106cd39a268698352cf10943c417d2f7799f7985" translate="yes" xml:space="preserve">
          <source>And, sometimes surprisingly, the following is as well:</source>
          <target state="translated">때로는 놀랍게도 다음 사항도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98cee4f987282b9a2bc48df1269201546773ac75" translate="yes" xml:space="preserve">
          <source>As a clarification, note that I said &quot;you don't cast&quot;, not &quot;you don't &lt;em&gt;need&lt;/em&gt; to cast&quot;. In my opinion, it's a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don't know about the risks.</source>
          <target state="translated">설명을 위해, &quot;주조 할 필요가 없습니다&quot;가 아니라 &quot;주조하지 않습니다&quot;라고 말씀하셨습니다. 제 생각에는, 캐스트를 제대로 받았더라도 캐스트를 포함시키지 못하는 것입니다. 그렇게하는 것에는 이점이 없지만, 잠재적 위험이 많으며 캐스트를 포함하면 위험에 대해 모른다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52d6db561d5a32a930d6064e45cfff6f3d42fec9" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++.</source>
          <target state="translated">다른 언급했듯이 C에는 필요하지 않지만 C ++에는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d1b5b1727f0d804cd9571ddd5eeac48d6b713bf5" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++. If you think you are going to compile your C code with a C++ compiler, for which reasons ever, you can use a macro instead, like:</source>
          <target state="translated">다른 언급했듯이 C에는 필요하지 않지만 C ++에는 필요합니다. C ++ 컴파일러로 C 코드를 컴파일 할 것이라고 생각되면 다음과 같은 매크로를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="336cb3d7090a86262459260c2cb734602c2436e0" translate="yes" xml:space="preserve">
          <source>Because &lt;strong&gt;stdlib.h&lt;/strong&gt; contains the prototype for malloc is found. In the
absence of a prototype for malloc, the standard requires that the C
compiler assumes malloc returns an int. If there is no cast, a
warning is issued when this integer is assigned to the pointer;
however, with the cast, this warning is not produced, hiding a bug.</source>
          <target state="translated">&lt;strong&gt;stdlib.h&lt;/strong&gt; 에 malloc의 프로토 타입이 포함되어 있기 때문에 찾을 수 있습니다. malloc에 ​​대한 프로토 타입이없는 경우, 표준에 따르면 C 컴파일러는 malloc이 int를 리턴한다고 가정합니다. 캐스트가 없으면이 정수가 포인터에 지정 될 때 경고가 발행됩니다. 그러나 캐스트와 함께이 경고가 생성되지 않아 버그가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="bdc72cf404853fbac86b2c23dcbbf0c9e530081f" translate="yes" xml:space="preserve">
          <source>But if you cast then, it can hide an error if you forgot to include
&lt;strong&gt;stdlib.h&lt;/strong&gt;. This can cause crashes (or, worse, not cause a crash
until way later in some totally different part of the code).</source>
          <target state="translated">그러나 캐스팅하면 &lt;strong&gt;stdlib.h&lt;/strong&gt; 포함을 잊어 버린 경우 오류를 숨길 수 있습니다. 이로 인해 충돌이 발생할 수 있습니다 (또는 코드의 완전히 다른 부분에서 나중에 충돌이 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="607d50bbf8a35ccb5efb5dcb48502884b9e0b8a2" translate="yes" xml:space="preserve">
          <source>But that is really a non-issue. You aren't using a 25 years old computer, so why would you use a 25 years old compiler?</source>
          <target state="translated">그러나 그것은 실제로 문제가 아닙니다. 25 년 된 컴퓨터를 사용하지 않는 이유는 무엇입니까? 25 년 된 컴파일러를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="944b838189a9bff8c526a212fceaae45ebfd75be" translate="yes" xml:space="preserve">
          <source>But there's a &lt;strong&gt;much stronger reason&lt;/strong&gt; not to introduce unnecessary pointer casts:</source>
          <target state="translated">그러나 불필요한 포인터 캐스트를 도입하지 않는 &lt;strong&gt;훨씬 더 강력한 이유가 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="478bb2a442cb08ae6c0bbcddf6fd2f695a1f51d8" translate="yes" xml:space="preserve">
          <source>C has a well specified ABI</source>
          <target state="translated">C는 잘 지정된 ABI를 가지고 있습니다</target>
        </trans-unit>
        <trans-unit id="944a73e911447184dc231ecc770caa2caeec4d8e" translate="yes" xml:space="preserve">
          <source>C++ may generate more code [exceptions, RTTI, templates, &lt;em&gt;runtime&lt;/em&gt; polymorphism]</source>
          <target state="translated">C ++에서 더 많은 코드를 생성 할 수 있음 [예외, RTTI, 템플릿, &lt;em&gt;런타임&lt;/em&gt; 다형성]</target>
        </trans-unit>
        <trans-unit id="ff9f56607dcdf5bb324bf522b13344b0a6d2e767" translate="yes" xml:space="preserve">
          <source>C++ will however not allow an implicit cast between &lt;code&gt;void*&lt;/code&gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use &lt;code&gt;new&lt;/code&gt; and not malloc(). And you should never compile C code using a C++ compiler.</source>
          <target state="translated">그러나 C ++은 &lt;code&gt;void*&lt;/code&gt; 와 다른 포인터 유형간에 암시 적 캐스트를 허용하지 않습니다. 따라서 C ++에서는 캐스트가 정확했을 것입니다. 그러나 C ++로 프로그래밍하는 경우 malloc ()이 아닌 &lt;code&gt;new&lt;/code&gt; 를 사용해야합니다. 그리고 C ++ 컴파일러를 사용하여 C 코드를 컴파일해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="78057e43e77bcc9e1b0e757fb0b316b966566195" translate="yes" xml:space="preserve">
          <source>Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).</source>
          <target state="translated">캐스팅은 특히 포인터가 malloc () 호출에서 멀리 선언 된 경우 대상 포인터 유형이 변경 될 경우 개발자가 유형 크기의 불일치를 식별하는 데 도움이 될 수 있습니다 (현대 컴파일러와 정적 분석기는 캐스트를 요구하지 않고도 이러한 동작에 대해 경고 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="3a2d7a3d4e4dd946e19f2db024674b8a866ed8cf" translate="yes" xml:space="preserve">
          <source>Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.</source>
          <target state="translated">캐스팅은 C가 아닌 C ++ 전용입니다. C ++ 컴파일러를 사용하는 경우 C 컴파일러로 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="78ef6be30b2521065f2a740c15e9efe938dca1d7" translate="yes" xml:space="preserve">
          <source>Casting is unnecessary in C because of:</source>
          <target state="translated">C에서는 다음과 같은 이유로 캐스팅이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b42fae74757338a083888cbb30e027c6114dbcf5" translate="yes" xml:space="preserve">
          <source>Casting the value returned by &lt;code&gt;malloc()&lt;/code&gt; is not necessary now, but I'd like to add one point that seems no one has pointed out:</source>
          <target state="translated">&lt;code&gt;malloc()&lt;/code&gt; 의해 반환 된 값을 캐스팅하는 것은 현재 필요하지 않지만 아무도 지적하지 않은 것으로 보이는 점을 하나 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="5dc2c2dd9de34c36ad74f0a09bd8fa0995f45367" translate="yes" xml:space="preserve">
          <source>Casts are bad, as people have pointed out. Specially pointer casts.</source>
          <target state="translated">사람들이 지적한 것처럼 캐스트는 좋지 않습니다. 특히 포인터 캐스트.</target>
        </trans-unit>
        <trans-unit id="346818851b71e2b51b940fdbcd739e7bed8a4685" translate="yes" xml:space="preserve">
          <source>Compare: &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; the second may overflow the &lt;code&gt;length * width&lt;/code&gt; when &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are smaller types than &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">비교 : &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; 두 번째는 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;length&lt;/code&gt; 가 &lt;code&gt;size_t&lt;/code&gt; 보다 작은 유형 인 경우 &lt;code&gt;length * width&lt;/code&gt; 오버 플로우 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a59634a691e677f0f3007226a9b9924a1c7ae0" translate="yes" xml:space="preserve">
          <source>Do I cast the result of malloc</source>
          <target state="translated">malloc의 결과를 캐스트합니까</target>
        </trans-unit>
        <trans-unit id="9a415f9c8b3c43f63b86077e60ea92ecb549f584" translate="yes" xml:space="preserve">
          <source>Failing to do so &lt;strong&gt;can hide an error&lt;/strong&gt;: note all the SO examples of confusing when to write &lt;code&gt;type *&lt;/code&gt; versus &lt;code&gt;type **&lt;/code&gt;.</source>
          <target state="translated">그렇게하지 않으면 &lt;strong&gt;오류를 숨길 수 있습니다&lt;/strong&gt; . &lt;code&gt;type *&lt;/code&gt; &lt;code&gt;type **&lt;/code&gt; 대 ** 형식 을 쓸 때 혼란을 일으키는 모든 SO 예제를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c2178cbc15519aa10d900c715292a6bb33865e63" translate="yes" xml:space="preserve">
          <source>For me, the take home and conclusion here is that casting &lt;code&gt;malloc&lt;/code&gt; in C is totally NOT necessary but if you however cast, it wont affect &lt;code&gt;malloc&lt;/code&gt; as &lt;code&gt;malloc&lt;/code&gt; will still allocate to you your requested blessed memory space.
Another take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.</source>
          <target state="translated">나를 위해, 집으로 가져 와서 결론은 C에서 &lt;code&gt;malloc&lt;/code&gt; 을 캐스팅하는 것이 완전히 필요하지 않다는 것입니다. 그러나 캐스팅 한 경우 &lt;code&gt;malloc&lt;/code&gt; 이 여전히 요청 된 축복받은 메모리 공간을 할당하므로 malloc에 영향을 미치지 않습니다. 사람들이 캐스팅하는 이유 또는 이유 중 하나는 C 또는 C ++에서 동일한 프로그램을 컴파일 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a6ca1a7645efee702ad8b765fe9acc8115a216a" translate="yes" xml:space="preserve">
          <source>For non-dynamic arrays, the third must-have function macro is</source>
          <target state="translated">비 동적 배열의 경우 세 번째 필수 기능 매크로는</target>
        </trans-unit>
        <trans-unit id="e5e168dace40a1a84f885ba2ab5051ce961fb7af" translate="yes" xml:space="preserve">
          <source>For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type</source>
          <target state="translated">C ++ 엄격한 규칙이 불편한 사람들을 위해 유추 유형과 함께 C ++ 11 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="aa1ec3f6766ce7c0a977b7f1dcad4b9a5591083b" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;Wikipedia에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d392caebbb009ac1a9c6b77c7ec1500ff9e46c8b" translate="yes" xml:space="preserve">
          <source>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</source>
          <target state="translated">그러나 암시 적 변환을 지원하지 않는 C ++ 플랫폼에서 동일한 코드가 완벽하게 호환되도록하려면 형식 캐스팅을 수행해야하므로 사용성에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="380ef8a6f771b5ae1e081f919a36b6a9c2179d06" translate="yes" xml:space="preserve">
          <source>I have been pretty horrified over the years by the staggeringly aged compilers I've been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even &lt;em&gt;test&lt;/em&gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you're coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.</source>
          <target state="translated">몇 년 동안 내가 사용해야했던 엄청나게 오래된 컴파일러들에 의해 나는 꽤 끔찍했습니다. 종종 회사와 관리자는 변화하는 컴파일러에 대해 매우 보수적 인 접근 방식을 채택하고 더 나은 표준 준수 및 코드 최적화 기능을 갖춘 새 컴파일러가 시스템에서 작동하는지 &lt;em&gt;테스트&lt;/em&gt; 조차하지 않습니다. 실무 개발자에게 실제적인 현실은 코딩 할 때베이스를 다루어야하지만 불행히도 malloc을 캐스팅하는 것은 코드에 적용 할 컴파일러를 제어 할 수없는 경우 좋은 습관입니다.</target>
        </trans-unit>
        <trans-unit id="0a9910af5e1d18f3c2c4a89ac01f4df8104d0369" translate="yes" xml:space="preserve">
          <source>I prefer to do the cast, but not manually. My favorite is using &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt;, you would get an error. &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; both take the same arguments, unlike &lt;code&gt;malloc&lt;/code&gt; that takes fewer arguments than &lt;code&gt;calloc&lt;/code&gt;. Just add &lt;code&gt;0&lt;/code&gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.</source>
          <target state="translated">나는 캐스트를 선호하지만 수동으로하지는 않습니다. 내가 가장 좋아하는 것은 glib의 &lt;code&gt;g_new&lt;/code&gt; 및 &lt;code&gt;g_new0&lt;/code&gt; 매크로를 사용하는 것입니다. glib를 사용하지 않으면 비슷한 매크로를 추가합니다. 이러한 매크로는 형식 안전성을 손상시키지 않으면 서 코드 중복을 줄입니다. 유형이 잘못되면 무효가 아닌 포인터 사이에 암시 적 캐스트가 발생하여 경고가 발생합니다 (C ++의 오류). &lt;code&gt;g_new&lt;/code&gt; 및 &lt;code&gt;g_new0&lt;/code&gt; 을 정의하는 헤더를 포함하지 않으면 오류가 발생합니다. &lt;code&gt;calloc&lt;/code&gt; 보다 적은 수의 인수를 사용하는 &lt;code&gt;malloc&lt;/code&gt; 과 달리 &lt;code&gt;g_new&lt;/code&gt; 및 &lt;code&gt;g_new0&lt;/code&gt; 은 동일한 인수를 사용합니다. 0으로 초기화하면 메모리가 초기화되지 않습니다. 코드는 변경없이 C ++ 컴파일러로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0d0fc82cd9dea6a8c022c171d7eeb4643d5033" translate="yes" xml:space="preserve">
          <source>I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:</source>
          <target state="translated">나는 형 시스템에서 못생긴 구멍의 비 승인을 보여주기 위해 캐스트를 넣었습니다.이 코드는 다음과 같은 코드가 진단없이 컴파일 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="e084e2204e0fd41e68fb321510dcda59220f10db" translate="yes" xml:space="preserve">
          <source>I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you've not included stdlib.h then you've &lt;em&gt;way&lt;/em&gt; more problems than casting malloc ! ).</source>
          <target state="translated">나는 malloc을 방어 작전이라고 생각하는 경향이 있습니다. 예쁘지 않고 완벽하지는 않지만 일반적으로 안전합니다. (솔직히 stdlib.h를 포함시키지 않았다면 malloc을 캐스팅하는 것보다 더 많은 문제가 있습니다!).</target>
        </trans-unit>
        <trans-unit id="a082eae6a8d0490ecb7ed60105f751966f9d8c0c" translate="yes" xml:space="preserve">
          <source>I wish that didn't exist (and it doesn't in C++) and so I cast. It represents my taste, and my programming politics. I'm not only casting a pointer, but effectively, casting a ballot, and &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;casting out demons of stupidity&lt;/a&gt;. If I can't &lt;em&gt;actually&lt;/em&gt;&lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;cast out stupidity&lt;/a&gt;, then at least let me express the wish to do so with a gesture of protest.</source>
          <target state="translated">나는 그것이 존재하지 않기를 바란다. (그리고 C ++에는 없다.) 그것은 내 취향과 프로그래밍 정치를 나타냅니다. 나는 포인터를 던질뿐만 아니라 효과적으로 투표 용지를 &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;캐스팅하고 바보 같은 악마를 캐스팅합니다&lt;/a&gt; . 내가 &lt;em&gt;실제로&lt;/em&gt; &lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;어리 석음을 낼&lt;/a&gt; 수 없다면, 적어도 항의의 몸짓으로 그렇게하고 싶은 소망을 표현하도록하자.</target>
        </trans-unit>
        <trans-unit id="be1a978a33b721660c705d3cb5ac611abd6a2873" translate="yes" xml:space="preserve">
          <source>I would also suggest that many organizations apply a coding standard of their own and that &lt;em&gt;that&lt;/em&gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.</source>
          <target state="translated">또한 많은 조직이 자체 코딩 표준을 적용하고 그것이 정의 된 경우 사람들이 따르는 방법이어야한다고 제안합니다. 명백한 지침이 없으면 나는 표준에 대한 노예의 준수보다는 모든 곳에서 컴파일 할 가능성이 가장 높습니다.</target>
        </trans-unit>
        <trans-unit id="63aba8e191469bdf847cbb632a77ed2a7d0526f5" translate="yes" xml:space="preserve">
          <source>If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; that's no biggie, you won't be able to build your program.</source>
          <target state="translated">헤더를 포함하는 것을 잊었 기 때문에 C 컴파일러가 함수를 찾을 수 없으면 그것에 대한 컴파일러 / 링커 오류가 발생합니다. 따라서 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 를 포함하는 것을 잊어 버린 경우 큰 문제는 아니며 프로그램을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="94a20e630767a5b13c70ee7de6feee73b37a4ac4" translate="yes" xml:space="preserve">
          <source>If pointers and integers are differently sized, then you're hiding a warning by casting and might lose bits of your returned address.</source>
          <target state="translated">포인터와 정수의 크기가 다른 경우 캐스팅하여 경고를 숨기고 반환 된 주소의 비트가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a75eb3940c4c479252444c653d371d024274a3" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may
  also, need to change all lines where malloc is called and cast.</source>
          <target state="translated">선언에서 포인터의 유형이 변경되면 malloc이 호출되고 캐스트되는 모든 행을 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df36036f7f3128303dea4303afa83edbcf774e7f" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may also need to change all lines where &lt;code&gt;malloc&lt;/code&gt; is called and cast.</source>
          <target state="translated">선언에서 포인터의 유형이 변경되면 &lt;code&gt;malloc&lt;/code&gt; 이 호출되고 캐스트되는 모든 행을 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bcac15068f3bb62943c1a0a7f50cfe6b4f3ff96" translate="yes" xml:space="preserve">
          <source>If you adhere to these macros, then a simple &lt;code&gt;grep&lt;/code&gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.</source>
          <target state="translated">이 매크로를 준수하면 이러한 식별자에 대한 코드 기반의 간단한 &lt;code&gt;grep&lt;/code&gt; 검색으로 모든 캐스트가있는 위치를 보여 주므로 잘못된 것이 있는지 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38906a251997aa3b8616c404232d137ef1fa9d7d" translate="yes" xml:space="preserve">
          <source>If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.</source>
          <target state="translated">동일한 소스 코드로 C 및 C ++를 모두 지원해야하는 경우 컴파일러 스위치를 사용하여 차이점을 표시하십시오. 호환되지 않기 때문에 두 언어 표준을 동일한 코드로 작성하려고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7d3ac445fa31b61523e6e62450fd24ba439b4dfa" translate="yes" xml:space="preserve">
          <source>If your C code compiles as C++, you can use this &lt;code&gt;-Wold-style-cast&lt;/code&gt; option to find out all occurrences of the &lt;code&gt;(type)&lt;/code&gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).</source>
          <target state="translated">C 코드가 C ++로 컴파일되는 경우,이 &lt;code&gt;-Wold-style-cast&lt;/code&gt; 옵션을 사용하여 코드에 들어올 수있는 &lt;code&gt;(type)&lt;/code&gt; 캐스팅 구문을 모두 찾아서 적절한 진단 코드로 교체하여 진단을 수행 할 수 있습니다. 위의 매크로 중에서 선택하십시오 (또는 필요한 경우 조합).</target>
        </trans-unit>
        <trans-unit id="a1ec8dc8e827dcddaf1ac66310df0ab7f63c0d88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;this question&lt;/a&gt;, someone suggested in a &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;comment&lt;/a&gt; that I should &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; cast the result of &lt;code&gt;malloc&lt;/code&gt;, i.e.</source>
          <target state="translated">&lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;이 질문&lt;/a&gt; 에서 누군가가 &lt;code&gt;malloc&lt;/code&gt; 의 결과를 캐스트해서는 안된다는 &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;의견&lt;/a&gt; 을 제안했습니다.</target>
        </trans-unit>
        <trans-unit id="b3a9cebe6da5e7431620120cb56c6c593d67810c" translate="yes" xml:space="preserve">
          <source>In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.</source>
          <target state="translated">C에서는 void *가 다른 포인터 유형으로 자동으로 안전하게 승격되므로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="c3a26193ac8cf855c86ef90718a310c04be870e5" translate="yes" xml:space="preserve">
          <source>In C you can implicitly convert a void pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.</source>
          <target state="translated">C에서는 void 포인터를 다른 종류의 포인터로 암시 적으로 변환 할 수 있으므로 캐스트가 필요하지 않습니다. 하나를 사용하면 캐주얼 관찰자에게 하나의 이유가 있다고 오해의 소지가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e2c913a047567f896a4a85cdc21e25cc2d0c7db" translate="yes" xml:space="preserve">
          <source>In C you get an implicit conversion from &lt;code&gt;void*&lt;/code&gt; to any other (data) pointer.</source>
          <target state="translated">C에서는 &lt;code&gt;void*&lt;/code&gt; 에서 다른 (데이터) 포인터로의 암시 적 변환을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="124df7e4df177a7e9968fd6be1560944643fd8df" translate="yes" xml:space="preserve">
          <source>In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from &lt;code&gt;void *&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implicit. C++ has a whole set of different flavors of casting.</source>
          <target state="translated">C ++에서는 상황이 다릅니다. 파생 클래스의 객체를 처리 할 때 포인터 유형을 캐스팅하는 것이 다소 일반적이며 정확합니다. 따라서 C ++에서 &lt;code&gt;void *&lt;/code&gt; 와의 변환은 암시 적이 지 &lt;strong&gt;않습니다&lt;/strong&gt; . C ++에는 다양한 종류의 캐스팅이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10a5ed8bd778002e10989f9f97e0681982b277e7" translate="yes" xml:space="preserve">
          <source>In C, a &lt;strong&gt;pointer cast is almost always an error&lt;/strong&gt;. This is because of the following rule (&lt;strong&gt;&amp;sect;6.5 p7&lt;/strong&gt; in N1570, the latest draft for C11):</source>
          <target state="translated">C에서 &lt;strong&gt;포인터 캐스트는 거의 항상 오류&lt;/strong&gt; 입니다. 이는 다음 규칙 때문입니다 (C11의 최신 초안 N1570의 &lt;strong&gt;&amp;sect;6.5 p7&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="93b491dccf959abfcaab359525161959ceec4cb9" translate="yes" xml:space="preserve">
          <source>In C, you don't need to cast the return value of &lt;code&gt;malloc&lt;/code&gt;. The pointer to void returned by &lt;code&gt;malloc&lt;/code&gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:</source>
          <target state="translated">C에서는 &lt;code&gt;malloc&lt;/code&gt; 의 반환 값을 캐스트 할 필요가 없습니다. &lt;code&gt;malloc&lt;/code&gt; 이 리턴 한 void에 대한 포인터는 자동으로 올바른 유형으로 변환됩니다. 그러나 코드를 C ++ 컴파일러로 컴파일하려면 캐스트가 필요합니다. 커뮤니티에서 선호하는 대안은 다음을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d2b0038978d4b2837d991cc706ee1d4bd7ec268" translate="yes" xml:space="preserve">
          <source>In a nutshell: Because in C, &lt;strong&gt;any&lt;/strong&gt; occurrence of a &lt;em&gt;pointer cast&lt;/em&gt; should raise a red flag for code requiring special attention, you should never write &lt;em&gt;unnecessary&lt;/em&gt; pointer casts.</source>
          <target state="translated">간단히 말해서 : C에서는 &lt;em&gt;포인터 캐스트&lt;/em&gt; 가 발생할 때 특별한주의가 필요한 코드에 대해 빨간색 플래그를 발생시켜야하므로 &lt;em&gt;불필요한&lt;/em&gt; 포인터 캐스트를 작성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f72796a47c4da0050142849a0a239342b6c889b7" translate="yes" xml:space="preserve">
          <source>In fact, a good practice is to wrap &lt;code&gt;malloc&lt;/code&gt; (and friends) with functions that return &lt;code&gt;unsigned char *&lt;/code&gt;, and basically never to use &lt;code&gt;void *&lt;/code&gt; in your code.  If you need a generic pointer-to-any-object, use a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;unsigned char *&lt;/code&gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like &lt;code&gt;memset&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; without casts.</source>
          <target state="translated">실제로, &lt;code&gt;unsigned char *&lt;/code&gt; 를 리턴하는 함수로 &lt;code&gt;malloc&lt;/code&gt; (및 친구)을 랩핑하고 기본적으로 코드에서 &lt;code&gt;void *&lt;/code&gt; 를 사용하지 않는 것이 좋습니다. 객체에 대한 일반적인 포인터가 필요한 경우 &lt;code&gt;char *&lt;/code&gt; 또는 &lt;code&gt;unsigned char *&lt;/code&gt; 를 사용하고 양방향으로 캐스트하십시오. 아마도 탐닉 할 수있는 휴식은 캐스트없이 &lt;code&gt;memset&lt;/code&gt; 및 &lt;code&gt;memcpy&lt;/code&gt; 와 같은 기능을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b825dc3705674b4d779a4cf9b27487a2abaa1c23" translate="yes" xml:space="preserve">
          <source>In general, you &lt;strong&gt;don't cast to or from &lt;code&gt;void *&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">일반적으로 &lt;strong&gt; &lt;code&gt;void *&lt;/code&gt; 로 캐스트하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbe94d1061df0a0af541802fb33ece0468f3940" translate="yes" xml:space="preserve">
          <source>In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want &quot;type safe&quot; allocation, I can recommend the following macro functions, which I always use in my C projects:</source>
          <target state="translated">C 언어에서는 빈 포인터를 모든 포인터에 할당 할 수 있으므로 타입 캐스트를 사용하지 않아야합니다. &quot;유형 안전&quot;할당을 원한다면 항상 C 프로젝트에서 사용하는 다음 매크로 함수를 추천 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f485ca9c16f19d61d27f9da6f8f8aadd049c0b" translate="yes" xml:space="preserve">
          <source>In the ancient days, that is, before &lt;strong&gt;ANSI C&lt;/strong&gt; provides the &lt;code&gt;void *&lt;/code&gt; as the generic type of pointers, &lt;code&gt;char *&lt;/code&gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.</source>
          <target state="translated">고대에, 즉 &lt;strong&gt;ANSI C&lt;/strong&gt; 가 &lt;code&gt;void *&lt;/code&gt; 를 포인터의 일반 유형으로 제공하기 전에 &lt;code&gt;char *&lt;/code&gt; 는 그러한 사용을위한 유형입니다. 이 경우 캐스트는 컴파일러 경고를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e73547744432a5c3e5cd36995aa06c8a9413ed0" translate="yes" xml:space="preserve">
          <source>Including the cast may allow a C program or function to compile as C++.</source>
          <target state="translated">캐스트를 포함하면 C 프로그램 또는 함수가 C ++로 컴파일 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8f9ba5f633406eee7f889296c7a7219db4f7a2e" translate="yes" xml:space="preserve">
          <source>It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).</source>
          <target state="translated">코드에 혼란을 더하고 캐스트는 읽기가 쉽지 않습니다 (특히 포인터 유형이 긴 경우).</target>
        </trans-unit>
        <trans-unit id="870023467a1d4925f143d3d61e6c60413492cb7a" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes (or, worse, &lt;em&gt;not&lt;/em&gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you're hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there's no automatic assumption that undeclared functions return &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 포함을 잊어 버린 경우 오류를 숨길 수 있습니다. 이로 인해 충돌이 발생할 수 있습니다 (또는 코드의 완전히 다른 부분에서 나중에 충돌이 발생 &lt;em&gt;하지 않음&lt;/em&gt; ). 포인터와 정수의 크기가 다른 경우 어떻게되는지 고려하십시오. 전송하면 경고를 숨기고 반환 된 주소의 비트가 손실 될 수 있습니다. 참고 : C99 기준으로 암시 적 함수는 C에서 사라졌으며 선언되지 않은 함수가 &lt;code&gt;int&lt;/code&gt; 를 반환한다는 자동 가정이 없으므로이 시점은 더 이상 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a275723f60a0b42b3396018cbbac4f68a95ffd86" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 포함을 잊어 버린 경우 오류를 숨길 수 있습니다. 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba6c240782a51eb4cc2e1cddaefc3c7e3ed8dde5" translate="yes" xml:space="preserve">
          <source>It depends on the programming language and compiler. If you use &lt;code&gt;malloc&lt;/code&gt; in C there is no need to type cast it, as it will automatically type cast, However if your using C++ then you should type cast because &lt;code&gt;malloc&lt;/code&gt; will return a &lt;code&gt;void*&lt;/code&gt; type.</source>
          <target state="translated">프로그래밍 언어와 컴파일러에 따라 다릅니다. C에서 &lt;code&gt;malloc&lt;/code&gt; 을 사용하는 경우 자동으로 캐스트를 입력하므로 캐스트를 입력 할 필요가 없습니다. 그러나 C ++을 사용하는 경우 &lt;code&gt;malloc&lt;/code&gt; 이 &lt;code&gt;void*&lt;/code&gt; 유형을 리턴하므로 cast를 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="6794ae23413780fefc55f46bbeacf139ac860cbb" translate="yes" xml:space="preserve">
          <source>It forces an &lt;strong&gt;extra cognitive cross-check&lt;/strong&gt;. It puts the (alleged) desired type right next to the arithmetic you're doing for the raw size of that variable. I bet you could do an SO study that shows that &lt;code&gt;malloc()&lt;/code&gt; bugs are caught much faster when there's a cast. As with assertions, annotations that reveal intent decrease bugs.</source>
          <target state="translated">&lt;strong&gt;추가적인인지 검사를&lt;/strong&gt; 강제합니다. 해당 변수의 원시 크기에 대해 수행중인 산술 옆에 (알려진) 원하는 유형을 넣습니다. 캐스팅이있을 때 &lt;code&gt;malloc()&lt;/code&gt; 버그가 훨씬 빨리 잡히는 것을 보여주는 SO 연구를 할 수 있다고 확신합니다. 어설 션과 마찬가지로 의도를 나타내는 주석은 버그를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="89402a760239fb0d292e8e281d0c2cb9fb56bd70" translate="yes" xml:space="preserve">
          <source>It is not mandatory to cast the results of &lt;code&gt;malloc&lt;/code&gt;, since it returns &lt;code&gt;void*&lt;/code&gt; , and a &lt;code&gt;void*&lt;/code&gt; can be pointed to any datatype.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; 의 결과를 캐스트 할 필요는 &lt;code&gt;void*&lt;/code&gt; 반환하므로 &lt;code&gt;void*&lt;/code&gt; 는 모든 데이터 유형을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e5afe0ad6c9ac54a0f00b1936fe1beb836fed49" translate="yes" xml:space="preserve">
          <source>It is unnecessary, as &lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in this case.</source>
          <target state="translated">이 &lt;code&gt;void *&lt;/code&gt; 가 자동으로 다른 포인터 유형으로 승격되므로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="58da5d50b5f49af45e54e7443828c3d89f115f36" translate="yes" xml:space="preserve">
          <source>It makes you repeat yourself, which is generally bad.</source>
          <target state="translated">그것은 당신이 자신을 반복하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0bed687df391f9e44c4a7612a09f35920968a326" translate="yes" xml:space="preserve">
          <source>It makes your code &lt;strong&gt;more portable&lt;/strong&gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).</source>
          <target state="translated">C와 C ++ 사이에서 코드의 &lt;strong&gt;이식성&lt;/strong&gt; 을 높이고 SO 경험이 보여 주듯이 많은 프로그래머들은 실제로 C ++ (또는 C + 로컬 컴파일러 확장)로 작성할 때 C로 작성한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="9815dbbf9f559686ae80a3f22cf2a01f2a14f9f3" translate="yes" xml:space="preserve">
          <source>Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.</source>
          <target state="translated">내 경험을 추가하고 컴퓨터 공학을 공부하면서 C로 작문 한 두세 명의 교수가 항상 malloc을 캐스팅 한 것을 보았지만 (큰 이력서와 C에 대한 이해를 가지고) 요청한 사람은 그것이 절대적으로 불필요하다고 말했지만 예전에는 절대적으로 구체적이었고 학생들이 절대적으로 구체적이라는 마음가짐을 갖기 위해서였습니다. 본질적으로 캐스트는 작동 방식에서 아무것도 변경하지 않으며 정확히 말하고 메모리를 할당하며 캐스트는 영향을 미치지 않으며 동일한 메모리를 얻거나 실수로 다른 것으로 캐스팅하더라도 컴파일러를 회피합니다. C) 같은 방식으로 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="0bff15a7d248d16466f2ec04acb6217150b312d2" translate="yes" xml:space="preserve">
          <source>Make sure there are no variables declared as &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 로 선언 된 변수가 없는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="28b75c4f7d75c381d47362b41c7d2dc7264fc67f" translate="yes" xml:space="preserve">
          <source>Make your program compile through a C compiler with all warnings turned on &lt;code&gt;-Wall&lt;/code&gt; and fix all errors and warnings</source>
          <target state="translated">모든 경고를 설정 한 상태에서 C 컴파일러를 통해 프로그램을 컴파일하고-모든 오류 및 경고를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="7f8e8015eabf551886df6e32673d5bd7e6acb193" translate="yes" xml:space="preserve">
          <source>No, you don't cast the result of &lt;code&gt;malloc()&lt;/code&gt;.</source>
          <target state="translated">아니요, &lt;code&gt;malloc()&lt;/code&gt; 의 결과를 캐스트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcc3f1618153ed78f1a42b8c3a2643297139152b" translate="yes" xml:space="preserve">
          <source>Notice that the second cons should in the ideal case disappear when using the subset common to C together with the &lt;em&gt;static&lt;/em&gt; polymorphic feature.</source>
          <target state="translated">&lt;em&gt;정적&lt;/em&gt; 다형성 피처와 함께 C에 공통적 인 부분 집합을 사용하는 경우 이상적인 경우 두 번째 단점이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="7cee94d571455fbb9d3fed6656eb5b047a324b4c" translate="yes" xml:space="preserve">
          <source>Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.</source>
          <target state="translated">이제 C 컴파일러를 사용하여 다시 컴파일하십시오. 이제 프로그램이 경고없이 컴파일되고 버그가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="66b2bc6a1bd3edda594e285fc1aff85a54ceee08" translate="yes" xml:space="preserve">
          <source>On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to &lt;code&gt;int&lt;/code&gt;. Casting the result from malloc explicitly would then hide away this bug.</source>
          <target state="translated">25 년이 지난 표준 버전을 따르는 고대 컴파일러에서는 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 를 포함하지 않으면 위험한 동작이 발생합니다. 고대 표준에서 보이는 프로토 타입이없는 함수는 암시 적으로 리턴 유형을 &lt;code&gt;int&lt;/code&gt; 로 변환했기 때문입니다. malloc에서 결과를 명시 적으로 캐스팅하면이 버그가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="bfeed771bd20c1b4da4b2efa7a63dcac68154c3a" translate="yes" xml:space="preserve">
          <source>On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.</source>
          <target state="translated">반면, 캐스팅은 프로그램의 이식성을 증가시킬 수 있습니다. 즉, C 프로그램 또는 함수를 C ++로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2e33a9bf914822832f2f444dd3ff0f0627ac9c" translate="yes" xml:space="preserve">
          <source>On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you &lt;em&gt;have to&lt;/em&gt; cast the return value of &lt;code&gt;malloc&lt;/code&gt; when assigning it to something other than &lt;code&gt;void *&lt;/code&gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:</source>
          <target state="translated">캐스팅 및 C ++ 호환성에 관한 주제에서 코드를 작성하여 C 및 C ++로 컴파일되도록하는 경우 (이 경우 &lt;code&gt;void *&lt;/code&gt; 이외의 코드에 &lt;code&gt;malloc&lt;/code&gt; 을 할당 할 때 반환 값 &lt;em&gt;을&lt;/em&gt; 캐스팅해야 함) 매우 유용한 것 : C ++로 컴파일 할 때 C ++ 스타일 캐스트로 변환하는 캐스팅에 매크로를 사용할 수 있지만 C로 컴파일 할 때 C 캐스트로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="979716fcac00ca0824baf8e472028097ea147365" translate="yes" xml:space="preserve">
          <source>People used to GCC and Clang are spoiled.  It's not all that good out there.</source>
          <target state="translated">GCC와 Clang에 익숙한 사람들은 망치고 있습니다. 그다지 좋은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3d20bd7e564692465d39c6283102bcfeaf2f188b" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C FAQ&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C FAQ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="913b8c72c65c6f2c696ebd2645ce6fe63ffd34ca" translate="yes" xml:space="preserve">
          <source>Repeating yourself in a way that the machine can check is often a &lt;strong&gt;great&lt;/strong&gt; idea. In fact, that's what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.</source>
          <target state="translated">기계가 점검 할 수있는 방식으로 자신을 반복하는 것이 종종 &lt;strong&gt;좋은&lt;/strong&gt; 생각입니다. 사실, 이것이 어서 트의 정의이고, 캐스트의 사용은 어서 트입니다. 튜링은 수년 전에 아이디어를 생각해 냈기 때문에 어설 션은 코드를 올바르게 얻는 가장 일반적인 기술입니다.</target>
        </trans-unit>
        <trans-unit id="eeb9da9341aff1229aac0eeb3d8f1a6873b9e49d" translate="yes" xml:space="preserve">
          <source>Side notes:</source>
          <target state="translated">사이드 노트 :</target>
        </trans-unit>
        <trans-unit id="e07ca56cc28cf07f0e7efd4adeef84b39f654a4d" translate="yes" xml:space="preserve">
          <source>Since keeping the &lt;code&gt;sizeof&lt;/code&gt; first, in this case, ensures multiplication is done with at least &lt;code&gt;size_t&lt;/code&gt; math.</source>
          <target state="translated">이 경우 &lt;code&gt;sizeof&lt;/code&gt; 를 먼저 유지하므로 최소한 &lt;code&gt;size_t&lt;/code&gt; 수학으로 곱셈을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ac0ad68dd4aefb4ac26bf0c5e2facd9461dc449e" translate="yes" xml:space="preserve">
          <source>Some comments:</source>
          <target state="translated">일부 의견 :</target>
        </trans-unit>
        <trans-unit id="c9afff0f26991110c2bc5c4c2920c45f8f9e49f9" translate="yes" xml:space="preserve">
          <source>Sometimes, you &lt;strong&gt;do&lt;/strong&gt; need to cast pointers, but given the &lt;em&gt;strict aliasing rule&lt;/em&gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you &lt;strong&gt;have to double-check for its validity&lt;/strong&gt;. Therefore, you never write an unnecessary pointer cast.</source>
          <target state="translated">때로는 포인터를 캐스팅해야하지만 &lt;em&gt;엄격한 앨리어싱 규칙이&lt;/em&gt; 주어지면 매우 조심해야합니다. 따라서 코드에서 포인터 캐스트가 발생하면 &lt;strong&gt;유효성을 다시 확인해야합니다&lt;/strong&gt; . 따라서 불필요한 포인터 캐스트를 작성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="348a3fbc26f2688c8530060e66a13437b015bb1b" translate="yes" xml:space="preserve">
          <source>That way you can still write it in a very compact way:</source>
          <target state="translated">그렇게하면 여전히 매우 컴팩트 한 방식으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c11a87c54fbc0d09c65c5842cdeb16fbf6ce8d2" translate="yes" xml:space="preserve">
          <source>The argument that it's not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call &quot;local management's reality field&quot;.  And that's bent and twisted more than space time ever was. :-)</source>
          <target state="translated">현재 표준에서 필요하지 않다는 주장은 상당히 유효합니다. 그러나 그 주장은 실제 세계의 실용성을 생략합니다. 우리는 오늘의 표준에 의해 독점적으로 지배되는 세계에서 코드를 작성하는 것이 아니라 내가 &quot;지역 경영의 현실 분야&quot;라고 부르는 것의 실용성에 의해 코딩됩니다. 그리고 그것은 시공간보다 더 구부러지고 뒤틀 렸습니다. :-)</target>
        </trans-unit>
        <trans-unit id="cf7a2c5002660ed9183a2da4a4f0f11caa52353d" translate="yes" xml:space="preserve">
          <source>The best thing to do when programming in C whenever it is possible:</source>
          <target state="translated">가능할 때마다 C로 프로그래밍 할 때 가장 좋은 방법 :</target>
        </trans-unit>
        <trans-unit id="8e6a11c3b2030400be409620a47673e0ff112fad" translate="yes" xml:space="preserve">
          <source>The cast allows for pre-1989 versions of malloc that originally returned a char *.</source>
          <target state="translated">캐스트는 원래 char *를 리턴 한 1989 년 이전 버전의 malloc을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="998ffdec25506c948a2e362fe99f1587650eba18" translate="yes" xml:space="preserve">
          <source>The cast is necessary here, because &lt;code&gt;printf()&lt;/code&gt; is a variadic function, so implicit conversions don't work.</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; 는 가변 함수이므로 캐스트가 필요합니다. 따라서 암시 적 변환은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a53090f29cc6f3d564bf1c8d0a4c07064105db01" translate="yes" xml:space="preserve">
          <source>The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging</source>
          <target state="translated">void 포인터의 개념은 malloc이 void를 리턴하는 이유는 모든 데이터 유형으로 캐스트 될 수 있다는 것입니다. 또한 자동 유형 변환에 대해서도 알고 있어야합니다. 따라서 반드시 포인터를 캐스트해야하는 것은 아닙니다. 코드를 깨끗하게 유지하고 디버깅을 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="26a10d066398b061801f974a2a5ece03f6f54619" translate="yes" xml:space="preserve">
          <source>The idea that it keeps you from noticing you failed to &lt;code&gt;#include&lt;/code&gt; an appropriate header file misses &lt;strong&gt;the forest for the trees&lt;/strong&gt;. It's the same as saying &quot;don't worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!&quot;</source>
          <target state="translated">적절한 헤더 파일을 &lt;code&gt;#include&lt;/code&gt; 하지 못한 것을 눈치 채지 못하게한다는 생각 &lt;strong&gt;은 나무의 숲을&lt;/strong&gt; 놓치게됩니다. &quot;컴파일러에게 프로토 타입이 보이지 않는다는 불만을 제기하지 않았다는 사실에 대해 걱정하지 마십시오. pesky stdlib.h는 반드시 기억해야 할 중요한 사실입니다.&quot;라고 말하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7affa9334d50427587a11f830fa868eb1953cbca" translate="yes" xml:space="preserve">
          <source>The most common reason why people cast the result of malloc is because they are unsure about how the C language works. That's a warning sign: if you don't know how a particular language mechanism works, then &lt;em&gt;don't&lt;/em&gt; take a guess. Look it up or ask on Stack Overflow.</source>
          <target state="translated">사람들이 malloc의 결과를 제시하는 가장 일반적인 이유는 C 언어의 작동 방식에 대해 확신이 없기 때문입니다. 경고 표시입니다. 특정 언어 메커니즘이 어떻게 작동하는지 모르는 경우 추측 &lt;em&gt;하지 마십시오&lt;/em&gt; . 그것을 보거나 스택 오버플로를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="56afad940865bfcbe28c291e24c2bdf0ea7f35b5" translate="yes" xml:space="preserve">
          <source>The only benefits from writing in C instead of C++ I can find are</source>
          <target state="translated">내가 찾을 수있는 C ++ 대신 C로 작성하면 얻을 수있는 유일한 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="006baad78c74403e4762e856f8320bbf41a3f370" translate="yes" xml:space="preserve">
          <source>The pointer returned if the allocation succeeds is suitably aligned so
  that it may be assigned to a pointer to any type of object with a
  fundamental alignment requirement and then used to access such an
  object or an array of such objects in the space allocated (until the
  space is explicitly deallocated)</source>
          <target state="translated">할당이 성공하면 반환되는 포인터는 기본 정렬 요구 사항을 가진 모든 유형의 객체에 대한 포인터에 할당 된 다음 할당 된 공간에서 해당 객체 또는 이러한 객체의 배열에 액세스하는 데 사용할 수 있도록 적절하게 정렬됩니다 ( 공간이 명시 적으로 할당 해제되었습니다)</target>
        </trans-unit>
        <trans-unit id="b3c30a12e0dff950c02a5280e6432480b9bd8396" translate="yes" xml:space="preserve">
          <source>The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.</source>
          <target state="translated">리턴 된 유형은 void *이며, 이는 참조 불가능하도록 원하는 유형의 데이터 포인터로 캐스트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711c8a89d3f2be83e87fab517121c689d0361a34" translate="yes" xml:space="preserve">
          <source>Then compile it using a C++ compiler with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-std=c++11&lt;/code&gt;. Fix all errors and warnings.</source>
          <target state="translated">그런 다음 &lt;code&gt;-Wall&lt;/code&gt; 및 &lt;code&gt;-std=c++11&lt;/code&gt; 과 함께 C ++ 컴파일러를 사용하여 컴파일하십시오. 모든 오류 및 경고를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b833fdcd9601eb781a63d97976bc2af1531deb0f" translate="yes" xml:space="preserve">
          <source>Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use &lt;code&gt;strip_qual&lt;/code&gt; just to remove a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.</source>
          <target state="translated">그런 다음 C ++로 코드를 정기적으로 컴파일하면 적절한 캐스트를 사용해야합니다. 예를 들어, &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;volatile&lt;/code&gt; 을 제거하기 위해 &lt;code&gt;strip_qual&lt;/code&gt; 을 사용하지만 유형 변환이 수행되는 방식으로 프로그램이 변경되면 진단을 받고 캐스트 조합을 사용해야합니다. 원하는 전환.</target>
        </trans-unit>
        <trans-unit id="d4e668d4c1ef3d785a282afa7e0b53c99ffaf425" translate="yes" xml:space="preserve">
          <source>There are cases where you actually &lt;em&gt;need&lt;/em&gt; a cast to &lt;code&gt;void *&lt;/code&gt;, e.g. if you want to print a pointer:</source>
          <target state="translated">예를 들어 포인터를 인쇄하려는 경우 실제로 &lt;code&gt;void *&lt;/code&gt; 캐스트가 &lt;em&gt;필요한&lt;/em&gt; 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee851d6bd4c154373eb426a6cf77ad29b6c76b9" translate="yes" xml:space="preserve">
          <source>There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.</source>
          <target state="translated">다른 이유가있을 수 있지만, 거의 확실하게 다른 이유는 조만간 심각한 문제에 빠질 것입니다.</target>
        </trans-unit>
        <trans-unit id="186638c0a67a1197f7cd4cae91b6dbb0d0ea92b8" translate="yes" xml:space="preserve">
          <source>This also moves the &lt;code&gt;length&lt;/code&gt; to the front for increased visibility, and drops the redundant parentheses with &lt;code&gt;sizeof&lt;/code&gt;; they &lt;em&gt;are only needed&lt;/em&gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: &lt;code&gt;sizeof&lt;/code&gt; is not a function! :)</source>
          <target state="translated">또한 가시성을 높이기 위해 &lt;code&gt;length&lt;/code&gt; 를 앞쪽으로 이동하고 &lt;code&gt;sizeof&lt;/code&gt; ; 인수가 유형 이름 인 경우 &lt;em&gt;에만 필요합니다&lt;/em&gt; . 많은 사람들이 이것을 알지 못하거나 무시하여 코드를 더 장황하게 만듭니다. 기억하십시오 : &lt;code&gt;sizeof&lt;/code&gt; 는 함수가 아닙니다! :)</target>
        </trans-unit>
        <trans-unit id="78ccd0f84465d8f80acc739eeb1edc6c075d1c6d" translate="yes" xml:space="preserve">
          <source>This is also known as the &lt;em&gt;strict aliasing rule&lt;/em&gt;. So the following code is &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">이것을 &lt;em&gt;엄격한 앨리어싱 규칙&lt;/em&gt; 이라고도합니다. 따라서 다음 코드는 &lt;em&gt;정의되지 않은 동작입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2e07b201f2cd09204952f0ea2a8352e94d8350f8" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;The GNU C Library Reference&lt;/a&gt; manual says:</source>
          <target state="translated">&lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;GNU C 라이브러리 레퍼런스&lt;/a&gt; 매뉴얼은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2612aa90747c8f2cdc6c4aacf3c9fc773e8c9fc1" translate="yes" xml:space="preserve">
          <source>This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include &lt;code&gt;stdlib.h&lt;/code&gt;or you will get</source>
          <target state="translated">이 절차를 통해 C ++ 엄격한 유형 검사를 이용하여 버그 수를 줄일 수 있습니다. 특히이 절차는 &lt;code&gt;stdlib.h&lt;/code&gt; 를 포함 시키거나</target>
        </trans-unit>
        <trans-unit id="f2cce072b4fc94a737199982264f4a8e1b007734" translate="yes" xml:space="preserve">
          <source>This treatment of conversions is the single largest standalone technical justification for working in a &quot;Clean C&quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">이러한 변환 처리는 &quot;Clean C&quot;에서 작업하기위한 가장 큰 독립형 기술 정당성입니다. C 및 C ++ 결합 방언은 &lt;code&gt;malloc&lt;/code&gt; 의 반환 값 캐스팅을 기술적으로 정당화합니다.</target>
        </trans-unit>
        <trans-unit id="6c17a9be57ef9ca7cd3adf5ee8b5ef9628a4d46a" translate="yes" xml:space="preserve">
          <source>To add further, your code needlessly repeats the type information (&lt;code&gt;int&lt;/code&gt;) which can cause errors. It's better to de-reference the pointer being used to store the return value, to &quot;lock&quot; the two together:</source>
          <target state="translated">더 추가하기 위해 코드는 불필요하게 오류를 일으킬 수있는 유형 정보 ( &lt;code&gt;int&lt;/code&gt; )를 반복합니다. 반환 값을 저장하는 데 사용되는 포인터를 역 참조하여 둘을 &quot;잠그는&quot;것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="81eed5fc51c3e3b44fa0ef9d4d25cef34a474770" translate="yes" xml:space="preserve">
          <source>To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.</source>
          <target state="translated">이러한 매크로를 고수하는 데 도움이되는 GNU C ++ (C! 아님) 컴파일러는 C 스타일 캐스트의 모든 항목에 대해 생성되는 선택적 진단 기능인 아름다운 기능을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca84b5f4a5ac7139271f3940379fb2cf0336ee9f" translate="yes" xml:space="preserve">
          <source>Under the ANSI C standard, the cast is redundant.</source>
          <target state="translated">ANSI C 표준에서는 캐스트가 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="e8ec134ac31640fb573e0e153c5725b4e050b271" translate="yes" xml:space="preserve">
          <source>While moving &lt;code&gt;length&lt;/code&gt; to the front &lt;em&gt;may&lt;/em&gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:</source>
          <target state="translated">드문 경우이지만 &lt;code&gt;length&lt;/code&gt; 를 앞쪽으로 이동하면 가시성 &lt;em&gt;이&lt;/em&gt; 높아질 &lt;em&gt;수&lt;/em&gt; 있지만 일반적인 경우에는 다음과 같이 표현을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9ee85b34131db60fdfd151a81fdc887dd4fcd22a" translate="yes" xml:space="preserve">
          <source>Why would this be the case?</source>
          <target state="translated">왜 이런 경우입니까?</target>
        </trans-unit>
        <trans-unit id="01acdaf9e307b1e0a0b814ed27a2ec340c2e2c33" translate="yes" xml:space="preserve">
          <source>With these in place you can simply say</source>
          <target state="translated">이것들을 사용하면 간단히 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="e0ed2586aa5abd52d3b653c0086a309021a02618" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;do&lt;/strong&gt; cast, because:</source>
          <target state="translated">다음과 같은 이유로 캐스트를 &lt;strong&gt;수행합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="79486d2c3a27f80999f77ddcc416d8f23c32e95a" translate="yes" xml:space="preserve">
          <source>You can store the result of &lt;code&gt;malloc&lt;/code&gt; into any pointer variable without a
  cast, because ISO C automatically converts the type &lt;code&gt;void *&lt;/code&gt; to another
  type of pointer when necessary. But the cast is necessary in contexts
  other than assignment operators or if you might want your code to run
  in traditional C.</source>
          <target state="translated">필요한 경우 ISO C가 &lt;code&gt;void *&lt;/code&gt; 유형을 다른 유형의 포인터로 자동 변환하기 때문에 &lt;code&gt;malloc&lt;/code&gt; 의 결과를 캐스트없이 모든 포인터 변수에 저장할 수 있습니다. 그러나 캐스트는 할당 연산자가 아닌 다른 컨텍스트에서 또는 코드가 전통적인 C에서 실행되기를 원할 경우 필요합니다.</target>
        </trans-unit>
        <trans-unit id="64d12490b03733be1bf0ccdb5177f441ae3b32a3" translate="yes" xml:space="preserve">
          <source>You don't cast the result of malloc, because doing so adds pointless clutter to your code.</source>
          <target state="translated">malloc의 결과를 캐스트하지 마십시오. 그렇게하면 코드에 무의미한 혼란이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="719d41b4076bc570c545a47f1031a67ded961c28" translate="yes" xml:space="preserve">
          <source>and also forces you to cast the result of &lt;code&gt;malloc&lt;/code&gt; or you will get</source>
          <target state="translated">또한 &lt;code&gt;malloc&lt;/code&gt; 의 결과를 캐스트하도록 강요하거나</target>
        </trans-unit>
        <trans-unit id="542161e54ecd4adeeeb635a9cdad11414084409e" translate="yes" xml:space="preserve">
          <source>and it will compile for C and C++.</source>
          <target state="translated">C 및 C ++를 위해 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="64083eb0fbc1cccbe1930ff6c0eb620b8e9c0cc1" translate="yes" xml:space="preserve">
          <source>i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">즉, C 프로그램을 C ++로 컴파일해야하는 경우 (별도의 언어이지만) &lt;code&gt;malloc&lt;/code&gt; 사용 결과를 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="7feac0152fbb8ddbd92237edaa50e15426a689c0" translate="yes" xml:space="preserve">
          <source>invalid conversion from &lt;code&gt;void*&lt;/code&gt; to &lt;code&gt;T*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void*&lt;/code&gt; 에서 &lt;code&gt;T*&lt;/code&gt; 로의 잘못된 변환</target>
        </trans-unit>
        <trans-unit id="d4336376d32d8dd4374715878d5ec2aff3007481" translate="yes" xml:space="preserve">
          <source>or what ever your target type is.</source>
          <target state="translated">또는 대상 유형이 무엇이든.</target>
        </trans-unit>
        <trans-unit id="82b524d90dbcf160ddb4a560d1503123520ae7c4" translate="yes" xml:space="preserve">
          <source>rather than:</source>
          <target state="translated">오히려</target>
        </trans-unit>
        <trans-unit id="6ef706998cf17ef7293cdb6fad421229fb5f8d93" translate="yes" xml:space="preserve">
          <source>tl;dr</source>
          <target state="translated">tl;dr</target>
        </trans-unit>
        <trans-unit id="0b710aa273bfb4642bf11423f66ee900b109348f" translate="yes" xml:space="preserve">
          <source>which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of &lt;code&gt;sieve&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;sieve&lt;/code&gt; 의 유형을 변경하는 경우 표현식의 오른쪽을 변경하는 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="56cf084c8081e52c77e6553b2ba637aae876ab2f" translate="yes" xml:space="preserve">
          <source>which makes array loops safer and more convenient:</source>
          <target state="translated">배열 루프를보다 안전하고 편리하게 만듭니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
