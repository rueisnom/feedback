<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/605845">
    <body>
      <group id="605845">
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">- un tipo de personaje.</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">- una versi&amp;oacute;n calificada de un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="e44f2c14403ad448407e98ab24bfdee66bfa24a3" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">- un tipo compatible con el tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,</source>
          <target state="translated">- un tipo que es el tipo con signo o sin signo correspondiente a una versi&amp;oacute;n calificada del tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the
  object,</source>
          <target state="translated">- un tipo que es el tipo con signo o sin signo correspondiente al tipo efectivo del objeto,</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">- un tipo agregado o de uni&amp;oacute;n que incluye uno de los tipos antes mencionados entre sus miembros (incluido, recursivamente, un miembro de una uni&amp;oacute;n agregada o contenida), o</target>
        </trans-unit>
        <trans-unit id="ae7e0cdae2ac7249d987bff149081b201e3a0fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;malloc&lt;/code&gt; was not declared within this scope</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; no fue declarado dentro de este alcance</target>
        </trans-unit>
        <trans-unit id="0e5f928812738db0ec93ccf2bf989d2ddde07c40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in the case of C.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; se promociona de forma autom&amp;aacute;tica y segura a cualquier otro tipo de puntero en el caso de C.</target>
        </trans-unit>
        <trans-unit id="a391dd112c4d19334c4d2262800b52d709ef87f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ventajas del casting&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70e320e2947eef2af5ecd6ba7d5df9624b0e3047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Desventajas de lanzar&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2846f9a1c6a1377c632edfa1214b7fc3a69f21f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.</source>
          <target state="translated">&lt;strong&gt;Editar: El&lt;/strong&gt; casting tiene un cierto punto. Cuando utiliza la notaci&amp;oacute;n de matriz, el c&amp;oacute;digo generado tiene que saber cu&amp;aacute;ntos lugares de memoria tiene que avanzar para alcanzar el comienzo del siguiente elemento, esto se logra mediante la conversi&amp;oacute;n. De esta manera, usted sabe que para un doble, va 8 bytes adelante, mientras que para un int va 4, y as&amp;iacute; sucesivamente. Por lo tanto, no tiene efecto si utiliza la notaci&amp;oacute;n de puntero, en notaci&amp;oacute;n de matriz se hace necesario.</target>
        </trans-unit>
        <trans-unit id="ecf1f68c1a0bb45cb2b18963cb8bbc692db8e531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No&lt;/strong&gt;; you &lt;em&gt;don't&lt;/em&gt; cast the result, since:</source>
          <target state="translated">&lt;strong&gt;No&lt;/strong&gt; &lt;em&gt;no&lt;/em&gt; arrojas el resultado, ya que:</target>
        </trans-unit>
        <trans-unit id="f479abc04339b7f7648e42d0dcae330fdbce9d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The casting of malloc is unnecessary in C but mandatory in C++.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La conversi&amp;oacute;n de malloc es innecesaria en C pero obligatoria en C ++.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="05ecd5960f9d99ecd5ac614c91583260f522bd42" translate="yes" xml:space="preserve">
          <source>A typical reason given for not doing so is that failure to &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; could go unnoticed. This isn't an issue anymore for a long time now as C99 made &lt;em&gt;implicit function declarations&lt;/em&gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.</source>
          <target state="translated">Una raz&amp;oacute;n t&amp;iacute;pica dada para no hacerlo es que el hecho de no &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; podr&amp;iacute;a pasar desapercibido. Esto ya no es un problema desde hace mucho tiempo ya que C99 hizo &lt;em&gt;que las declaraciones de funciones impl&amp;iacute;citas sean&lt;/em&gt; ilegales, por lo que si su compilador cumple al menos con C99, recibir&amp;aacute; un mensaje de diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="2a368dec1332cfeb0f803131ba36c04da26e07ad" translate="yes" xml:space="preserve">
          <source>A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).</source>
          <target state="translated">Un puntero de vacío puede convertirse en cualquier otro tipo de puntero sin un molde explícito (C11 6.3.2.3 y 6.5.16.1).</target>
        </trans-unit>
        <trans-unit id="0471ce3799acd66098fce34b5150690360d1c931" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">Un puntero de vacío es un puntero de objeto genérico y C soporta la conversión implícita de un tipo de puntero de vacío a otros tipos,por lo que no es necesario mecanografiarlo explícitamente.</target>
        </trans-unit>
        <trans-unit id="a26d186fb3412a6fc71664243f45c9e7df4a5f6e" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">Un puntero de vacío es un puntero genérico y C soporta la conversión implícita de un tipo de puntero de vacío a otros tipos,por lo que no es necesario mecanografiarlo explícitamente.</target>
        </trans-unit>
        <trans-unit id="d2e4fe0f4f3fae71f095a8f015fe0d1094245585" translate="yes" xml:space="preserve">
          <source>Adding the cast may mask failure to include the header &lt;em&gt;stdlib.h&lt;/em&gt;, in
  which the prototype for malloc is found. In the absence of a
  prototype for malloc, the standard requires that the C compiler
  assume malloc returns an int. If there is no cast, a warning is
  issued when this integer is assigned to the pointer; however, with
  the cast, this warning is not produced, hiding a bug. On certain
  architectures and data models (such as LP64 on 64-bit systems, where
  long and pointers are 64-bit and int is 32-bit), this error can
  actually result in undefined behaviour, as the implicitly declared
  malloc returns a 32-bit value whereas the actually defined function
  returns a 64-bit value. Depending on calling conventions and memory
  layout, this may result in stack smashing. This issue is less likely
  to go unnoticed in modern compilers, as they uniformly produce
  warnings that an undeclared function has been used, so a warning will
  still appear. For example, GCC's default behaviour is to show a
  warning that reads &quot;incompatible implicit declaration of built-in
  function&quot; regardless of whether the cast is present or not.</source>
          <target state="translated">Agregar el reparto puede enmascarar la falla al incluir el encabezado &lt;em&gt;stdlib.h&lt;/em&gt; , en el cual se encuentra el prototipo de malloc. En ausencia de un prototipo para malloc, el est&amp;aacute;ndar requiere que el compilador de C asuma que malloc devuelve un int. Si no hay conversi&amp;oacute;n, se emite una advertencia cuando este entero se asigna al puntero; sin embargo, con el reparto, esta advertencia no se produce, ocultando un error. En ciertas arquitecturas y modelos de datos (como LP64 en sistemas de 64 bits, donde long y punteros son de 64 bits e int es de 32 bits), este error puede dar lugar a un comportamiento indefinido, ya que el malloc declarado impl&amp;iacute;citamente devuelve un 32- valor de bit, mientras que la funci&amp;oacute;n realmente definida devuelve un valor de 64 bits. Dependiendo de las convenciones de llamadas y el dise&amp;ntilde;o de la memoria, esto puede provocar la destrucci&amp;oacute;n de la pila. Es menos probable que este problema pase desapercibido en los compiladores modernos, ya que uniformemente producen advertencias de que se ha utilizado una funci&amp;oacute;n no declarada, por lo que a&amp;uacute;n aparecer&amp;aacute; una advertencia. Por ejemplo, el comportamiento predeterminado de GCC es mostrar una advertencia que dice &quot;declaraci&amp;oacute;n impl&amp;iacute;cita incompatible de funci&amp;oacute;n incorporada&quot;, independientemente de si el elenco est&amp;aacute; presente o no.</target>
        </trans-unit>
        <trans-unit id="330de36771a8855149af70009a392efe7137c117" translate="yes" xml:space="preserve">
          <source>Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.</source>
          <target state="translated">También hay que tener en cuenta,como señalan los comentaristas,que lo anterior se refiere a la C directa,no a la C++.Creo muy firmemente en C y C++como lenguajes separados.</target>
        </trans-unit>
        <trans-unit id="49b4f10f65b03b7676c9928862b57a7bb5936eaa" translate="yes" xml:space="preserve">
          <source>Although &lt;strong&gt;malloc without casting is preferred method and most experienced programmers choose it&lt;/strong&gt;, you should use whichever you like having aware of the issues.</source>
          <target state="translated">Aunque &lt;strong&gt;malloc sin conversi&amp;oacute;n es el m&amp;eacute;todo preferido y la mayor&amp;iacute;a de los programadores experimentados lo eligen&lt;/strong&gt; , debe usar el que desee para tener conocimiento de los problemas.</target>
        </trans-unit>
        <trans-unit id="82b3b63ccc5e46c358ff4d906c737902b003bf00" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:</source>
          <target state="translated">A un objeto sólo se podrá acceder a su valor almacenado mediante una expresión de valor l que tenga uno de los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="415ebcd3f0d0eb14cdd2373b4ef70b900e3218af" translate="yes" xml:space="preserve">
          <source>And indeed the &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11 standard&lt;/a&gt; (p347) says so:</source>
          <target state="translated">Y, de hecho, el &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;est&amp;aacute;ndar ISO C11&lt;/a&gt; (p347) lo dice as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="106cd39a268698352cf10943c417d2f7799f7985" translate="yes" xml:space="preserve">
          <source>And, sometimes surprisingly, the following is as well:</source>
          <target state="translated">Y,a veces sorprendentemente,lo siguiente también:</target>
        </trans-unit>
        <trans-unit id="98cee4f987282b9a2bc48df1269201546773ac75" translate="yes" xml:space="preserve">
          <source>As a clarification, note that I said &quot;you don't cast&quot;, not &quot;you don't &lt;em&gt;need&lt;/em&gt; to cast&quot;. In my opinion, it's a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don't know about the risks.</source>
          <target state="translated">Como aclaraci&amp;oacute;n, tenga en cuenta que dije &quot;usted no lanza&quot;, no &quot;no &lt;em&gt;necesita&lt;/em&gt; lanzar&quot;. En mi opini&amp;oacute;n, es un fracaso incluir el elenco, incluso si lo hiciste bien. Simplemente no hay beneficios al hacerlo, pero hay un mont&amp;oacute;n de riesgos potenciales, e incluir el elenco indica que no conoce los riesgos.</target>
        </trans-unit>
        <trans-unit id="52d6db561d5a32a930d6064e45cfff6f3d42fec9" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++.</source>
          <target state="translated">Como ya se ha dicho,no se necesita para C,sino para C++.</target>
        </trans-unit>
        <trans-unit id="d1b5b1727f0d804cd9571ddd5eeac48d6b713bf5" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++. If you think you are going to compile your C code with a C++ compiler, for which reasons ever, you can use a macro instead, like:</source>
          <target state="translated">Como se ha dicho,no se necesita para C,sino para C++.Si crees que vas a compilar tu código C con un compilador de C++,por las razones que sean,puedes usar una macro en su lugar,como:</target>
        </trans-unit>
        <trans-unit id="336cb3d7090a86262459260c2cb734602c2436e0" translate="yes" xml:space="preserve">
          <source>Because &lt;strong&gt;stdlib.h&lt;/strong&gt; contains the prototype for malloc is found. In the
absence of a prototype for malloc, the standard requires that the C
compiler assumes malloc returns an int. If there is no cast, a
warning is issued when this integer is assigned to the pointer;
however, with the cast, this warning is not produced, hiding a bug.</source>
          <target state="translated">Porque &lt;strong&gt;stdlib.h&lt;/strong&gt; contiene el prototipo para malloc se encuentra. En ausencia de un prototipo para malloc, el est&amp;aacute;ndar requiere que el compilador de C asuma que malloc devuelve un int. Si no hay conversi&amp;oacute;n, se emite una advertencia cuando este entero se asigna al puntero; sin embargo, con el reparto, esta advertencia no se produce, ocultando un error.</target>
        </trans-unit>
        <trans-unit id="bdc72cf404853fbac86b2c23dcbbf0c9e530081f" translate="yes" xml:space="preserve">
          <source>But if you cast then, it can hide an error if you forgot to include
&lt;strong&gt;stdlib.h&lt;/strong&gt;. This can cause crashes (or, worse, not cause a crash
until way later in some totally different part of the code).</source>
          <target state="translated">Pero si lanza, puede ocultar un error si olvid&amp;oacute; incluir &lt;strong&gt;stdlib.h&lt;/strong&gt; . Esto puede causar bloqueos (o, lo que es peor, no causar un bloqueo hasta m&amp;aacute;s tarde en una parte totalmente diferente del c&amp;oacute;digo).</target>
        </trans-unit>
        <trans-unit id="607d50bbf8a35ccb5efb5dcb48502884b9e0b8a2" translate="yes" xml:space="preserve">
          <source>But that is really a non-issue. You aren't using a 25 years old computer, so why would you use a 25 years old compiler?</source>
          <target state="translated">Pero eso no es un problema.No estás usando un ordenador de 25 años,así que ¿por qué usar un compilador de 25 años?</target>
        </trans-unit>
        <trans-unit id="944b838189a9bff8c526a212fceaae45ebfd75be" translate="yes" xml:space="preserve">
          <source>But there's a &lt;strong&gt;much stronger reason&lt;/strong&gt; not to introduce unnecessary pointer casts:</source>
          <target state="translated">Pero hay una &lt;strong&gt;raz&amp;oacute;n mucho m&amp;aacute;s fuerte para&lt;/strong&gt; no introducir lanzamientos de puntero innecesarios:</target>
        </trans-unit>
        <trans-unit id="478bb2a442cb08ae6c0bbcddf6fd2f695a1f51d8" translate="yes" xml:space="preserve">
          <source>C has a well specified ABI</source>
          <target state="translated">C tiene un ABI bien especificado</target>
        </trans-unit>
        <trans-unit id="944a73e911447184dc231ecc770caa2caeec4d8e" translate="yes" xml:space="preserve">
          <source>C++ may generate more code [exceptions, RTTI, templates, &lt;em&gt;runtime&lt;/em&gt; polymorphism]</source>
          <target state="translated">C ++ puede generar m&amp;aacute;s c&amp;oacute;digo [excepciones, RTTI, plantillas, polimorfismo de &lt;em&gt;tiempo de ejecuci&amp;oacute;n&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ff9f56607dcdf5bb324bf522b13344b0a6d2e767" translate="yes" xml:space="preserve">
          <source>C++ will however not allow an implicit cast between &lt;code&gt;void*&lt;/code&gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use &lt;code&gt;new&lt;/code&gt; and not malloc(). And you should never compile C code using a C++ compiler.</source>
          <target state="translated">Sin embargo, C ++ no permitir&amp;aacute; una conversi&amp;oacute;n impl&amp;iacute;cita entre &lt;code&gt;void*&lt;/code&gt; y otro tipo de puntero. Entonces, en C ++, el reparto habr&amp;iacute;a sido correcto. Pero si programa en C ++, debe usar &lt;code&gt;new&lt;/code&gt; y no malloc (). Y nunca debe compilar c&amp;oacute;digo C usando un compilador de C ++.</target>
        </trans-unit>
        <trans-unit id="78057e43e77bcc9e1b0e757fb0b316b966566195" translate="yes" xml:space="preserve">
          <source>Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).</source>
          <target state="translated">El casting puede ayudar al desarrollador a identificar inconsistencias en el tamaño de los tipos en caso de que cambie el tipo de puntero de destino,en particular si el puntero se declara lejos de la llamada malloc()(aunque los compiladores modernos y los analizadores estáticos pueden advertir de ese comportamiento sin necesidad de recurrir al casting).</target>
        </trans-unit>
        <trans-unit id="3a2d7a3d4e4dd946e19f2db024674b8a866ed8cf" translate="yes" xml:space="preserve">
          <source>Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.</source>
          <target state="translated">El casting es sólo para C++,no para C.En caso de que estés usando un compilador de C++es mejor que lo cambies a un compilador de C.</target>
        </trans-unit>
        <trans-unit id="78ef6be30b2521065f2a740c15e9efe938dca1d7" translate="yes" xml:space="preserve">
          <source>Casting is unnecessary in C because of:</source>
          <target state="translated">El casting es innecesario en C debido a:</target>
        </trans-unit>
        <trans-unit id="b42fae74757338a083888cbb30e027c6114dbcf5" translate="yes" xml:space="preserve">
          <source>Casting the value returned by &lt;code&gt;malloc()&lt;/code&gt; is not necessary now, but I'd like to add one point that seems no one has pointed out:</source>
          <target state="translated">Ahora no es necesario convertir el valor devuelto por &lt;code&gt;malloc()&lt;/code&gt; , pero me gustar&amp;iacute;a agregar un punto que parece que nadie ha se&amp;ntilde;alado:</target>
        </trans-unit>
        <trans-unit id="5dc2c2dd9de34c36ad74f0a09bd8fa0995f45367" translate="yes" xml:space="preserve">
          <source>Casts are bad, as people have pointed out. Specially pointer casts.</source>
          <target state="translated">Los yesos son malos,como la gente ha señalado.Especialmente los yesos de punta.</target>
        </trans-unit>
        <trans-unit id="346818851b71e2b51b940fdbcd739e7bed8a4685" translate="yes" xml:space="preserve">
          <source>Compare: &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; the second may overflow the &lt;code&gt;length * width&lt;/code&gt; when &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are smaller types than &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">Compare: &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; versus &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; el segundo puede desbordar la &lt;code&gt;length * width&lt;/code&gt; cuando &lt;code&gt;width&lt;/code&gt; y &lt;code&gt;length&lt;/code&gt; son tipos m&amp;aacute;s peque&amp;ntilde;os que &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92a59634a691e677f0f3007226a9b9924a1c7ae0" translate="yes" xml:space="preserve">
          <source>Do I cast the result of malloc</source>
          <target state="translated">¿Debo emitir el resultado de la mallocación...</target>
        </trans-unit>
        <trans-unit id="9a415f9c8b3c43f63b86077e60ea92ecb549f584" translate="yes" xml:space="preserve">
          <source>Failing to do so &lt;strong&gt;can hide an error&lt;/strong&gt;: note all the SO examples of confusing when to write &lt;code&gt;type *&lt;/code&gt; versus &lt;code&gt;type **&lt;/code&gt;.</source>
          <target state="translated">Si no lo hace, &lt;strong&gt;puede ocultar un error&lt;/strong&gt; : tenga en cuenta todos los ejemplos SO de confusi&amp;oacute;n al escribir &lt;code&gt;type *&lt;/code&gt; versus &lt;code&gt;type **&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2178cbc15519aa10d900c715292a6bb33865e63" translate="yes" xml:space="preserve">
          <source>For me, the take home and conclusion here is that casting &lt;code&gt;malloc&lt;/code&gt; in C is totally NOT necessary but if you however cast, it wont affect &lt;code&gt;malloc&lt;/code&gt; as &lt;code&gt;malloc&lt;/code&gt; will still allocate to you your requested blessed memory space.
Another take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.</source>
          <target state="translated">Para m&amp;iacute;, la conclusi&amp;oacute;n y la conclusi&amp;oacute;n aqu&amp;iacute; es que lanzar &lt;code&gt;malloc&lt;/code&gt; en C NO es totalmente necesario, pero si lo haces, no afectar&amp;aacute; a &lt;code&gt;malloc&lt;/code&gt; , ya que &lt;code&gt;malloc&lt;/code&gt; a&amp;uacute;n te asignar&amp;aacute; el espacio de memoria bendito que solicitaste. Otra raz&amp;oacute;n para llevar a casa es la raz&amp;oacute;n o una de las razones por las cuales las personas hacen casting y esto es para permitirles compilar el mismo programa en C o C ++.</target>
        </trans-unit>
        <trans-unit id="9a6ca1a7645efee702ad8b765fe9acc8115a216a" translate="yes" xml:space="preserve">
          <source>For non-dynamic arrays, the third must-have function macro is</source>
          <target state="translated">Para las matrices no dinámicas,la tercera función macro imprescindible es</target>
        </trans-unit>
        <trans-unit id="e5e168dace40a1a84f885ba2ab5051ce961fb7af" translate="yes" xml:space="preserve">
          <source>For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type</source>
          <target state="translated">Para aquellos que encuentran las reglas estrictas de C++inconvenientes,podemos usar la característica de C++11 con el tipo inferido</target>
        </trans-unit>
        <trans-unit id="aa1ec3f6766ce7c0a977b7f1dcad4b9a5591083b" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;Wikipedia&lt;/a&gt;:</source>
          <target state="translated">De la &lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;Wikipedia&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d392caebbb009ac1a9c6b77c7ec1500ff9e46c8b" translate="yes" xml:space="preserve">
          <source>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</source>
          <target state="translated">Sin embargo,si quieres que el mismo código funcione perfectamente compatible en una plataforma C++,que no soporta la conversión implícita,tienes que hacer el encasillamiento,así que todo depende de la usabilidad.</target>
        </trans-unit>
        <trans-unit id="380ef8a6f771b5ae1e081f919a36b6a9c2179d06" translate="yes" xml:space="preserve">
          <source>I have been pretty horrified over the years by the staggeringly aged compilers I've been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even &lt;em&gt;test&lt;/em&gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you're coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.</source>
          <target state="translated">A lo largo de los a&amp;ntilde;os, he estado bastante horrorizado por los compiladores asombrosamente viejos que me han requerido usar. A menudo, las empresas y los gerentes adoptan un enfoque ultraconservador para cambiar los compiladores y ni siquiera &lt;em&gt;prueban&lt;/em&gt; si un nuevo compilador (con mejor cumplimiento de est&amp;aacute;ndares y optimizaci&amp;oacute;n de c&amp;oacute;digo) funcionar&amp;aacute; en su sistema. La realidad pr&amp;aacute;ctica para los desarrolladores que trabajan es que cuando est&amp;aacute;s codificando necesitas cubrir tus bases y, desafortunadamente, lanzar mallocs es un buen h&amp;aacute;bito si no puedes controlar qu&amp;eacute; compilador puede aplicarse a tu c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="0a9910af5e1d18f3c2c4a89ac01f4df8104d0369" translate="yes" xml:space="preserve">
          <source>I prefer to do the cast, but not manually. My favorite is using &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt;, you would get an error. &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; both take the same arguments, unlike &lt;code&gt;malloc&lt;/code&gt; that takes fewer arguments than &lt;code&gt;calloc&lt;/code&gt;. Just add &lt;code&gt;0&lt;/code&gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.</source>
          <target state="translated">Prefiero hacer el reparto, pero no manualmente. Mi favorito es usar las macros &lt;code&gt;g_new&lt;/code&gt; y &lt;code&gt;g_new0&lt;/code&gt; de glib. Si no se usa glib, agregar&amp;iacute;a macros similares. Esas macros reducen la duplicaci&amp;oacute;n de c&amp;oacute;digo sin comprometer la seguridad del tipo. Si obtiene el tipo incorrecto, obtendr&amp;iacute;a una conversi&amp;oacute;n impl&amp;iacute;cita entre punteros no vac&amp;iacute;os, lo que provocar&amp;iacute;a una advertencia (error en C ++). Si olvida incluir el encabezado que define &lt;code&gt;g_new&lt;/code&gt; y &lt;code&gt;g_new0&lt;/code&gt; , obtendr&amp;aacute; un error. &lt;code&gt;g_new&lt;/code&gt; y &lt;code&gt;g_new0&lt;/code&gt; toman los mismos argumentos, a diferencia de &lt;code&gt;malloc&lt;/code&gt; que toma menos argumentos que &lt;code&gt;calloc&lt;/code&gt; . Simplemente agregue &lt;code&gt;0&lt;/code&gt; para obtener memoria de inicializaci&amp;oacute;n cero. El c&amp;oacute;digo se puede compilar con un compilador de C ++ sin cambios.</target>
        </trans-unit>
        <trans-unit id="7a0d0fc82cd9dea6a8c022c171d7eeb4643d5033" translate="yes" xml:space="preserve">
          <source>I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:</source>
          <target state="translated">Puse el molde simplemente para mostrar mi desaprobación por el feo agujero en el sistema de tipos,que permite que códigos como el siguiente recorte se compilen sin diagnósticos,aunque no se usen moldes para provocar la mala conversión:</target>
        </trans-unit>
        <trans-unit id="e084e2204e0fd41e68fb321510dcda59220f10db" translate="yes" xml:space="preserve">
          <source>I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you've not included stdlib.h then you've &lt;em&gt;way&lt;/em&gt; more problems than casting malloc ! ).</source>
          <target state="translated">Tiendo a pensar en lanzar Malloc como una operaci&amp;oacute;n defensiva. No es bonito, no es perfecto, pero generalmente es seguro. (Honestamente, si no has incluido stdlib.h, &amp;iexcl;entonces tienes muchos m&amp;aacute;s problemas que lanzar malloc!).</target>
        </trans-unit>
        <trans-unit id="a082eae6a8d0490ecb7ed60105f751966f9d8c0c" translate="yes" xml:space="preserve">
          <source>I wish that didn't exist (and it doesn't in C++) and so I cast. It represents my taste, and my programming politics. I'm not only casting a pointer, but effectively, casting a ballot, and &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;casting out demons of stupidity&lt;/a&gt;. If I can't &lt;em&gt;actually&lt;/em&gt;&lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;cast out stupidity&lt;/a&gt;, then at least let me express the wish to do so with a gesture of protest.</source>
          <target state="translated">Desear&amp;iacute;a que no existiera (y no existe en C ++) y, por lo tanto, lanc&amp;eacute;. Representa mi gusto y mi pol&amp;iacute;tica de programaci&amp;oacute;n. No solo estoy lanzando un puntero, sino efectivamente, votando y &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;expulsando demonios de estupidez&lt;/a&gt; . Si no puedo &lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;expulsar la estupidez&lt;/a&gt; , al menos perm&amp;iacute;teme expresar el deseo de hacerlo con un gesto de protesta.</target>
        </trans-unit>
        <trans-unit id="be1a978a33b721660c705d3cb5ac611abd6a2873" translate="yes" xml:space="preserve">
          <source>I would also suggest that many organizations apply a coding standard of their own and that &lt;em&gt;that&lt;/em&gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.</source>
          <target state="translated">Tambi&amp;eacute;n sugerir&amp;iacute;a que muchas organizaciones apliquen un est&amp;aacute;ndar de codificaci&amp;oacute;n propio y que &lt;em&gt;ese&lt;/em&gt; deber&amp;iacute;a ser el m&amp;eacute;todo que la gente siga si se define. En ausencia de una gu&amp;iacute;a expl&amp;iacute;cita, tiendo a ir con mayor probabilidad de compilar en todas partes, en lugar de una servil adhesi&amp;oacute;n a un est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="63aba8e191469bdf847cbb632a77ed2a7d0526f5" translate="yes" xml:space="preserve">
          <source>If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; that's no biggie, you won't be able to build your program.</source>
          <target state="translated">Si un compilador de C no puede encontrar una funci&amp;oacute;n porque olvid&amp;oacute; incluir el encabezado, obtendr&amp;aacute; un error de compilador / enlazador al respecto. Entonces, si olvid&amp;oacute; incluir &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; que no es gran cosa, no podr&amp;aacute; compilar su programa.</target>
        </trans-unit>
        <trans-unit id="94a20e630767a5b13c70ee7de6feee73b37a4ac4" translate="yes" xml:space="preserve">
          <source>If pointers and integers are differently sized, then you're hiding a warning by casting and might lose bits of your returned address.</source>
          <target state="translated">Si los punteros y los enteros tienen un tamaño diferente,entonces estás ocultando una advertencia al lanzar y podrías perder trozos de tu dirección de retorno.</target>
        </trans-unit>
        <trans-unit id="65a75eb3940c4c479252444c653d371d024274a3" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may
  also, need to change all lines where malloc is called and cast.</source>
          <target state="translated">Si se cambia el tipo de puntero en su declaración,uno puede también,necesitar cambiar todas las líneas donde se llama y se lanza el malloc.</target>
        </trans-unit>
        <trans-unit id="df36036f7f3128303dea4303afa83edbcf774e7f" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may also need to change all lines where &lt;code&gt;malloc&lt;/code&gt; is called and cast.</source>
          <target state="translated">Si el tipo de puntero se cambia en su declaraci&amp;oacute;n, tambi&amp;eacute;n es posible que deba cambiar todas las l&amp;iacute;neas donde se llama y se &lt;code&gt;malloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bcac15068f3bb62943c1a0a7f50cfe6b4f3ff96" translate="yes" xml:space="preserve">
          <source>If you adhere to these macros, then a simple &lt;code&gt;grep&lt;/code&gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.</source>
          <target state="translated">Si se adhiere a estas macros, una simple b&amp;uacute;squeda &lt;code&gt;grep&lt;/code&gt; de su base de c&amp;oacute;digo para estos identificadores le mostrar&amp;aacute; d&amp;oacute;nde est&amp;aacute;n todos sus moldes, para que pueda revisar si alguno de ellos es incorrecto.</target>
        </trans-unit>
        <trans-unit id="38906a251997aa3b8616c404232d137ef1fa9d7d" translate="yes" xml:space="preserve">
          <source>If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.</source>
          <target state="translated">Si necesitas soportar tanto C como C++con el mismo código fuente,usa los interruptores del compilador para marcar las diferencias.No intente saturar ambos estándares de lenguaje con el mismo código,porque no son compatibles.</target>
        </trans-unit>
        <trans-unit id="7d3ac445fa31b61523e6e62450fd24ba439b4dfa" translate="yes" xml:space="preserve">
          <source>If your C code compiles as C++, you can use this &lt;code&gt;-Wold-style-cast&lt;/code&gt; option to find out all occurrences of the &lt;code&gt;(type)&lt;/code&gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).</source>
          <target state="translated">Si su c&amp;oacute;digo C se compila como C ++, puede usar esta &lt;code&gt;-Wold-style-cast&lt;/code&gt; para descubrir todas las apariciones de la sintaxis de conversi&amp;oacute;n &lt;code&gt;(type)&lt;/code&gt; que pueden colarse en el c&amp;oacute;digo y hacer un seguimiento de estos diagn&amp;oacute;sticos reemplaz&amp;aacute;ndolo por uno apropiado elecci&amp;oacute;n entre las macros anteriores (o una combinaci&amp;oacute;n, si es necesario).</target>
        </trans-unit>
        <trans-unit id="a1ec8dc8e827dcddaf1ac66310df0ab7f63c0d88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;this question&lt;/a&gt;, someone suggested in a &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;comment&lt;/a&gt; that I should &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; cast the result of &lt;code&gt;malloc&lt;/code&gt;, i.e.</source>
          <target state="translated">En &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;esta pregunta&lt;/a&gt; , alguien sugiri&amp;oacute; en un &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;comentario&lt;/a&gt; que no deber&amp;iacute;a emitir el resultado de &lt;code&gt;malloc&lt;/code&gt; , es decir</target>
        </trans-unit>
        <trans-unit id="b3a9cebe6da5e7431620120cb56c6c593d67810c" translate="yes" xml:space="preserve">
          <source>In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.</source>
          <target state="translated">En C es innecesario,ya que el vacío*es promovido automáticamente y de forma segura a cualquier otro tipo de puntero.</target>
        </trans-unit>
        <trans-unit id="c3a26193ac8cf855c86ef90718a310c04be870e5" translate="yes" xml:space="preserve">
          <source>In C you can implicitly convert a void pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.</source>
          <target state="translated">En C puedes convertir implícitamente un puntero de vacío en cualquier otro tipo de puntero,por lo que no es necesario un molde.El uso de uno puede sugerir al observador casual que hay alguna razón por la que se necesita uno,lo que puede ser engañoso.</target>
        </trans-unit>
        <trans-unit id="0e2c913a047567f896a4a85cdc21e25cc2d0c7db" translate="yes" xml:space="preserve">
          <source>In C you get an implicit conversion from &lt;code&gt;void*&lt;/code&gt; to any other (data) pointer.</source>
          <target state="translated">En C obtienes una conversi&amp;oacute;n impl&amp;iacute;cita de &lt;code&gt;void*&lt;/code&gt; a cualquier otro puntero (de datos).</target>
        </trans-unit>
        <trans-unit id="124df7e4df177a7e9968fd6be1560944643fd8df" translate="yes" xml:space="preserve">
          <source>In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from &lt;code&gt;void *&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implicit. C++ has a whole set of different flavors of casting.</source>
          <target state="translated">En C ++, la situaci&amp;oacute;n es diferente. La conversi&amp;oacute;n de tipos de puntero es algo com&amp;uacute;n (y correcta) cuando se trata de objetos de clases derivadas. Por lo tanto, tiene sentido que en C ++, la conversi&amp;oacute;n hacia y desde &lt;code&gt;void *&lt;/code&gt; &lt;strong&gt;no sea&lt;/strong&gt; impl&amp;iacute;cita. C ++ tiene un conjunto completo de diferentes sabores de fundici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="10a5ed8bd778002e10989f9f97e0681982b277e7" translate="yes" xml:space="preserve">
          <source>In C, a &lt;strong&gt;pointer cast is almost always an error&lt;/strong&gt;. This is because of the following rule (&lt;strong&gt;&amp;sect;6.5 p7&lt;/strong&gt; in N1570, the latest draft for C11):</source>
          <target state="translated">En C, un &lt;strong&gt;lanzamiento de puntero casi siempre es un error&lt;/strong&gt; . Esto se debe a la siguiente regla ( &lt;strong&gt;&amp;sect;6.5 p7&lt;/strong&gt; en N1570, el &amp;uacute;ltimo borrador para C11):</target>
        </trans-unit>
        <trans-unit id="93b491dccf959abfcaab359525161959ceec4cb9" translate="yes" xml:space="preserve">
          <source>In C, you don't need to cast the return value of &lt;code&gt;malloc&lt;/code&gt;. The pointer to void returned by &lt;code&gt;malloc&lt;/code&gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:</source>
          <target state="translated">En C, no necesita emitir el valor de retorno de &lt;code&gt;malloc&lt;/code&gt; . El puntero al vac&amp;iacute;o devuelto por &lt;code&gt;malloc&lt;/code&gt; se convierte autom&amp;aacute;ticamente al tipo correcto. Sin embargo, si desea que su c&amp;oacute;digo se compile con un compilador de C ++, se necesita un reparto. Una alternativa preferida entre la comunidad es usar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="8d2b0038978d4b2837d991cc706ee1d4bd7ec268" translate="yes" xml:space="preserve">
          <source>In a nutshell: Because in C, &lt;strong&gt;any&lt;/strong&gt; occurrence of a &lt;em&gt;pointer cast&lt;/em&gt; should raise a red flag for code requiring special attention, you should never write &lt;em&gt;unnecessary&lt;/em&gt; pointer casts.</source>
          <target state="translated">En pocas palabras: debido a que en C, &lt;strong&gt;cualquier&lt;/strong&gt; aparici&amp;oacute;n de una &lt;em&gt;conversi&amp;oacute;n&lt;/em&gt; de &lt;em&gt;puntero&lt;/em&gt; deber&amp;iacute;a levantar una bandera roja para el c&amp;oacute;digo que requiere atenci&amp;oacute;n especial, nunca debe escribir &lt;em&gt;transmisiones de&lt;/em&gt; puntero &lt;em&gt;innecesarias&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f72796a47c4da0050142849a0a239342b6c889b7" translate="yes" xml:space="preserve">
          <source>In fact, a good practice is to wrap &lt;code&gt;malloc&lt;/code&gt; (and friends) with functions that return &lt;code&gt;unsigned char *&lt;/code&gt;, and basically never to use &lt;code&gt;void *&lt;/code&gt; in your code.  If you need a generic pointer-to-any-object, use a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;unsigned char *&lt;/code&gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like &lt;code&gt;memset&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; without casts.</source>
          <target state="translated">De hecho, una buena pr&amp;aacute;ctica es envolver &lt;code&gt;malloc&lt;/code&gt; (y amigos) con funciones que devuelven &lt;code&gt;unsigned char *&lt;/code&gt; , y b&amp;aacute;sicamente nunca usar &lt;code&gt;void *&lt;/code&gt; en su c&amp;oacute;digo. Si necesita un puntero gen&amp;eacute;rico a cualquier objeto, use un &lt;code&gt;char *&lt;/code&gt; o un &lt;code&gt;unsigned char *&lt;/code&gt; , y realice conversiones en ambas direcciones. La &amp;uacute;nica relajaci&amp;oacute;n que puede permitirse, tal vez, es usar funciones como &lt;code&gt;memset&lt;/code&gt; y &lt;code&gt;memcpy&lt;/code&gt; sin conversiones .</target>
        </trans-unit>
        <trans-unit id="b825dc3705674b4d779a4cf9b27487a2abaa1c23" translate="yes" xml:space="preserve">
          <source>In general, you &lt;strong&gt;don't cast to or from &lt;code&gt;void *&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">En general, &lt;strong&gt;no emites hacia o desde &lt;code&gt;void *&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbe94d1061df0a0af541802fb33ece0468f3940" translate="yes" xml:space="preserve">
          <source>In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want &quot;type safe&quot; allocation, I can recommend the following macro functions, which I always use in my C projects:</source>
          <target state="translated">En el lenguaje C,se puede asignar un puntero de vacío a cualquier puntero,por lo que no se debe usar un molde de tipo.Si quieres una asignación &quot;segura de tipos&quot;,puedo recomendarte las siguientes funciones de macro,que siempre utilizo en mis proyectos C:</target>
        </trans-unit>
        <trans-unit id="58f485ca9c16f19d61d27f9da6f8f8aadd049c0b" translate="yes" xml:space="preserve">
          <source>In the ancient days, that is, before &lt;strong&gt;ANSI C&lt;/strong&gt; provides the &lt;code&gt;void *&lt;/code&gt; as the generic type of pointers, &lt;code&gt;char *&lt;/code&gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.</source>
          <target state="translated">En la antig&amp;uuml;edad, es decir, antes de que &lt;strong&gt;ANSI C&lt;/strong&gt; proporcione el &lt;code&gt;void *&lt;/code&gt; como el tipo gen&amp;eacute;rico de punteros, &lt;code&gt;char *&lt;/code&gt; es el tipo para dicho uso. En ese caso, el elenco puede cerrar las advertencias del compilador.</target>
        </trans-unit>
        <trans-unit id="7e73547744432a5c3e5cd36995aa06c8a9413ed0" translate="yes" xml:space="preserve">
          <source>Including the cast may allow a C program or function to compile as C++.</source>
          <target state="translated">Incluyendo el elenco puede permitir que un programa o función C se compile como C++.</target>
        </trans-unit>
        <trans-unit id="b8f9ba5f633406eee7f889296c7a7219db4f7a2e" translate="yes" xml:space="preserve">
          <source>It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).</source>
          <target state="translated">Añade desorden al código,los moldes no son muy fáciles de leer (especialmente si el tipo de puntero es largo).</target>
        </trans-unit>
        <trans-unit id="870023467a1d4925f143d3d61e6c60413492cb7a" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes (or, worse, &lt;em&gt;not&lt;/em&gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you're hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there's no automatic assumption that undeclared functions return &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Puede ocultar un error si olvid&amp;oacute; incluir &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; . Esto puede causar bloqueos (o, lo que es peor, &lt;em&gt;no&lt;/em&gt; causar un bloqueo hasta m&amp;aacute;s tarde en una parte totalmente diferente del c&amp;oacute;digo). Considere lo que sucede si los punteros y los enteros tienen tama&amp;ntilde;os diferentes; entonces est&amp;aacute; ocultando una advertencia al emitir y puede perder partes de su direcci&amp;oacute;n devuelta. Nota: a partir de C99, las funciones impl&amp;iacute;citas han desaparecido de C, y este punto ya no es relevante, ya que no existe un supuesto autom&amp;aacute;tico de que las funciones no declaradas devuelven &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a275723f60a0b42b3396018cbbac4f68a95ffd86" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes.</source>
          <target state="translated">Puede ocultar un error si olvid&amp;oacute; incluir &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; . Esto puede causar accidentes.</target>
        </trans-unit>
        <trans-unit id="ba6c240782a51eb4cc2e1cddaefc3c7e3ed8dde5" translate="yes" xml:space="preserve">
          <source>It depends on the programming language and compiler. If you use &lt;code&gt;malloc&lt;/code&gt; in C there is no need to type cast it, as it will automatically type cast, However if your using C++ then you should type cast because &lt;code&gt;malloc&lt;/code&gt; will return a &lt;code&gt;void*&lt;/code&gt; type.</source>
          <target state="translated">Depende del lenguaje de programaci&amp;oacute;n y del compilador. Si usa &lt;code&gt;malloc&lt;/code&gt; en C no hay necesidad de escribir cast, ya que escribir&amp;aacute; autom&amp;aacute;ticamente cast, sin embargo, si usa C ++, debe escribir cast porque &lt;code&gt;malloc&lt;/code&gt; devolver&amp;aacute; un tipo &lt;code&gt;void*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6794ae23413780fefc55f46bbeacf139ac860cbb" translate="yes" xml:space="preserve">
          <source>It forces an &lt;strong&gt;extra cognitive cross-check&lt;/strong&gt;. It puts the (alleged) desired type right next to the arithmetic you're doing for the raw size of that variable. I bet you could do an SO study that shows that &lt;code&gt;malloc()&lt;/code&gt; bugs are caught much faster when there's a cast. As with assertions, annotations that reveal intent decrease bugs.</source>
          <target state="translated">Obliga a una &lt;strong&gt;verificaci&amp;oacute;n cruzada cognitiva adicional&lt;/strong&gt; . Pone el (deseado) tipo deseado justo al lado de la aritm&amp;eacute;tica que est&amp;aacute; haciendo para el tama&amp;ntilde;o bruto de esa variable. Apuesto a que podr&amp;iacute;as hacer un estudio SO que muestre que los errores &lt;code&gt;malloc()&lt;/code&gt; se detectan mucho m&amp;aacute;s r&amp;aacute;pido cuando hay un yeso. Al igual que con las afirmaciones, las anotaciones que revelan la intenci&amp;oacute;n disminuyen los errores.</target>
        </trans-unit>
        <trans-unit id="89402a760239fb0d292e8e281d0c2cb9fb56bd70" translate="yes" xml:space="preserve">
          <source>It is not mandatory to cast the results of &lt;code&gt;malloc&lt;/code&gt;, since it returns &lt;code&gt;void*&lt;/code&gt; , and a &lt;code&gt;void*&lt;/code&gt; can be pointed to any datatype.</source>
          <target state="translated">No es obligatorio emitir los resultados de &lt;code&gt;malloc&lt;/code&gt; , ya que devuelve &lt;code&gt;void*&lt;/code&gt; , y un &lt;code&gt;void*&lt;/code&gt; puede apuntar a cualquier tipo de datos.</target>
        </trans-unit>
        <trans-unit id="6e5afe0ad6c9ac54a0f00b1936fe1beb836fed49" translate="yes" xml:space="preserve">
          <source>It is unnecessary, as &lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in this case.</source>
          <target state="translated">No es necesario, ya que &lt;code&gt;void *&lt;/code&gt; se promociona de forma autom&amp;aacute;tica y segura a cualquier otro tipo de puntero en este caso.</target>
        </trans-unit>
        <trans-unit id="58da5d50b5f49af45e54e7443828c3d89f115f36" translate="yes" xml:space="preserve">
          <source>It makes you repeat yourself, which is generally bad.</source>
          <target state="translated">Te hace repetirte,lo cual es generalmente malo.</target>
        </trans-unit>
        <trans-unit id="0bed687df391f9e44c4a7612a09f35920968a326" translate="yes" xml:space="preserve">
          <source>It makes your code &lt;strong&gt;more portable&lt;/strong&gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).</source>
          <target state="translated">Hace que su c&amp;oacute;digo sea &lt;strong&gt;m&amp;aacute;s port&amp;aacute;til&lt;/strong&gt; entre C y C ++, y como muestra la experiencia de SO, muchos programadores afirman que est&amp;aacute;n escribiendo en C cuando realmente est&amp;aacute;n escribiendo en C ++ (o C m&amp;aacute;s extensiones de compilador local).</target>
        </trans-unit>
        <trans-unit id="9815dbbf9f559686ae80a3f22cf2a01f2a14f9f3" translate="yes" xml:space="preserve">
          <source>Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.</source>
          <target state="translated">Sólo añadiendo mi experiencia,estudiando ingeniería informática veo que los dos o tres profesores que he visto escribiendo en C siempre hacen malloc,sin embargo el que pregunté (con un inmenso currículum y comprensión de la C)me dijo que es absolutamente innecesario,pero que sólo solía ser absolutamente específico,y para que los estudiantes entraran en la mentalidad de ser absolutamente específicos.Esencialmente el casting no cambiará nada en cómo funciona,hace exactamente lo que dice,asigna memoria,y el casting no lo afecta,obtienes la misma memoria,e incluso si lo lanzas a otra cosa por error (y de alguna manera evitas los errores de compilación)C accederá a él de la misma manera.</target>
        </trans-unit>
        <trans-unit id="0bff15a7d248d16466f2ec04acb6217150b312d2" translate="yes" xml:space="preserve">
          <source>Make sure there are no variables declared as &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">Aseg&amp;uacute;rese de que no haya variables declaradas como &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;ticas</target>
        </trans-unit>
        <trans-unit id="28b75c4f7d75c381d47362b41c7d2dc7264fc67f" translate="yes" xml:space="preserve">
          <source>Make your program compile through a C compiler with all warnings turned on &lt;code&gt;-Wall&lt;/code&gt; and fix all errors and warnings</source>
          <target state="translated">Haga que su programa se compile a trav&amp;eacute;s de un compilador de C con todas las advertencias activadas &lt;code&gt;-Wall&lt;/code&gt; y corrija todos los errores y advertencias</target>
        </trans-unit>
        <trans-unit id="7f8e8015eabf551886df6e32673d5bd7e6acb193" translate="yes" xml:space="preserve">
          <source>No, you don't cast the result of &lt;code&gt;malloc()&lt;/code&gt;.</source>
          <target state="translated">No, no emites el resultado de &lt;code&gt;malloc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcc3f1618153ed78f1a42b8c3a2643297139152b" translate="yes" xml:space="preserve">
          <source>Notice that the second cons should in the ideal case disappear when using the subset common to C together with the &lt;em&gt;static&lt;/em&gt; polymorphic feature.</source>
          <target state="translated">Tenga en cuenta que los segundos inconvenientes deber&amp;iacute;an desaparecer en el caso ideal cuando se utiliza el subconjunto com&amp;uacute;n a C junto con la caracter&amp;iacute;stica polim&amp;oacute;rfica &lt;em&gt;est&amp;aacute;tica&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7cee94d571455fbb9d3fed6656eb5b047a324b4c" translate="yes" xml:space="preserve">
          <source>Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.</source>
          <target state="translated">Ahora compila usando el compilador C de nuevo.Su programa debería ahora compilar sin ninguna advertencia y contener menos errores.</target>
        </trans-unit>
        <trans-unit id="66b2bc6a1bd3edda594e285fc1aff85a54ceee08" translate="yes" xml:space="preserve">
          <source>On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to &lt;code&gt;int&lt;/code&gt;. Casting the result from malloc explicitly would then hide away this bug.</source>
          <target state="translated">En compiladores antiguos que siguen una versi&amp;oacute;n del est&amp;aacute;ndar que tiene m&amp;aacute;s de 25 a&amp;ntilde;os, olvidarse de incluir &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; dar&amp;iacute;a como resultado un comportamiento peligroso. Porque en ese antiguo est&amp;aacute;ndar, las funciones sin un prototipo visible convirtieron impl&amp;iacute;citamente el tipo de retorno a &lt;code&gt;int&lt;/code&gt; . Lanzar el resultado de malloc expl&amp;iacute;citamente esconder&amp;iacute;a este error.</target>
        </trans-unit>
        <trans-unit id="bfeed771bd20c1b4da4b2efa7a63dcac68154c3a" translate="yes" xml:space="preserve">
          <source>On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.</source>
          <target state="translated">Por otro lado,el casting puede aumentar la portabilidad de su programa,es decir,permite a un programa o función de C compilar como C++.</target>
        </trans-unit>
        <trans-unit id="ba2e33a9bf914822832f2f444dd3ff0f0627ac9c" translate="yes" xml:space="preserve">
          <source>On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you &lt;em&gt;have to&lt;/em&gt; cast the return value of &lt;code&gt;malloc&lt;/code&gt; when assigning it to something other than &lt;code&gt;void *&lt;/code&gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:</source>
          <target state="translated">Sobre el tema de la conversi&amp;oacute;n de compatibilidad y C ++, si escribe su c&amp;oacute;digo para que se compile como C y C ++ (en cuyo caso &lt;em&gt;debe&lt;/em&gt; emitir el valor de retorno de &lt;code&gt;malloc&lt;/code&gt; al asignarlo a algo que no sea &lt;code&gt;void *&lt;/code&gt; ), puede hacerlo una cosa muy &amp;uacute;til para usted: puede usar macros para la conversi&amp;oacute;n que se traducen en conversiones de estilo C ++ cuando se compila como C ++, pero se reducen a una conversi&amp;oacute;n C cuando se compila como C:</target>
        </trans-unit>
        <trans-unit id="979716fcac00ca0824baf8e472028097ea147365" translate="yes" xml:space="preserve">
          <source>People used to GCC and Clang are spoiled.  It's not all that good out there.</source>
          <target state="translated">La gente acostumbrada al GCC y al Clang está mimada.No es tan bueno ahí fuera.</target>
        </trans-unit>
        <trans-unit id="3d20bd7e564692465d39c6283102bcfeaf2f188b" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C FAQ&lt;/a&gt;</source>
          <target state="translated">Referencia: &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C Preguntas frecuentes&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="913b8c72c65c6f2c696ebd2645ce6fe63ffd34ca" translate="yes" xml:space="preserve">
          <source>Repeating yourself in a way that the machine can check is often a &lt;strong&gt;great&lt;/strong&gt; idea. In fact, that's what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.</source>
          <target state="translated">Repetirse de una manera que la m&amp;aacute;quina pueda verificar es a menudo una &lt;strong&gt;gran&lt;/strong&gt; idea. De hecho, eso es una afirmaci&amp;oacute;n, y este uso de cast es una afirmaci&amp;oacute;n. Las afirmaciones siguen siendo la t&amp;eacute;cnica m&amp;aacute;s general que tenemos para obtener el c&amp;oacute;digo correcto, ya que a Turing se le ocurri&amp;oacute; la idea hace muchos a&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="eeb9da9341aff1229aac0eeb3d8f1a6873b9e49d" translate="yes" xml:space="preserve">
          <source>Side notes:</source>
          <target state="translated">Notas al margen:</target>
        </trans-unit>
        <trans-unit id="e07ca56cc28cf07f0e7efd4adeef84b39f654a4d" translate="yes" xml:space="preserve">
          <source>Since keeping the &lt;code&gt;sizeof&lt;/code&gt; first, in this case, ensures multiplication is done with at least &lt;code&gt;size_t&lt;/code&gt; math.</source>
          <target state="translated">Dado que mantener el &lt;code&gt;sizeof&lt;/code&gt; primero, en este caso, asegura que la multiplicaci&amp;oacute;n se realice con al menos &lt;code&gt;size_t&lt;/code&gt; math.</target>
        </trans-unit>
        <trans-unit id="ac0ad68dd4aefb4ac26bf0c5e2facd9461dc449e" translate="yes" xml:space="preserve">
          <source>Some comments:</source>
          <target state="translated">Algunos comentarios:</target>
        </trans-unit>
        <trans-unit id="c9afff0f26991110c2bc5c4c2920c45f8f9e49f9" translate="yes" xml:space="preserve">
          <source>Sometimes, you &lt;strong&gt;do&lt;/strong&gt; need to cast pointers, but given the &lt;em&gt;strict aliasing rule&lt;/em&gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you &lt;strong&gt;have to double-check for its validity&lt;/strong&gt;. Therefore, you never write an unnecessary pointer cast.</source>
          <target state="translated">A veces, necesita lanzar punteros, pero dada la &lt;em&gt;estricta regla de alias&lt;/em&gt; , debe tener mucho cuidado con eso. Por lo tanto, cualquier aparici&amp;oacute;n de un puntero emitido en su c&amp;oacute;digo es un lugar donde &lt;strong&gt;debe verificar su validez&lt;/strong&gt; . Por lo tanto, nunca escribe un molde de puntero innecesario.</target>
        </trans-unit>
        <trans-unit id="348a3fbc26f2688c8530060e66a13437b015bb1b" translate="yes" xml:space="preserve">
          <source>That way you can still write it in a very compact way:</source>
          <target state="translated">De esa manera todavía puedes escribirlo de una manera muy compacta:</target>
        </trans-unit>
        <trans-unit id="7c11a87c54fbc0d09c65c5842cdeb16fbf6ce8d2" translate="yes" xml:space="preserve">
          <source>The argument that it's not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call &quot;local management's reality field&quot;.  And that's bent and twisted more than space time ever was. :-)</source>
          <target state="translated">El argumento de que no es necesario según las normas actuales es bastante válido.Pero ese argumento omite los aspectos prácticos del mundo real.No codificamos en un mundo regido exclusivamente por el estándar del día,sino por los aspectos prácticos de lo que me gusta llamar &quot;el campo de la realidad de la gestión local&quot;.Y eso está más doblado y retorcido que el espacio tiempo.:-)</target>
        </trans-unit>
        <trans-unit id="cf7a2c5002660ed9183a2da4a4f0f11caa52353d" translate="yes" xml:space="preserve">
          <source>The best thing to do when programming in C whenever it is possible:</source>
          <target state="translated">Lo mejor es programar en C siempre que sea posible:</target>
        </trans-unit>
        <trans-unit id="8e6a11c3b2030400be409620a47673e0ff112fad" translate="yes" xml:space="preserve">
          <source>The cast allows for pre-1989 versions of malloc that originally returned a char *.</source>
          <target state="translated">El reparto permite versiones anteriores a 1989 de malloc que originalmente devolvían un char *.</target>
        </trans-unit>
        <trans-unit id="998ffdec25506c948a2e362fe99f1587650eba18" translate="yes" xml:space="preserve">
          <source>The cast is necessary here, because &lt;code&gt;printf()&lt;/code&gt; is a variadic function, so implicit conversions don't work.</source>
          <target state="translated">La conversi&amp;oacute;n es necesaria aqu&amp;iacute;, porque &lt;code&gt;printf()&lt;/code&gt; es una funci&amp;oacute;n variada, por lo que las conversiones impl&amp;iacute;citas no funcionan.</target>
        </trans-unit>
        <trans-unit id="a53090f29cc6f3d564bf1c8d0a4c07064105db01" translate="yes" xml:space="preserve">
          <source>The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging</source>
          <target state="translated">El concepto detrás del puntero de vacío es que puede ser lanzado a cualquier tipo de datos,por eso el malloc devuelve el vacío.También debes ser consciente de la tipificación automática.Así que no es obligatorio lanzar el puntero aunque debes hacerlo.Ayuda a mantener el código limpio y ayuda a la depuración</target>
        </trans-unit>
        <trans-unit id="26a10d066398b061801f974a2a5ece03f6f54619" translate="yes" xml:space="preserve">
          <source>The idea that it keeps you from noticing you failed to &lt;code&gt;#include&lt;/code&gt; an appropriate header file misses &lt;strong&gt;the forest for the trees&lt;/strong&gt;. It's the same as saying &quot;don't worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!&quot;</source>
          <target state="translated">La idea de que evita que se d&amp;eacute; cuenta de que no pudo &lt;code&gt;#include&lt;/code&gt; un archivo de encabezado apropiado pierde &lt;strong&gt;el bosque para los &amp;aacute;rboles&lt;/strong&gt; . Es lo mismo que decir &quot;no te preocupes por el hecho de que no pudiste pedirle al compilador que se quejara de no ver prototipos, &amp;iexcl;ese molesto stdlib.h es lo REAL realmente importante para recordar!</target>
        </trans-unit>
        <trans-unit id="7affa9334d50427587a11f830fa868eb1953cbca" translate="yes" xml:space="preserve">
          <source>The most common reason why people cast the result of malloc is because they are unsure about how the C language works. That's a warning sign: if you don't know how a particular language mechanism works, then &lt;em&gt;don't&lt;/em&gt; take a guess. Look it up or ask on Stack Overflow.</source>
          <target state="translated">La raz&amp;oacute;n m&amp;aacute;s com&amp;uacute;n por la cual las personas emiten el resultado de malloc es porque no est&amp;aacute;n seguros de c&amp;oacute;mo funciona el lenguaje C. Esa es una se&amp;ntilde;al de advertencia: si no sabes c&amp;oacute;mo funciona un mecanismo de lenguaje en particular, entonces &lt;em&gt;no&lt;/em&gt; adivines. B&amp;uacute;scalo o pregunta en Stack Overflow.</target>
        </trans-unit>
        <trans-unit id="56afad940865bfcbe28c291e24c2bdf0ea7f35b5" translate="yes" xml:space="preserve">
          <source>The only benefits from writing in C instead of C++ I can find are</source>
          <target state="translated">Los únicos beneficios de escribir en C en lugar de C++que puedo encontrar son</target>
        </trans-unit>
        <trans-unit id="006baad78c74403e4762e856f8320bbf41a3f370" translate="yes" xml:space="preserve">
          <source>The pointer returned if the allocation succeeds is suitably aligned so
  that it may be assigned to a pointer to any type of object with a
  fundamental alignment requirement and then used to access such an
  object or an array of such objects in the space allocated (until the
  space is explicitly deallocated)</source>
          <target state="translated">El puntero devuelto si la asignación tiene éxito se alinea adecuadamente para que pueda asignarse a un puntero a cualquier tipo de objeto con un requisito de alineación fundamental y luego se utiliza para acceder a tal objeto o a un conjunto de tales objetos en el espacio asignado (hasta que el espacio sea explícitamente asignado)</target>
        </trans-unit>
        <trans-unit id="b3c30a12e0dff950c02a5280e6432480b9bd8396" translate="yes" xml:space="preserve">
          <source>The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.</source>
          <target state="translated">El tipo devuelto es nulo*,que puede ser lanzado al tipo de puntero de datos que se desee para que sea desreferenciable.</target>
        </trans-unit>
        <trans-unit id="711c8a89d3f2be83e87fab517121c689d0361a34" translate="yes" xml:space="preserve">
          <source>Then compile it using a C++ compiler with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-std=c++11&lt;/code&gt;. Fix all errors and warnings.</source>
          <target state="translated">Luego &lt;code&gt;-Wall&lt;/code&gt; usando un compilador de C ++ con -Wall y &lt;code&gt;-std=c++11&lt;/code&gt; . Repara todos los errores y advertencias.</target>
        </trans-unit>
        <trans-unit id="b833fdcd9601eb781a63d97976bc2af1531deb0f" translate="yes" xml:space="preserve">
          <source>Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use &lt;code&gt;strip_qual&lt;/code&gt; just to remove a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.</source>
          <target state="translated">Luego, en el futuro, si compila regularmente el c&amp;oacute;digo con C ++, impondr&amp;aacute; el uso de un reparto apropiado. Por ejemplo, si usa &lt;code&gt;strip_qual&lt;/code&gt; solo para eliminar una &lt;code&gt;const&lt;/code&gt; ante o &lt;code&gt;volatile&lt;/code&gt; , pero el programa cambia de tal manera que ahora se trata de una conversi&amp;oacute;n de tipo, obtendr&amp;aacute; un diagn&amp;oacute;stico y tendr&amp;aacute; que usar una combinaci&amp;oacute;n de conversiones para obtener el conversi&amp;oacute;n deseada</target>
        </trans-unit>
        <trans-unit id="d4e668d4c1ef3d785a282afa7e0b53c99ffaf425" translate="yes" xml:space="preserve">
          <source>There are cases where you actually &lt;em&gt;need&lt;/em&gt; a cast to &lt;code&gt;void *&lt;/code&gt;, e.g. if you want to print a pointer:</source>
          <target state="translated">Hay casos en los que realmente &lt;em&gt;necesita&lt;/em&gt; una conversi&amp;oacute;n para &lt;code&gt;void *&lt;/code&gt; , por ejemplo, si desea imprimir un puntero:</target>
        </trans-unit>
        <trans-unit id="6ee851d6bd4c154373eb426a6cf77ad29b6c76b9" translate="yes" xml:space="preserve">
          <source>There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.</source>
          <target state="translated">Puede haber otras razones,pero otras razones,casi con toda seguridad,te meterán en serios problemas tarde o temprano.</target>
        </trans-unit>
        <trans-unit id="186638c0a67a1197f7cd4cae91b6dbb0d0ea92b8" translate="yes" xml:space="preserve">
          <source>This also moves the &lt;code&gt;length&lt;/code&gt; to the front for increased visibility, and drops the redundant parentheses with &lt;code&gt;sizeof&lt;/code&gt;; they &lt;em&gt;are only needed&lt;/em&gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: &lt;code&gt;sizeof&lt;/code&gt; is not a function! :)</source>
          <target state="translated">Esto tambi&amp;eacute;n mueve la &lt;code&gt;length&lt;/code&gt; hacia el frente para aumentar la visibilidad y elimina los par&amp;eacute;ntesis redundantes con &lt;code&gt;sizeof&lt;/code&gt; ; &lt;em&gt;solo son necesarios&lt;/em&gt; cuando el argumento es un nombre de tipo. Muchas personas parecen no saber (o ignorar) esto, lo que hace que su c&amp;oacute;digo sea m&amp;aacute;s detallado. Recuerde: &amp;iexcl; &lt;code&gt;sizeof&lt;/code&gt; no es una funci&amp;oacute;n! :)</target>
        </trans-unit>
        <trans-unit id="78ccd0f84465d8f80acc739eeb1edc6c075d1c6d" translate="yes" xml:space="preserve">
          <source>This is also known as the &lt;em&gt;strict aliasing rule&lt;/em&gt;. So the following code is &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">Esto tambi&amp;eacute;n se conoce como la &lt;em&gt;estricta regla de alias&lt;/em&gt; . Entonces, el siguiente c&amp;oacute;digo es &lt;em&gt;un comportamiento indefinido&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="2e07b201f2cd09204952f0ea2a8352e94d8350f8" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;The GNU C Library Reference&lt;/a&gt; manual says:</source>
          <target state="translated">Esto es lo que dice el manual de &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;referencia de la biblioteca GNU C&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2612aa90747c8f2cdc6c4aacf3c9fc773e8c9fc1" translate="yes" xml:space="preserve">
          <source>This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include &lt;code&gt;stdlib.h&lt;/code&gt;or you will get</source>
          <target state="translated">Este procedimiento le permite aprovechar la estricta verificaci&amp;oacute;n de tipos de C ++, reduciendo as&amp;iacute; la cantidad de errores. En particular, este procedimiento lo obliga a incluir &lt;code&gt;stdlib.h&lt;/code&gt; o obtendr&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="f2cce072b4fc94a737199982264f4a8e1b007734" translate="yes" xml:space="preserve">
          <source>This treatment of conversions is the single largest standalone technical justification for working in a &quot;Clean C&quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">Este tratamiento de conversiones es la justificaci&amp;oacute;n t&amp;eacute;cnica independiente m&amp;aacute;s grande para trabajar en una &quot;C limpia&quot;: el dialecto combinado C y C ++, que a su vez t&amp;eacute;cnicamente justifica el valor de retorno de &lt;code&gt;malloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c17a9be57ef9ca7cd3adf5ee8b5ef9628a4d46a" translate="yes" xml:space="preserve">
          <source>To add further, your code needlessly repeats the type information (&lt;code&gt;int&lt;/code&gt;) which can cause errors. It's better to de-reference the pointer being used to store the return value, to &quot;lock&quot; the two together:</source>
          <target state="translated">Para agregar m&amp;aacute;s, su c&amp;oacute;digo repite innecesariamente la informaci&amp;oacute;n de tipo ( &lt;code&gt;int&lt;/code&gt; ) que puede causar errores. Es mejor desreferenciar el puntero que se utiliza para almacenar el valor de retorno, para &quot;bloquear&quot; los dos juntos:</target>
        </trans-unit>
        <trans-unit id="81eed5fc51c3e3b44fa0ef9d4d25cef34a474770" translate="yes" xml:space="preserve">
          <source>To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.</source>
          <target state="translated">Para ayudarte a adherirte a estas macros,el compilador GNU C++(¡no C!)tiene una hermosa característica:un diagnóstico opcional que se produce para todas las ocurrencias de los moldes de estilo C.</target>
        </trans-unit>
        <trans-unit id="ca84b5f4a5ac7139271f3940379fb2cf0336ee9f" translate="yes" xml:space="preserve">
          <source>Under the ANSI C standard, the cast is redundant.</source>
          <target state="translated">Bajo el estándar ANSI C,el reparto es redundante.</target>
        </trans-unit>
        <trans-unit id="e8ec134ac31640fb573e0e153c5725b4e050b271" translate="yes" xml:space="preserve">
          <source>While moving &lt;code&gt;length&lt;/code&gt; to the front &lt;em&gt;may&lt;/em&gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:</source>
          <target state="translated">Si bien mover la &lt;code&gt;length&lt;/code&gt; hacia el frente &lt;em&gt;puede&lt;/em&gt; aumentar la visibilidad en algunos casos raros, tambi&amp;eacute;n se debe prestar atenci&amp;oacute;n a que, en el caso general, deber&amp;iacute;a ser mejor escribir la expresi&amp;oacute;n como:</target>
        </trans-unit>
        <trans-unit id="9ee85b34131db60fdfd151a81fdc887dd4fcd22a" translate="yes" xml:space="preserve">
          <source>Why would this be the case?</source>
          <target state="translated">¿Por qué sería este el caso?</target>
        </trans-unit>
        <trans-unit id="01acdaf9e307b1e0a0b814ed27a2ec340c2e2c33" translate="yes" xml:space="preserve">
          <source>With these in place you can simply say</source>
          <target state="translated">Con estos en su lugar puedes simplemente decir</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="e0ed2586aa5abd52d3b653c0086a309021a02618" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;do&lt;/strong&gt; cast, because:</source>
          <target state="translated">Lo &lt;strong&gt;haces&lt;/strong&gt; porque:</target>
        </trans-unit>
        <trans-unit id="79486d2c3a27f80999f77ddcc416d8f23c32e95a" translate="yes" xml:space="preserve">
          <source>You can store the result of &lt;code&gt;malloc&lt;/code&gt; into any pointer variable without a
  cast, because ISO C automatically converts the type &lt;code&gt;void *&lt;/code&gt; to another
  type of pointer when necessary. But the cast is necessary in contexts
  other than assignment operators or if you might want your code to run
  in traditional C.</source>
          <target state="translated">Puede almacenar el resultado de &lt;code&gt;malloc&lt;/code&gt; en cualquier variable de puntero sin conversi&amp;oacute;n, porque ISO C convierte autom&amp;aacute;ticamente el tipo &lt;code&gt;void *&lt;/code&gt; a otro tipo de puntero cuando sea necesario. Pero la conversi&amp;oacute;n es necesaria en contextos distintos a los operadores de asignaci&amp;oacute;n o si desea que su c&amp;oacute;digo se ejecute en C. tradicional</target>
        </trans-unit>
        <trans-unit id="64d12490b03733be1bf0ccdb5177f441ae3b32a3" translate="yes" xml:space="preserve">
          <source>You don't cast the result of malloc, because doing so adds pointless clutter to your code.</source>
          <target state="translated">No se arroja el resultado de la mallocación,porque al hacerlo se agrega un desorden inútil a su código.</target>
        </trans-unit>
        <trans-unit id="719d41b4076bc570c545a47f1031a67ded961c28" translate="yes" xml:space="preserve">
          <source>and also forces you to cast the result of &lt;code&gt;malloc&lt;/code&gt; or you will get</source>
          <target state="translated">y tambi&amp;eacute;n te obliga a lanzar el resultado de &lt;code&gt;malloc&lt;/code&gt; o obtendr&amp;aacute;s</target>
        </trans-unit>
        <trans-unit id="542161e54ecd4adeeeb635a9cdad11414084409e" translate="yes" xml:space="preserve">
          <source>and it will compile for C and C++.</source>
          <target state="translated">y compilará para C y C++.</target>
        </trans-unit>
        <trans-unit id="64083eb0fbc1cccbe1930ff6c0eb620b8e9c0cc1" translate="yes" xml:space="preserve">
          <source>i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">es decir: si necesita compilar el programa C como C ++ (aunque es un lenguaje separado) debe emitir el resultado del uso de &lt;code&gt;malloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7feac0152fbb8ddbd92237edaa50e15426a689c0" translate="yes" xml:space="preserve">
          <source>invalid conversion from &lt;code&gt;void*&lt;/code&gt; to &lt;code&gt;T*&lt;/code&gt;</source>
          <target state="translated">conversi&amp;oacute;n inv&amp;aacute;lida de &lt;code&gt;void*&lt;/code&gt; a &lt;code&gt;T*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4336376d32d8dd4374715878d5ec2aff3007481" translate="yes" xml:space="preserve">
          <source>or what ever your target type is.</source>
          <target state="translated">o cualquiera que sea tu tipo de objetivo.</target>
        </trans-unit>
        <trans-unit id="82b524d90dbcf160ddb4a560d1503123520ae7c4" translate="yes" xml:space="preserve">
          <source>rather than:</source>
          <target state="translated">en lugar de:</target>
        </trans-unit>
        <trans-unit id="6ef706998cf17ef7293cdb6fad421229fb5f8d93" translate="yes" xml:space="preserve">
          <source>tl;dr</source>
          <target state="translated">tl;dr</target>
        </trans-unit>
        <trans-unit id="0b710aa273bfb4642bf11423f66ee900b109348f" translate="yes" xml:space="preserve">
          <source>which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of &lt;code&gt;sieve&lt;/code&gt;.</source>
          <target state="translated">lo que adem&amp;aacute;s le libera de tener que preocuparse por cambiar el lado derecho de la expresi&amp;oacute;n si alguna vez cambia el tipo de &lt;code&gt;sieve&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56cf084c8081e52c77e6553b2ba637aae876ab2f" translate="yes" xml:space="preserve">
          <source>which makes array loops safer and more convenient:</source>
          <target state="translated">lo que hace que los bucles de la matriz sean más seguros y convenientes:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
