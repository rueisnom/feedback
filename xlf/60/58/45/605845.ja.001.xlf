<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/605845">
    <body>
      <group id="605845">
        <trans-unit id="7cf3442516aaa5d6749824461a7def10a1b8f03a" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a character type.</source>
          <target state="translated">&amp;mdash;文字タイプ。</target>
        </trans-unit>
        <trans-unit id="16d9cec79491cede88fd0ddafcbdb33b1a1dc888" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a qualified version of a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効なタイプと互換性のあるタイプの修飾バージョン、</target>
        </trans-unit>
        <trans-unit id="e44f2c14403ad448407e98ab24bfdee66bfa24a3" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type compatible with the effective type of the object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効なタイプと互換性のあるタイプ</target>
        </trans-unit>
        <trans-unit id="13d94646e2432e838a724c25f7870cb8f332c869" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効な型の修飾バージョンに対応する署名付きまたは署名なしの型である型</target>
        </trans-unit>
        <trans-unit id="4b87e5428fe7d01a75c7838ed5347266005ed316" translate="yes" xml:space="preserve">
          <source>&amp;mdash; a type that is the signed or unsigned type corresponding to the effective type of the
  object,</source>
          <target state="translated">&amp;mdash;オブジェクトの有効なタイプに対応する符号付きまたは符号なしタイプのタイプ</target>
        </trans-unit>
        <trans-unit id="62996c58c76d88b909b477d85de32e4c8a0be22f" translate="yes" xml:space="preserve">
          <source>&amp;mdash; an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or</source>
          <target state="translated">&amp;mdash;メンバーの中に前述のタイプの1つを含む集約またはユニオンタイプ（再帰的に、サブアグリゲートまたは含まれるユニオンのメンバーを含む）、または</target>
        </trans-unit>
        <trans-unit id="ae7e0cdae2ac7249d987bff149081b201e3a0fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;malloc&lt;/code&gt; was not declared within this scope</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; はこのスコープ内で宣言されていません</target>
        </trans-unit>
        <trans-unit id="0e5f928812738db0ec93ccf2bf989d2ddde07c40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in the case of C.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; は、Cの場合、自動的かつ安全に他のポインタ型に昇格されます。</target>
        </trans-unit>
        <trans-unit id="a391dd112c4d19334c4d2262800b52d709ef87f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Advantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;キャストの利点&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70e320e2947eef2af5ecd6ba7d5df9624b0e3047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disadvantages to casting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;キャストの短所&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2846f9a1c6a1377c632edfa1214b7fc3a69f21f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Casting has a certain point. When you use array notation, the code generated has to know how many memory places it has to advance to reach the beginning of the next element, this is achieved through casting. This way you know that for a double you go 8 bytes ahead while for an int you go 4, and so on. Thus it has no effect if you use pointer notation, in array notation it becomes necessary.</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt;キャスティングには一定のポイントがあります。 配列表記を使用する場合、生成されたコードは、次の要素の先頭に到達するために進める必要のあるメモリ場所の数を知る必要があります。これは、キャストによって実現されます。 これにより、doubleの場合は8バイト先に進み、intの場合は4バイト先に進むことがわかります。 したがって、ポインタ表記を使用しても効果はなく、配列表記では必要になります。</target>
        </trans-unit>
        <trans-unit id="ecf1f68c1a0bb45cb2b18963cb8bbc692db8e531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No&lt;/strong&gt;; you &lt;em&gt;don't&lt;/em&gt; cast the result, since:</source>
          <target state="translated">&lt;strong&gt;いいえ&lt;/strong&gt; ; 次の理由により、結果をキャストし&lt;em&gt;ません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f479abc04339b7f7648e42d0dcae330fdbce9d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The casting of malloc is unnecessary in C but mandatory in C++.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cではmallocのキャストは不要ですが、C ++では必須です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="05ecd5960f9d99ecd5ac614c91583260f522bd42" translate="yes" xml:space="preserve">
          <source>A typical reason given for not doing so is that failure to &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; could go unnoticed. This isn't an issue anymore for a long time now as C99 made &lt;em&gt;implicit function declarations&lt;/em&gt; illegal, so if your compiler conforms to at least C99, you will get a diagnostic message.</source>
          <target state="translated">そうしないことの典型的な理由は、 &lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt; の失敗が気付かれない可能性があることです。 C99が&lt;em&gt;暗黙の関数宣言を&lt;/em&gt;不正にしたため、これは長い間問題ではなくなりました。コンパイラが少なくともC99に準拠している場合、診断メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="2a368dec1332cfeb0f803131ba36c04da26e07ad" translate="yes" xml:space="preserve">
          <source>A void pointer can be converted to/from any other pointer type without an explicit cast (C11 6.3.2.3 and 6.5.16.1).</source>
          <target state="translated">void ポインタは、明示的なキャストなしに他の任意のポインタ型に変換することができます(C11 6.3.2.3 と 6.5.16.1)。</target>
        </trans-unit>
        <trans-unit id="0471ce3799acd66098fce34b5150690360d1c931" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic object pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">voidポインタは汎用オブジェクトポインタであり、C言語では voidポインタ型から他の型への暗黙の変換をサポートしているため、明示的に型キャストする必要はありません。</target>
        </trans-unit>
        <trans-unit id="a26d186fb3412a6fc71664243f45c9e7df4a5f6e" translate="yes" xml:space="preserve">
          <source>A void pointer is a generic pointer and C supports implicit conversion from a void pointer type to other types, so there is no need of explicitly typecasting it.</source>
          <target state="translated">voidポインタは汎用ポインタであり、C言語では voidポインタ型から他の型への暗黙の変換をサポートしているため、明示的に型キャストする必要はありません。</target>
        </trans-unit>
        <trans-unit id="d2e4fe0f4f3fae71f095a8f015fe0d1094245585" translate="yes" xml:space="preserve">
          <source>Adding the cast may mask failure to include the header &lt;em&gt;stdlib.h&lt;/em&gt;, in
  which the prototype for malloc is found. In the absence of a
  prototype for malloc, the standard requires that the C compiler
  assume malloc returns an int. If there is no cast, a warning is
  issued when this integer is assigned to the pointer; however, with
  the cast, this warning is not produced, hiding a bug. On certain
  architectures and data models (such as LP64 on 64-bit systems, where
  long and pointers are 64-bit and int is 32-bit), this error can
  actually result in undefined behaviour, as the implicitly declared
  malloc returns a 32-bit value whereas the actually defined function
  returns a 64-bit value. Depending on calling conventions and memory
  layout, this may result in stack smashing. This issue is less likely
  to go unnoticed in modern compilers, as they uniformly produce
  warnings that an undeclared function has been used, so a warning will
  still appear. For example, GCC's default behaviour is to show a
  warning that reads &quot;incompatible implicit declaration of built-in
  function&quot; regardless of whether the cast is present or not.</source>
          <target state="translated">キャストを追加すると、mallocのプロトタイプが見つかったヘッダー&lt;em&gt;stdlib.h&lt;/em&gt;を含めるための失敗がマスクされる場合があります。 mallocのプロトタイプがない場合、標準では、Cコンパイラがmallocがintを返すことを前提としています。 キャストがない場合、この整数がポインターに割り当てられると警告が出されます。 ただし、キャストでは、この警告は生成されず、バグを隠します。 特定のアーキテクチャとデータモデル（64ビットシステムのLP64など、longとポインタが64ビットで、intが32ビット）では、暗黙的に宣言されたmallocが32を返すため、このエラーは実際には未定義の動作を引き起こす可能性があります。実際に定義された関数は64ビット値を返しますが、ビット値。 呼び出し規約とメモリレイアウトによっては、スタックスマッシングが発生する可能性があります。 この問題は、宣言されていない関数が使用されたことを示す警告を一律に生成するため、最新のコンパイラでは気付かれない可能性が低く、警告が引き続き表示されます。 たとえば、GCCのデフォルトの動作では、キャストが存在するかどうかに関係なく、「組み込み関数の互換性のない暗黙の宣言」という警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="330de36771a8855149af70009a392efe7137c117" translate="yes" xml:space="preserve">
          <source>Also note, as commentators point out, that the above talks about straight C, not C++. I very firmly believe in C and C++ as separate languages.</source>
          <target state="translated">また、コメンテーターが指摘しているように、上記はC++ではなく、ストレートなCについて語っていることにも注意してください。私はCとC++を別の言語として信じています。</target>
        </trans-unit>
        <trans-unit id="49b4f10f65b03b7676c9928862b57a7bb5936eaa" translate="yes" xml:space="preserve">
          <source>Although &lt;strong&gt;malloc without casting is preferred method and most experienced programmers choose it&lt;/strong&gt;, you should use whichever you like having aware of the issues.</source>
          <target state="translated">&lt;strong&gt;キャストなしのmallocが推奨される方法であり、ほとんどの経験豊富なプログラマーがこれを選択します&lt;/strong&gt;が、問題を認識している方は好きな方を使用してください。</target>
        </trans-unit>
        <trans-unit id="82b3b63ccc5e46c358ff4d906c737902b003bf00" translate="yes" xml:space="preserve">
          <source>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:</source>
          <target state="translated">オブジェクトは、次のいずれかの型を持つ lvalue 式によってのみ、その格納された値にアクセスすることができる。</target>
        </trans-unit>
        <trans-unit id="415ebcd3f0d0eb14cdd2373b4ef70b900e3218af" translate="yes" xml:space="preserve">
          <source>And indeed the &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11 standard&lt;/a&gt; (p347) says so:</source>
          <target state="translated">実際、 &lt;a href=&quot;http://www.compsci.hunter.cuny.edu/~sweiss/resources/c11standard.pdf&quot;&gt;ISO C11標準&lt;/a&gt; （p347）は次のように述べています。</target>
        </trans-unit>
        <trans-unit id="106cd39a268698352cf10943c417d2f7799f7985" translate="yes" xml:space="preserve">
          <source>And, sometimes surprisingly, the following is as well:</source>
          <target state="translated">そして、たまに驚くことに、以下のようなこともあります。</target>
        </trans-unit>
        <trans-unit id="98cee4f987282b9a2bc48df1269201546773ac75" translate="yes" xml:space="preserve">
          <source>As a clarification, note that I said &quot;you don't cast&quot;, not &quot;you don't &lt;em&gt;need&lt;/em&gt; to cast&quot;. In my opinion, it's a failure to include the cast, even if you got it right. There are simply no benefits to doing it, but a bunch of potential risks, and including the cast indicates that you don't know about the risks.</source>
          <target state="translated">明確にするために、「キャストする必要はない」ではなく、「キャストしない」と言ったことに注意してください。 私の意見では、それを正しく理解していても、キャストを含めるのは失敗です。 それを行うだけの利点はありませんが、潜在的なリスクがたくさんあり、キャストを含めると、リスクについて知らないことがわかります。</target>
        </trans-unit>
        <trans-unit id="52d6db561d5a32a930d6064e45cfff6f3d42fec9" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++.</source>
          <target state="translated">他にも述べたように、Cでは必要ないが、C++では必要とされている。</target>
        </trans-unit>
        <trans-unit id="d1b5b1727f0d804cd9571ddd5eeac48d6b713bf5" translate="yes" xml:space="preserve">
          <source>As other stated, it is not needed for C, but for C++. If you think you are going to compile your C code with a C++ compiler, for which reasons ever, you can use a macro instead, like:</source>
          <target state="translated">他の人が言っているように、これはC言語には必要ありませんが、C++には必要です。もしあなたがC言語のコードをC++コンパイラでコンパイルしようと思っているのであれば、その代わりにマクロを使うことができます。</target>
        </trans-unit>
        <trans-unit id="336cb3d7090a86262459260c2cb734602c2436e0" translate="yes" xml:space="preserve">
          <source>Because &lt;strong&gt;stdlib.h&lt;/strong&gt; contains the prototype for malloc is found. In the
absence of a prototype for malloc, the standard requires that the C
compiler assumes malloc returns an int. If there is no cast, a
warning is issued when this integer is assigned to the pointer;
however, with the cast, this warning is not produced, hiding a bug.</source>
          <target state="translated">&lt;strong&gt;stdlib.h&lt;/strong&gt;にはmallocのプロトタイプが含まれているため、これが見つかります。 mallocのプロトタイプがない場合、標準では、Cコンパイラがmallocがintを返すことを前提としています。 キャストがない場合、この整数がポインターに割り当てられると警告が出されます。 ただし、キャストでは、この警告は生成されず、バグを隠します。</target>
        </trans-unit>
        <trans-unit id="bdc72cf404853fbac86b2c23dcbbf0c9e530081f" translate="yes" xml:space="preserve">
          <source>But if you cast then, it can hide an error if you forgot to include
&lt;strong&gt;stdlib.h&lt;/strong&gt;. This can cause crashes (or, worse, not cause a crash
until way later in some totally different part of the code).</source>
          <target state="translated">しかし、キャストした場合、 &lt;strong&gt;stdlib.h&lt;/strong&gt;をインクルードするのを忘れた場合、エラーを隠すことができ&lt;strong&gt;ます&lt;/strong&gt; 。 これにより、クラッシュが発生する可能性があります（さらに悪いことに、コードのまったく異なる一部の部分まではクラッシュしません）。</target>
        </trans-unit>
        <trans-unit id="607d50bbf8a35ccb5efb5dcb48502884b9e0b8a2" translate="yes" xml:space="preserve">
          <source>But that is really a non-issue. You aren't using a 25 years old computer, so why would you use a 25 years old compiler?</source>
          <target state="translated">しかし、それは本当に問題ではありません。25年前のコンピュータを使っているわけではないのに、なぜ25年前のコンパイラを使うのでしょうか?</target>
        </trans-unit>
        <trans-unit id="944b838189a9bff8c526a212fceaae45ebfd75be" translate="yes" xml:space="preserve">
          <source>But there's a &lt;strong&gt;much stronger reason&lt;/strong&gt; not to introduce unnecessary pointer casts:</source>
          <target state="translated">しかし、不要なポインターキャストを導入しない&lt;strong&gt;ほう&lt;/strong&gt;が&lt;strong&gt;はるかに強力な理由が&lt;/strong&gt;あります。</target>
        </trans-unit>
        <trans-unit id="478bb2a442cb08ae6c0bbcddf6fd2f695a1f51d8" translate="yes" xml:space="preserve">
          <source>C has a well specified ABI</source>
          <target state="translated">Cはよく指定されたABIを持っています。</target>
        </trans-unit>
        <trans-unit id="944a73e911447184dc231ecc770caa2caeec4d8e" translate="yes" xml:space="preserve">
          <source>C++ may generate more code [exceptions, RTTI, templates, &lt;em&gt;runtime&lt;/em&gt; polymorphism]</source>
          <target state="translated">C ++はより多くのコードを生成する可能性があります[例外、RTTI、テンプレート、 &lt;em&gt;ランタイム&lt;/em&gt;ポリモーフィズム]</target>
        </trans-unit>
        <trans-unit id="ff9f56607dcdf5bb324bf522b13344b0a6d2e767" translate="yes" xml:space="preserve">
          <source>C++ will however not allow an implicit cast between &lt;code&gt;void*&lt;/code&gt; and another pointer type. So in C++, the cast would have been correct. But if you program in C++, you should use &lt;code&gt;new&lt;/code&gt; and not malloc(). And you should never compile C code using a C++ compiler.</source>
          <target state="translated">ただし、C ++では、 &lt;code&gt;void*&lt;/code&gt; と別のポインター型の間の暗黙的なキャストは許可されません。 したがって、C ++では、キャストは正しかったでしょう。 ただし、C ++でプログラミングする場合は、malloc（）ではなく &lt;code&gt;new&lt;/code&gt; を使用する必要があります。 また、C ++コンパイラを使用してCコードをコンパイルしないでください。</target>
        </trans-unit>
        <trans-unit id="78057e43e77bcc9e1b0e757fb0b316b966566195" translate="yes" xml:space="preserve">
          <source>Casting can help the developer identify inconsistencies in type sizing should the destination pointer type change, particularly if the pointer is declared far from the malloc() call (although modern compilers and static analyzers can warn on such behaviour without requiring the cast).</source>
          <target state="translated">キャストは、特にポインタがmalloc()呼び出しから遠く離れた場所で宣言されている場合など、 宛先ポインタの型が変更された場合に、型のサイジングの不整合を発見するのに役立ちます (最新のコンパイラやスタティックアナライザは、キャストを必要とせずにそのような挙動を警告することができますが)。</target>
        </trans-unit>
        <trans-unit id="3a2d7a3d4e4dd946e19f2db024674b8a866ed8cf" translate="yes" xml:space="preserve">
          <source>Casting is only for C++ not C.In case you are using a C++ compiler you better change it to C compiler.</source>
          <target state="translated">C++コンパイラを使っている場合はCコンパイラに変更した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="78ef6be30b2521065f2a740c15e9efe938dca1d7" translate="yes" xml:space="preserve">
          <source>Casting is unnecessary in C because of:</source>
          <target state="translated">Cではキャスティングは不要なので。</target>
        </trans-unit>
        <trans-unit id="b42fae74757338a083888cbb30e027c6114dbcf5" translate="yes" xml:space="preserve">
          <source>Casting the value returned by &lt;code&gt;malloc()&lt;/code&gt; is not necessary now, but I'd like to add one point that seems no one has pointed out:</source>
          <target state="translated">&lt;code&gt;malloc()&lt;/code&gt; によって返された値をキャストする必要はありませんが、誰も指摘していないように見えるポイントを1つ追加したいと思います。</target>
        </trans-unit>
        <trans-unit id="5dc2c2dd9de34c36ad74f0a09bd8fa0995f45367" translate="yes" xml:space="preserve">
          <source>Casts are bad, as people have pointed out. Specially pointer casts.</source>
          <target state="translated">キャストはみんなが指摘しているように悪い。特にポインターキャスト。</target>
        </trans-unit>
        <trans-unit id="346818851b71e2b51b940fdbcd739e7bed8a4685" translate="yes" xml:space="preserve">
          <source>Compare: &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; vs. &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; the second may overflow the &lt;code&gt;length * width&lt;/code&gt; when &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are smaller types than &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">比較： &lt;code&gt;malloc(sizeof *sieve * length * width)&lt;/code&gt; と &lt;code&gt;malloc(length * width * sizeof *sieve)&lt;/code&gt; の比較では、 &lt;code&gt;width&lt;/code&gt; と &lt;code&gt;length&lt;/code&gt; が &lt;code&gt;size_t&lt;/code&gt; より小さい型の場合、2番目は &lt;code&gt;length * width&lt;/code&gt; オーバーフローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="92a59634a691e677f0f3007226a9b9924a1c7ae0" translate="yes" xml:space="preserve">
          <source>Do I cast the result of malloc</source>
          <target state="translated">malloc の結果をキャストしますか?</target>
        </trans-unit>
        <trans-unit id="9a415f9c8b3c43f63b86077e60ea92ecb549f584" translate="yes" xml:space="preserve">
          <source>Failing to do so &lt;strong&gt;can hide an error&lt;/strong&gt;: note all the SO examples of confusing when to write &lt;code&gt;type *&lt;/code&gt; versus &lt;code&gt;type **&lt;/code&gt;.</source>
          <target state="translated">そうしないと&lt;strong&gt;、エラーが隠れ&lt;/strong&gt;てしまう&lt;strong&gt;可能性があります&lt;/strong&gt; 。 &lt;code&gt;type *&lt;/code&gt; と &lt;code&gt;type **&lt;/code&gt; を書くときに混乱を招くSOの例すべてに注意してください。</target>
        </trans-unit>
        <trans-unit id="c2178cbc15519aa10d900c715292a6bb33865e63" translate="yes" xml:space="preserve">
          <source>For me, the take home and conclusion here is that casting &lt;code&gt;malloc&lt;/code&gt; in C is totally NOT necessary but if you however cast, it wont affect &lt;code&gt;malloc&lt;/code&gt; as &lt;code&gt;malloc&lt;/code&gt; will still allocate to you your requested blessed memory space.
Another take home is the reason or one of the reasons people do casting and this is to enable them compile same program either in C or C++.</source>
          <target state="translated">私にとって、ここでの結論と結論は、Cでの &lt;code&gt;malloc&lt;/code&gt; のキャストはまったく必要ないということですが、キャストしても &lt;code&gt;malloc&lt;/code&gt; はまだ要求された祝福されたメモリ空間を割り当てるため、 mallocには影響しません。 別の持ち帰りは、キャストを行う理由または理由の1つです。これは、CまたはC ++で同じプログラムをコンパイルできるようにするためです。</target>
        </trans-unit>
        <trans-unit id="9a6ca1a7645efee702ad8b765fe9acc8115a216a" translate="yes" xml:space="preserve">
          <source>For non-dynamic arrays, the third must-have function macro is</source>
          <target state="translated">非動的配列の場合、3番目に必須の関数マクロは</target>
        </trans-unit>
        <trans-unit id="e5e168dace40a1a84f885ba2ab5051ce961fb7af" translate="yes" xml:space="preserve">
          <source>For those that finds C++ strict rules inconvenient, we can use the C++11 feature with inferred  type</source>
          <target state="translated">C++の厳密なルールが不便だと感じている人のために、C++11 の推論型機能を利用することができます。</target>
        </trans-unit>
        <trans-unit id="aa1ec3f6766ce7c0a977b7f1dcad4b9a5591083b" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Advantages_to_casting&quot;&gt;ウィキペディア&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="d392caebbb009ac1a9c6b77c7ec1500ff9e46c8b" translate="yes" xml:space="preserve">
          <source>However, if you want the same code work perfectly compatible on a C++ platform, which does not support implicit conversion, you need to do the typecasting, so it all depends on usability.</source>
          <target state="translated">しかし、暗黙の変換をサポートしていないC++プラットフォーム上で同じコードを完全に互換性を持って動作させたい場合は、型キャストを行う必要がありますので、使い勝手に依存します。</target>
        </trans-unit>
        <trans-unit id="380ef8a6f771b5ae1e081f919a36b6a9c2179d06" translate="yes" xml:space="preserve">
          <source>I have been pretty horrified over the years by the staggeringly aged compilers I've been required to use.  Often companies and managers adopt an ultra-conservative approach to changing compilers and will not even &lt;em&gt;test&lt;/em&gt; if a new compiler ( with better standards compliance and code optimization ) will work in their system.  The practical reality for working developers is that when you're coding you need to cover your bases and, unfortunately, casting mallocs is a good habit if you cannot control what compiler may be applied to your code.</source>
          <target state="translated">私は長年にわたって、私が使用するように要求された驚異的に古くなったコンパイラーにかなり恐怖を感じてきました。 多くの場合、企業やマネージャーはコンパイラーの変更に非常に保守的なアプローチを採用しており、新しいコンパイラー（標準への準拠とコードの最適化が優れている）がシステムで機能するかどうかを&lt;em&gt;テスト&lt;/em&gt;することもありません。 作業している開発者にとって実際的な現実は、コーディングするときはベースをカバーする必要があることです。残念ながら、コードに適用するコンパイラーを制御できない場合は、mallocsのキャストが適切な習慣です。</target>
        </trans-unit>
        <trans-unit id="0a9910af5e1d18f3c2c4a89ac01f4df8104d0369" translate="yes" xml:space="preserve">
          <source>I prefer to do the cast, but not manually. My favorite is using &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; macros from glib. If glib is not used, I would add similar macros. Those macros reduce code duplication without compromising type safety. If you get the type wrong, you would get an implicit cast between non-void pointers, which would cause a warning (error in C++). If you forget to include the header that defines &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt;, you would get an error. &lt;code&gt;g_new&lt;/code&gt; and &lt;code&gt;g_new0&lt;/code&gt; both take the same arguments, unlike &lt;code&gt;malloc&lt;/code&gt; that takes fewer arguments than &lt;code&gt;calloc&lt;/code&gt;. Just add &lt;code&gt;0&lt;/code&gt; to get zero-initialized memory. The code can be compiled with a C++ compiler without changes.</source>
          <target state="translated">私はキャストを好むが、手動ではない。 私のお気に入りは、glibの &lt;code&gt;g_new&lt;/code&gt; および &lt;code&gt;g_new0&lt;/code&gt; マクロを使用することです 。 glibを使用しない場合は、同様のマクロを追加します。 これらのマクロは、型の安全性を損なうことなくコードの重複を減らします。 型が間違っていると、非voidポインター間の暗黙的なキャストが発生し、警告（C ++のエラー）が発生します。 &lt;code&gt;g_new&lt;/code&gt; および &lt;code&gt;g_new0&lt;/code&gt; を定義するヘッダーを含めるのを忘れると、エラーが発生します。 &lt;code&gt;calloc&lt;/code&gt; よりも引数が少ない &lt;code&gt;malloc&lt;/code&gt; とは異なり、 &lt;code&gt;g_new&lt;/code&gt; と &lt;code&gt;g_new0&lt;/code&gt; はどちらも同じ引数を取ります。 ゼロで初期化されたメモリを取得するには、 &lt;code&gt;0&lt;/code&gt; を追加するだけです。 コードは、C ++コンパイラで変更せずにコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="7a0d0fc82cd9dea6a8c022c171d7eeb4643d5033" translate="yes" xml:space="preserve">
          <source>I put in the cast simply to show disapproval of the ugly hole in the type system, which allows code such as the following snippet to compile without diagnostics, even though no casts are used to bring about the bad conversion:</source>
          <target state="translated">私がキャストを入れたのは、以下のスニペットのようなコードを診断なしでコンパイルできるようにしている型システムの醜い穴に不賛成であることを示すためです。</target>
        </trans-unit>
        <trans-unit id="e084e2204e0fd41e68fb321510dcda59220f10db" translate="yes" xml:space="preserve">
          <source>I tend to think of casting malloc as a defensive operation.  Not pretty, not perfect, but generally safe.  ( Honestly, if you've not included stdlib.h then you've &lt;em&gt;way&lt;/em&gt; more problems than casting malloc ! ).</source>
          <target state="translated">私はmallocを防御的な操作としてキャストすることを考える傾向があります。 きれいではありませんが、完璧ではありませんが、一般的には安全です。 （正直なところ、stdlib.hをインクルードしていない場合は、mallocをキャストするよりもはるかに多くの問題があります！）</target>
        </trans-unit>
        <trans-unit id="a082eae6a8d0490ecb7ed60105f751966f9d8c0c" translate="yes" xml:space="preserve">
          <source>I wish that didn't exist (and it doesn't in C++) and so I cast. It represents my taste, and my programming politics. I'm not only casting a pointer, but effectively, casting a ballot, and &lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;casting out demons of stupidity&lt;/a&gt;. If I can't &lt;em&gt;actually&lt;/em&gt;&lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;cast out stupidity&lt;/a&gt;, then at least let me express the wish to do so with a gesture of protest.</source>
          <target state="translated">私はそれが存在しなかった（そしてC ++には存在しなかった）ことを望み、キャストします。 それは私の好み、そして私のプログラミング政治を表しています。 私はポインターをキャストするだけでなく、効果的に、投票用紙を&lt;a href=&quot;http://dilbert.com/strip/1994-02-03&quot;&gt;キャストし、愚かな悪魔をキャストし&lt;/a&gt;ます。 私が&lt;a href=&quot;http://dilbert.com/strip/1994-02-02&quot;&gt;愚かさを&lt;/a&gt; &lt;em&gt;実際に&lt;/em&gt; 投げ出すことができないなら、少なくとも抗議のしぐさでそうする意志を表現させてください。</target>
        </trans-unit>
        <trans-unit id="be1a978a33b721660c705d3cb5ac611abd6a2873" translate="yes" xml:space="preserve">
          <source>I would also suggest that many organizations apply a coding standard of their own and that &lt;em&gt;that&lt;/em&gt; should be the method people follow if it is defined.  In the absence of explicit guidance I tend to go for most likely to compile everywhere, rather than slavish adherence to a standard.</source>
          <target state="translated">また、多くの組織が独自のコーディング標準を適用し、それが定義されている場合は人々が従う方法で&lt;em&gt;ある&lt;/em&gt;べきだとも提案します。 明示的なガイダンスがない場合、私は標準への忠実な遵守よりも、どこでもコンパイルする可能性が最も高い傾向があります。</target>
        </trans-unit>
        <trans-unit id="63aba8e191469bdf847cbb632a77ed2a7d0526f5" translate="yes" xml:space="preserve">
          <source>If a C compiler cannot find a function because you forgot to include the header, you will get a compiler/linker error about that. So if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; that's no biggie, you won't be able to build your program.</source>
          <target state="translated">ヘッダーをインクルードするのを忘れたためにCコンパイラーが関数を見つけられない場合、そのことに関するコンパイラー/リンカーエラーが発生します。 そのため、大したことのない &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; を含めるのを忘れた場合、プログラムをビルドできなくなります。</target>
        </trans-unit>
        <trans-unit id="94a20e630767a5b13c70ee7de6feee73b37a4ac4" translate="yes" xml:space="preserve">
          <source>If pointers and integers are differently sized, then you're hiding a warning by casting and might lose bits of your returned address.</source>
          <target state="translated">ポインタと整数のサイズが異なる場合は、キャストで警告を隠していることになり、返されたアドレスのビットを失う可能性があります。</target>
        </trans-unit>
        <trans-unit id="65a75eb3940c4c479252444c653d371d024274a3" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may
  also, need to change all lines where malloc is called and cast.</source>
          <target state="translated">ポインタの型が宣言時に変更された場合、malloc が呼び出されてキャストされるすべての行を変更する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="df36036f7f3128303dea4303afa83edbcf774e7f" translate="yes" xml:space="preserve">
          <source>If the type of the pointer is changed at its declaration, one may also need to change all lines where &lt;code&gt;malloc&lt;/code&gt; is called and cast.</source>
          <target state="translated">宣言時にポインターのタイプが変更される場合、 &lt;code&gt;malloc&lt;/code&gt; が呼び出されてキャストされるすべての行を変更する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="6bcac15068f3bb62943c1a0a7f50cfe6b4f3ff96" translate="yes" xml:space="preserve">
          <source>If you adhere to these macros, then a simple &lt;code&gt;grep&lt;/code&gt; search of your code base for these identifiers will show you where all your casts are, so you can review whether any of them are incorrect.</source>
          <target state="translated">これらのマクロに忠実である場合、これらの識別子のコードベースを単純に &lt;code&gt;grep&lt;/code&gt; 検索すると、すべてのキャストがどこにあるかがわかるので、それらのいずれかが正しくないかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="38906a251997aa3b8616c404232d137ef1fa9d7d" translate="yes" xml:space="preserve">
          <source>If you need to support both C and C++ with the same source code, use compiler switches to mark the differences. Do not attempt to sate both language standards with the same code, because they are not compatible.</source>
          <target state="translated">同じソースコードで C と C++の両方をサポートする必要がある場合は、コンパイラスイッチを使用して違いをマークします。互換性がないので、同じコードで両方の言語標準をサポートしようとしないでください。</target>
        </trans-unit>
        <trans-unit id="7d3ac445fa31b61523e6e62450fd24ba439b4dfa" translate="yes" xml:space="preserve">
          <source>If your C code compiles as C++, you can use this &lt;code&gt;-Wold-style-cast&lt;/code&gt; option to find out all occurrences of the &lt;code&gt;(type)&lt;/code&gt; casting syntax that may creep into the code, and follow up on these diagnostics by replacing it with an appropriate choice from among the above macros (or a combination, if necessary).</source>
          <target state="translated">CコードがC ++としてコンパイルされる場合、この &lt;code&gt;-Wold-style-cast&lt;/code&gt; オプションを使用して、コードに侵入する可能性のある &lt;code&gt;(type)&lt;/code&gt; キャスト構文のすべての出現を検出し、適切なものに置き換えることでこれらの診断を追跡できます。上記のマクロ（または必要に応じて組み合わせ）の中から選択します。</target>
        </trans-unit>
        <trans-unit id="a1ec8dc8e827dcddaf1ac66310df0ab7f63c0d88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;this question&lt;/a&gt;, someone suggested in a &lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;comment&lt;/a&gt; that I should &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; cast the result of &lt;code&gt;malloc&lt;/code&gt;, i.e.</source>
          <target state="translated">&lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array&quot;&gt;この質問では&lt;/a&gt; 、誰かが&lt;a href=&quot;http://stackoverflow.com/questions/571945/getting-a-stack-overflow-exception-when-declaring-a-large-array#comment388297_571961&quot;&gt;コメント&lt;/a&gt;で私が &lt;code&gt;malloc&lt;/code&gt; の結果をキャストしてはなら&lt;strong&gt;&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt;ことを提案しました、すなわち</target>
        </trans-unit>
        <trans-unit id="b3a9cebe6da5e7431620120cb56c6c593d67810c" translate="yes" xml:space="preserve">
          <source>In C it is unnecessary, as void * is automatically and safely promoted to any other pointer type.</source>
          <target state="translated">C言語では、void *は自動的に安全に他のポインタ型に昇格するので不要です。</target>
        </trans-unit>
        <trans-unit id="c3a26193ac8cf855c86ef90718a310c04be870e5" translate="yes" xml:space="preserve">
          <source>In C you can implicitly convert a void pointer to any other kind of pointer, so a cast is not necessary. Using one may suggest to the casual observer that there is some reason why one is needed, which may be misleading.</source>
          <target state="translated">C言語では、暗黙のうちにvoidポインタを他の種類のポインタに変換することができるので、キャストは必要ありません。これは誤解を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e2c913a047567f896a4a85cdc21e25cc2d0c7db" translate="yes" xml:space="preserve">
          <source>In C you get an implicit conversion from &lt;code&gt;void*&lt;/code&gt; to any other (data) pointer.</source>
          <target state="translated">Cでは、 &lt;code&gt;void*&lt;/code&gt; から他の（データ）ポインターへの暗黙的な変換が行われます。</target>
        </trans-unit>
        <trans-unit id="124df7e4df177a7e9968fd6be1560944643fd8df" translate="yes" xml:space="preserve">
          <source>In C++, the situation is different. Casting pointer types is somewhat common (and correct) when dealing with objects of derived classes. Therefore, it makes sense that in C++, the conversion to and from &lt;code&gt;void *&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implicit. C++ has a whole set of different flavors of casting.</source>
          <target state="translated">C ++では状況が異なります。 派生クラスのオブジェクトを処理する場合、ポインタ型のキャストはいくぶん一般的（かつ正しい）です。 したがって、C ++では、 &lt;code&gt;void *&lt;/code&gt; との間の変換&lt;strong&gt;は&lt;/strong&gt;暗黙的では&lt;strong&gt;ない&lt;/strong&gt;ことは理にかなって&lt;strong&gt;い&lt;/strong&gt;ます。 C ++には、さまざまな種類のキャストがあります。</target>
        </trans-unit>
        <trans-unit id="10a5ed8bd778002e10989f9f97e0681982b277e7" translate="yes" xml:space="preserve">
          <source>In C, a &lt;strong&gt;pointer cast is almost always an error&lt;/strong&gt;. This is because of the following rule (&lt;strong&gt;&amp;sect;6.5 p7&lt;/strong&gt; in N1570, the latest draft for C11):</source>
          <target state="translated">Cでは、 &lt;strong&gt;ポインタキャストはほとんどの場合エラー&lt;/strong&gt;です。 これは、次のルールによるものです（C11の最新のドラフトである、 &lt;strong&gt;N1570の6.5 p7&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="93b491dccf959abfcaab359525161959ceec4cb9" translate="yes" xml:space="preserve">
          <source>In C, you don't need to cast the return value of &lt;code&gt;malloc&lt;/code&gt;. The pointer to void returned by &lt;code&gt;malloc&lt;/code&gt; is automagically converted to the correct type. However, if you want your code to compile with a C++ compiler, a cast is needed. A preferred alternative among the community is to use the following:</source>
          <target state="translated">Cでは、 &lt;code&gt;malloc&lt;/code&gt; の戻り値をキャストする必要はありません。 &lt;code&gt;malloc&lt;/code&gt; によって返されたvoidへのポインターは、自動的に正しい型に変換されます。 ただし、コードをC ++コンパイラーでコンパイルする場合は、キャストが必要です。 コミュニティの間で推奨される代替策は、以下を使用することです。</target>
        </trans-unit>
        <trans-unit id="8d2b0038978d4b2837d991cc706ee1d4bd7ec268" translate="yes" xml:space="preserve">
          <source>In a nutshell: Because in C, &lt;strong&gt;any&lt;/strong&gt; occurrence of a &lt;em&gt;pointer cast&lt;/em&gt; should raise a red flag for code requiring special attention, you should never write &lt;em&gt;unnecessary&lt;/em&gt; pointer casts.</source>
          <target state="translated">簡単に言うと、Cでは、 &lt;em&gt;ポインタキャスト&lt;/em&gt;が発生すると、特別な注意を必要とするコードに対して赤いフラグが立てられるため、 &lt;em&gt;不必要な&lt;/em&gt;ポインタキャストを記述し&lt;em&gt;ないで&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="f72796a47c4da0050142849a0a239342b6c889b7" translate="yes" xml:space="preserve">
          <source>In fact, a good practice is to wrap &lt;code&gt;malloc&lt;/code&gt; (and friends) with functions that return &lt;code&gt;unsigned char *&lt;/code&gt;, and basically never to use &lt;code&gt;void *&lt;/code&gt; in your code.  If you need a generic pointer-to-any-object, use a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;unsigned char *&lt;/code&gt;, and have casts in both directions. The one relaxation that can be indulged, perhaps, is using functions like &lt;code&gt;memset&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; without casts.</source>
          <target state="translated">実際、 &lt;code&gt;malloc&lt;/code&gt; （およびその仲間）を &lt;code&gt;unsigned char *&lt;/code&gt; を返す関数でラップし、基本的にコードで &lt;code&gt;void *&lt;/code&gt; を使用しないことをお勧めします。 任意のオブジェクトへの汎用ポインタが必要な場合は、 &lt;code&gt;char *&lt;/code&gt; または &lt;code&gt;unsigned char *&lt;/code&gt; を使用し、双方向にキャストします。 おそらく、リラックスできる1つのリラクゼーションは、キャストなしで &lt;code&gt;memset&lt;/code&gt; や &lt;code&gt;memcpy&lt;/code&gt; などの関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="b825dc3705674b4d779a4cf9b27487a2abaa1c23" translate="yes" xml:space="preserve">
          <source>In general, you &lt;strong&gt;don't cast to or from &lt;code&gt;void *&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">通常、 &lt;strong&gt; &lt;code&gt;void *&lt;/code&gt; へのキャストやvoid *からのキャストは行いません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fbe94d1061df0a0af541802fb33ece0468f3940" translate="yes" xml:space="preserve">
          <source>In the C language, a void pointer can be assigned to any pointer, which is why you should not use a type cast. If you want &quot;type safe&quot; allocation, I can recommend the following macro functions, which I always use in my C projects:</source>
          <target state="translated">C言語では、Voidポインタは任意のポインタに代入できるので、型キャストを使うべきではありません。もし「型安全」な割り当てをしたいのであれば、私がCプロジェクトでいつも使っている以下のマクロ関数をお勧めします。</target>
        </trans-unit>
        <trans-unit id="58f485ca9c16f19d61d27f9da6f8f8aadd049c0b" translate="yes" xml:space="preserve">
          <source>In the ancient days, that is, before &lt;strong&gt;ANSI C&lt;/strong&gt; provides the &lt;code&gt;void *&lt;/code&gt; as the generic type of pointers, &lt;code&gt;char *&lt;/code&gt; is the type for such usage. In that case, the cast can shut down the compiler warnings.</source>
          <target state="translated">古代、つまり&lt;strong&gt;ANSI C&lt;/strong&gt;がポインタの汎用型として &lt;code&gt;void *&lt;/code&gt; を提供する前は、 &lt;code&gt;char *&lt;/code&gt; はそのような使用法の型です。 その場合、キャストはコンパイラの警告をシャットダウンできます。</target>
        </trans-unit>
        <trans-unit id="7e73547744432a5c3e5cd36995aa06c8a9413ed0" translate="yes" xml:space="preserve">
          <source>Including the cast may allow a C program or function to compile as C++.</source>
          <target state="translated">キャストを含めることで、C プログラムや関数を C++としてコンパイルできるようになる場合があります。</target>
        </trans-unit>
        <trans-unit id="b8f9ba5f633406eee7f889296c7a7219db4f7a2e" translate="yes" xml:space="preserve">
          <source>It adds clutter to the code, casts are not very easy to read (especially if the pointer type is long).</source>
          <target state="translated">それはコードに乱雑さを追加し、キャストは非常に読みにくくなります(特にポインタの型が長い場合)。</target>
        </trans-unit>
        <trans-unit id="870023467a1d4925f143d3d61e6c60413492cb7a" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes (or, worse, &lt;em&gt;not&lt;/em&gt; cause a crash until way later in some totally different part of the code). Consider what happens if pointers and integers are differently sized; then you're hiding a warning by casting and might lose bits of your returned address. Note: as of C99 implicit functions are gone from C, and this point is no longer relevant since there's no automatic assumption that undeclared functions return &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; を含めるのを忘れた場合、エラーを隠すことができます。 これにより、クラッシュが発生する可能性があります（さらに悪いことに、コードのまったく異なる一部の部分まではクラッシュし&lt;em&gt;ません&lt;/em&gt; ）。 ポインタと整数のサイズが異なる場合にどうなるかを考えます。 次に、キャストによって警告を非表示にし、返されたアドレスの一部を失う可能性があります。 注：C99以降、暗黙的な関数はCからなくなり、宣言されていない関数が &lt;code&gt;int&lt;/code&gt; を返すという自動的な仮定がないため、この点は関係ありません。</target>
        </trans-unit>
        <trans-unit id="a275723f60a0b42b3396018cbbac4f68a95ffd86" translate="yes" xml:space="preserve">
          <source>It can hide an error if you forgot to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;. This can cause crashes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; を含めるのを忘れた場合、エラーを隠すことができます。 これにより、クラッシュが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ba6c240782a51eb4cc2e1cddaefc3c7e3ed8dde5" translate="yes" xml:space="preserve">
          <source>It depends on the programming language and compiler. If you use &lt;code&gt;malloc&lt;/code&gt; in C there is no need to type cast it, as it will automatically type cast, However if your using C++ then you should type cast because &lt;code&gt;malloc&lt;/code&gt; will return a &lt;code&gt;void*&lt;/code&gt; type.</source>
          <target state="translated">それはプログラミング言語とコンパイラに依存します。 Cで &lt;code&gt;malloc&lt;/code&gt; を使用する場合は、自動的に型キャストされるため、型キャストする必要はありません。ただし、C ++を使用している場合は、 &lt;code&gt;malloc&lt;/code&gt; が &lt;code&gt;void*&lt;/code&gt; 型を返すため、キャストを入力する必要があります 。</target>
        </trans-unit>
        <trans-unit id="6794ae23413780fefc55f46bbeacf139ac860cbb" translate="yes" xml:space="preserve">
          <source>It forces an &lt;strong&gt;extra cognitive cross-check&lt;/strong&gt;. It puts the (alleged) desired type right next to the arithmetic you're doing for the raw size of that variable. I bet you could do an SO study that shows that &lt;code&gt;malloc()&lt;/code&gt; bugs are caught much faster when there's a cast. As with assertions, annotations that reveal intent decrease bugs.</source>
          <target state="translated">これは、 &lt;strong&gt;追加の認知的クロスチェックを&lt;/strong&gt;強制します。 それは、その変数の生のサイズのためにあなたがしている算術のすぐ隣に（主張された）望ましい型を置きます。 キャストがあると、 &lt;code&gt;malloc()&lt;/code&gt; のバグがはるかに速く検出されることを示すSOの調査ができると思います。 アサーションと同様に、意図を明らかにする注釈はバグを減らします。</target>
        </trans-unit>
        <trans-unit id="89402a760239fb0d292e8e281d0c2cb9fb56bd70" translate="yes" xml:space="preserve">
          <source>It is not mandatory to cast the results of &lt;code&gt;malloc&lt;/code&gt;, since it returns &lt;code&gt;void*&lt;/code&gt; , and a &lt;code&gt;void*&lt;/code&gt; can be pointed to any datatype.</source>
          <target state="translated">&lt;code&gt;malloc&lt;/code&gt; の結果をキャストすることは必須ではありません。これは、 &lt;code&gt;void*&lt;/code&gt; 返し、 &lt;code&gt;void*&lt;/code&gt; は任意のデータ型を指すことができるためです。</target>
        </trans-unit>
        <trans-unit id="6e5afe0ad6c9ac54a0f00b1936fe1beb836fed49" translate="yes" xml:space="preserve">
          <source>It is unnecessary, as &lt;code&gt;void *&lt;/code&gt; is automatically and safely promoted to any other pointer type in this case.</source>
          <target state="translated">この場合、 &lt;code&gt;void *&lt;/code&gt; は自動的かつ安全に他のポインター型に昇格されるため、これは不要です。</target>
        </trans-unit>
        <trans-unit id="58da5d50b5f49af45e54e7443828c3d89f115f36" translate="yes" xml:space="preserve">
          <source>It makes you repeat yourself, which is generally bad.</source>
          <target state="translated">自分をリピートさせてしまうので、一般的には悪いのですが。</target>
        </trans-unit>
        <trans-unit id="0bed687df391f9e44c4a7612a09f35920968a326" translate="yes" xml:space="preserve">
          <source>It makes your code &lt;strong&gt;more portable&lt;/strong&gt; between C and C++, and as SO experience shows, a great many programmers claim they are writing in C when they are really writing in C++ (or C plus local compiler extensions).</source>
          <target state="translated">これにより、CとC ++の間でコードの&lt;strong&gt;移植性&lt;/strong&gt;が&lt;strong&gt;向上&lt;/strong&gt;し、SOの経験からわかるように、多くのプログラマーはC ++（またはCとローカルコンパイラーの拡張機能）で実際に書いているときにCで書いていると主張しています。</target>
        </trans-unit>
        <trans-unit id="9815dbbf9f559686ae80a3f22cf2a01f2a14f9f3" translate="yes" xml:space="preserve">
          <source>Just adding my experience, studying computer engineering I see that the two or three professors that I have seen writing in C always cast malloc, however the one I asked (with an immense CV and understanding of C) told me that it is absolutely unnecessary but only used to be absolutely specific, and to get the students into the mentality of being absolutely specific. Essentially casting will not change anything in how it works, it does exactly what it says, allocates memory, and casting does not effect it, you get the same memory, and even if you cast it to something else by mistake (and somehow evade compiler errors) C will access it the same way.</source>
          <target state="translated">私の経験を加えると、コンピュータ工学を勉強していて、私がC言語で書いているのを見た2、3人の教授はいつもmallocをキャストしていましたが、私が尋ねた教授は(C言語を理解していて膨大な履歴書を持っている)、それは絶対に不要だが、絶対的に特定のものであること、そして絶対的に特定のものであることを学生に意識させるために使われているだけだと言っていました。本質的には、キャスティングをしてもその動作は何も変わりません。</target>
        </trans-unit>
        <trans-unit id="0bff15a7d248d16466f2ec04acb6217150b312d2" translate="yes" xml:space="preserve">
          <source>Make sure there are no variables declared as &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; として宣言された変数がないことを確認してください</target>
        </trans-unit>
        <trans-unit id="28b75c4f7d75c381d47362b41c7d2dc7264fc67f" translate="yes" xml:space="preserve">
          <source>Make your program compile through a C compiler with all warnings turned on &lt;code&gt;-Wall&lt;/code&gt; and fix all errors and warnings</source>
          <target state="translated">すべての警告をオンにした状態でCコンパイラを介してプログラムをコンパイルします- &lt;code&gt;-Wall&lt;/code&gt; とすべてのエラーと警告を修正します</target>
        </trans-unit>
        <trans-unit id="7f8e8015eabf551886df6e32673d5bd7e6acb193" translate="yes" xml:space="preserve">
          <source>No, you don't cast the result of &lt;code&gt;malloc()&lt;/code&gt;.</source>
          <target state="translated">いいえ、 &lt;code&gt;malloc()&lt;/code&gt; の結果はキャストしません。</target>
        </trans-unit>
        <trans-unit id="fcc3f1618153ed78f1a42b8c3a2643297139152b" translate="yes" xml:space="preserve">
          <source>Notice that the second cons should in the ideal case disappear when using the subset common to C together with the &lt;em&gt;static&lt;/em&gt; polymorphic feature.</source>
          <target state="translated">Cに共通のサブセットを&lt;em&gt;静的な&lt;/em&gt;ポリモーフィック機能と一緒に使用すると、2番目の短所が理想的なケースでは消えることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7cee94d571455fbb9d3fed6656eb5b047a324b4c" translate="yes" xml:space="preserve">
          <source>Now compile using the C compiler again. Your program should now compile without any warning and contain fewer bugs.</source>
          <target state="translated">もう一度Cコンパイラを使ってコンパイルしてください。これで、あなたのプログラムは警告なしでコンパイルされ、バグも少なくなったはずです。</target>
        </trans-unit>
        <trans-unit id="66b2bc6a1bd3edda594e285fc1aff85a54ceee08" translate="yes" xml:space="preserve">
          <source>On ancient compilers that follow a version of the standard which is more than 25 years old, forgetting to include &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; would result in dangerous behavior. Because in that ancient standard, functions without a visible prototype implicitly converted the return type to &lt;code&gt;int&lt;/code&gt;. Casting the result from malloc explicitly would then hide away this bug.</source>
          <target state="translated">25年以上前の標準のバージョンに従う古代のコンパイラでは、 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; を含めるのを忘れると危険な動作が発生します。 その古い標準では、可視プロトタイプのない関数は戻り値の型を暗黙的に &lt;code&gt;int&lt;/code&gt; に変換したからです。 mallocからの結果を明示的にキャストすると、このバグを隠すことができます。</target>
        </trans-unit>
        <trans-unit id="bfeed771bd20c1b4da4b2efa7a63dcac68154c3a" translate="yes" xml:space="preserve">
          <source>On the other hand, casting may increase the portability of your program. i.e, it allows a C program or function to compile as C++.</source>
          <target state="translated">一方、キャスティングはプログラムの移植性を向上させることができます。</target>
        </trans-unit>
        <trans-unit id="ba2e33a9bf914822832f2f444dd3ff0f0627ac9c" translate="yes" xml:space="preserve">
          <source>On the topic of casting and C++ compatibility, if you write your code so that it compiles as both C and C++ (in which case you &lt;em&gt;have to&lt;/em&gt; cast the return value of &lt;code&gt;malloc&lt;/code&gt; when assigning it to something other than &lt;code&gt;void *&lt;/code&gt;), you can do a very helpful thing for yourself: you can use macros for casting which translate to C++ style casts when compiling as C++, but reduce to a C cast when compiling as C:</source>
          <target state="translated">キャストとC ++の互換性については、CとC ++の両方としてコンパイルされるようにコードを記述した場合（その場合、 &lt;code&gt;void *&lt;/code&gt; 以外に割り当てるときに &lt;code&gt;malloc&lt;/code&gt; の戻り値&lt;em&gt;を&lt;/em&gt;キャストする必要があります）、次のようにできます。 C ++としてコンパイルする場合はC ++スタイルのキャストに変換されるが、Cとしてコンパイルする場合はCキャストに縮小するマクロをキャストに使用できます。</target>
        </trans-unit>
        <trans-unit id="979716fcac00ca0824baf8e472028097ea147365" translate="yes" xml:space="preserve">
          <source>People used to GCC and Clang are spoiled.  It's not all that good out there.</source>
          <target state="translated">GCCやClangに慣れている人は甘えている。外では全部ダメなんだよね。</target>
        </trans-unit>
        <trans-unit id="3d20bd7e564692465d39c6283102bcfeaf2f188b" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C FAQ&lt;/a&gt;</source>
          <target state="translated">リファレンス： &lt;a href=&quot;http://c-faq.com/malloc/cast.html&quot;&gt;C FAQ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="913b8c72c65c6f2c696ebd2645ce6fe63ffd34ca" translate="yes" xml:space="preserve">
          <source>Repeating yourself in a way that the machine can check is often a &lt;strong&gt;great&lt;/strong&gt; idea. In fact, that's what an assertion is, and this use of cast is an assertion. Assertions are still the most general technique we have for getting code correct, since Turing came up with the idea so many years ago.</source>
          <target state="translated">マシンがチェックできる方法で自分自身を繰り返すことは、多くの場合&lt;strong&gt;素晴らしい&lt;/strong&gt;アイデアです。 実際、それがアサーションとは何か、そしてこのキャストの使用はアサーションです。 チューリングは何年も前にアイデアを思い付いたので、アサーションはコードを正しくするための最も一般的な手法です。</target>
        </trans-unit>
        <trans-unit id="eeb9da9341aff1229aac0eeb3d8f1a6873b9e49d" translate="yes" xml:space="preserve">
          <source>Side notes:</source>
          <target state="translated">サイドノート。</target>
        </trans-unit>
        <trans-unit id="e07ca56cc28cf07f0e7efd4adeef84b39f654a4d" translate="yes" xml:space="preserve">
          <source>Since keeping the &lt;code&gt;sizeof&lt;/code&gt; first, in this case, ensures multiplication is done with at least &lt;code&gt;size_t&lt;/code&gt; math.</source>
          <target state="translated">この場合、 &lt;code&gt;sizeof&lt;/code&gt; を最初に維持するため、乗算は少なくとも &lt;code&gt;size_t&lt;/code&gt; 数学で実行されます。</target>
        </trans-unit>
        <trans-unit id="ac0ad68dd4aefb4ac26bf0c5e2facd9461dc449e" translate="yes" xml:space="preserve">
          <source>Some comments:</source>
          <target state="translated">いくつかのコメント。</target>
        </trans-unit>
        <trans-unit id="c9afff0f26991110c2bc5c4c2920c45f8f9e49f9" translate="yes" xml:space="preserve">
          <source>Sometimes, you &lt;strong&gt;do&lt;/strong&gt; need to cast pointers, but given the &lt;em&gt;strict aliasing rule&lt;/em&gt;, you have to be very careful with it. So, any occurrence of a pointer cast in your code is a place you &lt;strong&gt;have to double-check for its validity&lt;/strong&gt;. Therefore, you never write an unnecessary pointer cast.</source>
          <target state="translated">場合によっては、ポインタをキャストする必要があります&lt;strong&gt;が&lt;/strong&gt; 、 &lt;em&gt;厳密なエイリアシングルール&lt;/em&gt;が指定されているため、非常に注意する必要があります。 したがって、コード内でキャストされたポインタは、 &lt;strong&gt;その妥当性を再確認する&lt;/strong&gt;必要がある場所です。 したがって、不要なポインタキャストを記述することはありません。</target>
        </trans-unit>
        <trans-unit id="348a3fbc26f2688c8530060e66a13437b015bb1b" translate="yes" xml:space="preserve">
          <source>That way you can still write it in a very compact way:</source>
          <target state="translated">そうすれば、まだコンパクトに書けます。</target>
        </trans-unit>
        <trans-unit id="7c11a87c54fbc0d09c65c5842cdeb16fbf6ce8d2" translate="yes" xml:space="preserve">
          <source>The argument that it's not necessary under current standards is quite valid.  But that argument omits the practicalities of the real world.  We do not code in a world ruled exclusively by the standard of the day, but by the practicalities of what I like to call &quot;local management's reality field&quot;.  And that's bent and twisted more than space time ever was. :-)</source>
          <target state="translated">現行の基準では必要ないという議論は十分に成り立つ。しかし、その議論は現実世界の現実を省いています。私たちは、その日の基準だけで支配された世界でコーディングをしているのではなく、私が「ローカル経営者の現実のフィールド」と呼ぶのが好きなものの現実性によってコーディングをしているのです。そして、それは時空を超えるほどに曲げられ、捻じ曲げられている :-)</target>
        </trans-unit>
        <trans-unit id="cf7a2c5002660ed9183a2da4a4f0f11caa52353d" translate="yes" xml:space="preserve">
          <source>The best thing to do when programming in C whenever it is possible:</source>
          <target state="translated">可能な限りC言語でプログラミングをするときにやっておいたほうがいいこと。</target>
        </trans-unit>
        <trans-unit id="8e6a11c3b2030400be409620a47673e0ff112fad" translate="yes" xml:space="preserve">
          <source>The cast allows for pre-1989 versions of malloc that originally returned a char *.</source>
          <target state="translated">このキャストは、もともとchar *を返すmallocの1989年以前のバージョンに対応しています。</target>
        </trans-unit>
        <trans-unit id="998ffdec25506c948a2e362fe99f1587650eba18" translate="yes" xml:space="preserve">
          <source>The cast is necessary here, because &lt;code&gt;printf()&lt;/code&gt; is a variadic function, so implicit conversions don't work.</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; は可変個関数なので、暗黙的な変換は機能しないため、ここではキャストが必要です。</target>
        </trans-unit>
        <trans-unit id="a53090f29cc6f3d564bf1c8d0a4c07064105db01" translate="yes" xml:space="preserve">
          <source>The concept behind void pointer is that it can be casted to any data type that is why malloc returns void. Also you must be aware of automatic typecasting. So it is not mandatory to cast the pointer though you must do it. It helps in keeping the code clean and helps debugging</source>
          <target state="translated">void ポインタの背後にある概念は、malloc が void を返す理由である、任意のデータ型にキャストすることができるということです。また、自動型キャストにも注意が必要です。だから、それはあなたがそれを行う必要がありますが、ポインタをキャストすることは必須ではありません。これはコードをクリーンに保つのに役立ち、デバッグにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="26a10d066398b061801f974a2a5ece03f6f54619" translate="yes" xml:space="preserve">
          <source>The idea that it keeps you from noticing you failed to &lt;code&gt;#include&lt;/code&gt; an appropriate header file misses &lt;strong&gt;the forest for the trees&lt;/strong&gt;. It's the same as saying &quot;don't worry about the fact you failed to ask the compiler to complain about not seeing prototypes -- that pesky stdlib.h is the REAL important thing to remember!&quot;</source>
          <target state="translated">適切なヘッダーファイルを &lt;code&gt;#include&lt;/code&gt; できなかったことに気づかないようにするという考え&lt;strong&gt;は、ツリーのフォレストを&lt;/strong&gt;見落とし&lt;strong&gt;ています&lt;/strong&gt; 。 これは、「コンパイラーにプロトタイプが表示されないことについて文句を言うのに失敗したという事実について心配しないでください。厄介なstdlib.hは、覚えておかなければならない非常に重要なことです」と同じです。</target>
        </trans-unit>
        <trans-unit id="7affa9334d50427587a11f830fa868eb1953cbca" translate="yes" xml:space="preserve">
          <source>The most common reason why people cast the result of malloc is because they are unsure about how the C language works. That's a warning sign: if you don't know how a particular language mechanism works, then &lt;em&gt;don't&lt;/em&gt; take a guess. Look it up or ask on Stack Overflow.</source>
          <target state="translated">mallocの結果をキャストする最も一般的な理由は、C言語がどのように機能するかがわからないためです。 これは警告のサインです。特定の言語メカニズムがどのように機能するかがわからない場合は、推測しないでください。 それを調べるか、Stack Overflowで質問してください。</target>
        </trans-unit>
        <trans-unit id="56afad940865bfcbe28c291e24c2bdf0ea7f35b5" translate="yes" xml:space="preserve">
          <source>The only benefits from writing in C instead of C++ I can find are</source>
          <target state="translated">C++ではなくCで書くことのメリットは、以下のようなものだけです。</target>
        </trans-unit>
        <trans-unit id="006baad78c74403e4762e856f8320bbf41a3f370" translate="yes" xml:space="preserve">
          <source>The pointer returned if the allocation succeeds is suitably aligned so
  that it may be assigned to a pointer to any type of object with a
  fundamental alignment requirement and then used to access such an
  object or an array of such objects in the space allocated (until the
  space is explicitly deallocated)</source>
          <target state="translated">割り当てに成功した場合に返されるポインタは、基本的な整列要件を持つ任意のタイプのオブジェクトへのポインタに代入され、割り当てられた空間(空間が明示的に解放されるまで)内のそのようなオブジェクトまたはそのようなオブジェクトの配列にアクセスするために使用されることができるように適切に整列されています。</target>
        </trans-unit>
        <trans-unit id="b3c30a12e0dff950c02a5280e6432480b9bd8396" translate="yes" xml:space="preserve">
          <source>The returned type is void*, which can be cast to the desired type of data pointer in order to be dereferenceable.</source>
          <target state="translated">返される型は void*であり、これを任意の型のデータポインタにキャストして参照を解除できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="711c8a89d3f2be83e87fab517121c689d0361a34" translate="yes" xml:space="preserve">
          <source>Then compile it using a C++ compiler with &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-std=c++11&lt;/code&gt;. Fix all errors and warnings.</source>
          <target state="translated">次に、 &lt;code&gt;-Wall&lt;/code&gt; および &lt;code&gt;-std=c++11&lt;/code&gt; を指定したC ++コンパイラを使用してコンパイルします。 すべてのエラーと警告を修正します。</target>
        </trans-unit>
        <trans-unit id="b833fdcd9601eb781a63d97976bc2af1531deb0f" translate="yes" xml:space="preserve">
          <source>Then, going forward, if you regularly compile the code with C++, it will enforce the use of an appropriate cast. For instance, if you use &lt;code&gt;strip_qual&lt;/code&gt; just to remove a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;, but the program changes in such a way that a type conversion is now involved, you will get a diagnostic, and you will have to use a combination of casts to get the desired conversion.</source>
          <target state="translated">次に、C ++で定期的にコードをコンパイルすると、適切なキャストの使用が強制されます。 たとえば、 &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;volatile&lt;/code&gt; を削除するためだけに &lt;code&gt;strip_qual&lt;/code&gt; を使用し、プログラムが変更されて型変換が含まれるようになった場合、診断が行われ、キャストの組み合わせを使用して、望ましい変換。</target>
        </trans-unit>
        <trans-unit id="d4e668d4c1ef3d785a282afa7e0b53c99ffaf425" translate="yes" xml:space="preserve">
          <source>There are cases where you actually &lt;em&gt;need&lt;/em&gt; a cast to &lt;code&gt;void *&lt;/code&gt;, e.g. if you want to print a pointer:</source>
          <target state="translated">実際に &lt;code&gt;void *&lt;/code&gt; へのキャストが&lt;em&gt;必要な&lt;/em&gt;場合があります。たとえば、ポインターを出力したい場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6ee851d6bd4c154373eb426a6cf77ad29b6c76b9" translate="yes" xml:space="preserve">
          <source>There may be other reasons but other reasons, almost certainly, would land you in serious trouble sooner or later.</source>
          <target state="translated">他にも理由はあるかもしれませんが、他の理由は、ほぼ確実に、遅かれ早かれ深刻なトラブルに巻き込まれるでしょう。</target>
        </trans-unit>
        <trans-unit id="186638c0a67a1197f7cd4cae91b6dbb0d0ea92b8" translate="yes" xml:space="preserve">
          <source>This also moves the &lt;code&gt;length&lt;/code&gt; to the front for increased visibility, and drops the redundant parentheses with &lt;code&gt;sizeof&lt;/code&gt;; they &lt;em&gt;are only needed&lt;/em&gt; when the argument is a type name. Many people seem to not know (or ignore) this, which makes their code more verbose. Remember: &lt;code&gt;sizeof&lt;/code&gt; is not a function! :)</source>
          <target state="translated">これはまた、 &lt;code&gt;length&lt;/code&gt; を前面に移動して &lt;code&gt;sizeof&lt;/code&gt; 、 sizeofで余分な括弧を削除します。 これら&lt;em&gt;は&lt;/em&gt; 、引数が型名である場合に&lt;em&gt;のみ必要です&lt;/em&gt; 。 多くの人はこれを知らない（または無視する）ようで、コードがより冗長になります。 注意： &lt;code&gt;sizeof&lt;/code&gt; は関数ではありません！ :)</target>
        </trans-unit>
        <trans-unit id="78ccd0f84465d8f80acc739eeb1edc6c075d1c6d" translate="yes" xml:space="preserve">
          <source>This is also known as the &lt;em&gt;strict aliasing rule&lt;/em&gt;. So the following code is &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">これは、 &lt;em&gt;厳密なエイリアスルール&lt;/em&gt;とも呼ばれます。 したがって、次のコードは&lt;em&gt;未定義の動作&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="2e07b201f2cd09204952f0ea2a8352e94d8350f8" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;The GNU C Library Reference&lt;/a&gt; manual says:</source>
          <target state="translated">これは、 &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html&quot;&gt;GNU Cライブラリリファレンス&lt;/a&gt;マニュアルの内容です。</target>
        </trans-unit>
        <trans-unit id="2612aa90747c8f2cdc6c4aacf3c9fc773e8c9fc1" translate="yes" xml:space="preserve">
          <source>This procedure lets you take advantage of C++ strict type checking, thus reducing the number of bugs. In particular, this procedure forces you to include &lt;code&gt;stdlib.h&lt;/code&gt;or you will get</source>
          <target state="translated">この手順では、C ++の厳密な型チェックを利用できるため、バグの数を減らすことができます。 特に、この手順では &lt;code&gt;stdlib.h&lt;/code&gt; を含める必要があります。そうしないと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f2cce072b4fc94a737199982264f4a8e1b007734" translate="yes" xml:space="preserve">
          <source>This treatment of conversions is the single largest standalone technical justification for working in a &quot;Clean C&quot;: the combined C and C++ dialect, which in turn technically justifies casting the return value of &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">この変換の処理は、「クリーンC」で作業するための単一の最大のスタンドアロン技術的正当化です。これは、CとC ++の方言を組み合わせたもので、 &lt;code&gt;malloc&lt;/code&gt; の戻り値のキャストを技術的に正当化します。</target>
        </trans-unit>
        <trans-unit id="6c17a9be57ef9ca7cd3adf5ee8b5ef9628a4d46a" translate="yes" xml:space="preserve">
          <source>To add further, your code needlessly repeats the type information (&lt;code&gt;int&lt;/code&gt;) which can cause errors. It's better to de-reference the pointer being used to store the return value, to &quot;lock&quot; the two together:</source>
          <target state="translated">さらに追加すると、コードはエラーを引き起こす可能性のある型情報（ &lt;code&gt;int&lt;/code&gt; ）を不必要に繰り返します。 戻り値を格納するために使用されているポインターを逆参照して、2つを一緒に「ロック」することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="81eed5fc51c3e3b44fa0ef9d4d25cef34a474770" translate="yes" xml:space="preserve">
          <source>To help you adhere to these macros, the the GNU C++ (not C!) compiler has a beautiful feature: an optional diagnostic which is produced for all occurrences of C style casts.</source>
          <target state="translated">これらのマクロを守るために、GNU C++(Cではありません!)コンパイラには美しい機能があります:Cスタイルキャストのすべての出現に対して生成されるオプションの診断機能です。</target>
        </trans-unit>
        <trans-unit id="ca84b5f4a5ac7139271f3940379fb2cf0336ee9f" translate="yes" xml:space="preserve">
          <source>Under the ANSI C standard, the cast is redundant.</source>
          <target state="translated">ANSI C規格では、キャストは冗長です。</target>
        </trans-unit>
        <trans-unit id="e8ec134ac31640fb573e0e153c5725b4e050b271" translate="yes" xml:space="preserve">
          <source>While moving &lt;code&gt;length&lt;/code&gt; to the front &lt;em&gt;may&lt;/em&gt; increase visibility in some rare cases, one should also pay attention that in the general case, it should be better to write the expression as:</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; を前に移動すると、まれに視認性が向上する場合がありますが、一般的なケースでは、次のように式を記述する方がよいことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="9ee85b34131db60fdfd151a81fdc887dd4fcd22a" translate="yes" xml:space="preserve">
          <source>Why would this be the case?</source>
          <target state="translated">なぜこのようなことになるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="01acdaf9e307b1e0a0b814ed27a2ec340c2e2c33" translate="yes" xml:space="preserve">
          <source>With these in place you can simply say</source>
          <target state="translated">これらを配置することで、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="e0ed2586aa5abd52d3b653c0086a309021a02618" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;do&lt;/strong&gt; cast, because:</source>
          <target state="translated">あなた&lt;strong&gt;が&lt;/strong&gt;キャストするのは、</target>
        </trans-unit>
        <trans-unit id="79486d2c3a27f80999f77ddcc416d8f23c32e95a" translate="yes" xml:space="preserve">
          <source>You can store the result of &lt;code&gt;malloc&lt;/code&gt; into any pointer variable without a
  cast, because ISO C automatically converts the type &lt;code&gt;void *&lt;/code&gt; to another
  type of pointer when necessary. But the cast is necessary in contexts
  other than assignment operators or if you might want your code to run
  in traditional C.</source>
          <target state="translated">ISO Cは必要に応じて &lt;code&gt;void *&lt;/code&gt; 型を別の型のポインターに自動的に変換するため、 &lt;code&gt;malloc&lt;/code&gt; の結果をキャストなしで任意のポインター変数に格納できます。 ただし、キャストは代入演算子以外のコンテキストで、またはコードを従来のCで実行したい場合に必要です。</target>
        </trans-unit>
        <trans-unit id="64d12490b03733be1bf0ccdb5177f441ae3b32a3" translate="yes" xml:space="preserve">
          <source>You don't cast the result of malloc, because doing so adds pointless clutter to your code.</source>
          <target state="translated">malloc の結果をキャストしてはいけません。</target>
        </trans-unit>
        <trans-unit id="719d41b4076bc570c545a47f1031a67ded961c28" translate="yes" xml:space="preserve">
          <source>and also forces you to cast the result of &lt;code&gt;malloc&lt;/code&gt; or you will get</source>
          <target state="translated">また、 &lt;code&gt;malloc&lt;/code&gt; の結果をキャストするように強制します。そうしないと、</target>
        </trans-unit>
        <trans-unit id="542161e54ecd4adeeeb635a9cdad11414084409e" translate="yes" xml:space="preserve">
          <source>and it will compile for C and C++.</source>
          <target state="translated">で、CとC++用にコンパイルしてくれます。</target>
        </trans-unit>
        <trans-unit id="64083eb0fbc1cccbe1930ff6c0eb620b8e9c0cc1" translate="yes" xml:space="preserve">
          <source>i.e: If you need to compile C program as C++ (Although it is a separate language) you must cast the result of use &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">つまり、CプログラムをC ++としてコンパイルする必要がある場合（それは別の言語ですが）、 &lt;code&gt;malloc&lt;/code&gt; を使用した結果をキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="7feac0152fbb8ddbd92237edaa50e15426a689c0" translate="yes" xml:space="preserve">
          <source>invalid conversion from &lt;code&gt;void*&lt;/code&gt; to &lt;code&gt;T*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;void*&lt;/code&gt; から &lt;code&gt;T*&lt;/code&gt; への無効な変換</target>
        </trans-unit>
        <trans-unit id="d4336376d32d8dd4374715878d5ec2aff3007481" translate="yes" xml:space="preserve">
          <source>or what ever your target type is.</source>
          <target state="translated">または、あなたのターゲットタイプが何であれ</target>
        </trans-unit>
        <trans-unit id="82b524d90dbcf160ddb4a560d1503123520ae7c4" translate="yes" xml:space="preserve">
          <source>rather than:</source>
          <target state="translated">というよりも</target>
        </trans-unit>
        <trans-unit id="6ef706998cf17ef7293cdb6fad421229fb5f8d93" translate="yes" xml:space="preserve">
          <source>tl;dr</source>
          <target state="translated">tl;dr</target>
        </trans-unit>
        <trans-unit id="0b710aa273bfb4642bf11423f66ee900b109348f" translate="yes" xml:space="preserve">
          <source>which additionally frees you from having to worry about changing the right-hand side of the expression if ever you change the type of &lt;code&gt;sieve&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;sieve&lt;/code&gt; のタイプを変更した場合でも、式の右側を変更する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="56cf084c8081e52c77e6553b2ba637aae876ab2f" translate="yes" xml:space="preserve">
          <source>which makes array loops safer and more convenient:</source>
          <target state="translated">これにより、配列のループがより安全で便利になります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
