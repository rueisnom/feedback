<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/218384">
    <body>
      <group id="218384">
        <trans-unit id="46c79bb66ada9c56c9356e3a5d4614b774e8bdc4" translate="yes" xml:space="preserve">
          <source>&quot;Test.java:4&quot; gives the source filename of the class, AND it tells us that the statement where this occurred is in line 4 of the file.</source>
          <target state="translated">&quot;Test.java:4&quot;는 클래스의 소스 파일 이름을 제공하며, 이것이 발생하는 명령문이 파일의 4 행에 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f8604be0c3c1ed69f32edb319a462c6359c0f2ff" translate="yes" xml:space="preserve">
          <source>&quot;at Test.main&quot; says that we were in the &lt;code&gt;main&lt;/code&gt; method of the &lt;code&gt;Test&lt;/code&gt; class.</source>
          <target state="translated">&quot;at Test.main&quot;은 우리가 &lt;code&gt;Test&lt;/code&gt; 클래스의 &lt;code&gt;main&lt;/code&gt; 메소드에 있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="12c1a4fa7b528e612a2c55a656eae759beb053c2" translate="yes" xml:space="preserve">
          <source>(This is a technicality, but I think it bears mentioning: A reference that points to null isn't the same as a C pointer that points to an invalid memory location.  A null pointer is literally not pointing &lt;em&gt;anywhere&lt;/em&gt;, which is subtly different than pointing to a location that happens to be invalid.)</source>
          <target state="translated">(이것은 기술이지만, null을 가리키는 참조는 유효하지 않은 메모리 위치를 가리키는 C 포인터와 같지 않습니다. null 포인터는 문자 그대로 &lt;em&gt;어디에서나&lt;/em&gt; 가리 키지 않습니다. 유효하지 않은 위치를 가리 킵니다.)</target>
        </trans-unit>
        <trans-unit id="3728b911d50de4ab1fcf39dee7550bebda59d186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt;s are exceptions that occur when you try to use a reference that points to no location in memory (null) as though it were referencing an object.  Calling a method on a null reference or trying to access a field of a null reference will trigger a &lt;code&gt;NullPointerException&lt;/code&gt;.  These are the most common, but other ways are listed on the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; javadoc page.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; 은 객체를 참조하는 것처럼 메모리의 아무 위치도 가리 키지 않는 (null) 참조를 사용하려고 할 때 발생하는 예외입니다. 널 참조에서 메소드를 호출하거나 널 참조의 필드에 액세스하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 트리거됩니다. 가장 일반적이지만 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; javadoc 페이지에 다른 방법이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="49dafbcd2fe39c57babb5928a1f4a08427635d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Identify the null values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;널값 식별&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한보십시오:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7654b80f753ecf9a584b54f4799cf0bb000071db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trace where these values come from&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 값의 출처를 추적&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2bed1aff07e6c53e21f30814c172aaa955a67f89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trace where these values should be set&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 값을 설정해야하는 위치 추적&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2d6017504b728ef2dbcbb062072c2f986d225f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 - Not quite true. There are things called nested exceptions...&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1-사실이 아닙니다.&lt;/sup&gt; &lt;sup&gt;중첩 예외라는 것이 있습니다 ...&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="09098c16c787fffa3d5bef267be27f9b94eec756" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This particular NPE can be avoided if the comparison order is reversed; namely, use &lt;code&gt;.equals&lt;/code&gt; on a guaranteed non-null object.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;비교 순서가 반대로되면이 특정 NPE를 피할 수 있습니다.&lt;/sup&gt; &lt;sup&gt;즉, null이 아닌 보장 된 개체에서 &lt;code&gt;.equals&lt;/code&gt; 를 사용하십시오.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="230dd3a64393775192474761fa0c5cca37186f78" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NullPointerException&lt;/code&gt; is thrown at runtime whenever your program attempts to use a &lt;code&gt;null&lt;/code&gt; as if it was a real reference. For example, if you write this:</source>
          <target state="translated">프로그램이 실제 참조 인 것처럼 &lt;code&gt;null&lt;/code&gt; 을 사용하려고 할 때마다 런타임에 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다. 예를 들어 다음과 같이 작성하면</target>
        </trans-unit>
        <trans-unit id="a9e0552c7dd394c9a31c99c24d2f880c9a4d06fd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;null&lt;/code&gt; pointer is one that points to nowhere.  When you dereference a pointer &lt;code&gt;p&lt;/code&gt;, you say &quot;give me the data at the location stored in &quot;p&quot;.  When &lt;code&gt;p&lt;/code&gt; is a &lt;code&gt;null&lt;/code&gt; pointer, the location stored in &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;nowhere&lt;/code&gt;, you're saying &quot;give me the data at the location 'nowhere'&quot;.  Obviously, it can't do this, so it throws a &lt;code&gt;null pointer exception&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 포인터는 아무데도 가리키는 포인터입니다. 포인터 &lt;code&gt;p&lt;/code&gt; 를 역 참조 할 때 &quot;p&quot;에 저장된 위치에 데이터를 제공하십시오. &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 포인터 인 경우 &lt;code&gt;p&lt;/code&gt; 에 저장된 위치는 &lt;code&gt;nowhere&lt;/code&gt; &quot;위치에 데이터를 제공하십시오 'nowhere' &quot;입니다. 분명히이 작업을 수행 할 수 없으므로 &lt;code&gt;null pointer exception&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d6c4c5d7a89d4a6783980274bfbadea09013a5b5" translate="yes" xml:space="preserve">
          <source>A good place to start is the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;JavaDocs&lt;/a&gt;. They have this covered:</source>
          <target state="translated">시작하기 좋은 곳은 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;JavaDocs&lt;/a&gt; 입니다. 그들은 이것을 다루었습니다 :</target>
        </trans-unit>
        <trans-unit id="2e2d1cdef73de0035e0ec0fce5be6a96a237140d" translate="yes" xml:space="preserve">
          <source>A lot of explanations are already present to explain how it happens and how to fix it, but you should also follow &lt;strong&gt;best practices&lt;/strong&gt; to avoid &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;s at all.</source>
          <target state="translated">발생 방법 및 해결 방법을 설명하기 위해 많은 설명이 이미 제공되어 있지만 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 을 피하기 위해 &lt;strong&gt;모범 사례&lt;/strong&gt; 를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="638d693f2f038480214d58b990af25de39a3580e" translate="yes" xml:space="preserve">
          <source>A null pointer exception is an indicator that you are using an object without initializing it.</source>
          <target state="translated">널 포인터 예외는 오브젝트를 초기화하지 않고 사용 중임을 나타내는 표시기입니다.</target>
        </trans-unit>
        <trans-unit id="b54dde997bbaa1c77cec63081960af235d128fa6" translate="yes" xml:space="preserve">
          <source>A null pointer exception is thrown when an application attempts to use null in a case where an object is required. These include:</source>
          <target state="translated">개체가 필요한 경우 응용 프로그램에서 null을 사용하려고하면 null 포인터 예외가 발생합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="63cfcf1fbbdb802eace27ba6ed8669bc6cd6c3d1" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the field of a &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 오브젝트의 필드에 액세스하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="7bec35c01df22161ef1985731a3e114df5d788b9" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the field of a null object.</source>
          <target state="translated">널 오브젝트의 필드에 액세스하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="081b055d444278a91fcdc52fd056525afd4590b2" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the slots of &lt;code&gt;null&lt;/code&gt; as if it were an array.</source>
          <target state="translated">배열 인 것처럼 &lt;code&gt;null&lt;/code&gt; 슬롯에 액세스하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3071a717183323279cc12121c92bbf3a0674c2d0" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the slots of null as if it were an array.</source>
          <target state="translated">배열 인 것처럼 널 슬롯에 액세스하거나 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3c82e5aec8823b4eada017e77cc5f6f29a9a4682" translate="yes" xml:space="preserve">
          <source>All elements inside of an array &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5&quot;&gt;are initialized to their common initial value&lt;/a&gt;; for any type of object array, that means that all elements are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">배열 내부의 모든 요소 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5&quot;&gt;는 공통 초기 값으로 초기화됩니다&lt;/a&gt; . 모든 유형의 객체 배열에 대해, 이는 모든 요소가 &lt;code&gt;null&lt;/code&gt; 임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d5256dfc3f6349ad33fe733f72303dfc4540eb37" translate="yes" xml:space="preserve">
          <source>Alternatively, there may be cases where the purpose of the method is not solely to operate on the passed in object, and therefore a null parameter may be acceptable. In this case, you would need to check for a &lt;strong&gt;null parameter&lt;/strong&gt; and behave differently. You should also explain this in the documentation. For example, &lt;code&gt;doSomething()&lt;/code&gt; could be written as:</source>
          <target state="translated">대안으로, 메소드의 목적이 전달 된 오브젝트에 대해서만 조작하는 것이 아니기 때문에 널 매개 변수가 허용 될 수 있습니다. 이 경우 &lt;strong&gt;널 매개 변수&lt;/strong&gt; 를 확인하고 다르게 작동해야합니다. 설명서에서도이를 설명해야합니다. 예를 들어 &lt;code&gt;doSomething()&lt;/code&gt; 은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c610b12b0bdb7da0de89b6112dad5051859e5f8a" translate="yes" xml:space="preserve">
          <source>And on another place in your code:</source>
          <target state="translated">그리고 코드의 다른 곳에서 :</target>
        </trans-unit>
        <trans-unit id="fec17b583e2fe54653432fe84eafb118f367f489" translate="yes" xml:space="preserve">
          <source>Another occurrence of a &lt;code&gt;NullPointerException&lt;/code&gt; occurs when one declares an object array, then immediately tries to dereference elements inside of it.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; 의 또 다른 발생은 객체 배열을 선언 한 후 즉시 그 안의 요소를 역 참조하려고 시도 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ec98bf54606e720fcaaa69af937b822723782a2b" translate="yes" xml:space="preserve">
          <source>Applications should throw instances of this class to indicate other
  illegal uses of the null object.</source>
          <target state="translated">응용 프로그램은 null 객체의 다른 불법적 인 사용을 나타 내기 위해이 클래스의 인스턴스를 던져야합니다.</target>
        </trans-unit>
        <trans-unit id="bc2a7a3d52ad00a39aa87d3ee50b3aaad37ba8df" translate="yes" xml:space="preserve">
          <source>Applications should throw instances of this class to indicate other illegal uses of the &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;null&lt;/code&gt; 객체의 다른 불법적 인 사용을 나타 내기 위해이 클래스의 인스턴스를 던져야합니다.</target>
        </trans-unit>
        <trans-unit id="3bb9c94bc952d51ad045ffee95f408bcacb6ca66" translate="yes" xml:space="preserve">
          <source>As you should know, Java types are divided into &lt;em&gt;primitive types&lt;/em&gt; (&lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, etc.) and &lt;em&gt;reference types&lt;/em&gt;. Reference types in Java allow you to use the special value &lt;code&gt;null&lt;/code&gt; which is the Java way of saying &quot;no object&quot;.</source>
          <target state="translated">아시다시피 Java 유형은 &lt;em&gt;기본 유형&lt;/em&gt; ( &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; 등)과 &lt;em&gt;참조 유형으로 구분&lt;/em&gt; 됩니다. Java의 참조 유형을 사용하면 &quot;객체 없음&quot;이라고하는 Java 방식 인 특수 값 &lt;code&gt;null&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56bc238aac80b83b0ad417696ff3ad35156f1e99" translate="yes" xml:space="preserve">
          <source>At this time you have just &lt;strong&gt;declared&lt;/strong&gt; this object but not &lt;strong&gt;initialized or instantiated&lt;/strong&gt;. And whenever you try to access any property or method in it, it will throw  &lt;code&gt;NullPointerException&lt;/code&gt; which makes sense.</source>
          <target state="translated">현재이 객체를 &lt;strong&gt;선언&lt;/strong&gt; 했지만 &lt;strong&gt;초기화하거나 인스턴스화&lt;/strong&gt; 하지 않았습니다. 그리고 속성이나 메서드에 액세스하려고 할 때마다 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3ca15f5dab40cddc958cc899caa21a2ead819af" translate="yes" xml:space="preserve">
          <source>Avoid returning null in methods, for example returning empty collections when applicable.</source>
          <target state="translated">적용 가능한 경우 빈 컬렉션을 반환하는 등 메서드에서 null을 반환하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5bf95245956d03bfda307dee31c95faa928638e7" translate="yes" xml:space="preserve">
          <source>Avoiding &amp;ldquo;!= null&amp;rdquo; statements in Java?</source>
          <target state="translated">Java에서 &quot;! = null&quot;문을 피 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="e712d8332074c0bc1572f647f4af0f2ae63f7453" translate="yes" xml:space="preserve">
          <source>Because you are using &lt;code&gt;student&lt;/code&gt;, but you forgot to initialize it like in the
correct code shown below:</source>
          <target state="translated">&lt;code&gt;student&lt;/code&gt; 를 사용하고 있지만 아래 표시된 올바른 코드와 같이 초기화하는 것을 잊어 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="b92e2b55b4354330a3c96dc3a92d018a12ff9a30" translate="yes" xml:space="preserve">
          <source>But (I hear you say) what if the NPE was thrown inside the &lt;code&gt;length()&lt;/code&gt; method call?</source>
          <target state="translated">그러나 NPE가 &lt;code&gt;length()&lt;/code&gt; 메소드 호출 내부에 던져지면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="70de7c517ab05f22376120259b795a5d367579bd" translate="yes" xml:space="preserve">
          <source>But, when you try to declare a reference &lt;em&gt;type&lt;/em&gt;, something different happens. Take the following code:</source>
          <target state="translated">그러나 참조 &lt;em&gt;유형&lt;/em&gt; 을 선언하려고하면 다른 일이 발생합니다. 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b760c60d971f57b8c1e7ecdfb80c460f606d442" translate="yes" xml:space="preserve">
          <source>Calling the instance method of a &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 객체의 인스턴스 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="634a22d75f5bdbe844d7fa3fc013a702dcded4d8" translate="yes" xml:space="preserve">
          <source>Calling the instance method of a null object.</source>
          <target state="translated">null 객체의 인스턴스 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2a0a9d9e68fd881b18d0b16e39eef09d5cd31ae1" translate="yes" xml:space="preserve">
          <source>Declaration: &lt;code&gt;Item item[] = new Item[5];&lt;/code&gt;</source>
          <target state="translated">선언 : &lt;code&gt;Item item[] = new Item[5];&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="019ac43ed7ec529c737b8e34b517aec2236183b6" translate="yes" xml:space="preserve">
          <source>Declaration: &lt;code&gt;Object object;&lt;/code&gt;</source>
          <target state="translated">선언 : &lt;code&gt;Object object;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c746af47b00ccd6d6e07567df1b2eaa4c74bbcd" translate="yes" xml:space="preserve">
          <source>Declare</source>
          <target state="translated">Declare</target>
        </trans-unit>
        <trans-unit id="90599a45b68a2a1c4b1602b265e701d17c3453c2" translate="yes" xml:space="preserve">
          <source>Dereferencing usually happens when using &lt;code&gt;.&lt;/code&gt; to access a method or field, or using &lt;code&gt;[&lt;/code&gt; to index an array.</source>
          <target state="translated">역 참조는 일반적으로을 사용할 때 발생합니다 &lt;code&gt;.&lt;/code&gt; 메서드 나 필드에 액세스하거나 &lt;code&gt;[&lt;/code&gt; 를 사용하여 배열을 인덱싱합니다.</target>
        </trans-unit>
        <trans-unit id="d1d4b339edce051f7810e587e0c51e16ae74146a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;printString&lt;/code&gt; method can &lt;em&gt;check for null&lt;/em&gt;, for example:</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 또는 &lt;code&gt;printString&lt;/code&gt; 메소드는 다음 &lt;em&gt;과 같이 null을 확인할&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="37aefda29876d0fc65311b06db99106714c1d07e" translate="yes" xml:space="preserve">
          <source>Fail fast and use asserts to avoid propagation of null objects through the whole application when they shouldn't be null.</source>
          <target state="translated">null이 아니어야 할 때 전체 응용 프로그램을 통해 null 객체가 전파되는 것을 피하기 위해 신속하게 실패하고 어설 션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c1fb00189acb7a631f566fbdba728784b7fb6217" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;https://stackoverflow.com/q/3988788/2775450&quot;&gt;How to pinpoint the exception &amp;amp; cause using Stack Trace&lt;/a&gt;</source>
          <target state="translated">마지막으로 &lt;a href=&quot;https://stackoverflow.com/q/3988788/2775450&quot;&gt;스택 추적을 사용하여 예외를 식별하고 원인을 찾는 방법&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e523347a7b87520e096c7d1a14d92c4714f695c7" translate="yes" xml:space="preserve">
          <source>First observation: the compilation succeeds! The problem in the program is NOT a compilation error. It is a &lt;em&gt;runtime&lt;/em&gt; error. (Some IDEs may warn your program will always throw an exception ... but the standard &lt;code&gt;javac&lt;/code&gt; compiler doesn't.)</source>
          <target state="translated">첫 번째 관찰 : 편집이 성공했습니다! 프로그램의 문제는 컴파일 오류가 아닙니다. &lt;em&gt;런타임&lt;/em&gt; 오류입니다. (일부 IDE는 프로그램이 항상 예외를 throw 할 것이라고 경고 할 수 있지만 표준 &lt;code&gt;javac&lt;/code&gt; 컴파일러는 그렇지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8034a9b3e958bafca5b80be28a9299b4df2a9530" translate="yes" xml:space="preserve">
          <source>For example, below is a student class which will use it in our code.</source>
          <target state="translated">예를 들어, 아래는 코드에서 사용할 학생 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="369b0266a6a685e58d0bf30452751bfdd1e0a29b" translate="yes" xml:space="preserve">
          <source>For instance, you may have a method as follows:</source>
          <target state="translated">예를 들어 다음과 같은 방법이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e426a7d0a0945c9b135618483f0d59c549ba4902" translate="yes" xml:space="preserve">
          <source>Here, we see that the exception is thrown on line 13 (in the &lt;code&gt;printString&lt;/code&gt; method). Look at the line and check which values are null by
adding &lt;em&gt;logging statements&lt;/em&gt; or using a &lt;em&gt;debugger&lt;/em&gt;. We find out that &lt;code&gt;s&lt;/code&gt; is null, and calling the &lt;code&gt;length&lt;/code&gt; method on it throws the exception. We can see that the program stops throwing the exception when &lt;code&gt;s.length()&lt;/code&gt; is removed from the method.</source>
          <target state="translated">여기에서 예외는 13 행에서 발생합니다 ( &lt;code&gt;printString&lt;/code&gt; 메소드에서). 행을보고 &lt;em&gt;logging 문&lt;/em&gt; 을 추가하거나 &lt;em&gt;디버거를&lt;/em&gt; 사용하여 null 값을 확인하십시오. 우리는 &lt;code&gt;s&lt;/code&gt; 가 null임을 알아 내고 &lt;code&gt;length&lt;/code&gt; 메소드를 호출하면 예외가 발생합니다. 메소드에서 &lt;code&gt;s.length()&lt;/code&gt; 가 제거되면 프로그램이 예외 처리를 중지 함을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b11a882fed564b0eb9222ebda986752854af8c" translate="yes" xml:space="preserve">
          <source>How can that throw an NPE?</source>
          <target state="translated">어떻게 NPE를 던질 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="61b251a05ff88cf9158093feb2fc5a5c219ef28a" translate="yes" xml:space="preserve">
          <source>How do I fix it?</source>
          <target state="translated">어떻게 고치나요?</target>
        </trans-unit>
        <trans-unit id="327df277bc05aac18f0fa7fb4e2e987135c7512d" translate="yes" xml:space="preserve">
          <source>I still can't find the problem</source>
          <target state="translated">여전히 문제를 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="66b032c360e09ab3e68584d1ba075e1987c06cf7" translate="yes" xml:space="preserve">
          <source>I would add, very important, make a good use of the &lt;code&gt;final&lt;/code&gt; modifier.
&lt;a href=&quot;https://stackoverflow.com/questions/137868/using-final-modifier-whenever-applicable-in-java&quot;&gt;Using the &quot;final&quot; modifier whenever applicable in Java&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 수정자를 잘 활용하는 것이 중요합니다. &lt;a href=&quot;https://stackoverflow.com/questions/137868/using-final-modifier-whenever-applicable-in-java&quot;&gt;Java에 적용 할 때마다 &quot;최종&quot;수정 자 사용&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6308f70b4f0ae15d5eb767dca1766a9e484da9fb" translate="yes" xml:space="preserve">
          <source>If the exception has an associated error message, that will be output after the exception name. &lt;code&gt;NullPointerException&lt;/code&gt; is unusual in this respect, because it rarely has an error message.</source>
          <target state="translated">예외에 관련 오류 메시지가 있으면 예외 이름 뒤에 출력됩니다. &lt;code&gt;NullPointerException&lt;/code&gt; 은이 점에서 오류 메시지가 거의 없기 때문에 일반적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb26238ed800420e5c53a71b6bf0a0b7a52eaeb2" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;bar[pos]&lt;/code&gt; will throw an NPE.</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; 의 값이 &lt;code&gt;null&lt;/code&gt; 이면 &lt;code&gt;bar[pos]&lt;/code&gt; 는 NPE를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="37e77872a7e487d9afdbefdbf2345bfd255ec57b" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;bar[pos]&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then calling &lt;code&gt;length()&lt;/code&gt; on it will throw an NPE.</source>
          <target state="translated">&lt;code&gt;bar[pos]&lt;/code&gt; 의 값이 &lt;code&gt;null&lt;/code&gt; 이면 &lt;code&gt;length()&lt;/code&gt; 를 호출하면 NPE가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fb4addbf00588879005cb609de5d3b982823f43" translate="yes" xml:space="preserve">
          <source>If you are not giving the initialization section then the &lt;code&gt;NullPointerException&lt;/code&gt; arise.</source>
          <target state="translated">초기화 섹션을 제공하지 않으면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e65cd02770e6747d2781dbef1dbe7a0838997ff2" translate="yes" xml:space="preserve">
          <source>If you attempt to dereference &lt;code&gt;num&lt;/code&gt; BEFORE creating the object you get a &lt;code&gt;NullPointerException&lt;/code&gt;. In the most trivial cases, the compiler will catch the problem and let you know that &quot;&lt;code&gt;num may not have been initialized&lt;/code&gt;,&quot; but sometimes you may write code that does not directly create the object.</source>
          <target state="translated">객체를 만들기 전에 &lt;code&gt;num&lt;/code&gt; 을 역 참조하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다. 가장 사소한 경우에, 컴파일러는 문제를 잡아서 &quot; &lt;code&gt;num may not have been initialized&lt;/code&gt; &quot;라고 알려주지 만, 때로는 객체를 직접 생성하지 않는 코드를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b405ab91b8fae348c65830646a2f15cfa73ec595" translate="yes" xml:space="preserve">
          <source>If you count the lines in the file above, line 4 is the one that I labeled with the &quot;HERE&quot; comment.</source>
          <target state="translated">위의 파일에서 행을 세면 4 행은 &quot;HERE&quot;주석으로 레이블이 지정된 행입니다.</target>
        </trans-unit>
        <trans-unit id="a3f749cff981330fc865245f1db404f2d1866f2b" translate="yes" xml:space="preserve">
          <source>If you tried to debug the problem and still don't have a solution, you can post a question for more help, but make sure to include what you've tried so far. At a minimum, &lt;strong&gt;include the stacktrace&lt;/strong&gt; in the question, and &lt;strong&gt;mark the important line numbers&lt;/strong&gt; in the code. Also, try simplifying the code first (see &lt;a href=&quot;http://sscce.org/&quot;&gt;SSCCE&lt;/a&gt;).</source>
          <target state="translated">문제를 디버깅하려고했지만 여전히 해결 방법이없는 경우 추가 도움이 필요한 질문을 게시 할 수 있지만 지금까지 시도한 내용을 포함시켜야합니다. 최소한 질문에 &lt;strong&gt;스택 추적&lt;/strong&gt; 을 &lt;strong&gt;포함&lt;/strong&gt; 시키고 코드에 &lt;strong&gt;중요한 줄 번호&lt;/strong&gt; 를 &lt;strong&gt;표시하십시오&lt;/strong&gt; . 또한 코드를 먼저 단순화하십시오 ( &lt;a href=&quot;http://sscce.org/&quot;&gt;SSCCE&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="d37b6038f9a6cd2dff562dfe87901f623ec47b9e" translate="yes" xml:space="preserve">
          <source>If you want to use any object then you have two phases:</source>
          <target state="translated">객체를 사용하려면 두 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d544f7bccdff6bb68a69fb25d6a390dd45d80a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; all the variables you declare are actually &quot;references&quot; to the objects (or primitives) and not the objects themselves.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java에서&lt;/a&gt; 선언 한 모든 변수는 실제로 오브젝트 자체가 아니라 오브젝트 (또는 기본 요소)에 대한 &quot;참조&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="758063698f54411c5380c94bde31ca08d17694ea" translate="yes" xml:space="preserve">
          <source>In Java, everything (excluding primitive types) is in the form of a class.</source>
          <target state="translated">Java에서 모든 유형 (기본 유형 제외)은 클래스 형식입니다.</target>
        </trans-unit>
        <trans-unit id="2d1e8941405e95d8f2a50326004d775c905ad0da" translate="yes" xml:space="preserve">
          <source>In fact there is only one way: it can only happen if &lt;code&gt;foo&lt;/code&gt; has the value &lt;code&gt;null&lt;/code&gt;.  We then try to run the &lt;code&gt;length()&lt;/code&gt; method on &lt;code&gt;null&lt;/code&gt; and .... BANG!</source>
          <target state="translated">실제로 한 가지 방법 만 있습니다. &lt;code&gt;foo&lt;/code&gt; 에 &lt;code&gt;null&lt;/code&gt; 값이있는 경우에만 발생할 수 있습니다. 그런 다음 &lt;code&gt;null&lt;/code&gt; 및 .... BANG에서 &lt;code&gt;length()&lt;/code&gt; 메서드를 실행하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="e072b7c921ded7d305ef1e675e84ddd558ea97ee" translate="yes" xml:space="preserve">
          <source>In general, it's because something hasn't been initialized properly.</source>
          <target state="translated">일반적으로 무언가가 제대로 초기화되지 않았기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e84992bf73e77db6c21133edfc7e60f3abe481d5" translate="yes" xml:space="preserve">
          <source>In short the stack trace will tell us unambiguously which statement of the program has thrown the NPE.</source>
          <target state="translated">간단히 말해서 스택 추적은 프로그램의 어떤 진술이 NPE를 던 졌는지 분명하게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="ff129ea13cbf7d94f4945873a0e66ab25fb80786" translate="yes" xml:space="preserve">
          <source>In the second line, the &lt;code&gt;new&lt;/code&gt; keyword is used to instantiate (or create) an object of type &lt;code&gt;Integer&lt;/code&gt; and the pointer variable &lt;code&gt;num&lt;/code&gt; is assigned to that &lt;code&gt;Integer&lt;/code&gt; object.</source>
          <target state="translated">두 번째 줄에서 &lt;code&gt;new&lt;/code&gt; 키워드는 &lt;code&gt;Integer&lt;/code&gt; 유형의 객체를 인스턴스화 (또는 생성)하는 데 사용되며 포인터 변수 &lt;code&gt;num&lt;/code&gt; 은 해당 &lt;code&gt;Integer&lt;/code&gt; 객체에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f88263ab738c6ace334b24405051e63bb3e43df8" translate="yes" xml:space="preserve">
          <source>In this example, the variable &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; and Java will initialize it to &lt;code&gt;0&lt;/code&gt; for you. When you assign it the value of &lt;code&gt;10&lt;/code&gt; on the second line, your value of &lt;code&gt;10&lt;/code&gt; is written into the memory location referred to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;int&lt;/code&gt; 이며 Java는 변수를 &lt;code&gt;0&lt;/code&gt; 으로 초기화합니다. 두 번째 줄에 값 &lt;code&gt;10&lt;/code&gt; 을 할당하면 값 &lt;code&gt;10&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 가 참조하는 메모리 위치에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="58e9dc951da0b9f4f2e75e6349c8988645b66556" translate="yes" xml:space="preserve">
          <source>In which case, &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. If the method is intended to do something to the passed-in object, it is appropriate to throw the &lt;code&gt;NullPointerException&lt;/code&gt; because it's a programmer error and the programmer will need that information for debugging purposes.  Please include the name of the object variable in the exception message, like</source>
          <target state="translated">이 경우 &lt;code&gt;obj&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 입니다. 메소드가 전달 된 오브젝트에 대해 무언가를 수행하려는 경우, 프로그래머 오류이므로 프로그래머는 디버깅 목적으로 해당 정보가 필요하므로 &lt;code&gt;NullPointerException&lt;/code&gt; 을 발생시키는 것이 적절합니다. 다음과 같이 예외 메시지에 객체 변수의 이름을 포함하십시오</target>
        </trans-unit>
        <trans-unit id="eaa842988aa6b70454294a66ea91b95dd8434276" translate="yes" xml:space="preserve">
          <source>In which case, you are not creating the object &lt;code&gt;obj&lt;/code&gt;, but rather assuming that it was created before the &lt;code&gt;doSomething()&lt;/code&gt; method was called. Note, it is possible to call the method like this:</source>
          <target state="translated">이 경우, 객체 &lt;code&gt;obj&lt;/code&gt; 를 작성하지 않고 &lt;code&gt;doSomething()&lt;/code&gt; 메소드가 호출되기 전에 작성되었다고 가정합니다. 다음과 같이 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef62b29237cb984a3dfc705f60d31635eca26a1" translate="yes" xml:space="preserve">
          <source>Indeed it is! And that is the problem. When we initialize like this:</source>
          <target state="translated">실제로입니다! 그리고 그것이 문제입니다. 다음과 같이 초기화하면</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="dd695f048156244b311843d310329edc10ad3530" translate="yes" xml:space="preserve">
          <source>Initialization: &lt;code&gt;item[0] = new Item();&lt;/code&gt;</source>
          <target state="translated">초기화 : &lt;code&gt;item[0] = new Item();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa4a5d2f4df0ef578634d30eb2c60e497f43b6cf" translate="yes" xml:space="preserve">
          <source>Initialization: &lt;code&gt;object = new Object();&lt;/code&gt;</source>
          <target state="translated">초기화 : &lt;code&gt;object = new Object();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1926c212a3dc9c16b0c0d64823cf41cde00923e6" translate="yes" xml:space="preserve">
          <source>It is also the case that if you attempt to use a null reference with &lt;code&gt;synchronized&lt;/code&gt;, that will also throw this exception, &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19&quot;&gt;per the JLS&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; 와 함께 null 참조를 사용하려고 시도 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19&quot;&gt;하면 JLS에 따라이&lt;/a&gt; 예외가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d16dbce2624ff3130d8e2270cf0f83a79ee462c" translate="yes" xml:space="preserve">
          <source>It tells you the full name of the exception that was thrown; i.e. &lt;code&gt;java.lang.NullPointerException&lt;/code&gt;.</source>
          <target state="translated">발생 된 예외의 전체 이름을 알려줍니다. 즉 &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8417e2fba268434b1c803e3ff401a4e1a47b61fc" translate="yes" xml:space="preserve">
          <source>It tells you the name of the Java thread in which the exception was thrown.  For a simple program with one thread (like this one), it will be &quot;main&quot;. Let's move on ...</source>
          <target state="translated">예외가 발생한 Java 스레드의 이름을 알려줍니다. 하나의 스레드 (예 :이 스레드)가있는 간단한 프로그램의 경우 &quot;메인&quot;이됩니다. 계속 갑시다 ...</target>
        </trans-unit>
        <trans-unit id="2a253b1e78bf697c2a11dc2ac9d828a12960e3d4" translate="yes" xml:space="preserve">
          <source>It's like you are trying to access an object which is &lt;code&gt;null&lt;/code&gt;. Consider below example:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 인 객체에 액세스하려고하는 것과 같습니다. 아래 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="76418c77d1fc266f3a62cf5f684db71e4d1120d9" translate="yes" xml:space="preserve">
          <source>Let's illustrate with the simple example (above) first. We start by looking at the line that the stack trace has told us is where the NPE happened:</source>
          <target state="translated">간단한 예 (위)로 먼저 설명하겠습니다. 우리는 스택 트레이스가 우리에게 NPE가 발생한 위치를 알려주는 라인을 살펴보면서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d339292be5c375475471a2ad89e7eae3c587ba51" translate="yes" xml:space="preserve">
          <source>Looking at the first line, how could that throw an NPE?  There are two ways:</source>
          <target state="translated">첫 번째 줄을 보면 어떻게 NPE를 던질 수 있습니까? 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3048bc36d2ef3a5ca1d47ab6ade02d04a15cfa52" translate="yes" xml:space="preserve">
          <source>Next check where this value comes from. By following the callers of the method, we see that &lt;code&gt;s&lt;/code&gt; is passed in with &lt;code&gt;printString(name)&lt;/code&gt; in the &lt;code&gt;print()&lt;/code&gt; method, and &lt;code&gt;this.name&lt;/code&gt; is null.</source>
          <target state="translated">다음으로이 값의 출처를 확인하십시오. 메소드 호출자에 따라 &lt;code&gt;print()&lt;/code&gt; 메소드에서 &lt;code&gt;printString(name)&lt;/code&gt; 과 함께 &lt;code&gt;s&lt;/code&gt; 가 전달되고 &lt;code&gt;this.name&lt;/code&gt; 이 널임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68bd69464f365c0fbf0e01313f81d5c88e5bffca" translate="yes" xml:space="preserve">
          <source>Next, we need to figure out which of those scenarios explains what is actually happening. We will start by exploring the first one:</source>
          <target state="translated">다음으로, 어떤 시나리오에서 실제로 어떤 일이 일어나고 있는지 설명해야합니다. 우리는 첫 번째 것을 탐험하면서 시작할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="8eceeaca2b7a976cb9ee01b6b05534d3a2006ca8" translate="yes" xml:space="preserve">
          <source>Note that in a more complicated example, there will be lots of lines in the NPE stack trace. But you can be sure that the second line (the first &quot;at&quot; line) will tell you where the NPE was thrown&lt;sup&gt;1&lt;/sup&gt;.</source>
          <target state="translated">보다 복잡한 예에서는 NPE 스택 추적에 많은 행이 있습니다. 그러나 두 번째 줄 (첫 번째 &quot;at&quot;줄)이 NPE가 발생한 위치를 알려줄 것입니다 &lt;sup&gt;1&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="7efbcba01f44f10b16dc449b3a4ce5b93ec278ac" translate="yes" xml:space="preserve">
          <source>OK, so let's try a slightly more tricky example. This will require some &lt;em&gt;logical deduction&lt;/em&gt;.</source>
          <target state="translated">자, 좀 더 까다로운 예를 들어 봅시다. 여기에는 약간의 &lt;em&gt;논리적 추론&lt;/em&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="09140446828a190f98d3e888ff50d49babf39577" translate="yes" xml:space="preserve">
          <source>On the first line inside &lt;code&gt;main&lt;/code&gt;, I'm explicitly setting the &lt;code&gt;Object&lt;/code&gt; reference &lt;code&gt;obj&lt;/code&gt; equal to &lt;code&gt;null&lt;/code&gt;.  This means I have a reference, but it isn't pointing to any object.  After that, I try to treat the reference as though it points to an object by calling a method on it.  This results in a &lt;code&gt;NullPointerException&lt;/code&gt; because there is no code to execute in the location that the reference is pointing.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 내부의 첫 번째 줄에서 &lt;code&gt;Object&lt;/code&gt; 참조 &lt;code&gt;obj&lt;/code&gt; 를 &lt;code&gt;null&lt;/code&gt; 로 명시 적으로 설정하고 있습니다. 이것은 참조가 있지만 객체를 가리키고 있지 않음을 의미합니다. 그 후, 참조를 메소드를 호출하여 객체를 가리키는 것처럼 처리하려고합니다. 참조가 가리키는 위치에서 실행할 코드가 없기 때문에 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b3e2ae3b2ddecc346c758e8d3b5549b755c1e92" translate="yes" xml:space="preserve">
          <source>Or you can design the class so that &lt;code&gt;name&lt;/code&gt;&lt;em&gt;always has a non-null value&lt;/em&gt;:</source>
          <target state="translated">또는 &lt;code&gt;name&lt;/code&gt; &lt;em&gt;항상 null이 아닌 값을&lt;/em&gt; 갖도록 클래스를 디자인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc52fe609e5da3175933559d437d1fdb72e364c5" translate="yes" xml:space="preserve">
          <source>Other fixes</source>
          <target state="translated">다른 수정</target>
        </trans-unit>
        <trans-unit id="5332d8134d57cacdb6ee04717450e635f41c6767" translate="yes" xml:space="preserve">
          <source>Otherwise, if the value of the Expression is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">그렇지 않으면, Expression의 값이 널이면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59f63782fa2d7a08a6249d7857f98b11c193fbd3" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;valueOf()&lt;/code&gt; over &lt;code&gt;toString()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toString()&lt;/code&gt; 보다 &lt;code&gt;valueOf()&lt;/code&gt; 를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="e6eb6b961bbe76bed259ea3835d017bb805fcd01" translate="yes" xml:space="preserve">
          <source>Probably the quickest example code I could come up with to illustrate a &lt;code&gt;NullPointerException&lt;/code&gt; would be:</source>
          <target state="translated">아마도 &lt;code&gt;NullPointerException&lt;/code&gt; 을 설명하기 위해 얻을 수있는 가장 빠른 예제 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1aa69767a9902b2d9d069ada53c5e09041f46fc" translate="yes" xml:space="preserve">
          <source>Question: How do I read the NPE stacktrace?</source>
          <target state="translated">질문 : NPE 스택 추적을 어떻게 읽습니까?</target>
        </trans-unit>
        <trans-unit id="2a7214e14c4e2559dd384c3596ba27c46d122f5b" translate="yes" xml:space="preserve">
          <source>Question: How do I track down the cause of the NPE exception in my code?</source>
          <target state="translated">질문 : 코드에서 NPE 예외의 원인을 어떻게 추적합니까?</target>
        </trans-unit>
        <trans-unit id="110059053a369d1fac95bf75cd737030c08abcd5" translate="yes" xml:space="preserve">
          <source>Question: What causes a &lt;code&gt;NullPointerException&lt;/code&gt; (NPE)?</source>
          <target state="translated">질문 : NPE ( &lt;code&gt;NullPointerException&lt;/code&gt; )의 원인은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f7b4ef7eaa8bdc43a3fc8327ee8e3b2a393de223" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20c7030469d7703e9338b3a13079900db1ad58d0" translate="yes" xml:space="preserve">
          <source>Same for the array concept:</source>
          <target state="translated">배열 개념과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a328a8219b1d929d6ed454cdd41b31e02977388d" translate="yes" xml:space="preserve">
          <source>Second observation: when I run the program, it outputs two lines of &quot;gobbledy-gook&quot;. &lt;strong&gt;WRONG!!&lt;/strong&gt; That's not gobbledy-gook. It is a stacktrace ... and it provides &lt;em&gt;vital information&lt;/em&gt; that will help you track down the error in your code, if you take the time to read it carefully.</source>
          <target state="translated">두 번째 관찰 : 프로그램을 실행하면 두 줄의 &quot;gobbledy-gook&quot;이 출력됩니다. &lt;strong&gt;잘못된!!&lt;/strong&gt; 그것은 거칠지 않다. 그것은 스택 트레이스입니다 ... 시간을 들여주의 깊게 읽으면 코드의 오류를 추적하는 데 도움이되는 &lt;em&gt;중요한 정보&lt;/em&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5ece6ed3284a8e7793f5f8e6191387a1ca65d15c" translate="yes" xml:space="preserve">
          <source>See also:
&lt;a href=&quot;http://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html&quot;&gt;A good list of best practices&lt;/a&gt;</source>
          <target state="translated">다음을 참조하십시오 : &lt;a href=&quot;http://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html&quot;&gt;모범 사례 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c66fb315fd8a9161821812042eba9ece0fca8b7e" translate="yes" xml:space="preserve">
          <source>See this below example as well:</source>
          <target state="translated">아래 예제도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f608da5633e1fbbbac554cb0e0f6193783c3e96" translate="yes" xml:space="preserve">
          <source>So let's look at what it says:</source>
          <target state="translated">그래서 그것이 말하는 것을 보자.</target>
        </trans-unit>
        <trans-unit id="a957e6b089e86c3afa609e7f79243914d473cc8f" translate="yes" xml:space="preserve">
          <source>So now we have two &quot;at&quot; lines. The first one is for this line:</source>
          <target state="translated">이제 두 개의 &quot;at&quot;줄이 있습니다. 첫 번째는이 줄입니다.</target>
        </trans-unit>
        <trans-unit id="ad6c8b1add16d8acb60150ed283087c1e312a08e" translate="yes" xml:space="preserve">
          <source>So what about our second scenario? Well, we can see that &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, so that means that &lt;code&gt;foo[1]&lt;/code&gt; must be &lt;code&gt;null&lt;/code&gt;. Is that possible?</source>
          <target state="translated">두 번째 시나리오는 어떻습니까? &lt;code&gt;pos&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 이라는 것을 알 수 있습니다. 따라서 &lt;code&gt;foo[1]&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이어야합니다. 가능합니까?</target>
        </trans-unit>
        <trans-unit id="edded83678c3da726f6a8903ea8346cc771eea21" translate="yes" xml:space="preserve">
          <source>So where did that &lt;code&gt;null&lt;/code&gt; come from? In this case it is obvious, and it is obvious what we need to do to fix it. (Assign a non-null value to &lt;code&gt;foo&lt;/code&gt;.)</source>
          <target state="translated">그래서 그 &lt;code&gt;null&lt;/code&gt; 은 어디서 왔습니까? 이 경우에는 분명하며이를 해결하기 위해해야 ​​할 일이 분명합니다. 널이 아닌 값을 &lt;code&gt;foo&lt;/code&gt; 에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="4b796033ff61d122122d65b5810f1c0b31a4da7c" translate="yes" xml:space="preserve">
          <source>So you have a &lt;code&gt;NullPointerException&lt;/code&gt;. How do you fix it? Let's take a simple example which throws a &lt;code&gt;NullPointerException&lt;/code&gt;:</source>
          <target state="translated">따라서 &lt;code&gt;NullPointerException&lt;/code&gt; 이 있습니다. 어떻게 고치나요? &lt;code&gt;NullPointerException&lt;/code&gt; 을 발생시키는 간단한 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="3a73c967d00d54d26fc9adb9c9ba33d3cc383d28" translate="yes" xml:space="preserve">
          <source>Sonar with findbugs can detect NPE.
&lt;a href=&quot;https://stackoverflow.com/questions/20899931/can-sonar-catch-null-pointer-exceptions-caused-by-jvm-dynamically&quot;&gt;Can sonar catch null pointer exceptions caused by JVM Dynamically&lt;/a&gt;</source>
          <target state="translated">findbugs가있는 수중 음파 탐지기는 NPE를 감지 할 수 있습니다. &lt;a href=&quot;https://stackoverflow.com/questions/20899931/can-sonar-catch-null-pointer-exceptions-caused-by-jvm-dynamically&quot;&gt;JVM에서 동적으로 발생하는 소나 포인터에서 널 포인터 예외를 포착 할 수 있음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b3f0dcd539c143def5976a02527992145f3bd87" translate="yes" xml:space="preserve">
          <source>Suppose that I compile and run the program above:</source>
          <target state="translated">위의 프로그램을 컴파일하고 실행한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="fc52468f6c93bbc71a7e83fc6a1c10802582b2cc" translate="yes" xml:space="preserve">
          <source>Taking the length of &lt;code&gt;null&lt;/code&gt; as if it were an array.</source>
          <target state="translated">배열 인 것처럼 &lt;code&gt;null&lt;/code&gt; 길이를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7a05060b85348fb26d1541414ea261fc8549ebe" translate="yes" xml:space="preserve">
          <source>Taking the length of null as if it were an array.</source>
          <target state="translated">배열 인 것처럼 널 길이를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="70e38b9cf4b5f335ee765ffbb4c9d75eed7a25c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullPointerException&lt;/code&gt; occurs when you declare a variable but did not create an object and assign to the variable before trying to use the contents of the variable (called &lt;em&gt;dereferencing&lt;/em&gt;). So you are pointing to something that does not actually exist.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; 은 변수를 선언했지만 변수의 내용을 사용하기 전에 객체를 만들고 변수에 할당하지 않은 경우 ( &lt;em&gt;역 참조&lt;/em&gt; 라고 함) 발생합니다. 실제로 존재하지 않는 것을 가리키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd2a758bfbc7c2e200907cb43a178174a1ef438" translate="yes" xml:space="preserve">
          <source>The below code gives you a null pointer exception.</source>
          <target state="translated">아래 코드는 널 포인터 예외를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5afcbf74c6133d5e8acb0880821ac443b031db8d" translate="yes" xml:space="preserve">
          <source>The first line declares a variable named &lt;code&gt;num&lt;/code&gt;, but it does not actually contain a primitive value yet. Instead, it contains a pointer (because the type is &lt;code&gt;Integer&lt;/code&gt; which is a reference type). Since you have not yet said what to point to, Java sets it to &lt;code&gt;null&lt;/code&gt;, which means &quot;&lt;strong&gt;I am pointing to &lt;em&gt;nothing&lt;/em&gt;&lt;/strong&gt;&quot;.</source>
          <target state="translated">첫 번째 줄은 &lt;code&gt;num&lt;/code&gt; 이라는 변수를 선언하지만 실제로는 기본 값을 포함하지 않습니다. 대신 포인터가 포함됩니다 (유형이 참조 유형 인 &lt;code&gt;Integer&lt;/code&gt; 이므로). 무엇을 가리킬 지 아직 말하지 않았기 때문에, Java는 이것을 &quot; &lt;strong&gt;널링 &lt;em&gt;하지 않습니다&lt;/em&gt;&lt;/strong&gt; &quot;를 의미하는 &lt;code&gt;null&lt;/code&gt; 로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="94ff3f2d90b51f92f5a22e77c70e18165e13575b" translate="yes" xml:space="preserve">
          <source>The first line of the stack trace tells you a number of things:</source>
          <target state="translated">스택 추적의 첫 번째 줄은 여러 가지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="11b1b8cb1b03ae2aa5fe1b9dc487442dbfdff843" translate="yes" xml:space="preserve">
          <source>The first step is identifying exactly &lt;em&gt;which values are causing the exception&lt;/em&gt;. For this, we need to do some debugging. It's important to learn to read a &lt;em&gt;stacktrace&lt;/em&gt;. This will show you where the exception was thrown:</source>
          <target state="translated">첫 번째 단계는 &lt;em&gt;예외를 일으키는 값을&lt;/em&gt; 정확히 식별하는 것 &lt;em&gt;입니다&lt;/em&gt; . 이를 위해서는 디버깅이 필요합니다. &lt;em&gt;stacktrace&lt;/em&gt; 를 읽는 법을 배우는 것이 중요합니다. 예외가 발생한 위치가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f86a6ec7cb1a7454d5e5706d38263349a9ab618" translate="yes" xml:space="preserve">
          <source>The object lives in the VM memory space and the only way to access it is using &lt;code&gt;this&lt;/code&gt; references. Take this example:</source>
          <target state="translated">객체는 VM 메모리 공간에 있으며 액세스 할 수있는 유일한 방법은 &lt;code&gt;this&lt;/code&gt; 참조를 사용 하는 것입니다. 이 예제를 보자 :</target>
        </trans-unit>
        <trans-unit id="e2b9b98cc8af92a275b3f463db51d343e34aca5d" translate="yes" xml:space="preserve">
          <source>The second line is the most important one in diagnosing an NPE.</source>
          <target state="translated">두 번째 줄은 NPE 진단에서 가장 중요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="200bc558e7d3cbedcdab6266531c26406b51859d" translate="yes" xml:space="preserve">
          <source>The variable can have a &lt;em&gt;default value&lt;/em&gt; (and &lt;code&gt;setName&lt;/code&gt; can prevent it being set to null):</source>
          <target state="translated">변수는 &lt;em&gt;기본값을&lt;/em&gt; 가질 수 있습니다 (그리고 &lt;code&gt;setName&lt;/code&gt; 은 null로 설정되지 않도록 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="a42f342c5074f18b2ee8c62146f8c92dc81607f4" translate="yes" xml:space="preserve">
          <source>There are many ways that you could use a &lt;code&gt;null&lt;/code&gt; value that will result in a &lt;code&gt;NullPointerException&lt;/code&gt;. In fact, the only things that you &lt;em&gt;can&lt;/em&gt; do with a &lt;code&gt;null&lt;/code&gt; without causing an NPE are:</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; 을 발생시키는 &lt;code&gt;null&lt;/code&gt; 값을 사용하는 방법에는 여러 가지가 있습니다. 실제로 NPE를 발생시키지 않고 &lt;code&gt;null&lt;/code&gt; 로 수행 할 &lt;em&gt;수&lt;/em&gt; 있는 유일한 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87a50685fb8181533a1a38415f42609ffed3b6b7" translate="yes" xml:space="preserve">
          <source>This an important thing to know - when there are no more references to an object (in the example above when &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;otherReference&lt;/code&gt; both point to null) then the object is &quot;unreachable&quot;. There is no way we can work with it, so this object is ready to be garbage collected, and at some point, the VM will free the memory used by this object and will allocate another.</source>
          <target state="translated">이것은 알아야 할 중요한 사항입니다. 객체에 대한 참조가 더 이상없는 경우 (위의 예에서 &lt;code&gt;reference&lt;/code&gt; 와 &lt;code&gt;otherReference&lt;/code&gt; 가 모두 null을 가리키는 경우) 해당 객체는 &quot;도달 할 수 없습니다&quot;. 작업 할 수있는 방법이 없으므로이 개체는 가비지 수집 될 준비가되어 있으며 어느 시점에서 VM은이 개체가 사용하는 메모리를 해제하고 다른 개체를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="4027f6004fa781ce93560b2dd9d73f25224a03bd" translate="yes" xml:space="preserve">
          <source>This is enough to give us a solution: add a call to &lt;code&gt;printer.setName()&lt;/code&gt; before calling &lt;code&gt;printer.print()&lt;/code&gt;.</source>
          <target state="translated">이것은 우리에게 해결책을 제공하기에 충분합니다. &lt;code&gt;printer.setName()&lt;/code&gt; 를 호출하기 전에 printer.setName () 을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="0ca84ac3076d9c11cfc10289571d11019273ee9b" translate="yes" xml:space="preserve">
          <source>This is the hard part. The short answer is to apply logical inference to the evidence provided by the stack trace, the source code and the relevant API documentation.</source>
          <target state="translated">어려운 부분입니다. 짧은 대답은 스택 추적, 소스 코드 및 관련 API 설명서에서 제공 한 증거에 논리적 추론을 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7676e926601728e6f60a78aa4a791254b0dcaa71" translate="yes" xml:space="preserve">
          <source>This tells us a number of things:</source>
          <target state="translated">이것은 우리에게 많은 것들을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c54f75a574b2c4fd91cac2f701399ef8dfb71a73" translate="yes" xml:space="preserve">
          <source>Throwing &lt;code&gt;null&lt;/code&gt; as if it were a Throwable value.</source>
          <target state="translated">Throwable 값인 것처럼 &lt;code&gt;null&lt;/code&gt; 을 던집니다.</target>
        </trans-unit>
        <trans-unit id="07a54638a8e2bc759d8cf4b233a15f1d6bf23eb7" translate="yes" xml:space="preserve">
          <source>Throwing null as if it were a Throwable value.</source>
          <target state="translated">Throwable 값인 것처럼 null을 던집니다.</target>
        </trans-unit>
        <trans-unit id="619270eb9d34c9bc6746a84f38e87b07725f7c5b" translate="yes" xml:space="preserve">
          <source>Thrown when an application attempts to use null in a case where an
  object is required. These include:</source>
          <target state="translated">객체가 필요한 경우 응용 프로그램에서 null을 사용하려고하면 발생합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d45e625248d1bd8fbefc6c9c54d4c25071618a70" translate="yes" xml:space="preserve">
          <source>Use annotations &lt;a href=&quot;https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/NotNull.html&quot;&gt;&lt;code&gt;@NotNull&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://javadoc.io/static/com.github.spotbugs/spotbugs-annotations/3.1.12/edu/umd/cs/findbugs/annotations/Nullable.html&quot;&gt;&lt;code&gt;@Nullable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/NotNull.html&quot;&gt; &lt;code&gt;@NotNull&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://javadoc.io/static/com.github.spotbugs/spotbugs-annotations/3.1.12/edu/umd/cs/findbugs/annotations/Nullable.html&quot;&gt; &lt;code&gt;@Nullable&lt;/code&gt; &lt;/a&gt; 주석 사용</target>
        </trans-unit>
        <trans-unit id="3a45ab3058a4a8d1f2705a89ea1c87802cd3caa9" translate="yes" xml:space="preserve">
          <source>Use equals with a known object first: &lt;code&gt;if(&quot;knownObject&quot;.equals(unknownObject)&lt;/code&gt;</source>
          <target state="translated">먼저 알려진 객체와 같음 사용 : &lt;code&gt;if(&quot;knownObject&quot;.equals(unknownObject)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c9a4702b1c2baf074df6f4b2f4056e68b58c6b2" translate="yes" xml:space="preserve">
          <source>Use null safe &lt;a href=&quot;https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html&quot;&gt;&lt;code&gt;StringUtils&lt;/code&gt;&lt;/a&gt; methods &lt;code&gt;StringUtils.isEmpty(null)&lt;/code&gt;.</source>
          <target state="translated">null 안전 &lt;a href=&quot;https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html&quot;&gt; &lt;code&gt;StringUtils&lt;/code&gt; &lt;/a&gt; 메서드를 사용합니다. &lt;code&gt;StringUtils.isEmpty(null)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7aac8f8901568e201b480a0f51d1e38bd4e704" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;final&lt;/code&gt; modifier to enforce good initialization.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 수정자를 사용하여 양호한 초기화를 시행하십시오.</target>
        </trans-unit>
        <trans-unit id="5571a8c84a86d2b329356c5ece6f990e0c2ee9e8" translate="yes" xml:space="preserve">
          <source>Well, if that happened, the stack trace would look different. The first &quot;at&quot; line would say that the exception was thrown in some line in the &lt;code&gt;java.lang.String&lt;/code&gt; class, and line 4 of &lt;code&gt;Test.java&lt;/code&gt; would be the second &quot;at&quot; line.</source>
          <target state="translated">이런 일이 발생하면 스택 추적이 다르게 보일 것입니다. 첫 번째 &quot;at&quot;행은 예외가 &lt;code&gt;java.lang.String&lt;/code&gt; 클래스의 일부 행에서 발생했으며 &lt;code&gt;Test.java&lt;/code&gt; 의 4 행은 두 번째 &quot;at&quot;행이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ea8cb4ce3fa7d8910d932e12186ed6c797ff3eb" translate="yes" xml:space="preserve">
          <source>What are Null Pointer Exceptions (&lt;code&gt;java.lang.NullPointerException&lt;/code&gt;) and what causes them?</source>
          <target state="translated">널 포인터 예외 ( &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; ) 란 무엇이며 원인은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a23e7c7dd6bd4a210d09c8c4d18ed8b71c338010" translate="yes" xml:space="preserve">
          <source>What is a NullPointerException, and how do I fix it</source>
          <target state="translated">NullPointerException은 무엇이며 어떻게 해결합니까?</target>
        </trans-unit>
        <trans-unit id="fd79d84a8b29d705a7298fe1cdcfa64995856eae" translate="yes" xml:space="preserve">
          <source>What is a NullPointerException?</source>
          <target state="translated">NullPointerException은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0edb28c818192a20185dc07fb4a9521f4d21afac" translate="yes" xml:space="preserve">
          <source>What methods/tools can be used to determine the cause so that you stop
  the exception from causing the program to terminate prematurely?</source>
          <target state="translated">프로그램이 조기에 종료되지 않도록 예외를 막기 위해 원인을 판별하기 위해 어떤 방법 / 도구를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="045d1c645b9d61717b1c4818404fbc1b9d0fe6eb" translate="yes" xml:space="preserve">
          <source>When you attempt to execute one object method, the reference asks the living object to execute that method. But if the reference is referencing NULL (nothing, zero, void, nada)  then there is no way the method gets executed. Then the runtime let you know this by throwing a NullPointerException.</source>
          <target state="translated">하나의 객체 메소드를 실행하려고하면 참조는 살아있는 객체에 해당 메소드를 실행하도록 요청합니다. 그러나 참조가 NULL (nothing, zero, void, nada)을 참조하는 경우 메소드를 실행할 방법이 없습니다. 그런 다음 런타임은 NullPointerException을 발생시켜 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b38b6a98cef1c3244acc9814b85d017efbbe9ca2" translate="yes" xml:space="preserve">
          <source>When you declare a reference variable (i.e. an object) you are really creating a pointer to an object. Consider the following code where you declare a variable of primitive type &lt;code&gt;int&lt;/code&gt;:</source>
          <target state="translated">참조 변수 (즉, 객체)를 선언하면 실제로 객체에 대한 포인터를 만듭니다. 기본 유형 &lt;code&gt;int&lt;/code&gt; 의 변수를 선언하는 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="971a4d1346f3c7ff4aec8932ef90985736642518" translate="yes" xml:space="preserve">
          <source>Where does &lt;code&gt;bar&lt;/code&gt; come from? It is a parameter to the &lt;code&gt;test&lt;/code&gt; method call, and if we look at how &lt;code&gt;test&lt;/code&gt; was called, we can see that it comes from the &lt;code&gt;foo&lt;/code&gt; static variable. In addition, we can see clearly that we initialized &lt;code&gt;foo&lt;/code&gt; to a non-null value.  That is sufficient to tentatively dismiss this explanation. (In theory, something else could &lt;em&gt;change&lt;/em&gt;&lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; ... but that is not happening here.)</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; 는 어디에서 왔습니까? &lt;code&gt;test&lt;/code&gt; 메소드 호출에 대한 매개 변수이며, 테스트 호출 방식을 살펴보면 &lt;code&gt;foo&lt;/code&gt; 정적 변수에서 비롯된 것을 확인할 수 있습니다. 또한 &lt;code&gt;foo&lt;/code&gt; 가 null이 아닌 값으로 초기화되었음을 분명히 알 수 있습니다. 그것은이 설명을 잠정적으로 기각하기에 충분합니다. (이론적으로, 다른 것이 &lt;code&gt;foo&lt;/code&gt; 를 &lt;code&gt;null&lt;/code&gt; 로 &lt;em&gt;바꿀&lt;/em&gt; 수는 있지만 여기서는 일어나지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8734be1e4922d39775902ac36f9de454e8f5cd18" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;this.name&lt;/code&gt; set? In the &lt;code&gt;setName(String)&lt;/code&gt; method. With some more debugging, we can see that this method isn't called at all. If the method was called, make sure to check the &lt;em&gt;order&lt;/em&gt; that these methods are called, and the set method isn't called &lt;em&gt;after&lt;/em&gt; the print method.</source>
          <target state="translated">&lt;code&gt;this.name&lt;/code&gt; 은 어디에 설정되어 있습니까? &lt;code&gt;setName(String)&lt;/code&gt; 메소드에서. 좀 더 디버깅하면이 메소드가 전혀 호출되지 않음을 알 수 있습니다. 메소드가 호출 된 경우 이러한 메소드가 호출 된 &lt;em&gt;순서&lt;/em&gt; 를 확인하고 set 메소드가 print 메소드 &lt;em&gt;이후&lt;/em&gt; 에 호출되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="706f4059c0a82014b57c44cebf4ce048cfdc2bda" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;must&lt;/em&gt; initialize the elements in the array &lt;em&gt;before&lt;/em&gt; accessing or dereferencing them.</source>
          <target state="translated">액세스하거나 역 참조 &lt;em&gt;하기 전에&lt;/em&gt; 배열의 요소를 초기화 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c84e0b49f0f58904617fb6abbab17f59ee3f10cf" translate="yes" xml:space="preserve">
          <source>Your reference is &quot;pointing&quot; to null, thus &quot;Null -&amp;gt; Pointer&quot;.</source>
          <target state="translated">참조는 &quot;포인팅&quot;을 null로 지정하므로 &quot;Null-&amp;gt; 포인터&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b2766c956c0871691da99343bea9fdce861530cc" translate="yes" xml:space="preserve">
          <source>and the second one is for this line:</source>
          <target state="translated">두 번째는이 줄입니다.</target>
        </trans-unit>
        <trans-unit id="2b6f2c4a758bdfa568fbd16a03a6270d7b0cb1d4" translate="yes" xml:space="preserve">
          <source>assign it to a reference variable or read it from a reference variable,</source>
          <target state="translated">참조 변수에 지정하거나 참조 변수에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4794f1fa5f6182550ad52c39225ba650ca2c5cac" translate="yes" xml:space="preserve">
          <source>assign it to an array element or read it from an array element (provided that array reference itself is non-null!),</source>
          <target state="translated">배열 요소에 할당하거나 배열 요소에서 읽습니다 (배열 참조 자체가 null이 아닌 경우).</target>
        </trans-unit>
        <trans-unit id="fea64947f3e1c19acb6fae94b6a25dd469358299" translate="yes" xml:space="preserve">
          <source>pass it as a parameter or return it as a result, or</source>
          <target state="translated">매개 변수로 전달하거나 결과로 리턴하거나</target>
        </trans-unit>
        <trans-unit id="60ce2f688c217a588196b5698debb2b0bed8b3dc" translate="yes" xml:space="preserve">
          <source>test it using the &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; operators, or &lt;code&gt;instanceof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 연산자 또는 &lt;code&gt;instanceof&lt;/code&gt; 를 사용하여 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="48dd492845e5923b030e505964695a889432ed8e" translate="yes" xml:space="preserve">
          <source>the statement labelled &quot;HERE&quot; is going to attempt to run the &lt;code&gt;length()&lt;/code&gt; method on a &lt;code&gt;null&lt;/code&gt; reference, and this will throw a &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">&quot;HERE&quot;로 표시된 명령문은 &lt;code&gt;null&lt;/code&gt; 참조에서 &lt;code&gt;length()&lt;/code&gt; 메소드를 실행하려고 시도하며 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c5c707c98218e538788fb9a4baa24f7af56308cd" translate="yes" xml:space="preserve">
          <source>we allocate a &lt;code&gt;String[]&lt;/code&gt; with two elements &lt;em&gt;that are initialized to &lt;code&gt;null&lt;/code&gt;&lt;/em&gt;. After that, we have not changed the contents of &lt;code&gt;foo&lt;/code&gt; ... so &lt;code&gt;foo[1]&lt;/code&gt; will still be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;null&lt;/code&gt; 로 초기화 된&lt;/em&gt; 두 개의 요소 &lt;em&gt;를&lt;/em&gt; 가진 &lt;code&gt;String[]&lt;/code&gt; 을 할당합니다. 그 후에, 우리는 &lt;code&gt;foo&lt;/code&gt; 의 내용을 변경하지 않았습니다. 그래서 &lt;code&gt;foo[1]&lt;/code&gt; 은 여전히 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
