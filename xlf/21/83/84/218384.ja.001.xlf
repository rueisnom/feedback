<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/218384">
    <body>
      <group id="218384">
        <trans-unit id="46c79bb66ada9c56c9356e3a5d4614b774e8bdc4" translate="yes" xml:space="preserve">
          <source>&quot;Test.java:4&quot; gives the source filename of the class, AND it tells us that the statement where this occurred is in line 4 of the file.</source>
          <target state="translated">&quot;Test.java:4&quot; は、クラスのソース・ファイル名を示し、そのファイルの 4 行目にあるステートメントが発生していることを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="f8604be0c3c1ed69f32edb319a462c6359c0f2ff" translate="yes" xml:space="preserve">
          <source>&quot;at Test.main&quot; says that we were in the &lt;code&gt;main&lt;/code&gt; method of the &lt;code&gt;Test&lt;/code&gt; class.</source>
          <target state="translated">「at Test.main」は、 &lt;code&gt;Test&lt;/code&gt; クラスの &lt;code&gt;main&lt;/code&gt; メソッドにいたことを示しています。</target>
        </trans-unit>
        <trans-unit id="12c1a4fa7b528e612a2c55a656eae759beb053c2" translate="yes" xml:space="preserve">
          <source>(This is a technicality, but I think it bears mentioning: A reference that points to null isn't the same as a C pointer that points to an invalid memory location.  A null pointer is literally not pointing &lt;em&gt;anywhere&lt;/em&gt;, which is subtly different than pointing to a location that happens to be invalid.)</source>
          <target state="translated">（これは技術的ですが、私は言及に値すると思います：nullを指す参照は、無効なメモリ位置を指すCポインターと同じではありません。nullポインターは、文字通り&lt;em&gt;どこも&lt;/em&gt;指していません。たまたま無効な場所を指している。）</target>
        </trans-unit>
        <trans-unit id="3728b911d50de4ab1fcf39dee7550bebda59d186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullPointerException&lt;/code&gt;s are exceptions that occur when you try to use a reference that points to no location in memory (null) as though it were referencing an object.  Calling a method on a null reference or trying to access a field of a null reference will trigger a &lt;code&gt;NullPointerException&lt;/code&gt;.  These are the most common, but other ways are listed on the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; javadoc page.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; は、オブジェクトを参照しているかのように、メモリ内の場所がないことを示す参照（null）を使用しようとすると発生する例外です。 null参照でメソッドを呼び出すか、null参照のフィールドにアクセスしようとすると、 &lt;code&gt;NullPointerException&lt;/code&gt; がトリガーされます。 これらは最も一般的ですが、他の方法は&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; javadocページにリストされています。</target>
        </trans-unit>
        <trans-unit id="49dafbcd2fe39c57babb5928a1f4a08427635d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Identify the null values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;null値を特定する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="551e0b7660ec60a1ba024654ebf85dd6e11ea8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See also:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;以下も参照してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7654b80f753ecf9a584b54f4799cf0bb000071db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trace where these values come from&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これらの値の出所を追跡する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2bed1aff07e6c53e21f30814c172aaa955a67f89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trace where these values should be set&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これらの値を設定する必要がある場所をトレースする&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2d6017504b728ef2dbcbb062072c2f986d225f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1 - Not quite true. There are things called nested exceptions...&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1-まったく正しくない。&lt;/sup&gt; &lt;sup&gt;ネストされた例外と呼ばれるものがあります...&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="09098c16c787fffa3d5bef267be27f9b94eec756" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;This particular NPE can be avoided if the comparison order is reversed; namely, use &lt;code&gt;.equals&lt;/code&gt; on a guaranteed non-null object.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;この特定のNPEは、比較順序を逆にすれば回避できます。&lt;/sup&gt; &lt;sup&gt;つまり、保証されたnull以外のオブジェクトで &lt;code&gt;.equals&lt;/code&gt; を使用します。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="230dd3a64393775192474761fa0c5cca37186f78" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NullPointerException&lt;/code&gt; is thrown at runtime whenever your program attempts to use a &lt;code&gt;null&lt;/code&gt; as if it was a real reference. For example, if you write this:</source>
          <target state="translated">プログラムが &lt;code&gt;null&lt;/code&gt; を実際の参照であるかのように使用しようとすると、実行時に &lt;code&gt;NullPointerException&lt;/code&gt; がスローされます。 たとえば、次のように記述したとします。</target>
        </trans-unit>
        <trans-unit id="a9e0552c7dd394c9a31c99c24d2f880c9a4d06fd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;null&lt;/code&gt; pointer is one that points to nowhere.  When you dereference a pointer &lt;code&gt;p&lt;/code&gt;, you say &quot;give me the data at the location stored in &quot;p&quot;.  When &lt;code&gt;p&lt;/code&gt; is a &lt;code&gt;null&lt;/code&gt; pointer, the location stored in &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;nowhere&lt;/code&gt;, you're saying &quot;give me the data at the location 'nowhere'&quot;.  Obviously, it can't do this, so it throws a &lt;code&gt;null pointer exception&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; ポインターは、どこも指し示していないポインターです。 ポインター &lt;code&gt;p&lt;/code&gt; を逆参照すると、「pに格納されている場所にデータを与えてください &lt;code&gt;p&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; ポインターの場合、 &lt;code&gt;p&lt;/code&gt; に格納されている場所は &lt;code&gt;nowhere&lt;/code&gt; ありません。 'nowhere' &quot;です。明らかに、これは実行できないため、 &lt;code&gt;null pointer exception&lt;/code&gt; スローされます 。</target>
        </trans-unit>
        <trans-unit id="d6c4c5d7a89d4a6783980274bfbadea09013a5b5" translate="yes" xml:space="preserve">
          <source>A good place to start is the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;JavaDocs&lt;/a&gt;. They have this covered:</source>
          <target state="translated">まず、 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;JavaDocs&lt;/a&gt;から始めてください 。 彼らはこれをカバーしています：</target>
        </trans-unit>
        <trans-unit id="2e2d1cdef73de0035e0ec0fce5be6a96a237140d" translate="yes" xml:space="preserve">
          <source>A lot of explanations are already present to explain how it happens and how to fix it, but you should also follow &lt;strong&gt;best practices&lt;/strong&gt; to avoid &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt;s at all.</source>
          <target state="translated">どのように発生し、どのように修正するかを説明するために、すでに多くの説明が存在しますが、 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt;をまったく回避するための&lt;strong&gt;ベストプラクティス&lt;/strong&gt;に従う必要もあります。</target>
        </trans-unit>
        <trans-unit id="638d693f2f038480214d58b990af25de39a3580e" translate="yes" xml:space="preserve">
          <source>A null pointer exception is an indicator that you are using an object without initializing it.</source>
          <target state="translated">ヌルポインタ例外は、オブジェクトを初期化せずに使用していることを示す指標です。</target>
        </trans-unit>
        <trans-unit id="b54dde997bbaa1c77cec63081960af235d128fa6" translate="yes" xml:space="preserve">
          <source>A null pointer exception is thrown when an application attempts to use null in a case where an object is required. These include:</source>
          <target state="translated">オブジェクトが必要な場合にアプリケーションがNULLを使用しようとすると、NULLポインタ例外がスローされます。これには次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="63cfcf1fbbdb802eace27ba6ed8669bc6cd6c3d1" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the field of a &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; オブジェクトのフィールドへのアクセスまたは変更。</target>
        </trans-unit>
        <trans-unit id="7bec35c01df22161ef1985731a3e114df5d788b9" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the field of a null object.</source>
          <target state="translated">null オブジェクトのフィールドにアクセスまたは変更します。</target>
        </trans-unit>
        <trans-unit id="081b055d444278a91fcdc52fd056525afd4590b2" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the slots of &lt;code&gt;null&lt;/code&gt; as if it were an array.</source>
          <target state="translated">配列であるかのように &lt;code&gt;null&lt;/code&gt; のスロットにアクセスまたは変更する。</target>
        </trans-unit>
        <trans-unit id="3071a717183323279cc12121c92bbf3a0674c2d0" translate="yes" xml:space="preserve">
          <source>Accessing or modifying the slots of null as if it were an array.</source>
          <target state="translated">配列であるかのようにNULLのスロットにアクセスしたり、変更したりします。</target>
        </trans-unit>
        <trans-unit id="3c82e5aec8823b4eada017e77cc5f6f29a9a4682" translate="yes" xml:space="preserve">
          <source>All elements inside of an array &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5&quot;&gt;are initialized to their common initial value&lt;/a&gt;; for any type of object array, that means that all elements are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">配列内のすべての要素は、 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5&quot;&gt;共通の初期値に初期化されます&lt;/a&gt; 。 どのタイプのオブジェクト配列でも、すべての要素が &lt;code&gt;null&lt;/code&gt; であることを意味します 。</target>
        </trans-unit>
        <trans-unit id="d5256dfc3f6349ad33fe733f72303dfc4540eb37" translate="yes" xml:space="preserve">
          <source>Alternatively, there may be cases where the purpose of the method is not solely to operate on the passed in object, and therefore a null parameter may be acceptable. In this case, you would need to check for a &lt;strong&gt;null parameter&lt;/strong&gt; and behave differently. You should also explain this in the documentation. For example, &lt;code&gt;doSomething()&lt;/code&gt; could be written as:</source>
          <target state="translated">あるいは、メソッドの目的が、渡されたオブジェクトを操作することだけではない場合があり、そのためnullパラメータが許容される場合があります。 この場合、 &lt;strong&gt;nullパラメータ&lt;/strong&gt;をチェックして、異なる動作をする必要があり&lt;strong&gt;ます&lt;/strong&gt; 。 ドキュメントでもこれを説明する必要があります。 たとえば、 &lt;code&gt;doSomething()&lt;/code&gt; は次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="c610b12b0bdb7da0de89b6112dad5051859e5f8a" translate="yes" xml:space="preserve">
          <source>And on another place in your code:</source>
          <target state="translated">そして、あなたのコードの別の場所に</target>
        </trans-unit>
        <trans-unit id="fec17b583e2fe54653432fe84eafb118f367f489" translate="yes" xml:space="preserve">
          <source>Another occurrence of a &lt;code&gt;NullPointerException&lt;/code&gt; occurs when one declares an object array, then immediately tries to dereference elements inside of it.</source>
          <target state="translated">別の &lt;code&gt;NullPointerException&lt;/code&gt; が発生するのは、オブジェクト配列を宣言した直後に、その内部の要素を逆参照しようとした場合です。</target>
        </trans-unit>
        <trans-unit id="ec98bf54606e720fcaaa69af937b822723782a2b" translate="yes" xml:space="preserve">
          <source>Applications should throw instances of this class to indicate other
  illegal uses of the null object.</source>
          <target state="translated">アプリケーションはこのクラスのインスタンスをスローして、NULL オブジェクトの他の不正な使用を示す必要があります。</target>
        </trans-unit>
        <trans-unit id="bc2a7a3d52ad00a39aa87d3ee50b3aaad37ba8df" translate="yes" xml:space="preserve">
          <source>Applications should throw instances of this class to indicate other illegal uses of the &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">アプリケーションは、このクラスのインスタンスをスローして、 &lt;code&gt;null&lt;/code&gt; オブジェクトの他の不正な使用を示す必要があります 。</target>
        </trans-unit>
        <trans-unit id="3bb9c94bc952d51ad045ffee95f408bcacb6ca66" translate="yes" xml:space="preserve">
          <source>As you should know, Java types are divided into &lt;em&gt;primitive types&lt;/em&gt; (&lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, etc.) and &lt;em&gt;reference types&lt;/em&gt;. Reference types in Java allow you to use the special value &lt;code&gt;null&lt;/code&gt; which is the Java way of saying &quot;no object&quot;.</source>
          <target state="translated">ご存じのとおり、Javaの型は&lt;em&gt;プリミティブ型&lt;/em&gt; （ &lt;code&gt;boolean&lt;/code&gt; 、 &lt;code&gt;int&lt;/code&gt; など）と&lt;em&gt;参照型に&lt;/em&gt;分けられ&lt;em&gt;ます&lt;/em&gt; 。 Javaの参照型を使用すると、Javaで「オブジェクトなし」と言う特別な値 &lt;code&gt;null&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="56bc238aac80b83b0ad417696ff3ad35156f1e99" translate="yes" xml:space="preserve">
          <source>At this time you have just &lt;strong&gt;declared&lt;/strong&gt; this object but not &lt;strong&gt;initialized or instantiated&lt;/strong&gt;. And whenever you try to access any property or method in it, it will throw  &lt;code&gt;NullPointerException&lt;/code&gt; which makes sense.</source>
          <target state="translated">この時点で、このオブジェクトを&lt;strong&gt;宣言し&lt;/strong&gt;ましたが、 &lt;strong&gt;初期化またはインスタンス化して&lt;/strong&gt;いません。 そして、その中のプロパティやメソッドにアクセスしようとすると、 &lt;code&gt;NullPointerException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="c3ca15f5dab40cddc958cc899caa21a2ead819af" translate="yes" xml:space="preserve">
          <source>Avoid returning null in methods, for example returning empty collections when applicable.</source>
          <target state="translated">該当する場合は空のコレクションを返すなど、メソッドでnullを返さないようにします。</target>
        </trans-unit>
        <trans-unit id="5bf95245956d03bfda307dee31c95faa928638e7" translate="yes" xml:space="preserve">
          <source>Avoiding &amp;ldquo;!= null&amp;rdquo; statements in Java?</source>
          <target state="translated">Javaで「！= null」ステートメントを回避しますか？</target>
        </trans-unit>
        <trans-unit id="e712d8332074c0bc1572f647f4af0f2ae63f7453" translate="yes" xml:space="preserve">
          <source>Because you are using &lt;code&gt;student&lt;/code&gt;, but you forgot to initialize it like in the
correct code shown below:</source>
          <target state="translated">&lt;code&gt;student&lt;/code&gt; を使用しているが、以下に示す正しいコードのように初期化するのを忘れたため。</target>
        </trans-unit>
        <trans-unit id="b92e2b55b4354330a3c96dc3a92d018a12ff9a30" translate="yes" xml:space="preserve">
          <source>But (I hear you say) what if the NPE was thrown inside the &lt;code&gt;length()&lt;/code&gt; method call?</source>
          <target state="translated">しかし（私が言うように）、NPEが &lt;code&gt;length()&lt;/code&gt; メソッド呼び出し内でスローされた場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="70de7c517ab05f22376120259b795a5d367579bd" translate="yes" xml:space="preserve">
          <source>But, when you try to declare a reference &lt;em&gt;type&lt;/em&gt;, something different happens. Take the following code:</source>
          <target state="translated">しかし、参照&lt;em&gt;型&lt;/em&gt;を宣言しようとすると、別のことが起こります。 次のコードを見てください。</target>
        </trans-unit>
        <trans-unit id="3b760c60d971f57b8c1e7ecdfb80c460f606d442" translate="yes" xml:space="preserve">
          <source>Calling the instance method of a &lt;code&gt;null&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; オブジェクトのインスタンスメソッドを呼び出す。</target>
        </trans-unit>
        <trans-unit id="634a22d75f5bdbe844d7fa3fc013a702dcded4d8" translate="yes" xml:space="preserve">
          <source>Calling the instance method of a null object.</source>
          <target state="translated">null オブジェクトのインスタンスメソッドを呼び出す。</target>
        </trans-unit>
        <trans-unit id="2a0a9d9e68fd881b18d0b16e39eef09d5cd31ae1" translate="yes" xml:space="preserve">
          <source>Declaration: &lt;code&gt;Item item[] = new Item[5];&lt;/code&gt;</source>
          <target state="translated">宣言： &lt;code&gt;Item item[] = new Item[5];&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="019ac43ed7ec529c737b8e34b517aec2236183b6" translate="yes" xml:space="preserve">
          <source>Declaration: &lt;code&gt;Object object;&lt;/code&gt;</source>
          <target state="translated">宣言： &lt;code&gt;Object object;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c746af47b00ccd6d6e07567df1b2eaa4c74bbcd" translate="yes" xml:space="preserve">
          <source>Declare</source>
          <target state="translated">Declare</target>
        </trans-unit>
        <trans-unit id="90599a45b68a2a1c4b1602b265e701d17c3453c2" translate="yes" xml:space="preserve">
          <source>Dereferencing usually happens when using &lt;code&gt;.&lt;/code&gt; to access a method or field, or using &lt;code&gt;[&lt;/code&gt; to index an array.</source>
          <target state="translated">逆参照は通常、の使用時に発生し &lt;code&gt;.&lt;/code&gt; メソッドまたはフィールドにアクセスするか、 &lt;code&gt;[&lt;/code&gt; を使用して配列にインデックスを付けます。</target>
        </trans-unit>
        <trans-unit id="d1d4b339edce051f7810e587e0c51e16ae74146a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;printString&lt;/code&gt; method can &lt;em&gt;check for null&lt;/em&gt;, for example:</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; メソッドまたは &lt;code&gt;printString&lt;/code&gt; メソッドのいずれか&lt;em&gt;でnull&lt;/em&gt;を&lt;em&gt;確認&lt;/em&gt;でき&lt;em&gt;ます&lt;/em&gt; 。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="37aefda29876d0fc65311b06db99106714c1d07e" translate="yes" xml:space="preserve">
          <source>Fail fast and use asserts to avoid propagation of null objects through the whole application when they shouldn't be null.</source>
          <target state="translated">高速に失敗し、NULLであるべきではないときにアプリケーション全体を通してNULLオブジェクトが伝播するのを避けるためにアサートを使用します。</target>
        </trans-unit>
        <trans-unit id="c1fb00189acb7a631f566fbdba728784b7fb6217" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;https://stackoverflow.com/q/3988788/2775450&quot;&gt;How to pinpoint the exception &amp;amp; cause using Stack Trace&lt;/a&gt;</source>
          <target state="translated">最後に、 &lt;a href=&quot;https://stackoverflow.com/q/3988788/2775450&quot;&gt;スタックトレースを使用して例外と原因を特定する方法&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e523347a7b87520e096c7d1a14d92c4714f695c7" translate="yes" xml:space="preserve">
          <source>First observation: the compilation succeeds! The problem in the program is NOT a compilation error. It is a &lt;em&gt;runtime&lt;/em&gt; error. (Some IDEs may warn your program will always throw an exception ... but the standard &lt;code&gt;javac&lt;/code&gt; compiler doesn't.)</source>
          <target state="translated">最初の観察：コンパイルは成功しました！ プログラムの問題はコンパイルエラーではありません。 &lt;em&gt;実行時&lt;/em&gt;エラーです。 （一部のIDEは、プログラムが常に例外をスローすることを警告するかもしれませんが、標準の &lt;code&gt;javac&lt;/code&gt; コンパイラはそうではありません。）</target>
        </trans-unit>
        <trans-unit id="8034a9b3e958bafca5b80be28a9299b4df2a9530" translate="yes" xml:space="preserve">
          <source>For example, below is a student class which will use it in our code.</source>
          <target state="translated">例えば、以下は私たちのコードでそれを使用する学生クラスです。</target>
        </trans-unit>
        <trans-unit id="369b0266a6a685e58d0bf30452751bfdd1e0a29b" translate="yes" xml:space="preserve">
          <source>For instance, you may have a method as follows:</source>
          <target state="translated">例えば、以下のような方法があります。</target>
        </trans-unit>
        <trans-unit id="e426a7d0a0945c9b135618483f0d59c549ba4902" translate="yes" xml:space="preserve">
          <source>Here, we see that the exception is thrown on line 13 (in the &lt;code&gt;printString&lt;/code&gt; method). Look at the line and check which values are null by
adding &lt;em&gt;logging statements&lt;/em&gt; or using a &lt;em&gt;debugger&lt;/em&gt;. We find out that &lt;code&gt;s&lt;/code&gt; is null, and calling the &lt;code&gt;length&lt;/code&gt; method on it throws the exception. We can see that the program stops throwing the exception when &lt;code&gt;s.length()&lt;/code&gt; is removed from the method.</source>
          <target state="translated">ここでは、13行目（ &lt;code&gt;printString&lt;/code&gt; メソッド）で例外がスローされていることがわかります。 行を見て、 &lt;em&gt;ロギングステートメントを&lt;/em&gt;追加&lt;em&gt;する&lt;/em&gt;か、 &lt;em&gt;デバッガ&lt;/em&gt;を使用して、どの値がnullであるかを確認し&lt;em&gt;ます&lt;/em&gt; 。 &lt;code&gt;s&lt;/code&gt; がnullであることがわかり、 &lt;code&gt;length&lt;/code&gt; メソッドを呼び出すと例外がスローされます。 メソッドから &lt;code&gt;s.length()&lt;/code&gt; が削除されると、プログラムが例外のスローを停止することがわかります。</target>
        </trans-unit>
        <trans-unit id="24b11a882fed564b0eb9222ebda986752854af8c" translate="yes" xml:space="preserve">
          <source>How can that throw an NPE?</source>
          <target state="translated">どうやったらNPEを投げられるんだ?</target>
        </trans-unit>
        <trans-unit id="61b251a05ff88cf9158093feb2fc5a5c219ef28a" translate="yes" xml:space="preserve">
          <source>How do I fix it?</source>
          <target state="translated">どうやって直せばいいの?</target>
        </trans-unit>
        <trans-unit id="327df277bc05aac18f0fa7fb4e2e987135c7512d" translate="yes" xml:space="preserve">
          <source>I still can't find the problem</source>
          <target state="translated">まだ問題が見つからない</target>
        </trans-unit>
        <trans-unit id="66b032c360e09ab3e68584d1ba075e1987c06cf7" translate="yes" xml:space="preserve">
          <source>I would add, very important, make a good use of the &lt;code&gt;final&lt;/code&gt; modifier.
&lt;a href=&quot;https://stackoverflow.com/questions/137868/using-final-modifier-whenever-applicable-in-java&quot;&gt;Using the &quot;final&quot; modifier whenever applicable in Java&lt;/a&gt;</source>
          <target state="translated">非常に重要なことですが、 &lt;code&gt;final&lt;/code&gt; 修飾子を上手に利用します。 &lt;a href=&quot;https://stackoverflow.com/questions/137868/using-final-modifier-whenever-applicable-in-java&quot;&gt;Javaで該当する場合は常に「最終」修飾子を使用する&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6308f70b4f0ae15d5eb767dca1766a9e484da9fb" translate="yes" xml:space="preserve">
          <source>If the exception has an associated error message, that will be output after the exception name. &lt;code&gt;NullPointerException&lt;/code&gt; is unusual in this respect, because it rarely has an error message.</source>
          <target state="translated">例外に関連するエラーメッセージがある場合は、例外名の後に出力されます。 &lt;code&gt;NullPointerException&lt;/code&gt; はエラーメッセージがほとんどないため、この点で異常です。</target>
        </trans-unit>
        <trans-unit id="fb26238ed800420e5c53a71b6bf0a0b7a52eaeb2" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then &lt;code&gt;bar[pos]&lt;/code&gt; will throw an NPE.</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; の値が &lt;code&gt;null&lt;/code&gt; の場合、 &lt;code&gt;bar[pos]&lt;/code&gt; はNPEをスローします。</target>
        </trans-unit>
        <trans-unit id="37e77872a7e487d9afdbefdbf2345bfd255ec57b" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;bar[pos]&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; then calling &lt;code&gt;length()&lt;/code&gt; on it will throw an NPE.</source>
          <target state="translated">&lt;code&gt;bar[pos]&lt;/code&gt; の値が &lt;code&gt;null&lt;/code&gt; の場合、それに &lt;code&gt;length()&lt;/code&gt; を呼び出すとNPEがスローされます。</target>
        </trans-unit>
        <trans-unit id="2fb4addbf00588879005cb609de5d3b982823f43" translate="yes" xml:space="preserve">
          <source>If you are not giving the initialization section then the &lt;code&gt;NullPointerException&lt;/code&gt; arise.</source>
          <target state="translated">初期化セクションを指定しない場合、 &lt;code&gt;NullPointerException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="e65cd02770e6747d2781dbef1dbe7a0838997ff2" translate="yes" xml:space="preserve">
          <source>If you attempt to dereference &lt;code&gt;num&lt;/code&gt; BEFORE creating the object you get a &lt;code&gt;NullPointerException&lt;/code&gt;. In the most trivial cases, the compiler will catch the problem and let you know that &quot;&lt;code&gt;num may not have been initialized&lt;/code&gt;,&quot; but sometimes you may write code that does not directly create the object.</source>
          <target state="translated">オブジェクトを作成する前に &lt;code&gt;num&lt;/code&gt; を逆参照しようとすると、 &lt;code&gt;NullPointerException&lt;/code&gt; が発生します。 ほとんどの場合、コンパイラーが問題をキャッチし、「 &lt;code&gt;num may not have been initialized&lt;/code&gt; ていない可能性があります」と通知しますが、オブジェクトを直接作成しないコードを作成する場合があります。</target>
        </trans-unit>
        <trans-unit id="b405ab91b8fae348c65830646a2f15cfa73ec595" translate="yes" xml:space="preserve">
          <source>If you count the lines in the file above, line 4 is the one that I labeled with the &quot;HERE&quot; comment.</source>
          <target state="translated">上のファイルの行を数えてみると、4行目は「ここ」というコメントでラベルを貼ったものです。</target>
        </trans-unit>
        <trans-unit id="a3f749cff981330fc865245f1db404f2d1866f2b" translate="yes" xml:space="preserve">
          <source>If you tried to debug the problem and still don't have a solution, you can post a question for more help, but make sure to include what you've tried so far. At a minimum, &lt;strong&gt;include the stacktrace&lt;/strong&gt; in the question, and &lt;strong&gt;mark the important line numbers&lt;/strong&gt; in the code. Also, try simplifying the code first (see &lt;a href=&quot;http://sscce.org/&quot;&gt;SSCCE&lt;/a&gt;).</source>
          <target state="translated">問題をデバッグしようとしても解決策がない場合は、質問を投稿してさらにヘルプを得ることができますが、これまでに試した内容を必ず含めてください。 少なくとも、質問に&lt;strong&gt;スタックトレース&lt;/strong&gt;を&lt;strong&gt;含め&lt;/strong&gt; 、コードの&lt;strong&gt;重要な行番号&lt;/strong&gt;を&lt;strong&gt;マーク&lt;/strong&gt;します。 また、最初にコードを簡略化してみてください（ &lt;a href=&quot;http://sscce.org/&quot;&gt;SSCCEを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d37b6038f9a6cd2dff562dfe87901f623ec47b9e" translate="yes" xml:space="preserve">
          <source>If you want to use any object then you have two phases:</source>
          <target state="translated">どのようなオブジェクトでも使用したい場合、2つのフェーズがあります。</target>
        </trans-unit>
        <trans-unit id="9d544f7bccdff6bb68a69fb25d6a390dd45d80a2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Java&lt;/a&gt; all the variables you declare are actually &quot;references&quot; to the objects (or primitives) and not the objects themselves.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_%28programming_language%29&quot;&gt;Javaでは&lt;/a&gt; 、宣言するすべての変数は実際にはオブジェクト（またはプリミティブ）への「参照」であり、オブジェクト自体ではありません。</target>
        </trans-unit>
        <trans-unit id="758063698f54411c5380c94bde31ca08d17694ea" translate="yes" xml:space="preserve">
          <source>In Java, everything (excluding primitive types) is in the form of a class.</source>
          <target state="translated">Javaでは、(プリミティブ型を除く)すべてのものがクラスの形をしています。</target>
        </trans-unit>
        <trans-unit id="2d1e8941405e95d8f2a50326004d775c905ad0da" translate="yes" xml:space="preserve">
          <source>In fact there is only one way: it can only happen if &lt;code&gt;foo&lt;/code&gt; has the value &lt;code&gt;null&lt;/code&gt;.  We then try to run the &lt;code&gt;length()&lt;/code&gt; method on &lt;code&gt;null&lt;/code&gt; and .... BANG!</source>
          <target state="translated">実際には1つの方法しかありません。これは、 &lt;code&gt;foo&lt;/code&gt; の値が &lt;code&gt;null&lt;/code&gt; の場合にのみ発生します 。 次に、 &lt;code&gt;null&lt;/code&gt; および...で &lt;code&gt;length()&lt;/code&gt; メソッドを実行しようとします。</target>
        </trans-unit>
        <trans-unit id="e072b7c921ded7d305ef1e675e84ddd558ea97ee" translate="yes" xml:space="preserve">
          <source>In general, it's because something hasn't been initialized properly.</source>
          <target state="translated">一般的には、何かが正しく初期化されていないからです。</target>
        </trans-unit>
        <trans-unit id="e84992bf73e77db6c21133edfc7e60f3abe481d5" translate="yes" xml:space="preserve">
          <source>In short the stack trace will tell us unambiguously which statement of the program has thrown the NPE.</source>
          <target state="translated">要するに、スタックトレースは、プログラムのどの文がNPEを投げたかを明確に教えてくれます。</target>
        </trans-unit>
        <trans-unit id="ff129ea13cbf7d94f4945873a0e66ab25fb80786" translate="yes" xml:space="preserve">
          <source>In the second line, the &lt;code&gt;new&lt;/code&gt; keyword is used to instantiate (or create) an object of type &lt;code&gt;Integer&lt;/code&gt; and the pointer variable &lt;code&gt;num&lt;/code&gt; is assigned to that &lt;code&gt;Integer&lt;/code&gt; object.</source>
          <target state="translated">2行目では、 &lt;code&gt;new&lt;/code&gt; キーワードを使用して &lt;code&gt;Integer&lt;/code&gt; 型のオブジェクトをインスタンス化（または作成）し、ポインター変数 &lt;code&gt;num&lt;/code&gt; をその &lt;code&gt;Integer&lt;/code&gt; オブジェクトに割り当てています。</target>
        </trans-unit>
        <trans-unit id="f88263ab738c6ace334b24405051e63bb3e43df8" translate="yes" xml:space="preserve">
          <source>In this example, the variable &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; and Java will initialize it to &lt;code&gt;0&lt;/code&gt; for you. When you assign it the value of &lt;code&gt;10&lt;/code&gt; on the second line, your value of &lt;code&gt;10&lt;/code&gt; is written into the memory location referred to by &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">この例では、変数 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;int&lt;/code&gt; であり、Javaはそれを &lt;code&gt;0&lt;/code&gt; に初期化します。 2行目に値 &lt;code&gt;10&lt;/code&gt; を割り当てると、値 &lt;code&gt;10&lt;/code&gt; が &lt;code&gt;x&lt;/code&gt; によって参照されるメモリ位置に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="58e9dc951da0b9f4f2e75e6349c8988645b66556" translate="yes" xml:space="preserve">
          <source>In which case, &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. If the method is intended to do something to the passed-in object, it is appropriate to throw the &lt;code&gt;NullPointerException&lt;/code&gt; because it's a programmer error and the programmer will need that information for debugging purposes.  Please include the name of the object variable in the exception message, like</source>
          <target state="translated">その場合、 &lt;code&gt;obj&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; です。 メソッドが渡されたオブジェクトに対して何かを行うことを意図している場合、それはプログラマエラーであり、プログラマはデバッグのためにその情報を必要とするため、 &lt;code&gt;NullPointerException&lt;/code&gt; をスローすることが適切です。 次のように、例外メッセージにオブジェクト変数の名前を含めてください</target>
        </trans-unit>
        <trans-unit id="eaa842988aa6b70454294a66ea91b95dd8434276" translate="yes" xml:space="preserve">
          <source>In which case, you are not creating the object &lt;code&gt;obj&lt;/code&gt;, but rather assuming that it was created before the &lt;code&gt;doSomething()&lt;/code&gt; method was called. Note, it is possible to call the method like this:</source>
          <target state="translated">この場合、オブジェクト &lt;code&gt;obj&lt;/code&gt; を作成するのではなく、 &lt;code&gt;doSomething()&lt;/code&gt; メソッドが呼び出される前に作成されたと想定しています。 次のようにメソッドを呼び出すことが可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0ef62b29237cb984a3dfc705f60d31635eca26a1" translate="yes" xml:space="preserve">
          <source>Indeed it is! And that is the problem. When we initialize like this:</source>
          <target state="translated">確かにそうだ!そしてそれが問題なのです。このように初期化すると</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="dd695f048156244b311843d310329edc10ad3530" translate="yes" xml:space="preserve">
          <source>Initialization: &lt;code&gt;item[0] = new Item();&lt;/code&gt;</source>
          <target state="translated">初期化： &lt;code&gt;item[0] = new Item();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa4a5d2f4df0ef578634d30eb2c60e497f43b6cf" translate="yes" xml:space="preserve">
          <source>Initialization: &lt;code&gt;object = new Object();&lt;/code&gt;</source>
          <target state="translated">初期化： &lt;code&gt;object = new Object();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1926c212a3dc9c16b0c0d64823cf41cde00923e6" translate="yes" xml:space="preserve">
          <source>It is also the case that if you attempt to use a null reference with &lt;code&gt;synchronized&lt;/code&gt;, that will also throw this exception, &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19&quot;&gt;per the JLS&lt;/a&gt;:</source>
          <target state="translated">また、 &lt;code&gt;synchronized&lt;/code&gt; でnull参照を使用しようとすると&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.19&quot;&gt;、JLSごとに&lt;/a&gt;この例外もスローされます。</target>
        </trans-unit>
        <trans-unit id="2d16dbce2624ff3130d8e2270cf0f83a79ee462c" translate="yes" xml:space="preserve">
          <source>It tells you the full name of the exception that was thrown; i.e. &lt;code&gt;java.lang.NullPointerException&lt;/code&gt;.</source>
          <target state="translated">スローされた例外の完全な名前がわかります。 すなわち &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8417e2fba268434b1c803e3ff401a4e1a47b61fc" translate="yes" xml:space="preserve">
          <source>It tells you the name of the Java thread in which the exception was thrown.  For a simple program with one thread (like this one), it will be &quot;main&quot;. Let's move on ...</source>
          <target state="translated">これは、例外がスローされたJavaスレッドの名前を教えてくれます。1つのスレッドを持つ単純なプログラム(このようなもの)では、&quot;main &quot;になります。先に進んでみましょう ...</target>
        </trans-unit>
        <trans-unit id="2a253b1e78bf697c2a11dc2ac9d828a12960e3d4" translate="yes" xml:space="preserve">
          <source>It's like you are trying to access an object which is &lt;code&gt;null&lt;/code&gt;. Consider below example:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; であるオブジェクトにアクセスしようとしているようです。 以下の例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="76418c77d1fc266f3a62cf5f684db71e4d1120d9" translate="yes" xml:space="preserve">
          <source>Let's illustrate with the simple example (above) first. We start by looking at the line that the stack trace has told us is where the NPE happened:</source>
          <target state="translated">まず、簡単な例 (上)を使って説明してみましょう。まず、スタックトレースがNPEが発生した場所であると教えてくれた行を見ることから始めます。</target>
        </trans-unit>
        <trans-unit id="d339292be5c375475471a2ad89e7eae3c587ba51" translate="yes" xml:space="preserve">
          <source>Looking at the first line, how could that throw an NPE?  There are two ways:</source>
          <target state="translated">一行目を見ると、どうやってNPEを投げるのでしょうか?2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="3048bc36d2ef3a5ca1d47ab6ade02d04a15cfa52" translate="yes" xml:space="preserve">
          <source>Next check where this value comes from. By following the callers of the method, we see that &lt;code&gt;s&lt;/code&gt; is passed in with &lt;code&gt;printString(name)&lt;/code&gt; in the &lt;code&gt;print()&lt;/code&gt; method, and &lt;code&gt;this.name&lt;/code&gt; is null.</source>
          <target state="translated">次に、この値の出所を確認します。 メソッドの呼び出し元をたどると、 &lt;code&gt;s&lt;/code&gt; が &lt;code&gt;print()&lt;/code&gt; メソッドの &lt;code&gt;printString(name)&lt;/code&gt; で渡され、 &lt;code&gt;this.name&lt;/code&gt; がnullであることがわかります。</target>
        </trans-unit>
        <trans-unit id="68bd69464f365c0fbf0e01313f81d5c88e5bffca" translate="yes" xml:space="preserve">
          <source>Next, we need to figure out which of those scenarios explains what is actually happening. We will start by exploring the first one:</source>
          <target state="translated">次に、これらのシナリオのうち、実際に何が起こっているのかを説明しているのはどれなのかを知る必要があります。まず最初のシナリオを探ってみましょう</target>
        </trans-unit>
        <trans-unit id="8eceeaca2b7a976cb9ee01b6b05534d3a2006ca8" translate="yes" xml:space="preserve">
          <source>Note that in a more complicated example, there will be lots of lines in the NPE stack trace. But you can be sure that the second line (the first &quot;at&quot; line) will tell you where the NPE was thrown&lt;sup&gt;1&lt;/sup&gt;.</source>
          <target state="translated">より複雑な例では、NPEスタックトレースに多数の行があることに注意してください。 しかし、2行目（最初の &quot;at&quot;行）でNPEがどこにスローされたかが確実にわかります&lt;sup&gt;1&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="7efbcba01f44f10b16dc449b3a4ce5b93ec278ac" translate="yes" xml:space="preserve">
          <source>OK, so let's try a slightly more tricky example. This will require some &lt;em&gt;logical deduction&lt;/em&gt;.</source>
          <target state="translated">では、もう少しトリッキーな例を試してみましょう。 これには、いくつかの&lt;em&gt;論理的な控除&lt;/em&gt;が必要になります。</target>
        </trans-unit>
        <trans-unit id="09140446828a190f98d3e888ff50d49babf39577" translate="yes" xml:space="preserve">
          <source>On the first line inside &lt;code&gt;main&lt;/code&gt;, I'm explicitly setting the &lt;code&gt;Object&lt;/code&gt; reference &lt;code&gt;obj&lt;/code&gt; equal to &lt;code&gt;null&lt;/code&gt;.  This means I have a reference, but it isn't pointing to any object.  After that, I try to treat the reference as though it points to an object by calling a method on it.  This results in a &lt;code&gt;NullPointerException&lt;/code&gt; because there is no code to execute in the location that the reference is pointing.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 内の最初の行では、 &lt;code&gt;Object&lt;/code&gt; 参照 &lt;code&gt;obj&lt;/code&gt; を &lt;code&gt;null&lt;/code&gt; に明示的に設定しています 。 これは、参照があることを意味しますが、オブジェクトを指していません。 その後、参照をメソッドを呼び出すことにより、それがオブジェクトを指しているかのように扱います。 参照が指している場所で実行するコードがないため、これにより &lt;code&gt;NullPointerException&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="5b3e2ae3b2ddecc346c758e8d3b5549b755c1e92" translate="yes" xml:space="preserve">
          <source>Or you can design the class so that &lt;code&gt;name&lt;/code&gt;&lt;em&gt;always has a non-null value&lt;/em&gt;:</source>
          <target state="translated">または、 &lt;code&gt;name&lt;/code&gt; &lt;em&gt;常にnull以外の値が&lt;/em&gt;含まれるようにクラスを設計することもでき&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc52fe609e5da3175933559d437d1fdb72e364c5" translate="yes" xml:space="preserve">
          <source>Other fixes</source>
          <target state="translated">その他の修正</target>
        </trans-unit>
        <trans-unit id="5332d8134d57cacdb6ee04717450e635f41c6767" translate="yes" xml:space="preserve">
          <source>Otherwise, if the value of the Expression is null, a &lt;code&gt;NullPointerException&lt;/code&gt; is thrown.</source>
          <target state="translated">それ以外の場合、式の値がnullの場合、 &lt;code&gt;NullPointerException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="59f63782fa2d7a08a6249d7857f98b11c193fbd3" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;valueOf()&lt;/code&gt; over &lt;code&gt;toString()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toString()&lt;/code&gt; &lt;code&gt;valueOf()&lt;/code&gt; よりもvalueOf（）を優先します。</target>
        </trans-unit>
        <trans-unit id="e6eb6b961bbe76bed259ea3835d017bb805fcd01" translate="yes" xml:space="preserve">
          <source>Probably the quickest example code I could come up with to illustrate a &lt;code&gt;NullPointerException&lt;/code&gt; would be:</source>
          <target state="translated">おそらく、 &lt;code&gt;NullPointerException&lt;/code&gt; を説明するために思いつくことができる最も速いコード例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e1aa69767a9902b2d9d069ada53c5e09041f46fc" translate="yes" xml:space="preserve">
          <source>Question: How do I read the NPE stacktrace?</source>
          <target state="translated">質問です。NPEのスタックトレースを読むにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="2a7214e14c4e2559dd384c3596ba27c46d122f5b" translate="yes" xml:space="preserve">
          <source>Question: How do I track down the cause of the NPE exception in my code?</source>
          <target state="translated">質問です。自分のコードのNPE例外の原因を突き止めるにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="110059053a369d1fac95bf75cd737030c08abcd5" translate="yes" xml:space="preserve">
          <source>Question: What causes a &lt;code&gt;NullPointerException&lt;/code&gt; (NPE)?</source>
          <target state="translated">質問： &lt;code&gt;NullPointerException&lt;/code&gt; （NPE）の原因は何ですか？</target>
        </trans-unit>
        <trans-unit id="f7b4ef7eaa8bdc43a3fc8327ee8e3b2a393de223" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&lt;/a&gt;</source>
          <target state="translated">リファレンス： &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html&quot;&gt;http&lt;/a&gt; : //docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html</target>
        </trans-unit>
        <trans-unit id="20c7030469d7703e9338b3a13079900db1ad58d0" translate="yes" xml:space="preserve">
          <source>Same for the array concept:</source>
          <target state="translated">配列の概念も同じです。</target>
        </trans-unit>
        <trans-unit id="a328a8219b1d929d6ed454cdd41b31e02977388d" translate="yes" xml:space="preserve">
          <source>Second observation: when I run the program, it outputs two lines of &quot;gobbledy-gook&quot;. &lt;strong&gt;WRONG!!&lt;/strong&gt; That's not gobbledy-gook. It is a stacktrace ... and it provides &lt;em&gt;vital information&lt;/em&gt; that will help you track down the error in your code, if you take the time to read it carefully.</source>
          <target state="translated">2番目の観察：プログラムを実行すると、「gobbledy-gook」の2行が出力されます。 &lt;strong&gt;違う！！&lt;/strong&gt; それはゴチャゴチャではありません。 これはスタックトレースであり、時間をかけて注意深く読んだ場合、コード内のエラーを追跡するのに役立つ&lt;em&gt;重要な情報&lt;/em&gt;を提供します。</target>
        </trans-unit>
        <trans-unit id="5ece6ed3284a8e7793f5f8e6191387a1ca65d15c" translate="yes" xml:space="preserve">
          <source>See also:
&lt;a href=&quot;http://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html&quot;&gt;A good list of best practices&lt;/a&gt;</source>
          <target state="translated">参照： &lt;a href=&quot;http://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html&quot;&gt;ベストプラクティスの良いリスト&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c66fb315fd8a9161821812042eba9ece0fca8b7e" translate="yes" xml:space="preserve">
          <source>See this below example as well:</source>
          <target state="translated">以下の例も参照してください。</target>
        </trans-unit>
        <trans-unit id="3f608da5633e1fbbbac554cb0e0f6193783c3e96" translate="yes" xml:space="preserve">
          <source>So let's look at what it says:</source>
          <target state="translated">では、その内容を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a957e6b089e86c3afa609e7f79243914d473cc8f" translate="yes" xml:space="preserve">
          <source>So now we have two &quot;at&quot; lines. The first one is for this line:</source>
          <target state="translated">これで2つの &quot;at &quot;行ができました。1つ目はこの行のためのものです。</target>
        </trans-unit>
        <trans-unit id="ad6c8b1add16d8acb60150ed283087c1e312a08e" translate="yes" xml:space="preserve">
          <source>So what about our second scenario? Well, we can see that &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, so that means that &lt;code&gt;foo[1]&lt;/code&gt; must be &lt;code&gt;null&lt;/code&gt;. Is that possible?</source>
          <target state="translated">では、2番目のシナリオはどうでしょうか。 さて、 &lt;code&gt;pos&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; であることがわかり &lt;code&gt;null&lt;/code&gt; 。つまり、 &lt;code&gt;foo[1]&lt;/code&gt; はnullでなければなりません。 それは可能ですか？</target>
        </trans-unit>
        <trans-unit id="edded83678c3da726f6a8903ea8346cc771eea21" translate="yes" xml:space="preserve">
          <source>So where did that &lt;code&gt;null&lt;/code&gt; come from? In this case it is obvious, and it is obvious what we need to do to fix it. (Assign a non-null value to &lt;code&gt;foo&lt;/code&gt;.)</source>
          <target state="translated">それで、その &lt;code&gt;null&lt;/code&gt; どこから来たのですか？ この場合、それは明白であり、それを修正するために何をする必要があるかは明らかです。 （null以外の値を &lt;code&gt;foo&lt;/code&gt; に割り当てます。）</target>
        </trans-unit>
        <trans-unit id="4b796033ff61d122122d65b5810f1c0b31a4da7c" translate="yes" xml:space="preserve">
          <source>So you have a &lt;code&gt;NullPointerException&lt;/code&gt;. How do you fix it? Let's take a simple example which throws a &lt;code&gt;NullPointerException&lt;/code&gt;:</source>
          <target state="translated">したがって、 &lt;code&gt;NullPointerException&lt;/code&gt; があります。 どのように修正しますか？ &lt;code&gt;NullPointerException&lt;/code&gt; をスローする簡単な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3a73c967d00d54d26fc9adb9c9ba33d3cc383d28" translate="yes" xml:space="preserve">
          <source>Sonar with findbugs can detect NPE.
&lt;a href=&quot;https://stackoverflow.com/questions/20899931/can-sonar-catch-null-pointer-exceptions-caused-by-jvm-dynamically&quot;&gt;Can sonar catch null pointer exceptions caused by JVM Dynamically&lt;/a&gt;</source>
          <target state="translated">findbugsを備えたソナーはNPEを検出できます。 &lt;a href=&quot;https://stackoverflow.com/questions/20899931/can-sonar-catch-null-pointer-exceptions-caused-by-jvm-dynamically&quot;&gt;JVMが原因で発生するnullポインター例外を動的にキャッチできる&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b3f0dcd539c143def5976a02527992145f3bd87" translate="yes" xml:space="preserve">
          <source>Suppose that I compile and run the program above:</source>
          <target state="translated">上記のプログラムをコンパイルして実行したとします。</target>
        </trans-unit>
        <trans-unit id="fc52468f6c93bbc71a7e83fc6a1c10802582b2cc" translate="yes" xml:space="preserve">
          <source>Taking the length of &lt;code&gt;null&lt;/code&gt; as if it were an array.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; の長さを配列のように受け取ります。</target>
        </trans-unit>
        <trans-unit id="a7a05060b85348fb26d1541414ea261fc8549ebe" translate="yes" xml:space="preserve">
          <source>Taking the length of null as if it were an array.</source>
          <target state="translated">配列であるかのようにNULLの長さを取ります。</target>
        </trans-unit>
        <trans-unit id="70e38b9cf4b5f335ee765ffbb4c9d75eed7a25c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NullPointerException&lt;/code&gt; occurs when you declare a variable but did not create an object and assign to the variable before trying to use the contents of the variable (called &lt;em&gt;dereferencing&lt;/em&gt;). So you are pointing to something that does not actually exist.</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; は、変数を宣言したが、オブジェクトを作成せず、変数の内容を使用する前に変数に割り当てた場合に発生します（ &lt;em&gt;逆参照&lt;/em&gt;と呼ばれます）。 つまり、実際には存在しないものを指しています。</target>
        </trans-unit>
        <trans-unit id="4dd2a758bfbc7c2e200907cb43a178174a1ef438" translate="yes" xml:space="preserve">
          <source>The below code gives you a null pointer exception.</source>
          <target state="translated">以下のコードでは、NULL ポインタの例外が発生します。</target>
        </trans-unit>
        <trans-unit id="5afcbf74c6133d5e8acb0880821ac443b031db8d" translate="yes" xml:space="preserve">
          <source>The first line declares a variable named &lt;code&gt;num&lt;/code&gt;, but it does not actually contain a primitive value yet. Instead, it contains a pointer (because the type is &lt;code&gt;Integer&lt;/code&gt; which is a reference type). Since you have not yet said what to point to, Java sets it to &lt;code&gt;null&lt;/code&gt;, which means &quot;&lt;strong&gt;I am pointing to &lt;em&gt;nothing&lt;/em&gt;&lt;/strong&gt;&quot;.</source>
          <target state="translated">1行目は &lt;code&gt;num&lt;/code&gt; という名前の変数を宣言していますが、実際にはまだプリミティブ値が含まれていません。 代わりに、ポインターが含まれています（型が参照型である &lt;code&gt;Integer&lt;/code&gt; あるため）。 何を指すかまだ言っていないので、Javaはそれを &lt;code&gt;null&lt;/code&gt; に設定します 。これは、「 &lt;strong&gt;私は&lt;em&gt;何も&lt;/em&gt;指してい&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt; 」 &lt;strong&gt;ことを&lt;/strong&gt;意味します 。</target>
        </trans-unit>
        <trans-unit id="94ff3f2d90b51f92f5a22e77c70e18165e13575b" translate="yes" xml:space="preserve">
          <source>The first line of the stack trace tells you a number of things:</source>
          <target state="translated">スタックトレースの最初の行は、いくつかのことを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="11b1b8cb1b03ae2aa5fe1b9dc487442dbfdff843" translate="yes" xml:space="preserve">
          <source>The first step is identifying exactly &lt;em&gt;which values are causing the exception&lt;/em&gt;. For this, we need to do some debugging. It's important to learn to read a &lt;em&gt;stacktrace&lt;/em&gt;. This will show you where the exception was thrown:</source>
          <target state="translated">最初のステップは&lt;em&gt;、例外を引き起こしている値を&lt;/em&gt;正確&lt;em&gt;に&lt;/em&gt;識別することです。 このために、デバッグを行う必要があります。 &lt;em&gt;スタックトレースの&lt;/em&gt;読み方を学ぶことは重要&lt;em&gt;です&lt;/em&gt; 。 これは、例外がスローされた場所を示します。</target>
        </trans-unit>
        <trans-unit id="5f86a6ec7cb1a7454d5e5706d38263349a9ab618" translate="yes" xml:space="preserve">
          <source>The object lives in the VM memory space and the only way to access it is using &lt;code&gt;this&lt;/code&gt; references. Take this example:</source>
          <target state="translated">オブジェクトはVMのメモリ空間にあり、オブジェクトにアクセスする唯一の方法は、 &lt;code&gt;this&lt;/code&gt; 参照を使用することです。 この例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="e2b9b98cc8af92a275b3f463db51d343e34aca5d" translate="yes" xml:space="preserve">
          <source>The second line is the most important one in diagnosing an NPE.</source>
          <target state="translated">NPEを診断する上で最も重要なのは2行目です。</target>
        </trans-unit>
        <trans-unit id="200bc558e7d3cbedcdab6266531c26406b51859d" translate="yes" xml:space="preserve">
          <source>The variable can have a &lt;em&gt;default value&lt;/em&gt; (and &lt;code&gt;setName&lt;/code&gt; can prevent it being set to null):</source>
          <target state="translated">変数は&lt;em&gt;デフォルト値&lt;/em&gt;を持つことができ&lt;em&gt;ます&lt;/em&gt; （そして &lt;code&gt;setName&lt;/code&gt; はそれがnullに設定されるのを防ぐことができます）：</target>
        </trans-unit>
        <trans-unit id="a42f342c5074f18b2ee8c62146f8c92dc81607f4" translate="yes" xml:space="preserve">
          <source>There are many ways that you could use a &lt;code&gt;null&lt;/code&gt; value that will result in a &lt;code&gt;NullPointerException&lt;/code&gt;. In fact, the only things that you &lt;em&gt;can&lt;/em&gt; do with a &lt;code&gt;null&lt;/code&gt; without causing an NPE are:</source>
          <target state="translated">&lt;code&gt;NullPointerException&lt;/code&gt; が発生する &lt;code&gt;null&lt;/code&gt; 値を使用する方法は多数あります。 実際、NPEを発生させずに &lt;code&gt;null&lt;/code&gt; を&lt;em&gt;使用&lt;/em&gt;して&lt;em&gt;できること&lt;/em&gt;は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="87a50685fb8181533a1a38415f42609ffed3b6b7" translate="yes" xml:space="preserve">
          <source>This an important thing to know - when there are no more references to an object (in the example above when &lt;code&gt;reference&lt;/code&gt; and &lt;code&gt;otherReference&lt;/code&gt; both point to null) then the object is &quot;unreachable&quot;. There is no way we can work with it, so this object is ready to be garbage collected, and at some point, the VM will free the memory used by this object and will allocate another.</source>
          <target state="translated">これは知っておくべき重要なことです。オブジェクトへの参照がなくなると（ &lt;code&gt;reference&lt;/code&gt; と &lt;code&gt;otherReference&lt;/code&gt; の両方がnullを指す上記の例では）、オブジェクトは「到達不能」になります。 これを操作する方法はないため、このオブジェクトはガベージコレクションの準備ができており、ある時点で、VMはこのオブジェクトが使用していたメモリを解放し、別のメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="4027f6004fa781ce93560b2dd9d73f25224a03bd" translate="yes" xml:space="preserve">
          <source>This is enough to give us a solution: add a call to &lt;code&gt;printer.setName()&lt;/code&gt; before calling &lt;code&gt;printer.print()&lt;/code&gt;.</source>
          <target state="translated">これで十分な解決策が得られます &lt;code&gt;printer.setName()&lt;/code&gt; を呼び出す前にprinter.setName（）への呼び出しを追加します。</target>
        </trans-unit>
        <trans-unit id="0ca84ac3076d9c11cfc10289571d11019273ee9b" translate="yes" xml:space="preserve">
          <source>This is the hard part. The short answer is to apply logical inference to the evidence provided by the stack trace, the source code and the relevant API documentation.</source>
          <target state="translated">これが難しいところです。短い答えは、スタックトレース、ソースコード、関連するAPIドキュメントから提供される証拠に論理的推論を適用することです。</target>
        </trans-unit>
        <trans-unit id="7676e926601728e6f60a78aa4a791254b0dcaa71" translate="yes" xml:space="preserve">
          <source>This tells us a number of things:</source>
          <target state="translated">これはいくつかのことを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="c54f75a574b2c4fd91cac2f701399ef8dfb71a73" translate="yes" xml:space="preserve">
          <source>Throwing &lt;code&gt;null&lt;/code&gt; as if it were a Throwable value.</source>
          <target state="translated">Throwable値であるかのように &lt;code&gt;null&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="07a54638a8e2bc759d8cf4b233a15f1d6bf23eb7" translate="yes" xml:space="preserve">
          <source>Throwing null as if it were a Throwable value.</source>
          <target state="translated">throwable値であるかのようにnullをスローします。</target>
        </trans-unit>
        <trans-unit id="619270eb9d34c9bc6746a84f38e87b07725f7c5b" translate="yes" xml:space="preserve">
          <source>Thrown when an application attempts to use null in a case where an
  object is required. These include:</source>
          <target state="translated">オブジェクトが必要な場合にアプリケーションがnullを使用しようとしたときにスローされます。これには以下が含まれます。</target>
        </trans-unit>
        <trans-unit id="d45e625248d1bd8fbefc6c9c54d4c25071618a70" translate="yes" xml:space="preserve">
          <source>Use annotations &lt;a href=&quot;https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/NotNull.html&quot;&gt;&lt;code&gt;@NotNull&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://javadoc.io/static/com.github.spotbugs/spotbugs-annotations/3.1.12/edu/umd/cs/findbugs/annotations/Nullable.html&quot;&gt;&lt;code&gt;@Nullable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">アノテーション&lt;a href=&quot;https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/NotNull.html&quot;&gt; &lt;code&gt;@NotNull&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://javadoc.io/static/com.github.spotbugs/spotbugs-annotations/3.1.12/edu/umd/cs/findbugs/annotations/Nullable.html&quot;&gt; &lt;code&gt;@Nullable&lt;/code&gt; を&lt;/a&gt;使用する</target>
        </trans-unit>
        <trans-unit id="3a45ab3058a4a8d1f2705a89ea1c87802cd3caa9" translate="yes" xml:space="preserve">
          <source>Use equals with a known object first: &lt;code&gt;if(&quot;knownObject&quot;.equals(unknownObject)&lt;/code&gt;</source>
          <target state="translated">最初に既知のオブジェクトと等しいを使用： &lt;code&gt;if(&quot;knownObject&quot;.equals(unknownObject)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c9a4702b1c2baf074df6f4b2f4056e68b58c6b2" translate="yes" xml:space="preserve">
          <source>Use null safe &lt;a href=&quot;https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html&quot;&gt;&lt;code&gt;StringUtils&lt;/code&gt;&lt;/a&gt; methods &lt;code&gt;StringUtils.isEmpty(null)&lt;/code&gt;.</source>
          <target state="translated">nullの安全な&lt;a href=&quot;https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html&quot;&gt; &lt;code&gt;StringUtils&lt;/code&gt; &lt;/a&gt;メソッド &lt;code&gt;StringUtils.isEmpty(null)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8e7aac8f8901568e201b480a0f51d1e38bd4e704" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;final&lt;/code&gt; modifier to enforce good initialization.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 修飾子を使用して適切な初期化を実施します。</target>
        </trans-unit>
        <trans-unit id="5571a8c84a86d2b329356c5ece6f990e0c2ee9e8" translate="yes" xml:space="preserve">
          <source>Well, if that happened, the stack trace would look different. The first &quot;at&quot; line would say that the exception was thrown in some line in the &lt;code&gt;java.lang.String&lt;/code&gt; class, and line 4 of &lt;code&gt;Test.java&lt;/code&gt; would be the second &quot;at&quot; line.</source>
          <target state="translated">まあ、それが起こった場合、スタックトレースは異なって見えます。 最初の「at」行は、例外が &lt;code&gt;java.lang.String&lt;/code&gt; クラスのある行でスローされたことを &lt;code&gt;Test.java&lt;/code&gt; 、 Test.javaの 4行目が2番目の「at」行になります。</target>
        </trans-unit>
        <trans-unit id="2ea8cb4ce3fa7d8910d932e12186ed6c797ff3eb" translate="yes" xml:space="preserve">
          <source>What are Null Pointer Exceptions (&lt;code&gt;java.lang.NullPointerException&lt;/code&gt;) and what causes them?</source>
          <target state="translated">ヌルポインター例外（ &lt;code&gt;java.lang.NullPointerException&lt;/code&gt; ）とは何ですか。</target>
        </trans-unit>
        <trans-unit id="a23e7c7dd6bd4a210d09c8c4d18ed8b71c338010" translate="yes" xml:space="preserve">
          <source>What is a NullPointerException, and how do I fix it</source>
          <target state="translated">NullPointerException とは何か?</target>
        </trans-unit>
        <trans-unit id="fd79d84a8b29d705a7298fe1cdcfa64995856eae" translate="yes" xml:space="preserve">
          <source>What is a NullPointerException?</source>
          <target state="translated">NullPointerExceptionとは?</target>
        </trans-unit>
        <trans-unit id="0edb28c818192a20185dc07fb4a9521f4d21afac" translate="yes" xml:space="preserve">
          <source>What methods/tools can be used to determine the cause so that you stop
  the exception from causing the program to terminate prematurely?</source>
          <target state="translated">プログラムが早期に終了する原因となる例外を停止させるために、原因を特定するためにどのようなメソッドツールを使用することができますか?</target>
        </trans-unit>
        <trans-unit id="045d1c645b9d61717b1c4818404fbc1b9d0fe6eb" translate="yes" xml:space="preserve">
          <source>When you attempt to execute one object method, the reference asks the living object to execute that method. But if the reference is referencing NULL (nothing, zero, void, nada)  then there is no way the method gets executed. Then the runtime let you know this by throwing a NullPointerException.</source>
          <target state="translated">あるオブジェクトのメソッドを実行しようとすると、参照はそのメソッドを実行するように生きているオブジェクトに要求します。しかし、もし参照が NULL (nothing,zero,void,nada)を参照している場合、メソッドは実行されません。その場合、ランタイムはNullPointerExceptionを投げることでこのことを知らせてくれます。</target>
        </trans-unit>
        <trans-unit id="b38b6a98cef1c3244acc9814b85d017efbbe9ca2" translate="yes" xml:space="preserve">
          <source>When you declare a reference variable (i.e. an object) you are really creating a pointer to an object. Consider the following code where you declare a variable of primitive type &lt;code&gt;int&lt;/code&gt;:</source>
          <target state="translated">参照変数（つまり、オブジェクト）を宣言すると、実際にはオブジェクトへのポインターが作成されます。 プリミティブ型 &lt;code&gt;int&lt;/code&gt; の変数を宣言する次のコードを考えてください：</target>
        </trans-unit>
        <trans-unit id="971a4d1346f3c7ff4aec8932ef90985736642518" translate="yes" xml:space="preserve">
          <source>Where does &lt;code&gt;bar&lt;/code&gt; come from? It is a parameter to the &lt;code&gt;test&lt;/code&gt; method call, and if we look at how &lt;code&gt;test&lt;/code&gt; was called, we can see that it comes from the &lt;code&gt;foo&lt;/code&gt; static variable. In addition, we can see clearly that we initialized &lt;code&gt;foo&lt;/code&gt; to a non-null value.  That is sufficient to tentatively dismiss this explanation. (In theory, something else could &lt;em&gt;change&lt;/em&gt;&lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; ... but that is not happening here.)</source>
          <target state="translated">&lt;code&gt;bar&lt;/code&gt; どこから来たのですか？ これは &lt;code&gt;test&lt;/code&gt; メソッド呼び出しのパラメーターであり、 &lt;code&gt;test&lt;/code&gt; がどのように呼び出されたかを見ると、 &lt;code&gt;foo&lt;/code&gt; 静的変数からのものであることがわかります。 さらに、 &lt;code&gt;foo&lt;/code&gt; をnull以外の値に初期化したことがはっきりとわかります。 これで、この説明を一時的に却下するには十分です。 （理論的には、他の何かが &lt;code&gt;foo&lt;/code&gt; を &lt;code&gt;null&lt;/code&gt; に &lt;em&gt;変更&lt;/em&gt;する可能性があります ...しかし、それはここでは発生していません。）</target>
        </trans-unit>
        <trans-unit id="8734be1e4922d39775902ac36f9de454e8f5cd18" translate="yes" xml:space="preserve">
          <source>Where is &lt;code&gt;this.name&lt;/code&gt; set? In the &lt;code&gt;setName(String)&lt;/code&gt; method. With some more debugging, we can see that this method isn't called at all. If the method was called, make sure to check the &lt;em&gt;order&lt;/em&gt; that these methods are called, and the set method isn't called &lt;em&gt;after&lt;/em&gt; the print method.</source>
          <target state="translated">&lt;code&gt;this.name&lt;/code&gt; はどこに設定されていますか？ &lt;code&gt;setName(String)&lt;/code&gt; メソッド内。 さらにデバッグを行うと、このメソッドがまったく呼び出されないことがわかります。 メソッドが呼び出された場合は、これらのメソッドが呼び出される&lt;em&gt;順序&lt;/em&gt;を確認してください。また、setメソッドは、printメソッドの&lt;em&gt;後&lt;/em&gt;に呼び出さ&lt;em&gt;れ&lt;/em&gt;ません。</target>
        </trans-unit>
        <trans-unit id="706f4059c0a82014b57c44cebf4ce048cfdc2bda" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;must&lt;/em&gt; initialize the elements in the array &lt;em&gt;before&lt;/em&gt; accessing or dereferencing them.</source>
          <target state="translated">配列の要素&lt;em&gt;に&lt;/em&gt;アクセスまたは逆参照する&lt;em&gt;前に&lt;/em&gt; 、要素を初期化する&lt;em&gt;必要&lt;/em&gt;が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="c84e0b49f0f58904617fb6abbab17f59ee3f10cf" translate="yes" xml:space="preserve">
          <source>Your reference is &quot;pointing&quot; to null, thus &quot;Null -&amp;gt; Pointer&quot;.</source>
          <target state="translated">参照はnullを「ポイント」しているため、「null-&amp;gt;ポインタ」です。</target>
        </trans-unit>
        <trans-unit id="b2766c956c0871691da99343bea9fdce861530cc" translate="yes" xml:space="preserve">
          <source>and the second one is for this line:</source>
          <target state="translated">で、2つ目はこのセリフのためのものです。</target>
        </trans-unit>
        <trans-unit id="2b6f2c4a758bdfa568fbd16a03a6270d7b0cb1d4" translate="yes" xml:space="preserve">
          <source>assign it to a reference variable or read it from a reference variable,</source>
          <target state="translated">参照変数に代入したり、参照変数から読み込んだりします。</target>
        </trans-unit>
        <trans-unit id="4794f1fa5f6182550ad52c39225ba650ca2c5cac" translate="yes" xml:space="preserve">
          <source>assign it to an array element or read it from an array element (provided that array reference itself is non-null!),</source>
          <target state="translated">配列要素に代入したり、配列要素から読み込んだりすることができます(配列参照自体が NULL ではないことを条件とします!)。</target>
        </trans-unit>
        <trans-unit id="fea64947f3e1c19acb6fae94b6a25dd469358299" translate="yes" xml:space="preserve">
          <source>pass it as a parameter or return it as a result, or</source>
          <target state="translated">パラメータとして渡すか、結果として返すか、あるいは</target>
        </trans-unit>
        <trans-unit id="60ce2f688c217a588196b5698debb2b0bed8b3dc" translate="yes" xml:space="preserve">
          <source>test it using the &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; operators, or &lt;code&gt;instanceof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; または &lt;code&gt;!=&lt;/code&gt; 演算子、または &lt;code&gt;instanceof&lt;/code&gt; を使用してテストします 。</target>
        </trans-unit>
        <trans-unit id="48dd492845e5923b030e505964695a889432ed8e" translate="yes" xml:space="preserve">
          <source>the statement labelled &quot;HERE&quot; is going to attempt to run the &lt;code&gt;length()&lt;/code&gt; method on a &lt;code&gt;null&lt;/code&gt; reference, and this will throw a &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">「HERE」というラベルの付いたステートメントは、 &lt;code&gt;null&lt;/code&gt; 参照で &lt;code&gt;length()&lt;/code&gt; メソッドを実行しようとします。これにより、 &lt;code&gt;NullPointerException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="c5c707c98218e538788fb9a4baa24f7af56308cd" translate="yes" xml:space="preserve">
          <source>we allocate a &lt;code&gt;String[]&lt;/code&gt; with two elements &lt;em&gt;that are initialized to &lt;code&gt;null&lt;/code&gt;&lt;/em&gt;. After that, we have not changed the contents of &lt;code&gt;foo&lt;/code&gt; ... so &lt;code&gt;foo[1]&lt;/code&gt; will still be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;null&lt;/code&gt; に初期化される&lt;/em&gt; 2つの要素&lt;em&gt;を&lt;/em&gt;持つ &lt;code&gt;String[]&lt;/code&gt; を割り当て&lt;em&gt;ます&lt;/em&gt; 。 その後は &lt;code&gt;foo&lt;/code&gt; の内容を変更していません... &lt;code&gt;foo[1]&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; のままです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
