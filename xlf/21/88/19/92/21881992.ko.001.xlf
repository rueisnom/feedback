<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/21881992">
    <body>
      <group id="21881992">
        <trans-unit id="8973f81ed8cdf208adc888f971ea67b63b9726f7" translate="yes" xml:space="preserve">
          <source>(This is the amalgamated summary of tens of similar questions every week. Attempting to provide a &quot;canonical&quot; community wiki question/answer here so that all those questions can be directed to a good reference.)</source>
          <target state="translated">(매주 수십 개의 유사한 질문이 요약되어 있습니다. 여기에서 &quot;정식&quot;커뮤니티 위키 질문 / 답변을 제공하려고 시도하면 모든 질문에 대한 올바른 참조가 가능합니다.)</target>
        </trans-unit>
        <trans-unit id="2704b0ed3d0b6d930b5ebc50dc27b18d81f29ed9" translate="yes" xml:space="preserve">
          <source>1) onCreate():
This method invoked only once when the application is start at first time . So it called only once</source>
          <target state="translated">1) onCreate () :이 메소드는 애플리케이션이 처음 시작될 때 한 번만 호출됩니다. 한 번만 호출</target>
        </trans-unit>
        <trans-unit id="8f93f06008b956237d3f1650845ddbd315db7da0" translate="yes" xml:space="preserve">
          <source>2)onUpgrade()
This method called when we change the database version,then this methods gets invoked.It is used for the alter the table structure like adding new column after creating DB Schema</source>
          <target state="translated">2) onUpgrade ()이 메소드는 데이터베이스 버전을 변경할 때 호출 된 다음이 메소드가 호출됩니다.이 메소드는 DB 스키마 생성 후 새 열 추가와 같은 테이블 구조 변경에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6b472009c33fd34f66806a567ed6895d56dd40d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html&quot;&gt;&lt;code&gt;SQLiteOpenHelper&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate%28android.database.sqlite.SQLiteDatabase%29&quot;&gt;&lt;code&gt;onCreate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onUpgrade%28android.database.sqlite.SQLiteDatabase,%20int,%20int%29&quot;&gt;&lt;code&gt;onUpgrade()&lt;/code&gt;&lt;/a&gt; callbacks are invoked when the database is actually opened, for example by a call to &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase%28%29&quot;&gt;&lt;code&gt;getWritableDatabase()&lt;/code&gt;&lt;/a&gt;. The database is not opened when the database helper object itself is created.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html&quot;&gt; &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate%28android.database.sqlite.SQLiteDatabase%29&quot;&gt; &lt;code&gt;onCreate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onUpgrade%28android.database.sqlite.SQLiteDatabase,%20int,%20int%29&quot;&gt; &lt;code&gt;onUpgrade()&lt;/code&gt; &lt;/a&gt; 콜백은 데이터베이스가 실제로 열릴 때 (예 : &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase%28%29&quot;&gt; &lt;code&gt;getWritableDatabase()&lt;/code&gt; &lt;/a&gt; 호출로 ) 호출됩니다. 데이터베이스 헬퍼 오브젝트 자체가 작성 될 때 데이터베이스가 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ef1bcdd3e738b205ae7f888a0d625289a30bb9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; should call the super constructor.</source>
          <target state="translated">&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 는 수퍼 생성자를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d674502cf15c4936c81194cc888860e31e93258a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; versions the database files. The version number is the &lt;code&gt;int&lt;/code&gt; argument passed to the &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#SQLiteOpenHelper%28android.content.Context,%20java.lang.String,%20android.database.sqlite.SQLiteDatabase.CursorFactory,%20int%29&quot;&gt;constructor&lt;/a&gt;. In the database file, the version number is stored in &lt;a href=&quot;http://www.sqlite.org/pragma.html#pragma_schema_version&quot;&gt;&lt;code&gt;PRAGMA user_version&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 는 데이터베이스 파일을 버전 화합니다. 버전 번호는 &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#SQLiteOpenHelper%28android.content.Context,%20java.lang.String,%20android.database.sqlite.SQLiteDatabase.CursorFactory,%20int%29&quot;&gt;생성자에&lt;/a&gt; 전달 된 &lt;code&gt;int&lt;/code&gt; 인수입니다. 데이터베이스 파일에서 버전 번호는 &lt;a href=&quot;http://www.sqlite.org/pragma.html#pragma_schema_version&quot;&gt; &lt;code&gt;PRAGMA user_version&lt;/code&gt; 에&lt;/a&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="699a1fda8af7d7724273602f7a485e21428e17ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCreate()&lt;/code&gt; is only run when the database file did not exist and was just created. If &lt;code&gt;onCreate()&lt;/code&gt; returns successfully (doesn't throw an exception), the database is assumed to be created with the requested version number. As an implication, you should not catch &lt;code&gt;SQLException&lt;/code&gt;s in &lt;code&gt;onCreate()&lt;/code&gt; yourself.</source>
          <target state="translated">&lt;code&gt;onCreate()&lt;/code&gt; 는 데이터베이스 파일이 존재하지 않고 방금 작성된 경우에만 실행됩니다. &lt;code&gt;onCreate()&lt;/code&gt; 가 성공적으로 반환되면 ( 예외가 발생하지 않음) 데이터베이스는 요청 된 버전 번호로 생성 된 것으로 간주됩니다. 결과적으로 &lt;code&gt;onCreate()&lt;/code&gt; 에서 &lt;code&gt;SQLException&lt;/code&gt; 을 직접 잡아서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="52a588497f58d2764915ea38d2643cc534e68283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCreate()&lt;/code&gt; method is creating the tables you&amp;rsquo;ve defined and executing any other code you&amp;rsquo;ve written. However, this method will only be called if the SQLite file is missing in your app&amp;rsquo;s data directory (&lt;code&gt;/data/data/your.apps.classpath/databases&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;onCreate()&lt;/code&gt; 메소드는 정의한 테이블을 작성하고 작성한 다른 코드를 실행합니다. 그러나이 메소드는 앱의 데이터 디렉토리 ( &lt;code&gt;/data/data/your.apps.classpath/databases&lt;/code&gt; )에 SQLite 파일이없는 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="80fd512c9e2ed8dbd68e852d211837c73a662552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCreate&lt;/code&gt; will be invoked only when &lt;code&gt;getWritableDatabase()&lt;/code&gt; or &lt;code&gt;getReadableDatabase()&lt;/code&gt; is executed. And this will only invoked once when a &lt;code&gt;DBName&lt;/code&gt; specified in the first step is not available. You can add create table query on &lt;code&gt;onCreate&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;onCreate&lt;/code&gt; 는 &lt;code&gt;getWritableDatabase()&lt;/code&gt; 또는 &lt;code&gt;getReadableDatabase()&lt;/code&gt; 가 실행될 때만 호출됩니다. 그리고 이것은 첫 번째 단계에서 지정된 &lt;code&gt;DBName&lt;/code&gt; 을 사용할 수 없을 때 한 번만 호출됩니다. &lt;code&gt;onCreate&lt;/code&gt; 메소드에서 테이블 작성 쿼리를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2b66bdf406d0f09a8a5166db82ebd8ca1cfd2dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onUpgrade()&lt;/code&gt; is only called when the database file exists but the stored version number is lower than requested in constructor. The &lt;code&gt;onUpgrade()&lt;/code&gt; should update the table schema to the requested version.</source>
          <target state="translated">&lt;code&gt;onUpgrade()&lt;/code&gt; 는 데이터베이스 파일이 존재하지만 저장된 버전 번호가 생성자에서 요청한 것보다 낮은 경우에만 호출됩니다. &lt;code&gt;onUpgrade()&lt;/code&gt; 는 테이블 스키마를 요청 된 버전으로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="64d2851cbe6bd656f37521ae0ac1a169419ecec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super(context, DBName, null, DBversion);&lt;/code&gt; - This should be invoked first line of constructor</source>
          <target state="translated">&lt;code&gt;super(context, DBName, null, DBversion);&lt;/code&gt; -생성자의 첫 줄을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc07b5e9a2cbe8042e34325702c868a7f756cdbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Uninstall from your device and run it again.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 장치에서 제거하고 다시 실행하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b16762117ff1e4aa5110ca727eaf57373fc8478e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Setting -&amp;gt; app -&amp;gt; ClearData&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) 설정-&amp;gt; 앱-&amp;gt; ClearData&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d0ec10aa0085e1ddd64c273dcc81ce3e6e28953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt; Change &lt;code&gt;DATABASE_VERSION&lt;/code&gt; in your &quot;DatabaseHandler&quot; class (If you have added new column than it will upgrade automatically)</source>
          <target state="translated">&lt;strong&gt;3)&lt;/strong&gt; &quot;DatabaseHandler&quot;클래스에서 &lt;code&gt;DATABASE_VERSION&lt;/code&gt; 을 변경하십시오 (새 열을 추가 한 경우 자동으로 업그레이드되는 것보다)</target>
        </trans-unit>
        <trans-unit id="2e3f90974d6bf64c7323810b5de72a56cbd1c941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4)&lt;/strong&gt; Change &lt;code&gt;DATABASE_NAME&lt;/code&gt; in your &quot;DatabaseHandler&quot; class (I faced same problem. But I succeed by changing &lt;code&gt;DATABASE_NAME&lt;/code&gt;.)</source>
          <target state="translated">&lt;strong&gt;4)&lt;/strong&gt; &quot;DatabaseHandler&quot;클래스에서 &lt;code&gt;DATABASE_NAME&lt;/code&gt; 을 변경하십시오 (같은 문제에 직면했지만 &lt;code&gt;DATABASE_NAME&lt;/code&gt; 을 변경하면 성공합니다).</target>
        </trans-unit>
        <trans-unit id="772b7b2597ebdf8bd65ae0899d129d3229be7566" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;onCreate()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;onCreate()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d5412b603652710ee9c0f44b73da117842cd3cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;onUpgrade()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;onUpgrade()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d217ab0fe304ed8aff10be0a20aeaf0141550579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;onUpgrade&lt;/em&gt;&lt;/strong&gt;
This method is called when database version is upgraded. Suppose for the first time deployment , database version was 1 and in second deployment there was change in database structure like adding extra column in table. Suppose database version is 2 now.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;onUpgrade&lt;/em&gt;&lt;/strong&gt; 이 메소드는 데이터베이스 버전이 업그레이드 될 때 호출됩니다. 첫 번째 배포의 경우 데이터베이스 버전이 1이고 두 번째 배포의 경우 테이블에 열을 추가하는 것과 같은 데이터베이스 구조가 변경되었다고 가정합니다. 데이터베이스 버전이 2라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="7dda1d5697973762ad0eb2945a404511c27e96c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Database version is stored within the &lt;code&gt;SQLite&lt;/code&gt; database file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;데이터베이스 버전은 &lt;code&gt;SQLite&lt;/code&gt; 데이터베이스 파일에 저장됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35097e2b1b38de5ec88177ea2b0967e5b0e99a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4c7e936f65f8fa305b6798b15622abe8ff11b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note : if you want create another table or add columns or no such table, just increment the VERSION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : 다른 테이블을 만들거나 열을 추가하거나 그러한 테이블을 추가하지 않으려면 VERSION을 늘리십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18944ef373afce1d4222218eb57bd76f269486b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onCreate&lt;/strong&gt; is called for the first time when creation of tables are needed. We need to override this method where we write the script for table creation which is executed by SQLiteDatabase. execSQL method. After executing in first time deployment, this method will not be called onwards.</source>
          <target state="translated">테이블 작성이 필요한 경우 처음으로 &lt;strong&gt;onCreate&lt;/strong&gt; 가 호출됩니다. SQLiteDatabase에 의해 실행되는 테이블 작성을위한 스크립트를 작성하는 경우이 메소드를 대체해야합니다. execSQL 방법. 최초 배포에서 실행 한 후에는이 메서드가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1278ec2d9f4d1f81cf97095607b689a8ae6f07c0" translate="yes" xml:space="preserve">
          <source>As already explained in the older answer, if the database with the name doesn't exists, it triggers &lt;code&gt;onCreate&lt;/code&gt;.</source>
          <target state="translated">이전 답변에서 이미 설명했듯이 이름의 데이터베이스가 존재하지 않으면 &lt;code&gt;onCreate&lt;/code&gt; 를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="9b7cc9cf41152d2ed94f7284d8d207381fe3e77a" translate="yes" xml:space="preserve">
          <source>Below explanation explains &lt;code&gt;onUpgrade&lt;/code&gt; case with an example.</source>
          <target state="translated">아래의 설명은 예제와 함께 &lt;code&gt;onUpgrade&lt;/code&gt; 사례를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7aef22f06e7acf5e4cdc47aff93b63fc26795842" translate="yes" xml:space="preserve">
          <source>Below is the code snippet (No such column found may be because of spell in column name):</source>
          <target state="translated">아래는 코드 스 니펫입니다 (열 이름에 철자가 없기 때문에 해당 열을 찾을 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="f6dec3895ac0e2b4853631e27ec4423ac775a9b6" translate="yes" xml:space="preserve">
          <source>Clear application data. Use the application manager.</source>
          <target state="translated">응용 프로그램 데이터를 지 웁니다. 응용 프로그램 관리자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="219e6da53d0987275653ea784c3537411cfa82a9" translate="yes" xml:space="preserve">
          <source>Delete the old database file so that &lt;code&gt;onCreate()&lt;/code&gt; is run again. This is often preferred at development time where you have control over the installed versions and data loss is not an issue. Some ways to to delete the database file:</source>
          <target state="translated">&lt;code&gt;onCreate()&lt;/code&gt; 가 다시 실행되도록 이전 데이터베이스 파일을 삭제하십시오. 설치된 버전을 제어하고 데이터 손실이 문제가되지 않는 개발 시간에 종종 선호됩니다. 데이터베이스 파일을 삭제하는 몇 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="b9b5663cfae5cb5cebd7d22a54fff4e90845e4ca" translate="yes" xml:space="preserve">
          <source>Example pseudo code below:</source>
          <target state="translated">아래의 의사 코드 예 :</target>
        </trans-unit>
        <trans-unit id="0565d729ac8439c486301e8d3d88f3dab360c7ed" translate="yes" xml:space="preserve">
          <source>For development time schema upgrades where data loss is not an issue, you can just use &lt;code&gt;execSQL(&quot;DROP TABLE IF EXISTS &amp;lt;tablename&amp;gt;&quot;)&lt;/code&gt; in to remove your existing tables and call &lt;code&gt;onCreate()&lt;/code&gt; to recreate the database.</source>
          <target state="translated">데이터 손실이 문제가되지 않는 개발 시간 스키마 업그레이드의 경우 &lt;code&gt;execSQL(&quot;DROP TABLE IF EXISTS &amp;lt;tablename&amp;gt;&quot;)&lt;/code&gt; 을 사용하여 기존 테이블을 제거하고 &lt;code&gt;onCreate()&lt;/code&gt; 를 호출하여 데이터베이스를 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2edb94e69c32d2bbff1e2001c4bd4c3d3b7f8a7" translate="yes" xml:space="preserve">
          <source>For released versions, you should implement data migration in &lt;code&gt;onUpgrade()&lt;/code&gt; so your users don't lose their data.</source>
          <target state="translated">릴리스 된 버전의 경우 사용자가 데이터를 잃지 않도록 &lt;code&gt;onUpgrade()&lt;/code&gt; 에서 데이터 마이그레이션을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fe14d792e5a00fd347288eb08a0a7d4975df3ed" translate="yes" xml:space="preserve">
          <source>I have created my tables in my &lt;code&gt;SQLiteOpenHelper&lt;/code&gt;&lt;code&gt;onCreate()&lt;/code&gt; but receive</source>
          <target state="translated">내 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; &lt;code&gt;onCreate()&lt;/code&gt; 에서 테이블을 만들었지 만 수신</target>
        </trans-unit>
        <trans-unit id="86bebdca7c5f2b09b8ff3092ff824f7258be374d" translate="yes" xml:space="preserve">
          <source>If old version is &lt;code&gt;3&lt;/code&gt; and new version is &lt;code&gt;4&lt;/code&gt;, it will just run the upgrade logic for &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;</source>
          <target state="translated">이전 버전이 &lt;code&gt;3&lt;/code&gt; 이고 새 버전이 &lt;code&gt;4&lt;/code&gt; 이면 &lt;code&gt;3&lt;/code&gt; 에서 &lt;code&gt;4&lt;/code&gt; 까지의 업그레이드 논리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a09e5dc66fbed8ba718aab2f50c7b00a60efa2d9" translate="yes" xml:space="preserve">
          <source>If you are confident about syntax for creating table, than it may happen when you add new column in your same table, for that...</source>
          <target state="translated">테이블 생성 구문에 대해 확신이있는 경우 동일한 테이블에 새 열을 추가 할 때 발생할 수있는 것보다 ...</target>
        </trans-unit>
        <trans-unit id="e1a1616de43ff688286616dd91d759f6eb5756ee" translate="yes" xml:space="preserve">
          <source>If you forget to provide a &quot;name&quot; string as the second argument to the constructor, it creates an &quot;in-memory&quot; database which gets erased when you close the app.</source>
          <target state="translated">생성자에 대한 두 번째 인수로 &quot;이름&quot;문자열을 제공하는 것을 잊어 버린 경우 앱을 닫을 때 지워지는 &quot;메모리 내&quot;데이터베이스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="764ea625ed5a8227c7a7f557667434a20318691b" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;onUpgrade()&lt;/code&gt; method to be called, you need to increment the version number in your code.</source>
          <target state="translated">&lt;code&gt;onUpgrade()&lt;/code&gt; 메소드를 호출하려면 코드에서 버전 번호를 증가시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="832d3ad267a14cde56059605a5ae7a69c370013b" translate="yes" xml:space="preserve">
          <source>Increment the database version so that &lt;code&gt;onUpgrade()&lt;/code&gt; is invoked. This is slightly more complicated as more code is needed.</source>
          <target state="translated">&lt;code&gt;onUpgrade()&lt;/code&gt; 가 호출되도록 데이터베이스 버전을 늘리십시오 . 더 많은 코드가 필요할수록 약간 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d686bf3853559775a474e2b7257cc8fe41fb355c" translate="yes" xml:space="preserve">
          <source>May be I am too late but I would like to share my short and sweet answer.
Please check &lt;a href=&quot;https://stackoverflow.com/a/31605916/2110812&quot;&gt;&lt;strong&gt;Answer&lt;/strong&gt;&lt;/a&gt;  for a same problem. It will definitely help you. No more deep specifications.</source>
          <target state="translated">너무 늦었을 수도 있지만 짧고 달콤한 답변을 공유하고 싶습니다. 같은 문제에 대한 &lt;a href=&quot;https://stackoverflow.com/a/31605916/2110812&quot;&gt;&lt;strong&gt;답변&lt;/strong&gt;&lt;/a&gt; 을 확인하십시오. 확실히 당신을 도울 것입니다. 더 이상 깊은 사양이 없습니다.</target>
        </trans-unit>
        <trans-unit id="90b057306a09283e382db7c3fca71eb80b8e1191" translate="yes" xml:space="preserve">
          <source>Notice the missing &lt;code&gt;break&lt;/code&gt; statement in case &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. This is what I mean by incremental upgrade.</source>
          <target state="translated">경우 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 에서 누락 된 &lt;code&gt;break&lt;/code&gt; 문을 확인하십시오. 이것이 증분 업그레이드의 의미입니다.</target>
        </trans-unit>
        <trans-unit id="9408eac0671003d490fd4b96a9780037b99e2cc8" translate="yes" xml:space="preserve">
          <source>Now say you are planing to give a third version of application with db version as &lt;code&gt;3&lt;/code&gt; (db version is increased only when database schema is to be modified). In such incremental upgrades, you have to write the upgrade logic from each version incrementally for a better maintainable code</source>
          <target state="translated">이제 db 버전이 &lt;code&gt;3&lt;/code&gt; 인 응용 프로그램의 세 번째 버전을 제공 할 계획이라고 가정합니다 (데이터베이스 스키마를 수정해야하는 경우에만 db 버전이 증가 함). 이러한 증분 업그레이드에서는 유지 관리하기 쉬운 코드를 위해 각 버전에서 업그레이드 논리를 증분 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2cfd57e19fb499bbd6d722f0b08bee43403f4f11" translate="yes" xml:space="preserve">
          <source>Points to remember when extending &lt;code&gt;SQLiteOpenHelper&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 를 확장 할 때 기억해야 할 사항</target>
        </trans-unit>
        <trans-unit id="4f615bc61ca3348fc14ba33c4ac9f5ce59c2759f" translate="yes" xml:space="preserve">
          <source>Recheck your query in ur DatabaseHandler/DatabaseManager class(which ever you have took)</source>
          <target state="translated">ur DatabaseHandler / DatabaseManager 클래스에서 쿼리를 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9b53c90ed931c6c5bf8c74592389bd3e00502932" translate="yes" xml:space="preserve">
          <source>Say if the old version is &lt;code&gt;2&lt;/code&gt; and new version is &lt;code&gt;4&lt;/code&gt;, then the logic will upgrade the database from &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;3&lt;/code&gt; and then to &lt;code&gt;4&lt;/code&gt;</source>
          <target state="translated">이전 버전이 &lt;code&gt;2&lt;/code&gt; 이고 새 버전이 &lt;code&gt;4&lt;/code&gt; 이면 논리가 데이터베이스를 &lt;code&gt;2&lt;/code&gt; 에서 &lt;code&gt;3&lt;/code&gt; 으로 업그레이드 한 다음 4로 업그레이드합니다</target>
        </trans-unit>
        <trans-unit id="8bf48c6a3d32c8ea186c0e256e8577dbbfe900dc" translate="yes" xml:space="preserve">
          <source>Say, your first version of application had the &lt;code&gt;DatabaseHelper&lt;/code&gt; (extending &lt;code&gt;SQLiteOpenHelper&lt;/code&gt;) with constructor passing version as &lt;code&gt;1&lt;/code&gt; and then you provided an upgraded application with the new source code having version passed as &lt;code&gt;2&lt;/code&gt;, then automatically when the &lt;code&gt;DatabaseHelper&lt;/code&gt; is constructed, platform triggers &lt;code&gt;onUpgrade&lt;/code&gt; by seeing the file already exists, but the version is lower than the current version which you have passed.</source>
          <target state="translated">예를 들어, 첫 번째 버전의 응용 프로그램에는 생성자가 버전 &lt;code&gt;1&lt;/code&gt; 을 전달하는 &lt;code&gt;DatabaseHelper&lt;/code&gt; (확장 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; )가 있고 버전이 &lt;code&gt;2&lt;/code&gt; 로 전달 된 새 소스 코드로 업그레이드 된 응용 프로그램을 제공 한 다음 &lt;code&gt;DatabaseHelper&lt;/code&gt; 가 구성 될 때 자동으로 플랫폼이 트리거됩니다. 파일이 이미 존재하지만 버전이 전달한 현재 버전보다 낮습니다.</target>
        </trans-unit>
        <trans-unit id="c6c379f61950c21af8aec2d1a0bdb769ec13f725" translate="yes" xml:space="preserve">
          <source>So when the database helper constructor is called with a &lt;code&gt;name&lt;/code&gt; (2nd param), platform checks if the database exists or not and if the database exists, it gets the version information from the database file header and triggers the right call back</source>
          <target state="translated">따라서 데이터베이스 도우미 생성자가 &lt;code&gt;name&lt;/code&gt; (2 번째 매개 변수)으로 호출되면 플랫폼은 데이터베이스가 존재하는지 여부를 확인하고 데이터베이스가 존재하면 데이터베이스 파일 헤더에서 버전 정보를 가져 와서 올바른 콜백을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="0b9aa0de05a48321d0b1095068cf5fdefe772eca" translate="yes" xml:space="preserve">
          <source>Sqlite database override two methods</source>
          <target state="translated">Sqlite 데이터베이스는 두 가지 방법을 재정의</target>
        </trans-unit>
        <trans-unit id="9fc35026941210204bc5f629aca07c5c4a31fc1e" translate="yes" xml:space="preserve">
          <source>Sqliteopenhelper's method have methods create and upgrade,create is used when any table is first time created and upgrade method will called everytime whenever table's number of column is changed.</source>
          <target state="translated">Sqliteopenhelper의 메소드에는 create 및 upgrade 메소드가 있습니다. create는 테이블이 처음 작성 될 때 사용되며 테이블의 열 수가 변경 될 때마다 업그레이드 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2d81a8a5c7bacf1c42ced5a684fcdca305568594" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onUpgrade()&lt;/code&gt; method will only be called when the version integer is larger than the current version running in the app.</source>
          <target state="translated">&lt;code&gt;onUpgrade()&lt;/code&gt; 메소드는 버전 정수가 앱에서 실행중인 현재 버전보다 큰 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6b94607bd2af0821bc4e744801dd409b2d682ab4" translate="yes" xml:space="preserve">
          <source>This method will not be called if you&amp;rsquo;ve changed your code and relaunched in the emulator.  If you want &lt;code&gt;onCreate()&lt;/code&gt; to run you need to use adb to delete the SQLite database file.</source>
          <target state="translated">코드를 변경하고 에뮬레이터에서 다시 시작한 경우에는이 메소드가 호출되지 않습니다. &lt;code&gt;onCreate()&lt;/code&gt; 를 실행하려면 adb를 사용하여 SQLite 데이터베이스 파일을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="366b6613ea1e27174cff0bcd483c593d22850c06" translate="yes" xml:space="preserve">
          <source>To further add missing points here, as per the request by Jaskey</source>
          <target state="translated">Jaskey의 요청에 따라 여기에 누락 된 포인트를 추가하려면</target>
        </trans-unit>
        <trans-unit id="a6569bbdcb97ed3c78d484b43591547f3090b6e0" translate="yes" xml:space="preserve">
          <source>Uninstall the application. Use the application manager or &lt;code&gt;adb uninstall your.package.name&lt;/code&gt; from shell.</source>
          <target state="translated">응용 프로그램을 제거하십시오. 응용 프로그램 관리자를 사용하거나 &lt;code&gt;adb uninstall your.package.name&lt;/code&gt; 사용하여 쉘에서 your.package.name 을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ff4f5bd57b7fbd3b7a7ce543d35e816134fbfd4" translate="yes" xml:space="preserve">
          <source>Uninstall your application from the emulator or device. Run the app again. (OnCreate() is not executed when the database already exists)</source>
          <target state="translated">에뮬레이터 또는 장치에서 응용 프로그램을 제거하십시오. 앱을 다시 실행하십시오. (데이터베이스가 이미 존재하면 OnCreate ()가 실행되지 않습니다)</target>
        </trans-unit>
        <trans-unit id="7089156cd1e73d659d72f216471c9b2f9cb8ff11" translate="yes" xml:space="preserve">
          <source>When changing the table schema in code (&lt;code&gt;onCreate()&lt;/code&gt;), you should make sure the database is updated. Two main approaches:</source>
          <target state="translated">코드에서 테이블 스키마 ( &lt;code&gt;onCreate()&lt;/code&gt; )를 변경할 때 데이터베이스가 업데이트되었는지 확인해야합니다. 두 가지 주요 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="a8445470a2cd89d81df9215ce55b6fcdf763db23" translate="yes" xml:space="preserve">
          <source>When is SQLiteOpenHelper onCreate() / onUpgrade() run</source>
          <target state="translated">SQLiteOpenHelper onCreate () / onUpgrade ()가 언제 실행됩니까?</target>
        </trans-unit>
        <trans-unit id="d0091012f5ac3e297f43ffc9c1374bcc22f85795" translate="yes" xml:space="preserve">
          <source>When we create DataBase at a first time (i.e Database is not exists) &lt;code&gt;onCreate()&lt;/code&gt; create database with version which is passed in 
&lt;code&gt;SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&lt;/code&gt;</source>
          <target state="translated">처음으로 데이터베이스를 생성 할 때 (즉, 데이터베이스가 존재하지 않음) &lt;code&gt;onCreate()&lt;/code&gt; 는 &lt;code&gt;SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&lt;/code&gt; 전달 된 버전으로 데이터베이스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="804d1581563d8354862757f224f1f10106687801" translate="yes" xml:space="preserve">
          <source>Whenever you want to add new table just change &lt;code&gt;DBversion&lt;/code&gt; and do the queries in &lt;code&gt;onUpgrade&lt;/code&gt; table or simply uninstall then install the app.</source>
          <target state="translated">새 테이블을 추가 할 때마다 &lt;code&gt;DBversion&lt;/code&gt; 을 변경하고 &lt;code&gt;onUpgrade&lt;/code&gt; 테이블에서 쿼리를 수행 하거나 단순히 앱을 제거한 다음 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="53386ca891036a4cbbe13b55f9aaa49f065fa79a" translate="yes" xml:space="preserve">
          <source>You can create database &amp;amp; table like</source>
          <target state="translated">당신은 같은 데이터베이스 및 테이블을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="db1cf59b84c386cce2aacfee91cac73c4e4776bd" translate="yes" xml:space="preserve">
          <source>Your database name must end with .db also your query strings must have a terminator (;)</source>
          <target state="translated">데이터베이스 이름은 .db로 끝나야하며 쿼리 문자열에는 종결 자 (;)가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a80d24e6382e443740f8d891030ced0d61635b96" translate="yes" xml:space="preserve">
          <source>catch is the constructor</source>
          <target state="translated">catch는 생성자입니다</target>
        </trans-unit>
        <trans-unit id="a1632ff0c672d37e385809f7c8966c1663a4ffb8" translate="yes" xml:space="preserve">
          <source>errors. Why?</source>
          <target state="translated">오류. 왜?</target>
        </trans-unit>
        <trans-unit id="76b7ef80d4c5ccc3b3c59ff591e17ac9503ea18e" translate="yes" xml:space="preserve">
          <source>no such table found is mainly when you have not opened the &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; class with &lt;code&gt;getwritabledata()&lt;/code&gt; and before this you also have to call make constructor with databasename &amp;amp; version. 
And &lt;code&gt;OnUpgrade&lt;/code&gt; is called whenever there is upgrade value in version number given in &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;getwritabledata()&lt;/code&gt; 사용하여 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 클래스를 열지 않았을 때 이러한 테이블을 찾을 수 없으며이 전에 데이터베이스 이름 및 버전으로 make 생성자를 호출해야합니다. 그리고 &lt;code&gt;OnUpgrade&lt;/code&gt; 는 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 클래스에 주어진 버전 번호에 업그레이드 값이있을 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1fc8e4192a3dbfcd0f26ffb4a820f43ca5a0122f" translate="yes" xml:space="preserve">
          <source>override &lt;code&gt;onCreate&lt;/code&gt; and &lt;code&gt;onUpgrade&lt;/code&gt; (if needed)</source>
          <target state="translated">&lt;code&gt;onCreate&lt;/code&gt; 및 &lt;code&gt;onUpgrade&lt;/code&gt; 무시 (필요한 경우)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
