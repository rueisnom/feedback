<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/21881992">
    <body>
      <group id="21881992">
        <trans-unit id="8973f81ed8cdf208adc888f971ea67b63b9726f7" translate="yes" xml:space="preserve">
          <source>(This is the amalgamated summary of tens of similar questions every week. Attempting to provide a &quot;canonical&quot; community wiki question/answer here so that all those questions can be directed to a good reference.)</source>
          <target state="translated">(这是每周几十个类似问题的汇总,每周都会有几十个类似问题的汇总。试图在这里提供一个 &quot;典型的 &quot;社区维基问答,以便所有这些问题都能得到很好的参考)。)</target>
        </trans-unit>
        <trans-unit id="2704b0ed3d0b6d930b5ebc50dc27b18d81f29ed9" translate="yes" xml:space="preserve">
          <source>1) onCreate():
This method invoked only once when the application is start at first time . So it called only once</source>
          <target state="translated">1)onCreate()。这个方法在应用程序第一次启动时只调用一次。所以它只调用一次</target>
        </trans-unit>
        <trans-unit id="8f93f06008b956237d3f1650845ddbd315db7da0" translate="yes" xml:space="preserve">
          <source>2)onUpgrade()
This method called when we change the database version,then this methods gets invoked.It is used for the alter the table structure like adding new column after creating DB Schema</source>
          <target state="translated">2)onUpgrade()当我们改变数据库的版本时,这个方法被调用,然后这个方法被调用。</target>
        </trans-unit>
        <trans-unit id="d6b472009c33fd34f66806a567ed6895d56dd40d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html&quot;&gt;&lt;code&gt;SQLiteOpenHelper&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate%28android.database.sqlite.SQLiteDatabase%29&quot;&gt;&lt;code&gt;onCreate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onUpgrade%28android.database.sqlite.SQLiteDatabase,%20int,%20int%29&quot;&gt;&lt;code&gt;onUpgrade()&lt;/code&gt;&lt;/a&gt; callbacks are invoked when the database is actually opened, for example by a call to &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase%28%29&quot;&gt;&lt;code&gt;getWritableDatabase()&lt;/code&gt;&lt;/a&gt;. The database is not opened when the database helper object itself is created.</source>
          <target state="translated">实际打开数据库时，将调用&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html&quot;&gt; &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate%28android.database.sqlite.SQLiteDatabase%29&quot;&gt; &lt;code&gt;onCreate()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onUpgrade%28android.database.sqlite.SQLiteDatabase,%20int,%20int%29&quot;&gt; &lt;code&gt;onUpgrade()&lt;/code&gt; &lt;/a&gt;回调，例如，通过调用&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase%28%29&quot;&gt; &lt;code&gt;getWritableDatabase()&lt;/code&gt; &lt;/a&gt; 。 创建数据库助手对象本身时，不会打开数据库。</target>
        </trans-unit>
        <trans-unit id="6ef1bcdd3e738b205ae7f888a0d625289a30bb9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; should call the super constructor.</source>
          <target state="translated">&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 应该调用超级构造函数。</target>
        </trans-unit>
        <trans-unit id="d674502cf15c4936c81194cc888860e31e93258a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; versions the database files. The version number is the &lt;code&gt;int&lt;/code&gt; argument passed to the &lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#SQLiteOpenHelper%28android.content.Context,%20java.lang.String,%20android.database.sqlite.SQLiteDatabase.CursorFactory,%20int%29&quot;&gt;constructor&lt;/a&gt;. In the database file, the version number is stored in &lt;a href=&quot;http://www.sqlite.org/pragma.html#pragma_schema_version&quot;&gt;&lt;code&gt;PRAGMA user_version&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 对数据库文件进行版本控制。 版本号是传递给&lt;a href=&quot;http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#SQLiteOpenHelper%28android.content.Context,%20java.lang.String,%20android.database.sqlite.SQLiteDatabase.CursorFactory,%20int%29&quot;&gt;构造函数&lt;/a&gt;的 &lt;code&gt;int&lt;/code&gt; 参数。 在数据库文件中，版本号存储在&lt;a href=&quot;http://www.sqlite.org/pragma.html#pragma_schema_version&quot;&gt; &lt;code&gt;PRAGMA user_version&lt;/code&gt; 中&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="699a1fda8af7d7724273602f7a485e21428e17ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCreate()&lt;/code&gt; is only run when the database file did not exist and was just created. If &lt;code&gt;onCreate()&lt;/code&gt; returns successfully (doesn't throw an exception), the database is assumed to be created with the requested version number. As an implication, you should not catch &lt;code&gt;SQLException&lt;/code&gt;s in &lt;code&gt;onCreate()&lt;/code&gt; yourself.</source>
          <target state="translated">仅当数据库文件不存在且刚创建时才运行 &lt;code&gt;onCreate()&lt;/code&gt; 。 如果 &lt;code&gt;onCreate()&lt;/code&gt; 成功返回（不引发异常），则假定使用请求的版本号创建数据库。 这意味着，您不应该自己在 &lt;code&gt;onCreate()&lt;/code&gt; 中捕获 &lt;code&gt;SQLException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52a588497f58d2764915ea38d2643cc534e68283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCreate()&lt;/code&gt; method is creating the tables you&amp;rsquo;ve defined and executing any other code you&amp;rsquo;ve written. However, this method will only be called if the SQLite file is missing in your app&amp;rsquo;s data directory (&lt;code&gt;/data/data/your.apps.classpath/databases&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;onCreate()&lt;/code&gt; 方法将创建您已定义的表并执行您编写的任何其他代码。 但是，仅当应用程序的数据目录（ &lt;code&gt;/data/data/your.apps.classpath/databases&lt;/code&gt; ）中缺少SQLite文件时，才会调用此方法。</target>
        </trans-unit>
        <trans-unit id="80fd512c9e2ed8dbd68e852d211837c73a662552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCreate&lt;/code&gt; will be invoked only when &lt;code&gt;getWritableDatabase()&lt;/code&gt; or &lt;code&gt;getReadableDatabase()&lt;/code&gt; is executed. And this will only invoked once when a &lt;code&gt;DBName&lt;/code&gt; specified in the first step is not available. You can add create table query on &lt;code&gt;onCreate&lt;/code&gt; method</source>
          <target state="translated">仅当执行 &lt;code&gt;getWritableDatabase()&lt;/code&gt; 或 &lt;code&gt;getReadableDatabase()&lt;/code&gt; 时，才会调用 &lt;code&gt;onCreate&lt;/code&gt; 。 并且仅在第一步中指定的 &lt;code&gt;DBName&lt;/code&gt; 不可用时才调用一次。 您可以在 &lt;code&gt;onCreate&lt;/code&gt; 方法上添加创建表查询</target>
        </trans-unit>
        <trans-unit id="b2b66bdf406d0f09a8a5166db82ebd8ca1cfd2dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onUpgrade()&lt;/code&gt; is only called when the database file exists but the stored version number is lower than requested in constructor. The &lt;code&gt;onUpgrade()&lt;/code&gt; should update the table schema to the requested version.</source>
          <target state="translated">仅当数据库文件存在但存储的版本号低于构造函数中的请求时，才调用 &lt;code&gt;onUpgrade()&lt;/code&gt; 。 &lt;code&gt;onUpgrade()&lt;/code&gt; 应该将表架构更新为请求的版本。</target>
        </trans-unit>
        <trans-unit id="64d2851cbe6bd656f37521ae0ac1a169419ecec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super(context, DBName, null, DBversion);&lt;/code&gt; - This should be invoked first line of constructor</source>
          <target state="translated">&lt;code&gt;super(context, DBName, null, DBversion);&lt;/code&gt; -应该在构造函数的第一行调用</target>
        </trans-unit>
        <trans-unit id="cc07b5e9a2cbe8042e34325702c868a7f756cdbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Uninstall from your device and run it again.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）从设备上卸载并再次运行。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b16762117ff1e4aa5110ca727eaf57373fc8478e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Setting -&amp;gt; app -&amp;gt; ClearData&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）设置-&amp;gt;应用-&amp;gt; ClearData&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d0ec10aa0085e1ddd64c273dcc81ce3e6e28953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt; Change &lt;code&gt;DATABASE_VERSION&lt;/code&gt; in your &quot;DatabaseHandler&quot; class (If you have added new column than it will upgrade automatically)</source>
          <target state="translated">&lt;strong&gt;3）&lt;/strong&gt;在&amp;ldquo; DatabaseHandler&amp;rdquo;类中更改 &lt;code&gt;DATABASE_VERSION&lt;/code&gt; （如果添加了新列，它将自动升级）</target>
        </trans-unit>
        <trans-unit id="2e3f90974d6bf64c7323810b5de72a56cbd1c941" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4)&lt;/strong&gt; Change &lt;code&gt;DATABASE_NAME&lt;/code&gt; in your &quot;DatabaseHandler&quot; class (I faced same problem. But I succeed by changing &lt;code&gt;DATABASE_NAME&lt;/code&gt;.)</source>
          <target state="translated">&lt;strong&gt;4）&lt;/strong&gt;在您的&amp;ldquo; DatabaseHandler&amp;rdquo;类中更改 &lt;code&gt;DATABASE_NAME&lt;/code&gt; （我遇到了同样的问题。但是我通过更改 &lt;code&gt;DATABASE_NAME&lt;/code&gt; 成功了。）</target>
        </trans-unit>
        <trans-unit id="772b7b2597ebdf8bd65ae0899d129d3229be7566" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;onCreate()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;onCreate()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d5412b603652710ee9c0f44b73da117842cd3cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;onUpgrade()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;onUpgrade()&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d217ab0fe304ed8aff10be0a20aeaf0141550579" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;onUpgrade&lt;/em&gt;&lt;/strong&gt;
This method is called when database version is upgraded. Suppose for the first time deployment , database version was 1 and in second deployment there was change in database structure like adding extra column in table. Suppose database version is 2 now.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;onUpgrade&lt;/em&gt;&lt;/strong&gt;升级数据库版本时将调用此方法。 假设第一次部署的数据库版本为1，第二次部署的数据库结构发生了变化，例如在表中添加了额外的列。 假设数据库版本现在为2。</target>
        </trans-unit>
        <trans-unit id="7dda1d5697973762ad0eb2945a404511c27e96c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Database version is stored within the &lt;code&gt;SQLite&lt;/code&gt; database file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;数据库版本存储在 &lt;code&gt;SQLite&lt;/code&gt; 数据库文件中。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35097e2b1b38de5ec88177ea2b0967e5b0e99a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4c7e936f65f8fa305b6798b15622abe8ff11b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note : if you want create another table or add columns or no such table, just increment the VERSION&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：如果要创建另一个表或添加列或不添加此类表，只需增加VERSION&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18944ef373afce1d4222218eb57bd76f269486b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onCreate&lt;/strong&gt; is called for the first time when creation of tables are needed. We need to override this method where we write the script for table creation which is executed by SQLiteDatabase. execSQL method. After executing in first time deployment, this method will not be called onwards.</source>
          <target state="translated">需要创建表时，首次调用&lt;strong&gt;onCreate&lt;/strong&gt; 。 我们需要在编写用于创建表的脚本时重写此方法，该脚本由SQLiteDatabase执行。 execSQL方法。 在首次部署中执行后，将不会再调用此方法。</target>
        </trans-unit>
        <trans-unit id="1278ec2d9f4d1f81cf97095607b689a8ae6f07c0" translate="yes" xml:space="preserve">
          <source>As already explained in the older answer, if the database with the name doesn't exists, it triggers &lt;code&gt;onCreate&lt;/code&gt;.</source>
          <target state="translated">如较早的答案中已经解释的，如果名称不存在的数据库不存在，它将触发 &lt;code&gt;onCreate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b7cc9cf41152d2ed94f7284d8d207381fe3e77a" translate="yes" xml:space="preserve">
          <source>Below explanation explains &lt;code&gt;onUpgrade&lt;/code&gt; case with an example.</source>
          <target state="translated">下面的解释以一个例子说明 &lt;code&gt;onUpgrade&lt;/code&gt; 的情况。</target>
        </trans-unit>
        <trans-unit id="7aef22f06e7acf5e4cdc47aff93b63fc26795842" translate="yes" xml:space="preserve">
          <source>Below is the code snippet (No such column found may be because of spell in column name):</source>
          <target state="translated">以下是代码片段(没有发现此列可能是因为列名拼写问题)。</target>
        </trans-unit>
        <trans-unit id="f6dec3895ac0e2b4853631e27ec4423ac775a9b6" translate="yes" xml:space="preserve">
          <source>Clear application data. Use the application manager.</source>
          <target state="translated">清除应用数据。使用应用管理器。</target>
        </trans-unit>
        <trans-unit id="219e6da53d0987275653ea784c3537411cfa82a9" translate="yes" xml:space="preserve">
          <source>Delete the old database file so that &lt;code&gt;onCreate()&lt;/code&gt; is run again. This is often preferred at development time where you have control over the installed versions and data loss is not an issue. Some ways to to delete the database file:</source>
          <target state="translated">删除旧的数据库文件，以便再次运行 &lt;code&gt;onCreate()&lt;/code&gt; 。 在您可以控制安装版本并且数据丢失不是问题的开发时间，这通常是首选。 删除数据库文件的一些方法：</target>
        </trans-unit>
        <trans-unit id="b9b5663cfae5cb5cebd7d22a54fff4e90845e4ca" translate="yes" xml:space="preserve">
          <source>Example pseudo code below:</source>
          <target state="translated">下面的伪代码示例。</target>
        </trans-unit>
        <trans-unit id="0565d729ac8439c486301e8d3d88f3dab360c7ed" translate="yes" xml:space="preserve">
          <source>For development time schema upgrades where data loss is not an issue, you can just use &lt;code&gt;execSQL(&quot;DROP TABLE IF EXISTS &amp;lt;tablename&amp;gt;&quot;)&lt;/code&gt; in to remove your existing tables and call &lt;code&gt;onCreate()&lt;/code&gt; to recreate the database.</source>
          <target state="translated">对于没有数据丢失问题的开发时架构升级，您可以仅使用 &lt;code&gt;execSQL(&quot;DROP TABLE IF EXISTS &amp;lt;tablename&amp;gt;&quot;)&lt;/code&gt; 来删除现有表并调用 &lt;code&gt;onCreate()&lt;/code&gt; 重新创建数据库。</target>
        </trans-unit>
        <trans-unit id="b2edb94e69c32d2bbff1e2001c4bd4c3d3b7f8a7" translate="yes" xml:space="preserve">
          <source>For released versions, you should implement data migration in &lt;code&gt;onUpgrade()&lt;/code&gt; so your users don't lose their data.</source>
          <target state="translated">对于已发布的版本，应在 &lt;code&gt;onUpgrade()&lt;/code&gt; 中实现数据迁移，以使用户不会丢失其数据。</target>
        </trans-unit>
        <trans-unit id="0fe14d792e5a00fd347288eb08a0a7d4975df3ed" translate="yes" xml:space="preserve">
          <source>I have created my tables in my &lt;code&gt;SQLiteOpenHelper&lt;/code&gt;&lt;code&gt;onCreate()&lt;/code&gt; but receive</source>
          <target state="translated">我已经在 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; &lt;code&gt;onCreate()&lt;/code&gt; 中创建了表，但收到了</target>
        </trans-unit>
        <trans-unit id="86bebdca7c5f2b09b8ff3092ff824f7258be374d" translate="yes" xml:space="preserve">
          <source>If old version is &lt;code&gt;3&lt;/code&gt; and new version is &lt;code&gt;4&lt;/code&gt;, it will just run the upgrade logic for &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;</source>
          <target state="translated">如果旧版本是 &lt;code&gt;3&lt;/code&gt; ，新版本是 &lt;code&gt;4&lt;/code&gt; ，它将只运行 &lt;code&gt;3&lt;/code&gt; 到 &lt;code&gt;4&lt;/code&gt; 的升级逻辑</target>
        </trans-unit>
        <trans-unit id="a09e5dc66fbed8ba718aab2f50c7b00a60efa2d9" translate="yes" xml:space="preserve">
          <source>If you are confident about syntax for creating table, than it may happen when you add new column in your same table, for that...</source>
          <target state="translated">如果你对创建表格的语法很有信心,那么当你在同一个表格中添加新列时,可能会出现这样的情况,因为.....</target>
        </trans-unit>
        <trans-unit id="e1a1616de43ff688286616dd91d759f6eb5756ee" translate="yes" xml:space="preserve">
          <source>If you forget to provide a &quot;name&quot; string as the second argument to the constructor, it creates an &quot;in-memory&quot; database which gets erased when you close the app.</source>
          <target state="translated">如果你忘了提供一个 &quot;name &quot;字符串作为构造函数的第二个参数,它会创建一个 &quot;内存中 &quot;数据库,当你关闭应用程序时,这个数据库会被删除。</target>
        </trans-unit>
        <trans-unit id="764ea625ed5a8227c7a7f557667434a20318691b" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;onUpgrade()&lt;/code&gt; method to be called, you need to increment the version number in your code.</source>
          <target state="translated">如果要调用 &lt;code&gt;onUpgrade()&lt;/code&gt; 方法，则需要增加代码中的版本号。</target>
        </trans-unit>
        <trans-unit id="832d3ad267a14cde56059605a5ae7a69c370013b" translate="yes" xml:space="preserve">
          <source>Increment the database version so that &lt;code&gt;onUpgrade()&lt;/code&gt; is invoked. This is slightly more complicated as more code is needed.</source>
          <target state="translated">递增数据库版本，以便调用 &lt;code&gt;onUpgrade()&lt;/code&gt; 。 随着需要更多代码，这会稍微复杂一些。</target>
        </trans-unit>
        <trans-unit id="d686bf3853559775a474e2b7257cc8fe41fb355c" translate="yes" xml:space="preserve">
          <source>May be I am too late but I would like to share my short and sweet answer.
Please check &lt;a href=&quot;https://stackoverflow.com/a/31605916/2110812&quot;&gt;&lt;strong&gt;Answer&lt;/strong&gt;&lt;/a&gt;  for a same problem. It will definitely help you. No more deep specifications.</source>
          <target state="translated">可能为时已晚，但我想分享我简短而甜美的答案。 请检查&lt;a href=&quot;https://stackoverflow.com/a/31605916/2110812&quot;&gt;&lt;strong&gt;答案&lt;/strong&gt;&lt;/a&gt;是否存在相同问题。 肯定会对您有帮助。 没有更深的规格。</target>
        </trans-unit>
        <trans-unit id="90b057306a09283e382db7c3fca71eb80b8e1191" translate="yes" xml:space="preserve">
          <source>Notice the missing &lt;code&gt;break&lt;/code&gt; statement in case &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. This is what I mean by incremental upgrade.</source>
          <target state="translated">注意情况 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 中缺少的 &lt;code&gt;break&lt;/code&gt; 语句。 这就是我所说的增量升级。</target>
        </trans-unit>
        <trans-unit id="9408eac0671003d490fd4b96a9780037b99e2cc8" translate="yes" xml:space="preserve">
          <source>Now say you are planing to give a third version of application with db version as &lt;code&gt;3&lt;/code&gt; (db version is increased only when database schema is to be modified). In such incremental upgrades, you have to write the upgrade logic from each version incrementally for a better maintainable code</source>
          <target state="translated">现在说您打算提供数据库版本为 &lt;code&gt;3&lt;/code&gt; 的应用程序的第三版本（仅当要修改数据库架构时才增加数据库版本）。 在这种增量升级中，您必须逐个增量地编写每个版本的升级逻辑，以便获得更好的可维护代码</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2cfd57e19fb499bbd6d722f0b08bee43403f4f11" translate="yes" xml:space="preserve">
          <source>Points to remember when extending &lt;code&gt;SQLiteOpenHelper&lt;/code&gt;</source>
          <target state="translated">扩展 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 时要记住的要点</target>
        </trans-unit>
        <trans-unit id="4f615bc61ca3348fc14ba33c4ac9f5ce59c2759f" translate="yes" xml:space="preserve">
          <source>Recheck your query in ur DatabaseHandler/DatabaseManager class(which ever you have took)</source>
          <target state="translated">在DatabaseHandlerDatabaseManager类中重新检查你的查询(无论你用了哪一个)。</target>
        </trans-unit>
        <trans-unit id="9b53c90ed931c6c5bf8c74592389bd3e00502932" translate="yes" xml:space="preserve">
          <source>Say if the old version is &lt;code&gt;2&lt;/code&gt; and new version is &lt;code&gt;4&lt;/code&gt;, then the logic will upgrade the database from &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;3&lt;/code&gt; and then to &lt;code&gt;4&lt;/code&gt;</source>
          <target state="translated">假设旧版本是 &lt;code&gt;2&lt;/code&gt; ，新版本是 &lt;code&gt;4&lt;/code&gt; ，则逻辑会将数据库从 &lt;code&gt;2&lt;/code&gt; 升级到 &lt;code&gt;3&lt;/code&gt; ，然后再升级到 &lt;code&gt;4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bf48c6a3d32c8ea186c0e256e8577dbbfe900dc" translate="yes" xml:space="preserve">
          <source>Say, your first version of application had the &lt;code&gt;DatabaseHelper&lt;/code&gt; (extending &lt;code&gt;SQLiteOpenHelper&lt;/code&gt;) with constructor passing version as &lt;code&gt;1&lt;/code&gt; and then you provided an upgraded application with the new source code having version passed as &lt;code&gt;2&lt;/code&gt;, then automatically when the &lt;code&gt;DatabaseHelper&lt;/code&gt; is constructed, platform triggers &lt;code&gt;onUpgrade&lt;/code&gt; by seeing the file already exists, but the version is lower than the current version which you have passed.</source>
          <target state="translated">假设您的第一个应用程序版本的 &lt;code&gt;DatabaseHelper&lt;/code&gt; （扩展了 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; ）的构造函数将版本传递为 &lt;code&gt;1&lt;/code&gt; ，然后您为升级后的应用程序提供了新的源代码，其版本传递为 &lt;code&gt;2&lt;/code&gt; ，然后在构造 &lt;code&gt;DatabaseHelper&lt;/code&gt; 时自动将平台触发 &lt;code&gt;onUpgrade&lt;/code&gt; ，看到文件已经存在，但是版本低于您通过的当前版本。</target>
        </trans-unit>
        <trans-unit id="c6c379f61950c21af8aec2d1a0bdb769ec13f725" translate="yes" xml:space="preserve">
          <source>So when the database helper constructor is called with a &lt;code&gt;name&lt;/code&gt; (2nd param), platform checks if the database exists or not and if the database exists, it gets the version information from the database file header and triggers the right call back</source>
          <target state="translated">因此，当使用 &lt;code&gt;name&lt;/code&gt; （第二个参数）调用数据库帮助程序构造函数时，平台会检查数据库是否存在以及数据库是否存在，它将从数据库文件头获取版本信息并触发正确的回调</target>
        </trans-unit>
        <trans-unit id="0b9aa0de05a48321d0b1095068cf5fdefe772eca" translate="yes" xml:space="preserve">
          <source>Sqlite database override two methods</source>
          <target state="translated">Sqlite数据库覆盖两种方法</target>
        </trans-unit>
        <trans-unit id="9fc35026941210204bc5f629aca07c5c4a31fc1e" translate="yes" xml:space="preserve">
          <source>Sqliteopenhelper's method have methods create and upgrade,create is used when any table is first time created and upgrade method will called everytime whenever table's number of column is changed.</source>
          <target state="translated">Sqliteopenhelper的方法有create和upgrade两种方法,create是在第一次创建任何表时使用,upgrade方法在每次改变表的列数时都会被调用。</target>
        </trans-unit>
        <trans-unit id="2d81a8a5c7bacf1c42ced5a684fcdca305568594" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onUpgrade()&lt;/code&gt; method will only be called when the version integer is larger than the current version running in the app.</source>
          <target state="translated">仅当版本整数大于应用程序中运行的当前版本时，才会调用 &lt;code&gt;onUpgrade()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6b94607bd2af0821bc4e744801dd409b2d682ab4" translate="yes" xml:space="preserve">
          <source>This method will not be called if you&amp;rsquo;ve changed your code and relaunched in the emulator.  If you want &lt;code&gt;onCreate()&lt;/code&gt; to run you need to use adb to delete the SQLite database file.</source>
          <target state="translated">如果您更改了代码并在模拟器中重新启动，则不会调用此方法。 如果要运行 &lt;code&gt;onCreate()&lt;/code&gt; ，则需要使用adb删除SQLite数据库文件。</target>
        </trans-unit>
        <trans-unit id="366b6613ea1e27174cff0bcd483c593d22850c06" translate="yes" xml:space="preserve">
          <source>To further add missing points here, as per the request by Jaskey</source>
          <target state="translated">根据Jaskey的要求,在此进一步补充遗漏的地方。</target>
        </trans-unit>
        <trans-unit id="a6569bbdcb97ed3c78d484b43591547f3090b6e0" translate="yes" xml:space="preserve">
          <source>Uninstall the application. Use the application manager or &lt;code&gt;adb uninstall your.package.name&lt;/code&gt; from shell.</source>
          <target state="translated">卸载应用程序。 使用应用程序管理器或 &lt;code&gt;adb uninstall your.package.name&lt;/code&gt; 从shell 卸载your.package.name 。</target>
        </trans-unit>
        <trans-unit id="6ff4f5bd57b7fbd3b7a7ce543d35e816134fbfd4" translate="yes" xml:space="preserve">
          <source>Uninstall your application from the emulator or device. Run the app again. (OnCreate() is not executed when the database already exists)</source>
          <target state="translated">从模拟器或设备上卸载你的应用程序。再次运行该应用程序。(当数据库已经存在时,OnCreate()不被执行)</target>
        </trans-unit>
        <trans-unit id="7089156cd1e73d659d72f216471c9b2f9cb8ff11" translate="yes" xml:space="preserve">
          <source>When changing the table schema in code (&lt;code&gt;onCreate()&lt;/code&gt;), you should make sure the database is updated. Two main approaches:</source>
          <target state="translated">在代码（ &lt;code&gt;onCreate()&lt;/code&gt; ）中更改表架构时，应确保数据库已更新。 两种主要方法：</target>
        </trans-unit>
        <trans-unit id="a8445470a2cd89d81df9215ce55b6fcdf763db23" translate="yes" xml:space="preserve">
          <source>When is SQLiteOpenHelper onCreate() / onUpgrade() run</source>
          <target state="translated">SQLiteOpenHelper onCreate()onUpgrade()何时运行?</target>
        </trans-unit>
        <trans-unit id="d0091012f5ac3e297f43ffc9c1374bcc22f85795" translate="yes" xml:space="preserve">
          <source>When we create DataBase at a first time (i.e Database is not exists) &lt;code&gt;onCreate()&lt;/code&gt; create database with version which is passed in 
&lt;code&gt;SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&lt;/code&gt;</source>
          <target state="translated">当我们第一次创建数据库（即数据库不存在）时， &lt;code&gt;onCreate()&lt;/code&gt; 创建具有在 &lt;code&gt;SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version)&lt;/code&gt; 传递的版本的数据库（上下文上下文，字符串名称，SQLiteDatabase.CursorFactory工厂，整数版本）</target>
        </trans-unit>
        <trans-unit id="804d1581563d8354862757f224f1f10106687801" translate="yes" xml:space="preserve">
          <source>Whenever you want to add new table just change &lt;code&gt;DBversion&lt;/code&gt; and do the queries in &lt;code&gt;onUpgrade&lt;/code&gt; table or simply uninstall then install the app.</source>
          <target state="translated">每当您要添加新表时，只需更改 &lt;code&gt;DBversion&lt;/code&gt; 并在 &lt;code&gt;onUpgrade&lt;/code&gt; 表中进行查询，或者简单地卸载然后安装该应用程序即可。</target>
        </trans-unit>
        <trans-unit id="53386ca891036a4cbbe13b55f9aaa49f065fa79a" translate="yes" xml:space="preserve">
          <source>You can create database &amp;amp; table like</source>
          <target state="translated">您可以创建数据库和表</target>
        </trans-unit>
        <trans-unit id="db1cf59b84c386cce2aacfee91cac73c4e4776bd" translate="yes" xml:space="preserve">
          <source>Your database name must end with .db also your query strings must have a terminator (;)</source>
          <target state="translated">你的数据库名称必须以.db结尾,你的查询字符串也必须有一个终止符(;)</target>
        </trans-unit>
        <trans-unit id="a80d24e6382e443740f8d891030ced0d61635b96" translate="yes" xml:space="preserve">
          <source>catch is the constructor</source>
          <target state="translated">catch是构造者</target>
        </trans-unit>
        <trans-unit id="a1632ff0c672d37e385809f7c8966c1663a4ffb8" translate="yes" xml:space="preserve">
          <source>errors. Why?</source>
          <target state="translated">错误。为什么?</target>
        </trans-unit>
        <trans-unit id="76b7ef80d4c5ccc3b3c59ff591e17ac9503ea18e" translate="yes" xml:space="preserve">
          <source>no such table found is mainly when you have not opened the &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; class with &lt;code&gt;getwritabledata()&lt;/code&gt; and before this you also have to call make constructor with databasename &amp;amp; version. 
And &lt;code&gt;OnUpgrade&lt;/code&gt; is called whenever there is upgrade value in version number given in &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; class.</source>
          <target state="translated">找不到这样的表的主要原因是，当您尚未使用 &lt;code&gt;getwritabledata()&lt;/code&gt; 打开 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 类时，在此之前，您还必须调用具有数据库名和版本的make构造函数。 只要在 &lt;code&gt;SQLiteOpenHelper&lt;/code&gt; 类中给定的版本号中有升级值，就会调用OnUpgrade 。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1fc8e4192a3dbfcd0f26ffb4a820f43ca5a0122f" translate="yes" xml:space="preserve">
          <source>override &lt;code&gt;onCreate&lt;/code&gt; and &lt;code&gt;onUpgrade&lt;/code&gt; (if needed)</source>
          <target state="translated">覆盖 &lt;code&gt;onCreate&lt;/code&gt; 和 &lt;code&gt;onUpgrade&lt;/code&gt; （如果需要）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
