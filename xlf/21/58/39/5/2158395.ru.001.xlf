<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2158395">
    <body>
      <group id="2158395">
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b94d16302cf154c51472d68c89f80eccc9bf39da" translate="yes" xml:space="preserve">
          <source>A little more concise, but pretty much the same.</source>
          <target state="translated">Немного лаконичнее,но почти то же самое.</target>
        </trans-unit>
        <trans-unit id="2e1e92ffc64201504c5a6eff5c1414fff1c14c5b" translate="yes" xml:space="preserve">
          <source>Also note that this is equivalent to a DFS in a tree where some nodes are sublists &lt;code&gt;A = [1, 2]&lt;/code&gt; and some are simple items: &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; (for &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt;). The tree looks like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Также обратите внимание, что это эквивалентно DFS в дереве, где некоторые узлы являются подсписками &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = [1, 2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а некоторые являются простыми элементами: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Дерево выглядит так:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39ae53263fd5d3fc2ad1e4969d6289c8ceffa883" translate="yes" xml:space="preserve">
          <source>Also note:</source>
          <target state="translated">Также обратите внимание:</target>
        </trans-unit>
        <trans-unit id="b988bb020235fef9787bc47fbe5d47be55ac3d74" translate="yes" xml:space="preserve">
          <source>Also, notice that in &lt;code&gt;is_list_like&lt;/code&gt; I have &lt;code&gt;isinstance(item, list)&lt;/code&gt;, which could be changed to handle more input types, here I just wanted to have the simplest version where (iterable) is just a list. But you could also do that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, обратите внимание, что в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;is_list_like&lt;/code&gt; у&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; меня есть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;isinstance(item, list)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , который можно изменить для обработки большего количества типов ввода, здесь я просто хотел иметь простейшую версию, где (итерируемая) - это просто список. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но вы также можете сделать это:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cc5ad86f665601e560433987cb7417b01efca95" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;flatten&lt;/code&gt; can handle infinite generators, it can not handle infinite nesting:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может обрабатывать бесконечные генераторы, он не может обрабатывать бесконечное вложение:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c9eeb6d8077aaaaf78d4e63ffe4b8b711c773d" translate="yes" xml:space="preserve">
          <source>Although an elegant and very pythonic answer has been selected I would present my solution just for the review:</source>
          <target state="translated">Несмотря на то,что был выбран элегантный и очень питонический ответ,я бы представил свое решение только для рецензии:</target>
        </trans-unit>
        <trans-unit id="79005deb294f385cf51ff98cdbfe50b8975ffaaa" translate="yes" xml:space="preserve">
          <source>Although, if you knew you would have square brackets in your list in strings, like &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt;, you would have to do something else.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя, если бы вы знали, что в вашем списке будут квадратные скобки в виде строк, например &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вам придется заняться чем-то другим.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea99bd96f840dbdf67557a459fb8a821cca61dbf" translate="yes" xml:space="preserve">
          <source>Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.</source>
          <target state="translated">По сути,он преобразует вложенный список в строку,использует регекс для удаления вложенного синтаксиса,а затем преобразует результат обратно в (сплющенный)список.</target>
        </trans-unit>
        <trans-unit id="7bce1bc51c3449501719ffd5a57d46f6c16b5528" translate="yes" xml:space="preserve">
          <source>Basically, it's the exact same thing as finding the treasure. The dungeon is the &lt;em&gt;computer's memory&lt;/em&gt;, your goal now is not to find a treasure but to &lt;em&gt;compute some function&lt;/em&gt; (find &lt;em&gt;f(x)&lt;/em&gt; for a given &lt;em&gt;x&lt;/em&gt;). The indications simply are sub-routines that will help you solving &lt;em&gt;f(x)&lt;/em&gt;. Your strategy is the same as the &lt;em&gt;call stack&lt;/em&gt; strategy, the notebook is the stack, the rooms are the functions' return addresses:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По сути, это то же самое, что найти клад. Подземелье - &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это память компьютера.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Ваша цель теперь не в том, чтобы найти сокровище, а в том, чтобы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вычислить некоторую функцию&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (найти &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f (x)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для заданного &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;x&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). Признаки просто подпрограммы, которые помогут вам решить &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f (x)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Ваша стратегия аналогична &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;стратегии &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;стека вызовов&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ноутбук - это стек, комнаты - адреса возврата функций:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="00e8a0bc89e1685335629d80defa1da3e4b13655" translate="yes" xml:space="preserve">
          <source>Call stack size and recursive programming (dungeon analogy)</source>
          <target state="translated">Размер стека вызовов и рекурсивное программирование (аналогия с подземельями)</target>
        </trans-unit>
        <trans-unit id="fe08d2e421da75ca59dd2aeab5263533ae932acd" translate="yes" xml:space="preserve">
          <source>Deprecated since version 2.6: The compiler package has been removed in Python 3.</source>
          <target state="translated">Исключен с версии 2.6:Пакет компилятора удален на Python 3.</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="6e0393cc0cfaf97f6bbc102a7c484c707418a0a6" translate="yes" xml:space="preserve">
          <source>Executing a recursive program</source>
          <target state="translated">выполнение рекурсивной программы</target>
        </trans-unit>
        <trans-unit id="cffa8ae998bde40c61124489d1d7d218e9c222c6" translate="yes" xml:space="preserve">
          <source>Finding the treasure and exit</source>
          <target state="translated">Поиск сокровищ и выход</target>
        </trans-unit>
        <trans-unit id="89d4cc02db3c116e3e5e4b9ef0aa736c4918c1e7" translate="yes" xml:space="preserve">
          <source>Flatten an irregular list of lists</source>
          <target state="translated">Раздавите нестандартный список списков</target>
        </trans-unit>
        <trans-unit id="dc5881a87e62d2dd4244fc1bbeb8669c4db39c54" translate="yes" xml:space="preserve">
          <source>For the implementation, in python you can simplify a little bit by using iterators instead of simple lists. References to the (sub)iterators will be used to store &lt;em&gt;sublists return addresses&lt;/em&gt; (instead of having both the list address and the index). This is not a big difference but I feel this is more readable (and also a bit faster):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для реализации в Python вы можете немного упростить использование итераторов вместо простых списков. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылки на (под) итераторы будут использоваться для хранения &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;адресов возврата подсписков&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (вместо того, чтобы иметь адрес списка и индекс). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не большая разница, но я чувствую, что это более читабельно (а также немного быстрее):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14b3b87237e51935f59f6a45980acb7e07912e3d" translate="yes" xml:space="preserve">
          <source>Generator using recursion and duck typing (updated for Python 3):</source>
          <target state="translated">Генератор,использующий рекурсию и набор уток (обновлен для Python 3):</target>
        </trans-unit>
        <trans-unit id="29a3d6e99377c3e58e92fa6570cbcd314d1369e0" translate="yes" xml:space="preserve">
          <source>Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:</source>
          <target state="translated">Генераторная версия не рекурсивного решения @unutbu,по запросу @Andrew в комментарии:</target>
        </trans-unit>
        <trans-unit id="de414681c4d86a10bca5d7259bca22e7cc442e38" translate="yes" xml:space="preserve">
          <source>Here are some examples demonstrating its use:</source>
          <target state="translated">Вот несколько примеров,демонстрирующих его использование:</target>
        </trans-unit>
        <trans-unit id="d761607d7fd53dc85f57f027dcb4d53b118a4328" translate="yes" xml:space="preserve">
          <source>Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...</source>
          <target state="translated">Вот еще один подход py2,я не уверен,что это самый быстрый или самый элегантный и безопасный ...</target>
        </trans-unit>
        <trans-unit id="f8f1df1a614a50ef001234abdbb4b19c8fcde356" translate="yes" xml:space="preserve">
          <source>Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:</source>
          <target state="translated">Вот моя функциональная версия рекурсивного сплющивания,которая работает как с кортежами,так и со списками,и позволяет бросать любой микс позиционных аргументов.Возвращает генератор,который производит всю последовательность по порядку,аргумент за аргументом:</target>
        </trans-unit>
        <trans-unit id="192708e2b1612f7e2636733beef7d6446a1d0792" translate="yes" xml:space="preserve">
          <source>Here's a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.</source>
          <target state="translated">Вот простая функция,которая сглаживает списки произвольной глубины.Никакой рекурсии,чтобы избежать переполнения стека.</target>
        </trans-unit>
        <trans-unit id="cca580c17fbc89a2f6cb82d0bd1f19329e72e277" translate="yes" xml:space="preserve">
          <source>Here's another answer that is even more interesting...</source>
          <target state="translated">Вот еще один ответ,который еще интереснее...</target>
        </trans-unit>
        <trans-unit id="4d57f3784cbadc37b4cfe69affdca1585e5114eb" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;compiler.ast.flatten&lt;/code&gt; implementation in 2.7.5:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реализация &lt;/font&gt;&lt;/font&gt; &lt;code&gt;compiler.ast.flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в 2.7.5:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="86313aca1240327c8110d73a59910a2e4748a8eb" translate="yes" xml:space="preserve">
          <source>How to avoid this issue?</source>
          <target state="translated">Как избежать этой проблемы?</target>
        </trans-unit>
        <trans-unit id="73311ad0ce2612a0bac165fe5b4f0d2143fe420c" translate="yes" xml:space="preserve">
          <source>I actually adapted this from some practice Scheme code that I had written a while back.</source>
          <target state="translated">На самом деле я адаптировал это из какого-то практического кода Scheme,который я написал некоторое время назад.</target>
        </trans-unit>
        <trans-unit id="1fe7bbe6a54abd708286ebfd2590e527d89fb6bf" translate="yes" xml:space="preserve">
          <source>I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :</source>
          <target state="translated">Я знаю,что уже есть много потрясающих ответов,но я хотел добавить ответ,который использует функциональный метод программирования для решения вопроса.В этом ответе я использую двойную рекурсию :</target>
        </trans-unit>
        <trans-unit id="25ff56d30963a5a4f97668f1bc5fc99613a35d75" translate="yes" xml:space="preserve">
          <source>I didn't go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp's way of first and rest list processing</source>
          <target state="translated">Я не просмотрел здесь все уже доступные ответы,но вот один лайнер,который я придумал,позаимствовав у lisp способ обработки первого и второго списков рассылки.</target>
        </trans-unit>
        <trans-unit id="63f84972799a9df278bff951da68e8c61c51e0db" translate="yes" xml:space="preserve">
          <source>I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.</source>
          <target state="translated">Я не согласен с предыдущей реализацией.Проблема в том,что вы не должны быть в состоянии сгладить что-то,что не является итерабельным.Это сбивает с толку и создает неверное впечатление об аргументе.</target>
        </trans-unit>
        <trans-unit id="d21115e6807ec7e80c0e53149fb1e2549851a053" translate="yes" xml:space="preserve">
          <source>I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:</source>
          <target state="translated">Я предпочитаю простые ответы.Никаких генераторов.Нет ограничений по рекурсии или рекурсии.Только итерация:</target>
        </trans-unit>
        <trans-unit id="d552c40c91766011979100b463254df3b544b08b" translate="yes" xml:space="preserve">
          <source>I used recursive to solve &lt;strong&gt;&lt;em&gt;nested list with any depth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я использовал рекурсив, чтобы решить &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вложенный список с любой глубиной&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5f4c4090ed4da94119c438444b23567bd92e579" translate="yes" xml:space="preserve">
          <source>I used the &lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;Iterable ABC&lt;/a&gt; added in 2.6.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я использовал &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iterable ABC,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; добавленный в 2.6.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bfd5938dfd46dcfadadefac4f96e2163678e963" translate="yes" xml:space="preserve">
          <source>I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):</source>
          <target state="translated">Я новичок в Питоне и выхожу из шумопода.Это то,что я придумал (посмотрите на названия вариков для lulz):</target>
        </trans-unit>
        <trans-unit id="02500c7b14b0e35ad9d368d2709d1abf9be8bcbc" translate="yes" xml:space="preserve">
          <source>I'm not sure if this is necessarily quicker or more effective, but this is what I do:</source>
          <target state="translated">Я не уверен,обязательно ли это быстрее или эффективнее,но это то,что я делаю:</target>
        </trans-unit>
        <trans-unit id="6237c2b268a9a2c753eb0575cba2851d46cd8806" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has thought of this. Damn recursion I don't get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it's very specific to the OP's use case</source>
          <target state="translated">Удивительно,что никто об этом не подумал.Проклятая рекурсия Я не получаю рекурсивных ответов,которые дали здесь продвинутые люди.В любом случае,это моя попытка.Оговорка в том,что она очень специфична для случая использования ОП.</target>
        </trans-unit>
        <trans-unit id="f2a887d9dc7263e6673a358d623c71925b5827af" translate="yes" xml:space="preserve">
          <source>I'm the author of the &lt;code&gt;iteration_utilities&lt;/code&gt; library.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я являюсь автором &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;библиотеки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16f02278b2307a15155e59a48d751351737d9dc0" translate="yes" xml:space="preserve">
          <source>If you like recursion, this might be a solution of interest to you:</source>
          <target state="translated">Если вам нравится рекурсия,это может быть решением,которое вас заинтересует:</target>
        </trans-unit>
        <trans-unit id="ce254e7f2d55496a2a51b2fc7c005e802480f05a" translate="yes" xml:space="preserve">
          <source>If you need to test your solution, you can use this function to generate a simple nested list:</source>
          <target state="translated">Если вам необходимо протестировать ваше решение,вы можете использовать эту функцию для создания простого вложенного списка:</target>
        </trans-unit>
        <trans-unit id="ae9dea2001369860e6d6e3b472dfa7fe73dd1491" translate="yes" xml:space="preserve">
          <source>If you're not too familiar with the call stack, then maybe the following will help (otherwise you can just scroll to the &lt;strong&gt;Implementation&lt;/strong&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не слишком знакомы со стеком вызовов, то, возможно, вам поможет следующее (в противном случае вы можете просто перейти к &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;реализации&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccc8187609cdbafce2adf1007c1c12e540acf4ff" translate="yes" xml:space="preserve">
          <source>Imagine you enter a huge &lt;em&gt;dungeon with numbered rooms&lt;/em&gt;, looking for a treasure. You don't know the place but you have some &lt;strong&gt;indications&lt;/strong&gt; on how to find the treasure. Each indication is a riddle (difficulty varies, but you can't predict how hard they will be). You decide to think a little bit about a strategy to save time, you make two observations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Представьте, что вы входите в огромное &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;подземелье с пронумерованными комнатами в&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поисках сокровищ. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы не знаете место, но у вас есть некоторые &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;указания&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; о том, как найти клад. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каждое указание - загадка (сложность варьируется, но вы не можете предсказать, насколько сложными они будут). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы решаете немного подумать о стратегии экономии времени, вы делаете два замечания:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="755295b4b33843ecc770e563e6c872d57ade6d17" translate="yes" xml:space="preserve">
          <source>In Python 3, the &lt;code&gt;basestring&lt;/code&gt; is no more, but you can use a tuple of &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; to get the same effect there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В Python 3 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;basestring&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше не существует, но вы можете использовать кортеж &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для получения того же эффекта.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63ceef487e0ed2113d3415ac21f524ca491369eb" translate="yes" xml:space="preserve">
          <source>In the end, remember that you can't print a infinitely nested list &lt;code&gt;L&lt;/code&gt; using &lt;code&gt;print(L)&lt;/code&gt; because internally it will use recursive calls to &lt;code&gt;__repr__&lt;/code&gt; (&lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt;). For the same reason, solutions to &lt;code&gt;flatten&lt;/code&gt; involving &lt;code&gt;str&lt;/code&gt; will fail with the same error message.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В конце помните, что вы не можете распечатать бесконечно вложенный список &lt;/font&gt;&lt;/font&gt; &lt;code&gt;L&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; используя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;print(L)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потому что внутренне он будет использовать рекурсивные вызовы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;__repr__&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По той же причине решения для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с участием &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; не&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будут выполнены с тем же сообщением об ошибке.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa8151a1aab9fc8bab222f58152b8c8370bb3f5f" translate="yes" xml:space="preserve">
          <source>In this example, the stack maximum size is 2, because the input list (and therefore the tree) have depth 2.</source>
          <target state="translated">В данном примере максимальный размер стека равен 2,так как входной список (и,следовательно,дерево)имеет глубину 2.</target>
        </trans-unit>
        <trans-unit id="cc4e9d94220d7cd5461a09f4298103ba3f39a77f" translate="yes" xml:space="preserve">
          <source>Is this the best model? Did I overlook something? Any problems?</source>
          <target state="translated">Это лучшая модель? Я что-то упустил из виду? Какие-нибудь проблемы?</target>
        </trans-unit>
        <trans-unit id="9be35c6488088a4b9b217f398fdaa6add15ed10f" translate="yes" xml:space="preserve">
          <source>It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...</source>
          <target state="translated">Он может игнорировать любой конкретный (или производный)тип,который вы хотите,он возвращает итератор,так что вы можете преобразовать его в любой конкретный контейнер,такой как список,кортеж,диктат или просто потребляют его,чтобы уменьшить объем памяти,к лучшему или худшему,он может обрабатывать начальные нечитаемые объекты,такие как int ...</target>
        </trans-unit>
        <trans-unit id="3e28f912c3bce57b5166b693a2a552f23ab60528" translate="yes" xml:space="preserve">
          <source>It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:</source>
          <target state="translated">Было весело пытаться создать функцию,которая могла бы сгладить нестандартный список на Python,но,конечно,для этого и нужен Python (чтобы сделать программирование веселым).Следующий генератор достаточно хорошо работает с некоторыми оговорками:</target>
        </trans-unit>
        <trans-unit id="4bb90b9d131e83bfcc3336776d86f58c4d625af1" translate="yes" xml:space="preserve">
          <source>It will flatten datatypes that you might want left alone (like &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, and &lt;code&gt;str&lt;/code&gt; objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это сгладит типы данных, которые вы можете оставить в покое (например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; объекты). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, код основывается на том факте, что запрос итератора из неповторяемого вызывает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; TypeError &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e7334089e0c1aa21da068f2629fd98c0ba9bf10" translate="yes" xml:space="preserve">
          <source>It's an iterator so you need to iterate it (for example by wrapping it with &lt;code&gt;list&lt;/code&gt; or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it's written as C extension so it can be faster than pure python approaches:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это итератор, поэтому вам нужно повторить его (например, обернуть его &lt;/font&gt;&lt;/font&gt; &lt;code&gt;list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или использовать в цикле). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Внутренне он использует итеративный подход вместо рекурсивного подхода и написан как расширение C, поэтому он может быть быстрее, чем подходы чистого Python:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="327d7cc30ef399ae94d35dcc5692804d9ea4a921" translate="yes" xml:space="preserve">
          <source>It's hard (long) to find the treasure as you'll have to solve (potentially hard) riddles to get there.</source>
          <target state="translated">Трудно (долго)найти сокровище,так как для этого вам придется разгадывать (потенциально трудные)загадки.</target>
        </trans-unit>
        <trans-unit id="42a9a19d3d56bb3334c62df22e60fdada2dcdcd2" translate="yes" xml:space="preserve">
          <source>Just use a &lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt;&lt;code&gt;funcy&lt;/code&gt;&lt;/a&gt; library:
&lt;code&gt;pip install funcy&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Просто используйте &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;библиотеку &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt; &lt;code&gt;funcy&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pip install funcy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e972ca2d74e4344909c9d769a43e177bf4b73da" translate="yes" xml:space="preserve">
          <source>My solution:</source>
          <target state="translated">Мое решение:</target>
        </trans-unit>
        <trans-unit id="bad516f05c5f73910361629673802985b60ee859" translate="yes" xml:space="preserve">
          <source>Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn't bounded by python recursion depth since the function calls are happening in C, though this doesn't mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...</source>
          <target state="translated">Обратите внимание,что большая часть тяжелого подъема выполняется на C,так как,насколько я знаю,именно так реализуются итертуалы,поэтому,хотя AFAIK и является рекурсивным,он не ограничен глубиной рекурсии питона,так как вызовы функций происходят на C,хотя это не значит,что вы ограничены памятью,особенно в OS X,где размер стека имеет жесткий лимит на сегодняшний день (OS X Mavericks)...</target>
        </trans-unit>
        <trans-unit id="ed6380feaa8a9c7ce4fafd4f95fc7270dbb5cb2e" translate="yes" xml:space="preserve">
          <source>Once the treasure found, returning to the entrance may be easy, you just have to use the same path in the other direction (though this needs a bit of memory to recall your path).</source>
          <target state="translated">Как только сокровище найдено,вернуться к входу может быть легко,вам просто нужно использовать тот же самый путь в другом направлении (хотя это требует немного памяти,чтобы вспомнить ваш путь).</target>
        </trans-unit>
        <trans-unit id="d0cd477d78798b3f11b8ce3d44411f3dfe6dd415" translate="yes" xml:space="preserve">
          <source>Or perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;in this question&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Или, может быть, даже лучше, итератор. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Единственное решение, которое я видел, что работает для произвольного вложения, находится &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в этом вопросе&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2be78dba5189bfabfa4dc4f74e5681909c29d399" translate="yes" xml:space="preserve">
          <source>Or without chaining:</source>
          <target state="translated">Или без цепей:</target>
        </trans-unit>
        <trans-unit id="195bb83dcdc0362b1e06e323cc01a996b7dc71a5" translate="yes" xml:space="preserve">
          <source>Please tell how good or bad this code is?</source>
          <target state="translated">Пожалуйста,скажите,насколько этот код хорош или плох?</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">питон 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">Питон 3</target>
        </trans-unit>
        <trans-unit id="b1a4bdad53d496f016539994db00ab42bad7ab3a" translate="yes" xml:space="preserve">
          <source>Seems to work. Test:</source>
          <target state="translated">Похоже,работает.Тест:</target>
        </trans-unit>
        <trans-unit id="b017e65239c7000352a2a4d2945b86297a105e82" translate="yes" xml:space="preserve">
          <source>Slightly simplified version of this generator:</source>
          <target state="translated">Слегка упрощенная версия этого генератора:</target>
        </trans-unit>
        <trans-unit id="4e6420f44801052d8450e03e5a463a2b1ebe007c" translate="yes" xml:space="preserve">
          <source>So after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.</source>
          <target state="translated">Поэтому после того,как я определил функцию combine_nlist,эту функцию легко использовать,делая плоскостями.Или вы можете объединить ее в одну функцию.Мне нравится мое решение,потому что оно может быть применено к любому вложенному списку.</target>
        </trans-unit>
        <trans-unit id="e66b79cc8c23c3de703aca50e255ff68402ff67a" translate="yes" xml:space="preserve">
          <source>Test-run</source>
          <target state="translated">Test-run</target>
        </trans-unit>
        <trans-unit id="0554905ed68d85c07973d301a7834f6460a2979e" translate="yes" xml:space="preserve">
          <source>Testing and remarks on other implementations</source>
          <target state="translated">Тестирование и замечания по другим реализациям</target>
        </trans-unit>
        <trans-unit id="9b290a7129085c8c8ce8c31773fae071246e9164" translate="yes" xml:space="preserve">
          <source>Testing the generator works fine with the list that was provided. However, the new code will raise a &lt;code&gt;TypeError&lt;/code&gt; when a non-iterable object is given to it. Example are shown below of the new behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тестирование генератора прекрасно работает с предоставленным списком. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, новый код вызовет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда ему передается не повторяемый объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ниже приведен пример нового поведения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="532857664f8e776457b2a0176cabc53f62598867" translate="yes" xml:space="preserve">
          <source>That's actually pretty simple: &quot;don't use recursion if you don't know how deep it can go&quot;. That's not always true as in some cases, &lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;Tail Call recursion can be Optimized (TCO)&lt;/a&gt;. But in python, this is not the case, and even &quot;well written&quot; recursive function will &lt;strong&gt;not&lt;/strong&gt; optimize stack use. There is an interesting post from Guido about this question: &lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;Tail Recursion Elimination&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это на самом деле довольно просто: &amp;laquo;не используйте рекурсию, если вы не знаете, как глубоко она может зайти&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не всегда так, поскольку в некоторых случаях &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;рекурсия Tail Call может быть оптимизирована (TCO)&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но в python это не так, и даже &amp;laquo;хорошо написанная&amp;raquo; рекурсивная функция &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; оптимизирует использование стека. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть интересный пост от Гвидо по этому вопросу: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;устранение рекурсии хвоста&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5702b5681f002e1c77cf7f5d0d3515813c4410e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatten&lt;/code&gt; function here turns the list into a string, takes out &lt;strong&gt;all&lt;/strong&gt; of the square brackets, attaches square brackets back onto the ends, and turns it back into a list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Функция &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; здесь превращает список в строку, вынимает &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;все&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; квадратные скобки, прикрепляет квадратные скобки обратно к концам и превращает его обратно в список.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8528f7ed2c3c94ffb0211e58b7f2acb86af244a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield from&lt;/code&gt; operator returns an item from a generator one at a time. This &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;syntax for delegating to a subgenerator&lt;/a&gt; was added in 3.3</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Оператор &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; возвращает элемент от генератора по одному. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;синтаксис для делегирования субгенератору&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; был добавлен в 3.3&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="154968401f3a779a0b98b804cf8977b61118a1da" translate="yes" xml:space="preserve">
          <source>The DFS traversal pre-order is: L, 0, A, 1, 2, 3, 4. Remember, in order to implement an iterative DFS you also &quot;need&quot; a stack. The implementation I proposed before result in having the following states (for the &lt;code&gt;stack&lt;/code&gt; and the &lt;code&gt;flat_list&lt;/code&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предварительный порядок обхода DFS: L, 0, A, 1, 2, 3, 4. Помните, что для реализации итеративной DFS вам также &amp;laquo;нужен&amp;raquo; стек. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реализация, которую я предложил ранее, &lt;/font&gt; &lt;code&gt;flat_list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; к следующим состояниям (для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;flat_list&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="135a1768cd4daf87f3b12fac9dbe360fe7259fd6" translate="yes" xml:space="preserve">
          <source>The code is:</source>
          <target state="translated">Код таков:</target>
        </trans-unit>
        <trans-unit id="9bb4d095e6d13b019637c537fa9e20277e4e2a63" translate="yes" xml:space="preserve">
          <source>The easiest way is to use the &lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;morph&lt;/a&gt; library using &lt;code&gt;pip install morph&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Самый простой способ - использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;библиотеку &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;morph&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pip install morph&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9730b9e2745e5198081261761f9462f7733b005a" translate="yes" xml:space="preserve">
          <source>The flattened list is then returned.</source>
          <target state="translated">Затем возвращается расплющенный список.</target>
        </trans-unit>
        <trans-unit id="b6b91a4964cc48f9f9afa9ebc468a09d9ec028d7" translate="yes" xml:space="preserve">
          <source>The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.</source>
          <target state="translated">Следующий генератор почти такой же,как и первый,но не имеет проблемы с попыткой сгладить неграмотный объект.Он терпит неудачу,как и следовало ожидать,когда ему дается неуместный аргумент.</target>
        </trans-unit>
        <trans-unit id="bf5ea765f8026469fe3f7a96d57d282354586b40" translate="yes" xml:space="preserve">
          <source>The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.</source>
          <target state="translated">Внутренняя для цикла итераций через список.Если он находит элемент списка,то (1)использует list.extended()для выравнивания этой части одного уровня вложенности и (2)переключается keepChecking в True.keepchecking используется для управления внешним в цикле.Если внешнему циклу присваивается значение true,то он запускает внутренний цикл для другого прохода.</target>
        </trans-unit>
        <trans-unit id="072c6ff6dd9019102323263f9272dee7bb233cef" translate="yes" xml:space="preserve">
          <source>The problem you encountered in the dungeon will be the same here, the call stack has a finite size (here 1000) and therefore, if you enter too many functions without returning back then you'll fill the call stack and have an error that look like &lt;strike&gt;&quot;Dear adventurer, I'm very sorry but your notebook is full&quot;&lt;/strike&gt;: &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt;. Note that you don't need recursion to fill the call stack, but it's very unlikely that a non-recursive program call 1000 functions without ever returning. It's important to also understand that once you returned from a function, the call stack is freed from the address used (hence the name &quot;stack&quot;, return address are pushed in before entering a function and pulled out when returning). In the special case of a simple recursion (a function &lt;code&gt;f&lt;/code&gt; that call itself once -- over and over --) you will enter &lt;code&gt;f&lt;/code&gt; over and over until the computation is finished (until the treasure is found) and return from &lt;code&gt;f&lt;/code&gt; until you go back to the place where you called &lt;code&gt;f&lt;/code&gt; in the first place. The call stack will never be freed from anything until the end where it will be freed from all return addresses one after the other.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Проблема, с которой вы столкнулись в подземелье, будет такой же: стек вызовов имеет конечный размер (здесь 1000), и поэтому, если вы введете слишком много функций без возврата назад, вы заполняете стек вызовов и получаете сообщение об ошибке как &lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Уважаемый искатель приключений, мне очень жаль, но ваша записная книжка заполнена&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, Обратите внимание, что вам не нужна рекурсия для заполнения стека вызовов, но очень маловероятно, чтобы нерекурсивная программа вызывала 1000 функций без какого-либо возврата. Также важно понимать, что после того, как вы вернулись из функции, стек вызовов освобождается от используемого адреса (следовательно, имя &amp;laquo;стек&amp;raquo;, адрес возврата вставляется перед входом в функцию и извлекается при возврате). В особом случае простой рекурсии (функция &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которая вызывает себя один раз, снова и снова), вы будете вводить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; снова и снова, пока не закончится вычисление (пока не будет найдено сокровище), и возвращаться из &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; до тех пор, пока вы не уйдете обратно в то место, где вы назвали &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в первую очередь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Стек вызовов никогда не будет освобожден ни от чего до конца, где он будет освобожден от всех адресов возврата один за другим.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fccb286979da55d6c6e125dbea7209d07f046f87" translate="yes" xml:space="preserve">
          <source>There are better, faster methods (If you've reached here, you have seen them already)</source>
          <target state="translated">Есть лучшие,более быстрые методы (если вы достигли здесь,вы уже видели их).</target>
        </trans-unit>
        <trans-unit id="f9caba178eb8922f0394406ccdde49ee49df43a0" translate="yes" xml:space="preserve">
          <source>There is a technique that you can use to make any recursive function iterative, this technique we could call &lt;em&gt;&lt;strong&gt;bring your own notebook&lt;/strong&gt;&lt;/em&gt;. For example, in our particular case we simply are exploring a list, entering a room is equivalent to entering a sublist, the question you should ask yourself is &lt;em&gt;how can I get back from a list to its parent list?&lt;/em&gt; The answer is not that complex, repeat the following until the &lt;code&gt;stack&lt;/code&gt; is empty:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть методика, которую вы можете использовать, чтобы сделать любую рекурсивную функцию итеративной, этот метод, который мы могли бы назвать, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;принесет ваш собственный блокнот&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, в нашем конкретном случае мы просто изучаем список, вход в комнату эквивалентен вводу подсписка, вопрос, который вы должны задать себе, - &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как я могу вернуться из списка в его родительский список? &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответ не так сложен, повторяйте следующее до тех пор, пока &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; станет пустым:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a76c19332391eecb7270208d09b08dff1cefe111" translate="yes" xml:space="preserve">
          <source>This considers strings as &quot;simple items&quot; and therefore &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; will return &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; and not &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt;. Remark that in that case, &lt;code&gt;iter(item)&lt;/code&gt; is called twice on each item, let's pretend it's an exercise for the reader to make this cleaner.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это рассматривает строки как &quot;простые элементы&quot;, и поэтому &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет возвращать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а не &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Заметим, что в этом случае &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iter(item)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вызывается дважды для каждого элемента, давайте представим, что это упражнение для читателя, чтобы сделать это чище.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35450707d84bb0ce84709e530c6a2b600bd4d904" translate="yes" xml:space="preserve">
          <source>This is a simple implement of flatten on python2</source>
          <target state="translated">Это простое приспособление сплющенное на питоне2.</target>
        </trans-unit>
        <trans-unit id="2e4799018e16d870c6e5e1422846257d94aa57ba" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;flatten&lt;/code&gt; avoids python's recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта версия &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; позволяет избежать предела рекурсии Python (и, следовательно, работает с произвольно глубокими вложенными итерациями). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это генератор, который может обрабатывать строки и произвольные итерации (даже бесконечные).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2bd5654ac77b479f712d41c3a504f60b62c199d" translate="yes" xml:space="preserve">
          <source>This will flatten a list or dictionary (or list of lists or dictionaries of dictionaries etc). It assumes that the values are strings and it creates a string that concatenates each item with a separator argument. If you wanted you could use the separator to split the result into a list object afterward. It uses recursion if the next value is a list or a string. Use the key argument to tell whether you want the keys or the values (set key to false) from the dictionary object.</source>
          <target state="translated">Это позволит сгладить список или словарь (или список списков или словарей словарей и т.д.).Предполагается,что значения являются строками,и создается строка,соединяющая каждый элемент с аргументом-разделителем.При желании вы можете использовать разделитель для последующего разделения результата на объект списка.Он использует рекурсию,если следующим значением является список или строка.Используйте аргумент ключа,чтобы сказать,нужны ли вам ключи или значения (установите значение ключа в false)из объекта словаря.</target>
        </trans-unit>
        <trans-unit id="77dfd5cfcd224f3d1363dfe3cb85003efe050d9f" translate="yes" xml:space="preserve">
          <source>This works with two lists: an inner for loop and an outer while loop.</source>
          <target state="translated">Это работает с двумя списками:внутренний для петли и внешний для петли while.</target>
        </trans-unit>
        <trans-unit id="e537559c79429148f10b6b9cf0978b9e2371bc8a" translate="yes" xml:space="preserve">
          <source>Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.</source>
          <target state="translated">Эти пропуски продолжаются до тех пор,пока больше не будут найдены вложенные списки.Когда,наконец,возникает передача,где ни одна из них не найдена,keepChecking никогда не срабатывает до true,что означает,что listINested остается ложным,а внешняя передача,когда цикл завершается,остается ложной.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="303c2ecddc270d76490ec99651c75c05229ac735" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;itertools.chain&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;itertools.chain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="057ed5e75ff2f0ad40d7cbbc26525344260fd727" translate="yes" xml:space="preserve">
          <source>Using generator functions can make your example a little easier to read and probably boost the performance.</source>
          <target state="translated">Использование функций генератора может сделать ваш пример немного проще для чтения и,возможно,повысить производительность.</target>
        </trans-unit>
        <trans-unit id="2217cada8873c4496bd08dcd7534fbce6ad78f5c" translate="yes" xml:space="preserve">
          <source>When I say &lt;em&gt;most of the codes&lt;/em&gt; I mean all codes that use any form of recursion (or call a standard library function that is recursive). All these codes fail because for every of the recursive call made, the (call) stack grow by one unit, and the (default) python call stack has a size of 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда я говорю &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;большинство кодов,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; я имею в виду все коды, которые используют любую форму рекурсии (или вызывают стандартную библиотечную функцию, которая является рекурсивной). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все эти коды терпят неудачу, потому что для каждого сделанного рекурсивного вызова стек (вызова) увеличивается на одну единицу, а стек вызовов (по умолчанию) python имеет размер 1000.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d2be4bbcc49edcd35c84a1c8296c7bc26899184" translate="yes" xml:space="preserve">
          <source>When entering the dungeon, you notice a small &lt;strong&gt;notebook&lt;/strong&gt; here. You decide to use it to write down every room you exit after solving a riddle (when entering a new room), this way you'll be able to return back to the entrance. That's a genius idea, you &lt;em&gt;won't even spend a cent&lt;/em&gt; implementing your strategy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При входе в темницу вы замечаете небольшую &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тетрадь&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; здесь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы решаете использовать его, чтобы записать каждую комнату, в которую вы выходите после решения загадки (при входе в новую комнату), таким образом, вы сможете вернуться обратно ко входу. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это гениальная идея, вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;даже не потратите ни цента на&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; реализацию своей стратегии.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea08aaefc36c7bd0e08223e9634c0ae634211149" translate="yes" xml:space="preserve">
          <source>When trying to answer such a question you really need to give the limitations of the code you propose as a solution. If it was only about performances I wouldn't mind too much, but most of the codes proposed as solution (including the accepted answer) fail to flatten any list that has a depth greater than 1000.</source>
          <target state="translated">При попытке ответить на такой вопрос действительно необходимо дать ограничения кода,который вы предлагаете в качестве решения.Если бы речь шла только о производительности,я бы не возражал,но большинство кодов,предлагаемых в качестве решения (в том числе и принятый ответ),не могут сгладить любой список,который имеет глубину более 1000.</target>
        </trans-unit>
        <trans-unit id="1c4f6558f38981ddb59d040b4538d37b7efc2d09" translate="yes" xml:space="preserve">
          <source>Where the desired output is</source>
          <target state="translated">Где нужный выход</target>
        </trans-unit>
        <trans-unit id="07d07b7b8ea752db0d14deeb6cb38e985e165f11" translate="yes" xml:space="preserve">
          <source>Which gives: &lt;code&gt;build_deep_list(5)&lt;/code&gt; &amp;gt;&amp;gt;&amp;gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что дает: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;build_deep_list(5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12006179f5926aac3184169403362f3f9c481acf" translate="yes" xml:space="preserve">
          <source>Without using any library:</source>
          <target state="translated">Без использования библиотеки:</target>
        </trans-unit>
        <trans-unit id="bf88998d5c009de437a318db8effc7a1537c6a7e" translate="yes" xml:space="preserve">
          <source>Yes, I know this subject has been covered before (&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;here&lt;/a&gt;), but as far as I know, all solutions, except for one, fail on a list like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Да, я знаю, что эта тема уже была рассмотрена ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), но, насколько я знаю, все решения, кроме одного, терпят неудачу в таком списке:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74a1b281a15fddb74b8fce9e6b33b2503f2b15ba" translate="yes" xml:space="preserve">
          <source>You could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;deepflatten&lt;/code&gt;&lt;/a&gt; from the 3rd party package &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt;&lt;code&gt;iteration_utilities&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;deepflatten&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из стороннего пакета &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3debaf3c28a15f60ba292768b82cfaf8dfacc54c" translate="yes" xml:space="preserve">
          <source>You enter the dungeon, solving with great success the first 1001 riddles, but here comes something you hadn't planed, you have no space left in the notebook you borrowed. You decide to &lt;em&gt;abandon&lt;/em&gt; your quest as you prefer not having the treasure than being lost forever inside the dungeon (that looks smart indeed).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы входите в темницу, с большим успехом разгадывая первые 1001 загадку, но тут появляется то, что вы не планировали, у вас нет места в заимствованной вами записной книжке. Вы решаете &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отказаться от&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; своего квеста, так как предпочитаете не иметь сокровища, а быть потерянным навсегда в подземелье (это выглядит действительно умно).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64d4175e880a1832a2a0d0bb31fd6657fe5d0d89" translate="yes" xml:space="preserve">
          <source>every time an item is found, &lt;code&gt;yield&lt;/code&gt; it (or add them in a list);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;каждый раз, когда предмет найден, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; его (или добавьте в список);&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e51c354b48926dd260c73a845d3893393cf58cb" translate="yes" xml:space="preserve">
          <source>here is one simple and one not-so-simple case -</source>
          <target state="translated">вот один простой и не очень простой случай -</target>
        </trans-unit>
        <trans-unit id="adc6d4918f750b646571daa2e00df52c14b564db" translate="yes" xml:space="preserve">
          <source>here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt; so use it with caution ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь мы используем наборы для проверки типа, поэтому требуется O (1) против O (количество типов), чтобы проверить, следует ли игнорировать элемент, хотя, конечно, любое значение с производным типом указанных игнорируемых типов не будет выполнено Вот почему он использует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unicode&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поэтому используйте его с осторожностью ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccedab2b750529fb2f1b87bbe07378ea34020ea1" translate="yes" xml:space="preserve">
          <source>once a list is fully explored, go back to the parent list using the &lt;code&gt;stack&lt;/code&gt;&lt;em&gt;return &lt;code&gt;address&lt;/code&gt; (and &lt;code&gt;index&lt;/code&gt;)&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;как только список полностью изучен, вернитесь к родительскому списку, используя &lt;/font&gt;&lt;em&gt; &lt;code&gt;address&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; возврата &lt;/font&gt;&lt;/em&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(и &lt;/font&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;index&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="296855ad54af49593cc7b3f4e5521f091bd38983" translate="yes" xml:space="preserve">
          <source>push the current list &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; in a &lt;code&gt;stack&lt;/code&gt; when entering a new sublist (note that a list address+index is also an address, therefore we just use the exact same technique used by the call stack);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;помещать текущий &lt;/font&gt;&lt;/font&gt; &lt;code&gt;address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; списка &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; при входе в новый подсписок (обратите внимание, что адрес списка + индекс также является адресом, поэтому мы просто используем ту же самую технику, которая используется стеком вызовов);&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a5301a88da334dc5afc5b63979daa0f3f45e68" translate="yes" xml:space="preserve">
          <source>result</source>
          <target state="translated">result</target>
        </trans-unit>
        <trans-unit id="37b8dabf0b7bfae1c2eecb47a6afcd8bc92cc94c" translate="yes" xml:space="preserve">
          <source>returns:</source>
          <target state="translated">returns:</target>
        </trans-unit>
        <trans-unit id="9dd608f36d0db13a98f4add5e42d48a50fa3c769" translate="yes" xml:space="preserve">
          <source>tests:</source>
          <target state="translated">tests:</target>
        </trans-unit>
        <trans-unit id="90b34293d40fd211f22a7eb82950647a7a0d5b3f" translate="yes" xml:space="preserve">
          <source>there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you'll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...</source>
          <target state="translated">есть несколько более быстрый подход,но менее портативный метод,используйте его только в том случае,если можно предположить,что базовые элементы входа могут быть явно определены иначе,вы получите бесконечную рекурсию,а OS X с ее ограниченным размером стека,достаточно быстро бросит ошибку сегментации ...</target>
        </trans-unit>
        <trans-unit id="e33ad899228cb347b7c6fd1b4662e7475fffbffc" translate="yes" xml:space="preserve">
          <source>totally hacky but I think it would work (depending on your data_type)</source>
          <target state="translated">совершенно халтурный,но я думаю,что это сработает (в зависимости от вашего типа data_type).</target>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="translated">yields:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
