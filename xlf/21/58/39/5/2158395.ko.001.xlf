<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2158395">
    <body>
      <group id="2158395">
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b94d16302cf154c51472d68c89f80eccc9bf39da" translate="yes" xml:space="preserve">
          <source>A little more concise, but pretty much the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;조금 더 간결하지만 거의 동일합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e1e92ffc64201504c5a6eff5c1414fff1c14c5b" translate="yes" xml:space="preserve">
          <source>Also note that this is equivalent to a DFS in a tree where some nodes are sublists &lt;code&gt;A = [1, 2]&lt;/code&gt; and some are simple items: &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; (for &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt;). The tree looks like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 이것은 일부 노드가 하위 목록 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = [1, 2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이고 일부는 간단한 항목 인 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;트리의 DFS &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 같습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나무는 다음과 같습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39ae53263fd5d3fc2ad1e4969d6289c8ceffa883" translate="yes" xml:space="preserve">
          <source>Also note:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고 사항 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b988bb020235fef9787bc47fbe5d47be55ac3d74" translate="yes" xml:space="preserve">
          <source>Also, notice that in &lt;code&gt;is_list_like&lt;/code&gt; I have &lt;code&gt;isinstance(item, list)&lt;/code&gt;, which could be changed to handle more input types, here I just wanted to have the simplest version where (iterable) is just a list. But you could also do that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;is_list_like&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 많은 입력 유형을 처리하도록 변경할 수있는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;isinstance(item, list)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 있습니다. 여기서 (iterable)이 목록 인 가장 간단한 버전을 원했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 당신은 또한 그것을 할 수 있습니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cc5ad86f665601e560433987cb7417b01efca95" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;flatten&lt;/code&gt; can handle infinite generators, it can not handle infinite nesting:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 무한 생성기를 처리 할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무한 중첩을 처리 할 수는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c9eeb6d8077aaaaf78d4e63ffe4b8b711c773d" translate="yes" xml:space="preserve">
          <source>Although an elegant and very pythonic answer has been selected I would present my solution just for the review:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우아하고 매우 pythonic 답변이 선택되었지만 검토를 위해 내 솔루션을 제시합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79005deb294f385cf51ff98cdbfe50b8975ffaaa" translate="yes" xml:space="preserve">
          <source>Although, if you knew you would have square brackets in your list in strings, like &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt;, you would have to do something else.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 같이 문자열에 대괄호가 있음을 알고 있다면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 작업을 수행해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea99bd96f840dbdf67557a459fb8a821cca61dbf" translate="yes" xml:space="preserve">
          <source>Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 중첩 목록을 문자열로 변환하고 정규 표현식을 사용하여 중첩 구문을 제거한 다음 결과를 (평평한) 목록으로 다시 변환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bce1bc51c3449501719ffd5a57d46f6c16b5528" translate="yes" xml:space="preserve">
          <source>Basically, it's the exact same thing as finding the treasure. The dungeon is the &lt;em&gt;computer's memory&lt;/em&gt;, your goal now is not to find a treasure but to &lt;em&gt;compute some function&lt;/em&gt; (find &lt;em&gt;f(x)&lt;/em&gt; for a given &lt;em&gt;x&lt;/em&gt;). The indications simply are sub-routines that will help you solving &lt;em&gt;f(x)&lt;/em&gt;. Your strategy is the same as the &lt;em&gt;call stack&lt;/em&gt; strategy, the notebook is the stack, the rooms are the functions' return addresses:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 보물을 찾는 것과 똑같습니다. 던전은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴퓨터의 메모리입니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 이제 목표는 보물을 찾는 것이 아니라 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 함수&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계산하는 것입니다&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주어진 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;x에&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f (x)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 찾기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;). 표시는 단순히 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f (x)&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해결에 도움이되는 서브 루틴입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 전략은 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;콜 스택&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 전략 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과 동일 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 노트북은 스택이며 방은 함수의 반환 주소입니다.&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="00e8a0bc89e1685335629d80defa1da3e4b13655" translate="yes" xml:space="preserve">
          <source>Call stack size and recursive programming (dungeon analogy)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;콜 스택 크기 및 재귀 프로그래밍 (던전 유추)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe08d2e421da75ca59dd2aeab5263533ae932acd" translate="yes" xml:space="preserve">
          <source>Deprecated since version 2.6: The compiler package has been removed in Python 3.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;버전 2.6부터 사용되지 않음 : 컴파일러 패키지가 Python 3에서 제거되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="6e0393cc0cfaf97f6bbc102a7c484c707418a0a6" translate="yes" xml:space="preserve">
          <source>Executing a recursive program</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀 프로그램 실행&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cffa8ae998bde40c61124489d1d7d218e9c222c6" translate="yes" xml:space="preserve">
          <source>Finding the treasure and exit</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보물 찾기 및 종료&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89d4cc02db3c116e3e5e4b9ef0aa736c4918c1e7" translate="yes" xml:space="preserve">
          <source>Flatten an irregular list of lists</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불규칙한 목록 목록을 병합&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc5881a87e62d2dd4244fc1bbeb8669c4db39c54" translate="yes" xml:space="preserve">
          <source>For the implementation, in python you can simplify a little bit by using iterators instead of simple lists. References to the (sub)iterators will be used to store &lt;em&gt;sublists return addresses&lt;/em&gt; (instead of having both the list address and the index). This is not a big difference but I feel this is more readable (and also a bit faster):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현을 위해 파이썬에서는 간단한 목록 대신 반복자를 사용하여 조금 단순화 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(반복자) 반복자에 대한 참조는 ( &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;목록 주소와 색인이 아닌) &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 목록 리턴 주소&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 저장하는 데 사용됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 큰 차이는 아니지만 이것이 더 읽기 쉽다고 느낍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14b3b87237e51935f59f6a45980acb7e07912e3d" translate="yes" xml:space="preserve">
          <source>Generator using recursion and duck typing (updated for Python 3):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀 및 덕 입력을 사용하는 생성기 (Python 3 용으로 업데이트 됨) :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29a3d6e99377c3e58e92fa6570cbcd314d1369e0" translate="yes" xml:space="preserve">
          <source>Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의견에 @Andrew가 요청한 @unutbu의 비 재귀 솔루션 생성기 버전 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de414681c4d86a10bca5d7259bca22e7cc442e38" translate="yes" xml:space="preserve">
          <source>Here are some examples demonstrating its use:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 그 사용법을 보여주는 몇 가지 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d761607d7fd53dc85f57f027dcb4d53b118a4328" translate="yes" xml:space="preserve">
          <source>Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에 또 다른 py2 접근법이 있습니다. 가장 빠르거나 가장 우아하고 안전한지 확실하지 않습니다 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8f1df1a614a50ef001234abdbb4b19c8fcde356" translate="yes" xml:space="preserve">
          <source>Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 튜플과 목록을 모두 처리하고 위치 인수를 혼합하여 사용할 수있는 재귀 평면화의 기능 버전입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;arg를 기준으로 arg 전체 순서를 생성하는 생성기를 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="192708e2b1612f7e2636733beef7d6446a1d0792" translate="yes" xml:space="preserve">
          <source>Here's a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 임의의 깊이 목록을 평평하게하는 간단한 함수입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스택 오버플로를 피하기 위해 재귀가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cca580c17fbc89a2f6cb82d0bd1f19329e72e277" translate="yes" xml:space="preserve">
          <source>Here's another answer that is even more interesting...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 흥미로운 또 다른 대답은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d57f3784cbadc37b4cfe69affdca1585e5114eb" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;compiler.ast.flatten&lt;/code&gt; implementation in 2.7.5:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2.7.5 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;compiler.ast.flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구현은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="86313aca1240327c8110d73a59910a2e4748a8eb" translate="yes" xml:space="preserve">
          <source>How to avoid this issue?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제를 피하는 방법?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="73311ad0ce2612a0bac165fe5b4f0d2143fe420c" translate="yes" xml:space="preserve">
          <source>I actually adapted this from some practice Scheme code that I had written a while back.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 실제로 얼마 전에 작성한 연습 계획 코드에서 이것을 적용했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1fe7bbe6a54abd708286ebfd2590e527d89fb6bf" translate="yes" xml:space="preserve">
          <source>I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 이미 멋진 답변이 많이 있다는 것을 알고 있지만 질문을 해결하는 함수형 프로그래밍 방법을 사용하는 답변을 추가하고 싶었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 대답에서는 이중 재귀를 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25ff56d30963a5a4f97668f1bc5fc99613a35d75" translate="yes" xml:space="preserve">
          <source>I didn't go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp's way of first and rest list processing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 여기에 이미 사용 가능한 모든 대답을 겪지 않았지만 여기에 lisp의 첫 번째 방법과 나머지 목록 처리 방법에서 빌린 하나의 라이너가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63f84972799a9df278bff951da68e8c61c51e0db" translate="yes" xml:space="preserve">
          <source>I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전 구현에 동의하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제는 반복 불가능한 것을 평평하게 할 수 없다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 혼란스럽고 논쟁에 대한 잘못된 인상을줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d21115e6807ec7e80c0e53149fb1e2549851a053" translate="yes" xml:space="preserve">
          <source>I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 간단한 답변을 선호합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;발전기가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀 또는 재귀 제한이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그냥 반복 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d552c40c91766011979100b463254df3b544b08b" translate="yes" xml:space="preserve">
          <source>I used recursive to solve &lt;strong&gt;&lt;em&gt;nested list with any depth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀를 사용하여 &lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;깊이가있는 중첩 목록&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 해결했습니다.&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5f4c4090ed4da94119c438444b23567bd92e579" translate="yes" xml:space="preserve">
          <source>I used the &lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;Iterable ABC&lt;/a&gt; added in 2.6.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2.6에 추가 된 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iterable ABC를&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bfd5938dfd46dcfadadefac4f96e2163678e963" translate="yes" xml:space="preserve">
          <source>I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 파이썬을 처음 사용하고 lisp 배경에서 왔습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 내가 생각해 낸 것입니다 (lulz의 var 이름을 확인하십시오).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02500c7b14b0e35ad9d368d2709d1abf9be8bcbc" translate="yes" xml:space="preserve">
          <source>I'm not sure if this is necessarily quicker or more effective, but this is what I do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 반드시 더 빠르거나 효과적인지 확실하지 않지만 이것이 내가하는 일입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6237c2b268a9a2c753eb0575cba2851d46cd8806" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has thought of this. Damn recursion I don't get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it's very specific to the OP's use case</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아무도 이것에 대해 생각하지 않은 것에 놀랐습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀 끔찍한 나는 여기에 고급 사람들이 한 재귀 답변을 얻지 못합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어쨌든 여기에 내 시도가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주의 사항은 OP의 사용 사례에 매우 구체적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2a887d9dc7263e6673a358d623c71925b5827af" translate="yes" xml:space="preserve">
          <source>I'm the author of the &lt;code&gt;iteration_utilities&lt;/code&gt; library.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라이브러리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 저자입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16f02278b2307a15155e59a48d751351737d9dc0" translate="yes" xml:space="preserve">
          <source>If you like recursion, this might be a solution of interest to you:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀를 좋아하는 경우 관심있는 솔루션 일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce254e7f2d55496a2a51b2fc7c005e802480f05a" translate="yes" xml:space="preserve">
          <source>If you need to test your solution, you can use this function to generate a simple nested list:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;솔루션을 테스트해야하는 경우이 함수를 사용하여 간단한 중첩 목록을 생성 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae9dea2001369860e6d6e3b472dfa7fe73dd1491" translate="yes" xml:space="preserve">
          <source>If you're not too familiar with the call stack, then maybe the following will help (otherwise you can just scroll to the &lt;strong&gt;Implementation&lt;/strong&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호출 스택에 익숙하지 않은 경우 다음이 도움이 될 것입니다 (그렇지 않으면 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현으로&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스크롤 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccc8187609cdbafce2adf1007c1c12e540acf4ff" translate="yes" xml:space="preserve">
          <source>Imagine you enter a huge &lt;em&gt;dungeon with numbered rooms&lt;/em&gt;, looking for a treasure. You don't know the place but you have some &lt;strong&gt;indications&lt;/strong&gt; on how to find the treasure. Each indication is a riddle (difficulty varies, but you can't predict how hard they will be). You decide to think a little bit about a strategy to save time, you make two observations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;번호가 매겨진 방&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 거대한 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지하 감옥에&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 들어가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보물을 찾고 있다고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상상해보십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 장소를 모르지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보물을 찾는 방법에 대한 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표시&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 표시는 수수께끼입니다 (난이도는 다르지만 얼마나 힘들지는 예측할 수 없습니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간을 절약하기위한 전략에 대해 약간 생각하고 두 가지 관찰을합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="755295b4b33843ecc770e563e6c872d57ade6d17" translate="yes" xml:space="preserve">
          <source>In Python 3, the &lt;code&gt;basestring&lt;/code&gt; is no more, but you can use a tuple of &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; to get the same effect there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이썬 3에서는 기본 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;basestring&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 더 이상 없지만 튜플 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하여 동일한 효과를 얻을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63ceef487e0ed2113d3415ac21f524ca491369eb" translate="yes" xml:space="preserve">
          <source>In the end, remember that you can't print a infinitely nested list &lt;code&gt;L&lt;/code&gt; using &lt;code&gt;print(L)&lt;/code&gt; because internally it will use recursive calls to &lt;code&gt;__repr__&lt;/code&gt; (&lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt;). For the same reason, solutions to &lt;code&gt;flatten&lt;/code&gt; involving &lt;code&gt;str&lt;/code&gt; will fail with the same error message.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결국 &lt;/font&gt; &lt;code&gt;print(L)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무한히 중첩 된 목록 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;L&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인쇄&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할 수 없다는 점을 기억하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부적으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;__repr__&lt;/code&gt; 에 대한&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 재귀 호출을 사용하기 때문입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 이유로 &lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 관련된 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 솔루션 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 동일한 오류 메시지와 함께 실패합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa8151a1aab9fc8bab222f58152b8c8370bb3f5f" translate="yes" xml:space="preserve">
          <source>In this example, the stack maximum size is 2, because the input list (and therefore the tree) have depth 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 예에서 입력 목록 (및 트리)의 깊이는 2이므로 스택 최대 크기는 2입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc4e9d94220d7cd5461a09f4298103ba3f39a77f" translate="yes" xml:space="preserve">
          <source>Is this the best model? Did I overlook something? Any problems?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 최고의 모델입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 뭔가 간과 했습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제가 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9be35c6488088a4b9b217f398fdaa6add15ed10f" translate="yes" xml:space="preserve">
          <source>It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원하는 특정 (또는 파생 된) 유형을 무시하고 반복자를 반환하므로 목록, 튜플, dict와 같은 특정 컨테이너로 변환하거나 메모리 풋 프린트를 줄이기 위해 간단히 소비 할 수 있습니다. int와 같은 반복 불가능한 초기 객체를 처리 할 수 ​​있습니다 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e28f912c3bce57b5166b693a2a552f23ab60528" translate="yes" xml:space="preserve">
          <source>It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이썬에서 불규칙한 목록을 평평하게 할 수있는 함수를 만드는 것은 재미 있었지만, 물론 그것은 파이썬이 프로그래밍을 즐겁게하기위한 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같은 생성기는 일부 경고에 상당히 잘 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4bb90b9d131e83bfcc3336776d86f58c4d625af1" translate="yes" xml:space="preserve">
          <source>It will flatten datatypes that you might want left alone (like &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, and &lt;code&gt;str&lt;/code&gt; objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 객체 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같이 남겨두고 싶은 데이터 유형을 병합 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 코드는 반복 불가능한 반복자를 요청하면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; 발생&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 한다는 사실에 의존합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e7334089e0c1aa21da068f2629fd98c0ba9bf10" translate="yes" xml:space="preserve">
          <source>It's an iterator so you need to iterate it (for example by wrapping it with &lt;code&gt;list&lt;/code&gt; or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it's written as C extension so it can be faster than pure python approaches:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반복자이므로 반복해야합니다 (예 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 감싸 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;거나 루프에서 사용). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부적으로 재귀 적 접근 방식 대신 반복적 접근 방식을 사용하며 C 확장으로 작성되므로 순수한 파이썬 접근 방식보다 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="327d7cc30ef399ae94d35dcc5692804d9ea4a921" translate="yes" xml:space="preserve">
          <source>It's hard (long) to find the treasure as you'll have to solve (potentially hard) riddles to get there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보물을 찾기가 어렵 기 때문에 (잠재적으로) 수수께끼를 풀어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42a9a19d3d56bb3334c62df22e60fdada2dcdcd2" translate="yes" xml:space="preserve">
          <source>Just use a &lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt;&lt;code&gt;funcy&lt;/code&gt;&lt;/a&gt; library:
&lt;code&gt;pip install funcy&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt; &lt;code&gt;funcy&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라이브러리를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pip install funcy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e972ca2d74e4344909c9d769a43e177bf4b73da" translate="yes" xml:space="preserve">
          <source>My solution:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 해결책 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bad516f05c5f73910361629673802985b60ee859" translate="yes" xml:space="preserve">
          <source>Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn't bounded by python recursion depth since the function calls are happening in C, though this doesn't mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;itertools가 구현되는 방법을 알고있는 한 대부분의 무거운 리프팅은 C에서 수행됩니다. 따라서 재귀 적이지만 AFAIK는 C에서 함수 호출이 발생하기 때문에 파이썬 재귀 깊이에 의해 제한되지 않습니다. 그렇다고해서 특히 스택 크기가 현재 제한적인 OS X (OS X Mavericks) 인 OS X에서 메모리에 묶여 있다는 의미는 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ed6380feaa8a9c7ce4fafd4f95fc7270dbb5cb2e" translate="yes" xml:space="preserve">
          <source>Once the treasure found, returning to the entrance may be easy, you just have to use the same path in the other direction (though this needs a bit of memory to recall your path).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보물이 발견되면 입구로 돌아가는 것이 쉬울 수 있지만 다른 방향으로 동일한 경로를 사용해야합니다 (여기에는 경로를 기억하기 위해 약간의 메모리가 필요하지만).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0cd477d78798b3f11b8ce3d44411f3dfe6dd415" translate="yes" xml:space="preserve">
          <source>Or perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;in this question&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 아마도 더 나은 반복자입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;임의의 중첩에서 작동하는 유일한 해결책 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은이 질문에서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 찾을 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2be78dba5189bfabfa4dc4f74e5681909c29d399" translate="yes" xml:space="preserve">
          <source>Or without chaining:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 체인없이 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="195bb83dcdc0362b1e06e323cc01a996b7dc71a5" translate="yes" xml:space="preserve">
          <source>Please tell how good or bad this code is?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 코드가 얼마나 좋은지 나쁜지 알려주세요.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">파이썬 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">파이썬 3</target>
        </trans-unit>
        <trans-unit id="b1a4bdad53d496f016539994db00ab42bad7ab3a" translate="yes" xml:space="preserve">
          <source>Seems to work. Test:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작동하는 것 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테스트:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b017e65239c7000352a2a4d2945b86297a105e82" translate="yes" xml:space="preserve">
          <source>Slightly simplified version of this generator:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 발전기의 약간 단순화 된 버전 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e6420f44801052d8450e03e5a463a2b1ebe007c" translate="yes" xml:space="preserve">
          <source>So after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 combine_nlist 함수를 정의한 후에는이 함수를 사용하여 쉽게 만들 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 하나의 기능으로 결합 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중첩 된 목록에 적용 할 수 있기 때문에 솔루션을 좋아합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e66b79cc8c23c3de703aca50e255ff68402ff67a" translate="yes" xml:space="preserve">
          <source>Test-run</source>
          <target state="translated">Test-run</target>
        </trans-unit>
        <trans-unit id="0554905ed68d85c07973d301a7834f6460a2979e" translate="yes" xml:space="preserve">
          <source>Testing and remarks on other implementations</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 구현에 대한 테스트 및 의견&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b290a7129085c8c8ce8c31773fae071246e9164" translate="yes" xml:space="preserve">
          <source>Testing the generator works fine with the list that was provided. However, the new code will raise a &lt;code&gt;TypeError&lt;/code&gt; when a non-iterable object is given to it. Example are shown below of the new behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성기 테스트는 제공된 목록에서 제대로 작동합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 새로운 코드는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반복 불가능한 객체가 주어지면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 발생시킵니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래는 새로운 동작의 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="532857664f8e776457b2a0176cabc53f62598867" translate="yes" xml:space="preserve">
          <source>That's actually pretty simple: &quot;don't use recursion if you don't know how deep it can go&quot;. That's not always true as in some cases, &lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;Tail Call recursion can be Optimized (TCO)&lt;/a&gt;. But in python, this is not the case, and even &quot;well written&quot; recursive function will &lt;strong&gt;not&lt;/strong&gt; optimize stack use. There is an interesting post from Guido about this question: &lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;Tail Recursion Elimination&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로는 매우 간단합니다. &quot;얼마나 깊이 갈 수 있는지 모르는 경우 재귀를 사용하지 마십시오&quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우에 따라 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tail Call 재귀를 최적화 할 수있는&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것처럼 항상 사실은 아닙니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(TCO)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 파이썬에서는 그렇지 않습니다. 심지어 &quot;잘 작성된&quot;재귀 함수조차도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스택 사용을 최적화 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문에 대한 Guido의 흥미로운 게시물이 있습니다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tail Recursion Elimination&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5702b5681f002e1c77cf7f5d0d3515813c4410e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatten&lt;/code&gt; function here turns the list into a string, takes out &lt;strong&gt;all&lt;/strong&gt; of the square brackets, attaches square brackets back onto the ends, and turns it back into a list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 함수는 목록을 문자열로 바꾸고, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대괄호를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;꺼내고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, 대괄호를 끝에 붙이고 다시 목록으로 바꿉니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8528f7ed2c3c94ffb0211e58b7f2acb86af244a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield from&lt;/code&gt; operator returns an item from a generator one at a time. This &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;syntax for delegating to a subgenerator&lt;/a&gt; was added in 3.3</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;연산자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 한 번에 하나씩 발전기에서 항목을 반환합니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하위 생성기에 위임하기위한&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구문&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 3.3에서 추가되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="154968401f3a779a0b98b804cf8977b61118a1da" translate="yes" xml:space="preserve">
          <source>The DFS traversal pre-order is: L, 0, A, 1, 2, 3, 4. Remember, in order to implement an iterative DFS you also &quot;need&quot; a stack. The implementation I proposed before result in having the following states (for the &lt;code&gt;stack&lt;/code&gt; and the &lt;code&gt;flat_list&lt;/code&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DFS 순회 예약 주문은 L, 0, A, 1, 2, 3, 4입니다. 반복적 인 DFS를 구현하려면 스택이 &quot;필요&quot;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전에 제안한 구현 결과는 다음과 같은 상태가됩니다 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flat_list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="135a1768cd4daf87f3b12fac9dbe360fe7259fd6" translate="yes" xml:space="preserve">
          <source>The code is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드는 다음과 같습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9bb4d095e6d13b019637c537fa9e20277e4e2a63" translate="yes" xml:space="preserve">
          <source>The easiest way is to use the &lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;morph&lt;/a&gt; library using &lt;code&gt;pip install morph&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 쉬운 방법은 &lt;/font&gt; &lt;code&gt;pip install morph&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용하여 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모프&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라이브러리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 사용하는 것 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9730b9e2745e5198081261761f9462f7733b005a" translate="yes" xml:space="preserve">
          <source>The flattened list is then returned.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 병합 된 목록이 반환됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b6b91a4964cc48f9f9afa9ebc468a09d9ec028d7" translate="yes" xml:space="preserve">
          <source>The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 생성기는 첫 번째 생성기와 거의 동일하지만 반복 불가능한 객체를 평평하게 만드는 데 문제가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부적절한 주장이 주어지면 예상대로 실패합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf5ea765f8026469fe3f7a96d57d282354586b40" translate="yes" xml:space="preserve">
          <source>The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부 for 루프는 목록을 반복합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;목록 요소를 찾으면 (1) list.extend ()를 사용하여 해당 부분을 한 수준의 중첩 수준으로 평탄화하고 (2) 스위치를 keepChecking을 True로 설정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;keepchecking은 외부 while 루프를 제어하는 ​​데 사용됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;외부 루프가 true로 설정되면 다른 패스에 대해 내부 루프를 트리거합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="072c6ff6dd9019102323263f9272dee7bb233cef" translate="yes" xml:space="preserve">
          <source>The problem you encountered in the dungeon will be the same here, the call stack has a finite size (here 1000) and therefore, if you enter too many functions without returning back then you'll fill the call stack and have an error that look like &lt;strike&gt;&quot;Dear adventurer, I'm very sorry but your notebook is full&quot;&lt;/strike&gt;: &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt;. Note that you don't need recursion to fill the call stack, but it's very unlikely that a non-recursive program call 1000 functions without ever returning. It's important to also understand that once you returned from a function, the call stack is freed from the address used (hence the name &quot;stack&quot;, return address are pushed in before entering a function and pulled out when returning). In the special case of a simple recursion (a function &lt;code&gt;f&lt;/code&gt; that call itself once -- over and over --) you will enter &lt;code&gt;f&lt;/code&gt; over and over until the computation is finished (until the treasure is found) and return from &lt;code&gt;f&lt;/code&gt; until you go back to the place where you called &lt;code&gt;f&lt;/code&gt; in the first place. The call stack will never be freed from anything until the end where it will be freed from all return addresses one after the other.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;던전에서 발생한 문제는 여기에서 동일합니다. 호출 스택은 유한 크기 (여기서는 1000)이므로 반환하지 않고 너무 많은 함수를 입력하면 호출 스택을 채우고 오류가 발생합니다. 같은 &lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;친애하는 모험가, 정말 죄송하지만 노트북이 가득 찼습니다&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 호출 스택을 채우기 위해 재귀가 필요하지는 않지만 비 재귀 프로그램이 반환하지 않고 1000을 호출하는 것은 거의 불가능합니다. 함수에서 리턴 한 후에는 호출 스택이 사용 된 주소에서 해제됩니다 (따라서 이름 &quot;stack&quot;, 리턴 주소는 함수에 들어가기 전에 푸시되어 리턴 할 때 꺼내집니다). 간단한 재귀 (함수의 특별한 경우에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입력합니다 - - 반복이 호출 자체 번) &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 계산은 (보물이 발견 될 때까지) 마무리에서 반환 될 때까지 이상에 걸쳐 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 당신이 갈 때까지 당신이 &lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 불렀던 장소로 돌아 가기&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처음에. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호출 스택은 모든 리턴 주소에서 차례로 해제 될 때까지 어떤 것도 해제되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fccb286979da55d6c6e125dbea7209d07f046f87" translate="yes" xml:space="preserve">
          <source>There are better, faster methods (If you've reached here, you have seen them already)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 좋고 더 빠른 방법이 있습니다 (여기에 도달하면 이미 보았습니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9caba178eb8922f0394406ccdde49ee49df43a0" translate="yes" xml:space="preserve">
          <source>There is a technique that you can use to make any recursive function iterative, this technique we could call &lt;em&gt;&lt;strong&gt;bring your own notebook&lt;/strong&gt;&lt;/em&gt;. For example, in our particular case we simply are exploring a list, entering a room is equivalent to entering a sublist, the question you should ask yourself is &lt;em&gt;how can I get back from a list to its parent list?&lt;/em&gt; The answer is not that complex, repeat the following until the &lt;code&gt;stack&lt;/code&gt; is empty:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재귀 함수를 반복적으로 만드는 데 사용할 수있는 기술이 있습니다.이 기술을 사용 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 자신의 노트북을 가져올 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 특별한 경우에 우리는 단순히 목록을 탐색하고 방을 입력하는 것은 하위 목록을 입력하는 것과 같습니다. 스스로 질문해야 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 것은 목록에서 부모 목록으로 어떻게 돌아갈 수 있습니까? &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대답은 그렇게 복잡하지 않습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 비워 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;질 때까지 다음을 반복하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a76c19332391eecb7270208d09b08dff1cefe111" translate="yes" xml:space="preserve">
          <source>This considers strings as &quot;simple items&quot; and therefore &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; will return &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; and not &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt;. Remark that in that case, &lt;code&gt;iter(item)&lt;/code&gt; is called twice on each item, let's pretend it's an exercise for the reader to make this cleaner.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 문자열을 &quot;단순 항목&quot;으로 간주하므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt; &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 아닌 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[ &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 반환합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;e &quot;,&quot;s &quot;,&quot;t &quot;,&quot;a &quot;,&quot;b &quot;]&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .이 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iter(item)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 각 항목에 대해 두 번 호출 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;된다는 점에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주목&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하십시오. 독자가이 청소기를 더 깨끗하게 만드는 것으로 가정 해 봅시다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35450707d84bb0ce84709e530c6a2b600bd4d904" translate="yes" xml:space="preserve">
          <source>This is a simple implement of flatten on python2</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 python2에서 flatten의 간단한 구현입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e4799018e16d870c6e5e1422846257d94aa57ba" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;flatten&lt;/code&gt; avoids python's recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 버전의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 파이썬의 재귀 제한을 피합니다 (따라서 임의로 깊고 중첩 된 반복 가능 항목과 함께 작동). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문자열과 임의의 이터 러블 (무한대까지도)을 처리 할 수있는 생성기입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2bd5654ac77b479f712d41c3a504f60b62c199d" translate="yes" xml:space="preserve">
          <source>This will flatten a list or dictionary (or list of lists or dictionaries of dictionaries etc). It assumes that the values are strings and it creates a string that concatenates each item with a separator argument. If you wanted you could use the separator to split the result into a list object afterward. It uses recursion if the next value is a list or a string. Use the key argument to tell whether you want the keys or the values (set key to false) from the dictionary object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 목록 또는 사전 (또는 사전 목록 또는 사전 사전 등)이 병합됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값이 문자열이라고 가정하고 구분자 인수로 각 항목을 연결하는 문자열을 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원하는 경우 나중에 구분 기호를 사용하여 결과를 목록 개체로 분할 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 값이 목록 또는 문자열 인 경우 재귀를 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;키 인수를 사용하여 사전 오브젝트에서 키 또는 값 (키를 false로 설정)을 원하는지 여부를 알려줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77dfd5cfcd224f3d1363dfe3cb85003efe050d9f" translate="yes" xml:space="preserve">
          <source>This works with two lists: an inner for loop and an outer while loop.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 내부 for 루프와 외부 while 루프의 두 가지 목록으로 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e537559c79429148f10b6b9cf0978b9e2371bc8a" translate="yes" xml:space="preserve">
          <source>Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 패스는 더 이상 중첩 된 목록이 없을 때까지 계속 발생합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;패스가없는 곳에서 패스가 발생하면 keepChecking은 true로 트립되지 않습니다. 즉 listIsNested는 false로 유지되고 외부 while 루프는 종료됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="303c2ecddc270d76490ec99651c75c05229ac735" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;itertools.chain&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;itertools.chain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="057ed5e75ff2f0ad40d7cbbc26525344260fd727" translate="yes" xml:space="preserve">
          <source>Using generator functions can make your example a little easier to read and probably boost the performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성기 함수를 사용하면 예제를 좀 더 쉽게 읽고 성능을 향상시킬 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2217cada8873c4496bd08dcd7534fbce6ad78f5c" translate="yes" xml:space="preserve">
          <source>When I say &lt;em&gt;most of the codes&lt;/em&gt; I mean all codes that use any form of recursion (or call a standard library function that is recursive). All these codes fail because for every of the recursive call made, the (call) stack grow by one unit, and the (default) python call stack has a size of 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 코드를&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 말할 때 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 형태의 재귀를 사용하는 모든 코드를 의미합니다 (또는 재귀적인 표준 라이브러리 함수를 호출합니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 재귀 호출에 대해 (호출) 스택이 한 단위 씩 증가하고 (기본) 파이썬 호출 스택의 크기가 1000이기 때문에 이러한 코드는 모두 실패합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d2be4bbcc49edcd35c84a1c8296c7bc26899184" translate="yes" xml:space="preserve">
          <source>When entering the dungeon, you notice a small &lt;strong&gt;notebook&lt;/strong&gt; here. You decide to use it to write down every room you exit after solving a riddle (when entering a new room), this way you'll be able to return back to the entrance. That's a genius idea, you &lt;em&gt;won't even spend a cent&lt;/em&gt; implementing your strategy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지하 감옥에 들어가면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공책이&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수수께끼를 풀고 (새 방에 들어올 때) 나가는 모든 방을 적어두기로 결정하면 입구로 돌아갈 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 천재적인 아이디어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. 전략을 구현 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 데 1 센트를 쓰지 않아도됩니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea08aaefc36c7bd0e08223e9634c0ae634211149" translate="yes" xml:space="preserve">
          <source>When trying to answer such a question you really need to give the limitations of the code you propose as a solution. If it was only about performances I wouldn't mind too much, but most of the codes proposed as solution (including the accepted answer) fail to flatten any list that has a depth greater than 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러한 질문에 대답하려고 할 때 실제로 솔루션으로 제안하는 코드의 한계를 제시해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능에 관한 것이라면별로 신경 쓰지 않지만 솔루션으로 제안 된 대부분의 코드 (응답 포함)는 깊이가 1000보다 큰 목록을 평평하게하지 못합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c4f6558f38981ddb59d040b4538d37b7efc2d09" translate="yes" xml:space="preserve">
          <source>Where the desired output is</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원하는 출력이있는 곳&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="07d07b7b8ea752db0d14deeb6cb38e985e165f11" translate="yes" xml:space="preserve">
          <source>Which gives: &lt;code&gt;build_deep_list(5)&lt;/code&gt; &amp;gt;&amp;gt;&amp;gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어느 준다 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;build_deep_list(5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12006179f5926aac3184169403362f3f9c481acf" translate="yes" xml:space="preserve">
          <source>Without using any library:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라이브러리를 사용하지 않고 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf88998d5c009de437a318db8effc7a1537c6a7e" translate="yes" xml:space="preserve">
          <source>Yes, I know this subject has been covered before (&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;here&lt;/a&gt;), but as far as I know, all solutions, except for one, fail on a list like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇습니다.이 주제는 이전 ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다루었 음을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고 있지만, 아는 한 하나를 제외한 모든 솔루션은 다음과 같은 목록에서 실패합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74a1b281a15fddb74b8fce9e6b33b2503f2b15ba" translate="yes" xml:space="preserve">
          <source>You could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;deepflatten&lt;/code&gt;&lt;/a&gt; from the 3rd party package &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt;&lt;code&gt;iteration_utilities&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;타사 패키지 &lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;deepflatten&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3debaf3c28a15f60ba292768b82cfaf8dfacc54c" translate="yes" xml:space="preserve">
          <source>You enter the dungeon, solving with great success the first 1001 riddles, but here comes something you hadn't planed, you have no space left in the notebook you borrowed. You decide to &lt;em&gt;abandon&lt;/em&gt; your quest as you prefer not having the treasure than being lost forever inside the dungeon (that looks smart indeed).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 지하 감옥에 들어가서 첫 번째 1001 수수께끼를 성공적으로 해결했지만 여기에 계획하지 않은 것이 나오고, 빌린 노트북에 남은 공간이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 던전 안에서 영원히 잃어버린 것보다 보물을 갖기를 원하지 않기 때문에 퀘스트 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;포기&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하기로 결정했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(실제로는 똑똑해 보입니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64d4175e880a1832a2a0d0bb31fd6657fe5d0d89" translate="yes" xml:space="preserve">
          <source>every time an item is found, &lt;code&gt;yield&lt;/code&gt; it (or add them in a list);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아이템을 찾을 때마다, 아이템을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하거나 목록에 추가하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e51c354b48926dd260c73a845d3893393cf58cb" translate="yes" xml:space="preserve">
          <source>here is one simple and one not-so-simple case -</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기 하나의 단순하고 그렇지 않은 경우가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adc6d4918f750b646571daa2e00df52c14b564db" translate="yes" xml:space="preserve">
          <source>here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt; so use it with caution ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서는 집합을 사용하여 유형을 확인하므로 O (1) 대 O (유형 수)를 사용하여 요소를 무시해야하는지 여부를 확인합니다. 물론 언급 된 무시 된 유형의 파생 유형을 가진 값은 실패합니다. , 이것이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이므로주의해서 사용하십시오 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccedab2b750529fb2f1b87bbe07378ea34020ea1" translate="yes" xml:space="preserve">
          <source>once a list is fully explored, go back to the parent list using the &lt;code&gt;stack&lt;/code&gt;&lt;em&gt;return &lt;code&gt;address&lt;/code&gt; (and &lt;code&gt;index&lt;/code&gt;)&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리스트가 완전히 탐색되면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리턴 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )를&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하여 상위리스트로 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;돌아갑니다&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="296855ad54af49593cc7b3f4e5521f091bd38983" translate="yes" xml:space="preserve">
          <source>push the current list &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; in a &lt;code&gt;stack&lt;/code&gt; when entering a new sublist (note that a list address+index is also an address, therefore we just use the exact same technique used by the call stack);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새 하위 목록을 입력 할 때 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;현재 목록 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;넣습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(목록 주소 + 색인도 주소이므로 콜 스택에서 사용하는 것과 동일한 기술을 사용합니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a5301a88da334dc5afc5b63979daa0f3f45e68" translate="yes" xml:space="preserve">
          <source>result</source>
          <target state="translated">result</target>
        </trans-unit>
        <trans-unit id="37b8dabf0b7bfae1c2eecb47a6afcd8bc92cc94c" translate="yes" xml:space="preserve">
          <source>returns:</source>
          <target state="translated">returns:</target>
        </trans-unit>
        <trans-unit id="9dd608f36d0db13a98f4add5e42d48a50fa3c769" translate="yes" xml:space="preserve">
          <source>tests:</source>
          <target state="translated">tests:</target>
        </trans-unit>
        <trans-unit id="90b34293d40fd211f22a7eb82950647a7a0d5b3f" translate="yes" xml:space="preserve">
          <source>there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you'll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;약간 더 빠른 접근 방법이 있지만 이식성이 떨어지는 방법은 입력의 기본 요소를 명시 적으로 결정할 수 있다고 가정 할 수있는 경우에만 사용하십시오. 무한한 재귀를 얻을 수 있으며 스택 크기가 제한된 OS X는 세분화 오류를 상당히 빠르게 처리하십시오 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e33ad899228cb347b7c6fd1b4662e7475fffbffc" translate="yes" xml:space="preserve">
          <source>totally hacky but I think it would work (depending on your data_type)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완전히 해 키지 만 작동한다고 생각합니다 (data_type에 따라 다름)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="translated">yields:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
