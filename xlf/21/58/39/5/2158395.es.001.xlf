<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2158395">
    <body>
      <group id="2158395">
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b94d16302cf154c51472d68c89f80eccc9bf39da" translate="yes" xml:space="preserve">
          <source>A little more concise, but pretty much the same.</source>
          <target state="translated">Un poco más conciso,pero más o menos lo mismo.</target>
        </trans-unit>
        <trans-unit id="2e1e92ffc64201504c5a6eff5c1414fff1c14c5b" translate="yes" xml:space="preserve">
          <source>Also note that this is equivalent to a DFS in a tree where some nodes are sublists &lt;code&gt;A = [1, 2]&lt;/code&gt; and some are simple items: &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; (for &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt;). The tree looks like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n tenga en cuenta que esto es equivalente a un DFS en un &amp;aacute;rbol donde algunos nodos son sublistas &lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = [1, 2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y algunos son elementos simples: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &amp;aacute;rbol se ve as&amp;iacute;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39ae53263fd5d3fc2ad1e4969d6289c8ceffa883" translate="yes" xml:space="preserve">
          <source>Also note:</source>
          <target state="translated">También tenga en cuenta:</target>
        </trans-unit>
        <trans-unit id="b988bb020235fef9787bc47fbe5d47be55ac3d74" translate="yes" xml:space="preserve">
          <source>Also, notice that in &lt;code&gt;is_list_like&lt;/code&gt; I have &lt;code&gt;isinstance(item, list)&lt;/code&gt;, which could be changed to handle more input types, here I just wanted to have the simplest version where (iterable) is just a list. But you could also do that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;is_list_like&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en cuenta que en &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;is_list_like&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tengo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;isinstance(item, list)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que podr&amp;iacute;a modificarse para manejar m&amp;aacute;s tipos de entrada, aqu&amp;iacute; solo quer&amp;iacute;a tener la versi&amp;oacute;n m&amp;aacute;s simple donde (iterable) es solo una lista. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero tambi&amp;eacute;n podr&amp;iacute;as hacer eso:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cc5ad86f665601e560433987cb7417b01efca95" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;flatten&lt;/code&gt; can handle infinite generators, it can not handle infinite nesting:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aunque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede manejar generadores infinitos, no puede manejar anidamiento infinito:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c9eeb6d8077aaaaf78d4e63ffe4b8b711c773d" translate="yes" xml:space="preserve">
          <source>Although an elegant and very pythonic answer has been selected I would present my solution just for the review:</source>
          <target state="translated">Aunque se ha seleccionado una respuesta elegante y muy pitónica,presentaría mi solución sólo para la revisión:</target>
        </trans-unit>
        <trans-unit id="79005deb294f385cf51ff98cdbfe50b8975ffaaa" translate="yes" xml:space="preserve">
          <source>Although, if you knew you would have square brackets in your list in strings, like &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt;, you would have to do something else.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aunque, si supiera que tendr&amp;iacute;a corchetes en su lista en cadenas, como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , tendr&amp;iacute;a que hacer algo m&amp;aacute;s.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea99bd96f840dbdf67557a459fb8a821cca61dbf" translate="yes" xml:space="preserve">
          <source>Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.</source>
          <target state="translated">Básicamente,convierte la lista anidada en una cadena,utiliza un regex para eliminar la sintaxis anidada y luego convierte el resultado de nuevo a una lista (aplanada).</target>
        </trans-unit>
        <trans-unit id="7bce1bc51c3449501719ffd5a57d46f6c16b5528" translate="yes" xml:space="preserve">
          <source>Basically, it's the exact same thing as finding the treasure. The dungeon is the &lt;em&gt;computer's memory&lt;/em&gt;, your goal now is not to find a treasure but to &lt;em&gt;compute some function&lt;/em&gt; (find &lt;em&gt;f(x)&lt;/em&gt; for a given &lt;em&gt;x&lt;/em&gt;). The indications simply are sub-routines that will help you solving &lt;em&gt;f(x)&lt;/em&gt;. Your strategy is the same as the &lt;em&gt;call stack&lt;/em&gt; strategy, the notebook is the stack, the rooms are the functions' return addresses:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B&amp;aacute;sicamente, es exactamente lo mismo que encontrar el tesoro. La mazmorra es la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;memoria de&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;computadora&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , su objetivo ahora no es encontrar un tesoro sino &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;calcular alguna funci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (encontrar &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f (x)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para una &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;x&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dada &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;). Las indicaciones simplemente son subrutinas que lo ayudar&amp;aacute;n a resolver &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f (x)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Su estrategia es la misma que la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;estrategia de la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pila de llamadas&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el cuaderno es la pila, las salas son las direcciones de retorno de las funciones:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="00e8a0bc89e1685335629d80defa1da3e4b13655" translate="yes" xml:space="preserve">
          <source>Call stack size and recursive programming (dungeon analogy)</source>
          <target state="translated">El tamaño de la pila de llamadas y la programación recursiva (analogía de las mazmorras)</target>
        </trans-unit>
        <trans-unit id="fe08d2e421da75ca59dd2aeab5263533ae932acd" translate="yes" xml:space="preserve">
          <source>Deprecated since version 2.6: The compiler package has been removed in Python 3.</source>
          <target state="translated">Desaparecido desde la versión 2.6:El paquete compilador ha sido eliminado en Python 3.</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="6e0393cc0cfaf97f6bbc102a7c484c707418a0a6" translate="yes" xml:space="preserve">
          <source>Executing a recursive program</source>
          <target state="translated">Ejecutando un programa recursivo</target>
        </trans-unit>
        <trans-unit id="cffa8ae998bde40c61124489d1d7d218e9c222c6" translate="yes" xml:space="preserve">
          <source>Finding the treasure and exit</source>
          <target state="translated">Encontrar el tesoro y salir</target>
        </trans-unit>
        <trans-unit id="89d4cc02db3c116e3e5e4b9ef0aa736c4918c1e7" translate="yes" xml:space="preserve">
          <source>Flatten an irregular list of lists</source>
          <target state="translated">Aplanar una lista irregular de listas</target>
        </trans-unit>
        <trans-unit id="dc5881a87e62d2dd4244fc1bbeb8669c4db39c54" translate="yes" xml:space="preserve">
          <source>For the implementation, in python you can simplify a little bit by using iterators instead of simple lists. References to the (sub)iterators will be used to store &lt;em&gt;sublists return addresses&lt;/em&gt; (instead of having both the list address and the index). This is not a big difference but I feel this is more readable (and also a bit faster):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para la implementaci&amp;oacute;n, en python puede simplificar un poco utilizando iteradores en lugar de listas simples. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las referencias a los (sub) iteradores se utilizar&amp;aacute;n para almacenar las &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;direcciones de retorno de las sublistas&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (en lugar de tener tanto la direcci&amp;oacute;n de la lista como el &amp;iacute;ndice). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto no es una gran diferencia, pero creo que es m&amp;aacute;s legible (y tambi&amp;eacute;n un poco m&amp;aacute;s r&amp;aacute;pido):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14b3b87237e51935f59f6a45980acb7e07912e3d" translate="yes" xml:space="preserve">
          <source>Generator using recursion and duck typing (updated for Python 3):</source>
          <target state="translated">Generador que utiliza la recursión y la escritura en pato (actualizado para Python 3):</target>
        </trans-unit>
        <trans-unit id="29a3d6e99377c3e58e92fa6570cbcd314d1369e0" translate="yes" xml:space="preserve">
          <source>Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:</source>
          <target state="translated">Versión generadora de la solución no recursiva de @unutbu,como pidió @Andrew en un comentario:</target>
        </trans-unit>
        <trans-unit id="de414681c4d86a10bca5d7259bca22e7cc442e38" translate="yes" xml:space="preserve">
          <source>Here are some examples demonstrating its use:</source>
          <target state="translated">He aquí algunos ejemplos que demuestran su uso:</target>
        </trans-unit>
        <trans-unit id="d761607d7fd53dc85f57f027dcb4d53b118a4328" translate="yes" xml:space="preserve">
          <source>Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...</source>
          <target state="translated">Aquí hay otro acercamiento py2,no estoy seguro si es el más rápido o el más elegante o el más seguro...</target>
        </trans-unit>
        <trans-unit id="f8f1df1a614a50ef001234abdbb4b19c8fcde356" translate="yes" xml:space="preserve">
          <source>Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:</source>
          <target state="translated">Aquí está mi versión funcional del aplanamiento recursivo que maneja tanto tuplas como listas,y te permite lanzar cualquier mezcla de argumentos posicionales.Devuelve un generador que produce toda la secuencia en orden,arg por arg:</target>
        </trans-unit>
        <trans-unit id="192708e2b1612f7e2636733beef7d6446a1d0792" translate="yes" xml:space="preserve">
          <source>Here's a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.</source>
          <target state="translated">Aquí hay una simple función que aplana las listas de profundidad arbitraria.No hay recursividad,para evitar el desbordamiento de la pila.</target>
        </trans-unit>
        <trans-unit id="cca580c17fbc89a2f6cb82d0bd1f19329e72e277" translate="yes" xml:space="preserve">
          <source>Here's another answer that is even more interesting...</source>
          <target state="translated">Aquí hay otra respuesta que es aún más interesante...</target>
        </trans-unit>
        <trans-unit id="4d57f3784cbadc37b4cfe69affdca1585e5114eb" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;compiler.ast.flatten&lt;/code&gt; implementation in 2.7.5:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute; la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;implementaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;compiler.ast.flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en 2.7.5:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="86313aca1240327c8110d73a59910a2e4748a8eb" translate="yes" xml:space="preserve">
          <source>How to avoid this issue?</source>
          <target state="translated">¿Cómo evitar este problema?</target>
        </trans-unit>
        <trans-unit id="73311ad0ce2612a0bac165fe5b4f0d2143fe420c" translate="yes" xml:space="preserve">
          <source>I actually adapted this from some practice Scheme code that I had written a while back.</source>
          <target state="translated">De hecho,adapté esto de algún código de práctica del Esquema que había escrito hace un tiempo.</target>
        </trans-unit>
        <trans-unit id="1fe7bbe6a54abd708286ebfd2590e527d89fb6bf" translate="yes" xml:space="preserve">
          <source>I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :</source>
          <target state="translated">Soy consciente de que ya hay muchas respuestas impresionantes,pero quería añadir una respuesta que utilice el método de programación funcional para resolver la pregunta.En esta respuesta hago uso de la doble recursividad:</target>
        </trans-unit>
        <trans-unit id="25ff56d30963a5a4f97668f1bc5fc99613a35d75" translate="yes" xml:space="preserve">
          <source>I didn't go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp's way of first and rest list processing</source>
          <target state="translated">No he repasado todas las respuestas disponibles aquí,pero aquí hay una que se me ocurrió,tomando prestada la forma de ceceo del procesamiento de la primera y la lista de descanso.</target>
        </trans-unit>
        <trans-unit id="63f84972799a9df278bff951da68e8c61c51e0db" translate="yes" xml:space="preserve">
          <source>I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.</source>
          <target state="translated">No estoy de acuerdo con la aplicación anterior.El problema es que no deberías ser capaz de aplanar algo que no es un iterable.Es confuso y da una impresión equivocada del argumento.</target>
        </trans-unit>
        <trans-unit id="d21115e6807ec7e80c0e53149fb1e2549851a053" translate="yes" xml:space="preserve">
          <source>I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:</source>
          <target state="translated">Prefiero las respuestas simples.Sin generadores.No hay límites de recursividad o de recursividad.Sólo iteración:</target>
        </trans-unit>
        <trans-unit id="d552c40c91766011979100b463254df3b544b08b" translate="yes" xml:space="preserve">
          <source>I used recursive to solve &lt;strong&gt;&lt;em&gt;nested list with any depth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sol&amp;iacute;a ​​recursivo para resolver &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la lista anidada con cualquier profundidad&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5f4c4090ed4da94119c438444b23567bd92e579" translate="yes" xml:space="preserve">
          <source>I used the &lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;Iterable ABC&lt;/a&gt; added in 2.6.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Utilic&amp;eacute; el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iterable ABC&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a&amp;ntilde;adi&amp;oacute; en 2,6.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bfd5938dfd46dcfadadefac4f96e2163678e963" translate="yes" xml:space="preserve">
          <source>I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):</source>
          <target state="translated">Soy nuevo en la pitón y vengo de un fondo ceceo.Esto es lo que se me ocurrió (mira los nombres de las varillas para Lulz):</target>
        </trans-unit>
        <trans-unit id="02500c7b14b0e35ad9d368d2709d1abf9be8bcbc" translate="yes" xml:space="preserve">
          <source>I'm not sure if this is necessarily quicker or more effective, but this is what I do:</source>
          <target state="translated">No estoy seguro de si esto es necesariamente más rápido o más efectivo,pero esto es lo que hago:</target>
        </trans-unit>
        <trans-unit id="6237c2b268a9a2c753eb0575cba2851d46cd8806" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has thought of this. Damn recursion I don't get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it's very specific to the OP's use case</source>
          <target state="translated">Me sorprende que nadie haya pensado en esto.Maldita recursividad.No entiendo las respuestas recursivas que la gente avanzada de aquí hizo.De todos modos,aquí está mi intento en esto.La advertencia es que es muy específico para el caso de uso de la OP.</target>
        </trans-unit>
        <trans-unit id="f2a887d9dc7263e6673a358d623c71925b5827af" translate="yes" xml:space="preserve">
          <source>I'm the author of the &lt;code&gt;iteration_utilities&lt;/code&gt; library.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Soy el autor de la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;biblioteca &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16f02278b2307a15155e59a48d751351737d9dc0" translate="yes" xml:space="preserve">
          <source>If you like recursion, this might be a solution of interest to you:</source>
          <target state="translated">Si le gusta la recursividad,esta podría ser una solución de su interés:</target>
        </trans-unit>
        <trans-unit id="ce254e7f2d55496a2a51b2fc7c005e802480f05a" translate="yes" xml:space="preserve">
          <source>If you need to test your solution, you can use this function to generate a simple nested list:</source>
          <target state="translated">Si necesita probar su solución,puede usar esta función para generar una simple lista anidada:</target>
        </trans-unit>
        <trans-unit id="ae9dea2001369860e6d6e3b472dfa7fe73dd1491" translate="yes" xml:space="preserve">
          <source>If you're not too familiar with the call stack, then maybe the following will help (otherwise you can just scroll to the &lt;strong&gt;Implementation&lt;/strong&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si no est&amp;aacute; demasiado familiarizado con la pila de llamadas, quiz&amp;aacute;s lo siguiente le ayude (de lo contrario, puede desplazarse a la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Implementaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccc8187609cdbafce2adf1007c1c12e540acf4ff" translate="yes" xml:space="preserve">
          <source>Imagine you enter a huge &lt;em&gt;dungeon with numbered rooms&lt;/em&gt;, looking for a treasure. You don't know the place but you have some &lt;strong&gt;indications&lt;/strong&gt; on how to find the treasure. Each indication is a riddle (difficulty varies, but you can't predict how hard they will be). You decide to think a little bit about a strategy to save time, you make two observations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Imagina que entras en una &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mazmorra&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; enorme &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;con habitaciones numeradas&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , buscando un tesoro. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No conoces el lugar pero tienes algunas &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;indicaciones&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sobre c&amp;oacute;mo encontrar el tesoro. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cada indicaci&amp;oacute;n es un acertijo (la dificultad var&amp;iacute;a, pero no se puede predecir qu&amp;eacute; tan dif&amp;iacute;cil ser&amp;aacute;). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Decides pensar un poco en una estrategia para ahorrar tiempo, haces dos observaciones:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="755295b4b33843ecc770e563e6c872d57ade6d17" translate="yes" xml:space="preserve">
          <source>In Python 3, the &lt;code&gt;basestring&lt;/code&gt; is no more, but you can use a tuple of &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; to get the same effect there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En Python 3, la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;basestring&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya no existe, pero puede usar una tupla de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para obtener el mismo efecto all&amp;iacute;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63ceef487e0ed2113d3415ac21f524ca491369eb" translate="yes" xml:space="preserve">
          <source>In the end, remember that you can't print a infinitely nested list &lt;code&gt;L&lt;/code&gt; using &lt;code&gt;print(L)&lt;/code&gt; because internally it will use recursive calls to &lt;code&gt;__repr__&lt;/code&gt; (&lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt;). For the same reason, solutions to &lt;code&gt;flatten&lt;/code&gt; involving &lt;code&gt;str&lt;/code&gt; will fail with the same error message.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al final, recuerde que no puede imprimir una lista infinitamente anidada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;L&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;print(L)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; porque internamente usar&amp;aacute; llamadas recursivas a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;__repr__&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por la misma raz&amp;oacute;n, las soluciones para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; fallar&amp;aacute;n con el mismo mensaje de error.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa8151a1aab9fc8bab222f58152b8c8370bb3f5f" translate="yes" xml:space="preserve">
          <source>In this example, the stack maximum size is 2, because the input list (and therefore the tree) have depth 2.</source>
          <target state="translated">En este ejemplo,el tamaño máximo de la pila es 2,porque la lista de entrada (y por lo tanto el árbol)tiene una profundidad 2.</target>
        </trans-unit>
        <trans-unit id="cc4e9d94220d7cd5461a09f4298103ba3f39a77f" translate="yes" xml:space="preserve">
          <source>Is this the best model? Did I overlook something? Any problems?</source>
          <target state="translated">¿Este es el mejor modelo? ¿Se me pasó algo por alto? ¿Algún problema?</target>
        </trans-unit>
        <trans-unit id="9be35c6488088a4b9b217f398fdaa6add15ed10f" translate="yes" xml:space="preserve">
          <source>It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...</source>
          <target state="translated">Puede ignorar cualquier tipo específico (o derivado)que desee,devuelve un iterador,por lo que puede convertirlo en cualquier contenedor específico como lista,tupla,dic o simplemente consumirlo para reducir la huella de la memoria,para bien o para mal puede manejar objetos no literarios iniciales como int ...</target>
        </trans-unit>
        <trans-unit id="3e28f912c3bce57b5166b693a2a552f23ab60528" translate="yes" xml:space="preserve">
          <source>It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:</source>
          <target state="translated">Fue divertido intentar crear una función que pudiera aplanar la lista de irregulares en Python,pero por supuesto para eso está Python (para hacer la programación divertida).El siguiente generador funciona bastante bien con algunas advertencias:</target>
        </trans-unit>
        <trans-unit id="4bb90b9d131e83bfcc3336776d86f58c4d625af1" translate="yes" xml:space="preserve">
          <source>It will flatten datatypes that you might want left alone (like &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, and &lt;code&gt;str&lt;/code&gt; objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aplanar&amp;aacute; los tipos de datos que tal vez quiera dejar solos (como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;objetos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, el c&amp;oacute;digo se basa en el hecho de que solicitar un iterador de un no iterable genera un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e7334089e0c1aa21da068f2629fd98c0ba9bf10" translate="yes" xml:space="preserve">
          <source>It's an iterator so you need to iterate it (for example by wrapping it with &lt;code&gt;list&lt;/code&gt; or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it's written as C extension so it can be faster than pure python approaches:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es un iterador, por lo que debe iterarlo (por ejemplo, envolvi&amp;eacute;ndolo con la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;list&lt;/code&gt; a&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o us&amp;aacute;ndolo en un bucle). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Internamente utiliza un enfoque iterativo en lugar de un enfoque recursivo y est&amp;aacute; escrito como una extensi&amp;oacute;n C, por lo que puede ser m&amp;aacute;s r&amp;aacute;pido que los enfoques de Python puro:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="327d7cc30ef399ae94d35dcc5692804d9ea4a921" translate="yes" xml:space="preserve">
          <source>It's hard (long) to find the treasure as you'll have to solve (potentially hard) riddles to get there.</source>
          <target state="translated">Es difícil (largo)encontrar el tesoro ya que tendrás que resolver (potencialmente difícil)enigmas para llegar allí.</target>
        </trans-unit>
        <trans-unit id="42a9a19d3d56bb3334c62df22e60fdada2dcdcd2" translate="yes" xml:space="preserve">
          <source>Just use a &lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt;&lt;code&gt;funcy&lt;/code&gt;&lt;/a&gt; library:
&lt;code&gt;pip install funcy&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Simplemente use una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;biblioteca &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt; &lt;code&gt;funcy&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pip install funcy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e972ca2d74e4344909c9d769a43e177bf4b73da" translate="yes" xml:space="preserve">
          <source>My solution:</source>
          <target state="translated">Mi solución:</target>
        </trans-unit>
        <trans-unit id="bad516f05c5f73910361629673802985b60ee859" translate="yes" xml:space="preserve">
          <source>Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn't bounded by python recursion depth since the function calls are happening in C, though this doesn't mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...</source>
          <target state="translated">Nótese que la mayor parte del trabajo pesado se hace en C,ya que hasta donde yo sé así es como se implementan las herramientas de iteración,así que mientras es recursivo,AFAIK no está limitado por la profundidad de recursividad de la pitón ya que las llamadas de la función están ocurriendo en C,aunque esto no significa que esté limitado por la memoria,especialmente en OS X donde su tamaño de pila tiene un límite duro a partir de hoy (OS X Mavericks)...</target>
        </trans-unit>
        <trans-unit id="ed6380feaa8a9c7ce4fafd4f95fc7270dbb5cb2e" translate="yes" xml:space="preserve">
          <source>Once the treasure found, returning to the entrance may be easy, you just have to use the same path in the other direction (though this needs a bit of memory to recall your path).</source>
          <target state="translated">Una vez encontrado el tesoro,volver a la entrada puede ser fácil,sólo hay que usar el mismo camino en la otra dirección (aunque esto necesita un poco de memoria para recordar el camino).</target>
        </trans-unit>
        <trans-unit id="d0cd477d78798b3f11b8ce3d44411f3dfe6dd415" translate="yes" xml:space="preserve">
          <source>Or perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;in this question&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O tal vez incluso mejor, un iterador. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La &amp;uacute;nica soluci&amp;oacute;n que vi que funciona para un anidamiento arbitrario se encuentra &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;en esta pregunta&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2be78dba5189bfabfa4dc4f74e5681909c29d399" translate="yes" xml:space="preserve">
          <source>Or without chaining:</source>
          <target state="translated">O sin encadenar:</target>
        </trans-unit>
        <trans-unit id="195bb83dcdc0362b1e06e323cc01a996b7dc71a5" translate="yes" xml:space="preserve">
          <source>Please tell how good or bad this code is?</source>
          <target state="translated">Por favor,dígame qué tan bueno o malo es este código.</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">Python 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">Python 3</target>
        </trans-unit>
        <trans-unit id="b1a4bdad53d496f016539994db00ab42bad7ab3a" translate="yes" xml:space="preserve">
          <source>Seems to work. Test:</source>
          <target state="translated">Parece que funciona.Prueba:</target>
        </trans-unit>
        <trans-unit id="b017e65239c7000352a2a4d2945b86297a105e82" translate="yes" xml:space="preserve">
          <source>Slightly simplified version of this generator:</source>
          <target state="translated">Una versión ligeramente simplificada de este generador:</target>
        </trans-unit>
        <trans-unit id="4e6420f44801052d8450e03e5a463a2b1ebe007c" translate="yes" xml:space="preserve">
          <source>So after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.</source>
          <target state="translated">Así que después de que defina la función combine_lista,es fácil usar esta función para hacer el aplanamiento.O puedes combinarla en una sola función.Me gusta mi solución porque se puede aplicar a cualquier lista anidada.</target>
        </trans-unit>
        <trans-unit id="e66b79cc8c23c3de703aca50e255ff68402ff67a" translate="yes" xml:space="preserve">
          <source>Test-run</source>
          <target state="translated">Test-run</target>
        </trans-unit>
        <trans-unit id="0554905ed68d85c07973d301a7834f6460a2979e" translate="yes" xml:space="preserve">
          <source>Testing and remarks on other implementations</source>
          <target state="translated">Pruebas y observaciones sobre otras implementaciones</target>
        </trans-unit>
        <trans-unit id="9b290a7129085c8c8ce8c31773fae071246e9164" translate="yes" xml:space="preserve">
          <source>Testing the generator works fine with the list that was provided. However, the new code will raise a &lt;code&gt;TypeError&lt;/code&gt; when a non-iterable object is given to it. Example are shown below of the new behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Probar el generador funciona bien con la lista que se proporcion&amp;oacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, el nuevo c&amp;oacute;digo generar&amp;aacute; un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando se le d&amp;eacute; un objeto no iterable. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A continuaci&amp;oacute;n se muestran ejemplos del nuevo comportamiento.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="532857664f8e776457b2a0176cabc53f62598867" translate="yes" xml:space="preserve">
          <source>That's actually pretty simple: &quot;don't use recursion if you don't know how deep it can go&quot;. That's not always true as in some cases, &lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;Tail Call recursion can be Optimized (TCO)&lt;/a&gt;. But in python, this is not the case, and even &quot;well written&quot; recursive function will &lt;strong&gt;not&lt;/strong&gt; optimize stack use. There is an interesting post from Guido about this question: &lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;Tail Recursion Elimination&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Eso es bastante simple: &quot;no uses la recursividad si no sabes qu&amp;eacute; tan profundo puede llegar&quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Eso no siempre es cierto, ya que en algunos casos, la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;recursividad de llamadas de cola se puede optimizar (TCO)&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero en python, este no es el caso, e incluso la funci&amp;oacute;n recursiva &quot;bien escrita&quot; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; optimizar&amp;aacute; el uso de la pila. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay una publicaci&amp;oacute;n interesante de Guido sobre esta pregunta: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Eliminaci&amp;oacute;n de recursi&amp;oacute;n de cola&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5702b5681f002e1c77cf7f5d0d3515813c4410e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatten&lt;/code&gt; function here turns the list into a string, takes out &lt;strong&gt;all&lt;/strong&gt; of the square brackets, attaches square brackets back onto the ends, and turns it back into a list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; aqu&amp;iacute; convierte la lista en una cadena, saca &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;todos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; los corchetes, vuelve a colocar los corchetes en los extremos y los convierte nuevamente en una lista.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8528f7ed2c3c94ffb0211e58b7f2acb86af244a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield from&lt;/code&gt; operator returns an item from a generator one at a time. This &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;syntax for delegating to a subgenerator&lt;/a&gt; was added in 3.3</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; operador devuelve un art&amp;iacute;culo de un generador uno a la vez. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sintaxis para delegar en un subgenerador&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se agreg&amp;oacute; en 3.3&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="154968401f3a779a0b98b804cf8977b61118a1da" translate="yes" xml:space="preserve">
          <source>The DFS traversal pre-order is: L, 0, A, 1, 2, 3, 4. Remember, in order to implement an iterative DFS you also &quot;need&quot; a stack. The implementation I proposed before result in having the following states (for the &lt;code&gt;stack&lt;/code&gt; and the &lt;code&gt;flat_list&lt;/code&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El preorden transversal del DFS es: L, 0, A, 1, 2, 3, 4. Recuerde, para implementar un DFS iterativo tambi&amp;eacute;n &quot;necesita&quot; una pila. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La implementaci&amp;oacute;n que propuse antes da como resultado tener los siguientes estados (para la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y la lista &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flat_list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="135a1768cd4daf87f3b12fac9dbe360fe7259fd6" translate="yes" xml:space="preserve">
          <source>The code is:</source>
          <target state="translated">El código es:</target>
        </trans-unit>
        <trans-unit id="9bb4d095e6d13b019637c537fa9e20277e4e2a63" translate="yes" xml:space="preserve">
          <source>The easiest way is to use the &lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;morph&lt;/a&gt; library using &lt;code&gt;pip install morph&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La forma m&amp;aacute;s f&amp;aacute;cil es usar la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;biblioteca &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;morph&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pip install morph&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9730b9e2745e5198081261761f9462f7733b005a" translate="yes" xml:space="preserve">
          <source>The flattened list is then returned.</source>
          <target state="translated">La lista aplastada es entonces devuelta.</target>
        </trans-unit>
        <trans-unit id="b6b91a4964cc48f9f9afa9ebc468a09d9ec028d7" translate="yes" xml:space="preserve">
          <source>The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.</source>
          <target state="translated">El siguiente generador es casi igual al primero pero no tiene el problema de intentar aplanar un objeto no errático.Fracasa como uno esperaría cuando se le da un argumento inapropiado.</target>
        </trans-unit>
        <trans-unit id="bf5ea765f8026469fe3f7a96d57d282354586b40" translate="yes" xml:space="preserve">
          <source>The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.</source>
          <target state="translated">El bucle interno para el bucle itera a través de la lista.Si encuentra un elemento de la lista,(1)utiliza list.extend()para aplanar esa parte un nivel de anidación y (2)cambia keepChecking a True.keepchecking se utiliza para controlar el bucle while externo.Si el bucle exterior se ajusta a true,se activa el bucle interior para otra pasada.</target>
        </trans-unit>
        <trans-unit id="072c6ff6dd9019102323263f9272dee7bb233cef" translate="yes" xml:space="preserve">
          <source>The problem you encountered in the dungeon will be the same here, the call stack has a finite size (here 1000) and therefore, if you enter too many functions without returning back then you'll fill the call stack and have an error that look like &lt;strike&gt;&quot;Dear adventurer, I'm very sorry but your notebook is full&quot;&lt;/strike&gt;: &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt;. Note that you don't need recursion to fill the call stack, but it's very unlikely that a non-recursive program call 1000 functions without ever returning. It's important to also understand that once you returned from a function, the call stack is freed from the address used (hence the name &quot;stack&quot;, return address are pushed in before entering a function and pulled out when returning). In the special case of a simple recursion (a function &lt;code&gt;f&lt;/code&gt; that call itself once -- over and over --) you will enter &lt;code&gt;f&lt;/code&gt; over and over until the computation is finished (until the treasure is found) and return from &lt;code&gt;f&lt;/code&gt; until you go back to the place where you called &lt;code&gt;f&lt;/code&gt; in the first place. The call stack will never be freed from anything until the end where it will be freed from all return addresses one after the other.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El problema que encontr&amp;oacute; en la mazmorra ser&amp;aacute; el mismo aqu&amp;iacute;, la pila de llamadas tiene un tama&amp;ntilde;o finito (aqu&amp;iacute; 1000) y, por lo tanto, si ingresa demasiadas funciones sin regresar, llenar&amp;aacute; la pila de llamadas y tendr&amp;aacute; un error que se ver&amp;aacute; como &lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Estimado aventurero, lo siento mucho, pero su cuaderno est&amp;aacute; lleno&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. Tenga en cuenta que no necesita recursividad para llenar la pila de llamadas, pero es muy poco probable que un programa no recursivo llame a 1000 funciones sin volver nunca. Tambi&amp;eacute;n es importante comprender que una vez que regres&amp;oacute; de una funci&amp;oacute;n, la pila de llamadas se libera de la direcci&amp;oacute;n utilizada (de ah&amp;iacute; el nombre &quot;pila&quot;, la direcci&amp;oacute;n de retorno se ingresa antes de ingresar una funci&amp;oacute;n y se retira al regresar). En el caso especial de una recursi&amp;oacute;n simple (una funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que se llama a s&amp;iacute; misma una y otra vez), ingresar&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; una y otra vez hasta que finalice el c&amp;aacute;lculo (hasta que se encuentre el tesoro) y regresar&amp;aacute; de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hasta que vaya de vuelta al lugar donde llamaste &lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;en primer lugar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La pila de llamadas nunca se liberar&amp;aacute; de nada hasta el final, donde se liberar&amp;aacute; de todas las direcciones de retorno, una tras otra.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fccb286979da55d6c6e125dbea7209d07f046f87" translate="yes" xml:space="preserve">
          <source>There are better, faster methods (If you've reached here, you have seen them already)</source>
          <target state="translated">Hay métodos mejores y más rápidos (si has llegado hasta aquí,ya los has visto)</target>
        </trans-unit>
        <trans-unit id="f9caba178eb8922f0394406ccdde49ee49df43a0" translate="yes" xml:space="preserve">
          <source>There is a technique that you can use to make any recursive function iterative, this technique we could call &lt;em&gt;&lt;strong&gt;bring your own notebook&lt;/strong&gt;&lt;/em&gt;. For example, in our particular case we simply are exploring a list, entering a room is equivalent to entering a sublist, the question you should ask yourself is &lt;em&gt;how can I get back from a list to its parent list?&lt;/em&gt; The answer is not that complex, repeat the following until the &lt;code&gt;stack&lt;/code&gt; is empty:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay una t&amp;eacute;cnica que puede usar para hacer que cualquier funci&amp;oacute;n recursiva sea iterativa, esta t&amp;eacute;cnica podr&amp;iacute;amos llamar &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;traer su propio cuaderno&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, en nuestro caso particular simplemente estamos explorando una lista, ingresar a una habitaci&amp;oacute;n es equivalente a ingresar una sublista, la pregunta que debe &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;hacerse&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;c&amp;oacute;mo puedo volver de una lista a su lista principal. &lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La respuesta no es tan compleja, repita lo siguiente hasta que la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;eacute; vac&amp;iacute;a:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a76c19332391eecb7270208d09b08dff1cefe111" translate="yes" xml:space="preserve">
          <source>This considers strings as &quot;simple items&quot; and therefore &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; will return &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; and not &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt;. Remark that in that case, &lt;code&gt;iter(item)&lt;/code&gt; is called twice on each item, let's pretend it's an exercise for the reader to make this cleaner.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto considera las cadenas como &quot;elementos simples&quot; y, por &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tanto, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;flatten_iter ([[&quot;prueba&quot;, &quot;a&quot;], &quot;b])&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; devolver&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y no &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Observe que en ese caso, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iter(item)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se llama dos veces en cada &amp;iacute;tem, supongamos que es un ejercicio para el lector hacer esto m&amp;aacute;s limpio.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35450707d84bb0ce84709e530c6a2b600bd4d904" translate="yes" xml:space="preserve">
          <source>This is a simple implement of flatten on python2</source>
          <target state="translated">Este es un simple implemento de aplanar en pitón2</target>
        </trans-unit>
        <trans-unit id="2e4799018e16d870c6e5e1422846257d94aa57ba" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;flatten&lt;/code&gt; avoids python's recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta versi&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; evita el l&amp;iacute;mite de recursi&amp;oacute;n de Python (y, por lo tanto, funciona con iterables anidados arbitrariamente profundos). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es un generador que puede manejar cadenas e iterables arbitrarios (incluso infinitos).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2bd5654ac77b479f712d41c3a504f60b62c199d" translate="yes" xml:space="preserve">
          <source>This will flatten a list or dictionary (or list of lists or dictionaries of dictionaries etc). It assumes that the values are strings and it creates a string that concatenates each item with a separator argument. If you wanted you could use the separator to split the result into a list object afterward. It uses recursion if the next value is a list or a string. Use the key argument to tell whether you want the keys or the values (set key to false) from the dictionary object.</source>
          <target state="translated">Esto aplanará una lista o diccionario (o lista de listas o diccionarios de diccionarios,etc.).Supone que los valores son cadenas y crea una cadena que concatena cada elemento con un argumento separador.Si lo desea,puede utilizar el separador para dividir el resultado en un objeto de la lista después.Utiliza la recursividad si el siguiente valor es una lista o una cadena.Utiliza el argumento clave para indicar si quieres las claves o los valores (establece la clave como falsa)del objeto de diccionario.</target>
        </trans-unit>
        <trans-unit id="77dfd5cfcd224f3d1363dfe3cb85003efe050d9f" translate="yes" xml:space="preserve">
          <source>This works with two lists: an inner for loop and an outer while loop.</source>
          <target state="translated">Esto funciona con dos listas:una interna para el bucle y una externa para el bucle while.</target>
        </trans-unit>
        <trans-unit id="e537559c79429148f10b6b9cf0978b9e2371bc8a" translate="yes" xml:space="preserve">
          <source>Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.</source>
          <target state="translated">Esos pases siguen ocurriendo hasta que no se encuentran más listas anidadas.Cuando finalmente se produce un pase donde no se encuentra ninguno,keepChecking nunca se dispara a true,lo que significa que listIsNested permanece falso y el bucle externo mientras que el bucle sale.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="303c2ecddc270d76490ec99651c75c05229ac735" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;itertools.chain&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;itertools.chain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="057ed5e75ff2f0ad40d7cbbc26525344260fd727" translate="yes" xml:space="preserve">
          <source>Using generator functions can make your example a little easier to read and probably boost the performance.</source>
          <target state="translated">El uso de las funciones del generador puede hacer que su ejemplo sea un poco más fácil de leer y probablemente aumente el rendimiento.</target>
        </trans-unit>
        <trans-unit id="2217cada8873c4496bd08dcd7534fbce6ad78f5c" translate="yes" xml:space="preserve">
          <source>When I say &lt;em&gt;most of the codes&lt;/em&gt; I mean all codes that use any form of recursion (or call a standard library function that is recursive). All these codes fail because for every of the recursive call made, the (call) stack grow by one unit, and the (default) python call stack has a size of 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando digo la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mayor&amp;iacute;a de los c&amp;oacute;digos,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; me refiero a todos los c&amp;oacute;digos que usan cualquier forma de recursi&amp;oacute;n (o llaman a una funci&amp;oacute;n de biblioteca est&amp;aacute;ndar que es recursiva). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Todos estos c&amp;oacute;digos fallan porque por cada llamada recursiva realizada, la pila (llamada) crece en una unidad, y la pila de llamadas python (predeterminada) tiene un tama&amp;ntilde;o de 1000.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d2be4bbcc49edcd35c84a1c8296c7bc26899184" translate="yes" xml:space="preserve">
          <source>When entering the dungeon, you notice a small &lt;strong&gt;notebook&lt;/strong&gt; here. You decide to use it to write down every room you exit after solving a riddle (when entering a new room), this way you'll be able to return back to the entrance. That's a genius idea, you &lt;em&gt;won't even spend a cent&lt;/em&gt; implementing your strategy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al entrar en la mazmorra, ves un peque&amp;ntilde;o &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cuaderno&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; aqu&amp;iacute;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Decide usarlo para escribir cada habitaci&amp;oacute;n que salga despu&amp;eacute;s de resolver un acertijo (al ingresar a una nueva habitaci&amp;oacute;n), de esta manera podr&amp;aacute; regresar a la entrada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esa es una idea genial, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ni siquiera gastar&amp;aacute; un centavo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; implementando su estrategia.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea08aaefc36c7bd0e08223e9634c0ae634211149" translate="yes" xml:space="preserve">
          <source>When trying to answer such a question you really need to give the limitations of the code you propose as a solution. If it was only about performances I wouldn't mind too much, but most of the codes proposed as solution (including the accepted answer) fail to flatten any list that has a depth greater than 1000.</source>
          <target state="translated">Cuando se trata de responder a tal pregunta es necesario dar las limitaciones del código que se propone como solución.Si se tratara sólo de actuaciones no me importaría demasiado,pero la mayoría de los códigos propuestos como solución (incluyendo la respuesta aceptada)no logran aplanar ninguna lista que tenga una profundidad superior a 1000.</target>
        </trans-unit>
        <trans-unit id="1c4f6558f38981ddb59d040b4538d37b7efc2d09" translate="yes" xml:space="preserve">
          <source>Where the desired output is</source>
          <target state="translated">Donde la salida deseada es</target>
        </trans-unit>
        <trans-unit id="07d07b7b8ea752db0d14deeb6cb38e985e165f11" translate="yes" xml:space="preserve">
          <source>Which gives: &lt;code&gt;build_deep_list(5)&lt;/code&gt; &amp;gt;&amp;gt;&amp;gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que da: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;build_deep_list(5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12006179f5926aac3184169403362f3f9c481acf" translate="yes" xml:space="preserve">
          <source>Without using any library:</source>
          <target state="translated">Sin usar ninguna biblioteca:</target>
        </trans-unit>
        <trans-unit id="bf88998d5c009de437a318db8effc7a1537c6a7e" translate="yes" xml:space="preserve">
          <source>Yes, I know this subject has been covered before (&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;here&lt;/a&gt;), but as far as I know, all solutions, except for one, fail on a list like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;S&amp;iacute;, s&amp;eacute; que este tema se ha cubierto antes ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), pero que yo sepa, todas las soluciones, excepto una, fallan en una lista como esta:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74a1b281a15fddb74b8fce9e6b33b2503f2b15ba" translate="yes" xml:space="preserve">
          <source>You could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;deepflatten&lt;/code&gt;&lt;/a&gt; from the 3rd party package &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt;&lt;code&gt;iteration_utilities&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se podr&amp;iacute;a utilizar &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;deepflatten&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; del 3 paquete de fiesta &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3debaf3c28a15f60ba292768b82cfaf8dfacc54c" translate="yes" xml:space="preserve">
          <source>You enter the dungeon, solving with great success the first 1001 riddles, but here comes something you hadn't planed, you have no space left in the notebook you borrowed. You decide to &lt;em&gt;abandon&lt;/em&gt; your quest as you prefer not having the treasure than being lost forever inside the dungeon (that looks smart indeed).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entras en la mazmorra, resolviendo con gran &amp;eacute;xito los primeros 1001 acertijos, pero aqu&amp;iacute; viene algo que no hab&amp;iacute;as planeado, no te queda espacio en el cuaderno que tomaste prestado. Decides &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;abandonar&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tu b&amp;uacute;squeda, ya que prefieres no tener el tesoro que perderte para siempre dentro de la mazmorra (eso parece inteligente).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64d4175e880a1832a2a0d0bb31fd6657fe5d0d89" translate="yes" xml:space="preserve">
          <source>every time an item is found, &lt;code&gt;yield&lt;/code&gt; it (or add them in a list);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cada vez que se encuentre un art&amp;iacute;culo, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (o agr&amp;eacute;galo en una lista);&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e51c354b48926dd260c73a845d3893393cf58cb" translate="yes" xml:space="preserve">
          <source>here is one simple and one not-so-simple case -</source>
          <target state="translated">aquí hay un caso simple y otro no tan simple...</target>
        </trans-unit>
        <trans-unit id="adc6d4918f750b646571daa2e00df52c14b564db" translate="yes" xml:space="preserve">
          <source>here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt; so use it with caution ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute; estamos usando conjuntos para verificar el tipo, por lo que se necesita O (1) vs O (n&amp;uacute;mero de tipos) para verificar si un elemento debe ser ignorado o no, aunque, por supuesto, cualquier valor con el tipo derivado de los tipos ignorados declarados fallar&amp;aacute; , esta es la raz&amp;oacute;n por la que usa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;as&amp;iacute; que &amp;uacute;selo con precauci&amp;oacute;n ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccedab2b750529fb2f1b87bbe07378ea34020ea1" translate="yes" xml:space="preserve">
          <source>once a list is fully explored, go back to the parent list using the &lt;code&gt;stack&lt;/code&gt;&lt;em&gt;return &lt;code&gt;address&lt;/code&gt; (and &lt;code&gt;index&lt;/code&gt;)&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una vez que se explora por completo una lista, regrese a la lista principal utilizando la &lt;/font&gt;&lt;em&gt; &lt;code&gt;address&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; retorno de&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(y el &lt;/font&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;index&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="296855ad54af49593cc7b3f4e5521f091bd38983" translate="yes" xml:space="preserve">
          <source>push the current list &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; in a &lt;code&gt;stack&lt;/code&gt; when entering a new sublist (note that a list address+index is also an address, therefore we just use the exact same technique used by the call stack);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;empuje la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lista actual &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;y el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; al ingresar una nueva sublista (tenga en cuenta que una direcci&amp;oacute;n de lista + &amp;iacute;ndice tambi&amp;eacute;n es una direcci&amp;oacute;n, por lo tanto, solo usamos la misma t&amp;eacute;cnica utilizada por la pila de llamadas);&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a5301a88da334dc5afc5b63979daa0f3f45e68" translate="yes" xml:space="preserve">
          <source>result</source>
          <target state="translated">result</target>
        </trans-unit>
        <trans-unit id="37b8dabf0b7bfae1c2eecb47a6afcd8bc92cc94c" translate="yes" xml:space="preserve">
          <source>returns:</source>
          <target state="translated">returns:</target>
        </trans-unit>
        <trans-unit id="9dd608f36d0db13a98f4add5e42d48a50fa3c769" translate="yes" xml:space="preserve">
          <source>tests:</source>
          <target state="translated">tests:</target>
        </trans-unit>
        <trans-unit id="90b34293d40fd211f22a7eb82950647a7a0d5b3f" translate="yes" xml:space="preserve">
          <source>there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you'll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...</source>
          <target state="translated">hay un enfoque un poco más rápido,pero menos portátil,sólo úsalo si puedes asumir que los elementos base de la entrada pueden ser explícitamente determinados de otra manera,obtendrás una recursividad infinita,y OS X con su limitado tamaño de pila,lanzará un fallo de segmentación bastante rápido...</target>
        </trans-unit>
        <trans-unit id="e33ad899228cb347b7c6fd1b4662e7475fffbffc" translate="yes" xml:space="preserve">
          <source>totally hacky but I think it would work (depending on your data_type)</source>
          <target state="translated">totalmente hacky pero creo que funcionaría (dependiendo de tu data_type)</target>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="translated">yields:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
