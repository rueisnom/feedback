<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2158395">
    <body>
      <group id="2158395">
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b94d16302cf154c51472d68c89f80eccc9bf39da" translate="yes" xml:space="preserve">
          <source>A little more concise, but pretty much the same.</source>
          <target state="translated">简洁一点,但也差不多。</target>
        </trans-unit>
        <trans-unit id="2e1e92ffc64201504c5a6eff5c1414fff1c14c5b" translate="yes" xml:space="preserve">
          <source>Also note that this is equivalent to a DFS in a tree where some nodes are sublists &lt;code&gt;A = [1, 2]&lt;/code&gt; and some are simple items: &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; (for &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt;). The tree looks like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还要注意，这等效于树中的DFS，其中某些节点是子列表&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A = [1, 2]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而有些则是简单项目：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0, 1, 2, 3, 4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;L = [0, [1,2], 3, 4]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;树看起来像这样：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39ae53263fd5d3fc2ad1e4969d6289c8ceffa883" translate="yes" xml:space="preserve">
          <source>Also note:</source>
          <target state="translated">还注意到:</target>
        </trans-unit>
        <trans-unit id="b988bb020235fef9787bc47fbe5d47be55ac3d74" translate="yes" xml:space="preserve">
          <source>Also, notice that in &lt;code&gt;is_list_like&lt;/code&gt; I have &lt;code&gt;isinstance(item, list)&lt;/code&gt;, which could be changed to handle more input types, here I just wanted to have the simplest version where (iterable) is just a list. But you could also do that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，请注意，在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;is_list_like&lt;/code&gt; 中,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;isinstance(item, list)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，可以将其更改为处理更多输入类型，在这里我只想拥有最简单的版本，其中（iterable）只是一个列表。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是您也可以这样做：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cc5ad86f665601e560433987cb7417b01efca95" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;flatten&lt;/code&gt; can handle infinite generators, it can not handle infinite nesting:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管&lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以处理无限量的生成器，但它不能处理无限量的嵌套：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c9eeb6d8077aaaaf78d4e63ffe4b8b711c773d" translate="yes" xml:space="preserve">
          <source>Although an elegant and very pythonic answer has been selected I would present my solution just for the review:</source>
          <target state="translated">虽然选择了一个优雅而又非常火药味十足的答案,但我只想提出我的解决方案,以供复习时参考。</target>
        </trans-unit>
        <trans-unit id="79005deb294f385cf51ff98cdbfe50b8975ffaaa" translate="yes" xml:space="preserve">
          <source>Although, if you knew you would have square brackets in your list in strings, like &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt;, you would have to do something else.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;虽然，如果您知道列表中的方括号中有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[[1, 2], &quot;[3, 4] and [5]&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的字符串&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则您需要做其他事情。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea99bd96f840dbdf67557a459fb8a821cca61dbf" translate="yes" xml:space="preserve">
          <source>Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list.</source>
          <target state="translated">基本上,它将嵌套的列表转换为字符串,使用regex去掉嵌套的语法,然后将结果转换为(扁平化的)列表。</target>
        </trans-unit>
        <trans-unit id="7bce1bc51c3449501719ffd5a57d46f6c16b5528" translate="yes" xml:space="preserve">
          <source>Basically, it's the exact same thing as finding the treasure. The dungeon is the &lt;em&gt;computer's memory&lt;/em&gt;, your goal now is not to find a treasure but to &lt;em&gt;compute some function&lt;/em&gt; (find &lt;em&gt;f(x)&lt;/em&gt; for a given &lt;em&gt;x&lt;/em&gt;). The indications simply are sub-routines that will help you solving &lt;em&gt;f(x)&lt;/em&gt;. Your strategy is the same as the &lt;em&gt;call stack&lt;/em&gt; strategy, the notebook is the stack, the rooms are the functions' return addresses:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本上，这与寻找宝藏完全相同。地牢是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;计算机的内存&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您现在的目标不是找到宝藏，而是要&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;计算某些函数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于给定&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;x&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;找到&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f（x）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。这些指示只是子例程，可以帮助您解决&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;f（x）&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。您的策略与&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用堆栈&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;策略&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，笔记本是堆栈，房间是函数的返回地址：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="00e8a0bc89e1685335629d80defa1da3e4b13655" translate="yes" xml:space="preserve">
          <source>Call stack size and recursive programming (dungeon analogy)</source>
          <target state="translated">调用栈的大小和递归编程(地牢类比</target>
        </trans-unit>
        <trans-unit id="fe08d2e421da75ca59dd2aeab5263533ae932acd" translate="yes" xml:space="preserve">
          <source>Deprecated since version 2.6: The compiler package has been removed in Python 3.</source>
          <target state="translated">自 2.6 版起不再使用:在 Python 3 中删除了编译器包。</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="6e0393cc0cfaf97f6bbc102a7c484c707418a0a6" translate="yes" xml:space="preserve">
          <source>Executing a recursive program</source>
          <target state="translated">执行一个递归程序</target>
        </trans-unit>
        <trans-unit id="cffa8ae998bde40c61124489d1d7d218e9c222c6" translate="yes" xml:space="preserve">
          <source>Finding the treasure and exit</source>
          <target state="translated">寻宝和出口</target>
        </trans-unit>
        <trans-unit id="89d4cc02db3c116e3e5e4b9ef0aa736c4918c1e7" translate="yes" xml:space="preserve">
          <source>Flatten an irregular list of lists</source>
          <target state="translated">扁平化不规则的列表</target>
        </trans-unit>
        <trans-unit id="dc5881a87e62d2dd4244fc1bbeb8669c4db39c54" translate="yes" xml:space="preserve">
          <source>For the implementation, in python you can simplify a little bit by using iterators instead of simple lists. References to the (sub)iterators will be used to store &lt;em&gt;sublists return addresses&lt;/em&gt; (instead of having both the list address and the index). This is not a big difference but I feel this is more readable (and also a bit faster):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于实现，在python中，您可以使用迭代器而不是简单的列表来简化一点。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对（子）迭代器的引用将用于存储&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子列表的返回地址&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（而不是同时具有列表地址和索引）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这不是什么大的区别，但是我觉得它更具可读性（并且速度更快）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14b3b87237e51935f59f6a45980acb7e07912e3d" translate="yes" xml:space="preserve">
          <source>Generator using recursion and duck typing (updated for Python 3):</source>
          <target state="translated">使用递归和duck键入法生成器(为Python 3更新)。</target>
        </trans-unit>
        <trans-unit id="29a3d6e99377c3e58e92fa6570cbcd314d1369e0" translate="yes" xml:space="preserve">
          <source>Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:</source>
          <target state="translated">@unutbu的非递归解决方案的生成器版本,这是由@Andrew在评论中要求的。</target>
        </trans-unit>
        <trans-unit id="de414681c4d86a10bca5d7259bca22e7cc442e38" translate="yes" xml:space="preserve">
          <source>Here are some examples demonstrating its use:</source>
          <target state="translated">以下是一些例子来证明它的用途。</target>
        </trans-unit>
        <trans-unit id="d761607d7fd53dc85f57f027dcb4d53b118a4328" translate="yes" xml:space="preserve">
          <source>Here is another py2 approach, Im not sure if its the fastest or the most elegant nor safest ...</source>
          <target state="translated">这里是另一个py2的方法,我不确定它是否最快或最优雅也最安全。</target>
        </trans-unit>
        <trans-unit id="f8f1df1a614a50ef001234abdbb4b19c8fcde356" translate="yes" xml:space="preserve">
          <source>Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments. Returns a generator which produces the entire sequence in order, arg by arg:</source>
          <target state="translated">这里是我的递归扁平化的功能版本,它可以处理tuple和list,并允许你抛出任何混合的位置参数。返回一个生成器,它可以按顺序生成整个序列,按参数 arg 的顺序生成。</target>
        </trans-unit>
        <trans-unit id="192708e2b1612f7e2636733beef7d6446a1d0792" translate="yes" xml:space="preserve">
          <source>Here's a simple function that flattens lists of arbitrary depth. No recursion, to avoid stack overflow.</source>
          <target state="translated">这里有一个简单的函数,可以将任意深度的列表扁平化。不需要递归,避免堆栈溢出。</target>
        </trans-unit>
        <trans-unit id="cca580c17fbc89a2f6cb82d0bd1f19329e72e277" translate="yes" xml:space="preserve">
          <source>Here's another answer that is even more interesting...</source>
          <target state="translated">下面是另一个更有趣的答案.....。</target>
        </trans-unit>
        <trans-unit id="4d57f3784cbadc37b4cfe69affdca1585e5114eb" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;compiler.ast.flatten&lt;/code&gt; implementation in 2.7.5:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;compiler.ast.flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在2.7.5的实现：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="86313aca1240327c8110d73a59910a2e4748a8eb" translate="yes" xml:space="preserve">
          <source>How to avoid this issue?</source>
          <target state="translated">如何避免这个问题?</target>
        </trans-unit>
        <trans-unit id="73311ad0ce2612a0bac165fe5b4f0d2143fe420c" translate="yes" xml:space="preserve">
          <source>I actually adapted this from some practice Scheme code that I had written a while back.</source>
          <target state="translated">实际上,我是根据我前段时间写的一些实践计划代码改编的。</target>
        </trans-unit>
        <trans-unit id="1fe7bbe6a54abd708286ebfd2590e527d89fb6bf" translate="yes" xml:space="preserve">
          <source>I am aware that there are already many awesome answers but i wanted to add an answer that uses the functional programming method of solving the question. In this answer i make use of double recursion :</source>
          <target state="translated">我知道已经有很多很棒的答案了,但是我想增加一个使用函数式编程方法来解决这个问题的答案。在这个答案中,我使用了双递归的方法。</target>
        </trans-unit>
        <trans-unit id="25ff56d30963a5a4f97668f1bc5fc99613a35d75" translate="yes" xml:space="preserve">
          <source>I didn't go through all the already available answers here, but here is a one liner I came up with, borrowing from lisp's way of first and rest list processing</source>
          <target state="translated">我没有把这里已经有的答案都看完,但我在这里借用lisp的首尾列表处理方式,想出了一个单行本,借用了一下</target>
        </trans-unit>
        <trans-unit id="63f84972799a9df278bff951da68e8c61c51e0db" translate="yes" xml:space="preserve">
          <source>I disagree with the previous implementation. The problem is that you should not be able to flatten something that is not an iterable. It is confusing and gives the wrong impression of the argument.</source>
          <target state="translated">我不同意前面的实现方式。问题是,你不应该把不是迭代的东西放平。这样做会让人感到困惑,给人以错误的论证印象。</target>
        </trans-unit>
        <trans-unit id="d21115e6807ec7e80c0e53149fb1e2549851a053" translate="yes" xml:space="preserve">
          <source>I prefer simple answers.  No generators.  No recursion or recursion limits.  Just iteration:</source>
          <target state="translated">我喜欢简单的答案。没有生成器。没有递归和递归限制。只有迭代。</target>
        </trans-unit>
        <trans-unit id="d552c40c91766011979100b463254df3b544b08b" translate="yes" xml:space="preserve">
          <source>I used recursive to solve &lt;strong&gt;&lt;em&gt;nested list with any depth&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用递归来解决&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何深度的嵌套列表&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5f4c4090ed4da94119c438444b23567bd92e579" translate="yes" xml:space="preserve">
          <source>I used the &lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;Iterable ABC&lt;/a&gt; added in 2.6.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2.6中添加&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.python.org/library/collections.html#abcs-abstract-base-classes&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Iterable ABC&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bfd5938dfd46dcfadadefac4f96e2163678e963" translate="yes" xml:space="preserve">
          <source>I'm new to python and come from a lisp background. This is what I came up with (check out the var names for lulz):</source>
          <target state="translated">我是python的新手,来自lisp背景。这是我想出来的(看看lulz的var名)。</target>
        </trans-unit>
        <trans-unit id="02500c7b14b0e35ad9d368d2709d1abf9be8bcbc" translate="yes" xml:space="preserve">
          <source>I'm not sure if this is necessarily quicker or more effective, but this is what I do:</source>
          <target state="translated">我不知道这样做是否一定更快、更有效,但我是这样做的。</target>
        </trans-unit>
        <trans-unit id="6237c2b268a9a2c753eb0575cba2851d46cd8806" translate="yes" xml:space="preserve">
          <source>I'm surprised no one has thought of this. Damn recursion I don't get the recursive answers that the advanced people here made. anyway here is my attempt on this. caveat is it's very specific to the OP's use case</source>
          <target state="translated">我很惊讶没有人想到这个问题。该死的递归,我不明白这里的高级人士所做的递归答案。</target>
        </trans-unit>
        <trans-unit id="f2a887d9dc7263e6673a358d623c71925b5827af" translate="yes" xml:space="preserve">
          <source>I'm the author of the &lt;code&gt;iteration_utilities&lt;/code&gt; library.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;库&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的作者&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16f02278b2307a15155e59a48d751351737d9dc0" translate="yes" xml:space="preserve">
          <source>If you like recursion, this might be a solution of interest to you:</source>
          <target state="translated">如果你喜欢递归,这可能是你感兴趣的一个解决方案。</target>
        </trans-unit>
        <trans-unit id="ce254e7f2d55496a2a51b2fc7c005e802480f05a" translate="yes" xml:space="preserve">
          <source>If you need to test your solution, you can use this function to generate a simple nested list:</source>
          <target state="translated">如果你需要测试你的解决方案,你可以用这个功能生成一个简单的嵌套列表。</target>
        </trans-unit>
        <trans-unit id="ae9dea2001369860e6d6e3b472dfa7fe73dd1491" translate="yes" xml:space="preserve">
          <source>If you're not too familiar with the call stack, then maybe the following will help (otherwise you can just scroll to the &lt;strong&gt;Implementation&lt;/strong&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不太熟悉调用堆栈，那么以下内容可能会有所帮助（否则，您可以滚动到&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Implementation&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccc8187609cdbafce2adf1007c1c12e540acf4ff" translate="yes" xml:space="preserve">
          <source>Imagine you enter a huge &lt;em&gt;dungeon with numbered rooms&lt;/em&gt;, looking for a treasure. You don't know the place but you have some &lt;strong&gt;indications&lt;/strong&gt; on how to find the treasure. Each indication is a riddle (difficulty varies, but you can't predict how hard they will be). You decide to think a little bit about a strategy to save time, you make two observations:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;想象一下，您进入一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;带编号房间&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的巨大&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;地牢&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，寻找宝藏。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您不知道这个地方，但是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于如何找到宝藏&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一些&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指示&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个指示都是一个谜（难度各不相同，但是您无法预测它们的难易程度）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您决定对节省时间的策略进行一点思考，然后进行两个观察：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="755295b4b33843ecc770e563e6c872d57ade6d17" translate="yes" xml:space="preserve">
          <source>In Python 3, the &lt;code&gt;basestring&lt;/code&gt; is no more, but you can use a tuple of &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; to get the same effect there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Python 3中，基本&lt;/font&gt;&lt;/font&gt; &lt;code&gt;basestring&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再存在，但是您可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元组在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此处获得相同的效果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63ceef487e0ed2113d3415ac21f524ca491369eb" translate="yes" xml:space="preserve">
          <source>In the end, remember that you can't print a infinitely nested list &lt;code&gt;L&lt;/code&gt; using &lt;code&gt;print(L)&lt;/code&gt; because internally it will use recursive calls to &lt;code&gt;__repr__&lt;/code&gt; (&lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt;). For the same reason, solutions to &lt;code&gt;flatten&lt;/code&gt; involving &lt;code&gt;str&lt;/code&gt; will fail with the same error message.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最后，请记住，您不能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;print(L)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;打印无限嵌套的列表&lt;/font&gt;&lt;/font&gt; &lt;code&gt;L&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为在内部它将使用对&lt;/font&gt; &lt;code&gt;__repr__&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;递归调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded while getting the repr of an object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出于相同的原因，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;涉及&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; 的 &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将因相同的错误消息而失败。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa8151a1aab9fc8bab222f58152b8c8370bb3f5f" translate="yes" xml:space="preserve">
          <source>In this example, the stack maximum size is 2, because the input list (and therefore the tree) have depth 2.</source>
          <target state="translated">在这个例子中,堆栈最大大小为2,因为输入列表(因此树)的深度为2。</target>
        </trans-unit>
        <trans-unit id="cc4e9d94220d7cd5461a09f4298103ba3f39a77f" translate="yes" xml:space="preserve">
          <source>Is this the best model? Did I overlook something? Any problems?</source>
          <target state="translated">这是最好的模式吗?我是不是忽略了什么?有什么问题吗?</target>
        </trans-unit>
        <trans-unit id="9be35c6488088a4b9b217f398fdaa6add15ed10f" translate="yes" xml:space="preserve">
          <source>It can ignore any specific (or derived) type you would like, it returns an iterator, so you can convert it to any specific container such as list, tuple, dict or simply consume it in order to reduce memory footprint, for better or worse it can handle initial non-iterable objects such as int ...</source>
          <target state="translated">它可以忽略任何你想要的特定(或派生)类型,它返回一个迭代器,所以你可以将其转换为任何特定的容器,如list、tuple、dict或简单地消耗它,以减少内存占用,无论好坏,它都可以处理初始不可iterable对象,如int.....</target>
        </trans-unit>
        <trans-unit id="3e28f912c3bce57b5166b693a2a552f23ab60528" translate="yes" xml:space="preserve">
          <source>It was fun trying to create a function that could flatten irregular list in Python, but of course that is what Python is for (to make programming fun). The following generator works fairly well with some caveats:</source>
          <target state="translated">试图在Python中创建一个可以将不规则列表扁平化的函数是很有趣的,当然,这就是Python的作用(让编程变得有趣)。下面的生成器工作得相当不错,但有一些注意事项。</target>
        </trans-unit>
        <trans-unit id="4bb90b9d131e83bfcc3336776d86f58c4d625af1" translate="yes" xml:space="preserve">
          <source>It will flatten datatypes that you might want left alone (like &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, and &lt;code&gt;str&lt;/code&gt; objects). Also, the code relies on the fact that requesting an iterator from a non-iterable raises a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它将扁平化您可能希望单独保留的数据类型（例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此外，代码还依赖于以下事实：从不可迭代的对象请求迭代器会引发&lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e7334089e0c1aa21da068f2629fd98c0ba9bf10" translate="yes" xml:space="preserve">
          <source>It's an iterator so you need to iterate it (for example by wrapping it with &lt;code&gt;list&lt;/code&gt; or using it in a loop). Internally it uses an iterative approach instead of an recursive approach and it's written as C extension so it can be faster than pure python approaches:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个迭代器，因此您需要对其进行迭代（例如，通过将其包装在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;list&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或在循环中使用它）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在内部，它使用迭代方法而不是递归方法，并且将其编写为C扩展，因此它可以比纯python方法更快：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="327d7cc30ef399ae94d35dcc5692804d9ea4a921" translate="yes" xml:space="preserve">
          <source>It's hard (long) to find the treasure as you'll have to solve (potentially hard) riddles to get there.</source>
          <target state="translated">要找到宝藏是很难的(漫长的),因为你必须解开(可能是很难的)谜题才能到达。</target>
        </trans-unit>
        <trans-unit id="42a9a19d3d56bb3334c62df22e60fdada2dcdcd2" translate="yes" xml:space="preserve">
          <source>Just use a &lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt;&lt;code&gt;funcy&lt;/code&gt;&lt;/a&gt; library:
&lt;code&gt;pip install funcy&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只需使用一个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://funcy.readthedocs.io/en/stable/&quot;&gt; &lt;code&gt;funcy&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;库： &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pip install funcy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e972ca2d74e4344909c9d769a43e177bf4b73da" translate="yes" xml:space="preserve">
          <source>My solution:</source>
          <target state="translated">我的解决办法是:</target>
        </trans-unit>
        <trans-unit id="bad516f05c5f73910361629673802985b60ee859" translate="yes" xml:space="preserve">
          <source>Note most of the heavy lifting is done in C, since as far as I know thats how itertools are implemented, so while it is recursive, AFAIK it isn't bounded by python recursion depth since the function calls are happening in C, though this doesn't mean you are bounded by memory, specially in OS X where its stack size has a hard limit as of today (OS X Mavericks) ...</source>
          <target state="translated">注意,大部分的工作都是在C语言中完成的,因为据我所知,itertools是这样实现的,所以虽然它是递归的,但AFAIK它不受python递归深度的限制,因为函数调用是在C语言中进行的,不过这并不意味着你会受到内存的限制,特别是在OS X中,它的堆栈大小有一个硬性的限制(OS X Mavericks).....</target>
        </trans-unit>
        <trans-unit id="ed6380feaa8a9c7ce4fafd4f95fc7270dbb5cb2e" translate="yes" xml:space="preserve">
          <source>Once the treasure found, returning to the entrance may be easy, you just have to use the same path in the other direction (though this needs a bit of memory to recall your path).</source>
          <target state="translated">找到宝藏后,回到入口可能很容易,只需要用另一个方向的原路返回就可以了(当然这需要一定的记忆力来回忆自己的路径)。</target>
        </trans-unit>
        <trans-unit id="d0cd477d78798b3f11b8ce3d44411f3dfe6dd415" translate="yes" xml:space="preserve">
          <source>Or perhaps even better, an iterator. The only solution I saw that works for an arbitrary nesting is found &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;in this question&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;甚至更好的迭代器。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是我看到的唯一适用于任意嵌套的解决方案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2be78dba5189bfabfa4dc4f74e5681909c29d399" translate="yes" xml:space="preserve">
          <source>Or without chaining:</source>
          <target state="translated">或无链子的情况下。</target>
        </trans-unit>
        <trans-unit id="195bb83dcdc0362b1e06e323cc01a996b7dc71a5" translate="yes" xml:space="preserve">
          <source>Please tell how good or bad this code is?</source>
          <target state="translated">请告诉我这个代码是好是坏?</target>
        </trans-unit>
        <trans-unit id="85428b26db4c1794e05f4269b0c513309de817c9" translate="yes" xml:space="preserve">
          <source>Python 2</source>
          <target state="translated">Python 2</target>
        </trans-unit>
        <trans-unit id="0101a74afd88d622354b05b2b6416e029264bbac" translate="yes" xml:space="preserve">
          <source>Python 3</source>
          <target state="translated">Python 3</target>
        </trans-unit>
        <trans-unit id="b1a4bdad53d496f016539994db00ab42bad7ab3a" translate="yes" xml:space="preserve">
          <source>Seems to work. Test:</source>
          <target state="translated">似乎是可以的。检验一下。</target>
        </trans-unit>
        <trans-unit id="b017e65239c7000352a2a4d2945b86297a105e82" translate="yes" xml:space="preserve">
          <source>Slightly simplified version of this generator:</source>
          <target state="translated">这个发电机略微简化的版本。</target>
        </trans-unit>
        <trans-unit id="4e6420f44801052d8450e03e5a463a2b1ebe007c" translate="yes" xml:space="preserve">
          <source>So after i define function combine_nlist, it is easy to use this function do flatting. Or you can combine it into one function. I like my solution because it can be applied to any nested list.</source>
          <target state="translated">所以我定义了函数 combine_nlist之后,很容易用这个函数做平移。或者你可以把它组合成一个函数。我喜欢我的解决方案,因为它可以应用于任何嵌套的列表。</target>
        </trans-unit>
        <trans-unit id="e66b79cc8c23c3de703aca50e255ff68402ff67a" translate="yes" xml:space="preserve">
          <source>Test-run</source>
          <target state="translated">Test-run</target>
        </trans-unit>
        <trans-unit id="0554905ed68d85c07973d301a7834f6460a2979e" translate="yes" xml:space="preserve">
          <source>Testing and remarks on other implementations</source>
          <target state="translated">测试和关于其他实施方案的评论</target>
        </trans-unit>
        <trans-unit id="9b290a7129085c8c8ce8c31773fae071246e9164" translate="yes" xml:space="preserve">
          <source>Testing the generator works fine with the list that was provided. However, the new code will raise a &lt;code&gt;TypeError&lt;/code&gt; when a non-iterable object is given to it. Example are shown below of the new behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用提供的列表对生成器进行测试可以正常工作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，新代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在给它一个不可迭代的对象时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将引发&lt;/font&gt;&lt;/font&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下面显示了新行为的示例。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="532857664f8e776457b2a0176cabc53f62598867" translate="yes" xml:space="preserve">
          <source>That's actually pretty simple: &quot;don't use recursion if you don't know how deep it can go&quot;. That's not always true as in some cases, &lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;Tail Call recursion can be Optimized (TCO)&lt;/a&gt;. But in python, this is not the case, and even &quot;well written&quot; recursive function will &lt;strong&gt;not&lt;/strong&gt; optimize stack use. There is an interesting post from Guido about this question: &lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;Tail Recursion Elimination&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这实际上很简单：&amp;ldquo;如果您不知道递归的深度，请不要使用递归&amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并非总是如此，因为在某些情况下，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/310974/what-is-tail-call-optimization&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以优化尾调用递归（TCO）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是在python中，情况并非如此，即使&amp;ldquo;写得好的&amp;rdquo;递归函数也&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优化堆栈使用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Guido有一个有趣的帖子，关于这个问题：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尾递归消除&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5702b5681f002e1c77cf7f5d0d3515813c4410e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatten&lt;/code&gt; function here turns the list into a string, takes out &lt;strong&gt;all&lt;/strong&gt; of the square brackets, attaches square brackets back onto the ends, and turns it back into a list.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数将列表转换为字符串，取出&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方括号，将方括号附加到两端，然后将其转换回列表。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8528f7ed2c3c94ffb0211e58b7f2acb86af244a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield from&lt;/code&gt; operator returns an item from a generator one at a time. This &lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;syntax for delegating to a subgenerator&lt;/a&gt; was added in 3.3</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;操作者在同一时间发生器一个返回的项目。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.3.html#pep-380&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;句法委派到子发生器&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在3.3加入&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="154968401f3a779a0b98b804cf8977b61118a1da" translate="yes" xml:space="preserve">
          <source>The DFS traversal pre-order is: L, 0, A, 1, 2, 3, 4. Remember, in order to implement an iterative DFS you also &quot;need&quot; a stack. The implementation I proposed before result in having the following states (for the &lt;code&gt;stack&lt;/code&gt; and the &lt;code&gt;flat_list&lt;/code&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DFS遍历的顺序为：L，0，A，1、2、3、4。请记住，要实现迭代DFS，您还需要&amp;ldquo;堆栈&amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我之前提出的实现导致具有以下状态（对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;flat_list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="135a1768cd4daf87f3b12fac9dbe360fe7259fd6" translate="yes" xml:space="preserve">
          <source>The code is:</source>
          <target state="translated">代码是:</target>
        </trans-unit>
        <trans-unit id="9bb4d095e6d13b019637c537fa9e20277e4e2a63" translate="yes" xml:space="preserve">
          <source>The easiest way is to use the &lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;morph&lt;/a&gt; library using &lt;code&gt;pip install morph&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最简单的方法是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过&lt;/font&gt; &lt;code&gt;pip install morph&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/metagriffin/morph&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;morph&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;库&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9730b9e2745e5198081261761f9462f7733b005a" translate="yes" xml:space="preserve">
          <source>The flattened list is then returned.</source>
          <target state="translated">然后返回扁平化的列表。</target>
        </trans-unit>
        <trans-unit id="b6b91a4964cc48f9f9afa9ebc468a09d9ec028d7" translate="yes" xml:space="preserve">
          <source>The following generator is almost the same as the first but does not have the problem of trying to flatten a non-iterable object. It fails as one would expect when an inappropriate argument is given to it.</source>
          <target state="translated">下面的生成器与第一个生成器几乎相同,但没有试图将一个不可iterable对象扁平化的问题。当给它一个不合适的参数时,它就会失败。</target>
        </trans-unit>
        <trans-unit id="bf5ea765f8026469fe3f7a96d57d282354586b40" translate="yes" xml:space="preserve">
          <source>The inner for loop iterates through the list.  If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.  keepchecking is used to control the outer while loop.  If the outer loop gets set to true, it triggers the inner loop for another pass.</source>
          <target state="translated">内部的for循环会在列表中进行迭代。如果它发现了一个列表元素,它(1)使用list.extend()将该部分的嵌套一层层压平,(2)将keepChecking切换为True。如果外循环被设置为true,则会触发内循环进行另一次传递。</target>
        </trans-unit>
        <trans-unit id="072c6ff6dd9019102323263f9272dee7bb233cef" translate="yes" xml:space="preserve">
          <source>The problem you encountered in the dungeon will be the same here, the call stack has a finite size (here 1000) and therefore, if you enter too many functions without returning back then you'll fill the call stack and have an error that look like &lt;strike&gt;&quot;Dear adventurer, I'm very sorry but your notebook is full&quot;&lt;/strike&gt;: &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt;. Note that you don't need recursion to fill the call stack, but it's very unlikely that a non-recursive program call 1000 functions without ever returning. It's important to also understand that once you returned from a function, the call stack is freed from the address used (hence the name &quot;stack&quot;, return address are pushed in before entering a function and pulled out when returning). In the special case of a simple recursion (a function &lt;code&gt;f&lt;/code&gt; that call itself once -- over and over --) you will enter &lt;code&gt;f&lt;/code&gt; over and over until the computation is finished (until the treasure is found) and return from &lt;code&gt;f&lt;/code&gt; until you go back to the place where you called &lt;code&gt;f&lt;/code&gt; in the first place. The call stack will never be freed from anything until the end where it will be freed from all return addresses one after the other.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您在地牢中遇到的问题在这里是相同的，调用堆栈的大小是有限的（此处为1000），因此，如果您输入了太多函数而没有返回，那么您将填充调用堆栈，并出现错误像&lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;亲爱的冒险家，很抱歉，您的笔记本已满&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;RecursionError: maximum recursion depth exceeded&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。请注意，您无需递归即可填充调用堆栈，但是非递归程序调用1000函数而永远不会返回的可能性很小。同样重要的是要了解，从函数返回后，调用栈将从使用的地址中释放出来（因此，名称&amp;ldquo;栈&amp;rdquo;，返回地址在进入函数之前就被压入，并在返回时被拉出）。在简单递归的特殊情况下（函数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一次又一次地调用自身），您将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反复&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;输入&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直到计算完成（直到找到宝藏）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为止，然后&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直到执行回到你打电话给&lt;/font&gt; &lt;code&gt;f&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的地方&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用栈将永远不会释放任何东西，直到最后将它从所有返回地址中释放出来为止。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fccb286979da55d6c6e125dbea7209d07f046f87" translate="yes" xml:space="preserve">
          <source>There are better, faster methods (If you've reached here, you have seen them already)</source>
          <target state="translated">还有更好、更快的方法(如果你到了这里,你已经看到了)。</target>
        </trans-unit>
        <trans-unit id="f9caba178eb8922f0394406ccdde49ee49df43a0" translate="yes" xml:space="preserve">
          <source>There is a technique that you can use to make any recursive function iterative, this technique we could call &lt;em&gt;&lt;strong&gt;bring your own notebook&lt;/strong&gt;&lt;/em&gt;. For example, in our particular case we simply are exploring a list, entering a room is equivalent to entering a sublist, the question you should ask yourself is &lt;em&gt;how can I get back from a list to its parent list?&lt;/em&gt; The answer is not that complex, repeat the following until the &lt;code&gt;stack&lt;/code&gt; is empty:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用一种技术来迭代任何递归函数，这种技术我们可以称之为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自带笔记本&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，在我们的特定情况下，我们只是在探索一个列表，进入一个房间相当于输入一个子列表，您应该问自己的问题是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我如何才能从列表返回到其父列表？&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案并不那么复杂，重复以下步骤，直到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为空：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a76c19332391eecb7270208d09b08dff1cefe111" translate="yes" xml:space="preserve">
          <source>This considers strings as &quot;simple items&quot; and therefore &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; will return &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; and not &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt;. Remark that in that case, &lt;code&gt;iter(item)&lt;/code&gt; is called twice on each item, let's pretend it's an exercise for the reader to make this cleaner.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将字符串视为&amp;ldquo;简单项目&amp;rdquo;，因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten_iter([[&quot;test&quot;, &quot;a&quot;], &quot;b])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;test&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;, &quot;a&quot;, &quot;b&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。在这种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;iter(item)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在每个项目上被调用两次，让我们假设这是读者做这个清洁器的练习。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35450707d84bb0ce84709e530c6a2b600bd4d904" translate="yes" xml:space="preserve">
          <source>This is a simple implement of flatten on python2</source>
          <target state="translated">这是python2上的一个简单的扁平化实现。</target>
        </trans-unit>
        <trans-unit id="2e4799018e16d870c6e5e1422846257d94aa57ba" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;flatten&lt;/code&gt; avoids python's recursion limit (and thus works with arbitrarily deep, nested iterables). It is a generator which can handle strings and arbitrary iterables (even infinite ones).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此版本的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;flatten&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;避免了python的递归限制（因此可与任意深度的嵌套可迭代对象一起使用）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它是一个生成器，可以处理字符串和任意可迭代（甚至无限）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2bd5654ac77b479f712d41c3a504f60b62c199d" translate="yes" xml:space="preserve">
          <source>This will flatten a list or dictionary (or list of lists or dictionaries of dictionaries etc). It assumes that the values are strings and it creates a string that concatenates each item with a separator argument. If you wanted you could use the separator to split the result into a list object afterward. It uses recursion if the next value is a list or a string. Use the key argument to tell whether you want the keys or the values (set key to false) from the dictionary object.</source>
          <target state="translated">这将使一个列表或字典(或列表或字典的列表或字典的字典等)扁平化。它假定值是字符串,并创建一个字符串,将每个项与分隔符参数连接起来。如果你想的话,你可以使用分隔符将结果分割成一个列表对象。如果下一个值是列表或字符串,它就使用递归。使用key参数来告诉你要的是字典对象中的key还是值(将key设置为false)。</target>
        </trans-unit>
        <trans-unit id="77dfd5cfcd224f3d1363dfe3cb85003efe050d9f" translate="yes" xml:space="preserve">
          <source>This works with two lists: an inner for loop and an outer while loop.</source>
          <target state="translated">这可以使用两个列表:内部的for循环和外部的while循环。</target>
        </trans-unit>
        <trans-unit id="e537559c79429148f10b6b9cf0978b9e2371bc8a" translate="yes" xml:space="preserve">
          <source>Those passes keep happening until no more nested lists are found.  When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.</source>
          <target state="translated">这些传递会不断发生,直到没有找到更多的嵌套列表。当最终没有找到任何列表的时候,keepChecking永远不会被跳转为true,这意味着listIsNested保持为false,而外部的while循环退出。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="303c2ecddc270d76490ec99651c75c05229ac735" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;itertools.chain&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;itertools.chain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="057ed5e75ff2f0ad40d7cbbc26525344260fd727" translate="yes" xml:space="preserve">
          <source>Using generator functions can make your example a little easier to read and probably boost the performance.</source>
          <target state="translated">使用生成器功能可以让你的体例更容易阅读,并且可以或许提高性能。</target>
        </trans-unit>
        <trans-unit id="2217cada8873c4496bd08dcd7534fbce6ad78f5c" translate="yes" xml:space="preserve">
          <source>When I say &lt;em&gt;most of the codes&lt;/em&gt; I mean all codes that use any form of recursion (or call a standard library function that is recursive). All these codes fail because for every of the recursive call made, the (call) stack grow by one unit, and the (default) python call stack has a size of 1000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当我说&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数代码时，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的意思是所有使用任何形式的递归（或调用递归的标准库函数）的代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有这些代码都会失败，因为对于每个递归调用，（调用）堆栈都增加一个单位，而（默认）python调用堆栈的大小为1000。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d2be4bbcc49edcd35c84a1c8296c7bc26899184" translate="yes" xml:space="preserve">
          <source>When entering the dungeon, you notice a small &lt;strong&gt;notebook&lt;/strong&gt; here. You decide to use it to write down every room you exit after solving a riddle (when entering a new room), this way you'll be able to return back to the entrance. That's a genius idea, you &lt;em&gt;won't even spend a cent&lt;/em&gt; implementing your strategy.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进入地牢时，您会&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意到一个小&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;笔记本&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您决定使用它来写下谜题后（进入新房间时）写下您退出的每个房间，这样您就可以返回到入口。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那是一个天才的主意，您&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;甚至不会花一分钱来&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实施自己的策略。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea08aaefc36c7bd0e08223e9634c0ae634211149" translate="yes" xml:space="preserve">
          <source>When trying to answer such a question you really need to give the limitations of the code you propose as a solution. If it was only about performances I wouldn't mind too much, but most of the codes proposed as solution (including the accepted answer) fail to flatten any list that has a depth greater than 1000.</source>
          <target state="translated">当你试图回答这样的问题时,你真的需要给出你提出的代码作为解决方案的局限性。如果仅仅是关于性能的问题,我不会太在意,但大多数作为解决方案的代码(包括接受的答案)都无法将任何深度大于1000的列表推平。</target>
        </trans-unit>
        <trans-unit id="1c4f6558f38981ddb59d040b4538d37b7efc2d09" translate="yes" xml:space="preserve">
          <source>Where the desired output is</source>
          <target state="translated">所需产出为</target>
        </trans-unit>
        <trans-unit id="07d07b7b8ea752db0d14deeb6cb38e985e165f11" translate="yes" xml:space="preserve">
          <source>Which gives: &lt;code&gt;build_deep_list(5)&lt;/code&gt; &amp;gt;&amp;gt;&amp;gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给出：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;build_deep_list(5)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;gt;&amp;gt;&amp;gt; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[4, [3, [2, [1, [0]]]]]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12006179f5926aac3184169403362f3f9c481acf" translate="yes" xml:space="preserve">
          <source>Without using any library:</source>
          <target state="translated">在不使用任何图书馆的情况下。</target>
        </trans-unit>
        <trans-unit id="bf88998d5c009de437a318db8effc7a1537c6a7e" translate="yes" xml:space="preserve">
          <source>Yes, I know this subject has been covered before (&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;here&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;here&lt;/a&gt;), but as far as I know, all solutions, except for one, fail on a list like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是的，我知道以前已经讨论过这个主题（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/120886&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/406121&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/457215&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/952914&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），但是据我所知，除一个解决方案外，所有解决方案在这样的列表上都失败了：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74a1b281a15fddb74b8fce9e6b33b2503f2b15ba" translate="yes" xml:space="preserve">
          <source>You could use &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt;&lt;code&gt;deepflatten&lt;/code&gt;&lt;/a&gt; from the 3rd party package &lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt;&lt;code&gt;iteration_utilities&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第3方软件包的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html&quot;&gt; &lt;code&gt;deepflatten&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://iteration-utilities.readthedocs.io/en/latest/index.html&quot;&gt; &lt;code&gt;iteration_utilities&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;_实用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;程序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3debaf3c28a15f60ba292768b82cfaf8dfacc54c" translate="yes" xml:space="preserve">
          <source>You enter the dungeon, solving with great success the first 1001 riddles, but here comes something you hadn't planed, you have no space left in the notebook you borrowed. You decide to &lt;em&gt;abandon&lt;/em&gt; your quest as you prefer not having the treasure than being lost forever inside the dungeon (that looks smart indeed).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您进入了地牢，成功地解决了前1001个难题，但是这里有您没有计划的事情，您借用的笔记本中没有剩余空间。您决定&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;放弃&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自己的任务，因为您更喜欢没有财宝，而不是在地牢中永远失去（确实看起来很聪明）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64d4175e880a1832a2a0d0bb31fd6657fe5d0d89" translate="yes" xml:space="preserve">
          <source>every time an item is found, &lt;code&gt;yield&lt;/code&gt; it (or add them in a list);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每当找到一个项目时，就&lt;/font&gt;&lt;/font&gt; &lt;code&gt;yield&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它（或将它们添加到列表中）；&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e51c354b48926dd260c73a845d3893393cf58cb" translate="yes" xml:space="preserve">
          <source>here is one simple and one not-so-simple case -</source>
          <target state="translated">这里有一个简单的案例和一个不简单的案例----</target>
        </trans-unit>
        <trans-unit id="adc6d4918f750b646571daa2e00df52c14b564db" translate="yes" xml:space="preserve">
          <source>here we are using sets to check for the type so it takes O(1) vs O(number of types) to check whether or not an element should be ignored, though of course any value with derived type of the stated ignored types will fail, this is why its using &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt; so use it with caution ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，我们使用集合来检查类型，因此需要O（1）与O（类型数）来检查是否应忽略某个元素，尽管任何具有声明的被忽略类型的派生类型的值都将失败，这就是为什么它使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;str&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;unicode&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原因&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此请谨慎使用...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccedab2b750529fb2f1b87bbe07378ea34020ea1" translate="yes" xml:space="preserve">
          <source>once a list is fully explored, go back to the parent list using the &lt;code&gt;stack&lt;/code&gt;&lt;em&gt;return &lt;code&gt;address&lt;/code&gt; (and &lt;code&gt;index&lt;/code&gt;)&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全浏览列表后，请使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回到父列表&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="296855ad54af49593cc7b3f4e5521f091bd38983" translate="yes" xml:space="preserve">
          <source>push the current list &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; in a &lt;code&gt;stack&lt;/code&gt; when entering a new sublist (note that a list address+index is also an address, therefore we just use the exact same technique used by the call stack);</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;推动当前列表中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stack&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进入一个新的子表时（请注意，列表地址+指数也是一个地址，所以我们只使用由调用堆栈使用完全相同的技术）;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="37a5301a88da334dc5afc5b63979daa0f3f45e68" translate="yes" xml:space="preserve">
          <source>result</source>
          <target state="translated">result</target>
        </trans-unit>
        <trans-unit id="37b8dabf0b7bfae1c2eecb47a6afcd8bc92cc94c" translate="yes" xml:space="preserve">
          <source>returns:</source>
          <target state="translated">returns:</target>
        </trans-unit>
        <trans-unit id="9dd608f36d0db13a98f4add5e42d48a50fa3c769" translate="yes" xml:space="preserve">
          <source>tests:</source>
          <target state="translated">tests:</target>
        </trans-unit>
        <trans-unit id="90b34293d40fd211f22a7eb82950647a7a0d5b3f" translate="yes" xml:space="preserve">
          <source>there is a slightly faster approach, but less portable method, only use it if you can assume that the base elements of the input can be explicitly determined otherwise, you'll get an infinite recursion, and OS X with its limited stack size, will throw a segmentation fault fairly quickly ...</source>
          <target state="translated">有一个稍微快一点的方法,但不太便携,只有当你可以假设输入的基本元素可以被显式确定时,才会使用它,否则,你会得到一个无限递归,而OS X的堆栈大小有限,会很快抛出一个分段故障.....</target>
        </trans-unit>
        <trans-unit id="e33ad899228cb347b7c6fd1b4662e7475fffbffc" translate="yes" xml:space="preserve">
          <source>totally hacky but I think it would work (depending on your data_type)</source>
          <target state="translated">完全是黑客,但我想这是可行的(取决于你的data_type)。</target>
        </trans-unit>
        <trans-unit id="341f78d1b5a5471d159f158c1f163fc170e38478" translate="yes" xml:space="preserve">
          <source>yields:</source>
          <target state="translated">yields:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
