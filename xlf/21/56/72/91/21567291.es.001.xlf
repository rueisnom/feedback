<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/21567291">
    <body>
      <group id="21567291">
        <trans-unit id="ec7c214a1fdc8780b60bcb590f4198cc7cd9b775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What's the difference?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Cual es la diferencia?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd943620ecdfe6d8c4a83ff65c22201fa31d31a9" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1: &lt;code&gt;std::skipws&lt;/code&gt; is manipulator that tells the input stream to discard leading whitespace when performing formatted input. This can be turned off with the &lt;code&gt;std::noskipws&lt;/code&gt; manipulator.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::skipws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un manipulador que le dice a la secuencia de entrada que descarte los espacios en blanco al realizar la entrada formateada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se puede desactivar con el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;manipulador &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::noskipws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="b985457f75403e475b47db94270c83136e39c4ee" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;2: Input streams deem certain characters as whitespace by default, such the space character, newline character, form feed, carriage return, etc.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2: Las secuencias de entrada consideran ciertos caracteres como espacios en blanco de forma predeterminada, como el car&amp;aacute;cter de espacio, el car&amp;aacute;cter de nueva l&amp;iacute;nea, el avance de formulario, el retorno de carro, etc.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="54861e0dd6e7e7340d75914d2f06224b2a47e8e4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;3: This is the signature of &lt;code&gt;std::basic_istream&amp;lt;...&amp;gt;::ignore()&lt;/code&gt;. You can call it with zero arguments to discard a single character from the stream, one argument to discard a certain amount of characters, or two arguments to discard &lt;code&gt;count&lt;/code&gt; characters or until it reaches &lt;code&gt;delim&lt;/code&gt;, whichever one comes first. You normally use &lt;code&gt;std::numeric_limits&amp;lt;std::streamsize&amp;gt;::max()&lt;/code&gt; as the value of &lt;code&gt;count&lt;/code&gt; if you don't know how many characters there are before the delimiter, but you want to discard them anyway.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3: Esta es la firma de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::basic_istream&amp;lt;...&amp;gt;::ignore()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Puede llamarlo con cero argumentos para descartar un solo car&amp;aacute;cter de la secuencia, un argumento para descartar una cierta cantidad de caracteres, o dos argumentos para descartar el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;count&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; caracteres o hasta que llegue a la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;delim&lt;/code&gt; itaci&amp;oacute;n&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , lo que ocurra primero. Normalmente usa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::numeric_limits&amp;lt;std::streamsize&amp;gt;::max()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como valor de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;count&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; si no sabe cu&amp;aacute;ntos caracteres hay antes del delimitador, pero desea descartarlos de todos modos.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="88f90b25366407b37d1a00c8dcc4e4e535f6dc18" translate="yes" xml:space="preserve">
          <source>A newline is always appended to your input when you select</source>
          <target state="translated">Siempre se añade una nueva línea a la entrada cuando se selecciona</target>
        </trans-unit>
        <trans-unit id="3ba0e9b83fcbdba251f0dc44b8e0d3fa71cec891" translate="yes" xml:space="preserve">
          <source>Another overload of this function takes a delimiter of type &lt;code&gt;charT&lt;/code&gt;. A delimiter character is a character that represents the boundary between sequences of input. This particular overload sets the delimiter to the newline character &lt;code&gt;input.widen('\n')&lt;/code&gt; by default since one was not supplied.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otra sobrecarga de esta funci&amp;oacute;n toma un delimitador de tipo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;charT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un car&amp;aacute;cter delimitador es un car&amp;aacute;cter que representa el l&amp;iacute;mite entre las secuencias de entrada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta sobrecarga particular establece el delimitador en el car&amp;aacute;cter de nueva l&amp;iacute;nea &lt;/font&gt;&lt;/font&gt; &lt;code&gt;input.widen('\n')&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de forma predeterminada ya que no se proporcion&amp;oacute; uno.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="052521750e9a3c56e9fde37e02efbbf787c20b0c" translate="yes" xml:space="preserve">
          <source>Another way to discard the whitespace is to use the &lt;code&gt;std::ws&lt;/code&gt; function which is a manipulator designed to extract and discard leading whitespace from the beginning of an input stream:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otra forma de descartar el espacio en blanco es usar la funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::ws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que es un manipulador dise&amp;ntilde;ado para extraer y descartar el espacio en blanco inicial desde el comienzo de una secuencia de entrada:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebd400daeaa87b9872c1451d8dc28b406e3f2dd3" translate="yes" xml:space="preserve">
          <source>Because this leading newline inhibits the expected functionality of your program, it follows that it must be skipped our ignored somehow. One option is to call &lt;code&gt;std::cin.ignore()&lt;/code&gt; after the the first extraction. It will discard the next available character so that the newline is no longer in the way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debido a que esta nueva l&amp;iacute;nea l&amp;iacute;der inhibe la funcionalidad esperada de su programa, se deduce que se debe omitir nuestro ignorado de alguna manera. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una opci&amp;oacute;n es llamar a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::cin.ignore()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; despu&amp;eacute;s de la primera extracci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Descartar&amp;aacute; el siguiente personaje disponible para que la nueva l&amp;iacute;nea ya no est&amp;eacute; en el camino.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="a51d561ae289fee633489fe4e190348071c52ee1" translate="yes" xml:space="preserve">
          <source>Everything will be OK if you change your initial code in the following way:</source>
          <target state="translated">Todo estará bien si cambias tu código inicial de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="2849cb13a335fb59ef4ed494dc8432c9a3a24fa2" translate="yes" xml:space="preserve">
          <source>I have the following piece of code that prompts the user for their name and state:</source>
          <target state="translated">Tengo el siguiente código que le pide al usuario su nombre y estado:</target>
        </trans-unit>
        <trans-unit id="617bd29fce2e70b33c9e8d355f4bc533284670e9" translate="yes" xml:space="preserve">
          <source>If the delimiter has been found</source>
          <target state="translated">Si se ha encontrado el delimitador</target>
        </trans-unit>
        <trans-unit id="1305802d6e249da94f4f7a07e0bea5b8321d5036" translate="yes" xml:space="preserve">
          <source>If the end-of-file (EOF) character has been found</source>
          <target state="translated">Si se ha encontrado el carácter de fin de archivo (EOF)</target>
        </trans-unit>
        <trans-unit id="306ba67ef99ba715c1d94551412622dd4f53a4ec" translate="yes" xml:space="preserve">
          <source>If the stream has extracted the maximum amount of characters a &lt;code&gt;std::basic_string&amp;lt;charT&amp;gt;&lt;/code&gt; can hold</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si la secuencia ha extra&amp;iacute;do la cantidad m&amp;aacute;xima de caracteres que &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;puede contener &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::basic_string&amp;lt;charT&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ba38a94a4a02a8ac31ed6e31b42019bc855bb4a" translate="yes" xml:space="preserve">
          <source>If you are mixing formatted input with unformatted input and you need to discard residual whitespace, use &lt;code&gt;std::ws&lt;/code&gt;. Otherwise, if you need to clear out invalid input regardless of what it is, use &lt;code&gt;ignore()&lt;/code&gt;. In our example, we only need to clear whitespace since the stream consumed your input of &lt;code&gt;&quot;John&quot;&lt;/code&gt; for the &lt;code&gt;name&lt;/code&gt; variable. All that was left was the newline character.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si est&amp;aacute; mezclando entradas formateadas con entradas no formateadas y necesita descartar espacios en blanco residuales, use &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::ws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De lo contrario, si necesita borrar la entrada no v&amp;aacute;lida independientemente de lo que sea, use &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ignore()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En nuestro ejemplo, solo necesitamos borrar espacios en blanco ya que la secuencia consumi&amp;oacute; su entrada de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;John&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;variable de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Todo lo que quedaba era el personaje de nueva l&amp;iacute;nea.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84a322941debc5bf79050fd668f579d2e95fc9c4" translate="yes" xml:space="preserve">
          <source>In-Depth Explanation:</source>
          <target state="translated">Explicación detallada:</target>
        </trans-unit>
        <trans-unit id="7f321a5d5b1b57e654ad8e7d23fbb0e6633caed5" translate="yes" xml:space="preserve">
          <source>Now, these are a few of the conditions whereby &lt;code&gt;std::getline()&lt;/code&gt; terminates input:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, estas son algunas de las condiciones por las cuales &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; termina la entrada:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24f096b221f9534bcad007f2b5a32b490950b5b5" translate="yes" xml:space="preserve">
          <source>Return</source>
          <target state="translated">Return</target>
        </trans-unit>
        <trans-unit id="9784d91c3b7fceefefbe649b337cd37547c26834" translate="yes" xml:space="preserve">
          <source>Since the above condition is false, the sentry object will not discard the whitespace. The reason &lt;code&gt;noskipws&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; by this function is because the point of &lt;code&gt;std::getline()&lt;/code&gt; is to read raw, unformatted characters into a &lt;code&gt;std::basic_string&amp;lt;charT&amp;gt;&lt;/code&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como la condici&amp;oacute;n anterior es falsa, el objeto centinela no descartar&amp;aacute; el espacio en blanco. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La raz&amp;oacute;n por la cual &lt;/font&gt;&lt;/font&gt; &lt;code&gt;noskipws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se establece en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;true&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; por esta funci&amp;oacute;n es porque el objetivo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es leer caracteres sin formato y sin formato en un objeto &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::basic_string&amp;lt;charT&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7b2c45bc9b8a5268549eb87988ee9abf386351d8" translate="yes" xml:space="preserve">
          <source>The Solution:</source>
          <target state="translated">La solución:</target>
        </trans-unit>
        <trans-unit id="69c8c8d928a345d55b90e7a352d075898f33e91b" translate="yes" xml:space="preserve">
          <source>The above is a sentry object which is instantiated in all formatted/unformatted I/O functions in a standard C++ implementation. Sentry objects are used for preparing the stream for I/O and determining whether or not it is in a fail state. You'll only find that in the &lt;em&gt;unformatted&lt;/em&gt; input functions, the second argument to the sentry constructor is &lt;code&gt;true&lt;/code&gt;. That argument means that leading whitespace will &lt;em&gt;not&lt;/em&gt; be discarded from the beginning of the input sequence. Here is the relevant quote from the Standard [&amp;sect;27.7.2.1.3/2]:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo anterior es un objeto centinela que se instancia en todas las funciones de E / S formateadas / sin formato en una implementaci&amp;oacute;n est&amp;aacute;ndar de C ++. Los objetos centinela se usan para preparar la secuencia para E / S y determinar si est&amp;aacute; o no en estado de falla. Solo encontrar&amp;aacute; que en las &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funciones de entrada &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sin formato&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el segundo argumento para el constructor centinela es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;true&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Ese argumento significa que los espacios en blanco &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;iniciales &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se descartar&amp;aacute;n desde el comienzo de la secuencia de entrada. Aqu&amp;iacute; est&amp;aacute; la cita relevante de la Norma [&amp;sect;27.7.2.1.3 / 2]:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be721a2e400755675c47f55aefe8d028d7a02def" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;ignore(std::streamsize count = 1, int_type delim = Traits::eof())&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt; indiscriminately discards characters until it either discards &lt;code&gt;count&lt;/code&gt; characters, finds the delimiter (specified by the second argument &lt;code&gt;delim&lt;/code&gt;) or hits the end of the stream. &lt;code&gt;std::ws&lt;/code&gt; is only used for discarding whitespace characters from the beginning of the stream.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La diferencia es que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ignore(std::streamsize count = 1, int_type delim = Traits::eof())&lt;/code&gt; &lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; descarta indiscriminadamente los caracteres hasta que descarta el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;count&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; caracteres, encuentra el delimitador (especificado por el segundo argumento &lt;/font&gt;&lt;/font&gt; &lt;code&gt;delim&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) o llega al final de la corriente. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::ws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; solo se usa para descartar caracteres de espacio en blanco desde el comienzo de la secuencia.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="beb3607e8d8a4eda931f55fb5f54ea024fd0e1a5" translate="yes" xml:space="preserve">
          <source>The third condition is the one we're dealing with. Your input into &lt;code&gt;state&lt;/code&gt; is represented thusly:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La tercera condici&amp;oacute;n es con la que estamos lidiando. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Su entrada en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;state&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se representa as&amp;iacute;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be5b756cffe7eb6f28666a60b997bad4e4f0ff19" translate="yes" xml:space="preserve">
          <source>There's no way to stop this behavior of &lt;code&gt;std::getline()&lt;/code&gt;. What you'll have to do is discard the new line yourself before &lt;code&gt;std::getline()&lt;/code&gt; runs (but do it &lt;em&gt;after&lt;/em&gt; the formatted extraction). This can be done by using &lt;code&gt;ignore()&lt;/code&gt; to discard the rest of the input until we reach a fresh new line:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No hay forma de detener este comportamiento de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Lo que tendr&amp;aacute; que hacer es descartar la nueva l&amp;iacute;nea usted mismo antes de que se &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ejecute &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (pero h&amp;aacute;galo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;despu&amp;eacute;s de&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; la extracci&amp;oacute;n formateada). Esto se puede hacer usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ignore()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para descartar el resto de la entrada hasta llegar a una nueva l&amp;iacute;nea nueva:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de39c9c8eccb3d48cd77f434ca497754395456e5" translate="yes" xml:space="preserve">
          <source>This happens because an implicit line feed also known as newline character &lt;code&gt;\n&lt;/code&gt; is appended to all user input from a terminal as it's telling the stream to start a new line. You can safely account for this by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/getline&quot;&gt;&lt;code&gt;std::getline&lt;/code&gt;&lt;/a&gt; when checking for multiple lines of user input. The default behavior of &lt;code&gt;std::getline&lt;/code&gt; will read everything up to and including the newline character &lt;code&gt;\n&lt;/code&gt; from the input stream object which is &lt;code&gt;std::cin&lt;/code&gt; in this case.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto sucede porque un avance de l&amp;iacute;nea impl&amp;iacute;cito tambi&amp;eacute;n conocido como car&amp;aacute;cter de nueva l&amp;iacute;nea &lt;/font&gt;&lt;/font&gt; &lt;code&gt;\n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se agrega a todas las entradas del usuario desde un terminal, ya que le indica a la secuencia que comience una nueva l&amp;iacute;nea. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede dar cuenta de esto de manera segura utilizando &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/getline&quot;&gt; &lt;code&gt;std::getline&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando verifica m&amp;uacute;ltiples l&amp;iacute;neas de entrada del usuario. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El comportamiento predeterminado de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; leer&amp;aacute; todo, incluido el car&amp;aacute;cter de nueva l&amp;iacute;nea &lt;/font&gt;&lt;/font&gt; &lt;code&gt;\n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; del objeto de flujo de entrada que es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en este caso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c2f0e692274b5741fba942bfcca92c9d72b216ab" translate="yes" xml:space="preserve">
          <source>This has little to do with the input you provided yourself but rather with the default behavior &lt;code&gt;std::getline()&lt;/code&gt; exhibits. When you provided your input for the name (&lt;code&gt;std::cin &amp;gt;&amp;gt; name&lt;/code&gt;), you not only submitted the following characters, but also an implicit newline was appended to the stream:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto tiene poco que ver con la entrada que proporcion&amp;oacute; usted mismo, sino con el comportamiento predeterminado que &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;exhibe &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Cuando proporcion&amp;oacute; su entrada para el nombre ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::cin &amp;gt;&amp;gt; name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), no solo envi&amp;oacute; los siguientes caracteres, sino que tambi&amp;eacute;n se agreg&amp;oacute; una nueva l&amp;iacute;nea impl&amp;iacute;cita a la secuencia:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aead94030654d0d4376565f7c7d2c09982ef7a93" translate="yes" xml:space="preserve">
          <source>This is the overload of &lt;code&gt;std::getline()&lt;/code&gt; that you called:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta es la sobrecarga de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que llam&amp;oacute;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2885605d4d66577c4326b3736993f9e0d974cf56" translate="yes" xml:space="preserve">
          <source>Unlike the formatted input operators, &lt;code&gt;std::getline()&lt;/code&gt; is an &lt;em&gt;unformatted&lt;/em&gt; input function. And all unformatted input functions have the following code somewhat in common:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A diferencia de los operadores de entrada formateados, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n de entrada &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sin formato&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y todas las funciones de entrada sin formato tienen el siguiente c&amp;oacute;digo algo en com&amp;uacute;n:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7652cb2c60ebc2c8990bfa640aaa291d02b1e548" translate="yes" xml:space="preserve">
          <source>What I find is that the name has been successfully extracted, but not the state. Here is the input and resulting output:</source>
          <target state="translated">Lo que encuentro es que el nombre ha sido extraído con éxito,pero no el estado.Aquí está la entrada y la salida resultante:</target>
        </trans-unit>
        <trans-unit id="f484fecbd5602cfbd1cd7e1256c7746ee1c70397" translate="yes" xml:space="preserve">
          <source>Why does std::getline() skip input after a formatted extraction</source>
          <target state="translated">¿Por qué std::getline()salta la entrada después de una extracción formateada</target>
        </trans-unit>
        <trans-unit id="9a5b63c2c27331b350ca1f1ac9bc40e93e0def5f" translate="yes" xml:space="preserve">
          <source>Why does this happen?</source>
          <target state="translated">¿Por qué sucede esto?</target>
        </trans-unit>
        <trans-unit id="48807d13b9d5be24aaf6ca75c32641493050f84e" translate="yes" xml:space="preserve">
          <source>Why has the name of the state been omitted from the output? I've given the proper input, but the code somehow ignores it. Why does this happen?</source>
          <target state="translated">¿Por qué se ha omitido el nombre del estado en la salida? He dado la entrada adecuada,pero el código de alguna manera lo ignora.¿Por qué sucede esto?</target>
        </trans-unit>
        <trans-unit id="c633f6012ce2a23b10616accc184e616c83199a2" translate="yes" xml:space="preserve">
          <source>You may have noticed that you don't typically run into this problem when extracting with the formatted input operator (&lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt;). This is because input streams use whitespace as delimiters for input and have the &lt;code&gt;std::skipws&lt;/code&gt;&lt;sup&gt;1&lt;/sup&gt; manipulator set on by default. Streams will discard the leading whitespace from the stream when beginning to perform formatted input.&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es posible que haya notado que normalmente no se encuentra con este problema al extraer con el operador de entrada formateado ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;operator&amp;gt;&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se debe a que las secuencias de entrada utilizan espacios en blanco como delimitadores para la entrada y tienen el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;manipulador &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::skipws&lt;/code&gt; &lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; activado de forma predeterminada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las secuencias descartar&amp;aacute;n el espacio en blanco inicial de la secuencia cuando comience a realizar una entrada formateada. &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1b877967a4435b6ab378c6d234c358ea451509a3" translate="yes" xml:space="preserve">
          <source>You'll need to include &lt;code&gt;&amp;lt;limits&amp;gt;&lt;/code&gt; to use &lt;code&gt;std::numeric_limits&lt;/code&gt;. &lt;code&gt;std::basic_istream&amp;lt;...&amp;gt;::ignore()&lt;/code&gt; is a function that discards a specified amount of characters until it either finds a delimiter or reaches the end of the stream (&lt;code&gt;ignore()&lt;/code&gt; also discards the delimiter if it finds it). The &lt;code&gt;max()&lt;/code&gt; function returns the largest amount of characters that a stream can accept.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Deber&amp;aacute; incluir &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;limits&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::numeric_limits&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::basic_istream&amp;lt;...&amp;gt;::ignore()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es una funci&amp;oacute;n que descarta una cantidad espec&amp;iacute;fica de caracteres hasta que encuentra un delimitador o llega al final de la secuencia ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ignore()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n descarta el delimitador si lo encuentra) . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;max()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; devuelve la mayor cantidad de caracteres que una secuencia puede aceptar.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3852f688831d420a220fab41247f52313cf624d3" translate="yes" xml:space="preserve">
          <source>[...] If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards each character as long as the next available input character &lt;code&gt;c&lt;/code&gt; is a whitespace character. [...]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[...] Si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;noskipws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es cero y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no es cero, la funci&amp;oacute;n extrae y descarta cada car&amp;aacute;cter siempre que el siguiente car&amp;aacute;cter de entrada disponible &lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sea ​​un espacio en blanco. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[...]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f53a910c78329f1a95fd48bc21f823b8b460ee47" translate="yes" xml:space="preserve">
          <source>when submitting from a terminal. It is also used in files for moving toward the next line. The newline is left in the buffer after the extraction into &lt;code&gt;name&lt;/code&gt; until the next I/O operation where it is either discarded or consumed. When the flow of control reaches &lt;code&gt;std::getline()&lt;/code&gt;, the newline will be discarded, but the input will cease immediately. The reason this happens is because the default functionality of this function dictates that it should (it attempts to read a line and stops when it finds a newline).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cuando se env&amp;iacute;a desde una terminal. Tambi&amp;eacute;n se usa en archivos para moverse hacia la siguiente l&amp;iacute;nea. La nueva l&amp;iacute;nea se deja en el b&amp;uacute;fer despu&amp;eacute;s de la extracci&amp;oacute;n en el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hasta la pr&amp;oacute;xima operaci&amp;oacute;n de E / S donde se descarta o se consume. Cuando el flujo de control alcanza &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , la nueva l&amp;iacute;nea se descartar&amp;aacute;, pero la entrada cesar&amp;aacute; de inmediato. La raz&amp;oacute;n por la que esto sucede es porque la funcionalidad predeterminada de esta funci&amp;oacute;n dicta que deber&amp;iacute;a (intenta leer una l&amp;iacute;nea y se detiene cuando encuentra una nueva l&amp;iacute;nea).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71669d4354037a18ace2fdfc8f29b7515fffc4e7" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;next_pointer&lt;/code&gt; is the next character to be parsed. Since the character stored at the next position in the input sequence is the delimiter, &lt;code&gt;std::getline()&lt;/code&gt; will quietly discard that character, increment &lt;code&gt;next_pointer&lt;/code&gt; to the next available character, and stop input. This means that the rest of the characters that you have provided still remain in the buffer for the next I/O operation. You'll notice that if you perform another read from the line into &lt;code&gt;state&lt;/code&gt;, your extraction will yield the correct result as the last call to &lt;code&gt;std::getline()&lt;/code&gt; discarded the delimiter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;donde &lt;/font&gt;&lt;/font&gt; &lt;code&gt;next_pointer&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es el siguiente car&amp;aacute;cter a analizar. Como el car&amp;aacute;cter almacenado en la siguiente posici&amp;oacute;n en la secuencia de entrada es el delimitador, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; descartar&amp;aacute; silenciosamente ese car&amp;aacute;cter, incrementar&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;next_pointer&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; al siguiente car&amp;aacute;cter disponible y detendr&amp;aacute; la entrada. Esto significa que el resto de los caracteres que ha proporcionado a&amp;uacute;n permanecen en el b&amp;uacute;fer para la pr&amp;oacute;xima operaci&amp;oacute;n de E / S. Notar&amp;aacute; que si realiza otra lectura desde la l&amp;iacute;nea al &lt;/font&gt;&lt;/font&gt; &lt;code&gt;state&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , su extracci&amp;oacute;n arrojar&amp;aacute; el resultado correcto ya que la &amp;uacute;ltima llamada a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::getline()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; descart&amp;oacute; el delimitador.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
