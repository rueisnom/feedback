<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/215497">
    <body>
      <group id="215497">
        <trans-unit id="9c3a7eb169356df9222bd586b22d0df4e9a13f8c" translate="yes" xml:space="preserve">
          <source>(Caveat:  I am not a Java programmer, I am a Perl programmer.  Perl has no formal protections which is perhaps why I understand the problem so well :) )</source>
          <target state="translated">(주의 사항 : 저는 Java 프로그래머가 아니며 Perl 프로그래머입니다. Perl에는 공식적인 보호 기능이 없으므로 문제를 잘 이해하고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0a36612cffe057499a0611c73fed1aa932c69c44" translate="yes" xml:space="preserve">
          <source>....
Protected: Protected access modifier is the a little tricky and you can say is a superset of the default access modifier. Protected members are same as the default members as far as the access in the same package is concerned. The difference is that, the protected members are also accessible to the subclasses of the class in which the member is declared which are outside the package in which the parent class is present.</source>
          <target state="translated">.... 보호 : 보호 액세스 수정자는 약간 까다 롭고 기본 액세스 수정 자의 수퍼 세트라고 말할 수 있습니다. 보호 된 구성원은 동일한 패키지의 액세스에 관한 한 기본 구성원과 동일합니다. 차이점은 보호 된 멤버는 부모 클래스가있는 패키지 외부에있는 멤버가 선언 된 클래스의 서브 클래스에도 액세스 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bb129938f682e401003e1aed2ed4b40494353513" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;The official tutorial&lt;/a&gt; may be of some use to you.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;공식 튜토리얼&lt;/a&gt; 이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40d787e477845abe3af3bd4319e70db8b848c65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&lt;/a&gt;&lt;a href=&quot;http://www.tutorialspoint.com/java/java_access_modifiers.htm&quot;&gt;http://www.tutorialspoint.com/java/java_access_modifiers.htm&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&lt;/a&gt;&lt;a href=&quot;http://www.tutorialspoint.com/java/java_access_modifiers.htm&quot;&gt;http://www.tutorialspoint.com/java/java_access_modifiers.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c31ee98b0e56e1e2ad44c152f3835eb79ef6b74d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/676930/private-member-access-java&quot;&gt;A class's methods &lt;em&gt;are&lt;/em&gt; allowed to access private members of other objects of the same class.&lt;/a&gt; More precisely, a method of class C can access private members of C on objects of any subclass of C. Java doesn't support restricting access by instance, only by class. (Compare with Scala, which does support it using &lt;code&gt;private[this]&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/676930/private-member-access-java&quot;&gt;클래스의 메소드 &lt;em&gt;는&lt;/em&gt; 같은 클래스의 다른 객체의 비공개 멤버에 액세스 할 수 있습니다.&lt;/a&gt; 보다 정확하게는 클래스 C의 메소드는 C의 모든 서브 클래스의 오브젝트에서 C의 개인 멤버에 액세스 할 수 있습니다. Java는 인스턴스에 의한 액세스 제한을 지원하지 않습니다. ( &lt;code&gt;private[this]&lt;/code&gt; 사용하여 지원하는 Scala와 비교하십시오.)</target>
        </trans-unit>
        <trans-unit id="8f7f1dc8bc472b94392e3bd3ed6215989161afa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; (or &lt;code&gt;package-private&lt;/code&gt;): package scope.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; (또는 &lt;code&gt;package-private&lt;/code&gt; ) : 패키지 범위.</target>
        </trans-unit>
        <trans-unit id="3d298ea01eb1875fcce90ecc58ed559377bd324e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; --&amp;gt; No access modifier keyword is present. This means it is available strictly within the package of the class. &lt;strong&gt;Nowhere&lt;/strong&gt; outside that package it can be accessed.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; - &amp;gt; 액세스 수정 자 키워드가 없습니다. 이것은 클래스 패키지 내에서 엄격하게 사용할 수 있음을 의미합니다. 해당 패키지 외부에서는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="632f0c7f906968661339fb461c45f7088fc72706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; is not apply to package hierarchy</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 는 패키지 계층에 적용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="ad079c92642a022565d1ecd33455b4303c1a0f85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; --&amp;gt; accessible only within the same class where it is declared</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; - &amp;gt; 선언 된 동일한 클래스 내에서만 액세스 가능</target>
        </trans-unit>
        <trans-unit id="9f1519bd1834a636bcfd85562fc722c65063bd03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: accessible within the same class only.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; : 같은 클래스 내에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="463f7217c25ecb5d72756d802aad36eb4f6fe8b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: class scope.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; : 클래스 범위.</target>
        </trans-unit>
        <trans-unit id="af2e4fa6e526002b3cd89f765ab0e780189d733b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; --&amp;gt; Slightly less stricter than &lt;code&gt;default&lt;/code&gt; and apart from the same package classes it can be accessed by sub classes outside the &lt;em&gt;package&lt;/em&gt; it is declared.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; - &amp;gt; &lt;code&gt;default&lt;/code&gt; 보다 약간 덜 엄격하며 선언 된 &lt;em&gt;패키지&lt;/em&gt; 외부의 하위 클래스에서 액세스 할 수있는 동일한 패키지 클래스와는 별개입니다.</target>
        </trans-unit>
        <trans-unit id="c5a581c238cfb204babe7a22d7bc46e3fa3256dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: &lt;code&gt;package scope + child&lt;/code&gt; (like package, but we can subclass it from different packages). The protected modifier always keeps the &quot;parent-child&quot; relationship.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; : &lt;code&gt;package scope + child&lt;/code&gt; (패키지와 같지만 다른 패키지에서 서브 클래 싱 할 수 있음) 보호 된 수정자는 항상 &quot;부모-자식&quot;관계를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="910fdd220b274308d3d2344d80bf0070904f5aa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: accessible by the classes of the same package and the subclasses residing in any package.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; : 동일한 패키지의 클래스와 모든 패키지에있는 서브 클래스가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050d466202fbb4d01a4953aeadb3468653e9d848" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; --&amp;gt; accessible from every where</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; -&amp;gt; 모든 곳에서 액세스 가능</target>
        </trans-unit>
        <trans-unit id="0a072f8abd92b9840a119d8fd2cb36807b61f4b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;: accessible from everywhere.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; : 어디서나 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e5f72177dfd12fd5219a4e1db9d66c86b32aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;: everywhere.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; : 어디에나.</target>
        </trans-unit>
        <trans-unit id="cd953930c2c863ea399304a3c30036133536f2ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A class, method, constructor, interface etc declared public can be accessed from any other class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;public으로 선언 된 클래스, 메소드, 생성자, 인터페이스 등은 다른 클래스에서 액세스 할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be09917e70f565d8c708abe4cd6e61635b34eda0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A variable or method declared without any access control modifier is available to any other class in the same package. The fields in an interface are implicitly public static final and the methods in an interface are by default public.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;액세스 제어 수정 자없이 선언 된 변수 또는 메소드는 동일한 패키지의 다른 클래스에서 사용할 수 있습니다.&lt;/em&gt; &lt;em&gt;인터페이스의 필드는 암시 적으로 public static final이며 인터페이스의 메소드는 기본적으로 public입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee011cda99cb49527b83f0a5b8919102a1698c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;클래스 상속으로 인해 클래스의 모든 공용 메소드 및 변수는 서브 클래스에 의해 상속됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad348a2083c2d62016b21c1d255f3de23fa10b04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class and Interface&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;클래스와 인터페이스&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eaf0f2821bca046e8de9d5d37c914cacefc406cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Default access modifier means we do not explicitly declare an access modifier for a class, field, method, etc.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;기본 액세스 수정자는 클래스, 필드, 메소드 등에 대한 액세스 수정자를 명시 적으로 선언하지 않음을 의미합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb32cde4a8fce643003f72d2e1ba00918148a8da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Different Packages&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;다른 패키지&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d207fca631fc5ab4283a1e1cfa2b49aaaa7a4fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However if the public class we are trying to access is in a different package, then the public class still need to be imported.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;그러나 우리가 액세스하려는 공개 클래스가 다른 패키지에 있으면 공개 클래스를 계속 가져와야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed9665876783be76d2d202971e92d2ede6dcd26f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods, Variables and Constructors that are declared private can only be accessed within the declared class itself.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;private으로 선언 된 메소드, 변수 및 생성자는 선언 된 클래스 자체 내에서만 액세스 할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c601c4a206533aa7d299807e34c12f78d76e7236" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;메소드, 필드는 보호 된 것으로 선언 될 수 있지만 인터페이스의 메소드 및 필드는 보호 된 것으로 선언 될 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="607c9d99976709c606c4f88193f8de1144d0b2fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Private access modifier is the most restrictive access level. Class and interfaces cannot be private.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;개인 액세스 수정자는 가장 제한적인 액세스 수준입니다.&lt;/em&gt; &lt;em&gt;클래스 및 인터페이스는 개인용이 될 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9080a57bc2a9fbd0bde174c2cd9cfb1cc3d4e8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;보호 된 액세스는 서브 클래스가 헬퍼 메소드 또는 변수를 사용할 수있는 기회를 제공하면서 관련이없는 클래스가이를 사용하지 못하게합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e00422beb6d4fb1981562f55a7072acc71253369" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The protected access modifier cannot be applied to class and interfaces.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;보호 된 액세스 수정자는 클래스 및 인터페이스에 적용 할 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9e9bd71728a515b974c723b972dd81ff4a911f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Therefore fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java Universe.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;따라서 공개 클래스 내에 선언 된 필드, 메서드 및 블록은 Java Universe에 속하는 모든 클래스에서 액세스 할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65b8ac6a51801d8f9df0125860bf27145bcd2152" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Variables that are declared private can be accessed outside the class if public getter methods are present in the class.
Variables, methods and constructors which are declared protected in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;public getter 메소드가 클래스에있는 경우 private으로 선언 된 변수는 클래스 외부에서 액세스 할 수 있습니다.&lt;/em&gt; &lt;em&gt;수퍼 클래스에서 보호 된 것으로 선언 된 변수, 메소드 및 생성자는 다른 패키지의 서브 클래스 또는 보호 된 멤버의 클래스 패키지 내의 클래스에 의해서만 액세스 할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dfafa3f02ac99007413a76b7fa0132f54e95264" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Within the same Packages&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;동일한 패키지 내&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c98ea408dc0e335456b8bc359e5f6e6688da4fb9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class can be package-private. It can only be accessible from same package. Not from sub package, not from outside package.</source>
          <target state="translated">&lt;em&gt;class-&amp;gt;&lt;/em&gt; 최상위 클래스는 패키지 전용이 될 수 있습니다. 동일한 패키지에서만 액세스 할 수 있습니다. 하위 패키지가 아닌 외부 패키지가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9a2f5c5e06678e57a12196a656cbc25665cdfb9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class cannot be private. inner classes can be private which are accessible from same class.</source>
          <target state="translated">&lt;em&gt;class-&amp;gt;&lt;/em&gt; 최상위 클래스는 비공개 일 수 없습니다. 내부 클래스는 개인이 될 수 있으며 동일한 클래스에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49557558779971098b1beab7b3aca3d6045daa29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class cannot be protected.</source>
          <target state="translated">&lt;em&gt;class-&amp;gt;&lt;/em&gt; 최상위 클래스는 보호 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d03616909ff20fb6283b735f101a6bbb643bb3eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; accessible from package/subpackage/another package</source>
          <target state="translated">&lt;em&gt;클래스-&amp;gt;&lt;/em&gt; 패키지 / 서브 패키지 / 다른 패키지에서 액세스 가능</target>
        </trans-unit>
        <trans-unit id="c9e263282cf692bb34eb4b225c833709b4cf7edc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; Only accessible in same package or subpackage. Can only be access outside the package while extending class.</source>
          <target state="translated">&lt;em&gt;인스턴스 변수-&amp;gt;&lt;/em&gt; 동일한 패키지 또는 하위 패키지에서만 액세스 할 수 있습니다. 클래스를 확장하는 동안 패키지 외부에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96c7893be4597454db4583a10a583947d4674561" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible from package/subpackage/another package</source>
          <target state="translated">&lt;em&gt;인스턴스 변수-&amp;gt;&lt;/em&gt; 패키지 / 서브 패키지 / 다른 패키지에서 액세스 가능</target>
        </trans-unit>
        <trans-unit id="026e2611c853bf535859a5b5903a3be7acf05507" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible from same package. Not from sub package, not from outside package.</source>
          <target state="translated">&lt;em&gt;인스턴스 변수-&amp;gt;&lt;/em&gt; 동일한 패키지에서 액세스 가능 하위 패키지가 아닌 외부 패키지가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="173b1d875a31dfc5921965ffcf90d681aa11e6a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible only in the class. Cannot access outside the class.</source>
          <target state="translated">&lt;em&gt;인스턴스 변수-&amp;gt;&lt;/em&gt; 클래스에서만 액세스 가능 수업 외부에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f686cfad1f0d2953f73e22512646f451cc92170" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(D)irect&lt;/strong&gt; (invoke from a method inside the same class, or via &quot;this&quot; syntax).</source>
          <target state="translated">&lt;strong&gt;(D) 고침&lt;/strong&gt; (동일한 클래스 내의 메소드 또는 &quot;this&quot;구문을 통해 호출)</target>
        </trans-unit>
        <trans-unit id="2f0ba70dae68262e43e56b87dcf8848fd89d6328" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(I)nheritance&lt;/strong&gt; (via subclassing).</source>
          <target state="translated">&lt;strong&gt;(I) 상속&lt;/strong&gt; (하위 분류를 통한).</target>
        </trans-unit>
        <trans-unit id="37f3255a916c82622528f7b0e38edaeecd6e05d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(R)eference&lt;/strong&gt; (invoke a method using a reference to the class, or via &quot;dot&quot; syntax).</source>
          <target state="translated">&lt;strong&gt;(R) 추론&lt;/strong&gt; (클래스에 대한 참조를 사용하거나 &quot;도트&quot;구문을 통해 메소드를 호출)</target>
        </trans-unit>
        <trans-unit id="d47c24704c2b9863e2e3ea5d7687a108717bebe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Default:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 기본 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e866b80161e29b930ff930217326b95750c6bf3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Public&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 공개&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c5b5405bad9144f153406167830cfeaa7599707" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Private&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. 개인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aedac4ee80eebec26a1eb8895f25fc3e9ab66966" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Protected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4. 보호&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10ae501fbb4b985b6a4a6387afbed4b6c308d6df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cb1729758cbd3ed754ecb8b9228916334559d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Access modifiers in Java.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java의 수정 자에 액세스하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1448cd0adc12ffa3db85751d7d788972e1ab2fad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basically, within same package you can access default members on instance of class directly or on 'this' reference in subclasses.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본적으로 동일한 패키지 내에서 클래스 인스턴스의 기본 멤버에 직접 액세스하거나 서브 클래스의 'this'참조에 액세스 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85289d4bbd59b9fc93e676b9dd9d70acb4cca817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default (no modifier)&lt;/strong&gt;: Limited access to class and package</source>
          <target state="translated">&lt;strong&gt;기본값 (수정 자 없음)&lt;/strong&gt; : 클래스 및 패키지에 대한 제한된 액세스</target>
        </trans-unit>
        <trans-unit id="a1878f65fb532348cd1105c6341d17ed1f134691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default -No keyword:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본-키워드 없음 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b04f00e04bc38cbb526378ea597f7474886dbd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default:&lt;/strong&gt; It is accessible in the same package from any of the class of package.</source>
          <target state="translated">&lt;strong&gt;기본값 :&lt;/strong&gt; 모든 패키지 클래스에서 동일한 패키지로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41b7f6e44695c115445cfdf86e3775318ae5636a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overriding static methods in java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java에서 정적 메소드 대체&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c1f15f4ebb983532fb274e28770fe57bde1d4d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package-private (default)&lt;/strong&gt;:
This access specifier will provide access specified by private access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;패키지-개인 (기본값)&lt;/strong&gt; :이 액세스 지정자는 아래에 설명 된 액세스 외에 개인용 액세스 지정자가 지정한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2394388ff716cba591b2a38592dcfb0fc54be273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private:&lt;/strong&gt;  it can be access in same class.</source>
          <target state="translated">&lt;strong&gt;비공개 :&lt;/strong&gt; 동일한 클래스에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0ded9f3e89154a12e4907eb9238a15f78247f90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Private&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cb9f56d3c4fd96b6c4e794bc32a4d40c75f7676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;:
When you are developing some class and you want member of this class not to be exposed outside this class then you should declare it as private. private members can be accessed only in class where they are defined i.e. enclosing class. &lt;strong&gt;private members can be accessed on 'this' reference and also on other instances of class enclosing these members, but only within the definition of this class.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비공개&lt;/strong&gt; : 일부 클래스를 개발 중이고이 클래스의 멤버가이 클래스 외부에 노출되지 않게하려면 비공개로 선언해야합니다. 비공개 멤버는 클래스가 정의되어있는 클래스에서만 액세스 할 수 있습니다. &lt;strong&gt;비공개 멤버는 'this'참조 및이 멤버를 둘러싸고있는 다른 클래스 인스턴스에서 액세스 할 수 있지만이 클래스의 정의 내에서만 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d034dfbbb5bc7f21cf96cfb8f1346e544c26d94d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;: Limited access to class only</source>
          <target state="translated">&lt;strong&gt;개인&lt;/strong&gt; : 수업 만 이용 가능</target>
        </trans-unit>
        <trans-unit id="8695d4960b797f2b6f67e904191eb903c43e1aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected:&lt;/strong&gt; you can access variables in same package as well as subclass in any other package.
so basically it is &lt;strong&gt;default + Inherited&lt;/strong&gt; behavior.</source>
          <target state="translated">&lt;strong&gt;보호 :&lt;/strong&gt; 다른 패키지의 하위 클래스뿐만 아니라 동일한 패키지의 변수에 액세스 할 수 있습니다. 기본적으로 &lt;strong&gt;기본 + 상속 된&lt;/strong&gt; 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1cc4ba9e4e89686db9f53e13fd8b66ac42177424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Protected&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d10a4c31137ee8169148752120d940b936bc3f24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected&lt;/strong&gt;: Limited access to class, package and subclasses (both inside and outside package)</source>
          <target state="translated">&lt;strong&gt;보호&lt;/strong&gt; : 클래스, 패키지 및 서브 클래스에 대한 제한된 액세스 (패키지 내부 및 외부)</target>
        </trans-unit>
        <trans-unit id="09bfe678952f0c3d0b3e5646e875cdb224ae65c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public:&lt;/strong&gt; It is basically as simple as you can access from any class whether that is in same package or not.</source>
          <target state="translated">&lt;strong&gt;공용 :&lt;/strong&gt; 기본적으로 같은 패키지에 있든 없든 모든 클래스에서 액세스 할 수있는 것처럼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="daf97633cf021dedd039ac3d7f17e15721760df8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Public&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ef6e4673df9ec5787ab0c659ebd27e9c95e224b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public&lt;/strong&gt;: Accessible to class, package (all), and subclasses... In short, everywhere.</source>
          <target state="translated">&lt;strong&gt;공개&lt;/strong&gt; : 클래스, 패키지 (모두) 및 서브 클래스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea3436ff46ae8818a665ddb071efa68994538cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default&lt;/strong&gt; - accessible from package.</source>
          <target state="translated">&lt;strong&gt;기본값&lt;/strong&gt; -패키지에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b4cfa6911291d8ddc421bedd52ed7d82f9ee73d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;package-private:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;package-private:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c53c0e830d80b72103ef701f9080f24a7d1a99a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;private:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;private:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d91069bf7a48c4c4d6a00bfe7860b6cbc143d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;private&lt;/strong&gt; - accessible from its class only.</source>
          <target state="translated">&lt;strong&gt;비공개&lt;/strong&gt; -클래스에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afe8465ac8ccd97429f85b76250e88d3dfed7a2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;protected:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2bed00fc75e7d51b53be0dee63c249e4a93a6e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected&lt;/strong&gt; - accessible from package and sub-classes in other package.
as well</source>
          <target state="translated">&lt;strong&gt;protected-&lt;/strong&gt; 다른 패키지의 패키지 및 하위 클래스에서 액세스 할 수 있습니다. 게다가</target>
        </trans-unit>
        <trans-unit id="7056cef6786f8cf6365723485c784d324755daf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected&lt;/strong&gt;:
This access specifier will provide access specified by package-private access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;protected&lt;/strong&gt; :이 액세스 지정자는 아래에 설명 된 액세스 외에 패키지 개인 액세스 지정자로 지정된 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="31d169cdb7e077cb9bf36e76bd03f5556f7d9daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;public:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f45ba4381db9194fc2431928eb13db0ea7fad3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt; - accessible from anywhere in the application.</source>
          <target state="translated">&lt;strong&gt;공개&lt;/strong&gt; -응용 프로그램의 어느 곳에서나 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c79deadce74e410ea5f7108d88f579a381133846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt;: This access specifier will provide access specified by protected access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;public&lt;/strong&gt; :이 액세스 지정자는 아래에 설명 된 액세스 외에 보호 된 액세스 지정자로 지정된 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d36eb0da54971756790f3d446942c6a1a8ca6054" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(*) &lt;a href=&quot;https://stackoverflow.com/questions/28612420/what-is-encapsulation-exactly&quot;&gt;What is Encapsulation exactly?&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;(*) &lt;a href=&quot;https://stackoverflow.com/questions/28612420/what-is-encapsulation-exactly&quot;&gt;정확히 캡슐화 란 무엇입니까?&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="69e4829657ddc7c46d77dc0bc935268a8736ae11" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;void saveGame(File dst)&lt;/code&gt; method which is called from the GUI code should be public.</source>
          <target state="translated">GUI 코드에서 호출 된 &lt;code&gt;void saveGame(File dst)&lt;/code&gt; 메소드는 공용이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a1965065a3a72db5cb5bbc47bad12cce01c8893" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;private&lt;/strong&gt; member (&lt;code&gt;i&lt;/code&gt;) is &lt;em&gt;only&lt;/em&gt; accessible within the same class as it is declared.</source>
          <target state="translated">&lt;strong&gt;비공개&lt;/strong&gt; 멤버 ( &lt;code&gt;i&lt;/code&gt; )는 선언 된 동일한 클래스 내 &lt;em&gt;에서만&lt;/em&gt; 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c567cfcccb536538fb2bff328e96d3817df1bc65" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;protected&lt;/strong&gt; member (&lt;code&gt;k&lt;/code&gt;) is accessible within all classes in the same package &lt;em&gt;and&lt;/em&gt; within subclasses in other packages.</source>
          <target state="translated">&lt;strong&gt;보호 된&lt;/strong&gt; 멤버 ( &lt;code&gt;k&lt;/code&gt; )는 동일한 패키지의 모든 클래스 &lt;em&gt;와&lt;/em&gt; 다른 패키지의 서브 클래스에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb72f226a8ba71d7c3578d0fab29e570e86013a3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;public&lt;/strong&gt; member (&lt;code&gt;l&lt;/code&gt;) is accessible to all classes (unless it resides in a &lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/sotms/&quot;&gt;module&lt;/a&gt; that does not export the package it is declared in).</source>
          <target state="translated">&lt;strong&gt;공개&lt;/strong&gt; 멤버 ( &lt;code&gt;l&lt;/code&gt; )는 선언 된 패키지를 내 보내지 않는 &lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/sotms/&quot;&gt;모듈에&lt;/a&gt; 상주하지 않는 한 모든 클래스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f9daadf043c9bd9f0d0e247b851c20599c84f6" translate="yes" xml:space="preserve">
          <source>A Java access modifier specifies which classes can access a given
  class and its fields, constructors and methods. Access modifiers can
  be specified separately for a class, its constructors, fields and
  methods. Java access modifiers are also sometimes referred to in daily
  speech as Java access specifiers, but the correct name is Java access
  modifiers. Classes, fields, constructors and methods can have one of
  four different Java access modifiers:</source>
          <target state="translated">Java 액세스 수정자는 주어진 클래스와 해당 필드, 생성자 및 메소드에 액세스 할 수있는 클래스를 지정합니다. 액세스 수정자는 클래스, 생성자, 필드 및 메소드에 대해 별도로 지정할 수 있습니다. Java 액세스 수정자는 일상 연설에서 Java 액세스 지정자로 언급되기도하지만 올바른 이름은 Java 액세스 수정 자입니다. 클래스, 필드, 생성자 및 메소드는 다음 네 가지 Java 액세스 수정 자 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e82124ab3a422db45abe523f1679bc6aa91180c" translate="yes" xml:space="preserve">
          <source>A class may be declared with the modifier public, in which case that
  class is visible to all classes everywhere. If a class has no modifier
  (the default, also known as package-private), it is visible only
  within its own package</source>
          <target state="translated">클래스는 수정 자 public으로 선언 될 수 있으며,이 경우 클래스는 모든 클래스에서 볼 수 있습니다. 클래스에 수정자가없는 경우 (기본값, 패키지 전용이라고도 함) 자체 패키지 내에서만 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="702664d37f54e24a65c5847af5c9c48dec38ac9b" translate="yes" xml:space="preserve">
          <source>A class that should only be instantiated in a factory class (in the same package) should have a package restricted constructor, since it shouldn't be possible to call it directly from outside the package.</source>
          <target state="translated">팩토리 클래스에서만 (동일한 패키지로) 인스턴스화해야하는 클래스는 패키지 외부에서 직접 호출 할 수 없으므로 패키지 제한 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2d6ccdc5fb3619653080b70f843a3d53183d1d68" translate="yes" xml:space="preserve">
          <source>A class, method, constructor, interface, etc. declared public can be accessed from any other class. Therefore fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java universe.</source>
          <target state="translated">public으로 선언 된 클래스, 메소드, 생성자, 인터페이스 등은 다른 클래스에서 액세스 할 수 있습니다. 따라서 공개 클래스 내에 선언 된 필드, 메서드 및 블록은 Java 유니버스에 속한 모든 클래스에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c33800560e8ea15395ce4e031d5c61d474b047" translate="yes" xml:space="preserve">
          <source>A field &lt;code&gt;long internalCounter&lt;/code&gt; should probably be private since it's mutable and an implementation detail.</source>
          <target state="translated">필드 &lt;code&gt;long internalCounter&lt;/code&gt; 는 변경 가능하고 구현 세부 정보이므로 비공개이어야합니다.</target>
        </trans-unit>
        <trans-unit id="84f15ff4b953e019c687edc46342c1a4d6e9ef49" translate="yes" xml:space="preserve">
          <source>A member with &lt;strong&gt;no access modifier&lt;/strong&gt; (&lt;code&gt;j&lt;/code&gt;) is only accessible within classes in the same package.</source>
          <target state="translated">&lt;strong&gt;액세스 수정 자&lt;/strong&gt; ( &lt;code&gt;j&lt;/code&gt; )가 &lt;strong&gt;없는&lt;/strong&gt; 멤버는 동일한 패키지의 클래스 내에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c55ab8ded977750bfe1904b046504c141b94218c" translate="yes" xml:space="preserve">
          <source>A non-subclass inside a package of a subclass (A subclass inherits the protected members from its parent, and it makes them private to non-subclasses):</source>
          <target state="translated">서브 클래스 패키지 내부의 서브 클래스가 아닌 서브 클래스 (서브 클래스는 보호 된 멤버를 부모로부터 상속 받아 서브 클래스가 아닌 개인에게만 제공) :</target>
        </trans-unit>
        <trans-unit id="d652e362bd9495b3b5c5a0d3c9f4d692d5d6cfac" translate="yes" xml:space="preserve">
          <source>Access Specifiers in Java:
There are 4 access specifiers in java, namely private, package-private (default), protected and public in increasing access order.</source>
          <target state="translated">Java의 액세스 지정자 : Java에는 액세스 순서가 증가함에 따라 개인용, 패키지 전용 (기본값), 보호 및 공용의 4 가지 액세스 지정자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d90ffb4fa501229758715d3323e06c84a5ae97b4" translate="yes" xml:space="preserve">
          <source>Access level modifiers determine whether other classes can use a
  particular field or invoke a particular method. There are two levels
  of access control:</source>
          <target state="translated">액세스 레벨 수정자는 다른 클래스가 특정 필드를 사용하거나 특정 메소드를 호출 할 수 있는지 판별합니다. 두 가지 수준의 액세스 제어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35f9b2fc1a98f9e2d94d1f9485056d27b28eeaf" translate="yes" xml:space="preserve">
          <source>Access levels affect you in two ways. First, when you use classes that
  come from another source, such as the classes in the Java platform,
  access levels determine which members of those classes your own
  classes can use. Second, when you write a class, you need to decide
  what access level every member variable and every method in your class
  should have.</source>
          <target state="translated">액세스 수준은 두 가지 방식으로 영향을줍니다. 먼저, Java 플랫폼의 클래스와 같은 다른 소스에서 온 클래스를 사용하는 경우 액세스 레벨에 따라 해당 클래스의 클래스에서 사용할 수있는 멤버가 결정됩니다. 둘째, 클래스를 작성할 때 모든 멤버 변수 및 클래스의 모든 메소드에 어떤 액세스 레벨이 있어야하는지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="03834d1bba262bb9c1fe64f18662c2cfe0984376" translate="yes" xml:space="preserve">
          <source>Access modifier can be applicable for &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;field&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/60907642/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;method&lt;/code&gt;. Try to access, subclass or override this.</source>
          <target state="translated">액세스 수정자는 &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;field&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/60907642/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt; , &lt;code&gt;method&lt;/code&gt; 에 적용 할 수 있습니다. 이것을 접근, 서브 클래 싱 또는 오버라이드 시키십시오.</target>
        </trans-unit>
        <trans-unit id="9e3f67bc099476112adf6c930b20ba16a50afeba" translate="yes" xml:space="preserve">
          <source>Access modifiers are there to restrict access at several levels.</source>
          <target state="translated">액세스 수정자는 여러 레벨에서 액세스를 제한하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ef81daf780b1360468865cad0409109e0c35badd" translate="yes" xml:space="preserve">
          <source>Access modifiers is a tool to help you to prevent accidentally breaking encapsulation&lt;sup&gt;(*)&lt;/sup&gt;. Ask yourself if you intend the member to be something that's internal to the class, package, class hierarchy or not internal at all, and choose access level accordingly.</source>
          <target state="translated">액세스 수정자는 실수로 캡슐화가 깨지는 것을 방지하는 도구입니다 &lt;sup&gt;(*)&lt;/sup&gt; . 멤버가 클래스, 패키지, 클래스 계층 내부에 있거나 내부에없는 것을 원한다면 자신에게 물어보고 그에 따라 액세스 수준을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5eff681f376245a3dee4c9191f68f56b0af848bd" translate="yes" xml:space="preserve">
          <source>Access to &lt;code&gt;field&lt;/code&gt; or &lt;code&gt;method&lt;/code&gt; is through a &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 또는 &lt;code&gt;method&lt;/code&gt; 액세스는 &lt;code&gt;class&lt;/code&gt; 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="b2412c998fc16dee0b53ff74260ef514b93a1606" translate="yes" xml:space="preserve">
          <source>Accessible only inside the same class.</source>
          <target state="translated">같은 클래스 내에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a2d2458a3a2813e65aa1e280528e2ae281eb1b6" translate="yes" xml:space="preserve">
          <source>Accessible only to the classes in the same package and to the subclasses</source>
          <target state="translated">동일한 패키지의 클래스 및 서브 클래스에만 액세스 가능</target>
        </trans-unit>
        <trans-unit id="d0e99d1f0ad00dcd92752660239fe3e6461be76a" translate="yes" xml:space="preserve">
          <source>Accessible to the classes in the same package only.</source>
          <target state="translated">동일한 패키지의 클래스에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b3141b0946b8bc5002beaffc46356be6f4c620a" translate="yes" xml:space="preserve">
          <source>All the access specifiers are possible on class members (constructors, methods and static member functions, nested classes).</source>
          <target state="translated">모든 액세스 지정자는 클래스 멤버 (생성자, 메소드 및 정적 멤버 함수, 중첩 클래스)에서 가능합니다.</target>
        </trans-unit>
        <trans-unit id="039d200ae5db7c7b5f2a7c153d81e8001cb8966c" translate="yes" xml:space="preserve">
          <source>Also, use the @Override annotation when overriding to keep things from breaking when you refactor.</source>
          <target state="translated">또한 재정의 할 때 @Override 주석을 사용하여 리팩토링 할 때 문제가 발생하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="2e74d999b3d7180df815ddf8cc8c8247175ccf3b" translate="yes" xml:space="preserve">
          <source>An internal &lt;code&gt;void beforeRender()&lt;/code&gt; method called right before rendering and used as a hook in subclasses should be protected.</source>
          <target state="translated">렌더링 직전에 호출되고 서브 클래스에서 후크로 사용되는 내부 &lt;code&gt;void beforeRender()&lt;/code&gt; 메소드를 보호해야합니다.</target>
        </trans-unit>
        <trans-unit id="f562bc00e2ff22b13660ce46b08683a5aa376aae" translate="yes" xml:space="preserve">
          <source>Another thing is that classes which depend a lot on each other may end up in the same package and could eventually be refactored or merged if the dependency is too strong.</source>
          <target state="translated">또 다른 것은 서로 의존하는 클래스가 동일한 패키지로 끝나고 종속성이 너무 강한 경우 리팩토링되거나 병합 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c41355fcbb760f41e646cca45391d28712651f9" translate="yes" xml:space="preserve">
          <source>As a general rule I try to avoid overriding method implementations by subclassing; it's too easy to screw up the logic. Declare abstract protected methods if you intend for it to be overridden.</source>
          <target state="translated">일반적으로 서브 클래 싱으로 메소드 구현을 대체하지 않도록 노력합니다. 논리를 망치기가 너무 쉽습니다. 재정의하려는 경우 추상 보호 방법을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="32423b1a28b9a1d669c73210c669f380ab7cd7cf" translate="yes" xml:space="preserve">
          <source>As a result, if we divide access right into three rights:</source>
          <target state="translated">결과적으로 액세스 권한을 세 가지 권한으로 나누면 :</target>
        </trans-unit>
        <trans-unit id="db2bda78247e71f5efa83e0fc3e723c83ff44d0a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb:</source>
          <target state="translated">경험적으로 볼 때 :</target>
        </trans-unit>
        <trans-unit id="a81942444a4d0f2780ea3a629f2fe55b7bc48ec8" translate="yes" xml:space="preserve">
          <source>Assume that we have 2 classes; &lt;code&gt;Father&lt;/code&gt; and &lt;code&gt;Son&lt;/code&gt;, each in its own package:</source>
          <target state="translated">우리가 2 개의 수업을 가지고 있다고 가정하자. &lt;code&gt;Father&lt;/code&gt; and &lt;code&gt;Son&lt;/code&gt; 은 각각 자체 패키지로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9a0ac313bc297e77263ee6fbe80f0f9519aae9" translate="yes" xml:space="preserve">
          <source>At the member level&amp;mdash;public, private, protected, or package-private (no explicit modifier).</source>
          <target state="translated">구성원 수준 (공개, 개인, 보호 또는 패키지 개인) (명시 적 수정 자 없음)</target>
        </trans-unit>
        <trans-unit id="e305218fd0f9ba9ee5a5cdb055df557e07100698" translate="yes" xml:space="preserve">
          <source>At the top level&amp;mdash;public, or package-private (no explicit modifier).</source>
          <target state="translated">최상위 또는 공용 또는 패키지 전용 (명시 적 수정 자 없음)</target>
        </trans-unit>
        <trans-unit id="1c758ca2bda73911a8bb40b724a78e1d5d7c8eff" translate="yes" xml:space="preserve">
          <source>Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.</source>
          <target state="translated">클래스 상속으로 인해 클래스의 모든 공용 메소드 및 변수는 서브 클래스에 의해 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="fb75e9527859877f47e7706814e662a02518f379" translate="yes" xml:space="preserve">
          <source>But these protected members are &amp;ldquo;accessible outside the package only through inheritance&amp;ldquo;. i.e you can access a protected member of a class in its subclass present in some other package directly as if the member is present in the subclass itself. But that protected member will not be accessible in the subclass outside the package by using parent class&amp;rsquo;s reference. 
....</source>
          <target state="translated">그러나 이러한 보호 된 멤버는 &quot;상속을 통해서만 패키지 외부에서 액세스 할 수 있습니다&quot;. 즉, 멤버가 서브 클래스 자체에있는 것처럼 다른 패키지에있는 서브 클래스에있는 클래스의 보호 된 멤버에 직접 액세스 할 수 있습니다. 그러나 보호 된 멤버는 부모 클래스의 참조를 사용하여 패키지 외부의 서브 클래스에서 액세스 할 수 없습니다. ....</target>
        </trans-unit>
        <trans-unit id="c4a8265d49bc8acc6dd4762df0a314fae0081dc6" translate="yes" xml:space="preserve">
          <source>C++ defines an additional level called &quot;friend&quot; and the less you know about that the better.</source>
          <target state="translated">C ++은 &quot;friend&quot;라는 추가 레벨을 정의하며 이에 대해 더 잘 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="fea15bced6cf072a20331c3293889e5278470a9f" translate="yes" xml:space="preserve">
          <source>Can be accessed from anywhere. (Global Access)</source>
          <target state="translated">어디서나 액세스 할 수 있습니다. (글로벌 액세스)</target>
        </trans-unit>
        <trans-unit id="b6b8d9b4123fecc2397339f9346b53016b47c561" translate="yes" xml:space="preserve">
          <source>Can only be seen and used by the &lt;strong&gt;package&lt;/strong&gt; in which it was declared.  This is the default in Java (which some see as a mistake).</source>
          <target state="translated">선언 된 &lt;strong&gt;패키지&lt;/strong&gt; 에서만보고 사용할 수 있습니다. 이것은 Java의 기본값입니다 (일부는 실수로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="29a771fa03b2207c5bfcb8ccc88b283b088d93d8" translate="yes" xml:space="preserve">
          <source>Class and Interface</source>
          <target state="translated">클래스와 인터페이스</target>
        </trans-unit>
        <trans-unit id="abdbdface1f6d0a002a132de8ee6c16f0286d809" translate="yes" xml:space="preserve">
          <source>Class can be public or default</source>
          <target state="translated">수업은 공개 또는 기본이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4eff37234b0241258920d335734419acce47e495" translate="yes" xml:space="preserve">
          <source>Class members can be public, protected, default or private.</source>
          <target state="translated">클래스 멤버는 공개, 보호, 기본 또는 비공개 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b77183cc688eb0a13673641268a14b314543ef5c" translate="yes" xml:space="preserve">
          <source>Compiler output:</source>
          <target state="translated">컴파일러 출력 :</target>
        </trans-unit>
        <trans-unit id="5813699819cb9238ea0a3cac18732617dd8b7ef9" translate="yes" xml:space="preserve">
          <source>David's answer provides the meaning of each access modifier. As for when to use each, I'd suggest making public all classes and the methods of each class that are meant for external use (its API), and everything else private.</source>
          <target state="translated">David의 대답은 각 액세스 수정 자의 의미를 제공합니다. 각각을 사용할 때에 관해서는 모든 클래스와 외부 사용을위한 각 클래스의 메소드 (API) 및 기타 모든 것을 공개하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3048e4be2bec9d78ee94630c8921320fc4664da" translate="yes" xml:space="preserve">
          <source>Easy rule. Start with declaring everything private. And then progress towards the public as the needs arise and design warrants it.</source>
          <target state="translated">쉬운 규칙. 모든 것을 비공개로 선언하는 것으로 시작하십시오. 그런 다음 요구가 발생하고 디자인이이를 보증 할 때 대중을 향해 나아가십시오.</target>
        </trans-unit>
        <trans-unit id="1aed6cf212aa5ca85fdc040a3f80f02392b4b63d" translate="yes" xml:space="preserve">
          <source>Everyone can see it.</source>
          <target state="translated">누구나 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="a9375f321c90af9af48e6e3fb9835073a5901dfe" translate="yes" xml:space="preserve">
          <source>Explanations</source>
          <target state="translated">Explanations</target>
        </trans-unit>
        <trans-unit id="de130795061e0af332069bc81b222c01a70e8ee6" translate="yes" xml:space="preserve">
          <source>Finally, your friend wants to read your progress report for the semester which is posted on the website. However, every student has their own personal login to access this section of the campus website. This would make these credentials as &lt;strong&gt;PRIVATE&lt;/strong&gt;.</source>
          <target state="translated">마지막으로 친구가 웹 사이트에 게시 된 학기의 진행 상황 보고서를 읽으려고합니다. 그러나 모든 학생에게는 캠퍼스 웹 사이트의이 섹션에 액세스하기위한 자체 로그인이 있습니다. 이 자격 증명을 &lt;strong&gt;PRIVATE로&lt;/strong&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="414b0040a73b05acdd918cc38af972d787b57ad2" translate="yes" xml:space="preserve">
          <source>Following block diagram explain how data members of &lt;strong&gt;base class&lt;/strong&gt; are &lt;strong&gt;inherited&lt;/strong&gt; when &lt;strong&gt;derived class&lt;/strong&gt; access mode is &lt;strong&gt;private&lt;/strong&gt;.</source>
          <target state="translated">다음 블록 다이어그램은 &lt;strong&gt;파생 클래스&lt;/strong&gt; 액세스 모드가 &lt;strong&gt;전용 일&lt;/strong&gt; 때 &lt;strong&gt;기본 클래스&lt;/strong&gt; 의 데이터 멤버가 &lt;strong&gt;상속&lt;/strong&gt; 되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="211709b4e5a975998dfceb9f90b343faddbc3a82" translate="yes" xml:space="preserve">
          <source>For a taste of how these interact, consider this example. It is possible to &quot;leak&quot; private inner classes; this is usually a warning:</source>
          <target state="translated">이들이 어떻게 상호 작용하는지 맛 보려면이 예제를 고려하십시오. 개인 내부 클래스를 &quot;누설&quot;할 수 있습니다. 이것은 일반적으로 경고입니다.</target>
        </trans-unit>
        <trans-unit id="629b7e6e087c9f024573fb85ac0935aa91d841eb" translate="yes" xml:space="preserve">
          <source>For classes in the top scope, only &lt;code&gt;public&lt;/code&gt; and package-private are permitted. This design choice is presumably because &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; would be redundant at the package level (there is no inheritance of packages).</source>
          <target state="translated">최상위 범위의 클래스의 경우 &lt;code&gt;public&lt;/code&gt; 및 패키지 개인 만 허용됩니다. 이 디자인 선택은 패키지 수준에서 &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 이 중복되기 때문에 (패키지 상속이 없기 때문에) 아마도 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="358ca920d00cef8e692577e7de482b71e23ffa72" translate="yes" xml:space="preserve">
          <source>For example:
You may put sensitive security methods in a 'security' package.
Then put a public class which accesses some of the security related code in this package but keep other security classes &lt;strong&gt;package private&lt;/strong&gt;.
Thus other developers will only be able to use the publicly available class from outside of this package (unless they change the modifier).
This is not a security feature, but will &lt;strong&gt;guide&lt;/strong&gt; usage.</source>
          <target state="translated">예를 들어, 민감한 보안 방법을 '보안'패키지에 넣을 수 있습니다. 그런 다음이 패키지의 일부 보안 관련 코드에 액세스하는 공개 클래스를 배치하고 다른 보안 클래스 &lt;strong&gt;패키지는 비공개로&lt;/strong&gt; 유지하십시오. 따라서 다른 개발자는 수정자를 변경하지 않는 한이 패키지 외부에서 공개적으로 사용 가능한 클래스 만 사용할 수 있습니다. 이것은 보안 기능은 아니지만 사용법을 &lt;strong&gt;안내&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dc227021f08c9353ab45ce62f177cc6fd693f40c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://tutorials.jenkov.com/java/access-modifiers.html&quot;&gt;Java Access Modifiers&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://tutorials.jenkov.com/java/access-modifiers.html&quot;&gt;Java Access Modifiers에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3bf7a6338bd5d5a3a5912a1ea99b4fa3eaa6fe75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;Controlling Access to Members of a Class&lt;/a&gt; tutorials:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;액세스 제어에서 클래스 멤버&lt;/a&gt; 학습으로 :</target>
        </trans-unit>
        <trans-unit id="c9146570be1c93d6b1aab81c70a95becda8f9183" translate="yes" xml:space="preserve">
          <source>Here is detailed answer</source>
          <target state="translated">자세한 답변은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="dab161dd919298ea5955c5ca83a5191994ed419b" translate="yes" xml:space="preserve">
          <source>Here's a better version of the table. (Future proof with a column for modules.)</source>
          <target state="translated">더 나은 버전의 테이블이 있습니다. (모듈 열이있는 미래 증거)</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">도움이 되었기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="aa86ea3205f5b702b5c530cc16d177882fb58320" translate="yes" xml:space="preserve">
          <source>However, if the public class we are trying to access is in a different package, then the public class still need to be imported.</source>
          <target state="translated">그러나 액세스하려는 공개 클래스가 다른 패키지에 있으면 공개 클래스를 계속 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="3068a4b8c73e5abddb06c0c44f94cd1fc95d98ad" translate="yes" xml:space="preserve">
          <source>However, this is quite complicated, and for full details, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6&quot;&gt;consult the Java Language Specification&lt;/a&gt;. (Yes, there have been compiler bugs in the past.)</source>
          <target state="translated">그러나 이것은 매우 복잡하며 자세한 내용 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6&quot;&gt;은 Java 언어 사양을 참조하십시오&lt;/a&gt; . (예, 과거에는 컴파일러 버그가있었습니다.)</target>
        </trans-unit>
        <trans-unit id="65c381ea7d6931f0058f4696124a3922c9a01d9e" translate="yes" xml:space="preserve">
          <source>If a class member is declared with keyword protected then in this case it is available ONLY to same class members</source>
          <target state="translated">키워드 보호로 클래스 멤버를 선언하면이 경우 동일한 클래스 멤버 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711d3ba82f3b647c7d5406080db3495d8ec4da48" translate="yes" xml:space="preserve">
          <source>If a class member is declared with keyword protected then it can be accessed from same class members, outside class members within the same package and inherited class members. If a class member is protected then it can NOT be accessed from outside package class unless the outside packaged class is inherited i.e. extends the other package superclass. But a protected class member is always available to same package classes it does NOT matter weather the same package class is inherited or NOT</source>
          <target state="translated">키워드 보호를 사용하여 클래스 멤버를 선언하면 동일한 패키지 내의 클래스 클래스 외부 및 상속 된 클래스 멤버와 동일한 클래스 멤버에서 액세스 할 수 있습니다. 클래스 멤버가 보호 된 경우 외부 패키지 클래스가 상속되지 않으면 다른 패키지 수퍼 클래스를 확장하지 않으면 외부 패키지 클래스에서 액세스 할 수 없습니다. 그러나 보호 된 클래스 멤버는 항상 동일한 패키지 클래스에서 사용할 수 있습니다. 동일한 패키지 클래스가 상속되거나 그렇지 않은 날씨와 상관 없습니다.</target>
        </trans-unit>
        <trans-unit id="00c3f094a058fa6a019b6a1d9bef50a5bac1da87" translate="yes" xml:space="preserve">
          <source>If a class member is declared with public then it can be accessed from anywhere</source>
          <target state="translated">클래스 멤버가 public으로 선언되면 어디서나 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f687d570b26042fb8176f323cd37d2559e1a3d" translate="yes" xml:space="preserve">
          <source>If on the contrary you set everything as &lt;strong&gt;public&lt;/strong&gt; it will not be clear what should or should not be accessed, which may lead to writing a lot of javadoc (which does not enforce anything via the compiler...).</source>
          <target state="translated">반대로 모든 것을 &lt;strong&gt;공개&lt;/strong&gt; 로 설정하면 액세스해야하거나 액세스하지 않아야 할 내용이 명확하지 않으므로 많은 javadoc을 작성할 수 있습니다 (컴파일러를 통해 아무것도 시행하지 않습니다 ...).</target>
        </trans-unit>
        <trans-unit id="8a060e14cb3887508691d17bc70585a7b1cb9b1f" translate="yes" xml:space="preserve">
          <source>If you try to access private members on one class in another will throw compile error. For example,</source>
          <target state="translated">한 클래스에서 다른 멤버의 개인 멤버에 액세스하려고하면 컴파일 오류가 발생합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="31d88a3684ae0701668196799b25e5ac3e976cb2" translate="yes" xml:space="preserve">
          <source>If you want users to be able to customize behaviors, rather than making internals public so they can override them, it's often a better idea to shove those guts into an object and make that interface public.  That way they can simply plug in a new object.  For example, if you were writing a CD player and wanted the &quot;go find info about this CD&quot; bit customizable, rather than make those methods public you'd put all that functionality into its own object and make just your object getter/setter public.  In this way being stingy about exposing your guts encourages good composition and separation of concerns</source>
          <target state="translated">사용자가 내부를 공개하지 않고 비헤이비어를 커스터마이즈 할 수 있도록 사용자 정의 할 수 있도록하려면 이러한 내장을 객체로 밀어 넣고 해당 인터페이스를 공개하는 것이 좋습니다. 그렇게하면 새로운 객체를 간단히 연결할 수 있습니다. 예를 들어, CD 플레이어를 작성 중이고 &quot;이 CD에 대한 정보 찾기&quot;비트를 사용자 정의 할 수있게하려면 해당 메소드를 공개하지 않고 모든 기능을 자체 오브젝트에 넣고 오브젝트를 getter / setter로 공개하십시오. . 이런 식으로 장을 노출시키는 것에 신경 쓰지 않으면 좋은 구성과 우려의 분리가 촉진됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7a886c87a6eb77fdc25a1035f8d6da53cf8656" translate="yes" xml:space="preserve">
          <source>In Java default is NOT an access modifier keyword. If a class member is declared without any access modifier keyword then in this case it is considered as default member. The default class member is always available to same package class members. But outside package class member can NOT access default class members even if outside classes are subclasses unlike protected members</source>
          <target state="translated">Java에서 기본값은 액세스 수정 자 키워드가 아닙니다. 액세스 멤버 수정 자 키워드없이 클래스 멤버를 선언하면이 경우 기본 멤버로 간주됩니다. 기본 클래스 멤버는 항상 동일한 패키지 클래스 멤버가 사용할 수 있습니다. 그러나 외부 클래스가 보호 된 멤버와 달리 하위 클래스 인 경우에도 외부 패키지 클래스 멤버는 기본 클래스 멤버에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fff3d91dbf347df5d37ad1067782bedfe095b46f" translate="yes" xml:space="preserve">
          <source>In Java, are there clear rules on when to use each of access modifiers, namely the default (package private), &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, while making &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; and dealing with inheritance?</source>
          <target state="translated">Java에서는 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;interface&lt;/code&gt; 를 만들고 상속을 처리하면서 각 액세스 수정 자, 즉 기본 (패키지 개인), &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 을 언제 사용해야하는지에 대한 명확한 규칙이 있습니까?</target>
        </trans-unit>
        <trans-unit id="0a637c3e550bf7e3b47867e3e5c6bf98ec1df2d9" translate="yes" xml:space="preserve">
          <source>In non-static methods you can access directly because of &lt;strong&gt;this&lt;/strong&gt; reference (also in constructors)but to access in static methods you need to create object of the class.</source>
          <target state="translated">비 정적 메소드에서는 &lt;strong&gt;이&lt;/strong&gt; 참조 (생성자)로 인해 직접 액세스 할 수 있지만 정적 메소드로 액세스하려면 클래스의 오브젝트를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f53b845e511550d070f01e7e1e45f0c6618de79e" translate="yes" xml:space="preserve">
          <source>In very short</source>
          <target state="translated">아주 짧게</target>
        </trans-unit>
        <trans-unit id="0a280c9c0cc8b973c8bf1ae5a66442e357f07610" translate="yes" xml:space="preserve">
          <source>Inheritance. Successor &lt;code&gt;class&lt;/code&gt;(subclass) access modifier can be any. Successor &lt;code&gt;method&lt;/code&gt;(override) access modifier should be the same or expand it</source>
          <target state="translated">계승. 후속 &lt;code&gt;class&lt;/code&gt; (서브 클래스) 액세스 수정자는 아무 것도 될 수 없습니다. 후속 &lt;code&gt;method&lt;/code&gt; (재정의) 액세스 수정자는 동일하거나 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">내부 수업</target>
        </trans-unit>
        <trans-unit id="0ebd78cffc1684194f3fbbff5f4da1d70adec54f" translate="yes" xml:space="preserve">
          <source>Inside a class that is located in the same package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 가 정의 된 동일한 패키지에있는 클래스 내부 ( &lt;code&gt;fatherpackage&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="4cb68522151730f7fe478771c760ac74a2dfdcd4" translate="yes" xml:space="preserve">
          <source>Inside a subclass, on the current instance via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">서브 클래스 내부에서 &lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;super&lt;/code&gt; 를 통해 현재 인스턴스에서</target>
        </trans-unit>
        <trans-unit id="85ab384f0543ec447c88c37b720be06d8d5088de" translate="yes" xml:space="preserve">
          <source>Is an access to a member with this access specifier allowed?</source>
          <target state="translated">이 액세스 지정자가있는 멤버에 대한 액세스가 허용됩니까?</target>
        </trans-unit>
        <trans-unit id="68afd36f6cfde7e67dffed921baf25b1a58cbfec" translate="yes" xml:space="preserve">
          <source>It is all about &lt;strong&gt;encapsulation&lt;/strong&gt; (or as Joe Phillips stated, &lt;em&gt;least knowledge&lt;/em&gt;).</source>
          <target state="translated">&lt;strong&gt;캡슐화&lt;/strong&gt; 에 관한 모든 것입니다 (또는 Joe Phillips가 말했듯이 &lt;em&gt;최소한의 지식&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="9428cccda535e253598eaa7cdab4627dc9261f0f" translate="yes" xml:space="preserve">
          <source>It's actually a bit more complicated than a simple grid shows. The grid tells you whether an access is allowed, but what exactly constitutes an access? Also, access levels interact with nested classes and inheritance in complex ways.</source>
          <target state="translated">실제로는 간단한 그리드 쇼보다 조금 더 복잡합니다. 그리드는 액세스가 허용되는지 여부를 알려주지 만, 정확히 액세스를 구성하는 것은 무엇입니까? 또한 액세스 수준은 중첩 된 클래스 및 상속과 복잡한 방식으로 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="8d7eff0719ace3e48da815165c32c20e33793293" translate="yes" xml:space="preserve">
          <source>Java - Method accessibility inside package-private class?</source>
          <target state="translated">Java-패키지 전용 클래스 내의 메서드 접근성?</target>
        </trans-unit>
        <trans-unit id="540bbbbbf4debb7face493bc9c0566a5b985f14c" translate="yes" xml:space="preserve">
          <source>Java access modifiers are used to provide access control in Java.</source>
          <target state="translated">Java 액세스 수정자는 Java에서 액세스 제어를 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b326f17a3d2f7a73292bcff3aa33360fd288b8b2" translate="yes" xml:space="preserve">
          <source>Java access modifies which you can use</source>
          <target state="translated">Java 액세스는 사용할 수있는 수정</target>
        </trans-unit>
        <trans-unit id="2d507bfe48fd363710c7aa776449fca5b38c5c5a" translate="yes" xml:space="preserve">
          <source>Let's add a protected method &lt;code&gt;foo()&lt;/code&gt; to &lt;code&gt;Father&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Father&lt;/code&gt; 에 보호 된 메소드 &lt;code&gt;foo()&lt;/code&gt; 를 추가해 봅시다.</target>
        </trans-unit>
        <trans-unit id="825e439c12e8399e15d6ef5cddfff02318859b29" translate="yes" xml:space="preserve">
          <source>Let's assume that you're a student at a university and you have a friend who's coming to visit you over the weekend. Suppose there exists a big statue of the university's founder in the middle of the campus.</source>
          <target state="translated">당신이 대학의 학생이고 주말에 당신을 방문 할 친구가 있다고 가정합시다. 캠퍼스 한가운데에 대학 설립자의 큰 조각상이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dc55fb860e4b429ce495c5cbc9ba6248283659cf" translate="yes" xml:space="preserve">
          <source>Like you'd think, only the &lt;strong&gt;class&lt;/strong&gt; in which it is declared can see it.</source>
          <target state="translated">당신이 생각하는 것처럼, 그것이 선언 된 &lt;strong&gt;클래스&lt;/strong&gt; 만이 그것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8709df24bd586627893f85ebfa1884c2f82a5e55" translate="yes" xml:space="preserve">
          <source>List item</source>
          <target state="translated">목록 항목</target>
        </trans-unit>
        <trans-unit id="c1398e89d57631598bc754b3d6e89f276728b298" translate="yes" xml:space="preserve">
          <source>Local variables and formal parameters cannot take access specifiers. Since they are inherently inaccessible to the outside according to scoping rules, they are effectively private.</source>
          <target state="translated">지역 변수와 형식 매개 변수는 액세스 지정자를 사용할 수 없습니다. 범위 지정 규칙에 따라 본질적으로 외부에 액세스 할 수 없으므로 사실상 비공개입니다.</target>
        </trans-unit>
        <trans-unit id="1b8528ca6c2239a069ccb77a16a61d04aaa3ad2b" translate="yes" xml:space="preserve">
          <source>Many languages find the hierarchical nature of public/protected/private to be too limiting and not in line with reality.  To that end there is the concept of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Trait_class&quot;&gt;trait class&lt;/a&gt;, but that's another show.</source>
          <target state="translated">많은 언어들이 공공 / 보호 / 민간의 계층 적 성격이 너무 제한적이고 현실과 맞지 않는 것으로보고있다. 이를 위해 &lt;a href=&quot;http://en.wikipedia.org/wiki/Trait_class&quot;&gt;특성 클래스&lt;/a&gt; 라는 개념이 있지만 그것은 또 다른 쇼입니다.</target>
        </trans-unit>
        <trans-unit id="61039d9442076fb2e85d753a984b29c6d6e97613" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;private&lt;/code&gt;: Only if member is defined within the same class as calling code.</source>
          <target state="translated">멤버 &lt;code&gt;private&lt;/code&gt; : 멤버가 호출 코드와 동일한 클래스 내에 정의 된 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6766c91a1dac9b515e329f73674dee7761caf9" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;protected&lt;/code&gt;: Same package, or if member is defined in a superclass of the class containing the calling code.</source>
          <target state="translated">멤버가 &lt;code&gt;protected&lt;/code&gt; : 동일한 패키지 또는 멤버가 호출 코드를 포함하는 클래스의 수퍼 클래스에 정의 된 경우.</target>
        </trans-unit>
        <trans-unit id="56756b869829e0a2b3e5809cfb44466392b0d8dd" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;public&lt;/code&gt;: Yes.</source>
          <target state="translated">회원 &lt;code&gt;public&lt;/code&gt; : 예.</target>
        </trans-unit>
        <trans-unit id="333249b7b9e011c07bbf34cd6918aeb87c291c5d" translate="yes" xml:space="preserve">
          <source>Member is package private: Only if the calling code is within the member's immediately enclosing package.</source>
          <target state="translated">멤버가 패키지 비공개 : 호출 코드가 멤버의 즉시 둘러싸는 패키지 내에있는 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="46e6a422e152e53fcd52afdc532361e67997177b" translate="yes" xml:space="preserve">
          <source>Methods, variables and constructors that are declared private can only be accessed within the declared class itself. The private access modifier is the most restrictive access level. Class and interfaces cannot be private.</source>
          <target state="translated">private으로 선언 된 메서드, 변수 및 생성자는 선언 된 클래스 자체 내에서만 액세스 할 수 있습니다. 개인용 액세스 수정자는 가장 제한적인 액세스 수준입니다. 클래스 및 인터페이스는 개인용이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="335faa2a06faaaaddaf19dca7a6e552702624138" translate="yes" xml:space="preserve">
          <source>Methods,Variables and Constructors</source>
          <target state="translated">방법, 변수 및 생성자</target>
        </trans-unit>
        <trans-unit id="89cb26c7ec8c16073c200078d9348aed52d6c686" translate="yes" xml:space="preserve">
          <source>My two cents :)</source>
          <target state="translated">내 두 센트 :)</target>
        </trans-unit>
        <trans-unit id="87a523f027d0ba7adab70824c7b1fb94c7132d6f" translate="yes" xml:space="preserve">
          <source>Next, you want to take your friend to your dorm, but for that you need to register him as a visitor. This means that he gets an access pass (which is the same as yours) to get into various buildings on campus. This would make his access card as &lt;strong&gt;PROTECTED&lt;/strong&gt;.</source>
          <target state="translated">다음으로 친구를 기숙사로 데려가려고하지만 방문객으로 등록해야합니다. 이것은 그가 캠퍼스의 다양한 건물에 들어갈 수있는 액세스 패스 (귀하와 동일)를 얻음을 의미합니다. 이것은 그의 액세스 카드를 &lt;strong&gt;보호 형으로&lt;/strong&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7ec331f3044739b47bc605e4558099cf08d010f7" translate="yes" xml:space="preserve">
          <source>Normally, member variables are defined private, but member methods are public.</source>
          <target state="translated">일반적으로 멤버 변수는 개인용으로 정의되지만 멤버 메소드는 공용입니다.</target>
        </trans-unit>
        <trans-unit id="c6238ff0e30b27995906139dc0f1043520c044df" translate="yes" xml:space="preserve">
          <source>Note: &lt;em&gt;This is just a &lt;strong&gt;supplement&lt;/strong&gt; for the accepted answer.&lt;/em&gt;</source>
          <target state="translated">참고 : &lt;em&gt;이것은 허용되는 답변을 &lt;strong&gt;보완&lt;/strong&gt; 하는 것입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adb9aaea02b1cff0a3c213ab075fcb4d010034c7" translate="yes" xml:space="preserve">
          <source>Note: Declaring data members with private access specifier is known as &lt;strong&gt;data hiding.&lt;/strong&gt;</source>
          <target state="translated">참고 : 개인용 액세스 지정자를 사용하여 데이터 멤버를 선언하는 것을 &lt;strong&gt;데이터 숨기기라고합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="32500c238248244eb78c9f14aa99e41bd6942ed2" translate="yes" xml:space="preserve">
          <source>Now the confusion arises when it comes to &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">이제 혼란이 &lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 와 관련하여 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf67bd37c73d81bc5307563f78c833d29fe10889" translate="yes" xml:space="preserve">
          <source>Often times I've realized that remembering the basic concepts of any language can made possible by creating real-world analogies. Here is my analogy for understanding access modifiers in Java:</source>
          <target state="translated">종종 나는 어떤 언어의 기본 개념을 기억하는 것이 현실 세계의 비유를 통해 가능해질 수 있다는 것을 깨달았습니다. 다음은 Java의 액세스 수정자를 이해하는 비유입니다.</target>
        </trans-unit>
        <trans-unit id="97a14c4e2738d6c2804656e0a006451d5b27f196" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the parent class and it is &lt;em&gt;inside&lt;/em&gt; the package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;) [This can be included inside context no. 1]:</source>
          <target state="translated">유형이 부모 클래스이고 &lt;code&gt;foo()&lt;/code&gt; 가 정의 된 패키지 &lt;em&gt;내부에&lt;/em&gt; 있는 참조에서 ( &lt;code&gt;fatherpackage&lt;/code&gt; ) [이것은 컨텍스트 번호 안에 포함될 수 있습니다. 1]:</target>
        </trans-unit>
        <trans-unit id="b47a88794e5bc9eb69dfcdd8c1454a1d628c58f2" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the parent class and it is &lt;em&gt;outside&lt;/em&gt; the package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;):</source>
          <target state="translated">유형이 부모 클래스이고 &lt;code&gt;foo()&lt;/code&gt; 가 정의 된 패키지 &lt;em&gt;외부에&lt;/em&gt; 있는 참조에서 ( &lt;code&gt;fatherpackage&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="c64917ce44fe5662d78c50ec0a072083dbcd8daf" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the same class:</source>
          <target state="translated">유형이 동일한 클래스 인 참조에서 :</target>
        </trans-unit>
        <trans-unit id="1735879fe3a2e22b9b283485856a39553a8ac889" translate="yes" xml:space="preserve">
          <source>Only having private constructors also means that the class cannot be subclassed externally, since Java requires a subclass's constructors to implicitly or explicitly call a superclass constructor. (It can, however, contain a nested class that subclasses it.)</source>
          <target state="translated">Java는 서브 클래스의 생성자가 내재적으로 또는 명시 적으로 수퍼 클래스 생성자를 호출해야하므로 개인 생성자 만 있다는 것은 클래스를 외부에서 서브 클래 싱 할 수 없다는 것을 의미합니다. 그러나 하위 클래스를 포함하는 중첩 클래스를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d75774c0f96b6ee44eb6643c9fea71b50b90ea8" translate="yes" xml:space="preserve">
          <source>Order</source>
          <target state="translated">Order</target>
        </trans-unit>
        <trans-unit id="59e00bdab1723eeefe789e083d87acb6847d6733" translate="yes" xml:space="preserve">
          <source>Output: Hello</source>
          <target state="translated">출력 : 안녕하세요</target>
        </trans-unit>
        <trans-unit id="67a5927c5cce6b22e97f84af83e9faa9704ee973" translate="yes" xml:space="preserve">
          <source>Output:Hello</source>
          <target state="translated">Output:Hello</target>
        </trans-unit>
        <trans-unit id="48db52b778fccd255894481994bdacd74ee198b0" translate="yes" xml:space="preserve">
          <source>Over time you'll develop a sense for when to make some classes package-private and when to declare certain methods protected for use in subclasses.</source>
          <target state="translated">시간이 지남에 따라 일부 클래스를 패키지 전용으로 만들 때와 하위 클래스에서 사용하도록 보호 된 특정 메서드를 선언 할시기에 대한 이해가 높아질 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d1fefb5c50582321c4d75309559ed4fb1fb5c62" translate="yes" xml:space="preserve">
          <source>Package Private</source>
          <target state="translated">개인 패키지</target>
        </trans-unit>
        <trans-unit id="02d690f0069219ba265f693b9aa34bc858bc7b64" translate="yes" xml:space="preserve">
          <source>Package Private + can be seen by subclasses or package member.</source>
          <target state="translated">패키지 프라이빗 +는 서브 클래스 또는 패키지 멤버가 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67edadea70b35c0bde5fedf6ce3b8d7307338c28" translate="yes" xml:space="preserve">
          <source>Personally, I stick with just &quot;private&quot; and &quot;public&quot;.  Many OO languages just have that.  &quot;Protected&quot; can be handy, but it's really a cheat.  Once an interface is more than private it's outside of your control and you have to go looking in other people's code to find uses.</source>
          <target state="translated">개인적으로 저는 &quot;개인&quot;과 &quot;공개&quot;만 고집합니다. 많은 OO 언어가 있습니다. &quot;보호&quot;는 편리 할 수 ​​있지만 실제로는 치트입니다. 인터페이스가 개인용 인터페이스보다 많으면 제어 범위를 벗어나므로 다른 사람의 코드를 살펴보고 용도를 ​​찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="b092b192a4d648e172b4a375b0666e778cde5015" translate="yes" xml:space="preserve">
          <source>Please note:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="237dfa0a21c8e17a7276cf161eef7e0fba067c47" translate="yes" xml:space="preserve">
          <source>Private</source>
          <target state="translated">Private</target>
        </trans-unit>
        <trans-unit id="73c2c05c567e0abdbe3ba13d814ebd8d7a054684" translate="yes" xml:space="preserve">
          <source>Private access modifier - private:</source>
          <target state="translated">개인 액세스 수정 자-개인 :</target>
        </trans-unit>
        <trans-unit id="47498edf610d2474479d092eef6b21971a8e54cb" translate="yes" xml:space="preserve">
          <source>Private is not accessible outside the class
Default is accessible only in the package.
Protected in package as well as any class which extends it.
Public is open for all.</source>
          <target state="translated">클래스 외부에서 개인용으로 액세스 할 수 없음 기본값은 패키지에서만 액세스 가능합니다. 패키지와 패키지를 확장하는 클래스로 보호됩니다. 모두에게 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="07dc0891cffa12c73230979cda26f3ea127ced21" translate="yes" xml:space="preserve">
          <source>Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.</source>
          <target state="translated">보호 된 액세스는 서브 클래스가 헬퍼 메소드 또는 변수를 사용할 수있는 기회를 제공하면서 관련이없는 클래스가이를 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="427cebdbe94bd945eeb72a25018bea95d6a0d3e4" translate="yes" xml:space="preserve">
          <source>Protected access modifier - protected:</source>
          <target state="translated">보호 된 액세스 수정 자-보호 :</target>
        </trans-unit>
        <trans-unit id="dc5eb704bbcae1aff4efb71c55461d47767dabe7" translate="yes" xml:space="preserve">
          <source>Public</source>
          <target state="translated">Public</target>
        </trans-unit>
        <trans-unit id="373d5d53b0dab15eec7ea7ad71ce7aec9d662c30" translate="yes" xml:space="preserve">
          <source>Public Protected Default and private are access modifiers.</source>
          <target state="translated">공개 보호 기본값 및 개인은 액세스 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="5df8a0072d803165a9f31208c9db4592974fa499" translate="yes" xml:space="preserve">
          <source>Public access modifier - public:</source>
          <target state="translated">공개 액세스 수정 자-공개 :</target>
        </trans-unit>
        <trans-unit id="483bf2075c12023a5e849d12a42027be89c5e94b" translate="yes" xml:space="preserve">
          <source>Published</source>
          <target state="translated">Published</target>
        </trans-unit>
        <trans-unit id="79337cebe0b8469f44ee26dd522be3c1abbde46b" translate="yes" xml:space="preserve">
          <source>References links</source>
          <target state="translated">참조 링크</target>
        </trans-unit>
        <trans-unit id="23c4f19c70076332ae76378be5204b96f6c98f0f" translate="yes" xml:space="preserve">
          <source>Related Answers</source>
          <target state="translated">관련 답변</target>
        </trans-unit>
        <trans-unit id="56eee76535b8adfa9fe3329a7d09b87c34cc1f70" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/267781/java-class-accessibility&quot;&gt;Java Class Accessibility&lt;/a&gt;</source>
          <target state="translated">관련 : &lt;a href=&quot;https://stackoverflow.com/questions/267781/java-class-accessibility&quot;&gt;Java 클래스 접근성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17d8ed1a776981997da35f245b5fd1b0aca174fa" translate="yes" xml:space="preserve">
          <source>So bottom line is, &lt;strong&gt;protected members can be accessed in other packages, only if some class from this other package, extends class enclosing this protected member and protected member is accessed on 'this' reference or explicit instances of extended class, within definition of extended class.&lt;/strong&gt;</source>
          <target state="translated">따라서 결론은 &lt;strong&gt;보호 된 멤버는이 다른 패키지의 일부 클래스 가이 보호 된 멤버를 둘러싸는 클래스를 확장하고 보호 된 멤버가 확장의 정의 내에서 'this'참조 또는 확장 클래스의 명시 적 인스턴스에서 액세스되는 경우에만 다른 패키지에서 액세스 할 수 있다는 것입니다 수업.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21d3937db339f6e43775069049c209555c9447c1" translate="yes" xml:space="preserve">
          <source>So, rule of thumb is to make things only as visible as they have to be.  Start with private and only add more visibility as needed.  Only make public that which is absolutely necessary for the user to know, every detail you make public cramps your ability to redesign the system.</source>
          <target state="translated">따라서 경험 법칙은 필요한만큼만 표시하는 것입니다. 비공개로 시작하고 필요에 따라 더 많은 가시성을 추가하십시오. 사용자가 알기 위해 꼭 필요한 것을 공개하십시오. 공개 경련을 만드는 모든 세부 사항은 시스템을 재 설계 할 수있는 능력입니다.</target>
        </trans-unit>
        <trans-unit id="154dbc9264721e755cac5da7fa4be2894fd9a2ab" translate="yes" xml:space="preserve">
          <source>Some related questions:</source>
          <target state="translated">몇 가지 관련 질문 :</target>
        </trans-unit>
        <trans-unit id="4b2dc2e152a6049bc5dd339a5aaa36977da34901" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;http://www.trytoprogram.com/cplusplus-programming/access-specifiers/&quot;&gt; Access Specifiers &amp;ndash; Private, Public and Protected
&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;http://www.trytoprogram.com/cplusplus-programming/access-specifiers/&quot;&gt;액세스 지정자 &amp;ndash; 개인, 공개 및 보호&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c03da846ed372f26ddbd2660e72f7d8755c812d7" translate="yes" xml:space="preserve">
          <source>Start with the most restrictive (private) and see if you need less restrictive modifiers later on.</source>
          <target state="translated">가장 제한적인 (비공개)로 시작하여 나중에 덜 제한적인 수정자가 필요한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2db7bd0663d3a295c6b4c5b37588b2c72bf5eb2d" translate="yes" xml:space="preserve">
          <source>Swift access modifiers</source>
          <target state="translated">신속한 액세스 수정 자</target>
        </trans-unit>
        <trans-unit id="d3b8c8a1daa787e5c27587774294ce4f3fd4a1b6" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; access (specified by the absence of a keyword) is also called &lt;a href=&quot;https://stackoverflow.com/questions/5416074/java-package-private-terminology&quot;&gt;&lt;strong&gt;package-private&lt;/strong&gt;&lt;/a&gt;. Exception: in an interface, no modifier means public access; modifiers other than public are forbidden. Enum constants are always public.</source>
          <target state="translated">&quot;기본&quot;액세스 (키워드 부재로 지정)를 &lt;a href=&quot;https://stackoverflow.com/questions/5416074/java-package-private-terminology&quot;&gt;&lt;strong&gt;package-private&lt;/strong&gt;&lt;/a&gt; 라고도 &lt;strong&gt;합니다&lt;/strong&gt; . 예외 : 인터페이스에서 수정자는 공개 액세스를 의미하지 않습니다. public 이외의 수정자는 금지됩니다. 열거 형 상수는 항상 공개입니다.</target>
        </trans-unit>
        <trans-unit id="2586c08972816888f55708f755c54e0e86ec9ba4" translate="yes" xml:space="preserve">
          <source>The access specifiers can be strictly ordered</source>
          <target state="translated">액세스 지정자는 엄격하게 주문할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="df6efd781f79998f9f898aa9e074a442cdff5a02" translate="yes" xml:space="preserve">
          <source>The difference can be found in the links already provided but which one to use usually comes down to the &quot;Principle of Least Knowledge&quot;. Only allow the least visibility that is needed.</source>
          <target state="translated">차이점은 이미 제공된 링크에서 찾을 수 있지만 일반적으로 사용할 링크는 &quot;최소한 지식의 원리&quot;에 있습니다. 필요한 최소한의 가시성 만 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="679e82b3df66656fd5d1f4c9549d8ab9122877e6" translate="yes" xml:space="preserve">
          <source>The first data column indicates whether the class itself has access to
  the member defined by the access level. As you can see, a class always
  has access to its own members. The second column indicates whether
  classes in the same package as the class (regardless of their
  parentage) have access to the member. The third column indicates
  whether subclasses of the class declared outside this package have
  access to the member. The fourth column indicates whether all classes
  have access to the member.</source>
          <target state="translated">첫 번째 데이터 열은 클래스 자체가 액세스 수준으로 정의 된 멤버에 액세스 할 수 있는지 여부를 나타냅니다. 보시다시피 클래스는 항상 자체 멤버에게 액세스 할 수 있습니다. 두 번째 열은 클래스와 동일한 패키지의 클래스 (상위에 관계없이)가 멤버에 액세스 할 수 있는지 여부를 나타냅니다. 세 번째 열은이 패키지 외부에서 선언 된 클래스의 하위 클래스가 멤버에 액세스 할 수 있는지 여부를 나타냅니다. 네 번째 열은 모든 클래스가 멤버에 액세스 할 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c3ef407bfffcf2e4ffd72f9afb533124d421f084" translate="yes" xml:space="preserve">
          <source>The following situations are not valid.</source>
          <target state="translated">다음 상황은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e0ae3808955f5f848f420a39b6f2822eb0679d1" translate="yes" xml:space="preserve">
          <source>The following table shows the access to members permitted by each
  modifier.</source>
          <target state="translated">다음 표는 각 수정자가 허용하는 멤버에 대한 액세스를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6c3b0509347cd9fae8904b92da0d10e55784f19a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;foo()&lt;/code&gt; can be called in 4 contexts:</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 메소드는 4 가지 컨텍스트에서 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d356b3ec320b607fd260202ec32d80a6d8ebd453" translate="yes" xml:space="preserve">
          <source>The most misunderstood access modifier in Java is &lt;code&gt;protected&lt;/code&gt;. We know that it's similar to the default modifier with one exception in which subclasses can see it. But how? Here is an example which hopefully clarifies the confusion:</source>
          <target state="translated">Java에서 가장 오해 된 액세스 수정자는 &lt;code&gt;protected&lt;/code&gt; . 우리는 그것이 서브 클래스가 볼 수있는 한 가지 예외를 제외하고는 기본 수정 자와 유사하다는 것을 알고 있습니다. 그러나 어떻게? 다음은 혼동을 명확하게 설명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="be00e0232f8d8959670788550d4e065b0397435d" translate="yes" xml:space="preserve">
          <source>The protected access modifier cannot be applied to class and interfaces. Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.</source>
          <target state="translated">보호 된 액세스 수정자는 클래스 및 인터페이스에 적용 할 수 없습니다. 메소드, 필드는 보호 된 것으로 선언 될 수 있지만 인터페이스의 메소드 및 필드는 보호 된 것으로 선언 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="169ba09f6c249dafbff995f433c80a45b0644db7" translate="yes" xml:space="preserve">
          <source>They are meant for encapsulation, or hiding and showing contents of the class.</source>
          <target state="translated">그것들은 캡슐화, 또는 수업 내용을 숨기고 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="682ffc8981fc2bc88a6aeadf052aa2ee7fc48504" translate="yes" xml:space="preserve">
          <source>This access is more restricted than public and protected, but less restricted than private.</source>
          <target state="translated">이 액세스는 공용보다 제한적이고 보호되지만 개인보다는 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="ee4eefa591c2b5d729b2fadc0b84fbb3c332905c" translate="yes" xml:space="preserve">
          <source>This is related to Java &lt;a href=&quot;https://en.wikipedia.org/wiki/Access_modifiers&quot;&gt;Access Modifiers&lt;/a&gt;.</source>
          <target state="translated">이것은 Java &lt;a href=&quot;https://en.wikipedia.org/wiki/Access_modifiers&quot;&gt;Access Modifiers&lt;/a&gt; 와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="198b4459a701114bd5c61fdbe1c4faf71ffb4fe3" translate="yes" xml:space="preserve">
          <source>This is where the idea of &quot;published&quot; comes in.  Changing an interface (refactoring it) requires that you find all the code which is using it and change that, too.  If the interface is private, well no problem.  If it's protected you have to go find all your subclasses.  If it's public you have to go find all the code which uses your code.  Sometimes this is possible, for example if you're working on corporate code that's for internal use only it doesn't matter if an interface is public.  You can grab all the code out of the corporate repository.  But if an interface is &quot;published&quot;, if there is code using it outside your control, then you're hosed.  You must support that interface or risk breaking code.  Even protected interfaces can be considered published (which is why I don't bother with protected).</source>
          <target state="translated">여기서는 &quot;게시 됨&quot;이라는 아이디어가 나온다. 인터페이스를 변경 (리팩토링)하려면 인터페이스를 사용하는 모든 코드를 찾아서 변경해야한다. 인터페이스가 개인용이라면 아무 문제가 없습니다. 보호 된 경우 모든 하위 클래스를 찾아야합니다. 공개 된 경우 코드를 사용하는 모든 코드를 찾아야합니다. 예를 들어 내부 용으로 만 사용되는 회사 코드를 작업하는 경우 인터페이스가 공개인지 여부는 중요하지 않은 경우가 있습니다. 회사 리포지토리에서 모든 코드를 가져올 수 있습니다. 그러나 인터페이스가 &quot;게시 된&quot;경우 컨트롤 외부에서 인터페이스를 사용하는 코드가 있으면 문제가 발생합니다. 해당 인터페이스 또는 위험 코드를 지원해야합니다. 보호 된 인터페이스조차 게시 된 것으로 간주 될 수 있습니다 (이로 인해 보호 된 인터페이스가 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="6b5d1e74f2eea7ead15ccf29069baea5d0f69c05" translate="yes" xml:space="preserve">
          <source>This page writes well about the protected &amp;amp; default access modifier</source>
          <target state="translated">이 페이지는 보호 및 기본 액세스 수정 자에 대해 잘 작성합니다.</target>
        </trans-unit>
        <trans-unit id="eeb5424c66259e76273a69d238cdcc3c9e66fd22" translate="yes" xml:space="preserve">
          <source>To access if you are in same package you can access directly, but if you are in another package then you can create an object of the class.</source>
          <target state="translated">동일한 패키지에 있으면 직접 액세스 할 수 있지만 다른 패키지에 있으면 클래스의 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ae94913500b0661223e0efa7a5e7ca28857425" translate="yes" xml:space="preserve">
          <source>To access protected field defined in base class you can create object of child class.</source>
          <target state="translated">기본 클래스에 정의 된 보호 필드에 액세스하려면 하위 클래스의 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad466926d52efdf7885ec86fe714f4f216f7680" translate="yes" xml:space="preserve">
          <source>To access you can create an object of the class. But you can not access this variable outside of the package.</source>
          <target state="translated">액세스하려면 클래스의 객체를 만들 수 있습니다. 그러나 패키지 외부에서는이 변수에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fb58ec9231bc98bca307ae528c066d345048ea9" translate="yes" xml:space="preserve">
          <source>Top level class(first level scope) can be &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt;. &lt;code&gt;Nested class&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/59220181/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt; can have any of them</source>
          <target state="translated">최상위 클래스 (첫 번째 수준 범위)는 &lt;code&gt;public&lt;/code&gt; 및 &lt;code&gt;default&lt;/code&gt; 일 수 있습니다. &lt;code&gt;Nested class&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/59220181/4770877&quot;&gt;&lt;sup&gt;[정보]&lt;/sup&gt;&lt;/a&gt; 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384f7244462f630639626ae0b32c7bdfb001d0ba" translate="yes" xml:space="preserve">
          <source>Using the private modifier is the main way that an object encapsulates itself and hides data from the outside world.</source>
          <target state="translated">전용 수정자를 사용하는 것이 객체가 자신을 캡슐화하고 외부 세계에서 데이터를 숨기는 주요 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ab4e39861714a7bba115c44241b41a0b85300324" translate="yes" xml:space="preserve">
          <source>Variables and methods can be declared without any modifiers that are called. Default examples:</source>
          <target state="translated">변수와 메소드는 호출 된 수정 자없이 선언 될 수 있습니다. 기본 예 :</target>
        </trans-unit>
        <trans-unit id="34077ede14eaaebed19ee0bede3eea6d7f3eb11e" translate="yes" xml:space="preserve">
          <source>Variables that are declared private can be accessed outside the class if public getter methods are present in the class.</source>
          <target state="translated">public getter 메소드가 클래스에있는 경우 private으로 선언 된 변수는 클래스 외부에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a50d48aa080a7c6783e40cbfdb6e97dd79fc57b" translate="yes" xml:space="preserve">
          <source>Variables, methods and constructors which are declared protected in a superclass can be accessed only by the subclasses in another package or any class within the package of the protected members' class.</source>
          <target state="translated">수퍼 클래스에서 보호 된 것으로 선언 된 변수, 메소드 및 생성자는 다른 패키지의 서브 클래스 또는 보호 된 멤버의 클래스 패키지 내의 클래스에 의해서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12f084bc06fb25984a713a05ac96ec8fd8c87e3e" translate="yes" xml:space="preserve">
          <source>Visible outside the code I control.  (While not Java syntax, it is important for this discussion).</source>
          <target state="translated">내가 통제하는 코드 밖에서 볼 수 있습니다. (Java 구문은 아니지만이 토론에서 중요합니다).</target>
        </trans-unit>
        <trans-unit id="14bcee1179ba8505e906f60fb57592380df65a40" translate="yes" xml:space="preserve">
          <source>Visible to the class only (&lt;strong&gt;private&lt;/strong&gt;).</source>
          <target state="translated">수업 만 볼 수 있습니다 ( &lt;strong&gt;private&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f09f62b5791cfabbdd6e4c34df55d9bdb437435" translate="yes" xml:space="preserve">
          <source>Visible to the package and all subclasses (&lt;strong&gt;protected&lt;/strong&gt;).</source>
          <target state="translated">패키지 및 모든 하위 클래스에 표시됩니다 ( &lt;strong&gt;protected&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="54ef9402017fe93855f3b30d829bfd206f6e7f50" translate="yes" xml:space="preserve">
          <source>Visible to the package. The default. No modifiers are needed.</source>
          <target state="translated">패키지에 표시됩니다. 기본값입니다. 수정자가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca587ffd93b05980f46dc7a85340bbf8390ffe51" translate="yes" xml:space="preserve">
          <source>Visible to the world (&lt;strong&gt;public&lt;/strong&gt;).</source>
          <target state="translated">세계에 &lt;strong&gt;공개&lt;/strong&gt; ( &lt;strong&gt;공개&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="546b60f326b8d6a60c507410a570c1777530716c" translate="yes" xml:space="preserve">
          <source>We all use method and member modifiers like private, public, ... but one thing too few developers do is use packages to &lt;strong&gt;organize&lt;/strong&gt; code logically.</source>
          <target state="translated">우리는 모두 private, public과 같은 메소드와 멤버 수정자를 사용하지만 너무 적은 개발자는 패키지를 사용하여 코드를 논리적으로 &lt;strong&gt;구성&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0e9aa520836ae4a575fd28c23d90b4382f8165ec" translate="yes" xml:space="preserve">
          <source>We cannot Override the Static fields.if you try to override it does not show any error 
but it doesnot work what we except.</source>
          <target state="translated">정적 필드를 재정의 할 수 없습니다. 재정의하려고하면 오류가 표시되지 않지만 제외하고는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e35308834027bed876c4f7f710ec90003c87538e" translate="yes" xml:space="preserve">
          <source>What access specifiers apply to</source>
          <target state="translated">액세스 지정자가 적용되는 대상</target>
        </trans-unit>
        <trans-unit id="d80aa50837cce957e5ce3fb6bafde8063b8ddb68" translate="yes" xml:space="preserve">
          <source>What is the difference between public, protected, package-private and private in Java</source>
          <target state="translated">Java에서 공개, 보호, 패키지 개인 및 개인의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b46b79fb2f1824c3f83b93eb49daf91f0e91d07b" translate="yes" xml:space="preserve">
          <source>When exposing members ask yourself if you are exposing representation choices or abstraction choices. The first is something you want to avoid as it will introduce too many dependencies on the actual representation rather than on its observable behavior.</source>
          <target state="translated">멤버를 노출시킬 때 표현 선택이나 추상화 선택을 노출하는지 스스로에게 물어보십시오. 첫 번째는 관찰 할 수있는 행동보다는 실제 표현에 너무 많은 의존성을 유발하므로 피하고 싶은 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2edee9f094279931ccc7f4853b4b3611fed2c3b" translate="yes" xml:space="preserve">
          <source>When should you use what?  The whole idea is encapsulation to hide information.  As much as possible you want to hide the detail of how something is done from your users.  Why?  Because then you can change them later and not break anybody's code.  This lets you optimize, refactor, redesign and fix bugs without worry that someone was using that code you just overhauled.</source>
          <target state="translated">언제 무엇을 사용해야합니까? 전체 아이디어는 정보를 숨기는 캡슐화입니다. 가능한 한 사용자가 수행 한 작업에 대한 세부 정보를 숨기려고합니다. 왜? 따라서 나중에 변경할 수 있으며 다른 사람의 코드를 어 기지 않아도됩니다. 이를 통해 방금 개조 한 코드를 누군가가 사용하고 있다는 걱정없이 버그를 최적화, 리팩토링, 재 설계 및 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79af6581bf04a23396460cd17b21987c89702dec" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, then you should use protected access specifier for data member within Class1 if you don't want this member to be accessed outside your package (say in package of consumer of your package i.e. client who is using your APIs) in general, but you want to make an exception and allow access to this member only if client writes class say Class2 that extends Class1. So, in general, protected members will be accessible on 'this' reference in derived classes i.e. Class2 and also on explicit instances of Class2.</source>
          <target state="translated">패키지와 클래스 내의 클래스 (예 : Class1)를 개발할 때 패키지 외부에서이 멤버에 액세스하지 않으려면 Class1 내의 데이터 멤버에 대해 보호 된 액세스 지정자를 사용해야합니다. 패키지 (예 : API를 사용하는 클라이언트)). 그러나 클라이언트가 Class1을 확장하는 Class2라고 말하는 클래스를 작성하는 경우에만 예외를 만들고이 멤버에 대한 액세스를 허용하려고합니다. 따라서 일반적으로 보호 된 멤버는 파생 클래스 (예 : Class2) 및 명시적인 Class2 인스턴스에서 'this'참조로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027f6037ffd06215488adde61c7e586ebdeedc8b" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, then you should use public access specifier for data member within Class1 if you want this member to be accessible in other packages on instance of Class1 created in some class of other package. &lt;strong&gt;Basically this access specifier should be used when you intent to expose your data member to world without any condition.&lt;/strong&gt;</source>
          <target state="translated">패키지를 개발할 때 클래스 (클래스 1과 같은 클래스)를 개발할 때 다른 클래스의 클래스에서 작성된 클래스 1 인스턴스의 다른 패키지에서이 멤버에 액세스 할 수있게하려면 클래스 1 내의 데이터 멤버에 대해 공개 액세스 지정자를 사용해야합니다. 꾸러미. &lt;strong&gt;기본적으로이 액세스 지정자는 조건없이 데이터 멤버를 월드에 노출하려는 경우에 사용해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de23e22099f028dd172f317f3ef75423c6e9cb8a" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, you may use default (need not be mentioned explicitly) access specifier, to expose member within class, to other classes within your (same) package. In these other classes (within same package), you can access these default members on instance of Class1. Also you can access these default members within subclasses of Class1, say Class2 (on this reference or on instance of Class1 or on instance of Class2).</source>
          <target state="translated">패키지를 개발할 때 클래스 (예 : Class1)에 클래스 (예 : 명시 적으로 언급되지 않음) 액세스 지정자를 사용하여 클래스 내의 멤버를 (동일한) 패키지 내의 다른 클래스에 공개 할 수 있습니다. 이러한 다른 클래스 (같은 패키지 내)에서 Class1 인스턴스의 기본 멤버에 액세스 할 수 있습니다. 또한 Class1의 하위 클래스 내에서 Class2와 같은 기본 멤버에 액세스 할 수 있습니다 (이 참조 또는 Class1 인스턴스 또는 Class2 인스턴스).</target>
        </trans-unit>
        <trans-unit id="ab5f7c5da1e908785059d10eee82f660fd70e889" translate="yes" xml:space="preserve">
          <source>When you are thinking of access modifiers just think of it in this way (applies to both &lt;strong&gt;variables&lt;/strong&gt; and &lt;strong&gt;methods&lt;/strong&gt;):</source>
          <target state="translated">액세스 수정자를 생각할 때 다음과 같이 생각하십시오 ( &lt;strong&gt;변수&lt;/strong&gt; 와 &lt;strong&gt;메소드&lt;/strong&gt; 모두에 적용).</target>
        </trans-unit>
        <trans-unit id="b2cf35e176192eaa161d1a6d979b561f22449218" translate="yes" xml:space="preserve">
          <source>When you bring him to the campus, the first thing that you and your friend sees is this statue. This means that anyone who walks in the campus can look at the statue without the university's permission. This makes the statue as &lt;strong&gt;PUBLIC&lt;/strong&gt;.</source>
          <target state="translated">당신이 그를 캠퍼스로 데려 올 때, 당신과 당신의 친구가 가장 먼저 보는 것은이 조각상입니다. 이것은 캠퍼스를 걷는 사람은 대학의 허락없이 동상을 볼 수 있음을 의미합니다. 이것은 동상을 &lt;strong&gt;PUBLIC으로&lt;/strong&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9733e2040efa0c9d4a97d71582ab64f36a523dfc" translate="yes" xml:space="preserve">
          <source>When you write another class Class3 within same/different package
that extends Class2, protected member from Class1 will be accessible
on this reference and also on explicit instance of Class3. This will
be true for any hierarchy that is extended i.e. protected member
will still be accessible on this reference or instance of extended
class. Note that in Class3, if you create instance of Class2 then
you will not be able to access protected member from Class1 though
it is inherited.</source>
          <target state="translated">Class2를 확장하는 동일 / 다른 패키지 내에 다른 클래스 Class3을 작성하면 Class1의 보호 된 멤버는이 참조 및 명시 적 Class3 인스턴스에 액세스 할 수 있습니다. 이것은 확장 된 모든 계층에 적용됩니다. 즉, 보호 된 멤버는이 참조 또는 확장 클래스 인스턴스에서 계속 액세스 할 수 있습니다. Class3에서 Class2의 인스턴스를 만들면 상속 된 클래스 1에서 보호 된 멤버에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7db19bf48ccf8618b8d48b1bccd529b75f5e1638" translate="yes" xml:space="preserve">
          <source>Which modifier to choose?</source>
          <target state="translated">어떤 수정자를 선택해야합니까?</target>
        </trans-unit>
        <trans-unit id="78394873daaf3ca1c582b2022bd91ff90bffcfbf" translate="yes" xml:space="preserve">
          <source>You also have to consider &lt;em&gt;nested&lt;/em&gt; scopes, such as inner classes. An example of the complexity is that inner classes have members, which themselves can take access modifiers. So you can have a private inner class with a public member; can the member be accessed? (See below.) The general rule is to look at scope and think recursively to see whether you can access each level.</source>
          <target state="translated">내부 클래스와 같은 &lt;em&gt;중첩&lt;/em&gt; 범위도 고려해야합니다. 복잡한 예는 내부 클래스에 멤버가 있으며이 멤버 자체는 액세스 수정자를 사용할 수 있습니다. 그래서 당신은 공개 멤버와 개인 내부 수업을 가질 수 있습니다; 회원에게 액세스 할 수 있습니까? (아래 참조) 일반적인 규칙은 범위를보고 재귀 적으로 생각하여 각 수준에 액세스 할 수 있는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a9833145068de24bf1a54b7ae1bbaa1ff417a9d" translate="yes" xml:space="preserve">
          <source>You need access to a constructor to construct an object. Thus if all constructors are private, the class can only be constructed by code living within the class (typically static factory methods or static variable initializers). Similarly for package-private or protected constructors.</source>
          <target state="translated">객체를 생성하려면 생성자에 액세스해야합니다. 따라서 모든 생성자가 private 인 경우 클래스는 클래스 내에 존재하는 코드 (일반적으로 정적 팩토리 메서드 또는 정적 변수 이니셜 라이저)만으로 구성 할 수 있습니다. 패키지 개인 또는 보호 된 생성자의 경우와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="13ebc736719c7b0ac170a13671dcbca61014c961" translate="yes" xml:space="preserve">
          <source>You won't be able to access inherited protected member of Class1 in
Class2, if you attempt to access it on explicit instance of Class1,
although it is inherited in it.</source>
          <target state="translated">Class1의 명시 적 인스턴스에서 상속하려고하더라도 Class2의 상속 된 보호 된 멤버에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0342c9aebe9dfc86b2722a15889bef207a17eb8e" translate="yes" xml:space="preserve">
          <source>Your friend wants to login to the campus WiFi but doesn't have the any credentials to do so. The only way he can get online is if you share your login with him. (Remember, every student who goes to the university also possesses these login credentials). This would make your login credentials as &lt;strong&gt;NO MODIFIER&lt;/strong&gt;.</source>
          <target state="translated">친구가 캠퍼스 WiFi에 로그인하려고하지만 자격 증명이 없습니다. 그가 온라인에 접속할 수있는 유일한 방법은 로그인 정보를 공유하는 것입니다. (대학에 진학하는 모든 학생도이 로그인 자격 증명을 가지고 있음을 기억하십시오). 이것은 로그인 자격 증명을 &lt;strong&gt;NO MODIFIER로&lt;/strong&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="0c6a031212fa407e33d1f50ffda6a1bf40baaa82" translate="yes" xml:space="preserve">
          <source>default (no modifier specified): accessible by the classes of the same package.</source>
          <target state="translated">기본값 (수정자가 지정되지 않음) : 동일한 패키지의 클래스에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fa1dc60398c6bcdee08aa6c839a166432e015b" translate="yes" xml:space="preserve">
          <source>default (package)</source>
          <target state="translated">기본 (패키지)</target>
        </trans-unit>
        <trans-unit id="81d4e9552c19ab8c332c76804f094d59bfe0653c" translate="yes" xml:space="preserve">
          <source>meaning that &lt;code&gt;public&lt;/code&gt; provides the most access, &lt;code&gt;private&lt;/code&gt; the least. Any reference possible on a private member is also valid for a package-private member; any reference to a package-private member is valid on a protected member, and so on. (Giving access to protected members to other classes in the same package was considered a mistake.)</source>
          <target state="translated">즉, &lt;code&gt;public&lt;/code&gt; 이 가장 많이 액세스하고 &lt;code&gt;private&lt;/code&gt; 은 가장 적게 액세스합니다. 개인 구성원에 대해 가능한 모든 참조는 패키지 개인 구성원에게도 유효합니다. 패키지 전용 멤버에 대한 모든 참조는 보호 된 멤버 등에서 유효합니다. (동일한 패키지의 보호 된 멤버에게 다른 클래스에 대한 액세스 권한을 부여하는 것은 실수로 간주되었습니다.)</target>
        </trans-unit>
        <trans-unit id="e80721793c24ae14edfca9b26ad406a9815cd3ff" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>
        </trans-unit>
        <trans-unit id="964cab4bb4a5111731b0c00dbb43f794698d8731" translate="yes" xml:space="preserve">
          <source>protected</source>
          <target state="translated">protected</target>
        </trans-unit>
        <trans-unit id="61c9b2b17db77a27841bbeeabff923448b0f6388" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>
        </trans-unit>
        <trans-unit id="10aa8b2ec5bd3e37ab9afc32631742bf8b2f7f90" translate="yes" xml:space="preserve">
          <source>public &amp;gt; protected &amp;gt; package-private &amp;gt; private</source>
          <target state="translated">공개&amp;gt; 보호&amp;gt; 패키지 개인&amp;gt; 개인</target>
        </trans-unit>
        <trans-unit id="04e4d31337d73d519a701e0100bf1767c9be25cc" translate="yes" xml:space="preserve">
          <source>then we have this simple table:</source>
          <target state="translated">이 간단한 테이블이 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
