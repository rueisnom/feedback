<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/215497">
    <body>
      <group id="215497">
        <trans-unit id="9c3a7eb169356df9222bd586b22d0df4e9a13f8c" translate="yes" xml:space="preserve">
          <source>(Caveat:  I am not a Java programmer, I am a Perl programmer.  Perl has no formal protections which is perhaps why I understand the problem so well :) )</source>
          <target state="translated">注意:我不是Java程序员,我是Perl程序员。Perl没有正式的保护措施,这也许是我对这个问题理解得很好的原因:))</target>
        </trans-unit>
        <trans-unit id="0a36612cffe057499a0611c73fed1aa932c69c44" translate="yes" xml:space="preserve">
          <source>....
Protected: Protected access modifier is the a little tricky and you can say is a superset of the default access modifier. Protected members are same as the default members as far as the access in the same package is concerned. The difference is that, the protected members are also accessible to the subclasses of the class in which the member is declared which are outside the package in which the parent class is present.</source>
          <target state="translated">....受保护的....。受保护的访问修改器是一个有点棘手的修改器,可以说是默认访问修改器的超集。受保护的成员和默认成员在同一个包中的访问是一样的。不同的是,受保护的成员也可以访问该成员所声明的类的子类,而这些子类不在父类所在的包中。</target>
        </trans-unit>
        <trans-unit id="bb129938f682e401003e1aed2ed4b40494353513" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;The official tutorial&lt;/a&gt; may be of some use to you.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;官方教程&lt;/a&gt;可能对您有用。</target>
        </trans-unit>
        <trans-unit id="a40d787e477845abe3af3bd4319e70db8b848c65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&lt;/a&gt;&lt;a href=&quot;http://www.tutorialspoint.com/java/java_access_modifiers.htm&quot;&gt;http://www.tutorialspoint.com/java/java_access_modifiers.htm&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&lt;/a&gt;&lt;a href=&quot;http://www.tutorialspoint.com/java/java_access_modifiers.htm&quot;&gt;http://www.tutorialspoint.com/java/java_access_modifiers.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c31ee98b0e56e1e2ad44c152f3835eb79ef6b74d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/676930/private-member-access-java&quot;&gt;A class's methods &lt;em&gt;are&lt;/em&gt; allowed to access private members of other objects of the same class.&lt;/a&gt; More precisely, a method of class C can access private members of C on objects of any subclass of C. Java doesn't support restricting access by instance, only by class. (Compare with Scala, which does support it using &lt;code&gt;private[this]&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/676930/private-member-access-java&quot;&gt;允许类的方法访问同一类其他对象的私有成员。&lt;/a&gt; 更准确地说，类C的方法可以访问C的任何子类的对象上的C的私有成员。Java不支持仅按类限制实例的访问。 （与Scala比较，后者确实使用 &lt;code&gt;private[this]&lt;/code&gt; 支持它。）</target>
        </trans-unit>
        <trans-unit id="8f7f1dc8bc472b94392e3bd3ed6215989161afa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; (or &lt;code&gt;package-private&lt;/code&gt;): package scope.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; （或 &lt;code&gt;package-private&lt;/code&gt; ）：包范围。</target>
        </trans-unit>
        <trans-unit id="3d298ea01eb1875fcce90ecc58ed559377bd324e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; --&amp;gt; No access modifier keyword is present. This means it is available strictly within the package of the class. &lt;strong&gt;Nowhere&lt;/strong&gt; outside that package it can be accessed.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; -&amp;gt;不存在访问修饰符关键字。 这意味着它只能在该类的包中使用。 在该软件包之外的&lt;strong&gt;任何&lt;/strong&gt;地方都无法访问它。</target>
        </trans-unit>
        <trans-unit id="632f0c7f906968661339fb461c45f7088fc72706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; is not apply to package hierarchy</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 不适用于包层次结构</target>
        </trans-unit>
        <trans-unit id="ad079c92642a022565d1ecd33455b4303c1a0f85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; --&amp;gt; accessible only within the same class where it is declared</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; - &amp;gt;仅在声明它的同一个类中可访问</target>
        </trans-unit>
        <trans-unit id="9f1519bd1834a636bcfd85562fc722c65063bd03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: accessible within the same class only.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; ：只能在同一个类中访问。</target>
        </trans-unit>
        <trans-unit id="463f7217c25ecb5d72756d802aad36eb4f6fe8b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: class scope.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; ：类范围。</target>
        </trans-unit>
        <trans-unit id="af2e4fa6e526002b3cd89f765ab0e780189d733b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; --&amp;gt; Slightly less stricter than &lt;code&gt;default&lt;/code&gt; and apart from the same package classes it can be accessed by sub classes outside the &lt;em&gt;package&lt;/em&gt; it is declared.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; - &amp;gt;严格程度低于 &lt;code&gt;default&lt;/code&gt; ，除了相同的包类外，声明的&lt;em&gt;包&lt;/em&gt;外的子类也可以访问它。</target>
        </trans-unit>
        <trans-unit id="c5a581c238cfb204babe7a22d7bc46e3fa3256dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: &lt;code&gt;package scope + child&lt;/code&gt; (like package, but we can subclass it from different packages). The protected modifier always keeps the &quot;parent-child&quot; relationship.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; ： &lt;code&gt;package scope + child&lt;/code&gt; （类似于包，但是我们可以从不同的包中将其子类化）。 protected修饰符始终保持&amp;ldquo;父子&amp;rdquo;关系。</target>
        </trans-unit>
        <trans-unit id="910fdd220b274308d3d2344d80bf0070904f5aa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: accessible by the classes of the same package and the subclasses residing in any package.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; ：可以由同一软件包的类以及任何软件包中的子类访问。</target>
        </trans-unit>
        <trans-unit id="050d466202fbb4d01a4953aeadb3468653e9d848" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; --&amp;gt; accessible from every where</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; -&amp;gt;从任何地方均可访问</target>
        </trans-unit>
        <trans-unit id="0a072f8abd92b9840a119d8fd2cb36807b61f4b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;: accessible from everywhere.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; ：从任何地方均可访问。</target>
        </trans-unit>
        <trans-unit id="a9e5f72177dfd12fd5219a4e1db9d66c86b32aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;: everywhere.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; ：无处不在。</target>
        </trans-unit>
        <trans-unit id="cd953930c2c863ea399304a3c30036133536f2ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A class, method, constructor, interface etc declared public can be accessed from any other class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;可以从任何其他类访问已声明为公共的类，方法，构造函数，接口等。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be09917e70f565d8c708abe4cd6e61635b34eda0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A variable or method declared without any access control modifier is available to any other class in the same package. The fields in an interface are implicitly public static final and the methods in an interface are by default public.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;声明为没有任何访问控制修饰符的变量或方法可用于同一包中的任何其他类。&lt;/em&gt; &lt;em&gt;接口中的字段是隐式的public static final，而接口中的方法默认情况下是public。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee011cda99cb49527b83f0a5b8919102a1698c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;由于类继承，类的所有公共方法和变量均由其子类继承。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad348a2083c2d62016b21c1d255f3de23fa10b04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class and Interface&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;类和接口&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eaf0f2821bca046e8de9d5d37c914cacefc406cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Default access modifier means we do not explicitly declare an access modifier for a class, field, method, etc.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;默认访问修饰符意味着我们不会为类，字段，方法等显式声明访问修饰符。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb32cde4a8fce643003f72d2e1ba00918148a8da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Different Packages&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;不同包装&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d207fca631fc5ab4283a1e1cfa2b49aaaa7a4fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However if the public class we are trying to access is in a different package, then the public class still need to be imported.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;但是，如果我们尝试访问的公共类位于不同的包中，则仍然需要导入公共类。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed9665876783be76d2d202971e92d2ede6dcd26f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods, Variables and Constructors that are declared private can only be accessed within the declared class itself.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;声明为私有的方法，变量和构造函数只能在声明的类本身内访问。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c601c4a206533aa7d299807e34c12f78d76e7236" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;方法，字段可以声明为受保护，但是接口中的方法和字段不能声明为受保护。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="607c9d99976709c606c4f88193f8de1144d0b2fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Private access modifier is the most restrictive access level. Class and interfaces cannot be private.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;专用访问修饰符是最严格的访问级别。&lt;/em&gt; &lt;em&gt;类和接口不能是私有的。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9080a57bc2a9fbd0bde174c2cd9cfb1cc3d4e8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;受保护的访问使子类有机会使用helper方法或变量，同时防止无关的类尝试使用它。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e00422beb6d4fb1981562f55a7072acc71253369" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The protected access modifier cannot be applied to class and interfaces.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;受保护的访问修饰符不能应用于类和接口。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9e9bd71728a515b974c723b972dd81ff4a911f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Therefore fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java Universe.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;因此，可以从属于Java Universe的任何类中访问在公共类内声明的字段，方法，块。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65b8ac6a51801d8f9df0125860bf27145bcd2152" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Variables that are declared private can be accessed outside the class if public getter methods are present in the class.
Variables, methods and constructors which are declared protected in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果类中存在公共获取方法，则可以在类外部访问声明为私有的变量。&lt;/em&gt; &lt;em&gt;在超类中声明为受保护的变量，方法和构造函数只能由其他包中的子类或受保护成员类的包中的任何类访问。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dfafa3f02ac99007413a76b7fa0132f54e95264" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Within the same Packages&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;在同一包装内&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c98ea408dc0e335456b8bc359e5f6e6688da4fb9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class can be package-private. It can only be accessible from same package. Not from sub package, not from outside package.</source>
          <target state="translated">&lt;em&gt;class-&amp;gt;&lt;/em&gt;顶级类可以是包私有的。 只能从同一软件包访问它。 不是来自子包，不是来自外部包。</target>
        </trans-unit>
        <trans-unit id="9a2f5c5e06678e57a12196a656cbc25665cdfb9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class cannot be private. inner classes can be private which are accessible from same class.</source>
          <target state="translated">&lt;em&gt;class-&amp;gt;&lt;/em&gt;顶级类不能为私有。 内部类可以是私有的，可以从同一类访问。</target>
        </trans-unit>
        <trans-unit id="49557558779971098b1beab7b3aca3d6045daa29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class cannot be protected.</source>
          <target state="translated">&lt;em&gt;class-&amp;gt;&lt;/em&gt;顶级类不能被保护。</target>
        </trans-unit>
        <trans-unit id="d03616909ff20fb6283b735f101a6bbb643bb3eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; accessible from package/subpackage/another package</source>
          <target state="translated">&lt;em&gt;类-&amp;gt;&lt;/em&gt;可从包/子包/另一个包访问</target>
        </trans-unit>
        <trans-unit id="c9e263282cf692bb34eb4b225c833709b4cf7edc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; Only accessible in same package or subpackage. Can only be access outside the package while extending class.</source>
          <target state="translated">&lt;em&gt;实例变量-&amp;gt;&lt;/em&gt;仅可在同一包或子包中访问。 扩展类时只能在包外部访问。</target>
        </trans-unit>
        <trans-unit id="96c7893be4597454db4583a10a583947d4674561" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible from package/subpackage/another package</source>
          <target state="translated">&lt;em&gt;实例变量-&amp;gt;&lt;/em&gt;可从包/子包/另一个包访问</target>
        </trans-unit>
        <trans-unit id="026e2611c853bf535859a5b5903a3be7acf05507" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible from same package. Not from sub package, not from outside package.</source>
          <target state="translated">&lt;em&gt;实例变量-&amp;gt;&lt;/em&gt;可从同一包访问。 不是来自子包，不是来自外部包。</target>
        </trans-unit>
        <trans-unit id="173b1d875a31dfc5921965ffcf90d681aa11e6a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible only in the class. Cannot access outside the class.</source>
          <target state="translated">&lt;em&gt;实例变量-&amp;gt;&lt;/em&gt;仅在类中可访问。 无法在课程外访问。</target>
        </trans-unit>
        <trans-unit id="5f686cfad1f0d2953f73e22512646f451cc92170" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(D)irect&lt;/strong&gt; (invoke from a method inside the same class, or via &quot;this&quot; syntax).</source>
          <target state="translated">&lt;strong&gt;（D）irect&lt;/strong&gt; （从同一类内部的方法调用，或通过&amp;ldquo; this&amp;rdquo;语法调用）。</target>
        </trans-unit>
        <trans-unit id="2f0ba70dae68262e43e56b87dcf8848fd89d6328" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(I)nheritance&lt;/strong&gt; (via subclassing).</source>
          <target state="translated">&lt;strong&gt;（I）继承&lt;/strong&gt; （通过子类化）。</target>
        </trans-unit>
        <trans-unit id="37f3255a916c82622528f7b0e38edaeecd6e05d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(R)eference&lt;/strong&gt; (invoke a method using a reference to the class, or via &quot;dot&quot; syntax).</source>
          <target state="translated">&lt;strong&gt;（R）&lt;/strong&gt;引用（使用对类的引用或通过&amp;ldquo;点&amp;rdquo;语法调用方法）。</target>
        </trans-unit>
        <trans-unit id="d47c24704c2b9863e2e3ea5d7687a108717bebe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Default:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.默认值：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e866b80161e29b930ff930217326b95750c6bf3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Public&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.公开&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c5b5405bad9144f153406167830cfeaa7599707" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Private&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.私人的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aedac4ee80eebec26a1eb8895f25fc3e9ab66966" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Protected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.受保护&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10ae501fbb4b985b6a4a6387afbed4b6c308d6df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cb1729758cbd3ed754ecb8b9228916334559d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Access modifiers in Java.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java中的访问修饰符。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1448cd0adc12ffa3db85751d7d788972e1ab2fad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basically, within same package you can access default members on instance of class directly or on 'this' reference in subclasses.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基本上，在同一包中，您可以直接访问类实例的默认成员，也可以访问子类中的&amp;ldquo; this&amp;rdquo;引用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85289d4bbd59b9fc93e676b9dd9d70acb4cca817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default (no modifier)&lt;/strong&gt;: Limited access to class and package</source>
          <target state="translated">&lt;strong&gt;默认值（无修饰符）&lt;/strong&gt; ：限制访问类和包</target>
        </trans-unit>
        <trans-unit id="a1878f65fb532348cd1105c6341d17ed1f134691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default -No keyword:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;默认-无关键字：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b04f00e04bc38cbb526378ea597f7474886dbd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default:&lt;/strong&gt; It is accessible in the same package from any of the class of package.</source>
          <target state="translated">&lt;strong&gt;默认值：&lt;/strong&gt;可以从同一类软件包中的任何软件包类别访问它。</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41b7f6e44695c115445cfdf86e3775318ae5636a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overriding static methods in java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;覆盖Java中的静态方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c1f15f4ebb983532fb274e28770fe57bde1d4d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package-private (default)&lt;/strong&gt;:
This access specifier will provide access specified by private access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;Package-private（默认）&lt;/strong&gt; ：此访问说明符将提供私有访问说明符指定的访问权限，除了以下所述的访问权限。</target>
        </trans-unit>
        <trans-unit id="2394388ff716cba591b2a38592dcfb0fc54be273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private:&lt;/strong&gt;  it can be access in same class.</source>
          <target state="translated">&lt;strong&gt;私有：&lt;/strong&gt;可以在同一班级访问。</target>
        </trans-unit>
        <trans-unit id="d0ded9f3e89154a12e4907eb9238a15f78247f90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Private&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cb9f56d3c4fd96b6c4e794bc32a4d40c75f7676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;:
When you are developing some class and you want member of this class not to be exposed outside this class then you should declare it as private. private members can be accessed only in class where they are defined i.e. enclosing class. &lt;strong&gt;private members can be accessed on 'this' reference and also on other instances of class enclosing these members, but only within the definition of this class.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;私有的&lt;/strong&gt; ：当您开发某个类时，如果您不想让该类的成员暴露于此类之外，则应将其声明为私有。 私有成员只能在定义了私有成员的类（即封闭类）中访问。 &lt;strong&gt;私有成员可以在&amp;ldquo; this&amp;rdquo;引用以及包含这些成员的类的其他实例上访问，但只能在此类的定义内。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d034dfbbb5bc7f21cf96cfb8f1346e544c26d94d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;: Limited access to class only</source>
          <target state="translated">&lt;strong&gt;私人的&lt;/strong&gt; ：仅限上课的权限</target>
        </trans-unit>
        <trans-unit id="8695d4960b797f2b6f67e904191eb903c43e1aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected:&lt;/strong&gt; you can access variables in same package as well as subclass in any other package.
so basically it is &lt;strong&gt;default + Inherited&lt;/strong&gt; behavior.</source>
          <target state="translated">&lt;strong&gt;受保护：&lt;/strong&gt;您可以访问同一包中的变量以及任何其他包中的子类。 所以基本上它是&lt;strong&gt;默认+继承&lt;/strong&gt;行为。</target>
        </trans-unit>
        <trans-unit id="1cc4ba9e4e89686db9f53e13fd8b66ac42177424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Protected&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d10a4c31137ee8169148752120d940b936bc3f24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected&lt;/strong&gt;: Limited access to class, package and subclasses (both inside and outside package)</source>
          <target state="translated">&lt;strong&gt;受保护的&lt;/strong&gt; ：限制访问类，包和子类（包的内部和外部）</target>
        </trans-unit>
        <trans-unit id="09bfe678952f0c3d0b3e5646e875cdb224ae65c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public:&lt;/strong&gt; It is basically as simple as you can access from any class whether that is in same package or not.</source>
          <target state="translated">&lt;strong&gt;公共：&lt;/strong&gt;基本上，您可以从任何类（无论是否在同一包中）进行访问而变得如此简单。</target>
        </trans-unit>
        <trans-unit id="daf97633cf021dedd039ac3d7f17e15721760df8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Public&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ef6e4673df9ec5787ab0c659ebd27e9c95e224b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public&lt;/strong&gt;: Accessible to class, package (all), and subclasses... In short, everywhere.</source>
          <target state="translated">&lt;strong&gt;Public&lt;/strong&gt; ：可访问类，包（所有）和子类...简而言之，无处不在。</target>
        </trans-unit>
        <trans-unit id="3ea3436ff46ae8818a665ddb071efa68994538cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default&lt;/strong&gt; - accessible from package.</source>
          <target state="translated">&lt;strong&gt;默认&lt;/strong&gt; -可从包访问。</target>
        </trans-unit>
        <trans-unit id="5b4cfa6911291d8ddc421bedd52ed7d82f9ee73d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;package-private:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;package-private:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c53c0e830d80b72103ef701f9080f24a7d1a99a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;private:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;private:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d91069bf7a48c4c4d6a00bfe7860b6cbc143d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;private&lt;/strong&gt; - accessible from its class only.</source>
          <target state="translated">&lt;strong&gt;私有&lt;/strong&gt; -仅可从其类访问。</target>
        </trans-unit>
        <trans-unit id="afe8465ac8ccd97429f85b76250e88d3dfed7a2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;protected:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2bed00fc75e7d51b53be0dee63c249e4a93a6e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected&lt;/strong&gt; - accessible from package and sub-classes in other package.
as well</source>
          <target state="translated">&lt;strong&gt;受保护&lt;/strong&gt; -可从其他包中的包和子类访问。 以及</target>
        </trans-unit>
        <trans-unit id="7056cef6786f8cf6365723485c784d324755daf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected&lt;/strong&gt;:
This access specifier will provide access specified by package-private access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;protected&lt;/strong&gt; ：除了以下描述的访问之外，此访问说明还将提供由程序包专用访问说明指定的访问。</target>
        </trans-unit>
        <trans-unit id="31d169cdb7e077cb9bf36e76bd03f5556f7d9daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;public:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f45ba4381db9194fc2431928eb13db0ea7fad3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt; - accessible from anywhere in the application.</source>
          <target state="translated">&lt;strong&gt;公共&lt;/strong&gt; -可从应用程序中的任何位置访问。</target>
        </trans-unit>
        <trans-unit id="c79deadce74e410ea5f7108d88f579a381133846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt;: This access specifier will provide access specified by protected access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;public&lt;/strong&gt; ：除了以下描述的访问之外，此访问说明还将提供受保护的访问说明所指定的访问。</target>
        </trans-unit>
        <trans-unit id="d36eb0da54971756790f3d446942c6a1a8ca6054" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(*) &lt;a href=&quot;https://stackoverflow.com/questions/28612420/what-is-encapsulation-exactly&quot;&gt;What is Encapsulation exactly?&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（*） &lt;a href=&quot;https://stackoverflow.com/questions/28612420/what-is-encapsulation-exactly&quot;&gt;封装到底是什么？&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="69e4829657ddc7c46d77dc0bc935268a8736ae11" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;void saveGame(File dst)&lt;/code&gt; method which is called from the GUI code should be public.</source>
          <target state="translated">从GUI代码调用的 &lt;code&gt;void saveGame(File dst)&lt;/code&gt; 方法应该是公共的。</target>
        </trans-unit>
        <trans-unit id="5a1965065a3a72db5cb5bbc47bad12cce01c8893" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;private&lt;/strong&gt; member (&lt;code&gt;i&lt;/code&gt;) is &lt;em&gt;only&lt;/em&gt; accessible within the same class as it is declared.</source>
          <target state="translated">&lt;strong&gt;私有&lt;/strong&gt;成员（ &lt;code&gt;i&lt;/code&gt; ） &lt;em&gt;仅&lt;/em&gt;可在声明的同一个类中访问。</target>
        </trans-unit>
        <trans-unit id="c567cfcccb536538fb2bff328e96d3817df1bc65" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;protected&lt;/strong&gt; member (&lt;code&gt;k&lt;/code&gt;) is accessible within all classes in the same package &lt;em&gt;and&lt;/em&gt; within subclasses in other packages.</source>
          <target state="translated">&lt;strong&gt;受保护的&lt;/strong&gt;成员（ &lt;code&gt;k&lt;/code&gt; ）可在同一包的所有类中&lt;em&gt;以及&lt;/em&gt;在其他包的子类中访问。</target>
        </trans-unit>
        <trans-unit id="eb72f226a8ba71d7c3578d0fab29e570e86013a3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;public&lt;/strong&gt; member (&lt;code&gt;l&lt;/code&gt;) is accessible to all classes (unless it resides in a &lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/sotms/&quot;&gt;module&lt;/a&gt; that does not export the package it is declared in).</source>
          <target state="translated">所有类都可以访问&lt;strong&gt;公共&lt;/strong&gt;成员（ &lt;code&gt;l&lt;/code&gt; ）（除非它驻留在不导出声明其的包的&lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/sotms/&quot;&gt;模块&lt;/a&gt;中）。</target>
        </trans-unit>
        <trans-unit id="28f9daadf043c9bd9f0d0e247b851c20599c84f6" translate="yes" xml:space="preserve">
          <source>A Java access modifier specifies which classes can access a given
  class and its fields, constructors and methods. Access modifiers can
  be specified separately for a class, its constructors, fields and
  methods. Java access modifiers are also sometimes referred to in daily
  speech as Java access specifiers, but the correct name is Java access
  modifiers. Classes, fields, constructors and methods can have one of
  four different Java access modifiers:</source>
          <target state="translated">Java访问修改器指定了哪些类可以访问给定的类及其字段、构造函数和方法。访问修饰符可以分别指定一个类、它的构造函数、字段和方法。Java访问修饰符有时也被称为Java访问指定器,但正确的名称是Java访问修饰符。类、字段、构造函数和方法可以有四种不同的Java访问修饰符之一。</target>
        </trans-unit>
        <trans-unit id="2e82124ab3a422db45abe523f1679bc6aa91180c" translate="yes" xml:space="preserve">
          <source>A class may be declared with the modifier public, in which case that
  class is visible to all classes everywhere. If a class has no modifier
  (the default, also known as package-private), it is visible only
  within its own package</source>
          <target state="translated">一个类可以用修改器public来声明,在这种情况下,这个类在任何地方都是可见的。如果一个类没有修改器(默认情况下,也被称为package-private),那么它只能在自己的包内可见。</target>
        </trans-unit>
        <trans-unit id="702664d37f54e24a65c5847af5c9c48dec38ac9b" translate="yes" xml:space="preserve">
          <source>A class that should only be instantiated in a factory class (in the same package) should have a package restricted constructor, since it shouldn't be possible to call it directly from outside the package.</source>
          <target state="translated">一个只应该在工厂类中(在同一个包中)实例化的类,应该有一个包限制的构造函数,因为它不应该在包外直接调用。</target>
        </trans-unit>
        <trans-unit id="2d6ccdc5fb3619653080b70f843a3d53183d1d68" translate="yes" xml:space="preserve">
          <source>A class, method, constructor, interface, etc. declared public can be accessed from any other class. Therefore fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java universe.</source>
          <target state="translated">一个声明为public的类、方法、构造函数、接口等都可以从任何其他类中访问。因此,在公有类内部声明的字段、方法、块可以从属于Java世界的任何类中访问。</target>
        </trans-unit>
        <trans-unit id="59c33800560e8ea15395ce4e031d5c61d474b047" translate="yes" xml:space="preserve">
          <source>A field &lt;code&gt;long internalCounter&lt;/code&gt; should probably be private since it's mutable and an implementation detail.</source>
          <target state="translated">字段 &lt;code&gt;long internalCounter&lt;/code&gt; 可能应该是私有的，因为它是可变的和实现细节。</target>
        </trans-unit>
        <trans-unit id="84f15ff4b953e019c687edc46342c1a4d6e9ef49" translate="yes" xml:space="preserve">
          <source>A member with &lt;strong&gt;no access modifier&lt;/strong&gt; (&lt;code&gt;j&lt;/code&gt;) is only accessible within classes in the same package.</source>
          <target state="translated">&lt;strong&gt;没有访问修饰符&lt;/strong&gt; （ &lt;code&gt;j&lt;/code&gt; ）的成员只能在同一包中的类内访问。</target>
        </trans-unit>
        <trans-unit id="c55ab8ded977750bfe1904b046504c141b94218c" translate="yes" xml:space="preserve">
          <source>A non-subclass inside a package of a subclass (A subclass inherits the protected members from its parent, and it makes them private to non-subclasses):</source>
          <target state="translated">在一个子类的包内的非子类(子类从父类继承受保护的成员,并使其对非子类私有化)。</target>
        </trans-unit>
        <trans-unit id="d652e362bd9495b3b5c5a0d3c9f4d692d5d6cfac" translate="yes" xml:space="preserve">
          <source>Access Specifiers in Java:
There are 4 access specifiers in java, namely private, package-private (default), protected and public in increasing access order.</source>
          <target state="translated">Java中的访问指定器。java中的访问指定器有4个,分别是private、package-private(默认)、protected和public,访问顺序依次递增。</target>
        </trans-unit>
        <trans-unit id="d90ffb4fa501229758715d3323e06c84a5ae97b4" translate="yes" xml:space="preserve">
          <source>Access level modifiers determine whether other classes can use a
  particular field or invoke a particular method. There are two levels
  of access control:</source>
          <target state="translated">访问级别修改器决定了其他类是否可以使用特定的字段或调用特定的方法。访问控制有两个级别。</target>
        </trans-unit>
        <trans-unit id="f35f9b2fc1a98f9e2d94d1f9485056d27b28eeaf" translate="yes" xml:space="preserve">
          <source>Access levels affect you in two ways. First, when you use classes that
  come from another source, such as the classes in the Java platform,
  access levels determine which members of those classes your own
  classes can use. Second, when you write a class, you need to decide
  what access level every member variable and every method in your class
  should have.</source>
          <target state="translated">访问级别从两个方面影响你。首先,当你使用来自其他来源的类,比如Java平台中的类,访问级别决定了你自己的类中哪些成员可以使用这些类的成员。第二,当你写一个类时,你需要决定你的类中的每个成员变量和每个方法应该具有什么样的访问级别。</target>
        </trans-unit>
        <trans-unit id="03834d1bba262bb9c1fe64f18662c2cfe0984376" translate="yes" xml:space="preserve">
          <source>Access modifier can be applicable for &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;field&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/60907642/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;method&lt;/code&gt;. Try to access, subclass or override this.</source>
          <target state="translated">访问修饰符可适用于 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;field&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/60907642/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt; ， &lt;code&gt;method&lt;/code&gt; 。 尝试访问，子类化或覆盖它。</target>
        </trans-unit>
        <trans-unit id="9e3f67bc099476112adf6c930b20ba16a50afeba" translate="yes" xml:space="preserve">
          <source>Access modifiers are there to restrict access at several levels.</source>
          <target state="translated">访问修改器的存在是为了限制几个级别的访问。</target>
        </trans-unit>
        <trans-unit id="ef81daf780b1360468865cad0409109e0c35badd" translate="yes" xml:space="preserve">
          <source>Access modifiers is a tool to help you to prevent accidentally breaking encapsulation&lt;sup&gt;(*)&lt;/sup&gt;. Ask yourself if you intend the member to be something that's internal to the class, package, class hierarchy or not internal at all, and choose access level accordingly.</source>
          <target state="translated">访问修饰符是一种工具，可帮助您防止意外破坏封装&lt;sup&gt;（*）&lt;/sup&gt; 。 问问自己，您是否希望成员成为类，包，类层次结构的内部成员或根本不是内部成员，然后相应地选择访问级别。</target>
        </trans-unit>
        <trans-unit id="5eff681f376245a3dee4c9191f68f56b0af848bd" translate="yes" xml:space="preserve">
          <source>Access to &lt;code&gt;field&lt;/code&gt; or &lt;code&gt;method&lt;/code&gt; is through a &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;class&lt;/code&gt; 访问 &lt;code&gt;field&lt;/code&gt; 或 &lt;code&gt;method&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2412c998fc16dee0b53ff74260ef514b93a1606" translate="yes" xml:space="preserve">
          <source>Accessible only inside the same class.</source>
          <target state="translated">只有在同一班级内才可进入。</target>
        </trans-unit>
        <trans-unit id="3a2d2458a3a2813e65aa1e280528e2ae281eb1b6" translate="yes" xml:space="preserve">
          <source>Accessible only to the classes in the same package and to the subclasses</source>
          <target state="translated">只对同一包中的类和子类开放。</target>
        </trans-unit>
        <trans-unit id="d0e99d1f0ad00dcd92752660239fe3e6461be76a" translate="yes" xml:space="preserve">
          <source>Accessible to the classes in the same package only.</source>
          <target state="translated">只对同一包中的班级开放。</target>
        </trans-unit>
        <trans-unit id="5b3141b0946b8bc5002beaffc46356be6f4c620a" translate="yes" xml:space="preserve">
          <source>All the access specifiers are possible on class members (constructors, methods and static member functions, nested classes).</source>
          <target state="translated">所有的访问指定器都可以对类成员(构造函数、方法和静态成员函数、嵌套类)进行访问。</target>
        </trans-unit>
        <trans-unit id="039d200ae5db7c7b5f2a7c153d81e8001cb8966c" translate="yes" xml:space="preserve">
          <source>Also, use the @Override annotation when overriding to keep things from breaking when you refactor.</source>
          <target state="translated">另外,在重构的时候使用 @Override 注释,以防止重构的时候出现破坏。</target>
        </trans-unit>
        <trans-unit id="2e74d999b3d7180df815ddf8cc8c8247175ccf3b" translate="yes" xml:space="preserve">
          <source>An internal &lt;code&gt;void beforeRender()&lt;/code&gt; method called right before rendering and used as a hook in subclasses should be protected.</source>
          <target state="translated">应该保护在渲染之前调用的内部 &lt;code&gt;void beforeRender()&lt;/code&gt; 方法，该方法在子类中用作钩子。</target>
        </trans-unit>
        <trans-unit id="f562bc00e2ff22b13660ce46b08683a5aa376aae" translate="yes" xml:space="preserve">
          <source>Another thing is that classes which depend a lot on each other may end up in the same package and could eventually be refactored or merged if the dependency is too strong.</source>
          <target state="translated">还有一点是,相互依赖性很强的类最终可能会在同一个包里,如果依赖性太强,最终可能会被重构或合并。</target>
        </trans-unit>
        <trans-unit id="2c41355fcbb760f41e646cca45391d28712651f9" translate="yes" xml:space="preserve">
          <source>As a general rule I try to avoid overriding method implementations by subclassing; it's too easy to screw up the logic. Declare abstract protected methods if you intend for it to be overridden.</source>
          <target state="translated">作为一般规则,我尽量避免通过子classing来重写方法实现;这样太容易把逻辑搞得一团糟。如果你打算让它被重写,就声明抽象保护方法。</target>
        </trans-unit>
        <trans-unit id="32423b1a28b9a1d669c73210c669f380ab7cd7cf" translate="yes" xml:space="preserve">
          <source>As a result, if we divide access right into three rights:</source>
          <target state="translated">因此,如果我们把准入权分为三个权利。</target>
        </trans-unit>
        <trans-unit id="db2bda78247e71f5efa83e0fc3e723c83ff44d0a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb:</source>
          <target state="translated">作为一种经验法则。</target>
        </trans-unit>
        <trans-unit id="a81942444a4d0f2780ea3a629f2fe55b7bc48ec8" translate="yes" xml:space="preserve">
          <source>Assume that we have 2 classes; &lt;code&gt;Father&lt;/code&gt; and &lt;code&gt;Son&lt;/code&gt;, each in its own package:</source>
          <target state="translated">假设我们有2个班级； &lt;code&gt;Father&lt;/code&gt; 和 &lt;code&gt;Son&lt;/code&gt; ，每个人都有自己的包装：</target>
        </trans-unit>
        <trans-unit id="aa9a0ac313bc297e77263ee6fbe80f0f9519aae9" translate="yes" xml:space="preserve">
          <source>At the member level&amp;mdash;public, private, protected, or package-private (no explicit modifier).</source>
          <target state="translated">在成员级别上-公共，私有，受保护或整包私有（无显式修饰符）。</target>
        </trans-unit>
        <trans-unit id="e305218fd0f9ba9ee5a5cdb055df557e07100698" translate="yes" xml:space="preserve">
          <source>At the top level&amp;mdash;public, or package-private (no explicit modifier).</source>
          <target state="translated">在顶层-公共或程序包私有（无显式修饰符）。</target>
        </trans-unit>
        <trans-unit id="1c758ca2bda73911a8bb40b724a78e1d5d7c8eff" translate="yes" xml:space="preserve">
          <source>Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.</source>
          <target state="translated">由于类的继承性,一个类的所有公共方法和变量都是由其子类继承的。</target>
        </trans-unit>
        <trans-unit id="fb75e9527859877f47e7706814e662a02518f379" translate="yes" xml:space="preserve">
          <source>But these protected members are &amp;ldquo;accessible outside the package only through inheritance&amp;ldquo;. i.e you can access a protected member of a class in its subclass present in some other package directly as if the member is present in the subclass itself. But that protected member will not be accessible in the subclass outside the package by using parent class&amp;rsquo;s reference. 
....</source>
          <target state="translated">但是这些受保护的成员&amp;ldquo;只能通过继承在包外部访问&amp;rdquo;。 也就是说，您可以直接访问存在于其他包中的子类中某个类的受保护成员，就像该成员本身存在于子类中一样。 但是，使用父类的引用将无法在包外部的子类中访问该受保护的成员。 ....</target>
        </trans-unit>
        <trans-unit id="c4a8265d49bc8acc6dd4762df0a314fae0081dc6" translate="yes" xml:space="preserve">
          <source>C++ defines an additional level called &quot;friend&quot; and the less you know about that the better.</source>
          <target state="translated">C++定义了一个叫做 &quot;朋友 &quot;的额外关卡,你知道的越少越好。</target>
        </trans-unit>
        <trans-unit id="fea15bced6cf072a20331c3293889e5278470a9f" translate="yes" xml:space="preserve">
          <source>Can be accessed from anywhere. (Global Access)</source>
          <target state="translated">可从任何地方访问。(全球访问)</target>
        </trans-unit>
        <trans-unit id="b6b8d9b4123fecc2397339f9346b53016b47c561" translate="yes" xml:space="preserve">
          <source>Can only be seen and used by the &lt;strong&gt;package&lt;/strong&gt; in which it was declared.  This is the default in Java (which some see as a mistake).</source>
          <target state="translated">只能由声明它的&lt;strong&gt;包&lt;/strong&gt;查看和使用。 这是Java中的默认设置（有些人认为是错误的）。</target>
        </trans-unit>
        <trans-unit id="29a771fa03b2207c5bfcb8ccc88b283b088d93d8" translate="yes" xml:space="preserve">
          <source>Class and Interface</source>
          <target state="translated">类和接口</target>
        </trans-unit>
        <trans-unit id="abdbdface1f6d0a002a132de8ee6c16f0286d809" translate="yes" xml:space="preserve">
          <source>Class can be public or default</source>
          <target state="translated">类可以是公共的,也可以是默认的</target>
        </trans-unit>
        <trans-unit id="4eff37234b0241258920d335734419acce47e495" translate="yes" xml:space="preserve">
          <source>Class members can be public, protected, default or private.</source>
          <target state="translated">班级成员可以是公共的、受保护的、默认的或私人的。</target>
        </trans-unit>
        <trans-unit id="b77183cc688eb0a13673641268a14b314543ef5c" translate="yes" xml:space="preserve">
          <source>Compiler output:</source>
          <target state="translated">编译器输出。</target>
        </trans-unit>
        <trans-unit id="5813699819cb9238ea0a3cac18732617dd8b7ef9" translate="yes" xml:space="preserve">
          <source>David's answer provides the meaning of each access modifier. As for when to use each, I'd suggest making public all classes and the methods of each class that are meant for external use (its API), and everything else private.</source>
          <target state="translated">David的回答提供了每个访问修改器的含义。至于什么时候使用,我建议把所有的类和每个类的方法都公开,每个类的方法都要对外使用(它的API),其他的都是私有的。</target>
        </trans-unit>
        <trans-unit id="b3048e4be2bec9d78ee94630c8921320fc4664da" translate="yes" xml:space="preserve">
          <source>Easy rule. Start with declaring everything private. And then progress towards the public as the needs arise and design warrants it.</source>
          <target state="translated">简单的规则。从宣布所有的东西都是私人的开始。然后随着需求的出现和设计的需要,向公共的方向发展。</target>
        </trans-unit>
        <trans-unit id="1aed6cf212aa5ca85fdc040a3f80f02392b4b63d" translate="yes" xml:space="preserve">
          <source>Everyone can see it.</source>
          <target state="translated">大家都能看到。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="a9375f321c90af9af48e6e3fb9835073a5901dfe" translate="yes" xml:space="preserve">
          <source>Explanations</source>
          <target state="translated">Explanations</target>
        </trans-unit>
        <trans-unit id="de130795061e0af332069bc81b222c01a70e8ee6" translate="yes" xml:space="preserve">
          <source>Finally, your friend wants to read your progress report for the semester which is posted on the website. However, every student has their own personal login to access this section of the campus website. This would make these credentials as &lt;strong&gt;PRIVATE&lt;/strong&gt;.</source>
          <target state="translated">最后，您的朋友想阅读您发布在网站上的学期进度报告。 但是，每个学生都有自己的个人登录名以访问校园网站的此部分。 这将使这些凭据成为&lt;strong&gt;PRIVATE&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="414b0040a73b05acdd918cc38af972d787b57ad2" translate="yes" xml:space="preserve">
          <source>Following block diagram explain how data members of &lt;strong&gt;base class&lt;/strong&gt; are &lt;strong&gt;inherited&lt;/strong&gt; when &lt;strong&gt;derived class&lt;/strong&gt; access mode is &lt;strong&gt;private&lt;/strong&gt;.</source>
          <target state="translated">下面的框图说明了&lt;strong&gt;派生类&lt;/strong&gt;访问模式为&lt;strong&gt;private&lt;/strong&gt;时如何&lt;strong&gt;继承&lt;/strong&gt; &lt;strong&gt;基类的&lt;/strong&gt;数据成员。</target>
        </trans-unit>
        <trans-unit id="211709b4e5a975998dfceb9f90b343faddbc3a82" translate="yes" xml:space="preserve">
          <source>For a taste of how these interact, consider this example. It is possible to &quot;leak&quot; private inner classes; this is usually a warning:</source>
          <target state="translated">想了解一下这些交互方式,可以考虑这个例子。有可能 &quot;泄露 &quot;私有内部类;这通常是一个警告。</target>
        </trans-unit>
        <trans-unit id="629b7e6e087c9f024573fb85ac0935aa91d841eb" translate="yes" xml:space="preserve">
          <source>For classes in the top scope, only &lt;code&gt;public&lt;/code&gt; and package-private are permitted. This design choice is presumably because &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; would be redundant at the package level (there is no inheritance of packages).</source>
          <target state="translated">对于顶级范围的类，仅允许 &lt;code&gt;public&lt;/code&gt; 和包私有。 这种设计选择大概是因为 &lt;code&gt;protected&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 在程序包级别是多余的（没有程序包的继承）。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="358ca920d00cef8e692577e7de482b71e23ffa72" translate="yes" xml:space="preserve">
          <source>For example:
You may put sensitive security methods in a 'security' package.
Then put a public class which accesses some of the security related code in this package but keep other security classes &lt;strong&gt;package private&lt;/strong&gt;.
Thus other developers will only be able to use the publicly available class from outside of this package (unless they change the modifier).
This is not a security feature, but will &lt;strong&gt;guide&lt;/strong&gt; usage.</source>
          <target state="translated">例如：您可以将敏感的安全方法放在&amp;ldquo;安全&amp;rdquo;包中。 然后放置一个公共类，该类可以访问此程序包中的某些与安全相关的代码，但将其他安全类&lt;strong&gt;程序包&lt;/strong&gt;保持&lt;strong&gt;私有&lt;/strong&gt; 。 因此，其他开发人员将只能从此程序包外部使用公共可用的类（除非他们更改了修饰符）。 这不是安全功能，但将&lt;strong&gt;指导&lt;/strong&gt;使用。</target>
        </trans-unit>
        <trans-unit id="dc227021f08c9353ab45ce62f177cc6fd693f40c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://tutorials.jenkov.com/java/access-modifiers.html&quot;&gt;Java Access Modifiers&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;http://tutorials.jenkov.com/java/access-modifiers.html&quot;&gt;Java访问修饰符&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="3bf7a6338bd5d5a3a5912a1ea99b4fa3eaa6fe75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;Controlling Access to Members of a Class&lt;/a&gt; tutorials:</source>
          <target state="translated">从&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;控制访问到类成员&lt;/a&gt;教程：</target>
        </trans-unit>
        <trans-unit id="c9146570be1c93d6b1aab81c70a95becda8f9183" translate="yes" xml:space="preserve">
          <source>Here is detailed answer</source>
          <target state="translated">下面是详细的答案</target>
        </trans-unit>
        <trans-unit id="dab161dd919298ea5955c5ca83a5191994ed419b" translate="yes" xml:space="preserve">
          <source>Here's a better version of the table. (Future proof with a column for modules.)</source>
          <target state="translated">这里是一个更好的表格版本。(以后的证明,有模块的专栏)。</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">希望对你有帮助!</target>
        </trans-unit>
        <trans-unit id="aa86ea3205f5b702b5c530cc16d177882fb58320" translate="yes" xml:space="preserve">
          <source>However, if the public class we are trying to access is in a different package, then the public class still need to be imported.</source>
          <target state="translated">但是,如果我们要访问的公有类是在不同的包中,那么仍然需要导入公有类。</target>
        </trans-unit>
        <trans-unit id="3068a4b8c73e5abddb06c0c44f94cd1fc95d98ad" translate="yes" xml:space="preserve">
          <source>However, this is quite complicated, and for full details, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6&quot;&gt;consult the Java Language Specification&lt;/a&gt;. (Yes, there have been compiler bugs in the past.)</source>
          <target state="translated">但是，这非常复杂，有关详细信息， &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6&quot;&gt;请查阅Java Language Specification&lt;/a&gt; 。 （是的，过去有编译器错误。）</target>
        </trans-unit>
        <trans-unit id="65c381ea7d6931f0058f4696124a3922c9a01d9e" translate="yes" xml:space="preserve">
          <source>If a class member is declared with keyword protected then in this case it is available ONLY to same class members</source>
          <target state="translated">如果一个类成员被声明为protected关键字,那么在这种情况下,它只对相同的类成员可用。</target>
        </trans-unit>
        <trans-unit id="711d3ba82f3b647c7d5406080db3495d8ec4da48" translate="yes" xml:space="preserve">
          <source>If a class member is declared with keyword protected then it can be accessed from same class members, outside class members within the same package and inherited class members. If a class member is protected then it can NOT be accessed from outside package class unless the outside packaged class is inherited i.e. extends the other package superclass. But a protected class member is always available to same package classes it does NOT matter weather the same package class is inherited or NOT</source>
          <target state="translated">如果一个类成员被声明为protected关键字,那么它可以从同一类成员、同一包内的外部类成员和继承类成员中访问。如果一个类成员被保护,那么它不能从外部包类中访问,除非外部包类被继承,即扩展了其他包的超类。但是受保护的类成员总是对同一包类可用,这与同一包类是否继承无关。</target>
        </trans-unit>
        <trans-unit id="00c3f094a058fa6a019b6a1d9bef50a5bac1da87" translate="yes" xml:space="preserve">
          <source>If a class member is declared with public then it can be accessed from anywhere</source>
          <target state="translated">如果一个类成员被声明为public,那么它可以从任何地方访问。</target>
        </trans-unit>
        <trans-unit id="80f687d570b26042fb8176f323cd37d2559e1a3d" translate="yes" xml:space="preserve">
          <source>If on the contrary you set everything as &lt;strong&gt;public&lt;/strong&gt; it will not be clear what should or should not be accessed, which may lead to writing a lot of javadoc (which does not enforce anything via the compiler...).</source>
          <target state="translated">相反，如果将所有内容都设置为&lt;strong&gt;public&lt;/strong&gt; ，则不清楚应该访问或不应该访问什么，这可能会导致编写大量的javadoc（无法通过编译器强制执行任何操作&amp;hellip;&amp;hellip;）。</target>
        </trans-unit>
        <trans-unit id="8a060e14cb3887508691d17bc70585a7b1cb9b1f" translate="yes" xml:space="preserve">
          <source>If you try to access private members on one class in another will throw compile error. For example,</source>
          <target state="translated">如果你试图在一个类上访问私有成员,在另一个类上访问私有成员会抛出编译错误。[...]</target>
        </trans-unit>
        <trans-unit id="31d88a3684ae0701668196799b25e5ac3e976cb2" translate="yes" xml:space="preserve">
          <source>If you want users to be able to customize behaviors, rather than making internals public so they can override them, it's often a better idea to shove those guts into an object and make that interface public.  That way they can simply plug in a new object.  For example, if you were writing a CD player and wanted the &quot;go find info about this CD&quot; bit customizable, rather than make those methods public you'd put all that functionality into its own object and make just your object getter/setter public.  In this way being stingy about exposing your guts encourages good composition and separation of concerns</source>
          <target state="translated">如果你想让用户能够自定义行为,而不是把内部内容公开,让他们可以覆盖这些行为,那么通常最好的办法是把这些内脏塞到一个对象中,然后把这个接口公开。这样他们就可以简单地插入一个新对象。例如,如果你在写一个CD播放器,想让 &quot;去找关于这张CD的信息 &quot;的功能可以自定义,那么与其把这些方法公开,不如把所有的功能都放到自己的对象中,只把对象的getterter公开。这样一来,不吝于暴露你的胆量,就能鼓励良好的构图和分离关注点。</target>
        </trans-unit>
        <trans-unit id="7c7a886c87a6eb77fdc25a1035f8d6da53cf8656" translate="yes" xml:space="preserve">
          <source>In Java default is NOT an access modifier keyword. If a class member is declared without any access modifier keyword then in this case it is considered as default member. The default class member is always available to same package class members. But outside package class member can NOT access default class members even if outside classes are subclasses unlike protected members</source>
          <target state="translated">在Java中,default不是一个访问修改器关键字。如果一个类成员被声明为没有任何访问修改器关键字,那么在这种情况下,它被认为是默认成员。默认类成员总是对同一包的类成员可用。但是外部的包类成员不能访问默认类成员,即使外部类是子类,也不能访问默认类成员,这与protected成员不同。</target>
        </trans-unit>
        <trans-unit id="fff3d91dbf347df5d37ad1067782bedfe095b46f" translate="yes" xml:space="preserve">
          <source>In Java, are there clear rules on when to use each of access modifiers, namely the default (package private), &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, while making &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; and dealing with inheritance?</source>
          <target state="translated">在Java中，关于何时使用每个访问修饰符（即默认（程序包私有）， &lt;code&gt;public&lt;/code&gt; ， &lt;code&gt;protected&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; ）的明确规则，同时使 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;interface&lt;/code&gt; 以及继承都可以使用？</target>
        </trans-unit>
        <trans-unit id="0a637c3e550bf7e3b47867e3e5c6bf98ec1df2d9" translate="yes" xml:space="preserve">
          <source>In non-static methods you can access directly because of &lt;strong&gt;this&lt;/strong&gt; reference (also in constructors)but to access in static methods you need to create object of the class.</source>
          <target state="translated">在非静态方法中，由于&lt;strong&gt;此&lt;/strong&gt;引用（在构造函数中），您可以直接访问，但是在静态方法中，您需要创建类的对象。</target>
        </trans-unit>
        <trans-unit id="f53b845e511550d070f01e7e1e45f0c6618de79e" translate="yes" xml:space="preserve">
          <source>In very short</source>
          <target state="translated">很短的时间内</target>
        </trans-unit>
        <trans-unit id="0a280c9c0cc8b973c8bf1ae5a66442e357f07610" translate="yes" xml:space="preserve">
          <source>Inheritance. Successor &lt;code&gt;class&lt;/code&gt;(subclass) access modifier can be any. Successor &lt;code&gt;method&lt;/code&gt;(override) access modifier should be the same or expand it</source>
          <target state="translated">遗产。 后继 &lt;code&gt;class&lt;/code&gt; （子类）访问修饰符可以是任何。 后继 &lt;code&gt;method&lt;/code&gt; （覆盖）访问修饰符应该相同或展开</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">内部班</target>
        </trans-unit>
        <trans-unit id="0ebd78cffc1684194f3fbbff5f4da1d70adec54f" translate="yes" xml:space="preserve">
          <source>Inside a class that is located in the same package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;):</source>
          <target state="translated">在一个类中，该类位于定义了 &lt;code&gt;foo()&lt;/code&gt; 的同一包中（ &lt;code&gt;fatherpackage&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4cb68522151730f7fe478771c760ac74a2dfdcd4" translate="yes" xml:space="preserve">
          <source>Inside a subclass, on the current instance via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">在子类内部，通过 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;super&lt;/code&gt; 在当前实例上：</target>
        </trans-unit>
        <trans-unit id="85ab384f0543ec447c88c37b720be06d8d5088de" translate="yes" xml:space="preserve">
          <source>Is an access to a member with this access specifier allowed?</source>
          <target state="translated">是否允许使用这个访问指定器访问会员?</target>
        </trans-unit>
        <trans-unit id="68afd36f6cfde7e67dffed921baf25b1a58cbfec" translate="yes" xml:space="preserve">
          <source>It is all about &lt;strong&gt;encapsulation&lt;/strong&gt; (or as Joe Phillips stated, &lt;em&gt;least knowledge&lt;/em&gt;).</source>
          <target state="translated">这全都与&lt;strong&gt;封装&lt;/strong&gt;有关（或者正如Joe Phillips所说的那样， &lt;em&gt;至少是知识&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9428cccda535e253598eaa7cdab4627dc9261f0f" translate="yes" xml:space="preserve">
          <source>It's actually a bit more complicated than a simple grid shows. The grid tells you whether an access is allowed, but what exactly constitutes an access? Also, access levels interact with nested classes and inheritance in complex ways.</source>
          <target state="translated">实际上,这比简单的网格显示要复杂一些。网格告诉你一个访问是否被允许,但究竟什么才是访问呢?另外,访问级别与嵌套类和继承的交互方式也很复杂。</target>
        </trans-unit>
        <trans-unit id="8d7eff0719ace3e48da815165c32c20e33793293" translate="yes" xml:space="preserve">
          <source>Java - Method accessibility inside package-private class?</source>
          <target state="translated">Java--包-私有类内的方法可访问性?</target>
        </trans-unit>
        <trans-unit id="540bbbbbf4debb7face493bc9c0566a5b985f14c" translate="yes" xml:space="preserve">
          <source>Java access modifiers are used to provide access control in Java.</source>
          <target state="translated">Java访问修改器用于在Java中提供访问控制。</target>
        </trans-unit>
        <trans-unit id="b326f17a3d2f7a73292bcff3aa33360fd288b8b2" translate="yes" xml:space="preserve">
          <source>Java access modifies which you can use</source>
          <target state="translated">Java访问修改,你可以使用</target>
        </trans-unit>
        <trans-unit id="2d507bfe48fd363710c7aa776449fca5b38c5c5a" translate="yes" xml:space="preserve">
          <source>Let's add a protected method &lt;code&gt;foo()&lt;/code&gt; to &lt;code&gt;Father&lt;/code&gt;.</source>
          <target state="translated">让我们向 &lt;code&gt;Father&lt;/code&gt; 添加一个受保护的方法 &lt;code&gt;foo()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="825e439c12e8399e15d6ef5cddfff02318859b29" translate="yes" xml:space="preserve">
          <source>Let's assume that you're a student at a university and you have a friend who's coming to visit you over the weekend. Suppose there exists a big statue of the university's founder in the middle of the campus.</source>
          <target state="translated">假设你是某大学的学生,你有一个朋友周末要来看望你。假设在校园的中间有一个大学的创始人的大雕像。</target>
        </trans-unit>
        <trans-unit id="dc55fb860e4b429ce495c5cbc9ba6248283659cf" translate="yes" xml:space="preserve">
          <source>Like you'd think, only the &lt;strong&gt;class&lt;/strong&gt; in which it is declared can see it.</source>
          <target state="translated">就像您想的那样，只有声明了它的&lt;strong&gt;类&lt;/strong&gt;才能看到它。</target>
        </trans-unit>
        <trans-unit id="8709df24bd586627893f85ebfa1884c2f82a5e55" translate="yes" xml:space="preserve">
          <source>List item</source>
          <target state="translated">列表项目</target>
        </trans-unit>
        <trans-unit id="c1398e89d57631598bc754b3d6e89f276728b298" translate="yes" xml:space="preserve">
          <source>Local variables and formal parameters cannot take access specifiers. Since they are inherently inaccessible to the outside according to scoping rules, they are effectively private.</source>
          <target state="translated">本地变量和形式参数不能接受访问指定器。由于根据Scoping规则,它们本质上是不能被外部访问的,所以它们实际上是私有的。</target>
        </trans-unit>
        <trans-unit id="1b8528ca6c2239a069ccb77a16a61d04aaa3ad2b" translate="yes" xml:space="preserve">
          <source>Many languages find the hierarchical nature of public/protected/private to be too limiting and not in line with reality.  To that end there is the concept of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Trait_class&quot;&gt;trait class&lt;/a&gt;, but that's another show.</source>
          <target state="translated">许多语言发现，公共/受​​保护/私有的等级性质过于局限，与现实不符。 为此，有一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Trait_class&quot;&gt;特质类&lt;/a&gt;的概念，但这是另一个展示。</target>
        </trans-unit>
        <trans-unit id="61039d9442076fb2e85d753a984b29c6d6e97613" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;private&lt;/code&gt;: Only if member is defined within the same class as calling code.</source>
          <target state="translated">成员是 &lt;code&gt;private&lt;/code&gt; ：仅当成员与调用代码在同一类中定义时。</target>
        </trans-unit>
        <trans-unit id="9a6766c91a1dac9b515e329f73674dee7761caf9" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;protected&lt;/code&gt;: Same package, or if member is defined in a superclass of the class containing the calling code.</source>
          <target state="translated">成员 &lt;code&gt;protected&lt;/code&gt; ：同一包，或者如果成员在包含调用代码的类的超类中定义，则为受保护的成员。</target>
        </trans-unit>
        <trans-unit id="56756b869829e0a2b3e5809cfb44466392b0d8dd" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;public&lt;/code&gt;: Yes.</source>
          <target state="translated">成员是 &lt;code&gt;public&lt;/code&gt; ：是的。</target>
        </trans-unit>
        <trans-unit id="333249b7b9e011c07bbf34cd6918aeb87c291c5d" translate="yes" xml:space="preserve">
          <source>Member is package private: Only if the calling code is within the member's immediately enclosing package.</source>
          <target state="translated">成员是包的私有化。只有当调用的代码在成员的紧邻包内时,才会被调用。</target>
        </trans-unit>
        <trans-unit id="46e6a422e152e53fcd52afdc532361e67997177b" translate="yes" xml:space="preserve">
          <source>Methods, variables and constructors that are declared private can only be accessed within the declared class itself. The private access modifier is the most restrictive access level. Class and interfaces cannot be private.</source>
          <target state="translated">被声明为私有的方法、变量和构造函数只能在声明的类本身中进行访问。私有访问修改器是最有限制的访问级别。类和接口不能是私有的。</target>
        </trans-unit>
        <trans-unit id="335faa2a06faaaaddaf19dca7a6e552702624138" translate="yes" xml:space="preserve">
          <source>Methods,Variables and Constructors</source>
          <target state="translated">方法、变量和构造物</target>
        </trans-unit>
        <trans-unit id="89cb26c7ec8c16073c200078d9348aed52d6c686" translate="yes" xml:space="preserve">
          <source>My two cents :)</source>
          <target state="translated">我的两分钱)</target>
        </trans-unit>
        <trans-unit id="87a523f027d0ba7adab70824c7b1fb94c7132d6f" translate="yes" xml:space="preserve">
          <source>Next, you want to take your friend to your dorm, but for that you need to register him as a visitor. This means that he gets an access pass (which is the same as yours) to get into various buildings on campus. This would make his access card as &lt;strong&gt;PROTECTED&lt;/strong&gt;.</source>
          <target state="translated">接下来，您想带您的朋友去您的宿舍，但是为此您需要将他注册为访客。 这意味着他获得了通行证（与您的通行证相同），可以进入校园中的各种建筑物。 这将使他的访问卡被&lt;strong&gt;保护&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ec331f3044739b47bc605e4558099cf08d010f7" translate="yes" xml:space="preserve">
          <source>Normally, member variables are defined private, but member methods are public.</source>
          <target state="translated">通常情况下,成员变量是定义私有的,但成员方法是公开的。</target>
        </trans-unit>
        <trans-unit id="c6238ff0e30b27995906139dc0f1043520c044df" translate="yes" xml:space="preserve">
          <source>Note: &lt;em&gt;This is just a &lt;strong&gt;supplement&lt;/strong&gt; for the accepted answer.&lt;/em&gt;</source>
          <target state="translated">注意： &lt;em&gt;这只是已接受答案的&lt;strong&gt;补充&lt;/strong&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adb9aaea02b1cff0a3c213ab075fcb4d010034c7" translate="yes" xml:space="preserve">
          <source>Note: Declaring data members with private access specifier is known as &lt;strong&gt;data hiding.&lt;/strong&gt;</source>
          <target state="translated">注意：使用私有访问说明符声明数据成员称为&lt;strong&gt;数据隐藏。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="32500c238248244eb78c9f14aa99e41bd6942ed2" translate="yes" xml:space="preserve">
          <source>Now the confusion arises when it comes to &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">现在，当涉及 &lt;code&gt;default&lt;/code&gt; 和 &lt;code&gt;protected&lt;/code&gt; 时，就会出现混乱</target>
        </trans-unit>
        <trans-unit id="bf67bd37c73d81bc5307563f78c833d29fe10889" translate="yes" xml:space="preserve">
          <source>Often times I've realized that remembering the basic concepts of any language can made possible by creating real-world analogies. Here is my analogy for understanding access modifiers in Java:</source>
          <target state="translated">很多时候,我已经意识到,记住任何语言的基本概念都可以通过建立现实世界的类比来实现。下面是我对Java中访问修饰符的理解类比。</target>
        </trans-unit>
        <trans-unit id="97a14c4e2738d6c2804656e0a006451d5b27f196" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the parent class and it is &lt;em&gt;inside&lt;/em&gt; the package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;) [This can be included inside context no. 1]:</source>
          <target state="translated">对于类型为父类的引用，该引用位于定义 &lt;code&gt;foo()&lt;/code&gt; 的程序包中（ &lt;code&gt;fatherpackage&lt;/code&gt; 程序包）[可以包含在上下文编号为1的内部。 1]：</target>
        </trans-unit>
        <trans-unit id="b47a88794e5bc9eb69dfcdd8c1454a1d628c58f2" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the parent class and it is &lt;em&gt;outside&lt;/em&gt; the package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;):</source>
          <target state="translated">在类型为父类且位于定义 &lt;code&gt;foo()&lt;/code&gt; 的包&lt;em&gt;之外&lt;/em&gt;的引用&lt;em&gt;之外&lt;/em&gt; （ &lt;code&gt;fatherpackage&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c64917ce44fe5662d78c50ec0a072083dbcd8daf" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the same class:</source>
          <target state="translated">在其类型为同一类的参照物上:</target>
        </trans-unit>
        <trans-unit id="1735879fe3a2e22b9b283485856a39553a8ac889" translate="yes" xml:space="preserve">
          <source>Only having private constructors also means that the class cannot be subclassed externally, since Java requires a subclass's constructors to implicitly or explicitly call a superclass constructor. (It can, however, contain a nested class that subclasses it.)</source>
          <target state="translated">只有私有化构造函数也意味着该类不能被外部子类化,因为Java要求子类的构造函数必须隐含或显式地调用超类构造函数。(但是,它可以包含一个嵌套类来子类化它的子类)。</target>
        </trans-unit>
        <trans-unit id="1d75774c0f96b6ee44eb6643c9fea71b50b90ea8" translate="yes" xml:space="preserve">
          <source>Order</source>
          <target state="translated">Order</target>
        </trans-unit>
        <trans-unit id="59e00bdab1723eeefe789e083d87acb6847d6733" translate="yes" xml:space="preserve">
          <source>Output: Hello</source>
          <target state="translated">输出。你好</target>
        </trans-unit>
        <trans-unit id="67a5927c5cce6b22e97f84af83e9faa9704ee973" translate="yes" xml:space="preserve">
          <source>Output:Hello</source>
          <target state="translated">Output:Hello</target>
        </trans-unit>
        <trans-unit id="48db52b778fccd255894481994bdacd74ee198b0" translate="yes" xml:space="preserve">
          <source>Over time you'll develop a sense for when to make some classes package-private and when to declare certain methods protected for use in subclasses.</source>
          <target state="translated">随着时间的推移,你就会对什么时候把某些类做成私有类,什么时候声明某些方法是受保护的,以便在子类中使用。</target>
        </trans-unit>
        <trans-unit id="2d1fefb5c50582321c4d75309559ed4fb1fb5c62" translate="yes" xml:space="preserve">
          <source>Package Private</source>
          <target state="translated">私家套餐</target>
        </trans-unit>
        <trans-unit id="02d690f0069219ba265f693b9aa34bc858bc7b64" translate="yes" xml:space="preserve">
          <source>Package Private + can be seen by subclasses or package member.</source>
          <target state="translated">包私有+可以被子类或包成员看到。</target>
        </trans-unit>
        <trans-unit id="67edadea70b35c0bde5fedf6ce3b8d7307338c28" translate="yes" xml:space="preserve">
          <source>Personally, I stick with just &quot;private&quot; and &quot;public&quot;.  Many OO languages just have that.  &quot;Protected&quot; can be handy, but it's really a cheat.  Once an interface is more than private it's outside of your control and you have to go looking in other people's code to find uses.</source>
          <target state="translated">就个人而言,我坚持只用 &quot;私人 &quot;和 &quot;公共&quot;。很多OO语言都是这样的。&quot;protected &quot;可以很方便,但这真的是个骗局。一旦一个接口超过了private,它就不在你的控制范围内,你必须去找别人的代码来寻找用途。</target>
        </trans-unit>
        <trans-unit id="b092b192a4d648e172b4a375b0666e778cde5015" translate="yes" xml:space="preserve">
          <source>Please note:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="237dfa0a21c8e17a7276cf161eef7e0fba067c47" translate="yes" xml:space="preserve">
          <source>Private</source>
          <target state="translated">Private</target>
        </trans-unit>
        <trans-unit id="73c2c05c567e0abdbe3ba13d814ebd8d7a054684" translate="yes" xml:space="preserve">
          <source>Private access modifier - private:</source>
          <target state="translated">私人访问修改器--私人。</target>
        </trans-unit>
        <trans-unit id="47498edf610d2474479d092eef6b21971a8e54cb" translate="yes" xml:space="preserve">
          <source>Private is not accessible outside the class
Default is accessible only in the package.
Protected in package as well as any class which extends it.
Public is open for all.</source>
          <target state="translated">Private在类外无法访问,Default只能在包中访问。在包中以及任何扩展它的类都是受保护的。公共类对所有人开放。</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="07dc0891cffa12c73230979cda26f3ea127ced21" translate="yes" xml:space="preserve">
          <source>Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.</source>
          <target state="translated">受保护的访问给了子类一个使用帮助类方法或变量的机会,同时防止非相关类试图使用它。</target>
        </trans-unit>
        <trans-unit id="427cebdbe94bd945eeb72a25018bea95d6a0d3e4" translate="yes" xml:space="preserve">
          <source>Protected access modifier - protected:</source>
          <target state="translated">受保护的访问修改器--受保护。</target>
        </trans-unit>
        <trans-unit id="dc5eb704bbcae1aff4efb71c55461d47767dabe7" translate="yes" xml:space="preserve">
          <source>Public</source>
          <target state="translated">Public</target>
        </trans-unit>
        <trans-unit id="373d5d53b0dab15eec7ea7ad71ce7aec9d662c30" translate="yes" xml:space="preserve">
          <source>Public Protected Default and private are access modifiers.</source>
          <target state="translated">Public Protected Default和Private是访问修改器。</target>
        </trans-unit>
        <trans-unit id="5df8a0072d803165a9f31208c9db4592974fa499" translate="yes" xml:space="preserve">
          <source>Public access modifier - public:</source>
          <target state="translated">公共访问修改器 ----公共。</target>
        </trans-unit>
        <trans-unit id="483bf2075c12023a5e849d12a42027be89c5e94b" translate="yes" xml:space="preserve">
          <source>Published</source>
          <target state="translated">Published</target>
        </trans-unit>
        <trans-unit id="79337cebe0b8469f44ee26dd522be3c1abbde46b" translate="yes" xml:space="preserve">
          <source>References links</source>
          <target state="translated">参考资料链接</target>
        </trans-unit>
        <trans-unit id="23c4f19c70076332ae76378be5204b96f6c98f0f" translate="yes" xml:space="preserve">
          <source>Related Answers</source>
          <target state="translated">相关答案</target>
        </trans-unit>
        <trans-unit id="56eee76535b8adfa9fe3329a7d09b87c34cc1f70" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/267781/java-class-accessibility&quot;&gt;Java Class Accessibility&lt;/a&gt;</source>
          <target state="translated">相关： &lt;a href=&quot;https://stackoverflow.com/questions/267781/java-class-accessibility&quot;&gt;Java类可访问性&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17d8ed1a776981997da35f245b5fd1b0aca174fa" translate="yes" xml:space="preserve">
          <source>So bottom line is, &lt;strong&gt;protected members can be accessed in other packages, only if some class from this other package, extends class enclosing this protected member and protected member is accessed on 'this' reference or explicit instances of extended class, within definition of extended class.&lt;/strong&gt;</source>
          <target state="translated">因此，最重要的是， &lt;strong&gt;只有在其他包中的某个类扩展了包含该受保护成员的类的扩展类并且可以在扩展对象的定义内的&amp;ldquo; this&amp;rdquo;引用或扩展类的显式实例上访问受保护成员时，才可以在其他包中访问受保护成员。类。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21d3937db339f6e43775069049c209555c9447c1" translate="yes" xml:space="preserve">
          <source>So, rule of thumb is to make things only as visible as they have to be.  Start with private and only add more visibility as needed.  Only make public that which is absolutely necessary for the user to know, every detail you make public cramps your ability to redesign the system.</source>
          <target state="translated">所以,经验法则是让事情只在可视范围内进行。从私密性开始,只在需要时增加更多的可见性。只公开那些用户绝对需要知道的东西,你公开的每一个细节都会影响你重新设计系统的能力。</target>
        </trans-unit>
        <trans-unit id="154dbc9264721e755cac5da7fa4be2894fd9a2ab" translate="yes" xml:space="preserve">
          <source>Some related questions:</source>
          <target state="translated">一些相关问题:</target>
        </trans-unit>
        <trans-unit id="4b2dc2e152a6049bc5dd339a5aaa36977da34901" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;http://www.trytoprogram.com/cplusplus-programming/access-specifiers/&quot;&gt; Access Specifiers &amp;ndash; Private, Public and Protected
&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;http://www.trytoprogram.com/cplusplus-programming/access-specifiers/&quot;&gt;访问说明&amp;ndash;私有，公共和受保护&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c03da846ed372f26ddbd2660e72f7d8755c812d7" translate="yes" xml:space="preserve">
          <source>Start with the most restrictive (private) and see if you need less restrictive modifiers later on.</source>
          <target state="translated">先从限制性最强的(私人的)开始,看看以后是否需要限制性较弱的修饰语。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2db7bd0663d3a295c6b4c5b37588b2c72bf5eb2d" translate="yes" xml:space="preserve">
          <source>Swift access modifiers</source>
          <target state="translated">快速访问修改器</target>
        </trans-unit>
        <trans-unit id="d3b8c8a1daa787e5c27587774294ce4f3fd4a1b6" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; access (specified by the absence of a keyword) is also called &lt;a href=&quot;https://stackoverflow.com/questions/5416074/java-package-private-terminology&quot;&gt;&lt;strong&gt;package-private&lt;/strong&gt;&lt;/a&gt;. Exception: in an interface, no modifier means public access; modifiers other than public are forbidden. Enum constants are always public.</source>
          <target state="translated">&amp;ldquo;默认&amp;rdquo;访问权限（由缺少关键字指定）也称为&lt;a href=&quot;https://stackoverflow.com/questions/5416074/java-package-private-terminology&quot;&gt;&lt;strong&gt;package-private&lt;/strong&gt;&lt;/a&gt; 。 例外：在接口中，没有修饰符表示公共访问； 禁止使用除public之外的修饰符。 枚举常量始终是公共的。</target>
        </trans-unit>
        <trans-unit id="2586c08972816888f55708f755c54e0e86ec9ba4" translate="yes" xml:space="preserve">
          <source>The access specifiers can be strictly ordered</source>
          <target state="translated">访问指定器可以被严格排序</target>
        </trans-unit>
        <trans-unit id="df6efd781f79998f9f898aa9e074a442cdff5a02" translate="yes" xml:space="preserve">
          <source>The difference can be found in the links already provided but which one to use usually comes down to the &quot;Principle of Least Knowledge&quot;. Only allow the least visibility that is needed.</source>
          <target state="translated">在已经提供的链接中可以找到区别,但使用哪一个通常归结为 &quot;最小知识原则&quot;。只让最小的能见度,才是最需要的。</target>
        </trans-unit>
        <trans-unit id="679e82b3df66656fd5d1f4c9549d8ab9122877e6" translate="yes" xml:space="preserve">
          <source>The first data column indicates whether the class itself has access to
  the member defined by the access level. As you can see, a class always
  has access to its own members. The second column indicates whether
  classes in the same package as the class (regardless of their
  parentage) have access to the member. The third column indicates
  whether subclasses of the class declared outside this package have
  access to the member. The fourth column indicates whether all classes
  have access to the member.</source>
          <target state="translated">第一个数据列表示类本身是否可以访问由访问级别定义的成员。可以看到,一个类总是对自己的成员有访问权限。第二列表示与该类处于同一包中的类(无论其父类如何)是否可以访问该成员。第三列表示在这个包之外的类的子类是否可以访问该成员。第四列表示是否所有类都可以访问该成员。</target>
        </trans-unit>
        <trans-unit id="c3ef407bfffcf2e4ffd72f9afb533124d421f084" translate="yes" xml:space="preserve">
          <source>The following situations are not valid.</source>
          <target state="translated">下列情况不成立的。</target>
        </trans-unit>
        <trans-unit id="6e0ae3808955f5f848f420a39b6f2822eb0679d1" translate="yes" xml:space="preserve">
          <source>The following table shows the access to members permitted by each
  modifier.</source>
          <target state="translated">下表显示了每个修改器所允许的成员访问量:</target>
        </trans-unit>
        <trans-unit id="6c3b0509347cd9fae8904b92da0d10e55784f19a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;foo()&lt;/code&gt; can be called in 4 contexts:</source>
          <target state="translated">可以在4个上下文中调用 &lt;code&gt;foo()&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="d356b3ec320b607fd260202ec32d80a6d8ebd453" translate="yes" xml:space="preserve">
          <source>The most misunderstood access modifier in Java is &lt;code&gt;protected&lt;/code&gt;. We know that it's similar to the default modifier with one exception in which subclasses can see it. But how? Here is an example which hopefully clarifies the confusion:</source>
          <target state="translated">Java中最容易理解的访问修饰符 &lt;code&gt;protected&lt;/code&gt; 。 我们知道它类似于默认修饰符，但有一个例外，子类可以看到它。 但是如何？ 这是一个示例，希望可以澄清这种混淆：</target>
        </trans-unit>
        <trans-unit id="be00e0232f8d8959670788550d4e065b0397435d" translate="yes" xml:space="preserve">
          <source>The protected access modifier cannot be applied to class and interfaces. Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.</source>
          <target state="translated">受保护的访问修改器不能应用于类和接口。方法、字段可以被声明为保护,但是接口中的方法和字段不能被声明为保护。</target>
        </trans-unit>
        <trans-unit id="169ba09f6c249dafbff995f433c80a45b0644db7" translate="yes" xml:space="preserve">
          <source>They are meant for encapsulation, or hiding and showing contents of the class.</source>
          <target state="translated">它们是为了封装,或隐藏和显示类的内容。</target>
        </trans-unit>
        <trans-unit id="682ffc8981fc2bc88a6aeadf052aa2ee7fc48504" translate="yes" xml:space="preserve">
          <source>This access is more restricted than public and protected, but less restricted than private.</source>
          <target state="translated">这种准入比起公共的和保护的限制多,但比起私人的限制少。</target>
        </trans-unit>
        <trans-unit id="ee4eefa591c2b5d729b2fadc0b84fbb3c332905c" translate="yes" xml:space="preserve">
          <source>This is related to Java &lt;a href=&quot;https://en.wikipedia.org/wiki/Access_modifiers&quot;&gt;Access Modifiers&lt;/a&gt;.</source>
          <target state="translated">这与Java &lt;a href=&quot;https://en.wikipedia.org/wiki/Access_modifiers&quot;&gt;Access修饰符有关&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="198b4459a701114bd5c61fdbe1c4faf71ffb4fe3" translate="yes" xml:space="preserve">
          <source>This is where the idea of &quot;published&quot; comes in.  Changing an interface (refactoring it) requires that you find all the code which is using it and change that, too.  If the interface is private, well no problem.  If it's protected you have to go find all your subclasses.  If it's public you have to go find all the code which uses your code.  Sometimes this is possible, for example if you're working on corporate code that's for internal use only it doesn't matter if an interface is public.  You can grab all the code out of the corporate repository.  But if an interface is &quot;published&quot;, if there is code using it outside your control, then you're hosed.  You must support that interface or risk breaking code.  Even protected interfaces can be considered published (which is why I don't bother with protected).</source>
          <target state="translated">这就是 &quot;发布 &quot;这个概念的由来。改变一个接口(重构)需要你找到所有使用该接口的代码,并改变它。如果这个接口是私有的,那么没问题。如果它是受保护的,你必须去找所有的子类。如果它是公共的,你必须找到所有使用你的代码。有时这是有可能的,比如说,如果你在做企业代码,只用于内部使用,那么接口是否是公共的就无所谓了。你可以从企业代码库中抓取所有的代码。但如果一个接口是 &quot;发布的&quot;,如果有代码在你的控制范围之外使用它,那么你就完蛋了。你必须支持该接口,否则就会有破坏代码的风险。即使是受保护的接口也可以被认为是 &quot;发布 &quot;的(这也是我不屑于使用受保护的接口的原因)。</target>
        </trans-unit>
        <trans-unit id="6b5d1e74f2eea7ead15ccf29069baea5d0f69c05" translate="yes" xml:space="preserve">
          <source>This page writes well about the protected &amp;amp; default access modifier</source>
          <target state="translated">该页面很好地描述了受保护的默认访问修饰符</target>
        </trans-unit>
        <trans-unit id="eeb5424c66259e76273a69d238cdcc3c9e66fd22" translate="yes" xml:space="preserve">
          <source>To access if you are in same package you can access directly, but if you are in another package then you can create an object of the class.</source>
          <target state="translated">如果你在同一个包中,你可以直接访问,但如果你在另一个包中,你可以创建一个类的对象。</target>
        </trans-unit>
        <trans-unit id="14ae94913500b0661223e0efa7a5e7ca28857425" translate="yes" xml:space="preserve">
          <source>To access protected field defined in base class you can create object of child class.</source>
          <target state="translated">要访问基类中定义的保护字段,可以创建子类的对象。</target>
        </trans-unit>
        <trans-unit id="0ad466926d52efdf7885ec86fe714f4f216f7680" translate="yes" xml:space="preserve">
          <source>To access you can create an object of the class. But you can not access this variable outside of the package.</source>
          <target state="translated">要访问,你可以创建一个类的对象。但你不能在包外访问这个变量。</target>
        </trans-unit>
        <trans-unit id="1fb58ec9231bc98bca307ae528c066d345048ea9" translate="yes" xml:space="preserve">
          <source>Top level class(first level scope) can be &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt;. &lt;code&gt;Nested class&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/59220181/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt; can have any of them</source>
          <target state="translated">顶级类（第一级作用域）可以是 &lt;code&gt;public&lt;/code&gt; 和 &lt;code&gt;default&lt;/code&gt; 。 &lt;code&gt;Nested class&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/59220181/4770877&quot;&gt;&lt;sup&gt;[关于]&lt;/sup&gt;&lt;/a&gt;可以有任何一个</target>
        </trans-unit>
        <trans-unit id="384f7244462f630639626ae0b32c7bdfb001d0ba" translate="yes" xml:space="preserve">
          <source>Using the private modifier is the main way that an object encapsulates itself and hides data from the outside world.</source>
          <target state="translated">使用私有化修改器是对象对自身进行封装并向外界隐藏数据的主要方式。</target>
        </trans-unit>
        <trans-unit id="ab4e39861714a7bba115c44241b41a0b85300324" translate="yes" xml:space="preserve">
          <source>Variables and methods can be declared without any modifiers that are called. Default examples:</source>
          <target state="translated">变量和方法可以在没有任何修饰符被调用的情况下声明。默认的例子。</target>
        </trans-unit>
        <trans-unit id="34077ede14eaaebed19ee0bede3eea6d7f3eb11e" translate="yes" xml:space="preserve">
          <source>Variables that are declared private can be accessed outside the class if public getter methods are present in the class.</source>
          <target state="translated">如果类中存在公共getter方法,那么被声明为私有的变量可以在类外访问。</target>
        </trans-unit>
        <trans-unit id="0a50d48aa080a7c6783e40cbfdb6e97dd79fc57b" translate="yes" xml:space="preserve">
          <source>Variables, methods and constructors which are declared protected in a superclass can be accessed only by the subclasses in another package or any class within the package of the protected members' class.</source>
          <target state="translated">在超级类中声明为保护的变量、方法和构造函数只能被另一个包中的子类或被保护的成员类的包内的任何类访问。</target>
        </trans-unit>
        <trans-unit id="12f084bc06fb25984a713a05ac96ec8fd8c87e3e" translate="yes" xml:space="preserve">
          <source>Visible outside the code I control.  (While not Java syntax, it is important for this discussion).</source>
          <target state="translated">可见在我控制的代码之外。虽然不是Java语法,但这对这次讨论很重要)。</target>
        </trans-unit>
        <trans-unit id="14bcee1179ba8505e906f60fb57592380df65a40" translate="yes" xml:space="preserve">
          <source>Visible to the class only (&lt;strong&gt;private&lt;/strong&gt;).</source>
          <target state="translated">仅对班级可见（ &lt;strong&gt;私人&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f09f62b5791cfabbdd6e4c34df55d9bdb437435" translate="yes" xml:space="preserve">
          <source>Visible to the package and all subclasses (&lt;strong&gt;protected&lt;/strong&gt;).</source>
          <target state="translated">对包和所有子类（ &lt;strong&gt;protected&lt;/strong&gt; ）可见。</target>
        </trans-unit>
        <trans-unit id="54ef9402017fe93855f3b30d829bfd206f6e7f50" translate="yes" xml:space="preserve">
          <source>Visible to the package. The default. No modifiers are needed.</source>
          <target state="translated">可见,在包中。默认情况下。不需要修饰符。</target>
        </trans-unit>
        <trans-unit id="ca587ffd93b05980f46dc7a85340bbf8390ffe51" translate="yes" xml:space="preserve">
          <source>Visible to the world (&lt;strong&gt;public&lt;/strong&gt;).</source>
          <target state="translated">对世界（ &lt;strong&gt;公共&lt;/strong&gt; ）可见。</target>
        </trans-unit>
        <trans-unit id="546b60f326b8d6a60c507410a570c1777530716c" translate="yes" xml:space="preserve">
          <source>We all use method and member modifiers like private, public, ... but one thing too few developers do is use packages to &lt;strong&gt;organize&lt;/strong&gt; code logically.</source>
          <target state="translated">我们都使用方法和成员修饰符，例如private，public ...，但是很少有开发人员做的一件事是使用包来逻辑地&lt;strong&gt;组织&lt;/strong&gt;代码。</target>
        </trans-unit>
        <trans-unit id="0e9aa520836ae4a575fd28c23d90b4382f8165ec" translate="yes" xml:space="preserve">
          <source>We cannot Override the Static fields.if you try to override it does not show any error 
but it doesnot work what we except.</source>
          <target state="translated">我们不能覆盖静态字段,如果你试图覆盖它不会显示任何错误,但它不能像我们所想的那样工作。</target>
        </trans-unit>
        <trans-unit id="e35308834027bed876c4f7f710ec90003c87538e" translate="yes" xml:space="preserve">
          <source>What access specifiers apply to</source>
          <target state="translated">哪些访问指定器适用于</target>
        </trans-unit>
        <trans-unit id="d80aa50837cce957e5ce3fb6bafde8063b8ddb68" translate="yes" xml:space="preserve">
          <source>What is the difference between public, protected, package-private and private in Java</source>
          <target state="translated">Java中的公有、受保护、包-私有和私有的区别是什么?</target>
        </trans-unit>
        <trans-unit id="b46b79fb2f1824c3f83b93eb49daf91f0e91d07b" translate="yes" xml:space="preserve">
          <source>When exposing members ask yourself if you are exposing representation choices or abstraction choices. The first is something you want to avoid as it will introduce too many dependencies on the actual representation rather than on its observable behavior.</source>
          <target state="translated">当暴露成员时,请问自己,你是在暴露表示选择还是抽象选择。前者是你要避免的,因为它将引入太多依赖实际表示,而不是依赖它的可观察行为。</target>
        </trans-unit>
        <trans-unit id="e2edee9f094279931ccc7f4853b4b3611fed2c3b" translate="yes" xml:space="preserve">
          <source>When should you use what?  The whole idea is encapsulation to hide information.  As much as possible you want to hide the detail of how something is done from your users.  Why?  Because then you can change them later and not break anybody's code.  This lets you optimize, refactor, redesign and fix bugs without worry that someone was using that code you just overhauled.</source>
          <target state="translated">什么时候应该用什么?整个想法就是封装来隐藏信息。你要尽可能多的向用户隐藏一些细节,让他们知道一些事情是怎么做的。为什么要隐藏?因为这样你就可以在以后修改它们,而不会破坏任何人的代码。这让你可以进行优化、重构、重新设计和修复bug,而不用担心有人在使用你刚刚大修的代码。</target>
        </trans-unit>
        <trans-unit id="79af6581bf04a23396460cd17b21987c89702dec" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, then you should use protected access specifier for data member within Class1 if you don't want this member to be accessed outside your package (say in package of consumer of your package i.e. client who is using your APIs) in general, but you want to make an exception and allow access to this member only if client writes class say Class2 that extends Class1. So, in general, protected members will be accessible on 'this' reference in derived classes i.e. Class2 and also on explicit instances of Class2.</source>
          <target state="translated">当你在开发一些包,因此在包中的一些类(比如说Class1)时,如果你不希望这个成员在包外(比如说在你的包的消费者的包中,也就是使用你的API的客户机中)被访问,那么你应该为Class1中的数据成员使用protected access specifier,但是你想做一个例外,只有当客户机写了类,比如说Class2,扩展了Class1的Class2时,才允许访问这个成员。所以,一般情况下,受保护的成员可以在派生类中的 &quot;this &quot;引用中访问,也就是Class2,也可以在Class2的显式实例中访问。</target>
        </trans-unit>
        <trans-unit id="027f6037ffd06215488adde61c7e586ebdeedc8b" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, then you should use public access specifier for data member within Class1 if you want this member to be accessible in other packages on instance of Class1 created in some class of other package. &lt;strong&gt;Basically this access specifier should be used when you intent to expose your data member to world without any condition.&lt;/strong&gt;</source>
          <target state="translated">当您开发某个包并在其中开发某个类（例如Class1）时，如果您希望该成员在其他包的某个类中创建的Class1实例的其他包中可访问，则应该对Class1中的数据成员使用公共访问说明符包。 &lt;strong&gt;基本上，当您打算将数据成员无条件公开给世界时，应使用此访问说明符。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de23e22099f028dd172f317f3ef75423c6e9cb8a" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, you may use default (need not be mentioned explicitly) access specifier, to expose member within class, to other classes within your (same) package. In these other classes (within same package), you can access these default members on instance of Class1. Also you can access these default members within subclasses of Class1, say Class2 (on this reference or on instance of Class1 or on instance of Class2).</source>
          <target state="translated">当你正在开发一些包,因此在其中的一些类(比如说Class1),你可以使用默认的(不需要明文提到)访问指定器,将类内的成员暴露给(同一包内)的其他类。在这些其他类中(同一包内),你可以在Class1的实例上访问这些默认成员。同样,你也可以在Class1的子类中访问这些默认成员,比如说Class2(在这个引用上或在Class1的实例上或在Class2的实例上)。</target>
        </trans-unit>
        <trans-unit id="ab5f7c5da1e908785059d10eee82f660fd70e889" translate="yes" xml:space="preserve">
          <source>When you are thinking of access modifiers just think of it in this way (applies to both &lt;strong&gt;variables&lt;/strong&gt; and &lt;strong&gt;methods&lt;/strong&gt;):</source>
          <target state="translated">当您想到访问修饰符时，只需以这种方式考虑一下（适用于&lt;strong&gt;变量&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b2cf35e176192eaa161d1a6d979b561f22449218" translate="yes" xml:space="preserve">
          <source>When you bring him to the campus, the first thing that you and your friend sees is this statue. This means that anyone who walks in the campus can look at the statue without the university's permission. This makes the statue as &lt;strong&gt;PUBLIC&lt;/strong&gt;.</source>
          <target state="translated">当您将他带到校园时，您和您的朋友首先看到的是这座雕像。 这意味着在校园里散步的任何人都可以在未经大学许可的情况下看雕像。 这使得雕像成为&lt;strong&gt;PUBLIC&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9733e2040efa0c9d4a97d71582ab64f36a523dfc" translate="yes" xml:space="preserve">
          <source>When you write another class Class3 within same/different package
that extends Class2, protected member from Class1 will be accessible
on this reference and also on explicit instance of Class3. This will
be true for any hierarchy that is extended i.e. protected member
will still be accessible on this reference or instance of extended
class. Note that in Class3, if you create instance of Class2 then
you will not be able to access protected member from Class1 though
it is inherited.</source>
          <target state="translated">当你在同一个不同的包中写另一个类Class3扩展了Class2时,Class1中的protected member将在这个引用上和Class3的显式实例上访问。这对于任何被扩展的层次结构都是如此,也就是说,受保护的成员仍然可以在这个引用或扩展类的实例上访问。注意,在Class3中,如果你创建了Class2的实例,那么你将无法访问来自Class1的受保护成员,尽管它是继承的。</target>
        </trans-unit>
        <trans-unit id="7db19bf48ccf8618b8d48b1bccd529b75f5e1638" translate="yes" xml:space="preserve">
          <source>Which modifier to choose?</source>
          <target state="translated">该选择哪种修饰语?</target>
        </trans-unit>
        <trans-unit id="78394873daaf3ca1c582b2022bd91ff90bffcfbf" translate="yes" xml:space="preserve">
          <source>You also have to consider &lt;em&gt;nested&lt;/em&gt; scopes, such as inner classes. An example of the complexity is that inner classes have members, which themselves can take access modifiers. So you can have a private inner class with a public member; can the member be accessed? (See below.) The general rule is to look at scope and think recursively to see whether you can access each level.</source>
          <target state="translated">您还必须考虑&lt;em&gt;嵌套&lt;/em&gt;作用域，例如内部类。 复杂性的一个示例是内部类具有成员，这些成员本身可以使用访问修饰符。 因此，您可以与公共成员一起拥有私人内部类； 可以访问该成员吗？ （请参见下文。）一般规则是查看范围并进行递归思考，以查看是否可以访问每个级别。</target>
        </trans-unit>
        <trans-unit id="6a9833145068de24bf1a54b7ae1bbaa1ff417a9d" translate="yes" xml:space="preserve">
          <source>You need access to a constructor to construct an object. Thus if all constructors are private, the class can only be constructed by code living within the class (typically static factory methods or static variable initializers). Similarly for package-private or protected constructors.</source>
          <target state="translated">你需要访问构造函数来构造一个对象。因此,如果所有的构造函数都是私有的,那么类只能由类内的代码来构造(通常是静态工厂方法或静态变量初始化器)。同样,对于包-私有或受保护的构造函数也是如此。</target>
        </trans-unit>
        <trans-unit id="13ebc736719c7b0ac170a13671dcbca61014c961" translate="yes" xml:space="preserve">
          <source>You won't be able to access inherited protected member of Class1 in
Class2, if you attempt to access it on explicit instance of Class1,
although it is inherited in it.</source>
          <target state="translated">如果你试图在Class1的显式实例上访问Class1的受保护成员,尽管它在Class2中是继承的,但你将无法访问Class1中继承的受保护成员。</target>
        </trans-unit>
        <trans-unit id="0342c9aebe9dfc86b2722a15889bef207a17eb8e" translate="yes" xml:space="preserve">
          <source>Your friend wants to login to the campus WiFi but doesn't have the any credentials to do so. The only way he can get online is if you share your login with him. (Remember, every student who goes to the university also possesses these login credentials). This would make your login credentials as &lt;strong&gt;NO MODIFIER&lt;/strong&gt;.</source>
          <target state="translated">您的朋友想登录校园WiFi，但没有任何凭据。 他上线的唯一方法是与他共享登录信息。 （请记住，每个上大学的学生都拥有这些登录凭据）。 这将使您的登录凭据为&lt;strong&gt;NO MODIFIER&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="0c6a031212fa407e33d1f50ffda6a1bf40baaa82" translate="yes" xml:space="preserve">
          <source>default (no modifier specified): accessible by the classes of the same package.</source>
          <target state="translated">默认(未指定修改器):可由同一包中的类访问。</target>
        </trans-unit>
        <trans-unit id="64fa1dc60398c6bcdee08aa6c839a166432e015b" translate="yes" xml:space="preserve">
          <source>default (package)</source>
          <target state="translated">默认的</target>
        </trans-unit>
        <trans-unit id="81d4e9552c19ab8c332c76804f094d59bfe0653c" translate="yes" xml:space="preserve">
          <source>meaning that &lt;code&gt;public&lt;/code&gt; provides the most access, &lt;code&gt;private&lt;/code&gt; the least. Any reference possible on a private member is also valid for a package-private member; any reference to a package-private member is valid on a protected member, and so on. (Giving access to protected members to other classes in the same package was considered a mistake.)</source>
          <target state="translated">意味着 &lt;code&gt;public&lt;/code&gt; 提供最多的访问权限， &lt;code&gt;private&lt;/code&gt; 提供最少的访问权限。 私有成员上的任何引用对于包私有成员也有效； 对包专用成员的任何引用在受保护成员上均有效，依此类推。 （将受保护的成员授予同一程序包中的其他类的访问权限被认为是错误的。）</target>
        </trans-unit>
        <trans-unit id="e80721793c24ae14edfca9b26ad406a9815cd3ff" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>
        </trans-unit>
        <trans-unit id="964cab4bb4a5111731b0c00dbb43f794698d8731" translate="yes" xml:space="preserve">
          <source>protected</source>
          <target state="translated">protected</target>
        </trans-unit>
        <trans-unit id="61c9b2b17db77a27841bbeeabff923448b0f6388" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>
        </trans-unit>
        <trans-unit id="10aa8b2ec5bd3e37ab9afc32631742bf8b2f7f90" translate="yes" xml:space="preserve">
          <source>public &amp;gt; protected &amp;gt; package-private &amp;gt; private</source>
          <target state="translated">公共&amp;gt;受保护&amp;gt;包私有&amp;gt;私有</target>
        </trans-unit>
        <trans-unit id="04e4d31337d73d519a701e0100bf1767c9be25cc" translate="yes" xml:space="preserve">
          <source>then we have this simple table:</source>
          <target state="translated">那么我们就有了这个简单的表格。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
