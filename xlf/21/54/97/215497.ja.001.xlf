<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/215497">
    <body>
      <group id="215497">
        <trans-unit id="9c3a7eb169356df9222bd586b22d0df4e9a13f8c" translate="yes" xml:space="preserve">
          <source>(Caveat:  I am not a Java programmer, I am a Perl programmer.  Perl has no formal protections which is perhaps why I understand the problem so well :) )</source>
          <target state="translated">(注意:私はJavaプログラマではなく、Perlプログラマです。Perlには正式な保護がありませんので、私がこの問題をよく理解している理由かもしれません。))</target>
        </trans-unit>
        <trans-unit id="0a36612cffe057499a0611c73fed1aa932c69c44" translate="yes" xml:space="preserve">
          <source>....
Protected: Protected access modifier is the a little tricky and you can say is a superset of the default access modifier. Protected members are same as the default members as far as the access in the same package is concerned. The difference is that, the protected members are also accessible to the subclasses of the class in which the member is declared which are outside the package in which the parent class is present.</source>
          <target state="translated">....Protected.Protected アクセス修飾子は少し厄介なもので、デフォルトのアクセス修飾子のスーパーセットと言えます。保護されたメンバーは、同じパッケージ内でのアクセスに関してはデフォルトのメンバーと同じです。違いは、保護されたメンバーは、親クラスが存在するパッケージの外にある、メンバーが宣言されたクラスのサブクラスにもアクセスできるということです。</target>
        </trans-unit>
        <trans-unit id="bb129938f682e401003e1aed2ed4b40494353513" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;The official tutorial&lt;/a&gt; may be of some use to you.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;公式チュートリアル&lt;/a&gt;が役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="a40d787e477845abe3af3bd4319e70db8b848c65" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&lt;/a&gt;&lt;a href=&quot;http://www.tutorialspoint.com/java/java_access_modifiers.htm&quot;&gt;http://www.tutorialspoint.com/java/java_access_modifiers.htm&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&lt;/a&gt;&lt;a href=&quot;http://www.tutorialspoint.com/java/java_access_modifiers.htm&quot;&gt;http://www.tutorialspoint.com/java/java_access_modifiers.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c31ee98b0e56e1e2ad44c152f3835eb79ef6b74d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/676930/private-member-access-java&quot;&gt;A class's methods &lt;em&gt;are&lt;/em&gt; allowed to access private members of other objects of the same class.&lt;/a&gt; More precisely, a method of class C can access private members of C on objects of any subclass of C. Java doesn't support restricting access by instance, only by class. (Compare with Scala, which does support it using &lt;code&gt;private[this]&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/676930/private-member-access-java&quot;&gt;クラスのメソッド&lt;em&gt;は&lt;/em&gt; 、同じクラスの他のオブジェクトのプライベートメンバーにアクセスできます。&lt;/a&gt; より正確には、クラスCのメソッドは、Cの任意のサブクラスのオブジェクトのCのプライベートメンバーにアクセスできます。Javaは、インスタンスによるアクセス制限をサポートしていません。クラスによってのみ制限しています。 （ &lt;code&gt;private[this]&lt;/code&gt; を使用してサポートしているScalaと比較してください 。）</target>
        </trans-unit>
        <trans-unit id="8f7f1dc8bc472b94392e3bd3ed6215989161afa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; (or &lt;code&gt;package-private&lt;/code&gt;): package scope.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; （または &lt;code&gt;package-private&lt;/code&gt; ）：パッケージのスコープ。</target>
        </trans-unit>
        <trans-unit id="3d298ea01eb1875fcce90ecc58ed559377bd324e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; --&amp;gt; No access modifier keyword is present. This means it is available strictly within the package of the class. &lt;strong&gt;Nowhere&lt;/strong&gt; outside that package it can be accessed.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; -&amp;gt;アクセス修飾子キーワードはありません。 つまり、クラスのパッケージ内でのみ使用できます。 そのパッケージの外部にはアクセスできません。</target>
        </trans-unit>
        <trans-unit id="632f0c7f906968661339fb461c45f7088fc72706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; is not apply to package hierarchy</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; はパッケージ階層に適用されません</target>
        </trans-unit>
        <trans-unit id="ad079c92642a022565d1ecd33455b4303c1a0f85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; --&amp;gt; accessible only within the same class where it is declared</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; - &amp;gt;宣言されているのと同じクラス内でのみアクセス可能</target>
        </trans-unit>
        <trans-unit id="9f1519bd1834a636bcfd85562fc722c65063bd03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: accessible within the same class only.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; ：同じクラス内でのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="463f7217c25ecb5d72756d802aad36eb4f6fe8b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: class scope.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; ：クラススコープ。</target>
        </trans-unit>
        <trans-unit id="af2e4fa6e526002b3cd89f765ab0e780189d733b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; --&amp;gt; Slightly less stricter than &lt;code&gt;default&lt;/code&gt; and apart from the same package classes it can be accessed by sub classes outside the &lt;em&gt;package&lt;/em&gt; it is declared.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; -&amp;gt; &lt;code&gt;default&lt;/code&gt; よりも少し厳しくなく、同じパッケージクラスは別として、宣言された&lt;em&gt;パッケージの&lt;/em&gt;外部のサブクラスからアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c5a581c238cfb204babe7a22d7bc46e3fa3256dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: &lt;code&gt;package scope + child&lt;/code&gt; (like package, but we can subclass it from different packages). The protected modifier always keeps the &quot;parent-child&quot; relationship.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; ： &lt;code&gt;package scope + child&lt;/code&gt; （パッケージのようですが、異なるパッケージからサブクラス化できます）。 保護された修飾子は常に「親子」関係を維持します。</target>
        </trans-unit>
        <trans-unit id="910fdd220b274308d3d2344d80bf0070904f5aa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: accessible by the classes of the same package and the subclasses residing in any package.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; ：同じパッケージのクラス、および任意のパッケージにあるサブクラスからアクセスできます。</target>
        </trans-unit>
        <trans-unit id="050d466202fbb4d01a4953aeadb3468653e9d848" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; --&amp;gt; accessible from every where</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; -&amp;gt;どこからでもアクセス可能</target>
        </trans-unit>
        <trans-unit id="0a072f8abd92b9840a119d8fd2cb36807b61f4b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;: accessible from everywhere.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; ：どこからでもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a9e5f72177dfd12fd5219a4e1db9d66c86b32aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;: everywhere.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; ：どこでも。</target>
        </trans-unit>
        <trans-unit id="cd953930c2c863ea399304a3c30036133536f2ae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A class, method, constructor, interface etc declared public can be accessed from any other class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;クラス、メソッド、コンストラクター、インターフェースなどのpublic宣言は、他のクラスからアクセスできます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be09917e70f565d8c708abe4cd6e61635b34eda0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A variable or method declared without any access control modifier is available to any other class in the same package. The fields in an interface are implicitly public static final and the methods in an interface are by default public.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;アクセス制御修飾子なしで宣言された変数またはメソッドは、同じパッケージ内の他のクラスで使用できます。&lt;/em&gt; &lt;em&gt;インターフェースのフィールドは暗黙的にpublic static finalであり、インターフェースのメソッドはデフォルトでpublicです。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee011cda99cb49527b83f0a5b8919102a1698c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;クラス継承のため、クラスのすべてのパブリックメソッドと変数は、そのサブクラスによって継承されます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad348a2083c2d62016b21c1d255f3de23fa10b04" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class and Interface&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;クラスとインターフェース&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eaf0f2821bca046e8de9d5d37c914cacefc406cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Default access modifier means we do not explicitly declare an access modifier for a class, field, method, etc.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;デフォルトのアクセス修飾子とは、クラス、フィールド、メソッドなどのアクセス修飾子を明示的に宣言しないことを意味します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb32cde4a8fce643003f72d2e1ba00918148a8da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Different Packages&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;異なるパッケージ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d207fca631fc5ab4283a1e1cfa2b49aaaa7a4fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However if the public class we are trying to access is in a different package, then the public class still need to be imported.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ただし、アクセスしようとしているパブリッククラスが別のパッケージにある場合でも、パブリッククラスをインポートする必要があります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed9665876783be76d2d202971e92d2ede6dcd26f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods, Variables and Constructors that are declared private can only be accessed within the declared class itself.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;プライベートとして宣言されたメソッド、変数、およびコンストラクターは、宣言されたクラス自体内でのみアクセスできます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c601c4a206533aa7d299807e34c12f78d76e7236" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;メソッド、フィールドは保護されていると宣言できますが、インターフェースのメソッドとフィールドは保護されていると宣言できません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="607c9d99976709c606c4f88193f8de1144d0b2fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Private access modifier is the most restrictive access level. Class and interfaces cannot be private.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;プライベートアクセス修飾子は、最も制限的なアクセスレベルです。&lt;/em&gt; &lt;em&gt;クラスとインターフェースをプライベートにすることはできません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9080a57bc2a9fbd0bde174c2cd9cfb1cc3d4e8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;保護されたアクセスは、サブクラスがヘルパーメソッドまたは変数を使用する機会を与え、関連のないクラスがそれを使用しようとするのを防ぎます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e00422beb6d4fb1981562f55a7072acc71253369" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The protected access modifier cannot be applied to class and interfaces.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;保護されたアクセス修飾子は、クラスとインターフェイスに適用できません。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9e9bd71728a515b974c723b972dd81ff4a911f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Therefore fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java Universe.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;したがって、パブリッククラス内で宣言されたフィールド、メソッド、ブロックは、Javaユニバースに属する任意のクラスからアクセスできます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65b8ac6a51801d8f9df0125860bf27145bcd2152" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Variables that are declared private can be accessed outside the class if public getter methods are present in the class.
Variables, methods and constructors which are declared protected in a superclass can be accessed only by the subclasses in other package or any class within the package of the protected members' class.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;プライベートとして宣言された変数は、クラスにパブリックゲッターメソッドが存在する場合、クラスの外部からアクセスできます。&lt;/em&gt; &lt;em&gt;スーパークラスで保護されていると宣言された変数、メソッド、およびコンストラクターは、他のパッケージのサブクラス、または保護されたメンバーのクラスのパッケージ内のクラスからのみアクセスできます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dfafa3f02ac99007413a76b7fa0132f54e95264" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Within the same Packages&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;同じパッケージ内&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c98ea408dc0e335456b8bc359e5f6e6688da4fb9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class can be package-private. It can only be accessible from same package. Not from sub package, not from outside package.</source>
          <target state="translated">&lt;em&gt;クラス-&amp;gt;&lt;/em&gt;トップレベルのクラスは、パッケージプライベートにすることができます。 同じパッケージからのみアクセスできます。 サブパッケージからではなく、外部パッケージからではありません。</target>
        </trans-unit>
        <trans-unit id="9a2f5c5e06678e57a12196a656cbc25665cdfb9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class cannot be private. inner classes can be private which are accessible from same class.</source>
          <target state="translated">&lt;em&gt;クラス-&amp;gt;&lt;/em&gt;トップレベルのクラスをプライベートにすることはできません。 内部クラスはプライベートにすることができ、同じクラスからアクセスできます。</target>
        </trans-unit>
        <trans-unit id="49557558779971098b1beab7b3aca3d6045daa29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; a top level class cannot be protected.</source>
          <target state="translated">&lt;em&gt;クラス-&amp;gt;&lt;/em&gt;トップレベルのクラスは保護できません。</target>
        </trans-unit>
        <trans-unit id="d03616909ff20fb6283b735f101a6bbb643bb3eb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;class -&amp;gt;&lt;/em&gt; accessible from package/subpackage/another package</source>
          <target state="translated">&lt;em&gt;クラス-&amp;gt;&lt;/em&gt;パッケージ/サブパッケージ/別のパッケージからアクセス可能</target>
        </trans-unit>
        <trans-unit id="c9e263282cf692bb34eb4b225c833709b4cf7edc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; Only accessible in same package or subpackage. Can only be access outside the package while extending class.</source>
          <target state="translated">&lt;em&gt;インスタンス変数-&amp;gt;&lt;/em&gt;同じパッケージまたはサブパッケージでのみアクセスできます。 クラスの拡張中は、パッケージの外部にのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="96c7893be4597454db4583a10a583947d4674561" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible from package/subpackage/another package</source>
          <target state="translated">&lt;em&gt;インスタンス変数-&amp;gt;&lt;/em&gt;パッケージ/サブパッケージ/別のパッケージからアクセス可能</target>
        </trans-unit>
        <trans-unit id="026e2611c853bf535859a5b5903a3be7acf05507" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible from same package. Not from sub package, not from outside package.</source>
          <target state="translated">&lt;em&gt;インスタンス変数-&amp;gt;&lt;/em&gt;同じパッケージからアクセス可能。 サブパッケージからではなく、外部パッケージからではありません。</target>
        </trans-unit>
        <trans-unit id="173b1d875a31dfc5921965ffcf90d681aa11e6a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;instance variable -&amp;gt;&lt;/em&gt; accessible only in the class. Cannot access outside the class.</source>
          <target state="translated">&lt;em&gt;インスタンス変数-&amp;gt;&lt;/em&gt;クラスでのみアクセス可能。 クラス外にはアクセスできません。</target>
        </trans-unit>
        <trans-unit id="5f686cfad1f0d2953f73e22512646f451cc92170" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(D)irect&lt;/strong&gt; (invoke from a method inside the same class, or via &quot;this&quot; syntax).</source>
          <target state="translated">&lt;strong&gt;（D）irect&lt;/strong&gt; （同じクラス内のメソッドから、または「this」構文を使用して呼び出します）。</target>
        </trans-unit>
        <trans-unit id="2f0ba70dae68262e43e56b87dcf8848fd89d6328" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(I)nheritance&lt;/strong&gt; (via subclassing).</source>
          <target state="translated">&lt;strong&gt;（I）継承&lt;/strong&gt; （サブクラス化による）。</target>
        </trans-unit>
        <trans-unit id="37f3255a916c82622528f7b0e38edaeecd6e05d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(R)eference&lt;/strong&gt; (invoke a method using a reference to the class, or via &quot;dot&quot; syntax).</source>
          <target state="translated">&lt;strong&gt;（R）eference&lt;/strong&gt; （クラスへの参照を使用するか、「ドット」構文を使用してメソッドを呼び出す）。</target>
        </trans-unit>
        <trans-unit id="d47c24704c2b9863e2e3ea5d7687a108717bebe5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Default:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.デフォルト：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e866b80161e29b930ff930217326b95750c6bf3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Public&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.パブリック&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c5b5405bad9144f153406167830cfeaa7599707" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Private&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.プライベート&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aedac4ee80eebec26a1eb8895f25fc3e9ab66966" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Protected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.保護されている&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10ae501fbb4b985b6a4a6387afbed4b6c308d6df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cb1729758cbd3ed754ecb8b9228916334559d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Access modifiers in Java.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Javaのアクセス修飾子。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1448cd0adc12ffa3db85751d7d788972e1ab2fad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basically, within same package you can access default members on instance of class directly or on 'this' reference in subclasses.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基本的に、同じパッケージ内で、クラスのインスタンスの直接メンバーに、またはサブクラスの「this」参照にアクセスできます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85289d4bbd59b9fc93e676b9dd9d70acb4cca817" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default (no modifier)&lt;/strong&gt;: Limited access to class and package</source>
          <target state="translated">&lt;strong&gt;デフォルト（修飾子なし）&lt;/strong&gt; ：クラスとパッケージへの制限付きアクセス</target>
        </trans-unit>
        <trans-unit id="a1878f65fb532348cd1105c6341d17ed1f134691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default -No keyword:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;デフォルト-キーワードなし：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b04f00e04bc38cbb526378ea597f7474886dbd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default:&lt;/strong&gt; It is accessible in the same package from any of the class of package.</source>
          <target state="translated">&lt;strong&gt;デフォルト：&lt;/strong&gt;パッケージのどのクラスからでも同じパッケージでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1bc0a5d67820f61786ae04d054caabfe5bd3f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41b7f6e44695c115445cfdf86e3775318ae5636a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overriding static methods in java&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Javaでの静的メソッドのオーバーライド&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c1f15f4ebb983532fb274e28770fe57bde1d4d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Package-private (default)&lt;/strong&gt;:
This access specifier will provide access specified by private access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;Package-private（デフォルト）&lt;/strong&gt; ：このアクセス指定子は、以下で説明するアクセスに加えて、プライベートアクセス指定子によって指定されたアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="2394388ff716cba591b2a38592dcfb0fc54be273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private:&lt;/strong&gt;  it can be access in same class.</source>
          <target state="translated">&lt;strong&gt;プライベート：&lt;/strong&gt;同じクラスでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d0ded9f3e89154a12e4907eb9238a15f78247f90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Private&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cb9f56d3c4fd96b6c4e794bc32a4d40c75f7676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;:
When you are developing some class and you want member of this class not to be exposed outside this class then you should declare it as private. private members can be accessed only in class where they are defined i.e. enclosing class. &lt;strong&gt;private members can be accessed on 'this' reference and also on other instances of class enclosing these members, but only within the definition of this class.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プライベート&lt;/strong&gt; ：あるクラスを開発していて、このクラスのメンバーがこのクラスの外部に公開されないようにしたい場合は、プライベートとして宣言する必要があります。 プライベートメンバーは、それらが定義されているクラス（つまり、包含クラス）でのみアクセスできます。 &lt;strong&gt;プライベートメンバーには、 'this'参照およびこれらのメンバーを含むクラスの他のインスタンスでアクセスできますが、このクラスの定義内でのみアクセスできます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d034dfbbb5bc7f21cf96cfb8f1346e544c26d94d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Private&lt;/strong&gt;: Limited access to class only</source>
          <target state="translated">&lt;strong&gt;プライベート&lt;/strong&gt; ：クラスへの限定アクセス</target>
        </trans-unit>
        <trans-unit id="8695d4960b797f2b6f67e904191eb903c43e1aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected:&lt;/strong&gt; you can access variables in same package as well as subclass in any other package.
so basically it is &lt;strong&gt;default + Inherited&lt;/strong&gt; behavior.</source>
          <target state="translated">&lt;strong&gt;保護されてい&lt;/strong&gt;ます&lt;strong&gt;：&lt;/strong&gt;他のパッケージのサブクラスだけでなく、同じパッケージの変数にもアクセスできます。 したがって、基本的には&lt;strong&gt;デフォルト+継承&lt;/strong&gt;動作です。</target>
        </trans-unit>
        <trans-unit id="1cc4ba9e4e89686db9f53e13fd8b66ac42177424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Protected&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d10a4c31137ee8169148752120d940b936bc3f24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Protected&lt;/strong&gt;: Limited access to class, package and subclasses (both inside and outside package)</source>
          <target state="translated">&lt;strong&gt;保護&lt;/strong&gt; ：クラス、パッケージ、およびサブクラス（パッケージの内部と外部の両方）への制限付きアクセス</target>
        </trans-unit>
        <trans-unit id="09bfe678952f0c3d0b3e5646e875cdb224ae65c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public:&lt;/strong&gt; It is basically as simple as you can access from any class whether that is in same package or not.</source>
          <target state="translated">&lt;strong&gt;パブリック：&lt;/strong&gt;基本的に、同じパッケージにあるかどうかに関係なく、どのクラスからでもアクセスできるのと同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="daf97633cf021dedd039ac3d7f17e15721760df8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Public&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ef6e4673df9ec5787ab0c659ebd27e9c95e224b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Public&lt;/strong&gt;: Accessible to class, package (all), and subclasses... In short, everywhere.</source>
          <target state="translated">&lt;strong&gt;Public&lt;/strong&gt; ：クラス、パッケージ（すべて）、およびサブクラスにアクセス可能...つまり、どこでも。</target>
        </trans-unit>
        <trans-unit id="3ea3436ff46ae8818a665ddb071efa68994538cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default&lt;/strong&gt; - accessible from package.</source>
          <target state="translated">&lt;strong&gt;デフォルト&lt;/strong&gt; -パッケージからアクセス可能。</target>
        </trans-unit>
        <trans-unit id="5b4cfa6911291d8ddc421bedd52ed7d82f9ee73d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;package-private:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;package-private:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c53c0e830d80b72103ef701f9080f24a7d1a99a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;private:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;private:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d91069bf7a48c4c4d6a00bfe7860b6cbc143d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;private&lt;/strong&gt; - accessible from its class only.</source>
          <target state="translated">&lt;strong&gt;プライベート&lt;/strong&gt; -クラスからのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="afe8465ac8ccd97429f85b76250e88d3dfed7a2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;protected:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2bed00fc75e7d51b53be0dee63c249e4a93a6e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected&lt;/strong&gt; - accessible from package and sub-classes in other package.
as well</source>
          <target state="translated">&lt;strong&gt;protected-&lt;/strong&gt;パッケージおよび他のパッケージのサブクラスからアクセスできます。 同じように</target>
        </trans-unit>
        <trans-unit id="7056cef6786f8cf6365723485c784d324755daf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;protected&lt;/strong&gt;:
This access specifier will provide access specified by package-private access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;protected&lt;/strong&gt; ：このアクセス指定子は、以下で説明するアクセスに加えて、package-privateアクセス指定子によって指定されたアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="31d169cdb7e077cb9bf36e76bd03f5556f7d9daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;public:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f45ba4381db9194fc2431928eb13db0ea7fad3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt; - accessible from anywhere in the application.</source>
          <target state="translated">public-アプリケーションのどこからでもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c79deadce74e410ea5f7108d88f579a381133846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;public&lt;/strong&gt;: This access specifier will provide access specified by protected access specifier in addition to access described below.</source>
          <target state="translated">&lt;strong&gt;public&lt;/strong&gt; ：このアクセス指定子は、下記のアクセスに加えて、保護されたアクセス指定子によって指定されたアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="d36eb0da54971756790f3d446942c6a1a8ca6054" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;(*) &lt;a href=&quot;https://stackoverflow.com/questions/28612420/what-is-encapsulation-exactly&quot;&gt;What is Encapsulation exactly?&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;（*） &lt;a href=&quot;https://stackoverflow.com/questions/28612420/what-is-encapsulation-exactly&quot;&gt;カプセル化とは正確には何ですか？&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="69e4829657ddc7c46d77dc0bc935268a8736ae11" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;void saveGame(File dst)&lt;/code&gt; method which is called from the GUI code should be public.</source>
          <target state="translated">GUIコードから呼び出される &lt;code&gt;void saveGame(File dst)&lt;/code&gt; メソッドは公開する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a1965065a3a72db5cb5bbc47bad12cce01c8893" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;private&lt;/strong&gt; member (&lt;code&gt;i&lt;/code&gt;) is &lt;em&gt;only&lt;/em&gt; accessible within the same class as it is declared.</source>
          <target state="translated">&lt;strong&gt;プライベート&lt;/strong&gt;メンバー（ &lt;code&gt;i&lt;/code&gt; ）は、宣言されているのと同じクラス内で&lt;em&gt;のみ&lt;/em&gt;アクセスできます。</target>
        </trans-unit>
        <trans-unit id="c567cfcccb536538fb2bff328e96d3817df1bc65" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;protected&lt;/strong&gt; member (&lt;code&gt;k&lt;/code&gt;) is accessible within all classes in the same package &lt;em&gt;and&lt;/em&gt; within subclasses in other packages.</source>
          <target state="translated">&lt;strong&gt;保護された&lt;/strong&gt;メンバー（ &lt;code&gt;k&lt;/code&gt; ）は、同じパッケージのすべてのクラス内&lt;em&gt;および&lt;/em&gt;他のパッケージのサブクラス内でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="eb72f226a8ba71d7c3578d0fab29e570e86013a3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;public&lt;/strong&gt; member (&lt;code&gt;l&lt;/code&gt;) is accessible to all classes (unless it resides in a &lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/sotms/&quot;&gt;module&lt;/a&gt; that does not export the package it is declared in).</source>
          <target state="translated">&lt;strong&gt;パブリック&lt;/strong&gt;メンバー（ &lt;code&gt;l&lt;/code&gt; ）は、宣言されているパッケージをエクスポートしない&lt;a href=&quot;http://openjdk.java.net/projects/jigsaw/spec/sotms/&quot;&gt;モジュール&lt;/a&gt;に常駐している場合を除き、すべてのクラスにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="28f9daadf043c9bd9f0d0e247b851c20599c84f6" translate="yes" xml:space="preserve">
          <source>A Java access modifier specifies which classes can access a given
  class and its fields, constructors and methods. Access modifiers can
  be specified separately for a class, its constructors, fields and
  methods. Java access modifiers are also sometimes referred to in daily
  speech as Java access specifiers, but the correct name is Java access
  modifiers. Classes, fields, constructors and methods can have one of
  four different Java access modifiers:</source>
          <target state="translated">Javaのアクセス修飾子は、与えられたクラスとそのフィールド、コンストラクタ、メソッドにアクセスできるクラスを指定します。アクセス修飾子は、クラス、そのコンストラクタ、フィールド、メソッドに対して別々に指定することができます。Javaアクセス修飾子は、日常会話ではJavaアクセス指定子と呼ばれることもありますが、正しい名称はJavaアクセス修飾子です。クラス、フィールド、コンストラクタ、メソッドは、4つの異なるJavaアクセス修飾子のいずれかを持つことができます。</target>
        </trans-unit>
        <trans-unit id="2e82124ab3a422db45abe523f1679bc6aa91180c" translate="yes" xml:space="preserve">
          <source>A class may be declared with the modifier public, in which case that
  class is visible to all classes everywhere. If a class has no modifier
  (the default, also known as package-private), it is visible only
  within its own package</source>
          <target state="translated">クラスは修飾子 public で宣言することができ、その場合、そのクラスはどこにいてもすべてのクラスから見えるようになります。修飾子を持たないクラス (デフォルトでは package-private と呼ばれています)は、そのクラスのパッケージ内でのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="702664d37f54e24a65c5847af5c9c48dec38ac9b" translate="yes" xml:space="preserve">
          <source>A class that should only be instantiated in a factory class (in the same package) should have a package restricted constructor, since it shouldn't be possible to call it directly from outside the package.</source>
          <target state="translated">(同じパッケージ内の)ファクトリークラスでのみインスタンス化されるべきクラスは、パッケージ外から直接呼び出すことができないはずなので、パッケージ制限付きのコンストラクタを持つべきです。</target>
        </trans-unit>
        <trans-unit id="2d6ccdc5fb3619653080b70f843a3d53183d1d68" translate="yes" xml:space="preserve">
          <source>A class, method, constructor, interface, etc. declared public can be accessed from any other class. Therefore fields, methods, blocks declared inside a public class can be accessed from any class belonging to the Java universe.</source>
          <target state="translated">publicと宣言されたクラス、メソッド、コンストラクタ、インターフェイスなどは、他のどのクラスからもアクセスすることができます。したがって、パブリッククラス内で宣言されたフィールド、メソッド、ブロックは、Javaの世界に属するどのクラスからもアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="59c33800560e8ea15395ce4e031d5c61d474b047" translate="yes" xml:space="preserve">
          <source>A field &lt;code&gt;long internalCounter&lt;/code&gt; should probably be private since it's mutable and an implementation detail.</source>
          <target state="translated">フィールドが &lt;code&gt;long internalCounter&lt;/code&gt; は、変更可能であり、実装の詳細であるため、おそらくプライベートにする必要があります。</target>
        </trans-unit>
        <trans-unit id="84f15ff4b953e019c687edc46342c1a4d6e9ef49" translate="yes" xml:space="preserve">
          <source>A member with &lt;strong&gt;no access modifier&lt;/strong&gt; (&lt;code&gt;j&lt;/code&gt;) is only accessible within classes in the same package.</source>
          <target state="translated">&lt;strong&gt;アクセス修飾子&lt;/strong&gt; （ &lt;code&gt;j&lt;/code&gt; ）の&lt;strong&gt;ない&lt;/strong&gt;メンバーは、同じパッケージ内のクラス内でのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c55ab8ded977750bfe1904b046504c141b94218c" translate="yes" xml:space="preserve">
          <source>A non-subclass inside a package of a subclass (A subclass inherits the protected members from its parent, and it makes them private to non-subclasses):</source>
          <target state="translated">サブクラスのパッケージ内の非サブクラス(サブクラスは親から保護されたメンバーを継承し、それを非サブクラスにプライベートにします)。</target>
        </trans-unit>
        <trans-unit id="d652e362bd9495b3b5c5a0d3c9f4d692d5d6cfac" translate="yes" xml:space="preserve">
          <source>Access Specifiers in Java:
There are 4 access specifiers in java, namely private, package-private (default), protected and public in increasing access order.</source>
          <target state="translated">Javaのアクセス指定子。Javaには4つのアクセス指定子があり、アクセス順にprivate、package-private(デフォルト)、protected、publicがあります。</target>
        </trans-unit>
        <trans-unit id="d90ffb4fa501229758715d3323e06c84a5ae97b4" translate="yes" xml:space="preserve">
          <source>Access level modifiers determine whether other classes can use a
  particular field or invoke a particular method. There are two levels
  of access control:</source>
          <target state="translated">アクセスレベル修飾子は、他のクラスが特定のフィールドを使用したり、特定のメソッドを呼び出したりすることができるかどうかを決定します。アクセス制御には2つのレベルがあります。</target>
        </trans-unit>
        <trans-unit id="f35f9b2fc1a98f9e2d94d1f9485056d27b28eeaf" translate="yes" xml:space="preserve">
          <source>Access levels affect you in two ways. First, when you use classes that
  come from another source, such as the classes in the Java platform,
  access levels determine which members of those classes your own
  classes can use. Second, when you write a class, you need to decide
  what access level every member variable and every method in your class
  should have.</source>
          <target state="translated">アクセス・レベルは2つの方法で影響を与えます。第一に、Javaプラットフォームのクラスなど、別のソースから来たクラスを使用する場合、アクセス・レベルは、あなた自身のクラスが使用できるそれらのクラスのどのメンバを決定します。第二に、クラスを書くときには、クラス内のすべてのメンバ変数とすべてのメソッドが持つべきアクセス・レベルを決定する必要があります。</target>
        </trans-unit>
        <trans-unit id="03834d1bba262bb9c1fe64f18662c2cfe0984376" translate="yes" xml:space="preserve">
          <source>Access modifier can be applicable for &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;field&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/60907642/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;method&lt;/code&gt;. Try to access, subclass or override this.</source>
          <target state="translated">アクセス修飾子は、 &lt;code&gt;class&lt;/code&gt; 、 &lt;code&gt;field&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/60907642/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt; 、 &lt;code&gt;method&lt;/code&gt; に適用できます。 これにアクセス、サブクラス化、またはオーバーライドしてみてください。</target>
        </trans-unit>
        <trans-unit id="9e3f67bc099476112adf6c930b20ba16a50afeba" translate="yes" xml:space="preserve">
          <source>Access modifiers are there to restrict access at several levels.</source>
          <target state="translated">アクセス修飾子は、いくつかのレベルでアクセスを制限するために存在します。</target>
        </trans-unit>
        <trans-unit id="ef81daf780b1360468865cad0409109e0c35badd" translate="yes" xml:space="preserve">
          <source>Access modifiers is a tool to help you to prevent accidentally breaking encapsulation&lt;sup&gt;(*)&lt;/sup&gt;. Ask yourself if you intend the member to be something that's internal to the class, package, class hierarchy or not internal at all, and choose access level accordingly.</source>
          <target state="translated">アクセス修飾子は、誤ってカプセル化を解除することを防ぐためのツールです&lt;sup&gt;（*）&lt;/sup&gt; 。 メンバーがクラス、パッケージ、クラス階層の内部であるか、またはまったく内部でないかを考え、それに応じてアクセスレベルを選択します。</target>
        </trans-unit>
        <trans-unit id="5eff681f376245a3dee4c9191f68f56b0af848bd" translate="yes" xml:space="preserve">
          <source>Access to &lt;code&gt;field&lt;/code&gt; or &lt;code&gt;method&lt;/code&gt; is through a &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; または &lt;code&gt;method&lt;/code&gt; へのアクセスは、 &lt;code&gt;class&lt;/code&gt; 介して行われます。</target>
        </trans-unit>
        <trans-unit id="b2412c998fc16dee0b53ff74260ef514b93a1606" translate="yes" xml:space="preserve">
          <source>Accessible only inside the same class.</source>
          <target state="translated">同一クラス内でのみアクセス可能。</target>
        </trans-unit>
        <trans-unit id="3a2d2458a3a2813e65aa1e280528e2ae281eb1b6" translate="yes" xml:space="preserve">
          <source>Accessible only to the classes in the same package and to the subclasses</source>
          <target state="translated">同じパッケージ内のクラスとサブクラスからのみアクセス可能</target>
        </trans-unit>
        <trans-unit id="d0e99d1f0ad00dcd92752660239fe3e6461be76a" translate="yes" xml:space="preserve">
          <source>Accessible to the classes in the same package only.</source>
          <target state="translated">同一パッケージ内のクラスのみアクセス可能。</target>
        </trans-unit>
        <trans-unit id="5b3141b0946b8bc5002beaffc46356be6f4c620a" translate="yes" xml:space="preserve">
          <source>All the access specifiers are possible on class members (constructors, methods and static member functions, nested classes).</source>
          <target state="translated">すべてのアクセス指定子は、クラスのメンバ(コンストラクタ、メソッド、スタティックメンバ関数、ネストされたクラス)に対して可能です。</target>
        </trans-unit>
        <trans-unit id="039d200ae5db7c7b5f2a7c153d81e8001cb8966c" translate="yes" xml:space="preserve">
          <source>Also, use the @Override annotation when overriding to keep things from breaking when you refactor.</source>
          <target state="translated">また、リファクタリング時に壊れないようにするために、オーバーライド時には @Override アノテーションを使用してください。</target>
        </trans-unit>
        <trans-unit id="2e74d999b3d7180df815ddf8cc8c8247175ccf3b" translate="yes" xml:space="preserve">
          <source>An internal &lt;code&gt;void beforeRender()&lt;/code&gt; method called right before rendering and used as a hook in subclasses should be protected.</source>
          <target state="translated">レンダリングの直前に呼び出され、サブクラスでフックとして使用される内部 &lt;code&gt;void beforeRender()&lt;/code&gt; メソッドは保護する必要があります。</target>
        </trans-unit>
        <trans-unit id="f562bc00e2ff22b13660ce46b08683a5aa376aae" translate="yes" xml:space="preserve">
          <source>Another thing is that classes which depend a lot on each other may end up in the same package and could eventually be refactored or merged if the dependency is too strong.</source>
          <target state="translated">もう一つは、依存関係が強いクラスは結局同じパッケージで終わってしまい、依存関係が強すぎるとリファクタリングされたりマージされたりする可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="2c41355fcbb760f41e646cca45391d28712651f9" translate="yes" xml:space="preserve">
          <source>As a general rule I try to avoid overriding method implementations by subclassing; it's too easy to screw up the logic. Declare abstract protected methods if you intend for it to be overridden.</source>
          <target state="translated">一般的なルールとして、私はメソッドの実装をサブクラス化してオーバーライドすることは避けようとしています。オーバーライドする場合は、抽象的な protected メソッドを宣言してください。</target>
        </trans-unit>
        <trans-unit id="32423b1a28b9a1d669c73210c669f380ab7cd7cf" translate="yes" xml:space="preserve">
          <source>As a result, if we divide access right into three rights:</source>
          <target state="translated">その結果、アクセス権を3つに分けると</target>
        </trans-unit>
        <trans-unit id="db2bda78247e71f5efa83e0fc3e723c83ff44d0a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb:</source>
          <target state="translated">経験則としては</target>
        </trans-unit>
        <trans-unit id="a81942444a4d0f2780ea3a629f2fe55b7bc48ec8" translate="yes" xml:space="preserve">
          <source>Assume that we have 2 classes; &lt;code&gt;Father&lt;/code&gt; and &lt;code&gt;Son&lt;/code&gt;, each in its own package:</source>
          <target state="translated">2つのクラスがあると仮定します。 &lt;code&gt;Father&lt;/code&gt; と &lt;code&gt;Son&lt;/code&gt; 、それぞれ独自のパッケージ：</target>
        </trans-unit>
        <trans-unit id="aa9a0ac313bc297e77263ee6fbe80f0f9519aae9" translate="yes" xml:space="preserve">
          <source>At the member level&amp;mdash;public, private, protected, or package-private (no explicit modifier).</source>
          <target state="translated">メンバーレベル&amp;mdash;パブリック、プライベート、保護、またはパッケージプライベート（明示的な修飾子なし）。</target>
        </trans-unit>
        <trans-unit id="e305218fd0f9ba9ee5a5cdb055df557e07100698" translate="yes" xml:space="preserve">
          <source>At the top level&amp;mdash;public, or package-private (no explicit modifier).</source>
          <target state="translated">トップレベル-パブリック、またはパッケージプライベート（明示的な修飾子なし）。</target>
        </trans-unit>
        <trans-unit id="1c758ca2bda73911a8bb40b724a78e1d5d7c8eff" translate="yes" xml:space="preserve">
          <source>Because of class inheritance, all public methods and variables of a class are inherited by its subclasses.</source>
          <target state="translated">クラス継承のため、クラスのパブリックメソッドや変数はすべてサブクラスに継承されます。</target>
        </trans-unit>
        <trans-unit id="fb75e9527859877f47e7706814e662a02518f379" translate="yes" xml:space="preserve">
          <source>But these protected members are &amp;ldquo;accessible outside the package only through inheritance&amp;ldquo;. i.e you can access a protected member of a class in its subclass present in some other package directly as if the member is present in the subclass itself. But that protected member will not be accessible in the subclass outside the package by using parent class&amp;rsquo;s reference. 
....</source>
          <target state="translated">しかし、これらの保護されたメンバーは、「継承を通じてのみパッケージの外部からアクセスできます」。 つまり、メンバーがサブクラス自体に存在するかのように、他のパッケージに存在するサブクラスのクラスの保護されたメンバーに直接アクセスできます。 ただし、その保護されたメンバーは、親クラスの参照を使用して、パッケージ外のサブクラスでアクセスできなくなります。 ....</target>
        </trans-unit>
        <trans-unit id="c4a8265d49bc8acc6dd4762df0a314fae0081dc6" translate="yes" xml:space="preserve">
          <source>C++ defines an additional level called &quot;friend&quot; and the less you know about that the better.</source>
          <target state="translated">C++では「フレンド」という追加レベルを定義していて、それを知らない人ほど良いと思います。</target>
        </trans-unit>
        <trans-unit id="fea15bced6cf072a20331c3293889e5278470a9f" translate="yes" xml:space="preserve">
          <source>Can be accessed from anywhere. (Global Access)</source>
          <target state="translated">どこからでもアクセス可能。(グローバルアクセス)</target>
        </trans-unit>
        <trans-unit id="b6b8d9b4123fecc2397339f9346b53016b47c561" translate="yes" xml:space="preserve">
          <source>Can only be seen and used by the &lt;strong&gt;package&lt;/strong&gt; in which it was declared.  This is the default in Java (which some see as a mistake).</source>
          <target state="translated">宣言された&lt;strong&gt;パッケージ&lt;/strong&gt;でのみ表示および使用できます。 これはJavaのデフォルトです（一部を誤りと見なしています）。</target>
        </trans-unit>
        <trans-unit id="29a771fa03b2207c5bfcb8ccc88b283b088d93d8" translate="yes" xml:space="preserve">
          <source>Class and Interface</source>
          <target state="translated">クラスとインターフェース</target>
        </trans-unit>
        <trans-unit id="abdbdface1f6d0a002a132de8ee6c16f0286d809" translate="yes" xml:space="preserve">
          <source>Class can be public or default</source>
          <target state="translated">クラスはパブリックまたはデフォルトのどちらでも構いません。</target>
        </trans-unit>
        <trans-unit id="4eff37234b0241258920d335734419acce47e495" translate="yes" xml:space="preserve">
          <source>Class members can be public, protected, default or private.</source>
          <target state="translated">クラスのメンバは、パブリック、プロテクト、デフォルト、プライベートのいずれかにすることができます。</target>
        </trans-unit>
        <trans-unit id="b77183cc688eb0a13673641268a14b314543ef5c" translate="yes" xml:space="preserve">
          <source>Compiler output:</source>
          <target state="translated">コンパイラ出力。</target>
        </trans-unit>
        <trans-unit id="5813699819cb9238ea0a3cac18732617dd8b7ef9" translate="yes" xml:space="preserve">
          <source>David's answer provides the meaning of each access modifier. As for when to use each, I'd suggest making public all classes and the methods of each class that are meant for external use (its API), and everything else private.</source>
          <target state="translated">Davidの答えは、それぞれのアクセス修飾子の意味を提供しています。それぞれをいつ使うかについては、私はすべてのクラスと各クラスのメソッドを公開し、それ以外はすべてプライベートにすることを提案します。</target>
        </trans-unit>
        <trans-unit id="b3048e4be2bec9d78ee94630c8921320fc4664da" translate="yes" xml:space="preserve">
          <source>Easy rule. Start with declaring everything private. And then progress towards the public as the needs arise and design warrants it.</source>
          <target state="translated">簡単なルールです。すべてをプライベートと宣言することから始めましょう。そして、ニーズが発生し、デザインがそれを保証するように、パブリックに向かって進みます。</target>
        </trans-unit>
        <trans-unit id="1aed6cf212aa5ca85fdc040a3f80f02392b4b63d" translate="yes" xml:space="preserve">
          <source>Everyone can see it.</source>
          <target state="translated">誰が見てもわかる。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="a9375f321c90af9af48e6e3fb9835073a5901dfe" translate="yes" xml:space="preserve">
          <source>Explanations</source>
          <target state="translated">Explanations</target>
        </trans-unit>
        <trans-unit id="de130795061e0af332069bc81b222c01a70e8ee6" translate="yes" xml:space="preserve">
          <source>Finally, your friend wants to read your progress report for the semester which is posted on the website. However, every student has their own personal login to access this section of the campus website. This would make these credentials as &lt;strong&gt;PRIVATE&lt;/strong&gt;.</source>
          <target state="translated">最後に、あなたの友人は、ウェブサイトに掲載されている学期の進捗レポートを読みたいと考えています。 ただし、キャンパスWebサイトのこのセクションにアクセスするには、すべての学生が自分の個人ログインを持っています。 これにより、これらの資格が&lt;strong&gt;PRIVATEになり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="414b0040a73b05acdd918cc38af972d787b57ad2" translate="yes" xml:space="preserve">
          <source>Following block diagram explain how data members of &lt;strong&gt;base class&lt;/strong&gt; are &lt;strong&gt;inherited&lt;/strong&gt; when &lt;strong&gt;derived class&lt;/strong&gt; access mode is &lt;strong&gt;private&lt;/strong&gt;.</source>
          <target state="translated">次のブロック図は、 &lt;strong&gt;派生クラス&lt;/strong&gt;アクセスモードが&lt;strong&gt;プライベートの&lt;/strong&gt;場合に、 &lt;strong&gt;基本クラスの&lt;/strong&gt;データメンバーがどのように&lt;strong&gt;継承さ&lt;/strong&gt;れるかを説明しています。</target>
        </trans-unit>
        <trans-unit id="211709b4e5a975998dfceb9f90b343faddbc3a82" translate="yes" xml:space="preserve">
          <source>For a taste of how these interact, consider this example. It is possible to &quot;leak&quot; private inner classes; this is usually a warning:</source>
          <target state="translated">これらがどのように相互作用するかについては、この例を見てみましょう。プライベートな内部クラスを「リーク」することが可能です。</target>
        </trans-unit>
        <trans-unit id="629b7e6e087c9f024573fb85ac0935aa91d841eb" translate="yes" xml:space="preserve">
          <source>For classes in the top scope, only &lt;code&gt;public&lt;/code&gt; and package-private are permitted. This design choice is presumably because &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; would be redundant at the package level (there is no inheritance of packages).</source>
          <target state="translated">トップスコープのクラスでは、 &lt;code&gt;public&lt;/code&gt; とパッケージプライベートのみが許可されます。 この設計の選択は、 &lt;code&gt;protected&lt;/code&gt; &lt;code&gt;private&lt;/code&gt; がパッケージレベルで冗長になるためと考えられます（パッケージの継承はありません）。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="358ca920d00cef8e692577e7de482b71e23ffa72" translate="yes" xml:space="preserve">
          <source>For example:
You may put sensitive security methods in a 'security' package.
Then put a public class which accesses some of the security related code in this package but keep other security classes &lt;strong&gt;package private&lt;/strong&gt;.
Thus other developers will only be able to use the publicly available class from outside of this package (unless they change the modifier).
This is not a security feature, but will &lt;strong&gt;guide&lt;/strong&gt; usage.</source>
          <target state="translated">たとえば、機密性の高いセキュリティメソッドを「セキュリティ」パッケージに入れることができます。 次に、セキュリティ関連のコードの一部にアクセスするパブリッククラスをこのパッケージに入れますが、他のセキュリティクラス&lt;strong&gt;パッケージはプライベートにし&lt;/strong&gt;ます。 したがって、他の開発者は、このパッケージの外部から公開されているクラスのみを使用できます（修飾子を変更しない限り）。 これはセキュリティ機能ではありませんが、使用方法を&lt;strong&gt;ガイドし&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="dc227021f08c9353ab45ce62f177cc6fd693f40c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://tutorials.jenkov.com/java/access-modifiers.html&quot;&gt;Java Access Modifiers&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://tutorials.jenkov.com/java/access-modifiers.html&quot;&gt;Java Access Modifiers&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="3bf7a6338bd5d5a3a5912a1ea99b4fa3eaa6fe75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;Controlling Access to Members of a Class&lt;/a&gt; tutorials:</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html&quot;&gt;アクセスの制御&lt;/a&gt;からクラスのメンバーへのチュートリアル：</target>
        </trans-unit>
        <trans-unit id="c9146570be1c93d6b1aab81c70a95becda8f9183" translate="yes" xml:space="preserve">
          <source>Here is detailed answer</source>
          <target state="translated">詳細な回答はこちら</target>
        </trans-unit>
        <trans-unit id="dab161dd919298ea5955c5ca83a5191994ed419b" translate="yes" xml:space="preserve">
          <source>Here's a better version of the table. (Future proof with a column for modules.)</source>
          <target state="translated">表のより良いバージョンは以下の通りです。(将来的にはモジュール用の列を追加して証明します)</target>
        </trans-unit>
        <trans-unit id="0e6d777d680c768e495440c452935c2860321ef2" translate="yes" xml:space="preserve">
          <source>Hope this helps!</source>
          <target state="translated">これが役に立つことを願っています</target>
        </trans-unit>
        <trans-unit id="aa86ea3205f5b702b5c530cc16d177882fb58320" translate="yes" xml:space="preserve">
          <source>However, if the public class we are trying to access is in a different package, then the public class still need to be imported.</source>
          <target state="translated">しかし、アクセスしようとしているパブリッククラスが別のパッケージにある場合は、パブリッククラスをインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="3068a4b8c73e5abddb06c0c44f94cd1fc95d98ad" translate="yes" xml:space="preserve">
          <source>However, this is quite complicated, and for full details, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6&quot;&gt;consult the Java Language Specification&lt;/a&gt;. (Yes, there have been compiler bugs in the past.)</source>
          <target state="translated">ただし、これは非常に複雑です。詳細&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.6&quot;&gt;については、Java言語仕様を参照してください&lt;/a&gt; 。 （はい、過去にコンパイラのバグがありました。）</target>
        </trans-unit>
        <trans-unit id="65c381ea7d6931f0058f4696124a3922c9a01d9e" translate="yes" xml:space="preserve">
          <source>If a class member is declared with keyword protected then in this case it is available ONLY to same class members</source>
          <target state="translated">クラス・メンバがキーワード protected で宣言されている場合、この場合は同じクラス・メンバのみが利用可能です。</target>
        </trans-unit>
        <trans-unit id="711d3ba82f3b647c7d5406080db3495d8ec4da48" translate="yes" xml:space="preserve">
          <source>If a class member is declared with keyword protected then it can be accessed from same class members, outside class members within the same package and inherited class members. If a class member is protected then it can NOT be accessed from outside package class unless the outside packaged class is inherited i.e. extends the other package superclass. But a protected class member is always available to same package classes it does NOT matter weather the same package class is inherited or NOT</source>
          <target state="translated">クラスメンバがキーワード protected で宣言されている場合、同じクラスメンバ、同じパッケージ内の外部クラスメンバ、継承されたクラスメンバからアクセスすることができます。クラスメンバが protected されている場合、外部パッケージクラスが継承されていない限り、外部パッケージクラスからアクセスすることはできません (他のパッケージのスーパークラスを継承している場合など)。しかし、保護されたクラスメンバは常に同じパッケージクラスで利用可能であり、同じパッケージクラスが継承されているかどうかは関係ありません</target>
        </trans-unit>
        <trans-unit id="00c3f094a058fa6a019b6a1d9bef50a5bac1da87" translate="yes" xml:space="preserve">
          <source>If a class member is declared with public then it can be accessed from anywhere</source>
          <target state="translated">クラスのメンバが public で宣言されている場合は、どこからでもアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="80f687d570b26042fb8176f323cd37d2559e1a3d" translate="yes" xml:space="preserve">
          <source>If on the contrary you set everything as &lt;strong&gt;public&lt;/strong&gt; it will not be clear what should or should not be accessed, which may lead to writing a lot of javadoc (which does not enforce anything via the compiler...).</source>
          <target state="translated">逆に、すべてを&lt;strong&gt;パブリック&lt;/strong&gt;として設定すると、何にアクセスすべきか、何にアクセスすべきでないかが明確になりません。そのため、多くのjavadocが作成される可能性があります（コンパイラを介して何も強制されません...）。</target>
        </trans-unit>
        <trans-unit id="8a060e14cb3887508691d17bc70585a7b1cb9b1f" translate="yes" xml:space="preserve">
          <source>If you try to access private members on one class in another will throw compile error. For example,</source>
          <target state="translated">あるクラスのプライベートメンバーにアクセスしようとすると、コンパイルエラーが発生します。例えば</target>
        </trans-unit>
        <trans-unit id="31d88a3684ae0701668196799b25e5ac3e976cb2" translate="yes" xml:space="preserve">
          <source>If you want users to be able to customize behaviors, rather than making internals public so they can override them, it's often a better idea to shove those guts into an object and make that interface public.  That way they can simply plug in a new object.  For example, if you were writing a CD player and wanted the &quot;go find info about this CD&quot; bit customizable, rather than make those methods public you'd put all that functionality into its own object and make just your object getter/setter public.  In this way being stingy about exposing your guts encourages good composition and separation of concerns</source>
          <target state="translated">内部を公開してオーバーライドできるようにするのではなく、ユーザーが動作をカスタマイズできるようにしたいのであれば、その根性をオブジェクトに押し込んでインターフェイスを公開する方が良い考えです。そうすれば、単に新しいオブジェクトをプラグインすることができます。例えば、CDプレーヤーを書いていて、&quot;このCDについての情報を探しに行く &quot;ビットをカスタマイズしたい場合、これらのメソッドを公開するのではなく、独自のオブジェクトにすべての機能を入れて、オブジェクトのゲッターセッターだけを公開します。このようにして、あなたのガッツを公開することにケチをつけることは、良い構成と懸念事項の分離を促進します。</target>
        </trans-unit>
        <trans-unit id="7c7a886c87a6eb77fdc25a1035f8d6da53cf8656" translate="yes" xml:space="preserve">
          <source>In Java default is NOT an access modifier keyword. If a class member is declared without any access modifier keyword then in this case it is considered as default member. The default class member is always available to same package class members. But outside package class member can NOT access default class members even if outside classes are subclasses unlike protected members</source>
          <target state="translated">Java では、default はアクセス修飾子キーワードではありません。クラス・メンバがアクセス修飾子キーワードなしで宣言されている場合は、その場合はデフォルト・メンバとみなされます。デフォルト・クラス・メンバは、同じパッケージのクラス・メンバであればいつでも利用できます。しかし、外部のクラスがサブクラスであっても、外部のパッケージ・クラス・メンバは、 protected メンバとは異なり、デフォルト・クラス・メンバにアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="fff3d91dbf347df5d37ad1067782bedfe095b46f" translate="yes" xml:space="preserve">
          <source>In Java, are there clear rules on when to use each of access modifiers, namely the default (package private), &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;, while making &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; and dealing with inheritance?</source>
          <target state="translated">Javaでは、 &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;interface&lt;/code&gt; を作成し、継承を処理しながら、各アクセス修飾子、つまりデフォルト（パッケージプライベート）、 &lt;code&gt;public&lt;/code&gt; 、 &lt;code&gt;protected&lt;/code&gt; 、 &lt;code&gt;private&lt;/code&gt; をいつ使用するかについて明確なルールはありますか？</target>
        </trans-unit>
        <trans-unit id="0a637c3e550bf7e3b47867e3e5c6bf98ec1df2d9" translate="yes" xml:space="preserve">
          <source>In non-static methods you can access directly because of &lt;strong&gt;this&lt;/strong&gt; reference (also in constructors)but to access in static methods you need to create object of the class.</source>
          <target state="translated">非静的メソッドでは、 &lt;strong&gt;この&lt;/strong&gt;参照のため（コンストラクターでも）、直接アクセスできますが、静的メソッドでアクセスするには、クラスのオブジェクトを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="f53b845e511550d070f01e7e1e45f0c6618de79e" translate="yes" xml:space="preserve">
          <source>In very short</source>
          <target state="translated">非常に短い期間で</target>
        </trans-unit>
        <trans-unit id="0a280c9c0cc8b973c8bf1ae5a66442e357f07610" translate="yes" xml:space="preserve">
          <source>Inheritance. Successor &lt;code&gt;class&lt;/code&gt;(subclass) access modifier can be any. Successor &lt;code&gt;method&lt;/code&gt;(override) access modifier should be the same or expand it</source>
          <target state="translated">継承。 後続 &lt;code&gt;class&lt;/code&gt; （サブクラス）アクセス修飾子は任意です。 後続 &lt;code&gt;method&lt;/code&gt; （オーバーライド）アクセス修飾子は同じであるか、それを拡張する必要があります</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">インナークラス</target>
        </trans-unit>
        <trans-unit id="0ebd78cffc1684194f3fbbff5f4da1d70adec54f" translate="yes" xml:space="preserve">
          <source>Inside a class that is located in the same package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; が定義されているのと同じパッケージにあるクラスの内部（ &lt;code&gt;fatherpackage&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4cb68522151730f7fe478771c760ac74a2dfdcd4" translate="yes" xml:space="preserve">
          <source>Inside a subclass, on the current instance via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">サブクラス内、 &lt;code&gt;this&lt;/code&gt; または &lt;code&gt;super&lt;/code&gt; を介した現在のインスタンス：</target>
        </trans-unit>
        <trans-unit id="85ab384f0543ec447c88c37b720be06d8d5088de" translate="yes" xml:space="preserve">
          <source>Is an access to a member with this access specifier allowed?</source>
          <target state="translated">このアクセス指定子を持つメンバーへのアクセスは許可されていますか?</target>
        </trans-unit>
        <trans-unit id="68afd36f6cfde7e67dffed921baf25b1a58cbfec" translate="yes" xml:space="preserve">
          <source>It is all about &lt;strong&gt;encapsulation&lt;/strong&gt; (or as Joe Phillips stated, &lt;em&gt;least knowledge&lt;/em&gt;).</source>
          <target state="translated">それはすべて&lt;strong&gt;カプセル化&lt;/strong&gt;に関するものです（またはJoe Phillipsが述べたように、 &lt;em&gt;最低限の知識&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9428cccda535e253598eaa7cdab4627dc9261f0f" translate="yes" xml:space="preserve">
          <source>It's actually a bit more complicated than a simple grid shows. The grid tells you whether an access is allowed, but what exactly constitutes an access? Also, access levels interact with nested classes and inheritance in complex ways.</source>
          <target state="translated">実際には、単純なグリッドが示すよりも少し複雑です。グリッドはアクセスが許可されているかどうかを教えてくれますが、正確には何がアクセスを構成しているのでしょうか?また、アクセスレベルはネストされたクラスや継承と複雑に相互作用します。</target>
        </trans-unit>
        <trans-unit id="8d7eff0719ace3e48da815165c32c20e33793293" translate="yes" xml:space="preserve">
          <source>Java - Method accessibility inside package-private class?</source>
          <target state="translated">Java-パッケージ・プライベート・クラス内のメソッドのアクセシビリティ?</target>
        </trans-unit>
        <trans-unit id="540bbbbbf4debb7face493bc9c0566a5b985f14c" translate="yes" xml:space="preserve">
          <source>Java access modifiers are used to provide access control in Java.</source>
          <target state="translated">Javaのアクセス修飾子は、Javaでアクセス制御を行うために使用されます。</target>
        </trans-unit>
        <trans-unit id="b326f17a3d2f7a73292bcff3aa33360fd288b8b2" translate="yes" xml:space="preserve">
          <source>Java access modifies which you can use</source>
          <target state="translated">Javaのアクセスは、あなたが使用することができます変更します。</target>
        </trans-unit>
        <trans-unit id="2d507bfe48fd363710c7aa776449fca5b38c5c5a" translate="yes" xml:space="preserve">
          <source>Let's add a protected method &lt;code&gt;foo()&lt;/code&gt; to &lt;code&gt;Father&lt;/code&gt;.</source>
          <target state="translated">保護されたメソッド &lt;code&gt;foo()&lt;/code&gt; を &lt;code&gt;Father&lt;/code&gt; に追加しましょう。</target>
        </trans-unit>
        <trans-unit id="825e439c12e8399e15d6ef5cddfff02318859b29" translate="yes" xml:space="preserve">
          <source>Let's assume that you're a student at a university and you have a friend who's coming to visit you over the weekend. Suppose there exists a big statue of the university's founder in the middle of the campus.</source>
          <target state="translated">あなたが大学の学生で、週末に友人が遊びに来るとしましょう。大学のキャンパスの真ん中に大きな創立者の像があったとします。</target>
        </trans-unit>
        <trans-unit id="dc55fb860e4b429ce495c5cbc9ba6248283659cf" translate="yes" xml:space="preserve">
          <source>Like you'd think, only the &lt;strong&gt;class&lt;/strong&gt; in which it is declared can see it.</source>
          <target state="translated">ご想像のとおり、宣言された&lt;strong&gt;クラス&lt;/strong&gt;だけがそれを見ることができます。</target>
        </trans-unit>
        <trans-unit id="8709df24bd586627893f85ebfa1884c2f82a5e55" translate="yes" xml:space="preserve">
          <source>List item</source>
          <target state="translated">リスト項目</target>
        </trans-unit>
        <trans-unit id="c1398e89d57631598bc754b3d6e89f276728b298" translate="yes" xml:space="preserve">
          <source>Local variables and formal parameters cannot take access specifiers. Since they are inherently inaccessible to the outside according to scoping rules, they are effectively private.</source>
          <target state="translated">ローカル変数や形式的なパラメータは、アクセス指定子を取ることができません。スコーピングルールに従って、それらは本質的に外部からアクセスできないため、事実上プライベートなものとなります。</target>
        </trans-unit>
        <trans-unit id="1b8528ca6c2239a069ccb77a16a61d04aaa3ad2b" translate="yes" xml:space="preserve">
          <source>Many languages find the hierarchical nature of public/protected/private to be too limiting and not in line with reality.  To that end there is the concept of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Trait_class&quot;&gt;trait class&lt;/a&gt;, but that's another show.</source>
          <target state="translated">多くの言語では、パブリック/保護/プライベートの階層的性質が制限的であり、現実に沿っていないことがわかります。 そのために&lt;a href=&quot;http://en.wikipedia.org/wiki/Trait_class&quot;&gt;特性クラスの&lt;/a&gt;概念がありますが、それは別のショーです。</target>
        </trans-unit>
        <trans-unit id="61039d9442076fb2e85d753a984b29c6d6e97613" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;private&lt;/code&gt;: Only if member is defined within the same class as calling code.</source>
          <target state="translated">メンバーは &lt;code&gt;private&lt;/code&gt; ：呼び出しコードと同じクラス内でメンバーが定義されている場合のみ。</target>
        </trans-unit>
        <trans-unit id="9a6766c91a1dac9b515e329f73674dee7761caf9" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;protected&lt;/code&gt;: Same package, or if member is defined in a superclass of the class containing the calling code.</source>
          <target state="translated">Member is &lt;code&gt;protected&lt;/code&gt; ：同じパッケージ、またはメンバーが呼び出しコードを含むクラスのスーパークラスで定義されている場合。</target>
        </trans-unit>
        <trans-unit id="56756b869829e0a2b3e5809cfb44466392b0d8dd" translate="yes" xml:space="preserve">
          <source>Member is &lt;code&gt;public&lt;/code&gt;: Yes.</source>
          <target state="translated">メンバーは &lt;code&gt;public&lt;/code&gt; ます：はい。</target>
        </trans-unit>
        <trans-unit id="333249b7b9e011c07bbf34cd6918aeb87c291c5d" translate="yes" xml:space="preserve">
          <source>Member is package private: Only if the calling code is within the member's immediately enclosing package.</source>
          <target state="translated">メンバはパッケージ・プライベートです。呼び出したコードが、そのメンバのすぐ近くにあるパッケージ内にある場合に限ります。</target>
        </trans-unit>
        <trans-unit id="46e6a422e152e53fcd52afdc532361e67997177b" translate="yes" xml:space="preserve">
          <source>Methods, variables and constructors that are declared private can only be accessed within the declared class itself. The private access modifier is the most restrictive access level. Class and interfaces cannot be private.</source>
          <target state="translated">プライベートと宣言されたメソッド、変数、コンストラクタは、宣言されたクラス自体の中でのみアクセスすることができます。プライベートアクセス修飾子は、最も制限の多いアクセスレベルです。クラスやインターフェイスをプライベートにすることはできません。</target>
        </trans-unit>
        <trans-unit id="335faa2a06faaaaddaf19dca7a6e552702624138" translate="yes" xml:space="preserve">
          <source>Methods,Variables and Constructors</source>
          <target state="translated">メソッド、変数、およびコンストラクタ</target>
        </trans-unit>
        <trans-unit id="89cb26c7ec8c16073c200078d9348aed52d6c686" translate="yes" xml:space="preserve">
          <source>My two cents :)</source>
          <target state="translated">私の2セント :)</target>
        </trans-unit>
        <trans-unit id="87a523f027d0ba7adab70824c7b1fb94c7132d6f" translate="yes" xml:space="preserve">
          <source>Next, you want to take your friend to your dorm, but for that you need to register him as a visitor. This means that he gets an access pass (which is the same as yours) to get into various buildings on campus. This would make his access card as &lt;strong&gt;PROTECTED&lt;/strong&gt;.</source>
          <target state="translated">次に、友達を寮に連れて行きたいのですが、そのためには、彼を訪問者として登録する必要があります。 これは、彼がキャンパス内のさまざまな建物に入るためのアクセスパス（あなたのものと同じ）を取得することを意味します。 これにより、彼のアクセスカードは&lt;strong&gt;PROTECTEDになります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ec331f3044739b47bc605e4558099cf08d010f7" translate="yes" xml:space="preserve">
          <source>Normally, member variables are defined private, but member methods are public.</source>
          <target state="translated">通常、メンバー変数はプライベートで定義されますが、メンバーメソッドはパブリックで定義されます。</target>
        </trans-unit>
        <trans-unit id="c6238ff0e30b27995906139dc0f1043520c044df" translate="yes" xml:space="preserve">
          <source>Note: &lt;em&gt;This is just a &lt;strong&gt;supplement&lt;/strong&gt; for the accepted answer.&lt;/em&gt;</source>
          <target state="translated">注： &lt;em&gt;これは受け入れられた回答の単なる&lt;strong&gt;補足&lt;/strong&gt;です。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adb9aaea02b1cff0a3c213ab075fcb4d010034c7" translate="yes" xml:space="preserve">
          <source>Note: Declaring data members with private access specifier is known as &lt;strong&gt;data hiding.&lt;/strong&gt;</source>
          <target state="translated">注：プライベートアクセス指定子を使用してデータメンバーを宣言することは、 &lt;strong&gt;データ&lt;/strong&gt;非表示と呼ばれ&lt;strong&gt;ます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="32500c238248244eb78c9f14aa99e41bd6942ed2" translate="yes" xml:space="preserve">
          <source>Now the confusion arises when it comes to &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; と &lt;code&gt;protected&lt;/code&gt; に関しては混乱が生じます</target>
        </trans-unit>
        <trans-unit id="bf67bd37c73d81bc5307563f78c833d29fe10889" translate="yes" xml:space="preserve">
          <source>Often times I've realized that remembering the basic concepts of any language can made possible by creating real-world analogies. Here is my analogy for understanding access modifiers in Java:</source>
          <target state="translated">どんな言語の基本的な概念でも、実世界のアナロジーを作ることで覚えられることに気づくことがよくあります。ここでは、Javaのアクセス修飾子を理解するための私のアナロジーを紹介します。</target>
        </trans-unit>
        <trans-unit id="97a14c4e2738d6c2804656e0a006451d5b27f196" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the parent class and it is &lt;em&gt;inside&lt;/em&gt; the package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;) [This can be included inside context no. 1]:</source>
          <target state="translated">タイプが親クラスであり、 &lt;code&gt;foo()&lt;/code&gt; が定義されているパッケージ&lt;em&gt;内に&lt;/em&gt;ある参照（ &lt;code&gt;fatherpackage&lt;/code&gt; ）[これは、コンテキストno内に含めることができます。 1]：</target>
        </trans-unit>
        <trans-unit id="b47a88794e5bc9eb69dfcdd8c1454a1d628c58f2" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the parent class and it is &lt;em&gt;outside&lt;/em&gt; the package where &lt;code&gt;foo()&lt;/code&gt; is defined (&lt;code&gt;fatherpackage&lt;/code&gt;):</source>
          <target state="translated">タイプが親クラスであり、 &lt;code&gt;foo()&lt;/code&gt; が定義されているパッケージの&lt;em&gt;外部に&lt;/em&gt;ある参照（ &lt;code&gt;fatherpackage&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c64917ce44fe5662d78c50ec0a072083dbcd8daf" translate="yes" xml:space="preserve">
          <source>On an reference whose type is the same class:</source>
          <target state="translated">型が同じクラスである参照の場合。</target>
        </trans-unit>
        <trans-unit id="1735879fe3a2e22b9b283485856a39553a8ac889" translate="yes" xml:space="preserve">
          <source>Only having private constructors also means that the class cannot be subclassed externally, since Java requires a subclass's constructors to implicitly or explicitly call a superclass constructor. (It can, however, contain a nested class that subclasses it.)</source>
          <target state="translated">プライベート・コンストラクタを持つだけでは、そのクラスは外部からサブクラス化できないことも意味します。(ただし、それをサブクラス化するネストされたクラスを含むことはできます)。</target>
        </trans-unit>
        <trans-unit id="1d75774c0f96b6ee44eb6643c9fea71b50b90ea8" translate="yes" xml:space="preserve">
          <source>Order</source>
          <target state="translated">Order</target>
        </trans-unit>
        <trans-unit id="59e00bdab1723eeefe789e083d87acb6847d6733" translate="yes" xml:space="preserve">
          <source>Output: Hello</source>
          <target state="translated">出力します。こんにちは</target>
        </trans-unit>
        <trans-unit id="67a5927c5cce6b22e97f84af83e9faa9704ee973" translate="yes" xml:space="preserve">
          <source>Output:Hello</source>
          <target state="translated">Output:Hello</target>
        </trans-unit>
        <trans-unit id="48db52b778fccd255894481994bdacd74ee198b0" translate="yes" xml:space="preserve">
          <source>Over time you'll develop a sense for when to make some classes package-private and when to declare certain methods protected for use in subclasses.</source>
          <target state="translated">時間が経つにつれて、いくつかのクラスをいつパッケージ化してプライベートにするか、また、サブクラスで使用するために保護されたメソッドをいつ宣言するかについての感覚が養われていくでしょう。</target>
        </trans-unit>
        <trans-unit id="2d1fefb5c50582321c4d75309559ed4fb1fb5c62" translate="yes" xml:space="preserve">
          <source>Package Private</source>
          <target state="translated">プライベートパッケージ</target>
        </trans-unit>
        <trans-unit id="02d690f0069219ba265f693b9aa34bc858bc7b64" translate="yes" xml:space="preserve">
          <source>Package Private + can be seen by subclasses or package member.</source>
          <target state="translated">パッケージプライベート+はサブクラスやパッケージメンバーで見ることができます。</target>
        </trans-unit>
        <trans-unit id="67edadea70b35c0bde5fedf6ce3b8d7307338c28" translate="yes" xml:space="preserve">
          <source>Personally, I stick with just &quot;private&quot; and &quot;public&quot;.  Many OO languages just have that.  &quot;Protected&quot; can be handy, but it's really a cheat.  Once an interface is more than private it's outside of your control and you have to go looking in other people's code to find uses.</source>
          <target state="translated">個人的には、&quot;private &quot;と &quot;public &quot;だけにこだわっています。多くの OO 言語にはそれだけの機能があります。&quot;Protected&quot; は便利ですが、それは本当にズルです。インターフェースがプライベート以上になってしまうと、自分でコントロールできなくなってしまい、他の人のコードを探して使い道を探さなければならなくなります。</target>
        </trans-unit>
        <trans-unit id="b092b192a4d648e172b4a375b0666e778cde5015" translate="yes" xml:space="preserve">
          <source>Please note:</source>
          <target state="translated">ご注意ください。</target>
        </trans-unit>
        <trans-unit id="237dfa0a21c8e17a7276cf161eef7e0fba067c47" translate="yes" xml:space="preserve">
          <source>Private</source>
          <target state="translated">Private</target>
        </trans-unit>
        <trans-unit id="73c2c05c567e0abdbe3ba13d814ebd8d7a054684" translate="yes" xml:space="preserve">
          <source>Private access modifier - private:</source>
          <target state="translated">プライベートアクセス修飾子-private。</target>
        </trans-unit>
        <trans-unit id="47498edf610d2474479d092eef6b21971a8e54cb" translate="yes" xml:space="preserve">
          <source>Private is not accessible outside the class
Default is accessible only in the package.
Protected in package as well as any class which extends it.
Public is open for all.</source>
          <target state="translated">Private はクラス外からはアクセスできません。 Default はパッケージ内でのみアクセス可能です。パッケージ内だけでなく、それを拡張したクラスでも保護されます。パブリックはすべての人に公開されています。</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="07dc0891cffa12c73230979cda26f3ea127ced21" translate="yes" xml:space="preserve">
          <source>Protected access gives the subclass a chance to use the helper method or variable, while preventing a nonrelated class from trying to use it.</source>
          <target state="translated">保護されたアクセスは、サブクラスにヘルパーメソッドや変数を使用する機会を与え、無関係なクラスがそれを使用しようとするのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="427cebdbe94bd945eeb72a25018bea95d6a0d3e4" translate="yes" xml:space="preserve">
          <source>Protected access modifier - protected:</source>
          <target state="translated">保護されたアクセス修飾子-protected。</target>
        </trans-unit>
        <trans-unit id="dc5eb704bbcae1aff4efb71c55461d47767dabe7" translate="yes" xml:space="preserve">
          <source>Public</source>
          <target state="translated">Public</target>
        </trans-unit>
        <trans-unit id="373d5d53b0dab15eec7ea7ad71ce7aec9d662c30" translate="yes" xml:space="preserve">
          <source>Public Protected Default and private are access modifiers.</source>
          <target state="translated">Public Protected Defaultとprivateはアクセス修飾子です。</target>
        </trans-unit>
        <trans-unit id="5df8a0072d803165a9f31208c9db4592974fa499" translate="yes" xml:space="preserve">
          <source>Public access modifier - public:</source>
          <target state="translated">パブリックアクセス修飾子-public。</target>
        </trans-unit>
        <trans-unit id="483bf2075c12023a5e849d12a42027be89c5e94b" translate="yes" xml:space="preserve">
          <source>Published</source>
          <target state="translated">Published</target>
        </trans-unit>
        <trans-unit id="79337cebe0b8469f44ee26dd522be3c1abbde46b" translate="yes" xml:space="preserve">
          <source>References links</source>
          <target state="translated">参考リンク</target>
        </trans-unit>
        <trans-unit id="23c4f19c70076332ae76378be5204b96f6c98f0f" translate="yes" xml:space="preserve">
          <source>Related Answers</source>
          <target state="translated">関連する回答</target>
        </trans-unit>
        <trans-unit id="56eee76535b8adfa9fe3329a7d09b87c34cc1f70" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/267781/java-class-accessibility&quot;&gt;Java Class Accessibility&lt;/a&gt;</source>
          <target state="translated">関連： &lt;a href=&quot;https://stackoverflow.com/questions/267781/java-class-accessibility&quot;&gt;Javaクラスのアクセシビリティ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17d8ed1a776981997da35f245b5fd1b0aca174fa" translate="yes" xml:space="preserve">
          <source>So bottom line is, &lt;strong&gt;protected members can be accessed in other packages, only if some class from this other package, extends class enclosing this protected member and protected member is accessed on 'this' reference or explicit instances of extended class, within definition of extended class.&lt;/strong&gt;</source>
          <target state="translated">つまり&lt;strong&gt;、他のパッケージの保護されたメンバーにアクセスできるの&lt;/strong&gt;は、 &lt;strong&gt;この他のパッケージのクラスがこの保護されたメンバーを含むクラスを拡張し、保護されたメンバーが「this」参照または拡張クラスの明示的なインスタンスで、拡張の定義内でアクセスされる場合のみです。クラス。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21d3937db339f6e43775069049c209555c9447c1" translate="yes" xml:space="preserve">
          <source>So, rule of thumb is to make things only as visible as they have to be.  Start with private and only add more visibility as needed.  Only make public that which is absolutely necessary for the user to know, every detail you make public cramps your ability to redesign the system.</source>
          <target state="translated">ですから、経験則としては、必要な分だけ見えるようにすることです。最初は非公開にして、必要に応じてより多くの可視性を追加します。ユーザーが知るために絶対に必要なものだけを公開してください。</target>
        </trans-unit>
        <trans-unit id="154dbc9264721e755cac5da7fa4be2894fd9a2ab" translate="yes" xml:space="preserve">
          <source>Some related questions:</source>
          <target state="translated">関連する質問をいくつか。</target>
        </trans-unit>
        <trans-unit id="4b2dc2e152a6049bc5dd339a5aaa36977da34901" translate="yes" xml:space="preserve">
          <source>Source : &lt;a href=&quot;http://www.trytoprogram.com/cplusplus-programming/access-specifiers/&quot;&gt; Access Specifiers &amp;ndash; Private, Public and Protected
&lt;/a&gt;</source>
          <target state="translated">出典： &lt;a href=&quot;http://www.trytoprogram.com/cplusplus-programming/access-specifiers/&quot;&gt;アクセス指定子&amp;ndash;プライベート、パブリック、保護&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c03da846ed372f26ddbd2660e72f7d8755c812d7" translate="yes" xml:space="preserve">
          <source>Start with the most restrictive (private) and see if you need less restrictive modifiers later on.</source>
          <target state="translated">最も制限の多い(非公開)ものから始めて、後から制限の少ない修飾語が必要かどうかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="2db7bd0663d3a295c6b4c5b37588b2c72bf5eb2d" translate="yes" xml:space="preserve">
          <source>Swift access modifiers</source>
          <target state="translated">スイフトアクセス修飾子</target>
        </trans-unit>
        <trans-unit id="d3b8c8a1daa787e5c27587774294ce4f3fd4a1b6" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; access (specified by the absence of a keyword) is also called &lt;a href=&quot;https://stackoverflow.com/questions/5416074/java-package-private-terminology&quot;&gt;&lt;strong&gt;package-private&lt;/strong&gt;&lt;/a&gt;. Exception: in an interface, no modifier means public access; modifiers other than public are forbidden. Enum constants are always public.</source>
          <target state="translated">「デフォルト」アクセス（キーワードがないことで指定）は、 &lt;a href=&quot;https://stackoverflow.com/questions/5416074/java-package-private-terminology&quot;&gt;&lt;strong&gt;package-private&lt;/strong&gt;&lt;/a&gt;とも呼ばれ&lt;strong&gt;ます&lt;/strong&gt; 。 例外：インターフェースでは、修飾子はパブリックアクセスを意味しません。 public以外の修飾子は禁止されています。 列挙型定数は常にパブリックです。</target>
        </trans-unit>
        <trans-unit id="2586c08972816888f55708f755c54e0e86ec9ba4" translate="yes" xml:space="preserve">
          <source>The access specifiers can be strictly ordered</source>
          <target state="translated">アクセス指定子は厳密には</target>
        </trans-unit>
        <trans-unit id="df6efd781f79998f9f898aa9e074a442cdff5a02" translate="yes" xml:space="preserve">
          <source>The difference can be found in the links already provided but which one to use usually comes down to the &quot;Principle of Least Knowledge&quot;. Only allow the least visibility that is needed.</source>
          <target state="translated">その違いは、すでに提供されているリンクを見ればわかりますが、どちらを使うかは、通常、「最小知識の原則」にかかっています。必要最小限の可視性のみを許可する。</target>
        </trans-unit>
        <trans-unit id="679e82b3df66656fd5d1f4c9549d8ab9122877e6" translate="yes" xml:space="preserve">
          <source>The first data column indicates whether the class itself has access to
  the member defined by the access level. As you can see, a class always
  has access to its own members. The second column indicates whether
  classes in the same package as the class (regardless of their
  parentage) have access to the member. The third column indicates
  whether subclasses of the class declared outside this package have
  access to the member. The fourth column indicates whether all classes
  have access to the member.</source>
          <target state="translated">最初のデータ列は、クラス自身がアクセス・レベルで定義されたメンバへのアクセスを持っているかどうかを示します。ご覧のように、クラスは常に自身のメンバへのアクセスを持っています。2 番目の列は、そのクラスと同じパッケージ内のクラスが (親の有無にかかわらず)そのメンバへのアクセス権を持っているかどうかを示します。3 番目の列は、このパッケージ外で宣言されたクラスのサブクラスがメンバにアクセスできるかどうかを示します。4 番目の列は、すべてのクラスがメンバへのアクセス権を持つかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="c3ef407bfffcf2e4ffd72f9afb533124d421f084" translate="yes" xml:space="preserve">
          <source>The following situations are not valid.</source>
          <target state="translated">以下のような場合は無効です。</target>
        </trans-unit>
        <trans-unit id="6e0ae3808955f5f848f420a39b6f2822eb0679d1" translate="yes" xml:space="preserve">
          <source>The following table shows the access to members permitted by each
  modifier.</source>
          <target state="translated">各修飾子で許可されているメンバーへのアクセスを以下の表に示します。</target>
        </trans-unit>
        <trans-unit id="6c3b0509347cd9fae8904b92da0d10e55784f19a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;foo()&lt;/code&gt; can be called in 4 contexts:</source>
          <target state="translated">メソッド &lt;code&gt;foo()&lt;/code&gt; は、4つのコンテキストで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d356b3ec320b607fd260202ec32d80a6d8ebd453" translate="yes" xml:space="preserve">
          <source>The most misunderstood access modifier in Java is &lt;code&gt;protected&lt;/code&gt;. We know that it's similar to the default modifier with one exception in which subclasses can see it. But how? Here is an example which hopefully clarifies the confusion:</source>
          <target state="translated">Javaで最も誤解されているアクセス修飾子が &lt;code&gt;protected&lt;/code&gt; ます。 サブクラスがそれを見ることができるという一つの例外を除いて、それはデフォルトの修飾子に似ていることを知っています。 しかし、どうやって？ 混乱を明確にした例を次に示します。</target>
        </trans-unit>
        <trans-unit id="be00e0232f8d8959670788550d4e065b0397435d" translate="yes" xml:space="preserve">
          <source>The protected access modifier cannot be applied to class and interfaces. Methods, fields can be declared protected, however methods and fields in a interface cannot be declared protected.</source>
          <target state="translated">protectedアクセス修飾子は、クラスとインタフェースには適用できません。メソッドやフィールドはprotectedを宣言することができますが、 インターフェースのメソッドやフィールドはprotectedを宣言することができません。</target>
        </trans-unit>
        <trans-unit id="169ba09f6c249dafbff995f433c80a45b0644db7" translate="yes" xml:space="preserve">
          <source>They are meant for encapsulation, or hiding and showing contents of the class.</source>
          <target state="translated">これらはカプセル化、つまりクラスの内容を隠したり表示したりするためのものです。</target>
        </trans-unit>
        <trans-unit id="682ffc8981fc2bc88a6aeadf052aa2ee7fc48504" translate="yes" xml:space="preserve">
          <source>This access is more restricted than public and protected, but less restricted than private.</source>
          <target state="translated">このアクセスは、公開されているものや保護されているものよりも制限されていますが、非公開のものよりも制限されていません。</target>
        </trans-unit>
        <trans-unit id="ee4eefa591c2b5d729b2fadc0b84fbb3c332905c" translate="yes" xml:space="preserve">
          <source>This is related to Java &lt;a href=&quot;https://en.wikipedia.org/wiki/Access_modifiers&quot;&gt;Access Modifiers&lt;/a&gt;.</source>
          <target state="translated">これは、Java &lt;a href=&quot;https://en.wikipedia.org/wiki/Access_modifiers&quot;&gt;Access Modifiersに&lt;/a&gt;関連しています。</target>
        </trans-unit>
        <trans-unit id="198b4459a701114bd5c61fdbe1c4faf71ffb4fe3" translate="yes" xml:space="preserve">
          <source>This is where the idea of &quot;published&quot; comes in.  Changing an interface (refactoring it) requires that you find all the code which is using it and change that, too.  If the interface is private, well no problem.  If it's protected you have to go find all your subclasses.  If it's public you have to go find all the code which uses your code.  Sometimes this is possible, for example if you're working on corporate code that's for internal use only it doesn't matter if an interface is public.  You can grab all the code out of the corporate repository.  But if an interface is &quot;published&quot;, if there is code using it outside your control, then you're hosed.  You must support that interface or risk breaking code.  Even protected interfaces can be considered published (which is why I don't bother with protected).</source>
          <target state="translated">ここで「公開されている」という考え方が出てきます。インターフェースを変更する(リファクタリングする)には、それを使用しているすべてのコードを見つけて、それも変更する必要があります。インターフェースがプライベートなものであれば問題ありません。保護されている場合は、すべてのサブクラスを探さなければなりません。もしそれがpublicならば、あなたのコードを使っているコードをすべて見つけなければなりません。これが可能な場合もあります。例えば、内部でのみ使用される企業のコードに取り組んでいる場合、インターフェイスがパブリックであるかどうかは問題ではありません。企業リポジトリからすべてのコードを取得することができます。しかし、インターフェイスが「公開」されている場合、あなたの管理外でそれを使用しているコードがある場合は、あなたを追い出すことになります。そのインターフェイスをサポートしなければなりませんし、コードを壊すリスクもあります。保護されたインターフェイスでさえ公開されているとみなすことができます (これが、私が保護されたインターフェイスを気にしない理由です)。</target>
        </trans-unit>
        <trans-unit id="6b5d1e74f2eea7ead15ccf29069baea5d0f69c05" translate="yes" xml:space="preserve">
          <source>This page writes well about the protected &amp;amp; default access modifier</source>
          <target state="translated">このページは、保護されたデフォルトのアクセス修飾子についてよく書いています</target>
        </trans-unit>
        <trans-unit id="eeb5424c66259e76273a69d238cdcc3c9e66fd22" translate="yes" xml:space="preserve">
          <source>To access if you are in same package you can access directly, but if you are in another package then you can create an object of the class.</source>
          <target state="translated">同じパッケージ内であれば直接アクセスすることができますが、別のパッケージ内であればクラスのオブジェクトを作成してアクセスします。</target>
        </trans-unit>
        <trans-unit id="14ae94913500b0661223e0efa7a5e7ca28857425" translate="yes" xml:space="preserve">
          <source>To access protected field defined in base class you can create object of child class.</source>
          <target state="translated">基底クラスで定義されている保護されたフィールドにアクセスするには、子クラスのオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="0ad466926d52efdf7885ec86fe714f4f216f7680" translate="yes" xml:space="preserve">
          <source>To access you can create an object of the class. But you can not access this variable outside of the package.</source>
          <target state="translated">アクセスするには、クラスのオブジェクトを作成することができます。しかし、パッケージの外ではこの変数にアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="1fb58ec9231bc98bca307ae528c066d345048ea9" translate="yes" xml:space="preserve">
          <source>Top level class(first level scope) can be &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt;. &lt;code&gt;Nested class&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/59220181/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt; can have any of them</source>
          <target state="translated">トップレベルのクラス（最初のレベルのスコープ）は、 &lt;code&gt;public&lt;/code&gt; および &lt;code&gt;default&lt;/code&gt; することができます 。 &lt;code&gt;Nested class&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/59220181/4770877&quot;&gt;&lt;sup&gt;[About]&lt;/sup&gt;&lt;/a&gt;はそれらのいずれかを持つことができます</target>
        </trans-unit>
        <trans-unit id="384f7244462f630639626ae0b32c7bdfb001d0ba" translate="yes" xml:space="preserve">
          <source>Using the private modifier is the main way that an object encapsulates itself and hides data from the outside world.</source>
          <target state="translated">プライベート修飾子を使用することは、オブジェクトがそれ自身をカプセル化し、外部からデータを隠す主な方法です。</target>
        </trans-unit>
        <trans-unit id="ab4e39861714a7bba115c44241b41a0b85300324" translate="yes" xml:space="preserve">
          <source>Variables and methods can be declared without any modifiers that are called. Default examples:</source>
          <target state="translated">変数やメソッドは、呼び出される修飾子なしで宣言することができます。デフォルトの例。</target>
        </trans-unit>
        <trans-unit id="34077ede14eaaebed19ee0bede3eea6d7f3eb11e" translate="yes" xml:space="preserve">
          <source>Variables that are declared private can be accessed outside the class if public getter methods are present in the class.</source>
          <target state="translated">プライベートと宣言された変数は、クラス内にパブリックゲッターメソッドが存在する場合、クラス外からアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="0a50d48aa080a7c6783e40cbfdb6e97dd79fc57b" translate="yes" xml:space="preserve">
          <source>Variables, methods and constructors which are declared protected in a superclass can be accessed only by the subclasses in another package or any class within the package of the protected members' class.</source>
          <target state="translated">スーパークラスで保護されていると宣言されている変数、メソッド、コンストラクタは、別のパッケージのサブクラス、または保護されているメンバーのクラスのパッケージ内の任意のクラスからのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="12f084bc06fb25984a713a05ac96ec8fd8c87e3e" translate="yes" xml:space="preserve">
          <source>Visible outside the code I control.  (While not Java syntax, it is important for this discussion).</source>
          <target state="translated">私がコントロールするコードの外側に見える。(Javaの構文ではありませんが、この議論では重要です)。</target>
        </trans-unit>
        <trans-unit id="14bcee1179ba8505e906f60fb57592380df65a40" translate="yes" xml:space="preserve">
          <source>Visible to the class only (&lt;strong&gt;private&lt;/strong&gt;).</source>
          <target state="translated">クラスにのみ表示されます（ &lt;strong&gt;プライベート&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f09f62b5791cfabbdd6e4c34df55d9bdb437435" translate="yes" xml:space="preserve">
          <source>Visible to the package and all subclasses (&lt;strong&gt;protected&lt;/strong&gt;).</source>
          <target state="translated">パッケージとすべてのサブクラスに表示されます（ &lt;strong&gt;protected&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="54ef9402017fe93855f3b30d829bfd206f6e7f50" translate="yes" xml:space="preserve">
          <source>Visible to the package. The default. No modifiers are needed.</source>
          <target state="translated">パッケージに表示されます。デフォルトです。修飾子は必要ありません。</target>
        </trans-unit>
        <trans-unit id="ca587ffd93b05980f46dc7a85340bbf8390ffe51" translate="yes" xml:space="preserve">
          <source>Visible to the world (&lt;strong&gt;public&lt;/strong&gt;).</source>
          <target state="translated">世界に&lt;strong&gt;公開&lt;/strong&gt; （ &lt;strong&gt;一般公開&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="546b60f326b8d6a60c507410a570c1777530716c" translate="yes" xml:space="preserve">
          <source>We all use method and member modifiers like private, public, ... but one thing too few developers do is use packages to &lt;strong&gt;organize&lt;/strong&gt; code logically.</source>
          <target state="translated">私たちは皆、private、publicなどのメソッド修飾子とメンバー修飾子を使用していますが、開発者が少なすぎることの1つは、パッケージを使用&lt;strong&gt;して&lt;/strong&gt;コードを論理的に&lt;strong&gt;整理すること&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="0e9aa520836ae4a575fd28c23d90b4382f8165ec" translate="yes" xml:space="preserve">
          <source>We cannot Override the Static fields.if you try to override it does not show any error 
but it doesnot work what we except.</source>
          <target state="translated">静的フィールドをオーバーライドすることはできません。</target>
        </trans-unit>
        <trans-unit id="e35308834027bed876c4f7f710ec90003c87538e" translate="yes" xml:space="preserve">
          <source>What access specifiers apply to</source>
          <target state="translated">どのようなアクセス指定子が適用されるか</target>
        </trans-unit>
        <trans-unit id="d80aa50837cce957e5ce3fb6bafde8063b8ddb68" translate="yes" xml:space="preserve">
          <source>What is the difference between public, protected, package-private and private in Java</source>
          <target state="translated">Javaにおけるpublic、protected、package-private、privateの違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="b46b79fb2f1824c3f83b93eb49daf91f0e91d07b" translate="yes" xml:space="preserve">
          <source>When exposing members ask yourself if you are exposing representation choices or abstraction choices. The first is something you want to avoid as it will introduce too many dependencies on the actual representation rather than on its observable behavior.</source>
          <target state="translated">メンバを公開する際には、表現の選択肢を公開しているのか、抽象化の選択肢を公開しているのかを自問自答してください。前者は、観測可能な動作ではなく、実際の表現に多くの依存性を導入してしまうので、避けたいものです。</target>
        </trans-unit>
        <trans-unit id="e2edee9f094279931ccc7f4853b4b3611fed2c3b" translate="yes" xml:space="preserve">
          <source>When should you use what?  The whole idea is encapsulation to hide information.  As much as possible you want to hide the detail of how something is done from your users.  Why?  Because then you can change them later and not break anybody's code.  This lets you optimize, refactor, redesign and fix bugs without worry that someone was using that code you just overhauled.</source>
          <target state="translated">いつ何を使うべきか?全体的な考え方は、情報を隠すためのカプセル化です。可能な限り、何かがどのように行われるかの詳細をユーザーから隠したいものです。なぜでしょうか?そうすれば、後で変更しても誰のコードも壊さずに済むからです。これにより、最適化、リファクタリング、再設計、バグ修正を、オーバーホールしたコードを誰かが使っていることを心配することなく行うことができます。</target>
        </trans-unit>
        <trans-unit id="79af6581bf04a23396460cd17b21987c89702dec" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, then you should use protected access specifier for data member within Class1 if you don't want this member to be accessed outside your package (say in package of consumer of your package i.e. client who is using your APIs) in general, but you want to make an exception and allow access to this member only if client writes class say Class2 that extends Class1. So, in general, protected members will be accessible on 'this' reference in derived classes i.e. Class2 and also on explicit instances of Class2.</source>
          <target state="translated">あるパッケージを開発していて、その中にあるクラス (例えば Class1)を開発している場合、通常は Class1 内のデータメンバに protected アクセス指定子を使用しなければなりませんが、もしこのメンバがパッケージ外 (例えば、パッケージの消費者、つまり API を使用しているクライアントのパッケージ内)にアクセスされたくない場合、例外を設けて、クライアントが Class1 を拡張した Class2 のようなクラスを書いた場合にのみ、このメンバへのアクセスを許可したいとします。そのため、一般的に、protected なメンバは派生クラス、つまり Class2 の 'this' 参照や、Class2 の明示的なインスタンスからもアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="027f6037ffd06215488adde61c7e586ebdeedc8b" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, then you should use public access specifier for data member within Class1 if you want this member to be accessible in other packages on instance of Class1 created in some class of other package. &lt;strong&gt;Basically this access specifier should be used when you intent to expose your data member to world without any condition.&lt;/strong&gt;</source>
          <target state="translated">一部のパッケージを開発しているため、その中にクラス（たとえばClass1）がある場合、他のクラスで作成されたClass1のインスタンスの他のパッケージでこのメンバーにアクセスできるようにする場合は、Class1内のデータメンバーにパブリックアクセス指定子を使用する必要があります。パッケージ。 &lt;strong&gt;基本的に、このアクセス指定子は、データメンバーを条件なしで世界に公開する場合に使用する必要があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de23e22099f028dd172f317f3ef75423c6e9cb8a" translate="yes" xml:space="preserve">
          <source>When you are developing some package and hence some class (say Class1) within it, you may use default (need not be mentioned explicitly) access specifier, to expose member within class, to other classes within your (same) package. In these other classes (within same package), you can access these default members on instance of Class1. Also you can access these default members within subclasses of Class1, say Class2 (on this reference or on instance of Class1 or on instance of Class2).</source>
          <target state="translated">あるパッケージを開発していて、その中にあるクラス (例えば Class1)を開発している場合、デフォルトの (明示的に言及する必要はありません)アクセス指定子を使用して、クラス内のメンバを (同じ)パッケージ内の他のクラスに公開することができます。これらの他のクラス (同じパッケージ内の)では、Class1 のインスタンス上でこれらのデフォルトメンバにアクセスすることができます。また、Class1 のサブクラス、例えば Class2 の中でも、これらのデフォルトメンバにアクセスすることができます (この参照、または Class1 のインスタンス、または Class2 のインスタンス上で)。</target>
        </trans-unit>
        <trans-unit id="ab5f7c5da1e908785059d10eee82f660fd70e889" translate="yes" xml:space="preserve">
          <source>When you are thinking of access modifiers just think of it in this way (applies to both &lt;strong&gt;variables&lt;/strong&gt; and &lt;strong&gt;methods&lt;/strong&gt;):</source>
          <target state="translated">アクセス修飾子について考えるときは、このように考えてください（ &lt;strong&gt;変数&lt;/strong&gt;と&lt;strong&gt;メソッドの&lt;/strong&gt;両方に適用され&lt;strong&gt;ます&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b2cf35e176192eaa161d1a6d979b561f22449218" translate="yes" xml:space="preserve">
          <source>When you bring him to the campus, the first thing that you and your friend sees is this statue. This means that anyone who walks in the campus can look at the statue without the university's permission. This makes the statue as &lt;strong&gt;PUBLIC&lt;/strong&gt;.</source>
          <target state="translated">彼をキャンパスに連れて行ったとき、あなたとあなたの友達が最初に目にするのはこの像です。 つまり、キャンパス内を歩く人は誰でも、大学の許可なしに像を見ることができます。 これにより、像は&lt;strong&gt;PUBLICになり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9733e2040efa0c9d4a97d71582ab64f36a523dfc" translate="yes" xml:space="preserve">
          <source>When you write another class Class3 within same/different package
that extends Class2, protected member from Class1 will be accessible
on this reference and also on explicit instance of Class3. This will
be true for any hierarchy that is extended i.e. protected member
will still be accessible on this reference or instance of extended
class. Note that in Class3, if you create instance of Class2 then
you will not be able to access protected member from Class1 though
it is inherited.</source>
          <target state="translated">Class2 を拡張した別の Class3 を同じ別のパッケージ内に書いた場合、Class1 の protected メンバは、この参照や Class3 の明示的なインスタンスからもアクセス可能になります。これは拡張されたどの階層にも当てはまります。つまり、保護されたメンバはこの参照や拡張されたクラスのインスタンス上でもアクセス可能です。Class3では、Class2のインスタンスを作成した場合、継承されているにもかかわらず、Class1からのprotectedメンバにアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7db19bf48ccf8618b8d48b1bccd529b75f5e1638" translate="yes" xml:space="preserve">
          <source>Which modifier to choose?</source>
          <target state="translated">どの修飾子を選ぶか?</target>
        </trans-unit>
        <trans-unit id="78394873daaf3ca1c582b2022bd91ff90bffcfbf" translate="yes" xml:space="preserve">
          <source>You also have to consider &lt;em&gt;nested&lt;/em&gt; scopes, such as inner classes. An example of the complexity is that inner classes have members, which themselves can take access modifiers. So you can have a private inner class with a public member; can the member be accessed? (See below.) The general rule is to look at scope and think recursively to see whether you can access each level.</source>
          <target state="translated">また、内部クラスなどの&lt;em&gt;ネストされた&lt;/em&gt;スコープも考慮する必要があります。 複雑さの例としては、内部クラスにメンバーがあり、それ自体がアクセス修飾子を取ることができるということがあります。 したがって、パブリックメンバーを持つプライベート内部クラスを持つことができます。 メンバーはアクセスできますか？ （以下を参照してください。）一般的なルールは、スコープを見て、再帰的に考えて、各レベルにアクセスできるかどうかを確認することです。</target>
        </trans-unit>
        <trans-unit id="6a9833145068de24bf1a54b7ae1bbaa1ff417a9d" translate="yes" xml:space="preserve">
          <source>You need access to a constructor to construct an object. Thus if all constructors are private, the class can only be constructed by code living within the class (typically static factory methods or static variable initializers). Similarly for package-private or protected constructors.</source>
          <target state="translated">オブジェクトを構築するにはコンストラクタにアクセスする必要があります。したがって、すべてのコンストラクタがプライベートである場合は、クラス内に存在するコード (通常は静的なファクトリメソッドや静的な変数の初期化子)によってのみクラスを構築することができます。パッケージ・プライベートあるいは保護されたコンストラクタについても同様です。</target>
        </trans-unit>
        <trans-unit id="13ebc736719c7b0ac170a13671dcbca61014c961" translate="yes" xml:space="preserve">
          <source>You won't be able to access inherited protected member of Class1 in
Class2, if you attempt to access it on explicit instance of Class1,
although it is inherited in it.</source>
          <target state="translated">Class1の明示的なインスタンスにアクセスしようとすると、Class2ではClass1に継承された保護されたメンバにアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="0342c9aebe9dfc86b2722a15889bef207a17eb8e" translate="yes" xml:space="preserve">
          <source>Your friend wants to login to the campus WiFi but doesn't have the any credentials to do so. The only way he can get online is if you share your login with him. (Remember, every student who goes to the university also possesses these login credentials). This would make your login credentials as &lt;strong&gt;NO MODIFIER&lt;/strong&gt;.</source>
          <target state="translated">友達がキャンパスWiFiにログインしたいのですが、ログインするための資格情報がありません。 彼がオンラインになる唯一の方法は、あなたが彼とあなたのログインを共有することです。 （覚えておいてください、大学に通うすべての学生はこれらのログイン資格情報も持っています）。 これにより、ログイン資格情報が&lt;strong&gt;NO MODIFIERになり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="0c6a031212fa407e33d1f50ffda6a1bf40baaa82" translate="yes" xml:space="preserve">
          <source>default (no modifier specified): accessible by the classes of the same package.</source>
          <target state="translated">default (修飾子を指定しない):同じパッケージのクラスからアクセス可能。</target>
        </trans-unit>
        <trans-unit id="64fa1dc60398c6bcdee08aa6c839a166432e015b" translate="yes" xml:space="preserve">
          <source>default (package)</source>
          <target state="translated">デフォルト</target>
        </trans-unit>
        <trans-unit id="81d4e9552c19ab8c332c76804f094d59bfe0653c" translate="yes" xml:space="preserve">
          <source>meaning that &lt;code&gt;public&lt;/code&gt; provides the most access, &lt;code&gt;private&lt;/code&gt; the least. Any reference possible on a private member is also valid for a package-private member; any reference to a package-private member is valid on a protected member, and so on. (Giving access to protected members to other classes in the same package was considered a mistake.)</source>
          <target state="translated">つまり、 &lt;code&gt;public&lt;/code&gt; は最も多くのアクセスを提供し、 &lt;code&gt;private&lt;/code&gt; は最も少なく提供します。 プライベートメンバーで可能な参照は、パッケージプライベートメンバーにも有効です。 package-privateメンバーへの参照はすべて、保護されたメンバーで有効です。 （同じパッケージ内の他のクラスに保護されたメンバーにアクセス権を与えることは、誤りと見なされました。）</target>
        </trans-unit>
        <trans-unit id="e80721793c24ae14edfca9b26ad406a9815cd3ff" translate="yes" xml:space="preserve">
          <source>private</source>
          <target state="translated">private</target>
        </trans-unit>
        <trans-unit id="964cab4bb4a5111731b0c00dbb43f794698d8731" translate="yes" xml:space="preserve">
          <source>protected</source>
          <target state="translated">protected</target>
        </trans-unit>
        <trans-unit id="61c9b2b17db77a27841bbeeabff923448b0f6388" translate="yes" xml:space="preserve">
          <source>public</source>
          <target state="translated">public</target>
        </trans-unit>
        <trans-unit id="10aa8b2ec5bd3e37ab9afc32631742bf8b2f7f90" translate="yes" xml:space="preserve">
          <source>public &amp;gt; protected &amp;gt; package-private &amp;gt; private</source>
          <target state="translated">public&amp;gt; protected&amp;gt; package-private&amp;gt; private</target>
        </trans-unit>
        <trans-unit id="04e4d31337d73d519a701e0100bf1767c9be25cc" translate="yes" xml:space="preserve">
          <source>then we have this simple table:</source>
          <target state="translated">とすると、このようなシンプルなテーブルができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
