<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/8318911">
    <body>
      <group id="8318911">
        <trans-unit id="b6d6d3bed5e4360c8f981fc61092af8db40788be" translate="yes" xml:space="preserve">
          <source>...produces a document with a &lt;strong&gt;red background&lt;/strong&gt; across all browsers and platforms.</source>
          <target state="translated">... 모든 브라우저와 플랫폼에서 &lt;strong&gt;빨간색 배경&lt;/strong&gt; 의 문서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="90c79427a637d3c801f8bcf85aee6ce09e84e94e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C00C00000000&lt;/code&gt; =&amp;gt; &lt;code&gt;R:C00C, G:0000, B:0000&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C00C00000000&lt;/code&gt; =&amp;gt; &lt;code&gt;R:C00C, G:0000, B:0000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5908ea286f207046f7d7ff51a76583b34e4f1935" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ChuCknorris&lt;/code&gt; translates to &lt;code&gt;c00c0000000&lt;/code&gt;.  At this point, the browser will divide the string into three equal sections, indicating &lt;em&gt;Red&lt;/em&gt;, &lt;em&gt;Green&lt;/em&gt; and &lt;em&gt;Blue&lt;/em&gt; values: &lt;code&gt;c00c 0000 0000&lt;/code&gt;.  Extra bits in each section will be ignored, which makes the final result &lt;code&gt;#c00000&lt;/code&gt; which is a reddish color.</source>
          <target state="translated">&lt;code&gt;ChuCknorris&lt;/code&gt; 는 c00c0000000으로 변환됩니다. 이 시점에서 브라우저는 문자열을 3 개의 동일한 섹션으로 나누고 &lt;em&gt;Red&lt;/em&gt; , &lt;em&gt;Green&lt;/em&gt; 및 &lt;em&gt;Blue&lt;/em&gt; 값을 나타냅니다 : &lt;code&gt;c00c 0000 0000&lt;/code&gt; . 각 섹션의 추가 비트는 무시되므로 최종 결과는 &lt;code&gt;#c00000&lt;/code&gt; ( 붉은 색)입니다.</target>
        </trans-unit>
        <trans-unit id="c34f0e7761f96717c2bb3d2582bd4f5e58d37cd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R:C00C, G:0000, B:0000&lt;/code&gt; =&amp;gt; &lt;code&gt;R:C0, G:00, B:00&lt;/code&gt; =&amp;gt; &lt;code&gt;C00000&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;R:C00C, G:0000, B:0000&lt;/code&gt; =&amp;gt; &lt;code&gt;R:C0, G:00, B:00&lt;/code&gt; =&amp;gt; &lt;code&gt;C00000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdbd8e58905068323db13fcb9503c60d5874e2ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chucknorris&lt;/code&gt; starts with &lt;code&gt;c&lt;/code&gt; which is recognised character in hexadecimal, also it's converting all unrecognised characters into &lt;code&gt;0&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;chucknorris&lt;/code&gt; 는 16 진수로 인식되는 &lt;code&gt;c&lt;/code&gt; 로 시작하며 인식 할 수없는 모든 문자를 &lt;code&gt;0&lt;/code&gt; 으로 변환합니다!</target>
        </trans-unit>
        <trans-unit id="e20468aa188cf92984a3fe7c4e72c85ba9f5ee1e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;P.S. The numbers in brackets are the browser versions I tested on.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PS 괄호 안의 숫자는 내가 테스트 한 브라우저 버전입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c332061cf4bd899460b0a4c0a7eaa14bdb27b163" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Answer:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f11a76626f3923193066b36bddea5202082482d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;chucknorris&lt;/strong&gt; starts with &lt;strong&gt;c&lt;/strong&gt;, and the browser reads it into a hexadecimal value.</source>
          <target state="translated">&lt;strong&gt;chucknorris&lt;/strong&gt; 는 &lt;strong&gt;c로&lt;/strong&gt; 시작하고 브라우저는이를 16 진수 값으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="70dba0a8d26cfc893b536aca75d8cef34e574a8f" translate="yes" xml:space="preserve">
          <source>Because A, B, C, D, E, and F are &lt;a href=&quot;https://en.wikipedia.org/wiki/Hexadecimal&quot;&gt;characters in hexadecimal&lt;/a&gt;.</source>
          <target state="translated">A, B, C, D, E 및 F는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hexadecimal&quot;&gt;16 진 문자&lt;/a&gt; 이므로</target>
        </trans-unit>
        <trans-unit id="6383e2acd181bb3a5ec4afd24b43ced0521882a9" translate="yes" xml:space="preserve">
          <source>Below is a partial implementation of the algorithm. It does not handle errors or cases where the user enters a valid color.</source>
          <target state="translated">아래는 알고리즘의 일부 구현입니다. 사용자가 유효한 색상을 입력하는 오류나 경우를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cab63b218aa009ada235109baffd10be95227fbc" translate="yes" xml:space="preserve">
          <source>But we know valid hexadecimal for RGB is just 2 characters, means &lt;code&gt;R: c0, G: 00, B:00&lt;/code&gt;</source>
          <target state="translated">그러나 RGB에 유효한 16 진수는 2 자이므로 &lt;code&gt;R: c0, G: 00, B:00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a504a3c367a66f1ea44d16c56de7ba4785e7f063" translate="yes" xml:space="preserve">
          <source>Chuck Norris doesn't conform to web standards. Web standards conform
  to him. #BADA55</source>
          <target state="translated">척 노리스는 웹 표준을 준수하지 않습니다. 웹 표준은 그를 따릅니다. # 바다 55</target>
        </trans-unit>
        <trans-unit id="25f2a36123f930c6195de2f2a76a7893477fa1a1" translate="yes" xml:space="preserve">
          <source>Discard all characters except the first 2</source>
          <target state="translated">처음 2를 제외한 모든 캐릭터를 버리십시오</target>
        </trans-unit>
        <trans-unit id="e8481aaeb9bf6d1a4ee42e981e8214c61919ad5b" translate="yes" xml:space="preserve">
          <source>Discard all characters except the last 8</source>
          <target state="translated">마지막 8자를 제외한 모든 캐릭터를 버리십시오</target>
        </trans-unit>
        <trans-unit id="6ef923436ac0445f743a32432826c89b75857e3f" translate="yes" xml:space="preserve">
          <source>Discard leading zeros one by one &lt;strong&gt;as long as all components have a leading zero&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모든 구성 요소에 선행 0이있는 경우&lt;/strong&gt; 선행 0을 하나씩 폐기하십시오.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="2ad6903c956477937e34db882a192413e0f2a6e8" translate="yes" xml:space="preserve">
          <source>Finally, show &lt;code&gt;bgcolor = C00000&lt;/code&gt; in the web browser.</source>
          <target state="translated">마지막으로 웹 브라우저에서 &lt;code&gt;bgcolor = C00000&lt;/code&gt; 을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="bbf2c4484b34d3367380273de15a9c5ece0fe0fc" translate="yes" xml:space="preserve">
          <source>For example, notice that each character is parsed as a hex digit and then is shifted into a 32-bit integer &lt;strong&gt;without checking for overflow&lt;/strong&gt;. Only eight hex digits fit into a 32-bit integer, which is why only the last 8 characters are considered. After parsing the hex digits into 32-bit integers, they are then truncated into 8-bit integers by dividing them by 16 until they fit into 8-bit, which is why leading zeros are ignored.</source>
          <target state="translated">예를 들어, 각 문자는 16 진수로 구문 분석 된 다음 &lt;strong&gt;overflow를 확인하지 않고&lt;/strong&gt; 32 비트 정수로 이동됩니다. 32 비트 정수에는 8 개의 16 진수 만 들어가므로 마지막 8 자만 고려됩니다. 16 진 숫자를 32 비트 정수로 구문 분석 한 후 16 비트를 8 비트에 맞을 때까지 16으로 나누어 8 비트 정수로 잘 리므로 선행 0이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="83c640cf08966d805f9e82d6eba98fb691fc3312" translate="yes" xml:space="preserve">
          <source>Here's an example demonstrating it:</source>
          <target state="translated">다음은이를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="c4e4d6e50d0e6a2b0fb0bba88b73470d1bead009" translate="yes" xml:space="preserve">
          <source>Here's an example demonstrating the &lt;code&gt;bgcolor&lt;/code&gt; attribute in action, to produce this &quot;amazing&quot; colour swatch:</source>
          <target state="translated">다음은이 &quot;놀라운&quot;색상 견본을 생성하기 위해 &lt;code&gt;bgcolor&lt;/code&gt; 속성이 작동하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="5e148392e4d81aa2c0e735090f9dfd1c412a57f8" translate="yes" xml:space="preserve">
          <source>How come certain random strings produce colors when entered as background colors in HTML? For example:</source>
          <target state="translated">HTML에서 배경색으로 입력 할 때 특정 임의의 문자열이 어떻게 색상을 생성합니까? 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3ee309bb5fe3a685dbf781e5fe4fb694d9e5227" translate="yes" xml:space="preserve">
          <source>I also added the steps in the image as a quick reference for you:</source>
          <target state="translated">또한 이미지의 단계를 빠른 참조로 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5e43306214b153b4803bd9a0de3b097cebda39ee" translate="yes" xml:space="preserve">
          <source>I originally encountered this when someone pointed out you could do &lt;code&gt;color=&quot;crap&quot;&lt;/code&gt; and, well, it comes out brown.</source>
          <target state="translated">나는 누군가 누군가 당신이 &lt;code&gt;color=&quot;crap&quot;&lt;/code&gt; 을 할 수 있다고 지적했을 때 이것을 만났고, 그것은 갈색으로 나옵니다.</target>
        </trans-unit>
        <trans-unit id="794fcecab5a94318c4d8b4733915683f1b282056" translate="yes" xml:space="preserve">
          <source>I was able to use these rules to correctly interpret the following strings:</source>
          <target state="translated">이 규칙을 사용하여 다음 문자열을 올바르게 해석 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="4fc6645bc14aeb18dea2272bce3f5a7ad18fdb45" translate="yes" xml:space="preserve">
          <source>I'm sorry to disagree, but according to the rules for parsing a legacy color value posted by &lt;a href=&quot;https://stackoverflow.com/a/12630675/282110&quot;&gt;@Yuhong Bao&lt;/a&gt;, &lt;code&gt;chucknorris&lt;/code&gt; DOES NOT equate to &lt;code&gt;#CC0000&lt;/code&gt;, but rather to &lt;code&gt;#C00000&lt;/code&gt;, a very similar but slightly different hue of red. I used the &lt;a href=&quot;https://addons.mozilla.org/en-us/firefox/addon/colorzilla/&quot;&gt;Firefox ColorZilla add-on&lt;/a&gt; to verify this.</source>
          <target state="translated">동의하지 않아 죄송하지만 &lt;a href=&quot;https://stackoverflow.com/a/12630675/282110&quot;&gt;@Yuhong Bao가&lt;/a&gt; 게시 한 기존 색상 값을 구문 분석하는 규칙에 따라 &lt;code&gt;chucknorris&lt;/code&gt; 는 &lt;code&gt;#CC0000&lt;/code&gt; 과 동일하지 않지만 &lt;code&gt;#C00000&lt;/code&gt; 과 매우 유사하지만 약간 다른 빨간색 색조입니다. &lt;a href=&quot;https://addons.mozilla.org/en-us/firefox/addon/colorzilla/&quot;&gt;Firefox ColorZilla 애드온을&lt;/a&gt; 사용하여이를 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="96407bc67b95cb75ff2f84517c9c4326b5387c2d" translate="yes" xml:space="preserve">
          <source>If we apply the rules in turn from the blog post, we get the following:</source>
          <target state="translated">블로그 게시물에서 규칙을 차례로 적용하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1ba6534d2ba347bc8825172a692c88fa554b840b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;chucknorris&lt;/code&gt;, everything except &lt;strong&gt;&lt;code&gt;c&lt;/code&gt;&lt;/strong&gt; is not a valid hex value.</source>
          <target state="translated">&lt;code&gt;chucknorris&lt;/code&gt; 에서 &lt;strong&gt; &lt;code&gt;c&lt;/code&gt; 를&lt;/strong&gt; 제외한 모든 것은 유효한 16 진수 값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="290fec8b4271fbd11d019422133fa5ea4202765d" translate="yes" xml:space="preserve">
          <source>Interestingly, while &lt;code&gt;chucknorri&lt;/code&gt; produces a red background as well, &lt;code&gt;chucknorr&lt;/code&gt; produces a yellow background.</source>
          <target state="translated">흥미롭게도 &lt;code&gt;chucknorri&lt;/code&gt; 는 빨간색 배경을 생성하지만 chucknorr 는 노란색 배경을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="765cfa7e7dfbf72d563a17f756b39e567a44fd65" translate="yes" xml:space="preserve">
          <source>It is from the blog post &lt;em&gt;&lt;a href=&quot;http://scrappy-do.blogspot.com/2004/08/little-rant-about-microsoft-internet.html&quot;&gt;A little rant about Microsoft Internet Explorer's color parsing&lt;/a&gt;&lt;/em&gt; which covers it in great detail, including varying lengths of color values, etc.</source>
          <target state="translated">블로그 게시물에서 가져온 것입니다. 다양한 길이의 색상 값 등을 포함하여 &lt;em&gt;&lt;a href=&quot;http://scrappy-do.blogspot.com/2004/08/little-rant-about-microsoft-internet.html&quot;&gt;Microsoft Internet Explorer의 색상 구문 분석에 대해 조금&lt;/a&gt;&lt;/em&gt; 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dc5c8c17a5b4ac2fafa08f96f4999f4a955b0808" translate="yes" xml:space="preserve">
          <source>It's a holdover from the Netscape days:</source>
          <target state="translated">넷스케이프 시절부터 이어진 것입니다.</target>
        </trans-unit>
        <trans-unit id="4dcb6a6719024ce6cca04984eae3160fb4db813c" translate="yes" xml:space="preserve">
          <source>Missing digits are treated as 0[...]. An incorrect digit is simply interpreted as 0. For example the values #F0F0F0, F0F0F0, F0F0F, #FxFxFx and FxFxFx are all the same.</source>
          <target state="translated">누락 된 숫자는 0 [...]으로 처리됩니다. 잘못된 숫자는 단순히 0으로 해석됩니다. 예를 들어 값 # F0F0F0, F0F0F0, F0F0F, #FxFxFx 및 FxFxFx는 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="69d2baba5d52206b59836e5f56bd1fe2aa3f836f" translate="yes" xml:space="preserve">
          <source>Most browsers will simply ignore any NON-hex values in your color string, substituting non-hex digits with zeros.</source>
          <target state="translated">대부분의 브라우저는 색상 문자열에서 16 진이 아닌 숫자를 0으로 대체하여 NON 16 진 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="57ebe10afc8571b57b2bfb670ecc0ff03286840d" translate="yes" xml:space="preserve">
          <source>Note, this does &lt;em&gt;not&lt;/em&gt; apply to CSS color parsing, which follow the CSS standard.</source>
          <target state="translated">CSS 표준을 따르는 CSS 색상 분석 &lt;em&gt;에는&lt;/em&gt; 적용되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6c407fc9343097f5eb8da3005ef6583b42991a" translate="yes" xml:space="preserve">
          <source>Now they get divided by 3 for &lt;code&gt;RGB&lt;/code&gt;(red, green, blue)... &lt;code&gt;R: c00c, G: 0000, B:0000&lt;/code&gt;...</source>
          <target state="translated">이제 &lt;code&gt;RGB&lt;/code&gt; (빨강, 녹색, 파랑)의 경우 3으로 나눕니다 ... &lt;code&gt;R: c00c, G: 0000, B:0000&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="c3c1ff36a5806b42f8d0732ec9c98d43f66cb06b" translate="yes" xml:space="preserve">
          <source>On a lighter note</source>
          <target state="translated">가벼운 노트</target>
        </trans-unit>
        <trans-unit id="2ee91262dc281714710a98baa64093dad825e899" translate="yes" xml:space="preserve">
          <source>Pad out to the next total number of characters divisible by 3 (11 -&amp;gt; 12)</source>
          <target state="translated">3으로 나눌 수있는 다음 총 문자 수까지 채 웁니다 (11-&amp;gt; 12).</target>
        </trans-unit>
        <trans-unit id="c50cc129c3062e4377f3d8ffec65ddc847317b08" translate="yes" xml:space="preserve">
          <source>Replace all nonvalid hexadecimal characters with 0's</source>
          <target state="translated">유효하지 않은 모든 16 진 문자를 0으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="33da177fcd9603be4ffaee5cd1898f7bbd6de709" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;c&lt;/code&gt; is the only valid hex character in &lt;strong&gt;chucknorris&lt;/strong&gt;, the value turns into: &lt;code&gt;c00c00000000&lt;/code&gt;(&lt;strong&gt;0 for all values that were invalid&lt;/strong&gt;).</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 는 &lt;strong&gt;chucknorris&lt;/strong&gt; 에서 유효한 16 진 문자 &lt;code&gt;c00c00000000&lt;/code&gt; ( &lt;strong&gt;유효하지 않은 모든 값의 경우 0)&lt;/strong&gt; 으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7c337b0ecd082d5d555f5c05d992447814e67fc8" translate="yes" xml:space="preserve">
          <source>Since valid hex values for html backgrounds only contain 2 digits for each color type (&lt;strong&gt;r&lt;/strong&gt;, &lt;strong&gt;g&lt;/strong&gt;, &lt;strong&gt;b&lt;/strong&gt;), the last 2 digits are truncated from each group, leaving an rgb value of &lt;code&gt;c00000&lt;/code&gt; which is a brick-reddish toned color.</source>
          <target state="translated">html 배경에 유효한 16 진수 값은 각 색상 유형 ( &lt;strong&gt;r&lt;/strong&gt; , &lt;strong&gt;g&lt;/strong&gt; , &lt;strong&gt;b&lt;/strong&gt; )에 대해 2 자리 숫자 만 포함하므로 마지막 두 자리는 각 그룹에서 잘리고 rgb 값은 &lt;code&gt;c00000&lt;/code&gt; ( 브릭 레드 톤)입니다.</target>
        </trans-unit>
        <trans-unit id="ab34b7402e9e42c1c9ec64c3affc073a0fb296c0" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;chucknorris&lt;/code&gt; in hexadecimal format becomes: &lt;code&gt;c00c00000000&lt;/code&gt;, all other characters become &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; remains where they are...</source>
          <target state="translated">따라서 16 진 형식의 &lt;code&gt;chucknorris&lt;/code&gt; 는 c00c00000000 이되고, 다른 모든 문자는 &lt;code&gt;0&lt;/code&gt; 이 되고 &lt;code&gt;c&lt;/code&gt; 는 &lt;code&gt;c00c00000000&lt;/code&gt; 위치에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="be81fef282fbf90ea4f4b6ba08e17eef2b9550d6" translate="yes" xml:space="preserve">
          <source>So it gets converted to &lt;strong&gt;&lt;code&gt;c00c00000000&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">따라서 &lt;strong&gt; &lt;code&gt;c00c00000000&lt;/code&gt; 으로&lt;/strong&gt; 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a226ac0686214f3851c2150f8bc75a10df0c5e0" translate="yes" xml:space="preserve">
          <source>So the real result is:</source>
          <target state="translated">실제 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="9d90712d2d85ff7dc5b134241490237e188ff82e" translate="yes" xml:space="preserve">
          <source>Split into three equal groups, with each component representing the corresponding colour component of an RGB colour:</source>
          <target state="translated">각 구성 요소가 RGB 색상의 해당 색상 구성 요소를 나타내는 세 개의 동일한 그룹으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="22b8684e77d5872811b2d2bd98487be9c70e6f95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-a-legacy-color-value&quot;&gt;rules for parsing colors on legacy attributes&lt;/a&gt; involves additional steps than those mentioned in existing answers. The truncate component to 2 digits part is described as:</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-a-legacy-color-value&quot;&gt;레거시 속성에서 색상을 구문 분석&lt;/a&gt; 하는 규칙 에는 기존 답변에서 언급 한 것보다 추가 단계가 포함됩니다. 자르기 구성 요소를 2 자리로 자르는 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98bebaad014f443e9cfa6aa5e3bb2b6d335181e9" translate="yes" xml:space="preserve">
          <source>The WHATWG HTML spec has the exact algorithm for parsing a legacy color value:
&lt;a href=&quot;https://html.spec.whatwg.org/multipage/infrastructure.html#rules-for-parsing-a-legacy-colour-value&quot;&gt;https://html.spec.whatwg.org/multipage/infrastructure.html#rules-for-parsing-a-legacy-colour-value&lt;/a&gt;</source>
          <target state="translated">WHATWG HTML 사양에는 레거시 색상 값을 구문 분석하기위한 정확한 알고리즘이 있습니다 : &lt;a href=&quot;https://html.spec.whatwg.org/multipage/infrastructure.html#rules-for-parsing-a-legacy-colour-value&quot;&gt;https://html.spec.whatwg.org/multipage/infrastructure.html#rules-for-parsing-a-legacy-colour-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="563c77aaf3a6c4c0a6d5f9162b9b45a41b77afa5" translate="yes" xml:space="preserve">
          <source>The browser converts &lt;code&gt;chucknorris&lt;/code&gt; to a hexadecimal value, &lt;code&gt;C00C00000000&lt;/code&gt;.</source>
          <target state="translated">브라우저는 &lt;code&gt;chucknorris&lt;/code&gt; 를 16 진수 값 C00C00000000 으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="db492ccb7233e657b773304ac9c32d796a42ba87" translate="yes" xml:space="preserve">
          <source>The browser is trying to convert &lt;code&gt;chucknorris&lt;/code&gt; into hex colour code, because it's not a valid value.</source>
          <target state="translated">브라우저에서 &lt;code&gt;chucknorris&lt;/code&gt; 을 ( 를) 16 진수 색상 코드로 변환하려고합니다. 유효한 값이 아니기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3bb41ff155e8f44950032e41ef83da2257be30ae" translate="yes" xml:space="preserve">
          <source>The browser needs only two digits to indicate the colour:</source>
          <target state="translated">브라우저는 색상을 표시하기 위해 두 자리 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="adcdc605edb8695db4c3c6223cd61a037e20376a" translate="yes" xml:space="preserve">
          <source>The browser then divides the result into 3 groupds: &lt;code&gt;Red = c00c&lt;/code&gt;, &lt;code&gt;Green = 0000&lt;/code&gt;, &lt;code&gt;Blue = 0000&lt;/code&gt;.</source>
          <target state="translated">그런 다음 브라우저는 결과를 3 개의 그룹으로 나눕니다 : &lt;code&gt;Red = c00c&lt;/code&gt; , &lt;code&gt;Green = 0000&lt;/code&gt; , &lt;code&gt;Blue = 0000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0118d700e198b7fe2a7acf885fe97e75b338478f" translate="yes" xml:space="preserve">
          <source>The browser will try to convert &lt;strong&gt;chucknorris&lt;/strong&gt; into a hexadecimal value.</source>
          <target state="translated">브라우저는 &lt;strong&gt;척 노리스&lt;/strong&gt; 를 16 진수 값으로 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="244c5be6c1ed4f3119517a0cdca68341bfda23cf" translate="yes" xml:space="preserve">
          <source>The code Netscape Classic used for parsing color strings is open source:
&lt;a href=&quot;https://dxr.mozilla.org/classic/source/lib/layout/layimage.c#155&quot;&gt;https://dxr.mozilla.org/classic/source/lib/layout/layimage.c#155&lt;/a&gt;</source>
          <target state="translated">색상 문자열을 구문 분석하는 데 사용되는 Netscape Classic 코드는 다음과 같습니다. &lt;a href=&quot;https://dxr.mozilla.org/classic/source/lib/layout/layimage.c#155&quot;&gt;https://dxr.mozilla.org/classic/source/lib/layout/layimage.c#155&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="362cd8c956eec39c8859cae84ab2235fd7f2b8c1" translate="yes" xml:space="preserve">
          <source>The reason is the browser can &lt;strong&gt;not understand&lt;/strong&gt; it and try to somehow translate it to what it can understand and in this case into a hexadecimal value!...</source>
          <target state="translated">그 이유는 브라우저가 &lt;strong&gt;그것을 이해할&lt;/strong&gt; 수 &lt;strong&gt;없으며&lt;/strong&gt; 어떻게 든 그것을 이해할 수있는 것으로 변환하려고 시도 하고이 경우 16 진수 값으로 변환하려고 시도하기 때문입니다!</target>
        </trans-unit>
        <trans-unit id="cc2c9111fbc1046d9f042a864ddb534dbff0391d" translate="yes" xml:space="preserve">
          <source>The rules state:</source>
          <target state="translated">규칙 상태 :</target>
        </trans-unit>
        <trans-unit id="7b8eeefac6b07f44be74847c5f460c24fa05d0d7" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;C00C00000000&lt;/code&gt; hexadecimal value is converted to &lt;strong&gt;RGB&lt;/strong&gt; format (divided by 3):</source>
          <target state="translated">그런 다음 &lt;code&gt;C00C00000000&lt;/code&gt; 16 진수 값이 &lt;strong&gt;RGB&lt;/strong&gt; 형식으로 변환됩니다 (3으로 나눔).</target>
        </trans-unit>
        <trans-unit id="99b2d8c0528f0bb8b9733bf673e73481a97c434c" translate="yes" xml:space="preserve">
          <source>This also answers the other part of the question; why does &lt;code&gt;bgcolor=&quot;chucknorr&quot;&lt;/code&gt; produce a yellow colour? Well, if we apply the rules, the string is:</source>
          <target state="translated">이것은 또한 질문의 다른 부분에 대한 답변입니다. &lt;code&gt;bgcolor=&quot;chucknorr&quot;&lt;/code&gt; 가 노란색을 생성하는 이유는 무엇입니까? 규칙을 적용하면 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f6519c3c962b763ec04c1f3391d0840b781b47d" translate="yes" xml:space="preserve">
          <source>This seems to be an issue primarily with &lt;strong&gt;Internet&amp;nbsp;Explorer&lt;/strong&gt; and &lt;strong&gt;Opera&lt;/strong&gt; (12) as both Chrome (31) and Firefox (26) just ignore this.</source>
          <target state="translated">Chrome (31)과 Firefox (26)는 모두 이것을 무시하므로 &lt;strong&gt;Internet Explorer&lt;/strong&gt; 와 &lt;strong&gt;Opera&lt;/strong&gt; (12)에서 주로 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="982b4efb7f62e7ba16e6010f5d112c58a8dc8c0f" translate="yes" xml:space="preserve">
          <source>Truncate each of the arguments from the right down to two characters</source>
          <target state="translated">각 인수를 오른쪽에서 두 문자로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="e22523618c5e0152d5cb390dfdabf3dcb9d184bb" translate="yes" xml:space="preserve">
          <source>UPDATE: &lt;em&gt;The original answerers who said the color was &lt;code&gt;#CC0000&lt;/code&gt; have since edited their answers to include the correction.&lt;/em&gt;</source>
          <target state="translated">업데이트 : &lt;em&gt;색상이 &lt;code&gt;#CC0000&lt;/code&gt; 이라고 답한 원래 답변자는 수정 사항을 포함하도록 답변을 편집했습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2bb2894918109500d7347664d5db11d5763f5be5" translate="yes" xml:space="preserve">
          <source>Update: this code does not exactly match what is defined in the spec, but the only difference there is a few lines of code. I think it is these lines that was added (in Netscape 4):</source>
          <target state="translated">업데이트 :이 코드는 사양에 정의 된 것과 정확하게 일치하지 않지만 몇 줄의 코드가 다릅니다. Netscape 4에서 추가 된 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a80832a90f0eb46f0620cb5802e9e519794d6d1a" translate="yes" xml:space="preserve">
          <source>What's going on here?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="4ac41a83308a6172be5bc58e0eb88bd447a0e42b" translate="yes" xml:space="preserve">
          <source>Which becomes &lt;strong&gt;#c00000&lt;/strong&gt;, a shade of red.</source>
          <target state="translated">빨간색 인 &lt;strong&gt;# c00000&lt;/strong&gt; 이됩니다.</target>
        </trans-unit>
        <trans-unit id="a1cf917d626d52f0ed9d0975baea1e19c7cfce40" translate="yes" xml:space="preserve">
          <source>Which gives a light yellow gold colour. As the string starts off as 9 characters, we keep the second C this time around hence it ends up in the final colour value.</source>
          <target state="translated">연한 노랑색을 띤다. 문자열이 9 자로 시작하므로 이번에는 두 번째 C를 유지하므로 최종 색상 값으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="3b5332a6836335115a5e712a8f03989a61013d00" translate="yes" xml:space="preserve">
          <source>Which gives the following result:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf43a7d4d3de11551375719c67aac4c5393d224a" translate="yes" xml:space="preserve">
          <source>Why does HTML think “chucknorris” is a color</source>
          <target state="translated">HTML에서 &quot;chucknorris&quot;가 색상이라고 생각하는 이유</target>
        </trans-unit>
        <trans-unit id="7a18bdea0d37a5050bfc3e29d04f2b01bb5d937f" translate="yes" xml:space="preserve">
          <source>keep the hex values, and add 0's where necessary: &lt;code&gt;C0 00 00&lt;/code&gt;</source>
          <target state="translated">16 진 값을 유지하고 필요한 경우 0을 추가하십시오. &lt;code&gt;C0 00 00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c47551fdaf627f26cf5a7355e4bce773c4d6dc9" translate="yes" xml:space="preserve">
          <source>make the string a length that is a multiple of 3 by adding 0s: &lt;code&gt;chucknorris0&lt;/code&gt;</source>
          <target state="translated">0을 추가하여 문자열 길이를 3의 배수로 &lt;code&gt;chucknorris0&lt;/code&gt; . chucknorris0</target>
        </trans-unit>
        <trans-unit id="30740490b283b12912b3d0fbe1a7800b1169f5a6" translate="yes" xml:space="preserve">
          <source>separate the string into 3 equal length strings: &lt;code&gt;chuc knor ris0&lt;/code&gt;</source>
          <target state="translated">문자열을 3 개의 동일한 길이의 문자열로 분리하십시오. &lt;code&gt;chuc knor ris0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4607b8a03bcdec83b0345e2fa20d1b08e5977fe0" translate="yes" xml:space="preserve">
          <source>truncate each string to 2 characters: &lt;code&gt;ch kn ri&lt;/code&gt;</source>
          <target state="translated">각 문자열을 2 자로 자릅니다. &lt;code&gt;ch kn ri&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
