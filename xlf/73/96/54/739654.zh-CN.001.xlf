<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/739654">
    <body>
      <group id="739654">
        <trans-unit id="7aa298487facfa7aa89c2a22cdd52ba7dc91da86" translate="yes" xml:space="preserve">
          <source>(Fun fact: &lt;code&gt;functools.wraps()&lt;/code&gt; is a decorator! ☺)</source>
          <target state="translated">（有趣的事实： &lt;code&gt;functools.wraps()&lt;/code&gt; 是一个装饰器！☺）</target>
        </trans-unit>
        <trans-unit id="ec945f8e517954ed7e4692ae6848ed84a9f6930f" translate="yes" xml:space="preserve">
          <source>...which should return:</source>
          <target state="translated">...这应该会回来的。</target>
        </trans-unit>
        <trans-unit id="3faa24506c65496ffae93e5003ddfce73c6eba64" translate="yes" xml:space="preserve">
          <source>65 &amp;lt;=&amp;gt; 'a'</source>
          <target state="translated">65 &amp;lt;=&amp;gt;'a'</target>
        </trans-unit>
        <trans-unit id="afe8afb3504b20d32cc84ed5acd9acc2e68234b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino's answer&lt;/a&gt; has the great advantage of only using the stdlib, and works for this simple example where there are no &lt;em&gt;decorator&lt;/em&gt; arguments nor &lt;em&gt;decorated function&lt;/em&gt; arguments.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino的答案&lt;/a&gt;具有仅使用stdlib的巨大优势，并且适用于这个没有&lt;em&gt;装饰器&lt;/em&gt;参数和&lt;em&gt;装饰函数&lt;/em&gt;参数的简单示例。</target>
        </trans-unit>
        <trans-unit id="39c714204a40cb85b72f9b281dd635e38f398715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decopatch&lt;/code&gt; provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following:</source>
          <target state="translated">&lt;code&gt;decopatch&lt;/code&gt; 根据您的喜好为您提供了另外两种隐藏或显示各种python概念的开发样式。 最紧凑的样式如下：</target>
        </trans-unit>
        <trans-unit id="10817e8cbf2a8f8c871558bcbf7cba4e250496bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the big question:&lt;/strong&gt; What can I use decorators for?</source>
          <target state="translated">&lt;strong&gt;现在有个大问题：&lt;/strong&gt;我可以使用装饰器做什么？</target>
        </trans-unit>
        <trans-unit id="0e9207d4303034edd69e7d460d2e0f98665deab8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You cannot un-decorate a function.&lt;/strong&gt; (There &lt;em&gt;are&lt;/em&gt; hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it&amp;rsquo;s decorated &lt;em&gt;for all the code&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;您不能取消装饰功能。&lt;/strong&gt; （有&lt;em&gt;一些&lt;/em&gt;技巧可以创建可以删除的装饰器，但是没有人使用它们。）因此，一旦装饰了一个函数，就&lt;em&gt;对所有代码进行&lt;/em&gt;装饰。</target>
        </trans-unit>
        <trans-unit id="66212ac2a71bc0df84e94d800c5fc4470af8faf2" translate="yes" xml:space="preserve">
          <source>A decorator takes the function definition and creates a new function that executes this function and transforms the result.</source>
          <target state="translated">装饰器取函数定义并创建一个新的函数,执行这个函数并转换结果。</target>
        </trans-unit>
        <trans-unit id="cd8c02a403c82a2547a2a793d9ef26cd94680682" translate="yes" xml:space="preserve">
          <source>Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:</source>
          <target state="translated">或者,你也可以写一个工厂函数,将被装饰的函数的返回值封装在传递给工厂函数的标签中。比如说。</target>
        </trans-unit>
        <trans-unit id="e2020432815d54b419eb1736a4714dda1093a358" translate="yes" xml:space="preserve">
          <source>An italics decorator could be like</source>
          <target state="translated">楷体装饰器可以像</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">而现在。</target>
        </trans-unit>
        <trans-unit id="fa8ef8ac0a9ff400ae17fa4ce35011055463e50d" translate="yes" xml:space="preserve">
          <source>And of course you can return lambdas as well from a decorator function:</source>
          <target state="translated">当然,你也可以从装饰器函数中返回lambdas。</target>
        </trans-unit>
        <trans-unit id="e96a6693d5d4f88633cbc2a33e13e2a0d48f90da" translate="yes" xml:space="preserve">
          <source>Another interesting property of Python functions is they can be defined inside another function!</source>
          <target state="translated">Python函数的另一个有趣的属性是,它们可以在另一个函数内部定义!</target>
        </trans-unit>
        <trans-unit id="c9450f3b037f9bb8f807346211bc2236317782c0" translate="yes" xml:space="preserve">
          <source>Another way of doing the same thing:</source>
          <target state="translated">另一种方式,也是一样的。</target>
        </trans-unit>
        <trans-unit id="a0e3876948b2d3ad605eb008566ef83c5b67ca01" translate="yes" xml:space="preserve">
          <source>Anything else we saw recently that wrapped function?</source>
          <target state="translated">最近我们看到的还有什么包装功能吗?</target>
        </trans-unit>
        <trans-unit id="950c70e94b9928cfcf9d7106401cb7cb2cef23d4" translate="yes" xml:space="preserve">
          <source>As a conclusion, you can easily see how to answer the question:</source>
          <target state="translated">作为结论,你不难看出,如何回答这个问题。</target>
        </trans-unit>
        <trans-unit id="620dffe2846f63bcd6945026a10272cd967f3d58" translate="yes" xml:space="preserve">
          <source>As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a &lt;em&gt;decorator factory&lt;/em&gt;&amp;mdash;in other words, a decorator function that makes other decorators. That way there would be less code repetition&amp;mdash;and allow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; principle to be followed.</source>
          <target state="translated">如您所见，这两个装饰器中有很多重复的代码。 鉴于这种相似性，您最好改成一个实际上是&lt;em&gt;装饰器工厂&lt;/em&gt;的通用泛型，换句话说，是一个装饰器函数，该函数可以装饰其他装饰器。 这样，代码重复次数将减少，并允许遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt;原则。</target>
        </trans-unit>
        <trans-unit id="abd19ad545dabf6d1e68777b92e162297c4ad254" translate="yes" xml:space="preserve">
          <source>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use &lt;code&gt;*args, **kwargs&lt;/code&gt; if you wish. But remember decorators are called &lt;strong&gt;only once&lt;/strong&gt;. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do &quot;import x&quot;, &lt;strong&gt;the function is already decorated&lt;/strong&gt;, so you can't
change anything.</source>
          <target state="translated">如您所见，您可以像使用此技巧的任何函数一样将参数传递给装饰器。 如果愿意 &lt;code&gt;*args, **kwargs&lt;/code&gt; 您甚至可以使用* args，** kwargs 。 但是请记住，装饰器&lt;strong&gt;仅&lt;/strong&gt;被调用&lt;strong&gt;一次&lt;/strong&gt; 。 就在Python导入脚本时。 之后，您将无法动态设置参数。 当您执行&amp;ldquo; import x&amp;rdquo;时， &lt;strong&gt;该函数已经被修饰&lt;/strong&gt; ，因此您无法进行任何更改。</target>
        </trans-unit>
        <trans-unit id="2ae7d3dab77def1437b4c1c2a696d710ab1e1c5a" translate="yes" xml:space="preserve">
          <source>Before rushing to the solution, let&amp;rsquo;s write a little reminder:</source>
          <target state="translated">在寻求解决方案之前，让我们写一些提醒：</target>
        </trans-unit>
        <trans-unit id="206a50a63dabbf1b2361c766ff1e3bb73ade5429" translate="yes" xml:space="preserve">
          <source>Best practices: decorators</source>
          <target state="translated">最佳做法:装饰公司</target>
        </trans-unit>
        <trans-unit id="5c5cf2ca4a0d4c3c42cb3df68a42305fe76df7ba" translate="yes" xml:space="preserve">
          <source>But we seem to have nearly lost the original function.</source>
          <target state="translated">但是,我们似乎几乎失去了原有的功能。</target>
        </trans-unit>
        <trans-unit id="dfad1322f6d290e904a701b70d67c393d4fa29c4" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;the documentation&lt;/a&gt; to see how decorators work. Here is what you asked for:</source>
          <target state="translated">查看&lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;文档，&lt;/a&gt;以了解装饰器如何工作。 这是您要求的：</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="bd9f92315d53d212a9dc77eec8576e4334c597c0" translate="yes" xml:space="preserve">
          <source>Decorate functions with different number of arguments:</source>
          <target state="translated">用不同数量的参数来装饰函数。</target>
        </trans-unit>
        <trans-unit id="7514a0f4a85fc4cc4fca21d25add9ec96e9cffcb" translate="yes" xml:space="preserve">
          <source>Decorating methods</source>
          <target state="translated">装修方法</target>
        </trans-unit>
        <trans-unit id="1e4898de5bee34139a3f87dd9b517db79f32b352" translate="yes" xml:space="preserve">
          <source>Decorator Basics</source>
          <target state="translated">装饰师基础知识</target>
        </trans-unit>
        <trans-unit id="aa70f4c0f7a0072ec8a62a6cba4e841875ee10e8" translate="yes" xml:space="preserve">
          <source>Decorators are just a pythonic variant of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;decorator design pattern&lt;/a&gt;. There are several classic design patterns embedded in Python to ease development (like iterators).</source>
          <target state="translated">装饰器只是&lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;装饰器设计模式&lt;/a&gt;的pythonic变体。 Python中嵌入了几种经典的设计模式来简化开发（例如迭代器）。</target>
        </trans-unit>
        <trans-unit id="1960c6c3a393f8280a1557da87c5ae49cc49728f" translate="yes" xml:space="preserve">
          <source>Decorators are just syntactical sugar.</source>
          <target state="translated">装饰者只是句法糖。</target>
        </trans-unit>
        <trans-unit id="e676466dac7ab2332c55066fac838c036e30a5f4" translate="yes" xml:space="preserve">
          <source>Decorators demystified</source>
          <target state="translated">装修公司解密</target>
        </trans-unit>
        <trans-unit id="baaf86734e7519c8e5b9a287fdd51a09542a7a2f" translate="yes" xml:space="preserve">
          <source>Decorators slow down the function call. Keep that in mind.</source>
          <target state="translated">装饰者放慢了函数调用。牢记这一点。</target>
        </trans-unit>
        <trans-unit id="2b88592aafba3e2bb5d236b6157ec8f8c13f5d66" translate="yes" xml:space="preserve">
          <source>Decorators were introduced in Python 2.4, so be sure your code will be run on &amp;gt;= 2.4.</source>
          <target state="translated">装饰器是在Python 2.4中引入的，因此请确保您的代码将在&amp;gt; = 2.4上运行。</target>
        </trans-unit>
        <trans-unit id="5068621933ab115670d1f879b688ce5fd62f2f83" translate="yes" xml:space="preserve">
          <source>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &amp;gt;= 2.5; see below.)</source>
          <target state="translated">装饰器包装函数，这会使它们难以调试。 （这在Python&amp;gt; = 2.5时会更好；请参见下文。）</target>
        </trans-unit>
        <trans-unit id="7ecbff500103805264ec8d27bb1b00270113802a" translate="yes" xml:space="preserve">
          <source>Django uses decorators to manage caching and view permissions.</source>
          <target state="translated">Django使用装饰器来管理缓存和视图权限。</target>
        </trans-unit>
        <trans-unit id="ccfab1893a822fe4138fc5bf3a6aa54d78163c81" translate="yes" xml:space="preserve">
          <source>Don't forget the construction for which decorator syntax is a shorthand:</source>
          <target state="translated">不要忘了装饰器语法是什么构造的速记。</target>
        </trans-unit>
        <trans-unit id="12c4ffe1d987164a4bedf6ab2aac597a113e181c" translate="yes" xml:space="preserve">
          <source>Efficiency</source>
          <target state="translated">Efficiency</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2c8c5c8eff80573c570fa19e7fbdbb5106e81f4d" translate="yes" xml:space="preserve">
          <source>For more on decorators, check
&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&lt;/a&gt;</source>
          <target state="translated">有关装饰器的更多信息，请&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;访问http://www.ibm.com/developerworks/linux/library/l-cpdecor.html。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f4aa69a5271cb03d99c15f1d53bdb53823e15db" translate="yes" xml:space="preserve">
          <source>For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as:</source>
          <target state="translated">首先,我认为这使得装饰器的行为非常清晰,同时也使得新的装饰器的定义非常简洁。对于上面所列举的例子,你可以用以下方式解决。</target>
        </trans-unit>
        <trans-unit id="b8be5d3c79e4970b1da1e51927bf0b5137e6d815" translate="yes" xml:space="preserve">
          <source>For similar reasons, the &lt;code&gt;functools.wraps&lt;/code&gt; decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (&lt;code&gt;func.__doc__&lt;/code&gt;) be those of the decorated function instead of &lt;code&gt;wrapped()&lt;/code&gt;'s.</source>
          <target state="translated">出于类似的原因， &lt;code&gt;functools.wraps&lt;/code&gt; 装饰器用于将包装函数的元属性更改为要装饰的函数的元属性。 这使错误消息和嵌入式功能文档（ &lt;code&gt;func.__doc__&lt;/code&gt; ）成为修饰后的功能的消息，而不是 &lt;code&gt;wrapped()&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="61bbffc7a0ea6d9bf4052e3dc9914af60bc4775f" translate="yes" xml:space="preserve">
          <source>Full featured solution - overcoming most of these problems</source>
          <target state="translated">功能齐全的解决方案----克服大部分问题</target>
        </trans-unit>
        <trans-unit id="fb7e0637c4d5a6d73f637194c0246e331b6544bf" translate="yes" xml:space="preserve">
          <source>Functions references</source>
          <target state="translated">职能参考</target>
        </trans-unit>
        <trans-unit id="d9429ca6d1142349d10e10a94576fffa86564438" translate="yes" xml:space="preserve">
          <source>Great, now what would you say about passing arguments to the decorator itself?</source>
          <target state="translated">很好,现在你觉得把参数传递给装饰器本身的参数如何?</target>
        </trans-unit>
        <trans-unit id="da0d931207acb9b41e89d340765036903cec4311" translate="yes" xml:space="preserve">
          <source>Handcrafted decorators</source>
          <target state="translated">手工制作的装饰品</target>
        </trans-unit>
        <trans-unit id="6c94ddf86de798e414a3de66543416eb33764543" translate="yes" xml:space="preserve">
          <source>Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.</source>
          <target state="translated">下面是一个简单的链式装饰器的例子。注意最后一行----它显示出了被子下面的情况。</target>
        </trans-unit>
        <trans-unit id="879edad30080eeaee9e2cf7411d0c110780e7c60" translate="yes" xml:space="preserve">
          <source>Here it is: a decorator with arguments. Arguments can be set as variable:</source>
          <target state="translated">这里是:一个带参数的装饰器。参数可以设置为变量。</target>
        </trans-unit>
        <trans-unit id="078d424ccacc316d41eb3c9e64c0a049566eda86" translate="yes" xml:space="preserve">
          <source>Hey, did you see that? We used a function call with the &quot;&lt;code&gt;@&lt;/code&gt;&quot; syntax! :-)</source>
          <target state="translated">嘿，你看到了吗？ 我们使用了带有&amp;ldquo; &lt;code&gt;@&lt;/code&gt; &amp;rdquo;语法的函数调用！ :-)</target>
        </trans-unit>
        <trans-unit id="a14b8e424350d415cdd48e9f09183de9ffb56f6f" translate="yes" xml:space="preserve">
          <source>How can I make two decorators in Python that would do the following?</source>
          <target state="translated">如何在Python中制作两个装饰器,能做到以下几点?</target>
        </trans-unit>
        <trans-unit id="12a65f2bbbb67ec061b91830c0f3852f397b8da4" translate="yes" xml:space="preserve">
          <source>How can the decorators be useful?</source>
          <target state="translated">装修公司如何才能派上用场?</target>
        </trans-unit>
        <trans-unit id="b5614093ef277f04d2fcf8a8f6d17ab705e42f42" translate="yes" xml:space="preserve">
          <source>How to make a chain of function decorators</source>
          <target state="translated">如何做一个功能装饰链</target>
        </trans-unit>
        <trans-unit id="9c80cc9314ab160ba886800aef0563ac91482582" translate="yes" xml:space="preserve">
          <source>How you&amp;rsquo;d do it manually:</source>
          <target state="translated">您将如何手动操作：</target>
        </trans-unit>
        <trans-unit id="4a1cc8e375a4ebd9b5ffc2959ee04c7e8d713115" translate="yes" xml:space="preserve">
          <source>However it has 3 major limitations if you want to tackle more general cases:</source>
          <target state="translated">然而,如果你想处理更多的一般案件,它有3大限制。</target>
        </trans-unit>
        <trans-unit id="1a3cd9a00b172fb82cc5ee4d2ed407fb3a1ac23e" translate="yes" xml:space="preserve">
          <source>I know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don't you feel good about mastering this?</source>
          <target state="translated">我知道,你上次有这种感觉,是在听一个人说:&quot;在了解递归之前,你必须先了解递归&quot;。但现在,你不觉得掌握了这个东西就好了吗?</target>
        </trans-unit>
        <trans-unit id="726239257c85d745949f495cf86f83f7f3423958" translate="yes" xml:space="preserve">
          <source>I wrote &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;&lt;code&gt;decopatch&lt;/code&gt;&lt;/a&gt; to solve the first issue, and wrote &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt;&lt;code&gt;makefun.wraps&lt;/code&gt;&lt;/a&gt; to solve the other two. Note that &lt;code&gt;makefun&lt;/code&gt; leverages the same trick than the famous &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt;&lt;code&gt;decorator&lt;/code&gt;&lt;/a&gt; lib.</source>
          <target state="translated">我写了&lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt; &lt;code&gt;decopatch&lt;/code&gt; &lt;/a&gt;解决了第一个问题，并写了&lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt; &lt;code&gt;makefun.wraps&lt;/code&gt; &lt;/a&gt;解决了另外两个问题。 请注意， &lt;code&gt;makefun&lt;/code&gt; 与著名的&lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt; &lt;code&gt;decorator&lt;/code&gt; &lt;/a&gt; lib具有相同的技巧。</target>
        </trans-unit>
        <trans-unit id="5d7696becef5ac38fad435088d0ecb76e8a0289a" translate="yes" xml:space="preserve">
          <source>I'm not trying to make &lt;code&gt;HTML&lt;/code&gt; this way in a real application - just trying to understand how decorators and decorator chaining works.</source>
          <target state="translated">我并不是想在实际的应用程序中以这种方式制作 &lt;code&gt;HTML&lt;/code&gt; ，而是试图了解装饰器和装饰器链接的工作方式。</target>
        </trans-unit>
        <trans-unit id="1e0c463512620a7aa52516ce6954607005e44fad" translate="yes" xml:space="preserve">
          <source>If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.</source>
          <target state="translated">如果对装饰函数的速度很重要,可以通过编写一个稍微不同的装饰器工厂函数来实现一次性添加所有标签,这样就可以生成代码,避免了为每个标签使用单独的装饰器而产生的额外函数调用,从而将开销控制在一个额外的函数调用中。</target>
        </trans-unit>
        <trans-unit id="7f5eb6d6e3ee8c4703ec52543976257f38262e16" translate="yes" xml:space="preserve">
          <source>If you are not into long explanations, see &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantino&amp;rsquo;s answer&lt;/a&gt;.</source>
          <target state="translated">如果您不做&lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;详尽的&lt;/a&gt;解释，请参阅Paolo Bergantino的答案 。</target>
        </trans-unit>
        <trans-unit id="317dfc8d065e9e0684a901257748d3a5167229f3" translate="yes" xml:space="preserve">
          <source>If you can &lt;code&gt;return&lt;/code&gt; a function, you can pass one as a parameter:</source>
          <target state="translated">如果可以 &lt;code&gt;return&lt;/code&gt; 一个函数，则可以将一个作为参数传递：</target>
        </trans-unit>
        <trans-unit id="48e4b22d8da3dfe34b25ed14a816e2633b2c5e3a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re making general-purpose decorator--one you&amp;rsquo;ll apply to any function or method, no matter its arguments--then just use &lt;code&gt;*args, **kwargs&lt;/code&gt;:</source>
          <target state="translated">如果要制作通用装饰器（无论其参数如何，都将应用于任何函数或方法），则只需使用 &lt;code&gt;*args, **kwargs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bef3f2c6067205cdab221b9850de1b292b160e38" translate="yes" xml:space="preserve">
          <source>In Python 3, you also get &lt;code&gt;__qualname__&lt;/code&gt; and &lt;code&gt;__annotations__&lt;/code&gt; assigned by default.</source>
          <target state="translated">在Python 3中，默认情况下 &lt;code&gt;__annotations__&lt;/code&gt; 分配 &lt;code&gt;__qualname__&lt;/code&gt; 和__annotations__ 。</target>
        </trans-unit>
        <trans-unit id="f85fcf9dfd9a481037c239b8ac3cb04c0f757dbe" translate="yes" xml:space="preserve">
          <source>In both cases you can check that the decorator works as expected:</source>
          <target state="translated">在这两种情况下,你可以检查一下装饰机的工作原理是否符合预期。</target>
        </trans-unit>
        <trans-unit id="441b181831532dd1b1468f0beb612ec2adb9a6ac" translate="yes" xml:space="preserve">
          <source>It can be used as follows:</source>
          <target state="translated">它的使用方法如下:</target>
        </trans-unit>
        <trans-unit id="a2364cec8db742e16d44a56e4e97742669df4b53" translate="yes" xml:space="preserve">
          <source>It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it.</source>
          <target state="translated">很遗憾的是,现在还有一些锅炉板,但这是我们能做的最简单的了。</target>
        </trans-unit>
        <trans-unit id="d52aaab6a849e68c11a3c5f3892267606e5ba341" translate="yes" xml:space="preserve">
          <source>It looks like the other people have already told you how to solve the problem. I hope this will help you understand what decorators are.</source>
          <target state="translated">看上去别人已经告诉你怎么解决这个问题了。希望对你了解什么是装修公司有帮助。</target>
        </trans-unit>
        <trans-unit id="0a437594f7f26d9de32ed6e32daf8a7144562ec6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s exactly the same. &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot; is called. So when you &lt;code&gt;@my_decorator&lt;/code&gt;, you are telling Python to call the function 'labelled by the variable &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot;'.</source>
          <target state="translated">完全一样 调用了&amp;ldquo; &lt;code&gt;my_decorator&lt;/code&gt; &amp;rdquo;。 因此，当您使用 &lt;code&gt;@my_decorator&lt;/code&gt; 时 ，您在告诉Python调用函数&amp;ldquo;由变量&amp;ldquo; &lt;code&gt;my_decorator&lt;/code&gt; &amp;rdquo;标记&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7ce0ce68a04f2b66e2e819d56376b33b1a2e7a7e" translate="yes" xml:space="preserve">
          <source>Keep this in mind. We&amp;rsquo;ll circle back to it shortly.</source>
          <target state="translated">请记住这一点。 我们很快会回头再说。</target>
        </trans-unit>
        <trans-unit id="4bceeb87ddeae7d32f5a461e830c4a01e1c2dbb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do EXACTLY the same thing, but skip all the pesky intermediate variables:</source>
          <target state="translated">让我们做完全一样的事情，但是跳过所有讨厌的中间变量：</target>
        </trans-unit>
        <trans-unit id="77a07d0b57a22cf6113918bd191c5b56c27d8347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get evil. ☺</source>
          <target state="translated">让我们变得邪恶。 ☺</target>
        </trans-unit>
        <trans-unit id="78be7938d254badacf135b18dc6cc6c451c38c66" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s have some fun and write a decorator for the decorators:</source>
          <target state="translated">让我们玩得开心，为装饰者写一个装饰者：</target>
        </trans-unit>
        <trans-unit id="27294f1ad34ef605ff9afc4e6f4c9ab75aadb8e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make it &lt;em&gt;even shorter&lt;/em&gt;:</source>
          <target state="translated">让我们把它&lt;em&gt;变得更短&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="cc604b7219e99c7ead3ddb49899ab7f07ac1541b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice: decorating a decorator</source>
          <target state="translated">练习：装饰装饰器</target>
        </trans-unit>
        <trans-unit id="ca309b745c2658e0e7c0557696b22a6ed74f2b7c" translate="yes" xml:space="preserve">
          <source>No surprise here.</source>
          <target state="translated">在这里并不意外。</target>
        </trans-unit>
        <trans-unit id="255ef6b7422b7ccfa19a20bfa097944e74cf3b94" translate="yes" xml:space="preserve">
          <source>Note that a function is defined inside a function.
What it basically does is replace a function with the newly defined one. For example, I have this class</source>
          <target state="translated">注意,一个函数是在一个函数内部定义的。它的基本作用是用新定义的函数替换一个函数。例如,我有这样一个类</target>
        </trans-unit>
        <trans-unit id="2dc264a51f806548732cb077d81ae6952adc115e" translate="yes" xml:space="preserve">
          <source>Notice that this example didn't include the &lt;code&gt;list&lt;/code&gt; type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list.</source>
          <target state="translated">注意，该示例在装饰器的实例中未包括 &lt;code&gt;list&lt;/code&gt; 类型，因此在最终的print语句中，该方法将应用于列表本身，而不是列表的元素。</target>
        </trans-unit>
        <trans-unit id="7d0d40184a1e365e8aec68153ce0e6264dbac917" translate="yes" xml:space="preserve">
          <source>Now say, I want both functions to print &quot;---&quot; after and before they are done.
I could add a print &quot;---&quot; before and after each print statement.
But because I don't like repeating myself, I will make a decorator</source>
          <target state="translated">现在说,我想让这两个函数在完成后和完成前都打印&quot;-----&quot;。我可以在每条打印语句的前后加上一个打印&quot;-----&quot;。但因为我不喜欢重复,所以我将做一个装饰符</target>
        </trans-unit>
        <trans-unit id="6374db670ada8df89b3ba0c8efdc28f893467811" translate="yes" xml:space="preserve">
          <source>Now use them as desired:</source>
          <target state="translated">现在根据需要使用。</target>
        </trans-unit>
        <trans-unit id="0cb1ffaf9060bacf69b447f3baaca8c541d46cf1" translate="yes" xml:space="preserve">
          <source>Now, you probably want that every time you call &lt;code&gt;a_stand_alone_function&lt;/code&gt;, &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; is called instead. That&amp;rsquo;s easy, just overwrite &lt;code&gt;a_stand_alone_function&lt;/code&gt; with the function returned by &lt;code&gt;my_shiny_new_decorator&lt;/code&gt;:</source>
          <target state="translated">现在，您可能希望每次调用 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 时都调用a_stand_alone_function_decorated 。 这很简单，只需使用 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 返回的函数覆盖 &lt;code&gt;my_shiny_new_decorator&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="40887ec7e652c1bdf57a41f57f0cb24e4ff2822b" translate="yes" xml:space="preserve">
          <source>Now: to answer the question...</source>
          <target state="translated">现在:回答这个问题.....</target>
        </trans-unit>
        <trans-unit id="579d575c5ed4bac1f322abf77675f853665ad5bb" translate="yes" xml:space="preserve">
          <source>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:</source>
          <target state="translated">当然有了装饰品的好处是,你几乎可以马上用在任何东西上,不用重写。干,我说了。</target>
        </trans-unit>
        <trans-unit id="1be3cbc92c16a773de95bc885b3fc9e99b4a6788" translate="yes" xml:space="preserve">
          <source>Of course, you can accumulate decorators:</source>
          <target state="translated">当然,你可以积累装饰者。</target>
        </trans-unit>
        <trans-unit id="91a37b5d402fd2f9d6d6d0b09967c77439df7c5c" translate="yes" xml:space="preserve">
          <source>Oh yes, decorators!</source>
          <target state="translated">哦,是的,装饰师!</target>
        </trans-unit>
        <trans-unit id="10957fc6e11cfdfbf98f8f5f5c0ad12c66b378d0" translate="yes" xml:space="preserve">
          <source>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.</source>
          <target state="translated">好了,作为奖励,我将给你一个片段,让任何装饰器都能通用地接受任何参数。毕竟,为了接受参数,我们使用另一个函数创建了我们的装饰器。</target>
        </trans-unit>
        <trans-unit id="6bbd3347dd91397e5be987a0a88f7eff1abc0a3e" translate="yes" xml:space="preserve">
          <source>Okay, still here? Now the fun part...</source>
          <target state="translated">好了,还在这里?现在是有趣的部分.....</target>
        </trans-unit>
        <trans-unit id="56949a19e12ea95f6c3843043b9cdd359a9fb0c0" translate="yes" xml:space="preserve">
          <source>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (&lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">关于Python的一件事是方法和函数实际上是相同的。 唯一的区别是方法期望它们的第一个参数是对当前对象（ &lt;code&gt;self&lt;/code&gt; ）的引用。</target>
        </trans-unit>
        <trans-unit id="7e0a663c8d21ccb65a769c61071c5d509abd2783" translate="yes" xml:space="preserve">
          <source>Or, more flexibly:</source>
          <target state="translated">或者说,更加灵活。</target>
        </trans-unit>
        <trans-unit id="2fb316fd9385ead51b295112e84edb25cd8b95b1" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorated function</source>
          <target state="translated">传递参数给装饰过的函数</target>
        </trans-unit>
        <trans-unit id="24b163e0afbd75a6ca84ffb958862c256129d2de" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorator</source>
          <target state="translated">传递参数给装饰器</target>
        </trans-unit>
        <trans-unit id="17d426ae159ee05b9325ff80a8339b7de2e089f6" translate="yes" xml:space="preserve">
          <source>Personally I would have written the decorator somewhat differently:</source>
          <target state="translated">就我个人而言,我会将装饰者写得有些不同。</target>
        </trans-unit>
        <trans-unit id="c7b7f62e823e6869c5758a9786c02608bd932456" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参阅&lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c10adc093e3b42e5c9bf392b6f6849c6dbd8218e" translate="yes" xml:space="preserve">
          <source>Problems with the simple solution</source>
          <target state="translated">简单解决的问题</target>
        </trans-unit>
        <trans-unit id="6ed78550e4466481db863ec487bb1bd253cc35d3" translate="yes" xml:space="preserve">
          <source>Python decorators add extra functionality to another function</source>
          <target state="translated">Python装饰器为另一个函数添加额外的功能</target>
        </trans-unit>
        <trans-unit id="d1727d8a5520ad1a9627fdc2eab00abe2b5d6379" translate="yes" xml:space="preserve">
          <source>Python itself provides several decorators: &lt;code&gt;property&lt;/code&gt;, &lt;code&gt;staticmethod&lt;/code&gt;, etc.</source>
          <target state="translated">Python本身提供了几种装饰器： &lt;code&gt;property&lt;/code&gt; ， &lt;code&gt;staticmethod&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="284cca9bb8bff3580e1d28d9004c90370ab5fc92" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s functions are objects</source>
          <target state="translated">Python的函数是对象</target>
        </trans-unit>
        <trans-unit id="0fb5d72701f71daeb5de4c55b12b5b28333babb4" translate="yes" xml:space="preserve">
          <source>Refinements</source>
          <target state="translated">Refinements</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="447529f8d79e74c1015331f703c4fd58c0024d0f" translate="yes" xml:space="preserve">
          <source>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it&amp;rsquo;s temporary).</source>
          <target state="translated">看起来很酷而且功能强大，但是一个实际的例子将是很好的。 好吧，这里有1000种可能性。 经典用法是从外部库扩展功能行为（您不能对其进行修改），或者用于调试（您不希望对其进行修改，因为它是临时的）。</target>
        </trans-unit>
        <trans-unit id="8190083ab834e9da2d9dcad17a07753d67081489" translate="yes" xml:space="preserve">
          <source>Simple solution</source>
          <target state="translated">简单的解决方案</target>
        </trans-unit>
        <trans-unit id="379eadfed2be4f0025e4f13911405915d77b0d61" translate="yes" xml:space="preserve">
          <source>So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.</source>
          <target state="translated">所以,如果我们在这个函数上放上文档,或者是希望能够对取一个以上参数的函数进行装饰,或者我们只是想在调试的时候知道是什么函数,那么我们就需要在wrapper上多做一些工作。</target>
        </trans-unit>
        <trans-unit id="1c60607379772605752445769cae451aa46faaba" translate="yes" xml:space="preserve">
          <source>So now I can change my class to</source>
          <target state="translated">所以现在我可以把我的课改成</target>
        </trans-unit>
        <trans-unit id="6cbe6521ca09a7746011901561de604aa6c89d3c" translate="yes" xml:space="preserve">
          <source>So now:</source>
          <target state="translated">所以现在。</target>
        </trans-unit>
        <trans-unit id="efb7b2d9e9ca503721dfb04f5dc4469198ba42fa" translate="yes" xml:space="preserve">
          <source>So we see that &lt;code&gt;wraps&lt;/code&gt; makes the wrapping function do almost everything except tell us exactly what the function takes as arguments.</source>
          <target state="translated">因此，我们看到， &lt;code&gt;wraps&lt;/code&gt; 包裹函数几乎可以执行所有操作，除了确切告诉我们该函数将其用作参数之外。</target>
        </trans-unit>
        <trans-unit id="50cf77367001a751c11f1a93c8af87bfa1080df0" translate="yes" xml:space="preserve">
          <source>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?</source>
          <target state="translated">那么,回到带参数的装饰器。如果我们可以用函数来生成装饰器,那么我们可以把参数传递给那个函数,对吧?</target>
        </trans-unit>
        <trans-unit id="5cb9c55c987610f1d50dddd4525d5c7adbdde9f8" translate="yes" xml:space="preserve">
          <source>Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:</source>
          <target state="translated">说到计数器的例子--如上所述,计数器将在所有使用装饰器的函数之间共享。</target>
        </trans-unit>
        <trans-unit id="96b98ca4ad50b3f8c62ee69fd0d15c5c564ba92c" translate="yes" xml:space="preserve">
          <source>Taking decorators to the next level</source>
          <target state="translated">将装饰公司推向新的高度</target>
        </trans-unit>
        <trans-unit id="437612b73a9a61ff531195df2dfd1a552e3cd790" translate="yes" xml:space="preserve">
          <source>That means that &lt;strong&gt;a function can &lt;code&gt;return&lt;/code&gt; another function&lt;/strong&gt;.</source>
          <target state="translated">这意味着&lt;strong&gt;一个函数可以 &lt;code&gt;return&lt;/code&gt; 另一个函数&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f298bfca0f195e40010a96673a464012e8d44e65" translate="yes" xml:space="preserve">
          <source>That means you can build a decorator for methods the same way! Just remember to take &lt;code&gt;self&lt;/code&gt; into consideration:</source>
          <target state="translated">这意味着您可以以相同的方式为方法构建装饰器！ 只要记住要考虑一下 &lt;code&gt;self&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="050b7db66c47db53ba8a596842a9b2aa1e330633" translate="yes" xml:space="preserve">
          <source>That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt;), and the counter variable will remain private to each.</source>
          <target state="translated">这样，您的装饰器可以重复用于不同的功能（或多次装饰同一功能： &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt; ），并且counter变量将对每个函数保持私有。</target>
        </trans-unit>
        <trans-unit id="5564267bef96d8c06f321659900ce4a65f09fbb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functools&lt;/code&gt; module was introduced in Python 2.5. It includes the function &lt;code&gt;functools.wraps()&lt;/code&gt;, which copies the name, module, and docstring of the decorated function to its wrapper.</source>
          <target state="translated">&lt;code&gt;functools&lt;/code&gt; 模块是Python 2.5中引入的。 它包括函数 &lt;code&gt;functools.wraps()&lt;/code&gt; ，该函数将修饰后的函数的名称，模块和文档字符串复制到其包装器中。</target>
        </trans-unit>
        <trans-unit id="b96153d0cd80112477376110b277ba00b0b61985" translate="yes" xml:space="preserve">
          <source>The order you set the decorators MATTERS:</source>
          <target state="translated">你设置装饰者的顺序很重要。</target>
        </trans-unit>
        <trans-unit id="ee3ecad5bd632505c874495ef908b5ccadff853d" translate="yes" xml:space="preserve">
          <source>The output looks like:</source>
          <target state="translated">输出看起来像。</target>
        </trans-unit>
        <trans-unit id="c333dc4fec82663d8c79348d8fc54c67a7a233bc" translate="yes" xml:space="preserve">
          <source>The previous example, using the decorator syntax:</source>
          <target state="translated">前面的例子,使用装饰器语法。</target>
        </trans-unit>
        <trans-unit id="960b2fe36e68117facc37e06febe129a38132041" translate="yes" xml:space="preserve">
          <source>There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.</source>
          <target state="translated">还有其他的模块可以尝试解决这个问题,但标准库中还没有这个解决方案。</target>
        </trans-unit>
        <trans-unit id="af9cac89e15b8a4e52d28cb0c6dc344f017cf8ab" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s more!</source>
          <target state="translated">还有更多！</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b5039e57d9fc37a75f36b953d9898eff7500a6b9" translate="yes" xml:space="preserve">
          <source>This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact.</source>
          <target state="translated">这个答案早就有人回答过了,但我想,我还是把我的装潢班分享给大家,让大家写新的装潢师简单而紧凑。</target>
        </trans-unit>
        <trans-unit id="2904fc69aef6f7ec13cb9a23a39932c544deb84c" translate="yes" xml:space="preserve">
          <source>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function&amp;rsquo;s arguments directly to the decorator.</source>
          <target state="translated">因为装饰器必须接受一个函数作为参数，所以这可能会有些扭曲。 因此，您不能将装饰函数的参数直接传递给装饰器。</target>
        </trans-unit>
        <trans-unit id="a2c775a862081edfd042f2470df626fc3eef6aa4" translate="yes" xml:space="preserve">
          <source>This enables you to write:</source>
          <target state="translated">这样可以让你写。</target>
        </trans-unit>
        <trans-unit id="0b1c1e381424a38b2424282c1fa352f40d278095" translate="yes" xml:space="preserve">
          <source>This is how you would create a decorator with arguments, returning truly signature-preserving wrappers:</source>
          <target state="translated">这就是你将如何创建一个带参数的装饰器,返回真正的签名保存的包装器。</target>
        </trans-unit>
        <trans-unit id="ce42d5743ee1866f5dc731830ebf5ed5afa194eb" translate="yes" xml:space="preserve">
          <source>This is important! The label you give can point directly to the decorator&amp;mdash;&lt;strong&gt;or not&lt;/strong&gt;.</source>
          <target state="translated">这个很重要！ 您提供的标签可以直接指向装饰器，也可以不指向。</target>
        </trans-unit>
        <trans-unit id="5027fb5d3093f380441a1296b10193eb568104dd" translate="yes" xml:space="preserve">
          <source>This really is a large playground.</source>
          <target state="translated">这真的是一个大操场。</target>
        </trans-unit>
        <trans-unit id="1fd557f5cb363c1aff4438192da3019b9a577767" translate="yes" xml:space="preserve">
          <source>This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using &lt;code&gt;lambda&lt;/code&gt; functions as previously illustrated. Sample:</source>
          <target state="translated">这需要装饰器本身中的更多代码，但这仅在将其应用于函数定义时才运行，而不是在调用它们本身时才运行。 当通过使用 &lt;code&gt;lambda&lt;/code&gt; 函数创建更具可读性的名称时，这同样适用。 样品：</target>
        </trans-unit>
        <trans-unit id="a8eaf579c4f258b33b0482ef3b7df54778820469" translate="yes" xml:space="preserve">
          <source>To explain the decorator in a simple way:</source>
          <target state="translated">用简单的方式来解释装饰公司。</target>
        </trans-unit>
        <trans-unit id="473f07947e0fd95c8d023c615f35b4d07297397e" translate="yes" xml:space="preserve">
          <source>To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other:</source>
          <target state="translated">要想找到它,我们需要挖掘每一个λ的封闭性,其中的一个埋藏着另一个。</target>
        </trans-unit>
        <trans-unit id="d05d323aa64f59be265e5a87806a41e0c825210f" translate="yes" xml:space="preserve">
          <source>To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:</source>
          <target state="translated">为了使代码更易读,你可以给工厂生成的装饰器指定一个更有描述性的名称。</target>
        </trans-unit>
        <trans-unit id="883de3fa331a806ddd7c7652ca1e49092c7971b4" translate="yes" xml:space="preserve">
          <source>To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:</source>
          <target state="translated">要想最简单地做到这一点,可以制作返回lambdas(匿名函数)的装饰器,在函数(close)上关闭并调用它。</target>
        </trans-unit>
        <trans-unit id="62f4218b8c6ef484c2f1975f99215aea59a557d9" translate="yes" xml:space="preserve">
          <source>To return:</source>
          <target state="translated">返回:</target>
        </trans-unit>
        <trans-unit id="bd12f2d27cd71bb3463350185fcfc9d61abd15f6" translate="yes" xml:space="preserve">
          <source>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let&amp;rsquo;s see why with a simple example :</source>
          <target state="translated">要了解装饰器，您必须首先了解函数是Python中的对象。 这具有重要的后果。 让我们来看一个简单的例子：</target>
        </trans-unit>
        <trans-unit id="196f074c1d92f9ced554dc60521c54d33c9ca742" translate="yes" xml:space="preserve">
          <source>To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result.</source>
          <target state="translated">为了理解装饰器,必须注意的是,装饰器创建了一个新的函数,它是内部执行函数和转换结果的新函数。</target>
        </trans-unit>
        <trans-unit id="60902dc77861b8c1fdfaf6268a2464fa22de1ceb" translate="yes" xml:space="preserve">
          <source>Twisted to fake inlining asynchronous functions calls.</source>
          <target state="translated">扭曲为假的内联异步函数调用。</target>
        </trans-unit>
        <trans-unit id="c77a8f9b1468c11516a914ac6de3a49735219779" translate="yes" xml:space="preserve">
          <source>Using the Python decorator syntax:</source>
          <target state="translated">使用Python装饰器语法。</target>
        </trans-unit>
        <trans-unit id="aa9cefd3355dfbb169969e4d070840477e8f3574" translate="yes" xml:space="preserve">
          <source>We have the decorator &lt;code&gt;wraps&lt;/code&gt; from the &lt;code&gt;functools&lt;/code&gt; module in the standard library!</source>
          <target state="translated">我们在标准库中提供了 &lt;code&gt;functools&lt;/code&gt; 模块中的装饰器 &lt;code&gt;wraps&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="e7828a39d26d60430dd896cb93790f6a849e80c7" translate="yes" xml:space="preserve">
          <source>We wrapped the decorator.</source>
          <target state="translated">我们把装修公司包了起来。</target>
        </trans-unit>
        <trans-unit id="fe01beda96c243b61696dcac93827863db70a633" translate="yes" xml:space="preserve">
          <source>Well, you just have everything needed to understand decorators. You see, decorators are &amp;ldquo;wrappers&amp;rdquo;, which means that &lt;strong&gt;they let you execute code before and after the function they decorate&lt;/strong&gt; without modifying the function itself.</source>
          <target state="translated">好吧，您只需具备了解装饰器所需的一切。 您会看到，装饰器是&amp;ldquo;包装器&amp;rdquo;，这意味着&lt;strong&gt;它们使您可以在装饰函数之前和之后执行代码，而&lt;/strong&gt;无需修改函数本身。</target>
        </trans-unit>
        <trans-unit id="e60ee3faedca029b522b5766bd4fef43e46646de" translate="yes" xml:space="preserve">
          <source>When do:</source>
          <target state="translated">什么时候做。</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">哪些印刷品。</target>
        </trans-unit>
        <trans-unit id="0f59d388d686c4bb98639de68bb575c3f2e8c1b3" translate="yes" xml:space="preserve">
          <source>While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).</source>
          <target state="translated">虽然上面的例子都能正常工作,但当同时应用多个装饰器时,生成的代码涉及到大量的开销,即外在函数调用。这可能并不重要,这取决于具体的使用情况(例如,可能是IO-bound)。</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="80931ea7fb9f9baaccc7db7989d6b55cd34a1502" translate="yes" xml:space="preserve">
          <source>Yes, that&amp;rsquo;s all, it&amp;rsquo;s that simple. &lt;code&gt;@decorator&lt;/code&gt; is just a shortcut to:</source>
          <target state="translated">是的，仅此而已。 &lt;code&gt;@decorator&lt;/code&gt; 只是以下操作的快捷方式：</target>
        </trans-unit>
        <trans-unit id="82aa4bf8798112112023c3bf62cf028a41534be3" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; make two separate decorators that do what you want as illustrated directly below. Note the use of &lt;code&gt;*args, **kwargs&lt;/code&gt; in the declaration of the &lt;code&gt;wrapped()&lt;/code&gt; function which supports the decorated function having multiple arguments (which isn't really necessary for the example &lt;code&gt;say()&lt;/code&gt; function, but is included for generality).</source>
          <target state="translated">您&lt;em&gt;可以&lt;/em&gt;制作两个单独的装饰器，按您的意愿进行操作，如下所示。 请注意，在 &lt;code&gt;wrapped()&lt;/code&gt; 函数的声明中使用了 &lt;code&gt;*args, **kwargs&lt;/code&gt; ，该函数支持具有多个参数的修饰函数（对于示例 &lt;code&gt;say()&lt;/code&gt; 函数而言，这并不是必需的，但出于一般性考虑而包括在内）。</target>
        </trans-unit>
        <trans-unit id="3fcf6e6cdbd43a4541ee6fee7299941830fb61da" translate="yes" xml:space="preserve">
          <source>You can also write decorator in Class</source>
          <target state="translated">你也可以在类中写装饰器</target>
        </trans-unit>
        <trans-unit id="e0a9ddf317ada0cb0975c84b1b3a3350e91427a6" translate="yes" xml:space="preserve">
          <source>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.</source>
          <target state="translated">这时,你可以只管高兴地离开,也可以多烧点脑筋,看看装饰品的高级用途。</target>
        </trans-unit>
        <trans-unit id="50c0158657b192fc0e1e92b4b42743e823b5581b" translate="yes" xml:space="preserve">
          <source>You can use them to extend several functions in a DRY&amp;rsquo;s way, like so:</source>
          <target state="translated">您可以使用它们以DRY的方式扩展多个功能，如下所示：</target>
        </trans-unit>
        <trans-unit id="eb12aebb78c3f68a3b62316d71c4c613fca73470" translate="yes" xml:space="preserve">
          <source>You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator:</source>
          <target state="translated">你也可以用它来完成更复杂的任务,比如说一个装饰器,它可以自动使函数递归应用到迭代器中的所有参数。</target>
        </trans-unit>
        <trans-unit id="2ecc0fab1db96d14074c26f8bc8f79f84ec79ac0" translate="yes" xml:space="preserve">
          <source>You really do:</source>
          <target state="translated">你真的是这样。</target>
        </trans-unit>
        <trans-unit id="e81544690dadca1e7c105c62bc3929aebc31d34d" translate="yes" xml:space="preserve">
          <source>You want the following function, when called:</source>
          <target state="translated">你希望下面的函数,当被调用时。</target>
        </trans-unit>
        <trans-unit id="953873baa875246b6189da13ed630a79eb5fb0e9" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve seen that functions are objects. Therefore, functions:</source>
          <target state="translated">您已经看到函数是对象。 因此，功能：</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">而现在,</target>
        </trans-unit>
        <trans-unit id="cafef07857121c9781de270f85e3951e33ef3a0f" translate="yes" xml:space="preserve">
          <source>as already noted in several answers, you can not easily modify the code to &lt;strong&gt;add optional decorator arguments&lt;/strong&gt;. For example creating a &lt;code&gt;makestyle(style='bold')&lt;/code&gt; decorator is non-trivial.</source>
          <target state="translated">正如在几个答案中已经指出的那样，您无法轻松地修改代码以&lt;strong&gt;添加可选的decorator参数&lt;/strong&gt; 。 例如，创建 &lt;code&gt;makestyle(style='bold')&lt;/code&gt; 装饰器并非易事 。</target>
        </trans-unit>
        <trans-unit id="810b76f64a3518b6640d265928755185623d443d" translate="yes" xml:space="preserve">
          <source>besides, wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt;&lt;strong&gt;do not preserve the signature&lt;/strong&gt;, so if bad arguments are provided they will start executing, and might raise a different kind of error than the usual &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">此外，使用 &lt;code&gt;@functools.wraps&lt;/code&gt; 创建的包装器&lt;strong&gt;不会保留签名&lt;/strong&gt; ，因此，如果提供了错误的参数，它们将开始执行，并且可能会引发与通常的 &lt;code&gt;TypeError&lt;/code&gt; 不同的错误。</target>
        </trans-unit>
        <trans-unit id="278b019b92e03f8c6d596bdc96fa24cef85ab67c" translate="yes" xml:space="preserve">
          <source>can be assigned to a variable</source>
          <target state="translated">可以被分配到一个变量</target>
        </trans-unit>
        <trans-unit id="990c222d7e553798fcdfee2e5fa3c3d0fc120879" translate="yes" xml:space="preserve">
          <source>can be defined in another function</source>
          <target state="translated">可在另一个函数中定义</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">扩大到</target>
        </trans-unit>
        <trans-unit id="ccdbc5352040835da410ff1c10cbf69f8c83982f" translate="yes" xml:space="preserve">
          <source>finally, it is quite difficult in wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt; to &lt;strong&gt;access an argument based on its name&lt;/strong&gt;. Indeed the argument can appear in &lt;code&gt;*args&lt;/code&gt;, in &lt;code&gt;**kwargs&lt;/code&gt;, or may not appear at all (if it is optional).</source>
          <target state="translated">最后，在使用 &lt;code&gt;@functools.wraps&lt;/code&gt; 创建的包装器中，很难&lt;strong&gt;根据其名称访问参数&lt;/strong&gt; 。 实际上，该参数可以出现在 &lt;code&gt;*args&lt;/code&gt; ， &lt;code&gt;**kwargs&lt;/code&gt; 或根本不出现（如果它是可选的）。</target>
        </trans-unit>
        <trans-unit id="3329d6139a17df5aa82ad5b8a51d8ca500fc2a29" translate="yes" xml:space="preserve">
          <source>is equivalent to this</source>
          <target state="translated">相当于此</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a351948668a1fcb5487bf5eff7e9fd31790b9eb2" translate="yes" xml:space="preserve">
          <source>or even combine them like this:</source>
          <target state="translated">甚至可以这样组合起来。</target>
        </trans-unit>
        <trans-unit id="4e84bc5fa8cf62a2ac1a2b230a64c8b9a9db925e" translate="yes" xml:space="preserve">
          <source>which would yield:</source>
          <target state="translated">这将导致:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
