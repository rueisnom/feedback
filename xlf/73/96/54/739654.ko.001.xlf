<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/739654">
    <body>
      <group id="739654">
        <trans-unit id="7aa298487facfa7aa89c2a22cdd52ba7dc91da86" translate="yes" xml:space="preserve">
          <source>(Fun fact: &lt;code&gt;functools.wraps()&lt;/code&gt; is a decorator! ☺)</source>
          <target state="translated">(재미있는 사실 : &lt;code&gt;functools.wraps()&lt;/code&gt; 는 데코레이터입니다! ☺)</target>
        </trans-unit>
        <trans-unit id="ec945f8e517954ed7e4692ae6848ed84a9f6930f" translate="yes" xml:space="preserve">
          <source>...which should return:</source>
          <target state="translated">... 반환해야합니다 :</target>
        </trans-unit>
        <trans-unit id="3faa24506c65496ffae93e5003ddfce73c6eba64" translate="yes" xml:space="preserve">
          <source>65 &amp;lt;=&amp;gt; 'a'</source>
          <target state="translated">65 &amp;lt;=&amp;gt; '아'</target>
        </trans-unit>
        <trans-unit id="afe8afb3504b20d32cc84ed5acd9acc2e68234b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino's answer&lt;/a&gt; has the great advantage of only using the stdlib, and works for this simple example where there are no &lt;em&gt;decorator&lt;/em&gt; arguments nor &lt;em&gt;decorated function&lt;/em&gt; arguments.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino의 대답&lt;/a&gt; 은 stdlib 만 사용하면 큰 이점이 있으며 &lt;em&gt;데코레이터&lt;/em&gt; 인수 또는 &lt;em&gt;데코레이션 된 함수&lt;/em&gt; 인수가없는이 간단한 예제에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="39c714204a40cb85b72f9b281dd635e38f398715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decopatch&lt;/code&gt; provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following:</source>
          <target state="translated">&lt;code&gt;decopatch&lt;/code&gt; 는 환경 설정에 따라 다양한 파이썬 개념을 숨기거나 표시하는 두 가지 다른 개발 스타일을 제공합니다. 가장 컴팩트 한 스타일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10817e8cbf2a8f8c871558bcbf7cba4e250496bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the big question:&lt;/strong&gt; What can I use decorators for?</source>
          <target state="translated">&lt;strong&gt;이제 큰 질문 :&lt;/strong&gt; 데코레이터를 무엇에 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0e9207d4303034edd69e7d460d2e0f98665deab8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You cannot un-decorate a function.&lt;/strong&gt; (There &lt;em&gt;are&lt;/em&gt; hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it&amp;rsquo;s decorated &lt;em&gt;for all the code&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;함수를 장식 해제 할 수 없습니다.&lt;/strong&gt; (제거 할 수있는 데코레이터를 만드는 데 필요한 해킹이 있지만 아무도 사용하지 않습니다.) 따라서 함수가 일단 꾸미면 &lt;em&gt;모든 코드에 맞게&lt;/em&gt; 꾸며집니다.</target>
        </trans-unit>
        <trans-unit id="66212ac2a71bc0df84e94d800c5fc4470af8faf2" translate="yes" xml:space="preserve">
          <source>A decorator takes the function definition and creates a new function that executes this function and transforms the result.</source>
          <target state="translated">데코레이터는 함수 정의를 가져 와서이 함수를 실행하고 결과를 변환하는 새 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cd8c02a403c82a2547a2a793d9ef26cd94680682" translate="yes" xml:space="preserve">
          <source>Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:</source>
          <target state="translated">또는 팩토리 함수에 전달 된 태그에 데코 레이팅 된 함수의 반환 값을 래핑하는 데코레이터를 반환하는 팩토리 함수를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2020432815d54b419eb1736a4714dda1093a358" translate="yes" xml:space="preserve">
          <source>An italics decorator could be like</source>
          <target state="translated">이탤릭체 데코레이터는</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">그리고 지금:</target>
        </trans-unit>
        <trans-unit id="fa8ef8ac0a9ff400ae17fa4ce35011055463e50d" translate="yes" xml:space="preserve">
          <source>And of course you can return lambdas as well from a decorator function:</source>
          <target state="translated">물론 데코레이터 함수에서 람다도 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e96a6693d5d4f88633cbc2a33e13e2a0d48f90da" translate="yes" xml:space="preserve">
          <source>Another interesting property of Python functions is they can be defined inside another function!</source>
          <target state="translated">파이썬 함수의 또 다른 흥미로운 속성은 다른 함수 안에 정의 할 수 있다는 것입니다!</target>
        </trans-unit>
        <trans-unit id="c9450f3b037f9bb8f807346211bc2236317782c0" translate="yes" xml:space="preserve">
          <source>Another way of doing the same thing:</source>
          <target state="translated">같은 일을하는 또 다른 방법 :</target>
        </trans-unit>
        <trans-unit id="a0e3876948b2d3ad605eb008566ef83c5b67ca01" translate="yes" xml:space="preserve">
          <source>Anything else we saw recently that wrapped function?</source>
          <target state="translated">최근에 그 래핑 된 기능을 본 적이 있습니까?</target>
        </trans-unit>
        <trans-unit id="950c70e94b9928cfcf9d7106401cb7cb2cef23d4" translate="yes" xml:space="preserve">
          <source>As a conclusion, you can easily see how to answer the question:</source>
          <target state="translated">결론적으로, 질문에 대답하는 방법을 쉽게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="620dffe2846f63bcd6945026a10272cd967f3d58" translate="yes" xml:space="preserve">
          <source>As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a &lt;em&gt;decorator factory&lt;/em&gt;&amp;mdash;in other words, a decorator function that makes other decorators. That way there would be less code repetition&amp;mdash;and allow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; principle to be followed.</source>
          <target state="translated">보시다시피이 두 데코레이터에는 많은 중복 코드가 있습니다. 이러한 유사성을 감안할 때 실제로 &lt;em&gt;데코레이터 팩토리 인&lt;/em&gt; 일반 &lt;em&gt;팩터&lt;/em&gt; , 즉 다른 데코레이터를 만드는 데코레이터 기능을 만드는 것이 좋습니다. 이렇게하면 코드 반복 횟수가 줄어들고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; 원칙을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd19ad545dabf6d1e68777b92e162297c4ad254" translate="yes" xml:space="preserve">
          <source>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use &lt;code&gt;*args, **kwargs&lt;/code&gt; if you wish. But remember decorators are called &lt;strong&gt;only once&lt;/strong&gt;. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do &quot;import x&quot;, &lt;strong&gt;the function is already decorated&lt;/strong&gt;, so you can't
change anything.</source>
          <target state="translated">보시다시피,이 트릭을 사용하는 함수처럼 인수를 데코레이터에 전달할 수 있습니다. 원한다면 &lt;code&gt;*args, **kwargs&lt;/code&gt; 사용할 수도 있습니다. 그러나 데코레이터는 &lt;strong&gt;한 번만&lt;/strong&gt; 호출 &lt;strong&gt;됩니다&lt;/strong&gt; . 파이썬이 스크립트를 가져올 때. 나중에 인수를 동적으로 설정할 수 없습니다. &quot;가져 오기 x&quot;를 수행 &lt;strong&gt;하면 함수가 이미 장식되어&lt;/strong&gt; 있으므로 아무 것도 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ae7d3dab77def1437b4c1c2a696d710ab1e1c5a" translate="yes" xml:space="preserve">
          <source>Before rushing to the solution, let&amp;rsquo;s write a little reminder:</source>
          <target state="translated">솔루션으로 달려 가기 전에 약간의 알림을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="206a50a63dabbf1b2361c766ff1e3bb73ade5429" translate="yes" xml:space="preserve">
          <source>Best practices: decorators</source>
          <target state="translated">모범 사례 : 데코레이터</target>
        </trans-unit>
        <trans-unit id="5c5cf2ca4a0d4c3c42cb3df68a42305fe76df7ba" translate="yes" xml:space="preserve">
          <source>But we seem to have nearly lost the original function.</source>
          <target state="translated">그러나 우리는 원래 기능을 거의 잃어버린 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="dfad1322f6d290e904a701b70d67c393d4fa29c4" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;the documentation&lt;/a&gt; to see how decorators work. Here is what you asked for:</source>
          <target state="translated">데코레이터의 작동 방식을 보려면 &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;설명서&lt;/a&gt; 를 확인하십시오. 요청한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="bd9f92315d53d212a9dc77eec8576e4334c597c0" translate="yes" xml:space="preserve">
          <source>Decorate functions with different number of arguments:</source>
          <target state="translated">다른 수의 인수로 함수를 장식하십시오.</target>
        </trans-unit>
        <trans-unit id="7514a0f4a85fc4cc4fca21d25add9ec96e9cffcb" translate="yes" xml:space="preserve">
          <source>Decorating methods</source>
          <target state="translated">장식 방법</target>
        </trans-unit>
        <trans-unit id="1e4898de5bee34139a3f87dd9b517db79f32b352" translate="yes" xml:space="preserve">
          <source>Decorator Basics</source>
          <target state="translated">데코레이터 기본</target>
        </trans-unit>
        <trans-unit id="aa70f4c0f7a0072ec8a62a6cba4e841875ee10e8" translate="yes" xml:space="preserve">
          <source>Decorators are just a pythonic variant of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;decorator design pattern&lt;/a&gt;. There are several classic design patterns embedded in Python to ease development (like iterators).</source>
          <target state="translated">데코레이터는 단지 &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;데코레이터 디자인 패턴&lt;/a&gt; 의 파이썬 변형입니다. 파이썬과 같은 몇 가지 고전적인 디자인 패턴이 내장되어있어 개발을 쉽게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1960c6c3a393f8280a1557da87c5ae49cc49728f" translate="yes" xml:space="preserve">
          <source>Decorators are just syntactical sugar.</source>
          <target state="translated">데코레이터는 단지 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="e676466dac7ab2332c55066fac838c036e30a5f4" translate="yes" xml:space="preserve">
          <source>Decorators demystified</source>
          <target state="translated">데코레이션 된 데코레이터</target>
        </trans-unit>
        <trans-unit id="baaf86734e7519c8e5b9a287fdd51a09542a7a2f" translate="yes" xml:space="preserve">
          <source>Decorators slow down the function call. Keep that in mind.</source>
          <target state="translated">데코레이터는 함수 호출을 느리게합니다. 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="2b88592aafba3e2bb5d236b6157ec8f8c13f5d66" translate="yes" xml:space="preserve">
          <source>Decorators were introduced in Python 2.4, so be sure your code will be run on &amp;gt;= 2.4.</source>
          <target state="translated">데코레이터는 Python 2.4에서 도입되었으므로 코드가&amp;gt; = 2.4에서 실행되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5068621933ab115670d1f879b688ce5fd62f2f83" translate="yes" xml:space="preserve">
          <source>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &amp;gt;= 2.5; see below.)</source>
          <target state="translated">데코레이터는 함수를 래핑하여 디버그하기가 어려울 수 있습니다. (이것은 Python&amp;gt; = 2.5에서 나아집니다. 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="7ecbff500103805264ec8d27bb1b00270113802a" translate="yes" xml:space="preserve">
          <source>Django uses decorators to manage caching and view permissions.</source>
          <target state="translated">Django는 데코레이터를 사용하여 캐싱을 관리하고 권한을 봅니다.</target>
        </trans-unit>
        <trans-unit id="ccfab1893a822fe4138fc5bf3a6aa54d78163c81" translate="yes" xml:space="preserve">
          <source>Don't forget the construction for which decorator syntax is a shorthand:</source>
          <target state="translated">데코레이터 구문이 속기 인 구성을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="12c4ffe1d987164a4bedf6ab2aac597a113e181c" translate="yes" xml:space="preserve">
          <source>Efficiency</source>
          <target state="translated">Efficiency</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2c8c5c8eff80573c570fa19e7fbdbb5106e81f4d" translate="yes" xml:space="preserve">
          <source>For more on decorators, check
&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&lt;/a&gt;</source>
          <target state="translated">데코레이터에 대한 자세한 내용은 &lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html을&lt;/a&gt; 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="8f4aa69a5271cb03d99c15f1d53bdb53823e15db" translate="yes" xml:space="preserve">
          <source>For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as:</source>
          <target state="translated">하나는 이것이 데코레이터의 동작을 매우 명확하게 만드는 것이라고 생각하지만 새로운 데코레이터를 매우 간결하게 정의하기도 쉽습니다. 위에 나열된 예제의 경우 다음과 같이 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8be5d3c79e4970b1da1e51927bf0b5137e6d815" translate="yes" xml:space="preserve">
          <source>For similar reasons, the &lt;code&gt;functools.wraps&lt;/code&gt; decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (&lt;code&gt;func.__doc__&lt;/code&gt;) be those of the decorated function instead of &lt;code&gt;wrapped()&lt;/code&gt;'s.</source>
          <target state="translated">비슷한 이유로 &lt;code&gt;functools.wraps&lt;/code&gt; 데코레이터는 래핑 된 함수의 메타 속성을 데코레이션되는 메타 속성으로 변경하는 데 사용됩니다. 이것은 에러 메시지와 내장 함수 문서 ( &lt;code&gt;func.__doc__&lt;/code&gt; )를 &lt;code&gt;wrapped()&lt;/code&gt; 대신 데코 레이팅 된 함수의 문서로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="61bbffc7a0ea6d9bf4052e3dc9914af60bc4775f" translate="yes" xml:space="preserve">
          <source>Full featured solution - overcoming most of these problems</source>
          <target state="translated">모든 기능을 갖춘 솔루션-이러한 문제를 대부분 극복</target>
        </trans-unit>
        <trans-unit id="fb7e0637c4d5a6d73f637194c0246e331b6544bf" translate="yes" xml:space="preserve">
          <source>Functions references</source>
          <target state="translated">함수 참조</target>
        </trans-unit>
        <trans-unit id="d9429ca6d1142349d10e10a94576fffa86564438" translate="yes" xml:space="preserve">
          <source>Great, now what would you say about passing arguments to the decorator itself?</source>
          <target state="translated">좋아, 이제 데코레이터 자체에 인수를 전달하는 것에 대해 무엇을 말하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="da0d931207acb9b41e89d340765036903cec4311" translate="yes" xml:space="preserve">
          <source>Handcrafted decorators</source>
          <target state="translated">수제 데코레이터</target>
        </trans-unit>
        <trans-unit id="6c94ddf86de798e414a3de66543416eb33764543" translate="yes" xml:space="preserve">
          <source>Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.</source>
          <target state="translated">다음은 데코레이터 체인의 간단한 예입니다. 마지막 줄에 주목하십시오-표지 아래에서 무슨 일이 일어나고 있는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="879edad30080eeaee9e2cf7411d0c110780e7c60" translate="yes" xml:space="preserve">
          <source>Here it is: a decorator with arguments. Arguments can be set as variable:</source>
          <target state="translated">여기에 인수가있는 데코레이터가 있습니다. 인수는 변수로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="078d424ccacc316d41eb3c9e64c0a049566eda86" translate="yes" xml:space="preserve">
          <source>Hey, did you see that? We used a function call with the &quot;&lt;code&gt;@&lt;/code&gt;&quot; syntax! :-)</source>
          <target state="translated">저기요? &quot; &lt;code&gt;@&lt;/code&gt; &quot;구문으로 함수 호출을 사용했습니다! :-)</target>
        </trans-unit>
        <trans-unit id="a14b8e424350d415cdd48e9f09183de9ffb56f6f" translate="yes" xml:space="preserve">
          <source>How can I make two decorators in Python that would do the following?</source>
          <target state="translated">파이썬에서 다음을 수행하는 데코레이터 두 개를 어떻게 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="12a65f2bbbb67ec061b91830c0f3852f397b8da4" translate="yes" xml:space="preserve">
          <source>How can the decorators be useful?</source>
          <target state="translated">데코레이터는 어떻게 유용합니까?</target>
        </trans-unit>
        <trans-unit id="b5614093ef277f04d2fcf8a8f6d17ab705e42f42" translate="yes" xml:space="preserve">
          <source>How to make a chain of function decorators</source>
          <target state="translated">함수 데코레이터 체인을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="9c80cc9314ab160ba886800aef0563ac91482582" translate="yes" xml:space="preserve">
          <source>How you&amp;rsquo;d do it manually:</source>
          <target state="translated">수동으로 수행하는 방법 :</target>
        </trans-unit>
        <trans-unit id="4a1cc8e375a4ebd9b5ffc2959ee04c7e8d713115" translate="yes" xml:space="preserve">
          <source>However it has 3 major limitations if you want to tackle more general cases:</source>
          <target state="translated">그러나보다 일반적인 경우를 해결하려는 경우 3 가지 주요 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a3cd9a00b172fb82cc5ee4d2ed407fb3a1ac23e" translate="yes" xml:space="preserve">
          <source>I know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don't you feel good about mastering this?</source>
          <target state="translated">마지막으로이 느낌이 들었을 때 &quot;재귀를 이해하기 전에 먼저 재귀를 이해해야합니다&quot;라는 말을들은 후에였습니다. 그러나 지금, 이것을 마스터하는 것에 대해 기분이 좋지 않습니까?</target>
        </trans-unit>
        <trans-unit id="726239257c85d745949f495cf86f83f7f3423958" translate="yes" xml:space="preserve">
          <source>I wrote &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;&lt;code&gt;decopatch&lt;/code&gt;&lt;/a&gt; to solve the first issue, and wrote &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt;&lt;code&gt;makefun.wraps&lt;/code&gt;&lt;/a&gt; to solve the other two. Note that &lt;code&gt;makefun&lt;/code&gt; leverages the same trick than the famous &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt;&lt;code&gt;decorator&lt;/code&gt;&lt;/a&gt; lib.</source>
          <target state="translated">첫 번째 문제를 해결하기 위해 &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt; &lt;code&gt;makefun.wraps&lt;/code&gt; &lt;/a&gt; 를 작성하고 다른 두 문제를 해결하기 위해 makefun.wraps 를 작성 했습니다 . &lt;code&gt;makefun&lt;/code&gt; 은 유명한 &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt; &lt;code&gt;decorator&lt;/code&gt; &lt;/a&gt; 라이브러리와 동일한 트릭을 활용합니다.</target>
        </trans-unit>
        <trans-unit id="5d7696becef5ac38fad435088d0ecb76e8a0289a" translate="yes" xml:space="preserve">
          <source>I'm not trying to make &lt;code&gt;HTML&lt;/code&gt; this way in a real application - just trying to understand how decorators and decorator chaining works.</source>
          <target state="translated">실제 응용 프로그램에서 &lt;code&gt;HTML&lt;/code&gt; 을 이런 식으로 만들지 않고 데코레이터와 데코레이터 체인이 어떻게 작동하는지 이해하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1e0c463512620a7aa52516ce6954607005e44fad" translate="yes" xml:space="preserve">
          <source>If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.</source>
          <target state="translated">데코 레이팅 된 함수의 속도가 중요한 경우, 모든 태그를 한 번에 추가하는 것을 구현하는 약간 다른 데코레이터 팩토리 함수를 작성하여 오버 헤드를 단일 추가 함수 호출로 유지할 수 있으므로 발생하는 추가 함수 호출을 피하는 코드를 생성 할 수 있습니다 각 태그마다 별도의 데코레이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f5eb6d6e3ee8c4703ec52543976257f38262e16" translate="yes" xml:space="preserve">
          <source>If you are not into long explanations, see &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantino&amp;rsquo;s answer&lt;/a&gt;.</source>
          <target state="translated">자세한 설명이 없으면 &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantino의 답변을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="317dfc8d065e9e0684a901257748d3a5167229f3" translate="yes" xml:space="preserve">
          <source>If you can &lt;code&gt;return&lt;/code&gt; a function, you can pass one as a parameter:</source>
          <target state="translated">함수를 &lt;code&gt;return&lt;/code&gt; 할 수 있으면 함수를 매개 변수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e4b22d8da3dfe34b25ed14a816e2633b2c5e3a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re making general-purpose decorator--one you&amp;rsquo;ll apply to any function or method, no matter its arguments--then just use &lt;code&gt;*args, **kwargs&lt;/code&gt;:</source>
          <target state="translated">범용 데코레이터를 만드는 경우 인수에 관계없이 모든 함수 또는 메소드에 적용 할 수 있습니다. &lt;code&gt;*args, **kwargs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bef3f2c6067205cdab221b9850de1b292b160e38" translate="yes" xml:space="preserve">
          <source>In Python 3, you also get &lt;code&gt;__qualname__&lt;/code&gt; and &lt;code&gt;__annotations__&lt;/code&gt; assigned by default.</source>
          <target state="translated">Python 3에서는 기본적으로 &lt;code&gt;__qualname__&lt;/code&gt; 및 &lt;code&gt;__annotations__&lt;/code&gt; 이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f85fcf9dfd9a481037c239b8ac3cb04c0f757dbe" translate="yes" xml:space="preserve">
          <source>In both cases you can check that the decorator works as expected:</source>
          <target state="translated">두 경우 모두 데코레이터가 예상대로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="441b181831532dd1b1468f0beb612ec2adb9a6ac" translate="yes" xml:space="preserve">
          <source>It can be used as follows:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2364cec8db742e16d44a56e4e97742669df4b53" translate="yes" xml:space="preserve">
          <source>It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it.</source>
          <target state="translated">안타깝게도 보일러 플레이트가 아직 남아 있지만, 우리가 만들 수있는만큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d52aaab6a849e68c11a3c5f3892267606e5ba341" translate="yes" xml:space="preserve">
          <source>It looks like the other people have already told you how to solve the problem. I hope this will help you understand what decorators are.</source>
          <target state="translated">다른 사람들이 이미 문제를 해결하는 방법을 알려준 것 같습니다. 이것이 데코레이터가 무엇인지 이해하는 데 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="0a437594f7f26d9de32ed6e32daf8a7144562ec6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s exactly the same. &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot; is called. So when you &lt;code&gt;@my_decorator&lt;/code&gt;, you are telling Python to call the function 'labelled by the variable &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot;'.</source>
          <target state="translated">정확히 동일합니다. &quot; &lt;code&gt;my_decorator&lt;/code&gt; &quot;가 호출됩니다. 따라서 &lt;code&gt;@my_decorator&lt;/code&gt; 를 사용하면 Python에 ' &lt;code&gt;my_decorator&lt;/code&gt; '변수로 레이블이 지정된 함수를 호출하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="7ce0ce68a04f2b66e2e819d56376b33b1a2e7a7e" translate="yes" xml:space="preserve">
          <source>Keep this in mind. We&amp;rsquo;ll circle back to it shortly.</source>
          <target state="translated">이것을 명심하십시오. 우리는 곧 다시 동그라미 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4bceeb87ddeae7d32f5a461e830c4a01e1c2dbb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do EXACTLY the same thing, but skip all the pesky intermediate variables:</source>
          <target state="translated">정확히 같은 작업을 수행하지만 성가신 중간 변수를 모두 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="77a07d0b57a22cf6113918bd191c5b56c27d8347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get evil. ☺</source>
          <target state="translated">사악 해지자 ☺</target>
        </trans-unit>
        <trans-unit id="78be7938d254badacf135b18dc6cc6c451c38c66" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s have some fun and write a decorator for the decorators:</source>
          <target state="translated">재미있게 꾸미고 데코레이터를 위해 데코레이터를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="27294f1ad34ef605ff9afc4e6f4c9ab75aadb8e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make it &lt;em&gt;even shorter&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;더 짧게&lt;/em&gt; 만들어 보자.</target>
        </trans-unit>
        <trans-unit id="cc604b7219e99c7ead3ddb49899ab7f07ac1541b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice: decorating a decorator</source>
          <target state="translated">연습하자 : 데코레이터 꾸미기</target>
        </trans-unit>
        <trans-unit id="ca309b745c2658e0e7c0557696b22a6ed74f2b7c" translate="yes" xml:space="preserve">
          <source>No surprise here.</source>
          <target state="translated">놀랍지 않습니다.</target>
        </trans-unit>
        <trans-unit id="255ef6b7422b7ccfa19a20bfa097944e74cf3b94" translate="yes" xml:space="preserve">
          <source>Note that a function is defined inside a function.
What it basically does is replace a function with the newly defined one. For example, I have this class</source>
          <target state="translated">함수는 함수 내부에 정의되어 있습니다. 기본적으로하는 일은 함수를 새로 정의 된 함수로 바꾸는 것입니다. 예를 들어이 수업이 있습니다</target>
        </trans-unit>
        <trans-unit id="2dc264a51f806548732cb077d81ae6952adc115e" translate="yes" xml:space="preserve">
          <source>Notice that this example didn't include the &lt;code&gt;list&lt;/code&gt; type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list.</source>
          <target state="translated">이 예제는 데코레이터 인스턴스화에 &lt;code&gt;list&lt;/code&gt; 유형을 포함하지 않았으므로 최종 인쇄 명령문에서 메소드는 목록의 요소가 아닌 목록 자체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d0d40184a1e365e8aec68153ce0e6264dbac917" translate="yes" xml:space="preserve">
          <source>Now say, I want both functions to print &quot;---&quot; after and before they are done.
I could add a print &quot;---&quot; before and after each print statement.
But because I don't like repeating myself, I will make a decorator</source>
          <target state="translated">이제 두 기능이 모두 완료되기 전과 후에 &quot;---&quot;를 인쇄하기를 원합니다. 각 인쇄 문의 전후에 인쇄 &quot;---&quot;를 추가 할 수 있습니다. 그러나 나는 반복하는 것을 좋아하지 않기 때문에 데코레이터를 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="6374db670ada8df89b3ba0c8efdc28f893467811" translate="yes" xml:space="preserve">
          <source>Now use them as desired:</source>
          <target state="translated">이제 원하는대로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0cb1ffaf9060bacf69b447f3baaca8c541d46cf1" translate="yes" xml:space="preserve">
          <source>Now, you probably want that every time you call &lt;code&gt;a_stand_alone_function&lt;/code&gt;, &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; is called instead. That&amp;rsquo;s easy, just overwrite &lt;code&gt;a_stand_alone_function&lt;/code&gt; with the function returned by &lt;code&gt;my_shiny_new_decorator&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;a_stand_alone_function&lt;/code&gt; 을 호출 할 때마다 &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; 가 대신 호출 되기를 원할 것입니다. &lt;code&gt;a_stand_alone_function&lt;/code&gt; 에서 반환 한 함수로 a_stand_alone_function 을 덮어 쓰면 됩니다.</target>
        </trans-unit>
        <trans-unit id="40887ec7e652c1bdf57a41f57f0cb24e4ff2822b" translate="yes" xml:space="preserve">
          <source>Now: to answer the question...</source>
          <target state="translated">이제 : 질문에 대답하기 위해 ...</target>
        </trans-unit>
        <trans-unit id="579d575c5ed4bac1f322abf77675f853665ad5bb" translate="yes" xml:space="preserve">
          <source>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:</source>
          <target state="translated">물론 데코레이터의 장점은 다시 작성하지 않고도 거의 모든 항목에서 즉시 사용할 수 있다는 것입니다. 건조, 나는 말했다 :</target>
        </trans-unit>
        <trans-unit id="1be3cbc92c16a773de95bc885b3fc9e99b4a6788" translate="yes" xml:space="preserve">
          <source>Of course, you can accumulate decorators:</source>
          <target state="translated">물론 데코레이터를 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a37b5d402fd2f9d6d6d0b09967c77439df7c5c" translate="yes" xml:space="preserve">
          <source>Oh yes, decorators!</source>
          <target state="translated">예, 데코레이터!</target>
        </trans-unit>
        <trans-unit id="10957fc6e11cfdfbf98f8f5f5c0ad12c66b378d0" translate="yes" xml:space="preserve">
          <source>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.</source>
          <target state="translated">좋아, 보너스로, 데코레이터가 일반적으로 모든 인수를 수락하도록 스 니펫을 제공합니다. 결국 인수를 받아들이 기 위해 다른 함수를 사용하여 데코레이터를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="6bbd3347dd91397e5be987a0a88f7eff1abc0a3e" translate="yes" xml:space="preserve">
          <source>Okay, still here? Now the fun part...</source>
          <target state="translated">그래, 아직도 여기있어? 이제 재미있는 부분은 ...</target>
        </trans-unit>
        <trans-unit id="56949a19e12ea95f6c3843043b9cdd359a9fb0c0" translate="yes" xml:space="preserve">
          <source>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (&lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">파이썬에 대한 좋은 점은 메소드와 함수가 실제로 동일하다는 것입니다. 유일한 차이점은 메소드가 첫 번째 인수가 현재 오브젝트 ( &lt;code&gt;self&lt;/code&gt; )에 대한 참조라고 예상한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e0a663c8d21ccb65a769c61071c5d509abd2783" translate="yes" xml:space="preserve">
          <source>Or, more flexibly:</source>
          <target state="translated">또는 더 유연하게 :</target>
        </trans-unit>
        <trans-unit id="2fb316fd9385ead51b295112e84edb25cd8b95b1" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorated function</source>
          <target state="translated">데코 레이팅 된 함수에 인수 전달</target>
        </trans-unit>
        <trans-unit id="24b163e0afbd75a6ca84ffb958862c256129d2de" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorator</source>
          <target state="translated">데코레이터에게 인수 전달</target>
        </trans-unit>
        <trans-unit id="17d426ae159ee05b9325ff80a8339b7de2e089f6" translate="yes" xml:space="preserve">
          <source>Personally I would have written the decorator somewhat differently:</source>
          <target state="translated">개인적으로 나는 데코레이터를 다소 다르게 작성했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7b7f62e823e6869c5758a9786c02608bd932456" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c10adc093e3b42e5c9bf392b6f6849c6dbd8218e" translate="yes" xml:space="preserve">
          <source>Problems with the simple solution</source>
          <target state="translated">간단한 해결책의 문제</target>
        </trans-unit>
        <trans-unit id="6ed78550e4466481db863ec487bb1bd253cc35d3" translate="yes" xml:space="preserve">
          <source>Python decorators add extra functionality to another function</source>
          <target state="translated">파이썬 데코레이터는 다른 기능에 추가 기능을 추가합니다</target>
        </trans-unit>
        <trans-unit id="d1727d8a5520ad1a9627fdc2eab00abe2b5d6379" translate="yes" xml:space="preserve">
          <source>Python itself provides several decorators: &lt;code&gt;property&lt;/code&gt;, &lt;code&gt;staticmethod&lt;/code&gt;, etc.</source>
          <target state="translated">파이썬 자체는 몇 가지 데코레이터를 제공합니다 : &lt;code&gt;property&lt;/code&gt; , &lt;code&gt;staticmethod&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="284cca9bb8bff3580e1d28d9004c90370ab5fc92" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s functions are objects</source>
          <target state="translated">파이썬의 함수는 객체입니다</target>
        </trans-unit>
        <trans-unit id="0fb5d72701f71daeb5de4c55b12b5b28333babb4" translate="yes" xml:space="preserve">
          <source>Refinements</source>
          <target state="translated">Refinements</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="447529f8d79e74c1015331f703c4fd58c0024d0f" translate="yes" xml:space="preserve">
          <source>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it&amp;rsquo;s temporary).</source>
          <target state="translated">시원하고 강력 해 보이지만 실제 사례는 훌륭합니다. 음, 1000 가지 가능성이 있습니다. 고전적인 용도는 외부 lib에서 함수 동작을 확장하거나 (수정할 수 없음) 디버깅을 위해 (임시이므로 수정하고 싶지 않음) 것입니다.</target>
        </trans-unit>
        <trans-unit id="8190083ab834e9da2d9dcad17a07753d67081489" translate="yes" xml:space="preserve">
          <source>Simple solution</source>
          <target state="translated">간단한 솔루션</target>
        </trans-unit>
        <trans-unit id="379eadfed2be4f0025e4f13911405915d77b0d61" translate="yes" xml:space="preserve">
          <source>So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.</source>
          <target state="translated">따라서이 함수에 대한 문서를 작성하거나 하나 이상의 인수를 취하는 함수를 꾸미고 싶거나 디버깅 세션에서 어떤 함수를보고 있는지 알고 싶을 때는 싸개.</target>
        </trans-unit>
        <trans-unit id="1c60607379772605752445769cae451aa46faaba" translate="yes" xml:space="preserve">
          <source>So now I can change my class to</source>
          <target state="translated">이제 수업을 다음으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbe6521ca09a7746011901561de604aa6c89d3c" translate="yes" xml:space="preserve">
          <source>So now:</source>
          <target state="translated">그래서 지금:</target>
        </trans-unit>
        <trans-unit id="efb7b2d9e9ca503721dfb04f5dc4469198ba42fa" translate="yes" xml:space="preserve">
          <source>So we see that &lt;code&gt;wraps&lt;/code&gt; makes the wrapping function do almost everything except tell us exactly what the function takes as arguments.</source>
          <target state="translated">따라서 &lt;code&gt;wraps&lt;/code&gt; 은 랩핑 함수가 랩핑 함수가 인수로 취하는 것을 정확히 알려주는 것을 제외하고는 거의 모든 것을 수행한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50cf77367001a751c11f1a93c8af87bfa1080df0" translate="yes" xml:space="preserve">
          <source>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?</source>
          <target state="translated">그래서 논쟁이있는 데코레이터로 돌아갑니다. 함수를 사용하여 데코레이터를 즉석에서 생성 할 수 있다면 해당 함수에 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb9c55c987610f1d50dddd4525d5c7adbdde9f8" translate="yes" xml:space="preserve">
          <source>Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:</source>
          <target state="translated">카운터 예를 말하면-위에서 주어진 것처럼 카운터는 데코레이터를 사용하는 모든 기능간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="96b98ca4ad50b3f8c62ee69fd0d15c5c564ba92c" translate="yes" xml:space="preserve">
          <source>Taking decorators to the next level</source>
          <target state="translated">데코레이터를 한 단계 끌어 올리기</target>
        </trans-unit>
        <trans-unit id="437612b73a9a61ff531195df2dfd1a552e3cd790" translate="yes" xml:space="preserve">
          <source>That means that &lt;strong&gt;a function can &lt;code&gt;return&lt;/code&gt; another function&lt;/strong&gt;.</source>
          <target state="translated">이는 &lt;strong&gt;함수가 다른 함수를 &lt;code&gt;return&lt;/code&gt; 할 수&lt;/strong&gt; 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f298bfca0f195e40010a96673a464012e8d44e65" translate="yes" xml:space="preserve">
          <source>That means you can build a decorator for methods the same way! Just remember to take &lt;code&gt;self&lt;/code&gt; into consideration:</source>
          <target state="translated">즉, 같은 방법으로 데코레이터를 만들 수 있습니다! &lt;code&gt;self&lt;/code&gt; 을 고려하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="050b7db66c47db53ba8a596842a9b2aa1e330633" translate="yes" xml:space="preserve">
          <source>That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt;), and the counter variable will remain private to each.</source>
          <target state="translated">이렇게하면 데코레이터를 다른 함수에 재사용하거나 (같은 함수를 여러 번 꾸미는 데 사용할 수 있습니다 : &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt; ) 카운터 변수는 각각 개인용으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5564267bef96d8c06f321659900ce4a65f09fbb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functools&lt;/code&gt; module was introduced in Python 2.5. It includes the function &lt;code&gt;functools.wraps()&lt;/code&gt;, which copies the name, module, and docstring of the decorated function to its wrapper.</source>
          <target state="translated">&lt;code&gt;functools&lt;/code&gt; 모듈은 Python 2.5에서 도입되었습니다. &lt;code&gt;functools.wraps()&lt;/code&gt; 함수가 포함되어 있습니다.이 함수는 데코 레이팅 된 함수의 이름, 모듈 및 docstring을 랩퍼에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="b96153d0cd80112477376110b277ba00b0b61985" translate="yes" xml:space="preserve">
          <source>The order you set the decorators MATTERS:</source>
          <target state="translated">데코레이터 설정 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee3ecad5bd632505c874495ef908b5ccadff853d" translate="yes" xml:space="preserve">
          <source>The output looks like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c333dc4fec82663d8c79348d8fc54c67a7a233bc" translate="yes" xml:space="preserve">
          <source>The previous example, using the decorator syntax:</source>
          <target state="translated">데코레이터 구문을 사용하는 이전 예제 :</target>
        </trans-unit>
        <trans-unit id="960b2fe36e68117facc37e06febe129a38132041" translate="yes" xml:space="preserve">
          <source>There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.</source>
          <target state="translated">문제를 해결하려고 시도 할 수있는 다른 모듈이 있지만 솔루션은 아직 표준 라이브러리에 없습니다.</target>
        </trans-unit>
        <trans-unit id="af9cac89e15b8a4e52d28cb0c6dc344f017cf8ab" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s more!</source>
          <target state="translated">더있다!</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b5039e57d9fc37a75f36b953d9898eff7500a6b9" translate="yes" xml:space="preserve">
          <source>This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact.</source>
          <target state="translated">이 답변은 오랫동안 답변을 받았지만 새 데코레이터를 쉽고 컴팩트하게 작성하는 데코레이터 클래스를 공유한다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="2904fc69aef6f7ec13cb9a23a39932c544deb84c" translate="yes" xml:space="preserve">
          <source>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function&amp;rsquo;s arguments directly to the decorator.</source>
          <target state="translated">데코레이터는 함수를 인수로 받아 들여야하기 때문에 다소 왜곡 될 수 있습니다. 따라서 데코 레이팅 된 함수의 인수를 데코레이터에 직접 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2c775a862081edfd042f2470df626fc3eef6aa4" translate="yes" xml:space="preserve">
          <source>This enables you to write:</source>
          <target state="translated">이를 통해 다음을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b1c1e381424a38b2424282c1fa352f40d278095" translate="yes" xml:space="preserve">
          <source>This is how you would create a decorator with arguments, returning truly signature-preserving wrappers:</source>
          <target state="translated">다음은 인수를 사용하여 데코레이터를 작성하여 서명 보존 래퍼를 반환하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ce42d5743ee1866f5dc731830ebf5ed5afa194eb" translate="yes" xml:space="preserve">
          <source>This is important! The label you give can point directly to the decorator&amp;mdash;&lt;strong&gt;or not&lt;/strong&gt;.</source>
          <target state="translated">이것은 중요합니다! 제공하는 라벨은 데코레이터를 직접 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5027fb5d3093f380441a1296b10193eb568104dd" translate="yes" xml:space="preserve">
          <source>This really is a large playground.</source>
          <target state="translated">이것은 정말로 큰 놀이터입니다.</target>
        </trans-unit>
        <trans-unit id="1fd557f5cb363c1aff4438192da3019b9a577767" translate="yes" xml:space="preserve">
          <source>This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using &lt;code&gt;lambda&lt;/code&gt; functions as previously illustrated. Sample:</source>
          <target state="translated">데코레이터 자체에는 더 많은 코드가 필요하지만 나중에 함수 호출에 적용되지 않고 함수 정의에 적용될 때만 실행됩니다. 이것은 앞에서 설명한 것처럼 &lt;code&gt;lambda&lt;/code&gt; 함수를 사용하여 더 읽기 쉬운 이름을 만들 때도 적용됩니다. 견본:</target>
        </trans-unit>
        <trans-unit id="a8eaf579c4f258b33b0482ef3b7df54778820469" translate="yes" xml:space="preserve">
          <source>To explain the decorator in a simple way:</source>
          <target state="translated">간단한 방법으로 데코레이터를 설명하려면 :</target>
        </trans-unit>
        <trans-unit id="473f07947e0fd95c8d023c615f35b4d07297397e" translate="yes" xml:space="preserve">
          <source>To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other:</source>
          <target state="translated">그것을 찾으려면 우리는 각 람다의 클로저를 파헤쳐 야합니다. 하나는 다른 람다에 묻혀 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05d323aa64f59be265e5a87806a41e0c825210f" translate="yes" xml:space="preserve">
          <source>To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:</source>
          <target state="translated">코드를 더 읽기 쉽게하기 위해 팩토리에서 생성 한 데코레이터에 더 설명적인 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="883de3fa331a806ddd7c7652ca1e49092c7971b4" translate="yes" xml:space="preserve">
          <source>To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:</source>
          <target state="translated">가장 간단하게 수행하려면 함수 (클로저)를 닫는 람다 (익명 함수)를 반환하는 데코레이터를 만들고 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="62f4218b8c6ef484c2f1975f99215aea59a557d9" translate="yes" xml:space="preserve">
          <source>To return:</source>
          <target state="translated">돌려 주다:</target>
        </trans-unit>
        <trans-unit id="bd12f2d27cd71bb3463350185fcfc9d61abd15f6" translate="yes" xml:space="preserve">
          <source>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let&amp;rsquo;s see why with a simple example :</source>
          <target state="translated">데코레이터를 이해하려면 먼저 함수가 Python의 객체라는 것을 이해해야합니다. 이것은 중요한 결과를 초래합니다. 간단한 예제를 통해 이유를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="196f074c1d92f9ced554dc60521c54d33c9ca742" translate="yes" xml:space="preserve">
          <source>To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result.</source>
          <target state="translated">데코레이터를 이해하려면 데코레이터가 함수를 실행하고 결과를 변환하는 내부의 새로운 함수를 작성했음을 주목해야합니다.</target>
        </trans-unit>
        <trans-unit id="60902dc77861b8c1fdfaf6268a2464fa22de1ceb" translate="yes" xml:space="preserve">
          <source>Twisted to fake inlining asynchronous functions calls.</source>
          <target state="translated">인라인 비동기 함수 호출을 위조하도록 트위스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="c77a8f9b1468c11516a914ac6de3a49735219779" translate="yes" xml:space="preserve">
          <source>Using the Python decorator syntax:</source>
          <target state="translated">파이썬 데코레이터 구문 사용하기 :</target>
        </trans-unit>
        <trans-unit id="aa9cefd3355dfbb169969e4d070840477e8f3574" translate="yes" xml:space="preserve">
          <source>We have the decorator &lt;code&gt;wraps&lt;/code&gt; from the &lt;code&gt;functools&lt;/code&gt; module in the standard library!</source>
          <target state="translated">표준 라이브러리의 &lt;code&gt;functools&lt;/code&gt; 모듈에서 데코레이터 &lt;code&gt;wraps&lt;/code&gt; 이 있습니다!</target>
        </trans-unit>
        <trans-unit id="e7828a39d26d60430dd896cb93790f6a849e80c7" translate="yes" xml:space="preserve">
          <source>We wrapped the decorator.</source>
          <target state="translated">우리는 데코레이터를 감쌌습니다.</target>
        </trans-unit>
        <trans-unit id="fe01beda96c243b61696dcac93827863db70a633" translate="yes" xml:space="preserve">
          <source>Well, you just have everything needed to understand decorators. You see, decorators are &amp;ldquo;wrappers&amp;rdquo;, which means that &lt;strong&gt;they let you execute code before and after the function they decorate&lt;/strong&gt; without modifying the function itself.</source>
          <target state="translated">글쎄, 데코레이터를 이해하는 데 필요한 모든 것이 있습니다. 알다시피 데코레이터는 &quot;래퍼&quot;입니다. 즉, 함수 자체를 수정하지 않고 &lt;strong&gt;코드를 장식하기 전과 후에 코드를 실행할 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e60ee3faedca029b522b5766bd4fef43e46646de" translate="yes" xml:space="preserve">
          <source>When do:</source>
          <target state="translated">언제 :</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">어떤 지문 :</target>
        </trans-unit>
        <trans-unit id="0f59d388d686c4bb98639de68bb575c3f2e8c1b3" translate="yes" xml:space="preserve">
          <source>While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).</source>
          <target state="translated">위의 예제는 모든 작업을 수행하지만 생성 된 코드에는 여러 데코레이터를 한 번에 적용 할 때 외부 함수 호출 형식으로 상당한 양의 오버 헤드가 발생합니다. 정확한 사용법 (예 : I / O 바운드)에 따라 중요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="80931ea7fb9f9baaccc7db7989d6b55cd34a1502" translate="yes" xml:space="preserve">
          <source>Yes, that&amp;rsquo;s all, it&amp;rsquo;s that simple. &lt;code&gt;@decorator&lt;/code&gt; is just a shortcut to:</source>
          <target state="translated">네, 그게 다야, 간단합니다. &lt;code&gt;@decorator&lt;/code&gt; 는 다음에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="82aa4bf8798112112023c3bf62cf028a41534be3" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; make two separate decorators that do what you want as illustrated directly below. Note the use of &lt;code&gt;*args, **kwargs&lt;/code&gt; in the declaration of the &lt;code&gt;wrapped()&lt;/code&gt; function which supports the decorated function having multiple arguments (which isn't really necessary for the example &lt;code&gt;say()&lt;/code&gt; function, but is included for generality).</source>
          <target state="translated">아래 그림과 같이 원하는 것을 수행하는 두 개의 별도 데코레이터를 만들 &lt;em&gt;수&lt;/em&gt; 있습니다. 여러 인수를 갖는 데코 레이팅 된 함수를 지원하는 &lt;code&gt;wrapped()&lt;/code&gt; 함수 선언에서 &lt;code&gt;*args, **kwargs&lt;/code&gt; 의 사용에 주목하십시오 ( 예제 &lt;code&gt;say()&lt;/code&gt; 함수에는 실제로 필요하지는 않지만 일반적으로 포함됨).</target>
        </trans-unit>
        <trans-unit id="3fcf6e6cdbd43a4541ee6fee7299941830fb61da" translate="yes" xml:space="preserve">
          <source>You can also write decorator in Class</source>
          <target state="translated">클래스에서 데코레이터를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a9ddf317ada0cb0975c84b1b3a3350e91427a6" translate="yes" xml:space="preserve">
          <source>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.</source>
          <target state="translated">이제 그냥 행복하게 놔두거나 뇌를 조금 더 태우고 장식 자의 고급 사용법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c0158657b192fc0e1e92b4b42743e823b5581b" translate="yes" xml:space="preserve">
          <source>You can use them to extend several functions in a DRY&amp;rsquo;s way, like so:</source>
          <target state="translated">이를 사용하여 다음과 같이 DRY 방식으로 여러 기능을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb12aebb78c3f68a3b62316d71c4c613fca73470" translate="yes" xml:space="preserve">
          <source>You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator:</source>
          <target state="translated">예를 들어 함수를 반복자의 모든 인수에 재귀 적으로 적용하는 데코레이터와 같이 더 복잡한 작업을 수행하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ecc0fab1db96d14074c26f8bc8f79f84ec79ac0" translate="yes" xml:space="preserve">
          <source>You really do:</source>
          <target state="translated">당신은 정말로 :</target>
        </trans-unit>
        <trans-unit id="e81544690dadca1e7c105c62bc3929aebc31d34d" translate="yes" xml:space="preserve">
          <source>You want the following function, when called:</source>
          <target state="translated">호출 될 때 다음 기능을 원합니다.</target>
        </trans-unit>
        <trans-unit id="953873baa875246b6189da13ed630a79eb5fb0e9" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve seen that functions are objects. Therefore, functions:</source>
          <target state="translated">함수가 객체라는 것을 보았습니다. 따라서 기능 :</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">그리고 지금:</target>
        </trans-unit>
        <trans-unit id="cafef07857121c9781de270f85e3951e33ef3a0f" translate="yes" xml:space="preserve">
          <source>as already noted in several answers, you can not easily modify the code to &lt;strong&gt;add optional decorator arguments&lt;/strong&gt;. For example creating a &lt;code&gt;makestyle(style='bold')&lt;/code&gt; decorator is non-trivial.</source>
          <target state="translated">여러 답변에서 이미 언급했듯이 &lt;strong&gt;선택적 데코레이터 인수&lt;/strong&gt; 를 &lt;strong&gt;추가&lt;/strong&gt; 하기 위해 코드를 쉽게 수정할 수 없습니다. 예를 들어 &lt;code&gt;makestyle(style='bold')&lt;/code&gt; 데코레이터를 만드는 것은 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="810b76f64a3518b6640d265928755185623d443d" translate="yes" xml:space="preserve">
          <source>besides, wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt;&lt;strong&gt;do not preserve the signature&lt;/strong&gt;, so if bad arguments are provided they will start executing, and might raise a different kind of error than the usual &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">게다가 &lt;code&gt;@functools.wraps&lt;/code&gt; 생성 된 래퍼 &lt;strong&gt;는 서명을 보존하지 않으므로&lt;/strong&gt; 잘못된 인수가 제공되면 실행이 시작되고 일반적인 &lt;code&gt;TypeError&lt;/code&gt; 와 다른 종류의 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278b019b92e03f8c6d596bdc96fa24cef85ab67c" translate="yes" xml:space="preserve">
          <source>can be assigned to a variable</source>
          <target state="translated">변수에 할당 가능</target>
        </trans-unit>
        <trans-unit id="990c222d7e553798fcdfee2e5fa3c3d0fc120879" translate="yes" xml:space="preserve">
          <source>can be defined in another function</source>
          <target state="translated">다른 기능으로 정의 가능</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">~로 확장</target>
        </trans-unit>
        <trans-unit id="ccdbc5352040835da410ff1c10cbf69f8c83982f" translate="yes" xml:space="preserve">
          <source>finally, it is quite difficult in wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt; to &lt;strong&gt;access an argument based on its name&lt;/strong&gt;. Indeed the argument can appear in &lt;code&gt;*args&lt;/code&gt;, in &lt;code&gt;**kwargs&lt;/code&gt;, or may not appear at all (if it is optional).</source>
          <target state="translated">마지막으로 &lt;code&gt;@functools.wraps&lt;/code&gt; 로 생성 된 래퍼 &lt;strong&gt;에서는 이름을 기반으로하는 인수&lt;/strong&gt; 에 &lt;strong&gt;액세스&lt;/strong&gt; 하기가 매우 어렵습니다. 실제로 인수는 &lt;code&gt;*args&lt;/code&gt; , &lt;code&gt;**kwargs&lt;/code&gt; 에 표시되거나 전혀 표시되지 않을 수 있습니다 (선택적 경우).</target>
        </trans-unit>
        <trans-unit id="3329d6139a17df5aa82ad5b8a51d8ca500fc2a29" translate="yes" xml:space="preserve">
          <source>is equivalent to this</source>
          <target state="translated">이것과 같습니다</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a351948668a1fcb5487bf5eff7e9fd31790b9eb2" translate="yes" xml:space="preserve">
          <source>or even combine them like this:</source>
          <target state="translated">또는 다음과 같이 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="4e84bc5fa8cf62a2ac1a2b230a64c8b9a9db925e" translate="yes" xml:space="preserve">
          <source>which would yield:</source>
          <target state="translated">다음과 같은 결과가 나옵니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
