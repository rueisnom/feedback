<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/739654">
    <body>
      <group id="739654">
        <trans-unit id="7aa298487facfa7aa89c2a22cdd52ba7dc91da86" translate="yes" xml:space="preserve">
          <source>(Fun fact: &lt;code&gt;functools.wraps()&lt;/code&gt; is a decorator! ☺)</source>
          <target state="translated">(Dato &lt;code&gt;functools.wraps()&lt;/code&gt; : functools.wraps () es un decorador! ☺)</target>
        </trans-unit>
        <trans-unit id="ec945f8e517954ed7e4692ae6848ed84a9f6930f" translate="yes" xml:space="preserve">
          <source>...which should return:</source>
          <target state="translated">...que debería regresar:</target>
        </trans-unit>
        <trans-unit id="3faa24506c65496ffae93e5003ddfce73c6eba64" translate="yes" xml:space="preserve">
          <source>65 &amp;lt;=&amp;gt; 'a'</source>
          <target state="translated">65 &amp;lt;=&amp;gt; 'a'</target>
        </trans-unit>
        <trans-unit id="afe8afb3504b20d32cc84ed5acd9acc2e68234b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino's answer&lt;/a&gt; has the great advantage of only using the stdlib, and works for this simple example where there are no &lt;em&gt;decorator&lt;/em&gt; arguments nor &lt;em&gt;decorated function&lt;/em&gt; arguments.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;La respuesta de Paolo Bergantino&lt;/a&gt; tiene la gran ventaja de solo usar stdlib, y funciona para este ejemplo simple donde no hay argumentos &lt;em&gt;decoradores&lt;/em&gt; ni argumentos de &lt;em&gt;funciones decoradas&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="39c714204a40cb85b72f9b281dd635e38f398715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decopatch&lt;/code&gt; provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following:</source>
          <target state="translated">&lt;code&gt;decopatch&lt;/code&gt; le proporciona otros dos estilos de desarrollo que ocultan o muestran los diversos conceptos de python, seg&amp;uacute;n sus preferencias. El estilo m&amp;aacute;s compacto es el siguiente:</target>
        </trans-unit>
        <trans-unit id="10817e8cbf2a8f8c871558bcbf7cba4e250496bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the big question:&lt;/strong&gt; What can I use decorators for?</source>
          <target state="translated">&lt;strong&gt;Ahora la gran pregunta:&lt;/strong&gt; &amp;iquest;para qu&amp;eacute; puedo usar decoradores?</target>
        </trans-unit>
        <trans-unit id="0e9207d4303034edd69e7d460d2e0f98665deab8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You cannot un-decorate a function.&lt;/strong&gt; (There &lt;em&gt;are&lt;/em&gt; hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it&amp;rsquo;s decorated &lt;em&gt;for all the code&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;No puede des-decorar una funci&amp;oacute;n.&lt;/strong&gt; (Hay trucos para crear decoradores que se pueden quitar, pero nadie los usa). Entonces, una vez que se decora una funci&amp;oacute;n, se decora &lt;em&gt;para todo el c&amp;oacute;digo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66212ac2a71bc0df84e94d800c5fc4470af8faf2" translate="yes" xml:space="preserve">
          <source>A decorator takes the function definition and creates a new function that executes this function and transforms the result.</source>
          <target state="translated">Un decorador toma la definición de la función y crea una nueva función que ejecuta esta función y transforma el resultado.</target>
        </trans-unit>
        <trans-unit id="cd8c02a403c82a2547a2a793d9ef26cd94680682" translate="yes" xml:space="preserve">
          <source>Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:</source>
          <target state="translated">Alternativamente,podría escribir una función de fábrica que devuelva un decorador que envuelva el valor de retorno de la función decorada en una etiqueta pasada a la función de fábrica.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e2020432815d54b419eb1736a4714dda1093a358" translate="yes" xml:space="preserve">
          <source>An italics decorator could be like</source>
          <target state="translated">Un decorador en cursiva podría ser como</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">Y ahora:</target>
        </trans-unit>
        <trans-unit id="fa8ef8ac0a9ff400ae17fa4ce35011055463e50d" translate="yes" xml:space="preserve">
          <source>And of course you can return lambdas as well from a decorator function:</source>
          <target state="translated">Y,por supuesto,también puedes devolver las lambdas de una función de decorador:</target>
        </trans-unit>
        <trans-unit id="e96a6693d5d4f88633cbc2a33e13e2a0d48f90da" translate="yes" xml:space="preserve">
          <source>Another interesting property of Python functions is they can be defined inside another function!</source>
          <target state="translated">Otra propiedad interesante de las funciones de Python es que pueden ser definidas dentro de otra función!</target>
        </trans-unit>
        <trans-unit id="c9450f3b037f9bb8f807346211bc2236317782c0" translate="yes" xml:space="preserve">
          <source>Another way of doing the same thing:</source>
          <target state="translated">Otra forma de hacer lo mismo:</target>
        </trans-unit>
        <trans-unit id="a0e3876948b2d3ad605eb008566ef83c5b67ca01" translate="yes" xml:space="preserve">
          <source>Anything else we saw recently that wrapped function?</source>
          <target state="translated">¿Algo más que hayamos visto recientemente en esa función de envoltura?</target>
        </trans-unit>
        <trans-unit id="950c70e94b9928cfcf9d7106401cb7cb2cef23d4" translate="yes" xml:space="preserve">
          <source>As a conclusion, you can easily see how to answer the question:</source>
          <target state="translated">Como conclusión,se puede ver fácilmente cómo responder a la pregunta:</target>
        </trans-unit>
        <trans-unit id="620dffe2846f63bcd6945026a10272cd967f3d58" translate="yes" xml:space="preserve">
          <source>As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a &lt;em&gt;decorator factory&lt;/em&gt;&amp;mdash;in other words, a decorator function that makes other decorators. That way there would be less code repetition&amp;mdash;and allow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; principle to be followed.</source>
          <target state="translated">Como puede ver, hay muchos c&amp;oacute;digos duplicados en estos dos decoradores. Dada esta similitud, ser&amp;iacute;a mejor para usted hacer una gen&amp;eacute;rica que fuera en realidad una &lt;em&gt;f&amp;aacute;brica de decoradores,&lt;/em&gt; en otras palabras, una funci&amp;oacute;n de decorador que crea otros decoradores. De esa manera, habr&amp;iacute;a menos repetici&amp;oacute;n de c&amp;oacute;digo y permitir&amp;iacute;a seguir el principio &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abd19ad545dabf6d1e68777b92e162297c4ad254" translate="yes" xml:space="preserve">
          <source>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use &lt;code&gt;*args, **kwargs&lt;/code&gt; if you wish. But remember decorators are called &lt;strong&gt;only once&lt;/strong&gt;. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do &quot;import x&quot;, &lt;strong&gt;the function is already decorated&lt;/strong&gt;, so you can't
change anything.</source>
          <target state="translated">Como puede ver, puede pasar argumentos al decorador como cualquier funci&amp;oacute;n usando este truco. Incluso puede usar &lt;code&gt;*args, **kwargs&lt;/code&gt; si lo desea. Pero recuerde que los decoradores &lt;strong&gt;solo&lt;/strong&gt; se llaman &lt;strong&gt;una vez&lt;/strong&gt; . Justo cuando Python importa el script. No puede establecer din&amp;aacute;micamente los argumentos despu&amp;eacute;s. Cuando &quot;importa x&quot;, &lt;strong&gt;la funci&amp;oacute;n ya est&amp;aacute; decorada&lt;/strong&gt; , por lo que no puede cambiar nada.</target>
        </trans-unit>
        <trans-unit id="2ae7d3dab77def1437b4c1c2a696d710ab1e1c5a" translate="yes" xml:space="preserve">
          <source>Before rushing to the solution, let&amp;rsquo;s write a little reminder:</source>
          <target state="translated">Antes de apresurarnos a la soluci&amp;oacute;n, escribamos un peque&amp;ntilde;o recordatorio:</target>
        </trans-unit>
        <trans-unit id="206a50a63dabbf1b2361c766ff1e3bb73ade5429" translate="yes" xml:space="preserve">
          <source>Best practices: decorators</source>
          <target state="translated">Mejores prácticas:decoradores</target>
        </trans-unit>
        <trans-unit id="5c5cf2ca4a0d4c3c42cb3df68a42305fe76df7ba" translate="yes" xml:space="preserve">
          <source>But we seem to have nearly lost the original function.</source>
          <target state="translated">Pero parece que casi hemos perdido la función original.</target>
        </trans-unit>
        <trans-unit id="dfad1322f6d290e904a701b70d67c393d4fa29c4" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;the documentation&lt;/a&gt; to see how decorators work. Here is what you asked for:</source>
          <target state="translated">Consulte &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;la documentaci&amp;oacute;n&lt;/a&gt; para ver c&amp;oacute;mo funcionan los decoradores. Esto es lo que pediste:</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="bd9f92315d53d212a9dc77eec8576e4334c597c0" translate="yes" xml:space="preserve">
          <source>Decorate functions with different number of arguments:</source>
          <target state="translated">Decorar las funciones con un número diferente de argumentos:</target>
        </trans-unit>
        <trans-unit id="7514a0f4a85fc4cc4fca21d25add9ec96e9cffcb" translate="yes" xml:space="preserve">
          <source>Decorating methods</source>
          <target state="translated">Métodos de decoración</target>
        </trans-unit>
        <trans-unit id="1e4898de5bee34139a3f87dd9b517db79f32b352" translate="yes" xml:space="preserve">
          <source>Decorator Basics</source>
          <target state="translated">Conceptos básicos de decoración</target>
        </trans-unit>
        <trans-unit id="aa70f4c0f7a0072ec8a62a6cba4e841875ee10e8" translate="yes" xml:space="preserve">
          <source>Decorators are just a pythonic variant of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;decorator design pattern&lt;/a&gt;. There are several classic design patterns embedded in Python to ease development (like iterators).</source>
          <target state="translated">Los decoradores son solo una variante pit&amp;oacute;nica del &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;patr&amp;oacute;n de dise&amp;ntilde;o&lt;/a&gt; del decorador . Hay varios patrones de dise&amp;ntilde;o cl&amp;aacute;sicos integrados en Python para facilitar el desarrollo (como iteradores).</target>
        </trans-unit>
        <trans-unit id="1960c6c3a393f8280a1557da87c5ae49cc49728f" translate="yes" xml:space="preserve">
          <source>Decorators are just syntactical sugar.</source>
          <target state="translated">Los decoradores son sólo azúcar sintáctico.</target>
        </trans-unit>
        <trans-unit id="e676466dac7ab2332c55066fac838c036e30a5f4" translate="yes" xml:space="preserve">
          <source>Decorators demystified</source>
          <target state="translated">Decoradores desmitificados</target>
        </trans-unit>
        <trans-unit id="baaf86734e7519c8e5b9a287fdd51a09542a7a2f" translate="yes" xml:space="preserve">
          <source>Decorators slow down the function call. Keep that in mind.</source>
          <target state="translated">Los decoradores ralentizan la llamada de la función.Tengan eso en cuenta.</target>
        </trans-unit>
        <trans-unit id="2b88592aafba3e2bb5d236b6157ec8f8c13f5d66" translate="yes" xml:space="preserve">
          <source>Decorators were introduced in Python 2.4, so be sure your code will be run on &amp;gt;= 2.4.</source>
          <target state="translated">Los decoradores se introdujeron en Python 2.4, as&amp;iacute; que aseg&amp;uacute;rese de que su c&amp;oacute;digo se ejecutar&amp;aacute; en&amp;gt; = 2.4.</target>
        </trans-unit>
        <trans-unit id="5068621933ab115670d1f879b688ce5fd62f2f83" translate="yes" xml:space="preserve">
          <source>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &amp;gt;= 2.5; see below.)</source>
          <target state="translated">Los decoradores envuelven funciones, lo que puede dificultar la depuraci&amp;oacute;n. (Esto mejora con Python&amp;gt; = 2.5; ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="7ecbff500103805264ec8d27bb1b00270113802a" translate="yes" xml:space="preserve">
          <source>Django uses decorators to manage caching and view permissions.</source>
          <target state="translated">Django utiliza decoradores para gestionar el caché y ver los permisos.</target>
        </trans-unit>
        <trans-unit id="ccfab1893a822fe4138fc5bf3a6aa54d78163c81" translate="yes" xml:space="preserve">
          <source>Don't forget the construction for which decorator syntax is a shorthand:</source>
          <target state="translated">No olvides la construcción para la cual la sintaxis del decorador es una taquigrafía:</target>
        </trans-unit>
        <trans-unit id="12c4ffe1d987164a4bedf6ab2aac597a113e181c" translate="yes" xml:space="preserve">
          <source>Efficiency</source>
          <target state="translated">Efficiency</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2c8c5c8eff80573c570fa19e7fbdbb5106e81f4d" translate="yes" xml:space="preserve">
          <source>For more on decorators, check
&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&lt;/a&gt;</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre decoradores, consulte &lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f4aa69a5271cb03d99c15f1d53bdb53823e15db" translate="yes" xml:space="preserve">
          <source>For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as:</source>
          <target state="translated">Creo que esto hace que el comportamiento de los decoradores sea muy claro,pero también facilita la definición de los nuevos decoradores de forma muy concisa.Para el ejemplo mencionado anteriormente,podrías entonces resolverlo como:</target>
        </trans-unit>
        <trans-unit id="b8be5d3c79e4970b1da1e51927bf0b5137e6d815" translate="yes" xml:space="preserve">
          <source>For similar reasons, the &lt;code&gt;functools.wraps&lt;/code&gt; decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (&lt;code&gt;func.__doc__&lt;/code&gt;) be those of the decorated function instead of &lt;code&gt;wrapped()&lt;/code&gt;'s.</source>
          <target state="translated">Por razones similares, el decorador &lt;code&gt;functools.wraps&lt;/code&gt; se usa para cambiar los meta atributos de la funci&amp;oacute;n envuelta para que sean los del decorado. Esto hace que los mensajes de error y la documentaci&amp;oacute;n de la funci&amp;oacute;n incrustada ( &lt;code&gt;func.__doc__&lt;/code&gt; ) sean los de la funci&amp;oacute;n decorada en lugar de &lt;code&gt;wrapped()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61bbffc7a0ea6d9bf4052e3dc9914af60bc4775f" translate="yes" xml:space="preserve">
          <source>Full featured solution - overcoming most of these problems</source>
          <target state="translated">Solución completa-superando la mayoría de estos problemas</target>
        </trans-unit>
        <trans-unit id="fb7e0637c4d5a6d73f637194c0246e331b6544bf" translate="yes" xml:space="preserve">
          <source>Functions references</source>
          <target state="translated">Referencias de las funciones</target>
        </trans-unit>
        <trans-unit id="d9429ca6d1142349d10e10a94576fffa86564438" translate="yes" xml:space="preserve">
          <source>Great, now what would you say about passing arguments to the decorator itself?</source>
          <target state="translated">Genial,¿ahora qué dirías sobre pasar argumentos al propio decorador?</target>
        </trans-unit>
        <trans-unit id="da0d931207acb9b41e89d340765036903cec4311" translate="yes" xml:space="preserve">
          <source>Handcrafted decorators</source>
          <target state="translated">Decoradores artesanales</target>
        </trans-unit>
        <trans-unit id="6c94ddf86de798e414a3de66543416eb33764543" translate="yes" xml:space="preserve">
          <source>Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.</source>
          <target state="translated">Aquí hay un simple ejemplo de encadenar a los decoradores.Fíjense en la última línea,que muestra lo que está pasando bajo las cubiertas.</target>
        </trans-unit>
        <trans-unit id="879edad30080eeaee9e2cf7411d0c110780e7c60" translate="yes" xml:space="preserve">
          <source>Here it is: a decorator with arguments. Arguments can be set as variable:</source>
          <target state="translated">Aquí está:un decorador con argumentos.Los argumentos se pueden establecer como variables:</target>
        </trans-unit>
        <trans-unit id="078d424ccacc316d41eb3c9e64c0a049566eda86" translate="yes" xml:space="preserve">
          <source>Hey, did you see that? We used a function call with the &quot;&lt;code&gt;@&lt;/code&gt;&quot; syntax! :-)</source>
          <target state="translated">Oye, &amp;iquest;viste eso? &amp;iexcl;Utilizamos una llamada de funci&amp;oacute;n con la sintaxis &quot; &lt;code&gt;@&lt;/code&gt; &quot;! :-)</target>
        </trans-unit>
        <trans-unit id="a14b8e424350d415cdd48e9f09183de9ffb56f6f" translate="yes" xml:space="preserve">
          <source>How can I make two decorators in Python that would do the following?</source>
          <target state="translated">¿Cómo puedo hacer dos decoradores en Python que hagan lo siguiente?</target>
        </trans-unit>
        <trans-unit id="12a65f2bbbb67ec061b91830c0f3852f397b8da4" translate="yes" xml:space="preserve">
          <source>How can the decorators be useful?</source>
          <target state="translated">¿Cómo pueden ser útiles los decoradores?</target>
        </trans-unit>
        <trans-unit id="b5614093ef277f04d2fcf8a8f6d17ab705e42f42" translate="yes" xml:space="preserve">
          <source>How to make a chain of function decorators</source>
          <target state="translated">Cómo hacer una cadena de decoradores funcionales</target>
        </trans-unit>
        <trans-unit id="9c80cc9314ab160ba886800aef0563ac91482582" translate="yes" xml:space="preserve">
          <source>How you&amp;rsquo;d do it manually:</source>
          <target state="translated">C&amp;oacute;mo lo har&amp;iacute;as manualmente:</target>
        </trans-unit>
        <trans-unit id="4a1cc8e375a4ebd9b5ffc2959ee04c7e8d713115" translate="yes" xml:space="preserve">
          <source>However it has 3 major limitations if you want to tackle more general cases:</source>
          <target state="translated">Sin embargo,tiene 3 limitaciones importantes si se quiere abordar casos más generales:</target>
        </trans-unit>
        <trans-unit id="1a3cd9a00b172fb82cc5ee4d2ed407fb3a1ac23e" translate="yes" xml:space="preserve">
          <source>I know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don't you feel good about mastering this?</source>
          <target state="translated">Lo sé,la última vez que tuviste este sentimiento,fue después de escuchar a un tipo diciendo:&quot;antes de entender la recursividad,primero debes entender la recursividad&quot;.Pero ahora,¿no te sientes bien dominando esto?</target>
        </trans-unit>
        <trans-unit id="726239257c85d745949f495cf86f83f7f3423958" translate="yes" xml:space="preserve">
          <source>I wrote &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;&lt;code&gt;decopatch&lt;/code&gt;&lt;/a&gt; to solve the first issue, and wrote &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt;&lt;code&gt;makefun.wraps&lt;/code&gt;&lt;/a&gt; to solve the other two. Note that &lt;code&gt;makefun&lt;/code&gt; leverages the same trick than the famous &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt;&lt;code&gt;decorator&lt;/code&gt;&lt;/a&gt; lib.</source>
          <target state="translated">Escrib&amp;iacute; &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt; &lt;code&gt;decopatch&lt;/code&gt; &lt;/a&gt; para resolver el primer problema, y ​​escrib&amp;iacute; &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt; &lt;code&gt;makefun.wraps&lt;/code&gt; &lt;/a&gt; para resolver los otros dos. Tenga en cuenta que &lt;code&gt;makefun&lt;/code&gt; aprovecha el mismo truco que el famoso &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt; &lt;code&gt;decorator&lt;/code&gt; &lt;/a&gt; lib.</target>
        </trans-unit>
        <trans-unit id="5d7696becef5ac38fad435088d0ecb76e8a0289a" translate="yes" xml:space="preserve">
          <source>I'm not trying to make &lt;code&gt;HTML&lt;/code&gt; this way in a real application - just trying to understand how decorators and decorator chaining works.</source>
          <target state="translated">No estoy tratando de hacer &lt;code&gt;HTML&lt;/code&gt; de esta manera en una aplicaci&amp;oacute;n real, solo estoy tratando de entender c&amp;oacute;mo funcionan los decoradores y el encadenamiento de decoradores.</target>
        </trans-unit>
        <trans-unit id="1e0c463512620a7aa52516ce6954607005e44fad" translate="yes" xml:space="preserve">
          <source>If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.</source>
          <target state="translated">Si la velocidad de la función decorada es importante,la sobrecarga puede mantenerse en una sola llamada de función extra escribiendo una función de fábrica de decorador ligeramente diferente que implemente la adición de todas las etiquetas a la vez,de modo que pueda generar un código que evite las llamadas de función adicionales incurridas por el uso de decoradores separados para cada etiqueta.</target>
        </trans-unit>
        <trans-unit id="7f5eb6d6e3ee8c4703ec52543976257f38262e16" translate="yes" xml:space="preserve">
          <source>If you are not into long explanations, see &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantino&amp;rsquo;s answer&lt;/a&gt;.</source>
          <target state="translated">Si no le gustan las explicaciones largas, vea &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;la respuesta de Paolo Bergantino&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="317dfc8d065e9e0684a901257748d3a5167229f3" translate="yes" xml:space="preserve">
          <source>If you can &lt;code&gt;return&lt;/code&gt; a function, you can pass one as a parameter:</source>
          <target state="translated">Si puede &lt;code&gt;return&lt;/code&gt; una funci&amp;oacute;n, puede pasar una como par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="48e4b22d8da3dfe34b25ed14a816e2633b2c5e3a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re making general-purpose decorator--one you&amp;rsquo;ll apply to any function or method, no matter its arguments--then just use &lt;code&gt;*args, **kwargs&lt;/code&gt;:</source>
          <target state="translated">Si est&amp;aacute; haciendo un decorador de uso general, uno que aplicar&amp;aacute; a cualquier funci&amp;oacute;n o m&amp;eacute;todo, sin importar sus argumentos, entonces solo use &lt;code&gt;*args, **kwargs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bef3f2c6067205cdab221b9850de1b292b160e38" translate="yes" xml:space="preserve">
          <source>In Python 3, you also get &lt;code&gt;__qualname__&lt;/code&gt; and &lt;code&gt;__annotations__&lt;/code&gt; assigned by default.</source>
          <target state="translated">En Python 3, tambi&amp;eacute;n obtiene &lt;code&gt;__qualname__&lt;/code&gt; y &lt;code&gt;__annotations__&lt;/code&gt; asignados por defecto.</target>
        </trans-unit>
        <trans-unit id="f85fcf9dfd9a481037c239b8ac3cb04c0f757dbe" translate="yes" xml:space="preserve">
          <source>In both cases you can check that the decorator works as expected:</source>
          <target state="translated">En ambos casos puedes comprobar que el decorador trabaja como se espera:</target>
        </trans-unit>
        <trans-unit id="441b181831532dd1b1468f0beb612ec2adb9a6ac" translate="yes" xml:space="preserve">
          <source>It can be used as follows:</source>
          <target state="translated">Se puede utilizar de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="a2364cec8db742e16d44a56e4e97742669df4b53" translate="yes" xml:space="preserve">
          <source>It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it.</source>
          <target state="translated">Es desafortunado que todavía haya algo de calderilla,pero esto es lo más simple que podemos hacer.</target>
        </trans-unit>
        <trans-unit id="d52aaab6a849e68c11a3c5f3892267606e5ba341" translate="yes" xml:space="preserve">
          <source>It looks like the other people have already told you how to solve the problem. I hope this will help you understand what decorators are.</source>
          <target state="translated">Parece que los demás ya le han dicho cómo resolver el problema.Espero que esto le ayude a entender lo que son los decoradores.</target>
        </trans-unit>
        <trans-unit id="0a437594f7f26d9de32ed6e32daf8a7144562ec6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s exactly the same. &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot; is called. So when you &lt;code&gt;@my_decorator&lt;/code&gt;, you are telling Python to call the function 'labelled by the variable &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot;'.</source>
          <target state="translated">Es exactamente lo mismo. Se &lt;code&gt;my_decorator&lt;/code&gt; &quot; my_decorator &quot;. Entonces, cuando usted &lt;code&gt;@my_decorator&lt;/code&gt; , le est&amp;aacute; diciendo a Python que llame a la funci&amp;oacute;n 'etiquetada por la variable &quot; &lt;code&gt;my_decorator&lt;/code&gt; &quot;'.</target>
        </trans-unit>
        <trans-unit id="7ce0ce68a04f2b66e2e819d56376b33b1a2e7a7e" translate="yes" xml:space="preserve">
          <source>Keep this in mind. We&amp;rsquo;ll circle back to it shortly.</source>
          <target state="translated">Mant&amp;eacute;n esto en mente. Volveremos a &amp;eacute;l en breve.</target>
        </trans-unit>
        <trans-unit id="4bceeb87ddeae7d32f5a461e830c4a01e1c2dbb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do EXACTLY the same thing, but skip all the pesky intermediate variables:</source>
          <target state="translated">Hagamos EXACTAMENTE lo mismo, pero omita todas las molestas variables intermedias:</target>
        </trans-unit>
        <trans-unit id="77a07d0b57a22cf6113918bd191c5b56c27d8347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get evil. ☺</source>
          <target state="translated">Vamos a ponernos malvados. ☺</target>
        </trans-unit>
        <trans-unit id="78be7938d254badacf135b18dc6cc6c451c38c66" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s have some fun and write a decorator for the decorators:</source>
          <target state="translated">Divirt&amp;aacute;monos y escribamos un decorador para los decoradores:</target>
        </trans-unit>
        <trans-unit id="27294f1ad34ef605ff9afc4e6f4c9ab75aadb8e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make it &lt;em&gt;even shorter&lt;/em&gt;:</source>
          <target state="translated">Hag&amp;aacute;moslo &lt;em&gt;a&amp;uacute;n m&amp;aacute;s corto&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="cc604b7219e99c7ead3ddb49899ab7f07ac1541b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice: decorating a decorator</source>
          <target state="translated">Practiquemos: decorar un decorador</target>
        </trans-unit>
        <trans-unit id="ca309b745c2658e0e7c0557696b22a6ed74f2b7c" translate="yes" xml:space="preserve">
          <source>No surprise here.</source>
          <target state="translated">No es una sorpresa.</target>
        </trans-unit>
        <trans-unit id="255ef6b7422b7ccfa19a20bfa097944e74cf3b94" translate="yes" xml:space="preserve">
          <source>Note that a function is defined inside a function.
What it basically does is replace a function with the newly defined one. For example, I have this class</source>
          <target state="translated">Observe que una función se define dentro de una función.Lo que hace básicamente es reemplazar una función con la recién definida.Por ejemplo,tengo esta clase</target>
        </trans-unit>
        <trans-unit id="2dc264a51f806548732cb077d81ae6952adc115e" translate="yes" xml:space="preserve">
          <source>Notice that this example didn't include the &lt;code&gt;list&lt;/code&gt; type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list.</source>
          <target state="translated">Tenga en cuenta que este ejemplo no incluy&amp;oacute; el tipo de &lt;code&gt;list&lt;/code&gt; a en la creaci&amp;oacute;n de instancias del decorador, por lo que en la declaraci&amp;oacute;n de impresi&amp;oacute;n final el m&amp;eacute;todo se aplica a la lista en s&amp;iacute;, no a los elementos de la lista.</target>
        </trans-unit>
        <trans-unit id="7d0d40184a1e365e8aec68153ce0e6264dbac917" translate="yes" xml:space="preserve">
          <source>Now say, I want both functions to print &quot;---&quot; after and before they are done.
I could add a print &quot;---&quot; before and after each print statement.
But because I don't like repeating myself, I will make a decorator</source>
          <target state="translated">Ahora di,quiero que ambas funciones impriman &quot;---&quot; después y antes de que se hagan.Podría añadir un &quot;---&quot; antes y después de cada impresión.Pero como no me gusta repetirme,haré que un decorador</target>
        </trans-unit>
        <trans-unit id="6374db670ada8df89b3ba0c8efdc28f893467811" translate="yes" xml:space="preserve">
          <source>Now use them as desired:</source>
          <target state="translated">Ahora úsalos como quieras:</target>
        </trans-unit>
        <trans-unit id="0cb1ffaf9060bacf69b447f3baaca8c541d46cf1" translate="yes" xml:space="preserve">
          <source>Now, you probably want that every time you call &lt;code&gt;a_stand_alone_function&lt;/code&gt;, &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; is called instead. That&amp;rsquo;s easy, just overwrite &lt;code&gt;a_stand_alone_function&lt;/code&gt; with the function returned by &lt;code&gt;my_shiny_new_decorator&lt;/code&gt;:</source>
          <target state="translated">Ahora, probablemente quieras que cada vez que llames &lt;code&gt;a_stand_alone_function&lt;/code&gt; , se llame a_stand_alone_function_decorated . Eso es f&amp;aacute;cil, simplemente sobrescribe &lt;code&gt;a_stand_alone_function&lt;/code&gt; con la funci&amp;oacute;n devuelta por &lt;code&gt;my_shiny_new_decorator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40887ec7e652c1bdf57a41f57f0cb24e4ff2822b" translate="yes" xml:space="preserve">
          <source>Now: to answer the question...</source>
          <target state="translated">Ahora:para responder a la pregunta...</target>
        </trans-unit>
        <trans-unit id="579d575c5ed4bac1f322abf77675f853665ad5bb" translate="yes" xml:space="preserve">
          <source>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:</source>
          <target state="translated">Por supuesto,lo bueno de los decoradores es que puedes usarlos de inmediato en casi todo sin necesidad de reescribir.Seco,dije:</target>
        </trans-unit>
        <trans-unit id="1be3cbc92c16a773de95bc885b3fc9e99b4a6788" translate="yes" xml:space="preserve">
          <source>Of course, you can accumulate decorators:</source>
          <target state="translated">Por supuesto,puedes acumular decoradores:</target>
        </trans-unit>
        <trans-unit id="91a37b5d402fd2f9d6d6d0b09967c77439df7c5c" translate="yes" xml:space="preserve">
          <source>Oh yes, decorators!</source>
          <target state="translated">¡Oh sí,decoradores!</target>
        </trans-unit>
        <trans-unit id="10957fc6e11cfdfbf98f8f5f5c0ad12c66b378d0" translate="yes" xml:space="preserve">
          <source>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.</source>
          <target state="translated">Vale,como bonus,te daré un recorte para que cualquier decorador acepte genéricamente cualquier argumento.Después de todo,para aceptar los argumentos,creamos nuestro decorador usando otra función.</target>
        </trans-unit>
        <trans-unit id="6bbd3347dd91397e5be987a0a88f7eff1abc0a3e" translate="yes" xml:space="preserve">
          <source>Okay, still here? Now the fun part...</source>
          <target state="translated">Bien,¿todavía aquí? Ahora la parte divertida...</target>
        </trans-unit>
        <trans-unit id="56949a19e12ea95f6c3843043b9cdd359a9fb0c0" translate="yes" xml:space="preserve">
          <source>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (&lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">Una cosa ingeniosa sobre Python es que los m&amp;eacute;todos y las funciones son realmente los mismos. La &amp;uacute;nica diferencia es que los m&amp;eacute;todos esperan que su primer argumento sea una referencia al objeto actual ( &lt;code&gt;self&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e0a663c8d21ccb65a769c61071c5d509abd2783" translate="yes" xml:space="preserve">
          <source>Or, more flexibly:</source>
          <target state="translated">O,más flexiblemente:</target>
        </trans-unit>
        <trans-unit id="2fb316fd9385ead51b295112e84edb25cd8b95b1" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorated function</source>
          <target state="translated">Pasar argumentos a la función condecorada</target>
        </trans-unit>
        <trans-unit id="24b163e0afbd75a6ca84ffb958862c256129d2de" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorator</source>
          <target state="translated">Pasando argumentos al decorador</target>
        </trans-unit>
        <trans-unit id="17d426ae159ee05b9325ff80a8339b7de2e089f6" translate="yes" xml:space="preserve">
          <source>Personally I would have written the decorator somewhat differently:</source>
          <target state="translated">Personalmente,habría escrito al decorador de forma algo diferente:</target>
        </trans-unit>
        <trans-unit id="c7b7f62e823e6869c5758a9786c02608bd932456" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">Consulte la &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="c10adc093e3b42e5c9bf392b6f6849c6dbd8218e" translate="yes" xml:space="preserve">
          <source>Problems with the simple solution</source>
          <target state="translated">Problemas con la solución simple</target>
        </trans-unit>
        <trans-unit id="6ed78550e4466481db863ec487bb1bd253cc35d3" translate="yes" xml:space="preserve">
          <source>Python decorators add extra functionality to another function</source>
          <target state="translated">Los decoradores de pitón añaden una funcionalidad extra a otra función</target>
        </trans-unit>
        <trans-unit id="d1727d8a5520ad1a9627fdc2eab00abe2b5d6379" translate="yes" xml:space="preserve">
          <source>Python itself provides several decorators: &lt;code&gt;property&lt;/code&gt;, &lt;code&gt;staticmethod&lt;/code&gt;, etc.</source>
          <target state="translated">Python proporciona varios decoradores: &lt;code&gt;property&lt;/code&gt; , &lt;code&gt;staticmethod&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="284cca9bb8bff3580e1d28d9004c90370ab5fc92" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s functions are objects</source>
          <target state="translated">Las funciones de Python son objetos.</target>
        </trans-unit>
        <trans-unit id="0fb5d72701f71daeb5de4c55b12b5b28333babb4" translate="yes" xml:space="preserve">
          <source>Refinements</source>
          <target state="translated">Refinements</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="447529f8d79e74c1015331f703c4fd58c0024d0f" translate="yes" xml:space="preserve">
          <source>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it&amp;rsquo;s temporary).</source>
          <target state="translated">Parece genial y poderoso, pero un ejemplo pr&amp;aacute;ctico ser&amp;iacute;a genial. Bueno, hay 1000 posibilidades. Los usos cl&amp;aacute;sicos est&amp;aacute;n extendiendo el comportamiento de una funci&amp;oacute;n desde una biblioteca externa (no puede modificarla), o para la depuraci&amp;oacute;n (no desea modificarla porque es temporal).</target>
        </trans-unit>
        <trans-unit id="8190083ab834e9da2d9dcad17a07753d67081489" translate="yes" xml:space="preserve">
          <source>Simple solution</source>
          <target state="translated">Solución simple</target>
        </trans-unit>
        <trans-unit id="379eadfed2be4f0025e4f13911405915d77b0d61" translate="yes" xml:space="preserve">
          <source>So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.</source>
          <target state="translated">Así que si ponemos documentación sobre esta función,o queríamos ser capaces de decorar funciones que requieren más de un argumento,o simplemente queríamos saber qué función estábamos viendo en una sesión de depuración,necesitamos hacer un poco más con nuestro envoltorio.</target>
        </trans-unit>
        <trans-unit id="1c60607379772605752445769cae451aa46faaba" translate="yes" xml:space="preserve">
          <source>So now I can change my class to</source>
          <target state="translated">Así que ahora puedo cambiar mi clase a</target>
        </trans-unit>
        <trans-unit id="6cbe6521ca09a7746011901561de604aa6c89d3c" translate="yes" xml:space="preserve">
          <source>So now:</source>
          <target state="translated">Así que ahora:</target>
        </trans-unit>
        <trans-unit id="efb7b2d9e9ca503721dfb04f5dc4469198ba42fa" translate="yes" xml:space="preserve">
          <source>So we see that &lt;code&gt;wraps&lt;/code&gt; makes the wrapping function do almost everything except tell us exactly what the function takes as arguments.</source>
          <target state="translated">Entonces, vemos que las &lt;code&gt;wraps&lt;/code&gt; hacen que la funci&amp;oacute;n de envoltura haga casi todo, excepto decirnos exactamente lo que la funci&amp;oacute;n toma como argumentos.</target>
        </trans-unit>
        <trans-unit id="50cf77367001a751c11f1a93c8af87bfa1080df0" translate="yes" xml:space="preserve">
          <source>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?</source>
          <target state="translated">Así que,volviendo a los decoradores con argumentos.Si podemos usar funciones para generar el decorador sobre la marcha,podemos pasar argumentos a esa función,¿verdad?</target>
        </trans-unit>
        <trans-unit id="5cb9c55c987610f1d50dddd4525d5c7adbdde9f8" translate="yes" xml:space="preserve">
          <source>Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:</source>
          <target state="translated">Hablando del ejemplo del contador-como se ha indicado anteriormente,el contador se repartirá entre todas las funciones que utilizan el decorador:</target>
        </trans-unit>
        <trans-unit id="96b98ca4ad50b3f8c62ee69fd0d15c5c564ba92c" translate="yes" xml:space="preserve">
          <source>Taking decorators to the next level</source>
          <target state="translated">Llevar a los decoradores al siguiente nivel</target>
        </trans-unit>
        <trans-unit id="437612b73a9a61ff531195df2dfd1a552e3cd790" translate="yes" xml:space="preserve">
          <source>That means that &lt;strong&gt;a function can &lt;code&gt;return&lt;/code&gt; another function&lt;/strong&gt;.</source>
          <target state="translated">Eso significa que &lt;strong&gt;una funci&amp;oacute;n puede &lt;code&gt;return&lt;/code&gt; otra funci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f298bfca0f195e40010a96673a464012e8d44e65" translate="yes" xml:space="preserve">
          <source>That means you can build a decorator for methods the same way! Just remember to take &lt;code&gt;self&lt;/code&gt; into consideration:</source>
          <target state="translated">&amp;iexcl;Eso significa que puedes construir un decorador para m&amp;eacute;todos de la misma manera! Solo recuerda tomarte en cuenta:</target>
        </trans-unit>
        <trans-unit id="050b7db66c47db53ba8a596842a9b2aa1e330633" translate="yes" xml:space="preserve">
          <source>That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt;), and the counter variable will remain private to each.</source>
          <target state="translated">De esa manera, su decorador puede reutilizarse para diferentes funciones (o usarse para decorar la misma funci&amp;oacute;n varias veces: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt; ), y la variable counter seguir&amp;aacute; siendo privada para cada uno.</target>
        </trans-unit>
        <trans-unit id="5564267bef96d8c06f321659900ce4a65f09fbb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functools&lt;/code&gt; module was introduced in Python 2.5. It includes the function &lt;code&gt;functools.wraps()&lt;/code&gt;, which copies the name, module, and docstring of the decorated function to its wrapper.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;functools&lt;/code&gt; se introdujo en Python 2.5. Incluye la funci&amp;oacute;n &lt;code&gt;functools.wraps()&lt;/code&gt; , que copia el nombre, el m&amp;oacute;dulo y la cadena de documentos de la funci&amp;oacute;n decorada en su envoltorio.</target>
        </trans-unit>
        <trans-unit id="b96153d0cd80112477376110b277ba00b0b61985" translate="yes" xml:space="preserve">
          <source>The order you set the decorators MATTERS:</source>
          <target state="translated">El orden que le des a los decoradores es importante:</target>
        </trans-unit>
        <trans-unit id="ee3ecad5bd632505c874495ef908b5ccadff853d" translate="yes" xml:space="preserve">
          <source>The output looks like:</source>
          <target state="translated">La salida parece:</target>
        </trans-unit>
        <trans-unit id="c333dc4fec82663d8c79348d8fc54c67a7a233bc" translate="yes" xml:space="preserve">
          <source>The previous example, using the decorator syntax:</source>
          <target state="translated">El ejemplo anterior,usando la sintaxis del decorador:</target>
        </trans-unit>
        <trans-unit id="960b2fe36e68117facc37e06febe129a38132041" translate="yes" xml:space="preserve">
          <source>There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.</source>
          <target state="translated">Hay otros módulos que pueden intentar abordar el problema,pero la solución no está todavía en la biblioteca estándar.</target>
        </trans-unit>
        <trans-unit id="af9cac89e15b8a4e52d28cb0c6dc344f017cf8ab" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s more!</source>
          <target state="translated">&amp;iexcl;Hay m&amp;aacute;s!</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b5039e57d9fc37a75f36b953d9898eff7500a6b9" translate="yes" xml:space="preserve">
          <source>This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact.</source>
          <target state="translated">Esta respuesta ha sido contestada hace mucho tiempo,pero pensé en compartir mi clase de decorador que hace que escribir nuevos decoradores sea fácil y compacto.</target>
        </trans-unit>
        <trans-unit id="2904fc69aef6f7ec13cb9a23a39932c544deb84c" translate="yes" xml:space="preserve">
          <source>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function&amp;rsquo;s arguments directly to the decorator.</source>
          <target state="translated">Esto puede torcerse un poco, ya que un decorador debe aceptar una funci&amp;oacute;n como argumento. Por lo tanto, no puede pasar los argumentos de la funci&amp;oacute;n decorada directamente al decorador.</target>
        </trans-unit>
        <trans-unit id="a2c775a862081edfd042f2470df626fc3eef6aa4" translate="yes" xml:space="preserve">
          <source>This enables you to write:</source>
          <target state="translated">Esto te permite escribir:</target>
        </trans-unit>
        <trans-unit id="0b1c1e381424a38b2424282c1fa352f40d278095" translate="yes" xml:space="preserve">
          <source>This is how you would create a decorator with arguments, returning truly signature-preserving wrappers:</source>
          <target state="translated">Así es como se crearía un decorador con argumentos,devolviendo envoltorios que conservan la firma:</target>
        </trans-unit>
        <trans-unit id="ce42d5743ee1866f5dc731830ebf5ed5afa194eb" translate="yes" xml:space="preserve">
          <source>This is important! The label you give can point directly to the decorator&amp;mdash;&lt;strong&gt;or not&lt;/strong&gt;.</source>
          <target state="translated">&amp;iexcl;Esto es importante! La etiqueta que le d&amp;eacute; puede apuntar directamente al decorador, &lt;strong&gt;o no&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5027fb5d3093f380441a1296b10193eb568104dd" translate="yes" xml:space="preserve">
          <source>This really is a large playground.</source>
          <target state="translated">Este es realmente un gran patio de recreo.</target>
        </trans-unit>
        <trans-unit id="1fd557f5cb363c1aff4438192da3019b9a577767" translate="yes" xml:space="preserve">
          <source>This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using &lt;code&gt;lambda&lt;/code&gt; functions as previously illustrated. Sample:</source>
          <target state="translated">Esto requiere m&amp;aacute;s c&amp;oacute;digo en el decorador en s&amp;iacute;, pero esto solo se ejecuta cuando se aplica a las definiciones de funciones, no m&amp;aacute;s tarde cuando se llaman a ellos mismos. Esto tambi&amp;eacute;n se aplica al crear nombres m&amp;aacute;s legibles mediante el uso de funciones &lt;code&gt;lambda&lt;/code&gt; como se ilustra anteriormente. Muestra:</target>
        </trans-unit>
        <trans-unit id="a8eaf579c4f258b33b0482ef3b7df54778820469" translate="yes" xml:space="preserve">
          <source>To explain the decorator in a simple way:</source>
          <target state="translated">Para explicar al decorador de una manera sencilla:</target>
        </trans-unit>
        <trans-unit id="473f07947e0fd95c8d023c615f35b4d07297397e" translate="yes" xml:space="preserve">
          <source>To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other:</source>
          <target state="translated">Para encontrarlo,tendríamos que cavar en el cierre de cada lambda,una de las cuales está enterrada en la otra:</target>
        </trans-unit>
        <trans-unit id="d05d323aa64f59be265e5a87806a41e0c825210f" translate="yes" xml:space="preserve">
          <source>To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:</source>
          <target state="translated">Para hacer el código más legible,puedes asignar un nombre más descriptivo a los decoradores de la fábrica:</target>
        </trans-unit>
        <trans-unit id="883de3fa331a806ddd7c7652ca1e49092c7971b4" translate="yes" xml:space="preserve">
          <source>To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:</source>
          <target state="translated">Para hacer esto de manera más simple,hacer que los decoradores que devuelvan lambdas (funciones anónimas)que se cierran sobre la función (cierres)y la llamen:</target>
        </trans-unit>
        <trans-unit id="62f4218b8c6ef484c2f1975f99215aea59a557d9" translate="yes" xml:space="preserve">
          <source>To return:</source>
          <target state="translated">Para volver:</target>
        </trans-unit>
        <trans-unit id="bd12f2d27cd71bb3463350185fcfc9d61abd15f6" translate="yes" xml:space="preserve">
          <source>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let&amp;rsquo;s see why with a simple example :</source>
          <target state="translated">Para comprender los decoradores, primero debe comprender que las funciones son objetos en Python. Esto tiene importantes consecuencias. Veamos por qu&amp;eacute; con un simple ejemplo:</target>
        </trans-unit>
        <trans-unit id="196f074c1d92f9ced554dc60521c54d33c9ca742" translate="yes" xml:space="preserve">
          <source>To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result.</source>
          <target state="translated">Para entender al decorador,es importante notar,que el decorador creó una nueva función hacer que es interna que ejecuta la función y transforma el resultado.</target>
        </trans-unit>
        <trans-unit id="60902dc77861b8c1fdfaf6268a2464fa22de1ceb" translate="yes" xml:space="preserve">
          <source>Twisted to fake inlining asynchronous functions calls.</source>
          <target state="translated">Torcido para falsificar las llamadas de las funciones asincrónicas en línea.</target>
        </trans-unit>
        <trans-unit id="c77a8f9b1468c11516a914ac6de3a49735219779" translate="yes" xml:space="preserve">
          <source>Using the Python decorator syntax:</source>
          <target state="translated">Usando la sintaxis del decorador de Python:</target>
        </trans-unit>
        <trans-unit id="aa9cefd3355dfbb169969e4d070840477e8f3574" translate="yes" xml:space="preserve">
          <source>We have the decorator &lt;code&gt;wraps&lt;/code&gt; from the &lt;code&gt;functools&lt;/code&gt; module in the standard library!</source>
          <target state="translated">&amp;iexcl;Tenemos las &lt;code&gt;wraps&lt;/code&gt; decorador del m&amp;oacute;dulo &lt;code&gt;functools&lt;/code&gt; en la biblioteca est&amp;aacute;ndar!</target>
        </trans-unit>
        <trans-unit id="e7828a39d26d60430dd896cb93790f6a849e80c7" translate="yes" xml:space="preserve">
          <source>We wrapped the decorator.</source>
          <target state="translated">Envolvimos al decorador.</target>
        </trans-unit>
        <trans-unit id="fe01beda96c243b61696dcac93827863db70a633" translate="yes" xml:space="preserve">
          <source>Well, you just have everything needed to understand decorators. You see, decorators are &amp;ldquo;wrappers&amp;rdquo;, which means that &lt;strong&gt;they let you execute code before and after the function they decorate&lt;/strong&gt; without modifying the function itself.</source>
          <target state="translated">Bueno, solo tienes todo lo necesario para entender a los decoradores. Ver&amp;aacute;, los decoradores son &quot;envoltorios&quot;, lo que significa que &lt;strong&gt;le permiten ejecutar c&amp;oacute;digo antes y despu&amp;eacute;s de la funci&amp;oacute;n que decoran&lt;/strong&gt; sin modificar la funci&amp;oacute;n misma.</target>
        </trans-unit>
        <trans-unit id="e60ee3faedca029b522b5766bd4fef43e46646de" translate="yes" xml:space="preserve">
          <source>When do:</source>
          <target state="translated">Cuando lo haga:</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">Que huellas:</target>
        </trans-unit>
        <trans-unit id="0f59d388d686c4bb98639de68bb575c3f2e8c1b3" translate="yes" xml:space="preserve">
          <source>While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).</source>
          <target state="translated">Si bien los ejemplos anteriores hacen todo el trabajo,el código generado implica una buena cantidad de gastos generales en forma de llamadas de funciones extrañas cuando se aplican varios decoradores a la vez.Esto puede no importar,dependiendo del uso exacto (que puede ser IO-bound,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="80931ea7fb9f9baaccc7db7989d6b55cd34a1502" translate="yes" xml:space="preserve">
          <source>Yes, that&amp;rsquo;s all, it&amp;rsquo;s that simple. &lt;code&gt;@decorator&lt;/code&gt; is just a shortcut to:</source>
          <target state="translated">S&amp;iacute;, eso es todo, es as&amp;iacute; de simple. &lt;code&gt;@decorator&lt;/code&gt; es solo un atajo para:</target>
        </trans-unit>
        <trans-unit id="82aa4bf8798112112023c3bf62cf028a41534be3" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; make two separate decorators that do what you want as illustrated directly below. Note the use of &lt;code&gt;*args, **kwargs&lt;/code&gt; in the declaration of the &lt;code&gt;wrapped()&lt;/code&gt; function which supports the decorated function having multiple arguments (which isn't really necessary for the example &lt;code&gt;say()&lt;/code&gt; function, but is included for generality).</source>
          <target state="translated">Puede hacer dos decoradores separados que hagan lo que quiera como se ilustra directamente a continuaci&amp;oacute;n. Tenga en cuenta el uso de &lt;code&gt;*args, **kwargs&lt;/code&gt; en la declaraci&amp;oacute;n de la funci&amp;oacute;n wrap &lt;code&gt;wrapped()&lt;/code&gt; que admite la funci&amp;oacute;n decorada que tiene m&amp;uacute;ltiples argumentos (que no es realmente necesario para la funci&amp;oacute;n &lt;code&gt;say()&lt;/code&gt; , pero se incluye por generalidad).</target>
        </trans-unit>
        <trans-unit id="3fcf6e6cdbd43a4541ee6fee7299941830fb61da" translate="yes" xml:space="preserve">
          <source>You can also write decorator in Class</source>
          <target state="translated">También puedes escribir decorador en la clase</target>
        </trans-unit>
        <trans-unit id="e0a9ddf317ada0cb0975c84b1b3a3350e91427a6" translate="yes" xml:space="preserve">
          <source>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.</source>
          <target state="translated">Ahora puedes irte feliz,o quemar tu cerebro un poco más y ver los usos avanzados de los decoradores.</target>
        </trans-unit>
        <trans-unit id="50c0158657b192fc0e1e92b4b42743e823b5581b" translate="yes" xml:space="preserve">
          <source>You can use them to extend several functions in a DRY&amp;rsquo;s way, like so:</source>
          <target state="translated">Puede usarlos para extender varias funciones de una manera SECA, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="eb12aebb78c3f68a3b62316d71c4c613fca73470" translate="yes" xml:space="preserve">
          <source>You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator:</source>
          <target state="translated">También podrías usarlo para hacer tareas más complejas,como por ejemplo un decorador que hace que la función se aplique automáticamente de forma recursiva a todos los argumentos de un iterador:</target>
        </trans-unit>
        <trans-unit id="2ecc0fab1db96d14074c26f8bc8f79f84ec79ac0" translate="yes" xml:space="preserve">
          <source>You really do:</source>
          <target state="translated">De verdad que sí:</target>
        </trans-unit>
        <trans-unit id="e81544690dadca1e7c105c62bc3929aebc31d34d" translate="yes" xml:space="preserve">
          <source>You want the following function, when called:</source>
          <target state="translated">Quiere la siguiente función,cuando se le llame:</target>
        </trans-unit>
        <trans-unit id="953873baa875246b6189da13ed630a79eb5fb0e9" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve seen that functions are objects. Therefore, functions:</source>
          <target state="translated">Has visto que las funciones son objetos. Por lo tanto, las funciones:</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">y ahora:</target>
        </trans-unit>
        <trans-unit id="cafef07857121c9781de270f85e3951e33ef3a0f" translate="yes" xml:space="preserve">
          <source>as already noted in several answers, you can not easily modify the code to &lt;strong&gt;add optional decorator arguments&lt;/strong&gt;. For example creating a &lt;code&gt;makestyle(style='bold')&lt;/code&gt; decorator is non-trivial.</source>
          <target state="translated">como ya se se&amp;ntilde;al&amp;oacute; en varias respuestas, no puede modificar f&amp;aacute;cilmente el c&amp;oacute;digo para &lt;strong&gt;agregar argumentos decoradores opcionales&lt;/strong&gt; . Por ejemplo, crear un &lt;code&gt;makestyle(style='bold')&lt;/code&gt; no es trivial.</target>
        </trans-unit>
        <trans-unit id="810b76f64a3518b6640d265928755185623d443d" translate="yes" xml:space="preserve">
          <source>besides, wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt;&lt;strong&gt;do not preserve the signature&lt;/strong&gt;, so if bad arguments are provided they will start executing, and might raise a different kind of error than the usual &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">adem&amp;aacute;s, los envoltorios creados con &lt;code&gt;@functools.wraps&lt;/code&gt; &lt;strong&gt;no conservan la firma&lt;/strong&gt; , por lo que si se proporcionan argumentos incorrectos, comenzar&amp;aacute;n a ejecutarse y podr&amp;iacute;an generar un tipo de error diferente al &lt;code&gt;TypeError&lt;/code&gt; habitual.</target>
        </trans-unit>
        <trans-unit id="278b019b92e03f8c6d596bdc96fa24cef85ab67c" translate="yes" xml:space="preserve">
          <source>can be assigned to a variable</source>
          <target state="translated">puede asignarse a una variable</target>
        </trans-unit>
        <trans-unit id="990c222d7e553798fcdfee2e5fa3c3d0fc120879" translate="yes" xml:space="preserve">
          <source>can be defined in another function</source>
          <target state="translated">puede definirse en otra función</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">se expande a</target>
        </trans-unit>
        <trans-unit id="ccdbc5352040835da410ff1c10cbf69f8c83982f" translate="yes" xml:space="preserve">
          <source>finally, it is quite difficult in wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt; to &lt;strong&gt;access an argument based on its name&lt;/strong&gt;. Indeed the argument can appear in &lt;code&gt;*args&lt;/code&gt;, in &lt;code&gt;**kwargs&lt;/code&gt;, or may not appear at all (if it is optional).</source>
          <target state="translated">Finalmente, es bastante dif&amp;iacute;cil en los contenedores creados con &lt;code&gt;@functools.wraps&lt;/code&gt; &lt;strong&gt;acceder a un argumento basado en su nombre&lt;/strong&gt; . De hecho, el argumento puede aparecer en &lt;code&gt;*args&lt;/code&gt; , en &lt;code&gt;**kwargs&lt;/code&gt; , o puede no aparecer en absoluto (si es opcional).</target>
        </trans-unit>
        <trans-unit id="3329d6139a17df5aa82ad5b8a51d8ca500fc2a29" translate="yes" xml:space="preserve">
          <source>is equivalent to this</source>
          <target state="translated">es equivalente a esto</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">es equivalente a:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a351948668a1fcb5487bf5eff7e9fd31790b9eb2" translate="yes" xml:space="preserve">
          <source>or even combine them like this:</source>
          <target state="translated">o incluso combinarlos de esta manera:</target>
        </trans-unit>
        <trans-unit id="4e84bc5fa8cf62a2ac1a2b230a64c8b9a9db925e" translate="yes" xml:space="preserve">
          <source>which would yield:</source>
          <target state="translated">...que se rendiría:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
