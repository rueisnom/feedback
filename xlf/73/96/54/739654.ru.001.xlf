<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/739654">
    <body>
      <group id="739654">
        <trans-unit id="7aa298487facfa7aa89c2a22cdd52ba7dc91da86" translate="yes" xml:space="preserve">
          <source>(Fun fact: &lt;code&gt;functools.wraps()&lt;/code&gt; is a decorator! ☺)</source>
          <target state="translated">(Интересный факт: &lt;code&gt;functools.wraps()&lt;/code&gt; - декоратор! ☺)</target>
        </trans-unit>
        <trans-unit id="ec945f8e517954ed7e4692ae6848ed84a9f6930f" translate="yes" xml:space="preserve">
          <source>...which should return:</source>
          <target state="translated">...который должен вернуться:</target>
        </trans-unit>
        <trans-unit id="3faa24506c65496ffae93e5003ddfce73c6eba64" translate="yes" xml:space="preserve">
          <source>65 &amp;lt;=&amp;gt; 'a'</source>
          <target state="translated">65 &amp;lt;=&amp;gt; 'а'</target>
        </trans-unit>
        <trans-unit id="afe8afb3504b20d32cc84ed5acd9acc2e68234b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino's answer&lt;/a&gt; has the great advantage of only using the stdlib, and works for this simple example where there are no &lt;em&gt;decorator&lt;/em&gt; arguments nor &lt;em&gt;decorated function&lt;/em&gt; arguments.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Ответ Паоло Бергантино&lt;/a&gt; имеет большое преимущество, заключающееся в использовании только stdlib, и работает для этого простого примера, где нет аргументов &lt;em&gt;декоратора или&lt;/em&gt; аргументов &lt;em&gt;декорированной функции&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="39c714204a40cb85b72f9b281dd635e38f398715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decopatch&lt;/code&gt; provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following:</source>
          <target state="translated">&lt;code&gt;decopatch&lt;/code&gt; предоставляет вам два других стиля разработки, которые скрывают или отображают различные концепции Python, в зависимости от ваших предпочтений. Самый компактный стиль выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="10817e8cbf2a8f8c871558bcbf7cba4e250496bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the big question:&lt;/strong&gt; What can I use decorators for?</source>
          <target state="translated">&lt;strong&gt;Теперь большой вопрос: для&lt;/strong&gt; чего я могу использовать декораторы?</target>
        </trans-unit>
        <trans-unit id="0e9207d4303034edd69e7d460d2e0f98665deab8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You cannot un-decorate a function.&lt;/strong&gt; (There &lt;em&gt;are&lt;/em&gt; hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it&amp;rsquo;s decorated &lt;em&gt;for all the code&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Вы не можете отменить декорацию функции.&lt;/strong&gt; (Существуют хаки для создания декораторов, которые можно удалить, но никто не использует их.) Поэтому, как только функция декорирована, она декорируется &lt;em&gt;для всего кода&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66212ac2a71bc0df84e94d800c5fc4470af8faf2" translate="yes" xml:space="preserve">
          <source>A decorator takes the function definition and creates a new function that executes this function and transforms the result.</source>
          <target state="translated">Декоратор берет определение функции и создает новую функцию,которая выполняет эту функцию и преобразует результат.</target>
        </trans-unit>
        <trans-unit id="cd8c02a403c82a2547a2a793d9ef26cd94680682" translate="yes" xml:space="preserve">
          <source>Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:</source>
          <target state="translated">В качестве альтернативы можно написать заводскую функцию,которая возвращает декоратор,обертывающий возвращаемое значение декорированной функции в тег,переданный заводской функции.Например:</target>
        </trans-unit>
        <trans-unit id="e2020432815d54b419eb1736a4714dda1093a358" translate="yes" xml:space="preserve">
          <source>An italics decorator could be like</source>
          <target state="translated">Декоратор с курсивом может быть как</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">А теперь..:</target>
        </trans-unit>
        <trans-unit id="fa8ef8ac0a9ff400ae17fa4ce35011055463e50d" translate="yes" xml:space="preserve">
          <source>And of course you can return lambdas as well from a decorator function:</source>
          <target state="translated">И,конечно же,вы можете вернуть баранину и с декоративной функции:</target>
        </trans-unit>
        <trans-unit id="e96a6693d5d4f88633cbc2a33e13e2a0d48f90da" translate="yes" xml:space="preserve">
          <source>Another interesting property of Python functions is they can be defined inside another function!</source>
          <target state="translated">Еще одним интересным свойством функций Python является то,что они могут быть определены внутри другой функции!</target>
        </trans-unit>
        <trans-unit id="c9450f3b037f9bb8f807346211bc2236317782c0" translate="yes" xml:space="preserve">
          <source>Another way of doing the same thing:</source>
          <target state="translated">Другой способ сделать то же самое:</target>
        </trans-unit>
        <trans-unit id="a0e3876948b2d3ad605eb008566ef83c5b67ca01" translate="yes" xml:space="preserve">
          <source>Anything else we saw recently that wrapped function?</source>
          <target state="translated">Что-нибудь еще,что мы видели недавно?</target>
        </trans-unit>
        <trans-unit id="950c70e94b9928cfcf9d7106401cb7cb2cef23d4" translate="yes" xml:space="preserve">
          <source>As a conclusion, you can easily see how to answer the question:</source>
          <target state="translated">В заключение,вы можете легко увидеть,как ответить на вопрос:</target>
        </trans-unit>
        <trans-unit id="620dffe2846f63bcd6945026a10272cd967f3d58" translate="yes" xml:space="preserve">
          <source>As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a &lt;em&gt;decorator factory&lt;/em&gt;&amp;mdash;in other words, a decorator function that makes other decorators. That way there would be less code repetition&amp;mdash;and allow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; principle to be followed.</source>
          <target state="translated">Как вы можете видеть, в этих двух декораторах много повторяющегося кода. Учитывая это сходство, было бы лучше вместо вас создать общий, который на самом деле был &lt;em&gt;фабрикой декораторов,&lt;/em&gt; другими словами, функцию декоратора, которая создает другие декораторы. Таким образом, будет меньше повторения кода и будет соблюдаться принцип &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abd19ad545dabf6d1e68777b92e162297c4ad254" translate="yes" xml:space="preserve">
          <source>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use &lt;code&gt;*args, **kwargs&lt;/code&gt; if you wish. But remember decorators are called &lt;strong&gt;only once&lt;/strong&gt;. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do &quot;import x&quot;, &lt;strong&gt;the function is already decorated&lt;/strong&gt;, so you can't
change anything.</source>
          <target state="translated">Как видите, вы можете передавать аргументы декоратору как любую функцию, используя этот трюк. Вы даже можете использовать &lt;code&gt;*args, **kwargs&lt;/code&gt; если хотите. Но помните, декораторы называются &lt;strong&gt;только один раз&lt;/strong&gt; . Просто когда Python импортирует скрипт. Вы не можете динамически устанавливать аргументы впоследствии. Когда вы делаете &amp;laquo;import x&amp;raquo;, &lt;strong&gt;функция уже оформлена&lt;/strong&gt; , поэтому вы ничего не можете изменить.</target>
        </trans-unit>
        <trans-unit id="2ae7d3dab77def1437b4c1c2a696d710ab1e1c5a" translate="yes" xml:space="preserve">
          <source>Before rushing to the solution, let&amp;rsquo;s write a little reminder:</source>
          <target state="translated">Прежде чем торопиться с решением, напишем небольшое напоминание:</target>
        </trans-unit>
        <trans-unit id="206a50a63dabbf1b2361c766ff1e3bb73ade5429" translate="yes" xml:space="preserve">
          <source>Best practices: decorators</source>
          <target state="translated">Передовая практика:декораторы</target>
        </trans-unit>
        <trans-unit id="5c5cf2ca4a0d4c3c42cb3df68a42305fe76df7ba" translate="yes" xml:space="preserve">
          <source>But we seem to have nearly lost the original function.</source>
          <target state="translated">Но,похоже,мы почти потеряли первоначальную функцию.</target>
        </trans-unit>
        <trans-unit id="dfad1322f6d290e904a701b70d67c393d4fa29c4" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;the documentation&lt;/a&gt; to see how decorators work. Here is what you asked for:</source>
          <target state="translated">Ознакомьтесь &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;с документацией,&lt;/a&gt; чтобы увидеть, как работают декораторы. Вот что вы просили:</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="bd9f92315d53d212a9dc77eec8576e4334c597c0" translate="yes" xml:space="preserve">
          <source>Decorate functions with different number of arguments:</source>
          <target state="translated">Декорировать функции с различным количеством аргументов:</target>
        </trans-unit>
        <trans-unit id="7514a0f4a85fc4cc4fca21d25add9ec96e9cffcb" translate="yes" xml:space="preserve">
          <source>Decorating methods</source>
          <target state="translated">Методы украшения</target>
        </trans-unit>
        <trans-unit id="1e4898de5bee34139a3f87dd9b517db79f32b352" translate="yes" xml:space="preserve">
          <source>Decorator Basics</source>
          <target state="translated">Основы декоратора</target>
        </trans-unit>
        <trans-unit id="aa70f4c0f7a0072ec8a62a6cba4e841875ee10e8" translate="yes" xml:space="preserve">
          <source>Decorators are just a pythonic variant of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;decorator design pattern&lt;/a&gt;. There are several classic design patterns embedded in Python to ease development (like iterators).</source>
          <target state="translated">Декораторы - это всего лишь питонический вариант &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;шаблона дизайна декоратора&lt;/a&gt; . Существует несколько классических шаблонов проектирования, встроенных в Python для упрощения разработки (например, итераторы).</target>
        </trans-unit>
        <trans-unit id="1960c6c3a393f8280a1557da87c5ae49cc49728f" translate="yes" xml:space="preserve">
          <source>Decorators are just syntactical sugar.</source>
          <target state="translated">Декораторы-это просто синтаксический сахар.</target>
        </trans-unit>
        <trans-unit id="e676466dac7ab2332c55066fac838c036e30a5f4" translate="yes" xml:space="preserve">
          <source>Decorators demystified</source>
          <target state="translated">Декораторы демистифицированы</target>
        </trans-unit>
        <trans-unit id="baaf86734e7519c8e5b9a287fdd51a09542a7a2f" translate="yes" xml:space="preserve">
          <source>Decorators slow down the function call. Keep that in mind.</source>
          <target state="translated">Декораторы замедляют вызов функции.Имейте это в виду.</target>
        </trans-unit>
        <trans-unit id="2b88592aafba3e2bb5d236b6157ec8f8c13f5d66" translate="yes" xml:space="preserve">
          <source>Decorators were introduced in Python 2.4, so be sure your code will be run on &amp;gt;= 2.4.</source>
          <target state="translated">Декораторы были введены в Python 2.4, поэтому убедитесь, что ваш код будет работать на&amp;gt; = 2.4.</target>
        </trans-unit>
        <trans-unit id="5068621933ab115670d1f879b688ce5fd62f2f83" translate="yes" xml:space="preserve">
          <source>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &amp;gt;= 2.5; see below.)</source>
          <target state="translated">Декораторы обертывают функции, которые могут затруднить их отладку. (Это улучшается в Python&amp;gt; = 2.5; см. Ниже.)</target>
        </trans-unit>
        <trans-unit id="7ecbff500103805264ec8d27bb1b00270113802a" translate="yes" xml:space="preserve">
          <source>Django uses decorators to manage caching and view permissions.</source>
          <target state="translated">Django использует декораторы для управления кэшированием и разрешениями на просмотр.</target>
        </trans-unit>
        <trans-unit id="ccfab1893a822fe4138fc5bf3a6aa54d78163c81" translate="yes" xml:space="preserve">
          <source>Don't forget the construction for which decorator syntax is a shorthand:</source>
          <target state="translated">Не забудьте про конструкцию,для которой синтаксис декоратора является сокращением:</target>
        </trans-unit>
        <trans-unit id="12c4ffe1d987164a4bedf6ab2aac597a113e181c" translate="yes" xml:space="preserve">
          <source>Efficiency</source>
          <target state="translated">Efficiency</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2c8c5c8eff80573c570fa19e7fbdbb5106e81f4d" translate="yes" xml:space="preserve">
          <source>For more on decorators, check
&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации о декораторах, посетите &lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f4aa69a5271cb03d99c15f1d53bdb53823e15db" translate="yes" xml:space="preserve">
          <source>For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as:</source>
          <target state="translated">С одной стороны,я думаю,что это делает поведение декораторов очень ясным,но с другой стороны,это позволяет легко определить новых декораторов очень лаконично.Для примера,приведенного выше,вы можете решить,как:</target>
        </trans-unit>
        <trans-unit id="b8be5d3c79e4970b1da1e51927bf0b5137e6d815" translate="yes" xml:space="preserve">
          <source>For similar reasons, the &lt;code&gt;functools.wraps&lt;/code&gt; decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (&lt;code&gt;func.__doc__&lt;/code&gt;) be those of the decorated function instead of &lt;code&gt;wrapped()&lt;/code&gt;'s.</source>
          <target state="translated">По тем же причинам декоратор &lt;code&gt;functools.wraps&lt;/code&gt; используется для изменения мета-атрибутов упакованной функции, чтобы они соответствовали атрибутам декорируемой функции. Это делает сообщения об ошибках и документацию встроенных функций ( &lt;code&gt;func.__doc__&lt;/code&gt; ) теми же, что и у украшенной функции вместо &lt;code&gt;wrapped()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61bbffc7a0ea6d9bf4052e3dc9914af60bc4775f" translate="yes" xml:space="preserve">
          <source>Full featured solution - overcoming most of these problems</source>
          <target state="translated">Полнофункциональное решение-преодоление большинства из этих проблем</target>
        </trans-unit>
        <trans-unit id="fb7e0637c4d5a6d73f637194c0246e331b6544bf" translate="yes" xml:space="preserve">
          <source>Functions references</source>
          <target state="translated">Функции ссылки</target>
        </trans-unit>
        <trans-unit id="d9429ca6d1142349d10e10a94576fffa86564438" translate="yes" xml:space="preserve">
          <source>Great, now what would you say about passing arguments to the decorator itself?</source>
          <target state="translated">Отлично,а теперь,что бы вы сказали о передаче аргументов самому декоратору?</target>
        </trans-unit>
        <trans-unit id="da0d931207acb9b41e89d340765036903cec4311" translate="yes" xml:space="preserve">
          <source>Handcrafted decorators</source>
          <target state="translated">декораторы ручной работы</target>
        </trans-unit>
        <trans-unit id="6c94ddf86de798e414a3de66543416eb33764543" translate="yes" xml:space="preserve">
          <source>Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.</source>
          <target state="translated">Вот простой пример цепочки декораторов.Обратите внимание на последнюю строку-она показывает,что происходит под крышками.</target>
        </trans-unit>
        <trans-unit id="879edad30080eeaee9e2cf7411d0c110780e7c60" translate="yes" xml:space="preserve">
          <source>Here it is: a decorator with arguments. Arguments can be set as variable:</source>
          <target state="translated">Вот он:декоратор с аргументами.Аргументы могут быть установлены как переменные:</target>
        </trans-unit>
        <trans-unit id="078d424ccacc316d41eb3c9e64c0a049566eda86" translate="yes" xml:space="preserve">
          <source>Hey, did you see that? We used a function call with the &quot;&lt;code&gt;@&lt;/code&gt;&quot; syntax! :-)</source>
          <target state="translated">Эй, ты видел это? Мы использовали вызов функции с синтаксисом &quot; &lt;code&gt;@&lt;/code&gt; &quot;! :-)</target>
        </trans-unit>
        <trans-unit id="a14b8e424350d415cdd48e9f09183de9ffb56f6f" translate="yes" xml:space="preserve">
          <source>How can I make two decorators in Python that would do the following?</source>
          <target state="translated">Как я могу сделать двух декораторов на Питоне,которые сделают следующее?</target>
        </trans-unit>
        <trans-unit id="12a65f2bbbb67ec061b91830c0f3852f397b8da4" translate="yes" xml:space="preserve">
          <source>How can the decorators be useful?</source>
          <target state="translated">Как могут быть полезны декораторы?</target>
        </trans-unit>
        <trans-unit id="b5614093ef277f04d2fcf8a8f6d17ab705e42f42" translate="yes" xml:space="preserve">
          <source>How to make a chain of function decorators</source>
          <target state="translated">Как сделать цепочку декораторов функции</target>
        </trans-unit>
        <trans-unit id="9c80cc9314ab160ba886800aef0563ac91482582" translate="yes" xml:space="preserve">
          <source>How you&amp;rsquo;d do it manually:</source>
          <target state="translated">Как бы вы сделали это вручную:</target>
        </trans-unit>
        <trans-unit id="4a1cc8e375a4ebd9b5ffc2959ee04c7e8d713115" translate="yes" xml:space="preserve">
          <source>However it has 3 major limitations if you want to tackle more general cases:</source>
          <target state="translated">Однако у него есть 3 основных ограничения,если вы хотите рассмотреть более общие случаи:</target>
        </trans-unit>
        <trans-unit id="1a3cd9a00b172fb82cc5ee4d2ed407fb3a1ac23e" translate="yes" xml:space="preserve">
          <source>I know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don't you feel good about mastering this?</source>
          <target state="translated">Я знаю,в последний раз у тебя было такое чувство,когда ты слушал,как парень говорит:&quot;Прежде чем понять рекурсию,ты должен сначала понять рекурсию&quot;.Но сейчас,разве ты не чувствуешь себя хорошо,когда осваиваешь это?</target>
        </trans-unit>
        <trans-unit id="726239257c85d745949f495cf86f83f7f3423958" translate="yes" xml:space="preserve">
          <source>I wrote &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;&lt;code&gt;decopatch&lt;/code&gt;&lt;/a&gt; to solve the first issue, and wrote &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt;&lt;code&gt;makefun.wraps&lt;/code&gt;&lt;/a&gt; to solve the other two. Note that &lt;code&gt;makefun&lt;/code&gt; leverages the same trick than the famous &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt;&lt;code&gt;decorator&lt;/code&gt;&lt;/a&gt; lib.</source>
          <target state="translated">Я написал &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt; &lt;code&gt;decopatch&lt;/code&gt; ,&lt;/a&gt; чтобы решить первую проблему, и написал &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt; &lt;code&gt;makefun.wraps&lt;/code&gt; ,&lt;/a&gt; чтобы решить две другие. Обратите внимание, что &lt;code&gt;makefun&lt;/code&gt; использует тот же трюк, что и известный &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt; &lt;code&gt;decorator&lt;/code&gt; &lt;/a&gt; lib.</target>
        </trans-unit>
        <trans-unit id="5d7696becef5ac38fad435088d0ecb76e8a0289a" translate="yes" xml:space="preserve">
          <source>I'm not trying to make &lt;code&gt;HTML&lt;/code&gt; this way in a real application - just trying to understand how decorators and decorator chaining works.</source>
          <target state="translated">Я не пытаюсь сделать &lt;code&gt;HTML&lt;/code&gt; таким способом в реальном приложении - просто пытаюсь понять, как работают декораторы и цепочки декораторов.</target>
        </trans-unit>
        <trans-unit id="1e0c463512620a7aa52516ce6954607005e44fad" translate="yes" xml:space="preserve">
          <source>If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.</source>
          <target state="translated">Если скорость декорированной функции важна,то накладные расходы можно удержать на одном дополнительном вызове функции,написав немного другую фабричную функцию декоратора,которая реализует добавление всех тегов одновременно,так что она может генерировать код,который позволяет избежать вызова дополнительных функций,связанных с использованием отдельных декораторов для каждого тега.</target>
        </trans-unit>
        <trans-unit id="7f5eb6d6e3ee8c4703ec52543976257f38262e16" translate="yes" xml:space="preserve">
          <source>If you are not into long explanations, see &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantino&amp;rsquo;s answer&lt;/a&gt;.</source>
          <target state="translated">Если у вас нет длинных объяснений, посмотрите &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;ответ Паоло Бергантино&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="317dfc8d065e9e0684a901257748d3a5167229f3" translate="yes" xml:space="preserve">
          <source>If you can &lt;code&gt;return&lt;/code&gt; a function, you can pass one as a parameter:</source>
          <target state="translated">Если вы можете &lt;code&gt;return&lt;/code&gt; функцию, вы можете передать ее в качестве параметра:</target>
        </trans-unit>
        <trans-unit id="48e4b22d8da3dfe34b25ed14a816e2633b2c5e3a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re making general-purpose decorator--one you&amp;rsquo;ll apply to any function or method, no matter its arguments--then just use &lt;code&gt;*args, **kwargs&lt;/code&gt;:</source>
          <target state="translated">Если вы создаете декоратор общего назначения - тот, который вы примените к любой функции или методу, независимо от его аргументов, - тогда просто используйте &lt;code&gt;*args, **kwargs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bef3f2c6067205cdab221b9850de1b292b160e38" translate="yes" xml:space="preserve">
          <source>In Python 3, you also get &lt;code&gt;__qualname__&lt;/code&gt; and &lt;code&gt;__annotations__&lt;/code&gt; assigned by default.</source>
          <target state="translated">В Python 3 вы также получаете &lt;code&gt;__qualname__&lt;/code&gt; и &lt;code&gt;__annotations__&lt;/code&gt; , назначенные по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f85fcf9dfd9a481037c239b8ac3cb04c0f757dbe" translate="yes" xml:space="preserve">
          <source>In both cases you can check that the decorator works as expected:</source>
          <target state="translated">В обоих случаях вы можете проверить,что декоратор работает,как и ожидалось:</target>
        </trans-unit>
        <trans-unit id="441b181831532dd1b1468f0beb612ec2adb9a6ac" translate="yes" xml:space="preserve">
          <source>It can be used as follows:</source>
          <target state="translated">Его можно использовать следующим образом:</target>
        </trans-unit>
        <trans-unit id="a2364cec8db742e16d44a56e4e97742669df4b53" translate="yes" xml:space="preserve">
          <source>It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it.</source>
          <target state="translated">Жаль,что есть еще какой-то шаблон,но это примерно так просто,как мы можем сделать это.</target>
        </trans-unit>
        <trans-unit id="d52aaab6a849e68c11a3c5f3892267606e5ba341" translate="yes" xml:space="preserve">
          <source>It looks like the other people have already told you how to solve the problem. I hope this will help you understand what decorators are.</source>
          <target state="translated">Похоже,что другие люди уже рассказали вам,как решить проблему.Надеюсь,это поможет вам понять,что такое декораторы.</target>
        </trans-unit>
        <trans-unit id="0a437594f7f26d9de32ed6e32daf8a7144562ec6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s exactly the same. &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot; is called. So when you &lt;code&gt;@my_decorator&lt;/code&gt;, you are telling Python to call the function 'labelled by the variable &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot;'.</source>
          <target state="translated">Это точно так же. &quot; &lt;code&gt;my_decorator&lt;/code&gt; &quot; называется. Поэтому, когда вы &lt;code&gt;@my_decorator&lt;/code&gt; , вы говорите Python вызвать функцию, &amp;laquo;помеченную переменной&amp;laquo; &lt;code&gt;my_decorator&lt;/code&gt; &amp;raquo;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7ce0ce68a04f2b66e2e819d56376b33b1a2e7a7e" translate="yes" xml:space="preserve">
          <source>Keep this in mind. We&amp;rsquo;ll circle back to it shortly.</source>
          <target state="translated">Имейте это в виду. Мы скоро вернемся к этому.</target>
        </trans-unit>
        <trans-unit id="4bceeb87ddeae7d32f5a461e830c4a01e1c2dbb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do EXACTLY the same thing, but skip all the pesky intermediate variables:</source>
          <target state="translated">Давайте сделаем точно то же самое, но пропустим все надоедливые промежуточные переменные:</target>
        </trans-unit>
        <trans-unit id="77a07d0b57a22cf6113918bd191c5b56c27d8347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get evil. ☺</source>
          <target state="translated">Давай получим зло. ☺</target>
        </trans-unit>
        <trans-unit id="78be7938d254badacf135b18dc6cc6c451c38c66" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s have some fun and write a decorator for the decorators:</source>
          <target state="translated">Давайте немного повеселимся и напишем декоратор для декораторов:</target>
        </trans-unit>
        <trans-unit id="27294f1ad34ef605ff9afc4e6f4c9ab75aadb8e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make it &lt;em&gt;even shorter&lt;/em&gt;:</source>
          <target state="translated">Давайте сделаем это &lt;em&gt;еще короче&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="cc604b7219e99c7ead3ddb49899ab7f07ac1541b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice: decorating a decorator</source>
          <target state="translated">Давайте потренируемся: украшать декоратор</target>
        </trans-unit>
        <trans-unit id="ca309b745c2658e0e7c0557696b22a6ed74f2b7c" translate="yes" xml:space="preserve">
          <source>No surprise here.</source>
          <target state="translated">Неудивительно.</target>
        </trans-unit>
        <trans-unit id="255ef6b7422b7ccfa19a20bfa097944e74cf3b94" translate="yes" xml:space="preserve">
          <source>Note that a function is defined inside a function.
What it basically does is replace a function with the newly defined one. For example, I have this class</source>
          <target state="translated">Обратите внимание,что функция определяется внутри функции.В основном она заменяет функцию на вновь определенную.Например,у меня есть такой класс</target>
        </trans-unit>
        <trans-unit id="2dc264a51f806548732cb077d81ae6952adc115e" translate="yes" xml:space="preserve">
          <source>Notice that this example didn't include the &lt;code&gt;list&lt;/code&gt; type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list.</source>
          <target state="translated">Обратите внимание, что в этом примере тип экземпляра не был включен в экземпляр декоратора, поэтому в последнем операторе print метод применяется к самому списку, а не к элементам списка.</target>
        </trans-unit>
        <trans-unit id="7d0d40184a1e365e8aec68153ce0e6264dbac917" translate="yes" xml:space="preserve">
          <source>Now say, I want both functions to print &quot;---&quot; after and before they are done.
I could add a print &quot;---&quot; before and after each print statement.
But because I don't like repeating myself, I will make a decorator</source>
          <target state="translated">Теперь скажите,что я хочу,чтобы обе функции печатали &quot;---&quot; после и до того,как они закончатся.Я мог бы добавлять &quot;---&quot; до и после каждого оператора печати.Но так как я не люблю повторять себя,я сделаю декоратора.</target>
        </trans-unit>
        <trans-unit id="6374db670ada8df89b3ba0c8efdc28f893467811" translate="yes" xml:space="preserve">
          <source>Now use them as desired:</source>
          <target state="translated">Теперь используйте их по желанию:</target>
        </trans-unit>
        <trans-unit id="0cb1ffaf9060bacf69b447f3baaca8c541d46cf1" translate="yes" xml:space="preserve">
          <source>Now, you probably want that every time you call &lt;code&gt;a_stand_alone_function&lt;/code&gt;, &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; is called instead. That&amp;rsquo;s easy, just overwrite &lt;code&gt;a_stand_alone_function&lt;/code&gt; with the function returned by &lt;code&gt;my_shiny_new_decorator&lt;/code&gt;:</source>
          <target state="translated">Теперь вы, вероятно, хотите, чтобы каждый раз, когда вы вызываете &lt;code&gt;a_stand_alone_function&lt;/code&gt; , вместо этого вызывается a_stand_alone_function_decorated . Это просто, просто перезапишите &lt;code&gt;a_stand_alone_function&lt;/code&gt; функцией, возвращаемой &lt;code&gt;my_shiny_new_decorator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40887ec7e652c1bdf57a41f57f0cb24e4ff2822b" translate="yes" xml:space="preserve">
          <source>Now: to answer the question...</source>
          <target state="translated">Теперь:чтобы ответить на вопрос...</target>
        </trans-unit>
        <trans-unit id="579d575c5ed4bac1f322abf77675f853665ad5bb" translate="yes" xml:space="preserve">
          <source>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:</source>
          <target state="translated">Конечно,с декораторами хорошо то,что их можно сразу же использовать практически на чем угодно,не переписывая.ДРИ,я сказал:</target>
        </trans-unit>
        <trans-unit id="1be3cbc92c16a773de95bc885b3fc9e99b4a6788" translate="yes" xml:space="preserve">
          <source>Of course, you can accumulate decorators:</source>
          <target state="translated">Конечно,можно накапливать декораторы:</target>
        </trans-unit>
        <trans-unit id="91a37b5d402fd2f9d6d6d0b09967c77439df7c5c" translate="yes" xml:space="preserve">
          <source>Oh yes, decorators!</source>
          <target state="translated">О да,декораторы!</target>
        </trans-unit>
        <trans-unit id="10957fc6e11cfdfbf98f8f5f5c0ad12c66b378d0" translate="yes" xml:space="preserve">
          <source>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.</source>
          <target state="translated">Хорошо,в качестве бонуса,я дам тебе фрагмент,чтобы заставить любого декоратора согласиться на любые аргументы.В конце концов,чтобы принять аргументы,мы создали наш декоратор с помощью другой функции.</target>
        </trans-unit>
        <trans-unit id="6bbd3347dd91397e5be987a0a88f7eff1abc0a3e" translate="yes" xml:space="preserve">
          <source>Okay, still here? Now the fun part...</source>
          <target state="translated">Хорошо,все еще здесь? Теперь самое интересное...</target>
        </trans-unit>
        <trans-unit id="56949a19e12ea95f6c3843043b9cdd359a9fb0c0" translate="yes" xml:space="preserve">
          <source>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (&lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">Отличная особенность Python в том, что методы и функции действительно одинаковы. Единственное отличие состоит в том, что методы ожидают, что их первый аргумент является ссылкой на текущий объект ( &lt;code&gt;self&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e0a663c8d21ccb65a769c61071c5d509abd2783" translate="yes" xml:space="preserve">
          <source>Or, more flexibly:</source>
          <target state="translated">Или,более гибко:</target>
        </trans-unit>
        <trans-unit id="2fb316fd9385ead51b295112e84edb25cd8b95b1" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorated function</source>
          <target state="translated">Передача аргументов на декорированную функцию</target>
        </trans-unit>
        <trans-unit id="24b163e0afbd75a6ca84ffb958862c256129d2de" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorator</source>
          <target state="translated">Передача аргументов декоратору</target>
        </trans-unit>
        <trans-unit id="17d426ae159ee05b9325ff80a8339b7de2e089f6" translate="yes" xml:space="preserve">
          <source>Personally I would have written the decorator somewhat differently:</source>
          <target state="translated">Лично я бы написал декоратору несколько иначе:</target>
        </trans-unit>
        <trans-unit id="c7b7f62e823e6869c5758a9786c02608bd932456" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">Пожалуйста, обратитесь к &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;документации&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="c10adc093e3b42e5c9bf392b6f6849c6dbd8218e" translate="yes" xml:space="preserve">
          <source>Problems with the simple solution</source>
          <target state="translated">Проблемы с простым решением</target>
        </trans-unit>
        <trans-unit id="6ed78550e4466481db863ec487bb1bd253cc35d3" translate="yes" xml:space="preserve">
          <source>Python decorators add extra functionality to another function</source>
          <target state="translated">Декораторы питона добавляют дополнительную функциональность к другой функции</target>
        </trans-unit>
        <trans-unit id="d1727d8a5520ad1a9627fdc2eab00abe2b5d6379" translate="yes" xml:space="preserve">
          <source>Python itself provides several decorators: &lt;code&gt;property&lt;/code&gt;, &lt;code&gt;staticmethod&lt;/code&gt;, etc.</source>
          <target state="translated">Сам Python предоставляет несколько декораторов: &lt;code&gt;property&lt;/code&gt; , &lt;code&gt;staticmethod&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="284cca9bb8bff3580e1d28d9004c90370ab5fc92" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s functions are objects</source>
          <target state="translated">Функции Python являются объектами</target>
        </trans-unit>
        <trans-unit id="0fb5d72701f71daeb5de4c55b12b5b28333babb4" translate="yes" xml:space="preserve">
          <source>Refinements</source>
          <target state="translated">Refinements</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="447529f8d79e74c1015331f703c4fd58c0024d0f" translate="yes" xml:space="preserve">
          <source>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it&amp;rsquo;s temporary).</source>
          <target state="translated">Кажется круто и мощно, но практический пример был бы великолепен. Ну, есть 1000 возможностей. Классическое использование расширяет поведение функции из внешней библиотеки (вы не можете ее изменить) или для отладки (вы не хотите изменять ее, потому что она временная).</target>
        </trans-unit>
        <trans-unit id="8190083ab834e9da2d9dcad17a07753d67081489" translate="yes" xml:space="preserve">
          <source>Simple solution</source>
          <target state="translated">Простое решение</target>
        </trans-unit>
        <trans-unit id="379eadfed2be4f0025e4f13911405915d77b0d61" translate="yes" xml:space="preserve">
          <source>So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.</source>
          <target state="translated">Так что если мы поставим документацию по этой функции,или захотим иметь возможность декорировать функции,которые принимают более одного аргумента,или мы просто захотим узнать,на какую функцию мы смотрим в отладочном сеансе,нам нужно сделать немного больше с нашей оберткой.</target>
        </trans-unit>
        <trans-unit id="1c60607379772605752445769cae451aa46faaba" translate="yes" xml:space="preserve">
          <source>So now I can change my class to</source>
          <target state="translated">Так что теперь я могу сменить класс на</target>
        </trans-unit>
        <trans-unit id="6cbe6521ca09a7746011901561de604aa6c89d3c" translate="yes" xml:space="preserve">
          <source>So now:</source>
          <target state="translated">Так что теперь:</target>
        </trans-unit>
        <trans-unit id="efb7b2d9e9ca503721dfb04f5dc4469198ba42fa" translate="yes" xml:space="preserve">
          <source>So we see that &lt;code&gt;wraps&lt;/code&gt; makes the wrapping function do almost everything except tell us exactly what the function takes as arguments.</source>
          <target state="translated">Итак, мы видим, что &lt;code&gt;wraps&lt;/code&gt; заставляет функцию wrapping выполнять почти все, кроме того, что она точно сообщает нам, что функция принимает в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="50cf77367001a751c11f1a93c8af87bfa1080df0" translate="yes" xml:space="preserve">
          <source>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?</source>
          <target state="translated">Итак,вернемся к декораторам с аргументами.Если мы можем использовать функции для генерации декоратора на лету,мы можем передать аргументы в эту функцию,не так ли?</target>
        </trans-unit>
        <trans-unit id="5cb9c55c987610f1d50dddd4525d5c7adbdde9f8" translate="yes" xml:space="preserve">
          <source>Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:</source>
          <target state="translated">Говоря о примере счетчика-как было сказано выше,счетчик будет разделен между всеми функциями,которые используют декоратор:</target>
        </trans-unit>
        <trans-unit id="96b98ca4ad50b3f8c62ee69fd0d15c5c564ba92c" translate="yes" xml:space="preserve">
          <source>Taking decorators to the next level</source>
          <target state="translated">Поднимая декораторов на новый уровень</target>
        </trans-unit>
        <trans-unit id="437612b73a9a61ff531195df2dfd1a552e3cd790" translate="yes" xml:space="preserve">
          <source>That means that &lt;strong&gt;a function can &lt;code&gt;return&lt;/code&gt; another function&lt;/strong&gt;.</source>
          <target state="translated">Это означает, что &lt;strong&gt;функция может &lt;code&gt;return&lt;/code&gt; другую функцию&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f298bfca0f195e40010a96673a464012e8d44e65" translate="yes" xml:space="preserve">
          <source>That means you can build a decorator for methods the same way! Just remember to take &lt;code&gt;self&lt;/code&gt; into consideration:</source>
          <target state="translated">Это означает, что вы можете создать декоратор для методов таким же образом! Просто не забудьте принять во внимание себя:</target>
        </trans-unit>
        <trans-unit id="050b7db66c47db53ba8a596842a9b2aa1e330633" translate="yes" xml:space="preserve">
          <source>That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt;), and the counter variable will remain private to each.</source>
          <target state="translated">Таким образом, ваш декоратор может быть повторно использован для разных функций (или использован для многократного декорирования одной и той же функции: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt; ), и переменная counter останется закрытой для каждой.</target>
        </trans-unit>
        <trans-unit id="5564267bef96d8c06f321659900ce4a65f09fbb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functools&lt;/code&gt; module was introduced in Python 2.5. It includes the function &lt;code&gt;functools.wraps()&lt;/code&gt;, which copies the name, module, and docstring of the decorated function to its wrapper.</source>
          <target state="translated">Модуль &lt;code&gt;functools&lt;/code&gt; был введен в Python 2.5. Он включает функцию &lt;code&gt;functools.wraps()&lt;/code&gt; , которая копирует имя, модуль и строку документации оформленной функции в свою оболочку.</target>
        </trans-unit>
        <trans-unit id="b96153d0cd80112477376110b277ba00b0b61985" translate="yes" xml:space="preserve">
          <source>The order you set the decorators MATTERS:</source>
          <target state="translated">Порядок,который вы устанавливаете декораторам MATTERS:</target>
        </trans-unit>
        <trans-unit id="ee3ecad5bd632505c874495ef908b5ccadff853d" translate="yes" xml:space="preserve">
          <source>The output looks like:</source>
          <target state="translated">Выход выглядит так:</target>
        </trans-unit>
        <trans-unit id="c333dc4fec82663d8c79348d8fc54c67a7a233bc" translate="yes" xml:space="preserve">
          <source>The previous example, using the decorator syntax:</source>
          <target state="translated">Предыдущий пример,с использованием синтаксиса декоратора:</target>
        </trans-unit>
        <trans-unit id="960b2fe36e68117facc37e06febe129a38132041" translate="yes" xml:space="preserve">
          <source>There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.</source>
          <target state="translated">Есть и другие модули,которые могут попытаться решить эту проблему,но решения еще нет в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="af9cac89e15b8a4e52d28cb0c6dc344f017cf8ab" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s more!</source>
          <target state="translated">Есть еще кое-что!</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b5039e57d9fc37a75f36b953d9898eff7500a6b9" translate="yes" xml:space="preserve">
          <source>This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact.</source>
          <target state="translated">На этот ответ уже давно ответили,но я подумал,что мог бы поделиться со мной своим классом декораторов,который делает написание новых декораторов легким и компактным.</target>
        </trans-unit>
        <trans-unit id="2904fc69aef6f7ec13cb9a23a39932c544deb84c" translate="yes" xml:space="preserve">
          <source>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function&amp;rsquo;s arguments directly to the decorator.</source>
          <target state="translated">Это может быть несколько искажено, поскольку декоратор должен принимать функцию в качестве аргумента. Следовательно, вы не можете передавать аргументы декорированной функции напрямую декоратору.</target>
        </trans-unit>
        <trans-unit id="a2c775a862081edfd042f2470df626fc3eef6aa4" translate="yes" xml:space="preserve">
          <source>This enables you to write:</source>
          <target state="translated">Это позволяет тебе писать:</target>
        </trans-unit>
        <trans-unit id="0b1c1e381424a38b2424282c1fa352f40d278095" translate="yes" xml:space="preserve">
          <source>This is how you would create a decorator with arguments, returning truly signature-preserving wrappers:</source>
          <target state="translated">Так вы создадите декоратора с аргументами,возвращая обертки,действительно сохраняющие подпись:</target>
        </trans-unit>
        <trans-unit id="ce42d5743ee1866f5dc731830ebf5ed5afa194eb" translate="yes" xml:space="preserve">
          <source>This is important! The label you give can point directly to the decorator&amp;mdash;&lt;strong&gt;or not&lt;/strong&gt;.</source>
          <target state="translated">Это важно! Ярлык, который вы даете, может указывать непосредственно на декоратора - &lt;strong&gt;или нет&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5027fb5d3093f380441a1296b10193eb568104dd" translate="yes" xml:space="preserve">
          <source>This really is a large playground.</source>
          <target state="translated">Это действительно большая игровая площадка.</target>
        </trans-unit>
        <trans-unit id="1fd557f5cb363c1aff4438192da3019b9a577767" translate="yes" xml:space="preserve">
          <source>This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using &lt;code&gt;lambda&lt;/code&gt; functions as previously illustrated. Sample:</source>
          <target state="translated">Для этого требуется больше кода в самом декораторе, но он выполняется только тогда, когда он применяется к определениям функций, а не позже, когда они сами вызываются. Это также применяется при создании более удобочитаемых имен с использованием &lt;code&gt;lambda&lt;/code&gt; функций, как показано ранее. Образец:</target>
        </trans-unit>
        <trans-unit id="a8eaf579c4f258b33b0482ef3b7df54778820469" translate="yes" xml:space="preserve">
          <source>To explain the decorator in a simple way:</source>
          <target state="translated">Чтобы объяснить декоратору простым способом:</target>
        </trans-unit>
        <trans-unit id="473f07947e0fd95c8d023c615f35b4d07297397e" translate="yes" xml:space="preserve">
          <source>To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other:</source>
          <target state="translated">Чтобы найти его,нам нужно будет покопаться в замыкании каждой лямбды,одна из которых похоронена в другой:</target>
        </trans-unit>
        <trans-unit id="d05d323aa64f59be265e5a87806a41e0c825210f" translate="yes" xml:space="preserve">
          <source>To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:</source>
          <target state="translated">Чтобы сделать код более читаемым,можно присвоить декораторам,созданным на заводе,более описательное название:</target>
        </trans-unit>
        <trans-unit id="883de3fa331a806ddd7c7652ca1e49092c7971b4" translate="yes" xml:space="preserve">
          <source>To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:</source>
          <target state="translated">Чтобы сделать это проще всего,сделайте декораторы,которые возвращают лямбды (анонимные функции),которые закрываются над функцией (закрываются),и вызовите их:</target>
        </trans-unit>
        <trans-unit id="62f4218b8c6ef484c2f1975f99215aea59a557d9" translate="yes" xml:space="preserve">
          <source>To return:</source>
          <target state="translated">Вернуться:</target>
        </trans-unit>
        <trans-unit id="bd12f2d27cd71bb3463350185fcfc9d61abd15f6" translate="yes" xml:space="preserve">
          <source>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let&amp;rsquo;s see why with a simple example :</source>
          <target state="translated">Чтобы понять декораторы, вы должны сначала понять, что функции - это объекты в Python. Это имеет важные последствия. Давайте посмотрим, почему на простом примере:</target>
        </trans-unit>
        <trans-unit id="196f074c1d92f9ced554dc60521c54d33c9ca742" translate="yes" xml:space="preserve">
          <source>To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result.</source>
          <target state="translated">Чтобы понять декоратора,важно заметить,что декоратор создал новую функцию do,которая является внутренней,которая выполняет функцию и преобразует результат.</target>
        </trans-unit>
        <trans-unit id="60902dc77861b8c1fdfaf6268a2464fa22de1ceb" translate="yes" xml:space="preserve">
          <source>Twisted to fake inlining asynchronous functions calls.</source>
          <target state="translated">Витой,чтобы подделать встраиваемые вызовы асинхронных функций.</target>
        </trans-unit>
        <trans-unit id="c77a8f9b1468c11516a914ac6de3a49735219779" translate="yes" xml:space="preserve">
          <source>Using the Python decorator syntax:</source>
          <target state="translated">Используя синтаксис декораторов Питона:</target>
        </trans-unit>
        <trans-unit id="aa9cefd3355dfbb169969e4d070840477e8f3574" translate="yes" xml:space="preserve">
          <source>We have the decorator &lt;code&gt;wraps&lt;/code&gt; from the &lt;code&gt;functools&lt;/code&gt; module in the standard library!</source>
          <target state="translated">У нас есть &lt;code&gt;wraps&lt;/code&gt; декоратора из модуля &lt;code&gt;functools&lt;/code&gt; в стандартной библиотеке!</target>
        </trans-unit>
        <trans-unit id="e7828a39d26d60430dd896cb93790f6a849e80c7" translate="yes" xml:space="preserve">
          <source>We wrapped the decorator.</source>
          <target state="translated">Мы завернули декоратора.</target>
        </trans-unit>
        <trans-unit id="fe01beda96c243b61696dcac93827863db70a633" translate="yes" xml:space="preserve">
          <source>Well, you just have everything needed to understand decorators. You see, decorators are &amp;ldquo;wrappers&amp;rdquo;, which means that &lt;strong&gt;they let you execute code before and after the function they decorate&lt;/strong&gt; without modifying the function itself.</source>
          <target state="translated">Ну, у вас просто есть все необходимое для понимания декораторов. Видите ли, декораторы являются &amp;laquo;обертками&amp;raquo;, что означает, что &lt;strong&gt;они позволяют вам выполнять код до и после функции, которую они декорируют,&lt;/strong&gt; без изменения самой функции.</target>
        </trans-unit>
        <trans-unit id="e60ee3faedca029b522b5766bd4fef43e46646de" translate="yes" xml:space="preserve">
          <source>When do:</source>
          <target state="translated">Когда?</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">Какие отпечатки:</target>
        </trans-unit>
        <trans-unit id="0f59d388d686c4bb98639de68bb575c3f2e8c1b3" translate="yes" xml:space="preserve">
          <source>While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).</source>
          <target state="translated">В то время как вышеприведенные примеры выполняют всю работу,генерируемый код требует значительных накладных расходов в виде посторонних вызовов функций при одновременном применении нескольких декораторов.Это может не иметь значения,в зависимости от точного использования (которое может быть связано,например,с IO).</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="80931ea7fb9f9baaccc7db7989d6b55cd34a1502" translate="yes" xml:space="preserve">
          <source>Yes, that&amp;rsquo;s all, it&amp;rsquo;s that simple. &lt;code&gt;@decorator&lt;/code&gt; is just a shortcut to:</source>
          <target state="translated">Да, это все, это так просто. &lt;code&gt;@decorator&lt;/code&gt; - это просто ярлык для:</target>
        </trans-unit>
        <trans-unit id="82aa4bf8798112112023c3bf62cf028a41534be3" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; make two separate decorators that do what you want as illustrated directly below. Note the use of &lt;code&gt;*args, **kwargs&lt;/code&gt; in the declaration of the &lt;code&gt;wrapped()&lt;/code&gt; function which supports the decorated function having multiple arguments (which isn't really necessary for the example &lt;code&gt;say()&lt;/code&gt; function, but is included for generality).</source>
          <target state="translated">Вы &lt;em&gt;можете&lt;/em&gt; сделать два отдельных декоратора, которые будут делать то, что вы хотите, как показано ниже. Обратите внимание на использование &lt;code&gt;*args, **kwargs&lt;/code&gt; в объявлении функции &lt;code&gt;wrapped()&lt;/code&gt; которая поддерживает декорированную функцию, имеющую несколько аргументов (что на самом деле не обязательно для функции &lt;code&gt;say()&lt;/code&gt; примера, но включено для общности).</target>
        </trans-unit>
        <trans-unit id="3fcf6e6cdbd43a4541ee6fee7299941830fb61da" translate="yes" xml:space="preserve">
          <source>You can also write decorator in Class</source>
          <target state="translated">Вы также можете написать декоратора в классе</target>
        </trans-unit>
        <trans-unit id="e0a9ddf317ada0cb0975c84b1b3a3350e91427a6" translate="yes" xml:space="preserve">
          <source>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.</source>
          <target state="translated">Теперь вы можете просто уйти счастливым,или сжечь свой мозг немного больше и увидеть продвинутое использование декораторов.</target>
        </trans-unit>
        <trans-unit id="50c0158657b192fc0e1e92b4b42743e823b5581b" translate="yes" xml:space="preserve">
          <source>You can use them to extend several functions in a DRY&amp;rsquo;s way, like so:</source>
          <target state="translated">Вы можете использовать их для расширения нескольких функций в режиме СУХОГО, например, так:</target>
        </trans-unit>
        <trans-unit id="eb12aebb78c3f68a3b62316d71c4c613fca73470" translate="yes" xml:space="preserve">
          <source>You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator:</source>
          <target state="translated">Вы также можете использовать его для выполнения более сложных задач,таких как,например,декоратор,который автоматически заставляет функцию рекурсивно применять ее ко всем аргументам в итераторе:</target>
        </trans-unit>
        <trans-unit id="2ecc0fab1db96d14074c26f8bc8f79f84ec79ac0" translate="yes" xml:space="preserve">
          <source>You really do:</source>
          <target state="translated">Правда:</target>
        </trans-unit>
        <trans-unit id="e81544690dadca1e7c105c62bc3929aebc31d34d" translate="yes" xml:space="preserve">
          <source>You want the following function, when called:</source>
          <target state="translated">Вам нужна следующая функция,при вызове:</target>
        </trans-unit>
        <trans-unit id="953873baa875246b6189da13ed630a79eb5fb0e9" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve seen that functions are objects. Therefore, functions:</source>
          <target state="translated">Вы видели, что функции являются объектами. Следовательно, функции:</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">и сейчас:</target>
        </trans-unit>
        <trans-unit id="cafef07857121c9781de270f85e3951e33ef3a0f" translate="yes" xml:space="preserve">
          <source>as already noted in several answers, you can not easily modify the code to &lt;strong&gt;add optional decorator arguments&lt;/strong&gt;. For example creating a &lt;code&gt;makestyle(style='bold')&lt;/code&gt; decorator is non-trivial.</source>
          <target state="translated">как уже отмечалось в нескольких ответах, вы не можете легко изменить код, &lt;strong&gt;добавив необязательные аргументы декоратора&lt;/strong&gt; . Например, создание &lt;code&gt;makestyle(style='bold')&lt;/code&gt; нетривиально.</target>
        </trans-unit>
        <trans-unit id="810b76f64a3518b6640d265928755185623d443d" translate="yes" xml:space="preserve">
          <source>besides, wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt;&lt;strong&gt;do not preserve the signature&lt;/strong&gt;, so if bad arguments are provided they will start executing, and might raise a different kind of error than the usual &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">кроме того, оболочки, созданные с помощью &lt;code&gt;@functools.wraps&lt;/code&gt; &lt;strong&gt;, не сохраняют подпись&lt;/strong&gt; , поэтому, если предоставлены неверные аргументы, они начнут выполняться и могут вызвать ошибку другого типа, чем обычная ошибка &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="278b019b92e03f8c6d596bdc96fa24cef85ab67c" translate="yes" xml:space="preserve">
          <source>can be assigned to a variable</source>
          <target state="translated">может быть присвоен переменной</target>
        </trans-unit>
        <trans-unit id="990c222d7e553798fcdfee2e5fa3c3d0fc120879" translate="yes" xml:space="preserve">
          <source>can be defined in another function</source>
          <target state="translated">может быть определено в другой функции</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">распространиться до</target>
        </trans-unit>
        <trans-unit id="ccdbc5352040835da410ff1c10cbf69f8c83982f" translate="yes" xml:space="preserve">
          <source>finally, it is quite difficult in wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt; to &lt;strong&gt;access an argument based on its name&lt;/strong&gt;. Indeed the argument can appear in &lt;code&gt;*args&lt;/code&gt;, in &lt;code&gt;**kwargs&lt;/code&gt;, or may not appear at all (if it is optional).</source>
          <target state="translated">наконец, в оболочках, созданных с помощью &lt;code&gt;@functools.wraps&lt;/code&gt; довольно сложно &lt;strong&gt;получить доступ к аргументу, основанному на его имени&lt;/strong&gt; . Действительно, аргумент может появляться в &lt;code&gt;*args&lt;/code&gt; , в &lt;code&gt;**kwargs&lt;/code&gt; или может не появляться вообще (если это необязательно).</target>
        </trans-unit>
        <trans-unit id="3329d6139a17df5aa82ad5b8a51d8ca500fc2a29" translate="yes" xml:space="preserve">
          <source>is equivalent to this</source>
          <target state="translated">равносильно этому</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">эквивалентно:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a351948668a1fcb5487bf5eff7e9fd31790b9eb2" translate="yes" xml:space="preserve">
          <source>or even combine them like this:</source>
          <target state="translated">или даже соединить их вот так:</target>
        </trans-unit>
        <trans-unit id="4e84bc5fa8cf62a2ac1a2b230a64c8b9a9db925e" translate="yes" xml:space="preserve">
          <source>which would yield:</source>
          <target state="translated">что уступило бы:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
