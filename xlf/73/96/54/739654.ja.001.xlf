<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/739654">
    <body>
      <group id="739654">
        <trans-unit id="7aa298487facfa7aa89c2a22cdd52ba7dc91da86" translate="yes" xml:space="preserve">
          <source>(Fun fact: &lt;code&gt;functools.wraps()&lt;/code&gt; is a decorator! ☺)</source>
          <target state="translated">（楽しい事実： &lt;code&gt;functools.wraps()&lt;/code&gt; はデコレータです！ ☺ ）</target>
        </trans-unit>
        <trans-unit id="ec945f8e517954ed7e4692ae6848ed84a9f6930f" translate="yes" xml:space="preserve">
          <source>...which should return:</source>
          <target state="translated">...戻ってくるはずです。</target>
        </trans-unit>
        <trans-unit id="3faa24506c65496ffae93e5003ddfce73c6eba64" translate="yes" xml:space="preserve">
          <source>65 &amp;lt;=&amp;gt; 'a'</source>
          <target state="translated">65 &amp;lt;=&amp;gt; 'a'</target>
        </trans-unit>
        <trans-unit id="afe8afb3504b20d32cc84ed5acd9acc2e68234b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantino's answer&lt;/a&gt; has the great advantage of only using the stdlib, and works for this simple example where there are no &lt;em&gt;decorator&lt;/em&gt; arguments nor &lt;em&gt;decorated function&lt;/em&gt; arguments.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/739665/7262247&quot;&gt;Paolo Bergantinoの回答に&lt;/a&gt;は、stdlibのみを使用するという大きな利点があり、 &lt;em&gt;デコレーター&lt;/em&gt;引数も&lt;em&gt;装飾された関数&lt;/em&gt;引数もないこの単純な例で&lt;em&gt;機能し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="39c714204a40cb85b72f9b281dd635e38f398715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decopatch&lt;/code&gt; provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following:</source>
          <target state="translated">&lt;code&gt;decopatch&lt;/code&gt; は、好みに応じて、さまざまなpythonの概念を非表示または表示する他の2つの開発スタイルを提供します。 最もコンパクトなスタイルは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="10817e8cbf2a8f8c871558bcbf7cba4e250496bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now the big question:&lt;/strong&gt; What can I use decorators for?</source>
          <target state="translated">&lt;strong&gt;さて、大きな質問&lt;/strong&gt;です。デコレーターは何に使用できますか？</target>
        </trans-unit>
        <trans-unit id="0e9207d4303034edd69e7d460d2e0f98665deab8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You cannot un-decorate a function.&lt;/strong&gt; (There &lt;em&gt;are&lt;/em&gt; hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it&amp;rsquo;s decorated &lt;em&gt;for all the code&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;関数の装飾を解除することはできません。&lt;/strong&gt; （削除できるデコレーターを作成するハックはありますが、誰も使用しません。）したがって、関数が装飾さ&lt;em&gt;れると、すべてのコードに対して&lt;/em&gt;装飾さ&lt;em&gt;れます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="66212ac2a71bc0df84e94d800c5fc4470af8faf2" translate="yes" xml:space="preserve">
          <source>A decorator takes the function definition and creates a new function that executes this function and transforms the result.</source>
          <target state="translated">デコレータは、関数の定義を受け取り、この関数を実行して結果を変換する新しい関数を作成します。</target>
        </trans-unit>
        <trans-unit id="cd8c02a403c82a2547a2a793d9ef26cd94680682" translate="yes" xml:space="preserve">
          <source>Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:</source>
          <target state="translated">あるいは、装飾された関数の戻り値をファクトリー関数に渡されたタグでラップするデコレータを返すファクトリー関数を書くこともできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e2020432815d54b419eb1736a4714dda1093a358" translate="yes" xml:space="preserve">
          <source>An italics decorator could be like</source>
          <target state="translated">イタリック体のデコレータは、次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="3eeed83f3bdbae4049cbd25b068c143d33dc373a" translate="yes" xml:space="preserve">
          <source>And now:</source>
          <target state="translated">そして今。</target>
        </trans-unit>
        <trans-unit id="fa8ef8ac0a9ff400ae17fa4ce35011055463e50d" translate="yes" xml:space="preserve">
          <source>And of course you can return lambdas as well from a decorator function:</source>
          <target state="translated">もちろんデコレータ関数からもラムダを返すことができます。</target>
        </trans-unit>
        <trans-unit id="e96a6693d5d4f88633cbc2a33e13e2a0d48f90da" translate="yes" xml:space="preserve">
          <source>Another interesting property of Python functions is they can be defined inside another function!</source>
          <target state="translated">Pythonの関数のもう一つの興味深い特性は、別の関数の中で定義できることです。</target>
        </trans-unit>
        <trans-unit id="c9450f3b037f9bb8f807346211bc2236317782c0" translate="yes" xml:space="preserve">
          <source>Another way of doing the same thing:</source>
          <target state="translated">同じことをする別の方法。</target>
        </trans-unit>
        <trans-unit id="a0e3876948b2d3ad605eb008566ef83c5b67ca01" translate="yes" xml:space="preserve">
          <source>Anything else we saw recently that wrapped function?</source>
          <target state="translated">最近見た機能をラップさせたものは?</target>
        </trans-unit>
        <trans-unit id="950c70e94b9928cfcf9d7106401cb7cb2cef23d4" translate="yes" xml:space="preserve">
          <source>As a conclusion, you can easily see how to answer the question:</source>
          <target state="translated">結論から言うと、どのように答えればいいのかがすぐにわかります。</target>
        </trans-unit>
        <trans-unit id="620dffe2846f63bcd6945026a10272cd967f3d58" translate="yes" xml:space="preserve">
          <source>As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a &lt;em&gt;decorator factory&lt;/em&gt;&amp;mdash;in other words, a decorator function that makes other decorators. That way there would be less code repetition&amp;mdash;and allow the &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRY&lt;/a&gt; principle to be followed.</source>
          <target state="translated">ご覧のとおり、これらの2つのデコレータには重複したコードがたくさんあります。 この類似性を考えると、実際には&lt;em&gt;デコレータファクトリで&lt;/em&gt;ある一般的なもの、つまり、他のデコレータを作成するデコレータ関数を作成する方がよいでしょう。 そうすれば、コードの繰り返しが少なくなり、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Don't_repeat_yourself&quot;&gt;DRYの&lt;/a&gt;原則に従うことができます。</target>
        </trans-unit>
        <trans-unit id="abd19ad545dabf6d1e68777b92e162297c4ad254" translate="yes" xml:space="preserve">
          <source>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use &lt;code&gt;*args, **kwargs&lt;/code&gt; if you wish. But remember decorators are called &lt;strong&gt;only once&lt;/strong&gt;. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do &quot;import x&quot;, &lt;strong&gt;the function is already decorated&lt;/strong&gt;, so you can't
change anything.</source>
          <target state="translated">ご覧のとおり、このトリックを使用する関数のように、デコレータに引数を渡すことができます。 必要に応じて &lt;code&gt;*args, **kwargs&lt;/code&gt; 使用することもできます。 ただし、デコレータは&lt;strong&gt;一度だけ&lt;/strong&gt;呼び出されることを忘れ&lt;strong&gt;ないでください&lt;/strong&gt; 。 Pythonがスクリプトをインポートしたとき。 後で引数を動的に設定することはできません。 「import x」を実行すると&lt;strong&gt;、関数は既に装飾されている&lt;/strong&gt;ため、何も変更できません。</target>
        </trans-unit>
        <trans-unit id="2ae7d3dab77def1437b4c1c2a696d710ab1e1c5a" translate="yes" xml:space="preserve">
          <source>Before rushing to the solution, let&amp;rsquo;s write a little reminder:</source>
          <target state="translated">ソリューションに取り掛かる前に、少しリマインダーを書いてみましょう：</target>
        </trans-unit>
        <trans-unit id="206a50a63dabbf1b2361c766ff1e3bb73ade5429" translate="yes" xml:space="preserve">
          <source>Best practices: decorators</source>
          <target state="translated">ベストプラクティス:デコレーター</target>
        </trans-unit>
        <trans-unit id="5c5cf2ca4a0d4c3c42cb3df68a42305fe76df7ba" translate="yes" xml:space="preserve">
          <source>But we seem to have nearly lost the original function.</source>
          <target state="translated">しかし、本来の機能を失いかけているようです。</target>
        </trans-unit>
        <trans-unit id="dfad1322f6d290e904a701b70d67c393d4fa29c4" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;the documentation&lt;/a&gt; to see how decorators work. Here is what you asked for:</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function&quot;&gt;ドキュメント&lt;/a&gt;をチェックして、デコレータの動作を確認してください。 ここにあなたが求めたものがあります：</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="bd9f92315d53d212a9dc77eec8576e4334c597c0" translate="yes" xml:space="preserve">
          <source>Decorate functions with different number of arguments:</source>
          <target state="translated">引数の数が異なる関数をデコレーションします。</target>
        </trans-unit>
        <trans-unit id="7514a0f4a85fc4cc4fca21d25add9ec96e9cffcb" translate="yes" xml:space="preserve">
          <source>Decorating methods</source>
          <target state="translated">飾り付けの方法</target>
        </trans-unit>
        <trans-unit id="1e4898de5bee34139a3f87dd9b517db79f32b352" translate="yes" xml:space="preserve">
          <source>Decorator Basics</source>
          <target state="translated">デコレーターの基礎知識</target>
        </trans-unit>
        <trans-unit id="aa70f4c0f7a0072ec8a62a6cba4e841875ee10e8" translate="yes" xml:space="preserve">
          <source>Decorators are just a pythonic variant of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;decorator design pattern&lt;/a&gt;. There are several classic design patterns embedded in Python to ease development (like iterators).</source>
          <target state="translated">デコレータは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;デコレータデザインパターンの&lt;/a&gt; pythonicバリアントです。 Pythonには、（イテレータのように）開発を容易にするためにいくつかの古典的なデザインパターンが埋め込まれています。</target>
        </trans-unit>
        <trans-unit id="1960c6c3a393f8280a1557da87c5ae49cc49728f" translate="yes" xml:space="preserve">
          <source>Decorators are just syntactical sugar.</source>
          <target state="translated">デコレーターはただの構文上の糖質だからな</target>
        </trans-unit>
        <trans-unit id="e676466dac7ab2332c55066fac838c036e30a5f4" translate="yes" xml:space="preserve">
          <source>Decorators demystified</source>
          <target state="translated">デコレーターの神秘化</target>
        </trans-unit>
        <trans-unit id="baaf86734e7519c8e5b9a287fdd51a09542a7a2f" translate="yes" xml:space="preserve">
          <source>Decorators slow down the function call. Keep that in mind.</source>
          <target state="translated">デコレーターは関数の呼び出しが遅くなります。それを念頭に置いてください。</target>
        </trans-unit>
        <trans-unit id="2b88592aafba3e2bb5d236b6157ec8f8c13f5d66" translate="yes" xml:space="preserve">
          <source>Decorators were introduced in Python 2.4, so be sure your code will be run on &amp;gt;= 2.4.</source>
          <target state="translated">デコレーターはPython 2.4で導入されたので、コードが2.4以上で実行されるようにしてください。</target>
        </trans-unit>
        <trans-unit id="5068621933ab115670d1f879b688ce5fd62f2f83" translate="yes" xml:space="preserve">
          <source>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &amp;gt;= 2.5; see below.)</source>
          <target state="translated">デコレータは関数をラップするため、デバッグが難しくなります。 （これはPython&amp;gt; = 2.5で改善されます。以下を参照してください。）</target>
        </trans-unit>
        <trans-unit id="7ecbff500103805264ec8d27bb1b00270113802a" translate="yes" xml:space="preserve">
          <source>Django uses decorators to manage caching and view permissions.</source>
          <target state="translated">Django はデコレータを使ってキャッシュやビューのパーミッションを管理しています。</target>
        </trans-unit>
        <trans-unit id="ccfab1893a822fe4138fc5bf3a6aa54d78163c81" translate="yes" xml:space="preserve">
          <source>Don't forget the construction for which decorator syntax is a shorthand:</source>
          <target state="translated">デコレータ構文が略語になっている構造を忘れてはいけません。</target>
        </trans-unit>
        <trans-unit id="12c4ffe1d987164a4bedf6ab2aac597a113e181c" translate="yes" xml:space="preserve">
          <source>Efficiency</source>
          <target state="translated">Efficiency</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2c8c5c8eff80573c570fa19e7fbdbb5106e81f4d" translate="yes" xml:space="preserve">
          <source>For more on decorators, check
&lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&lt;/a&gt;</source>
          <target state="translated">デコレーターについて詳しくは、 &lt;a href=&quot;http://www.ibm.com/developerworks/linux/library/l-cpdecor.html&quot;&gt;http：//www.ibm.com/developerworks/linux/library/l-cpdecor.htmlを&lt;/a&gt;確認してください</target>
        </trans-unit>
        <trans-unit id="8f4aa69a5271cb03d99c15f1d53bdb53823e15db" translate="yes" xml:space="preserve">
          <source>For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as:</source>
          <target state="translated">一つには、これはデコレータの動作を非常に明確にしていると思いますが、新しいデコレータを非常に簡潔に定義することも容易になります。上記の例では、次のように解くことができます。</target>
        </trans-unit>
        <trans-unit id="b8be5d3c79e4970b1da1e51927bf0b5137e6d815" translate="yes" xml:space="preserve">
          <source>For similar reasons, the &lt;code&gt;functools.wraps&lt;/code&gt; decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (&lt;code&gt;func.__doc__&lt;/code&gt;) be those of the decorated function instead of &lt;code&gt;wrapped()&lt;/code&gt;'s.</source>
          <target state="translated">同様の理由で、 &lt;code&gt;functools.wraps&lt;/code&gt; デコレーターを使用して、ラップされた関数のメタ属性を、装飾される関数のメタ属性に変更します。 これにより、エラーメッセージと埋め込み関数のドキュメント（ &lt;code&gt;func.__doc__&lt;/code&gt; ）は、 &lt;code&gt;wrapped()&lt;/code&gt; ではなく、装飾された関数のものになります。</target>
        </trans-unit>
        <trans-unit id="61bbffc7a0ea6d9bf4052e3dc9914af60bc4775f" translate="yes" xml:space="preserve">
          <source>Full featured solution - overcoming most of these problems</source>
          <target state="translated">フル機能のソリューション-これらの問題のほとんどを克服する</target>
        </trans-unit>
        <trans-unit id="fb7e0637c4d5a6d73f637194c0246e331b6544bf" translate="yes" xml:space="preserve">
          <source>Functions references</source>
          <target state="translated">関数リファレンス</target>
        </trans-unit>
        <trans-unit id="d9429ca6d1142349d10e10a94576fffa86564438" translate="yes" xml:space="preserve">
          <source>Great, now what would you say about passing arguments to the decorator itself?</source>
          <target state="translated">いいですね、ではデコレータ自身に引数を渡すことについてはどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="da0d931207acb9b41e89d340765036903cec4311" translate="yes" xml:space="preserve">
          <source>Handcrafted decorators</source>
          <target state="translated">手作りのデコレーター</target>
        </trans-unit>
        <trans-unit id="6c94ddf86de798e414a3de66543416eb33764543" translate="yes" xml:space="preserve">
          <source>Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.</source>
          <target state="translated">ここでは、装飾品を連鎖させる簡単な例を紹介します。最後の行に注意してください-それはカバーの下で何が起こっているかを示しています。</target>
        </trans-unit>
        <trans-unit id="879edad30080eeaee9e2cf7411d0c110780e7c60" translate="yes" xml:space="preserve">
          <source>Here it is: a decorator with arguments. Arguments can be set as variable:</source>
          <target state="translated">引数を持つデコレータです。引数は変数として設定できます。</target>
        </trans-unit>
        <trans-unit id="078d424ccacc316d41eb3c9e64c0a049566eda86" translate="yes" xml:space="preserve">
          <source>Hey, did you see that? We used a function call with the &quot;&lt;code&gt;@&lt;/code&gt;&quot; syntax! :-)</source>
          <target state="translated">ねえ、あなたはそれを見ましたか？ 「 &lt;code&gt;@&lt;/code&gt; 」構文の関数呼び出しを使用しました！ :-)</target>
        </trans-unit>
        <trans-unit id="a14b8e424350d415cdd48e9f09183de9ffb56f6f" translate="yes" xml:space="preserve">
          <source>How can I make two decorators in Python that would do the following?</source>
          <target state="translated">Pythonで以下のようなデコレータを2つ作るにはどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="12a65f2bbbb67ec061b91830c0f3852f397b8da4" translate="yes" xml:space="preserve">
          <source>How can the decorators be useful?</source>
          <target state="translated">デコレーターはどうすれば便利なのか?</target>
        </trans-unit>
        <trans-unit id="b5614093ef277f04d2fcf8a8f6d17ab705e42f42" translate="yes" xml:space="preserve">
          <source>How to make a chain of function decorators</source>
          <target state="translated">機能デコレーターのチェーンの作り方</target>
        </trans-unit>
        <trans-unit id="9c80cc9314ab160ba886800aef0563ac91482582" translate="yes" xml:space="preserve">
          <source>How you&amp;rsquo;d do it manually:</source>
          <target state="translated">手動で行う方法：</target>
        </trans-unit>
        <trans-unit id="4a1cc8e375a4ebd9b5ffc2959ee04c7e8d713115" translate="yes" xml:space="preserve">
          <source>However it has 3 major limitations if you want to tackle more general cases:</source>
          <target state="translated">しかし、より一般的なケースに取り組みたい場合は、それは3つの大きな制限があります。</target>
        </trans-unit>
        <trans-unit id="1a3cd9a00b172fb82cc5ee4d2ed407fb3a1ac23e" translate="yes" xml:space="preserve">
          <source>I know, the last time you had this feeling, it was after listening a guy saying: &quot;before understanding recursion, you must first understand recursion&quot;. But now, don't you feel good about mastering this?</source>
          <target state="translated">最後にこの感覚を味わったのは...ある男の言葉を聞いた後だったな &quot;「再帰を理解する前に、まず再帰を理解しなければならない」と言っていたのを聞いた後のことです。でも、今は、これをマスターした時の気持ちよさを感じませんか?</target>
        </trans-unit>
        <trans-unit id="726239257c85d745949f495cf86f83f7f3423958" translate="yes" xml:space="preserve">
          <source>I wrote &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;&lt;code&gt;decopatch&lt;/code&gt;&lt;/a&gt; to solve the first issue, and wrote &lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt;&lt;code&gt;makefun.wraps&lt;/code&gt;&lt;/a&gt; to solve the other two. Note that &lt;code&gt;makefun&lt;/code&gt; leverages the same trick than the famous &lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt;&lt;code&gt;decorator&lt;/code&gt;&lt;/a&gt; lib.</source>
          <target state="translated">最初の問題を解決するために&lt;a href=&quot;https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers&quot;&gt; &lt;code&gt;makefun.wraps&lt;/code&gt; &lt;/a&gt;を作成し、他の2つを解決するためにmakefun.wrapsを作成しました。 &lt;code&gt;makefun&lt;/code&gt; は有名な&lt;a href=&quot;https://github.com/micheles/decorator&quot;&gt; &lt;code&gt;decorator&lt;/code&gt; &lt;/a&gt; libと同じトリックを利用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d7696becef5ac38fad435088d0ecb76e8a0289a" translate="yes" xml:space="preserve">
          <source>I'm not trying to make &lt;code&gt;HTML&lt;/code&gt; this way in a real application - just trying to understand how decorators and decorator chaining works.</source>
          <target state="translated">私は実際のアプリケーションでこのように &lt;code&gt;HTML&lt;/code&gt; を作成しようとしているのではなく、デコレータとデコレータチェーンのしくみを理解しようとしています。</target>
        </trans-unit>
        <trans-unit id="1e0c463512620a7aa52516ce6954607005e44fad" translate="yes" xml:space="preserve">
          <source>If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.</source>
          <target state="translated">デコレーション関数の速度が重要な場合は、すべてのタグを一度に追加することを実装した、少し異なるデコレータファクトリ関数を書くことで、オーバーヘッドを1回の余分な関数呼び出しに抑えることができ、タグごとに別々のデコレータを使用することで発生する追加関数呼び出しを回避するコードを生成することができます。</target>
        </trans-unit>
        <trans-unit id="7f5eb6d6e3ee8c4703ec52543976257f38262e16" translate="yes" xml:space="preserve">
          <source>If you are not into long explanations, see &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantino&amp;rsquo;s answer&lt;/a&gt;.</source>
          <target state="translated">長い説明に詳しくない場合は、 &lt;a href=&quot;https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665&quot;&gt;Paolo Bergantinoの回答を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="317dfc8d065e9e0684a901257748d3a5167229f3" translate="yes" xml:space="preserve">
          <source>If you can &lt;code&gt;return&lt;/code&gt; a function, you can pass one as a parameter:</source>
          <target state="translated">関数を &lt;code&gt;return&lt;/code&gt; ことができる場合は、パラメータとして渡すことができます。</target>
        </trans-unit>
        <trans-unit id="48e4b22d8da3dfe34b25ed14a816e2633b2c5e3a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re making general-purpose decorator--one you&amp;rsquo;ll apply to any function or method, no matter its arguments--then just use &lt;code&gt;*args, **kwargs&lt;/code&gt;:</source>
          <target state="translated">汎用のデコレータ（引数に関係なく任意の関数またはメソッドに適用されるデコレータ）を作成する場合は、 &lt;code&gt;*args, **kwargs&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="bef3f2c6067205cdab221b9850de1b292b160e38" translate="yes" xml:space="preserve">
          <source>In Python 3, you also get &lt;code&gt;__qualname__&lt;/code&gt; and &lt;code&gt;__annotations__&lt;/code&gt; assigned by default.</source>
          <target state="translated">Python 3では、デフォルトで &lt;code&gt;__qualname__&lt;/code&gt; と &lt;code&gt;__annotations__&lt;/code&gt; も割り当てられます。</target>
        </trans-unit>
        <trans-unit id="f85fcf9dfd9a481037c239b8ac3cb04c0f757dbe" translate="yes" xml:space="preserve">
          <source>In both cases you can check that the decorator works as expected:</source>
          <target state="translated">どちらの場合も、デコレータが期待通りに動作することを確認することができます。</target>
        </trans-unit>
        <trans-unit id="441b181831532dd1b1468f0beb612ec2adb9a6ac" translate="yes" xml:space="preserve">
          <source>It can be used as follows:</source>
          <target state="translated">以下のように使用することができます。</target>
        </trans-unit>
        <trans-unit id="a2364cec8db742e16d44a56e4e97742669df4b53" translate="yes" xml:space="preserve">
          <source>It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it.</source>
          <target state="translated">まだまだボイチャがあるのは残念ですが、これくらいの簡単なものは作れそうです。</target>
        </trans-unit>
        <trans-unit id="d52aaab6a849e68c11a3c5f3892267606e5ba341" translate="yes" xml:space="preserve">
          <source>It looks like the other people have already told you how to solve the problem. I hope this will help you understand what decorators are.</source>
          <target state="translated">他の方が解決方法を教えてくれているようですね。これを参考にデコレーターとは何かを理解していただければと思います。</target>
        </trans-unit>
        <trans-unit id="0a437594f7f26d9de32ed6e32daf8a7144562ec6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s exactly the same. &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot; is called. So when you &lt;code&gt;@my_decorator&lt;/code&gt;, you are telling Python to call the function 'labelled by the variable &quot;&lt;code&gt;my_decorator&lt;/code&gt;&quot;'.</source>
          <target state="translated">まったく同じです。 「 &lt;code&gt;my_decorator&lt;/code&gt; 」が呼び出されます。 つまり、 &lt;code&gt;@my_decorator&lt;/code&gt; 場合、Pythonに「変数「 &lt;code&gt;my_decorator&lt;/code&gt; 」でラベル付けされた」関数を呼び出すように指示しています。</target>
        </trans-unit>
        <trans-unit id="7ce0ce68a04f2b66e2e819d56376b33b1a2e7a7e" translate="yes" xml:space="preserve">
          <source>Keep this in mind. We&amp;rsquo;ll circle back to it shortly.</source>
          <target state="translated">これを覚えておいてください。 すぐに戻ります。</target>
        </trans-unit>
        <trans-unit id="4bceeb87ddeae7d32f5a461e830c4a01e1c2dbb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do EXACTLY the same thing, but skip all the pesky intermediate variables:</source>
          <target state="translated">まったく同じことをしましょう。ただし、厄介な中間変数はすべてスキップします。</target>
        </trans-unit>
        <trans-unit id="77a07d0b57a22cf6113918bd191c5b56c27d8347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get evil. ☺</source>
          <target state="translated">悪を手に入れましょう。 ☺</target>
        </trans-unit>
        <trans-unit id="78be7938d254badacf135b18dc6cc6c451c38c66" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s have some fun and write a decorator for the decorators:</source>
          <target state="translated">楽しみながら、デコレータのデコレータを書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="27294f1ad34ef605ff9afc4e6f4c9ab75aadb8e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make it &lt;em&gt;even shorter&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;さらに短くし&lt;/em&gt;ましょう：</target>
        </trans-unit>
        <trans-unit id="cc604b7219e99c7ead3ddb49899ab7f07ac1541b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s practice: decorating a decorator</source>
          <target state="translated">練習しましょう：デコレーターの装飾</target>
        </trans-unit>
        <trans-unit id="ca309b745c2658e0e7c0557696b22a6ed74f2b7c" translate="yes" xml:space="preserve">
          <source>No surprise here.</source>
          <target state="translated">ここでは驚きはありません。</target>
        </trans-unit>
        <trans-unit id="255ef6b7422b7ccfa19a20bfa097944e74cf3b94" translate="yes" xml:space="preserve">
          <source>Note that a function is defined inside a function.
What it basically does is replace a function with the newly defined one. For example, I have this class</source>
          <target state="translated">関数は関数の中で定義されていることに注意してください。基本的に何をするかというと、関数を新しく定義されたものに置き換えることです。例えば、次のようなクラスがあります。</target>
        </trans-unit>
        <trans-unit id="2dc264a51f806548732cb077d81ae6952adc115e" translate="yes" xml:space="preserve">
          <source>Notice that this example didn't include the &lt;code&gt;list&lt;/code&gt; type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list.</source>
          <target state="translated">この例では、デコレータのインスタンス化に &lt;code&gt;list&lt;/code&gt; タイプが含まれていないため、最後のprintステートメントでは、メソッドはリストの要素ではなくリスト自体に適用されます。</target>
        </trans-unit>
        <trans-unit id="7d0d40184a1e365e8aec68153ce0e6264dbac917" translate="yes" xml:space="preserve">
          <source>Now say, I want both functions to print &quot;---&quot; after and before they are done.
I could add a print &quot;---&quot; before and after each print statement.
But because I don't like repeating myself, I will make a decorator</source>
          <target state="translated">さて、両方の関数が終わった後とその前に &quot;---&quot; を表示したいとします。それぞれのprint文の前後にprint &quot;---&quot;を追加することができます。しかし、私は自分自身を繰り返すのが好きではないので、デコレータ</target>
        </trans-unit>
        <trans-unit id="6374db670ada8df89b3ba0c8efdc28f893467811" translate="yes" xml:space="preserve">
          <source>Now use them as desired:</source>
          <target state="translated">あとはお好みでお使いください。</target>
        </trans-unit>
        <trans-unit id="0cb1ffaf9060bacf69b447f3baaca8c541d46cf1" translate="yes" xml:space="preserve">
          <source>Now, you probably want that every time you call &lt;code&gt;a_stand_alone_function&lt;/code&gt;, &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; is called instead. That&amp;rsquo;s easy, just overwrite &lt;code&gt;a_stand_alone_function&lt;/code&gt; with the function returned by &lt;code&gt;my_shiny_new_decorator&lt;/code&gt;:</source>
          <target state="translated">ここで、おそらく &lt;code&gt;a_stand_alone_function&lt;/code&gt; を呼び出すたびに 、代わりに &lt;code&gt;a_stand_alone_function_decorated&lt;/code&gt; が呼び出されるようにする必要があります。 これは簡単です &lt;code&gt;a_stand_alone_function&lt;/code&gt; 返された関数でa_stand_alone_functionを上書きするだけ &lt;code&gt;my_shiny_new_decorator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40887ec7e652c1bdf57a41f57f0cb24e4ff2822b" translate="yes" xml:space="preserve">
          <source>Now: to answer the question...</source>
          <target state="translated">さて:質問に答えるために...</target>
        </trans-unit>
        <trans-unit id="579d575c5ed4bac1f322abf77675f853665ad5bb" translate="yes" xml:space="preserve">
          <source>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:</source>
          <target state="translated">もちろんデコレーターの良いところは、書き換えなしでほとんどのものにすぐに使えることです。DRYと言いました。</target>
        </trans-unit>
        <trans-unit id="1be3cbc92c16a773de95bc885b3fc9e99b4a6788" translate="yes" xml:space="preserve">
          <source>Of course, you can accumulate decorators:</source>
          <target state="translated">もちろん、デコレーターを溜めておくこともできます。</target>
        </trans-unit>
        <trans-unit id="91a37b5d402fd2f9d6d6d0b09967c77439df7c5c" translate="yes" xml:space="preserve">
          <source>Oh yes, decorators!</source>
          <target state="translated">そうだ、デコレーターだ!</target>
        </trans-unit>
        <trans-unit id="10957fc6e11cfdfbf98f8f5f5c0ad12c66b378d0" translate="yes" xml:space="preserve">
          <source>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.</source>
          <target state="translated">さて、おまけとして、どんなデコレータでも一般的にどんな引数も受け付けるようにするためのスニペットをあげよう。結局のところ、引数を受け入れるために、別の関数を使ってデコレータを作成しました。</target>
        </trans-unit>
        <trans-unit id="6bbd3347dd91397e5be987a0a88f7eff1abc0a3e" translate="yes" xml:space="preserve">
          <source>Okay, still here? Now the fun part...</source>
          <target state="translated">よし、まだか?さて、お楽しみは...</target>
        </trans-unit>
        <trans-unit id="56949a19e12ea95f6c3843043b9cdd359a9fb0c0" translate="yes" xml:space="preserve">
          <source>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (&lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">Pythonの気の利いた点の1つは、メソッドと関数がまったく同じであることです。 唯一の違いは、メソッドは最初の引数が現在のオブジェクト（ &lt;code&gt;self&lt;/code&gt; ）への参照であることを想定していることです。</target>
        </trans-unit>
        <trans-unit id="7e0a663c8d21ccb65a769c61071c5d509abd2783" translate="yes" xml:space="preserve">
          <source>Or, more flexibly:</source>
          <target state="translated">というか、もっと柔軟に。</target>
        </trans-unit>
        <trans-unit id="2fb316fd9385ead51b295112e84edb25cd8b95b1" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorated function</source>
          <target state="translated">デコレーションされた関数に引数を渡す</target>
        </trans-unit>
        <trans-unit id="24b163e0afbd75a6ca84ffb958862c256129d2de" translate="yes" xml:space="preserve">
          <source>Passing arguments to the decorator</source>
          <target state="translated">デコレータに引数を渡す</target>
        </trans-unit>
        <trans-unit id="17d426ae159ee05b9325ff80a8339b7de2e089f6" translate="yes" xml:space="preserve">
          <source>Personally I would have written the decorator somewhat differently:</source>
          <target state="translated">個人的には、デコレーターの書き方が多少違っていても良かったかなと思います。</target>
        </trans-unit>
        <trans-unit id="c7b7f62e823e6869c5758a9786c02608bd932456" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">詳細については、 &lt;a href=&quot;https://smarie.github.io/python-decopatch/&quot;&gt;ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c10adc093e3b42e5c9bf392b6f6849c6dbd8218e" translate="yes" xml:space="preserve">
          <source>Problems with the simple solution</source>
          <target state="translated">シンプルな解法の問題点</target>
        </trans-unit>
        <trans-unit id="6ed78550e4466481db863ec487bb1bd253cc35d3" translate="yes" xml:space="preserve">
          <source>Python decorators add extra functionality to another function</source>
          <target state="translated">Pythonのデコレータは、別の関数に追加機能を追加します。</target>
        </trans-unit>
        <trans-unit id="d1727d8a5520ad1a9627fdc2eab00abe2b5d6379" translate="yes" xml:space="preserve">
          <source>Python itself provides several decorators: &lt;code&gt;property&lt;/code&gt;, &lt;code&gt;staticmethod&lt;/code&gt;, etc.</source>
          <target state="translated">Python自体がいくつかのデコレータを提供しています： &lt;code&gt;property&lt;/code&gt; 、 &lt;code&gt;staticmethod&lt;/code&gt; など。</target>
        </trans-unit>
        <trans-unit id="284cca9bb8bff3580e1d28d9004c90370ab5fc92" translate="yes" xml:space="preserve">
          <source>Python&amp;rsquo;s functions are objects</source>
          <target state="translated">Pythonの関数はオブジェクトです</target>
        </trans-unit>
        <trans-unit id="0fb5d72701f71daeb5de4c55b12b5b28333babb4" translate="yes" xml:space="preserve">
          <source>Refinements</source>
          <target state="translated">Refinements</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="447529f8d79e74c1015331f703c4fd58c0024d0f" translate="yes" xml:space="preserve">
          <source>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it&amp;rsquo;s temporary).</source>
          <target state="translated">クールでパワフルに見えますが、実用的な例は素晴らしいでしょう。 まあ、1000の可能性があります。 古典的な使用法は、外部のlibから関数の動作を拡張する（変更できない）、またはデバッグする（一時的なものであるため変更しない）ことです。</target>
        </trans-unit>
        <trans-unit id="8190083ab834e9da2d9dcad17a07753d67081489" translate="yes" xml:space="preserve">
          <source>Simple solution</source>
          <target state="translated">シンプルな解決策</target>
        </trans-unit>
        <trans-unit id="379eadfed2be4f0025e4f13911405915d77b0d61" translate="yes" xml:space="preserve">
          <source>So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.</source>
          <target state="translated">そのため、この関数にドキュメントを作成したり、複数の引数を取る関数をデコレーションできるようにしたり、デバッグセッションでどの関数を見ているのかを知りたい場合は、ラッパーでもう少し工夫する必要があります。</target>
        </trans-unit>
        <trans-unit id="1c60607379772605752445769cae451aa46faaba" translate="yes" xml:space="preserve">
          <source>So now I can change my class to</source>
          <target state="translated">ということで、クラスを</target>
        </trans-unit>
        <trans-unit id="6cbe6521ca09a7746011901561de604aa6c89d3c" translate="yes" xml:space="preserve">
          <source>So now:</source>
          <target state="translated">だから今。</target>
        </trans-unit>
        <trans-unit id="efb7b2d9e9ca503721dfb04f5dc4469198ba42fa" translate="yes" xml:space="preserve">
          <source>So we see that &lt;code&gt;wraps&lt;/code&gt; makes the wrapping function do almost everything except tell us exactly what the function takes as arguments.</source>
          <target state="translated">したがって、 &lt;code&gt;wraps&lt;/code&gt; を使用すると、ラッピング関数がほとんどすべてを実行することがわかります。</target>
        </trans-unit>
        <trans-unit id="50cf77367001a751c11f1a93c8af87bfa1080df0" translate="yes" xml:space="preserve">
          <source>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?</source>
          <target state="translated">さて、引数を持つデコレータの話に戻ります。関数を使ってその場でデコレータを生成できるのであれば、その関数に引数を渡すことができますよね?</target>
        </trans-unit>
        <trans-unit id="5cb9c55c987610f1d50dddd4525d5c7adbdde9f8" translate="yes" xml:space="preserve">
          <source>Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:</source>
          <target state="translated">カウンタの例といえば-上で述べたように、カウンタはデコレータを使用するすべての関数間で共有されます。</target>
        </trans-unit>
        <trans-unit id="96b98ca4ad50b3f8c62ee69fd0d15c5c564ba92c" translate="yes" xml:space="preserve">
          <source>Taking decorators to the next level</source>
          <target state="translated">デコレーターを次のレベルに引き上げる</target>
        </trans-unit>
        <trans-unit id="437612b73a9a61ff531195df2dfd1a552e3cd790" translate="yes" xml:space="preserve">
          <source>That means that &lt;strong&gt;a function can &lt;code&gt;return&lt;/code&gt; another function&lt;/strong&gt;.</source>
          <target state="translated">つまり&lt;strong&gt;、関数は別の関数を &lt;code&gt;return&lt;/code&gt; ことができます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f298bfca0f195e40010a96673a464012e8d44e65" translate="yes" xml:space="preserve">
          <source>That means you can build a decorator for methods the same way! Just remember to take &lt;code&gt;self&lt;/code&gt; into consideration:</source>
          <target state="translated">つまり、同じ方法でメソッドのデコレータを構築できるということです。 &lt;code&gt;self&lt;/code&gt; を考慮に入れることを忘れないでください：</target>
        </trans-unit>
        <trans-unit id="050b7db66c47db53ba8a596842a9b2aa1e330633" translate="yes" xml:space="preserve">
          <source>That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt;), and the counter variable will remain private to each.</source>
          <target state="translated">そうすることで、デコレーターをさまざまな関数に再利用でき（または、同じ関数を複数回デコレーションするために使用できます： &lt;code&gt;func_counter1 = counter(func); func_counter2 = counter(func)&lt;/code&gt; ）、カウンター変数はそれぞれにプライベートのままです。</target>
        </trans-unit>
        <trans-unit id="5564267bef96d8c06f321659900ce4a65f09fbb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;functools&lt;/code&gt; module was introduced in Python 2.5. It includes the function &lt;code&gt;functools.wraps()&lt;/code&gt;, which copies the name, module, and docstring of the decorated function to its wrapper.</source>
          <target state="translated">&lt;code&gt;functools&lt;/code&gt; モジュールはPython 2.5で導入されました。 関数 &lt;code&gt;functools.wraps()&lt;/code&gt; が含まれています。これは、 装飾された関数の名前、モジュール、およびdocstringをラッパーにコピーします。</target>
        </trans-unit>
        <trans-unit id="b96153d0cd80112477376110b277ba00b0b61985" translate="yes" xml:space="preserve">
          <source>The order you set the decorators MATTERS:</source>
          <target state="translated">デコレーターを設定する順番は重要です。</target>
        </trans-unit>
        <trans-unit id="ee3ecad5bd632505c874495ef908b5ccadff853d" translate="yes" xml:space="preserve">
          <source>The output looks like:</source>
          <target state="translated">出力はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="c333dc4fec82663d8c79348d8fc54c67a7a233bc" translate="yes" xml:space="preserve">
          <source>The previous example, using the decorator syntax:</source>
          <target state="translated">先ほどの例では、デコレータ構文を使用しています。</target>
        </trans-unit>
        <trans-unit id="960b2fe36e68117facc37e06febe129a38132041" translate="yes" xml:space="preserve">
          <source>There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.</source>
          <target state="translated">この問題に取り組もうとするモジュールは他にもありますが、解決策はまだ標準ライブラリにはありません。</target>
        </trans-unit>
        <trans-unit id="af9cac89e15b8a4e52d28cb0c6dc344f017cf8ab" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s more!</source>
          <target state="translated">もっとあります！</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b5039e57d9fc37a75f36b953d9898eff7500a6b9" translate="yes" xml:space="preserve">
          <source>This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact.</source>
          <target state="translated">この答えは長くなりましたが、新しいデコレータを簡単にコンパクトに書けるデコレータクラスを共有しようと思いました。</target>
        </trans-unit>
        <trans-unit id="2904fc69aef6f7ec13cb9a23a39932c544deb84c" translate="yes" xml:space="preserve">
          <source>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function&amp;rsquo;s arguments directly to the decorator.</source>
          <target state="translated">デコレータは関数を引数として受け入れなければならないので、これは多少ねじれる可能性があります。 したがって、装飾された関数の引数を直接デコレータに渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="a2c775a862081edfd042f2470df626fc3eef6aa4" translate="yes" xml:space="preserve">
          <source>This enables you to write:</source>
          <target state="translated">これで書けるようになりました。</target>
        </trans-unit>
        <trans-unit id="0b1c1e381424a38b2424282c1fa352f40d278095" translate="yes" xml:space="preserve">
          <source>This is how you would create a decorator with arguments, returning truly signature-preserving wrappers:</source>
          <target state="translated">このようにして引数を持つデコレータを作成し、真にシグネチャを保持するラッパーを返します。</target>
        </trans-unit>
        <trans-unit id="ce42d5743ee1866f5dc731830ebf5ed5afa194eb" translate="yes" xml:space="preserve">
          <source>This is important! The label you give can point directly to the decorator&amp;mdash;&lt;strong&gt;or not&lt;/strong&gt;.</source>
          <target state="translated">これは重要！ 付与するラベルは、デコレータを直接指すこともできます。</target>
        </trans-unit>
        <trans-unit id="5027fb5d3093f380441a1296b10193eb568104dd" translate="yes" xml:space="preserve">
          <source>This really is a large playground.</source>
          <target state="translated">これは本当に広い遊び場です。</target>
        </trans-unit>
        <trans-unit id="1fd557f5cb363c1aff4438192da3019b9a577767" translate="yes" xml:space="preserve">
          <source>This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using &lt;code&gt;lambda&lt;/code&gt; functions as previously illustrated. Sample:</source>
          <target state="translated">これにはデコレータ自体にさらに多くのコードが必要ですが、これは関数定義に適用されているときにのみ実行され、後でそれら自体が呼び出されたときに実行されません。 これは、前述の &lt;code&gt;lambda&lt;/code&gt; 関数を使用して、より読みやすい名前を作成する場合にも当てはまります。 サンプル：</target>
        </trans-unit>
        <trans-unit id="a8eaf579c4f258b33b0482ef3b7df54778820469" translate="yes" xml:space="preserve">
          <source>To explain the decorator in a simple way:</source>
          <target state="translated">デコレーターを簡単に説明すると</target>
        </trans-unit>
        <trans-unit id="473f07947e0fd95c8d023c615f35b4d07297397e" translate="yes" xml:space="preserve">
          <source>To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other:</source>
          <target state="translated">それを見つけるためには ラムダの閉鎖を 掘り下げる必要があります そのうちの一つが他の場所に 埋まっています</target>
        </trans-unit>
        <trans-unit id="d05d323aa64f59be265e5a87806a41e0c825210f" translate="yes" xml:space="preserve">
          <source>To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:</source>
          <target state="translated">コードをより読みやすくするために、工場で生成されたデコレータに、より説明的な名前を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="883de3fa331a806ddd7c7652ca1e49092c7971b4" translate="yes" xml:space="preserve">
          <source>To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:</source>
          <target state="translated">これを最も簡単に行うには、関数(クロージャ)の上に閉じるランブダ(匿名関数)を返し、それを呼び出すデコレータを作ります。</target>
        </trans-unit>
        <trans-unit id="62f4218b8c6ef484c2f1975f99215aea59a557d9" translate="yes" xml:space="preserve">
          <source>To return:</source>
          <target state="translated">戻るために。</target>
        </trans-unit>
        <trans-unit id="bd12f2d27cd71bb3463350185fcfc9d61abd15f6" translate="yes" xml:space="preserve">
          <source>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let&amp;rsquo;s see why with a simple example :</source>
          <target state="translated">デコレーターを理解するには、まず関数がPythonのオブジェクトであることを理解する必要があります。 これには重要な結果があります。 簡単な例で理由を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="196f074c1d92f9ced554dc60521c54d33c9ca742" translate="yes" xml:space="preserve">
          <source>To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result.</source>
          <target state="translated">デコレータを理解する上で重要なことは、デコレータが関数を実行して結果を変換する内側の関数doを新たに作成したことです。</target>
        </trans-unit>
        <trans-unit id="60902dc77861b8c1fdfaf6268a2464fa22de1ceb" translate="yes" xml:space="preserve">
          <source>Twisted to fake inlining asynchronous functions calls.</source>
          <target state="translated">非同期関数の呼び出しをインライン化するために捻じ曲げられています。</target>
        </trans-unit>
        <trans-unit id="c77a8f9b1468c11516a914ac6de3a49735219779" translate="yes" xml:space="preserve">
          <source>Using the Python decorator syntax:</source>
          <target state="translated">Pythonのデコレータ構文を使用します。</target>
        </trans-unit>
        <trans-unit id="aa9cefd3355dfbb169969e4d070840477e8f3574" translate="yes" xml:space="preserve">
          <source>We have the decorator &lt;code&gt;wraps&lt;/code&gt; from the &lt;code&gt;functools&lt;/code&gt; module in the standard library!</source>
          <target state="translated">標準ライブラリの &lt;code&gt;functools&lt;/code&gt; モジュールからのデコレータ &lt;code&gt;wraps&lt;/code&gt; があります！</target>
        </trans-unit>
        <trans-unit id="e7828a39d26d60430dd896cb93790f6a849e80c7" translate="yes" xml:space="preserve">
          <source>We wrapped the decorator.</source>
          <target state="translated">飾りをラッピングしました。</target>
        </trans-unit>
        <trans-unit id="fe01beda96c243b61696dcac93827863db70a633" translate="yes" xml:space="preserve">
          <source>Well, you just have everything needed to understand decorators. You see, decorators are &amp;ldquo;wrappers&amp;rdquo;, which means that &lt;strong&gt;they let you execute code before and after the function they decorate&lt;/strong&gt; without modifying the function itself.</source>
          <target state="translated">まあ、あなたはデコレータを理解するために必要なすべてを持っています。 デコレーターは「ラッパー」です。つまり、デコレーターは、関数自体を変更せずに&lt;strong&gt;、デコレートする関数の前後にコードを実行できるようにします&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e60ee3faedca029b522b5766bd4fef43e46646de" translate="yes" xml:space="preserve">
          <source>When do:</source>
          <target state="translated">いつやるの?</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">どの指紋だ</target>
        </trans-unit>
        <trans-unit id="0f59d388d686c4bb98639de68bb575c3f2e8c1b3" translate="yes" xml:space="preserve">
          <source>While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).</source>
          <target state="translated">上記の例はすべて動作しますが、生成されたコードは、複数のデコレータが一度に適用されたときに、不要な関数呼び出しの形でかなりのオーバーヘッドを伴います。これは、正確な使用法(例えば IO バインドであるかもしれません)によっては、重要ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="80931ea7fb9f9baaccc7db7989d6b55cd34a1502" translate="yes" xml:space="preserve">
          <source>Yes, that&amp;rsquo;s all, it&amp;rsquo;s that simple. &lt;code&gt;@decorator&lt;/code&gt; is just a shortcut to:</source>
          <target state="translated">はい、それだけです。とても簡単です。 &lt;code&gt;@decorator&lt;/code&gt; は次のショートカットにすぎません。</target>
        </trans-unit>
        <trans-unit id="82aa4bf8798112112023c3bf62cf028a41534be3" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;could&lt;/em&gt; make two separate decorators that do what you want as illustrated directly below. Note the use of &lt;code&gt;*args, **kwargs&lt;/code&gt; in the declaration of the &lt;code&gt;wrapped()&lt;/code&gt; function which supports the decorated function having multiple arguments (which isn't really necessary for the example &lt;code&gt;say()&lt;/code&gt; function, but is included for generality).</source>
          <target state="translated">すぐ下に示すように、2つの個別のデコレータを作成して、必要な処理を行うことができます。 複数の引数を持つ装飾された関数をサポートする &lt;code&gt;wrapped()&lt;/code&gt; 関数の宣言での &lt;code&gt;*args, **kwargs&lt;/code&gt; の使用に注意してください（これはサンプルの &lt;code&gt;say()&lt;/code&gt; 関数には実際には必要ありませんが、一般性のために含まれています）。</target>
        </trans-unit>
        <trans-unit id="3fcf6e6cdbd43a4541ee6fee7299941830fb61da" translate="yes" xml:space="preserve">
          <source>You can also write decorator in Class</source>
          <target state="translated">クラスでデコレータを書くこともできます。</target>
        </trans-unit>
        <trans-unit id="e0a9ddf317ada0cb0975c84b1b3a3350e91427a6" translate="yes" xml:space="preserve">
          <source>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.</source>
          <target state="translated">今はただ幸せなままにしておくか、もう少し脳を燃やしてデコレーターの高度な使い方を見ることができます。</target>
        </trans-unit>
        <trans-unit id="50c0158657b192fc0e1e92b4b42743e823b5581b" translate="yes" xml:space="preserve">
          <source>You can use them to extend several functions in a DRY&amp;rsquo;s way, like so:</source>
          <target state="translated">これらを使用して、次のようにDRYの方法でいくつかの関数を拡張できます。</target>
        </trans-unit>
        <trans-unit id="eb12aebb78c3f68a3b62316d71c4c613fca73470" translate="yes" xml:space="preserve">
          <source>You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator:</source>
          <target state="translated">また、より複雑なタスクを行うために使用することもできます。例えば、イテレータ内のすべての引数に再帰的に関数を自動的に適用するデコレータのように。</target>
        </trans-unit>
        <trans-unit id="2ecc0fab1db96d14074c26f8bc8f79f84ec79ac0" translate="yes" xml:space="preserve">
          <source>You really do:</source>
          <target state="translated">本当にそうなんですね。</target>
        </trans-unit>
        <trans-unit id="e81544690dadca1e7c105c62bc3929aebc31d34d" translate="yes" xml:space="preserve">
          <source>You want the following function, when called:</source>
          <target state="translated">呼び出されたときに、次のような関数が欲しいと思います。</target>
        </trans-unit>
        <trans-unit id="953873baa875246b6189da13ed630a79eb5fb0e9" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve seen that functions are objects. Therefore, functions:</source>
          <target state="translated">関数はオブジェクトであることがわかりました。 したがって、機能：</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">そして今。</target>
        </trans-unit>
        <trans-unit id="cafef07857121c9781de270f85e3951e33ef3a0f" translate="yes" xml:space="preserve">
          <source>as already noted in several answers, you can not easily modify the code to &lt;strong&gt;add optional decorator arguments&lt;/strong&gt;. For example creating a &lt;code&gt;makestyle(style='bold')&lt;/code&gt; decorator is non-trivial.</source>
          <target state="translated">いくつかの回答ですでに述べたように、コードを簡単に変更して&lt;strong&gt;オプションのデコレーター引数&lt;/strong&gt;を&lt;strong&gt;追加&lt;/strong&gt;することはできません。 たとえば、 &lt;code&gt;makestyle(style='bold')&lt;/code&gt; デコレータを作成するのは簡単ではありません。</target>
        </trans-unit>
        <trans-unit id="810b76f64a3518b6640d265928755185623d443d" translate="yes" xml:space="preserve">
          <source>besides, wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt;&lt;strong&gt;do not preserve the signature&lt;/strong&gt;, so if bad arguments are provided they will start executing, and might raise a different kind of error than the usual &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;@functools.wraps&lt;/code&gt; 作成されたラッパー&lt;strong&gt;は署名を保持しない&lt;/strong&gt;ため、不正な引数が提供された場合、実行が開始され、通常の &lt;code&gt;TypeError&lt;/code&gt; とは異なる種類のエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="278b019b92e03f8c6d596bdc96fa24cef85ab67c" translate="yes" xml:space="preserve">
          <source>can be assigned to a variable</source>
          <target state="translated">を変数に代入することができます。</target>
        </trans-unit>
        <trans-unit id="990c222d7e553798fcdfee2e5fa3c3d0fc120879" translate="yes" xml:space="preserve">
          <source>can be defined in another function</source>
          <target state="translated">は別の関数で定義することができます。</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">拡がる</target>
        </trans-unit>
        <trans-unit id="ccdbc5352040835da410ff1c10cbf69f8c83982f" translate="yes" xml:space="preserve">
          <source>finally, it is quite difficult in wrappers created with &lt;code&gt;@functools.wraps&lt;/code&gt; to &lt;strong&gt;access an argument based on its name&lt;/strong&gt;. Indeed the argument can appear in &lt;code&gt;*args&lt;/code&gt;, in &lt;code&gt;**kwargs&lt;/code&gt;, or may not appear at all (if it is optional).</source>
          <target state="translated">最後に、 &lt;code&gt;@functools.wraps&lt;/code&gt; 作成されたラッパーでは&lt;strong&gt;、その名前に基づいて引数&lt;/strong&gt;に&lt;strong&gt;アクセスする&lt;/strong&gt;ことは非常に困難です。 実際、引数は &lt;code&gt;*args&lt;/code&gt; 、 &lt;code&gt;**kwargs&lt;/code&gt; に現れるか、まったく現れない場合があります（オプションの場合）。</target>
        </trans-unit>
        <trans-unit id="3329d6139a17df5aa82ad5b8a51d8ca500fc2a29" translate="yes" xml:space="preserve">
          <source>is equivalent to this</source>
          <target state="translated">はこれに相当します。</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a351948668a1fcb5487bf5eff7e9fd31790b9eb2" translate="yes" xml:space="preserve">
          <source>or even combine them like this:</source>
          <target state="translated">とか、こんな感じで組み合わせてもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="4e84bc5fa8cf62a2ac1a2b230a64c8b9a9db925e" translate="yes" xml:space="preserve">
          <source>which would yield:</source>
          <target state="translated">となります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
