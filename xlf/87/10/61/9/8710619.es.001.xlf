<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/8710619">
    <body>
      <group id="8710619">
        <trans-unit id="fe6e80afa27690a6a1e23042a03339d49cd2b679" translate="yes" xml:space="preserve">
          <source>A compound assignment expression of the form &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; is equivalent to &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of &lt;code&gt;E1&lt;/code&gt;, except that &lt;code&gt;E1&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">Una expresi&amp;oacute;n de asignaci&amp;oacute;n compuesta de la forma &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; es equivalente a &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es el tipo de &lt;code&gt;E1&lt;/code&gt; , excepto que &lt;code&gt;E1&lt;/code&gt; se eval&amp;uacute;a solo una vez.</target>
        </trans-unit>
        <trans-unit id="0364601af1d440782a9886e91357dff484de1aac" translate="yes" xml:space="preserve">
          <source>A good example of this casting is using *= or /=</source>
          <target state="translated">Un buen ejemplo de este casting es usar *=o =</target>
        </trans-unit>
        <trans-unit id="279a1cd3b464a2d0bba54a74f955b3d3a3176517" translate="yes" xml:space="preserve">
          <source>An example cited from &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt;</source>
          <target state="translated">Un ejemplo citado de &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c08b4fc70848c5aae75aab90180bf273db81df6" translate="yes" xml:space="preserve">
          <source>As always with these questions, the JLS holds the answer. In this case &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 Compound Assignment Operators&lt;/a&gt;. An extract:</source>
          <target state="translated">Como siempre con estas preguntas, el JLS tiene la respuesta. En este caso, &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 Operadores de asignaci&amp;oacute;n compuesta&lt;/a&gt; . Un extracto:</target>
        </trans-unit>
        <trans-unit id="5ba4fa61ea27a5944cb4ae89cf5367ff30ef28ed" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;+=&lt;/code&gt; is coded in such a way that it does type casting. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</source>
          <target state="translated">Pero &lt;code&gt;+=&lt;/code&gt; est&amp;aacute; codificado de tal manera que escribe tipo casting. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae130a04cf426d477d3556e10de3f9da51280995" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;a = a + b&lt;/code&gt; doesn't work, that would mean &lt;code&gt;a += b&lt;/code&gt; would never work for bytes if it &lt;code&gt;E1 += E2&lt;/code&gt; was defined to be &lt;code&gt;E1 = E1 + E2&lt;/code&gt;. As the previous example shows, that would be indeed the case. As a hack to make &lt;code&gt;+=&lt;/code&gt; operator work for bytes and shorts, there is an implicit cast involved. It's not that great of a hack, but back during the Java 1.0 work, the focus was on getting the language released to begin with. Now, because of backwards compatibility, this hack introduced in Java 1.0 couldn't be removed.</source>
          <target state="translated">Pero si &lt;code&gt;a = a + b&lt;/code&gt; no funciona, eso significar&amp;iacute;a que &lt;code&gt;a += b&lt;/code&gt; nunca funcionar&amp;iacute;a para bytes si &lt;code&gt;E1 += E2&lt;/code&gt; se definiera como &lt;code&gt;E1 = E1 + E2&lt;/code&gt; . Como muestra el ejemplo anterior, ese ser&amp;iacute;a el caso. Como un truco para hacer que el operador &lt;code&gt;+=&lt;/code&gt; funcione para bytes y cortos, hay un elenco impl&amp;iacute;cito involucrado. No es un gran truco, pero durante el trabajo de Java 1.0, el enfoque se centr&amp;oacute; en liberar el lenguaje para empezar. Ahora, debido a la compatibilidad con versiones anteriores, este truco introducido en Java 1.0 no se pudo eliminar.</target>
        </trans-unit>
        <trans-unit id="ce41838c527dc15014a8a05f5bfa14989fd0fb62" translate="yes" xml:space="preserve">
          <source>But if we try this:</source>
          <target state="translated">Pero si intentamos esto:</target>
        </trans-unit>
        <trans-unit id="9f0e3bc00b013a32678e2121583114b9ebea8a17" translate="yes" xml:space="preserve">
          <source>Did you guess 3? Too bad, this program won't compile. Why? Well, it so happens that addition of bytes in Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;is defined to return an &lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. This, I believe was because the Java Virtual Machine doesn't define byte operations to save on bytecodes (there is a limited number of those, after all), using integer operations instead is an implementation detail exposed in a language.</source>
          <target state="translated">&amp;iquest;Adivinaste 3? L&amp;aacute;stima, este programa no se compilar&amp;aacute;. &amp;iquest;Por qu&amp;eacute;? Bueno, sucede que la adici&amp;oacute;n de bytes en Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;se define para devolver un &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; . Esto, creo que fue porque la M&amp;aacute;quina Virtual Java no define operaciones de bytes para guardar en c&amp;oacute;digos de bytes (despu&amp;eacute;s de todo, hay un n&amp;uacute;mero limitado de ellos), el uso de operaciones enteras en su lugar es un detalle de implementaci&amp;oacute;n expuesto en un lenguaje.</target>
        </trans-unit>
        <trans-unit id="90a6c7c3c6ca01a564175444b2c818f963863c42" translate="yes" xml:space="preserve">
          <source>Does it mean that in fact &lt;code&gt;i += j;&lt;/code&gt; is a shortcut for something like this
&lt;code&gt;i = (type of i) (i + j)&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Significa que, de hecho, &lt;code&gt;i += j;&lt;/code&gt; es un atajo para algo como esto &lt;code&gt;i = (type of i) (i + j)&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f038b305feefd0f95fe337d2d2652529bc51747e" translate="yes" xml:space="preserve">
          <source>For example, the following code is correct:</source>
          <target state="translated">Por ejemplo,el siguiente código es correcto:</target>
        </trans-unit>
        <trans-unit id="6267184b2c4bc9e0765ed547ef1d15a1b70c4a85" translate="yes" xml:space="preserve">
          <source>For example, when you write:</source>
          <target state="translated">Por ejemplo,cuando escribes:</target>
        </trans-unit>
        <trans-unit id="ee50437b4b89794edd53b64c69655ee58728cf3d" translate="yes" xml:space="preserve">
          <source>I just checked the &lt;code&gt;.class&lt;/code&gt; file code.</source>
          <target state="translated">Acabo de comprobar el c&amp;oacute;digo del archivo &lt;code&gt;.class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09c7a812797c2454ddd47141dad43697fda9bc3a" translate="yes" xml:space="preserve">
          <source>In Java type conversions are performed automatically when the type of the expression on the right hand side of an assignment operation can be safely promoted to the type of the variable on the left hand side of the assignment. Thus we can safely assign:</source>
          <target state="translated">En Java las conversiones de tipo se realizan automáticamente cuando el tipo de la expresión en el lado derecho de una operación de asignación puede ser promovido con seguridad al tipo de la variable en el lado izquierdo de la asignación.Así podemos asignar con seguridad:</target>
        </trans-unit>
        <trans-unit id="e703016318f8c25d1d9a981d4ddf51e18ef86592" translate="yes" xml:space="preserve">
          <source>In other words, your assumption is correct.</source>
          <target state="translated">En otras palabras,su suposición es correcta.</target>
        </trans-unit>
        <trans-unit id="f0288786c9a8ca0579fd3f06940f05e0414912fd" translate="yes" xml:space="preserve">
          <source>Java Language Specification &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;defines &lt;code&gt;E1 op= E2&lt;/code&gt; to be equivalent to &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a type of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E1&lt;/code&gt; is evaluated once&lt;/a&gt;.</source>
          <target state="translated">La especificaci&amp;oacute;n del lenguaje Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;define que &lt;code&gt;E1 op= E2&lt;/code&gt; es equivalente a &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; donde &lt;code&gt;T&lt;/code&gt; es un tipo de &lt;code&gt;E1&lt;/code&gt; y &lt;code&gt;E1&lt;/code&gt; se eval&amp;uacute;a una vez&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b31185e5e992669b60849ab724ebe4ddc6e8b508" translate="yes" xml:space="preserve">
          <source>Really a good thing to know</source>
          <target state="translated">Realmente es bueno saber</target>
        </trans-unit>
        <trans-unit id="136ab125acd799cb2684d8539ef560b2a115ae96" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;this description of implicit casting&lt;/a&gt;</source>
          <target state="translated">Ver: &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;esta descripci&amp;oacute;n del casting impl&amp;iacute;cito&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9df74f93008fd50c6905d26834aac49cdb7df29" translate="yes" xml:space="preserve">
          <source>So to avoid it, you must write your code like this:</source>
          <target state="translated">Así que para evitarlo,debes escribir tu código así:</target>
        </trans-unit>
        <trans-unit id="e2af4df8f9e3a41bf49850cb8229180cc59381aa" translate="yes" xml:space="preserve">
          <source>Sometimes, such a question can be asked at an interview.</source>
          <target state="translated">A veces,esa pregunta puede hacerse en una entrevista.</target>
        </trans-unit>
        <trans-unit id="bb0b6674314e38164129042867cdc6f53891c049" translate="yes" xml:space="preserve">
          <source>Subtle point here...</source>
          <target state="translated">Un punto sutil aquí...</target>
        </trans-unit>
        <trans-unit id="20c15c7769ca8dfc4c209fae82587e6da2277494" translate="yes" xml:space="preserve">
          <source>That's a technical answer, but you may be wondering why that's a case. Well, let's consider the following program.</source>
          <target state="translated">Es una respuesta técnica,pero se preguntarán por qué es un caso.Bueno,consideremos el siguiente programa.</target>
        </trans-unit>
        <trans-unit id="44d952297cc065a18903f1a2ab718fa5f744281c" translate="yes" xml:space="preserve">
          <source>The int object is casted to long &amp;amp; both are added and you get long object.</source>
          <target state="translated">El objeto int se convierte en largo y ambos se agregan y obtienes un objeto largo.</target>
        </trans-unit>
        <trans-unit id="d34716a0ce9b35449bd1b46cfa8514187cf0d601" translate="yes" xml:space="preserve">
          <source>The main difference is that with &lt;code&gt;a = a + b&lt;/code&gt;, there is no typecasting going on, and so the compiler gets angry at you for not typecasting. But with &lt;code&gt;a += b&lt;/code&gt;, what it's really doing is typecasting &lt;code&gt;b&lt;/code&gt; to a type compatible with &lt;code&gt;a&lt;/code&gt;. So if you do</source>
          <target state="translated">La principal diferencia es que con &lt;code&gt;a = a + b&lt;/code&gt; , no hay ning&amp;uacute;n tipo de conversi&amp;oacute;n de texto, por lo que el compilador se enoja contigo por no escribirlo. Pero con &lt;code&gt;a += b&lt;/code&gt; , lo que realmente est&amp;aacute; haciendo es convertir &lt;code&gt;b&lt;/code&gt; a un tipo compatible con &lt;code&gt;a&lt;/code&gt; . Entonces si lo haces</target>
        </trans-unit>
        <trans-unit id="c9ec6704b481e32d0673f24b11fe4cd91a634830" translate="yes" xml:space="preserve">
          <source>The problem here involves type casting.</source>
          <target state="translated">El problema aquí tiene que ver con el moldeado de los tipos.</target>
        </trans-unit>
        <trans-unit id="3286136395a3eb8402d57f9a1bc02f232511f195" translate="yes" xml:space="preserve">
          <source>The same will not work the other way round. For example we cannot automatically convert a long to an int because the first requires more storage than the second and consequently information may be lost. To force such a conversion we must carry out an explicit conversion.</source>
          <target state="translated">Lo mismo no funcionará al revés.Por ejemplo,no podemos convertir automáticamente un largo en un int porque el primero requiere más almacenamiento que el segundo y,en consecuencia,la información puede perderse.Para forzar tal conversión debemos realizar una conversión explícita.</target>
        </trans-unit>
        <trans-unit id="b127c9759204a223a39e541475b7e0a7e7e23d2a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;i = i + j;&lt;/code&gt; will not compile but &lt;code&gt;i += j;&lt;/code&gt; will compile fine.</source>
          <target state="translated">Entonces &lt;code&gt;i = i + j;&lt;/code&gt; no compilar&amp;aacute; pero &lt;code&gt;i += j;&lt;/code&gt; Se compilar&amp;aacute; bien.</target>
        </trans-unit>
        <trans-unit id="28a6f37f42e10bd31723edb18b5351d75d790c1d" translate="yes" xml:space="preserve">
          <source>There is an implicit typecast for &lt;code&gt;i+j&lt;/code&gt; when &lt;code&gt;j&lt;/code&gt; is a double and &lt;code&gt;i&lt;/code&gt; is an int.
Java &lt;strong&gt;ALWAYS&lt;/strong&gt; converts an integer into a double when there is an operation between them.</source>
          <target state="translated">Hay un tipo de letra impl&amp;iacute;cito para &lt;code&gt;i+j&lt;/code&gt; cuando &lt;code&gt;j&lt;/code&gt; es un doble e &lt;code&gt;i&lt;/code&gt; es un int. Java &lt;strong&gt;SIEMPRE&lt;/strong&gt; convierte un n&amp;uacute;mero entero en un doble cuando hay una operaci&amp;oacute;n entre ellos.</target>
        </trans-unit>
        <trans-unit id="146c922e0dbcf587665f9004107892ed8a734050" translate="yes" xml:space="preserve">
          <source>To clarify &lt;code&gt;i+=j&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is an integer and &lt;code&gt;j&lt;/code&gt; is a double can be described as</source>
          <target state="translated">Para aclarar &lt;code&gt;i+=j&lt;/code&gt; donde &lt;code&gt;i&lt;/code&gt; es un n&amp;uacute;mero entero y &lt;code&gt;j&lt;/code&gt; es un doble, puede describirse como</target>
        </trans-unit>
        <trans-unit id="9cdafb8a4569a39dbdd1cc8242f4f864cebd4626" translate="yes" xml:space="preserve">
          <source>Type - Conversion</source>
          <target state="translated">Tipo-Conversión</target>
        </trans-unit>
        <trans-unit id="ef7e30718b01b4bd3649ae836ce2c2fdd526fae9" translate="yes" xml:space="preserve">
          <source>Until today, I thought that for example:</source>
          <target state="translated">Hasta hoy,pensé que por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b411cd5e8ac2d2bfefe7e0438232a5781a92da47" translate="yes" xml:space="preserve">
          <source>Very good question. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;Java Language specification&lt;/a&gt; confirms your suggestion.</source>
          <target state="translated">Muy buena pregunta La &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;especificaci&amp;oacute;n del lenguaje Java&lt;/a&gt; confirma su sugerencia.</target>
        </trans-unit>
        <trans-unit id="44dc017327f8da38205d25425b212a6438058ba2" translate="yes" xml:space="preserve">
          <source>Was just a shortcut for:</source>
          <target state="translated">era sólo un atajo para:</target>
        </trans-unit>
        <trans-unit id="1a0fa91703a3ea7b0b51339b8cc7effdea9442a4" translate="yes" xml:space="preserve">
          <source>What does this program print?</source>
          <target state="translated">¿Qué imprime este programa?</target>
        </trans-unit>
        <trans-unit id="b2dff14df907b2d5ff7b98620dd6c9165e4f01d1" translate="yes" xml:space="preserve">
          <source>What you're really doing is:</source>
          <target state="translated">Lo que realmente estás haciendo es:</target>
        </trans-unit>
        <trans-unit id="16d0d8b1356f59eb5978f70aaf70dff973325c9c" translate="yes" xml:space="preserve">
          <source>When you add int and long,</source>
          <target state="translated">Cuando añades int y largo,</target>
        </trans-unit>
        <trans-unit id="b018561bc12ef2acfd1631f5b6349bcd49475341" translate="yes" xml:space="preserve">
          <source>Why don't Java's +=, -=, *=, /= compound assignment operators require casting</source>
          <target state="translated">¿Por qué los +=,-=,*=,=operadores de asignación de compuestos de Java no requieren fundición</target>
        </trans-unit>
        <trans-unit id="b00cc12a28a0c5716ac5d5e1ead3036b83db8701" translate="yes" xml:space="preserve">
          <source>Yes,</source>
          <target state="translated">Yes,</target>
        </trans-unit>
        <trans-unit id="34823a2aa2982535156ec845d3c3dab8c6cfbcc9" translate="yes" xml:space="preserve">
          <source>You might want to typecast &lt;code&gt;j&lt;/code&gt; to &lt;code&gt;(int)&lt;/code&gt; in this case for clarity.</source>
          <target state="translated">Es posible que desee escribir &lt;code&gt;j&lt;/code&gt; en &lt;code&gt;(int)&lt;/code&gt; en este caso para mayor claridad.</target>
        </trans-unit>
        <trans-unit id="02fb86dce452e33394dfd5daada6819af636150a" translate="yes" xml:space="preserve">
          <source>[...] the following code is correct:</source>
          <target state="translated">...el siguiente código es correcto:</target>
        </trans-unit>
        <trans-unit id="acd218195a6faad005e9b62c9455d3692d86cde7" translate="yes" xml:space="preserve">
          <source>and results in x having the value 7 because it is equivalent to:</source>
          <target state="translated">y resulta en que x tiene el valor 7 porque es equivalente a:</target>
        </trans-unit>
        <trans-unit id="b0457b0000b3d4130147f6d71d7c50eeb982269b" translate="yes" xml:space="preserve">
          <source>basically when we write</source>
          <target state="translated">básicamente cuando escribimos</target>
        </trans-unit>
        <trans-unit id="60cf96c8674fdb6fb0b57b394e68cb4ef42e2182" translate="yes" xml:space="preserve">
          <source>but in case of &lt;code&gt;+=&lt;/code&gt; it just works fine because the operator implicitly does the type casting from type of right variable to type of left variable so need not cast explicitly.</source>
          <target state="translated">pero en el caso de &lt;code&gt;+=&lt;/code&gt; simplemente funciona bien porque el operador realiza impl&amp;iacute;citamente el tipo de conversi&amp;oacute;n de tipo de variable derecha a tipo de variable izquierda, por lo que no es necesario emitir expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="d02946c187bcbe2fa7b786addfc08b8b6cf361bb" translate="yes" xml:space="preserve">
          <source>but long object cannot be implicitly casted to int. So, you have to do that explicitly.</source>
          <target state="translated">pero el objeto largo no puede ser implícitamente lanzado al int.Así que,tienes que hacerlo explícitamente.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0060fef58e92ce48614c8bf13ac0553c1193b98c" translate="yes" xml:space="preserve">
          <source>the compiler converts this to</source>
          <target state="translated">el compilador convierte esto en</target>
        </trans-unit>
        <trans-unit id="b6da30c33c6cd325a034851de899b65419fa7622" translate="yes" xml:space="preserve">
          <source>there is no automatic typecasting. In C++ there will not be any error compiling the above code, but in Java you will get something like &lt;code&gt;Incompatible type exception&lt;/code&gt;.</source>
          <target state="translated">No hay encasillamiento autom&amp;aacute;tico. En C ++ no habr&amp;aacute; ning&amp;uacute;n error al compilar el c&amp;oacute;digo anterior, pero en Java obtendr&amp;aacute; algo como &lt;code&gt;Incompatible type exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6825281ba91a2e72c36c939224152fce4b08a6da" translate="yes" xml:space="preserve">
          <source>you need to cast from &lt;code&gt;long&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;&lt;code&gt;explicitly&lt;/code&gt; in case of &lt;code&gt;i = i + l&lt;/code&gt;  then it will compile and give correct output. like</source>
          <target state="translated">necesita convertir de &lt;code&gt;long&lt;/code&gt; a &lt;code&gt;int&lt;/code&gt; &lt;code&gt;explicitly&lt;/code&gt; en el caso de &lt;code&gt;i = i + l&lt;/code&gt; entonces se compilar&amp;aacute; y dar&amp;aacute; la salida correcta. me gusta</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
