<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/8710619">
    <body>
      <group id="8710619">
        <trans-unit id="fe6e80afa27690a6a1e23042a03339d49cd2b679" translate="yes" xml:space="preserve">
          <source>A compound assignment expression of the form &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; is equivalent to &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of &lt;code&gt;E1&lt;/code&gt;, except that &lt;code&gt;E1&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">Составное выражение присваивания в форме &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; эквивалентно &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тип &lt;code&gt;E1&lt;/code&gt; , за исключением того, что &lt;code&gt;E1&lt;/code&gt; оценивается только один раз.</target>
        </trans-unit>
        <trans-unit id="0364601af1d440782a9886e91357dff484de1aac" translate="yes" xml:space="preserve">
          <source>A good example of this casting is using *= or /=</source>
          <target state="translated">Хорошим примером такого кастинга является использование *=или =</target>
        </trans-unit>
        <trans-unit id="279a1cd3b464a2d0bba54a74f955b3d3a3176517" translate="yes" xml:space="preserve">
          <source>An example cited from &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt;</source>
          <target state="translated">Пример, приведенный в &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c08b4fc70848c5aae75aab90180bf273db81df6" translate="yes" xml:space="preserve">
          <source>As always with these questions, the JLS holds the answer. In this case &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 Compound Assignment Operators&lt;/a&gt;. An extract:</source>
          <target state="translated">Как всегда с этими вопросами, JLS держит ответ. В этом случае &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 Операторы сложного присваивания&lt;/a&gt; . Выписка:</target>
        </trans-unit>
        <trans-unit id="5ba4fa61ea27a5944cb4ae89cf5367ff30ef28ed" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;+=&lt;/code&gt; is coded in such a way that it does type casting. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</source>
          <target state="translated">Но &lt;code&gt;+=&lt;/code&gt; кодируется таким образом, что он выполняет приведение типов. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae130a04cf426d477d3556e10de3f9da51280995" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;a = a + b&lt;/code&gt; doesn't work, that would mean &lt;code&gt;a += b&lt;/code&gt; would never work for bytes if it &lt;code&gt;E1 += E2&lt;/code&gt; was defined to be &lt;code&gt;E1 = E1 + E2&lt;/code&gt;. As the previous example shows, that would be indeed the case. As a hack to make &lt;code&gt;+=&lt;/code&gt; operator work for bytes and shorts, there is an implicit cast involved. It's not that great of a hack, but back during the Java 1.0 work, the focus was on getting the language released to begin with. Now, because of backwards compatibility, this hack introduced in Java 1.0 couldn't be removed.</source>
          <target state="translated">Но если &lt;code&gt;a = a + b&lt;/code&gt; не работает, это означало бы, что &lt;code&gt;a += b&lt;/code&gt; никогда не будет работать для байтов, если его &lt;code&gt;E1 += E2&lt;/code&gt; было определено как &lt;code&gt;E1 = E1 + E2&lt;/code&gt; . Как показывает предыдущий пример, это действительно так. В качестве хака, заставляющего оператор &lt;code&gt;+=&lt;/code&gt; работать для байтов и шортов, подразумевается неявное приведение. Это не так здорово, но во время работы над Java 1.0 основное внимание уделялось выпуску языка с самого начала. Теперь, из-за обратной совместимости, этот хак, введенный в Java 1.0, не может быть удален.</target>
        </trans-unit>
        <trans-unit id="ce41838c527dc15014a8a05f5bfa14989fd0fb62" translate="yes" xml:space="preserve">
          <source>But if we try this:</source>
          <target state="translated">Но если мы попробуем:</target>
        </trans-unit>
        <trans-unit id="9f0e3bc00b013a32678e2121583114b9ebea8a17" translate="yes" xml:space="preserve">
          <source>Did you guess 3? Too bad, this program won't compile. Why? Well, it so happens that addition of bytes in Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;is defined to return an &lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. This, I believe was because the Java Virtual Machine doesn't define byte operations to save on bytecodes (there is a limited number of those, after all), using integer operations instead is an implementation detail exposed in a language.</source>
          <target state="translated">Вы догадались 3? Жаль, что эта программа не скомпилируется. Почему? Что ж, бывает так, что добавление байтов в Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;определено как возвращающее &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; . Я полагаю, это произошло потому, что виртуальная машина Java не определяет байтовые операции для сохранения в байтовых кодах (в конце концов, их число ограничено), а использование целочисленных операций - это деталь реализации, представленная на языке.</target>
        </trans-unit>
        <trans-unit id="90a6c7c3c6ca01a564175444b2c818f963863c42" translate="yes" xml:space="preserve">
          <source>Does it mean that in fact &lt;code&gt;i += j;&lt;/code&gt; is a shortcut for something like this
&lt;code&gt;i = (type of i) (i + j)&lt;/code&gt;?</source>
          <target state="translated">Означает ли это, что на самом деле &lt;code&gt;i += j;&lt;/code&gt; такое ярлык для чего-то вроде этого &lt;code&gt;i = (type of i) (i + j)&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f038b305feefd0f95fe337d2d2652529bc51747e" translate="yes" xml:space="preserve">
          <source>For example, the following code is correct:</source>
          <target state="translated">Например,следующий код корректен:</target>
        </trans-unit>
        <trans-unit id="6267184b2c4bc9e0765ed547ef1d15a1b70c4a85" translate="yes" xml:space="preserve">
          <source>For example, when you write:</source>
          <target state="translated">Например,когда ты пишешь:</target>
        </trans-unit>
        <trans-unit id="ee50437b4b89794edd53b64c69655ee58728cf3d" translate="yes" xml:space="preserve">
          <source>I just checked the &lt;code&gt;.class&lt;/code&gt; file code.</source>
          <target state="translated">Я только что проверил код файла &lt;code&gt;.class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09c7a812797c2454ddd47141dad43697fda9bc3a" translate="yes" xml:space="preserve">
          <source>In Java type conversions are performed automatically when the type of the expression on the right hand side of an assignment operation can be safely promoted to the type of the variable on the left hand side of the assignment. Thus we can safely assign:</source>
          <target state="translated">В Java преобразования типов выполняются автоматически,когда тип выражения справа от операции присваивания может быть безопасно переведен в тип переменной слева от операции присваивания.Таким образом,мы можем безопасно присвоить:</target>
        </trans-unit>
        <trans-unit id="e703016318f8c25d1d9a981d4ddf51e18ef86592" translate="yes" xml:space="preserve">
          <source>In other words, your assumption is correct.</source>
          <target state="translated">Другими словами,ваше предположение верно.</target>
        </trans-unit>
        <trans-unit id="f0288786c9a8ca0579fd3f06940f05e0414912fd" translate="yes" xml:space="preserve">
          <source>Java Language Specification &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;defines &lt;code&gt;E1 op= E2&lt;/code&gt; to be equivalent to &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a type of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E1&lt;/code&gt; is evaluated once&lt;/a&gt;.</source>
          <target state="translated">Спецификация языка Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;определяет &lt;code&gt;E1 op= E2&lt;/code&gt; чтобы быть эквивалентным &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; где &lt;code&gt;T&lt;/code&gt; - это тип &lt;code&gt;E1&lt;/code&gt; , а &lt;code&gt;E1&lt;/code&gt; оценивается один раз&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b31185e5e992669b60849ab724ebe4ddc6e8b508" translate="yes" xml:space="preserve">
          <source>Really a good thing to know</source>
          <target state="translated">Действительно хорошая вещь,чтобы знать</target>
        </trans-unit>
        <trans-unit id="136ab125acd799cb2684d8539ef560b2a115ae96" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;this description of implicit casting&lt;/a&gt;</source>
          <target state="translated">Смотрите: &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;это описание неявного приведения&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9df74f93008fd50c6905d26834aac49cdb7df29" translate="yes" xml:space="preserve">
          <source>So to avoid it, you must write your code like this:</source>
          <target state="translated">Так что,чтобы избежать этого,вы должны написать свой код вот так:</target>
        </trans-unit>
        <trans-unit id="e2af4df8f9e3a41bf49850cb8229180cc59381aa" translate="yes" xml:space="preserve">
          <source>Sometimes, such a question can be asked at an interview.</source>
          <target state="translated">Иногда такой вопрос можно задать на собеседовании.</target>
        </trans-unit>
        <trans-unit id="bb0b6674314e38164129042867cdc6f53891c049" translate="yes" xml:space="preserve">
          <source>Subtle point here...</source>
          <target state="translated">Тонкий момент...</target>
        </trans-unit>
        <trans-unit id="20c15c7769ca8dfc4c209fae82587e6da2277494" translate="yes" xml:space="preserve">
          <source>That's a technical answer, but you may be wondering why that's a case. Well, let's consider the following program.</source>
          <target state="translated">Это технический ответ,но вам может быть интересно,почему это так.Ну,давайте рассмотрим следующую программу.</target>
        </trans-unit>
        <trans-unit id="44d952297cc065a18903f1a2ab718fa5f744281c" translate="yes" xml:space="preserve">
          <source>The int object is casted to long &amp;amp; both are added and you get long object.</source>
          <target state="translated">Объект int приводится к long, и оба добавляются, и вы получаете long объект.</target>
        </trans-unit>
        <trans-unit id="d34716a0ce9b35449bd1b46cfa8514187cf0d601" translate="yes" xml:space="preserve">
          <source>The main difference is that with &lt;code&gt;a = a + b&lt;/code&gt;, there is no typecasting going on, and so the compiler gets angry at you for not typecasting. But with &lt;code&gt;a += b&lt;/code&gt;, what it's really doing is typecasting &lt;code&gt;b&lt;/code&gt; to a type compatible with &lt;code&gt;a&lt;/code&gt;. So if you do</source>
          <target state="translated">Основное различие заключается в том, что при &lt;code&gt;a = a + b&lt;/code&gt; не происходит встраивание типов, и поэтому компилятор злится на вас за отсутствие встраивания типов. Но с &lt;code&gt;a += b&lt;/code&gt; , на самом деле, это приведение типов к типу, совместимому с &lt;code&gt;a&lt;/code&gt; . Так что если вы делаете</target>
        </trans-unit>
        <trans-unit id="c9ec6704b481e32d0673f24b11fe4cd91a634830" translate="yes" xml:space="preserve">
          <source>The problem here involves type casting.</source>
          <target state="translated">Проблема здесь заключается в литье по типу.</target>
        </trans-unit>
        <trans-unit id="3286136395a3eb8402d57f9a1bc02f232511f195" translate="yes" xml:space="preserve">
          <source>The same will not work the other way round. For example we cannot automatically convert a long to an int because the first requires more storage than the second and consequently information may be lost. To force such a conversion we must carry out an explicit conversion.</source>
          <target state="translated">То же самое не сработает наоборот.Например,мы не можем автоматически преобразовать длину в int,так как первая требует больше памяти,чем вторая,и,следовательно,информация может быть потеряна.Чтобы форсировать такое преобразование,мы должны выполнить явное преобразование.</target>
        </trans-unit>
        <trans-unit id="b127c9759204a223a39e541475b7e0a7e7e23d2a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;i = i + j;&lt;/code&gt; will not compile but &lt;code&gt;i += j;&lt;/code&gt; will compile fine.</source>
          <target state="translated">Тогда &lt;code&gt;i = i + j;&lt;/code&gt; не скомпилируется, но &lt;code&gt;i += j;&lt;/code&gt; скомпилирует нормально.</target>
        </trans-unit>
        <trans-unit id="28a6f37f42e10bd31723edb18b5351d75d790c1d" translate="yes" xml:space="preserve">
          <source>There is an implicit typecast for &lt;code&gt;i+j&lt;/code&gt; when &lt;code&gt;j&lt;/code&gt; is a double and &lt;code&gt;i&lt;/code&gt; is an int.
Java &lt;strong&gt;ALWAYS&lt;/strong&gt; converts an integer into a double when there is an operation between them.</source>
          <target state="translated">Существует неявное приведение типов для &lt;code&gt;i+j&lt;/code&gt; , когда &lt;code&gt;j&lt;/code&gt; - двойное число, а &lt;code&gt;i&lt;/code&gt; - целое число. Java &lt;strong&gt;ВСЕГДА&lt;/strong&gt; преобразует целое число в двойное, когда между ними есть операция.</target>
        </trans-unit>
        <trans-unit id="146c922e0dbcf587665f9004107892ed8a734050" translate="yes" xml:space="preserve">
          <source>To clarify &lt;code&gt;i+=j&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is an integer and &lt;code&gt;j&lt;/code&gt; is a double can be described as</source>
          <target state="translated">Чтобы уточнить &lt;code&gt;i+=j&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - целое число, а &lt;code&gt;j&lt;/code&gt; - двойное, его можно описать как</target>
        </trans-unit>
        <trans-unit id="9cdafb8a4569a39dbdd1cc8242f4f864cebd4626" translate="yes" xml:space="preserve">
          <source>Type - Conversion</source>
          <target state="translated">Тип-преобразование</target>
        </trans-unit>
        <trans-unit id="ef7e30718b01b4bd3649ae836ce2c2fdd526fae9" translate="yes" xml:space="preserve">
          <source>Until today, I thought that for example:</source>
          <target state="translated">До сегодняшнего дня я думал,что,например:</target>
        </trans-unit>
        <trans-unit id="b411cd5e8ac2d2bfefe7e0438232a5781a92da47" translate="yes" xml:space="preserve">
          <source>Very good question. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;Java Language specification&lt;/a&gt; confirms your suggestion.</source>
          <target state="translated">Очень хороший вопрос Спецификация &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;языка Java&lt;/a&gt; подтверждает ваше предложение.</target>
        </trans-unit>
        <trans-unit id="44dc017327f8da38205d25425b212a6438058ba2" translate="yes" xml:space="preserve">
          <source>Was just a shortcut for:</source>
          <target state="translated">Это был всего лишь короткий путь:</target>
        </trans-unit>
        <trans-unit id="1a0fa91703a3ea7b0b51339b8cc7effdea9442a4" translate="yes" xml:space="preserve">
          <source>What does this program print?</source>
          <target state="translated">Что печатает эта программа?</target>
        </trans-unit>
        <trans-unit id="b2dff14df907b2d5ff7b98620dd6c9165e4f01d1" translate="yes" xml:space="preserve">
          <source>What you're really doing is:</source>
          <target state="translated">То,что ты на самом деле делаешь:</target>
        </trans-unit>
        <trans-unit id="16d0d8b1356f59eb5978f70aaf70dff973325c9c" translate="yes" xml:space="preserve">
          <source>When you add int and long,</source>
          <target state="translated">Когда ты добавляешь интриги и длинные,</target>
        </trans-unit>
        <trans-unit id="b018561bc12ef2acfd1631f5b6349bcd49475341" translate="yes" xml:space="preserve">
          <source>Why don't Java's +=, -=, *=, /= compound assignment operators require casting</source>
          <target state="translated">Почему бы Java's +=,-=,*=,=составные операторы присваивания не требуют кастинга</target>
        </trans-unit>
        <trans-unit id="b00cc12a28a0c5716ac5d5e1ead3036b83db8701" translate="yes" xml:space="preserve">
          <source>Yes,</source>
          <target state="translated">Yes,</target>
        </trans-unit>
        <trans-unit id="34823a2aa2982535156ec845d3c3dab8c6cfbcc9" translate="yes" xml:space="preserve">
          <source>You might want to typecast &lt;code&gt;j&lt;/code&gt; to &lt;code&gt;(int)&lt;/code&gt; in this case for clarity.</source>
          <target state="translated">В этом случае вы можете указать тип &lt;code&gt;j&lt;/code&gt; для &lt;code&gt;(int)&lt;/code&gt; для ясности.</target>
        </trans-unit>
        <trans-unit id="02fb86dce452e33394dfd5daada6819af636150a" translate="yes" xml:space="preserve">
          <source>[...] the following code is correct:</source>
          <target state="translated">[...]следующий код верен:</target>
        </trans-unit>
        <trans-unit id="acd218195a6faad005e9b62c9455d3692d86cde7" translate="yes" xml:space="preserve">
          <source>and results in x having the value 7 because it is equivalent to:</source>
          <target state="translated">и приводит к тому,что Х имеет значение 7,потому что оно эквивалентно:</target>
        </trans-unit>
        <trans-unit id="b0457b0000b3d4130147f6d71d7c50eeb982269b" translate="yes" xml:space="preserve">
          <source>basically when we write</source>
          <target state="translated">в основном,когда мы пишем</target>
        </trans-unit>
        <trans-unit id="60cf96c8674fdb6fb0b57b394e68cb4ef42e2182" translate="yes" xml:space="preserve">
          <source>but in case of &lt;code&gt;+=&lt;/code&gt; it just works fine because the operator implicitly does the type casting from type of right variable to type of left variable so need not cast explicitly.</source>
          <target state="translated">но в случае &lt;code&gt;+=&lt;/code&gt; это просто отлично работает, потому что оператор неявно выполняет приведение типа из типа правой переменной в тип левой переменной, поэтому нет необходимости явного приведения.</target>
        </trans-unit>
        <trans-unit id="d02946c187bcbe2fa7b786addfc08b8b6cf361bb" translate="yes" xml:space="preserve">
          <source>but long object cannot be implicitly casted to int. So, you have to do that explicitly.</source>
          <target state="translated">но длинный объект не может быть неявно передан в int.Поэтому,вы должны сделать это явно.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0060fef58e92ce48614c8bf13ac0553c1193b98c" translate="yes" xml:space="preserve">
          <source>the compiler converts this to</source>
          <target state="translated">компилятор преобразует это в</target>
        </trans-unit>
        <trans-unit id="b6da30c33c6cd325a034851de899b65419fa7622" translate="yes" xml:space="preserve">
          <source>there is no automatic typecasting. In C++ there will not be any error compiling the above code, but in Java you will get something like &lt;code&gt;Incompatible type exception&lt;/code&gt;.</source>
          <target state="translated">нет автоматической типизации. В C ++ не будет ошибок при компиляции приведенного выше кода, но в Java вы получите что-то вроде &lt;code&gt;Incompatible type exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6825281ba91a2e72c36c939224152fce4b08a6da" translate="yes" xml:space="preserve">
          <source>you need to cast from &lt;code&gt;long&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;&lt;code&gt;explicitly&lt;/code&gt; in case of &lt;code&gt;i = i + l&lt;/code&gt;  then it will compile and give correct output. like</source>
          <target state="translated">вам нужно &lt;code&gt;explicitly&lt;/code&gt; привести от &lt;code&gt;long&lt;/code&gt; к &lt;code&gt;int&lt;/code&gt; в случае &lt;code&gt;i = i + l&lt;/code&gt; тогда он скомпилируется и даст правильный вывод. лайк</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
