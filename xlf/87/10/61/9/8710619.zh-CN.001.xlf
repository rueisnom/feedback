<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/8710619">
    <body>
      <group id="8710619">
        <trans-unit id="fe6e80afa27690a6a1e23042a03339d49cd2b679" translate="yes" xml:space="preserve">
          <source>A compound assignment expression of the form &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; is equivalent to &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of &lt;code&gt;E1&lt;/code&gt;, except that &lt;code&gt;E1&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">形式为 &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; 的复合赋值表达式等效于 &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;E1&lt;/code&gt; 的类型，只是 &lt;code&gt;E1&lt;/code&gt; 仅被评估一次。</target>
        </trans-unit>
        <trans-unit id="0364601af1d440782a9886e91357dff484de1aac" translate="yes" xml:space="preserve">
          <source>A good example of this casting is using *= or /=</source>
          <target state="translated">这种铸造的一个很好的例子是使用*=或==。</target>
        </trans-unit>
        <trans-unit id="279a1cd3b464a2d0bba54a74f955b3d3a3176517" translate="yes" xml:space="preserve">
          <source>An example cited from &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2中&lt;/a&gt;引用的示例</target>
        </trans-unit>
        <trans-unit id="1c08b4fc70848c5aae75aab90180bf273db81df6" translate="yes" xml:space="preserve">
          <source>As always with these questions, the JLS holds the answer. In this case &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 Compound Assignment Operators&lt;/a&gt;. An extract:</source>
          <target state="translated">与这些问题一样，JLS保留了答案。 在这种情况下，第&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;1.5.26.2节&amp;ldquo;复合赋值运算符&amp;rdquo;&lt;/a&gt; 。 摘录：</target>
        </trans-unit>
        <trans-unit id="5ba4fa61ea27a5944cb4ae89cf5367ff30ef28ed" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;+=&lt;/code&gt; is coded in such a way that it does type casting. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</source>
          <target state="translated">但是 &lt;code&gt;+=&lt;/code&gt; 的编码方式可以进行类型转换。 &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae130a04cf426d477d3556e10de3f9da51280995" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;a = a + b&lt;/code&gt; doesn't work, that would mean &lt;code&gt;a += b&lt;/code&gt; would never work for bytes if it &lt;code&gt;E1 += E2&lt;/code&gt; was defined to be &lt;code&gt;E1 = E1 + E2&lt;/code&gt;. As the previous example shows, that would be indeed the case. As a hack to make &lt;code&gt;+=&lt;/code&gt; operator work for bytes and shorts, there is an implicit cast involved. It's not that great of a hack, but back during the Java 1.0 work, the focus was on getting the language released to begin with. Now, because of backwards compatibility, this hack introduced in Java 1.0 couldn't be removed.</source>
          <target state="translated">但是，如果 &lt;code&gt;a = a + b&lt;/code&gt; 不起作用，则意味着如果将 &lt;code&gt;E1 += E2&lt;/code&gt; 定义为 &lt;code&gt;E1 = E1 + E2&lt;/code&gt; 则 &lt;code&gt;a += b&lt;/code&gt; 永远不会对字节起作用。 如前面的示例所示，情况确实如此。 作为使 &lt;code&gt;+=&lt;/code&gt; 运算符适用于字节和短裤的技巧，其中涉及隐式强制转换。 这并不是什么骇人听闻的事情，但是在Java 1.0工作期间，重点就在于开始发布该语言。 现在，由于向后兼容，无法删除Java 1.0中引入的这种hack。</target>
        </trans-unit>
        <trans-unit id="ce41838c527dc15014a8a05f5bfa14989fd0fb62" translate="yes" xml:space="preserve">
          <source>But if we try this:</source>
          <target state="translated">但是,如果我们这样试试</target>
        </trans-unit>
        <trans-unit id="9f0e3bc00b013a32678e2121583114b9ebea8a17" translate="yes" xml:space="preserve">
          <source>Did you guess 3? Too bad, this program won't compile. Why? Well, it so happens that addition of bytes in Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;is defined to return an &lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. This, I believe was because the Java Virtual Machine doesn't define byte operations to save on bytecodes (there is a limited number of those, after all), using integer operations instead is an implementation detail exposed in a language.</source>
          <target state="translated">你猜3吗？ 太糟糕了，该程序无法编译。 为什么？ 好吧，碰巧在Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;中定义&lt;/a&gt;了字节加法以返回 &lt;code&gt;int&lt;/code&gt; 。 我相信这是因为Java虚拟机没有定义要保存在字节码上的字节操作（毕竟，字节码数量有限），而使用整数运算代替的是一种语言公开的实现细节。</target>
        </trans-unit>
        <trans-unit id="90a6c7c3c6ca01a564175444b2c818f963863c42" translate="yes" xml:space="preserve">
          <source>Does it mean that in fact &lt;code&gt;i += j;&lt;/code&gt; is a shortcut for something like this
&lt;code&gt;i = (type of i) (i + j)&lt;/code&gt;?</source>
          <target state="translated">这是否意味着实际上 &lt;code&gt;i += j;&lt;/code&gt; 是这样的快捷方式 &lt;code&gt;i = (type of i) (i + j)&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="f038b305feefd0f95fe337d2d2652529bc51747e" translate="yes" xml:space="preserve">
          <source>For example, the following code is correct:</source>
          <target state="translated">例如,下面的代码是正确的。</target>
        </trans-unit>
        <trans-unit id="6267184b2c4bc9e0765ed547ef1d15a1b70c4a85" translate="yes" xml:space="preserve">
          <source>For example, when you write:</source>
          <target state="translated">比如说,当你写的时候。</target>
        </trans-unit>
        <trans-unit id="ee50437b4b89794edd53b64c69655ee58728cf3d" translate="yes" xml:space="preserve">
          <source>I just checked the &lt;code&gt;.class&lt;/code&gt; file code.</source>
          <target state="translated">我只是检查了 &lt;code&gt;.class&lt;/code&gt; 文件代码。</target>
        </trans-unit>
        <trans-unit id="09c7a812797c2454ddd47141dad43697fda9bc3a" translate="yes" xml:space="preserve">
          <source>In Java type conversions are performed automatically when the type of the expression on the right hand side of an assignment operation can be safely promoted to the type of the variable on the left hand side of the assignment. Thus we can safely assign:</source>
          <target state="translated">在Java中,当赋值操作右侧的表达式的类型可以安全地提升到赋值左侧的变量类型时,就会自动进行类型转换。这样,我们就可以安全地进行赋值。</target>
        </trans-unit>
        <trans-unit id="e703016318f8c25d1d9a981d4ddf51e18ef86592" translate="yes" xml:space="preserve">
          <source>In other words, your assumption is correct.</source>
          <target state="translated">换句话说,你的假设是正确的。</target>
        </trans-unit>
        <trans-unit id="f0288786c9a8ca0579fd3f06940f05e0414912fd" translate="yes" xml:space="preserve">
          <source>Java Language Specification &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;defines &lt;code&gt;E1 op= E2&lt;/code&gt; to be equivalent to &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a type of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E1&lt;/code&gt; is evaluated once&lt;/a&gt;.</source>
          <target state="translated">Java语言规范&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;将 &lt;code&gt;E1 op= E2&lt;/code&gt; 定义为等效于 &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;E1&lt;/code&gt; 的类型，并且 &lt;code&gt;E1&lt;/code&gt; 被评估一次&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b31185e5e992669b60849ab724ebe4ddc6e8b508" translate="yes" xml:space="preserve">
          <source>Really a good thing to know</source>
          <target state="translated">真的是个好东西</target>
        </trans-unit>
        <trans-unit id="136ab125acd799cb2684d8539ef560b2a115ae96" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;this description of implicit casting&lt;/a&gt;</source>
          <target state="translated">请参阅： &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;这种隐式转换的描述&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9df74f93008fd50c6905d26834aac49cdb7df29" translate="yes" xml:space="preserve">
          <source>So to avoid it, you must write your code like this:</source>
          <target state="translated">所以为了避免这种情况,你必须这样写你的代码。</target>
        </trans-unit>
        <trans-unit id="e2af4df8f9e3a41bf49850cb8229180cc59381aa" translate="yes" xml:space="preserve">
          <source>Sometimes, such a question can be asked at an interview.</source>
          <target state="translated">有时候,这样的问题可以在面试时问。</target>
        </trans-unit>
        <trans-unit id="bb0b6674314e38164129042867cdc6f53891c049" translate="yes" xml:space="preserve">
          <source>Subtle point here...</source>
          <target state="translated">这里有一个微妙的点.....</target>
        </trans-unit>
        <trans-unit id="20c15c7769ca8dfc4c209fae82587e6da2277494" translate="yes" xml:space="preserve">
          <source>That's a technical answer, but you may be wondering why that's a case. Well, let's consider the following program.</source>
          <target state="translated">这是一个技术性的答案,但你可能会想知道为什么会出现这种情况。那么,我们来考虑一下下面的方案。</target>
        </trans-unit>
        <trans-unit id="44d952297cc065a18903f1a2ab718fa5f744281c" translate="yes" xml:space="preserve">
          <source>The int object is casted to long &amp;amp; both are added and you get long object.</source>
          <target state="translated">将int对象强制转换为long对象，并且两者都添加，就得到long对象。</target>
        </trans-unit>
        <trans-unit id="d34716a0ce9b35449bd1b46cfa8514187cf0d601" translate="yes" xml:space="preserve">
          <source>The main difference is that with &lt;code&gt;a = a + b&lt;/code&gt;, there is no typecasting going on, and so the compiler gets angry at you for not typecasting. But with &lt;code&gt;a += b&lt;/code&gt;, what it's really doing is typecasting &lt;code&gt;b&lt;/code&gt; to a type compatible with &lt;code&gt;a&lt;/code&gt;. So if you do</source>
          <target state="translated">主要区别在于，使用 &lt;code&gt;a = a + b&lt;/code&gt; ，不会进行类型转换，因此编译器会因为不进行类型转换而对您生气。 但是， &lt;code&gt;a += b&lt;/code&gt; ，实际上是将 &lt;code&gt;b&lt;/code&gt; 类型转换为与 &lt;code&gt;a&lt;/code&gt; 兼容的类型。 所以如果你这样做</target>
        </trans-unit>
        <trans-unit id="c9ec6704b481e32d0673f24b11fe4cd91a634830" translate="yes" xml:space="preserve">
          <source>The problem here involves type casting.</source>
          <target state="translated">这里的问题涉及类型铸造。</target>
        </trans-unit>
        <trans-unit id="3286136395a3eb8402d57f9a1bc02f232511f195" translate="yes" xml:space="preserve">
          <source>The same will not work the other way round. For example we cannot automatically convert a long to an int because the first requires more storage than the second and consequently information may be lost. To force such a conversion we must carry out an explicit conversion.</source>
          <target state="translated">同样的情况也不会反过来。例如,我们不能自动将一个长转换为英特,因为前者需要比后者更多的存储量,因此信息可能会丢失。要强制进行这样的转换,我们必须进行显式转换。</target>
        </trans-unit>
        <trans-unit id="b127c9759204a223a39e541475b7e0a7e7e23d2a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;i = i + j;&lt;/code&gt; will not compile but &lt;code&gt;i += j;&lt;/code&gt; will compile fine.</source>
          <target state="translated">那么 &lt;code&gt;i = i + j;&lt;/code&gt; 不会编译，但是 &lt;code&gt;i += j;&lt;/code&gt; 会编译的很好。</target>
        </trans-unit>
        <trans-unit id="28a6f37f42e10bd31723edb18b5351d75d790c1d" translate="yes" xml:space="preserve">
          <source>There is an implicit typecast for &lt;code&gt;i+j&lt;/code&gt; when &lt;code&gt;j&lt;/code&gt; is a double and &lt;code&gt;i&lt;/code&gt; is an int.
Java &lt;strong&gt;ALWAYS&lt;/strong&gt; converts an integer into a double when there is an operation between them.</source>
          <target state="translated">当 &lt;code&gt;j&lt;/code&gt; 为双精度数且 &lt;code&gt;i&lt;/code&gt; 为整数时， &lt;code&gt;i+j&lt;/code&gt; 有一个隐式类型转换。 当它们之间存在运算&lt;strong&gt;符&lt;/strong&gt;时，Java &lt;strong&gt;总是&lt;/strong&gt;将整数转换为双&lt;strong&gt;精度&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="146c922e0dbcf587665f9004107892ed8a734050" translate="yes" xml:space="preserve">
          <source>To clarify &lt;code&gt;i+=j&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is an integer and &lt;code&gt;j&lt;/code&gt; is a double can be described as</source>
          <target state="translated">为了阐明 &lt;code&gt;i+=j&lt;/code&gt; ，其中 &lt;code&gt;i&lt;/code&gt; 是整数， &lt;code&gt;j&lt;/code&gt; 是双精度数，可以描述为</target>
        </trans-unit>
        <trans-unit id="9cdafb8a4569a39dbdd1cc8242f4f864cebd4626" translate="yes" xml:space="preserve">
          <source>Type - Conversion</source>
          <target state="translated">类型-转换</target>
        </trans-unit>
        <trans-unit id="ef7e30718b01b4bd3649ae836ce2c2fdd526fae9" translate="yes" xml:space="preserve">
          <source>Until today, I thought that for example:</source>
          <target state="translated">直到今天,我以为,比如说。</target>
        </trans-unit>
        <trans-unit id="b411cd5e8ac2d2bfefe7e0438232a5781a92da47" translate="yes" xml:space="preserve">
          <source>Very good question. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;Java Language specification&lt;/a&gt; confirms your suggestion.</source>
          <target state="translated">很好的问题。 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;Java语言规范&lt;/a&gt;证实了您的建议。</target>
        </trans-unit>
        <trans-unit id="44dc017327f8da38205d25425b212a6438058ba2" translate="yes" xml:space="preserve">
          <source>Was just a shortcut for:</source>
          <target state="translated">只是一个捷径。</target>
        </trans-unit>
        <trans-unit id="1a0fa91703a3ea7b0b51339b8cc7effdea9442a4" translate="yes" xml:space="preserve">
          <source>What does this program print?</source>
          <target state="translated">这个程序打印的是什么?</target>
        </trans-unit>
        <trans-unit id="b2dff14df907b2d5ff7b98620dd6c9165e4f01d1" translate="yes" xml:space="preserve">
          <source>What you're really doing is:</source>
          <target state="translated">你真正在做的是:</target>
        </trans-unit>
        <trans-unit id="16d0d8b1356f59eb5978f70aaf70dff973325c9c" translate="yes" xml:space="preserve">
          <source>When you add int and long,</source>
          <target state="translated">当你加入int和long时。</target>
        </trans-unit>
        <trans-unit id="b018561bc12ef2acfd1631f5b6349bcd49475341" translate="yes" xml:space="preserve">
          <source>Why don't Java's +=, -=, *=, /= compound assignment operators require casting</source>
          <target state="translated">为什么Java的+=、-=、-=、*=、=复合赋值操作符不需要铸造?</target>
        </trans-unit>
        <trans-unit id="b00cc12a28a0c5716ac5d5e1ead3036b83db8701" translate="yes" xml:space="preserve">
          <source>Yes,</source>
          <target state="translated">Yes,</target>
        </trans-unit>
        <trans-unit id="34823a2aa2982535156ec845d3c3dab8c6cfbcc9" translate="yes" xml:space="preserve">
          <source>You might want to typecast &lt;code&gt;j&lt;/code&gt; to &lt;code&gt;(int)&lt;/code&gt; in this case for clarity.</source>
          <target state="translated">为了清楚起见，您可能希望在这种情况下将 &lt;code&gt;j&lt;/code&gt; 强制转换为 &lt;code&gt;(int)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02fb86dce452e33394dfd5daada6819af636150a" translate="yes" xml:space="preserve">
          <source>[...] the following code is correct:</source>
          <target state="translated">[....]下列代码正确的是()。</target>
        </trans-unit>
        <trans-unit id="acd218195a6faad005e9b62c9455d3692d86cde7" translate="yes" xml:space="preserve">
          <source>and results in x having the value 7 because it is equivalent to:</source>
          <target state="translated">并导致x的值为7,因为它相当于:</target>
        </trans-unit>
        <trans-unit id="b0457b0000b3d4130147f6d71d7c50eeb982269b" translate="yes" xml:space="preserve">
          <source>basically when we write</source>
          <target state="translated">基本上,当我们写</target>
        </trans-unit>
        <trans-unit id="60cf96c8674fdb6fb0b57b394e68cb4ef42e2182" translate="yes" xml:space="preserve">
          <source>but in case of &lt;code&gt;+=&lt;/code&gt; it just works fine because the operator implicitly does the type casting from type of right variable to type of left variable so need not cast explicitly.</source>
          <target state="translated">但是在 &lt;code&gt;+=&lt;/code&gt; 的情况下，它可以很好地工作，因为运算符会隐式执行从右变量类型到左变量类型的类型转换，因此无需显式转换。</target>
        </trans-unit>
        <trans-unit id="d02946c187bcbe2fa7b786addfc08b8b6cf361bb" translate="yes" xml:space="preserve">
          <source>but long object cannot be implicitly casted to int. So, you have to do that explicitly.</source>
          <target state="translated">但长对象不能被隐式铸造为int。所以,你必须要明确地做到这一点。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0060fef58e92ce48614c8bf13ac0553c1193b98c" translate="yes" xml:space="preserve">
          <source>the compiler converts this to</source>
          <target state="translated">编译器将其转换为</target>
        </trans-unit>
        <trans-unit id="b6da30c33c6cd325a034851de899b65419fa7622" translate="yes" xml:space="preserve">
          <source>there is no automatic typecasting. In C++ there will not be any error compiling the above code, but in Java you will get something like &lt;code&gt;Incompatible type exception&lt;/code&gt;.</source>
          <target state="translated">没有自动类型转换。 在C ++中，编译上面的代码不会有任何错误，但是在Java中，您会得到类似 &lt;code&gt;Incompatible type exception&lt;/code&gt; 的信息 。</target>
        </trans-unit>
        <trans-unit id="6825281ba91a2e72c36c939224152fce4b08a6da" translate="yes" xml:space="preserve">
          <source>you need to cast from &lt;code&gt;long&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;&lt;code&gt;explicitly&lt;/code&gt; in case of &lt;code&gt;i = i + l&lt;/code&gt;  then it will compile and give correct output. like</source>
          <target state="translated">如果 &lt;code&gt;i = i + l&lt;/code&gt; 则需要从 &lt;code&gt;long&lt;/code&gt; &lt;code&gt;explicitly&lt;/code&gt; 为 &lt;code&gt;int&lt;/code&gt; ，然后它将进行编译并提供正确的输出。 喜欢</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
