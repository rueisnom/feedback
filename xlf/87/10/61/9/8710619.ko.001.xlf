<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/8710619">
    <body>
      <group id="8710619">
        <trans-unit id="fe6e80afa27690a6a1e23042a03339d49cd2b679" translate="yes" xml:space="preserve">
          <source>A compound assignment expression of the form &lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; is equivalent to &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of &lt;code&gt;E1&lt;/code&gt;, except that &lt;code&gt;E1&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">&lt;code&gt;E1&amp;nbsp;op=&amp;nbsp;E2&lt;/code&gt; 형식의 복합 할당 표현식은 &lt;code&gt;E1&amp;nbsp;=&amp;nbsp;(T)((E1)&amp;nbsp;op&amp;nbsp;(E2))&lt;/code&gt; 와 동일합니다. 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;E1&lt;/code&gt; 유형이며 &lt;code&gt;E1&lt;/code&gt; 은 한 번만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="0364601af1d440782a9886e91357dff484de1aac" translate="yes" xml:space="preserve">
          <source>A good example of this casting is using *= or /=</source>
          <target state="translated">이 캐스팅의 좋은 예는 * = 또는 / =</target>
        </trans-unit>
        <trans-unit id="279a1cd3b464a2d0bba54a74f955b3d3a3176517" translate="yes" xml:space="preserve">
          <source>An example cited from &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2&lt;/a&gt; 에서 인용 된 예</target>
        </trans-unit>
        <trans-unit id="1c08b4fc70848c5aae75aab90180bf273db81df6" translate="yes" xml:space="preserve">
          <source>As always with these questions, the JLS holds the answer. In this case &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 Compound Assignment Operators&lt;/a&gt;. An extract:</source>
          <target state="translated">이러한 질문들과 마찬가지로 JLS는 그 해답을 가지고 있습니다. 이 경우 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;&amp;sect;15.26.2 복합 할당 연산자&lt;/a&gt; . 추출물 :</target>
        </trans-unit>
        <trans-unit id="5ba4fa61ea27a5944cb4ae89cf5367ff30ef28ed" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;+=&lt;/code&gt; is coded in such a way that it does type casting. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</source>
          <target state="translated">그러나 &lt;code&gt;+=&lt;/code&gt; 는 유형 캐스팅을 수행하는 방식으로 코딩됩니다. &lt;code&gt;i=(int)(i+m)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae130a04cf426d477d3556e10de3f9da51280995" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;a = a + b&lt;/code&gt; doesn't work, that would mean &lt;code&gt;a += b&lt;/code&gt; would never work for bytes if it &lt;code&gt;E1 += E2&lt;/code&gt; was defined to be &lt;code&gt;E1 = E1 + E2&lt;/code&gt;. As the previous example shows, that would be indeed the case. As a hack to make &lt;code&gt;+=&lt;/code&gt; operator work for bytes and shorts, there is an implicit cast involved. It's not that great of a hack, but back during the Java 1.0 work, the focus was on getting the language released to begin with. Now, because of backwards compatibility, this hack introduced in Java 1.0 couldn't be removed.</source>
          <target state="translated">그러나 &lt;code&gt;a = a + b&lt;/code&gt; 가 작동하지 않으면 &lt;code&gt;a += b&lt;/code&gt; 가 바이트에 대해 작동하지 않을 것입니다. &lt;code&gt;E1 += E2&lt;/code&gt; 가 &lt;code&gt;E1 = E1 + E2&lt;/code&gt; 로 정의 된 경우. 앞의 예제에서 알 수 있듯이 실제로는 그럴 것입니다. 바이트와 ​​쇼트에 &lt;code&gt;+=&lt;/code&gt; 연산자를 사용하기위한 해킹으로, 암시 적 캐스트가 수반됩니다. 그다지 해킹은 아니지만 Java 1.0 작업 중에는 언어 출시를 시작하는 데 중점을 두었습니다. 이전 버전과의 호환성으로 인해 Java 1.0에 도입 된이 핵을 제거 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="ce41838c527dc15014a8a05f5bfa14989fd0fb62" translate="yes" xml:space="preserve">
          <source>But if we try this:</source>
          <target state="translated">그러나 우리가 이것을 시도한다면 :</target>
        </trans-unit>
        <trans-unit id="9f0e3bc00b013a32678e2121583114b9ebea8a17" translate="yes" xml:space="preserve">
          <source>Did you guess 3? Too bad, this program won't compile. Why? Well, it so happens that addition of bytes in Java &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;is defined to return an &lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. This, I believe was because the Java Virtual Machine doesn't define byte operations to save on bytecodes (there is a limited number of those, after all), using integer operations instead is an implementation detail exposed in a language.</source>
          <target state="translated">당신은 3을 추측 했습니까? 이 프로그램은 컴파일되지 않습니다. 왜? Java에 바이트를 추가 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2&quot;&gt;하면 &lt;code&gt;int&lt;/code&gt; 를 반환하도록 정의됩니다&lt;/a&gt; . Java Virtual Machine은 바이트 코드를 저장하기 위해 바이트 연산을 정의하지 않기 때문에 (결국 제한된 수의 정수가 있음) 정수 연산을 사용하는 대신 언어에 노출 된 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="90a6c7c3c6ca01a564175444b2c818f963863c42" translate="yes" xml:space="preserve">
          <source>Does it mean that in fact &lt;code&gt;i += j;&lt;/code&gt; is a shortcut for something like this
&lt;code&gt;i = (type of i) (i + j)&lt;/code&gt;?</source>
          <target state="translated">실제로 &lt;code&gt;i += j;&lt;/code&gt; 이 &lt;code&gt;i = (type of i) (i + j)&lt;/code&gt; 와 같은 바로 가기입니까?</target>
        </trans-unit>
        <trans-unit id="f038b305feefd0f95fe337d2d2652529bc51747e" translate="yes" xml:space="preserve">
          <source>For example, the following code is correct:</source>
          <target state="translated">예를 들어 다음 코드는 정확합니다.</target>
        </trans-unit>
        <trans-unit id="6267184b2c4bc9e0765ed547ef1d15a1b70c4a85" translate="yes" xml:space="preserve">
          <source>For example, when you write:</source>
          <target state="translated">예를 들어 다음과 같이 쓸 때</target>
        </trans-unit>
        <trans-unit id="ee50437b4b89794edd53b64c69655ee58728cf3d" translate="yes" xml:space="preserve">
          <source>I just checked the &lt;code&gt;.class&lt;/code&gt; file code.</source>
          <target state="translated">방금 &lt;code&gt;.class&lt;/code&gt; 파일 코드를 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="09c7a812797c2454ddd47141dad43697fda9bc3a" translate="yes" xml:space="preserve">
          <source>In Java type conversions are performed automatically when the type of the expression on the right hand side of an assignment operation can be safely promoted to the type of the variable on the left hand side of the assignment. Thus we can safely assign:</source>
          <target state="translated">할당 유형의 오른쪽에있는 표현식 유형이 할당의 왼쪽에있는 변수 유형으로 안전하게 승격 될 수있는 경우 Java 유형 변환은 자동으로 수행됩니다. 따라서 다음을 안전하게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e703016318f8c25d1d9a981d4ddf51e18ef86592" translate="yes" xml:space="preserve">
          <source>In other words, your assumption is correct.</source>
          <target state="translated">다시 말해, 당신의 가정은 맞습니다.</target>
        </trans-unit>
        <trans-unit id="f0288786c9a8ca0579fd3f06940f05e0414912fd" translate="yes" xml:space="preserve">
          <source>Java Language Specification &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;defines &lt;code&gt;E1 op= E2&lt;/code&gt; to be equivalent to &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a type of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E1&lt;/code&gt; is evaluated once&lt;/a&gt;.</source>
          <target state="translated">Java 언어 사양 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2&quot;&gt;은 &lt;code&gt;E1 op= E2&lt;/code&gt; 를 &lt;code&gt;E1 = (T) ((E1) op (E2))&lt;/code&gt; 와 동일하게 정의합니다. 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;E1&lt;/code&gt; 유형이고 &lt;code&gt;E1&lt;/code&gt; 은 한 번 평가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b31185e5e992669b60849ab724ebe4ddc6e8b508" translate="yes" xml:space="preserve">
          <source>Really a good thing to know</source>
          <target state="translated">정말 좋은 점</target>
        </trans-unit>
        <trans-unit id="136ab125acd799cb2684d8539ef560b2a115ae96" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;this description of implicit casting&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://www.cs.cmu.edu/~pattis/15-1XX/15-200/lectures/voe/lecture.html#ImplicitConversion&quot;&gt;암시 적 캐스팅에 대한이 설명&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9df74f93008fd50c6905d26834aac49cdb7df29" translate="yes" xml:space="preserve">
          <source>So to avoid it, you must write your code like this:</source>
          <target state="translated">따라서이를 피하려면 다음과 같이 코드를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2af4df8f9e3a41bf49850cb8229180cc59381aa" translate="yes" xml:space="preserve">
          <source>Sometimes, such a question can be asked at an interview.</source>
          <target state="translated">때로는 인터뷰에서 그러한 질문을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb0b6674314e38164129042867cdc6f53891c049" translate="yes" xml:space="preserve">
          <source>Subtle point here...</source>
          <target state="translated">미묘한 점은 ...</target>
        </trans-unit>
        <trans-unit id="20c15c7769ca8dfc4c209fae82587e6da2277494" translate="yes" xml:space="preserve">
          <source>That's a technical answer, but you may be wondering why that's a case. Well, let's consider the following program.</source>
          <target state="translated">그것은 기술적 인 답변이지만 왜 그런지 궁금 할 것입니다. 다음 프로그램을 생각해 보자.</target>
        </trans-unit>
        <trans-unit id="44d952297cc065a18903f1a2ab718fa5f744281c" translate="yes" xml:space="preserve">
          <source>The int object is casted to long &amp;amp; both are added and you get long object.</source>
          <target state="translated">int 객체는 long으로 캐스트되고 둘 다 추가되며 긴 객체를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d34716a0ce9b35449bd1b46cfa8514187cf0d601" translate="yes" xml:space="preserve">
          <source>The main difference is that with &lt;code&gt;a = a + b&lt;/code&gt;, there is no typecasting going on, and so the compiler gets angry at you for not typecasting. But with &lt;code&gt;a += b&lt;/code&gt;, what it's really doing is typecasting &lt;code&gt;b&lt;/code&gt; to a type compatible with &lt;code&gt;a&lt;/code&gt;. So if you do</source>
          <target state="translated">주요 차이점은 &lt;code&gt;a = a + b&lt;/code&gt; 이면 typecasting이 진행되지 않으므로 컴파일러가 typecasting을하지 않은 것에 대해 화가납니다. 그러나 &lt;code&gt;a += b&lt;/code&gt; 하면 실제로하는 것은 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 와 호환되는 유형으로 타입 캐스팅 하는 것 입니다. 그래서 당신이 할 경우</target>
        </trans-unit>
        <trans-unit id="c9ec6704b481e32d0673f24b11fe4cd91a634830" translate="yes" xml:space="preserve">
          <source>The problem here involves type casting.</source>
          <target state="translated">여기서 문제는 유형 캐스팅과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3286136395a3eb8402d57f9a1bc02f232511f195" translate="yes" xml:space="preserve">
          <source>The same will not work the other way round. For example we cannot automatically convert a long to an int because the first requires more storage than the second and consequently information may be lost. To force such a conversion we must carry out an explicit conversion.</source>
          <target state="translated">다른 방식으로는 동일하게 작동하지 않습니다. 예를 들어 첫 번째는 두 번째보다 많은 저장 공간이 필요하고 결과적으로 정보가 손실 될 수 있기 때문에 long을 int로 자동 변환 할 수 없습니다. 그러한 개종을 강요하려면 명시적인 개종을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b127c9759204a223a39e541475b7e0a7e7e23d2a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;i = i + j;&lt;/code&gt; will not compile but &lt;code&gt;i += j;&lt;/code&gt; will compile fine.</source>
          <target state="translated">그런 다음 &lt;code&gt;i = i + j;&lt;/code&gt; 컴파일하지 않지만 &lt;code&gt;i += j;&lt;/code&gt; 잘 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="28a6f37f42e10bd31723edb18b5351d75d790c1d" translate="yes" xml:space="preserve">
          <source>There is an implicit typecast for &lt;code&gt;i+j&lt;/code&gt; when &lt;code&gt;j&lt;/code&gt; is a double and &lt;code&gt;i&lt;/code&gt; is an int.
Java &lt;strong&gt;ALWAYS&lt;/strong&gt; converts an integer into a double when there is an operation between them.</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; 가 double이고 &lt;code&gt;i&lt;/code&gt; 가 int 인 경우 &lt;code&gt;i+j&lt;/code&gt; 에 대한 암시 적 타입 캐스트가 있습니다. Java는 &lt;strong&gt;항상&lt;/strong&gt; 정수 사이에 연산이있을 때 정수를 double로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="146c922e0dbcf587665f9004107892ed8a734050" translate="yes" xml:space="preserve">
          <source>To clarify &lt;code&gt;i+=j&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is an integer and &lt;code&gt;j&lt;/code&gt; is a double can be described as</source>
          <target state="translated">&lt;code&gt;i+=j&lt;/code&gt; 를 명확히하기 위해, 여기서 &lt;code&gt;i&lt;/code&gt; 는 정수이고 &lt;code&gt;j&lt;/code&gt; 는 이중이다</target>
        </trans-unit>
        <trans-unit id="9cdafb8a4569a39dbdd1cc8242f4f864cebd4626" translate="yes" xml:space="preserve">
          <source>Type - Conversion</source>
          <target state="translated">유형-변환</target>
        </trans-unit>
        <trans-unit id="ef7e30718b01b4bd3649ae836ce2c2fdd526fae9" translate="yes" xml:space="preserve">
          <source>Until today, I thought that for example:</source>
          <target state="translated">오늘까지는 예를 들어 다음과 같이 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="b411cd5e8ac2d2bfefe7e0438232a5781a92da47" translate="yes" xml:space="preserve">
          <source>Very good question. The &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;Java Language specification&lt;/a&gt; confirms your suggestion.</source>
          <target state="translated">아주 좋은 질문입니다. &lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2&quot;&gt;Java 언어 사양&lt;/a&gt; 은 제안 사항을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="44dc017327f8da38205d25425b212a6438058ba2" translate="yes" xml:space="preserve">
          <source>Was just a shortcut for:</source>
          <target state="translated">다음에 대한 바로 가기였습니다.</target>
        </trans-unit>
        <trans-unit id="1a0fa91703a3ea7b0b51339b8cc7effdea9442a4" translate="yes" xml:space="preserve">
          <source>What does this program print?</source>
          <target state="translated">이 프로그램은 무엇을 인쇄합니까?</target>
        </trans-unit>
        <trans-unit id="b2dff14df907b2d5ff7b98620dd6c9165e4f01d1" translate="yes" xml:space="preserve">
          <source>What you're really doing is:</source>
          <target state="translated">당신이 정말로하고있는 일은 :</target>
        </trans-unit>
        <trans-unit id="16d0d8b1356f59eb5978f70aaf70dff973325c9c" translate="yes" xml:space="preserve">
          <source>When you add int and long,</source>
          <target state="translated">int와 long을 추가하면</target>
        </trans-unit>
        <trans-unit id="b018561bc12ef2acfd1631f5b6349bcd49475341" translate="yes" xml:space="preserve">
          <source>Why don't Java's +=, -=, *=, /= compound assignment operators require casting</source>
          <target state="translated">Java의 + =,-=, * =, / = 복합 할당 연산자가 캐스팅을 요구하지 않는 이유</target>
        </trans-unit>
        <trans-unit id="b00cc12a28a0c5716ac5d5e1ead3036b83db8701" translate="yes" xml:space="preserve">
          <source>Yes,</source>
          <target state="translated">Yes,</target>
        </trans-unit>
        <trans-unit id="34823a2aa2982535156ec845d3c3dab8c6cfbcc9" translate="yes" xml:space="preserve">
          <source>You might want to typecast &lt;code&gt;j&lt;/code&gt; to &lt;code&gt;(int)&lt;/code&gt; in this case for clarity.</source>
          <target state="translated">이 경우 명확성을 위해 &lt;code&gt;j&lt;/code&gt; 를 &lt;code&gt;(int)&lt;/code&gt; 로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02fb86dce452e33394dfd5daada6819af636150a" translate="yes" xml:space="preserve">
          <source>[...] the following code is correct:</source>
          <target state="translated">[...] 다음 코드가 맞습니다 :</target>
        </trans-unit>
        <trans-unit id="acd218195a6faad005e9b62c9455d3692d86cde7" translate="yes" xml:space="preserve">
          <source>and results in x having the value 7 because it is equivalent to:</source>
          <target state="translated">x는 다음과 같기 때문에 값 7을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b0457b0000b3d4130147f6d71d7c50eeb982269b" translate="yes" xml:space="preserve">
          <source>basically when we write</source>
          <target state="translated">기본적으로 우리가 쓸 때</target>
        </trans-unit>
        <trans-unit id="60cf96c8674fdb6fb0b57b394e68cb4ef42e2182" translate="yes" xml:space="preserve">
          <source>but in case of &lt;code&gt;+=&lt;/code&gt; it just works fine because the operator implicitly does the type casting from type of right variable to type of left variable so need not cast explicitly.</source>
          <target state="translated">그러나 &lt;code&gt;+=&lt;/code&gt; 의 경우 연산자가 묵시적으로 올바른 변수 유형에서 왼쪽 변수 유형으로 유형 캐스팅을 수행하므로 명시 적으로 캐스팅 할 필요가 없으므로 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d02946c187bcbe2fa7b786addfc08b8b6cf361bb" translate="yes" xml:space="preserve">
          <source>but long object cannot be implicitly casted to int. So, you have to do that explicitly.</source>
          <target state="translated">그러나 긴 객체는 암시 적으로 int로 캐스팅 할 수 없습니다. 따라서 명시 적으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0060fef58e92ce48614c8bf13ac0553c1193b98c" translate="yes" xml:space="preserve">
          <source>the compiler converts this to</source>
          <target state="translated">컴파일러는 이것을 이것을</target>
        </trans-unit>
        <trans-unit id="b6da30c33c6cd325a034851de899b65419fa7622" translate="yes" xml:space="preserve">
          <source>there is no automatic typecasting. In C++ there will not be any error compiling the above code, but in Java you will get something like &lt;code&gt;Incompatible type exception&lt;/code&gt;.</source>
          <target state="translated">자동 타입 캐스팅이 없습니다. C ++에서는 위의 코드를 컴파일하는 데 오류가 없지만 Java에서는 &lt;code&gt;Incompatible type exception&lt;/code&gt; 과 같은 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6825281ba91a2e72c36c939224152fce4b08a6da" translate="yes" xml:space="preserve">
          <source>you need to cast from &lt;code&gt;long&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;&lt;code&gt;explicitly&lt;/code&gt; in case of &lt;code&gt;i = i + l&lt;/code&gt;  then it will compile and give correct output. like</source>
          <target state="translated">&lt;code&gt;i = i + l&lt;/code&gt; 경우 &lt;code&gt;long&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; 로 &lt;code&gt;explicitly&lt;/code&gt; 캐스팅해야 컴파일되고 올바른 출력을 제공합니다. 처럼</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
