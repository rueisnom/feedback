<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/784929">
    <body>
      <group id="784929">
        <trans-unit id="9d8ee90d447e634111f086fe5d63063e02604c04" translate="yes" xml:space="preserve">
          <source>! is &quot;boolean not&quot;, which essentially typecasts the value of &quot;enable&quot; to its boolean opposite. The second ! flips this value. So, &lt;code&gt;!!enable&lt;/code&gt; means &quot;not not enable,&quot; giving you the value of &lt;code&gt;enable&lt;/code&gt; as a boolean.</source>
          <target state="translated">！ 「boolean not」であり、基本的に「enable」の値を反対のブール値に型キャストします。 二番目 ！ この値を反転します。 したがって、 &lt;code&gt;!!enable&lt;/code&gt; は「有効にしない」 ことを意味し、ブール値として &lt;code&gt;enable&lt;/code&gt; の値を提供します。</target>
        </trans-unit>
        <trans-unit id="1267640ee6e890d8ceb635273042d73661945ffd" translate="yes" xml:space="preserve">
          <source>(please read code descriptions)</source>
          <target state="translated">(コードの説明をお読みください)</target>
        </trans-unit>
        <trans-unit id="dbc5329443fc97ea79e3d6fc7a7c08bb400f6cdb" translate="yes" xml:space="preserve">
          <source>... you might be surprised to see React render a &lt;code&gt;0&lt;/code&gt; when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns &lt;code&gt;0&lt;/code&gt;, which JSX happily renders, as it should. It can't tell you didn't have &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (or something less contrived).</source>
          <target state="translated">...メッセージがゼロのときにReactが &lt;code&gt;0&lt;/code&gt; をレンダリングするのを見ると、驚くかもしれません。 JSXがレンダリングされないようにするには、明示的にfalseを返す必要があります。 上記のステートメントは &lt;code&gt;0&lt;/code&gt; を返し、JSXは正常にレンダリングします。 &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; がなかったことはわかりません：{messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt; Get your count to zero！&amp;lt;/ div&amp;gt;} （または何か不自然なこと）。</target>
        </trans-unit>
        <trans-unit id="c4b43c7ba8236eeadfe785d67215c403a6e6e119" translate="yes" xml:space="preserve">
          <source>...will NOT result in a true condition, and the code block will not be executed, even if the element does exist.</source>
          <target state="translated">...は真の状態にはならず、たとえ要素が存在していてもコードブロックは実行されません。</target>
        </trans-unit>
        <trans-unit id="bd18c0553a45634b99d4953abd9dd07bb59545b2" translate="yes" xml:space="preserve">
          <source>3rd party libraries that expect explicit Boolean values</source>
          <target state="translated">明示的なブール値を期待するサードパーティライブラリ</target>
        </trans-unit>
        <trans-unit id="05317c9a3565f977ff95a0b1172dd228b7234929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!0 === false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!!0 === false&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b16fdc2b982571586ffd6bc3139aa446dfb0262b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; converts the value to the right of it to its equivalent boolean value. (Think poor man's way of &quot;type-casting&quot;). Its &lt;em&gt;intent&lt;/em&gt; is usually to convey to the reader that the code does not care &lt;em&gt;what&lt;/em&gt; value is in the variable, but what it's &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&quot;truth&quot; value&lt;/a&gt; is.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 右側の値を同等のブール値に変換します。 （貧しい人の「型キャスト」の方法を考えてください）。 その&lt;em&gt;意図&lt;/em&gt;は通常、コードが変数に&lt;em&gt;どのような&lt;/em&gt;値が入っているかではなく、それが&lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;「真の」値で&lt;/a&gt;あるかどうかを読者に伝えることです。</target>
        </trans-unit>
        <trans-unit id="de68e033596cd4f5d22f42c9c74a29c3813083dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; is not an operator. It is the double-use of &lt;code&gt;!&lt;/code&gt; -- which is the logical &quot;not&quot; operator.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; は演算子ではありません。 の兼用です &lt;code&gt;!&lt;/code&gt; -これは論理的な「否定」演算子です。</target>
        </trans-unit>
        <trans-unit id="0c49aab7f0deeecf7c139cada81e75156b64a3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; it's using &lt;code&gt;NOT&lt;/code&gt; operation twice together, &lt;code&gt;!&lt;/code&gt; convert the value to a &lt;code&gt;boolean&lt;/code&gt; and reverse it, here is a simple example to see how &lt;code&gt;!!&lt;/code&gt; works:</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; &lt;code&gt;NOT&lt;/code&gt; 演算を一緒に2回使用してい &lt;code&gt;!&lt;/code&gt; 値を &lt;code&gt;boolean&lt;/code&gt; 値に変換し、それを逆にします。ここに、簡単な例を示します &lt;code&gt;!!&lt;/code&gt; 動作します：</target>
        </trans-unit>
        <trans-unit id="40472ff2de807d44da0389b6ed6c479fe97e450d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!expr&lt;/code&gt; returns a Boolean value (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) depending on the &lt;em&gt;truthiness&lt;/em&gt; of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:</source>
          <target state="translated">&lt;code&gt;!!expr&lt;/code&gt; は、式の&lt;em&gt;真実性&lt;/em&gt;に応じてブール値（ &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; ）を返します。 非ブール型で使用するとより意味があります。 これらの例、特に3番目の例以降を検討してください。</target>
        </trans-unit>
        <trans-unit id="c11c8b2ce2578dcc578b1ef73f483f4da8bddb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!foo&lt;/code&gt; applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus &lt;code&gt;+foo&lt;/code&gt; to cast to number and concatenating an empty string &lt;code&gt;''+foo&lt;/code&gt; to cast to string.</source>
          <target state="translated">&lt;code&gt;!!foo&lt;/code&gt; は、単項not演算子を2回適用し、ブール型にキャストするために使用され、単項プラス &lt;code&gt;+foo&lt;/code&gt; を使用して数値にキャストし、空の文字列 &lt;code&gt;''+foo&lt;/code&gt; を連結して文字列にキャストします。</target>
        </trans-unit>
        <trans-unit id="a3fbcf80055d72c6902769ea1b0b209d18d54c31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; is &lt;code&gt;!!0 === !!undefined&lt;/code&gt; and is true! Same truthiness! (In this case, both &quot;have a truthiness of falsy&quot;.)</source>
          <target state="translated">&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; は &lt;code&gt;!!0 === !!undefined&lt;/code&gt; であり、trueです！ 同じ真実！ （この場合、どちらも「偽りの真実性を持っている」）。</target>
        </trans-unit>
        <trans-unit id="d3afe30734c2565c10167b232d767321261e858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!x&lt;/code&gt; is shorthand for &lt;code&gt;Boolean(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!!x&lt;/code&gt; は &lt;code&gt;Boolean(x)&lt;/code&gt; の省略形です</target>
        </trans-unit>
        <trans-unit id="721b932e6bc1cc17c9cd50fea7dc4b8b7a6ad668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is &lt;em&gt;NOT&lt;/em&gt;.  So &lt;code&gt;!true&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;!0&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!1&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; はあり&lt;em&gt;ません&lt;/em&gt; 。 つまり、 &lt;code&gt;!true&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; であり、 &lt;code&gt;!false&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。 &lt;code&gt;!0&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;!1&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a84f888f6e0a39683c0e570def98bcac6595167f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0 === false&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0 === false&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="601bab0f9b947357bf0bbc8ebc5b625e5e7af331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; is a bitwise AND; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; is a logical AND. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; (a false value); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; がビット単位のANDの場合 &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; が論理ANDの場合。 &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; （偽の値）です。 &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; はtrueです。</target>
        </trans-unit>
        <trans-unit id="fe8e944fda44e395ec8eb52766a2d42b25be5541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a = b)&lt;/code&gt; is assignment followed by use of the truth value of &lt;code&gt;b&lt;/code&gt;; &lt;code&gt;if (a == b)&lt;/code&gt; is an equality comparison.</source>
          <target state="translated">&lt;code&gt;if (a = b)&lt;/code&gt; が代入の後に &lt;code&gt;b&lt;/code&gt; の真理値を使用する場合; &lt;code&gt;if (a == b)&lt;/code&gt; が等値比較である場合。</target>
        </trans-unit>
        <trans-unit id="a4c32abc5c7932aafafe8b72767dd17a9e12923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myVar1 === myVar2&lt;/code&gt; is &lt;code&gt;0 === undefined&lt;/code&gt; and is obviously false.</source>
          <target state="translated">&lt;code&gt;myVar1 === myVar2&lt;/code&gt; は &lt;code&gt;0 === undefined&lt;/code&gt; であり、明らかにfalseです。</target>
        </trans-unit>
        <trans-unit id="7899bf510c8f1081aeced8dc9e82c3717d6f3a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is &lt;em&gt;not&lt;/em&gt; not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!!&lt;/code&gt; &lt;/strong&gt; 値では&lt;em&gt;ない&lt;/em&gt;ものの「真実」を決定します。</target>
        </trans-unit>
        <trans-unit id="05ffd1c973d25f3fa642c01bde2e2d7437ff0b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!&lt;/code&gt; &lt;/strong&gt; 値ではないものの「真実」を決定します。</target>
        </trans-unit>
        <trans-unit id="6d9ad97a5f3ee3fba703f038b8cb73c50bd30761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brew some tea:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;お茶を淹れます：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80a5baf090dcfffcd4153848ee43b313dff5f952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But wait, there's more!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;しかし、待ってください、まだまだあります！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3574ce92cb57aeb1f7ff451de1bbe4886856bb60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 24 Oct 2017, 6 Feb 19:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集2017年10月24日、2月19日：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a055a42c402ff7009188d3b50ace76756b7075b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実際には：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36ed1544d47aa0950bc63b80406386d69ec830fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In theory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;理論的には：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a17136c4cff424debad877c2ecfe86e4318d16b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S.&lt;/strong&gt; Another way of doing the same thing is &lt;code&gt;(b || {}).foo&lt;/code&gt;, because if b is undefined then &lt;code&gt;b || {}&lt;/code&gt; will be &lt;code&gt;{}&lt;/code&gt;, and you'll be accessing a value in an empty object (no error) instead of trying to access a value within &quot;undefined&quot; (causes an error).  So, &lt;code&gt;(b || {}).foo&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; and &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;PS&lt;/strong&gt;同じことを行う別の方法は &lt;code&gt;(b || {}).foo&lt;/code&gt; これは、bが未定義の場合、 &lt;code&gt;b || {}&lt;/code&gt; であるためです。 {}は &lt;code&gt;{}&lt;/code&gt; になり、 &quot;undefined&quot;内の値にアクセスしようとする代わりに、空のオブジェクト（エラーなし）の値にアクセスします（エラーの原因）。 したがって、 &lt;code&gt;(b || {}).foo&lt;/code&gt; は &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; と同じで、 &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; は &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt; と同じです。 foo.bar 。</target>
        </trans-unit>
        <trans-unit id="5b8f384febfdd7d7361b695f817e89853b5220d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We digress...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;余談です...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="022b17591a08c04d294c7aa2b97cef1c499d1b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;it means !true= false&lt;br/&gt;
 and  !!true = true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それは！true = falseを意味します&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt; &lt;strong&gt;そして!! true = true&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4626b6d0fd1defd823f8f27a6ee0096c94607fb" translate="yes" xml:space="preserve">
          <source>A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; performs a logical AND (true if both sides are true), and &lt;code&gt;a &amp;amp; b&lt;/code&gt; performs a bitwise AND. &lt;code&gt;a || b&lt;/code&gt; performs a logical OR (true if at least one are true), and &lt;code&gt;a | b&lt;/code&gt; performs a bitwise OR. There's a bitwise XOR (exclusive OR) as &lt;code&gt;a ^ b&lt;/code&gt;, but there's no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: &lt;code&gt;!!x !== !!y&lt;/code&gt;.</source>
          <target state="translated">3番目の使用法は、論理XORおよび論理XNORを生成することです。 CとJavaScriptの両方で、 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; は論理AND（両側がtrueの場合はtrue）を実行し、 &lt;code&gt;a &amp;amp; b&lt;/code&gt; はビットごとのANDを実行します。 &lt;code&gt;a || b&lt;/code&gt; bは論理OR（少なくとも1つがtrueの場合はtrue）を実行し、 &lt;code&gt;a | b&lt;/code&gt; bはビットごとのORを実行します。 &lt;code&gt;a ^ b&lt;/code&gt; にはビット単位のXOR（排他的OR）がありますが、論理XORの組み込み演算子はありません（一方が真の場合は真）。 たとえば、ユーザーが2つのフィールドのどちらか一方にテキストを入力できるようにすることができます。 あなたができることは、それぞれを真理値に変換して比較することです： &lt;code&gt;!!x !== !!y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="937148e0ba3cf2e3a6ad662dce342d4574705192" translate="yes" xml:space="preserve">
          <source>After seeing all these great answers, I would like to add another reason for using  &lt;code&gt;!!&lt;/code&gt;. Currenty I'm working in Angular 2-4 (TypeScript) and I want to return a boolean as &lt;code&gt;false&lt;/code&gt; when my user is not authenticated. If he isn't authenticated, the token-string would be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;. I can do this by using the next block of code:</source>
          <target state="translated">これらの素晴らしい答えをすべて見てから、私は使用する別の理由を追加したいと思います &lt;code&gt;!!&lt;/code&gt; 。 現在、私はAngular 2-4（TypeScript）で作業しており、ユーザーが認証されていない場合はブール値を &lt;code&gt;false&lt;/code&gt; として返します。 認証されていない場合、トークン文字列は &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;&quot;&quot;&lt;/code&gt; になります 。 これを行うには、次のコードブロックを使用します。</target>
        </trans-unit>
        <trans-unit id="719bb016bfb2ea5208e53cc2ef5f67a057166604" translate="yes" xml:space="preserve">
          <source>And things get even crazier depending on your engine. WScript, for instance, wins the prize.</source>
          <target state="translated">また、エンジンによってはさらにおかしくなることもあります。例えば、WScript が優勝しています。</target>
        </trans-unit>
        <trans-unit id="d2e6426f3b2e591c60f6c55c2d312ca4857318d9" translate="yes" xml:space="preserve">
          <source>Another use, which I mentioned in an &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;answer about C's corresponding &lt;code&gt;!!&lt;/code&gt; operator&lt;/a&gt;, is with &quot;lint&quot; tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn't quite as Boolean:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;Cの対応について&lt;/a&gt;の回答で述べた別の使用法 &lt;code&gt;!!&lt;/code&gt; operatorは 、一般的なタイプミスを探して診断を印刷する「lint」ツールを備えています。 たとえば、CとJavaScriptの両方で、ブール演算のいくつかの一般的なタイプミスは、出力がブール値ではない他の動作を生成します。</target>
        </trans-unit>
        <trans-unit id="5d7e80841153e3f0b33aa705ecbcdee928b5ed77" translate="yes" xml:space="preserve">
          <source>At first, the place you have:</source>
          <target state="translated">最初は、あなたが持っている場所。</target>
        </trans-unit>
        <trans-unit id="37383f3a991b3aaf3607d0d306ed294c9e3535ec" translate="yes" xml:space="preserve">
          <source>Basically, &lt;code&gt;!!&lt;/code&gt; make us sure, the value we get is boolean, not falsy, truthy or string etc...</source>
          <target state="translated">基本的に、 &lt;code&gt;!!&lt;/code&gt; 私たちが得る値はブール値であり、偽り、真実、文字列などではありません...</target>
        </trans-unit>
        <trans-unit id="f0db7bebe15c805ab3aec2ff3047007e131c1547" translate="yes" xml:space="preserve">
          <source>Because javascript has what are called &quot;truthy&quot; and &quot;falsey&quot; values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">JavaScriptには「真の」および「偽の」値と呼ばれるものが含まれているため、他の式で評価すると、検査対象の値または式が実際には &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; でなくても、trueまたはfalseの条件となる式があります 。</target>
        </trans-unit>
        <trans-unit id="ebcd804c817f36ef59a932affdb9a970bbb27d1b" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;some historical Windows jive&lt;/a&gt;, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; still gives you 0, or WScript's &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Look away. It's hideous.&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;歴史的なWindows jive&lt;/a&gt;があるため、メッセージボックスに-1が出力されます。 cmd.exeプロンプトで試してみてください。 しかし、 &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; は0またはWScriptの &lt;code&gt;false&lt;/code&gt; を返します 。 &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;目をそらす。&lt;/a&gt; それは恐ろしいです。</target>
        </trans-unit>
        <trans-unit id="34a3c4d1b09c4c334e45f565ff959b93e1297ce9" translate="yes" xml:space="preserve">
          <source>But if you &amp;rArr;</source>
          <target state="translated">でも&amp;rArr;</target>
        </trans-unit>
        <trans-unit id="55af43b97047e9feca9827254a5bad346b4fb1ea" translate="yes" xml:space="preserve">
          <source>But if you see strange &lt;code&gt;0&lt;/code&gt;s in your rendered JSX, think loose falsy management.</source>
          <target state="translated">ただし、レンダリングされたJSXに奇妙な &lt;code&gt;0&lt;/code&gt; が見られる場合は、緩やかな偽の管理と考えてください。</target>
        </trans-unit>
        <trans-unit id="c3d9638bccd08789c5c96539764af9bdb9abbc4d" translate="yes" xml:space="preserve">
          <source>But this can be an issue when something is undefined.</source>
          <target state="translated">しかし、これは何かが未定義の場合に問題になることがあります。</target>
        </trans-unit>
        <trans-unit id="fc510cf59a92c328aac077d7719d62aac7a4811c" translate="yes" xml:space="preserve">
          <source>But what if I have two values I need to check for equal truthi/falsi-ness?</source>
          <target state="translated">しかし、2つの値を持っている場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="0a33acba295ef44765fa6e094d5bf1d8422929b7" translate="yes" xml:space="preserve">
          <source>Comparing truthiness :)</source>
          <target state="translated">真実性の比較 :)</target>
        </trans-unit>
        <trans-unit id="c26332ba114f738a9008487cc2e7e1224052ab38" translate="yes" xml:space="preserve">
          <source>Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;dynamic typing&lt;/a&gt;&lt;/strong&gt; (aka &quot;duck typing&quot;). We want to write a function that returns &lt;code&gt;true&lt;/code&gt; if a user's browser supports the HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; element, but we don't want the function to throw an error if &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is undefined; and we don't want to use &lt;code&gt;try ... catch&lt;/code&gt; to handle any possible errors (because they're gross); &lt;em&gt;and also&lt;/em&gt; we don't want to use a check inside the function that won't consistently reveal the truth about the feature (for example, &lt;code&gt;document.createElement('audio')&lt;/code&gt; will still create an element called &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; even if HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is not supported).</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;動的型付け&lt;/a&gt;&lt;/strong&gt; （別名「ダック型付け」）によって機能の機能（この場合はプラットフォームの互換性）を検出する簡潔な関数について考えてみます。 ユーザーのブラウザーがHTML5の &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 要素をサポートしている場合に &lt;code&gt;true&lt;/code&gt; を返す関数を記述したいのですが、 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; が定義されていない場合に関数がエラーをスローするのは望ましくありません。 そして、考えられるエラーを処理するために &lt;code&gt;try ... catch&lt;/code&gt; を使用したくありません（エラーがひどいため）。 &lt;em&gt;また&lt;/em&gt; 、機能の真実を一貫して明らかにしない関数内のチェックを使用したくない（たとえば、 &lt;code&gt;document.createElement('audio')&lt;/code&gt; は、HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; はサポートされていません）。</target>
        </trans-unit>
        <trans-unit id="9c2bfed607f580ac4ac34ab9f08a0c6aa7cb0429" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Object&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;. If it was falsey (e.g. &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, etc.), it will be &lt;code&gt;false&lt;/code&gt;, otherwise, &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; を &lt;code&gt;boolean&lt;/code&gt; に変換します。 falseの場合（たとえば、 &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; など）、 &lt;code&gt;false&lt;/code&gt; になり 、それ以外の場合は &lt;code&gt;true&lt;/code&gt; になります 。</target>
        </trans-unit>
        <trans-unit id="7af2387329e42b1e1dcdbdc75737b43eb16b3b56" translate="yes" xml:space="preserve">
          <source>Double boolean negation. Often used to check if value is not undefined.</source>
          <target state="translated">ダブルブーリアン否定。値が未定義でないかどうかをチェックするためによく使われます。</target>
        </trans-unit>
        <trans-unit id="1378886488bff47eea733f621e4e6b0a3b97b140" translate="yes" xml:space="preserve">
          <source>Each function accepts an argument for a &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; and an &lt;code&gt;attribute&lt;/code&gt; to look for, but they each return different values based on what the comparisons determine.</source>
          <target state="translated">各関数は &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; の引数と検索する &lt;code&gt;attribute&lt;/code&gt; を受け入れますが、比較によって決定された内容に基づいて、それぞれが異なる値を返します。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="1e86b051c400fed4e8f797a656375e775595e029" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; and &lt;code&gt;!!0 === false&lt;/code&gt;.</source>
          <target state="translated">例： &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; および &lt;code&gt;!!0 === false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0da32197e1f2c3ed9016c076548a9c1dc68c0878" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False in JSX (React) has a special meaning&lt;/a&gt; that's not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in &lt;code&gt;messageCount&lt;/code&gt;...</source>
          <target state="translated">たとえば&lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;、JSX（React）のFalseには、&lt;/a&gt;単純な偽造ではトリガーされない特別な意味があります。 JSXで次のようなものを &lt;code&gt;messageCount&lt;/code&gt; うとした場合、 messageCountに intが期待されます...</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="eaa9bb432088641bac3a4242e7ee096bd6cecd11" translate="yes" xml:space="preserve">
          <source>Here are the three approaches:</source>
          <target state="translated">ここでは3つのアプローチを紹介します。</target>
        </trans-unit>
        <trans-unit id="f64e010c295a2870b0f4d659e488a6c517e64044" translate="yes" xml:space="preserve">
          <source>Here's an interesting case... &lt;code&gt;!!&lt;/code&gt; might be useful when 3rd party libs expect explicit Boolean values.</source>
          <target state="translated">ここに興味深いケースがあります... &lt;code&gt;!!&lt;/code&gt; サードパーティのライブラリが明示的なブール値を期待している場合に役立つことがあります。</target>
        </trans-unit>
        <trans-unit id="5dcc317e1dd0008af8179d1f9a0f92f72220ebe0" translate="yes" xml:space="preserve">
          <source>However it has several practical uses.</source>
          <target state="translated">しかし、それはいくつかの実用的な用途を持っています。</target>
        </trans-unit>
        <trans-unit id="f73892b42e6ec2099f18c789a4ca27320607324a" translate="yes" xml:space="preserve">
          <source>However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting &lt;code&gt;true&lt;/code&gt; from a non-boolean, possibly undefined value is indeed by using &lt;code&gt;!!&lt;/code&gt;. Hopefully this ridiculously clears it up.</source>
          <target state="translated">まれにこれらの状況が発生する可能性がありますが、ブール値ではない、おそらく未定義の値から &lt;code&gt;true&lt;/code&gt; となる最も簡潔で最もパフォーマンスの高い、したがって最も好ましい手段が実際に &lt;code&gt;!!&lt;/code&gt; 。 うまくいけば、これはばかげてそれを片付けます。</target>
        </trans-unit>
        <trans-unit id="4f858245f3d281e55c31873b62aa68516b0b67f3" translate="yes" xml:space="preserve">
          <source>However:</source>
          <target state="translated">However:</target>
        </trans-unit>
        <trans-unit id="e75de3aca85245f9741f3ed73aba2405a0e6cfcd" translate="yes" xml:space="preserve">
          <source>I can't think of a great, non-contrived use case for that offhand. Maybe you have &quot;linked&quot; fields in a form?</source>
          <target state="translated">今のところ、そのための優れた、非妥協的なユースケースは思いつきません。フォームの中に「リンクされた」フィールドがあるのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="bd129d49875f1c7bf2d6c56ffa1cefd1aa871386" translate="yes" xml:space="preserve">
          <source>I just wanted to add that</source>
          <target state="translated">それを付け加えたかっただけです。</target>
        </trans-unit>
        <trans-unit id="227f3285ec3ec43c9acc1d6e328c5b2a5034b7af" translate="yes" xml:space="preserve">
          <source>I saw some code that seems to use an operator I don't recognize, in the form of two exclamation points, like so: &lt;code&gt;!!&lt;/code&gt;. Can someone please tell me what this operator does?</source>
          <target state="translated">次のような2つの感嘆符の形で、認識できない演算子を使用しているように見えるコードをいくつか見ました &lt;code&gt;!!&lt;/code&gt; 。 誰かこのオペレーターが何をしているのか教えてもらえますか？</target>
        </trans-unit>
        <trans-unit id="0ab6442ad8b0b1090c870a59a8d71ba43701e2c7" translate="yes" xml:space="preserve">
          <source>I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.</source>
          <target state="translated">これは C++で !演算子はオーバーライドしても bool 演算子はオーバーライドしないということから来ているのではないかと思います。</target>
        </trans-unit>
        <trans-unit id="003e87252c9f7ec44808278e2171c30bbf27960f" translate="yes" xml:space="preserve">
          <source>I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of &amp;amp;&amp;amp; and 
first success or last fail in case of || of condition chain.</source>
          <target state="translated">言及する価値があると思いますが、論理AND / ORと組み合わせた条件はブール値を返しませんが、&amp;amp;&amp;amp;の場合は最後の成功または最初の失敗、||の場合は最初の成功または最後の失敗 条件チェーンの。</target>
        </trans-unit>
        <trans-unit id="d802fb28a6d04b4cc61b6721bff2527b6ab50f8a" translate="yes" xml:space="preserve">
          <source>I'm more comfortable handling falsiness myself with a ternary --</source>
          <target state="translated">自分的には三項式の方が偽りの処理が楽なんだけどね --{cHn.</target>
        </trans-unit>
        <trans-unit id="f605cfe8b7167fb9c1edb800b4a71aae4fe2edfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a false value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がfalse値の場合、 &lt;code&gt;!x&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;!!x&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0e2542885728d534e0cbf50ded3d8082dbb4bc2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a true value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が真の値の場合、 &lt;code&gt;!x&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; で、 &lt;code&gt;!!x&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="24f97de69477863bf6708059e17ad9778d8a9cc3" translate="yes" xml:space="preserve">
          <source>If that element does in fact exist, the expression will evaluate as true, and the code block will be executed.</source>
          <target state="translated">その要素が実際に存在する場合、式は真として評価され、コードブロックが実行されます。</target>
        </trans-unit>
        <trans-unit id="442b7a39eb1de6839bcbf2cca353f71f520acfac" translate="yes" xml:space="preserve">
          <source>If you &amp;rArr;</source>
          <target state="translated">&amp;rArr;</target>
        </trans-unit>
        <trans-unit id="5075badbf5e88b6b0caa8ef134b856caccd05702" translate="yes" xml:space="preserve">
          <source>If you only care that a value is truthy or falsy, then use the short form. Instead of</source>
          <target state="translated">ある値が真実か偽りかだけを気にするのであれば、短縮形を使いましょう。の代わりに</target>
        </trans-unit>
        <trans-unit id="25c0c498a0bdb8446495ca30bd5369fa1fe77b30" translate="yes" xml:space="preserve">
          <source>In order to cast the condition to a true boolean literal we can use the double negation:</source>
          <target state="translated">条件を真のブーリアンリテラルにキャストするために、二重否定を使うことができます。</target>
        </trans-unit>
        <trans-unit id="d94b2b8672da34c8a43dd1c8cbce124ec9f02e37" translate="yes" xml:space="preserve">
          <source>Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (&lt;em&gt;without&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;) to explicitly cast values, ie</source>
          <target state="translated">これらのハックの代わりに、（ &lt;code&gt;new&lt;/code&gt; &lt;em&gt;を&lt;/em&gt;使用&lt;em&gt;せずに&lt;/em&gt; ）プリミティブ型に対応するコンストラクター関数を使用して、明示的に値をキャストすることもできます。</target>
        </trans-unit>
        <trans-unit id="ef8ebd812b149cf4ca6384ab75bf685b7c51d444" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;Boolean&lt;/code&gt; class can be used.</source>
          <target state="translated">代わりに、 &lt;code&gt;Boolean&lt;/code&gt; クラスを使用できます。</target>
        </trans-unit>
        <trans-unit id="bd5f0f08c8b69e561341c016a5178bbabfab99f4" translate="yes" xml:space="preserve">
          <source>It converts the suffix to a Boolean value.</source>
          <target state="translated">サフィックスをブール値に変換します。</target>
        </trans-unit>
        <trans-unit id="04f0b660a5f5fd40c699d9299636f12196d971ce" translate="yes" xml:space="preserve">
          <source>It forces all things to boolean.</source>
          <target state="translated">すべてのものを強制的にブール値にします。</target>
        </trans-unit>
        <trans-unit id="362012587fedf1f206a41069ff29470d4bcc9b9f" translate="yes" xml:space="preserve">
          <source>It seems that the &lt;code&gt;!!&lt;/code&gt; operator results in a double negation.</source>
          <target state="translated">どうやら &lt;code&gt;!!&lt;/code&gt; 演算子は二重否定になります。</target>
        </trans-unit>
        <trans-unit id="d12e704c471bd7b5f2ef621231182892cdbce3ce" translate="yes" xml:space="preserve">
          <source>It simulates the behavior of the &lt;code&gt;Boolean()&lt;/code&gt; casting function.
The first &lt;code&gt;NOT&lt;/code&gt; returns a Boolean value no matter what operand it is given. The second &lt;code&gt;NOT&lt;/code&gt; negates that &lt;code&gt;Boolean&lt;/code&gt; value and so gives the &lt;code&gt;true&lt;/code&gt; Boolean value of a variable. The end result is the same as using the &lt;code&gt;Boolean()&lt;/code&gt; function on a value.</source>
          <target state="translated">これは、 &lt;code&gt;Boolean()&lt;/code&gt; キャスト関数の動作をシミュレートします。 最初の &lt;code&gt;NOT&lt;/code&gt; は、指定されたオペランドに関係なくブール値を返します。 2番目の &lt;code&gt;NOT&lt;/code&gt; はその &lt;code&gt;Boolean&lt;/code&gt; 値を否定するので、変数の &lt;code&gt;true&lt;/code&gt; ブール値を与えます。 最終結果は、 &lt;code&gt;Boolean()&lt;/code&gt; 関数を使用した場合と同じです。</target>
        </trans-unit>
        <trans-unit id="b34f307bed6829df645edce297716e7d66021503" translate="yes" xml:space="preserve">
          <source>It's a double &lt;code&gt;not&lt;/code&gt; operation.  The first &lt;code&gt;!&lt;/code&gt; converts the value to boolean and inverts its logical value.  The second &lt;code&gt;!&lt;/code&gt; inverts the logical value back.</source>
          <target state="translated">これは、二重 &lt;code&gt;not&lt;/code&gt; 操作です。 最初 &lt;code&gt;!&lt;/code&gt; 値をブール値に変換し、その論理値を反転します。 2番目 &lt;code&gt;!&lt;/code&gt; 論理値を元に戻します。</target>
        </trans-unit>
        <trans-unit id="c63e6ec5ccb83901a441e96930f2594861a2a402" translate="yes" xml:space="preserve">
          <source>It's a horribly obscure way to do a type conversion.</source>
          <target state="translated">恐ろしく曖昧な型変換の仕方ですね。</target>
        </trans-unit>
        <trans-unit id="a0bfc03fee00b0a95a35794ff4b18bfb284ed3d7" translate="yes" xml:space="preserve">
          <source>It's just the logical NOT operator, twice - it's used to convert something to boolean, e.g.:</source>
          <target state="translated">これはただの論理 NOT 演算子で、2回使用します-何かをブール値に変換するために使用されます。</target>
        </trans-unit>
        <trans-unit id="54382507df0f3d9ecbfe0a329a53e74bef4a1834" translate="yes" xml:space="preserve">
          <source>It's not a single operator, it's two.  It's equivalent to the following and is a quick way to cast a value to boolean.</source>
          <target state="translated">1つの演算子ではなく、2つの演算子です。以下のように等価で、値をブール値にキャストするのが手っ取り早いです。</target>
        </trans-unit>
        <trans-unit id="7f323048105e7d3908de65a905d0ecb9e7cccddb" translate="yes" xml:space="preserve">
          <source>JSX' docs suggest you be more explicit, write self-commenting code, and use a comparison to force to a Boolean.</source>
          <target state="translated">JSXのドキュメントでは、より明示的にすること、セルフコメントのコードを書くこと、ブール値に強制的に比較を使用することが推奨されています。</target>
        </trans-unit>
        <trans-unit id="857f728eac2339b6a141ba1d44e27519c2166bbc" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;strong&gt;these &lt;em&gt;are JSX &amp;amp; Typescript conventions&lt;/em&gt;, not ones inherent to JavaScript&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;これら&lt;em&gt;はJSXとTypescriptの規則であり&lt;/em&gt; 、JavaScriptに固有の&lt;em&gt;規則&lt;/em&gt;ではないことに&lt;em&gt;注意し&lt;/em&gt;&lt;/strong&gt;てください。</target>
        </trans-unit>
        <trans-unit id="558b0b10df23ff62727f0cdf06a369839b8ba0b0" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; in use.</source>
          <target state="translated">つまり、 &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; が使用されています。</target>
        </trans-unit>
        <trans-unit id="71a6705b7fa3ec15cdb9c15f74c0a2866a4f8b3e" translate="yes" xml:space="preserve">
          <source>Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.</source>
          <target state="translated">当然ながら、これらはすべて単に !someThing と入力しているのと同じですが、括弧を追加することで、よりわかりやすくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="062b9d1606d85c2c91b697df5b29f343f34bfd4f" translate="yes" xml:space="preserve">
          <source>Note that there are some &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;unintuitive cases&lt;/a&gt; where a boolean will be cast to a number (&lt;code&gt;true&lt;/code&gt; is cast to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;) when comparing a boolean to a number. In this case, &lt;code&gt;!!&lt;/code&gt; might be mentally useful. Though, again, &lt;strong&gt;these are cases where you're comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake.&lt;/strong&gt;&lt;code&gt;if (-1)&lt;/code&gt; is still the way to go here.</source>
          <target state="translated">ブール値を数値と比較するときに、ブール値が数値にキャストされる（ &lt;code&gt;true&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; にキャストされ、 &lt;code&gt;false&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; にされる ）いくつかの&lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;直感的でないケース&lt;/a&gt;があることに注意してください。 この場合、 &lt;code&gt;!!&lt;/code&gt; 精神的に役立つかもしれません。 繰り返しますが、 &lt;strong&gt;これらは非ブール値をハードタイプのブール値と比較する場合です。つまり、深刻な間違いです。&lt;/strong&gt; &lt;code&gt;if (-1)&lt;/code&gt; はまだここに行く方法です。</target>
        </trans-unit>
        <trans-unit id="57d186fffc848f3760d873fa6a5efef0c4b69fd9" translate="yes" xml:space="preserve">
          <source>One fix involves the bangbang, which coerces &lt;code&gt;0&lt;/code&gt; into &lt;code&gt;!!0&lt;/code&gt;, which is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">1つの修正には、 &lt;code&gt;0&lt;/code&gt; を &lt;code&gt;!!0&lt;/code&gt; 強制するbangbangが含まれます 。これは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1a6f54cbcb01cbe0a3333b72e4ff3a962a0f801e" translate="yes" xml:space="preserve">
          <source>One use is to lossily compress an object to its truth value, so that your code isn't holding a reference to a big object and keeping it alive. Assigning &lt;code&gt;!!some_big_object&lt;/code&gt; to a variable instead of &lt;code&gt;some_big_object&lt;/code&gt; lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as &lt;code&gt;null&lt;/code&gt; or the undefined value, such as browser feature detection.</source>
          <target state="translated">1つの使用法は、オブジェクトをその真の値に不可逆的に圧縮して、コードが大きなオブジェクトへの参照を保持せず、それを維持することです。 &lt;code&gt;!!some_big_object&lt;/code&gt; 代わりに!! some_big_objectを変数に割り当てると、ガベージコレクターのために変数を &lt;code&gt;some_big_object&lt;/code&gt; できます。 これは、オブジェクト、または &lt;code&gt;null&lt;/code&gt; などのfalse値、またはブラウザ機能の検出などの未定義の値を生成する場合に役立ちます 。</target>
        </trans-unit>
        <trans-unit id="161e7eb8bec71d838abd41540cca030c08d6f7f6" translate="yes" xml:space="preserve">
          <source>Please check code snippet out below &lt;strong&gt;&amp;darr;&lt;/strong&gt;</source>
          <target state="translated">以下のコードスニペットをチェックしてください&lt;strong&gt;&amp;darr;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9c634cfd1a38a3aa345e046738679df22d80362" translate="yes" xml:space="preserve">
          <source>Practical uses</source>
          <target state="translated">実用的な使い方</target>
        </trans-unit>
        <trans-unit id="114da967498be8e2c2cdf7df8db42e88ebd380c7" translate="yes" xml:space="preserve">
          <source>Pretend we have &lt;code&gt;myVar1 = 0;&lt;/code&gt; and &lt;code&gt;myVar2 = undefined;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;myVar1 = 0;&lt;/code&gt; そして &lt;code&gt;myVar2 = undefined;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2f2915a66e774b1c83f8a2a3e89284ac648434e" translate="yes" xml:space="preserve">
          <source>Real World Example &quot;Test IE version&quot;:</source>
          <target state="translated">実例「IEのバージョンをテストする</target>
        </trans-unit>
        <trans-unit id="b39d3fef53ba3ed826f8428d58a2371af89a4e7d" translate="yes" xml:space="preserve">
          <source>Returns boolean value of a variable.</source>
          <target state="translated">変数のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="fc98ae78ccf4552e39bcf193255cd5a8ae570858" translate="yes" xml:space="preserve">
          <source>Same deal in Typescript: If you have a function that returns a boolean (or you're assigning a value to a boolean variable), you [usually] can't return/assign a boolean-y value; it has to be a strongly typed boolean. This means, &lt;strong&gt;iff &lt;code&gt;myObject&lt;/code&gt; is strongly typed&lt;/strong&gt;, &lt;code&gt;return !myObject;&lt;/code&gt; works for a function returning a boolean, but &lt;code&gt;return myObject;&lt;/code&gt; doesn't. You have to &lt;code&gt;return !!myObject&lt;/code&gt; to match Typescript's expectations.</source>
          <target state="translated">Typescriptでも同じことが言えます：ブール値を返す関数がある場合（またはブール変数に値を割り当てている場合）、[通常]ブール値のyを返す/割り当てることはできません。 強く型付けされたブール値でなければなりません。 つまり、 &lt;strong&gt; &lt;code&gt;myObject&lt;/code&gt; が厳密に型指定されている場合は&lt;/strong&gt; 、 &lt;code&gt;return !myObject;&lt;/code&gt; ブール値を返す関数で機能しますが、 &lt;code&gt;return myObject;&lt;/code&gt; しません。 Typescriptの期待に合う &lt;code&gt;return !!myObject&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="03d3dfc9a836826357b793d282380cd7f94081b6" translate="yes" xml:space="preserve">
          <source>See &quot;== and !=&quot; from &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint's directions&lt;/a&gt; (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:</source>
          <target state="translated">&lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLintの指示&lt;/a&gt;から「==と！=」を参照してください（注：Crockfordはサイトを少し動かしています。そのリンクはいつか死ぬ可能性があります）。その理由について少し説明します。</target>
        </trans-unit>
        <trans-unit id="b77b945dc1e2fb58fae032d74373f3a357e30b37" translate="yes" xml:space="preserve">
          <source>Simply casting :(</source>
          <target state="translated">単なるキャスティング :(</target>
        </trans-unit>
        <trans-unit id="6a0157727338f2b7b3fe3318d34c2684d92b3ba2" translate="yes" xml:space="preserve">
          <source>So  it's like using &lt;code&gt;Boolean&lt;/code&gt; function in javascript, but easy and shorter way to convert a value to boolean:</source>
          <target state="translated">つまり、JavaScriptで &lt;code&gt;Boolean&lt;/code&gt; 関数を使用するようなものですが、値をブール値に変換する簡単で短い方法です。</target>
        </trans-unit>
        <trans-unit id="c4992f9e1d0a43038d9ca1117fe08701149b40b0" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;!!&lt;/code&gt; is not an operator, it's just the &lt;code&gt;!&lt;/code&gt; operator twice.</source>
          <target state="translated">だから &lt;code&gt;!!&lt;/code&gt; は演算子ではなく、単なる &lt;code&gt;!&lt;/code&gt; 演算子を2回。</target>
        </trans-unit>
        <trans-unit id="0addbe39410a730dff513bf6537d8856157b56c9" translate="yes" xml:space="preserve">
          <source>So many answers doing half the work. Yes, &lt;code&gt;!!X&lt;/code&gt; could be read as &quot;the truthiness of X [represented as a boolean]&quot;. But &lt;code&gt;!!&lt;/code&gt; isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. &lt;code&gt;!!myVar === true&lt;/code&gt; is the same as just &lt;code&gt;myVar&lt;/code&gt;. Comparing &lt;code&gt;!!X&lt;/code&gt; to a &quot;real&quot; boolean isn't really useful.</source>
          <target state="translated">作業の半分を実行するための非常に多くの回答。 はい、 &lt;code&gt;!!X&lt;/code&gt; は「Xの真実[ブール値として表現]」と読むことができます。 しかし &lt;code&gt;!!&lt;/code&gt; 実際には、単一の変数が真実であるか偽であるかを判断するために重要ではありません。 &lt;code&gt;!!myVar === true&lt;/code&gt; は、 &lt;code&gt;myVar&lt;/code&gt; と同じです。 &lt;code&gt;!!X&lt;/code&gt; を「実際の」ブール値と比較しても、あまり役に立ちません。</target>
        </trans-unit>
        <trans-unit id="014ab2f522034cc3c77ca7c114cbd4670167db8e" translate="yes" xml:space="preserve">
          <source>So now if you have a truthy for both &lt;em&gt;or&lt;/em&gt; a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your &lt;code&gt;errorObjects&lt;/code&gt; collection.</source>
          <target state="translated">だから今あなたが両方に真実である&lt;em&gt;か&lt;/em&gt; 、配偶者の名前と年齢の両方で偽物があるなら、あなたは続けることができます。 それ以外の場合は、値（またはごく初期の組み合わせ）のフィールドが1つだけあり、 &lt;code&gt;errorObjects&lt;/code&gt; コレクションに追加のエラーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="e63cc48d4173484ca47b8b9c48f21169296682e7" translate="yes" xml:space="preserve">
          <source>So the only place you'd really need to use &quot;boolean-cast variables&quot; would be if you had a situation where you're checking if both variables have the &lt;em&gt;same&lt;/em&gt; truthiness, right? That is, &lt;b&gt;use &lt;code&gt;!!&lt;/code&gt; if you need to see if two vars are &lt;em&gt;both truthy or both falsy&lt;/em&gt; (or not), that is, &lt;em&gt;of equal&lt;/em&gt; (or not) &lt;em&gt;truthiness&lt;/em&gt;.&lt;/b&gt;</source>
          <target state="translated">したがって、「boolean-cast変数」を実際に使用する必要がある唯一の場所は、両方の変数が&lt;em&gt;同じ&lt;/em&gt;真実性を持っているかどうかをチェックしている状況である場合でしょうか。 つまり、 &lt;b&gt;使用 &lt;code&gt;!!&lt;/code&gt; &lt;/b&gt; &lt;b&gt;2つの変数が&lt;em&gt;どちらも真実であるか、どちらも偽であるか&lt;/em&gt; （またはそうでないか）、つまり&lt;em&gt;等しい&lt;/em&gt; （または&lt;em&gt;真で&lt;/em&gt;ない）かどうかを確認する必要がある場合。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8fc0438c0801780b20fbecd73911dad21ef51b6" translate="yes" xml:space="preserve">
          <source>So to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!.</source>
          <target state="translated">この場合、負(または正)の答えを得るためには、まずブーリアンを得るために !演算子を使用する必要がありますが、正の場合をチェックしたい場合は !</target>
        </trans-unit>
        <trans-unit id="6e23c1f4bfbfa0ccb58b6c59c222898580d75194" translate="yes" xml:space="preserve">
          <source>So you're converting a value to a boolean, then inverting it, then inverting it again.</source>
          <target state="translated">つまり、値をブール値に変換して、それを反転させて、また反転させるということですね。</target>
        </trans-unit>
        <trans-unit id="70f19fcd06b0becbaad2b70e1d5cf4e4e3e27fee" translate="yes" xml:space="preserve">
          <source>Some of you probably noticed that in this specific example, one could simply check for a property using the slightly &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;more performant&lt;/a&gt;&lt;/strong&gt; means of checking if the object in question &lt;em&gt;has&lt;/em&gt; a property. There are two ways to do this:</source>
          <target state="translated">この特定の例で&lt;em&gt;は&lt;/em&gt; 、問題のオブジェクトにプロパティ&lt;em&gt;が&lt;/em&gt;あるかどうかを確認する、少し&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;パフォーマンスの高い&lt;/a&gt;&lt;/strong&gt;方法を使用して、プロパティを簡単に確認できることに気付いた方もいるでしょう。 これを行うには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="4b46f5ed42b9b9e328c2f46362683a228c43e509" translate="yes" xml:space="preserve">
          <source>Some operators in JavaScript perform implicit type conversions, and are sometimes
used for type conversion.</source>
          <target state="translated">JavaScriptの演算子の中には、暗黙の型変換を行うものがあります。</target>
        </trans-unit>
        <trans-unit id="ea085d9130b086f1623397b738adcbac23d6d7e9" translate="yes" xml:space="preserve">
          <source>That is...</source>
          <target state="translated">それは...</target>
        </trans-unit>
        <trans-unit id="82fc7d92ba7e869e36f27a18325c4d16d5a80178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; construct is a simple way of turning any JavaScript expression into
its Boolean equivalent.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; コンストラクトは、JavaScript式をブール式に変換する簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="90d1a7ed711f96e90a1182e13fa7e55e0596693e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 演算子は、あなたが書いたものがあなたの意図したものであることをlintツールに再保証します。この操作を実行してから、結果の真の値を取ります。</target>
        </trans-unit>
        <trans-unit id="eabc5d96ac71e6f38058420dd87159a58d3314a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements and the &lt;code&gt;?&lt;/code&gt; operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and &lt;code&gt;null&lt;/code&gt; are both false.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; および &lt;code&gt;while&lt;/code&gt; ステートメントと &lt;code&gt;?&lt;/code&gt; 演算子は真理値を使用して、実行するコードのブランチを決定します。 たとえば、ゼロとNaNの数値と空の文字列はfalseですが、他の数値と文字列はtrueです。 オブジェクトはtrueですが、未定義の値と &lt;code&gt;null&lt;/code&gt; はどちらもfalseです。</target>
        </trans-unit>
        <trans-unit id="29d047ae2b1b9b41221cc9a49cebe8c72ef84804" translate="yes" xml:space="preserve">
          <source>The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r\n' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.</source>
          <target state="translated">と !=演算子は、比較する前に型強制を行います。これは悪いことです。これは型エラーを隠すことができます。JSLintは==が正しく使われているかどうかを確実に判断することができませんので、==と !=は全く使わず、常により信頼性の高い==と !==演算子を代わりに使うのが最善です。</target>
        </trans-unit>
        <trans-unit id="19d8f9dad8485f308ad86d92258b4c919e2fb866" translate="yes" xml:space="preserve">
          <source>The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; are both &quot;truthy&quot; and we will continue down the so-called &quot;&amp;amp;&amp;amp; chain&quot; to the next value to the right.</source>
          <target state="translated">上記は未定義を返しますが、空の文字列がある場合、false、null、0、undefinedこれらの値は返され、チェーン内でそれらに遭遇するとすぐに &lt;code&gt;[]&lt;/code&gt; と &lt;code&gt;{}&lt;/code&gt; はどちらも「真実」であり、いわゆる「&amp;amp;&amp;amp;チェイン」が右側の次の値に。</target>
        </trans-unit>
        <trans-unit id="b6f0570101450478158dcd94c3db9bdc410dbccf" translate="yes" xml:space="preserve">
          <source>The above's not so useful. &lt;code&gt;if (!0)&lt;/code&gt; gives you the same results as &lt;code&gt;if (!!0 === false)&lt;/code&gt;. I can't think of a good case for casting a variable to boolean and then comparing to a &quot;true&quot; boolean.</source>
          <target state="translated">上記はそれほど役に立ちません。 &lt;code&gt;if (!0)&lt;/code&gt; は &lt;code&gt;if (!!0 === false)&lt;/code&gt; と同じ結果になります。 変数をブール値にキャストして、「真の」ブール値と比較する良いケースは考えられません。</target>
        </trans-unit>
        <trans-unit id="281762abc14819a66dcacbfde55f5e8401270f1d" translate="yes" xml:space="preserve">
          <source>The context in which I saw this was,</source>
          <target state="translated">これを見た時の文脈は</target>
        </trans-unit>
        <trans-unit id="acc6b507b28fe734085a51694ffb662d2f97612f" translate="yes" xml:space="preserve">
          <source>The double &quot;not&quot; in this case is quite simple.  It is simply two &lt;code&gt;not&lt;/code&gt;s back to back.</source>
          <target state="translated">この場合の二重の「not」は非常に単純です。 背中合わせではなく単に2つです。</target>
        </trans-unit>
        <trans-unit id="531d1ca78f0741ca59c6f0a6607b3ea3cdc4a6d9" translate="yes" xml:space="preserve">
          <source>The double negation operator &lt;code&gt;!!&lt;/code&gt; calculates the truth value of a value. It's actually two operators, where &lt;code&gt;!!x&lt;/code&gt; means &lt;code&gt;!(!x)&lt;/code&gt;, and behaves as follows:</source>
          <target state="translated">二重否定演算子 &lt;code&gt;!!&lt;/code&gt; 値の真理値を計算します。 これは実際には2つの演算子で、 &lt;code&gt;!!x&lt;/code&gt; は &lt;code&gt;!(!x)&lt;/code&gt; を意味し、次のように動作します。</target>
        </trans-unit>
        <trans-unit id="0fedba5c4ec19ca80540448ef2226b8d7209ad69" translate="yes" xml:space="preserve">
          <source>The exception for Typescript? If &lt;code&gt;myObject&lt;/code&gt; was an &lt;code&gt;any&lt;/code&gt;, you're back in JavaScript's Wild West and can return it without &lt;code&gt;!!&lt;/code&gt;, even if your return type is a boolean.</source>
          <target state="translated">Typescriptの例外？ &lt;code&gt;myObject&lt;/code&gt; が &lt;code&gt;any&lt;/code&gt; だった場合 、JavaScriptのワイルドウエストに戻り、それなしで返すことができます &lt;code&gt;!!&lt;/code&gt; 、戻り値の型がブール値であっても。</target>
        </trans-unit>
        <trans-unit id="e4d67b97b47952ce6811073a8a2a38486c684c78" translate="yes" xml:space="preserve">
          <source>The first bang forces the js engine to run &lt;code&gt;Boolean(x)&lt;/code&gt; but also has the side effect of inverting the value.  So the second bang undoes the side effect.</source>
          <target state="translated">最初のbangはjsエンジンに &lt;code&gt;Boolean(x)&lt;/code&gt; の実行を強制しますが、値を反転するという副作用もあります。 したがって、2番目の強打は副作用を元に戻します。</target>
        </trans-unit>
        <trans-unit id="fe7b25df5389abed33b3b0b02607f02a5ccbe313" translate="yes" xml:space="preserve">
          <source>The first one simply &quot;inverts&quot; the truthy or falsey value, resulting in an actual boolean type, and then the second one &quot;inverts&quot; it back again to it's original state, but now in an actual boolean value.  That way you have consistency:</source>
          <target state="translated">最初のものは単純にtruthyまたはfalsey値を &quot;反転 &quot;させ、実際のブーリアン型にし、2番目のものはそれを元の状態に &quot;反転 &quot;させ、実際のブーリアン値に戻します。このようにして、一貫性を保つことができます。</target>
        </trans-unit>
        <trans-unit id="7bbf601d501a5f0c41724feba5edab84aa91cd28" translate="yes" xml:space="preserve">
          <source>The trick here is the chain of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;s will return &lt;strong&gt;the first falsey value&lt;/strong&gt; it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the &lt;code&gt;b.foo.bar&lt;/code&gt; statement, and we get no error.</source>
          <target state="translated">ここでの秘訣は &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; のチェーンが&lt;strong&gt;最初に検出した誤った値&lt;/strong&gt;を返すことです-そして、これはifステートメントなどにフィードできます。したがって、b.fooが未定義の場合、undefinedを返し、 &lt;code&gt;b.foo.bar&lt;/code&gt; をスキップしますステートメント、そしてエラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="f362651fc7a92ae9f0a9673d4c5486b2f3f73825" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!false&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">真実は &lt;code&gt;false&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; はないことです （それが &lt;code&gt;!false&lt;/code&gt; が&lt;strong&gt; &lt;code&gt;true&lt;/code&gt; になる&lt;/strong&gt;理由です ）</target>
        </trans-unit>
        <trans-unit id="a45301cb714edcffab6f1d258022757ae0ecd7bd" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!!false&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">真実は &lt;code&gt;false&lt;/code&gt; がfalseでは&lt;em&gt;ない&lt;/em&gt; &lt;code&gt;false&lt;/code&gt; （そのため &lt;code&gt;!!false&lt;/code&gt; は&lt;strong&gt; &lt;code&gt;false&lt;/code&gt; になります&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="dc6dfe93853155dde81483486981f53f459fca48" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!true&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">真実は &lt;code&gt;true&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; はないということです （そのため &lt;code&gt;!true&lt;/code&gt; は&lt;strong&gt; &lt;code&gt;false&lt;/code&gt; になります&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="de5886521d1b8bae3b9e573aa8de49514dcf5e6d" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!!true&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">真実は &lt;code&gt;true&lt;/code&gt; は真ではない&lt;em&gt;こと&lt;/em&gt; &lt;code&gt;true&lt;/code&gt; （そのため &lt;code&gt;!!true&lt;/code&gt; は&lt;strong&gt; &lt;code&gt;true&lt;/code&gt; になります&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="3c5ec1883ea648c4eac15e44a0e47cc089c821db" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;!&lt;/code&gt; operator converts its operand to a boolean and negates it.</source>
          <target state="translated">単項 &lt;code&gt;!&lt;/code&gt; 演算子はそのオペランドをブール値に変換し、それを否定します。</target>
        </trans-unit>
        <trans-unit id="33306e297fa07aa22ffeca48a2d3b1ca6f355960" translate="yes" xml:space="preserve">
          <source>Then you do &lt;code&gt;!0&lt;/code&gt;, it will be converted to boolean and be evaluated to &lt;code&gt;true&lt;/code&gt;, because 0 is &lt;code&gt;falsy&lt;/code&gt;, so you get the reversed value and converted to boolean, so it gets evaluated to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">次に &lt;code&gt;!0&lt;/code&gt; を実行すると、ブール値に変換されて &lt;code&gt;true&lt;/code&gt; に評価されます 。これは、0が &lt;code&gt;falsy&lt;/code&gt; であるため、逆の値を取得してブール値に変換し、 trueに評価されるためです 。</target>
        </trans-unit>
        <trans-unit id="71ab5eac91ed7f0607dae3a2cf1d7e72a4ca4e97" translate="yes" xml:space="preserve">
          <source>This fact lead to the following idiom that you can see in your source code:</source>
          <target state="translated">この事実は、ソースコードで見られる次のような慣用句につながります。</target>
        </trans-unit>
        <trans-unit id="5206aead5c0929d44fb460d6a6d755b4275d68d5" translate="yes" xml:space="preserve">
          <source>This question has been answered quite thoroughly, but I'd like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.</source>
          <target state="translated">この質問については、ここまでで十分に答えが出ていますが、できるだけ簡略化して意味がわかりやすくなるように答えを付け加えたいと思います。</target>
        </trans-unit>
        <trans-unit id="900a6ce54db6671d1163b4588fef81576caa9d76" translate="yes" xml:space="preserve">
          <source>Tons of great answers here, but if you've read down this far, this helped me to 'get it'. Open the console on Chrome (etc), and start typing:</source>
          <target state="translated">ここにはたくさんの素晴らしい回答がありますが、ここまで読んでくれたなら、これは私が「それを得る」のに役立ちました。Chrome(など)でコンソールを開き、入力を開始します。</target>
        </trans-unit>
        <trans-unit id="b5a7a294200e3cb34da2a97adf5d130ba6c38c00" translate="yes" xml:space="preserve">
          <source>Use logical not operator two times</source>
          <target state="translated">論理演算子ではない演算子を2回使用する</target>
        </trans-unit>
        <trans-unit id="037ce300d2779ff07c53c4b5b8748bb947cb98bb" translate="yes" xml:space="preserve">
          <source>What is the !! (not not) operator in JavaScript</source>
          <target state="translated">演算子は何ですか! (not not)演算子とは何ですか?</target>
        </trans-unit>
        <trans-unit id="2bd5abc68757873bb182393e529f58b5f1764ea3" translate="yes" xml:space="preserve">
          <source>What we wish to determine in the comparison is the &quot;truth&quot; &lt;em&gt;about&lt;/em&gt; the value of a reference, not the &lt;em&gt;value of&lt;/em&gt; the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be &lt;em&gt;&lt;code&gt;false&lt;/code&gt;&lt;/em&gt; (or falsey), or if we expect the value not to be typeof &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">比較で決定したいの&lt;em&gt;は&lt;/em&gt; 、参照自体の&lt;em&gt;値で&lt;/em&gt;はなく、参照の値&lt;em&gt;について&lt;/em&gt;の「真実」です。 値が&lt;em&gt; &lt;code&gt;false&lt;/code&gt; &lt;/em&gt; （またはfalse）であると予想される場合、または値がtypeof &lt;code&gt;boolean&lt;/code&gt; ではない場合でも、値についての真実を知りたいユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="e6dfeec064b00b28af55ee18d69a51869a08807e" translate="yes" xml:space="preserve">
          <source>What you gain with &lt;code&gt;!!&lt;/code&gt; is the ability to check the truthiness of multiple variables &lt;em&gt;against each other&lt;/em&gt; in a repeatable, standardized (and JSLint friendly) fashion.</source>
          <target state="translated">あなたが得るもの &lt;code&gt;!!&lt;/code&gt; 複数の変数の真実性を、再現性のある標準化された（そしてJSLintに優しい）方法&lt;em&gt;で相互&lt;/em&gt;にチェックする機能です。</target>
        </trans-unit>
        <trans-unit id="d568b1f542f2ac7d26a5c47b5cb7b7775b67ea06" translate="yes" xml:space="preserve">
          <source>When used at the top level of a Boolean context (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;), the &lt;code&gt;!!&lt;/code&gt; operator is behaviorally a no-op. For example, &lt;code&gt;if (x)&lt;/code&gt; and &lt;code&gt;if (!!x)&lt;/code&gt; mean the same thing.</source>
          <target state="translated">ブールコンテキストの最上位レベル（ &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、または &lt;code&gt;?&lt;/code&gt; ）で使用すると、 &lt;code&gt;!!&lt;/code&gt; 演算子は動作的には何もしません。 たとえば、 &lt;code&gt;if (x)&lt;/code&gt; と &lt;code&gt;if (!!x)&lt;/code&gt; は同じ意味です。</target>
        </trans-unit>
        <trans-unit id="15bdd7d9c3451db43373e5025a0173bdf0c60369" translate="yes" xml:space="preserve">
          <source>Why?  Because &lt;code&gt;document.getElementById()&lt;/code&gt; is a &quot;truthy&quot; expression that will evaluate as true in this &lt;code&gt;if()&lt;/code&gt; statement, but it is not an actual boolean value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">どうして？ &lt;code&gt;document.getElementById()&lt;/code&gt; は、この &lt;code&gt;if()&lt;/code&gt; ステートメントでtrueと評価される「真の」式ですが、実際のブール値 &lt;code&gt;true&lt;/code&gt; ではないためです 。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2562e78de1b3256bca3da91141bb0297a876088d" translate="yes" xml:space="preserve">
          <source>and instead of</source>
          <target state="translated">の代わりに</target>
        </trans-unit>
        <trans-unit id="6ff7395099aa52cc1ac2567047b5dc904e83a97c" translate="yes" xml:space="preserve">
          <source>but we don't want the reversed &lt;strong&gt;boolean version&lt;/strong&gt; of the value, so we can reverse it again to get our result! That's why we use another &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">ただし、値の逆&lt;strong&gt;ブールバージョン&lt;/strong&gt;は必要ないので、もう一度逆にして結果を得ることができます。 そのため、別の &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1136ebda06acfbb946c27883e9c70a00d96a8324" translate="yes" xml:space="preserve">
          <source>here is a piece of code from angular js</source>
          <target state="translated">ここに angular js のコードの一部があります。</target>
        </trans-unit>
        <trans-unit id="07aee702dc1bc81b24b43ca8e96d3a68f77ddfba" translate="yes" xml:space="preserve">
          <source>if requestAnimationFrame was assinged undefined then
!requestAnimationFrame would be true and one more ! of it would be false</source>
          <target state="translated">requestAnimationFrame が未定義である場合、 !requestAnimationFrame は真であり、そのうちのもう一つの !</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">と同じです。</target>
        </trans-unit>
        <trans-unit id="fb81871808eeba6b79f000511077e0392e5040fe" translate="yes" xml:space="preserve">
          <source>it can be achieved by checking in following way in general:</source>
          <target state="translated">一般的には以下のようにチェックすることで実現できます。</target>
        </trans-unit>
        <trans-unit id="bf9bb582fda3d69616ba7956287f904859457f58" translate="yes" xml:space="preserve">
          <source>just say</source>
          <target state="translated">言うだけ</target>
        </trans-unit>
        <trans-unit id="dc01c6b7487aab92695f7ba918540cf5051f72f4" translate="yes" xml:space="preserve">
          <source>say</source>
          <target state="translated">say</target>
        </trans-unit>
        <trans-unit id="287b978241585895eb95865fc85abb7f32f60d1e" translate="yes" xml:space="preserve">
          <source>so if requestAnimationFrame was assigned a function
 then
!requestAnimationFrame would be false and one more ! of it would be true</source>
          <target state="translated">したがって、もしrequestAnimationFrameに関数が割り当てられていたら、 !requestAnimationFrameはfalseになり、そのうちの1つがtrueになります。</target>
        </trans-unit>
        <trans-unit id="7c2b4b647bd0e7cbaa828c353b4a7be55a9be894" translate="yes" xml:space="preserve">
          <source>the short way could be using !!</source>
          <target state="translated">近道は</target>
        </trans-unit>
        <trans-unit id="2b1fd3dee3545afca88dbce54f7f1d0f063a468f" translate="yes" xml:space="preserve">
          <source>their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame</source>
          <target state="translated">彼らの意図は、requestAnimationFrame の関数の可用性に基づいて rafSupported を true または false に設定することです。</target>
        </trans-unit>
        <trans-unit id="7b247e535f27451042dc1de383c546cfcbe520d6" translate="yes" xml:space="preserve">
          <source>will BOTH return true, as expected.</source>
          <target state="translated">は期待通り、両方とも真を返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
