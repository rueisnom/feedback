<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/784929">
    <body>
      <group id="784929">
        <trans-unit id="9d8ee90d447e634111f086fe5d63063e02604c04" translate="yes" xml:space="preserve">
          <source>! is &quot;boolean not&quot;, which essentially typecasts the value of &quot;enable&quot; to its boolean opposite. The second ! flips this value. So, &lt;code&gt;!!enable&lt;/code&gt; means &quot;not not enable,&quot; giving you the value of &lt;code&gt;enable&lt;/code&gt; as a boolean.</source>
          <target state="translated">! is &quot;boolean not&quot;, который по существу типизирует значение &quot;enable&quot; к его логическому противоположному значению. Секунда ! переворачивает это значение. Таким образом, &lt;code&gt;!!enable&lt;/code&gt; означает &amp;laquo;не включен&amp;raquo;, давая вам значение &lt;code&gt;enable&lt;/code&gt; в качестве логического значения.</target>
        </trans-unit>
        <trans-unit id="1267640ee6e890d8ceb635273042d73661945ffd" translate="yes" xml:space="preserve">
          <source>(please read code descriptions)</source>
          <target state="translated">(пожалуйста,ознакомьтесь с описанием кода)</target>
        </trans-unit>
        <trans-unit id="dbc5329443fc97ea79e3d6fc7a7c08bb400f6cdb" translate="yes" xml:space="preserve">
          <source>... you might be surprised to see React render a &lt;code&gt;0&lt;/code&gt; when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns &lt;code&gt;0&lt;/code&gt;, which JSX happily renders, as it should. It can't tell you didn't have &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (or something less contrived).</source>
          <target state="translated">... вы можете быть удивлены, увидев, что React отображает &lt;code&gt;0&lt;/code&gt; , когда у вас есть ноль сообщений. Вы должны явно вернуть false, чтобы JSX не отображал. Вышеприведенный оператор возвращает &lt;code&gt;0&lt;/code&gt; , который JSX успешно отображает, как и должно быть. Он не может сказать, что у вас не было &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (или что-то менее надуманное).</target>
        </trans-unit>
        <trans-unit id="c4b43c7ba8236eeadfe785d67215c403a6e6e119" translate="yes" xml:space="preserve">
          <source>...will NOT result in a true condition, and the code block will not be executed, even if the element does exist.</source>
          <target state="translated">...не приведет к истинному состоянию,и блок кода не будет выполнен,даже если элемент действительно существует.</target>
        </trans-unit>
        <trans-unit id="bd18c0553a45634b99d4953abd9dd07bb59545b2" translate="yes" xml:space="preserve">
          <source>3rd party libraries that expect explicit Boolean values</source>
          <target state="translated">сторонние библиотеки,которые ожидают явных Булевых значений</target>
        </trans-unit>
        <trans-unit id="05317c9a3565f977ff95a0b1172dd228b7234929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!0 === false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!!0 === false&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b16fdc2b982571586ffd6bc3139aa446dfb0262b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; converts the value to the right of it to its equivalent boolean value. (Think poor man's way of &quot;type-casting&quot;). Its &lt;em&gt;intent&lt;/em&gt; is usually to convey to the reader that the code does not care &lt;em&gt;what&lt;/em&gt; value is in the variable, but what it's &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&quot;truth&quot; value&lt;/a&gt; is.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; преобразует значение справа от него в эквивалентное логическое значение. (Подумайте о том, как бедняк &amp;laquo;набирает текст&amp;raquo;). Его &lt;em&gt;цель&lt;/em&gt; обычно состоит в том, чтобы донести до читателя, что коду не важно, &lt;em&gt;какое&lt;/em&gt; значение находится в переменной, а какое значение &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&amp;laquo;истинно&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de68e033596cd4f5d22f42c9c74a29c3813083dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; is not an operator. It is the double-use of &lt;code&gt;!&lt;/code&gt; -- which is the logical &quot;not&quot; operator.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; не оператор. Это двойное использование &lt;code&gt;!&lt;/code&gt; - который является логическим оператором &quot;не&quot;.</target>
        </trans-unit>
        <trans-unit id="0c49aab7f0deeecf7c139cada81e75156b64a3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; it's using &lt;code&gt;NOT&lt;/code&gt; operation twice together, &lt;code&gt;!&lt;/code&gt; convert the value to a &lt;code&gt;boolean&lt;/code&gt; and reverse it, here is a simple example to see how &lt;code&gt;!!&lt;/code&gt; works:</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; он использует операцию &lt;code&gt;NOT&lt;/code&gt; дважды вместе &lt;code&gt;!&lt;/code&gt; преобразовать значение в &lt;code&gt;boolean&lt;/code&gt; и обратить его, вот простой пример, чтобы увидеть, как &lt;code&gt;!!&lt;/code&gt; работает:</target>
        </trans-unit>
        <trans-unit id="40472ff2de807d44da0389b6ed6c479fe97e450d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!expr&lt;/code&gt; returns a Boolean value (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) depending on the &lt;em&gt;truthiness&lt;/em&gt; of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:</source>
          <target state="translated">&lt;code&gt;!!expr&lt;/code&gt; возвращает логическое значение ( &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; ) в зависимости от &lt;em&gt;достоверности&lt;/em&gt; выражения. Это имеет больше смысла при использовании не-булевых типов. Рассмотрим эти примеры, особенно 3-й пример и далее:</target>
        </trans-unit>
        <trans-unit id="c11c8b2ce2578dcc578b1ef73f483f4da8bddb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!foo&lt;/code&gt; applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus &lt;code&gt;+foo&lt;/code&gt; to cast to number and concatenating an empty string &lt;code&gt;''+foo&lt;/code&gt; to cast to string.</source>
          <target state="translated">&lt;code&gt;!!foo&lt;/code&gt; применяет унарный оператор not дважды и используется для приведения к логическому типу, аналогично использованию унарного плюс &lt;code&gt;+foo&lt;/code&gt; для приведения к числу и объединения пустой строки &lt;code&gt;''+foo&lt;/code&gt; для приведения к строке.</target>
        </trans-unit>
        <trans-unit id="a3fbcf80055d72c6902769ea1b0b209d18d54c31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; is &lt;code&gt;!!0 === !!undefined&lt;/code&gt; and is true! Same truthiness! (In this case, both &quot;have a truthiness of falsy&quot;.)</source>
          <target state="translated">&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; is &lt;code&gt;!!0 === !!undefined&lt;/code&gt; и это правда! Та же самая правдивость! (В этом случае оба &amp;laquo;имеют правдивую ложь&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="d3afe30734c2565c10167b232d767321261e858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!x&lt;/code&gt; is shorthand for &lt;code&gt;Boolean(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!!x&lt;/code&gt; - это сокращение от &lt;code&gt;Boolean(x)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721b932e6bc1cc17c9cd50fea7dc4b8b7a6ad668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is &lt;em&gt;NOT&lt;/em&gt;.  So &lt;code&gt;!true&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;!0&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!1&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; &lt;em&gt;НЕ&lt;/em&gt; Итак, &lt;code&gt;!true&lt;/code&gt; - это &lt;code&gt;false&lt;/code&gt; , а &lt;code&gt;!false&lt;/code&gt; - это &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;!0&lt;/code&gt; это &lt;code&gt;true&lt;/code&gt; , а &lt;code&gt;!1&lt;/code&gt; это &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84f888f6e0a39683c0e570def98bcac6595167f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0 === false&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0 === false&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601bab0f9b947357bf0bbc8ebc5b625e5e7af331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; is a bitwise AND; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; is a logical AND. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; (a false value); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; является побитовым И; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; является логическим И. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; - это &lt;code&gt;0&lt;/code&gt; (ложное значение); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; верно.</target>
        </trans-unit>
        <trans-unit id="fe8e944fda44e395ec8eb52766a2d42b25be5541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a = b)&lt;/code&gt; is assignment followed by use of the truth value of &lt;code&gt;b&lt;/code&gt;; &lt;code&gt;if (a == b)&lt;/code&gt; is an equality comparison.</source>
          <target state="translated">&lt;code&gt;if (a = b)&lt;/code&gt; присваивание, за которым следует значение истинности &lt;code&gt;b&lt;/code&gt; ; &lt;code&gt;if (a == b)&lt;/code&gt; - сравнение на равенство.</target>
        </trans-unit>
        <trans-unit id="a4c32abc5c7932aafafe8b72767dd17a9e12923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myVar1 === myVar2&lt;/code&gt; is &lt;code&gt;0 === undefined&lt;/code&gt; and is obviously false.</source>
          <target state="translated">&lt;code&gt;myVar1 === myVar2&lt;/code&gt; равен &lt;code&gt;0 === undefined&lt;/code&gt; и явно ложен.</target>
        </trans-unit>
        <trans-unit id="7899bf510c8f1081aeced8dc9e82c3717d6f3a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is &lt;em&gt;not&lt;/em&gt; not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!!&lt;/code&gt; &lt;/strong&gt; определяет &amp;laquo;правду&amp;raquo; о том, что значение &lt;em&gt;не&lt;/em&gt; является:</target>
        </trans-unit>
        <trans-unit id="05ffd1c973d25f3fa642c01bde2e2d7437ff0b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!&lt;/code&gt; &lt;/strong&gt; определяет &amp;laquo;правду&amp;raquo; о том, что значение не является:</target>
        </trans-unit>
        <trans-unit id="6d9ad97a5f3ee3fba703f038b8cb73c50bd30761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brew some tea:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Заварите немного чая:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80a5baf090dcfffcd4153848ee43b313dff5f952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But wait, there's more!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Но подождите, это еще не все!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3574ce92cb57aeb1f7ff451de1bbe4886856bb60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 24 Oct 2017, 6 Feb 19:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ 24 октября 2017 г., 6 февраля 19:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a055a42c402ff7009188d3b50ace76756b7075b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;На практике:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36ed1544d47aa0950bc63b80406386d69ec830fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In theory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В теории:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a17136c4cff424debad877c2ecfe86e4318d16b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S.&lt;/strong&gt; Another way of doing the same thing is &lt;code&gt;(b || {}).foo&lt;/code&gt;, because if b is undefined then &lt;code&gt;b || {}&lt;/code&gt; will be &lt;code&gt;{}&lt;/code&gt;, and you'll be accessing a value in an empty object (no error) instead of trying to access a value within &quot;undefined&quot; (causes an error).  So, &lt;code&gt;(b || {}).foo&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; and &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;PS&lt;/strong&gt; Еще один способ сделать то же самое - это &lt;code&gt;(b || {}).foo&lt;/code&gt; , потому что если b не определено, то &lt;code&gt;b || {}&lt;/code&gt; {} будет &lt;code&gt;{}&lt;/code&gt; , и вы будете обращаться к значению в пустом объекте (без ошибок), вместо того, чтобы пытаться получить доступ к значению в пределах &amp;laquo;неопределенного&amp;raquo; (вызывает ошибку). Итак, &lt;code&gt;(b || {}).foo&lt;/code&gt; - это то же самое, что &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; , и &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; - то же самое, что и &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8f384febfdd7d7361b695f817e89853b5220d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We digress...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Мы отвлеклись ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="022b17591a08c04d294c7aa2b97cef1c499d1b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;it means !true= false&lt;br/&gt;
 and  !!true = true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;это значит! true = false&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt; &lt;strong&gt;и !! правда = правда&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4626b6d0fd1defd823f8f27a6ee0096c94607fb" translate="yes" xml:space="preserve">
          <source>A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; performs a logical AND (true if both sides are true), and &lt;code&gt;a &amp;amp; b&lt;/code&gt; performs a bitwise AND. &lt;code&gt;a || b&lt;/code&gt; performs a logical OR (true if at least one are true), and &lt;code&gt;a | b&lt;/code&gt; performs a bitwise OR. There's a bitwise XOR (exclusive OR) as &lt;code&gt;a ^ b&lt;/code&gt;, but there's no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: &lt;code&gt;!!x !== !!y&lt;/code&gt;.</source>
          <target state="translated">Третье использование - создание логического XOR и логического XNOR. И в C, и в JavaScript &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; выполняет логическое AND (true, если обе стороны верны), а &lt;code&gt;a &amp;amp; b&lt;/code&gt; выполняет побитовое AND. &lt;code&gt;a || b&lt;/code&gt; b выполняет логическое ИЛИ (true, если хотя бы один из них равен true), и &lt;code&gt;a | b&lt;/code&gt; b выполняет побитовое ИЛИ. Существует битовое XOR (исключающее ИЛИ) как &lt;code&gt;a ^ b&lt;/code&gt; , но нет встроенного оператора для логического XOR (true, если истинна только одна сторона). Например, вы можете разрешить пользователю вводить текст точно в одно из двух полей. Что вы можете сделать, так это преобразовать каждое значение в истинное и сравнить их:</target>
        </trans-unit>
        <trans-unit id="937148e0ba3cf2e3a6ad662dce342d4574705192" translate="yes" xml:space="preserve">
          <source>After seeing all these great answers, I would like to add another reason for using  &lt;code&gt;!!&lt;/code&gt;. Currenty I'm working in Angular 2-4 (TypeScript) and I want to return a boolean as &lt;code&gt;false&lt;/code&gt; when my user is not authenticated. If he isn't authenticated, the token-string would be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;. I can do this by using the next block of code:</source>
          <target state="translated">Увидев все эти замечательные ответы, я хотел бы добавить еще одну причину использования &lt;code&gt;!!&lt;/code&gt; , В настоящее время я работаю в Angular 2-4 (TypeScript) и хочу вернуть логическое значение как &lt;code&gt;false&lt;/code&gt; когда мой пользователь не аутентифицирован. Если он не аутентифицирован, строка-токен будет &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;&quot;&quot;&lt;/code&gt; . Я могу сделать это с помощью следующего блока кода:</target>
        </trans-unit>
        <trans-unit id="719bb016bfb2ea5208e53cc2ef5f67a057166604" translate="yes" xml:space="preserve">
          <source>And things get even crazier depending on your engine. WScript, for instance, wins the prize.</source>
          <target state="translated">И все становится еще более сумасшедшим в зависимости от вашего двигателя.WScript,например,выигрывает приз.</target>
        </trans-unit>
        <trans-unit id="d2e6426f3b2e591c60f6c55c2d312ca4857318d9" translate="yes" xml:space="preserve">
          <source>Another use, which I mentioned in an &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;answer about C's corresponding &lt;code&gt;!!&lt;/code&gt; operator&lt;/a&gt;, is with &quot;lint&quot; tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn't quite as Boolean:</source>
          <target state="translated">Другое использование, которое я упомянул в &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;ответе о соответствующем C &lt;code&gt;!!&lt;/code&gt; &lt;/a&gt; оператор , с инструментами &quot;Lint&quot;, которые ищут общие опечатки и диагностики печати. Например, как в C, так и в JavaScript несколько общих опечаток для логических операций приводят к другому поведению, вывод которого не совсем как логический:</target>
        </trans-unit>
        <trans-unit id="5d7e80841153e3f0b33aa705ecbcdee928b5ed77" translate="yes" xml:space="preserve">
          <source>At first, the place you have:</source>
          <target state="translated">Сначала место,которое у тебя есть:</target>
        </trans-unit>
        <trans-unit id="37383f3a991b3aaf3607d0d306ed294c9e3535ec" translate="yes" xml:space="preserve">
          <source>Basically, &lt;code&gt;!!&lt;/code&gt; make us sure, the value we get is boolean, not falsy, truthy or string etc...</source>
          <target state="translated">В основном, &lt;code&gt;!!&lt;/code&gt; убедитесь, что мы получаем логическое значение, а не ложное, правдивое или строковое и т. д.</target>
        </trans-unit>
        <trans-unit id="f0db7bebe15c805ab3aec2ff3047007e131c1547" translate="yes" xml:space="preserve">
          <source>Because javascript has what are called &quot;truthy&quot; and &quot;falsey&quot; values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Поскольку в javascript есть значения, которые называются &amp;laquo;правдивыми&amp;raquo; и &amp;laquo;ложными&amp;raquo; значениями, существуют выражения, которые при оценке в других выражениях приведут к условию &amp;laquo;истина&amp;raquo; или &amp;laquo;ложь&amp;raquo;, даже если проверяемое значение или выражение на самом деле не является &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebcd804c817f36ef59a932affdb9a970bbb27d1b" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;some historical Windows jive&lt;/a&gt;, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; still gives you 0, or WScript's &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Look away. It's hideous.&lt;/a&gt;</source>
          <target state="translated">Из-за &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;некоторого исторического джайва Windows это выведет&lt;/a&gt; -1 в окне сообщения! Попробуйте в командной строке cmd.exe и посмотрите! Но &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; прежнему выдает 0 или &lt;code&gt;false&lt;/code&gt; WScript. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Отвернись.&lt;/a&gt; Это отвратительно</target>
        </trans-unit>
        <trans-unit id="34a3c4d1b09c4c334e45f565ff959b93e1297ce9" translate="yes" xml:space="preserve">
          <source>But if you &amp;rArr;</source>
          <target state="translated">Но если вы &amp;rArr;</target>
        </trans-unit>
        <trans-unit id="55af43b97047e9feca9827254a5bad346b4fb1ea" translate="yes" xml:space="preserve">
          <source>But if you see strange &lt;code&gt;0&lt;/code&gt;s in your rendered JSX, think loose falsy management.</source>
          <target state="translated">Но если вы видите странные &lt;code&gt;0&lt;/code&gt; с в вашем рендеринге JSX, подумайте о ложном управлении.</target>
        </trans-unit>
        <trans-unit id="c3d9638bccd08789c5c96539764af9bdb9abbc4d" translate="yes" xml:space="preserve">
          <source>But this can be an issue when something is undefined.</source>
          <target state="translated">Но это может быть проблемой,когда что-то не определено.</target>
        </trans-unit>
        <trans-unit id="fc510cf59a92c328aac077d7719d62aac7a4811c" translate="yes" xml:space="preserve">
          <source>But what if I have two values I need to check for equal truthi/falsi-ness?</source>
          <target state="translated">Но что,если у меня есть две ценности,которые я должен проверить на равные истины?</target>
        </trans-unit>
        <trans-unit id="0a33acba295ef44765fa6e094d5bf1d8422929b7" translate="yes" xml:space="preserve">
          <source>Comparing truthiness :)</source>
          <target state="translated">Сравнительная правдивость :)</target>
        </trans-unit>
        <trans-unit id="c26332ba114f738a9008487cc2e7e1224052ab38" translate="yes" xml:space="preserve">
          <source>Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;dynamic typing&lt;/a&gt;&lt;/strong&gt; (aka &quot;duck typing&quot;). We want to write a function that returns &lt;code&gt;true&lt;/code&gt; if a user's browser supports the HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; element, but we don't want the function to throw an error if &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is undefined; and we don't want to use &lt;code&gt;try ... catch&lt;/code&gt; to handle any possible errors (because they're gross); &lt;em&gt;and also&lt;/em&gt; we don't want to use a check inside the function that won't consistently reveal the truth about the feature (for example, &lt;code&gt;document.createElement('audio')&lt;/code&gt; will still create an element called &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; even if HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is not supported).</source>
          <target state="translated">Рассмотрим краткую функцию, которая определяет функциональные возможности (и в данном случае совместимость с платформой) посредством &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;динамической типизации&lt;/a&gt;&lt;/strong&gt; (так называемая &amp;laquo;утиная типизация&amp;raquo;). Мы хотим написать функцию, которая возвращает &lt;code&gt;true&lt;/code&gt; , если браузер пользователя поддерживает элемент HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; , но мы не хотим, чтобы функция выдавала ошибку, если &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; не определено; и мы не хотим использовать &lt;code&gt;try ... catch&lt;/code&gt; для обработки любых возможных ошибок (потому что они грубые); &lt;em&gt;а также&lt;/em&gt; мы не хотим использовать проверку внутри функции, которая не будет последовательно раскрывать правду о функции (например, &lt;code&gt;document.createElement('audio')&lt;/code&gt; все равно создаст элемент с именем &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; , даже если HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; не поддерживается).</target>
        </trans-unit>
        <trans-unit id="9c2bfed607f580ac4ac34ab9f08a0c6aa7cb0429" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Object&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;. If it was falsey (e.g. &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, etc.), it will be &lt;code&gt;false&lt;/code&gt;, otherwise, &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Преобразует &lt;code&gt;Object&lt;/code&gt; в &lt;code&gt;boolean&lt;/code&gt; . Если это было false (например, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; и т. Д.), Это будет &lt;code&gt;false&lt;/code&gt; , в противном случае - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7af2387329e42b1e1dcdbdc75737b43eb16b3b56" translate="yes" xml:space="preserve">
          <source>Double boolean negation. Often used to check if value is not undefined.</source>
          <target state="translated">Двойное булевое отрицание.Часто используется для проверки,не является ли значение неопределенным.</target>
        </trans-unit>
        <trans-unit id="1378886488bff47eea733f621e4e6b0a3b97b140" translate="yes" xml:space="preserve">
          <source>Each function accepts an argument for a &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; and an &lt;code&gt;attribute&lt;/code&gt; to look for, but they each return different values based on what the comparisons determine.</source>
          <target state="translated">Каждая функция принимает аргумент для &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; и &lt;code&gt;attribute&lt;/code&gt; для поиска, но каждая из них возвращает разные значения в зависимости от того, что определяют сравнения.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="1e86b051c400fed4e8f797a656375e775595e029" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; and &lt;code&gt;!!0 === false&lt;/code&gt;.</source>
          <target state="translated">Например: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; и &lt;code&gt;!!0 === false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0da32197e1f2c3ed9016c076548a9c1dc68c0878" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False in JSX (React) has a special meaning&lt;/a&gt; that's not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in &lt;code&gt;messageCount&lt;/code&gt;...</source>
          <target state="translated">Например, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False в JSX (React) имеет особое значение,&lt;/a&gt; которое не вызывается простой ложью. Если вы попытались вернуть что-то вроде следующего в ваш JSX, ожидая int в &lt;code&gt;messageCount&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="eaa9bb432088641bac3a4242e7ee096bd6cecd11" translate="yes" xml:space="preserve">
          <source>Here are the three approaches:</source>
          <target state="translated">Вот три подхода:</target>
        </trans-unit>
        <trans-unit id="f64e010c295a2870b0f4d659e488a6c517e64044" translate="yes" xml:space="preserve">
          <source>Here's an interesting case... &lt;code&gt;!!&lt;/code&gt; might be useful when 3rd party libs expect explicit Boolean values.</source>
          <target state="translated">Вот интересный случай ... &lt;code&gt;!!&lt;/code&gt; может быть полезно, когда сторонние библиотеки ожидают явных логических значений.</target>
        </trans-unit>
        <trans-unit id="5dcc317e1dd0008af8179d1f9a0f92f72220ebe0" translate="yes" xml:space="preserve">
          <source>However it has several practical uses.</source>
          <target state="translated">Однако он имеет несколько практических применений.</target>
        </trans-unit>
        <trans-unit id="f73892b42e6ec2099f18c789a4ca27320607324a" translate="yes" xml:space="preserve">
          <source>However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting &lt;code&gt;true&lt;/code&gt; from a non-boolean, possibly undefined value is indeed by using &lt;code&gt;!!&lt;/code&gt;. Hopefully this ridiculously clears it up.</source>
          <target state="translated">Какими бы редкими ни были эти ситуации, может существовать несколько сценариев, в которых наиболее сжатый, наиболее производительный и, следовательно, наиболее предпочтительный способ получения &lt;code&gt;true&lt;/code&gt; из небулева, возможно, неопределенного значения действительно заключается в использовании &lt;code&gt;!!&lt;/code&gt; , Надеюсь, это смехотворно проясняет.</target>
        </trans-unit>
        <trans-unit id="4f858245f3d281e55c31873b62aa68516b0b67f3" translate="yes" xml:space="preserve">
          <source>However:</source>
          <target state="translated">However:</target>
        </trans-unit>
        <trans-unit id="e75de3aca85245f9741f3ed73aba2405a0e6cfcd" translate="yes" xml:space="preserve">
          <source>I can't think of a great, non-contrived use case for that offhand. Maybe you have &quot;linked&quot; fields in a form?</source>
          <target state="translated">Я не могу придумать отличный,неуправляемый футляр для такого использования.Может,у вас есть &quot;связанные&quot; поля в форме?</target>
        </trans-unit>
        <trans-unit id="bd129d49875f1c7bf2d6c56ffa1cefd1aa871386" translate="yes" xml:space="preserve">
          <source>I just wanted to add that</source>
          <target state="translated">Я просто хотел добавить,что</target>
        </trans-unit>
        <trans-unit id="227f3285ec3ec43c9acc1d6e328c5b2a5034b7af" translate="yes" xml:space="preserve">
          <source>I saw some code that seems to use an operator I don't recognize, in the form of two exclamation points, like so: &lt;code&gt;!!&lt;/code&gt;. Can someone please tell me what this operator does?</source>
          <target state="translated">Я видел некоторый код, который, кажется, использует незнакомый оператор в виде двух восклицательных знаков, например так: &lt;code&gt;!!&lt;/code&gt; , Может кто-нибудь сказать, пожалуйста, что делает этот оператор?</target>
        </trans-unit>
        <trans-unit id="0ab6442ad8b0b1090c870a59a8d71ba43701e2c7" translate="yes" xml:space="preserve">
          <source>I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.</source>
          <target state="translated">Подозреваю,что это остатки от Си++,где люди переопределяют оператор !,но не оператор bool.</target>
        </trans-unit>
        <trans-unit id="003e87252c9f7ec44808278e2171c30bbf27960f" translate="yes" xml:space="preserve">
          <source>I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of &amp;amp;&amp;amp; and 
first success or last fail in case of || of condition chain.</source>
          <target state="translated">Я думаю, стоит упомянуть, что условие в сочетании с логическим И / ИЛИ не будет возвращать логическое значение, но последний успех или первый сбой в случае &amp;amp;&amp;amp; и первый успех или последний сбой в случае || цепи условий.</target>
        </trans-unit>
        <trans-unit id="d802fb28a6d04b4cc61b6721bff2527b6ab50f8a" translate="yes" xml:space="preserve">
          <source>I'm more comfortable handling falsiness myself with a ternary --</source>
          <target state="translated">Мне и самому удобнее справляться с фальшивками с тернарием...</target>
        </trans-unit>
        <trans-unit id="f605cfe8b7167fb9c1edb800b4a71aae4fe2edfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a false value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; является ложным значением &lt;code&gt;!x&lt;/code&gt; является &lt;code&gt;true&lt;/code&gt; , а &lt;code&gt;!!x&lt;/code&gt; является &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2542885728d534e0cbf50ded3d8082dbb4bc2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a true value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;x&lt;/code&gt; - истинное значение &lt;code&gt;!x&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; , а &lt;code&gt;!!x&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24f97de69477863bf6708059e17ad9778d8a9cc3" translate="yes" xml:space="preserve">
          <source>If that element does in fact exist, the expression will evaluate as true, and the code block will be executed.</source>
          <target state="translated">Если этот элемент действительно существует,выражение будет оценено как истинное,и блок кода будет выполнен.</target>
        </trans-unit>
        <trans-unit id="442b7a39eb1de6839bcbf2cca353f71f520acfac" translate="yes" xml:space="preserve">
          <source>If you &amp;rArr;</source>
          <target state="translated">Если вы &amp;rArr;</target>
        </trans-unit>
        <trans-unit id="5075badbf5e88b6b0caa8ef134b856caccd05702" translate="yes" xml:space="preserve">
          <source>If you only care that a value is truthy or falsy, then use the short form. Instead of</source>
          <target state="translated">Если вас волнует только то,что ценность является правдивой или фальшивой,тогда используйте короткую форму.Вместо</target>
        </trans-unit>
        <trans-unit id="25c0c498a0bdb8446495ca30bd5369fa1fe77b30" translate="yes" xml:space="preserve">
          <source>In order to cast the condition to a true boolean literal we can use the double negation:</source>
          <target state="translated">Для того,чтобы привести условие к истинному булевому буквальному значению,можно использовать двойное отрицание:</target>
        </trans-unit>
        <trans-unit id="d94b2b8672da34c8a43dd1c8cbce124ec9f02e37" translate="yes" xml:space="preserve">
          <source>Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (&lt;em&gt;without&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;) to explicitly cast values, ie</source>
          <target state="translated">Вместо этих хаков вы также можете использовать функции конструктора, соответствующие типам примитивов ( &lt;em&gt;без&lt;/em&gt; использования &lt;code&gt;new&lt;/code&gt; ), для явного приведения значений, т.е.</target>
        </trans-unit>
        <trans-unit id="ef8ebd812b149cf4ca6384ab75bf685b7c51d444" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;Boolean&lt;/code&gt; class can be used.</source>
          <target state="translated">Вместо этого можно использовать &lt;code&gt;Boolean&lt;/code&gt; класс.</target>
        </trans-unit>
        <trans-unit id="bd5f0f08c8b69e561341c016a5178bbabfab99f4" translate="yes" xml:space="preserve">
          <source>It converts the suffix to a Boolean value.</source>
          <target state="translated">Он преобразует суффикс в булевское значение.</target>
        </trans-unit>
        <trans-unit id="04f0b660a5f5fd40c699d9299636f12196d971ce" translate="yes" xml:space="preserve">
          <source>It forces all things to boolean.</source>
          <target state="translated">Это заставляет все вещи булевать.</target>
        </trans-unit>
        <trans-unit id="362012587fedf1f206a41069ff29470d4bcc9b9f" translate="yes" xml:space="preserve">
          <source>It seems that the &lt;code&gt;!!&lt;/code&gt; operator results in a double negation.</source>
          <target state="translated">Кажется, что &lt;code&gt;!!&lt;/code&gt; оператор приводит к двойному отрицанию.</target>
        </trans-unit>
        <trans-unit id="d12e704c471bd7b5f2ef621231182892cdbce3ce" translate="yes" xml:space="preserve">
          <source>It simulates the behavior of the &lt;code&gt;Boolean()&lt;/code&gt; casting function.
The first &lt;code&gt;NOT&lt;/code&gt; returns a Boolean value no matter what operand it is given. The second &lt;code&gt;NOT&lt;/code&gt; negates that &lt;code&gt;Boolean&lt;/code&gt; value and so gives the &lt;code&gt;true&lt;/code&gt; Boolean value of a variable. The end result is the same as using the &lt;code&gt;Boolean()&lt;/code&gt; function on a value.</source>
          <target state="translated">Он имитирует поведение функции приведения типа &lt;code&gt;Boolean()&lt;/code&gt; . Первое &lt;code&gt;NOT&lt;/code&gt; возвращает логическое значение независимо от того, какой операнд ему дан. Второе &lt;code&gt;NOT&lt;/code&gt; отрицает это &lt;code&gt;Boolean&lt;/code&gt; значение и, таким образом, дает &lt;code&gt;true&lt;/code&gt; логическое значение переменной. Конечный результат аналогичен использованию функции &lt;code&gt;Boolean()&lt;/code&gt; для значения.</target>
        </trans-unit>
        <trans-unit id="b34f307bed6829df645edce297716e7d66021503" translate="yes" xml:space="preserve">
          <source>It's a double &lt;code&gt;not&lt;/code&gt; operation.  The first &lt;code&gt;!&lt;/code&gt; converts the value to boolean and inverts its logical value.  The second &lt;code&gt;!&lt;/code&gt; inverts the logical value back.</source>
          <target state="translated">Это двойная &lt;code&gt;not&lt;/code&gt; операция. Первое &lt;code&gt;!&lt;/code&gt; преобразует значение в логическое значение и инвертирует его логическое значение. Второе &lt;code&gt;!&lt;/code&gt; инвертирует логическое значение обратно.</target>
        </trans-unit>
        <trans-unit id="c63e6ec5ccb83901a441e96930f2594861a2a402" translate="yes" xml:space="preserve">
          <source>It's a horribly obscure way to do a type conversion.</source>
          <target state="translated">Это ужасно непонятный способ сделать преобразование типа.</target>
        </trans-unit>
        <trans-unit id="a0bfc03fee00b0a95a35794ff4b18bfb284ed3d7" translate="yes" xml:space="preserve">
          <source>It's just the logical NOT operator, twice - it's used to convert something to boolean, e.g.:</source>
          <target state="translated">Это просто логический оператор NOT,дважды-он используется для преобразования чего-то в булевую,например:</target>
        </trans-unit>
        <trans-unit id="54382507df0f3d9ecbfe0a329a53e74bef4a1834" translate="yes" xml:space="preserve">
          <source>It's not a single operator, it's two.  It's equivalent to the following and is a quick way to cast a value to boolean.</source>
          <target state="translated">Это не один оператор,а два.Это эквивалентно следующему и является быстрым способом отбрасывания значения до булева.</target>
        </trans-unit>
        <trans-unit id="7f323048105e7d3908de65a905d0ecb9e7cccddb" translate="yes" xml:space="preserve">
          <source>JSX' docs suggest you be more explicit, write self-commenting code, and use a comparison to force to a Boolean.</source>
          <target state="translated">Документы JSX' предлагают вам быть более откровенным,писать самокомментирующийся код и использовать сравнение с Boolean.</target>
        </trans-unit>
        <trans-unit id="857f728eac2339b6a141ba1d44e27519c2166bbc" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;strong&gt;these &lt;em&gt;are JSX &amp;amp; Typescript conventions&lt;/em&gt;, not ones inherent to JavaScript&lt;/strong&gt;.</source>
          <target state="translated">Имейте в виду, что &lt;strong&gt;это &lt;em&gt;соглашения JSX и Typescript&lt;/em&gt; , а не присущие JavaScript&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="558b0b10df23ff62727f0cdf06a369839b8ba0b0" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; in use.</source>
          <target state="translated">А именно, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="71a6705b7fa3ec15cdb9c15f74c0a2866a4f8b3e" translate="yes" xml:space="preserve">
          <source>Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.</source>
          <target state="translated">Естественно,все это то же самое,что просто набрать !someThing,но добавленные скобки могут помочь сделать это более понятным.</target>
        </trans-unit>
        <trans-unit id="062b9d1606d85c2c91b697df5b29f343f34bfd4f" translate="yes" xml:space="preserve">
          <source>Note that there are some &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;unintuitive cases&lt;/a&gt; where a boolean will be cast to a number (&lt;code&gt;true&lt;/code&gt; is cast to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;) when comparing a boolean to a number. In this case, &lt;code&gt;!!&lt;/code&gt; might be mentally useful. Though, again, &lt;strong&gt;these are cases where you're comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake.&lt;/strong&gt;&lt;code&gt;if (-1)&lt;/code&gt; is still the way to go here.</source>
          <target state="translated">Обратите внимание, что есть некоторые &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;неинтуитивные случаи,&lt;/a&gt; когда логическое значение будет приведено к числу ( &lt;code&gt;true&lt;/code&gt; приведено к &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; к &lt;code&gt;0&lt;/code&gt; ) при сравнении логического значения с числом. В этом случае &lt;code&gt;!!&lt;/code&gt; может быть психически полезным. Хотя, опять же, &lt;strong&gt;это те случаи, когда вы сравниваете не-логическое значение с жестко типизированным логическим значением, что, на мой взгляд, является серьезной ошибкой.&lt;/strong&gt; &lt;code&gt;if (-1)&lt;/code&gt; еще путь сюда.</target>
        </trans-unit>
        <trans-unit id="57d186fffc848f3760d873fa6a5efef0c4b69fd9" translate="yes" xml:space="preserve">
          <source>One fix involves the bangbang, which coerces &lt;code&gt;0&lt;/code&gt; into &lt;code&gt;!!0&lt;/code&gt;, which is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Одно из исправлений касается bangbang, который приводит &lt;code&gt;0&lt;/code&gt; к &lt;code&gt;!!0&lt;/code&gt; , что &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a6f54cbcb01cbe0a3333b72e4ff3a962a0f801e" translate="yes" xml:space="preserve">
          <source>One use is to lossily compress an object to its truth value, so that your code isn't holding a reference to a big object and keeping it alive. Assigning &lt;code&gt;!!some_big_object&lt;/code&gt; to a variable instead of &lt;code&gt;some_big_object&lt;/code&gt; lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as &lt;code&gt;null&lt;/code&gt; or the undefined value, such as browser feature detection.</source>
          <target state="translated">Одним из способов является сжатие с потерями объекта до его истинного значения, чтобы ваш код не содержал ссылку на большой объект и не поддерживал его. Присвоение &lt;code&gt;!!some_big_object&lt;/code&gt; переменной вместо &lt;code&gt;some_big_object&lt;/code&gt; позволяет избавиться от нее для сборщика мусора. Это полезно в случаях, когда создается либо объект, либо ложное значение, например, &lt;code&gt;null&lt;/code&gt; , или неопределенное значение, например, определение функции браузера.</target>
        </trans-unit>
        <trans-unit id="161e7eb8bec71d838abd41540cca030c08d6f7f6" translate="yes" xml:space="preserve">
          <source>Please check code snippet out below &lt;strong&gt;&amp;darr;&lt;/strong&gt;</source>
          <target state="translated">Пожалуйста, проверьте фрагмент кода ниже &lt;strong&gt;&amp;darr;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9c634cfd1a38a3aa345e046738679df22d80362" translate="yes" xml:space="preserve">
          <source>Practical uses</source>
          <target state="translated">Практическое применение</target>
        </trans-unit>
        <trans-unit id="114da967498be8e2c2cdf7df8db42e88ebd380c7" translate="yes" xml:space="preserve">
          <source>Pretend we have &lt;code&gt;myVar1 = 0;&lt;/code&gt; and &lt;code&gt;myVar2 = undefined;&lt;/code&gt;.</source>
          <target state="translated">Притворимся, что у нас &lt;code&gt;myVar1 = 0;&lt;/code&gt; и &lt;code&gt;myVar2 = undefined;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d2f2915a66e774b1c83f8a2a3e89284ac648434e" translate="yes" xml:space="preserve">
          <source>Real World Example &quot;Test IE version&quot;:</source>
          <target state="translated">Пример из реального мира &quot;Test IE version&quot;:</target>
        </trans-unit>
        <trans-unit id="b39d3fef53ba3ed826f8428d58a2371af89a4e7d" translate="yes" xml:space="preserve">
          <source>Returns boolean value of a variable.</source>
          <target state="translated">Возвращает логическое значение переменной.</target>
        </trans-unit>
        <trans-unit id="fc98ae78ccf4552e39bcf193255cd5a8ae570858" translate="yes" xml:space="preserve">
          <source>Same deal in Typescript: If you have a function that returns a boolean (or you're assigning a value to a boolean variable), you [usually] can't return/assign a boolean-y value; it has to be a strongly typed boolean. This means, &lt;strong&gt;iff &lt;code&gt;myObject&lt;/code&gt; is strongly typed&lt;/strong&gt;, &lt;code&gt;return !myObject;&lt;/code&gt; works for a function returning a boolean, but &lt;code&gt;return myObject;&lt;/code&gt; doesn't. You have to &lt;code&gt;return !!myObject&lt;/code&gt; to match Typescript's expectations.</source>
          <target state="translated">То же самое в Typescript: если у вас есть функция, которая возвращает логическое значение (или вы присваиваете значение логической переменной), вы [обычно] не можете вернуть / присвоить логическое значение-y; это должен быть строго типизированный логический тип. Это означает, что &lt;strong&gt;если &lt;code&gt;myObject&lt;/code&gt; строго типизирован&lt;/strong&gt; , &lt;code&gt;return !myObject;&lt;/code&gt; работает для функции, возвращающей логическое значение, но &lt;code&gt;return myObject;&lt;/code&gt; не делает. Вы должны &lt;code&gt;return !!myObject&lt;/code&gt; чтобы соответствовать ожиданиям Typescript.</target>
        </trans-unit>
        <trans-unit id="03d3dfc9a836826357b793d282380cd7f94081b6" translate="yes" xml:space="preserve">
          <source>See &quot;== and !=&quot; from &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint's directions&lt;/a&gt; (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:</source>
          <target state="translated">Посмотрите &quot;== и! =&quot; Из &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;указаний JSLint&lt;/a&gt; (примечание: Крокфорд немного перемещает свой сайт; в какой-то момент эта ссылка может умереть), чтобы узнать, почему:</target>
        </trans-unit>
        <trans-unit id="b77b945dc1e2fb58fae032d74373f3a357e30b37" translate="yes" xml:space="preserve">
          <source>Simply casting :(</source>
          <target state="translated">Простое литье :(</target>
        </trans-unit>
        <trans-unit id="6a0157727338f2b7b3fe3318d34c2684d92b3ba2" translate="yes" xml:space="preserve">
          <source>So  it's like using &lt;code&gt;Boolean&lt;/code&gt; function in javascript, but easy and shorter way to convert a value to boolean:</source>
          <target state="translated">Так что это похоже на использование &lt;code&gt;Boolean&lt;/code&gt; функции в javascript, но простой и короткий способ преобразования значения в булево:</target>
        </trans-unit>
        <trans-unit id="c4992f9e1d0a43038d9ca1117fe08701149b40b0" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;!!&lt;/code&gt; is not an operator, it's just the &lt;code&gt;!&lt;/code&gt; operator twice.</source>
          <target state="translated">Так &lt;code&gt;!!&lt;/code&gt; это не оператор, это просто &lt;code&gt;!&lt;/code&gt; оператор дважды.</target>
        </trans-unit>
        <trans-unit id="0addbe39410a730dff513bf6537d8856157b56c9" translate="yes" xml:space="preserve">
          <source>So many answers doing half the work. Yes, &lt;code&gt;!!X&lt;/code&gt; could be read as &quot;the truthiness of X [represented as a boolean]&quot;. But &lt;code&gt;!!&lt;/code&gt; isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. &lt;code&gt;!!myVar === true&lt;/code&gt; is the same as just &lt;code&gt;myVar&lt;/code&gt;. Comparing &lt;code&gt;!!X&lt;/code&gt; to a &quot;real&quot; boolean isn't really useful.</source>
          <target state="translated">Так много ответов делают половину работы. Да, &lt;code&gt;!!X&lt;/code&gt; можно прочитать как &amp;laquo;истинность X [представлена ​​как логическое значение]&amp;raquo;. Но &lt;code&gt;!!&lt;/code&gt; На самом деле, это не так важно для выяснения, является ли единственная переменная (или даже если много переменных) истинной или ложной. &lt;code&gt;!!myVar === true&lt;/code&gt; - это то же самое, что и &lt;code&gt;myVar&lt;/code&gt; . Сравнение &lt;code&gt;!!X&lt;/code&gt; с &amp;laquo;настоящим&amp;raquo; логическим значением не очень полезно.</target>
        </trans-unit>
        <trans-unit id="014ab2f522034cc3c77ca7c114cbd4670167db8e" translate="yes" xml:space="preserve">
          <source>So now if you have a truthy for both &lt;em&gt;or&lt;/em&gt; a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your &lt;code&gt;errorObjects&lt;/code&gt; collection.</source>
          <target state="translated">Так что теперь, если у вас есть правдивое для обоих &lt;em&gt;или&lt;/em&gt; ложное имя и возраст супруга, вы можете продолжить. В противном случае у вас есть только одно поле со значением (или очень ранний брак), и вам нужно создать дополнительную ошибку в вашей коллекции &lt;code&gt;errorObjects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e63cc48d4173484ca47b8b9c48f21169296682e7" translate="yes" xml:space="preserve">
          <source>So the only place you'd really need to use &quot;boolean-cast variables&quot; would be if you had a situation where you're checking if both variables have the &lt;em&gt;same&lt;/em&gt; truthiness, right? That is, &lt;b&gt;use &lt;code&gt;!!&lt;/code&gt; if you need to see if two vars are &lt;em&gt;both truthy or both falsy&lt;/em&gt; (or not), that is, &lt;em&gt;of equal&lt;/em&gt; (or not) &lt;em&gt;truthiness&lt;/em&gt;.&lt;/b&gt;</source>
          <target state="translated">Таким образом, единственное место, где вам действительно нужно использовать &amp;laquo;переменные логического преобразования&amp;raquo;, - это если бы у вас была ситуация, когда вы проверяете, имеют ли обе переменные &lt;em&gt;одинаковую&lt;/em&gt; истинность, верно? То есть &lt;b&gt;пользуйтесь &lt;code&gt;!!&lt;/code&gt; &lt;/b&gt; &lt;b&gt;если вам нужно увидеть, являются ли две переменные &lt;em&gt;правдивыми или ложными&lt;/em&gt; (или нет), то есть &lt;em&gt;равными&lt;/em&gt; (или нет) &lt;em&gt;правдивостью&lt;/em&gt; .&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8fc0438c0801780b20fbecd73911dad21ef51b6" translate="yes" xml:space="preserve">
          <source>So to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!.</source>
          <target state="translated">Поэтому,чтобы получить отрицательный(или положительный)ответ в этом случае,сначала нужно использовать оператор !! для получения логического ключа,но если вы захотите проверить положительный ответ,то воспользуйтесь оператором !!!</target>
        </trans-unit>
        <trans-unit id="6e23c1f4bfbfa0ccb58b6c59c222898580d75194" translate="yes" xml:space="preserve">
          <source>So you're converting a value to a boolean, then inverting it, then inverting it again.</source>
          <target state="translated">Значит,вы преобразовываете значение в булевую,затем инвертируете его,а затем снова инвертируете.</target>
        </trans-unit>
        <trans-unit id="70f19fcd06b0becbaad2b70e1d5cf4e4e3e27fee" translate="yes" xml:space="preserve">
          <source>Some of you probably noticed that in this specific example, one could simply check for a property using the slightly &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;more performant&lt;/a&gt;&lt;/strong&gt; means of checking if the object in question &lt;em&gt;has&lt;/em&gt; a property. There are two ways to do this:</source>
          <target state="translated">Некоторые из вас, вероятно, заметили, что в этом конкретном примере можно просто проверить свойство, используя чуть &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;более производительные&lt;/a&gt;&lt;/strong&gt; средства проверки, имеет ли рассматриваемый объект свойство. Есть два способа сделать это:</target>
        </trans-unit>
        <trans-unit id="4b46f5ed42b9b9e328c2f46362683a228c43e509" translate="yes" xml:space="preserve">
          <source>Some operators in JavaScript perform implicit type conversions, and are sometimes
used for type conversion.</source>
          <target state="translated">Некоторые операторы в JavaScript выполняют неявное приведение типов,а иногда используются для приведения типов.</target>
        </trans-unit>
        <trans-unit id="ea085d9130b086f1623397b738adcbac23d6d7e9" translate="yes" xml:space="preserve">
          <source>That is...</source>
          <target state="translated">Это...</target>
        </trans-unit>
        <trans-unit id="82fc7d92ba7e869e36f27a18325c4d16d5a80178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; construct is a simple way of turning any JavaScript expression into
its Boolean equivalent.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; Конструкция - это простой способ превратить любое выражение JavaScript в его логический эквивалент.</target>
        </trans-unit>
        <trans-unit id="90d1a7ed711f96e90a1182e13fa7e55e0596693e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; Оператор убеждает инструмент lint в том, что вы написали то, что имели в виду: выполните эту операцию, а затем примите истинное значение результата.</target>
        </trans-unit>
        <trans-unit id="eabc5d96ac71e6f38058420dd87159a58d3314a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements and the &lt;code&gt;?&lt;/code&gt; operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and &lt;code&gt;null&lt;/code&gt; are both false.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; и в &lt;code&gt;while&lt;/code&gt; заявления и то &lt;code&gt;?&lt;/code&gt; оператор использует значения истинности, чтобы определить, какую ветвь кода запустить. Например, нулевые и NaN числа и пустая строка являются ложными, но другие числа и строки являются истинными. Объекты имеют значение true, но неопределенное значение и &lt;code&gt;null&lt;/code&gt; оба имеют значение false.</target>
        </trans-unit>
        <trans-unit id="29d047ae2b1b9b41221cc9a49cebe8c72ef84804" translate="yes" xml:space="preserve">
          <source>The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r\n' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.</source>
          <target state="translated">Операторы ==и !=перед сравнением выполняют принуждение типов.Это плохо,так как приводит к тому,что ' \t\r\n' ==0 будет true.Это может маскировать ошибки с типами.JSLint не может надежно определить,правильно ли используется ==,поэтому лучше вообще не использовать ==и !=,а всегда использовать более надежные операторы ===и !==.</target>
        </trans-unit>
        <trans-unit id="19d8f9dad8485f308ad86d92258b4c919e2fb866" translate="yes" xml:space="preserve">
          <source>The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; are both &quot;truthy&quot; and we will continue down the so-called &quot;&amp;amp;&amp;amp; chain&quot; to the next value to the right.</source>
          <target state="translated">Вышеприведенный возврат не определен, но если у вас есть пустая строка, false, null, 0, undefined, эти значения вернутся, и как только мы встретим их в цепочке - &lt;code&gt;[]&lt;/code&gt; и &lt;code&gt;{}&lt;/code&gt; оба являются &amp;laquo;истинными&amp;raquo;, и мы продолжим вниз по так называемая цепочка &amp;amp;&amp;amp; к следующему значению справа.</target>
        </trans-unit>
        <trans-unit id="b6f0570101450478158dcd94c3db9bdc410dbccf" translate="yes" xml:space="preserve">
          <source>The above's not so useful. &lt;code&gt;if (!0)&lt;/code&gt; gives you the same results as &lt;code&gt;if (!!0 === false)&lt;/code&gt;. I can't think of a good case for casting a variable to boolean and then comparing to a &quot;true&quot; boolean.</source>
          <target state="translated">Выше не так полезно. &lt;code&gt;if (!0)&lt;/code&gt; дает те же результаты, что и &lt;code&gt;if (!!0 === false)&lt;/code&gt; . Я не могу придумать хорошего случая для приведения переменной к логическому, а затем сравнения с &amp;laquo;истинным&amp;raquo; логическим значением.</target>
        </trans-unit>
        <trans-unit id="281762abc14819a66dcacbfde55f5e8401270f1d" translate="yes" xml:space="preserve">
          <source>The context in which I saw this was,</source>
          <target state="translated">Контекст,в котором я это видел,</target>
        </trans-unit>
        <trans-unit id="acc6b507b28fe734085a51694ffb662d2f97612f" translate="yes" xml:space="preserve">
          <source>The double &quot;not&quot; in this case is quite simple.  It is simply two &lt;code&gt;not&lt;/code&gt;s back to back.</source>
          <target state="translated">Двойное &amp;laquo;не&amp;raquo; в этом случае довольно просто. Это просто два &lt;code&gt;not&lt;/code&gt; спина к спине.</target>
        </trans-unit>
        <trans-unit id="531d1ca78f0741ca59c6f0a6607b3ea3cdc4a6d9" translate="yes" xml:space="preserve">
          <source>The double negation operator &lt;code&gt;!!&lt;/code&gt; calculates the truth value of a value. It's actually two operators, where &lt;code&gt;!!x&lt;/code&gt; means &lt;code&gt;!(!x)&lt;/code&gt;, and behaves as follows:</source>
          <target state="translated">Оператор двойного отрицания &lt;code&gt;!!&lt;/code&gt; вычисляет истинное значение стоимости. На самом деле это два оператора, где &lt;code&gt;!!x&lt;/code&gt; означает &lt;code&gt;!(!x)&lt;/code&gt; и ведет себя следующим образом:</target>
        </trans-unit>
        <trans-unit id="0fedba5c4ec19ca80540448ef2226b8d7209ad69" translate="yes" xml:space="preserve">
          <source>The exception for Typescript? If &lt;code&gt;myObject&lt;/code&gt; was an &lt;code&gt;any&lt;/code&gt;, you're back in JavaScript's Wild West and can return it without &lt;code&gt;!!&lt;/code&gt;, even if your return type is a boolean.</source>
          <target state="translated">Исключение для Typescript? Если &lt;code&gt;myObject&lt;/code&gt; был &lt;code&gt;any&lt;/code&gt; , вы вернулись в JavaScript на Диком Западе и можете вернуть его без &lt;code&gt;!!&lt;/code&gt; , даже если ваш тип возвращаемого значения является логическим.</target>
        </trans-unit>
        <trans-unit id="e4d67b97b47952ce6811073a8a2a38486c684c78" translate="yes" xml:space="preserve">
          <source>The first bang forces the js engine to run &lt;code&gt;Boolean(x)&lt;/code&gt; but also has the side effect of inverting the value.  So the second bang undoes the side effect.</source>
          <target state="translated">Первый удар заставляет двигатель js запускать &lt;code&gt;Boolean(x)&lt;/code&gt; но также имеет побочный эффект инвертирования значения. Таким образом, второй удар отменяет побочный эффект.</target>
        </trans-unit>
        <trans-unit id="fe7b25df5389abed33b3b0b02607f02a5ccbe313" translate="yes" xml:space="preserve">
          <source>The first one simply &quot;inverts&quot; the truthy or falsey value, resulting in an actual boolean type, and then the second one &quot;inverts&quot; it back again to it's original state, but now in an actual boolean value.  That way you have consistency:</source>
          <target state="translated">Первый просто &quot;инвертирует&quot; истинное или ложное значение,в результате чего получается действительный булевый тип,а второй &quot;инвертирует&quot; его обратно в исходное состояние,но теперь в действительное булевое значение.Таким образом,вы получаете последовательность:</target>
        </trans-unit>
        <trans-unit id="7bbf601d501a5f0c41724feba5edab84aa91cd28" translate="yes" xml:space="preserve">
          <source>The trick here is the chain of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;s will return &lt;strong&gt;the first falsey value&lt;/strong&gt; it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the &lt;code&gt;b.foo.bar&lt;/code&gt; statement, and we get no error.</source>
          <target state="translated">Хитрость здесь в том, что цепочка &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; s вернет &lt;strong&gt;первое найденное значение Falsey&lt;/strong&gt; - и это может быть передано в оператор if и т. Д. Поэтому, если b.foo не определен, он вернет undefined и пропустит &lt;code&gt;b.foo.bar&lt;/code&gt; заявление, и мы не получим ошибки.</target>
        </trans-unit>
        <trans-unit id="f362651fc7a92ae9f0a9673d4c5486b2f3f73825" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!false&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">Правда в том, что &lt;code&gt;false&lt;/code&gt; не &lt;code&gt;true&lt;/code&gt; (вот почему &lt;code&gt;!false&lt;/code&gt; приводит к &lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="a45301cb714edcffab6f1d258022757ae0ecd7bd" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!!false&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">Правда в том, что &lt;code&gt;false&lt;/code&gt; не является &lt;code&gt;false&lt;/code&gt; (вот почему &lt;code&gt;!!false&lt;/code&gt; приводит к &lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="dc6dfe93853155dde81483486981f53f459fca48" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!true&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">Правда в том, что &lt;code&gt;true&lt;/code&gt; - это не &lt;code&gt;false&lt;/code&gt; (вот почему &lt;code&gt;!true&lt;/code&gt; Истина - &lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="de5886521d1b8bae3b9e573aa8de49514dcf5e6d" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!!true&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">Правда в том, что &lt;code&gt;true&lt;/code&gt; - это &lt;em&gt;не&lt;/em&gt; &lt;code&gt;true&lt;/code&gt; (вот почему &lt;code&gt;!!true&lt;/code&gt; приводит к &lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="3c5ec1883ea648c4eac15e44a0e47cc089c821db" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;!&lt;/code&gt; operator converts its operand to a boolean and negates it.</source>
          <target state="translated">Одинарный &lt;code&gt;!&lt;/code&gt; Оператор преобразует свой операнд в логическое значение и отрицает его.</target>
        </trans-unit>
        <trans-unit id="33306e297fa07aa22ffeca48a2d3b1ca6f355960" translate="yes" xml:space="preserve">
          <source>Then you do &lt;code&gt;!0&lt;/code&gt;, it will be converted to boolean and be evaluated to &lt;code&gt;true&lt;/code&gt;, because 0 is &lt;code&gt;falsy&lt;/code&gt;, so you get the reversed value and converted to boolean, so it gets evaluated to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Затем вы делаете &lt;code&gt;!0&lt;/code&gt; , оно будет преобразовано в логическое значение и будет оценено как &lt;code&gt;true&lt;/code&gt; , потому что 0 является &lt;code&gt;falsy&lt;/code&gt; , поэтому вы получаете обратное значение и конвертируетесь в логическое значение, поэтому оно оценивается как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71ab5eac91ed7f0607dae3a2cf1d7e72a4ca4e97" translate="yes" xml:space="preserve">
          <source>This fact lead to the following idiom that you can see in your source code:</source>
          <target state="translated">Этот факт приводит к следующей идиоме,которую можно увидеть в исходных текстах:</target>
        </trans-unit>
        <trans-unit id="5206aead5c0929d44fb460d6a6d755b4275d68d5" translate="yes" xml:space="preserve">
          <source>This question has been answered quite thoroughly, but I'd like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.</source>
          <target state="translated">На этот вопрос был дан довольно исчерпывающий ответ,но я хотел бы добавить ответ,который,я надеюсь,будет максимально упрощен,делая смысл !! настолько простым для понимания,насколько это возможно.</target>
        </trans-unit>
        <trans-unit id="900a6ce54db6671d1163b4588fef81576caa9d76" translate="yes" xml:space="preserve">
          <source>Tons of great answers here, but if you've read down this far, this helped me to 'get it'. Open the console on Chrome (etc), and start typing:</source>
          <target state="translated">Здесь тонны отличных ответов,но если вы читали так далеко,то это помогло мне &quot;достать&quot;.Откройте консоль на Chrome (и т.д.)и начинайте печатать:</target>
        </trans-unit>
        <trans-unit id="b5a7a294200e3cb34da2a97adf5d130ba6c38c00" translate="yes" xml:space="preserve">
          <source>Use logical not operator two times</source>
          <target state="translated">Использовать логический,а не оператор два раза</target>
        </trans-unit>
        <trans-unit id="037ce300d2779ff07c53c4b5b8748bb947cb98bb" translate="yes" xml:space="preserve">
          <source>What is the !! (not not) operator in JavaScript</source>
          <target state="translated">Что за !!! (не)оператор в JavaScript.</target>
        </trans-unit>
        <trans-unit id="2bd5abc68757873bb182393e529f58b5f1764ea3" translate="yes" xml:space="preserve">
          <source>What we wish to determine in the comparison is the &quot;truth&quot; &lt;em&gt;about&lt;/em&gt; the value of a reference, not the &lt;em&gt;value of&lt;/em&gt; the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be &lt;em&gt;&lt;code&gt;false&lt;/code&gt;&lt;/em&gt; (or falsey), or if we expect the value not to be typeof &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">Что мы хотим определить при сравнении, так это &amp;laquo;правда&amp;raquo; &lt;em&gt;о&lt;/em&gt; значении ссылки, а не о &lt;em&gt;ценности&lt;/em&gt; самой ссылки. Существует вариант использования, в котором мы можем захотеть узнать правду о значении, даже если мы ожидаем, что значение будет &lt;em&gt; &lt;code&gt;false&lt;/code&gt; &lt;/em&gt; (или ложным), или если мы ожидаем, что значение не будет typeof &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6dfeec064b00b28af55ee18d69a51869a08807e" translate="yes" xml:space="preserve">
          <source>What you gain with &lt;code&gt;!!&lt;/code&gt; is the ability to check the truthiness of multiple variables &lt;em&gt;against each other&lt;/em&gt; in a repeatable, standardized (and JSLint friendly) fashion.</source>
          <target state="translated">Что вы получаете с &lt;code&gt;!!&lt;/code&gt; это способность проверять достоверность нескольких переменных &lt;em&gt;друг против друга&lt;/em&gt; повторяемым, стандартизированным (и дружественным JSLint) способом.</target>
        </trans-unit>
        <trans-unit id="d568b1f542f2ac7d26a5c47b5cb7b7775b67ea06" translate="yes" xml:space="preserve">
          <source>When used at the top level of a Boolean context (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;), the &lt;code&gt;!!&lt;/code&gt; operator is behaviorally a no-op. For example, &lt;code&gt;if (x)&lt;/code&gt; and &lt;code&gt;if (!!x)&lt;/code&gt; mean the same thing.</source>
          <target state="translated">При использовании на верхнем уровне логического контекста ( &lt;code&gt;if&lt;/code&gt; , в &lt;code&gt;while&lt;/code&gt; , или &lt;code&gt;?&lt;/code&gt; ), &lt;code&gt;!!&lt;/code&gt; Оператор поведенчески неактивен. Например, &lt;code&gt;if (x)&lt;/code&gt; и &lt;code&gt;if (!!x)&lt;/code&gt; означают одно и то же.</target>
        </trans-unit>
        <trans-unit id="15bdd7d9c3451db43373e5025a0173bdf0c60369" translate="yes" xml:space="preserve">
          <source>Why?  Because &lt;code&gt;document.getElementById()&lt;/code&gt; is a &quot;truthy&quot; expression that will evaluate as true in this &lt;code&gt;if()&lt;/code&gt; statement, but it is not an actual boolean value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Почему? Поскольку &lt;code&gt;document.getElementById()&lt;/code&gt; является &amp;laquo;истинным&amp;raquo; выражением, которое будет оцениваться как истинное в этом операторе &lt;code&gt;if()&lt;/code&gt; , но оно не является фактическим логическим значением &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2562e78de1b3256bca3da91141bb0297a876088d" translate="yes" xml:space="preserve">
          <source>and instead of</source>
          <target state="translated">и вместо</target>
        </trans-unit>
        <trans-unit id="6ff7395099aa52cc1ac2567047b5dc904e83a97c" translate="yes" xml:space="preserve">
          <source>but we don't want the reversed &lt;strong&gt;boolean version&lt;/strong&gt; of the value, so we can reverse it again to get our result! That's why we use another &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">но нам не нужна обратная &lt;strong&gt;логическая версия&lt;/strong&gt; значения, поэтому мы можем снова изменить ее, чтобы получить наш результат! Вот почему мы используем другое &lt;code&gt;!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="1136ebda06acfbb946c27883e9c70a00d96a8324" translate="yes" xml:space="preserve">
          <source>here is a piece of code from angular js</source>
          <target state="translated">вот кусок кода из угловых js.</target>
        </trans-unit>
        <trans-unit id="07aee702dc1bc81b24b43ca8e96d3a68f77ddfba" translate="yes" xml:space="preserve">
          <source>if requestAnimationFrame was assinged undefined then
!requestAnimationFrame would be true and one more ! of it would be false</source>
          <target state="translated">если бы requestAnimationFrame был определен как неопределенный,то !requestAnimationFrame был бы истинен,и еще один ! из них был бы ложным.</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">такой же,как</target>
        </trans-unit>
        <trans-unit id="fb81871808eeba6b79f000511077e0392e5040fe" translate="yes" xml:space="preserve">
          <source>it can be achieved by checking in following way in general:</source>
          <target state="translated">это может быть достигнуто путем проверки в целом следующим образом:</target>
        </trans-unit>
        <trans-unit id="bf9bb582fda3d69616ba7956287f904859457f58" translate="yes" xml:space="preserve">
          <source>just say</source>
          <target state="translated">просто сказать</target>
        </trans-unit>
        <trans-unit id="dc01c6b7487aab92695f7ba918540cf5051f72f4" translate="yes" xml:space="preserve">
          <source>say</source>
          <target state="translated">say</target>
        </trans-unit>
        <trans-unit id="287b978241585895eb95865fc85abb7f32f60d1e" translate="yes" xml:space="preserve">
          <source>so if requestAnimationFrame was assigned a function
 then
!requestAnimationFrame would be false and one more ! of it would be true</source>
          <target state="translated">так что если бы requestAnimationFrame был назначен функцией,то !requestAnimationFrame был бы ложным и еще один ! из них был бы истинным</target>
        </trans-unit>
        <trans-unit id="7c2b4b647bd0e7cbaa828c353b4a7be55a9be894" translate="yes" xml:space="preserve">
          <source>the short way could be using !!</source>
          <target state="translated">короткий путь может быть использован!!!</target>
        </trans-unit>
        <trans-unit id="2b1fd3dee3545afca88dbce54f7f1d0f063a468f" translate="yes" xml:space="preserve">
          <source>their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame</source>
          <target state="translated">их целью является установка rafSupported в true или false в зависимости от наличия функции в requestAnimationFrame</target>
        </trans-unit>
        <trans-unit id="7b247e535f27451042dc1de383c546cfcbe520d6" translate="yes" xml:space="preserve">
          <source>will BOTH return true, as expected.</source>
          <target state="translated">вернется,как и ожидалось.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
