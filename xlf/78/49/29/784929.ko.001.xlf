<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/784929">
    <body>
      <group id="784929">
        <trans-unit id="9d8ee90d447e634111f086fe5d63063e02604c04" translate="yes" xml:space="preserve">
          <source>! is &quot;boolean not&quot;, which essentially typecasts the value of &quot;enable&quot; to its boolean opposite. The second ! flips this value. So, &lt;code&gt;!!enable&lt;/code&gt; means &quot;not not enable,&quot; giving you the value of &lt;code&gt;enable&lt;/code&gt; as a boolean.</source>
          <target state="translated">! &quot;boolean not&quot;은 기본적으로 &quot;enable&quot;값을 부울 반대쪽으로 타입 캐스트합니다. 두번째 ! 이 값을 뒤집습니다. 따라서 &lt;code&gt;!!enable&lt;/code&gt; 은 &quot; 활성화 하지 않음&quot;을 의미하며 enable의 값을 부울로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1267640ee6e890d8ceb635273042d73661945ffd" translate="yes" xml:space="preserve">
          <source>(please read code descriptions)</source>
          <target state="translated">(코드 설명을 읽으십시오)</target>
        </trans-unit>
        <trans-unit id="dbc5329443fc97ea79e3d6fc7a7c08bb400f6cdb" translate="yes" xml:space="preserve">
          <source>... you might be surprised to see React render a &lt;code&gt;0&lt;/code&gt; when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns &lt;code&gt;0&lt;/code&gt;, which JSX happily renders, as it should. It can't tell you didn't have &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (or something less contrived).</source>
          <target state="translated">... 메시지가 없을 때 React가 &lt;code&gt;0&lt;/code&gt; 을 렌더링하는 것을보고 놀랄 수도 있습니다. JSX가 렌더링되지 않도록하려면 명시 적으로 false를 반환해야합니다. 위의 명령문은 &lt;code&gt;0&lt;/code&gt; 을 반환하며, JSX는 정상적으로 렌더링됩니다. &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (또는 덜 고안된 것)이 없다는 것을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4b43c7ba8236eeadfe785d67215c403a6e6e119" translate="yes" xml:space="preserve">
          <source>...will NOT result in a true condition, and the code block will not be executed, even if the element does exist.</source>
          <target state="translated">... 실제 상태가 아니며 요소가 존재하더라도 코드 블록이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd18c0553a45634b99d4953abd9dd07bb59545b2" translate="yes" xml:space="preserve">
          <source>3rd party libraries that expect explicit Boolean values</source>
          <target state="translated">명시 적 부울 값이 필요한 타사 라이브러리</target>
        </trans-unit>
        <trans-unit id="05317c9a3565f977ff95a0b1172dd228b7234929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!0 === false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!!0 === false&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b16fdc2b982571586ffd6bc3139aa446dfb0262b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; converts the value to the right of it to its equivalent boolean value. (Think poor man's way of &quot;type-casting&quot;). Its &lt;em&gt;intent&lt;/em&gt; is usually to convey to the reader that the code does not care &lt;em&gt;what&lt;/em&gt; value is in the variable, but what it's &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&quot;truth&quot; value&lt;/a&gt; is.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 오른쪽의 값을 동등한 부울 값으로 변환합니다. (가난한 사람의 &quot;유형 캐스팅&quot;방식을 생각하십시오). 그 &lt;em&gt;의도&lt;/em&gt; 는 일반적으로 코드가 변수에있는 값이 아니라 &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&quot;진실&quot;값에&lt;/a&gt; 관심이 있다는 것을 독자에게 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="de68e033596cd4f5d22f42c9c74a29c3813083dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; is not an operator. It is the double-use of &lt;code&gt;!&lt;/code&gt; -- which is the logical &quot;not&quot; operator.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 연산자가 아닙니다. &lt;code&gt;!&lt;/code&gt; 의 이중 사용입니다 -논리적 인 &quot;not&quot;연산자입니다.</target>
        </trans-unit>
        <trans-unit id="0c49aab7f0deeecf7c139cada81e75156b64a3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; it's using &lt;code&gt;NOT&lt;/code&gt; operation twice together, &lt;code&gt;!&lt;/code&gt; convert the value to a &lt;code&gt;boolean&lt;/code&gt; and reverse it, here is a simple example to see how &lt;code&gt;!!&lt;/code&gt; works:</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; &lt;code&gt;NOT&lt;/code&gt; 연산을 두 번 함께 사용하고 있습니다 &lt;code&gt;!&lt;/code&gt; 값을 &lt;code&gt;boolean&lt;/code&gt; 로 변환하고 반대로 변환하는 방법은 다음과 같습니다 &lt;code&gt;!!&lt;/code&gt; 공장:</target>
        </trans-unit>
        <trans-unit id="40472ff2de807d44da0389b6ed6c479fe97e450d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!expr&lt;/code&gt; returns a Boolean value (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) depending on the &lt;em&gt;truthiness&lt;/em&gt; of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:</source>
          <target state="translated">&lt;code&gt;!!expr&lt;/code&gt; 은 식의 &lt;em&gt;진실성&lt;/em&gt; 에 따라 부울 값 ( &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )을 반환합니다. 부울이 아닌 유형에 사용될 때 더 의미가 있습니다. 다음 예, 특히 세 번째 예 이상을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c11c8b2ce2578dcc578b1ef73f483f4da8bddb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!foo&lt;/code&gt; applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus &lt;code&gt;+foo&lt;/code&gt; to cast to number and concatenating an empty string &lt;code&gt;''+foo&lt;/code&gt; to cast to string.</source>
          <target state="translated">&lt;code&gt;!!foo&lt;/code&gt; 는 단항 not 연산자를 두 번 적용하며, 단항 더하기 &lt;code&gt;+foo&lt;/code&gt; 를 사용하여 숫자로 캐스트하고 빈 문자열 &lt;code&gt;''+foo&lt;/code&gt; 를 연결하여 문자열로 캐스트하는 것과 유사한 부울 유형으로 캐스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3fbcf80055d72c6902769ea1b0b209d18d54c31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; is &lt;code&gt;!!0 === !!undefined&lt;/code&gt; and is true! Same truthiness! (In this case, both &quot;have a truthiness of falsy&quot;.)</source>
          <target state="translated">&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; 는 &lt;code&gt;!!0 === !!undefined&lt;/code&gt; 으며 사실입니다! 같은 진실성! (이 경우, 둘 다 &quot;거짓의 진실성을가집니다&quot;.</target>
        </trans-unit>
        <trans-unit id="d3afe30734c2565c10167b232d767321261e858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!x&lt;/code&gt; is shorthand for &lt;code&gt;Boolean(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!!x&lt;/code&gt; 는 &lt;code&gt;Boolean(x)&lt;/code&gt; 약자입니다.</target>
        </trans-unit>
        <trans-unit id="721b932e6bc1cc17c9cd50fea7dc4b8b7a6ad668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is &lt;em&gt;NOT&lt;/em&gt;.  So &lt;code&gt;!true&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;!0&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!1&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; &lt;em&gt;아닙니다&lt;/em&gt; . 따라서 &lt;code&gt;!true&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 이고 &lt;code&gt;!false&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 입니다. &lt;code&gt;!0&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;!1&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a84f888f6e0a39683c0e570def98bcac6595167f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0 === false&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0 === false&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="601bab0f9b947357bf0bbc8ebc5b625e5e7af331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; is a bitwise AND; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; is a logical AND. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; (a false value); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; 가 비트 AND 인 경우; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; 가 논리 AND 인 경우 &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; (거짓 값)입니다. &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; 는 사실입니다.</target>
        </trans-unit>
        <trans-unit id="fe8e944fda44e395ec8eb52766a2d42b25be5541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a = b)&lt;/code&gt; is assignment followed by use of the truth value of &lt;code&gt;b&lt;/code&gt;; &lt;code&gt;if (a == b)&lt;/code&gt; is an equality comparison.</source>
          <target state="translated">&lt;code&gt;if (a = b)&lt;/code&gt; 가 할당되고 &lt;code&gt;b&lt;/code&gt; 의 진리 값을 사용하는 경우; &lt;code&gt;if (a == b)&lt;/code&gt; 가 동등 비교 인 경우</target>
        </trans-unit>
        <trans-unit id="a4c32abc5c7932aafafe8b72767dd17a9e12923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myVar1 === myVar2&lt;/code&gt; is &lt;code&gt;0 === undefined&lt;/code&gt; and is obviously false.</source>
          <target state="translated">&lt;code&gt;myVar1 === myVar2&lt;/code&gt; 는 &lt;code&gt;0 === undefined&lt;/code&gt; 되어 있지 않으며 분명히 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="7899bf510c8f1081aeced8dc9e82c3717d6f3a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is &lt;em&gt;not&lt;/em&gt; not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!!&lt;/code&gt; &lt;/strong&gt; 값이 &lt;em&gt;아닌&lt;/em&gt; 것에 대한 &quot;진실&quot;을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="05ffd1c973d25f3fa642c01bde2e2d7437ff0b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!&lt;/code&gt; &lt;/strong&gt; 값이 아닌 &quot;진실&quot;을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6d9ad97a5f3ee3fba703f038b8cb73c50bd30761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brew some tea:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;차를 끓이십시오 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80a5baf090dcfffcd4153848ee43b313dff5f952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But wait, there's more!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그러나 더 많은 것이 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3574ce92cb57aeb1f7ff451de1bbe4886856bb60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 24 Oct 2017, 6 Feb 19:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2017 년 10 월 24 일, 2 월 19 일 편집 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a055a42c402ff7009188d3b50ace76756b7075b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실제로:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36ed1544d47aa0950bc63b80406386d69ec830fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In theory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이론에 의하면:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a17136c4cff424debad877c2ecfe86e4318d16b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S.&lt;/strong&gt; Another way of doing the same thing is &lt;code&gt;(b || {}).foo&lt;/code&gt;, because if b is undefined then &lt;code&gt;b || {}&lt;/code&gt; will be &lt;code&gt;{}&lt;/code&gt;, and you'll be accessing a value in an empty object (no error) instead of trying to access a value within &quot;undefined&quot; (causes an error).  So, &lt;code&gt;(b || {}).foo&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; and &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;추신 :&lt;/strong&gt; 같은 일을하는 또 다른 방법은 &lt;code&gt;(b || {}).foo&lt;/code&gt; 입니다 . 왜냐하면 b가 정의되지 않으면 &lt;code&gt;b || {}&lt;/code&gt; {} 은 &lt;code&gt;{}&lt;/code&gt; 이고 &quot;정의되지 않은&quot;값에 액세스하려고 시도하는 대신 오류가없는 빈 객체의 값에 액세스합니다 (오류 없음). 따라서 &lt;code&gt;(b || {}).foo&lt;/code&gt; 는 &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; 와 같고 &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; 는 &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8f384febfdd7d7361b695f817e89853b5220d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We digress...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;우린 ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="022b17591a08c04d294c7aa2b97cef1c499d1b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;it means !true= false&lt;br/&gt;
 and  !!true = true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그것은! true = false를 의미합니다&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt; &lt;strong&gt;그리고 !! true = true&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4626b6d0fd1defd823f8f27a6ee0096c94607fb" translate="yes" xml:space="preserve">
          <source>A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; performs a logical AND (true if both sides are true), and &lt;code&gt;a &amp;amp; b&lt;/code&gt; performs a bitwise AND. &lt;code&gt;a || b&lt;/code&gt; performs a logical OR (true if at least one are true), and &lt;code&gt;a | b&lt;/code&gt; performs a bitwise OR. There's a bitwise XOR (exclusive OR) as &lt;code&gt;a ^ b&lt;/code&gt;, but there's no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: &lt;code&gt;!!x !== !!y&lt;/code&gt;.</source>
          <target state="translated">세 번째 용도는 논리 XOR 및 논리 XNOR을 생성하는 것입니다. C와 JavaScript에서 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 는 논리 AND를 수행하고 (양쪽이 모두 true이면 true) &lt;code&gt;a &amp;amp; b&lt;/code&gt; 는 비트 AND를 수행합니다. &lt;code&gt;a || b&lt;/code&gt; b 는 논리 OR을 수행하고 (적어도 하나이면 true) &lt;code&gt;a | b&lt;/code&gt; b 는 비트 단위 OR을 수행합니다. 비트 xOR (배타적 OR)은 &lt;code&gt;a ^ b&lt;/code&gt; 이지만 논리 XOR에 대한 기본 제공 연산자는 없습니다 (정확히 한면이면 true). 예를 들어, 사용자가 정확히 두 필드 중 하나에 텍스트를 입력하도록 할 수 있습니다. 당신이 할 수있는 일은 각각을 진리 값으로 변환하고 비교합니다 : &lt;code&gt;!!x !== !!y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="937148e0ba3cf2e3a6ad662dce342d4574705192" translate="yes" xml:space="preserve">
          <source>After seeing all these great answers, I would like to add another reason for using  &lt;code&gt;!!&lt;/code&gt;. Currenty I'm working in Angular 2-4 (TypeScript) and I want to return a boolean as &lt;code&gt;false&lt;/code&gt; when my user is not authenticated. If he isn't authenticated, the token-string would be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;. I can do this by using the next block of code:</source>
          <target state="translated">이 위대한 답변을 모두 본 후에는을 사용하는 또 다른 이유를 추가하고 싶습니다 &lt;code&gt;!!&lt;/code&gt; . 현재 Angular 2-4 (TypeScript)에서 일하고 있으며 사용자가 인증되지 않은 경우 부울을 &lt;code&gt;false&lt;/code&gt; 로 반환하려고합니다. 인증되지 않은 경우 token-string은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 입니다. 다음 코드 블록을 사용하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719bb016bfb2ea5208e53cc2ef5f67a057166604" translate="yes" xml:space="preserve">
          <source>And things get even crazier depending on your engine. WScript, for instance, wins the prize.</source>
          <target state="translated">그리고 엔진에 따라 상황이 훨씬 더 어려워집니다. 예를 들어 WScript가 상을 수상합니다.</target>
        </trans-unit>
        <trans-unit id="d2e6426f3b2e591c60f6c55c2d312ca4857318d9" translate="yes" xml:space="preserve">
          <source>Another use, which I mentioned in an &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;answer about C's corresponding &lt;code&gt;!!&lt;/code&gt; operator&lt;/a&gt;, is with &quot;lint&quot; tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn't quite as Boolean:</source>
          <target state="translated">또 다른 용도 &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;는 C에 해당&lt;/a&gt; 하는 답변 에서 언급했습니다 &lt;code&gt;!!&lt;/code&gt; operator 는 일반적인 오타 및 인쇄 진단을 찾는 &quot;보풀이없는&quot;도구입니다. 예를 들어, C와 JavaScript 모두에서 부울 연산에 대한 몇 가지 일반적인 오타는 출력이 부울이 아닌 다른 동작을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5d7e80841153e3f0b33aa705ecbcdee928b5ed77" translate="yes" xml:space="preserve">
          <source>At first, the place you have:</source>
          <target state="translated">처음에는 다음과 같은 장소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37383f3a991b3aaf3607d0d306ed294c9e3535ec" translate="yes" xml:space="preserve">
          <source>Basically, &lt;code&gt;!!&lt;/code&gt; make us sure, the value we get is boolean, not falsy, truthy or string etc...</source>
          <target state="translated">기본적으로 &lt;code&gt;!!&lt;/code&gt; 우리가 얻는 가치는 거짓, 진실 또는 문자열 등이 아닌 부울입니다.</target>
        </trans-unit>
        <trans-unit id="f0db7bebe15c805ab3aec2ff3047007e131c1547" translate="yes" xml:space="preserve">
          <source>Because javascript has what are called &quot;truthy&quot; and &quot;falsey&quot; values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Javascript에는 &quot;truthy&quot;및 &quot;falsey&quot;값이 있으므로 검사중인 값 또는 표현식이 실제로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 가 아닌 경우에도 다른 표현식에서 평가할 때 true 또는 false 조건이되는 표현식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebcd804c817f36ef59a932affdb9a970bbb27d1b" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;some historical Windows jive&lt;/a&gt;, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; still gives you 0, or WScript's &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Look away. It's hideous.&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;역사적인 Windows jive&lt;/a&gt; 때문에 메시지 상자에 -1이 출력됩니다! cmd.exe 프롬프트에서 사용해보십시오! 그러나 &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; 여전히 0 또는 WScript의 &lt;code&gt;false&lt;/code&gt; 를 제공 합니다. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;멀리 봐&lt;/a&gt; 끔찍 해요</target>
        </trans-unit>
        <trans-unit id="34a3c4d1b09c4c334e45f565ff959b93e1297ce9" translate="yes" xml:space="preserve">
          <source>But if you &amp;rArr;</source>
          <target state="translated">하지만 &amp;rArr;</target>
        </trans-unit>
        <trans-unit id="55af43b97047e9feca9827254a5bad346b4fb1ea" translate="yes" xml:space="preserve">
          <source>But if you see strange &lt;code&gt;0&lt;/code&gt;s in your rendered JSX, think loose falsy management.</source>
          <target state="translated">그러나 렌더링 된 JSX에 이상한 &lt;code&gt;0&lt;/code&gt; 이 표시되면 허위 관리를 느슨하게 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="c3d9638bccd08789c5c96539764af9bdb9abbc4d" translate="yes" xml:space="preserve">
          <source>But this can be an issue when something is undefined.</source>
          <target state="translated">그러나 이것은 정의되지 않은 경우 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc510cf59a92c328aac077d7719d62aac7a4811c" translate="yes" xml:space="preserve">
          <source>But what if I have two values I need to check for equal truthi/falsi-ness?</source>
          <target state="translated">그러나 두 가지 가치가 있다면 동일한 진실성 / 거짓 성을 확인해야합니까?</target>
        </trans-unit>
        <trans-unit id="0a33acba295ef44765fa6e094d5bf1d8422929b7" translate="yes" xml:space="preserve">
          <source>Comparing truthiness :)</source>
          <target state="translated">진실성 비교 :)</target>
        </trans-unit>
        <trans-unit id="c26332ba114f738a9008487cc2e7e1224052ab38" translate="yes" xml:space="preserve">
          <source>Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;dynamic typing&lt;/a&gt;&lt;/strong&gt; (aka &quot;duck typing&quot;). We want to write a function that returns &lt;code&gt;true&lt;/code&gt; if a user's browser supports the HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; element, but we don't want the function to throw an error if &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is undefined; and we don't want to use &lt;code&gt;try ... catch&lt;/code&gt; to handle any possible errors (because they're gross); &lt;em&gt;and also&lt;/em&gt; we don't want to use a check inside the function that won't consistently reveal the truth about the feature (for example, &lt;code&gt;document.createElement('audio')&lt;/code&gt; will still create an element called &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; even if HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is not supported).</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;동적 타이핑&lt;/a&gt;&lt;/strong&gt; (일명 &quot;덕 타이핑&quot;)을 통해 기능 기능 (이 경우 플랫폼 호환성)을 감지하는 간결한 기능을 고려하십시오. 사용자 브라우저가 HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 요소를 지원하는 경우 &lt;code&gt;true&lt;/code&gt; 를 반환하는 함수를 작성하려고하지만 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 가 정의되지 않은 경우 함수가 오류를 발생시키지 않도록합니다. 그리고 우리는 &lt;code&gt;try ... catch&lt;/code&gt; 를 사용하고 싶지 않습니다. 가능한 오류를 처리하기 위해 catch하십시오 (매우 심각하기 때문에). &lt;em&gt;또한&lt;/em&gt; 기능에 대한 진실을 일관되게 밝히지 않는 함수 내부에서 확인을 사용하고 싶지 않습니다 (예 : &lt;code&gt;document.createElement('audio')&lt;/code&gt; 는 HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 는 지원되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9c2bfed607f580ac4ac34ab9f08a0c6aa7cb0429" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Object&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;. If it was falsey (e.g. &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, etc.), it will be &lt;code&gt;false&lt;/code&gt;, otherwise, &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 를 &lt;code&gt;boolean&lt;/code&gt; 으로 변환합니다. false이면 (예 : &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 등) &lt;code&gt;false&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7af2387329e42b1e1dcdbdc75737b43eb16b3b56" translate="yes" xml:space="preserve">
          <source>Double boolean negation. Often used to check if value is not undefined.</source>
          <target state="translated">이중 부울 부정. 값이 정의되지 않았는지 확인하는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1378886488bff47eea733f621e4e6b0a3b97b140" translate="yes" xml:space="preserve">
          <source>Each function accepts an argument for a &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; and an &lt;code&gt;attribute&lt;/code&gt; to look for, but they each return different values based on what the comparisons determine.</source>
          <target state="translated">각 함수는 &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; 에 대한 인수와 찾을 &lt;code&gt;attribute&lt;/code&gt; 을 허용하지만 비교가 결정한 내용에 따라 서로 다른 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e86b051c400fed4e8f797a656375e775595e029" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; and &lt;code&gt;!!0 === false&lt;/code&gt;.</source>
          <target state="translated">예를 들면 : &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; 및 &lt;code&gt;!!0 === false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0da32197e1f2c3ed9016c076548a9c1dc68c0878" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False in JSX (React) has a special meaning&lt;/a&gt; that's not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in &lt;code&gt;messageCount&lt;/code&gt;...</source>
          <target state="translated">예를 들어, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;JSX의 False (React)는&lt;/a&gt; 단순한 허위로 유발되지 않는 특별한 의미 를 갖습니다. JSX에서 다음과 같은 것을 반환하려고 시도하면 &lt;code&gt;messageCount&lt;/code&gt; 에 int가 있어야합니다 ...</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="eaa9bb432088641bac3a4242e7ee096bd6cecd11" translate="yes" xml:space="preserve">
          <source>Here are the three approaches:</source>
          <target state="translated">세 가지 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f64e010c295a2870b0f4d659e488a6c517e64044" translate="yes" xml:space="preserve">
          <source>Here's an interesting case... &lt;code&gt;!!&lt;/code&gt; might be useful when 3rd party libs expect explicit Boolean values.</source>
          <target state="translated">흥미로운 사례가 있습니다 ... &lt;code&gt;!!&lt;/code&gt; 타사 라이브러리에 명시적인 부울 값이 필요한 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dcc317e1dd0008af8179d1f9a0f92f72220ebe0" translate="yes" xml:space="preserve">
          <source>However it has several practical uses.</source>
          <target state="translated">그러나 몇 가지 실용적인 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73892b42e6ec2099f18c789a4ca27320607324a" translate="yes" xml:space="preserve">
          <source>However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting &lt;code&gt;true&lt;/code&gt; from a non-boolean, possibly undefined value is indeed by using &lt;code&gt;!!&lt;/code&gt;. Hopefully this ridiculously clears it up.</source>
          <target state="translated">그러나 이러한 상황은 드물지만, 부울하지 않고 정의되지 않은 값에서 &lt;code&gt;true&lt;/code&gt; 을 얻는 가장 간결한 방법이 실제로는 &lt;code&gt;!!&lt;/code&gt; . 잘하면 이것은 말도 안되게 정리합니다.</target>
        </trans-unit>
        <trans-unit id="4f858245f3d281e55c31873b62aa68516b0b67f3" translate="yes" xml:space="preserve">
          <source>However:</source>
          <target state="translated">However:</target>
        </trans-unit>
        <trans-unit id="e75de3aca85245f9741f3ed73aba2405a0e6cfcd" translate="yes" xml:space="preserve">
          <source>I can't think of a great, non-contrived use case for that offhand. Maybe you have &quot;linked&quot; fields in a form?</source>
          <target state="translated">나는 그 미손에 대한 유인되지 않은 훌륭한 유스 케이스를 생각할 수 없다. 양식에 &quot;연결된&quot;필드가 있습니까?</target>
        </trans-unit>
        <trans-unit id="bd129d49875f1c7bf2d6c56ffa1cefd1aa871386" translate="yes" xml:space="preserve">
          <source>I just wanted to add that</source>
          <target state="translated">나는 단지 그것을 추가하고 싶었다</target>
        </trans-unit>
        <trans-unit id="227f3285ec3ec43c9acc1d6e328c5b2a5034b7af" translate="yes" xml:space="preserve">
          <source>I saw some code that seems to use an operator I don't recognize, in the form of two exclamation points, like so: &lt;code&gt;!!&lt;/code&gt;. Can someone please tell me what this operator does?</source>
          <target state="translated">인식하지 못하는 연산자를 사용하는 것으로 보이는 일부 코드는 다음과 같이 두 개의 느낌표 형태로 나타납니다. &lt;code&gt;!!&lt;/code&gt; . 누군가이 연산자가 무엇을하는지 말해 줄 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0ab6442ad8b0b1090c870a59a8d71ba43701e2c7" translate="yes" xml:space="preserve">
          <source>I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.</source>
          <target state="translated">사람들이!를 재정의하는 C ++에서 남은 것으로 생각됩니다. 부울 연산자가 아닌 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="003e87252c9f7ec44808278e2171c30bbf27960f" translate="yes" xml:space="preserve">
          <source>I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of &amp;amp;&amp;amp; and 
first success or last fail in case of || of condition chain.</source>
          <target state="translated">논리적 AND / OR과 결합 된 조건은 부울 값을 반환하지 않지만 &amp;amp;&amp;amp; 및 첫 번째 성공 또는 ||의 경우 마지막 실패 또는 || 조건 체인의.</target>
        </trans-unit>
        <trans-unit id="d802fb28a6d04b4cc61b6721bff2527b6ab50f8a" translate="yes" xml:space="preserve">
          <source>I'm more comfortable handling falsiness myself with a ternary --</source>
          <target state="translated">나는 삼항으로 자신을 조작하는 것이 더 편합니다.</target>
        </trans-unit>
        <trans-unit id="f605cfe8b7167fb9c1edb800b4a71aae4fe2edfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a false value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 false 값이면 &lt;code&gt;!x&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;!!x&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e2542885728d534e0cbf50ded3d8082dbb4bc2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a true value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 true 값이면 &lt;code&gt;!x&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 이고 &lt;code&gt;!!x&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24f97de69477863bf6708059e17ad9778d8a9cc3" translate="yes" xml:space="preserve">
          <source>If that element does in fact exist, the expression will evaluate as true, and the code block will be executed.</source>
          <target state="translated">해당 요소가 실제로 존재하면 표현식은 true로 평가되고 코드 블록이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="442b7a39eb1de6839bcbf2cca353f71f520acfac" translate="yes" xml:space="preserve">
          <source>If you &amp;rArr;</source>
          <target state="translated">당신이 &amp;rArr;</target>
        </trans-unit>
        <trans-unit id="5075badbf5e88b6b0caa8ef134b856caccd05702" translate="yes" xml:space="preserve">
          <source>If you only care that a value is truthy or falsy, then use the short form. Instead of</source>
          <target state="translated">값이 진실하거나 허위임을 신경 쓰면 짧은 형식을 사용하십시오. 대신에</target>
        </trans-unit>
        <trans-unit id="25c0c498a0bdb8446495ca30bd5369fa1fe77b30" translate="yes" xml:space="preserve">
          <source>In order to cast the condition to a true boolean literal we can use the double negation:</source>
          <target state="translated">조건을 실제 부울 리터럴로 캐스트하기 위해 이중 부정을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d94b2b8672da34c8a43dd1c8cbce124ec9f02e37" translate="yes" xml:space="preserve">
          <source>Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (&lt;em&gt;without&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;) to explicitly cast values, ie</source>
          <target state="translated">이러한 핵 대신에 기본 유형에 해당하는 생성자 함수 &lt;em&gt;를&lt;/em&gt; 사용하여 ( &lt;code&gt;new&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 사용 &lt;em&gt;하지 않고&lt;/em&gt; ) 명시 적으로 값을 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef8ebd812b149cf4ca6384ab75bf685b7c51d444" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;Boolean&lt;/code&gt; class can be used.</source>
          <target state="translated">대신 &lt;code&gt;Boolean&lt;/code&gt; 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd5f0f08c8b69e561341c016a5178bbabfab99f4" translate="yes" xml:space="preserve">
          <source>It converts the suffix to a Boolean value.</source>
          <target state="translated">접미사를 부울 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="04f0b660a5f5fd40c699d9299636f12196d971ce" translate="yes" xml:space="preserve">
          <source>It forces all things to boolean.</source>
          <target state="translated">그것은 모든 것을 부울로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="362012587fedf1f206a41069ff29470d4bcc9b9f" translate="yes" xml:space="preserve">
          <source>It seems that the &lt;code&gt;!!&lt;/code&gt; operator results in a double negation.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 연산자는 이중 부정을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="d12e704c471bd7b5f2ef621231182892cdbce3ce" translate="yes" xml:space="preserve">
          <source>It simulates the behavior of the &lt;code&gt;Boolean()&lt;/code&gt; casting function.
The first &lt;code&gt;NOT&lt;/code&gt; returns a Boolean value no matter what operand it is given. The second &lt;code&gt;NOT&lt;/code&gt; negates that &lt;code&gt;Boolean&lt;/code&gt; value and so gives the &lt;code&gt;true&lt;/code&gt; Boolean value of a variable. The end result is the same as using the &lt;code&gt;Boolean()&lt;/code&gt; function on a value.</source>
          <target state="translated">&lt;code&gt;Boolean()&lt;/code&gt; 캐스팅 함수의 동작을 시뮬레이션합니다. 첫 번째 &lt;code&gt;NOT&lt;/code&gt; 은 어떤 피연산자에 관계없이 부울 값을 반환합니다. 두 번째 &lt;code&gt;NOT&lt;/code&gt; 은 해당 &lt;code&gt;Boolean&lt;/code&gt; 값을 무효화하므로 변수의 &lt;code&gt;true&lt;/code&gt; 부울 값을 제공합니다. 최종 결과는 값에 &lt;code&gt;Boolean()&lt;/code&gt; 함수를 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b34f307bed6829df645edce297716e7d66021503" translate="yes" xml:space="preserve">
          <source>It's a double &lt;code&gt;not&lt;/code&gt; operation.  The first &lt;code&gt;!&lt;/code&gt; converts the value to boolean and inverts its logical value.  The second &lt;code&gt;!&lt;/code&gt; inverts the logical value back.</source>
          <target state="translated">이중이 &lt;code&gt;not&lt;/code&gt; 조작입니다. 첫 &lt;code&gt;!&lt;/code&gt; 값을 부울로 변환하고 논리 값을 반전시킵니다. 두 번째 &lt;code&gt;!&lt;/code&gt; 논리 값을 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="c63e6ec5ccb83901a441e96930f2594861a2a402" translate="yes" xml:space="preserve">
          <source>It's a horribly obscure way to do a type conversion.</source>
          <target state="translated">형식 변환을 수행하는 끔찍한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a0bfc03fee00b0a95a35794ff4b18bfb284ed3d7" translate="yes" xml:space="preserve">
          <source>It's just the logical NOT operator, twice - it's used to convert something to boolean, e.g.:</source>
          <target state="translated">논리적 NOT 연산자이며 두 번-무언가를 부울로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54382507df0f3d9ecbfe0a329a53e74bef4a1834" translate="yes" xml:space="preserve">
          <source>It's not a single operator, it's two.  It's equivalent to the following and is a quick way to cast a value to boolean.</source>
          <target state="translated">단일 연산자가 아니며 두 개입니다. 다음과 동일하며 값을 부울로 캐스팅하는 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7f323048105e7d3908de65a905d0ecb9e7cccddb" translate="yes" xml:space="preserve">
          <source>JSX' docs suggest you be more explicit, write self-commenting code, and use a comparison to force to a Boolean.</source>
          <target state="translated">JSX의 문서는 더 명확하고 자체 주석 코드를 작성하며 비교를 사용하여 부울로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="857f728eac2339b6a141ba1d44e27519c2166bbc" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;strong&gt;these &lt;em&gt;are JSX &amp;amp; Typescript conventions&lt;/em&gt;, not ones inherent to JavaScript&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;이것은&lt;/em&gt; JavaScript 고유의 &lt;em&gt;규칙이 아니라 JSX &amp;amp; Typescript 규칙&lt;/em&gt;&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="558b0b10df23ff62727f0cdf06a369839b8ba0b0" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; in use.</source>
          <target state="translated">즉, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; 가 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="71a6705b7fa3ec15cdb9c15f74c0a2866a4f8b3e" translate="yes" xml:space="preserve">
          <source>Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.</source>
          <target state="translated">당연히 이것들은 단순히 !! someThing을 입력하는 것과 동일하지만 추가 된 괄호는 더 이해하기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="062b9d1606d85c2c91b697df5b29f343f34bfd4f" translate="yes" xml:space="preserve">
          <source>Note that there are some &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;unintuitive cases&lt;/a&gt; where a boolean will be cast to a number (&lt;code&gt;true&lt;/code&gt; is cast to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;) when comparing a boolean to a number. In this case, &lt;code&gt;!!&lt;/code&gt; might be mentally useful. Though, again, &lt;strong&gt;these are cases where you're comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake.&lt;/strong&gt;&lt;code&gt;if (-1)&lt;/code&gt; is still the way to go here.</source>
          <target state="translated">부울을 숫자와 비교할 때 부울이 숫자로 캐스트되는 (직접은 &lt;code&gt;1&lt;/code&gt; 로 캐스트되고 &lt;code&gt;false&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 으로 ) &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;직관적이지 않은 경우&lt;/a&gt; 가 있습니다. 이 경우 &lt;code&gt;!!&lt;/code&gt; 정신적으로 유용 할 수 있습니다. 다시, &lt;strong&gt;이것은 부울이 아닌 것을 하드 타입의 부울과 비교하는 경우입니다.&lt;/strong&gt; &lt;code&gt;if (-1)&lt;/code&gt; 이 여전히 여기로가는 길이라면</target>
        </trans-unit>
        <trans-unit id="57d186fffc848f3760d873fa6a5efef0c4b69fd9" translate="yes" xml:space="preserve">
          <source>One fix involves the bangbang, which coerces &lt;code&gt;0&lt;/code&gt; into &lt;code&gt;!!0&lt;/code&gt;, which is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">하나의 수정은 bangbang과 관련되어 있으며, &lt;code&gt;0&lt;/code&gt; 은 &lt;code&gt;!!0&lt;/code&gt; 으로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6f54cbcb01cbe0a3333b72e4ff3a962a0f801e" translate="yes" xml:space="preserve">
          <source>One use is to lossily compress an object to its truth value, so that your code isn't holding a reference to a big object and keeping it alive. Assigning &lt;code&gt;!!some_big_object&lt;/code&gt; to a variable instead of &lt;code&gt;some_big_object&lt;/code&gt; lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as &lt;code&gt;null&lt;/code&gt; or the undefined value, such as browser feature detection.</source>
          <target state="translated">한 가지 용도는 객체를 실제 값으로 손실 압축하여 코드가 큰 객체에 대한 참조를 보유하지 않고 살아있는 상태로 유지하는 것입니다. &lt;code&gt;!!some_big_object&lt;/code&gt; 대신 !! some_big_object 를 변수에 할당하면 가비지 수집기에서 변수를 &lt;code&gt;some_big_object&lt;/code&gt; 할 수 있습니다. 이는 개체 또는 &lt;code&gt;null&lt;/code&gt; 과 같은 false 값 또는 브라우저 기능 감지와 같은 정의되지 않은 값을 생성하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="161e7eb8bec71d838abd41540cca030c08d6f7f6" translate="yes" xml:space="preserve">
          <source>Please check code snippet out below &lt;strong&gt;&amp;darr;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;darr;&lt;/strong&gt; 아래의 코드 스 니펫을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a9c634cfd1a38a3aa345e046738679df22d80362" translate="yes" xml:space="preserve">
          <source>Practical uses</source>
          <target state="translated">실용</target>
        </trans-unit>
        <trans-unit id="114da967498be8e2c2cdf7df8db42e88ebd380c7" translate="yes" xml:space="preserve">
          <source>Pretend we have &lt;code&gt;myVar1 = 0;&lt;/code&gt; and &lt;code&gt;myVar2 = undefined;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;myVar1 = 0;&lt;/code&gt; 척합니다 . 및 &lt;code&gt;myVar2 = undefined;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f2915a66e774b1c83f8a2a3e89284ac648434e" translate="yes" xml:space="preserve">
          <source>Real World Example &quot;Test IE version&quot;:</source>
          <target state="translated">실제 예제 &quot;Test IE version&quot;:</target>
        </trans-unit>
        <trans-unit id="b39d3fef53ba3ed826f8428d58a2371af89a4e7d" translate="yes" xml:space="preserve">
          <source>Returns boolean value of a variable.</source>
          <target state="translated">변수의 부울 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc98ae78ccf4552e39bcf193255cd5a8ae570858" translate="yes" xml:space="preserve">
          <source>Same deal in Typescript: If you have a function that returns a boolean (or you're assigning a value to a boolean variable), you [usually] can't return/assign a boolean-y value; it has to be a strongly typed boolean. This means, &lt;strong&gt;iff &lt;code&gt;myObject&lt;/code&gt; is strongly typed&lt;/strong&gt;, &lt;code&gt;return !myObject;&lt;/code&gt; works for a function returning a boolean, but &lt;code&gt;return myObject;&lt;/code&gt; doesn't. You have to &lt;code&gt;return !!myObject&lt;/code&gt; to match Typescript's expectations.</source>
          <target state="translated">Typescript와 같은 거래 : 불리언을 반환하는 함수가 있거나 불리언 변수에 값을 할당하는 경우, 일반적으로 불리언 y 값을 반환 / 할당 할 수 없습니다. 강력하게 형식화 된 부울이어야합니다. 즉, &lt;strong&gt; &lt;code&gt;myObject&lt;/code&gt; 가 강력하게 입력&lt;/strong&gt; 되면 &lt;code&gt;return !myObject;&lt;/code&gt; 부울을 반환하는 함수에서 작동하지만 &lt;code&gt;return myObject;&lt;/code&gt; 하지 않습니다. Typescript의 기대치에 맞게 &lt;code&gt;return !!myObject&lt;/code&gt; 를 반환 해야합니다.</target>
        </trans-unit>
        <trans-unit id="03d3dfc9a836826357b793d282380cd7f94081b6" translate="yes" xml:space="preserve">
          <source>See &quot;== and !=&quot; from &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint's directions&lt;/a&gt; (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:</source>
          <target state="translated">&lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint의 지시에 따라&lt;/a&gt; &quot;== 및! =&quot;를 참조하십시오 (참고 : Crockford가 약간의 사이트를 이동하고 있습니다. 해당 링크는 어느 시점에서 죽기 쉽습니다).</target>
        </trans-unit>
        <trans-unit id="b77b945dc1e2fb58fae032d74373f3a357e30b37" translate="yes" xml:space="preserve">
          <source>Simply casting :(</source>
          <target state="translated">단순히 캐스팅 :(</target>
        </trans-unit>
        <trans-unit id="6a0157727338f2b7b3fe3318d34c2684d92b3ba2" translate="yes" xml:space="preserve">
          <source>So  it's like using &lt;code&gt;Boolean&lt;/code&gt; function in javascript, but easy and shorter way to convert a value to boolean:</source>
          <target state="translated">따라서 자바 스크립트에서 &lt;code&gt;Boolean&lt;/code&gt; 함수를 사용하는 것과 같지만 값을 부울로 변환하는 쉽고 짧은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c4992f9e1d0a43038d9ca1117fe08701149b40b0" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;!!&lt;/code&gt; is not an operator, it's just the &lt;code&gt;!&lt;/code&gt; operator twice.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 연산자가 아니라 단지 &lt;code&gt;!&lt;/code&gt; 연산자 두 번.</target>
        </trans-unit>
        <trans-unit id="0addbe39410a730dff513bf6537d8856157b56c9" translate="yes" xml:space="preserve">
          <source>So many answers doing half the work. Yes, &lt;code&gt;!!X&lt;/code&gt; could be read as &quot;the truthiness of X [represented as a boolean]&quot;. But &lt;code&gt;!!&lt;/code&gt; isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. &lt;code&gt;!!myVar === true&lt;/code&gt; is the same as just &lt;code&gt;myVar&lt;/code&gt;. Comparing &lt;code&gt;!!X&lt;/code&gt; to a &quot;real&quot; boolean isn't really useful.</source>
          <target state="translated">작업의 절반을 수행하는 많은 답변. 예, &lt;code&gt;!!X&lt;/code&gt; 는 &quot;X의 진실성 (부울로 표시됨)&quot;으로 읽을 수 있습니다. 그러나 &lt;code&gt;!!&lt;/code&gt; 실제로 말해서 하나의 변수가 진실인지 거짓인지 파악하는 데 중요하지 않습니다. &lt;code&gt;!!myVar === true&lt;/code&gt; 는 myVar 와 동일합니다. &lt;code&gt;!!X&lt;/code&gt; 를 &quot;실제&quot;부울과 비교하는 것은 실제로 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="014ab2f522034cc3c77ca7c114cbd4670167db8e" translate="yes" xml:space="preserve">
          <source>So now if you have a truthy for both &lt;em&gt;or&lt;/em&gt; a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your &lt;code&gt;errorObjects&lt;/code&gt; collection.</source>
          <target state="translated">따라서 배우자 이름과 나이에 대해 모두 진실 &lt;em&gt;하거나&lt;/em&gt; 허위가 있다면 계속할 수 있습니다. 그렇지 않으면 값이있는 필드 (또는 매우 이른 결혼 생활) 만 있고 &lt;code&gt;errorObjects&lt;/code&gt; 컬렉션에 추가 오류를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="e63cc48d4173484ca47b8b9c48f21169296682e7" translate="yes" xml:space="preserve">
          <source>So the only place you'd really need to use &quot;boolean-cast variables&quot; would be if you had a situation where you're checking if both variables have the &lt;em&gt;same&lt;/em&gt; truthiness, right? That is, &lt;b&gt;use &lt;code&gt;!!&lt;/code&gt; if you need to see if two vars are &lt;em&gt;both truthy or both falsy&lt;/em&gt; (or not), that is, &lt;em&gt;of equal&lt;/em&gt; (or not) &lt;em&gt;truthiness&lt;/em&gt;.&lt;/b&gt;</source>
          <target state="translated">따라서 실제로 &quot;부울 캐스트 변수&quot;를 사용해야하는 유일한 장소는 두 변수가 &lt;em&gt;동일한&lt;/em&gt; 진실성을 갖는지 확인하는 상황이있는 것입니다. 즉, &lt;b&gt;사용 &lt;code&gt;!!&lt;/code&gt; &lt;/b&gt; &lt;b&gt;두 가지 변수가 &lt;em&gt;모두 진실인지 또는 둘 다 거짓인지&lt;/em&gt; (또는 그렇지 않은지), 즉 &lt;em&gt;동등한 지&lt;/em&gt; (또는 &lt;em&gt;진실&lt;/em&gt; 하지 않은지) &lt;em&gt;인지 확인 해야하는 경우&lt;/em&gt; .&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8fc0438c0801780b20fbecd73911dad21ef51b6" translate="yes" xml:space="preserve">
          <source>So to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!.</source>
          <target state="translated">따라서이 경우 부정적인 (또는 긍정적) 대답을 얻으려면 먼저! 연산자는 부울을 가져 오지만 긍정적 인 경우를 확인하려면 !!를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6e23c1f4bfbfa0ccb58b6c59c222898580d75194" translate="yes" xml:space="preserve">
          <source>So you're converting a value to a boolean, then inverting it, then inverting it again.</source>
          <target state="translated">따라서 값을 부울로 변환 한 다음 뒤집은 다음 다시 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="70f19fcd06b0becbaad2b70e1d5cf4e4e3e27fee" translate="yes" xml:space="preserve">
          <source>Some of you probably noticed that in this specific example, one could simply check for a property using the slightly &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;more performant&lt;/a&gt;&lt;/strong&gt; means of checking if the object in question &lt;em&gt;has&lt;/em&gt; a property. There are two ways to do this:</source>
          <target state="translated">여러분 중 일부는이 특정 예에서 문제의 객체에 속성 &lt;em&gt;이&lt;/em&gt; 있는지 확인하는 약간 &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;더 성능이 좋은&lt;/a&gt;&lt;/strong&gt; 방법을 사용하여 속성을 간단히 확인할 수 있음을 알았습니다. 이를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b46f5ed42b9b9e328c2f46362683a228c43e509" translate="yes" xml:space="preserve">
          <source>Some operators in JavaScript perform implicit type conversions, and are sometimes
used for type conversion.</source>
          <target state="translated">JavaScript의 일부 연산자는 암시 적 유형 변환을 수행하며 때로는 유형 변환에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea085d9130b086f1623397b738adcbac23d6d7e9" translate="yes" xml:space="preserve">
          <source>That is...</source>
          <target state="translated">그건...</target>
        </trans-unit>
        <trans-unit id="82fc7d92ba7e869e36f27a18325c4d16d5a80178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; construct is a simple way of turning any JavaScript expression into
its Boolean equivalent.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; construct는 JavaScript 표현식을 불리언으로 바꾸는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="90d1a7ed711f96e90a1182e13fa7e55e0596693e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 연산자는 보푸라기 도구를 사용하여 작성한 내용이 의도 한 내용임을 재확인합니다.이 작업을 수행 한 다음 결과의 진실 된 가치를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="eabc5d96ac71e6f38058420dd87159a58d3314a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements and the &lt;code&gt;?&lt;/code&gt; operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and &lt;code&gt;null&lt;/code&gt; are both false.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;while&lt;/code&gt; 문과 &lt;code&gt;?&lt;/code&gt; 연산자는 진리 값을 사용하여 실행할 코드 분기를 결정합니다. 예를 들어, 0과 NaN 숫자와 빈 문자열은 거짓이지만 다른 숫자와 문자열은 참입니다. 객체는 true이지만 정의되지 않은 값과 &lt;code&gt;null&lt;/code&gt; 은 모두 false입니다.</target>
        </trans-unit>
        <trans-unit id="29d047ae2b1b9b41221cc9a49cebe8c72ef84804" translate="yes" xml:space="preserve">
          <source>The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r\n' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.</source>
          <target state="translated">== 및! = 연산자는 비교하기 전에 강제 변환을 수행합니다. '\ t \ r \ n'== 0이 참이기 때문에 이것은 나쁩니다. 유형 오류를 마스크 할 수 있습니다. JSLint는 ==가 올바르게 사용되고 있는지 확실하게 확인할 수 없으므로 == 및! =를 전혀 사용하지 않고 항상보다 안정적인 === 및! == 연산자를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="19d8f9dad8485f308ad86d92258b4c919e2fb866" translate="yes" xml:space="preserve">
          <source>The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; are both &quot;truthy&quot; and we will continue down the so-called &quot;&amp;amp;&amp;amp; chain&quot; to the next value to the right.</source>
          <target state="translated">위의 정의는 반환되지 않지만 빈 문자열, false, null, 0을 정의하지 않으면 정의되지 않은 값이 반환됩니다. 체인에서 값을 발견하면 곧 &lt;code&gt;[]&lt;/code&gt; 와 &lt;code&gt;{}&lt;/code&gt; 가 &quot;truthy&quot;하고 계속 표시됩니다. 소위 &quot;&amp;amp;&amp;amp; chain&quot;은 오른쪽에있는 다음 값입니다.</target>
        </trans-unit>
        <trans-unit id="b6f0570101450478158dcd94c3db9bdc410dbccf" translate="yes" xml:space="preserve">
          <source>The above's not so useful. &lt;code&gt;if (!0)&lt;/code&gt; gives you the same results as &lt;code&gt;if (!!0 === false)&lt;/code&gt;. I can't think of a good case for casting a variable to boolean and then comparing to a &quot;true&quot; boolean.</source>
          <target state="translated">위의 내용은 그렇게 유용하지 않습니다. &lt;code&gt;if (!0)&lt;/code&gt; 은 &lt;code&gt;if (!!0 === false)&lt;/code&gt; 와 동일한 결과를 제공합니다. 변수를 부울로 캐스트 한 다음 &quot;참&quot;부울과 비교하는 좋은 사례는 생각할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="281762abc14819a66dcacbfde55f5e8401270f1d" translate="yes" xml:space="preserve">
          <source>The context in which I saw this was,</source>
          <target state="translated">내가 본 상황은</target>
        </trans-unit>
        <trans-unit id="acc6b507b28fe734085a51694ffb662d2f97612f" translate="yes" xml:space="preserve">
          <source>The double &quot;not&quot; in this case is quite simple.  It is simply two &lt;code&gt;not&lt;/code&gt;s back to back.</source>
          <target state="translated">이 경우 이중 &quot;not&quot;은 매우 간단합니다. 그것은 연속해서 두 개가 &lt;code&gt;not&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="531d1ca78f0741ca59c6f0a6607b3ea3cdc4a6d9" translate="yes" xml:space="preserve">
          <source>The double negation operator &lt;code&gt;!!&lt;/code&gt; calculates the truth value of a value. It's actually two operators, where &lt;code&gt;!!x&lt;/code&gt; means &lt;code&gt;!(!x)&lt;/code&gt;, and behaves as follows:</source>
          <target state="translated">이중 부정 연산자 &lt;code&gt;!!&lt;/code&gt; 값의 실제 값을 계산합니다. 실제로는 두 연산자입니다. 여기서 &lt;code&gt;!!x&lt;/code&gt; 는 &lt;code&gt;!(!x)&lt;/code&gt; 의미하며 다음과 같이 동작합니다.</target>
        </trans-unit>
        <trans-unit id="0fedba5c4ec19ca80540448ef2226b8d7209ad69" translate="yes" xml:space="preserve">
          <source>The exception for Typescript? If &lt;code&gt;myObject&lt;/code&gt; was an &lt;code&gt;any&lt;/code&gt;, you're back in JavaScript's Wild West and can return it without &lt;code&gt;!!&lt;/code&gt;, even if your return type is a boolean.</source>
          <target state="translated">Typescript의 예외? &lt;code&gt;myObject&lt;/code&gt; 가 &lt;code&gt;any&lt;/code&gt; 인 경우 JavaScript의 Wild West로 돌아와 &lt;code&gt;!!&lt;/code&gt; 없이 반환 할 수 있습니다 ! 반환 유형이 부울 인 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="e4d67b97b47952ce6811073a8a2a38486c684c78" translate="yes" xml:space="preserve">
          <source>The first bang forces the js engine to run &lt;code&gt;Boolean(x)&lt;/code&gt; but also has the side effect of inverting the value.  So the second bang undoes the side effect.</source>
          <target state="translated">첫 번째 강타는 js 엔진이 &lt;code&gt;Boolean(x)&lt;/code&gt; 을 실행하도록 강제하지만 값을 반전시키는 부작용도 있습니다. 따라서 두 번째 강타는 부작용을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="fe7b25df5389abed33b3b0b02607f02a5ccbe313" translate="yes" xml:space="preserve">
          <source>The first one simply &quot;inverts&quot; the truthy or falsey value, resulting in an actual boolean type, and then the second one &quot;inverts&quot; it back again to it's original state, but now in an actual boolean value.  That way you have consistency:</source>
          <target state="translated">첫 번째는 단순히 진실 또는 허위 값을 &quot;반전&quot;하여 실제 부울 유형을 초래 한 다음 두 번째는 원래의 상태로 다시 &quot;반전&quot;하지만 실제 부울 값으로 다시 되돌립니다. 그렇게하면 일관성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbf601d501a5f0c41724feba5edab84aa91cd28" translate="yes" xml:space="preserve">
          <source>The trick here is the chain of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;s will return &lt;strong&gt;the first falsey value&lt;/strong&gt; it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the &lt;code&gt;b.foo.bar&lt;/code&gt; statement, and we get no error.</source>
          <target state="translated">여기서의 트릭은 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; s 체인이 찾은 &lt;strong&gt;첫 번째 잘못된 값을&lt;/strong&gt; 반환 &lt;strong&gt;하며&lt;/strong&gt; , if 문 등에 제공 될 수 있습니다. 따라서 b.foo가 정의되지 않은 경우 undefined를 반환하고 &lt;code&gt;b.foo.bar&lt;/code&gt; 를 건너 뜁니다. 우리는 오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f362651fc7a92ae9f0a9673d4c5486b2f3f73825" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!false&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">진실은 &lt;code&gt;false&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이 아니라는 것 입니다 (그래서 &lt;code&gt;!false&lt;/code&gt; 는 &lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="a45301cb714edcffab6f1d258022757ae0ecd7bd" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!!false&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">진실은 &lt;code&gt;false&lt;/code&gt; 이 거짓 이 아니라는 것입니다 (그래서 &lt;code&gt;!!false&lt;/code&gt; 은 &lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="dc6dfe93853155dde81483486981f53f459fca48" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!true&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">진실은 &lt;code&gt;true&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 이 아니라는 것입니다 (그래서 &lt;code&gt;!true&lt;/code&gt; 는 &lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="de5886521d1b8bae3b9e573aa8de49514dcf5e6d" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!!true&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">진실은 진실이 &lt;code&gt;true&lt;/code&gt; 이 아니라는 &lt;em&gt;것&lt;/em&gt; &lt;code&gt;true&lt;/code&gt; (그래서 &lt;code&gt;!!true&lt;/code&gt; 결과는 &lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="3c5ec1883ea648c4eac15e44a0e47cc089c821db" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;!&lt;/code&gt; operator converts its operand to a boolean and negates it.</source>
          <target state="translated">단항 &lt;code&gt;!&lt;/code&gt; 연산자는 피연산자를 부울로 변환하고 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="33306e297fa07aa22ffeca48a2d3b1ca6f355960" translate="yes" xml:space="preserve">
          <source>Then you do &lt;code&gt;!0&lt;/code&gt;, it will be converted to boolean and be evaluated to &lt;code&gt;true&lt;/code&gt;, because 0 is &lt;code&gt;falsy&lt;/code&gt;, so you get the reversed value and converted to boolean, so it gets evaluated to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;!0&lt;/code&gt; 을 수행하면 0이 &lt;code&gt;falsy&lt;/code&gt; 이기 때문에 부울로 변환되고 &lt;code&gt;true&lt;/code&gt; 로 평가되므로 반전 된 값을 가져 와서 부울로 변환하므로 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="71ab5eac91ed7f0607dae3a2cf1d7e72a4ca4e97" translate="yes" xml:space="preserve">
          <source>This fact lead to the following idiom that you can see in your source code:</source>
          <target state="translated">이 사실은 소스 코드에서 볼 수있는 다음 관용구로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="5206aead5c0929d44fb460d6a6d755b4275d68d5" translate="yes" xml:space="preserve">
          <source>This question has been answered quite thoroughly, but I'd like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.</source>
          <target state="translated">이 질문은 매우 철저하게 답변되었지만 가능한 한 단순화되어 희망의 의미를 갖는 답변을 추가하고 싶습니다 !! 최대한 쉽게 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="900a6ce54db6671d1163b4588fef81576caa9d76" translate="yes" xml:space="preserve">
          <source>Tons of great answers here, but if you've read down this far, this helped me to 'get it'. Open the console on Chrome (etc), and start typing:</source>
          <target state="translated">여기에 많은 훌륭한 답변이 있지만, 지금까지 읽으 셨다면, 이것이 제가 '얻는'데 도움이되었습니다. Chrome 등에서 콘솔을 열고 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b5a7a294200e3cb34da2a97adf5d130ba6c38c00" translate="yes" xml:space="preserve">
          <source>Use logical not operator two times</source>
          <target state="translated">논리 NOT 연산자를 두 번 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="037ce300d2779ff07c53c4b5b8748bb947cb98bb" translate="yes" xml:space="preserve">
          <source>What is the !! (not not) operator in JavaScript</source>
          <target state="translated">이것은 !! JavaScript가 아닌 연산자</target>
        </trans-unit>
        <trans-unit id="2bd5abc68757873bb182393e529f58b5f1764ea3" translate="yes" xml:space="preserve">
          <source>What we wish to determine in the comparison is the &quot;truth&quot; &lt;em&gt;about&lt;/em&gt; the value of a reference, not the &lt;em&gt;value of&lt;/em&gt; the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be &lt;em&gt;&lt;code&gt;false&lt;/code&gt;&lt;/em&gt; (or falsey), or if we expect the value not to be typeof &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">우리가 비교에서 결정하고자하는 것은 참조 자체의 &lt;em&gt;가치가&lt;/em&gt; 아니라 참조의 가치에 &lt;em&gt;관한&lt;/em&gt; &quot;진실&quot;입니다. 값이 &lt;em&gt; &lt;code&gt;false&lt;/code&gt; &lt;/em&gt; (또는 &lt;em&gt;false&lt;/em&gt; )이거나 값이 &lt;code&gt;boolean&lt;/code&gt; 유형이 아닌 것으로 예상하더라도 값에 대한 진실을 알고 자하는 유스 케이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6dfeec064b00b28af55ee18d69a51869a08807e" translate="yes" xml:space="preserve">
          <source>What you gain with &lt;code&gt;!!&lt;/code&gt; is the ability to check the truthiness of multiple variables &lt;em&gt;against each other&lt;/em&gt; in a repeatable, standardized (and JSLint friendly) fashion.</source>
          <target state="translated">당신이 얻는 것 &lt;code&gt;!!&lt;/code&gt; 여러 변수의 진실성을 반복 가능하고 표준화 된 (그리고 JSLint 친화적 인) 방식으로 &lt;em&gt;서로&lt;/em&gt; 비교할 수있는 능력입니다.</target>
        </trans-unit>
        <trans-unit id="d568b1f542f2ac7d26a5c47b5cb7b7775b67ea06" translate="yes" xml:space="preserve">
          <source>When used at the top level of a Boolean context (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;), the &lt;code&gt;!!&lt;/code&gt; operator is behaviorally a no-op. For example, &lt;code&gt;if (x)&lt;/code&gt; and &lt;code&gt;if (!!x)&lt;/code&gt; mean the same thing.</source>
          <target state="translated">부울 컨텍스트의 최상위 레벨 ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; )에서 사용될 때 &lt;code&gt;!!&lt;/code&gt; 연산자는 행동 적으로 작동하지 않습니다. 예를 들어 &lt;code&gt;if (x)&lt;/code&gt; 와 &lt;code&gt;if (!!x)&lt;/code&gt; 는 같은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="15bdd7d9c3451db43373e5025a0173bdf0c60369" translate="yes" xml:space="preserve">
          <source>Why?  Because &lt;code&gt;document.getElementById()&lt;/code&gt; is a &quot;truthy&quot; expression that will evaluate as true in this &lt;code&gt;if()&lt;/code&gt; statement, but it is not an actual boolean value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">왜? &lt;code&gt;document.getElementById()&lt;/code&gt; 는이 &lt;code&gt;if()&lt;/code&gt; 문에서 true로 평가되는 &quot;truthy&quot;표현식이지만 실제 부울 값 &lt;code&gt;true&lt;/code&gt; 는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2562e78de1b3256bca3da91141bb0297a876088d" translate="yes" xml:space="preserve">
          <source>and instead of</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="6ff7395099aa52cc1ac2567047b5dc904e83a97c" translate="yes" xml:space="preserve">
          <source>but we don't want the reversed &lt;strong&gt;boolean version&lt;/strong&gt; of the value, so we can reverse it again to get our result! That's why we use another &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">그러나 우리는 값의 역상 &lt;strong&gt;불리언 버전&lt;/strong&gt; 을 원하지 않기 때문에 결과를 얻기 위해 다시 역으로 할 수 있습니다! 우리가 다른 것을 사용하는 이유입니다 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1136ebda06acfbb946c27883e9c70a00d96a8324" translate="yes" xml:space="preserve">
          <source>here is a piece of code from angular js</source>
          <target state="translated">다음은 각도 js의 코드입니다.</target>
        </trans-unit>
        <trans-unit id="07aee702dc1bc81b24b43ca8e96d3a68f77ddfba" translate="yes" xml:space="preserve">
          <source>if requestAnimationFrame was assinged undefined then
!requestAnimationFrame would be true and one more ! of it would be false</source>
          <target state="translated">requestAnimationFrame이 정의되지 않은 것으로 가정하면! requestAnimationFrame은 true이고 하나 더 있습니다! 그것의 거짓</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">와 같다</target>
        </trans-unit>
        <trans-unit id="fb81871808eeba6b79f000511077e0392e5040fe" translate="yes" xml:space="preserve">
          <source>it can be achieved by checking in following way in general:</source>
          <target state="translated">일반적으로 다음과 같은 방법으로 확인하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf9bb582fda3d69616ba7956287f904859457f58" translate="yes" xml:space="preserve">
          <source>just say</source>
          <target state="translated">그냥 말해</target>
        </trans-unit>
        <trans-unit id="dc01c6b7487aab92695f7ba918540cf5051f72f4" translate="yes" xml:space="preserve">
          <source>say</source>
          <target state="translated">say</target>
        </trans-unit>
        <trans-unit id="287b978241585895eb95865fc85abb7f32f60d1e" translate="yes" xml:space="preserve">
          <source>so if requestAnimationFrame was assigned a function
 then
!requestAnimationFrame would be false and one more ! of it would be true</source>
          <target state="translated">따라서 requestAnimationFrame에 함수가 할당되면! requestAnimationFrame은 false이고 하나 더 있습니다! 그것의 사실이다</target>
        </trans-unit>
        <trans-unit id="7c2b4b647bd0e7cbaa828c353b4a7be55a9be894" translate="yes" xml:space="preserve">
          <source>the short way could be using !!</source>
          <target state="translated">짧은 길은 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="2b1fd3dee3545afca88dbce54f7f1d0f063a468f" translate="yes" xml:space="preserve">
          <source>their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame</source>
          <target state="translated">그들의 의도는 requestAnimationFrame의 함수 가용성에 따라 rafSupported를 true 또는 false로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b247e535f27451042dc1de383c546cfcbe520d6" translate="yes" xml:space="preserve">
          <source>will BOTH return true, as expected.</source>
          <target state="translated">예상대로 BOTH가 모두 true를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
