<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/784929">
    <body>
      <group id="784929">
        <trans-unit id="9d8ee90d447e634111f086fe5d63063e02604c04" translate="yes" xml:space="preserve">
          <source>! is &quot;boolean not&quot;, which essentially typecasts the value of &quot;enable&quot; to its boolean opposite. The second ! flips this value. So, &lt;code&gt;!!enable&lt;/code&gt; means &quot;not not enable,&quot; giving you the value of &lt;code&gt;enable&lt;/code&gt; as a boolean.</source>
          <target state="translated">! es &quot;boolean not&quot;, que esencialmente encasilla el valor de &quot;enable&quot; a su opuesto booleano. El segundo ! Voltea este valor. Entonces, &lt;code&gt;!!enable&lt;/code&gt; significa &quot;no no enable&quot;, que le da el valor de &lt;code&gt;enable&lt;/code&gt; como booleano.</target>
        </trans-unit>
        <trans-unit id="1267640ee6e890d8ceb635273042d73661945ffd" translate="yes" xml:space="preserve">
          <source>(please read code descriptions)</source>
          <target state="translated">(por favor,lea las descripciones de los códigos)</target>
        </trans-unit>
        <trans-unit id="dbc5329443fc97ea79e3d6fc7a7c08bb400f6cdb" translate="yes" xml:space="preserve">
          <source>... you might be surprised to see React render a &lt;code&gt;0&lt;/code&gt; when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns &lt;code&gt;0&lt;/code&gt;, which JSX happily renders, as it should. It can't tell you didn't have &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (or something less contrived).</source>
          <target state="translated">... puede que se sorprenda al ver que React representa un &lt;code&gt;0&lt;/code&gt; cuando tiene cero mensajes. Debe devolver expl&amp;iacute;citamente false para que JSX no se procese. La declaraci&amp;oacute;n anterior devuelve &lt;code&gt;0&lt;/code&gt; , que JSX representa felizmente, como deber&amp;iacute;a. No puede decir que no tuvo &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (o algo menos artificial).</target>
        </trans-unit>
        <trans-unit id="c4b43c7ba8236eeadfe785d67215c403a6e6e119" translate="yes" xml:space="preserve">
          <source>...will NOT result in a true condition, and the code block will not be executed, even if the element does exist.</source>
          <target state="translated">...no resultará en una condición verdadera,y el bloque de código no se ejecutará,incluso si el elemento existe.</target>
        </trans-unit>
        <trans-unit id="bd18c0553a45634b99d4953abd9dd07bb59545b2" translate="yes" xml:space="preserve">
          <source>3rd party libraries that expect explicit Boolean values</source>
          <target state="translated">Bibliotecas de terceros que esperan valores booleanos explícitos</target>
        </trans-unit>
        <trans-unit id="05317c9a3565f977ff95a0b1172dd228b7234929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!0 === false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!!0 === false&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b16fdc2b982571586ffd6bc3139aa446dfb0262b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; converts the value to the right of it to its equivalent boolean value. (Think poor man's way of &quot;type-casting&quot;). Its &lt;em&gt;intent&lt;/em&gt; is usually to convey to the reader that the code does not care &lt;em&gt;what&lt;/em&gt; value is in the variable, but what it's &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&quot;truth&quot; value&lt;/a&gt; is.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; convierte el valor a su derecha en su valor booleano equivalente. (Piense en la forma de &quot;fundici&amp;oacute;n de tipos&quot; de los pobres). Por lo general, su &lt;em&gt;intenci&amp;oacute;n&lt;/em&gt; es transmitir al lector que al c&amp;oacute;digo no le importa &lt;em&gt;qu&amp;eacute;&lt;/em&gt; valor tiene la variable, sino cu&amp;aacute;l es su &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;valor de &quot;verdad&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de68e033596cd4f5d22f42c9c74a29c3813083dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; is not an operator. It is the double-use of &lt;code&gt;!&lt;/code&gt; -- which is the logical &quot;not&quot; operator.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; No es un operador. Es el doble uso de &lt;code&gt;!&lt;/code&gt; - que es el operador l&amp;oacute;gico &quot;no&quot;.</target>
        </trans-unit>
        <trans-unit id="0c49aab7f0deeecf7c139cada81e75156b64a3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; it's using &lt;code&gt;NOT&lt;/code&gt; operation twice together, &lt;code&gt;!&lt;/code&gt; convert the value to a &lt;code&gt;boolean&lt;/code&gt; and reverse it, here is a simple example to see how &lt;code&gt;!!&lt;/code&gt; works:</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; est&amp;aacute; utilizando la operaci&amp;oacute;n &lt;code&gt;NOT&lt;/code&gt; dos veces juntos &lt;code&gt;!&lt;/code&gt; convierta el valor a &lt;code&gt;boolean&lt;/code&gt; o e invi&amp;eacute;rtalo, &amp;iexcl;aqu&amp;iacute; hay un ejemplo simple para ver c&amp;oacute;mo &lt;code&gt;!!&lt;/code&gt; trabajos:</target>
        </trans-unit>
        <trans-unit id="40472ff2de807d44da0389b6ed6c479fe97e450d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!expr&lt;/code&gt; returns a Boolean value (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) depending on the &lt;em&gt;truthiness&lt;/em&gt; of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:</source>
          <target state="translated">&lt;code&gt;!!expr&lt;/code&gt; devuelve un valor booleano ( &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; ) dependiendo de la &lt;em&gt;veracidad&lt;/em&gt; de la expresi&amp;oacute;n. Tiene m&amp;aacute;s sentido cuando se usa en tipos no booleanos. Considere estos ejemplos, especialmente el 3er ejemplo y en adelante:</target>
        </trans-unit>
        <trans-unit id="c11c8b2ce2578dcc578b1ef73f483f4da8bddb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!foo&lt;/code&gt; applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus &lt;code&gt;+foo&lt;/code&gt; to cast to number and concatenating an empty string &lt;code&gt;''+foo&lt;/code&gt; to cast to string.</source>
          <target state="translated">&lt;code&gt;!!foo&lt;/code&gt; aplica el operador unario no dos veces y se usa para lanzar a tipo booleano similar al uso de unario m&amp;aacute;s &lt;code&gt;+foo&lt;/code&gt; para lanzar al n&amp;uacute;mero y concatenar una cadena vac&amp;iacute;a &lt;code&gt;''+foo&lt;/code&gt; para lanzar a la cadena.</target>
        </trans-unit>
        <trans-unit id="a3fbcf80055d72c6902769ea1b0b209d18d54c31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; is &lt;code&gt;!!0 === !!undefined&lt;/code&gt; and is true! Same truthiness! (In this case, both &quot;have a truthiness of falsy&quot;.)</source>
          <target state="translated">&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; es &lt;code&gt;!!0 === !!undefined&lt;/code&gt; y es cierto! La misma veracidad! (En este caso, ambos &quot;tienen una verdad de falsedad&quot;).</target>
        </trans-unit>
        <trans-unit id="d3afe30734c2565c10167b232d767321261e858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!x&lt;/code&gt; is shorthand for &lt;code&gt;Boolean(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!!x&lt;/code&gt; es la abreviatura de &lt;code&gt;Boolean(x)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721b932e6bc1cc17c9cd50fea7dc4b8b7a6ad668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is &lt;em&gt;NOT&lt;/em&gt;.  So &lt;code&gt;!true&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;!0&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!1&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; &lt;em&gt;NO&lt;/em&gt; es Entonces &lt;code&gt;!true&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , y &lt;code&gt;!false&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;!0&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;!1&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84f888f6e0a39683c0e570def98bcac6595167f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0 === false&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0 === false&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601bab0f9b947357bf0bbc8ebc5b625e5e7af331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; is a bitwise AND; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; is a logical AND. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; (a false value); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; es un AND bit a bit; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; es un AND l&amp;oacute;gico. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; (un valor falso); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; es cierto.</target>
        </trans-unit>
        <trans-unit id="fe8e944fda44e395ec8eb52766a2d42b25be5541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a = b)&lt;/code&gt; is assignment followed by use of the truth value of &lt;code&gt;b&lt;/code&gt;; &lt;code&gt;if (a == b)&lt;/code&gt; is an equality comparison.</source>
          <target state="translated">&lt;code&gt;if (a = b)&lt;/code&gt; es una asignaci&amp;oacute;n seguida del uso del valor de verdad de &lt;code&gt;b&lt;/code&gt; ; &lt;code&gt;if (a == b)&lt;/code&gt; es una comparaci&amp;oacute;n de igualdad.</target>
        </trans-unit>
        <trans-unit id="a4c32abc5c7932aafafe8b72767dd17a9e12923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myVar1 === myVar2&lt;/code&gt; is &lt;code&gt;0 === undefined&lt;/code&gt; and is obviously false.</source>
          <target state="translated">&lt;code&gt;myVar1 === myVar2&lt;/code&gt; es &lt;code&gt;0 === undefined&lt;/code&gt; y obviamente es falso.</target>
        </trans-unit>
        <trans-unit id="7899bf510c8f1081aeced8dc9e82c3717d6f3a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is &lt;em&gt;not&lt;/em&gt; not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!!&lt;/code&gt; &lt;/strong&gt; determina la &quot;verdad&quot; de lo que un valor &lt;em&gt;no&lt;/em&gt; es:</target>
        </trans-unit>
        <trans-unit id="05ffd1c973d25f3fa642c01bde2e2d7437ff0b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!&lt;/code&gt; &lt;/strong&gt; determina la &quot;verdad&quot; de lo que no es un valor:</target>
        </trans-unit>
        <trans-unit id="6d9ad97a5f3ee3fba703f038b8cb73c50bd30761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brew some tea:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Prepara un poco de t&amp;eacute;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80a5baf090dcfffcd4153848ee43b313dff5f952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But wait, there's more!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Pero espera hay mas!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3574ce92cb57aeb1f7ff451de1bbe4886856bb60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 24 Oct 2017, 6 Feb 19:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDITAR 24 oct 2017, 6 feb 19:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a055a42c402ff7009188d3b50ace76756b7075b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;En la pr&amp;aacute;ctica:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36ed1544d47aa0950bc63b80406386d69ec830fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In theory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;En teoria:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a17136c4cff424debad877c2ecfe86e4318d16b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S.&lt;/strong&gt; Another way of doing the same thing is &lt;code&gt;(b || {}).foo&lt;/code&gt;, because if b is undefined then &lt;code&gt;b || {}&lt;/code&gt; will be &lt;code&gt;{}&lt;/code&gt;, and you'll be accessing a value in an empty object (no error) instead of trying to access a value within &quot;undefined&quot; (causes an error).  So, &lt;code&gt;(b || {}).foo&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; and &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;PD&lt;/strong&gt; Otra forma de hacer lo mismo es &lt;code&gt;(b || {}).foo&lt;/code&gt; , porque si b no est&amp;aacute; definido, entonces &lt;code&gt;b || {}&lt;/code&gt; {} ser&amp;aacute; &lt;code&gt;{}&lt;/code&gt; , y acceder&amp;aacute; a un valor en un objeto vac&amp;iacute;o (sin error) en lugar de intentar acceder a un valor dentro de &quot;indefinido&quot; (provoca un error). Entonces, &lt;code&gt;(b || {}).foo&lt;/code&gt; es lo mismo que &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; y &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; es lo mismo que &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b8f384febfdd7d7361b695f817e89853b5220d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We digress...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Estamos divagando ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="022b17591a08c04d294c7aa2b97cef1c499d1b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;it means !true= false&lt;br/&gt;
 and  !!true = true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;significa! verdadero = falso&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt; &lt;strong&gt;y !! verdadero = verdadero&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4626b6d0fd1defd823f8f27a6ee0096c94607fb" translate="yes" xml:space="preserve">
          <source>A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; performs a logical AND (true if both sides are true), and &lt;code&gt;a &amp;amp; b&lt;/code&gt; performs a bitwise AND. &lt;code&gt;a || b&lt;/code&gt; performs a logical OR (true if at least one are true), and &lt;code&gt;a | b&lt;/code&gt; performs a bitwise OR. There's a bitwise XOR (exclusive OR) as &lt;code&gt;a ^ b&lt;/code&gt;, but there's no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: &lt;code&gt;!!x !== !!y&lt;/code&gt;.</source>
          <target state="translated">Un tercer uso es producir XOR l&amp;oacute;gico y XNOR l&amp;oacute;gico. Tanto en C como en JavaScript, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; realiza un AND l&amp;oacute;gico (verdadero si ambos lados son verdaderos), y &lt;code&gt;a &amp;amp; b&lt;/code&gt; realiza un AND bit a bit. &lt;code&gt;a || b&lt;/code&gt; b realiza un OR l&amp;oacute;gico (verdadero si al menos uno es verdadero), y &lt;code&gt;a | b&lt;/code&gt; b realiza un OR bit a bit. Hay un XOR bit a bit (OR exclusivo) como &lt;code&gt;a ^ b&lt;/code&gt; , pero no hay un operador incorporado para XOR l&amp;oacute;gico (verdadero si exactamente un lado es verdadero). Es posible que, por ejemplo, desee permitir que el usuario ingrese texto en exactamente uno de los dos campos. Lo que puede hacer es convertir cada uno en un valor de verdad y compararlos: &lt;code&gt;!!x !== !!y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="937148e0ba3cf2e3a6ad662dce342d4574705192" translate="yes" xml:space="preserve">
          <source>After seeing all these great answers, I would like to add another reason for using  &lt;code&gt;!!&lt;/code&gt;. Currenty I'm working in Angular 2-4 (TypeScript) and I want to return a boolean as &lt;code&gt;false&lt;/code&gt; when my user is not authenticated. If he isn't authenticated, the token-string would be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;. I can do this by using the next block of code:</source>
          <target state="translated">&amp;iexcl;Despu&amp;eacute;s de ver todas estas excelentes respuestas, me gustar&amp;iacute;a agregar otra raz&amp;oacute;n para usar &lt;code&gt;!!&lt;/code&gt; . Actualmente estoy trabajando en Angular 2-4 (TypeScript) y quiero devolver un booleano como &lt;code&gt;false&lt;/code&gt; cuando mi usuario no est&amp;aacute; autenticado. Si no est&amp;aacute; autenticado, la cadena de token ser&amp;iacute;a &lt;code&gt;null&lt;/code&gt; o &lt;code&gt;&quot;&quot;&lt;/code&gt; . Puedo hacer esto usando el siguiente bloque de c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="719bb016bfb2ea5208e53cc2ef5f67a057166604" translate="yes" xml:space="preserve">
          <source>And things get even crazier depending on your engine. WScript, for instance, wins the prize.</source>
          <target state="translated">Y las cosas se vuelven aún más locas dependiendo de tu motor.WScript,por ejemplo,gana el premio.</target>
        </trans-unit>
        <trans-unit id="d2e6426f3b2e591c60f6c55c2d312ca4857318d9" translate="yes" xml:space="preserve">
          <source>Another use, which I mentioned in an &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;answer about C's corresponding &lt;code&gt;!!&lt;/code&gt; operator&lt;/a&gt;, is with &quot;lint&quot; tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn't quite as Boolean:</source>
          <target state="translated">&amp;iexcl;Otro uso, que mencion&amp;eacute; en una &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;respuesta sobre las correspondientes de C &lt;code&gt;!!&lt;/code&gt; &lt;/a&gt; operador , est&amp;aacute; con herramientas de &quot;pelusa&quot; que buscan errores tipogr&amp;aacute;ficos comunes y diagn&amp;oacute;sticos de impresi&amp;oacute;n. Por ejemplo, tanto en C como en JavaScript, algunos errores tipogr&amp;aacute;ficos comunes para las operaciones booleanas producen otros comportamientos cuya salida no es tan booleana:</target>
        </trans-unit>
        <trans-unit id="5d7e80841153e3f0b33aa705ecbcdee928b5ed77" translate="yes" xml:space="preserve">
          <source>At first, the place you have:</source>
          <target state="translated">Al principio,el lugar que tienes:</target>
        </trans-unit>
        <trans-unit id="37383f3a991b3aaf3607d0d306ed294c9e3535ec" translate="yes" xml:space="preserve">
          <source>Basically, &lt;code&gt;!!&lt;/code&gt; make us sure, the value we get is boolean, not falsy, truthy or string etc...</source>
          <target state="translated">B&amp;aacute;sicamente &lt;code&gt;!!&lt;/code&gt; aseg&amp;uacute;rese de que el valor que obtenemos sea booleano, no falso, verdadero o cadena, etc.</target>
        </trans-unit>
        <trans-unit id="f0db7bebe15c805ab3aec2ff3047007e131c1547" translate="yes" xml:space="preserve">
          <source>Because javascript has what are called &quot;truthy&quot; and &quot;falsey&quot; values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Debido a que JavaScript tiene lo que se llama valores &quot;veraces&quot; y &quot;falsey&quot;, existen expresiones que, cuando se eval&amp;uacute;an en otras expresiones, dar&amp;aacute;n como resultado una condici&amp;oacute;n verdadera o falsa, aunque el valor o la expresi&amp;oacute;n que se examina no sea realmente &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebcd804c817f36ef59a932affdb9a970bbb27d1b" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;some historical Windows jive&lt;/a&gt;, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; still gives you 0, or WScript's &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Look away. It's hideous.&lt;/a&gt;</source>
          <target state="translated">&amp;iexcl;Debido a &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;algunos&lt;/a&gt; cambios hist&amp;oacute;ricos de Windows , eso generar&amp;aacute; -1 en un cuadro de mensaje! &amp;iexcl;Pru&amp;eacute;belo en un indicador de cmd.exe y vea! Pero &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; todav&amp;iacute;a le da 0, o WScript es &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Apartar.&lt;/a&gt; Es horrible</target>
        </trans-unit>
        <trans-unit id="34a3c4d1b09c4c334e45f565ff959b93e1297ce9" translate="yes" xml:space="preserve">
          <source>But if you &amp;rArr;</source>
          <target state="translated">Pero si &amp;rArr;</target>
        </trans-unit>
        <trans-unit id="55af43b97047e9feca9827254a5bad346b4fb1ea" translate="yes" xml:space="preserve">
          <source>But if you see strange &lt;code&gt;0&lt;/code&gt;s in your rendered JSX, think loose falsy management.</source>
          <target state="translated">Pero si ve &lt;code&gt;0&lt;/code&gt; s extra&amp;ntilde;os en su JSX renderizado, piense en una gesti&amp;oacute;n falsa falsa.</target>
        </trans-unit>
        <trans-unit id="c3d9638bccd08789c5c96539764af9bdb9abbc4d" translate="yes" xml:space="preserve">
          <source>But this can be an issue when something is undefined.</source>
          <target state="translated">Pero esto puede ser un problema cuando algo no está definido.</target>
        </trans-unit>
        <trans-unit id="fc510cf59a92c328aac077d7719d62aac7a4811c" translate="yes" xml:space="preserve">
          <source>But what if I have two values I need to check for equal truthi/falsi-ness?</source>
          <target state="translated">¿Pero qué pasa si tengo dos valores que necesito comprobar para la igualdad de la veracidad?</target>
        </trans-unit>
        <trans-unit id="0a33acba295ef44765fa6e094d5bf1d8422929b7" translate="yes" xml:space="preserve">
          <source>Comparing truthiness :)</source>
          <target state="translated">Comparando la veracidad :)</target>
        </trans-unit>
        <trans-unit id="c26332ba114f738a9008487cc2e7e1224052ab38" translate="yes" xml:space="preserve">
          <source>Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;dynamic typing&lt;/a&gt;&lt;/strong&gt; (aka &quot;duck typing&quot;). We want to write a function that returns &lt;code&gt;true&lt;/code&gt; if a user's browser supports the HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; element, but we don't want the function to throw an error if &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is undefined; and we don't want to use &lt;code&gt;try ... catch&lt;/code&gt; to handle any possible errors (because they're gross); &lt;em&gt;and also&lt;/em&gt; we don't want to use a check inside the function that won't consistently reveal the truth about the feature (for example, &lt;code&gt;document.createElement('audio')&lt;/code&gt; will still create an element called &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; even if HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is not supported).</source>
          <target state="translated">Considere una funci&amp;oacute;n concisa que detecta la funcionalidad de la caracter&amp;iacute;stica (y en este caso, la compatibilidad de la plataforma) a trav&amp;eacute;s de &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;la escritura din&amp;aacute;mica&lt;/a&gt;&lt;/strong&gt; (tambi&amp;eacute;n conocida como &quot;escritura de pato&quot;). Queremos escribir una funci&amp;oacute;n que devuelva &lt;code&gt;true&lt;/code&gt; si el navegador de un usuario admite el elemento &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; HTML5, pero no queremos que la funci&amp;oacute;n arroje un error si &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; no est&amp;aacute; definido; y no queremos usar &lt;code&gt;try ... catch&lt;/code&gt; para manejar posibles errores (porque son asquerosos); &lt;em&gt;y&lt;/em&gt; tampoco queremos usar una verificaci&amp;oacute;n dentro de la funci&amp;oacute;n que no revelar&amp;aacute; constantemente la verdad sobre la funci&amp;oacute;n (por ejemplo, &lt;code&gt;document.createElement('audio')&lt;/code&gt; seguir&amp;aacute; creando un elemento llamado &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; incluso si HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; no es compatible).</target>
        </trans-unit>
        <trans-unit id="9c2bfed607f580ac4ac34ab9f08a0c6aa7cb0429" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Object&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;. If it was falsey (e.g. &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, etc.), it will be &lt;code&gt;false&lt;/code&gt;, otherwise, &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Convierte el &lt;code&gt;Object&lt;/code&gt; en &lt;code&gt;boolean&lt;/code&gt; o . Si fue falsey (por ejemplo, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; , etc.), ser&amp;aacute; &lt;code&gt;false&lt;/code&gt; , de lo contrario, ser&amp;aacute; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7af2387329e42b1e1dcdbdc75737b43eb16b3b56" translate="yes" xml:space="preserve">
          <source>Double boolean negation. Often used to check if value is not undefined.</source>
          <target state="translated">Doble negación booleana.A menudo se usa para comprobar si el valor no está indefinido.</target>
        </trans-unit>
        <trans-unit id="1378886488bff47eea733f621e4e6b0a3b97b140" translate="yes" xml:space="preserve">
          <source>Each function accepts an argument for a &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; and an &lt;code&gt;attribute&lt;/code&gt; to look for, but they each return different values based on what the comparisons determine.</source>
          <target state="translated">Cada funci&amp;oacute;n acepta un argumento para buscar un &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; y un &lt;code&gt;attribute&lt;/code&gt; , pero cada uno devuelve valores diferentes en funci&amp;oacute;n de lo que determinen las comparaciones.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1e86b051c400fed4e8f797a656375e775595e029" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; and &lt;code&gt;!!0 === false&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; y &lt;code&gt;!!0 === false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0da32197e1f2c3ed9016c076548a9c1dc68c0878" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False in JSX (React) has a special meaning&lt;/a&gt; that's not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in &lt;code&gt;messageCount&lt;/code&gt;...</source>
          <target state="translated">Por ejemplo, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False en JSX (React) tiene un significado especial&lt;/a&gt; que no se desencadena en la falsedad simple. Si intent&amp;oacute; devolver algo como lo siguiente en su JSX, esperando un int en &lt;code&gt;messageCount&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="eaa9bb432088641bac3a4242e7ee096bd6cecd11" translate="yes" xml:space="preserve">
          <source>Here are the three approaches:</source>
          <target state="translated">Aquí están los tres enfoques:</target>
        </trans-unit>
        <trans-unit id="f64e010c295a2870b0f4d659e488a6c517e64044" translate="yes" xml:space="preserve">
          <source>Here's an interesting case... &lt;code&gt;!!&lt;/code&gt; might be useful when 3rd party libs expect explicit Boolean values.</source>
          <target state="translated">Aqu&amp;iacute; hay un caso interesante ... &lt;code&gt;!!&lt;/code&gt; podr&amp;iacute;a ser &amp;uacute;til cuando las bibliotecas de terceros esperan valores booleanos expl&amp;iacute;citos.</target>
        </trans-unit>
        <trans-unit id="5dcc317e1dd0008af8179d1f9a0f92f72220ebe0" translate="yes" xml:space="preserve">
          <source>However it has several practical uses.</source>
          <target state="translated">Sin embargo,tiene varios usos prácticos.</target>
        </trans-unit>
        <trans-unit id="f73892b42e6ec2099f18c789a4ca27320607324a" translate="yes" xml:space="preserve">
          <source>However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting &lt;code&gt;true&lt;/code&gt; from a non-boolean, possibly undefined value is indeed by using &lt;code&gt;!!&lt;/code&gt;. Hopefully this ridiculously clears it up.</source>
          <target state="translated">Por muy raras que puedan ser estas situaciones, puede haber algunos escenarios en los que el medio m&amp;aacute;s conciso, m&amp;aacute;s eficaz y, por lo tanto, el m&amp;aacute;s preferido para obtener la &lt;code&gt;true&lt;/code&gt; partir de un valor no booleano, posiblemente indefinido, &amp;iexcl;es de hecho usando &lt;code&gt;!!&lt;/code&gt; . Esperemos que esto lo aclare rid&amp;iacute;culamente.</target>
        </trans-unit>
        <trans-unit id="4f858245f3d281e55c31873b62aa68516b0b67f3" translate="yes" xml:space="preserve">
          <source>However:</source>
          <target state="translated">However:</target>
        </trans-unit>
        <trans-unit id="e75de3aca85245f9741f3ed73aba2405a0e6cfcd" translate="yes" xml:space="preserve">
          <source>I can't think of a great, non-contrived use case for that offhand. Maybe you have &quot;linked&quot; fields in a form?</source>
          <target state="translated">No puedo pensar en un gran caso de uso no convencional para eso de improviso.¿Tal vez tienes campos &quot;vinculados&quot; en un formulario?</target>
        </trans-unit>
        <trans-unit id="bd129d49875f1c7bf2d6c56ffa1cefd1aa871386" translate="yes" xml:space="preserve">
          <source>I just wanted to add that</source>
          <target state="translated">Sólo quería añadir que</target>
        </trans-unit>
        <trans-unit id="227f3285ec3ec43c9acc1d6e328c5b2a5034b7af" translate="yes" xml:space="preserve">
          <source>I saw some code that seems to use an operator I don't recognize, in the form of two exclamation points, like so: &lt;code&gt;!!&lt;/code&gt;. Can someone please tell me what this operator does?</source>
          <target state="translated">&amp;iexcl;Vi un c&amp;oacute;digo que parece usar un operador que no reconozco, en forma de dos signos de exclamaci&amp;oacute;n, as&amp;iacute;: &lt;code&gt;!!&lt;/code&gt; . &amp;iquest;Alguien puede decirme qu&amp;eacute; hace este operador?</target>
        </trans-unit>
        <trans-unit id="0ab6442ad8b0b1090c870a59a8d71ba43701e2c7" translate="yes" xml:space="preserve">
          <source>I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.</source>
          <target state="translated">Sospecho que esto es un remanente de C++donde la gente anula el operador ! pero no el operador de bool.</target>
        </trans-unit>
        <trans-unit id="003e87252c9f7ec44808278e2171c30bbf27960f" translate="yes" xml:space="preserve">
          <source>I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of &amp;amp;&amp;amp; and 
first success or last fail in case of || of condition chain.</source>
          <target state="translated">Creo que vale la pena mencionar que una condici&amp;oacute;n combinada con AND / OR l&amp;oacute;gico no devolver&amp;aacute; un valor booleano, sino el &amp;uacute;ltimo &amp;eacute;xito o el primer error en el caso de &amp;amp;&amp;amp; y el primer &amp;eacute;xito o el &amp;uacute;ltimo error en el caso de || de condici&amp;oacute;n de cadena.</target>
        </trans-unit>
        <trans-unit id="d802fb28a6d04b4cc61b6721bff2527b6ab50f8a" translate="yes" xml:space="preserve">
          <source>I'm more comfortable handling falsiness myself with a ternary --</source>
          <target state="translated">Me siento más cómodo manejando la falsedad yo mismo con un ternario...</target>
        </trans-unit>
        <trans-unit id="f605cfe8b7167fb9c1edb800b4a71aae4fe2edfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a false value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un valor falso,! &lt;code&gt;!x&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;!!x&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2542885728d534e0cbf50ded3d8082dbb4bc2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a true value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un valor verdadero,! &lt;code&gt;!x&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; y &lt;code&gt;!!x&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24f97de69477863bf6708059e17ad9778d8a9cc3" translate="yes" xml:space="preserve">
          <source>If that element does in fact exist, the expression will evaluate as true, and the code block will be executed.</source>
          <target state="translated">Si ese elemento existe de hecho,la expresión se evaluará como verdadera,y el bloque de código se ejecutará.</target>
        </trans-unit>
        <trans-unit id="442b7a39eb1de6839bcbf2cca353f71f520acfac" translate="yes" xml:space="preserve">
          <source>If you &amp;rArr;</source>
          <target state="translated">Si &amp;rArr;</target>
        </trans-unit>
        <trans-unit id="5075badbf5e88b6b0caa8ef134b856caccd05702" translate="yes" xml:space="preserve">
          <source>If you only care that a value is truthy or falsy, then use the short form. Instead of</source>
          <target state="translated">Si sólo te importa que un valor sea verdadero o falso,entonces usa la forma corta.En lugar de</target>
        </trans-unit>
        <trans-unit id="25c0c498a0bdb8446495ca30bd5369fa1fe77b30" translate="yes" xml:space="preserve">
          <source>In order to cast the condition to a true boolean literal we can use the double negation:</source>
          <target state="translated">Para poder convertir la condición en un verdadero literal booleano,podemos usar la doble negación:</target>
        </trans-unit>
        <trans-unit id="d94b2b8672da34c8a43dd1c8cbce124ec9f02e37" translate="yes" xml:space="preserve">
          <source>Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (&lt;em&gt;without&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;) to explicitly cast values, ie</source>
          <target state="translated">En lugar de estos hacks, tambi&amp;eacute;n puede usar las funciones de constructor correspondientes a los tipos primitivos ( &lt;em&gt;sin&lt;/em&gt; usar &lt;code&gt;new&lt;/code&gt; ) para emitir valores expl&amp;iacute;citamente, es decir</target>
        </trans-unit>
        <trans-unit id="ef8ebd812b149cf4ca6384ab75bf685b7c51d444" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;Boolean&lt;/code&gt; class can be used.</source>
          <target state="translated">En su lugar, se puede usar la clase &lt;code&gt;Boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5f0f08c8b69e561341c016a5178bbabfab99f4" translate="yes" xml:space="preserve">
          <source>It converts the suffix to a Boolean value.</source>
          <target state="translated">Convierte el sufijo en un valor booleano.</target>
        </trans-unit>
        <trans-unit id="04f0b660a5f5fd40c699d9299636f12196d971ce" translate="yes" xml:space="preserve">
          <source>It forces all things to boolean.</source>
          <target state="translated">Obliga a todas las cosas a boolearse.</target>
        </trans-unit>
        <trans-unit id="362012587fedf1f206a41069ff29470d4bcc9b9f" translate="yes" xml:space="preserve">
          <source>It seems that the &lt;code&gt;!!&lt;/code&gt; operator results in a double negation.</source>
          <target state="translated">Parece que el &lt;code&gt;!!&lt;/code&gt; El operador da como resultado una doble negaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d12e704c471bd7b5f2ef621231182892cdbce3ce" translate="yes" xml:space="preserve">
          <source>It simulates the behavior of the &lt;code&gt;Boolean()&lt;/code&gt; casting function.
The first &lt;code&gt;NOT&lt;/code&gt; returns a Boolean value no matter what operand it is given. The second &lt;code&gt;NOT&lt;/code&gt; negates that &lt;code&gt;Boolean&lt;/code&gt; value and so gives the &lt;code&gt;true&lt;/code&gt; Boolean value of a variable. The end result is the same as using the &lt;code&gt;Boolean()&lt;/code&gt; function on a value.</source>
          <target state="translated">Simula el comportamiento de la funci&amp;oacute;n de conversi&amp;oacute;n &lt;code&gt;Boolean()&lt;/code&gt; . El primer &lt;code&gt;NOT&lt;/code&gt; devuelve un valor booleano sin importar qu&amp;eacute; operando se le d&amp;eacute;. El segundo &lt;code&gt;NOT&lt;/code&gt; niega ese valor &lt;code&gt;Boolean&lt;/code&gt; y, por lo tanto, da el &lt;code&gt;true&lt;/code&gt; valor booleano de una variable. El resultado final es el mismo que usar la &lt;code&gt;Boolean()&lt;/code&gt; en un valor.</target>
        </trans-unit>
        <trans-unit id="b34f307bed6829df645edce297716e7d66021503" translate="yes" xml:space="preserve">
          <source>It's a double &lt;code&gt;not&lt;/code&gt; operation.  The first &lt;code&gt;!&lt;/code&gt; converts the value to boolean and inverts its logical value.  The second &lt;code&gt;!&lt;/code&gt; inverts the logical value back.</source>
          <target state="translated">Es una doble &lt;code&gt;not&lt;/code&gt; operaci&amp;oacute;n. El primero &lt;code&gt;!&lt;/code&gt; convierte el valor en booleano e invierte su valor l&amp;oacute;gico. El segundo &lt;code&gt;!&lt;/code&gt; invierte el valor l&amp;oacute;gico de nuevo.</target>
        </trans-unit>
        <trans-unit id="c63e6ec5ccb83901a441e96930f2594861a2a402" translate="yes" xml:space="preserve">
          <source>It's a horribly obscure way to do a type conversion.</source>
          <target state="translated">Es una forma horriblemente oscura de hacer una conversión de tipos.</target>
        </trans-unit>
        <trans-unit id="a0bfc03fee00b0a95a35794ff4b18bfb284ed3d7" translate="yes" xml:space="preserve">
          <source>It's just the logical NOT operator, twice - it's used to convert something to boolean, e.g.:</source>
          <target state="translated">Es sólo el operador lógico NOT,dos veces-se utiliza para convertir algo a booleano,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="54382507df0f3d9ecbfe0a329a53e74bef4a1834" translate="yes" xml:space="preserve">
          <source>It's not a single operator, it's two.  It's equivalent to the following and is a quick way to cast a value to boolean.</source>
          <target state="translated">No es un solo operador,son dos.Es equivalente a lo siguiente y es una forma rápida de dar un valor a la booleana.</target>
        </trans-unit>
        <trans-unit id="7f323048105e7d3908de65a905d0ecb9e7cccddb" translate="yes" xml:space="preserve">
          <source>JSX' docs suggest you be more explicit, write self-commenting code, and use a comparison to force to a Boolean.</source>
          <target state="translated">Los documentos de JSX sugieren ser más explícitos,escribir código de autocomentario y usar una comparación para forzar a un booleano.</target>
        </trans-unit>
        <trans-unit id="857f728eac2339b6a141ba1d44e27519c2166bbc" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;strong&gt;these &lt;em&gt;are JSX &amp;amp; Typescript conventions&lt;/em&gt;, not ones inherent to JavaScript&lt;/strong&gt;.</source>
          <target state="translated">Tenga en cuenta que &lt;strong&gt;estas &lt;em&gt;son convenciones JSX y mecanografiadas&lt;/em&gt; , no inherentes a JavaScript&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="558b0b10df23ff62727f0cdf06a369839b8ba0b0" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; in use.</source>
          <target state="translated">A saber, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; en uso.</target>
        </trans-unit>
        <trans-unit id="71a6705b7fa3ec15cdb9c15f74c0a2866a4f8b3e" translate="yes" xml:space="preserve">
          <source>Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.</source>
          <target state="translated">Naturalmente,todo esto es lo mismo que simplemente escribir algo,pero los paréntesis añadidos podrían ayudar a hacerlo más comprensible.</target>
        </trans-unit>
        <trans-unit id="062b9d1606d85c2c91b697df5b29f343f34bfd4f" translate="yes" xml:space="preserve">
          <source>Note that there are some &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;unintuitive cases&lt;/a&gt; where a boolean will be cast to a number (&lt;code&gt;true&lt;/code&gt; is cast to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;) when comparing a boolean to a number. In this case, &lt;code&gt;!!&lt;/code&gt; might be mentally useful. Though, again, &lt;strong&gt;these are cases where you're comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake.&lt;/strong&gt;&lt;code&gt;if (-1)&lt;/code&gt; is still the way to go here.</source>
          <target state="translated">Tenga en cuenta que hay algunos &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;casos poco intuitivos&lt;/a&gt; en los que un booleano se convertir&amp;aacute; en un n&amp;uacute;mero ( &lt;code&gt;true&lt;/code&gt; se convierte en &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; en &lt;code&gt;0&lt;/code&gt; ) al comparar un booleano con un n&amp;uacute;mero. En este caso, &lt;code&gt;!!&lt;/code&gt; puede ser mentalmente &amp;uacute;til Aunque, de nuevo, &lt;strong&gt;estos son casos en los que se compara un booleano no booleano con un booleano de tipo r&amp;iacute;gido, lo cual es un error grave.&lt;/strong&gt; &lt;code&gt;if (-1)&lt;/code&gt; sigue siendo el camino a seguir aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="57d186fffc848f3760d873fa6a5efef0c4b69fd9" translate="yes" xml:space="preserve">
          <source>One fix involves the bangbang, which coerces &lt;code&gt;0&lt;/code&gt; into &lt;code&gt;!!0&lt;/code&gt;, which is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Una soluci&amp;oacute;n implica el bangbang, que obliga a &lt;code&gt;0&lt;/code&gt; a &lt;code&gt;!!0&lt;/code&gt; , lo cual es &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a6f54cbcb01cbe0a3333b72e4ff3a962a0f801e" translate="yes" xml:space="preserve">
          <source>One use is to lossily compress an object to its truth value, so that your code isn't holding a reference to a big object and keeping it alive. Assigning &lt;code&gt;!!some_big_object&lt;/code&gt; to a variable instead of &lt;code&gt;some_big_object&lt;/code&gt; lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as &lt;code&gt;null&lt;/code&gt; or the undefined value, such as browser feature detection.</source>
          <target state="translated">Un uso es comprimir con p&amp;eacute;rdida un objeto a su valor de verdad, para que su c&amp;oacute;digo no tenga una referencia a un objeto grande y lo mantenga vivo. Al asignar &lt;code&gt;!!some_big_object&lt;/code&gt; a una variable en lugar de &lt;code&gt;some_big_object&lt;/code&gt; , vamos al recolector de basura. Esto es &amp;uacute;til para casos que producen un objeto o un valor falso como &lt;code&gt;null&lt;/code&gt; o un valor indefinido, como la detecci&amp;oacute;n de caracter&amp;iacute;sticas del navegador.</target>
        </trans-unit>
        <trans-unit id="161e7eb8bec71d838abd41540cca030c08d6f7f6" translate="yes" xml:space="preserve">
          <source>Please check code snippet out below &lt;strong&gt;&amp;darr;&lt;/strong&gt;</source>
          <target state="translated">Verifique el fragmento de c&amp;oacute;digo a continuaci&amp;oacute;n &lt;strong&gt;&amp;darr;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9c634cfd1a38a3aa345e046738679df22d80362" translate="yes" xml:space="preserve">
          <source>Practical uses</source>
          <target state="translated">Usos prácticos</target>
        </trans-unit>
        <trans-unit id="114da967498be8e2c2cdf7df8db42e88ebd380c7" translate="yes" xml:space="preserve">
          <source>Pretend we have &lt;code&gt;myVar1 = 0;&lt;/code&gt; and &lt;code&gt;myVar2 = undefined;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;myVar1 = 0;&lt;/code&gt; que tenemos myVar1 = 0; y &lt;code&gt;myVar2 = undefined;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f2915a66e774b1c83f8a2a3e89284ac648434e" translate="yes" xml:space="preserve">
          <source>Real World Example &quot;Test IE version&quot;:</source>
          <target state="translated">Ejemplo del mundo real &quot;Prueba de la versión IE&quot;:</target>
        </trans-unit>
        <trans-unit id="b39d3fef53ba3ed826f8428d58a2371af89a4e7d" translate="yes" xml:space="preserve">
          <source>Returns boolean value of a variable.</source>
          <target state="translated">Devuelve el valor booleano de una variable.</target>
        </trans-unit>
        <trans-unit id="fc98ae78ccf4552e39bcf193255cd5a8ae570858" translate="yes" xml:space="preserve">
          <source>Same deal in Typescript: If you have a function that returns a boolean (or you're assigning a value to a boolean variable), you [usually] can't return/assign a boolean-y value; it has to be a strongly typed boolean. This means, &lt;strong&gt;iff &lt;code&gt;myObject&lt;/code&gt; is strongly typed&lt;/strong&gt;, &lt;code&gt;return !myObject;&lt;/code&gt; works for a function returning a boolean, but &lt;code&gt;return myObject;&lt;/code&gt; doesn't. You have to &lt;code&gt;return !!myObject&lt;/code&gt; to match Typescript's expectations.</source>
          <target state="translated">El mismo trato en Typecript: si tiene una funci&amp;oacute;n que devuelve un valor booleano (o est&amp;aacute; asignando un valor a una variable booleana), [generalmente] no puede devolver / asignar un valor booleano-y; Tiene que ser un booleano fuertemente tipado. Esto significa que &lt;strong&gt;si &lt;code&gt;myObject&lt;/code&gt; est&amp;aacute; fuertemente tipado&lt;/strong&gt; , &lt;code&gt;return !myObject;&lt;/code&gt; funciona para una funci&amp;oacute;n que devuelve un valor booleano, pero &lt;code&gt;return myObject;&lt;/code&gt; no lo hace Tienes que &lt;code&gt;return !!myObject&lt;/code&gt; para que coincida con las expectativas de Typecript.</target>
        </trans-unit>
        <trans-unit id="03d3dfc9a836826357b793d282380cd7f94081b6" translate="yes" xml:space="preserve">
          <source>See &quot;== and !=&quot; from &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint's directions&lt;/a&gt; (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:</source>
          <target state="translated">Vea &quot;== y! =&quot; &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;De las instrucciones&lt;/a&gt; de JSLint (nota: Crockford est&amp;aacute; moviendo su sitio un poco; ese enlace puede morir en alg&amp;uacute;n momento) por un poco sobre por qu&amp;eacute;:</target>
        </trans-unit>
        <trans-unit id="b77b945dc1e2fb58fae032d74373f3a357e30b37" translate="yes" xml:space="preserve">
          <source>Simply casting :(</source>
          <target state="translated">Simplemente el casting :(</target>
        </trans-unit>
        <trans-unit id="6a0157727338f2b7b3fe3318d34c2684d92b3ba2" translate="yes" xml:space="preserve">
          <source>So  it's like using &lt;code&gt;Boolean&lt;/code&gt; function in javascript, but easy and shorter way to convert a value to boolean:</source>
          <target state="translated">Entonces, es como usar &lt;code&gt;Boolean&lt;/code&gt; funci&amp;oacute;n booleana en javascript, pero es una forma f&amp;aacute;cil y m&amp;aacute;s corta de convertir un valor a booleano:</target>
        </trans-unit>
        <trans-unit id="c4992f9e1d0a43038d9ca1117fe08701149b40b0" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;!!&lt;/code&gt; is not an operator, it's just the &lt;code&gt;!&lt;/code&gt; operator twice.</source>
          <target state="translated">Entonces &lt;code&gt;!!&lt;/code&gt; no es un operador, es solo el &lt;code&gt;!&lt;/code&gt; operador dos veces.</target>
        </trans-unit>
        <trans-unit id="0addbe39410a730dff513bf6537d8856157b56c9" translate="yes" xml:space="preserve">
          <source>So many answers doing half the work. Yes, &lt;code&gt;!!X&lt;/code&gt; could be read as &quot;the truthiness of X [represented as a boolean]&quot;. But &lt;code&gt;!!&lt;/code&gt; isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. &lt;code&gt;!!myVar === true&lt;/code&gt; is the same as just &lt;code&gt;myVar&lt;/code&gt;. Comparing &lt;code&gt;!!X&lt;/code&gt; to a &quot;real&quot; boolean isn't really useful.</source>
          <target state="translated">Tantas respuestas haciendo la mitad del trabajo. S&amp;iacute;, &lt;code&gt;!!X&lt;/code&gt; podr&amp;iacute;a leerse como &quot;la veracidad de X [representada como un booleano]&quot;. Pero &lt;code&gt;!!&lt;/code&gt; pr&amp;aacute;cticamente no es tan importante para determinar si una sola variable es (o incluso si muchas variables son) verdadera o falsa. &lt;code&gt;!!myVar === true&lt;/code&gt; es lo mismo que solo &lt;code&gt;myVar&lt;/code&gt; . Comparar &lt;code&gt;!!X&lt;/code&gt; con un booleano &quot;real&quot; no es realmente &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="014ab2f522034cc3c77ca7c114cbd4670167db8e" translate="yes" xml:space="preserve">
          <source>So now if you have a truthy for both &lt;em&gt;or&lt;/em&gt; a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your &lt;code&gt;errorObjects&lt;/code&gt; collection.</source>
          <target state="translated">Entonces, si tiene una verdad para ambos &lt;em&gt;o&lt;/em&gt; una falsa para el nombre y la edad del c&amp;oacute;nyuge, puede continuar. De lo contrario, solo tiene un campo con un valor (o un matrimonio arreglado muy temprano) y necesita crear un error adicional en su colecci&amp;oacute;n &lt;code&gt;errorObjects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e63cc48d4173484ca47b8b9c48f21169296682e7" translate="yes" xml:space="preserve">
          <source>So the only place you'd really need to use &quot;boolean-cast variables&quot; would be if you had a situation where you're checking if both variables have the &lt;em&gt;same&lt;/em&gt; truthiness, right? That is, &lt;b&gt;use &lt;code&gt;!!&lt;/code&gt; if you need to see if two vars are &lt;em&gt;both truthy or both falsy&lt;/em&gt; (or not), that is, &lt;em&gt;of equal&lt;/em&gt; (or not) &lt;em&gt;truthiness&lt;/em&gt;.&lt;/b&gt;</source>
          <target state="translated">Entonces, el &amp;uacute;nico lugar en el que realmente necesitar&amp;iacute;a usar &quot;variables de conversi&amp;oacute;n booleana&quot; ser&amp;iacute;a si tuviera una situaci&amp;oacute;n en la que est&amp;eacute; verificando si ambas variables tienen la &lt;em&gt;misma&lt;/em&gt; veracidad, &amp;iquest;verdad? Es decir, &lt;b&gt;uso &lt;code&gt;!!&lt;/code&gt; &lt;/b&gt; &lt;b&gt;si necesita ver si dos vars son &lt;em&gt;ambos verdaderos o ambos falsos&lt;/em&gt; (o no), es decir, &lt;em&gt;de igual&lt;/em&gt; (o no) &lt;em&gt;veracidad&lt;/em&gt; .&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8fc0438c0801780b20fbecd73911dad21ef51b6" translate="yes" xml:space="preserve">
          <source>So to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!.</source>
          <target state="translated">Así que para obtener una respuesta negativa (o positiva)en ese caso tendrías que usar primero el operador ! para obtener una booleana,pero si quisieras comprobar el caso positivo usarías !!.</target>
        </trans-unit>
        <trans-unit id="6e23c1f4bfbfa0ccb58b6c59c222898580d75194" translate="yes" xml:space="preserve">
          <source>So you're converting a value to a boolean, then inverting it, then inverting it again.</source>
          <target state="translated">Así que estás convirtiendo un valor a un booleano,luego lo inviertes,y luego lo vuelves a invertir.</target>
        </trans-unit>
        <trans-unit id="70f19fcd06b0becbaad2b70e1d5cf4e4e3e27fee" translate="yes" xml:space="preserve">
          <source>Some of you probably noticed that in this specific example, one could simply check for a property using the slightly &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;more performant&lt;/a&gt;&lt;/strong&gt; means of checking if the object in question &lt;em&gt;has&lt;/em&gt; a property. There are two ways to do this:</source>
          <target state="translated">Algunos de ustedes probablemente notaron que en este ejemplo espec&amp;iacute;fico, uno simplemente podr&amp;iacute;a verificar una propiedad utilizando los medios ligeramente &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;m&amp;aacute;s eficaces&lt;/a&gt;&lt;/strong&gt; para verificar si el objeto en cuesti&amp;oacute;n &lt;em&gt;tiene&lt;/em&gt; una propiedad. Hay dos maneras de hacer esto:</target>
        </trans-unit>
        <trans-unit id="4b46f5ed42b9b9e328c2f46362683a228c43e509" translate="yes" xml:space="preserve">
          <source>Some operators in JavaScript perform implicit type conversions, and are sometimes
used for type conversion.</source>
          <target state="translated">Algunos operadores en JavaScript realizan conversiones de tipos implícitas,y a veces se utilizan para la conversión de tipos.</target>
        </trans-unit>
        <trans-unit id="ea085d9130b086f1623397b738adcbac23d6d7e9" translate="yes" xml:space="preserve">
          <source>That is...</source>
          <target state="translated">Eso es...</target>
        </trans-unit>
        <trans-unit id="82fc7d92ba7e869e36f27a18325c4d16d5a80178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; construct is a simple way of turning any JavaScript expression into
its Boolean equivalent.</source>
          <target state="translated">El &lt;code&gt;!!&lt;/code&gt; construir es una forma simple de convertir cualquier expresi&amp;oacute;n de JavaScript en su equivalente booleano.</target>
        </trans-unit>
        <trans-unit id="90d1a7ed711f96e90a1182e13fa7e55e0596693e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.</source>
          <target state="translated">El &lt;code&gt;!!&lt;/code&gt; El operador asegura a la herramienta Lint que lo que escribi&amp;oacute; es lo que quiso decir: realice esta operaci&amp;oacute;n y luego tome el valor verdadero del resultado.</target>
        </trans-unit>
        <trans-unit id="eabc5d96ac71e6f38058420dd87159a58d3314a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements and the &lt;code&gt;?&lt;/code&gt; operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and &lt;code&gt;null&lt;/code&gt; are both false.</source>
          <target state="translated">Las declaraciones &lt;code&gt;if&lt;/code&gt; y &lt;code&gt;while&lt;/code&gt; y el &lt;code&gt;?&lt;/code&gt; El operador utiliza valores de verdad para determinar qu&amp;eacute; rama de c&amp;oacute;digo ejecutar. Por ejemplo, los n&amp;uacute;meros cero y NaN y la cadena vac&amp;iacute;a son falsos, pero otros n&amp;uacute;meros y cadenas son verdaderos. Los objetos son verdaderos, pero el valor indefinido y &lt;code&gt;null&lt;/code&gt; son falsos.</target>
        </trans-unit>
        <trans-unit id="29d047ae2b1b9b41221cc9a49cebe8c72ef84804" translate="yes" xml:space="preserve">
          <source>The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r\n' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.</source>
          <target state="translated">Los operadores ==y !=hacen la coacción antes de comparar.Esto es malo porque hace que ' \t\r\N ==0 sea cierto.Esto puede enmascarar errores de tipo.JSLint no puede determinar de forma fiable si ==se está usando correctamente,así que es mejor no usar ==y !=en absoluto y usar siempre los operadores más fiables ===y !==en su lugar.</target>
        </trans-unit>
        <trans-unit id="19d8f9dad8485f308ad86d92258b4c919e2fb866" translate="yes" xml:space="preserve">
          <source>The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; are both &quot;truthy&quot; and we will continue down the so-called &quot;&amp;amp;&amp;amp; chain&quot; to the next value to the right.</source>
          <target state="translated">El valor anterior devuelve indefinido, pero si tiene una cadena vac&amp;iacute;a, falsa, nula, 0, indefinida, esos valores regresar&amp;aacute;n y tan pronto como los encontremos en la cadena, &lt;code&gt;[]&lt;/code&gt; y &lt;code&gt;{}&lt;/code&gt; son ambos &quot;verdaderos&quot; y continuaremos hacia abajo llamado &quot;&amp;amp;&amp;amp; chain&quot; al siguiente valor a la derecha.</target>
        </trans-unit>
        <trans-unit id="b6f0570101450478158dcd94c3db9bdc410dbccf" translate="yes" xml:space="preserve">
          <source>The above's not so useful. &lt;code&gt;if (!0)&lt;/code&gt; gives you the same results as &lt;code&gt;if (!!0 === false)&lt;/code&gt;. I can't think of a good case for casting a variable to boolean and then comparing to a &quot;true&quot; boolean.</source>
          <target state="translated">Lo anterior no es tan &amp;uacute;til. &lt;code&gt;if (!0)&lt;/code&gt; le da los mismos resultados que &lt;code&gt;if (!!0 === false)&lt;/code&gt; . No puedo pensar en un buen caso para convertir una variable en booleana y luego compararla con una booleana &quot;verdadera&quot;.</target>
        </trans-unit>
        <trans-unit id="281762abc14819a66dcacbfde55f5e8401270f1d" translate="yes" xml:space="preserve">
          <source>The context in which I saw this was,</source>
          <target state="translated">El contexto en el que vi esto fue,</target>
        </trans-unit>
        <trans-unit id="acc6b507b28fe734085a51694ffb662d2f97612f" translate="yes" xml:space="preserve">
          <source>The double &quot;not&quot; in this case is quite simple.  It is simply two &lt;code&gt;not&lt;/code&gt;s back to back.</source>
          <target state="translated">El doble &quot;no&quot; en este caso es bastante simple. Es simplemente dos &lt;code&gt;not&lt;/code&gt; s consecutivos.</target>
        </trans-unit>
        <trans-unit id="531d1ca78f0741ca59c6f0a6607b3ea3cdc4a6d9" translate="yes" xml:space="preserve">
          <source>The double negation operator &lt;code&gt;!!&lt;/code&gt; calculates the truth value of a value. It's actually two operators, where &lt;code&gt;!!x&lt;/code&gt; means &lt;code&gt;!(!x)&lt;/code&gt;, and behaves as follows:</source>
          <target state="translated">&amp;iexcl;El operador de doble negaci&amp;oacute;n &lt;code&gt;!!&lt;/code&gt; calcula el valor de verdad de un valor. En realidad son dos operadores, donde &lt;code&gt;!!x&lt;/code&gt; significa &lt;code&gt;!(!x)&lt;/code&gt; , y se comporta de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0fedba5c4ec19ca80540448ef2226b8d7209ad69" translate="yes" xml:space="preserve">
          <source>The exception for Typescript? If &lt;code&gt;myObject&lt;/code&gt; was an &lt;code&gt;any&lt;/code&gt;, you're back in JavaScript's Wild West and can return it without &lt;code&gt;!!&lt;/code&gt;, even if your return type is a boolean.</source>
          <target state="translated">&amp;iquest;La excepci&amp;oacute;n para el mecanografiado? &amp;iexcl;Si &lt;code&gt;myObject&lt;/code&gt; era un &lt;code&gt;any&lt;/code&gt; , est&amp;aacute;s de vuelta en el Salvaje Oeste de JavaScript y puedes devolverlo sin &lt;code&gt;!!&lt;/code&gt; , incluso si su tipo de retorno es booleano.</target>
        </trans-unit>
        <trans-unit id="e4d67b97b47952ce6811073a8a2a38486c684c78" translate="yes" xml:space="preserve">
          <source>The first bang forces the js engine to run &lt;code&gt;Boolean(x)&lt;/code&gt; but also has the side effect of inverting the value.  So the second bang undoes the side effect.</source>
          <target state="translated">La primera explosi&amp;oacute;n fuerza al motor js a ejecutar &lt;code&gt;Boolean(x)&lt;/code&gt; pero tambi&amp;eacute;n tiene el efecto secundario de invertir el valor. Entonces, la segunda explosi&amp;oacute;n deshace el efecto secundario.</target>
        </trans-unit>
        <trans-unit id="fe7b25df5389abed33b3b0b02607f02a5ccbe313" translate="yes" xml:space="preserve">
          <source>The first one simply &quot;inverts&quot; the truthy or falsey value, resulting in an actual boolean type, and then the second one &quot;inverts&quot; it back again to it's original state, but now in an actual boolean value.  That way you have consistency:</source>
          <target state="translated">El primero simplemente &quot;invierte&quot; el valor de verdad o falso,resultando en un tipo booleano real,y luego el segundo lo &quot;invierte&quot; de nuevo a su estado original,pero ahora en un valor booleano real.De esta manera se obtiene consistencia:</target>
        </trans-unit>
        <trans-unit id="7bbf601d501a5f0c41724feba5edab84aa91cd28" translate="yes" xml:space="preserve">
          <source>The trick here is the chain of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;s will return &lt;strong&gt;the first falsey value&lt;/strong&gt; it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the &lt;code&gt;b.foo.bar&lt;/code&gt; statement, and we get no error.</source>
          <target state="translated">El truco aqu&amp;iacute; es que la cadena de &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; s devolver&amp;aacute; &lt;strong&gt;el primer valor de falsey&lt;/strong&gt; que encuentre, y esto se puede alimentar a una declaraci&amp;oacute;n if, etc. As&amp;iacute; que si b.foo no est&amp;aacute; definido, volver&amp;aacute; indefinido y omitir&amp;aacute; el &lt;code&gt;b.foo.bar&lt;/code&gt; declaraci&amp;oacute;n, y no recibimos ning&amp;uacute;n error.</target>
        </trans-unit>
        <trans-unit id="f362651fc7a92ae9f0a9673d4c5486b2f3f73825" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!false&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">La verdad es que &lt;code&gt;false&lt;/code&gt; no es &lt;code&gt;true&lt;/code&gt; ( &lt;code&gt;!false&lt;/code&gt; por eso ! Falso da como resultado &lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="a45301cb714edcffab6f1d258022757ae0ecd7bd" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!!false&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">La verdad es que &lt;code&gt;false&lt;/code&gt; no &lt;em&gt;es&lt;/em&gt; &lt;code&gt;false&lt;/code&gt; (es por eso que &lt;code&gt;!!false&lt;/code&gt; da como resultado &lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="dc6dfe93853155dde81483486981f53f459fca48" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!true&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">La verdad es que &lt;code&gt;true&lt;/code&gt; no es &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;!true&lt;/code&gt; por eso ! Verdadero da como resultado &lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="de5886521d1b8bae3b9e573aa8de49514dcf5e6d" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!!true&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">La verdad es que &lt;code&gt;true&lt;/code&gt; no &lt;em&gt;es&lt;/em&gt; &lt;code&gt;true&lt;/code&gt; (es por eso que &lt;code&gt;!!true&lt;/code&gt; resulta en &lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="3c5ec1883ea648c4eac15e44a0e47cc089c821db" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;!&lt;/code&gt; operator converts its operand to a boolean and negates it.</source>
          <target state="translated">El unario &lt;code&gt;!&lt;/code&gt; El operador convierte su operando en un booleano y lo niega.</target>
        </trans-unit>
        <trans-unit id="33306e297fa07aa22ffeca48a2d3b1ca6f355960" translate="yes" xml:space="preserve">
          <source>Then you do &lt;code&gt;!0&lt;/code&gt;, it will be converted to boolean and be evaluated to &lt;code&gt;true&lt;/code&gt;, because 0 is &lt;code&gt;falsy&lt;/code&gt;, so you get the reversed value and converted to boolean, so it gets evaluated to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;Entonces lo hace &lt;code&gt;!0&lt;/code&gt; , se convertir&amp;aacute; a booleano y se evaluar&amp;aacute; a &lt;code&gt;true&lt;/code&gt; , porque 0 es &lt;code&gt;falsy&lt;/code&gt; , por lo que obtiene el valor invertido y se convierte a booleano, por lo que se eval&amp;uacute;a a &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71ab5eac91ed7f0607dae3a2cf1d7e72a4ca4e97" translate="yes" xml:space="preserve">
          <source>This fact lead to the following idiom that you can see in your source code:</source>
          <target state="translated">Este hecho lleva al siguiente idioma que puedes ver en tu código fuente:</target>
        </trans-unit>
        <trans-unit id="5206aead5c0929d44fb460d6a6d755b4275d68d5" translate="yes" xml:space="preserve">
          <source>This question has been answered quite thoroughly, but I'd like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.</source>
          <target state="translated">Esta pregunta ha sido contestada bastante a fondo,pero me gustaría añadir una respuesta que espero sea lo más simplificada posible,haciendo que el significado de !! sea tan simple de entender como pueda ser.</target>
        </trans-unit>
        <trans-unit id="900a6ce54db6671d1163b4588fef81576caa9d76" translate="yes" xml:space="preserve">
          <source>Tons of great answers here, but if you've read down this far, this helped me to 'get it'. Open the console on Chrome (etc), and start typing:</source>
          <target state="translated">Toneladas de grandes respuestas aquí,pero si has leído hasta aquí,esto me ayudó a &quot;conseguirlo&quot;.Abre la consola en Chrome (etc),y empieza a escribir:</target>
        </trans-unit>
        <trans-unit id="b5a7a294200e3cb34da2a97adf5d130ba6c38c00" translate="yes" xml:space="preserve">
          <source>Use logical not operator two times</source>
          <target state="translated">Use la lógica no el operador dos veces</target>
        </trans-unit>
        <trans-unit id="037ce300d2779ff07c53c4b5b8748bb947cb98bb" translate="yes" xml:space="preserve">
          <source>What is the !! (not not) operator in JavaScript</source>
          <target state="translated">¡¿Qué es el!? (no no)operador en JavaScript</target>
        </trans-unit>
        <trans-unit id="2bd5abc68757873bb182393e529f58b5f1764ea3" translate="yes" xml:space="preserve">
          <source>What we wish to determine in the comparison is the &quot;truth&quot; &lt;em&gt;about&lt;/em&gt; the value of a reference, not the &lt;em&gt;value of&lt;/em&gt; the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be &lt;em&gt;&lt;code&gt;false&lt;/code&gt;&lt;/em&gt; (or falsey), or if we expect the value not to be typeof &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">Lo que deseamos determinar en la comparaci&amp;oacute;n es la &quot;verdad&quot; &lt;em&gt;sobre&lt;/em&gt; el valor de una referencia, no el &lt;em&gt;valor de&lt;/em&gt; la referencia en s&amp;iacute;. Hay un caso de uso en el que podr&amp;iacute;amos querer saber la verdad sobre un valor, incluso si esperamos que el valor sea &lt;em&gt; &lt;code&gt;false&lt;/code&gt; &lt;/em&gt; (o falso), o si esperamos que el valor no sea typeof &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6dfeec064b00b28af55ee18d69a51869a08807e" translate="yes" xml:space="preserve">
          <source>What you gain with &lt;code&gt;!!&lt;/code&gt; is the ability to check the truthiness of multiple variables &lt;em&gt;against each other&lt;/em&gt; in a repeatable, standardized (and JSLint friendly) fashion.</source>
          <target state="translated">&amp;iexcl;Con qu&amp;eacute; ganas &lt;code&gt;!!&lt;/code&gt; es la capacidad de verificar la veracidad de m&amp;uacute;ltiples variables &lt;em&gt;entre s&amp;iacute;&lt;/em&gt; de manera repetible, estandarizada (y amigable con JSLint).</target>
        </trans-unit>
        <trans-unit id="d568b1f542f2ac7d26a5c47b5cb7b7775b67ea06" translate="yes" xml:space="preserve">
          <source>When used at the top level of a Boolean context (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;), the &lt;code&gt;!!&lt;/code&gt; operator is behaviorally a no-op. For example, &lt;code&gt;if (x)&lt;/code&gt; and &lt;code&gt;if (!!x)&lt;/code&gt; mean the same thing.</source>
          <target state="translated">Cuando se usa en el nivel superior de un contexto booleano ( &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; ), El &lt;code&gt;!!&lt;/code&gt; El operador es un comportamiento no operativo. Por ejemplo, &lt;code&gt;if (x)&lt;/code&gt; y &lt;code&gt;if (!!x)&lt;/code&gt; significan lo mismo.</target>
        </trans-unit>
        <trans-unit id="15bdd7d9c3451db43373e5025a0173bdf0c60369" translate="yes" xml:space="preserve">
          <source>Why?  Because &lt;code&gt;document.getElementById()&lt;/code&gt; is a &quot;truthy&quot; expression that will evaluate as true in this &lt;code&gt;if()&lt;/code&gt; statement, but it is not an actual boolean value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute;? Porque &lt;code&gt;document.getElementById()&lt;/code&gt; es una expresi&amp;oacute;n &quot;veraz&quot; que se evaluar&amp;aacute; como verdadera en esta declaraci&amp;oacute;n &lt;code&gt;if()&lt;/code&gt; , pero no es un valor booleano real de &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2562e78de1b3256bca3da91141bb0297a876088d" translate="yes" xml:space="preserve">
          <source>and instead of</source>
          <target state="translated">y en lugar de</target>
        </trans-unit>
        <trans-unit id="6ff7395099aa52cc1ac2567047b5dc904e83a97c" translate="yes" xml:space="preserve">
          <source>but we don't want the reversed &lt;strong&gt;boolean version&lt;/strong&gt; of the value, so we can reverse it again to get our result! That's why we use another &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">pero no queremos la &lt;strong&gt;versi&amp;oacute;n booleana&lt;/strong&gt; invertida del valor, por lo que podemos invertirla nuevamente para obtener nuestro resultado. &amp;iexcl;Por eso usamos otro &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1136ebda06acfbb946c27883e9c70a00d96a8324" translate="yes" xml:space="preserve">
          <source>here is a piece of code from angular js</source>
          <target state="translated">aquí hay un pedazo de código de la js angular</target>
        </trans-unit>
        <trans-unit id="07aee702dc1bc81b24b43ca8e96d3a68f77ddfba" translate="yes" xml:space="preserve">
          <source>if requestAnimationFrame was assinged undefined then
!requestAnimationFrame would be true and one more ! of it would be false</source>
          <target state="translated">Si la petición &quot;Marco de Animación&quot; estuviera indefinida,entonces,la petición &quot;Marco de Animación&quot; sería verdadera y una más sería falsa.</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">es la misma que</target>
        </trans-unit>
        <trans-unit id="fb81871808eeba6b79f000511077e0392e5040fe" translate="yes" xml:space="preserve">
          <source>it can be achieved by checking in following way in general:</source>
          <target state="translated">se puede conseguir comprobando de la siguiente manera en general:</target>
        </trans-unit>
        <trans-unit id="bf9bb582fda3d69616ba7956287f904859457f58" translate="yes" xml:space="preserve">
          <source>just say</source>
          <target state="translated">Sólo di...</target>
        </trans-unit>
        <trans-unit id="dc01c6b7487aab92695f7ba918540cf5051f72f4" translate="yes" xml:space="preserve">
          <source>say</source>
          <target state="translated">say</target>
        </trans-unit>
        <trans-unit id="287b978241585895eb95865fc85abb7f32f60d1e" translate="yes" xml:space="preserve">
          <source>so if requestAnimationFrame was assigned a function
 then
!requestAnimationFrame would be false and one more ! of it would be true</source>
          <target state="translated">así que si a requestAnimationFrame se le asignara una función entonces! requestAnimationFrame sería falsa y una más! de ella sería verdadera</target>
        </trans-unit>
        <trans-unit id="7c2b4b647bd0e7cbaa828c353b4a7be55a9be894" translate="yes" xml:space="preserve">
          <source>the short way could be using !!</source>
          <target state="translated">el camino corto podría estar usando !!</target>
        </trans-unit>
        <trans-unit id="2b1fd3dee3545afca88dbce54f7f1d0f063a468f" translate="yes" xml:space="preserve">
          <source>their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame</source>
          <target state="translated">su intención es establecer rafSupported a verdadero o falso basado en la disponibilidad de la función en requestAnimationFrame</target>
        </trans-unit>
        <trans-unit id="7b247e535f27451042dc1de383c546cfcbe520d6" translate="yes" xml:space="preserve">
          <source>will BOTH return true, as expected.</source>
          <target state="translated">...ambos volverán a ser verdaderos,como se esperaba.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
