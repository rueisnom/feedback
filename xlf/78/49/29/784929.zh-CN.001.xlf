<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/784929">
    <body>
      <group id="784929">
        <trans-unit id="9d8ee90d447e634111f086fe5d63063e02604c04" translate="yes" xml:space="preserve">
          <source>! is &quot;boolean not&quot;, which essentially typecasts the value of &quot;enable&quot; to its boolean opposite. The second ! flips this value. So, &lt;code&gt;!!enable&lt;/code&gt; means &quot;not not enable,&quot; giving you the value of &lt;code&gt;enable&lt;/code&gt; as a boolean.</source>
          <target state="translated">！ 是&amp;ldquo; boolean not&amp;rdquo;，实际上将&amp;ldquo; enable&amp;rdquo;的值转换为与其相反的布尔值。 第二 ！ 翻转此值。 因此， &lt;code&gt;!!enable&lt;/code&gt; 表示&amp;ldquo;未启用&amp;rdquo;，为您提供了 &lt;code&gt;enable&lt;/code&gt; 值的布尔值。</target>
        </trans-unit>
        <trans-unit id="1267640ee6e890d8ceb635273042d73661945ffd" translate="yes" xml:space="preserve">
          <source>(please read code descriptions)</source>
          <target state="translated">(请阅读代码说明)</target>
        </trans-unit>
        <trans-unit id="dbc5329443fc97ea79e3d6fc7a7c08bb400f6cdb" translate="yes" xml:space="preserve">
          <source>... you might be surprised to see React render a &lt;code&gt;0&lt;/code&gt; when you have zero messages. You have to explicitly return false for JSX not to render. The above statement returns &lt;code&gt;0&lt;/code&gt;, which JSX happily renders, as it should. It can't tell you didn't have &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; (or something less contrived).</source>
          <target state="translated">...当您收到零条消息时，看到React将 &lt;code&gt;0&lt;/code&gt; 渲染可能会让您感到惊讶。 您必须显式返回false，JSX才会呈现。 上面的语句返回 &lt;code&gt;0&lt;/code&gt; ，这是JSX乐意呈现的。 它不能告诉您没有 &lt;code&gt;Count: {messageCount &amp;amp;&amp;amp; &amp;lt;div&amp;gt;Get your count to zero!&amp;lt;/div&amp;gt;}&lt;/code&gt; （或其他较不人为的东西）。</target>
        </trans-unit>
        <trans-unit id="c4b43c7ba8236eeadfe785d67215c403a6e6e119" translate="yes" xml:space="preserve">
          <source>...will NOT result in a true condition, and the code block will not be executed, even if the element does exist.</source>
          <target state="translated">...将不会导致一个真实的条件,并且代码块不会被执行,即使该元素确实存在。</target>
        </trans-unit>
        <trans-unit id="bd18c0553a45634b99d4953abd9dd07bb59545b2" translate="yes" xml:space="preserve">
          <source>3rd party libraries that expect explicit Boolean values</source>
          <target state="translated">第三方库期待显式布尔值</target>
        </trans-unit>
        <trans-unit id="05317c9a3565f977ff95a0b1172dd228b7234929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!0 === false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!!0 === false&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b16fdc2b982571586ffd6bc3139aa446dfb0262b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; converts the value to the right of it to its equivalent boolean value. (Think poor man's way of &quot;type-casting&quot;). Its &lt;em&gt;intent&lt;/em&gt; is usually to convey to the reader that the code does not care &lt;em&gt;what&lt;/em&gt; value is in the variable, but what it's &lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&quot;truth&quot; value&lt;/a&gt; is.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 将其右边的值转换为其等效的布尔值。 （想想穷人的&amp;ldquo;类型转换&amp;rdquo;方式）。 它的&lt;em&gt;目的&lt;/em&gt;通常是向读者传达代码并不关心变量中的值是什么，而是其&lt;a href=&quot;http://11heavens.com/falsy-and-truthy-in-javascript&quot;&gt;&amp;ldquo;真实&amp;rdquo;值&lt;/a&gt;是什么。</target>
        </trans-unit>
        <trans-unit id="de68e033596cd4f5d22f42c9c74a29c3813083dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; is not an operator. It is the double-use of &lt;code&gt;!&lt;/code&gt; -- which is the logical &quot;not&quot; operator.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 不是运算符。 这是双重用途 &lt;code&gt;!&lt;/code&gt; -逻辑上的&amp;ldquo;非&amp;rdquo;运算符。</target>
        </trans-unit>
        <trans-unit id="0c49aab7f0deeecf7c139cada81e75156b64a3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!&lt;/code&gt; it's using &lt;code&gt;NOT&lt;/code&gt; operation twice together, &lt;code&gt;!&lt;/code&gt; convert the value to a &lt;code&gt;boolean&lt;/code&gt; and reverse it, here is a simple example to see how &lt;code&gt;!!&lt;/code&gt; works:</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 一起使用两次 &lt;code&gt;NOT&lt;/code&gt; 操作 &lt;code&gt;!&lt;/code&gt; 将值转换为 &lt;code&gt;boolean&lt;/code&gt; 并将其反转，这是一个简单的示例，了解如何实现 &lt;code&gt;!!&lt;/code&gt; 作品：</target>
        </trans-unit>
        <trans-unit id="40472ff2de807d44da0389b6ed6c479fe97e450d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!expr&lt;/code&gt; returns a Boolean value (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) depending on the &lt;em&gt;truthiness&lt;/em&gt; of the expression. It makes more sense when used on non-boolean types. Consider these examples, especially the 3rd example and onward:</source>
          <target state="translated">&lt;code&gt;!!expr&lt;/code&gt; 根据表达式的&lt;em&gt;真实性&lt;/em&gt;返回布尔值（ &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）。 在非布尔类型上使用时更有意义。 考虑以下示例，尤其是第三个示例及以后的示例：</target>
        </trans-unit>
        <trans-unit id="c11c8b2ce2578dcc578b1ef73f483f4da8bddb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!foo&lt;/code&gt; applies the unary not operator twice and is used to cast to boolean type similar to the use of unary plus &lt;code&gt;+foo&lt;/code&gt; to cast to number and concatenating an empty string &lt;code&gt;''+foo&lt;/code&gt; to cast to string.</source>
          <target state="translated">&lt;code&gt;!!foo&lt;/code&gt; 两次应用一元非运算符，并用于转换为布尔类型，类似于使用一元加 &lt;code&gt;+foo&lt;/code&gt; 转换为数字并连接空字符串 &lt;code&gt;''+foo&lt;/code&gt; 转换为字符串。</target>
        </trans-unit>
        <trans-unit id="a3fbcf80055d72c6902769ea1b0b209d18d54c31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; is &lt;code&gt;!!0 === !!undefined&lt;/code&gt; and is true! Same truthiness! (In this case, both &quot;have a truthiness of falsy&quot;.)</source>
          <target state="translated">&lt;code&gt;!!myVar1 === !!myVar2&lt;/code&gt; 是 &lt;code&gt;!!0 === !!undefined&lt;/code&gt; ，是真的！ 同样的真实性！ （在这种情况下，两个&amp;ldquo;都具有虚假的真实性&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="d3afe30734c2565c10167b232d767321261e858a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!!x&lt;/code&gt; is shorthand for &lt;code&gt;Boolean(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;!!x&lt;/code&gt; 是 &lt;code&gt;Boolean(x)&lt;/code&gt; 的简写</target>
        </trans-unit>
        <trans-unit id="721b932e6bc1cc17c9cd50fea7dc4b8b7a6ad668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&lt;/code&gt; is &lt;em&gt;NOT&lt;/em&gt;.  So &lt;code&gt;!true&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!false&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;!0&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!1&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; &lt;em&gt;不是&lt;/em&gt; 。 所以 &lt;code&gt;!true&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;!false&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;!0&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;!1&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a84f888f6e0a39683c0e570def98bcac6595167f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0 === false&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0 === false&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="601bab0f9b947357bf0bbc8ebc5b625e5e7af331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; is a bitwise AND; &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; is a logical AND. &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; (a false value); &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;if (a &amp;amp; b)&lt;/code&gt; 是按位AND； &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; 是逻辑AND。 &lt;code&gt;2 &amp;amp; 5&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; （错误值）； &lt;code&gt;2 &amp;amp;&amp;amp; 5&lt;/code&gt; 是真的。</target>
        </trans-unit>
        <trans-unit id="fe8e944fda44e395ec8eb52766a2d42b25be5541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if (a = b)&lt;/code&gt; is assignment followed by use of the truth value of &lt;code&gt;b&lt;/code&gt;; &lt;code&gt;if (a == b)&lt;/code&gt; is an equality comparison.</source>
          <target state="translated">&lt;code&gt;if (a = b)&lt;/code&gt; 是赋值，然后使用 &lt;code&gt;b&lt;/code&gt; 的真值； &lt;code&gt;if (a == b)&lt;/code&gt; 是一个相等比较。</target>
        </trans-unit>
        <trans-unit id="a4c32abc5c7932aafafe8b72767dd17a9e12923e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myVar1 === myVar2&lt;/code&gt; is &lt;code&gt;0 === undefined&lt;/code&gt; and is obviously false.</source>
          <target state="translated">&lt;code&gt;myVar1 === myVar2&lt;/code&gt; 为 &lt;code&gt;0 === undefined&lt;/code&gt; ，显然为false。</target>
        </trans-unit>
        <trans-unit id="7899bf510c8f1081aeced8dc9e82c3717d6f3a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is &lt;em&gt;not&lt;/em&gt; not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!!&lt;/code&gt; &lt;/strong&gt; 确定&lt;em&gt;不是&lt;/em&gt;值的&amp;ldquo;真相&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="05ffd1c973d25f3fa642c01bde2e2d7437ff0b40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt; determines the &quot;truth&quot; of what a value is not:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;!&lt;/code&gt; &lt;/strong&gt; 确定值不是什么的&amp;ldquo;真相&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="6d9ad97a5f3ee3fba703f038b8cb73c50bd30761" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Brew some tea:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;冲泡一些茶：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80a5baf090dcfffcd4153848ee43b313dff5f952" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But wait, there's more!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但是，等等，还有更多！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3574ce92cb57aeb1f7ff451de1bbe4886856bb60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT 24 Oct 2017, 6 Feb 19:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑2017年10月24日，19年2月6日：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a055a42c402ff7009188d3b50ace76756b7075b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In practice:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在实践中：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36ed1544d47aa0950bc63b80406386d69ec830fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In theory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;理论上：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a17136c4cff424debad877c2ecfe86e4318d16b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;P.S.&lt;/strong&gt; Another way of doing the same thing is &lt;code&gt;(b || {}).foo&lt;/code&gt;, because if b is undefined then &lt;code&gt;b || {}&lt;/code&gt; will be &lt;code&gt;{}&lt;/code&gt;, and you'll be accessing a value in an empty object (no error) instead of trying to access a value within &quot;undefined&quot; (causes an error).  So, &lt;code&gt;(b || {}).foo&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; and &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; is the same as &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;PS&lt;/strong&gt;做同一件事的另一种方法是 &lt;code&gt;(b || {}).foo&lt;/code&gt; ，因为如果b未定义，则 &lt;code&gt;b || {}&lt;/code&gt; {}将是 &lt;code&gt;{}&lt;/code&gt; ，您将访问一个空对象中的值（无错误），而不是尝试访问&amp;ldquo;未定义&amp;rdquo;中的值（导致错误）。 因此， &lt;code&gt;(b || {}).foo&lt;/code&gt; 与 &lt;code&gt;b &amp;amp;&amp;amp; b.foo&lt;/code&gt; 相同，而 &lt;code&gt;((b || {}).foo || {}).bar&lt;/code&gt; 与 &lt;code&gt;b &amp;amp;&amp;amp; b.foo &amp;amp;&amp;amp; b.foo.bar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b8f384febfdd7d7361b695f817e89853b5220d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We digress...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我们离题了...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="022b17591a08c04d294c7aa2b97cef1c499d1b80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;it means !true= false&lt;br/&gt;
 and  !!true = true&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这意味着！true = false&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt; &lt;strong&gt;和!! true = true&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4626b6d0fd1defd823f8f27a6ee0096c94607fb" translate="yes" xml:space="preserve">
          <source>A third use is to produce logical XOR and logical XNOR. In both C and JavaScript, &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; performs a logical AND (true if both sides are true), and &lt;code&gt;a &amp;amp; b&lt;/code&gt; performs a bitwise AND. &lt;code&gt;a || b&lt;/code&gt; performs a logical OR (true if at least one are true), and &lt;code&gt;a | b&lt;/code&gt; performs a bitwise OR. There's a bitwise XOR (exclusive OR) as &lt;code&gt;a ^ b&lt;/code&gt;, but there's no built-in operator for logical XOR (true if exactly one side is true). You might, for example, want to allow the user to enter text in exactly one of two fields. What you can do is convert each to a truth value and compare them: &lt;code&gt;!!x !== !!y&lt;/code&gt;.</source>
          <target state="translated">第三种用途是产生逻辑XOR和逻辑XNOR。 在C和JavaScript中， &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 执行逻辑AND（如果双方均为真，则为true），而 &lt;code&gt;a &amp;amp; b&lt;/code&gt; 执行按位AND。 &lt;code&gt;a || b&lt;/code&gt; b执行逻辑OR（如果至少一个为true，则为true），而 &lt;code&gt;a | b&lt;/code&gt; b执行按位或。 有一个按位XOR（异或）作为 &lt;code&gt;a ^ b&lt;/code&gt; ，但是没有用于逻辑XOR的内置运算符（如果恰好一侧为true，则为true）。 例如，您可能希望允许用户在两​​个字段之一中恰好输入文本。 您可以做的是将每个转换为真值并进行比较： &lt;code&gt;!!x !== !!y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="937148e0ba3cf2e3a6ad662dce342d4574705192" translate="yes" xml:space="preserve">
          <source>After seeing all these great answers, I would like to add another reason for using  &lt;code&gt;!!&lt;/code&gt;. Currenty I'm working in Angular 2-4 (TypeScript) and I want to return a boolean as &lt;code&gt;false&lt;/code&gt; when my user is not authenticated. If he isn't authenticated, the token-string would be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;. I can do this by using the next block of code:</source>
          <target state="translated">看到所有这些很棒的答案之后，我想补充一下使用 &lt;code&gt;!!&lt;/code&gt; 的另一个原因。 。 当前，我正在使用Angular 2-4（TypeScript），并且当我的用户未通过身份验证时，我想将布尔值返回为 &lt;code&gt;false&lt;/code&gt; 。 如果未通过身份验证，则令牌字符串将为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。 我可以通过使用下面的代码块来做到这一点：</target>
        </trans-unit>
        <trans-unit id="719bb016bfb2ea5208e53cc2ef5f67a057166604" translate="yes" xml:space="preserve">
          <source>And things get even crazier depending on your engine. WScript, for instance, wins the prize.</source>
          <target state="translated">而根据你的引擎,情况会变得更加疯狂。比如说,WScript,就能赢得大奖。</target>
        </trans-unit>
        <trans-unit id="d2e6426f3b2e591c60f6c55c2d312ca4857318d9" translate="yes" xml:space="preserve">
          <source>Another use, which I mentioned in an &lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;answer about C's corresponding &lt;code&gt;!!&lt;/code&gt; operator&lt;/a&gt;, is with &quot;lint&quot; tools that look for common typos and print diagnostics. For example, in both C and JavaScript, a few common typos for Boolean operations produce other behaviors whose output isn't quite as Boolean:</source>
          <target state="translated">我在&lt;a href=&quot;https://stackoverflow.com/a/35525827/2738262&quot;&gt;关于C的对应答案中&lt;/a&gt;提到的另一种用法 &lt;code&gt;!!&lt;/code&gt; 操作符带有&amp;ldquo;皮棉&amp;rdquo;工具，用于查找常见的错字和打印诊断信息。 例如，在C和JavaScript中，布尔运算的一些常见错别字都会产生其他行为，其输出与布尔值不太相同：</target>
        </trans-unit>
        <trans-unit id="5d7e80841153e3f0b33aa705ecbcdee928b5ed77" translate="yes" xml:space="preserve">
          <source>At first, the place you have:</source>
          <target state="translated">起初,你有的地方。</target>
        </trans-unit>
        <trans-unit id="37383f3a991b3aaf3607d0d306ed294c9e3535ec" translate="yes" xml:space="preserve">
          <source>Basically, &lt;code&gt;!!&lt;/code&gt; make us sure, the value we get is boolean, not falsy, truthy or string etc...</source>
          <target state="translated">基本上， &lt;code&gt;!!&lt;/code&gt; 确保我们得到的值是布尔值，不是虚假，真实或字符串等。</target>
        </trans-unit>
        <trans-unit id="f0db7bebe15c805ab3aec2ff3047007e131c1547" translate="yes" xml:space="preserve">
          <source>Because javascript has what are called &quot;truthy&quot; and &quot;falsey&quot; values, there are expressions that when evaluated in other expressions will result in a true or false condition, even though the value or expression being examined is not actually &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">因为javascript具有所谓的&amp;ldquo; truthy&amp;rdquo;和&amp;ldquo; falsey&amp;rdquo;值，所以有些表达式在其他表达式中求值时会产生true或false的条件，即使所检查的值或表达式实际上不是 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebcd804c817f36ef59a932affdb9a970bbb27d1b" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;some historical Windows jive&lt;/a&gt;, that'll output -1 in a message box! Try it in a cmd.exe prompt and see! But &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; still gives you 0, or WScript's &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;Look away. It's hideous.&lt;/a&gt;</source>
          <target state="translated">由于&lt;a href=&quot;https://stackoverflow.com/a/14462348/1028230&quot;&gt;Windows&lt;/a&gt;的一些历史记录 ，它将在消息框中输出-1！ 在cmd.exe提示中尝试一下，看看！ 但是 &lt;code&gt;WScript.echo(-1 == test())&lt;/code&gt; 仍然为您提供0，或者WScript为 &lt;code&gt;false&lt;/code&gt; 。 &lt;a href=&quot;https://www.google.com/search?q=look+away+I%27m+hideous&quot;&gt;别看&lt;/a&gt; 太可怕了</target>
        </trans-unit>
        <trans-unit id="34a3c4d1b09c4c334e45f565ff959b93e1297ce9" translate="yes" xml:space="preserve">
          <source>But if you &amp;rArr;</source>
          <target state="translated">但是如果你&amp;rArr;</target>
        </trans-unit>
        <trans-unit id="55af43b97047e9feca9827254a5bad346b4fb1ea" translate="yes" xml:space="preserve">
          <source>But if you see strange &lt;code&gt;0&lt;/code&gt;s in your rendered JSX, think loose falsy management.</source>
          <target state="translated">但是，如果在渲染的JSX中看到奇怪的 &lt;code&gt;0&lt;/code&gt; ，请考虑宽松的虚假管理。</target>
        </trans-unit>
        <trans-unit id="c3d9638bccd08789c5c96539764af9bdb9abbc4d" translate="yes" xml:space="preserve">
          <source>But this can be an issue when something is undefined.</source>
          <target state="translated">但是,当一些东西没有被定义时,这可能是一个问题。</target>
        </trans-unit>
        <trans-unit id="fc510cf59a92c328aac077d7719d62aac7a4811c" translate="yes" xml:space="preserve">
          <source>But what if I have two values I need to check for equal truthi/falsi-ness?</source>
          <target state="translated">但是,如果我有两个值需要检查真理性是否相等呢?</target>
        </trans-unit>
        <trans-unit id="0a33acba295ef44765fa6e094d5bf1d8422929b7" translate="yes" xml:space="preserve">
          <source>Comparing truthiness :)</source>
          <target state="translated">比较真实性:)</target>
        </trans-unit>
        <trans-unit id="c26332ba114f738a9008487cc2e7e1224052ab38" translate="yes" xml:space="preserve">
          <source>Consider a concise function which detects feature functionality (and in this case, platform compatibility) by way of &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;dynamic typing&lt;/a&gt;&lt;/strong&gt; (aka &quot;duck typing&quot;). We want to write a function that returns &lt;code&gt;true&lt;/code&gt; if a user's browser supports the HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; element, but we don't want the function to throw an error if &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is undefined; and we don't want to use &lt;code&gt;try ... catch&lt;/code&gt; to handle any possible errors (because they're gross); &lt;em&gt;and also&lt;/em&gt; we don't want to use a check inside the function that won't consistently reveal the truth about the feature (for example, &lt;code&gt;document.createElement('audio')&lt;/code&gt; will still create an element called &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; even if HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; is not supported).</source>
          <target state="translated">考虑一个简洁的功能，该功能通过&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Type_system#Dynamic_typing&quot;&gt;动态类型&lt;/a&gt;&lt;/strong&gt; （也称为&amp;ldquo;鸭子类型&amp;rdquo;）检测功能（在这种情况下为平台兼容性）。 如果用户的浏览器支持HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 元素，我们想编写一个返回 &lt;code&gt;true&lt;/code&gt; 的函数，但是如果 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 未定义，我们不希望该函数抛出错误。 而且我们不想使用 &lt;code&gt;try ... catch&lt;/code&gt; 来处理任何可能的错误（因为它们很严重）； &lt;em&gt;而且&lt;/em&gt;我们也不想在函数内部使用不会始终揭示功能真实性的检查（例如， &lt;code&gt;document.createElement('audio')&lt;/code&gt; 仍会创建一个名为 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 的元素，即使HTML5 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9c2bfed607f580ac4ac34ab9f08a0c6aa7cb0429" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;Object&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt;. If it was falsey (e.g. &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, etc.), it will be &lt;code&gt;false&lt;/code&gt;, otherwise, &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Object&lt;/code&gt; 转换为 &lt;code&gt;boolean&lt;/code&gt; 。 如果为假（例如 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;undefined&lt;/code&gt; 等），则为 &lt;code&gt;false&lt;/code&gt; ，否则为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7af2387329e42b1e1dcdbdc75737b43eb16b3b56" translate="yes" xml:space="preserve">
          <source>Double boolean negation. Often used to check if value is not undefined.</source>
          <target state="translated">双布林否定。通常用于检查值是否不是未定义。</target>
        </trans-unit>
        <trans-unit id="1378886488bff47eea733f621e4e6b0a3b97b140" translate="yes" xml:space="preserve">
          <source>Each function accepts an argument for a &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; and an &lt;code&gt;attribute&lt;/code&gt; to look for, but they each return different values based on what the comparisons determine.</source>
          <target state="translated">每个函数都接受 &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; 的参数和要查找的 &lt;code&gt;attribute&lt;/code&gt; ，但是它们各自根据比较确定的结果返回不同的值。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="1e86b051c400fed4e8f797a656375e775595e029" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; and &lt;code&gt;!!0 === false&lt;/code&gt;.</source>
          <target state="translated">例如： &lt;code&gt;!!&quot;he shot me down&quot; === true&lt;/code&gt; 和 &lt;code&gt;!!0 === false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0da32197e1f2c3ed9016c076548a9c1dc68c0878" translate="yes" xml:space="preserve">
          <source>For instance, &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;False in JSX (React) has a special meaning&lt;/a&gt; that's not triggered on simple falsiness. If you tried returning something like the following in your JSX, expecting an int in &lt;code&gt;messageCount&lt;/code&gt;...</source>
          <target state="translated">例如， &lt;a href=&quot;https://react-cn.github.io/react/tips/false-in-jsx.html&quot;&gt;JSX（React）中的False具有特殊含义&lt;/a&gt; ，不会因简单的虚假行为而触发。 如果您尝试在JSX中返回类似以下内容的内容，则期望 &lt;code&gt;messageCount&lt;/code&gt; 中的int ...</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">比如说:</target>
        </trans-unit>
        <trans-unit id="eaa9bb432088641bac3a4242e7ee096bd6cecd11" translate="yes" xml:space="preserve">
          <source>Here are the three approaches:</source>
          <target state="translated">以下是三种方法。</target>
        </trans-unit>
        <trans-unit id="f64e010c295a2870b0f4d659e488a6c517e64044" translate="yes" xml:space="preserve">
          <source>Here's an interesting case... &lt;code&gt;!!&lt;/code&gt; might be useful when 3rd party libs expect explicit Boolean values.</source>
          <target state="translated">这是一个有趣的案例 &lt;code&gt;!!&lt;/code&gt; 当第三方库期望显式布尔值时，此方法可能很有用。</target>
        </trans-unit>
        <trans-unit id="5dcc317e1dd0008af8179d1f9a0f92f72220ebe0" translate="yes" xml:space="preserve">
          <source>However it has several practical uses.</source>
          <target state="translated">然而,它有几个实际用途。</target>
        </trans-unit>
        <trans-unit id="f73892b42e6ec2099f18c789a4ca27320607324a" translate="yes" xml:space="preserve">
          <source>However rare these situations may be, there may exist a few scenarios where the most concise, most performant, and thus most preferred means of getting &lt;code&gt;true&lt;/code&gt; from a non-boolean, possibly undefined value is indeed by using &lt;code&gt;!!&lt;/code&gt;. Hopefully this ridiculously clears it up.</source>
          <target state="translated">不管这些情况多么罕见，在某些情况下，最简洁，最有效，因此最可取的从非布尔值，可能未定义的值中实现值的最佳方法的确是使用 &lt;code&gt;!!&lt;/code&gt; 。 希望这很荒谬。</target>
        </trans-unit>
        <trans-unit id="4f858245f3d281e55c31873b62aa68516b0b67f3" translate="yes" xml:space="preserve">
          <source>However:</source>
          <target state="translated">However:</target>
        </trans-unit>
        <trans-unit id="e75de3aca85245f9741f3ed73aba2405a0e6cfcd" translate="yes" xml:space="preserve">
          <source>I can't think of a great, non-contrived use case for that offhand. Maybe you have &quot;linked&quot; fields in a form?</source>
          <target state="translated">我想不出一个很好的、非争议的用例。也许你在一个表单里有 &quot;链接 &quot;字段?</target>
        </trans-unit>
        <trans-unit id="bd129d49875f1c7bf2d6c56ffa1cefd1aa871386" translate="yes" xml:space="preserve">
          <source>I just wanted to add that</source>
          <target state="translated">我只是想补充一下</target>
        </trans-unit>
        <trans-unit id="227f3285ec3ec43c9acc1d6e328c5b2a5034b7af" translate="yes" xml:space="preserve">
          <source>I saw some code that seems to use an operator I don't recognize, in the form of two exclamation points, like so: &lt;code&gt;!!&lt;/code&gt;. Can someone please tell me what this operator does?</source>
          <target state="translated">我看到了一些似乎使用不认识的运算符的代码，它以两个感叹号的形式出现，像这样： &lt;code&gt;!!&lt;/code&gt; 。 有人可以告诉我这个操作员做什么吗？</target>
        </trans-unit>
        <trans-unit id="0ab6442ad8b0b1090c870a59a8d71ba43701e2c7" translate="yes" xml:space="preserve">
          <source>I suspect this is a leftover from C++ where people override the ! operator but not the bool operator.</source>
          <target state="translated">我怀疑这是C++的遗留问题,在这里,人们重写了 ! 操作符而不重写 bool 操作符。</target>
        </trans-unit>
        <trans-unit id="003e87252c9f7ec44808278e2171c30bbf27960f" translate="yes" xml:space="preserve">
          <source>I think worth mentioning is, that a condition combined with logical AND/OR will not return a boolean value but last success or first fail in case of &amp;amp;&amp;amp; and 
first success or last fail in case of || of condition chain.</source>
          <target state="translated">我认为值得一提的是，结合了逻辑AND / OR的条件将不会返回布尔值，但是在&amp;amp;&amp;amp;的情况下，最后一次成功或第一次失败，在||的情况下是第一次成功或最后一次失败。 条件链。</target>
        </trans-unit>
        <trans-unit id="d802fb28a6d04b4cc61b6721bff2527b6ab50f8a" translate="yes" xml:space="preserve">
          <source>I'm more comfortable handling falsiness myself with a ternary --</source>
          <target state="translated">我自己在处理虚伪性的时候,用一个三性的......</target>
        </trans-unit>
        <trans-unit id="f605cfe8b7167fb9c1edb800b4a71aae4fe2edfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a false value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为假值，则 &lt;code&gt;!x&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，而 &lt;code&gt;!!x&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e2542885728d534e0cbf50ded3d8082dbb4bc2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a true value, &lt;code&gt;!x&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;!!x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为真值，则 &lt;code&gt;!x&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，而 &lt;code&gt;!!x&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24f97de69477863bf6708059e17ad9778d8a9cc3" translate="yes" xml:space="preserve">
          <source>If that element does in fact exist, the expression will evaluate as true, and the code block will be executed.</source>
          <target state="translated">如果该元素确实存在,则表达式将被评价为true,代码块将被执行。</target>
        </trans-unit>
        <trans-unit id="442b7a39eb1de6839bcbf2cca353f71f520acfac" translate="yes" xml:space="preserve">
          <source>If you &amp;rArr;</source>
          <target state="translated">如果你&amp;rArr;</target>
        </trans-unit>
        <trans-unit id="5075badbf5e88b6b0caa8ef134b856caccd05702" translate="yes" xml:space="preserve">
          <source>If you only care that a value is truthy or falsy, then use the short form. Instead of</source>
          <target state="translated">如果你只关心一个值是真还是假,那就用简答的形式。而不是</target>
        </trans-unit>
        <trans-unit id="25c0c498a0bdb8446495ca30bd5369fa1fe77b30" translate="yes" xml:space="preserve">
          <source>In order to cast the condition to a true boolean literal we can use the double negation:</source>
          <target state="translated">为了将条件投射到一个真正的布尔字段,我们可以使用双否定。</target>
        </trans-unit>
        <trans-unit id="d94b2b8672da34c8a43dd1c8cbce124ec9f02e37" translate="yes" xml:space="preserve">
          <source>Instead of these hacks, you can also use the constructor functions corresponding to the primitive types (&lt;em&gt;without&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;) to explicitly cast values, ie</source>
          <target state="translated">除了这些技巧外，您还可以使用与原始类型相对应的构造函数（ &lt;em&gt;不&lt;/em&gt;使用 &lt;code&gt;new&lt;/code&gt; ）来显式转换值，即</target>
        </trans-unit>
        <trans-unit id="ef8ebd812b149cf4ca6384ab75bf685b7c51d444" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;Boolean&lt;/code&gt; class can be used.</source>
          <target state="translated">而是可以使用 &lt;code&gt;Boolean&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="bd5f0f08c8b69e561341c016a5178bbabfab99f4" translate="yes" xml:space="preserve">
          <source>It converts the suffix to a Boolean value.</source>
          <target state="translated">它将后缀转换为布尔值。</target>
        </trans-unit>
        <trans-unit id="04f0b660a5f5fd40c699d9299636f12196d971ce" translate="yes" xml:space="preserve">
          <source>It forces all things to boolean.</source>
          <target state="translated">它迫使所有的东西都是布尔型的。</target>
        </trans-unit>
        <trans-unit id="362012587fedf1f206a41069ff29470d4bcc9b9f" translate="yes" xml:space="preserve">
          <source>It seems that the &lt;code&gt;!!&lt;/code&gt; operator results in a double negation.</source>
          <target state="translated">看来， &lt;code&gt;!!&lt;/code&gt; 运算符导致双重否定。</target>
        </trans-unit>
        <trans-unit id="d12e704c471bd7b5f2ef621231182892cdbce3ce" translate="yes" xml:space="preserve">
          <source>It simulates the behavior of the &lt;code&gt;Boolean()&lt;/code&gt; casting function.
The first &lt;code&gt;NOT&lt;/code&gt; returns a Boolean value no matter what operand it is given. The second &lt;code&gt;NOT&lt;/code&gt; negates that &lt;code&gt;Boolean&lt;/code&gt; value and so gives the &lt;code&gt;true&lt;/code&gt; Boolean value of a variable. The end result is the same as using the &lt;code&gt;Boolean()&lt;/code&gt; function on a value.</source>
          <target state="translated">它模拟 &lt;code&gt;Boolean()&lt;/code&gt; 强制转换函数的行为。 无论给定哪个操作数，第一个 &lt;code&gt;NOT&lt;/code&gt; 都将返回布尔值。 第二个 &lt;code&gt;NOT&lt;/code&gt; 取反该 &lt;code&gt;Boolean&lt;/code&gt; 值，因此给出变量的 &lt;code&gt;true&lt;/code&gt; 布尔值。 最终结果与对 &lt;code&gt;Boolean()&lt;/code&gt; 使用Boolean（）函数相同。</target>
        </trans-unit>
        <trans-unit id="b34f307bed6829df645edce297716e7d66021503" translate="yes" xml:space="preserve">
          <source>It's a double &lt;code&gt;not&lt;/code&gt; operation.  The first &lt;code&gt;!&lt;/code&gt; converts the value to boolean and inverts its logical value.  The second &lt;code&gt;!&lt;/code&gt; inverts the logical value back.</source>
          <target state="translated">这是双重操作。 第一 &lt;code&gt;!&lt;/code&gt; 将值转换为布尔值并反转其逻辑值。 第二 &lt;code&gt;!&lt;/code&gt; 反转逻辑值。</target>
        </trans-unit>
        <trans-unit id="c63e6ec5ccb83901a441e96930f2594861a2a402" translate="yes" xml:space="preserve">
          <source>It's a horribly obscure way to do a type conversion.</source>
          <target state="translated">这是一种可怕的隐晦的类型转换方式。</target>
        </trans-unit>
        <trans-unit id="a0bfc03fee00b0a95a35794ff4b18bfb284ed3d7" translate="yes" xml:space="preserve">
          <source>It's just the logical NOT operator, twice - it's used to convert something to boolean, e.g.:</source>
          <target state="translated">这只是逻辑上的NOT运算符,两次----它是用来将一些东西转换为布尔型的,例如。</target>
        </trans-unit>
        <trans-unit id="54382507df0f3d9ecbfe0a329a53e74bef4a1834" translate="yes" xml:space="preserve">
          <source>It's not a single operator, it's two.  It's equivalent to the following and is a quick way to cast a value to boolean.</source>
          <target state="translated">它不是一个运算符,而是两个。相当于下面的,它是一个快速投向布尔值的方法。</target>
        </trans-unit>
        <trans-unit id="7f323048105e7d3908de65a905d0ecb9e7cccddb" translate="yes" xml:space="preserve">
          <source>JSX' docs suggest you be more explicit, write self-commenting code, and use a comparison to force to a Boolean.</source>
          <target state="translated">JSX' docs建议你更加明确,写出自我注释的代码,用对比的方式来强行比对布尔。</target>
        </trans-unit>
        <trans-unit id="857f728eac2339b6a141ba1d44e27519c2166bbc" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;strong&gt;these &lt;em&gt;are JSX &amp;amp; Typescript conventions&lt;/em&gt;, not ones inherent to JavaScript&lt;/strong&gt;.</source>
          <target state="translated">请记住， &lt;strong&gt;这些&lt;em&gt;是JSX和Typescript约定&lt;/em&gt; ，而不是JavaScript固有的&lt;em&gt;约定&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="558b0b10df23ff62727f0cdf06a369839b8ba0b0" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Boolean(X) = !!X&lt;/code&gt; in use.</source>
          <target state="translated">即，正在使用 &lt;code&gt;Boolean(X) = !!X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a6705b7fa3ec15cdb9c15f74c0a2866a4f8b3e" translate="yes" xml:space="preserve">
          <source>Naturally, these are all the same as merely typing !!someThing, but the added parentheses might help make it more understandable.</source>
          <target state="translated">当然,这些都是和单纯的键入 !!someThing一样,但加了括号可能会让人更容易理解。</target>
        </trans-unit>
        <trans-unit id="062b9d1606d85c2c91b697df5b29f343f34bfd4f" translate="yes" xml:space="preserve">
          <source>Note that there are some &lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;unintuitive cases&lt;/a&gt; where a boolean will be cast to a number (&lt;code&gt;true&lt;/code&gt; is cast to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;) when comparing a boolean to a number. In this case, &lt;code&gt;!!&lt;/code&gt; might be mentally useful. Though, again, &lt;strong&gt;these are cases where you're comparing a non-boolean to a hard-typed boolean, which is, imo, a serious mistake.&lt;/strong&gt;&lt;code&gt;if (-1)&lt;/code&gt; is still the way to go here.</source>
          <target state="translated">请注意，在某些&lt;a href=&quot;https://stackoverflow.com/a/3619813/1028230&quot;&gt;不直观的情况下&lt;/a&gt; ，将布尔值与数字进行比较时，布尔值将被强制转换为数字（将 &lt;code&gt;true&lt;/code&gt; 强制转换为 &lt;code&gt;1&lt;/code&gt; ，将 &lt;code&gt;false&lt;/code&gt; 强制转换为 &lt;code&gt;0&lt;/code&gt; ）。 在这种情况下， &lt;code&gt;!!&lt;/code&gt; 可能在心理上有用。 同样，在&lt;strong&gt;这些情况下，您将非布尔值与硬类型的布尔值进行比较，这是一个严重的错误。&lt;/strong&gt; &lt;code&gt;if (-1)&lt;/code&gt; 仍然是此处的出路。</target>
        </trans-unit>
        <trans-unit id="57d186fffc848f3760d873fa6a5efef0c4b69fd9" translate="yes" xml:space="preserve">
          <source>One fix involves the bangbang, which coerces &lt;code&gt;0&lt;/code&gt; into &lt;code&gt;!!0&lt;/code&gt;, which is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">一种解决方法涉及bangbang，它将 &lt;code&gt;0&lt;/code&gt; 强制为 &lt;code&gt;!!0&lt;/code&gt; ，这是 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1a6f54cbcb01cbe0a3333b72e4ff3a962a0f801e" translate="yes" xml:space="preserve">
          <source>One use is to lossily compress an object to its truth value, so that your code isn't holding a reference to a big object and keeping it alive. Assigning &lt;code&gt;!!some_big_object&lt;/code&gt; to a variable instead of &lt;code&gt;some_big_object&lt;/code&gt; lets go of it for the garbage collector. This is useful for cases that produce either an object or a false value such as &lt;code&gt;null&lt;/code&gt; or the undefined value, such as browser feature detection.</source>
          <target state="translated">一种用途是将对象有损地压缩到其真实值，这样您的代码就不会保留对大对象的引用并使它保持活动状态。 将 &lt;code&gt;!!some_big_object&lt;/code&gt; 分配给变量而不是 &lt;code&gt;some_big_object&lt;/code&gt; 可以将其释放给垃圾收集器。 这对于产生对象或错误值（例如 &lt;code&gt;null&lt;/code&gt; 或未定义值）（例如浏览器功能检测）的情况很有用。</target>
        </trans-unit>
        <trans-unit id="161e7eb8bec71d838abd41540cca030c08d6f7f6" translate="yes" xml:space="preserve">
          <source>Please check code snippet out below &lt;strong&gt;&amp;darr;&lt;/strong&gt;</source>
          <target state="translated">请检查下面的代码片段&lt;strong&gt;&amp;darr;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9c634cfd1a38a3aa345e046738679df22d80362" translate="yes" xml:space="preserve">
          <source>Practical uses</source>
          <target state="translated">实际用途</target>
        </trans-unit>
        <trans-unit id="114da967498be8e2c2cdf7df8db42e88ebd380c7" translate="yes" xml:space="preserve">
          <source>Pretend we have &lt;code&gt;myVar1 = 0;&lt;/code&gt; and &lt;code&gt;myVar2 = undefined;&lt;/code&gt;.</source>
          <target state="translated">假设我们的 &lt;code&gt;myVar1 = 0;&lt;/code&gt; 和 &lt;code&gt;myVar2 = undefined;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2f2915a66e774b1c83f8a2a3e89284ac648434e" translate="yes" xml:space="preserve">
          <source>Real World Example &quot;Test IE version&quot;:</source>
          <target state="translated">真实世界示例 &quot;测试IE版本&quot;。</target>
        </trans-unit>
        <trans-unit id="b39d3fef53ba3ed826f8428d58a2371af89a4e7d" translate="yes" xml:space="preserve">
          <source>Returns boolean value of a variable.</source>
          <target state="translated">返回一个变量的布尔值。</target>
        </trans-unit>
        <trans-unit id="fc98ae78ccf4552e39bcf193255cd5a8ae570858" translate="yes" xml:space="preserve">
          <source>Same deal in Typescript: If you have a function that returns a boolean (or you're assigning a value to a boolean variable), you [usually] can't return/assign a boolean-y value; it has to be a strongly typed boolean. This means, &lt;strong&gt;iff &lt;code&gt;myObject&lt;/code&gt; is strongly typed&lt;/strong&gt;, &lt;code&gt;return !myObject;&lt;/code&gt; works for a function returning a boolean, but &lt;code&gt;return myObject;&lt;/code&gt; doesn't. You have to &lt;code&gt;return !!myObject&lt;/code&gt; to match Typescript's expectations.</source>
          <target state="translated">在Typescript中也是如此：如果您有一个返回布尔值的函数（或者您正在为布尔变量赋值），则[通常]您无法返回/分配布尔y值； 它必须是一个强类型的布尔值。 这意味着， &lt;strong&gt;如果 &lt;code&gt;myObject&lt;/code&gt; 是强类型的&lt;/strong&gt; ，则 &lt;code&gt;return !myObject;&lt;/code&gt; 适用于返回布尔值但 &lt;code&gt;return myObject;&lt;/code&gt; 的函数； 没有。 您必须 &lt;code&gt;return !!myObject&lt;/code&gt; 以符合Typescript的期望。</target>
        </trans-unit>
        <trans-unit id="03d3dfc9a836826357b793d282380cd7f94081b6" translate="yes" xml:space="preserve">
          <source>See &quot;== and !=&quot; from &lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint's directions&lt;/a&gt; (note: Crockford is moving his site around a bit; that link is liable to die at some point) for a little on why:</source>
          <target state="translated">请从&lt;a href=&quot;http://old.jslint.com/lint.html&quot;&gt;JSLint的指导中&lt;/a&gt;查看&amp;ldquo; ==和！=&amp;ldquo;（注意：Crockford 会将其站点稍微移动一下；该链接可能会在某个时刻死掉），其中有一些原因：</target>
        </trans-unit>
        <trans-unit id="b77b945dc1e2fb58fae032d74373f3a357e30b37" translate="yes" xml:space="preserve">
          <source>Simply casting :(</source>
          <target state="translated">仅仅是铸造:(</target>
        </trans-unit>
        <trans-unit id="6a0157727338f2b7b3fe3318d34c2684d92b3ba2" translate="yes" xml:space="preserve">
          <source>So  it's like using &lt;code&gt;Boolean&lt;/code&gt; function in javascript, but easy and shorter way to convert a value to boolean:</source>
          <target state="translated">因此，就像在javascript中使用 &lt;code&gt;Boolean&lt;/code&gt; 函数一样，但是将值转换为布尔值的简便快捷方式：</target>
        </trans-unit>
        <trans-unit id="c4992f9e1d0a43038d9ca1117fe08701149b40b0" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;!!&lt;/code&gt; is not an operator, it's just the &lt;code&gt;!&lt;/code&gt; operator twice.</source>
          <target state="translated">所以 &lt;code&gt;!!&lt;/code&gt; 不是运算符，而只是 &lt;code&gt;!&lt;/code&gt; 操作员两次。</target>
        </trans-unit>
        <trans-unit id="0addbe39410a730dff513bf6537d8856157b56c9" translate="yes" xml:space="preserve">
          <source>So many answers doing half the work. Yes, &lt;code&gt;!!X&lt;/code&gt; could be read as &quot;the truthiness of X [represented as a boolean]&quot;. But &lt;code&gt;!!&lt;/code&gt; isn't, practically speaking, so important for figuring out whether a single variable is (or even if many variables are) truthy or falsy. &lt;code&gt;!!myVar === true&lt;/code&gt; is the same as just &lt;code&gt;myVar&lt;/code&gt;. Comparing &lt;code&gt;!!X&lt;/code&gt; to a &quot;real&quot; boolean isn't really useful.</source>
          <target state="translated">这么多的答案完成了一半的工作。 是的， &lt;code&gt;!!X&lt;/code&gt; 可以理解为&amp;ldquo; X（以布尔值表示）的真实性&amp;rdquo;。 但是 &lt;code&gt;!!&lt;/code&gt; 实际上，对于弄清单个变量是真实的还是虚假的，并没有那么重要。 &lt;code&gt;!!myVar === true&lt;/code&gt; 与 &lt;code&gt;myVar&lt;/code&gt; 相同。 将 &lt;code&gt;!!X&lt;/code&gt; 与&amp;ldquo;真实&amp;rdquo;布尔值进行比较并不是真正有用。</target>
        </trans-unit>
        <trans-unit id="014ab2f522034cc3c77ca7c114cbd4670167db8e" translate="yes" xml:space="preserve">
          <source>So now if you have a truthy for both &lt;em&gt;or&lt;/em&gt; a falsy for both spouse name and age, you can continue. Otherwise you've only got one field with a value (or a very early arranged marriage) and need to create an extra error on your &lt;code&gt;errorObjects&lt;/code&gt; collection.</source>
          <target state="translated">因此，现在，如果您对配偶双方的姓名和年龄均不真实， &lt;em&gt;或者&lt;/em&gt;对配偶姓名和年龄均不真实，则可以继续。 否则，您只有一个带有值的字段（或者很早就安排了婚姻），并且需要在 &lt;code&gt;errorObjects&lt;/code&gt; 集合上创建一个额外的错误。</target>
        </trans-unit>
        <trans-unit id="e63cc48d4173484ca47b8b9c48f21169296682e7" translate="yes" xml:space="preserve">
          <source>So the only place you'd really need to use &quot;boolean-cast variables&quot; would be if you had a situation where you're checking if both variables have the &lt;em&gt;same&lt;/em&gt; truthiness, right? That is, &lt;b&gt;use &lt;code&gt;!!&lt;/code&gt; if you need to see if two vars are &lt;em&gt;both truthy or both falsy&lt;/em&gt; (or not), that is, &lt;em&gt;of equal&lt;/em&gt; (or not) &lt;em&gt;truthiness&lt;/em&gt;.&lt;/b&gt;</source>
          <target state="translated">因此，您真正需要使用&amp;ldquo;布尔值转换变量&amp;rdquo;的唯一地方是，如果您要检查两个变量是否具有&lt;em&gt;相同的&lt;/em&gt;真实性，对吗？ 也就是说， &lt;b&gt;使用 &lt;code&gt;!!&lt;/code&gt; &lt;/b&gt; &lt;b&gt;如果您需要查看两个变量是否&lt;em&gt;都是真实的或都是虚假的&lt;/em&gt; （或不是），那就是&lt;em&gt;相等&lt;/em&gt; （或不）的&lt;em&gt;真实性&lt;/em&gt; 。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e8fc0438c0801780b20fbecd73911dad21ef51b6" translate="yes" xml:space="preserve">
          <source>So to get a negative(or positive) answer in that case you would first need to use the ! operator to get a boolean, but if you wanted to check the positive case would use !!.</source>
          <target state="translated">所以,在这种情况下,要得到一个负值(或正值)的答案,你首先需要使用 !&quot;操作符来得到一个布尔值,但如果你想检查正值的情况,可以使用 !&quot;。</target>
        </trans-unit>
        <trans-unit id="6e23c1f4bfbfa0ccb58b6c59c222898580d75194" translate="yes" xml:space="preserve">
          <source>So you're converting a value to a boolean, then inverting it, then inverting it again.</source>
          <target state="translated">所以你把一个值转换为布尔值,然后反转,再反转。</target>
        </trans-unit>
        <trans-unit id="70f19fcd06b0becbaad2b70e1d5cf4e4e3e27fee" translate="yes" xml:space="preserve">
          <source>Some of you probably noticed that in this specific example, one could simply check for a property using the slightly &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;more performant&lt;/a&gt;&lt;/strong&gt; means of checking if the object in question &lt;em&gt;has&lt;/em&gt; a property. There are two ways to do this:</source>
          <target state="translated">你们中的有些人可能注意到，在此特定示例中，可以使用&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/hasownproperty-vs-comparison&quot;&gt;性能&lt;/a&gt;&lt;/strong&gt;稍强的方法（即检查所讨论的对象是否&lt;em&gt;具有&lt;/em&gt;属性）来简单地检查属性。 有两种方法可以做到这一点：</target>
        </trans-unit>
        <trans-unit id="4b46f5ed42b9b9e328c2f46362683a228c43e509" translate="yes" xml:space="preserve">
          <source>Some operators in JavaScript perform implicit type conversions, and are sometimes
used for type conversion.</source>
          <target state="translated">JavaScript中的一些操作符可以执行隐式类型转换,有时也用于类型转换。</target>
        </trans-unit>
        <trans-unit id="ea085d9130b086f1623397b738adcbac23d6d7e9" translate="yes" xml:space="preserve">
          <source>That is...</source>
          <target state="translated">那是.....</target>
        </trans-unit>
        <trans-unit id="82fc7d92ba7e869e36f27a18325c4d16d5a80178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; construct is a simple way of turning any JavaScript expression into
its Boolean equivalent.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 构造是将任何JavaScript表达式转换为其等效布尔值的简单方法。</target>
        </trans-unit>
        <trans-unit id="90d1a7ed711f96e90a1182e13fa7e55e0596693e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!!&lt;/code&gt; operator reassures the lint tool that what you wrote is what you meant: do this operation, then take the truth value of the result.</source>
          <target state="translated">&lt;code&gt;!!&lt;/code&gt; 操作员向皮棉工具保证您写的是您的意思：执行此操作，然后获取结果的真实值。</target>
        </trans-unit>
        <trans-unit id="eabc5d96ac71e6f38058420dd87159a58d3314a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements and the &lt;code&gt;?&lt;/code&gt; operator use truth values to determine which branch of code to run. For example, zero and NaN numbers and the empty string are false, but other numbers and strings are true. Objects are true, but the undefined value and &lt;code&gt;null&lt;/code&gt; are both false.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; 语句以及 &lt;code&gt;?&lt;/code&gt; 操作员使用真值确定要运行的代码分支。 例如，零和NaN数字和空字符串为false，但其他数字和字符串为true。 对象为true，但undefined值和 &lt;code&gt;null&lt;/code&gt; 均为false。</target>
        </trans-unit>
        <trans-unit id="29d047ae2b1b9b41221cc9a49cebe8c72ef84804" translate="yes" xml:space="preserve">
          <source>The == and != operators do type coercion before comparing. This is bad because it causes ' \t\r\n' == 0 to be true. This can mask type errors. JSLint cannot reliably determine if == is being used correctly, so it is best to not use == and != at all and to always use the more reliable === and !== operators instead.</source>
          <target state="translated">==和 !=操作符在比较之前做了类型胁迫。这是很糟糕的,因为它导致 '===0' ==为真。这可能会掩盖类型错误。JSLint 无法可靠地确定 ==是否被正确使用,所以最好完全不使用 ==和 !=,而总是使用更可靠的 ===和 !==运算子。</target>
        </trans-unit>
        <trans-unit id="19d8f9dad8485f308ad86d92258b4c919e2fb866" translate="yes" xml:space="preserve">
          <source>The above return undefined but if you have an empty string, false, null, 0, undefined those values will return and soon as we encounter them in the chain -- &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; are both &quot;truthy&quot; and we will continue down the so-called &quot;&amp;amp;&amp;amp; chain&quot; to the next value to the right.</source>
          <target state="translated">上面的返回值是undefined，但是如果您有一个空字符串，false，null，0，undefined，则这些值将返回，并且在链中遇到它们时- &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 都是&amp;ldquo;真实的&amp;rdquo;，我们将继续向下操作所谓的&amp;ldquo; &amp;amp;&amp;amp;链&amp;rdquo;到右边的下一个值。</target>
        </trans-unit>
        <trans-unit id="b6f0570101450478158dcd94c3db9bdc410dbccf" translate="yes" xml:space="preserve">
          <source>The above's not so useful. &lt;code&gt;if (!0)&lt;/code&gt; gives you the same results as &lt;code&gt;if (!!0 === false)&lt;/code&gt;. I can't think of a good case for casting a variable to boolean and then comparing to a &quot;true&quot; boolean.</source>
          <target state="translated">以上不是那么有用。 &lt;code&gt;if (!0)&lt;/code&gt; 的结果与 &lt;code&gt;if (!!0 === false)&lt;/code&gt; 。 我想不出将变量转换为布尔值然后与&amp;ldquo; true&amp;rdquo;布尔值进行比较的好例子。</target>
        </trans-unit>
        <trans-unit id="281762abc14819a66dcacbfde55f5e8401270f1d" translate="yes" xml:space="preserve">
          <source>The context in which I saw this was,</source>
          <target state="translated">我看到这句话的背景是:</target>
        </trans-unit>
        <trans-unit id="acc6b507b28fe734085a51694ffb662d2f97612f" translate="yes" xml:space="preserve">
          <source>The double &quot;not&quot; in this case is quite simple.  It is simply two &lt;code&gt;not&lt;/code&gt;s back to back.</source>
          <target state="translated">在这种情况下，双&amp;ldquo; not&amp;rdquo;非常简单。 这只是两个 &lt;code&gt;not&lt;/code&gt; 背对背。</target>
        </trans-unit>
        <trans-unit id="531d1ca78f0741ca59c6f0a6607b3ea3cdc4a6d9" translate="yes" xml:space="preserve">
          <source>The double negation operator &lt;code&gt;!!&lt;/code&gt; calculates the truth value of a value. It's actually two operators, where &lt;code&gt;!!x&lt;/code&gt; means &lt;code&gt;!(!x)&lt;/code&gt;, and behaves as follows:</source>
          <target state="translated">双重否定运算符 &lt;code&gt;!!&lt;/code&gt; 计算值的真值。 实际上是两个运算符， &lt;code&gt;!!x&lt;/code&gt; 表示 &lt;code&gt;!(!x)&lt;/code&gt; ，其行为如下：</target>
        </trans-unit>
        <trans-unit id="0fedba5c4ec19ca80540448ef2226b8d7209ad69" translate="yes" xml:space="preserve">
          <source>The exception for Typescript? If &lt;code&gt;myObject&lt;/code&gt; was an &lt;code&gt;any&lt;/code&gt;, you're back in JavaScript's Wild West and can return it without &lt;code&gt;!!&lt;/code&gt;, even if your return type is a boolean.</source>
          <target state="translated">Typescript例外？ 如果 &lt;code&gt;myObject&lt;/code&gt; 是 &lt;code&gt;any&lt;/code&gt; ，那么您将返回JavaScript的Wild West，并且可以不使用 &lt;code&gt;!!&lt;/code&gt; 将其返回！ ，即使您的返回类型是布尔值。</target>
        </trans-unit>
        <trans-unit id="e4d67b97b47952ce6811073a8a2a38486c684c78" translate="yes" xml:space="preserve">
          <source>The first bang forces the js engine to run &lt;code&gt;Boolean(x)&lt;/code&gt; but also has the side effect of inverting the value.  So the second bang undoes the side effect.</source>
          <target state="translated">第一次爆炸会迫使js引擎运行 &lt;code&gt;Boolean(x)&lt;/code&gt; ,但也会产生反转值的副作用。 因此，第二次爆炸消除了副作用。</target>
        </trans-unit>
        <trans-unit id="fe7b25df5389abed33b3b0b02607f02a5ccbe313" translate="yes" xml:space="preserve">
          <source>The first one simply &quot;inverts&quot; the truthy or falsey value, resulting in an actual boolean type, and then the second one &quot;inverts&quot; it back again to it's original state, but now in an actual boolean value.  That way you have consistency:</source>
          <target state="translated">第一个简单地将truthy或falsey的值 &quot;反转&quot;,产生一个实际的布尔类型,然后第二个 &quot;反转&quot;,再次将其 &quot;反转 &quot;回原来的状态,但现在是一个实际的布尔值。这样,你就有了一致性。</target>
        </trans-unit>
        <trans-unit id="7bbf601d501a5f0c41724feba5edab84aa91cd28" translate="yes" xml:space="preserve">
          <source>The trick here is the chain of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;s will return &lt;strong&gt;the first falsey value&lt;/strong&gt; it finds -- and this can be fed to an if statement etc.  So if b.foo is undefined, it will return undefined and skip the &lt;code&gt;b.foo.bar&lt;/code&gt; statement, and we get no error.</source>
          <target state="translated">这里的窍门是 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 的链将返回它找到&lt;strong&gt;的第一个虚假值&lt;/strong&gt; -可以将其馈送到if语句等。因此，如果b.foo是未定义的，它将返回undefined并跳过 &lt;code&gt;b.foo.bar&lt;/code&gt; 声明，我们没有任何错误。</target>
        </trans-unit>
        <trans-unit id="f362651fc7a92ae9f0a9673d4c5486b2f3f73825" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!false&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">事实是 &lt;code&gt;false&lt;/code&gt; 不是 &lt;code&gt;true&lt;/code&gt; （这就是 &lt;code&gt;!false&lt;/code&gt; 导致&lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt;的原因）</target>
        </trans-unit>
        <trans-unit id="a45301cb714edcffab6f1d258022757ae0ecd7bd" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;false&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!!false&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">事实是 &lt;code&gt;false&lt;/code&gt; 并非&lt;em&gt;不是&lt;/em&gt; &lt;code&gt;false&lt;/code&gt; （这就是 &lt;code&gt;!!false&lt;/code&gt; 导致&lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt;的原因）</target>
        </trans-unit>
        <trans-unit id="dc6dfe93853155dde81483486981f53f459fca48" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;code&gt;false&lt;/code&gt; (that's why &lt;code&gt;!true&lt;/code&gt; results
in &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">事实是 &lt;code&gt;true&lt;/code&gt; 并非 &lt;code&gt;false&lt;/code&gt; （这就是 &lt;code&gt;!true&lt;/code&gt; 导致&lt;strong&gt; &lt;code&gt;false&lt;/code&gt; &lt;/strong&gt;的原因）</target>
        </trans-unit>
        <trans-unit id="de5886521d1b8bae3b9e573aa8de49514dcf5e6d" translate="yes" xml:space="preserve">
          <source>The truth is that &lt;code&gt;true&lt;/code&gt; is not &lt;em&gt;not&lt;/em&gt;&lt;code&gt;true&lt;/code&gt; (that's why &lt;code&gt;!!true&lt;/code&gt; results in &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">事实是 &lt;code&gt;true&lt;/code&gt; &lt;em&gt;并非&lt;/em&gt; &lt;code&gt;true&lt;/code&gt; （这就是 &lt;code&gt;!!true&lt;/code&gt; 导致&lt;strong&gt; &lt;code&gt;true&lt;/code&gt; &lt;/strong&gt;的原因）</target>
        </trans-unit>
        <trans-unit id="3c5ec1883ea648c4eac15e44a0e47cc089c821db" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;!&lt;/code&gt; operator converts its operand to a boolean and negates it.</source>
          <target state="translated">一元 &lt;code&gt;!&lt;/code&gt; 运算符将其操作数转换为布尔值并取反。</target>
        </trans-unit>
        <trans-unit id="33306e297fa07aa22ffeca48a2d3b1ca6f355960" translate="yes" xml:space="preserve">
          <source>Then you do &lt;code&gt;!0&lt;/code&gt;, it will be converted to boolean and be evaluated to &lt;code&gt;true&lt;/code&gt;, because 0 is &lt;code&gt;falsy&lt;/code&gt;, so you get the reversed value and converted to boolean, so it gets evaluated to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">然后，您执行 &lt;code&gt;!0&lt;/code&gt; ，它将被转换为boolean并被评估为 &lt;code&gt;true&lt;/code&gt; ，因为0是 &lt;code&gt;falsy&lt;/code&gt; ，因此您获得了相反的值并转换为boolean，因此它被评估为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71ab5eac91ed7f0607dae3a2cf1d7e72a4ca4e97" translate="yes" xml:space="preserve">
          <source>This fact lead to the following idiom that you can see in your source code:</source>
          <target state="translated">这个事实导致了下面这个成语,你可以在源码中看到。</target>
        </trans-unit>
        <trans-unit id="5206aead5c0929d44fb460d6a6d755b4275d68d5" translate="yes" xml:space="preserve">
          <source>This question has been answered quite thoroughly, but I'd like to add an answer that I hope is as simplified as possible, making the meaning of !! as simple to grasp as can be.</source>
          <target state="translated">这个问题已经回答得相当透彻了,但我想补充一个答案,希望能尽量简化,让大家对!!!的含义尽可能地简单掌握。</target>
        </trans-unit>
        <trans-unit id="900a6ce54db6671d1163b4588fef81576caa9d76" translate="yes" xml:space="preserve">
          <source>Tons of great answers here, but if you've read down this far, this helped me to 'get it'. Open the console on Chrome (etc), and start typing:</source>
          <target state="translated">这里有很多很好的答案,但如果你读到这里,这对我的 &quot;理解 &quot;有很大的帮助。在Chrome浏览器(等)上打开控制台,开始打字。</target>
        </trans-unit>
        <trans-unit id="b5a7a294200e3cb34da2a97adf5d130ba6c38c00" translate="yes" xml:space="preserve">
          <source>Use logical not operator two times</source>
          <target state="translated">使用逻辑不运算符两次</target>
        </trans-unit>
        <trans-unit id="037ce300d2779ff07c53c4b5b8748bb947cb98bb" translate="yes" xml:space="preserve">
          <source>What is the !! (not not) operator in JavaScript</source>
          <target state="translated">什么是! (not not)操作符</target>
        </trans-unit>
        <trans-unit id="2bd5abc68757873bb182393e529f58b5f1764ea3" translate="yes" xml:space="preserve">
          <source>What we wish to determine in the comparison is the &quot;truth&quot; &lt;em&gt;about&lt;/em&gt; the value of a reference, not the &lt;em&gt;value of&lt;/em&gt; the reference itself. There is a use-case where we might want to know the truth about a value, even if we expect the value to be &lt;em&gt;&lt;code&gt;false&lt;/code&gt;&lt;/em&gt; (or falsey), or if we expect the value not to be typeof &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">我们希望在比较中确定的是&lt;em&gt;关于&lt;/em&gt;参考值的&amp;ldquo;真实性&amp;rdquo;，而不是参考本身的&lt;em&gt;值&lt;/em&gt; 。 在一个用例中，即使我们期望值是&lt;em&gt; &lt;code&gt;false&lt;/code&gt; &lt;/em&gt; （或falsey），或者期望值不是typeof &lt;code&gt;boolean&lt;/code&gt; ，我们也可能想知道关于值的真相。</target>
        </trans-unit>
        <trans-unit id="e6dfeec064b00b28af55ee18d69a51869a08807e" translate="yes" xml:space="preserve">
          <source>What you gain with &lt;code&gt;!!&lt;/code&gt; is the ability to check the truthiness of multiple variables &lt;em&gt;against each other&lt;/em&gt; in a repeatable, standardized (and JSLint friendly) fashion.</source>
          <target state="translated">你从中获得什么 &lt;code&gt;!!&lt;/code&gt; 是一种以可重复，标准化（和JSLint友好）方式&lt;em&gt;相互&lt;/em&gt;检查多个变量的真实性的功能。</target>
        </trans-unit>
        <trans-unit id="d568b1f542f2ac7d26a5c47b5cb7b7775b67ea06" translate="yes" xml:space="preserve">
          <source>When used at the top level of a Boolean context (&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;), the &lt;code&gt;!!&lt;/code&gt; operator is behaviorally a no-op. For example, &lt;code&gt;if (x)&lt;/code&gt; and &lt;code&gt;if (!!x)&lt;/code&gt; mean the same thing.</source>
          <target state="translated">在布尔上下文的最高级别（ &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;?&lt;/code&gt; ）上使用时， &lt;code&gt;!!&lt;/code&gt; 操作员在行为上是无操作的。 例如， &lt;code&gt;if (x)&lt;/code&gt; 和 &lt;code&gt;if (!!x)&lt;/code&gt; 表示同一件事。</target>
        </trans-unit>
        <trans-unit id="15bdd7d9c3451db43373e5025a0173bdf0c60369" translate="yes" xml:space="preserve">
          <source>Why?  Because &lt;code&gt;document.getElementById()&lt;/code&gt; is a &quot;truthy&quot; expression that will evaluate as true in this &lt;code&gt;if()&lt;/code&gt; statement, but it is not an actual boolean value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">为什么？ 因为 &lt;code&gt;document.getElementById()&lt;/code&gt; 是一个&amp;ldquo;真实的&amp;rdquo;表达式，在此 &lt;code&gt;if()&lt;/code&gt; 语句中其值为 &lt;code&gt;true&lt;/code&gt; ，但它不是布尔值true的实际值。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2562e78de1b3256bca3da91141bb0297a876088d" translate="yes" xml:space="preserve">
          <source>and instead of</source>
          <target state="translated">而不是</target>
        </trans-unit>
        <trans-unit id="6ff7395099aa52cc1ac2567047b5dc904e83a97c" translate="yes" xml:space="preserve">
          <source>but we don't want the reversed &lt;strong&gt;boolean version&lt;/strong&gt; of the value, so we can reverse it again to get our result! That's why we use another &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">但我们不希望&lt;strong&gt;值的布尔&lt;/strong&gt;值取反，因此我们可以再次将其取反以获得结果！ 这就是为什么我们使用另一个 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1136ebda06acfbb946c27883e9c70a00d96a8324" translate="yes" xml:space="preserve">
          <source>here is a piece of code from angular js</source>
          <target state="translated">这里有一段Angular js的代码</target>
        </trans-unit>
        <trans-unit id="07aee702dc1bc81b24b43ca8e96d3a68f77ddfba" translate="yes" xml:space="preserve">
          <source>if requestAnimationFrame was assinged undefined then
!requestAnimationFrame would be true and one more ! of it would be false</source>
          <target state="translated">如果requestAnimationFrame被指定为未定义,那么 !requestAnimationFrame将为真,再有一个 !将为假。</target>
        </trans-unit>
        <trans-unit id="841108c86e9fbb4edafbf1fc269ca06fbd9c2aa7" translate="yes" xml:space="preserve">
          <source>is the same as</source>
          <target state="translated">等于</target>
        </trans-unit>
        <trans-unit id="fb81871808eeba6b79f000511077e0392e5040fe" translate="yes" xml:space="preserve">
          <source>it can be achieved by checking in following way in general:</source>
          <target state="translated">一般来说,可以通过以下方式进行检查:</target>
        </trans-unit>
        <trans-unit id="bf9bb582fda3d69616ba7956287f904859457f58" translate="yes" xml:space="preserve">
          <source>just say</source>
          <target state="translated">只说</target>
        </trans-unit>
        <trans-unit id="dc01c6b7487aab92695f7ba918540cf5051f72f4" translate="yes" xml:space="preserve">
          <source>say</source>
          <target state="translated">say</target>
        </trans-unit>
        <trans-unit id="287b978241585895eb95865fc85abb7f32f60d1e" translate="yes" xml:space="preserve">
          <source>so if requestAnimationFrame was assigned a function
 then
!requestAnimationFrame would be false and one more ! of it would be true</source>
          <target state="translated">所以,如果requestAnimationFrame被分配了一个函数,那么 !requestAnimationFrame就会变成false,再多一个 !就会变成true</target>
        </trans-unit>
        <trans-unit id="7c2b4b647bd0e7cbaa828c353b4a7be55a9be894" translate="yes" xml:space="preserve">
          <source>the short way could be using !!</source>
          <target state="translated">近路可以用!!!</target>
        </trans-unit>
        <trans-unit id="2b1fd3dee3545afca88dbce54f7f1d0f063a468f" translate="yes" xml:space="preserve">
          <source>their intention is to set rafSupported to true or false based on the availability of function in requestAnimationFrame</source>
          <target state="translated">他们的意图是根据requestAnimationFrame中函数的可用性,将rafSupported设置为true或false。</target>
        </trans-unit>
        <trans-unit id="7b247e535f27451042dc1de383c546cfcbe520d6" translate="yes" xml:space="preserve">
          <source>will BOTH return true, as expected.</source>
          <target state="translated">都会像预期的那样返回真值。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
