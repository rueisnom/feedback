<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/588866">
    <body>
      <group id="588866">
        <trans-unit id="29411947b64337d949e3249a16a8087de5059836" translate="yes" xml:space="preserve">
          <source>'atomic' means it cannot be broken down. 
  In OS/programming terms an atomic function call is one that cannot be interrupted - the entire function must be executed, and not swapped out of the CPU by the OS's usual context switching until it's complete. Just in case you didn't know: since the CPU can only do one thing at a time, the OS rotates access to the CPU to all running processes in little time-slices, to give the &lt;em&gt;illusion&lt;/em&gt; of multitasking. The CPU scheduler can (and does) interrupt a process at any point in its execution - even in mid function call. So for actions like updating shared counter variables where two processes could try to update the variable at the same time, they must be executed 'atomically', i.e., each update action has to finish in its entirety before any other process can be swapped onto the CPU.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;атомный&amp;raquo; означает, что его нельзя сломать. В терминах OS / программирования вызов атомарной функции - это вызов, который не может быть прерван - вся функция должна быть выполнена, а не выгружена из ЦПУ обычным переключением контекста ОС до его завершения. На тот случай, если вы не знали: поскольку ЦП может делать только одну вещь за раз, ОС вращает доступ к ЦП всем запущенным процессам за небольшие промежутки времени, чтобы создать &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;иллюзию&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;многозадачности. Планировщик ЦП может (и делает) прерывать процесс в любой момент его выполнения - даже в середине вызова функции. Таким образом, для таких действий, как обновление переменных общего счетчика, когда два процесса могут пытаться обновить переменную одновременно, они должны выполняться &amp;laquo;атомарно&amp;raquo;, т. Е. Каждое действие обновления должно завершаться полностью, прежде чем любой другой процесс может быть перенесен на ЦПУ.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="65736baa892bc6f32d06472e7079b5cff8c9af94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assign&lt;/code&gt;             // Default</source>
          <target state="translated">&lt;code&gt;assign&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // по умолчанию&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bac17a28340bcd4bfb53b1b5e3a83f2a13250a9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt;             // Default</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // По умолчанию&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d882e76c1163761e47b5a0bb408737608a9242" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; is the default behavior</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поведение по умолчанию&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd25f9b1ee3c8eaa4226923ff82b96fd6eca134a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; is thread safe.</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потокобезопасен.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80e3a512b8083c4567a879d96cc0303bf08edd67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; means only one thread access the variable (static type).</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает, что только один поток обращается к переменной (статический тип).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff1d83cc3154ada7d25a25cffb2c0f316485b818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomicity&lt;/code&gt; of a single property also cannot guarantee thread safety when multiple dependent properties are in play.</source>
          <target state="translated">&lt;code&gt;atomicity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; отдельного свойства также не может гарантировать безопасность потока, когда в игре находятся несколько зависимых свойств.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0676c9bf1fac4480032641cbb6a68b1b7b2be56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; is NOT default behavior. We need to add the &lt;code&gt;nonatomic&lt;/code&gt; keyword in the property attribute.</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; НЕ является поведением по умолчанию. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Нам нужно добавить &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ключевое слово &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в атрибуте свойства.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b453d3a7a5746cdfc0be6127c5ee1332e4ae20b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; is thread-unsafe.</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поток-небезопасный.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="144c4b12fa77d18882a8cd254b25ce6824a3fd33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; means multiple thread access the variable (dynamic type).</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает, что многопоточный доступ к переменной (динамический тип).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94704458ff99f8b43566a1a29d92a57098a31b7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readwrite&lt;/code&gt;                 // Default</source>
          <target state="translated">&lt;code&gt;readwrite&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // по умолчанию&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16fdeec49d31d634e8dd057a685b6f1a125f2dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strong = retain&lt;/code&gt;        // Default</source>
          <target state="translated">&lt;code&gt;strong = retain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // по умолчанию&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1817be6d1b19c950de8c9a2fd3ae06f454649a42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Thats why non atomic is called thread unsafe But but it is fast in performance because of parallel execution&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот почему non atomic называется потоком небезопасным, но он быстрый по производительности из-за параллельного выполнения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cdd7cb3f0962dd785ee980cc0728796fe1f9761" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The keywords doesn't have to be written as first property attribute at all.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ключевые слова вообще не должны записываться как первый атрибут свойства.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a10d89828ebaa54d8102b7cb13ba8665b0b81b2" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Note that there is no &quot;atomic&quot; keyword, if you do not specify &quot;nonatomic&quot;, then the property is atomic, but specifying &quot;atomic&quot; explicitly will result in an error.&lt;/strike&gt;</source>
          <target state="translated">&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что ключевое слово &amp;laquo;atomic&amp;raquo; отсутствует, если вы не укажете &amp;laquo;nonatomic&amp;raquo;, тогда свойство является атомарным, но явное указание &amp;laquo;atomic&amp;raquo; приведет к ошибке.&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="ffd409aa01eefdb8323b9fe5351b0b0a2ae95d7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-  Nonatomic means multiple thread access the variable(dynamic type).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- Неатомный означает, что многопоточный доступ к переменной (динамический тип).&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="466db7383e12a27164e85bd429689284264834b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;- Nonatomic is thread unsafe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- Неатомный поток небезопасен.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36549c905b7712f2a9bd3e65321c0b4716e2e567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;- but it is fast in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- но это быстро в производительности&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ffaa095c82217a0d20db0b7833a8f1b5ded92da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Atomic is thread safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Атомный потокобезопасный.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="386c6c59efb1ceedd21973ad7d42db9e83d58724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Atomic means only one thread access the variable(static type).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Атомный означает, что только один поток обращается к переменной (статический тип).&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9289b20dbb4a5dfc44402b984b9b7fb71c00550" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Nonatomic is NOT default behavior, we need to add nonatomic keyword    in property attribute.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Nonatomic НЕ является поведением по умолчанию, нам нужно добавить ключевое слово nonatomic в атрибуте свойства.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0c853f0aa5af920ea97541fcad5a333859dd74d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-but it is slow in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- но это медленно в производительности&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4f84e82d964d65d5331ec4dc31848f2f7892ac9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt; will ALWAYS guarantee&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; воля ВСЕГДА гарантирует&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddde3b23162bbee9de624e2f156bcd96875a1c35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bb576a1c9d49b79e806ea0099e6c66b36101634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;nonatomic&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;nonatomic&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="716a0725bfe701eef013b5666a762ce35538990b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Atomicity
atomic (default)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атомарность атомная (по умолчанию)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="568741eb5bb25f08010362cde0dec871c3a27255" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;That's why atomic is called thread Safe&lt;/em&gt;&lt;/strong&gt; and 
&lt;strong&gt;&lt;em&gt;That's why it is called read-write safe&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот почему Atomic называется потокобезопасным,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; именно поэтому он называется безопасным для чтения и записи.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6db8014b9ff772505aa968a0f3cb71151a1dfeb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;nonatomic&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;nonatomic&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86bb8a493b4f26c9d609a3571320b145e83a3265" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;And&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ae1919a56a424217d7942d186776bb7154473a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атомный:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8847114c556e5aa0915a5a58f41de257fd15603b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic properties&lt;/strong&gt; :- When a variable assigned with atomic property that means it has only one thread access and it will be thread safe and will be good in performance perspective, will have default behaviour.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атомарные свойства&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : - Когда переменная, назначенная с атомарным свойством, которое означает, что она имеет доступ только к одному потоку и будет поточно-ориентированной и будет хорошей с точки зрения производительности, будет иметь поведение по умолчанию.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10970c29b4e931a96e449c43e2331815ca29c267" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic&lt;/strong&gt;     = thread safety</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атомный&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = потокобезопасность&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf1acd29fac53602f47b91d7c8afc125f052e57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomicity property attributes (atomic and nonatomic) are not reflected in the corresponding Swift property declaration, but the atomicity guarantees of the Objective-C implementation still hold when the imported property is accessed from Swift.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атрибуты свойств атомарности (атомарные и неатомарные) не отражены в соответствующем объявлении свойства Swift, но гарантии атомарности реализации Objective-C все еще сохраняются, когда к импортированному свойству обращаются из Swift.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d30e499b268ef956cffe268c4793a9718b721f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons :&lt;/strong&gt;
Chances of garbage value in case of multi-threading.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Минусы:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вероятность получения мусора в случае многопоточности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e4911144287afea7fb4bf6a0ef3999b2bb29492" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons :&lt;/strong&gt;
Performance hit, makes execution a little slower</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Минусы:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; производительность снижается, выполнение немного замедляется&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="234b4527dee6fe4a00dfe2bbf7a4bb066e7ff877" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget, this doesn't mean that the property as a whole is thread-safe. Only the method call of the setter/getter is. But if you use a setter and after that a getter at the same time with 2 different threads, it could be broken too!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не забывайте, это не означает, что свойство в целом является потокобезопасным. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Только вызов метода метода установки / получения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но если вы используете сеттер, а затем одновременно геттер с двумя разными потоками, он тоже может быть поврежден!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd1385db75a313e27cd1eb8e32ba179bf7f05987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Execution&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f1d5591d26cb3f294591f3efdff8f6b9e2481e94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to declare:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как объявить:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7811690ec89311f10f21d909af0798328148ae64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non Atomic Properties&lt;/strong&gt; :- When a variable assigned with atomic property that means it has multi thread access and it will not be thread safe and will be slow in performance perspective, will have default behaviour and when two different threads want to access variable at same time it will give unexpected results.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Неатомарные свойства&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : - Когда переменная, назначенная с атомарным свойством, которое означает, что она имеет многопоточный доступ, не будет поточно-ориентированной и будет медленной с точки зрения производительности, будет иметь поведение по умолчанию и когда два разных потока захотят получить доступ к переменной одновременно это даст неожиданные результаты.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6678f00c71129c25e8fad8de4d6883b313b1be14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-Atomic :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Неатомный:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8545b1c7ebcf7fbb96a330cc7553c4639fcd04f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-atomic&lt;/strong&gt; = No thread safety</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не атомарный&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = нет безопасности потока&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8601d32aec89322e75d4db57f8a0bc0221121029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now If *name property is atomic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь, если * name свойство является атомарным&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="151983afa96ad8bf924e8cee40345c29148887cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now If *name property is nonatomic&lt;/strong&gt; then</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь, если * name свойство неатомично,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; то&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc771fd41033a77969a605ae1d4d583af20dfab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros :&lt;/strong&gt;
Extremely fast execution.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Плюсы:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чрезвычайно быстрое исполнение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d428c41cc97f21b9ed84d34ebd585cbf9424fe05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros :&lt;/strong&gt;
Return of fully initialised objects each time makes it best choice in case of multi-threading.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Плюсы:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; возврат полностью инициализированных объектов каждый раз делает его лучшим выбором в случае многопоточности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5dd2654f3ebc510659995067c7118d35b3e88d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So &amp;mdash; if you define an atomic property in Objective-C it will remain atomic when used by Swift.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, если вы определите атомарное свойство в Objective-C, оно останется атомарным при использовании Swift.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d99c357ae636e2b3295a9622db183d6bbd34fa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is no such keyword &quot;atomic&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Там нет такого ключевого слова &quot;атомная&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b354ff06cc9df3b63e2688468d4f8a55f30ccb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What?! Are multithreading and &lt;a href=&quot;https://stackoverflow.com/questions/261683/what-is-meant-by-thread-safe-code&quot;&gt;thread safety&lt;/a&gt; different?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Какие?! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отличаются ли многопоточность и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/261683/what-is-meant-by-thread-safe-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;безопасность потоков&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c255bfcdaf01e1eed156159bb65466687e8bbb" translate="yes" xml:space="preserve">
          <source>AND in implementation file</source>
          <target state="translated">И в файле реализации</target>
        </trans-unit>
        <trans-unit id="031026e6565f207b619d61f36867d2bad1a58089" translate="yes" xml:space="preserve">
          <source>ARC | atomic | synthesized getter: 47</source>
          <target state="translated">atomic</target>
        </trans-unit>
        <trans-unit id="5cdbb3f5ce65e619a74e436ca69abc9e558570a5" translate="yes" xml:space="preserve">
          <source>ARC | nonatomic | synthesized getter: 38 (note: ARC's adding ref count cycling here)</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="4f64e38a90d15b8a6b6573bc690e9e02e460bc3e" translate="yes" xml:space="preserve">
          <source>Adding to this:</source>
          <target state="translated">Добавим к этому:</target>
        </trans-unit>
        <trans-unit id="005fcaf14fcbfa73d92d1ddda41994d6c9b6572e" translate="yes" xml:space="preserve">
          <source>After reading so many articles, Stack&amp;nbsp;Overflow posts and making demo applications to check variable property attributes, I decided to put all the attributes information together:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;После прочтения очень многих статей, публикаций Stack Overflow и создания демонстрационных приложений для проверки атрибутов переменных свойств, я решил собрать всю информацию об атрибутах:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97743bd8dd615d016758a893c5cacd3619f8ec85" translate="yes" xml:space="preserve">
          <source>All properties work parallelly (like asynchronously).</source>
          <target state="translated">Все свойства работают параллельно (как асинхронно).</target>
        </trans-unit>
        <trans-unit id="3dea8ae48d01239709fc42013945ab309b71b9be" translate="yes" xml:space="preserve">
          <source>Allowing to be read right in the middle of a 'not yet finished write or empty value' or not allowing and only allowing to read when the value is &lt;em&gt;fully&lt;/em&gt; written.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Позволяет читать прямо в середине &amp;laquo;еще не законченной записи или пустого значения&amp;raquo; или не разрешает и разрешает читать только тогда, когда значение &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;полностью&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; записано.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffe57890eea72d085b8c1756cf6ca03abeaf9aee" translate="yes" xml:space="preserve">
          <source>Although I pay close attention to performance, I still say &lt;strong&gt;Semantics First!&lt;/strong&gt;. Meanwhile, performance is a low priority for many projects. However, knowing execution details and costs of technologies you use certainly doesn't hurt. You should use the right technology for your needs, purposes, and abilities. Hopefully this will save you a few hours of comparisons, and help you make a better informed decision when designing your programs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хотя я уделяю пристальное внимание производительности, я по-прежнему говорю &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Semantics First! &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Между тем, производительность является низким приоритетом для многих проектов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако знание деталей исполнения и стоимости используемых вами технологий, безусловно, не повредит. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы должны использовать правильную технологию для ваших потребностей, целей и способностей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Надеюсь, это сэкономит вам несколько часов сравнений и поможет вам принять более обоснованное решение при разработке ваших программ.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cbd9d8863eeb2645be04a094bcbed84ed0f52b0" translate="yes" xml:space="preserve">
          <source>Another difference is that atomic properties will retain/release cycle your objects within the getter.</source>
          <target state="translated">Другое отличие состоит в том,что атомные свойства будут сохранять цикл освобождения ваших объектов в геттере.</target>
        </trans-unit>
        <trans-unit id="b90a1bc53199071cf2f05cf74dce10673fc22174" translate="yes" xml:space="preserve">
          <source>As atomic is default so,</source>
          <target state="translated">Так как атомный по умолчанию так и есть,</target>
        </trans-unit>
        <trans-unit id="669dc440babc6ff197e609915366d3ba4ec76a8c" translate="yes" xml:space="preserve">
          <source>As you have probably guessed, reference count activity/cycling is a significant contributor with atomics and under ARC. You would also see greater differences in contested cases.</source>
          <target state="translated">Как вы,вероятно,догадались,циклический подсчет активности ссылок является существенным вкладом с атомикой и под ARC.Вы также увидите большие различия в спорных случаях.</target>
        </trans-unit>
        <trans-unit id="5b1dca09059391e6197dc9be1c6f3ad674bb8c11" translate="yes" xml:space="preserve">
          <source>Assuming that you are @synthesizing the method implementations, atomic vs. non-atomic changes the generated code.  If you are writing your own setter/getters, atomic/nonatomic/retain/assign/copy are merely advisory.  (Note:  @synthesize is now the default behavior in recent versions of LLVM.  There is also no need to declare instance variables;  they will be synthesized automatically, too, and will have an &lt;code&gt;_&lt;/code&gt; prepended to their name to prevent accidental direct access).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предполагая, что вы @synthesizing реализации метода, атомарный против неатомарного изменения сгенерированного кода. Если вы пишете свой собственный установщик / получатель, атомарный / неатомный / сохранить / назначить / копировать просто рекомендации. (Примечание: @synthesize теперь является поведением по умолчанию в последних версиях LLVM. Также нет необходимости объявлять переменные экземпляра; они также будут автоматически синтезироваться и &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;к их имени &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;будет &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;добавляться &lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы предотвратить случайный прямой доступ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51aecdcbd1fa29f5e17a19748f03b1a72c7b0d7c" translate="yes" xml:space="preserve">
          <source>At the same time if you call</source>
          <target state="translated">В то же время,если вы позвоните</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="9b160c50dc810596cdf78df71886c71571d64371" translate="yes" xml:space="preserve">
          <source>Atomic - it can't be broken down, so the result is expected. With nonatomic - when another thread access the memory zone it can modify it, so the result is unexpected.</source>
          <target state="translated">Атомный-его нельзя сломать,поэтому результат ожидается.С неатомным-когда другой поток обращается к зоне памяти,он может ее модифицировать,поэтому результат будет неожиданным.</target>
        </trans-unit>
        <trans-unit id="56787168e1c9b9ef3ae0cf3dad2217f8eba7d6c7" translate="yes" xml:space="preserve">
          <source>Atomic &lt;strong&gt;doesn't&lt;/strong&gt; guarantee thread safety, though it's useful for achieving thread safety. Thread Safety is relative to how you write your code/ which thread queue you are reading/writing from. It only guarantees non-crashable multithreading.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Atomic &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; гарантирует безопасность потоков, хотя это полезно для достижения безопасности потоков. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Потокобезопасность связана с тем, как вы пишете свой код / ​​из какой очереди потока вы читаете / пишете. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это гарантирует только неразрушаемую многопоточность.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="158d5f3bbf986fce8d6f3929fb7a0ecce795cd2b" translate="yes" xml:space="preserve">
          <source>Atomic accessors in a non garbage collected environment (i.e. when using retain/release/autorelease) will use a lock to ensure that another thread doesn't interfere with the correct setting/getting of the value.</source>
          <target state="translated">Атомные аксессуары в среде,не собирающей мусор (т.е.при использовании retainreleaseautorelease),будут использовать блокировку,чтобы гарантировать,что другой поток не помешает правильной установке значения.</target>
        </trans-unit>
        <trans-unit id="89e66db1ad91cce7b2d346303a7b197d5ece77a4" translate="yes" xml:space="preserve">
          <source>Atomic guarantees that access to the property will be performed in an atomic manner. E.g. it always return a fully initialised objects, any get/set of a property on one thread must complete before another can access it.</source>
          <target state="translated">Атомные гарантии того,что доступ к собственности будет осуществляться атомным способом.Например,он всегда возвращает полностью инициализированные объекты,любое получение свойства на одном потоке должно быть завершено,прежде чем к другому потоку будет получен доступ.</target>
        </trans-unit>
        <trans-unit id="f5f7dedc45052e0d3aeb0e9c80106066a594e4ba" translate="yes" xml:space="preserve">
          <source>Atomic is &lt;strong&gt;thread safe&lt;/strong&gt;, it is &lt;strong&gt;slow&lt;/strong&gt; and it &lt;strong&gt;well-assures (not guaranteed)&lt;/strong&gt; that only the locked value is provided no matter how many threads are attempting access over the same zone. When using atomic, a piece of code written inside this function becomes the part of the critical section, to which only one thread can execute at a time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атомный &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;потокобезопасный&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , он &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;медленный,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и он &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;уверяет (не гарантирует),&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что предоставляется только заблокированное значение, независимо от того, сколько потоков пытается получить доступ через одну и ту же зону. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;При использовании atomic часть кода, написанная внутри этой функции, становится частью критической секции, в которую одновременно может работать только один поток.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7585badc81fcfc702a4b9198178ff361601c32cd" translate="yes" xml:space="preserve">
          <source>Atomic is the default: if you don&amp;rsquo;t type anything, your property is
  atomic. An atomic property is guaranteed that if you try to read from
  it, you will get back a valid value. It does not make any guarantees
  about what that value might be, but you will get back good data, not
  just junk memory. What this allows you to do is if you have multiple
  threads or multiple processes pointing at a single variable, one
  thread can read and another thread can write. If they hit at the same
  time, the reader thread is guaranteed to get one of the two values:
  either before the change or after the change. What atomic does not
  give you is any sort of guarantee about which of those values you
  might get. Atomic is really commonly confused with being thread-safe,
  and that is not correct. You need to guarantee your thread safety
  other ways. However, atomic will guarantee that if you try to read,
  you get back some kind of value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По умолчанию используется атомарный: если вы ничего не печатаете, ваше свойство атомарное. Атомарное свойство гарантировано, что если вы попытаетесь прочитать из него, вы получите верное значение. Это не дает никаких гарантий относительно того, каким может быть это значение, но вы получите хорошие данные, а не только ненужную память. Это позволяет вам, если у вас есть несколько потоков или несколько процессов, указывающих на одну переменную, один поток может читать, а другой поток может писать. Если они попадают в одно и то же время, поток чтения гарантированно получит одно из двух значений: либо до изменения, либо после изменения. То, что не дает вам атомарность, это какая-то гарантия того, какие из этих ценностей вы можете получить. Atomic обычно путают с поточностью потоков, и это не правильно. Вы должны гарантировать безопасность вашей нити другими способами.Тем не менее, Atomic гарантирует, что если вы попытаетесь читать, вы получите какое-то значение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c26403b797c5d1768fd18ce45b0e96426d55041b" translate="yes" xml:space="preserve">
          <source>Atomic make getter and setter of the property thread safe. for example if u have written :</source>
          <target state="translated">Atomic make getter and setter of the property thread safe.например,если u написал :</target>
        </trans-unit>
        <trans-unit id="ea657186686dc25af58658f7340d085ea2354148" translate="yes" xml:space="preserve">
          <source>Atomic means only one thread accesses the variable (static type). Atomic is thread-safe, but it is slow.</source>
          <target state="translated">Atomic означает,что только один поток обращается к переменной (статический тип).Atomic-потокобезопасен,но медленен.</target>
        </trans-unit>
        <trans-unit id="f6d05505130392ddbaadc6fa8e2fe878cbaf0010" translate="yes" xml:space="preserve">
          <source>Atomic means only one thread can access the variable at a time (static type). Atomic is thread-safe, but it is slow.</source>
          <target state="translated">Atomic означает,что только один поток может обращаться к переменной одновременно (статический тип).Atomic-потокобезопасен,но медленен.</target>
        </trans-unit>
        <trans-unit id="2c29d43758bf4c1706fdf7c909cd8aef22678f57" translate="yes" xml:space="preserve">
          <source>Atomic: Ensure thread-safety by locking the thread using NSLOCK.</source>
          <target state="translated">Атомный:Обеспечить безопасность резьбы путем блокировки резьбы с помощью NSLOCK.</target>
        </trans-unit>
        <trans-unit id="cd7773c6a864e0691a1de774e8c8593a1e851ce9" translate="yes" xml:space="preserve">
          <source>Basically, the atomic version has to take a lock in order to guarantee thread safety, and also is bumping the ref count on the object (and the autorelease count to balance it) so that the object is guaranteed to exist for the caller, otherwise there is a potential race condition if another thread is setting the value, causing the ref count to drop to 0.</source>
          <target state="translated">В принципе,для обеспечения безопасности потока атомарная версия должна взять блокировку,а также обрушить счетчик ссылок на объект (и счетчик авторелиза для его балансировки)так,чтобы объект гарантированно существовал для вызывающего,в противном случае существует потенциальное состояние гонки,если другой поток устанавливает значение,в результате чего счетчик ссылок падает до 0.</target>
        </trans-unit>
        <trans-unit id="dfc88261cc9b67c90909d642678537e41c4ff870" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;atomic&lt;/code&gt; variables can not be interrupted, the value contained by them at any point is (thread-lock) guaranteed to be &lt;strong&gt;uncorrupted&lt;/strong&gt;, although, ensuring this thread lock makes access to them slower. &lt;code&gt;non-atomic&lt;/code&gt; variables, on the other hand, make no such guarantee but do offer the luxury of quicker access. To sum it up, go with &lt;code&gt;non-atomic&lt;/code&gt; when you know your variables won't be accessed by multiple threads simultaneously and speed things up.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; переменные не могут быть прерваны, значение, содержащееся в них в любой точке (поточечная блокировка), гарантированно не будет &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;повреждено&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , хотя, гарантируя, что эта блокировка потока делает доступ к ним более медленным. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;non-atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; переменные, с другой стороны, не дают такой гарантии, но предлагают роскошь быстрого доступа. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подводя итог, перейдите к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;non-atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если вы знаете, что ваши переменные не будут доступны нескольким потокам одновременно, и это ускорит процесс.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5def4d181c0b234f6030c20a1065db3aa1e7656e" translate="yes" xml:space="preserve">
          <source>Before you begin: You must know that every object in memory needs to be deallocated from memory for a new writer to happen. You can't just simply write on top of something as you do on paper. You &lt;strong&gt;must&lt;/strong&gt; first erase (dealloc) it and then you can write onto it. If at the moment that the erase is done (or half done) and nothing &lt;strong&gt;has yet&lt;/strong&gt; been wrote (or half wrote) and you try to read it could be very problematic! Atomic and nonatomic help you treat this problem in different ways.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Прежде чем начать: Вы должны знать, что каждый объект в памяти должен быть освобожден из памяти, чтобы произошла новая запись. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы не можете просто написать поверх чего-либо, как на бумаге. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должны&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сначала стереть (dealloc) это, а затем вы можете написать на него. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если в момент, когда стирание выполнено (или наполовину выполнено) и ничего &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;еще&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не написано (или наполовину написано), и вы пытаетесь прочитать, это может быть очень проблематично! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атомные и неатомные помогают вам по-разному относиться к этой проблеме.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e19bbd7c23d0c7c4056f980c7f2cc203506c4688" translate="yes" xml:space="preserve">
          <source>But it is fast in performance</source>
          <target state="translated">Но по производительности она быстрая.</target>
        </trans-unit>
        <trans-unit id="59d1bb168c787f2090eeb85af65c9e07fbd0c969" translate="yes" xml:space="preserve">
          <source>But it is slow in performance</source>
          <target state="translated">Но он медленно работает</target>
        </trans-unit>
        <trans-unit id="466385388946acc99f6af4e50599b87b0caa1038" translate="yes" xml:space="preserve">
          <source>Code Talk :</source>
          <target state="translated">Кодовый разговор :</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="1bababff006e8f53086ecf6a193ae7c2dc1436a1" translate="yes" xml:space="preserve">
          <source>Crashing or not because of having or not having an autorelease pool.</source>
          <target state="translated">Сбой или нет из-за наличия или отсутствия пула авторелиза.</target>
        </trans-unit>
        <trans-unit id="4cf9c3f11dca2f6a00e2d96ff2141da6323e8c8b" translate="yes" xml:space="preserve">
          <source>Doesn't guarantee full written values to be read!</source>
          <target state="translated">Не гарантирует полное прочтение написанных значений!</target>
        </trans-unit>
        <trans-unit id="2a68c2b3f3d3b9d7f59544dacf5f1d2373fa8a26" translate="yes" xml:space="preserve">
          <source>Due to the number of optimizations and variations in implementations, it's quite difficult to measure real-world impacts in these contexts. You might often hear something like &quot;Trust it, unless you profile and find it is a problem&quot;. Due to the abstraction level, it's actually quite difficult to measure actual impact. Gleaning actual costs from profiles can be very time consuming, and due to abstractions, quite inaccurate. As well, ARC vs MRC can make a big difference.</source>
          <target state="translated">В связи с большим количеством оптимизаций и вариаций в реализациях,довольно сложно измерить реальное воздействие в этих условиях.Часто можно услышать что-то вроде &quot;Доверьтесь ему,если только Вы не составите профиль и не обнаружите,что это проблема&quot;.Из-за уровня абстракции,на самом деле довольно сложно измерить реальное воздействие.Получение фактических затрат от профилей может быть очень трудоемким,а из-за абстракций довольно неточным.Также,ARC против MRC может иметь большую разницу.</target>
        </trans-unit>
        <trans-unit id="dc588869b460d7a7c0dde78b8f7455e69c812d3c" translate="yes" xml:space="preserve">
          <source>Easiest answer first: There's no difference between your second two examples. By default, property accessors are atomic.</source>
          <target state="translated">Самый простой ответ первым:Нет разницы между вторыми двумя примерами.По умолчанию атрибуты доступа к свойствам атомарные.</target>
        </trans-unit>
        <trans-unit id="757cc03a89227c519cc7dc5a2bfb3c7e09103b83" translate="yes" xml:space="preserve">
          <source>Ensuring data integrity -- one of the primary challenges of multi-threaded programming -- is achieved by other means.</source>
          <target state="translated">Обеспечение целостности данных-одна из основных задач многопоточного программирования-достигается другими способами.</target>
        </trans-unit>
        <trans-unit id="952a7acd4884031a827584cd959102d7c27e63db" translate="yes" xml:space="preserve">
          <source>Example with MRC of a property with an ivar _internal:</source>
          <target state="translated">Пример с MRC собственности с ivar _internal:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="af66993b461bd3431cadd690caf86ea36449e356" translate="yes" xml:space="preserve">
          <source>First read &lt;a href=&quot;https://stackoverflow.com/questions/21098494/atomic-properties-vs-thread-safe-in-objective-c&quot;&gt;this&lt;/a&gt; question and then read &lt;a href=&quot;https://stackoverflow.com/a/589392/5175709&quot;&gt;Bbum's answer&lt;/a&gt;. In addition, then read my summary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сначала прочитайте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/21098494/atomic-properties-vs-thread-safe-in-objective-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этот&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вопрос, а затем прочитайте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/589392/5175709&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответ Bbum&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, тогда прочитайте мое резюме.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cecd6711aec49678ad292677bfd067b2bfe459b" translate="yes" xml:space="preserve">
          <source>For In Swift
Confirming that Swift properties are nonatomic in the ObjC sense. One reason is so you think about whether per-property atomicity is sufficient for your needs.</source>
          <target state="translated">For In Swift Confirming that Swift properties are nonatomic in the ObjC sense.Одна из причин заключается в том,что вы думаете о том,достаточно ли атомарности по свойствам для ваших нужд.</target>
        </trans-unit>
        <trans-unit id="0ea1177f91a4c498d582627a0507f246eb7808be" translate="yes" xml:space="preserve">
          <source>Fro more info please visit the website 
&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для получения дополнительной информации посетите веб-сайт &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db368e14ab7f01e913bc2e2e6d175b2110a3c9c9" translate="yes" xml:space="preserve">
          <source>Here's the interesting part: Performance using atomic property accesses in &lt;strong&gt;uncontested&lt;/strong&gt; (e.g. single-threaded) cases can be really very fast in some cases. In less than ideal cases, use of atomic accesses can cost more than 20 times the overhead of &lt;code&gt;nonatomic&lt;/code&gt;. While the &lt;strong&gt;Contested&lt;/strong&gt; case using 7 threads was 44 times slower for the three-byte struct (2.2&amp;nbsp;GHz &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core&amp;nbsp;i7&lt;/a&gt; Quad Core, x86_64). The three-byte struct is an example of a very slow property.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот интересная часть: производительность, использующая доступ к &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;элементарным&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; свойствам в &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;неоспоримых&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (например, однопоточных) случаях, в некоторых случаях может быть действительно очень высокой. В менее идеальных случаях, использование атомных доступов может стоить больше , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чем в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;20 раз накладных расходов на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . В &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;случае &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оспариваемого&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; случая, использующего 7 потоков, для трехбайтовой структуры было в 44 раза медленнее (2,2 ГГц &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Core i7&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Quad Core, x86_64). Трехбайтовая структура является примером очень медленного свойства.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42e679fd3d38e1ac2ae9fb1fd1602697916fa1ae" translate="yes" xml:space="preserve">
          <source>I found a pretty well put explanation of atomic and non-atomic properties &lt;a href=&quot;http://archive.atomicmpc.com.au/forums.asp?s=2&amp;amp;c=10&amp;amp;t=4594&quot;&gt;here&lt;/a&gt;. Here's some relevant text from the same:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я нашел довольно удачное объяснение атомных и неатомных свойств &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://archive.atomicmpc.com.au/forums.asp?s=2&amp;amp;c=10&amp;amp;t=4594&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот некоторые соответствующие тексты из того же:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0dcf329e22e36816a065b09cb8ea101357ebfd69" translate="yes" xml:space="preserve">
          <source>I'd always considered atomic as a default quite curious. At the abstraction level we work at, using atomic properties for a class as a vehicle to achieve 100% thread-safety is a corner case. For truly correct multithreaded programs, intervention by the programmer is almost certainly a requirement. Meanwhile, performance characteristics and execution have not&amp;nbsp;yet been detailed in depth. Having written some heavily multithreaded programs over the years, I had been declaring my properties as &lt;code&gt;nonatomic&lt;/code&gt; the entire time because atomic was not sensible for any purpose. During discussion of the details of atomic and nonatomic properties &lt;a href=&quot;https://stackoverflow.com/questions/12010211/use-of-atomic-properties-in-objective-c-any-side-effects&quot;&gt;this question&lt;/a&gt;, I did some profiling encountered some curious results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я всегда считал атомную по умолчанию довольно любопытной. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На уровне абстракции, над которым мы работаем, использование атомарных свойств для класса в качестве транспортного средства для достижения 100% -ной безопасности потока является ключевым случаем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для действительно правильных многопоточных программ вмешательство программиста почти наверняка является требованием. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Между тем, характеристики производительности и исполнения еще не были подробно описаны. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Написав несколько многопоточных программ за эти годы, я все время объявлял свои свойства &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потому что атомарные не имели смысла ни для каких целей. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Во время обсуждения деталей атомных и неатомных свойств &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12010211/use-of-atomic-properties-in-objective-c-any-side-effects&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;этого вопроса&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; я при профилировании столкнулся с любопытными результатами.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53df0d90dbfd2e8b81a9c6bdb363f7adf147a62d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;before&lt;/strong&gt; writing you &lt;strong&gt;have&lt;/strong&gt; erased that which was previously written on paper and then someone wants to read you &lt;em&gt;can&lt;/em&gt; still read. How? You will be reading from something similar to Mac OS Trash bin ( as Trash bin is not still 100% erased...it's in a limbo) ---&amp;gt; If ThreadA is to read while ThreadB has already deallocated to write, you would get a value from either the final fully written value by ThreadB or get something from autorelease pool.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;перед&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; тем писать вы &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;уже&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; стерта , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что ранее было написано на бумаге , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;а затем кто - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то хочет читать вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;можете&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; еще прочитать. Как? Вы будете читать что-то похожее на мусорное ведро Mac OS (так как мусорное ведро еще не удалено на 100% ... оно находится в подвешенном состоянии) ---&amp;gt; Если ThreadA должен читать, а ThreadB уже освобожден для записи, вы получите значение из окончательного полностью записанного значения ThreadB или получение чего-либо из пула автоматического выпуска.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aeb0ab7ed38eced8087358822adc1caacc3f25eb" translate="yes" xml:space="preserve">
          <source>If a thread changes the value of the instance the changed value is available to all the threads, and only one thread can change the value at a time.</source>
          <target state="translated">Если поток изменяет значение экземпляра,то измененное значение доступно всем потокам,и только один поток может изменять значение за раз.</target>
        </trans-unit>
        <trans-unit id="9cd5b7f015914683553101835da5c0b4775c2c87" translate="yes" xml:space="preserve">
          <source>If one person is trying to write and has only written 4 of the 8 letters to write, then no can read in the middle, the reading can only be done when all 8 letters is written --&amp;gt; No read(get) will happen on 'a thread that is still writing', i.e. if there are 8 bytes to bytes to be written, and only 4 bytes are written&amp;mdash;&amp;mdash;up to that moment, you are not allowed to read from it. But since I said it won't crash then it would read from the value of an &lt;em&gt;autoreleased&lt;/em&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если один человек пытается написать и написал только 4 из 8 писем для записи, то не может читать в середине, чтение может быть выполнено только тогда, когда написаны все 8 букв -&amp;gt; Не будет прочитано (получить) произойдет &amp;laquo;поток, который все еще пишет&amp;raquo;, т. е. если есть 8 байтов для байтов, которые должны быть записаны, и только 4 байта записаны - до этого момента вы не можете читать из него. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но так как я сказал, что он не будет аварийно &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;завершать работу,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; он будет считывать значение из &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;автоматически выпущенного&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; объекта.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e60a837b656fdb2a0431c6bc1d827b07c77b719" translate="yes" xml:space="preserve">
          <source>If the instance variable is not gonna be changed by multiple threads you can use it. It improves the performance.</source>
          <target state="translated">Если переменная экземпляра не будет изменяться несколькими потоками,ее можно использовать.Это улучшает производительность.</target>
        </trans-unit>
        <trans-unit id="fa7d0e9c8949d2b6aa328a9fec0cb7a660ef020c" translate="yes" xml:space="preserve">
          <source>If the property &quot;name&quot; was nonatomic, then all threads in above example - A,B, C and D will execute simultaneously producing any unpredictable result. In case of atomic, either one of A, B or C will execute first, but D can still execute in parallel.</source>
          <target state="translated">Если свойство &quot;name&quot; было неатомарным,то все потоки в вышеприведенном примере-A,B,C и D будут выполняться одновременно,приводя к любому непредсказуемому результату.В случае атомарного,сначала будет выполняться один из A,B или C,но D все равно может выполняться параллельно.</target>
        </trans-unit>
        <trans-unit id="fe485326675d7d2b88c23e0f595ee6a297fa4017" translate="yes" xml:space="preserve">
          <source>If two different people want to read and write at the same time, your paper won't just burn! --&amp;gt; Your application will never crash, even in a race condition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если два разных человека хотят читать и писать одновременно, ваша газета не просто сгорит! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-&amp;gt; Ваше приложение никогда не рухнет, даже в состоянии гонки.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2907fa671a851246609e65b92f375972d2b090d5" translate="yes" xml:space="preserve">
          <source>If you are using atomic, it means the thread will be safe and read-only. If you are using nonatomic, it means the multiple threads access the variable and is thread unsafe, but it is executed fast, done a read and write operations; this is a dynamic type.</source>
          <target state="translated">Если вы используете атом,это означает,что поток будет безопасен и доступен только для чтения.Если вы используете неатомарный тип,это означает,что несколько потоков обращаются к переменной и является потокобезопасным,но выполняется быстро,выполняются операции чтения и записи;это динамический тип.</target>
        </trans-unit>
        <trans-unit id="428f7d87b20e0ac4a9aac645a9382a64497f95b5" translate="yes" xml:space="preserve">
          <source>If you are using your property in multi-threaded code then you would be able to see the difference between nonatomic and atomic attributes. Nonatomic is faster than atomic and atomic is thread-safe, not nonatomic.</source>
          <target state="translated">Если вы используете свое свойство в многопоточном коде,то вы сможете увидеть разницу между неатомарными и атомарными атрибутами.Нонатомный быстрее,чем атомарный,и атомарный безопасен для потоков,а не неатомарный.</target>
        </trans-unit>
        <trans-unit id="bf0fc3cb78576b4927e58b55e16dad60b50135e6" translate="yes" xml:space="preserve">
          <source>If you call &quot;name&quot; from thread &lt;strong&gt;A&lt;/strong&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы называете &amp;laquo;имя&amp;raquo; из потока &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;А&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bed63c9b598ff3c1689b7a172b312f05c94268c" translate="yes" xml:space="preserve">
          <source>If you do not specify &quot;nonatomic&quot;, then the property is atomic, but you can still specify &quot;atomic&quot; explicitly in recent versions if you want to.</source>
          <target state="translated">Если вы не указываете &quot;неатомарный&quot;,то это свойство является атомарным,но вы все еще можете указывать &quot;atomic&quot; явно в последних версиях,если хотите.</target>
        </trans-unit>
        <trans-unit id="b3d25d57cfcaf0f91a92c71b555c13ca24c48562" translate="yes" xml:space="preserve">
          <source>If you imagine the following function occurring on two threads at once you can see why the results would not be pretty.</source>
          <target state="translated">Если представить себе следующую функцию,происходящую на двух потоках одновременно,то можно понять,почему результаты были бы некрасивы.</target>
        </trans-unit>
        <trans-unit id="ad0bd596c87dee16e9b201c0db38575508e5f5f7" translate="yes" xml:space="preserve">
          <source>Implication of &lt;code&gt;atomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смысл &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83e77580a4c5ad2c6ae90254011081aed2807ee6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;nonatomic&lt;/code&gt;, no such guarantees are made.   Thus, &lt;code&gt;nonatomic&lt;/code&gt; is considerably faster than &quot;atomic&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , такие гарантии не предоставляются. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; значительно быстрее, чем &amp;laquo;атомное&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8933d5f65d5f09ff3f586e9b3d5961e4504e9a90" translate="yes" xml:space="preserve">
          <source>In iOS, &lt;code&gt;@sychronise&lt;/code&gt; also provides the mutex lock .Now it serves in FIFO mode and ensures the flow is not affected by two classes sharing the same instance. However, if the task is on main thread, avoid accessing object using atomic properties as it may hold your UI and degrade the performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В iOS &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@sychronise&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также обеспечивает блокировку мьютекса. Теперь он работает в режиме FIFO и гарантирует, что на поток не влияют два класса, совместно использующие один и тот же экземпляр. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако, если задача находится в главном потоке, избегайте доступа к объекту с использованием атомарных свойств, так как это может задержать ваш пользовательский интерфейс и снизить производительность.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78dcc05a8b48a89d78a8a925227ef5c773900b55" translate="yes" xml:space="preserve">
          <source>In our context:</source>
          <target state="translated">В нашем контексте:</target>
        </trans-unit>
        <trans-unit id="b2fc2a31bbb825f80a48c090d06d5637549e56ef" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;strong&gt;Variable property attributes or modifiers in iOS&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt; you can find all the above-mentioned attributes, and that will definitely help you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В статье &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Атрибуты свойств переменных или модификаторы в iOS&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вы можете найти все вышеупомянутые атрибуты, и это определенно вам поможет.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b510c07af1689d04e0c92073219c7e5327f2a972" translate="yes" xml:space="preserve">
          <source>In this case, thread A could be renaming the object by calling &lt;code&gt;setFirstName:&lt;/code&gt; and then calling &lt;code&gt;setLastName:&lt;/code&gt;.   In the meantime, thread B may call &lt;code&gt;fullName&lt;/code&gt; in between thread A's two calls and will receive the new first name coupled with the old last name.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае поток А может переименовать объект, вызвав &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFirstName:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и затем вызвать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setLastName:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Между тем, поток B может вызвать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fullName&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; между двумя вызовами потока A и получит новое имя в сочетании со старой фамилией.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da9491d2fb2ea9a679ca39f1170f07c876da3d2d" translate="yes" xml:space="preserve">
          <source>Instance variables are thread-safe if they behave correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.</source>
          <target state="translated">Экземплярские переменные являются потокобезопасными,если они корректно ведут себя при обращении из нескольких потоков,независимо от планирования или чередования выполнения этих потоков средой исполнения,и без дополнительной синхронизации или иной координации со стороны вызывающего кода.</target>
        </trans-unit>
        <trans-unit id="88955b39760efe23b0a168fea5c46d327d69b8c0" translate="yes" xml:space="preserve">
          <source>Interesting side note: User-defined accessors of the three-byte struct were 52 times faster than the synthesized atomic accessors; or 84% the speed of synthesized nonatomic accessors.</source>
          <target state="translated">Интересная заметка:Пользовательские аксессоры трехбайтовой структуры были в 52 раза быстрее синтезированных атомных аксессоров;или 84% скорости синтезированных неатомных аксессоров.</target>
        </trans-unit>
        <trans-unit id="bd5f7aa29cdb5852e9c6134812d23c81d4c91dde" translate="yes" xml:space="preserve">
          <source>Is faster than atomic</source>
          <target state="translated">быстрее,чем атомный</target>
        </trans-unit>
        <trans-unit id="d9935d8df3697bfdf2e3d1810a602d26ae25554e" translate="yes" xml:space="preserve">
          <source>It is not actually a keyword.</source>
          <target state="translated">На самом деле это не ключевое слово.</target>
        </trans-unit>
        <trans-unit id="965f4053d5f6a421d7a99992699acc65a44280ac" translate="yes" xml:space="preserve">
          <source>It may result in unexpected behavior, when two different process (threads) access the same variable at the same time.</source>
          <target state="translated">Это может привести к неожиданному поведению,когда два разных процесса (потока)обращаются к одной и той же переменной одновременно.</target>
        </trans-unit>
        <trans-unit id="ff986039c13fe411fa26a6360a02bf568a2527f8" translate="yes" xml:space="preserve">
          <source>It only assures the thread safety; it does not guarantee that. &lt;strong&gt;What I mean is you hire an expert driver for you car, still it doesn't guarantees car won't meet an accident. However, probability remains the slightest.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это только гарантирует безопасность потока; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это не гарантирует этого. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я имею в виду, что вы нанимаете опытного водителя для своей машины, но это не гарантирует, что автомобиль не попадет в аварию. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако вероятность остается малейшей.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7e4c133e544fa1549014a474b3fdd79ecdd9b91" translate="yes" xml:space="preserve">
          <source>It will ensure value &quot;Sourov&quot; for A</source>
          <target state="translated">Это обеспечит значение &quot;Суров&quot; для A</target>
        </trans-unit>
        <trans-unit id="8aabb46c24820f1082cacf15fbe9319e591e75fa" translate="yes" xml:space="preserve">
          <source>It will return value &quot;Datta&quot; for A</source>
          <target state="translated">Он вернет значение &quot;Датта&quot; для A</target>
        </trans-unit>
        <trans-unit id="d1d66b8948b48962f8898cfc2c57c109d82eec4c" translate="yes" xml:space="preserve">
          <source>It will return value &quot;Datta&quot; for B</source>
          <target state="translated">Он вернёт значение &quot;Датта&quot; для B</target>
        </trans-unit>
        <trans-unit id="5a101e022a872ea8b43a671dbba37801c695a1a0" translate="yes" xml:space="preserve">
          <source>MRC | atomic | synthesized getter: 47</source>
          <target state="translated">atomic</target>
        </trans-unit>
        <trans-unit id="a9c588343e9c4452aa8db91f654be503b1635cd7" translate="yes" xml:space="preserve">
          <source>MRC | nonatomic | manually implemented getters: 2</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="3e6e15d6a8cbe6913bff385297e0082e4e14a0e8" translate="yes" xml:space="preserve">
          <source>MRC | nonatomic | synthesized getter: 7</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="f936ab0c829c9aaa1ec757b6c0fe8638f4147e53" translate="yes" xml:space="preserve">
          <source>Mutex lock, as per the name, locks the mutability of the object. So if the object is accessed by a class, no other class can access the same object.</source>
          <target state="translated">Блокировка мьютекса,в соответствии с именем,блокирует мутируемость объекта.Таким образом,если к объекту обращается класс,ни один другой класс не может получить доступ к тому же самому объекту.</target>
        </trans-unit>
        <trans-unit id="cf200f6a5c12c6aa0c00f246af59f0794bb918fd" translate="yes" xml:space="preserve">
          <source>Non atomic: Doesn't ensure thread-safety as there is no thread-locking mechanism.</source>
          <target state="translated">Неатомные:Не обеспечивает безопасность резьбы,так как нет механизма блокировки резьбы.</target>
        </trans-unit>
        <trans-unit id="cef6468ab63b7d41ecdaa4adabb0e5f0fb04e3f5" translate="yes" xml:space="preserve">
          <source>Non-Atomic</source>
          <target state="translated">Non-Atomic</target>
        </trans-unit>
        <trans-unit id="7265a45814aa6aabd0873b14668bcf5e20b299da" translate="yes" xml:space="preserve">
          <source>Nonatomic means multiple threads access the variable (dynamic type). Nonatomic is thread-unsafe, but it is fast.</source>
          <target state="translated">Неатомный означает,что несколько потоков обращаются к переменной (динамический тип).Нонатомный является потокобезопасным,но быстрым.</target>
        </trans-unit>
        <trans-unit id="40adcfc307e315b6e42a566334895747663e1977" translate="yes" xml:space="preserve">
          <source>Nonatomic means multiple threads can access the variable at same time (dynamic type). Nonatomic is thread-unsafe, but it is fast.</source>
          <target state="translated">Неатомный означает,что несколько потоков могут обращаться к переменной одновременно (динамический тип).Нонатомный является потокобезопасным,но быстрым.</target>
        </trans-unit>
        <trans-unit id="3bbe9a95845165551fded485e043fff87beb015a" translate="yes" xml:space="preserve">
          <source>Not as fast as &lt;code&gt;nonatomic&lt;/code&gt; because &lt;code&gt;nonatomic&lt;/code&gt; doesn't require any watchdog work on that from runtime .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Не так быстро, как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потому что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не требуют никакой сторожевой работы над этим из среды выполнения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b35330b19eb26e776ba809c005b85869c82196c" translate="yes" xml:space="preserve">
          <source>Now, the atomic variant is a bit more complicated:</source>
          <target state="translated">Атомный вариант немного сложнее:</target>
        </trans-unit>
        <trans-unit id="476e89eb6fdf9059091b1eff94b8ef25b54472b1" translate="yes" xml:space="preserve">
          <source>Objects in contested cases can also exceed 50 times.</source>
          <target state="translated">Объекты в спорных случаях также могут превышать 50 раз.</target>
        </trans-unit>
        <trans-unit id="2b4b3304ba3417b0a99cb67827234158af1d91b0" translate="yes" xml:space="preserve">
          <source>Ok. The first thing I would like to clear up is that the locking implementation is implementation-defined and abstracted. Louis uses &lt;code&gt;@synchronized(self)&lt;/code&gt; in his example -- I have seen this as a common source of confusion. The implementation does not &lt;em&gt;actually&lt;/em&gt; use &lt;code&gt;@synchronized(self)&lt;/code&gt;; it uses object level &lt;em&gt;spin locks&lt;/em&gt;. Louis's illustration is good for a high-level illustration using constructs we are all familiar with, but it's important to know it does not use &lt;code&gt;@synchronized(self)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ОК. Первое, что я хотел бы прояснить, это то, что реализация блокировки определяется реализацией и абстрагируется. Луи использует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в своем примере - я видел это как общий источник путаницы. Реализация на &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;самом деле&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; он использует &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;спин-блокировки на&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; уровне объекта &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. Иллюстрация Луи хороша для иллюстрации высокого уровня, использующей конструкции, с которыми мы все знакомы, но важно знать, что она не использует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eda76917b36b5a0223c73aefb7f0094260633e0" translate="yes" xml:space="preserve">
          <source>On the flip side, non-atomic, as you can probably guess, just means,
  &amp;ldquo;don&amp;rsquo;t do that atomic stuff.&amp;rdquo; What you lose is that guarantee that you
  always get back something. If you try to read in the middle of a
  write, you could get back garbage data. But, on the other hand, you go
  a little bit faster. Because atomic properties have to do some magic
  to guarantee that you will get back a value, they are a bit slower. If
  it is a property that you are accessing a lot, you may want to drop
  down to nonatomic to make sure that you are not incurring that speed
  penalty.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С другой стороны, неатомарное, как вы, вероятно, можете догадаться, просто означает &amp;laquo;не делайте этого атомарного материала&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То, что вы теряете, - это гарантия того, что вы всегда что-то получите &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы попытаетесь прочитать в середине записи, вы можете получить обратно данные мусора. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но, с другой стороны, вы идете немного быстрее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку атомарные свойства должны творить чудеса, чтобы гарантировать возвращение значения, они работают немного медленнее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это свойство, к которому вы часто обращаетесь, вы можете перейти к неатомному, чтобы убедиться, что вы не понесете этот штраф за скорость.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c81a07baf1e0c099e90ee1555e3bf169d497d6a" translate="yes" xml:space="preserve">
          <source>On the flip side, non-atomic, as you can probably guess, just means,
  &amp;ldquo;don&amp;rsquo;t do that atomic stuff.&amp;rdquo; What you lose is that guarantee that you
  always get back something. If you try to read in the middle of a
  write, you could get back garbage data. But, on the other hand, you go
  a little bit faster. Because atomic properties have to do some magic
  to guarantee that you will get back a value, they are a bit slower. If
  it is a property that you are accessing a lot, you may want to drop
  down to nonatomic to make sure that you are not incurring that speed
  penalty. Access</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С другой стороны, неатомарное, как вы, вероятно, можете догадаться, просто означает &amp;laquo;не делайте этого атомарного материала&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То, что вы теряете, - это гарантия того, что вы всегда что-то получите &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы попытаетесь прочитать в середине записи, вы можете получить обратно данные мусора. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но, с другой стороны, вы идете немного быстрее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку атомарные свойства должны творить чудеса, чтобы гарантировать возвращение значения, они работают немного медленнее. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это свойство, к которому вы часто обращаетесь, вы можете перейти к неатомному, чтобы убедиться, что вы не понесете этот штраф за скорость. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Доступ&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede7fdf8394bacfee2c5d9d6c6715fcc80fd5ca2" translate="yes" xml:space="preserve">
          <source>On the other hand does &lt;code&gt;nonatomic&lt;/code&gt; add nothing to your code. So it is only thread safe if you code security mechanism yourself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С другой стороны, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ничего &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;добавляют к вашему коду. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что это только потокобезопасно, если вы сами создаете механизм безопасности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f9e4693c5de190a913db87e5fffad315df67cf0" translate="yes" xml:space="preserve">
          <source>Overall they are different in 2 aspects:</source>
          <target state="translated">В целом они отличаются в двух аспектах:</target>
        </trans-unit>
        <trans-unit id="a8d21ad08d8d73e7da30d9ddc531902648d50e29" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://forums.developer.apple.com/thread/25642&quot;&gt;https://forums.developer.apple.com/thread/25642&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылка: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://forums.developer.apple.com/thread/25642&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://forums.developer.apple.com/thread/25642&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fecd72ac5703d1f089cc77fd529233801bb3a26" translate="yes" xml:space="preserve">
          <source>Retain counts are the way in which memory is managed in Objective-C.
  When you create an object, it has a retain count of 1. When you send
  an object a retain message, its retain count is incremented by 1. When
  you send an object a release message, its retain count is decremented
  by 1. When you send an object an &lt;strong&gt;autorelease message&lt;/strong&gt;, its retain count
  is decremented by 1 at some stage in the future. If an objectʼs retain
  count is reduced to 0, it is deallocated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сохранять счетчики - это способ управления памятью в Objective-C. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вы создаете объект, он имеет счет сохранения 1. Когда вы отправляете объекту сообщение сохранения, его счет хранения увеличивается на 1. Когда вы отправляете объекту сообщение об освобождении, его счет хранения уменьшается на 1. Когда вы отправьте объекту &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сообщение&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; об &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;автоматическом высвобождении&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , его количество сохранений будет уменьшено на 1 на каком-то этапе в будущем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если количество сохраняемых объектов уменьшается до 0, оно освобождается.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebe6555b66f03eb95c37f29257ced7d32e7dc117" translate="yes" xml:space="preserve">
          <source>See Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8036604&quot;&gt;I am getting issues if I use @property(atomic,retain)NSString *myString&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;См. Вопрос переполнения стека. У &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8036604&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;меня возникают проблемы, если я использую @property (atomic, retain) NSString * myString&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da147f788793e65a0755d642c4bb0e545a250a7" translate="yes" xml:space="preserve">
          <source>See more here: &lt;a href=&quot;https://realm.io/news/tmi-objective-c-property-attributes/&quot;&gt;https://realm.io/news/tmi-objective-c-property-attributes/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Смотрите больше здесь: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://realm.io/news/tmi-objective-c-property-attributes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://realm.io/news/tmi-objective-c-property-attributes/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7f269e276c1c10bb04cd4f5d00a647d81224fcd" translate="yes" xml:space="preserve">
          <source>See the &quot;&lt;a href=&quot;http://www.scribd.com/doc/121014348/89/Performance-and-Threading&quot;&gt;Performance and Threading&lt;/a&gt;&quot; section of Apple's Objective-C 2.0 documentation for some more information and for other considerations when creating multi-threaded apps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;См. Раздел &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.scribd.com/doc/121014348/89/Performance-and-Threading&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Производительность и многопоточность&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo; документации Apple Objective-C 2.0 для получения дополнительной информации и других соображений при создании многопоточных приложений.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48821aa7a0680f5b53cb1a6360cb3b3f30d0e1f3" translate="yes" xml:space="preserve">
          <source>Since there is no such thing like Mac OS Trash Bin, then nobody cares whether or not you always get a value (&amp;lt;-- This could potentially lead to a crash), nor anybody cares if someone tries to read halfway through your writing (although halfway writing in memory is very different from halfway writing on paper, on memory it could give you a crazy stupid value from before, while on paper you only see half of what's been written) --&amp;gt; Doesn't guarantee to not crash, because it doesn't use autorelease mechanism.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку не существует такой вещи, как мусорное ведро Mac OS, то никого не волнует, всегда ли вы получаете значение (&amp;lt;- это может привести к сбою), и никому нет дела, если кто-то пытается прочитать в середине вашего письма (хотя наполовину запись в памяти сильно отличается от написания наполовину на бумаге, в памяти это может дать вам сумасшедшее глупое значение, в то время как на бумаге вы видите только половину написанного) -&amp;gt; Не гарантирует, что не произойдет сбой, потому что это не использует механизм автоматического выпуска.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="113d393b69e044789d1b6366771234113f38b14f" translate="yes" xml:space="preserve">
          <source>So I'd be guessing that atomic in this case means the attribute reader methods cannot be interrupted - in effect meaning that the variable(s) being read by the method cannot change their value half way through because some other thread/call/function gets swapped onto the CPU.</source>
          <target state="translated">Таким образом,я бы догадался,что атомарный в данном случае означает,что методы чтения атрибутов не могут быть прерваны-в сущности,это означает,что считываемые методом переменные не могут изменить свое значение наполовину,так как какая-то другая потоком-вызовом функция переключается на CPU.</target>
        </trans-unit>
        <trans-unit id="69377ccc9052efea495fe71ce1907c01a47348e0" translate="yes" xml:space="preserve">
          <source>So let's step back, &lt;em&gt;not&lt;/em&gt; focussing on the implementation of property accesses, we'll include the usual suspects like &lt;code&gt;objc_msgSend&lt;/code&gt;, and examine some real-world high-level results for many calls to a &lt;code&gt;NSString&lt;/code&gt; getter in &lt;em&gt;uncontested&lt;/em&gt; cases (values in seconds):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, давайте вернемся назад, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сосредотачиваясь на реализации доступа к свойствам, мы включим обычные подозреваемые, такие как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;objc_msgSend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и рассмотрим некоторые реальные высокоуровневые результаты для многих обращений к &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;получателю &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;неоспоримых&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; случаях (значения в секундах):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e73cec755e1a5861f24f2339a99f042aded44c4" translate="yes" xml:space="preserve">
          <source>So these last two are the same:</source>
          <target state="translated">Значит,эти последние два одинаковые:</target>
        </trans-unit>
        <trans-unit id="0fa399823cc9a3b9c6fc88614e72860a2970f673" translate="yes" xml:space="preserve">
          <source>Such situation operation will perform serially.
 &lt;strong&gt;And Slow in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Такая ситуация операция будет выполнять поочередно. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И медленно в исполнении&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aef6c1df292141223c4225f95d65f2f8dd8d1cd6" translate="yes" xml:space="preserve">
          <source>Suppose a task related to three properties are</source>
          <target state="translated">Предположим,задача,связанная с тремя свойствами</target>
        </trans-unit>
        <trans-unit id="7fc22c24b2c8b9f7f69f63e17474f6fc605495d1" translate="yes" xml:space="preserve">
          <source>Suppose there is an atomic string property called &quot;name&quot;, and if you call &lt;code&gt;[self setName:@&quot;A&quot;]&lt;/code&gt; from thread A, call &lt;code&gt;[self setName:@&quot;B&quot;]&lt;/code&gt; from thread B, and call &lt;code&gt;[self name]&lt;/code&gt; from thread C, then all operations on different threads will be performed serially which means if one thread is executing a setter or getter, then other threads will wait.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, что есть атомарное строковое свойство с именем &amp;laquo;name&amp;raquo;, и если вы вызываете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self setName:@&quot;A&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из потока A, вызываете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self setName:@&quot;B&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из потока B и вызываете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self name]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; из поток C, тогда все операции в разных потоках будут выполняться последовательно, что означает, что если один поток выполняет установщик или получатель, то другие потоки будут ожидать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64bbc7da00d041882553632c9d6151a6047024d2" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default&lt;/strong&gt; is &lt;code&gt;atomic&lt;/code&gt;, this means it does cost you performance whenever you use the property, but it is thread safe. What Objective-C does, is set a lock, so only the actual thread may access the variable, as long as the setter/getter is executed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По умолчанию&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , это означает , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что делает стоить вам производительность всякого раза , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда вы используете свойство, но это поточно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что делает Objective-C, так это устанавливает блокировку, поэтому только фактический поток может получить доступ к переменной, пока выполняется установщик / получатель.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d29141c6d63a5b7ea6a09f9b7af2c90594dc0ae" translate="yes" xml:space="preserve">
          <source>The atomic property ensures to retain a fully initialised value irrespective of how many threads are doing getter &amp;amp; setter on it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Свойство atomic гарантирует сохранение полностью инициализированного значения независимо от того, сколько потоков выполняет для него getter &amp;amp; setter.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6640dea145fe359abf70ed10c4ea9eb6bb728dda" translate="yes" xml:space="preserve">
          <source>The best way to understand the difference is using the following example.</source>
          <target state="translated">Лучший способ понять разницу-использовать следующий пример.</target>
        </trans-unit>
        <trans-unit id="3134cf91b76122f389197dac0a38627d8e34e79b" translate="yes" xml:space="preserve">
          <source>The last two are identical; &quot;atomic&quot; is the default behavior (&lt;strike&gt;note that it is not actually a keyword; it is specified only by the absence of &lt;code&gt;nonatomic&lt;/code&gt;&lt;/strike&gt; -- &lt;code&gt;atomic&lt;/code&gt; was added as a keyword in recent versions of llvm/clang).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Последние два идентичны; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;atomic&amp;raquo; - это поведение по умолчанию ( &lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обратите внимание, что на самом деле это не ключевое слово; оно определяется только отсутствием &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в последних версиях llvm / clang в качестве ключевого слова был добавлен &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54da41fe44eb73968148a077b290f8b60c74912e" translate="yes" xml:space="preserve">
          <source>The nonatomic property specifies that synthesized accessors simply set or return a value directly, with no guarantees about what happens if that same value is accessed simultaneously from different threads.</source>
          <target state="translated">Неатомное свойство указывает,что синтезированные аксессоры просто устанавливают или возвращают значение напрямую,без каких-либо гарантий того,что произойдет,если одно и то же значение будет доступно одновременно из разных потоков.</target>
        </trans-unit>
        <trans-unit id="96d01ce85b72880373e3c0dcd3f3bc35a68d5182" translate="yes" xml:space="preserve">
          <source>The syntax and semantics are already well-defined by other excellent answers to this question. Because &lt;em&gt;execution&lt;/em&gt; and &lt;em&gt;performance&lt;/em&gt; are not detailed well, I will add my answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Синтаксис и семантика уже хорошо определены другими превосходными ответами на этот вопрос. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;исполнение&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;производительность&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не детализированы, я добавлю свой ответ.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9dd04fd3b87b8e6634cb35ae09b1210f69bb26fd" translate="yes" xml:space="preserve">
          <source>The truth is that they use spin lock to implement atomic property. The code as below:</source>
          <target state="translated">Правда в том,что они используют спиновой замок для реализации атомной собственности.Код,как ниже:</target>
        </trans-unit>
        <trans-unit id="90d87c12b9e2bb4e32e509af94e1f228c0cf3ed3" translate="yes" xml:space="preserve">
          <source>Then It will return value &quot;Datta&quot; for B</source>
          <target state="translated">Затем он вернет значение &quot;Датта&quot; для B.</target>
        </trans-unit>
        <trans-unit id="12a3f33c0a6d700d8d23d40a430ab7d0d07c038c" translate="yes" xml:space="preserve">
          <source>There are actually a large number of different variants of how these things work depending on whether the properties are scalar values or objects, and how retain, copy, readonly, nonatomic, etc interact. In general the property synthesizers just know how to do the &quot;right thing&quot; for all combinations.</source>
          <target state="translated">На самом деле существует большое количество различных вариантов того,как эти вещи работают в зависимости от того,являются ли свойства скалярными значениями или объектами,и как они сохраняют,копируют,только для чтения,нонатомичны и т.д.В общем,синтезаторы свойств просто знают,как сделать &quot;правильную вещь&quot; для всех комбинаций.</target>
        </trans-unit>
        <trans-unit id="1ca1757c9d44592c31915b42da6f23bdd121ea3e" translate="yes" xml:space="preserve">
          <source>This is explained in Apple's &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;documentation&lt;/a&gt;, but below are some examples of what is actually happening.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это объясняется в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;документации&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Apple &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, но ниже приведены некоторые примеры того, что на самом деле происходит.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="066c6b0a7801dd6a2523303a92225758599fcded" translate="yes" xml:space="preserve">
          <source>This makes property &quot;name&quot; read/write safe, but if another thread, D, calls &lt;code&gt;[name release]&lt;/code&gt; simultaneously then this operation might produce a crash because there is no setter/getter call involved here. Which means an object is read/write safe (ATOMIC), but not thread-safe as another threads can simultaneously send any type of messages to the object. The developer should ensure thread-safety for such objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это делает свойство &amp;laquo;имя&amp;raquo; доступным для чтения / записи, но если другой поток, D, вызывает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[name release]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; одновременно, то эта операция может привести к сбою, так как здесь нет вызова setter / getter. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что объект является безопасным для чтения / записи (ATOMIC), но не потокобезопасным, поскольку другие потоки могут одновременно отправлять объекту сообщения любого типа. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Разработчик должен обеспечить безопасность потоков для таких объектов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e11028386ce8d3ec51e22188331a6eee4d25d4eb" translate="yes" xml:space="preserve">
          <source>Thread safety:</source>
          <target state="translated">Безопасность резьбы:</target>
        </trans-unit>
        <trans-unit id="e0add02488dd9fb38cb10fde62581151af49ced0" translate="yes" xml:space="preserve">
          <source>To address this, you need a &lt;em&gt;transactional model&lt;/em&gt;.   I.e. some other kind of synchronization and/or exclusion that allows one to exclude access to &lt;code&gt;fullName&lt;/code&gt; while the dependent properties are being updated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для решения этой проблемы вам нужна &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;транзакционная модель&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Т.е. какой-то другой вид синхронизации и / или исключения, позволяющий исключить доступ к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fullName&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; во время обновления зависимых свойств.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5110af47a6444933e62ac77d9ec23d8337442dd9" translate="yes" xml:space="preserve">
          <source>To simplify the entire confusion, let us understand mutex lock.</source>
          <target state="translated">Чтобы упростить всю эту путаницу,давайте разберемся с мьютексным замком.</target>
        </trans-unit>
        <trans-unit id="bc1c0153c9c58e2e9e7658c0005457d1997dea11" translate="yes" xml:space="preserve">
          <source>Unlike Atomic, it doesn't ensure fully initialised object return each time.</source>
          <target state="translated">В отличие от Atomic,он не обеспечивает полный инициализированный возврат объекта каждый раз.</target>
        </trans-unit>
        <trans-unit id="b24c7b3b63fa45274145ca8bf271886c92e41e64" translate="yes" xml:space="preserve">
          <source>Vijayendra Tripathi has already given an example for a multi-threaded environment.</source>
          <target state="translated">Vijayendra Tripathi уже привела пример для многопоточной среды.</target>
        </trans-unit>
        <trans-unit id="282a30d041d8affe9efa43d4e1dc9b43e44779fb" translate="yes" xml:space="preserve">
          <source>We can use the above like</source>
          <target state="translated">Мы можем использовать вышеперечисленное,как</target>
        </trans-unit>
        <trans-unit id="e3ba9e816602170c61a435a2bd6558fcc1491c60" translate="yes" xml:space="preserve">
          <source>What &quot;atomic&quot; does &lt;strong&gt;not&lt;/strong&gt; do is make any guarantees about thread safety.  If thread A is calling the getter simultaneously with thread B and C calling the setter with different values, thread A may get any one of the three values returned -- the one prior to any setters being called or either of the values passed into the setters in B and C.  Likewise, the object may end up with the value from B or C, no way to tell.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То, что &amp;laquo;атомарный&amp;raquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; делает, это делает какие-либо гарантии безопасности потоков. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если поток A вызывает геттер одновременно, а поток B и C вызывают метод установки с разными значениями, поток A может получить любое из трех возвращенных значений - одно перед вызовом любого метода установки или любое из значений, переданных в методы установки. в B и C. Аналогично, объект может в конечном итоге получить значение из B или C, что никак нельзя сказать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75b417c352b35dcb29960132183fac99bea8692c" translate="yes" xml:space="preserve">
          <source>What do &lt;code&gt;atomic&lt;/code&gt; and &lt;code&gt;nonatomic&lt;/code&gt; mean in property declarations?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;означают &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в декларациях свойств?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f88aa3645b681f6cb9c6ef6394fafdf9591974e9" translate="yes" xml:space="preserve">
          <source>What is the functional difference between these 3?</source>
          <target state="translated">В чем функциональная разница между этими 3?</target>
        </trans-unit>
        <trans-unit id="b724b678520bf6613baa4fd73257c08dd17931cd" translate="yes" xml:space="preserve">
          <source>What is the operational difference between these three?</source>
          <target state="translated">В чем разница между этими тремя?</target>
        </trans-unit>
        <trans-unit id="f756614cb11bcdd5b59e27f02d997161f296ea51" translate="yes" xml:space="preserve">
          <source>What's the difference between the atomic and nonatomic attributes</source>
          <target state="translated">В чем разница между атомными и неатомными атрибутами.</target>
        </trans-unit>
        <trans-unit id="c64b1d527fee8009f5adc6a83e6a239d59e0ea51" translate="yes" xml:space="preserve">
          <source>Where to use &lt;code&gt;atomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Где использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7e7bc1f7a764eaa33b78b0b105cc9acc35d0b510" translate="yes" xml:space="preserve">
          <source>Where to use &lt;code&gt;nonatomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Где использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54566271c0cda41c75f32f014925fd367b3560c7" translate="yes" xml:space="preserve">
          <source>With &quot;atomic&quot;, the synthesized setter/getter will ensure that a &lt;em&gt;whole&lt;/em&gt; value is always returned from the getter or set by the setter, regardless of setter activity on any other thread.   That is, if thread A is in the middle of the getter while thread B calls the setter, an actual viable value -- an autoreleased object, most likely -- will be returned to the caller in A.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С &amp;laquo;атомарным&amp;raquo; синтезированный установщик / получатель будет гарантировать, что &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;целое&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; значение всегда возвращается из получателя или устанавливается установщиком, независимо от активности сеттера в любом другом потоке. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То есть, если поток A находится в середине метода получения, а поток B вызывает метод установки, фактическое жизнеспособное значение - объект с автоматически выпускаемым кодом, скорее всего, - будет возвращено вызывающей стороне в A.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c9a3225e3bb61264813e6bc22cf4e00afcb6175" translate="yes" xml:space="preserve">
          <source>Yes. Multithreading means: multiple threads can read a shared piece of data at the same time and we will not crash, yet it doesn't guarantee that you aren't reading from a non-autoreleased value. With thread safety, it's guaranteed that what you read is not auto-released. 
The reason that we don't make everything atomic by default is, that there is a performance cost and for most things don't really need thread safety. A few parts of our code need it and for those few parts, we need to write our code in a thread-safe way using locks, mutex or synchronization.</source>
          <target state="translated">Да.Многопоточность означает:несколько потоков могут одновременно читать общий кусок данных,и мы не прервемся,но это не гарантирует,что вы не будете читать из неавтоматического значения.С безопасностью потока гарантируется,что прочитанное не будет автоматически освобождено.Причина,по которой мы не делаем все атомарное по умолчанию,заключается в том,что есть стоимость производительности и для большинства вещей на самом деле не нужна нитевая безопасность.Несколько частей нашего кода нуждаются в этом,и для этих нескольких частей,мы должны написать наш код в потокобезопасным способом с использованием замков,мьютекса или синхронизации.</target>
        </trans-unit>
        <trans-unit id="4eeca7ec366447fc5ec19a0b9ad7e6b1fe0fb298" translate="yes" xml:space="preserve">
          <source>atomic (default)</source>
          <target state="translated">атомный (по умолчанию)</target>
        </trans-unit>
        <trans-unit id="4a63e825f62c5da736e35e342ff2c8a54bca26cd" translate="yes" xml:space="preserve">
          <source>courtesy
&lt;a href=&quot;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&quot;&gt;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&lt;/a&gt;</source>
          <target state="translated">courtesy
&lt;a href=&quot;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&quot;&gt;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f124574f61bdf32374632af0108e67664713163a" translate="yes" xml:space="preserve">
          <source>courtesy &lt;a href=&quot;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&quot;&gt;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вежливость &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32e276343305029c03cdcb3816d31d9b48ec3b8a" translate="yes" xml:space="preserve">
          <source>faster (for synthesized code, that is, for variables created using @property and @synthesize)</source>
          <target state="translated">быстрее (для синтезированного кода,то есть для переменных,созданных с помощью @property и @synthesize)</target>
        </trans-unit>
        <trans-unit id="b87d9f5aa62d639719db3c1cba82e1a8056395ba" translate="yes" xml:space="preserve">
          <source>from thread &lt;strong&gt;B&lt;/strong&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;из нити &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea03bbce1bf33f2a2f1f731974a10c0b4d23d189" translate="yes" xml:space="preserve">
          <source>if the instance variable is gonna be accessed in a multithreaded environment.</source>
          <target state="translated">если переменная экземпляра будет доступна в многопоточной среде.</target>
        </trans-unit>
        <trans-unit id="2a72dfc65f7a451001d4950d531af6251bac7c29" translate="yes" xml:space="preserve">
          <source>is NOT the default behavior</source>
          <target state="translated">НЕ является поведением по умолчанию</target>
        </trans-unit>
        <trans-unit id="f84f249f927c1237bd8d3f9d8beee88f0e82e524" translate="yes" xml:space="preserve">
          <source>is NOT thread safe.</source>
          <target state="translated">НЕ является безопасным для резьбы.</target>
        </trans-unit>
        <trans-unit id="c3f9636d3c7898c47849a2e162812438d24bdcd9" translate="yes" xml:space="preserve">
          <source>is not fast, as it ensures the process is completed entirely</source>
          <target state="translated">не быстрый,так как обеспечивает полное завершение процесса.</target>
        </trans-unit>
        <trans-unit id="73a390d781fdc2811cea29373d9b4ebafddb1cd6" translate="yes" xml:space="preserve">
          <source>is the default behavior</source>
          <target state="translated">поведение по умолчанию</target>
        </trans-unit>
        <trans-unit id="4490b997d646a855de50058e749d8a90da0b8e08" translate="yes" xml:space="preserve">
          <source>is thread safe.</source>
          <target state="translated">безопасен для резьбы.</target>
        </trans-unit>
        <trans-unit id="f05572b4d0844e4f8ee101746d55eb4ac8f137e3" translate="yes" xml:space="preserve">
          <source>may result in unexpected behavior, when two different process access the same variable at the same time</source>
          <target state="translated">может привести к неожиданному поведению,когда два разных процесса обращаются к одной и той же переменной одновременно</target>
        </trans-unit>
        <trans-unit id="3f5ed1fe4cc1bdb26194014d8b09d207046b8cce" translate="yes" xml:space="preserve">
          <source>nonatomic</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="c749558b48cd7f85853939c44d043c5ce6c52a24" translate="yes" xml:space="preserve">
          <source>not thread-safe</source>
          <target state="translated">небезопасный для резьбы</target>
        </trans-unit>
        <trans-unit id="4983137fc7b12c4757b165db2c0980a574bdd040" translate="yes" xml:space="preserve">
          <source>will ensure the present process is completed by the CPU, before another process accesses the variable</source>
          <target state="translated">обеспечит завершение текущего процесса процессором,прежде чем другой процесс получит доступ к переменной</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
