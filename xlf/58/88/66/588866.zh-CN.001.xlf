<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/588866">
    <body>
      <group id="588866">
        <trans-unit id="29411947b64337d949e3249a16a8087de5059836" translate="yes" xml:space="preserve">
          <source>'atomic' means it cannot be broken down. 
  In OS/programming terms an atomic function call is one that cannot be interrupted - the entire function must be executed, and not swapped out of the CPU by the OS's usual context switching until it's complete. Just in case you didn't know: since the CPU can only do one thing at a time, the OS rotates access to the CPU to all running processes in little time-slices, to give the &lt;em&gt;illusion&lt;/em&gt; of multitasking. The CPU scheduler can (and does) interrupt a process at any point in its execution - even in mid function call. So for actions like updating shared counter variables where two processes could try to update the variable at the same time, they must be executed 'atomically', i.e., each update action has to finish in its entirety before any other process can be swapped onto the CPU.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;原子&amp;rdquo;意味着它不能被分解。用OS /编程术语来说，原子函数调用是不能中断的-整个函数必须执行，并且直到完成后，才通过OS的常规上下文切换将其交换出CPU。以防万一您不知道：由于CPU一次只能做一件事，因此OS会在很短的时间内将对所有正在运行的进程的CPU访问权轮流旋转，给人一种&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;错觉&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多任务处理。 CPU调度程序可以（并且确实）在执行的任何时刻中断进程，即使是在函数调用中间也是如此。因此，对于诸如更新共享计数器变量之类的操作（其中两个进程可以尝试同时更新变量），必须&amp;ldquo;以原子方式&amp;rdquo;执行它们，即，每个更新操作必须完整完成，然后才能将任何其他进程交换到该进程上。中央处理器。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="65736baa892bc6f32d06472e7079b5cff8c9af94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assign&lt;/code&gt;             // Default</source>
          <target state="translated">&lt;code&gt;assign&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; //默认&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bac17a28340bcd4bfb53b1b5e3a83f2a13250a9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt;             // Default</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; //默认&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d882e76c1163761e47b5a0bb408737608a9242" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; is the default behavior</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是默认行为&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd25f9b1ee3c8eaa4226923ff82b96fd6eca134a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; is thread safe.</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是线程安全的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80e3a512b8083c4567a879d96cc0303bf08edd67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; means only one thread access the variable (static type).</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着只有一个线程访问该变量（静态类型）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff1d83cc3154ada7d25a25cffb2c0f316485b818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomicity&lt;/code&gt; of a single property also cannot guarantee thread safety when multiple dependent properties are in play.</source>
          <target state="translated">&lt;code&gt;atomicity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当多个从属属性在起作用时，单个属性的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;性也不能保证线程安全。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0676c9bf1fac4480032641cbb6a68b1b7b2be56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; is NOT default behavior. We need to add the &lt;code&gt;nonatomic&lt;/code&gt; keyword in the property attribute.</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是默认行为。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们需要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在property属性中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;添加&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b453d3a7a5746cdfc0be6127c5ee1332e4ae20b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; is thread-unsafe.</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是线程不安全的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="144c4b12fa77d18882a8cd254b25ce6824a3fd33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; means multiple thread access the variable (dynamic type).</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意味着多线程访问变量（动态类型）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94704458ff99f8b43566a1a29d92a57098a31b7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readwrite&lt;/code&gt;                 // Default</source>
          <target state="translated">&lt;code&gt;readwrite&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; //默认&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16fdeec49d31d634e8dd057a685b6f1a125f2dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strong = retain&lt;/code&gt;        // Default</source>
          <target state="translated">&lt;code&gt;strong = retain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; //默认&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1817be6d1b19c950de8c9a2fd3ae06f454649a42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Thats why non atomic is called thread unsafe But but it is fast in performance because of parallel execution&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是为什么非原子级称为线程不安全的原因，但是由于并行执行，它的性能很快&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cdd7cb3f0962dd785ee980cc0728796fe1f9761" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The keywords doesn't have to be written as first property attribute at all.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全不必将关键字写为第一属性。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a10d89828ebaa54d8102b7cb13ba8665b0b81b2" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Note that there is no &quot;atomic&quot; keyword, if you do not specify &quot;nonatomic&quot;, then the property is atomic, but specifying &quot;atomic&quot; explicitly will result in an error.&lt;/strike&gt;</source>
          <target state="translated">&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，没有&amp;ldquo; atomic&amp;rdquo;关键字，如果未指定&amp;ldquo; nonatomic&amp;rdquo;，则该属性为atomic，但是显式指定&amp;ldquo; atomic&amp;rdquo;将导致错误。&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="ffd409aa01eefdb8323b9fe5351b0b0a2ae95d7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-  Nonatomic means multiple thread access the variable(dynamic type).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-非原子意味着多线程访问变量（动态类型）。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="466db7383e12a27164e85bd429689284264834b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;- Nonatomic is thread unsafe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-非原子是线程不安全的。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36549c905b7712f2a9bd3e65321c0b4716e2e567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;- but it is fast in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-但性能很快&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ffaa095c82217a0d20db0b7833a8f1b5ded92da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Atomic is thread safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-原子是线程安全的。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="386c6c59efb1ceedd21973ad7d42db9e83d58724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Atomic means only one thread access the variable(static type).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Atomic表示仅一个线程访问该变量（静态类型）。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9289b20dbb4a5dfc44402b984b9b7fb71c00550" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Nonatomic is NOT default behavior, we need to add nonatomic keyword    in property attribute.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-nonatomic不是默认行为，我们需要在property属性中添加nonatomic关键字。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0c853f0aa5af920ea97541fcad5a333859dd74d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-but it is slow in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-但是性能很慢&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4f84e82d964d65d5331ec4dc31848f2f7892ac9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt; will ALWAYS guarantee&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将始终保证&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddde3b23162bbee9de624e2f156bcd96875a1c35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bb576a1c9d49b79e806ea0099e6c66b36101634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;nonatomic&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;nonatomic&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="716a0725bfe701eef013b5666a762ce35538990b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Atomicity
atomic (default)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子原子性（默认）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="568741eb5bb25f08010362cde0dec871c3a27255" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;That's why atomic is called thread Safe&lt;/em&gt;&lt;/strong&gt; and 
&lt;strong&gt;&lt;em&gt;That's why it is called read-write safe&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是为什么atomic称为线程安全&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，也 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就是为什么它称为读写安全的原因&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6db8014b9ff772505aa968a0f3cb71151a1dfeb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;nonatomic&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;nonatomic&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86bb8a493b4f26c9d609a3571320b145e83a3265" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;And&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ae1919a56a424217d7942d186776bb7154473a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8847114c556e5aa0915a5a58f41de257fd15603b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic properties&lt;/strong&gt; :- When a variable assigned with atomic property that means it has only one thread access and it will be thread safe and will be good in performance perspective, will have default behaviour.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子属性&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：-当一个分配了原子属性的变量时，它仅具有一个线程访问权限，并且将是线程安全的，并且在性能方面会很好，它将具有默认行为。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10970c29b4e931a96e449c43e2331815ca29c267" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic&lt;/strong&gt;     = thread safety</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; =线程安全&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf1acd29fac53602f47b91d7c8afc125f052e57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomicity property attributes (atomic and nonatomic) are not reflected in the corresponding Swift property declaration, but the atomicity guarantees of the Objective-C implementation still hold when the imported property is accessed from Swift.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子性属性（原子和非原子）没有反映在相应的Swift属性声明中，但是从Swift访问导入的属性时，Objective-C实现的原子性保证仍然有效。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d30e499b268ef956cffe268c4793a9718b721f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons :&lt;/strong&gt;
Chances of garbage value in case of multi-threading.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缺点：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 在多线程的情况下，可能会产生垃圾值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e4911144287afea7fb4bf6a0ef3999b2bb29492" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons :&lt;/strong&gt;
Performance hit, makes execution a little slower</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缺点：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 性能下降，执行速度变慢&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="234b4527dee6fe4a00dfe2bbf7a4bb066e7ff877" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget, this doesn't mean that the property as a whole is thread-safe. Only the method call of the setter/getter is. But if you use a setter and after that a getter at the same time with 2 different threads, it could be broken too!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不要忘记，这并不意味着整个属性都是线程安全的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅setter / getter的方法调用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果您同时使用setter和具有两个不同线程的getter，则它也可能会损坏！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd1385db75a313e27cd1eb8e32ba179bf7f05987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Execution&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f1d5591d26cb3f294591f3efdff8f6b9e2481e94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to declare:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何申报：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7811690ec89311f10f21d909af0798328148ae64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non Atomic Properties&lt;/strong&gt; :- When a variable assigned with atomic property that means it has multi thread access and it will not be thread safe and will be slow in performance perspective, will have default behaviour and when two different threads want to access variable at same time it will give unexpected results.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非原子属性&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：-当一个分配了原子属性的变量意味着它具有多线程访问权限，并且不是线程安全的，并且性能下降时，将具有默认行为，并且两个不同的线程希望同时访问该变量它会产生意想不到的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6678f00c71129c25e8fad8de4d6883b313b1be14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-Atomic :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非原子：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8545b1c7ebcf7fbb96a330cc7553c4639fcd04f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-atomic&lt;/strong&gt; = No thread safety</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非原子&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; =无线程安全&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8601d32aec89322e75d4db57f8a0bc0221121029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now If *name property is atomic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，如果* name属性是atomic&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="151983afa96ad8bf924e8cee40345c29148887cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now If *name property is nonatomic&lt;/strong&gt; then</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，如果* name属性是非原子的，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc771fd41033a77969a605ae1d4d583af20dfab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros :&lt;/strong&gt;
Extremely fast execution.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优点：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 执行速度极快。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d428c41cc97f21b9ed84d34ebd585cbf9424fe05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros :&lt;/strong&gt;
Return of fully initialised objects each time makes it best choice in case of multi-threading.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优点：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 在多线程的情况下，每次返回完全初始化的对象都是最佳选择。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5dd2654f3ebc510659995067c7118d35b3e88d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So &amp;mdash; if you define an atomic property in Objective-C it will remain atomic when used by Swift.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此-如果您在Objective-C中定义一个原子属性，当Swift使用它时它将保持原子性。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d99c357ae636e2b3295a9622db183d6bbd34fa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is no such keyword &quot;atomic&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有这样的关键字&amp;ldquo; atomic&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b354ff06cc9df3b63e2688468d4f8a55f30ccb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What?! Are multithreading and &lt;a href=&quot;https://stackoverflow.com/questions/261683/what-is-meant-by-thread-safe-code&quot;&gt;thread safety&lt;/a&gt; different?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么？！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多线程和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/261683/what-is-meant-by-thread-safe-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线程安全性&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是否&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不同？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c255bfcdaf01e1eed156159bb65466687e8bbb" translate="yes" xml:space="preserve">
          <source>AND in implementation file</source>
          <target state="translated">和在执行文件中</target>
        </trans-unit>
        <trans-unit id="031026e6565f207b619d61f36867d2bad1a58089" translate="yes" xml:space="preserve">
          <source>ARC | atomic | synthesized getter: 47</source>
          <target state="translated">atomic</target>
        </trans-unit>
        <trans-unit id="5cdbb3f5ce65e619a74e436ca69abc9e558570a5" translate="yes" xml:space="preserve">
          <source>ARC | nonatomic | synthesized getter: 38 (note: ARC's adding ref count cycling here)</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="4f64e38a90d15b8a6b6573bc690e9e02e460bc3e" translate="yes" xml:space="preserve">
          <source>Adding to this:</source>
          <target state="translated">在此基础上再加上。</target>
        </trans-unit>
        <trans-unit id="005fcaf14fcbfa73d92d1ddda41994d6c9b6572e" translate="yes" xml:space="preserve">
          <source>After reading so many articles, Stack&amp;nbsp;Overflow posts and making demo applications to check variable property attributes, I decided to put all the attributes information together:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在阅读了很多文章，Stack Overflow的帖子并制作了演示应用程序以检查可变属性属性之后，我决定将所有属性信息放在一起：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97743bd8dd615d016758a893c5cacd3619f8ec85" translate="yes" xml:space="preserve">
          <source>All properties work parallelly (like asynchronously).</source>
          <target state="translated">所有属性都是并行工作的(像异步一样)。</target>
        </trans-unit>
        <trans-unit id="3dea8ae48d01239709fc42013945ab309b71b9be" translate="yes" xml:space="preserve">
          <source>Allowing to be read right in the middle of a 'not yet finished write or empty value' or not allowing and only allowing to read when the value is &lt;em&gt;fully&lt;/em&gt; written.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许在&amp;ldquo;尚未完成的写入或空值&amp;rdquo;中间进行读取，或者不允许并且仅在值&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;写入&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;后才允许读取&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffe57890eea72d085b8c1756cf6ca03abeaf9aee" translate="yes" xml:space="preserve">
          <source>Although I pay close attention to performance, I still say &lt;strong&gt;Semantics First!&lt;/strong&gt;. Meanwhile, performance is a low priority for many projects. However, knowing execution details and costs of technologies you use certainly doesn't hurt. You should use the right technology for your needs, purposes, and abilities. Hopefully this will save you a few hours of comparisons, and help you make a better informed decision when designing your programs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管我非常关注性能，但我还是说&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语义第一！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时，对于许多项目而言，性能并不是优先事项。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，知道执行细节和所用技术的成本肯定不会受到损害。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您应该根据自己的需求，目的和能力使用正确的技术。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;希望这将节省您几个小时的比较，并帮助您在设计程序时做出更明智的决定。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cbd9d8863eeb2645be04a094bcbed84ed0f52b0" translate="yes" xml:space="preserve">
          <source>Another difference is that atomic properties will retain/release cycle your objects within the getter.</source>
          <target state="translated">另一个区别是,原子属性将保留你的对象在getter中的循环。</target>
        </trans-unit>
        <trans-unit id="b90a1bc53199071cf2f05cf74dce10673fc22174" translate="yes" xml:space="preserve">
          <source>As atomic is default so,</source>
          <target state="translated">由于Atomic是默认的,所以。</target>
        </trans-unit>
        <trans-unit id="669dc440babc6ff197e609915366d3ba4ec76a8c" translate="yes" xml:space="preserve">
          <source>As you have probably guessed, reference count activity/cycling is a significant contributor with atomics and under ARC. You would also see greater differences in contested cases.</source>
          <target state="translated">正如你可能已经猜到的那样,参考计数活动循环是与原子学和ARC下的一个重要贡献者。在有争议的情况下,你也会看到更大的差异。</target>
        </trans-unit>
        <trans-unit id="5b1dca09059391e6197dc9be1c6f3ad674bb8c11" translate="yes" xml:space="preserve">
          <source>Assuming that you are @synthesizing the method implementations, atomic vs. non-atomic changes the generated code.  If you are writing your own setter/getters, atomic/nonatomic/retain/assign/copy are merely advisory.  (Note:  @synthesize is now the default behavior in recent versions of LLVM.  There is also no need to declare instance variables;  they will be synthesized automatically, too, and will have an &lt;code&gt;_&lt;/code&gt; prepended to their name to prevent accidental direct access).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假定您正在@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@一起的一起的@@@@@@@@ @的合成时，原子对非原子对生成的代码进行的更改来实现。如果您正在编写自己的setter / getter，则原子/非原子/保留/分配/复制仅是建议性的。 （注意：@synthesize现在是LLVM的最新版本中的默认行为。也无需声明实例变量；它们也将自动合成，并且&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在其名称前加上&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以防止意外的直接访问）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51aecdcbd1fa29f5e17a19748f03b1a72c7b0d7c" translate="yes" xml:space="preserve">
          <source>At the same time if you call</source>
          <target state="translated">同时,如果你打电话给</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="9b160c50dc810596cdf78df71886c71571d64371" translate="yes" xml:space="preserve">
          <source>Atomic - it can't be broken down, so the result is expected. With nonatomic - when another thread access the memory zone it can modify it, so the result is unexpected.</source>
          <target state="translated">带原子性----它不能被分解,所以结果是意料之中的。用非原子性----当另一个线程访问内存区时,它可以修改它,所以结果是意料之外的。</target>
        </trans-unit>
        <trans-unit id="56787168e1c9b9ef3ae0cf3dad2217f8eba7d6c7" translate="yes" xml:space="preserve">
          <source>Atomic &lt;strong&gt;doesn't&lt;/strong&gt; guarantee thread safety, though it's useful for achieving thread safety. Thread Safety is relative to how you write your code/ which thread queue you are reading/writing from. It only guarantees non-crashable multithreading.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保证线程安全，尽管它对于实现线程安全很有用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线程安全与您编写代码的方式/从中读取/写入哪个线程队列有关。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它仅保证不可崩溃的多线程。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="158d5f3bbf986fce8d6f3929fb7a0ecce795cd2b" translate="yes" xml:space="preserve">
          <source>Atomic accessors in a non garbage collected environment (i.e. when using retain/release/autorelease) will use a lock to ensure that another thread doesn't interfere with the correct setting/getting of the value.</source>
          <target state="translated">非垃圾收集环境中的原子访问器(即使用 retainreleaseautorelease 时)会使用一个锁来确保另一个线程不会干扰值的正确设置getting。</target>
        </trans-unit>
        <trans-unit id="89e66db1ad91cce7b2d346303a7b197d5ece77a4" translate="yes" xml:space="preserve">
          <source>Atomic guarantees that access to the property will be performed in an atomic manner. E.g. it always return a fully initialised objects, any get/set of a property on one thread must complete before another can access it.</source>
          <target state="translated">Atomic保证了对属性的访问将以原子方式进行。例如,它总是返回一个完全初始化的对象,一个线程上的任何一个属性的getset必须在另一个线程访问它之前完成。</target>
        </trans-unit>
        <trans-unit id="f5f7dedc45052e0d3aeb0e9c80106066a594e4ba" translate="yes" xml:space="preserve">
          <source>Atomic is &lt;strong&gt;thread safe&lt;/strong&gt;, it is &lt;strong&gt;slow&lt;/strong&gt; and it &lt;strong&gt;well-assures (not guaranteed)&lt;/strong&gt; that only the locked value is provided no matter how many threads are attempting access over the same zone. When using atomic, a piece of code written inside this function becomes the part of the critical section, to which only one thread can execute at a time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Atomic是&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线程安全的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它运行&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓慢，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且可以&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很好地确保（无法保证）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论在同一区域上尝试访问多少线程，都仅提供锁定值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当使用原子时，写在此函数内部的一段代码成为关键部分的一部分，一次只能执行一个线程。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7585badc81fcfc702a4b9198178ff361601c32cd" translate="yes" xml:space="preserve">
          <source>Atomic is the default: if you don&amp;rsquo;t type anything, your property is
  atomic. An atomic property is guaranteed that if you try to read from
  it, you will get back a valid value. It does not make any guarantees
  about what that value might be, but you will get back good data, not
  just junk memory. What this allows you to do is if you have multiple
  threads or multiple processes pointing at a single variable, one
  thread can read and another thread can write. If they hit at the same
  time, the reader thread is guaranteed to get one of the two values:
  either before the change or after the change. What atomic does not
  give you is any sort of guarantee about which of those values you
  might get. Atomic is really commonly confused with being thread-safe,
  and that is not correct. You need to guarantee your thread safety
  other ways. However, atomic will guarantee that if you try to read,
  you get back some kind of value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子是默认设置：如果您不输入任何内容，则您的属性是原子的。原子属性可以保证，如果您尝试从中读取内容，则将取回有效值。它不能保证该值是多少，但是您将获得良好的数据，而不仅仅是垃圾内存。这允许您执行的操作是，如果您有多个线程或多个进程指向一个变量，则一个线程可以读取而另一个线程可以写入。如果它们同时命中，则保证读取器线程获得两个值之一：更改之前或更改之后。原子不会给您任何保证，您可能会获得这些值中的哪一个。原子通常确实与线程安全混淆，这是不正确的。您需要以其他方式保证线程安全。但是，atomic可以保证，如果您尝试阅读，则会获得某种价值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c26403b797c5d1768fd18ce45b0e96426d55041b" translate="yes" xml:space="preserve">
          <source>Atomic make getter and setter of the property thread safe. for example if u have written :</source>
          <target state="translated">Atomic使属性线程的getter和setter安全。</target>
        </trans-unit>
        <trans-unit id="ea657186686dc25af58658f7340d085ea2354148" translate="yes" xml:space="preserve">
          <source>Atomic means only one thread accesses the variable (static type). Atomic is thread-safe, but it is slow.</source>
          <target state="translated">Atomic意味着只有一个线程访问这个变量(静态类型)。Atomic是线程安全的,但速度很慢。</target>
        </trans-unit>
        <trans-unit id="f6d05505130392ddbaadc6fa8e2fe878cbaf0010" translate="yes" xml:space="preserve">
          <source>Atomic means only one thread can access the variable at a time (static type). Atomic is thread-safe, but it is slow.</source>
          <target state="translated">Atomic意味着一次只能有一个线程访问这个变量(静态类型)。Atomic是线程安全的,但速度很慢。</target>
        </trans-unit>
        <trans-unit id="2c29d43758bf4c1706fdf7c909cd8aef22678f57" translate="yes" xml:space="preserve">
          <source>Atomic: Ensure thread-safety by locking the thread using NSLOCK.</source>
          <target state="translated">Atomic。使用NSLOCK锁定线程,确保线程安全。</target>
        </trans-unit>
        <trans-unit id="cd7773c6a864e0691a1de774e8c8593a1e851ce9" translate="yes" xml:space="preserve">
          <source>Basically, the atomic version has to take a lock in order to guarantee thread safety, and also is bumping the ref count on the object (and the autorelease count to balance it) so that the object is guaranteed to exist for the caller, otherwise there is a potential race condition if another thread is setting the value, causing the ref count to drop to 0.</source>
          <target state="translated">基本上,原子版为了保证线程安全,必须采取锁的方式,同时也在颠簸对象上的ref计数(和自动释放计数来平衡),这样就可以保证对象对调用者来说是存在的,否则,如果另一个线程在设置值时,就会出现潜在的竞赛条件,导致ref计数降到0。</target>
        </trans-unit>
        <trans-unit id="dfc88261cc9b67c90909d642678537e41c4ff870" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;atomic&lt;/code&gt; variables can not be interrupted, the value contained by them at any point is (thread-lock) guaranteed to be &lt;strong&gt;uncorrupted&lt;/strong&gt;, although, ensuring this thread lock makes access to them slower. &lt;code&gt;non-atomic&lt;/code&gt; variables, on the other hand, make no such guarantee but do offer the luxury of quicker access. To sum it up, go with &lt;code&gt;non-atomic&lt;/code&gt; when you know your variables won't be accessed by multiple threads simultaneously and speed things up.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量不能被中断，所以保证它们在任何时候所包含的值（线程锁定）都不会被&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;破坏&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，尽管确保这种线程锁定会使访问它们的速度变慢。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;non-atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量不提供这样的保证，但确实提供了更快的访问权限。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总结起来，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您知道多个线程不会同时访问您的变量并加快处理速度时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，请使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;non-atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5def4d181c0b234f6030c20a1065db3aa1e7656e" translate="yes" xml:space="preserve">
          <source>Before you begin: You must know that every object in memory needs to be deallocated from memory for a new writer to happen. You can't just simply write on top of something as you do on paper. You &lt;strong&gt;must&lt;/strong&gt; first erase (dealloc) it and then you can write onto it. If at the moment that the erase is done (or half done) and nothing &lt;strong&gt;has yet&lt;/strong&gt; been wrote (or half wrote) and you try to read it could be very problematic! Atomic and nonatomic help you treat this problem in different ways.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;开始之前：您必须知道内存中的每个对象都需要从内存中重新分配，以使新的编写器能够发生。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您不能像在纸上一样简单地在某些东西上写字。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;先擦除（取消分配）它，然后才能对其进行写入。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果目前擦除已完成（或已完成一半），而&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尚未&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;写入任何内容（或已写入一半），而您尝试读取它，则可能会非常麻烦！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子和非原子可帮助您以不同方式解决此问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e19bbd7c23d0c7c4056f980c7f2cc203506c4688" translate="yes" xml:space="preserve">
          <source>But it is fast in performance</source>
          <target state="translated">但它在性能上是很快的</target>
        </trans-unit>
        <trans-unit id="59d1bb168c787f2090eeb85af65c9e07fbd0c969" translate="yes" xml:space="preserve">
          <source>But it is slow in performance</source>
          <target state="translated">但是,它的性能很慢</target>
        </trans-unit>
        <trans-unit id="466385388946acc99f6af4e50599b87b0caa1038" translate="yes" xml:space="preserve">
          <source>Code Talk :</source>
          <target state="translated">Code Talk :</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="1bababff006e8f53086ecf6a193ae7c2dc1436a1" translate="yes" xml:space="preserve">
          <source>Crashing or not because of having or not having an autorelease pool.</source>
          <target state="translated">撞车或不撞车,是因为有或没有自动驾驶池。</target>
        </trans-unit>
        <trans-unit id="4cf9c3f11dca2f6a00e2d96ff2141da6323e8c8b" translate="yes" xml:space="preserve">
          <source>Doesn't guarantee full written values to be read!</source>
          <target state="translated">并不保证完整的书面值可以被读取!</target>
        </trans-unit>
        <trans-unit id="2a68c2b3f3d3b9d7f59544dacf5f1d2373fa8a26" translate="yes" xml:space="preserve">
          <source>Due to the number of optimizations and variations in implementations, it's quite difficult to measure real-world impacts in these contexts. You might often hear something like &quot;Trust it, unless you profile and find it is a problem&quot;. Due to the abstraction level, it's actually quite difficult to measure actual impact. Gleaning actual costs from profiles can be very time consuming, and due to abstractions, quite inaccurate. As well, ARC vs MRC can make a big difference.</source>
          <target state="translated">由于优化的数量和实现方式的差异,在这些背景下,要衡量实际影响是相当困难的。你可能经常会听到一些类似 &quot;相信它,除非你剖析后发现它是个问题 &quot;的说法。由于抽象程度的原因,实际上很难衡量实际的影响。从配置文件中搜集实际成本可能非常耗费时间,而且由于抽象的原因,相当不准确。同样的,ARC与MRC也会有很大的区别。</target>
        </trans-unit>
        <trans-unit id="dc588869b460d7a7c0dde78b8f7455e69c812d3c" translate="yes" xml:space="preserve">
          <source>Easiest answer first: There's no difference between your second two examples. By default, property accessors are atomic.</source>
          <target state="translated">最容易回答的先说。你的后两个例子没有什么区别。默认情况下,属性访问器是原子性的。</target>
        </trans-unit>
        <trans-unit id="757cc03a89227c519cc7dc5a2bfb3c7e09103b83" translate="yes" xml:space="preserve">
          <source>Ensuring data integrity -- one of the primary challenges of multi-threaded programming -- is achieved by other means.</source>
          <target state="translated">确保数据的完整性 ----多线程编程的主要挑战之一 ----是通过其他方式实现的。</target>
        </trans-unit>
        <trans-unit id="952a7acd4884031a827584cd959102d7c27e63db" translate="yes" xml:space="preserve">
          <source>Example with MRC of a property with an ivar _internal:</source>
          <target state="translated">用MRC举例说明一个具有象牙塔_internal的财产。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="af66993b461bd3431cadd690caf86ea36449e356" translate="yes" xml:space="preserve">
          <source>First read &lt;a href=&quot;https://stackoverflow.com/questions/21098494/atomic-properties-vs-thread-safe-in-objective-c&quot;&gt;this&lt;/a&gt; question and then read &lt;a href=&quot;https://stackoverflow.com/a/589392/5175709&quot;&gt;Bbum's answer&lt;/a&gt;. In addition, then read my summary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先阅读&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/21098494/atomic-properties-vs-thread-safe-in-objective-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题，然后阅读&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/589392/5175709&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bbum的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，请阅读我的摘要。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cecd6711aec49678ad292677bfd067b2bfe459b" translate="yes" xml:space="preserve">
          <source>For In Swift
Confirming that Swift properties are nonatomic in the ObjC sense. One reason is so you think about whether per-property atomicity is sufficient for your needs.</source>
          <target state="translated">对于In Swift确认Swift属性在ObjC意义上是非原子性的。一个原因是让你思考每个属性的原子性是否足以满足你的需求。</target>
        </trans-unit>
        <trans-unit id="0ea1177f91a4c498d582627a0507f246eb7808be" translate="yes" xml:space="preserve">
          <source>Fro more info please visit the website 
&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关更多信息，请访问网站 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db368e14ab7f01e913bc2e2e6d175b2110a3c9c9" translate="yes" xml:space="preserve">
          <source>Here's the interesting part: Performance using atomic property accesses in &lt;strong&gt;uncontested&lt;/strong&gt; (e.g. single-threaded) cases can be really very fast in some cases. In less than ideal cases, use of atomic accesses can cost more than 20 times the overhead of &lt;code&gt;nonatomic&lt;/code&gt;. While the &lt;strong&gt;Contested&lt;/strong&gt; case using 7 threads was 44 times slower for the three-byte struct (2.2&amp;nbsp;GHz &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core&amp;nbsp;i7&lt;/a&gt; Quad Core, x86_64). The three-byte struct is an example of a very slow property.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是有趣的部分：&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在某些情况下，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无争议&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（例如单线程）情况下的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子属性访问&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以实现非常快的性能。在不太理想的情况下，使用原子访问的开销可能&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子访问开销的20倍以上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于三字节结构（2.2 GHz &lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Core i7&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;四核，x86_64），&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用7个线程&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;竞争&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况要慢44倍&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。三字节结构是一个非常慢的属性的示例。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42e679fd3d38e1ac2ae9fb1fd1602697916fa1ae" translate="yes" xml:space="preserve">
          <source>I found a pretty well put explanation of atomic and non-atomic properties &lt;a href=&quot;http://archive.atomicmpc.com.au/forums.asp?s=2&amp;amp;c=10&amp;amp;t=4594&quot;&gt;here&lt;/a&gt;. Here's some relevant text from the same:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我发现原子和非原子性的一个很好的解释放在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://archive.atomicmpc.com.au/forums.asp?s=2&amp;amp;c=10&amp;amp;t=4594&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是来自同一方面的一些相关文本：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0dcf329e22e36816a065b09cb8ea101357ebfd69" translate="yes" xml:space="preserve">
          <source>I'd always considered atomic as a default quite curious. At the abstraction level we work at, using atomic properties for a class as a vehicle to achieve 100% thread-safety is a corner case. For truly correct multithreaded programs, intervention by the programmer is almost certainly a requirement. Meanwhile, performance characteristics and execution have not&amp;nbsp;yet been detailed in depth. Having written some heavily multithreaded programs over the years, I had been declaring my properties as &lt;code&gt;nonatomic&lt;/code&gt; the entire time because atomic was not sensible for any purpose. During discussion of the details of atomic and nonatomic properties &lt;a href=&quot;https://stackoverflow.com/questions/12010211/use-of-atomic-properties-in-objective-c-any-side-effects&quot;&gt;this question&lt;/a&gt;, I did some profiling encountered some curious results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我一直都将atomic作为默认值感到非常好奇。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在我们的抽象层次上，使用原子属性作为类来实现100％线程安全是一种极端的情况。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于真正正确的多线程程序，几乎可以肯定需要程序员的干预。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时，性能特征和执行方式尚未深入。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已经写了一些严重的多线程程序，多年来，我一直宣称我的属性&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的全部时间，因为原子是不懂事用于任何目的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在讨论&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12010211/use-of-atomic-properties-in-objective-c-any-side-effects&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的原子和非原子特性的细节时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我进行了一些分析，并遇到了一些奇怪的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53df0d90dbfd2e8b81a9c6bdb363f7adf147a62d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;before&lt;/strong&gt; writing you &lt;strong&gt;have&lt;/strong&gt; erased that which was previously written on paper and then someone wants to read you &lt;em&gt;can&lt;/em&gt; still read. How? You will be reading from something similar to Mac OS Trash bin ( as Trash bin is not still 100% erased...it's in a limbo) ---&amp;gt; If ThreadA is to read while ThreadB has already deallocated to write, you would get a value from either the final fully written value by ThreadB or get something from autorelease pool.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;写&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已经&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;擦除了以前写在纸上的东西，然后有人想要阅读，您&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仍然&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读。怎么样？您将从类似Mac OS的垃圾箱中读取内容（由于垃圾箱仍未100％擦除...处于困境中）---&amp;gt;如果在ThreadB已经被释放分配进行写入的同时读取ThreadA，您将得到从ThreadB最终完全写入的值中获取一个值，或者从自动释放池中获取某些值。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aeb0ab7ed38eced8087358822adc1caacc3f25eb" translate="yes" xml:space="preserve">
          <source>If a thread changes the value of the instance the changed value is available to all the threads, and only one thread can change the value at a time.</source>
          <target state="translated">如果一个线程改变了实例的值,那么所有的线程都可以使用被改变的值,而且一次只能改变一个线程的值。</target>
        </trans-unit>
        <trans-unit id="9cd5b7f015914683553101835da5c0b4775c2c87" translate="yes" xml:space="preserve">
          <source>If one person is trying to write and has only written 4 of the 8 letters to write, then no can read in the middle, the reading can only be done when all 8 letters is written --&amp;gt; No read(get) will happen on 'a thread that is still writing', i.e. if there are 8 bytes to bytes to be written, and only 4 bytes are written&amp;mdash;&amp;mdash;up to that moment, you are not allowed to read from it. But since I said it won't crash then it would read from the value of an &lt;em&gt;autoreleased&lt;/em&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果一个人试图写并且只写了8个字母中的4个，那么中间没有人可以阅读，只有当所有8个字母都写完之后才能进行阅读-&amp;gt;不会发生read（get） &amp;ldquo;仍在写入的线程&amp;rdquo;，即如果要写入的字节数为8个字节，而仅写入4个字节，则直到此时为止，您都不允许从中读取。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是由于我说过它不会崩溃，所以它将从&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自动释放&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的值中读取&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e60a837b656fdb2a0431c6bc1d827b07c77b719" translate="yes" xml:space="preserve">
          <source>If the instance variable is not gonna be changed by multiple threads you can use it. It improves the performance.</source>
          <target state="translated">如果实例变量不会被多个线程改变,你可以使用它。这样可以提高性能。</target>
        </trans-unit>
        <trans-unit id="fa7d0e9c8949d2b6aa328a9fec0cb7a660ef020c" translate="yes" xml:space="preserve">
          <source>If the property &quot;name&quot; was nonatomic, then all threads in above example - A,B, C and D will execute simultaneously producing any unpredictable result. In case of atomic, either one of A, B or C will execute first, but D can still execute in parallel.</source>
          <target state="translated">如果属性 &quot;name &quot;是非原子性的,那么上面例子中的所有线程--A、B、C和D都会同时执行,产生任何不可预知的结果。如果是原子性的,那么A、B或C中的任何一个会先执行,但D仍然可以并行执行。</target>
        </trans-unit>
        <trans-unit id="fe485326675d7d2b88c23e0f595ee6a297fa4017" translate="yes" xml:space="preserve">
          <source>If two different people want to read and write at the same time, your paper won't just burn! --&amp;gt; Your application will never crash, even in a race condition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果两个不同的人想同时阅读和写作，那么您的论文将不会燃烧！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-&amp;gt;即使在竞争条件下，您的应用程序也绝不会崩溃。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2907fa671a851246609e65b92f375972d2b090d5" translate="yes" xml:space="preserve">
          <source>If you are using atomic, it means the thread will be safe and read-only. If you are using nonatomic, it means the multiple threads access the variable and is thread unsafe, but it is executed fast, done a read and write operations; this is a dynamic type.</source>
          <target state="translated">如果你使用的是原子型,就意味着线程安全,只读。如果你使用的是非原子型,则意味着多线程访问变量,是线程不安全的,但它的执行速度很快,完成了读写操作;这是一种动态类型。</target>
        </trans-unit>
        <trans-unit id="428f7d87b20e0ac4a9aac645a9382a64497f95b5" translate="yes" xml:space="preserve">
          <source>If you are using your property in multi-threaded code then you would be able to see the difference between nonatomic and atomic attributes. Nonatomic is faster than atomic and atomic is thread-safe, not nonatomic.</source>
          <target state="translated">如果你是在多线程代码中使用你的属性,那么你就能看出非原子属性和原子属性的区别。非原子属性比原子属性快,而原子属性是线程安全的,而不是非原子属性。</target>
        </trans-unit>
        <trans-unit id="bf0fc3cb78576b4927e58b55e16dad60b50135e6" translate="yes" xml:space="preserve">
          <source>If you call &quot;name&quot; from thread &lt;strong&gt;A&lt;/strong&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您从线程&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&amp;ldquo;名称&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bed63c9b598ff3c1689b7a172b312f05c94268c" translate="yes" xml:space="preserve">
          <source>If you do not specify &quot;nonatomic&quot;, then the property is atomic, but you can still specify &quot;atomic&quot; explicitly in recent versions if you want to.</source>
          <target state="translated">如果你不指定 &quot;非原子性&quot;,那么该属性就是原子性的,但如果你想的话,在最近的版本中仍然可以明确指定 &quot;原子性&quot;。</target>
        </trans-unit>
        <trans-unit id="b3d25d57cfcaf0f91a92c71b555c13ca24c48562" translate="yes" xml:space="preserve">
          <source>If you imagine the following function occurring on two threads at once you can see why the results would not be pretty.</source>
          <target state="translated">如果你想象以下功能同时发生在两个线程上,你就会明白为什么结果会不好看。</target>
        </trans-unit>
        <trans-unit id="ad0bd596c87dee16e9b201c0db38575508e5f5f7" translate="yes" xml:space="preserve">
          <source>Implication of &lt;code&gt;atomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;含义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83e77580a4c5ad2c6ae90254011081aed2807ee6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;nonatomic&lt;/code&gt;, no such guarantees are made.   Thus, &lt;code&gt;nonatomic&lt;/code&gt; is considerably faster than &quot;atomic&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，不会做出任何此类保证。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比&amp;ldquo;原子&amp;rdquo;要快得多。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8933d5f65d5f09ff3f586e9b3d5961e4504e9a90" translate="yes" xml:space="preserve">
          <source>In iOS, &lt;code&gt;@sychronise&lt;/code&gt; also provides the mutex lock .Now it serves in FIFO mode and ensures the flow is not affected by two classes sharing the same instance. However, if the task is on main thread, avoid accessing object using atomic properties as it may hold your UI and degrade the performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在iOS中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@sychronise&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还提供了互斥锁。现在，它以FIFO模式提供服务，并确保该流不受共享同一实例的两个类的影响。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果任务在主线程上，请避免使用原子属性访问对象，因为它可能会占用您的UI并降低性能。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78dcc05a8b48a89d78a8a925227ef5c773900b55" translate="yes" xml:space="preserve">
          <source>In our context:</source>
          <target state="translated">在我们的语境中。</target>
        </trans-unit>
        <trans-unit id="b2fc2a31bbb825f80a48c090d06d5637549e56ef" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;strong&gt;Variable property attributes or modifiers in iOS&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt; you can find all the above-mentioned attributes, and that will definitely help you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;iOS中的变量属性属性或修饰符一文中，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以找到上述所有属性，这肯定会对您有所帮助。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b510c07af1689d04e0c92073219c7e5327f2a972" translate="yes" xml:space="preserve">
          <source>In this case, thread A could be renaming the object by calling &lt;code&gt;setFirstName:&lt;/code&gt; and then calling &lt;code&gt;setLastName:&lt;/code&gt;.   In the meantime, thread B may call &lt;code&gt;fullName&lt;/code&gt; in between thread A's two calls and will receive the new first name coupled with the old last name.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，线程A可以通过调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFirstName:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;setLastName:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;setLastName：&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来重命名对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时，线程B可能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在线程A的两次调用之间&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fullName&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且将接收新的名字和旧的名字。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da9491d2fb2ea9a679ca39f1170f07c876da3d2d" translate="yes" xml:space="preserve">
          <source>Instance variables are thread-safe if they behave correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.</source>
          <target state="translated">如果实例变量在从多个线程访问时的行为是正确的,那么这些实例变量就是线程安全的,而不考虑运行时环境对这些线程的执行进行调度或交错,并且调用代码不需要额外的同步或其他协调。</target>
        </trans-unit>
        <trans-unit id="88955b39760efe23b0a168fea5c46d327d69b8c0" translate="yes" xml:space="preserve">
          <source>Interesting side note: User-defined accessors of the three-byte struct were 52 times faster than the synthesized atomic accessors; or 84% the speed of synthesized nonatomic accessors.</source>
          <target state="translated">有趣的是:用户定义的三字节结构的访问器的速度是合成原子访问器的52倍,是合成非原子访问器的84%。</target>
        </trans-unit>
        <trans-unit id="bd5f7aa29cdb5852e9c6134812d23c81d4c91dde" translate="yes" xml:space="preserve">
          <source>Is faster than atomic</source>
          <target state="translated">比原子弹快</target>
        </trans-unit>
        <trans-unit id="d9935d8df3697bfdf2e3d1810a602d26ae25554e" translate="yes" xml:space="preserve">
          <source>It is not actually a keyword.</source>
          <target state="translated">其实,这并不是一个关键词。</target>
        </trans-unit>
        <trans-unit id="965f4053d5f6a421d7a99992699acc65a44280ac" translate="yes" xml:space="preserve">
          <source>It may result in unexpected behavior, when two different process (threads) access the same variable at the same time.</source>
          <target state="translated">当两个不同的进程(线程)同时访问同一个变量时,可能会产生意想不到的行为。</target>
        </trans-unit>
        <trans-unit id="ff986039c13fe411fa26a6360a02bf568a2527f8" translate="yes" xml:space="preserve">
          <source>It only assures the thread safety; it does not guarantee that. &lt;strong&gt;What I mean is you hire an expert driver for you car, still it doesn't guarantees car won't meet an accident. However, probability remains the slightest.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它仅确保线程安全。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它不能保证。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的意思是，您为汽车聘请了专业的驾驶员，但这仍然不能保证汽车不会发生事故。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，可能性仍然很小。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7e4c133e544fa1549014a474b3fdd79ecdd9b91" translate="yes" xml:space="preserve">
          <source>It will ensure value &quot;Sourov&quot; for A</source>
          <target state="translated">它将确保A的价值 &quot;Sourov&quot;</target>
        </trans-unit>
        <trans-unit id="8aabb46c24820f1082cacf15fbe9319e591e75fa" translate="yes" xml:space="preserve">
          <source>It will return value &quot;Datta&quot; for A</source>
          <target state="translated">它将返回A的值 &quot;Datta&quot;。</target>
        </trans-unit>
        <trans-unit id="d1d66b8948b48962f8898cfc2c57c109d82eec4c" translate="yes" xml:space="preserve">
          <source>It will return value &quot;Datta&quot; for B</source>
          <target state="translated">它将返回B的值 &quot;Datta&quot;</target>
        </trans-unit>
        <trans-unit id="5a101e022a872ea8b43a671dbba37801c695a1a0" translate="yes" xml:space="preserve">
          <source>MRC | atomic | synthesized getter: 47</source>
          <target state="translated">atomic</target>
        </trans-unit>
        <trans-unit id="a9c588343e9c4452aa8db91f654be503b1635cd7" translate="yes" xml:space="preserve">
          <source>MRC | nonatomic | manually implemented getters: 2</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="3e6e15d6a8cbe6913bff385297e0082e4e14a0e8" translate="yes" xml:space="preserve">
          <source>MRC | nonatomic | synthesized getter: 7</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="f936ab0c829c9aaa1ec757b6c0fe8638f4147e53" translate="yes" xml:space="preserve">
          <source>Mutex lock, as per the name, locks the mutability of the object. So if the object is accessed by a class, no other class can access the same object.</source>
          <target state="translated">Mutex锁,顾名思义就是锁定对象的可变性。所以,如果对象被一个类访问,其他任何类都不能访问同一个对象。</target>
        </trans-unit>
        <trans-unit id="cf200f6a5c12c6aa0c00f246af59f0794bb918fd" translate="yes" xml:space="preserve">
          <source>Non atomic: Doesn't ensure thread-safety as there is no thread-locking mechanism.</source>
          <target state="translated">非原子性的。不能确保线程安全,因为没有线程锁定机制。</target>
        </trans-unit>
        <trans-unit id="cef6468ab63b7d41ecdaa4adabb0e5f0fb04e3f5" translate="yes" xml:space="preserve">
          <source>Non-Atomic</source>
          <target state="translated">Non-Atomic</target>
        </trans-unit>
        <trans-unit id="7265a45814aa6aabd0873b14668bcf5e20b299da" translate="yes" xml:space="preserve">
          <source>Nonatomic means multiple threads access the variable (dynamic type). Nonatomic is thread-unsafe, but it is fast.</source>
          <target state="translated">Nonatomic意味着多个线程访问变量(动态类型)。Nonatomic是线程不安全的,但它的速度很快。</target>
        </trans-unit>
        <trans-unit id="40adcfc307e315b6e42a566334895747663e1977" translate="yes" xml:space="preserve">
          <source>Nonatomic means multiple threads can access the variable at same time (dynamic type). Nonatomic is thread-unsafe, but it is fast.</source>
          <target state="translated">Nonatomic意味着多个线程可以同时访问该变量(动态类型)。Nonatomic是线程不安全的,但它的速度很快。</target>
        </trans-unit>
        <trans-unit id="3bbe9a95845165551fded485e043fff87beb015a" translate="yes" xml:space="preserve">
          <source>Not as fast as &lt;code&gt;nonatomic&lt;/code&gt; because &lt;code&gt;nonatomic&lt;/code&gt; doesn't require any watchdog work on that from runtime .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;速度快，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非原子的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不需要从运行时进行任何看门狗工作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b35330b19eb26e776ba809c005b85869c82196c" translate="yes" xml:space="preserve">
          <source>Now, the atomic variant is a bit more complicated:</source>
          <target state="translated">现在,原子变体就比较复杂了。</target>
        </trans-unit>
        <trans-unit id="476e89eb6fdf9059091b1eff94b8ef25b54472b1" translate="yes" xml:space="preserve">
          <source>Objects in contested cases can also exceed 50 times.</source>
          <target state="translated">争议案件中的对象也可以超过50次。</target>
        </trans-unit>
        <trans-unit id="2b4b3304ba3417b0a99cb67827234158af1d91b0" translate="yes" xml:space="preserve">
          <source>Ok. The first thing I would like to clear up is that the locking implementation is implementation-defined and abstracted. Louis uses &lt;code&gt;@synchronized(self)&lt;/code&gt; in his example -- I have seen this as a common source of confusion. The implementation does not &lt;em&gt;actually&lt;/em&gt; use &lt;code&gt;@synchronized(self)&lt;/code&gt;; it uses object level &lt;em&gt;spin locks&lt;/em&gt;. Louis's illustration is good for a high-level illustration using constructs we are all familiar with, but it's important to know it does not use &lt;code&gt;@synchronized(self)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好。我要清除的第一件事是锁定实现是实现定义和抽象的。路易&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在他的示例中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;－我已将其视为常见的混淆源。该实现&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上并不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ;它使用对象级&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自旋锁&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 Louis的插图非常适合使用我们都熟悉的结构进行高级插图，但重要的是要知道它不使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eda76917b36b5a0223c73aefb7f0094260633e0" translate="yes" xml:space="preserve">
          <source>On the flip side, non-atomic, as you can probably guess, just means,
  &amp;ldquo;don&amp;rsquo;t do that atomic stuff.&amp;rdquo; What you lose is that guarantee that you
  always get back something. If you try to read in the middle of a
  write, you could get back garbage data. But, on the other hand, you go
  a little bit faster. Because atomic properties have to do some magic
  to guarantee that you will get back a value, they are a bit slower. If
  it is a property that you are accessing a lot, you may want to drop
  down to nonatomic to make sure that you are not incurring that speed
  penalty.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，您可能会猜到，非原子只是表示&amp;ldquo;不要做原子的事情&amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您所失去的是确保您总是能得到一些回报。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果尝试在写入过程中进行读取，则可能会获取垃圾数据。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，另一方面，您走得更快。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为原子属性必须做一些魔术才能保证您将获得一个值，所以它们要慢一些。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果这是您经常访问的属性，则可能需要降低为非原子属性，以确保不会造成速度损失。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c81a07baf1e0c099e90ee1555e3bf169d497d6a" translate="yes" xml:space="preserve">
          <source>On the flip side, non-atomic, as you can probably guess, just means,
  &amp;ldquo;don&amp;rsquo;t do that atomic stuff.&amp;rdquo; What you lose is that guarantee that you
  always get back something. If you try to read in the middle of a
  write, you could get back garbage data. But, on the other hand, you go
  a little bit faster. Because atomic properties have to do some magic
  to guarantee that you will get back a value, they are a bit slower. If
  it is a property that you are accessing a lot, you may want to drop
  down to nonatomic to make sure that you are not incurring that speed
  penalty. Access</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，您可能会猜到，非原子只是表示&amp;ldquo;不要做原子的事情&amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您所失去的是确保您总是能得到一些回报。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果尝试在写入过程中进行读取，则可能会获取垃圾数据。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，另一方面，您走得更快。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为原子属性必须做一些魔术才能保证您将获得一个值，所以它们要慢一些。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果这是您经常访问的属性，则可能需要降低为非原子属性，以确保不会造成速度损失。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede7fdf8394bacfee2c5d9d6c6715fcc80fd5ca2" translate="yes" xml:space="preserve">
          <source>On the other hand does &lt;code&gt;nonatomic&lt;/code&gt; add nothing to your code. So it is only thread safe if you code security mechanism yourself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会向您的代码添加任何内容。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，只有您自己编写安全机制，这才是线程安全的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f9e4693c5de190a913db87e5fffad315df67cf0" translate="yes" xml:space="preserve">
          <source>Overall they are different in 2 aspects:</source>
          <target state="translated">总的来说,它们有2个方面的不同。</target>
        </trans-unit>
        <trans-unit id="a8d21ad08d8d73e7da30d9ddc531902648d50e29" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://forums.developer.apple.com/thread/25642&quot;&gt;https://forums.developer.apple.com/thread/25642&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参考：&lt;/font&gt;&lt;a href=&quot;https://forums.developer.apple.com/thread/25642&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//forums.developer.apple.com/thread/25642&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fecd72ac5703d1f089cc77fd529233801bb3a26" translate="yes" xml:space="preserve">
          <source>Retain counts are the way in which memory is managed in Objective-C.
  When you create an object, it has a retain count of 1. When you send
  an object a retain message, its retain count is incremented by 1. When
  you send an object a release message, its retain count is decremented
  by 1. When you send an object an &lt;strong&gt;autorelease message&lt;/strong&gt;, its retain count
  is decremented by 1 at some stage in the future. If an objectʼs retain
  count is reduced to 0, it is deallocated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保留计数是在Objective-C中管理内存的方式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建对象时，其保留计数为1。向对象发送保留消息时，其保留计数增加1。向对象发送释放消息时，其保留计数减少1。向对象发送&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自动释放消息&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其保留计数在将来的某个阶段递减1。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果对象的保留计数减少到0，则将其释放。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebe6555b66f03eb95c37f29257ced7d32e7dc117" translate="yes" xml:space="preserve">
          <source>See Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8036604&quot;&gt;I am getting issues if I use @property(atomic,retain)NSString *myString&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅堆栈溢出&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8036604&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题，如果我使用@property（atomic，retain）NSString * myString，则会遇到问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da147f788793e65a0755d642c4bb0e545a250a7" translate="yes" xml:space="preserve">
          <source>See more here: &lt;a href=&quot;https://realm.io/news/tmi-objective-c-property-attributes/&quot;&gt;https://realm.io/news/tmi-objective-c-property-attributes/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在此处查看更多信息：&lt;/font&gt;&lt;a href=&quot;https://realm.io/news/tmi-objective-c-property-attributes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//realm.io/news/tmi-objective-c-property-attributes/&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7f269e276c1c10bb04cd4f5d00a647d81224fcd" translate="yes" xml:space="preserve">
          <source>See the &quot;&lt;a href=&quot;http://www.scribd.com/doc/121014348/89/Performance-and-Threading&quot;&gt;Performance and Threading&lt;/a&gt;&quot; section of Apple's Objective-C 2.0 documentation for some more information and for other considerations when creating multi-threaded apps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一些更多信息以及创建多线程应用程序时的其他注意事项，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Apple的Objective-C 2.0文档&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.scribd.com/doc/121014348/89/Performance-and-Threading&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;性能和线程&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;部分。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48821aa7a0680f5b53cb1a6360cb3b3f30d0e1f3" translate="yes" xml:space="preserve">
          <source>Since there is no such thing like Mac OS Trash Bin, then nobody cares whether or not you always get a value (&amp;lt;-- This could potentially lead to a crash), nor anybody cares if someone tries to read halfway through your writing (although halfway writing in memory is very different from halfway writing on paper, on memory it could give you a crazy stupid value from before, while on paper you only see half of what's been written) --&amp;gt; Doesn't guarantee to not crash, because it doesn't use autorelease mechanism.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于没有像Mac OS Trash Bin这样的东西，所以没有人关心您是否始终获得价值（&amp;lt;-这可能导致崩溃），也没有人关心是否有人尝试在写作过程中进行阅读（尽管在内存中进行中途书写与在纸上进行中途书写有很大不同，在内存中它可能会给您一个从前的疯狂愚蠢的价值，而在纸上您只会看到所写内容的一半）-&amp;gt;不保证不会崩溃，因为它不使用自动释放机制。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="113d393b69e044789d1b6366771234113f38b14f" translate="yes" xml:space="preserve">
          <source>So I'd be guessing that atomic in this case means the attribute reader methods cannot be interrupted - in effect meaning that the variable(s) being read by the method cannot change their value half way through because some other thread/call/function gets swapped onto the CPU.</source>
          <target state="translated">所以我猜测,在这种情况下,原子性意味着属性读取方法不能被中断--实际上意味着被该方法读取的变量不能因为其他线程函数被换到CPU上而中途改变其值。</target>
        </trans-unit>
        <trans-unit id="69377ccc9052efea495fe71ce1907c01a47348e0" translate="yes" xml:space="preserve">
          <source>So let's step back, &lt;em&gt;not&lt;/em&gt; focussing on the implementation of property accesses, we'll include the usual suspects like &lt;code&gt;objc_msgSend&lt;/code&gt;, and examine some real-world high-level results for many calls to a &lt;code&gt;NSString&lt;/code&gt; getter in &lt;em&gt;uncontested&lt;/em&gt; cases (values in seconds):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，让我们退后一步，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;专注于属性访问的实现，我们将包括&lt;/font&gt;&lt;/font&gt; &lt;code&gt;objc_msgSend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样的常见可疑&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并在一些&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无争议的&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况下（以秒为单位的值）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;检查对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; getter的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多次调用的一些真实的高级结果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e73cec755e1a5861f24f2339a99f042aded44c4" translate="yes" xml:space="preserve">
          <source>So these last two are the same:</source>
          <target state="translated">所以最后这两个是一样的。</target>
        </trans-unit>
        <trans-unit id="0fa399823cc9a3b9c6fc88614e72860a2970f673" translate="yes" xml:space="preserve">
          <source>Such situation operation will perform serially.
 &lt;strong&gt;And Slow in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种情况操作将顺序执行。 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且性能慢&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aef6c1df292141223c4225f95d65f2f8dd8d1cd6" translate="yes" xml:space="preserve">
          <source>Suppose a task related to three properties are</source>
          <target state="translated">假设一个与三个属性相关的任务是</target>
        </trans-unit>
        <trans-unit id="7fc22c24b2c8b9f7f69f63e17474f6fc605495d1" translate="yes" xml:space="preserve">
          <source>Suppose there is an atomic string property called &quot;name&quot;, and if you call &lt;code&gt;[self setName:@&quot;A&quot;]&lt;/code&gt; from thread A, call &lt;code&gt;[self setName:@&quot;B&quot;]&lt;/code&gt; from thread B, and call &lt;code&gt;[self name]&lt;/code&gt; from thread C, then all operations on different threads will be performed serially which means if one thread is executing a setter or getter, then other threads will wait.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设有一个名为&amp;ldquo;名&amp;rdquo;原子串属性，如果你调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self setName:@&quot;A&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从线程A，调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self setName:@&quot;B&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从线程B，并调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self name]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从线程C，然后对不同线程的所有操作将依次执行，这意味着如果一个线程正在执行setter或getter，则其他线程将等待。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64bbc7da00d041882553632c9d6151a6047024d2" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default&lt;/strong&gt; is &lt;code&gt;atomic&lt;/code&gt;, this means it does cost you performance whenever you use the property, but it is thread safe. What Objective-C does, is set a lock, so only the actual thread may access the variable, as long as the setter/getter is executed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;默认情况下&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这意味着它无论您何时使用属性花费你的表现，但它是线程安全的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Objective-C的作用是设置一个锁，因此，只要执行了setter / getter，只有实际线程才能访问该变量。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d29141c6d63a5b7ea6a09f9b7af2c90594dc0ae" translate="yes" xml:space="preserve">
          <source>The atomic property ensures to retain a fully initialised value irrespective of how many threads are doing getter &amp;amp; setter on it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原子属性可确保保留完全初始化的值，而不管有多少线程正在对其执行getter和setter方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6640dea145fe359abf70ed10c4ea9eb6bb728dda" translate="yes" xml:space="preserve">
          <source>The best way to understand the difference is using the following example.</source>
          <target state="translated">最好的理解方法是用下面的例子。</target>
        </trans-unit>
        <trans-unit id="3134cf91b76122f389197dac0a38627d8e34e79b" translate="yes" xml:space="preserve">
          <source>The last two are identical; &quot;atomic&quot; is the default behavior (&lt;strike&gt;note that it is not actually a keyword; it is specified only by the absence of &lt;code&gt;nonatomic&lt;/code&gt;&lt;/strike&gt; -- &lt;code&gt;atomic&lt;/code&gt; was added as a keyword in recent versions of llvm/clang).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;后两个相同；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo; atomic&amp;rdquo;是默认行为（&lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，它实际上不是关键字；仅通过不存在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来指定&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在最近的llvm / clang版本中将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;atomic&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为关键字添加）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54da41fe44eb73968148a077b290f8b60c74912e" translate="yes" xml:space="preserve">
          <source>The nonatomic property specifies that synthesized accessors simply set or return a value directly, with no guarantees about what happens if that same value is accessed simultaneously from different threads.</source>
          <target state="translated">非原子属性规定,合成的访问器只需直接设置或返回一个值就可以了,如果从不同的线程同时访问相同的值,则不保证会发生什么。</target>
        </trans-unit>
        <trans-unit id="96d01ce85b72880373e3c0dcd3f3bc35a68d5182" translate="yes" xml:space="preserve">
          <source>The syntax and semantics are already well-defined by other excellent answers to this question. Because &lt;em&gt;execution&lt;/em&gt; and &lt;em&gt;performance&lt;/em&gt; are not detailed well, I will add my answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该问题的其他出色答案已经很好地定义了语法和语义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;性能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不够详细，我将添加我的答案。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9dd04fd3b87b8e6634cb35ae09b1210f69bb26fd" translate="yes" xml:space="preserve">
          <source>The truth is that they use spin lock to implement atomic property. The code as below:</source>
          <target state="translated">事实是,他们使用自旋锁来实现原子属性。代码如下所示。</target>
        </trans-unit>
        <trans-unit id="90d87c12b9e2bb4e32e509af94e1f228c0cf3ed3" translate="yes" xml:space="preserve">
          <source>Then It will return value &quot;Datta&quot; for B</source>
          <target state="translated">那么它将返回B的值 &quot;Datta&quot;。</target>
        </trans-unit>
        <trans-unit id="12a3f33c0a6d700d8d23d40a430ab7d0d07c038c" translate="yes" xml:space="preserve">
          <source>There are actually a large number of different variants of how these things work depending on whether the properties are scalar values or objects, and how retain, copy, readonly, nonatomic, etc interact. In general the property synthesizers just know how to do the &quot;right thing&quot; for all combinations.</source>
          <target state="translated">实际上,这些东西的工作方式有很多不同的变体,这取决于属性是标量值还是对象,以及 retain、copy、copy、readonly、nonomic等如何相互作用。一般来说,属性合成器只是知道如何为所有的组合做 &quot;正确的事情&quot;。</target>
        </trans-unit>
        <trans-unit id="1ca1757c9d44592c31915b42da6f23bdd121ea3e" translate="yes" xml:space="preserve">
          <source>This is explained in Apple's &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;documentation&lt;/a&gt;, but below are some examples of what is actually happening.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Apple的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中对此进行了说明，但以下是一些实际情况的示例。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="066c6b0a7801dd6a2523303a92225758599fcded" translate="yes" xml:space="preserve">
          <source>This makes property &quot;name&quot; read/write safe, but if another thread, D, calls &lt;code&gt;[name release]&lt;/code&gt; simultaneously then this operation might produce a crash because there is no setter/getter call involved here. Which means an object is read/write safe (ATOMIC), but not thread-safe as another threads can simultaneously send any type of messages to the object. The developer should ensure thread-safety for such objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这使属性&amp;ldquo;名称&amp;rdquo;的读/写安全，但是如果另一个线程D &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[name release]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则此操作可能会导致崩溃，因为此处不涉及setter / getter调用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着一个对象是读/写安全（ATOMIC）的，但不是线程安全的，因为另一个线程可以同时向该对象发送任何类型的消息。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;开发人员应确保此类对象的线程安全。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e11028386ce8d3ec51e22188331a6eee4d25d4eb" translate="yes" xml:space="preserve">
          <source>Thread safety:</source>
          <target state="translated">螺纹安全。</target>
        </trans-unit>
        <trans-unit id="e0add02488dd9fb38cb10fde62581151af49ced0" translate="yes" xml:space="preserve">
          <source>To address this, you need a &lt;em&gt;transactional model&lt;/em&gt;.   I.e. some other kind of synchronization and/or exclusion that allows one to exclude access to &lt;code&gt;fullName&lt;/code&gt; while the dependent properties are being updated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了解决这个问题，您需要一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;事务模型&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即某种其他类型的同步和/或排除，允许&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在更新从属属性时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排除对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fullName&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5110af47a6444933e62ac77d9ec23d8337442dd9" translate="yes" xml:space="preserve">
          <source>To simplify the entire confusion, let us understand mutex lock.</source>
          <target state="translated">为了简化整个困惑,我们来理解一下静音锁。</target>
        </trans-unit>
        <trans-unit id="bc1c0153c9c58e2e9e7658c0005457d1997dea11" translate="yes" xml:space="preserve">
          <source>Unlike Atomic, it doesn't ensure fully initialised object return each time.</source>
          <target state="translated">与Atomic不同的是,它不能保证每次都完全初始化对象返回。</target>
        </trans-unit>
        <trans-unit id="b24c7b3b63fa45274145ca8bf271886c92e41e64" translate="yes" xml:space="preserve">
          <source>Vijayendra Tripathi has already given an example for a multi-threaded environment.</source>
          <target state="translated">Vijayendra Tripathi已经给出了一个多线程环境的例子。</target>
        </trans-unit>
        <trans-unit id="282a30d041d8affe9efa43d4e1dc9b43e44779fb" translate="yes" xml:space="preserve">
          <source>We can use the above like</source>
          <target state="translated">我们可以用上面的方法来做,比如</target>
        </trans-unit>
        <trans-unit id="e3ba9e816602170c61a435a2bd6558fcc1491c60" translate="yes" xml:space="preserve">
          <source>What &quot;atomic&quot; does &lt;strong&gt;not&lt;/strong&gt; do is make any guarantees about thread safety.  If thread A is calling the getter simultaneously with thread B and C calling the setter with different values, thread A may get any one of the three values returned -- the one prior to any setters being called or either of the values passed into the setters in B and C.  Likewise, the object may end up with the value from B or C, no way to tell.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么&amp;ldquo;原子&amp;rdquo;并&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做的就是关于线程安全任何保证。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果线程A同时调用线程getter，而线程B和C同时调用具有不同值的setter，则线程A可能会获得返回的三个值中的任何一个-在调用任何setter之前的值之一，或者将其中一个值传递给setter同样，对象可能以B或C中的值结尾，无法分辨。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75b417c352b35dcb29960132183fac99bea8692c" translate="yes" xml:space="preserve">
          <source>What do &lt;code&gt;atomic&lt;/code&gt; and &lt;code&gt;nonatomic&lt;/code&gt; mean in property declarations?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;属性声明中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;意思？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f88aa3645b681f6cb9c6ef6394fafdf9591974e9" translate="yes" xml:space="preserve">
          <source>What is the functional difference between these 3?</source>
          <target state="translated">这3者在功能上有什么区别?</target>
        </trans-unit>
        <trans-unit id="b724b678520bf6613baa4fd73257c08dd17931cd" translate="yes" xml:space="preserve">
          <source>What is the operational difference between these three?</source>
          <target state="translated">这三者在操作上有什么区别?</target>
        </trans-unit>
        <trans-unit id="f756614cb11bcdd5b59e27f02d997161f296ea51" translate="yes" xml:space="preserve">
          <source>What's the difference between the atomic and nonatomic attributes</source>
          <target state="translated">原子属性和非原子属性有什么区别?</target>
        </trans-unit>
        <trans-unit id="c64b1d527fee8009f5adc6a83e6a239d59e0ea51" translate="yes" xml:space="preserve">
          <source>Where to use &lt;code&gt;atomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在哪里使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7e7bc1f7a764eaa33b78b0b105cc9acc35d0b510" translate="yes" xml:space="preserve">
          <source>Where to use &lt;code&gt;nonatomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在哪里使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54566271c0cda41c75f32f014925fd367b3560c7" translate="yes" xml:space="preserve">
          <source>With &quot;atomic&quot;, the synthesized setter/getter will ensure that a &lt;em&gt;whole&lt;/em&gt; value is always returned from the getter or set by the setter, regardless of setter activity on any other thread.   That is, if thread A is in the middle of the getter while thread B calls the setter, an actual viable value -- an autoreleased object, most likely -- will be returned to the caller in A.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&amp;ldquo; atomic&amp;rdquo;，合成的setter / getter将确保&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;始终从getter返回或由setter设置&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值，而不管任何其他线程上的setter活动如何。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也就是说，如果线程A在getter的中间，而线程B在调用setter时，则实际的可行值（很可能是自动释放的对象）将返回给A中的调用者。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c9a3225e3bb61264813e6bc22cf4e00afcb6175" translate="yes" xml:space="preserve">
          <source>Yes. Multithreading means: multiple threads can read a shared piece of data at the same time and we will not crash, yet it doesn't guarantee that you aren't reading from a non-autoreleased value. With thread safety, it's guaranteed that what you read is not auto-released. 
The reason that we don't make everything atomic by default is, that there is a performance cost and for most things don't really need thread safety. A few parts of our code need it and for those few parts, we need to write our code in a thread-safe way using locks, mutex or synchronization.</source>
          <target state="translated">是的,多线程的意思是:多个线程可以同时读取一个共享数据,我们不会崩溃。多线程的意思是:多个线程可以同时读取一个共享的数据,我们不会崩溃,然而它并不能保证你读到的不是自动释放的值。有了线程安全,可以保证你读到的东西不会自动释放。我们之所以不把所有的东西都默认为原子化,是因为有一个性能成本,对于大多数东西来说,其实不需要线程安全。我们的代码有几个部分需要它,而对于这几个部分,我们需要用锁、mutex或者同步的方式来写我们的代码,用线程安全的方式来写。</target>
        </trans-unit>
        <trans-unit id="4eeca7ec366447fc5ec19a0b9ad7e6b1fe0fb298" translate="yes" xml:space="preserve">
          <source>atomic (default)</source>
          <target state="translated">原子</target>
        </trans-unit>
        <trans-unit id="4a63e825f62c5da736e35e342ff2c8a54bca26cd" translate="yes" xml:space="preserve">
          <source>courtesy
&lt;a href=&quot;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&quot;&gt;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&lt;/a&gt;</source>
          <target state="translated">courtesy
&lt;a href=&quot;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&quot;&gt;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f124574f61bdf32374632af0108e67664713163a" translate="yes" xml:space="preserve">
          <source>courtesy &lt;a href=&quot;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&quot;&gt;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://academy.realm.io/posts/tmi-objective-c-property-attributes/提供&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32e276343305029c03cdcb3816d31d9b48ec3b8a" translate="yes" xml:space="preserve">
          <source>faster (for synthesized code, that is, for variables created using @property and @synthesize)</source>
          <target state="translated">更快(对于合成代码,也就是说,对于使用@property和@synthesize创建的变量,更快</target>
        </trans-unit>
        <trans-unit id="b87d9f5aa62d639719db3c1cba82e1a8056395ba" translate="yes" xml:space="preserve">
          <source>from thread &lt;strong&gt;B&lt;/strong&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从线程&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B开始&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea03bbce1bf33f2a2f1f731974a10c0b4d23d189" translate="yes" xml:space="preserve">
          <source>if the instance variable is gonna be accessed in a multithreaded environment.</source>
          <target state="translated">如果要在多线程环境中访问实例变量,那么就需要在多线程环境中访问。</target>
        </trans-unit>
        <trans-unit id="2a72dfc65f7a451001d4950d531af6251bac7c29" translate="yes" xml:space="preserve">
          <source>is NOT the default behavior</source>
          <target state="translated">不是默认的行为</target>
        </trans-unit>
        <trans-unit id="f84f249f927c1237bd8d3f9d8beee88f0e82e524" translate="yes" xml:space="preserve">
          <source>is NOT thread safe.</source>
          <target state="translated">是不安全的。</target>
        </trans-unit>
        <trans-unit id="c3f9636d3c7898c47849a2e162812438d24bdcd9" translate="yes" xml:space="preserve">
          <source>is not fast, as it ensures the process is completed entirely</source>
          <target state="translated">并不快,因为它确保了整个过程的完成。</target>
        </trans-unit>
        <trans-unit id="73a390d781fdc2811cea29373d9b4ebafddb1cd6" translate="yes" xml:space="preserve">
          <source>is the default behavior</source>
          <target state="translated">是默认的行为</target>
        </trans-unit>
        <trans-unit id="4490b997d646a855de50058e749d8a90da0b8e08" translate="yes" xml:space="preserve">
          <source>is thread safe.</source>
          <target state="translated">是线程安全的。</target>
        </trans-unit>
        <trans-unit id="f05572b4d0844e4f8ee101746d55eb4ac8f137e3" translate="yes" xml:space="preserve">
          <source>may result in unexpected behavior, when two different process access the same variable at the same time</source>
          <target state="translated">当两个不同的进程同时访问同一个变量时,可能会产生意想不到的行为。</target>
        </trans-unit>
        <trans-unit id="3f5ed1fe4cc1bdb26194014d8b09d207046b8cce" translate="yes" xml:space="preserve">
          <source>nonatomic</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="c749558b48cd7f85853939c44d043c5ce6c52a24" translate="yes" xml:space="preserve">
          <source>not thread-safe</source>
          <target state="translated">不安全</target>
        </trans-unit>
        <trans-unit id="4983137fc7b12c4757b165db2c0980a574bdd040" translate="yes" xml:space="preserve">
          <source>will ensure the present process is completed by the CPU, before another process accesses the variable</source>
          <target state="translated">将确保目前的进程在另一个进程访问变量之前由CPU完成</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
