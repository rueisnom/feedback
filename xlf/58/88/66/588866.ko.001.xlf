<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/588866">
    <body>
      <group id="588866">
        <trans-unit id="29411947b64337d949e3249a16a8087de5059836" translate="yes" xml:space="preserve">
          <source>'atomic' means it cannot be broken down. 
  In OS/programming terms an atomic function call is one that cannot be interrupted - the entire function must be executed, and not swapped out of the CPU by the OS's usual context switching until it's complete. Just in case you didn't know: since the CPU can only do one thing at a time, the OS rotates access to the CPU to all running processes in little time-slices, to give the &lt;em&gt;illusion&lt;/em&gt; of multitasking. The CPU scheduler can (and does) interrupt a process at any point in its execution - even in mid function call. So for actions like updating shared counter variables where two processes could try to update the variable at the same time, they must be executed 'atomically', i.e., each update action has to finish in its entirety before any other process can be swapped onto the CPU.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'원자'는 분류 할 수 없음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OS / 프로그래밍 용어에서 원자 함수 호출은 중단 할 수없는 호출입니다. 전체 함수를 실행해야하며, 완료 될 때까지 OS의 일반적인 컨텍스트 전환으로 CPU에서 스왑하지 않아야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알 수없는 경우 : CPU가 한 번에 하나의 작업 만 수행 할 수 있기 때문에 OS는 작은 시간 조각으로 실행중인 모든 프로세스에 대한 CPU 액세스를 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;환상으로 전환합니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 태스킹 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CPU 스케줄러는 실행 중 언제라도 (중간 함수 호출에서도) 프로세스를 중단시킬 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 두 프로세스가 동시에 변수를 업데이트하려고 시도 할 수있는 공유 카운터 변수 업데이트와 같은 작업의 경우 '원자 적으로'실행되어야합니다. 즉, 다른 프로세스로 스왑하기 전에 각 업데이트 작업이 완전히 완료되어야합니다. CPU.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="65736baa892bc6f32d06472e7079b5cff8c9af94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assign&lt;/code&gt;             // Default</source>
          <target state="translated">&lt;code&gt;assign&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // 기본&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bac17a28340bcd4bfb53b1b5e3a83f2a13250a9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt;             // Default</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // 기본&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01d882e76c1163761e47b5a0bb408737608a9242" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; is the default behavior</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 기본 행동입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd25f9b1ee3c8eaa4226923ff82b96fd6eca134a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; is thread safe.</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 스레드 안전합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80e3a512b8083c4567a879d96cc0303bf08edd67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic&lt;/code&gt; means only one thread access the variable (static type).</source>
          <target state="translated">&lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 하나의 스레드 만 변수 (정적 유형)에 액세스 함을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff1d83cc3154ada7d25a25cffb2c0f316485b818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomicity&lt;/code&gt; of a single property also cannot guarantee thread safety when multiple dependent properties are in play.</source>
          <target state="translated">&lt;code&gt;atomicity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 속성의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 성은&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다중 종속 속성이 작동 중일 때 스레드 안전성을 보장 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0676c9bf1fac4480032641cbb6a68b1b7b2be56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; is NOT default behavior. We need to add the &lt;code&gt;nonatomic&lt;/code&gt; keyword in the property attribute.</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 기본 동작이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;property 속성에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 키워드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 추가해야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b453d3a7a5746cdfc0be6127c5ee1332e4ae20b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; is thread-unsafe.</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 자는 스레드 안전하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="144c4b12fa77d18882a8cd254b25ce6824a3fd33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonatomic&lt;/code&gt; means multiple thread access the variable (dynamic type).</source>
          <target state="translated">&lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 다중 스레드가 변수 (동적 유형)에 액세스 함을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94704458ff99f8b43566a1a29d92a57098a31b7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readwrite&lt;/code&gt;                 // Default</source>
          <target state="translated">&lt;code&gt;readwrite&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // 기본&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16fdeec49d31d634e8dd057a685b6f1a125f2dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strong = retain&lt;/code&gt;        // Default</source>
          <target state="translated">&lt;code&gt;strong = retain&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; // 기본값&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1817be6d1b19c950de8c9a2fd3ae06f454649a42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Thats why non atomic is called thread unsafe But but it is fast in performance because of parallel execution&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 원자가 아닌 것을 스레드 안전하지 않은 이유이지만 병렬 실행으로 인해 성능이 빠릅니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cdd7cb3f0962dd785ee980cc0728796fe1f9761" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The keywords doesn't have to be written as first property attribute at all.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;키워드를 첫 번째 속성 속성으로 쓰지 않아도됩니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a10d89828ebaa54d8102b7cb13ba8665b0b81b2" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Note that there is no &quot;atomic&quot; keyword, if you do not specify &quot;nonatomic&quot;, then the property is atomic, but specifying &quot;atomic&quot; explicitly will result in an error.&lt;/strike&gt;</source>
          <target state="translated">&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;atomic&quot;키워드가 없으며 &quot;nonatomic&quot;을 지정하지 않으면 속성이 원자 적이지만 &quot;atomic&quot;을 명시 적으로 지정하면 오류가 발생합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="ffd409aa01eefdb8323b9fe5351b0b0a2ae95d7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-  Nonatomic means multiple thread access the variable(dynamic type).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-비 원자 (nonatomic)는 변수 (다이나믹 타입)에 다중 스레드 접근을 의미합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="466db7383e12a27164e85bd429689284264834b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;- Nonatomic is thread unsafe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-비 원자 스레드 안전하지 않습니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36549c905b7712f2a9bd3e65321c0b4716e2e567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;- but it is fast in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-그러나 성능이 빠릅니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ffaa095c82217a0d20db0b7833a8f1b5ded92da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Atomic is thread safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 스레드 안전합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="386c6c59efb1ceedd21973ad7d42db9e83d58724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Atomic means only one thread access the variable(static type).&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-원자는 하나의 스레드 만 변수 (정적 유형)에 액세스 함을 의미합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9289b20dbb4a5dfc44402b984b9b7fb71c00550" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-Nonatomic is NOT default behavior, we need to add nonatomic keyword    in property attribute.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Nonatomic은 기본 동작이 아니며 속성 속성에 비 원자 키워드를 추가해야합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0c853f0aa5af920ea97541fcad5a333859dd74d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-but it is slow in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 성능이 느립니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4f84e82d964d65d5331ec4dc31848f2f7892ac9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt; will ALWAYS guarantee&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 항상 보장합니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddde3b23162bbee9de624e2f156bcd96875a1c35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bb576a1c9d49b79e806ea0099e6c66b36101634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;nonatomic&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;nonatomic&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="716a0725bfe701eef013b5666a762ce35538990b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Atomicity
atomic (default)&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원 자성 원자 (디폴트 값)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="568741eb5bb25f08010362cde0dec871c3a27255" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;That's why atomic is called thread Safe&lt;/em&gt;&lt;/strong&gt; and 
&lt;strong&gt;&lt;em&gt;That's why it is called read-write safe&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전이라는 이유 원자의 것으로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하고 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 그의는 그것은 읽기 - 쓰기 안전이라고하는 이유&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6db8014b9ff772505aa968a0f3cb71151a1dfeb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;nonatomic&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;nonatomic&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86bb8a493b4f26c9d609a3571320b145e83a3265" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;And&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ae1919a56a424217d7942d186776bb7154473a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자력 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8847114c556e5aa0915a5a58f41de257fd15603b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic properties&lt;/strong&gt; :- When a variable assigned with atomic property that means it has only one thread access and it will be thread safe and will be good in performance perspective, will have default behaviour.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 속성&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :-원자 속성이 할당 된 변수가 하나의 스레드 액세스 만 가지고 스레드 안전하고 성능 관점에서 우수함을 의미하면 기본 동작을합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10970c29b4e931a96e449c43e2331815ca29c267" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomic&lt;/strong&gt;     = thread safety</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = 스레드 안전&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf1acd29fac53602f47b91d7c8afc125f052e57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Atomicity property attributes (atomic and nonatomic) are not reflected in the corresponding Swift property declaration, but the atomicity guarantees of the Objective-C implementation still hold when the imported property is accessed from Swift.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 속성과 비 원자 속성은 해당 Swift 속성 선언에 반영되지 않지만 가져온 속성이 Swift에서 액세스 될 때 Objective-C 구현의 원 자성 보장은 여전히 ​​유지됩니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d30e499b268ef956cffe268c4793a9718b721f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons :&lt;/strong&gt;
Chances of garbage value in case of multi-threading.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단점 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 멀티 스레딩의 경우 가비지 값이 발생할 가능성이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e4911144287afea7fb4bf6a0ef3999b2bb29492" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons :&lt;/strong&gt;
Performance hit, makes execution a little slower</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단점 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 성능 저하, 실행 속도가 약간 느려짐&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="234b4527dee6fe4a00dfe2bbf7a4bb066e7ff877" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't forget, this doesn't mean that the property as a whole is thread-safe. Only the method call of the setter/getter is. But if you use a setter and after that a getter at the same time with 2 different threads, it could be broken too!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잊지 마십시오. 이것이 속성 전체가 스레드로부터 안전하다는 것을 의미하지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;setter / getter의 메소드 호출 만 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 setter를 사용하고 그 후에 getter를 동시에 2 개의 다른 스레드로 사용하면 깨질 수도 있습니다!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd1385db75a313e27cd1eb8e32ba179bf7f05987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Execution&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f1d5591d26cb3f294591f3efdff8f6b9e2481e94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to declare:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;선언하는 방법 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7811690ec89311f10f21d909af0798328148ae64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non Atomic Properties&lt;/strong&gt; :- When a variable assigned with atomic property that means it has multi thread access and it will not be thread safe and will be slow in performance perspective, will have default behaviour and when two different threads want to access variable at same time it will give unexpected results.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자 속성&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :-원자 속성이 할당 된 변수는 다중 스레드 액세스가 가능하고 스레드 안전하지 않으며 성능 관점에서 느려질 때 기본 동작을 가지며 두 개의 다른 스레드가 동시에 변수에 액세스하려고 할 때 예기치 않은 결과가 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6678f00c71129c25e8fad8de4d6883b313b1be14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-Atomic :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8545b1c7ebcf7fbb96a330cc7553c4639fcd04f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non-atomic&lt;/strong&gt; = No thread safety</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = 나사산 안전 없음&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8601d32aec89322e75d4db57f8a0bc0221121029" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now If *name property is atomic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* name 속성이 원자 인 경우&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="151983afa96ad8bf924e8cee40345c29148887cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Now If *name property is nonatomic&lt;/strong&gt; then</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* name 속성이 비 원자&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라면&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc771fd41033a77969a605ae1d4d583af20dfab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros :&lt;/strong&gt;
Extremely fast execution.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;장점 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 매우 빠른 실행.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d428c41cc97f21b9ed84d34ebd585cbf9424fe05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros :&lt;/strong&gt;
Return of fully initialised objects each time makes it best choice in case of multi-threading.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;장점 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 매번 완전히 초기화 된 객체를 반환하면 멀티 스레딩의 경우 최상의 선택입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5dd2654f3ebc510659995067c7118d35b3e88d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So &amp;mdash; if you define an atomic property in Objective-C it will remain atomic when used by Swift.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 Objective-C에서 원자 속성을 정의하면 Swift에서 사용할 때 원자 속성으로 유지됩니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d99c357ae636e2b3295a9622db183d6bbd34fa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is no such keyword &quot;atomic&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;atomic&quot;이라는 키워드가 없습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b354ff06cc9df3b63e2688468d4f8a55f30ccb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What?! Are multithreading and &lt;a href=&quot;https://stackoverflow.com/questions/261683/what-is-meant-by-thread-safe-code&quot;&gt;thread safety&lt;/a&gt; different?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;뭐?! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레딩과 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/261683/what-is-meant-by-thread-safe-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전성이&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다른가요?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c255bfcdaf01e1eed156159bb65466687e8bbb" translate="yes" xml:space="preserve">
          <source>AND in implementation file</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;AND 구현 파일&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="031026e6565f207b619d61f36867d2bad1a58089" translate="yes" xml:space="preserve">
          <source>ARC | atomic | synthesized getter: 47</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아크 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합성 게터 : 47&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cdbb3f5ce65e619a74e436ca69abc9e558570a5" translate="yes" xml:space="preserve">
          <source>ARC | nonatomic | synthesized getter: 38 (note: ARC's adding ref count cycling here)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아크 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합성 게터 : 38 (참고 : ARC의 ref 카운트 사이클링 추가)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f64e38a90d15b8a6b6573bc690e9e02e460bc3e" translate="yes" xml:space="preserve">
          <source>Adding to this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것에 추가 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="005fcaf14fcbfa73d92d1ddda41994d6c9b6572e" translate="yes" xml:space="preserve">
          <source>After reading so many articles, Stack&amp;nbsp;Overflow posts and making demo applications to check variable property attributes, I decided to put all the attributes information together:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;너무 많은 기사를 읽고 Stack Overflow 게시물을 작성하고 데모 응용 프로그램에서 가변 속성 속성을 확인한 후 모든 속성 정보를 하나로 묶기로 결정했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97743bd8dd615d016758a893c5cacd3619f8ec85" translate="yes" xml:space="preserve">
          <source>All properties work parallelly (like asynchronously).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 속성은 병렬 적으로 (비동기 적으로) 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3dea8ae48d01239709fc42013945ab309b71b9be" translate="yes" xml:space="preserve">
          <source>Allowing to be read right in the middle of a 'not yet finished write or empty value' or not allowing and only allowing to read when the value is &lt;em&gt;fully&lt;/em&gt; written.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'아직 완료되지 않은 쓰기 또는 빈 값'중간에 바로 읽도록 허용하거나 값이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완전히&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기록 된 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우에만 읽도록 허용합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ffe57890eea72d085b8c1756cf6ca03abeaf9aee" translate="yes" xml:space="preserve">
          <source>Although I pay close attention to performance, I still say &lt;strong&gt;Semantics First!&lt;/strong&gt;. Meanwhile, performance is a low priority for many projects. However, knowing execution details and costs of technologies you use certainly doesn't hurt. You should use the right technology for your needs, purposes, and abilities. Hopefully this will save you a few hours of comparisons, and help you make a better informed decision when designing your programs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 성능에 세심한주의를 기울이지 만, 여전히 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Semantics First&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라고 말합니다 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;! &lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한편, 많은 프로젝트에서 성능은 우선 순위가 낮습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 실행 세부 사항과 사용하는 기술 비용을 아는 것이 확실합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필요, 목적 및 능력에 맞는 기술을 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 방법을 사용하면 몇 시간의 비교를 줄일 수 있고 프로그램을 디자인 할 때보다 정확한 결정을 내릴 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2cbd9d8863eeb2645be04a094bcbed84ed0f52b0" translate="yes" xml:space="preserve">
          <source>Another difference is that atomic properties will retain/release cycle your objects within the getter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 차이점은 원자 속성이 게터 내에서 객체를 유지 / 해제하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b90a1bc53199071cf2f05cf74dce10673fc22174" translate="yes" xml:space="preserve">
          <source>As atomic is default so,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자가 기본값이므로&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="669dc440babc6ff197e609915366d3ba4ec76a8c" translate="yes" xml:space="preserve">
          <source>As you have probably guessed, reference count activity/cycling is a significant contributor with atomics and under ARC. You would also see greater differences in contested cases.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;짐작할 수 있듯이, 참조 카운트 활동 / 사이클링은 원자와 ARC 하에서 중요한 기여자입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 이의 제기 된 사례에서 더 큰 차이를 볼 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b1dca09059391e6197dc9be1c6f3ad674bb8c11" translate="yes" xml:space="preserve">
          <source>Assuming that you are @synthesizing the method implementations, atomic vs. non-atomic changes the generated code.  If you are writing your own setter/getters, atomic/nonatomic/retain/assign/copy are merely advisory.  (Note:  @synthesize is now the default behavior in recent versions of LLVM.  There is also no need to declare instance variables;  they will be synthesized automatically, too, and will have an &lt;code&gt;_&lt;/code&gt; prepended to their name to prevent accidental direct access).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드 구현을 @synthesizing한다고 가정하면 원자 대 비 원자는 생성 된 코드를 변경합니다. 자신의 세터 / 게터를 작성하는 경우 원자 / 비 원자 / 유지 / 할당 / 복사는 단지 자문 일뿐입니다. (참고 : @synthesize는 이제 LLVM의 최신 버전에서 기본 동작입니다. 인스턴스 변수를 선언 할 필요도 없습니다. 인스턴스 변수도 자동으로 합성되며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실수로 직접 액세스하지 못하도록 이름 앞에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; 가&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 붙습니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51aecdcbd1fa29f5e17a19748f03b1a72c7b0d7c" translate="yes" xml:space="preserve">
          <source>At the same time if you call</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 전화하면 동시에&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3023cb8188912c321e51f84008e15af7ab75428" translate="yes" xml:space="preserve">
          <source>Atomic</source>
          <target state="translated">Atomic</target>
        </trans-unit>
        <trans-unit id="9b160c50dc810596cdf78df71886c71571d64371" translate="yes" xml:space="preserve">
          <source>Atomic - it can't be broken down, so the result is expected. With nonatomic - when another thread access the memory zone it can modify it, so the result is unexpected.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자-그것은 나눌 수 없으므로 결과가 기대됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자-다른 스레드가 메모리 영역에 액세스하면이를 수정할 수 있으므로 예상치 못한 결과가 발생합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="56787168e1c9b9ef3ae0cf3dad2217f8eba7d6c7" translate="yes" xml:space="preserve">
          <source>Atomic &lt;strong&gt;doesn't&lt;/strong&gt; guarantee thread safety, though it's useful for achieving thread safety. Thread Safety is relative to how you write your code/ which thread queue you are reading/writing from. It only guarantees non-crashable multithreading.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;안전은 스레드 안전을 보장 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지는 않지만&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스레드 안전을 달성하는 데 유용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전성은 코드 작성 방법 / 읽고 쓰는 스레드 대기열과 관련이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;충돌 불가능한 멀티 스레딩 만 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="158d5f3bbf986fce8d6f3929fb7a0ecce795cd2b" translate="yes" xml:space="preserve">
          <source>Atomic accessors in a non garbage collected environment (i.e. when using retain/release/autorelease) will use a lock to ensure that another thread doesn't interfere with the correct setting/getting of the value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가비지 수집되지 않은 환경 (예 : 유지 / 릴리스 / 자동 릴리스를 사용하는 경우)의 원자 접근자는 다른 스레드가 값의 올바른 설정 / 가져 오기를 방해하지 않도록 잠금을 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89e66db1ad91cce7b2d346303a7b197d5ece77a4" translate="yes" xml:space="preserve">
          <source>Atomic guarantees that access to the property will be performed in an atomic manner. E.g. it always return a fully initialised objects, any get/set of a property on one thread must complete before another can access it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 속성에 대한 액세스가 원자 방식으로 수행되도록 보장합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 항상 완전히 초기화 된 객체를 반환합니다. 한 스레드의 속성 가져 오기 / 설정은 다른 스레드가 액세스하기 전에 완료해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f5f7dedc45052e0d3aeb0e9c80106066a594e4ba" translate="yes" xml:space="preserve">
          <source>Atomic is &lt;strong&gt;thread safe&lt;/strong&gt;, it is &lt;strong&gt;slow&lt;/strong&gt; and it &lt;strong&gt;well-assures (not guaranteed)&lt;/strong&gt; that only the locked value is provided no matter how many threads are attempting access over the same zone. When using atomic, a piece of code written inside this function becomes the part of the critical section, to which only one thread can execute at a time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 그것이 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;느린&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘 보증한다 (보장 할 수 없습니다)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 많은 스레드가 동일한 영역에 대한 액세스를 시도하는 방법에만 고정 값에 상관없이 제공되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아토믹 (atomic)을 사용할 때,이 함수 안에 작성된 코드 조각은 한 번에 하나의 스레드 만 실행할 수있는 중요 섹션의 일부가됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7585badc81fcfc702a4b9198178ff361601c32cd" translate="yes" xml:space="preserve">
          <source>Atomic is the default: if you don&amp;rsquo;t type anything, your property is
  atomic. An atomic property is guaranteed that if you try to read from
  it, you will get back a valid value. It does not make any guarantees
  about what that value might be, but you will get back good data, not
  just junk memory. What this allows you to do is if you have multiple
  threads or multiple processes pointing at a single variable, one
  thread can read and another thread can write. If they hit at the same
  time, the reader thread is guaranteed to get one of the two values:
  either before the change or after the change. What atomic does not
  give you is any sort of guarantee about which of those values you
  might get. Atomic is really commonly confused with being thread-safe,
  and that is not correct. You need to guarantee your thread safety
  other ways. However, atomic will guarantee that if you try to read,
  you get back some kind of value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자가 기본값입니다. 아무 것도 입력하지 않으면 속성이 원 자성입니다. 원자 속성은 그것을 읽으려고 시도하면 유효한 값을 얻습니다. 그 값이 무엇인지 보장하지는 않지만 정크 메모리뿐만 아니라 좋은 데이터를 다시 얻을 수 있습니다. 이것이 할 수있는 것은 단일 변수를 가리키는 다중 스레드 또는 다중 프로세스가있는 경우 하나의 스레드가 읽고 다른 스레드가 쓸 수있는 것입니다. 동시에 충돌하면 리더 스레드는 변경 전 또는 변경 후 두 값 중 하나를 얻습니다. 원자가 제공하지 않는 것은 어떤 값을 얻을 수 있는지에 대한 보증입니다. 원자는 일반적으로 스레드 안전과 혼동되기 때문에 정확하지 않습니다. 다른 방법으로 스레드 안전을 보장해야합니다.그러나 원자는 당신이 읽으려고하면 어떤 종류의 가치를 얻도록 보장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c26403b797c5d1768fd18ce45b0e96426d55041b" translate="yes" xml:space="preserve">
          <source>Atomic make getter and setter of the property thread safe. for example if u have written :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 속성 스레드의 getter 및 setter를 안전하게 만듭니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 u가 다음과 같이 쓴 경우 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea657186686dc25af58658f7340d085ea2354148" translate="yes" xml:space="preserve">
          <source>Atomic means only one thread accesses the variable (static type). Atomic is thread-safe, but it is slow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 하나의 스레드 만 변수 (정적 유형)에 액세스 함을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 스레드로부터 안전하지만 느립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f6d05505130392ddbaadc6fa8e2fe878cbaf0010" translate="yes" xml:space="preserve">
          <source>Atomic means only one thread can access the variable at a time (static type). Atomic is thread-safe, but it is slow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 한 번에 하나의 스레드 만 변수에 액세스 할 수 있음을 의미합니다 (정적 유형). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 스레드로부터 안전하지만 느립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c29d43758bf4c1706fdf7c909cd8aef22678f57" translate="yes" xml:space="preserve">
          <source>Atomic: Ensure thread-safety by locking the thread using NSLOCK.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 : NSLOCK을 사용하여 스레드를 잠그면 스레드 안전성이 보장됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd7773c6a864e0691a1de774e8c8593a1e851ce9" translate="yes" xml:space="preserve">
          <source>Basically, the atomic version has to take a lock in order to guarantee thread safety, and also is bumping the ref count on the object (and the autorelease count to balance it) so that the object is guaranteed to exist for the caller, otherwise there is a potential race condition if another thread is setting the value, causing the ref count to drop to 0.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 원자 버전은 스레드 안전을 보장하기 위해 잠금을 수행해야하며 호출자에게 객체가 존재하도록 객체의 참조 횟수와 객체의 균형을 잡기 위해 자동 해제 횟수를 충돌시킵니다. 다른 스레드가 값을 설정하여 참조 횟수가 0으로 떨어지면 잠재적 경쟁 조건입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dfc88261cc9b67c90909d642678537e41c4ff870" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;atomic&lt;/code&gt; variables can not be interrupted, the value contained by them at any point is (thread-lock) guaranteed to be &lt;strong&gt;uncorrupted&lt;/strong&gt;, although, ensuring this thread lock makes access to them slower. &lt;code&gt;non-atomic&lt;/code&gt; variables, on the other hand, make no such guarantee but do offer the luxury of quicker access. To sum it up, go with &lt;code&gt;non-atomic&lt;/code&gt; when you know your variables won't be accessed by multiple threads simultaneously and speed things up.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때문에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 변수 중단 될 수없고, 어떤 시점에서 그들에 포함 된 값으로 보증 (쓰레드 로크)은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;손상되지 않은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스레드 잠금을 보장하는 느린 그들에 액세스하여, 비록. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;non-atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 변수는 그러한 보장을하지는 않지만 더 빠른 액세스를 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요약하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 스레드가 동시에 변수에 액세스하지 않고 속도를 높일 때 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;non-atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이동 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5def4d181c0b234f6030c20a1065db3aa1e7656e" translate="yes" xml:space="preserve">
          <source>Before you begin: You must know that every object in memory needs to be deallocated from memory for a new writer to happen. You can't just simply write on top of something as you do on paper. You &lt;strong&gt;must&lt;/strong&gt; first erase (dealloc) it and then you can write onto it. If at the moment that the erase is done (or half done) and nothing &lt;strong&gt;has yet&lt;/strong&gt; been wrote (or half wrote) and you try to read it could be very problematic! Atomic and nonatomic help you treat this problem in different ways.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시작하기 전에 : 새 라이터가 발생하려면 메모리의 모든 객체를 메모리에서 할당 해제해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;종이에 쓰는 것처럼 단순히 위에 글을 쓸 수는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있어야합니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 첫 번째 (할당 해제)을 삭제를하고 당신은 그것에 쓸 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지우기가 완료된 (또는 절반이 완료된) 시점에서 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아직&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 쓰지 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않은&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (또는 절반이 쓴) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아무것도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;읽지 않으면 매우 문제가 될 수 있습니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 및 비 원자 (nonatomic)는이 문제를 다른 방식으로 처리하는 데 도움이됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e19bbd7c23d0c7c4056f980c7f2cc203506c4688" translate="yes" xml:space="preserve">
          <source>But it is fast in performance</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 성능이 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59d1bb168c787f2090eeb85af65c9e07fbd0c969" translate="yes" xml:space="preserve">
          <source>But it is slow in performance</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 성능이 느립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="466385388946acc99f6af4e50599b87b0caa1038" translate="yes" xml:space="preserve">
          <source>Code Talk :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드 토크 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="1bababff006e8f53086ecf6a193ae7c2dc1436a1" translate="yes" xml:space="preserve">
          <source>Crashing or not because of having or not having an autorelease pool.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자동 릴리스 풀이 있거나 없어서 충돌 여부&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cf9c3f11dca2f6a00e2d96ff2141da6323e8c8b" translate="yes" xml:space="preserve">
          <source>Doesn't guarantee full written values to be read!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 기록 값을 읽도록 보장하지는 않습니다!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a68c2b3f3d3b9d7f59544dacf5f1d2373fa8a26" translate="yes" xml:space="preserve">
          <source>Due to the number of optimizations and variations in implementations, it's quite difficult to measure real-world impacts in these contexts. You might often hear something like &quot;Trust it, unless you profile and find it is a problem&quot;. Due to the abstraction level, it's actually quite difficult to measure actual impact. Gleaning actual costs from profiles can be very time consuming, and due to abstractions, quite inaccurate. As well, ARC vs MRC can make a big difference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현의 최적화 및 변형이 많기 때문에 이러한 상황에서 실제 영향을 측정하는 것은 매우 어렵습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;프로필을 작성하여 문제가 발견되지 않는 한 신뢰하기&quot;와 같은 소리가 들릴 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;추상화 수준으로 인해 실제로 실제 영향을 측정하는 것은 매우 어렵습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로파일에서 실제 비용을 모으는 데는 시간이 많이 걸리고 추상화로 인해 매우 정확하지 않을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 ARC와 MRC는 큰 차이를 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc588869b460d7a7c0dde78b8f7455e69c812d3c" translate="yes" xml:space="preserve">
          <source>Easiest answer first: There's no difference between your second two examples. By default, property accessors are atomic.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 쉬운 대답 먼저 : 두 번째 예 사이에는 차이가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 속성 접근자는 원자 적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="757cc03a89227c519cc7dc5a2bfb3c7e09103b83" translate="yes" xml:space="preserve">
          <source>Ensuring data integrity -- one of the primary challenges of multi-threaded programming -- is achieved by other means.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레드 프로그래밍의 주요 과제 중 하나 인 데이터 무결성 보장은 다른 방법으로 달성됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="952a7acd4884031a827584cd959102d7c27e63db" translate="yes" xml:space="preserve">
          <source>Example with MRC of a property with an ivar _internal:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ivar _internal이있는 속성의 MRC를 사용한 예 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="af66993b461bd3431cadd690caf86ea36449e356" translate="yes" xml:space="preserve">
          <source>First read &lt;a href=&quot;https://stackoverflow.com/questions/21098494/atomic-properties-vs-thread-safe-in-objective-c&quot;&gt;this&lt;/a&gt; question and then read &lt;a href=&quot;https://stackoverflow.com/a/589392/5175709&quot;&gt;Bbum's answer&lt;/a&gt;. In addition, then read my summary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 읽기 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/21098494/atomic-properties-vs-thread-safe-in-objective-c&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 질문을하고 읽을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/589392/5175709&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bbum의 답변을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 내 요약을 읽으십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0cecd6711aec49678ad292677bfd067b2bfe459b" translate="yes" xml:space="preserve">
          <source>For In Swift
Confirming that Swift properties are nonatomic in the ObjC sense. One reason is so you think about whether per-property atomicity is sufficient for your needs.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스위프트의 경우 스위프트 속성이 ObjC 의미에서 비 원자인지 확인합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 가지 이유는 속성 별 원자가 당신의 필요에 충분한 지 생각하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0ea1177f91a4c498d582627a0507f246eb7808be" translate="yes" xml:space="preserve">
          <source>Fro more info please visit the website 
&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 정보는 웹 사이트 &lt;/font&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html을&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 방문하십시오. &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db368e14ab7f01e913bc2e2e6d175b2110a3c9c9" translate="yes" xml:space="preserve">
          <source>Here's the interesting part: Performance using atomic property accesses in &lt;strong&gt;uncontested&lt;/strong&gt; (e.g. single-threaded) cases can be really very fast in some cases. In less than ideal cases, use of atomic accesses can cost more than 20 times the overhead of &lt;code&gt;nonatomic&lt;/code&gt;. While the &lt;strong&gt;Contested&lt;/strong&gt; case using 7 threads was 44 times slower for the three-byte struct (2.2&amp;nbsp;GHz &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core&amp;nbsp;i7&lt;/a&gt; Quad Core, x86_64). The three-byte struct is an example of a very slow property.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;흥미로운 부분은 다음과 같습니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경합되지 않은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (예 : 단일 스레드) 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에 원자 속성 액세스를 사용하는 성능 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 경우에 따라 매우 빠릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이상적인 미만의 경우, 원자 액세스의 사용은 20 회 오버 헤드보다 요할 수 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;7 개의 스레드를 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컨테스트 된&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 케이스는 3 바이트 구조 (2.2GHz &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코어 i7&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 쿼드 코어, x86_64)의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우 44 배 느 렸습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3 바이트 구조체는 매우 느린 속성의 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42e679fd3d38e1ac2ae9fb1fd1602697916fa1ae" translate="yes" xml:space="preserve">
          <source>I found a pretty well put explanation of atomic and non-atomic properties &lt;a href=&quot;http://archive.atomicmpc.com.au/forums.asp?s=2&amp;amp;c=10&amp;amp;t=4594&quot;&gt;here&lt;/a&gt;. Here's some relevant text from the same:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 속성과 비 원자 속성에 대한 설명을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://archive.atomicmpc.com.au/forums.asp?s=2&amp;amp;c=10&amp;amp;t=4594&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에서 찾아 냈습니다&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 동일한 관련 텍스트입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0dcf329e22e36816a065b09cb8ea101357ebfd69" translate="yes" xml:space="preserve">
          <source>I'd always considered atomic as a default quite curious. At the abstraction level we work at, using atomic properties for a class as a vehicle to achieve 100% thread-safety is a corner case. For truly correct multithreaded programs, intervention by the programmer is almost certainly a requirement. Meanwhile, performance characteristics and execution have not&amp;nbsp;yet been detailed in depth. Having written some heavily multithreaded programs over the years, I had been declaring my properties as &lt;code&gt;nonatomic&lt;/code&gt; the entire time because atomic was not sensible for any purpose. During discussion of the details of atomic and nonatomic properties &lt;a href=&quot;https://stackoverflow.com/questions/12010211/use-of-atomic-properties-in-objective-c-any-side-effects&quot;&gt;this question&lt;/a&gt;, I did some profiling encountered some curious results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 항상 원자를 기본적으로 매우 흥미로운 것으로 생각했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리가 작업하는 추상화 수준에서 클래스의 원자 속성을 차량으로 사용하여 100 % 스레드 안전성을 달성하는 것이 가장 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;진정한 올바른 멀티 스레드 프로그램을 위해서는 프로그래머의 개입이 거의 필요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한편, 성능 특성 및 실행은 아직 자세히 설명되지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수년 동안 엄청나게 많은 멀티 스레드 프로그램을 작성한 후, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자는 어떤 목적으로도 합리적이지 않기 때문에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 속성을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 자성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로 선언했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12010211/use-of-atomic-properties-in-objective-c-any-side-effects&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문에 대한&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 원자 및 비 원자 특성의 세부 사항을 논의하는 동안 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 프로파일 링에서 흥미로운 결과가 발생했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53df0d90dbfd2e8b81a9c6bdb363f7adf147a62d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;before&lt;/strong&gt; writing you &lt;strong&gt;have&lt;/strong&gt; erased that which was previously written on paper and then someone wants to read you &lt;em&gt;can&lt;/em&gt; still read. How? You will be reading from something similar to Mac OS Trash bin ( as Trash bin is not still 100% erased...it's in a limbo) ---&amp;gt; If ThreadA is to read while ThreadB has already deallocated to write, you would get a value from either the final fully written value by ThreadB or get something from autorelease pool.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;만약 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전에&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 당신이 쓰는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이전에 종이에 작성하고 누군가가 읽고 싶어 한 것을 삭제 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 수 있습니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 아직 읽어 보시기 바랍니다. 어떻게? Mac OS 휴지통과 비슷한 것을 읽을 것입니다 (휴지통은 여전히 ​​100 % 지워지지 않기 때문에 ... 림보에 있습니다) ---&amp;gt; ThreadB가 이미 쓰기 할당을 해제 한 상태에서 ThreadA를 읽으면 얻을 수 있습니다. ThreadB에 의해 완전히 작성된 최종 값 또는 자동 릴리스 풀에서 값을 가져 오는 값&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aeb0ab7ed38eced8087358822adc1caacc3f25eb" translate="yes" xml:space="preserve">
          <source>If a thread changes the value of the instance the changed value is available to all the threads, and only one thread can change the value at a time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드가 인스턴스 값을 변경하면 변경된 값을 모든 스레드에서 사용할 수 있으며 한 번에 하나의 스레드 만 값을 변경할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cd5b7f015914683553101835da5c0b4775c2c87" translate="yes" xml:space="preserve">
          <source>If one person is trying to write and has only written 4 of the 8 letters to write, then no can read in the middle, the reading can only be done when all 8 letters is written --&amp;gt; No read(get) will happen on 'a thread that is still writing', i.e. if there are 8 bytes to bytes to be written, and only 4 bytes are written&amp;mdash;&amp;mdash;up to that moment, you are not allowed to read from it. But since I said it won't crash then it would read from the value of an &lt;em&gt;autoreleased&lt;/em&gt; object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 사람이 쓰려고하고 8 글자 중 4 글자 만 쓰면 중간에 읽을 수 없으며, 8 글자를 모두 쓸 때만 읽을 수 있습니다-&amp;gt; 읽지 않음 '쓰고있는 스레드', 즉 8 바이트에서 바이트로 쓸 바이트가 있고 4 바이트 만 쓰면 그 시점까지 읽을 수 없습니다. 나는 그 다음 충돌하지 것이라고 말했다하지만 이후 그것은의 값에서 읽을 것 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오토 릴리즈&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 객체입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e60a837b656fdb2a0431c6bc1d827b07c77b719" translate="yes" xml:space="preserve">
          <source>If the instance variable is not gonna be changed by multiple threads you can use it. It improves the performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인스턴스 변수가 여러 스레드에 의해 변경되지 않으면 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능이 향상됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa7d0e9c8949d2b6aa328a9fec0cb7a660ef020c" translate="yes" xml:space="preserve">
          <source>If the property &quot;name&quot; was nonatomic, then all threads in above example - A,B, C and D will execute simultaneously producing any unpredictable result. In case of atomic, either one of A, B or C will execute first, but D can still execute in parallel.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;name&quot;속성이 원자가 아닌 경우 위의 예-A, B, C 및 D에있는 모든 스레드가 동시에 실행되어 예기치 않은 결과가 생성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자의 경우 A, B 또는 C 중 하나가 먼저 실행되지만 D는 여전히 병렬로 실행될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe485326675d7d2b88c23e0f595ee6a297fa4017" translate="yes" xml:space="preserve">
          <source>If two different people want to read and write at the same time, your paper won't just burn! --&amp;gt; Your application will never crash, even in a race condition.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서로 다른 두 사람이 동시에 읽고 쓰기를 원한다면 종이가 타지 않을 것입니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-&amp;gt; 경쟁 조건에서도 애플리케이션이 중단되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2907fa671a851246609e65b92f375972d2b090d5" translate="yes" xml:space="preserve">
          <source>If you are using atomic, it means the thread will be safe and read-only. If you are using nonatomic, it means the multiple threads access the variable and is thread unsafe, but it is executed fast, done a read and write operations; this is a dynamic type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자를 사용하는 경우 스레드가 안전하고 읽기 전용임을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비원자를 사용하는 경우 여러 스레드가 변수에 액세스하고 스레드가 안전하지 않다는 것을 의미하지만 빠르게 실행되고 읽기 및 쓰기 작업이 수행됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 동적 유형입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="428f7d87b20e0ac4a9aac645a9382a64497f95b5" translate="yes" xml:space="preserve">
          <source>If you are using your property in multi-threaded code then you would be able to see the difference between nonatomic and atomic attributes. Nonatomic is faster than atomic and atomic is thread-safe, not nonatomic.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다중 스레드 코드에서 속성을 사용하는 경우 비 원자 속성과 원자 속성의 차이를 볼 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비원자는 원자보다 빠르며 원자는 스레드가 아니라 비 원자입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf0fc3cb78576b4927e58b55e16dad60b50135e6" translate="yes" xml:space="preserve">
          <source>If you call &quot;name&quot; from thread &lt;strong&gt;A&lt;/strong&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 스레드에서 &quot;이름&quot;을 호출하는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;,&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bed63c9b598ff3c1689b7a172b312f05c94268c" translate="yes" xml:space="preserve">
          <source>If you do not specify &quot;nonatomic&quot;, then the property is atomic, but you can still specify &quot;atomic&quot; explicitly in recent versions if you want to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;비 원자&quot;를 지정하지 않으면 속성이 원자 적이지만 원하는 경우 최신 버전에서 &quot;원자&quot;를 명시 적으로 지정할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3d25d57cfcaf0f91a92c71b555c13ca24c48562" translate="yes" xml:space="preserve">
          <source>If you imagine the following function occurring on two threads at once you can see why the results would not be pretty.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의 스레드에서 한 번에 다음 기능이 발생한다고 생각하면 결과가 좋지 않은 이유를 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad0bd596c87dee16e9b201c0db38575508e5f5f7" translate="yes" xml:space="preserve">
          <source>Implication of &lt;code&gt;atomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83e77580a4c5ad2c6ae90254011081aed2807ee6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;nonatomic&lt;/code&gt;, no such guarantees are made.   Thus, &lt;code&gt;nonatomic&lt;/code&gt; is considerably faster than &quot;atomic&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 그런 보장이 이루어지지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 자는 &quot;원자&quot;보다 상당히 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8933d5f65d5f09ff3f586e9b3d5961e4504e9a90" translate="yes" xml:space="preserve">
          <source>In iOS, &lt;code&gt;@sychronise&lt;/code&gt; also provides the mutex lock .Now it serves in FIFO mode and ensures the flow is not affected by two classes sharing the same instance. However, if the task is on main thread, avoid accessing object using atomic properties as it may hold your UI and degrade the performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;iOS에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@sychronise&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 뮤텍스 잠금도 제공합니다. 이제는 FIFO 모드에서 작동하며 동일한 인스턴스를 공유하는 두 클래스의 흐름에 영향을 미치지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 작업이 기본 스레드에있는 경우 UI를 보유하고 성능을 저하시킬 수 있으므로 원자 속성을 사용하여 객체에 액세스하지 마십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78dcc05a8b48a89d78a8a925227ef5c773900b55" translate="yes" xml:space="preserve">
          <source>In our context:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리의 맥락에서 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b2fc2a31bbb825f80a48c090d06d5637549e56ef" translate="yes" xml:space="preserve">
          <source>In the article &lt;em&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;strong&gt;Variable property attributes or modifiers in iOS&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt; you can find all the above-mentioned attributes, and that will definitely help you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;iOS의 변수 속성 속성 또는 수정 자&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기사 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 위에서 언급 한 모든 속성을 찾을 수 있으며 이는 확실히 도움이 될 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b510c07af1689d04e0c92073219c7e5327f2a972" translate="yes" xml:space="preserve">
          <source>In this case, thread A could be renaming the object by calling &lt;code&gt;setFirstName:&lt;/code&gt; and then calling &lt;code&gt;setLastName:&lt;/code&gt;.   In the meantime, thread B may call &lt;code&gt;fullName&lt;/code&gt; in between thread A's two calls and will receive the new first name coupled with the old last name.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 경우 스레드 A는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFirstName:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 호출 한 다음 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setLastName:&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 호출 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 오브젝트의 이름을 바꿀 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 동안 스레드 B는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 A의 두 호출 사이에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fullName&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 호출 할 수 있으며 이전 성과 결합 된 새로운 이름을받습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da9491d2fb2ea9a679ca39f1170f07c876da3d2d" translate="yes" xml:space="preserve">
          <source>Instance variables are thread-safe if they behave correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인스턴스 변수는 런타임 환경에 의한 스레드 실행의 스케줄링 또는 인터리빙에 관계없이 호출 스레드에서 추가 동기화 또는 기타 조정없이 여러 스레드에서 액세스 할 때 올바르게 작동하는 경우 스레드 안전합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88955b39760efe23b0a168fea5c46d327d69b8c0" translate="yes" xml:space="preserve">
          <source>Interesting side note: User-defined accessors of the three-byte struct were 52 times faster than the synthesized atomic accessors; or 84% the speed of synthesized nonatomic accessors.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;흥미로운 참고 사항 : 3 바이트 구조체의 사용자 정의 접근자는 합성 원자 접근 자보다 52 배 빠릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 합성 된 비 원자 접근 자의 속도 84 %&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd5f7aa29cdb5852e9c6134812d23c81d4c91dde" translate="yes" xml:space="preserve">
          <source>Is faster than atomic</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자보다 빠름&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9935d8df3697bfdf2e3d1810a602d26ae25554e" translate="yes" xml:space="preserve">
          <source>It is not actually a keyword.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로는 키워드가 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="965f4053d5f6a421d7a99992699acc65a44280ac" translate="yes" xml:space="preserve">
          <source>It may result in unexpected behavior, when two different process (threads) access the same variable at the same time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 개의 다른 프로세스 (스레드)가 동시에 동일한 변수에 액세스 할 때 예기치 않은 동작이 발생할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff986039c13fe411fa26a6360a02bf568a2527f8" translate="yes" xml:space="preserve">
          <source>It only assures the thread safety; it does not guarantee that. &lt;strong&gt;What I mean is you hire an expert driver for you car, still it doesn't guarantees car won't meet an accident. However, probability remains the slightest.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전 만 보장합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보장하지 않습니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 말은 당신이 당신의 차를 위해 전문 운전자를 고용한다는 것입니다. 그럼에도 불구하고 자동차가 사고를 당하지 않을 것이라고 보장하지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 가능성은 가장 적습니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7e4c133e544fa1549014a474b3fdd79ecdd9b91" translate="yes" xml:space="preserve">
          <source>It will ensure value &quot;Sourov&quot; for A</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 &quot;Sourov&quot;의 가치를 보장합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8aabb46c24820f1082cacf15fbe9319e591e75fa" translate="yes" xml:space="preserve">
          <source>It will return value &quot;Datta&quot; for A</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A에 대해 &quot;Datta&quot;값을 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1d66b8948b48962f8898cfc2c57c109d82eec4c" translate="yes" xml:space="preserve">
          <source>It will return value &quot;Datta&quot; for B</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B에 대해 &quot;Datta&quot;값을 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5a101e022a872ea8b43a671dbba37801c695a1a0" translate="yes" xml:space="preserve">
          <source>MRC | atomic | synthesized getter: 47</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MRC | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합성 게터 : 47&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9c588343e9c4452aa8db91f654be503b1635cd7" translate="yes" xml:space="preserve">
          <source>MRC | nonatomic | manually implemented getters: 2</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MRC | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수동으로 구현 된 게터 : 2&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e6e15d6a8cbe6913bff385297e0082e4e14a0e8" translate="yes" xml:space="preserve">
          <source>MRC | nonatomic | synthesized getter: 7</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MRC | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자 | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합성 게터 : 7&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f936ab0c829c9aaa1ec757b6c0fe8638f4147e53" translate="yes" xml:space="preserve">
          <source>Mutex lock, as per the name, locks the mutability of the object. So if the object is accessed by a class, no other class can access the same object.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이름에 따라 뮤텍스 잠금은 객체의 변경 성을 잠급니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 클래스가 객체에 액세스하면 다른 클래스는 동일한 객체에 액세스 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf200f6a5c12c6aa0c00f246af59f0794bb918fd" translate="yes" xml:space="preserve">
          <source>Non atomic: Doesn't ensure thread-safety as there is no thread-locking mechanism.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 원자 : 스레드 잠금 메커니즘이 없기 때문에 스레드 안전성을 보장하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cef6468ab63b7d41ecdaa4adabb0e5f0fb04e3f5" translate="yes" xml:space="preserve">
          <source>Non-Atomic</source>
          <target state="translated">Non-Atomic</target>
        </trans-unit>
        <trans-unit id="7265a45814aa6aabd0873b14668bcf5e20b299da" translate="yes" xml:space="preserve">
          <source>Nonatomic means multiple threads access the variable (dynamic type). Nonatomic is thread-unsafe, but it is fast.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비원 자란 다중 스레드가 변수 (동적 유형)에 액세스 함을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비원자는 스레드 안전하지 않지만 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40adcfc307e315b6e42a566334895747663e1977" translate="yes" xml:space="preserve">
          <source>Nonatomic means multiple threads can access the variable at same time (dynamic type). Nonatomic is thread-unsafe, but it is fast.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비원 자란 여러 스레드가 동시에 변수에 액세스 할 수 있음을 의미합니다 (동적 유형). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비원자는 스레드 안전하지 않지만 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3bbe9a95845165551fded485e043fff87beb015a" translate="yes" xml:space="preserve">
          <source>Not as fast as &lt;code&gt;nonatomic&lt;/code&gt; because &lt;code&gt;nonatomic&lt;/code&gt; doesn't require any watchdog work on that from runtime .</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에는 런타임에서 워치 독 작업이 필요하지 않기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때문에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 만큼 빠르지 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않습니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b35330b19eb26e776ba809c005b85869c82196c" translate="yes" xml:space="preserve">
          <source>Now, the atomic variant is a bit more complicated:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 원자 변형은 조금 더 복잡합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476e89eb6fdf9059091b1eff94b8ef25b54472b1" translate="yes" xml:space="preserve">
          <source>Objects in contested cases can also exceed 50 times.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;분쟁이 발생한 경우의 개체도 50 배를 초과 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b4b3304ba3417b0a99cb67827234158af1d91b0" translate="yes" xml:space="preserve">
          <source>Ok. The first thing I would like to clear up is that the locking implementation is implementation-defined and abstracted. Louis uses &lt;code&gt;@synchronized(self)&lt;/code&gt; in his example -- I have seen this as a common source of confusion. The implementation does not &lt;em&gt;actually&lt;/em&gt; use &lt;code&gt;@synchronized(self)&lt;/code&gt;; it uses object level &lt;em&gt;spin locks&lt;/em&gt;. Louis's illustration is good for a high-level illustration using constructs we are all familiar with, but it's important to know it does not use &lt;code&gt;@synchronized(self)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;확인. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가장 먼저 정리하고 싶은 것은 잠금 구현이 구현 정의되고 추상화된다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Louis는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그의 예제에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-나는 이것을 일반적인 혼란의 근원으로 보았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지 않습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 레벨 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스핀 잠금을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Louis의 일러스트레이션은 우리 모두에게 친숙한 구문을 사용하는 높은 수준의 일러스트레이션에 적합하지만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;@synchronized(self)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하지 않는 것이 중요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eda76917b36b5a0223c73aefb7f0094260633e0" translate="yes" xml:space="preserve">
          <source>On the flip side, non-atomic, as you can probably guess, just means,
  &amp;ldquo;don&amp;rsquo;t do that atomic stuff.&amp;rdquo; What you lose is that guarantee that you
  always get back something. If you try to read in the middle of a
  write, you could get back garbage data. But, on the other hand, you go
  a little bit faster. Because atomic properties have to do some magic
  to guarantee that you will get back a value, they are a bit slower. If
  it is a property that you are accessing a lot, you may want to drop
  down to nonatomic to make sure that you are not incurring that speed
  penalty.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반대로 원자가 아닌 것은 아마도 &quot;원자 적 일을하지 말라&quot;는 것을 의미 할 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 잃어버린 것은 항상 무언가를 되 찾는다는 보장입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;쓰기 도중에 읽으려고하면 가비지 데이터를 다시 얻을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 다른 한편으로는 조금 더 빠릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 속성은 값을 되 찾을 수 있도록 약간의 마법을 수행해야하기 때문에 조금 느립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 당신이 많이 접근하는 재산이라면, 당신은 그 속도 패널티가 발생하지 않도록 비 원자력으로 드롭 다운 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9c81a07baf1e0c099e90ee1555e3bf169d497d6a" translate="yes" xml:space="preserve">
          <source>On the flip side, non-atomic, as you can probably guess, just means,
  &amp;ldquo;don&amp;rsquo;t do that atomic stuff.&amp;rdquo; What you lose is that guarantee that you
  always get back something. If you try to read in the middle of a
  write, you could get back garbage data. But, on the other hand, you go
  a little bit faster. Because atomic properties have to do some magic
  to guarantee that you will get back a value, they are a bit slower. If
  it is a property that you are accessing a lot, you may want to drop
  down to nonatomic to make sure that you are not incurring that speed
  penalty. Access</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반대로 원자가 아닌 것은 아마도 &quot;원자 적 일을하지 말라&quot;는 것을 의미 할 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 잃어버린 것은 항상 무언가를 되 찾는다는 보장입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;쓰기 도중에 읽으려고하면 가비지 데이터를 다시 얻을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 다른 한편으로는 조금 더 빠릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 속성은 값을 되 찾을 수 있도록 약간의 마법을 수행해야하기 때문에 조금 느립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것이 당신이 많이 접근하는 재산이라면, 당신은 그 속도 패널티가 발생하지 않도록 비 원자력으로 드롭 다운 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;접속하다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ede7fdf8394bacfee2c5d9d6c6715fcc80fd5ca2" translate="yes" xml:space="preserve">
          <source>On the other hand does &lt;code&gt;nonatomic&lt;/code&gt; add nothing to your code. So it is only thread safe if you code security mechanism yourself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 자는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드에 아무것도 추가하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 보안 메커니즘을 직접 코딩하는 경우에만 스레드 안전합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6f9e4693c5de190a913db87e5fffad315df67cf0" translate="yes" xml:space="preserve">
          <source>Overall they are different in 2 aspects:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전반적으로 두 가지 측면에서 다릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8d21ad08d8d73e7da30d9ddc531902648d50e29" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://forums.developer.apple.com/thread/25642&quot;&gt;https://forums.developer.apple.com/thread/25642&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참조 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://forums.developer.apple.com/thread/25642&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://forums.developer.apple.com/thread/25642&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fecd72ac5703d1f089cc77fd529233801bb3a26" translate="yes" xml:space="preserve">
          <source>Retain counts are the way in which memory is managed in Objective-C.
  When you create an object, it has a retain count of 1. When you send
  an object a retain message, its retain count is incremented by 1. When
  you send an object a release message, its retain count is decremented
  by 1. When you send an object an &lt;strong&gt;autorelease message&lt;/strong&gt;, its retain count
  is decremented by 1 at some stage in the future. If an objectʼs retain
  count is reduced to 0, it is deallocated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보유 횟수는 Objective-C에서 메모리가 관리되는 방식입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체를 만들 때 유지 횟수는 1입니다. 객체에 보관 메시지를 보내면 보관 횟수가 1 씩 증가합니다. 객체를 릴리즈 메시지를 보내면 보관 횟수가 1 씩 감소합니다. 객체에 자동 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;릴리스 메시지를&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보내면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;향후 보유 단계에서 보유 횟수가 1 씩 감소합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체의 보유 횟수가 0으로 감소하면 할당이 해제됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebe6555b66f03eb95c37f29257ced7d32e7dc117" translate="yes" xml:space="preserve">
          <source>See Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8036604&quot;&gt;I am getting issues if I use @property(atomic,retain)NSString *myString&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8036604&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@property (atomic, retain) NSString * myString을 사용하면 문제가 발생하는&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스택 오버플로 질문을 참조하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9da147f788793e65a0755d642c4bb0e545a250a7" translate="yes" xml:space="preserve">
          <source>See more here: &lt;a href=&quot;https://realm.io/news/tmi-objective-c-property-attributes/&quot;&gt;https://realm.io/news/tmi-objective-c-property-attributes/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 내용은 여기를 참조하십시오 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://realm.io/news/tmi-objective-c-property-attributes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://realm.io/news/tmi-objective-c-property-attributes/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7f269e276c1c10bb04cd4f5d00a647d81224fcd" translate="yes" xml:space="preserve">
          <source>See the &quot;&lt;a href=&quot;http://www.scribd.com/doc/121014348/89/Performance-and-Threading&quot;&gt;Performance and Threading&lt;/a&gt;&quot; section of Apple's Objective-C 2.0 documentation for some more information and for other considerations when creating multi-threaded apps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레드 응용 프로그램을 만들 때의 추가 정보 및 기타 고려 사항은 Apple Objective-C 2.0 설명서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &quot; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.scribd.com/doc/121014348/89/Performance-and-Threading&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능 및 스레딩&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;섹션을 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48821aa7a0680f5b53cb1a6360cb3b3f30d0e1f3" translate="yes" xml:space="preserve">
          <source>Since there is no such thing like Mac OS Trash Bin, then nobody cares whether or not you always get a value (&amp;lt;-- This could potentially lead to a crash), nor anybody cares if someone tries to read halfway through your writing (although halfway writing in memory is very different from halfway writing on paper, on memory it could give you a crazy stupid value from before, while on paper you only see half of what's been written) --&amp;gt; Doesn't guarantee to not crash, because it doesn't use autorelease mechanism.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mac OS 휴지통과 같은 것은 없기 때문에 아무도 항상 가치를 얻는 지 (&amp;lt;-잠재적으로 충돌을 일으킬 수 있음) 상관하지 않으며 누군가가 글을 읽는 동안 절반을 읽으려고 할 때 아무도 신경 쓰지 않습니다. 메모리에 반만 쓰는 것은 종이에 반쯤 쓰는 것과는 매우 다릅니다. 메모리에 그것은 이전부터 미친 바보 같은 가치를 줄 수 있지만 종이에는 쓰여진 것의 절반 만 볼 수 있습니다)-&amp;gt; 충돌하지 않을 것이라고 보장하지 않습니다 자동 릴리스 메커니즘을 사용하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="113d393b69e044789d1b6366771234113f38b14f" translate="yes" xml:space="preserve">
          <source>So I'd be guessing that atomic in this case means the attribute reader methods cannot be interrupted - in effect meaning that the variable(s) being read by the method cannot change their value half way through because some other thread/call/function gets swapped onto the CPU.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서이 경우 원자는 속성 판독기 메소드를 중단 할 수 없다는 것을 의미합니다. 실제로 메소드가 읽은 변수는 다른 스레드 / 호출 / 함수가 가져 오기 때문에 절반의 값을 변경할 수 없음을 의미합니다 CPU로 교체되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="69377ccc9052efea495fe71ce1907c01a47348e0" translate="yes" xml:space="preserve">
          <source>So let's step back, &lt;em&gt;not&lt;/em&gt; focussing on the implementation of property accesses, we'll include the usual suspects like &lt;code&gt;objc_msgSend&lt;/code&gt;, and examine some real-world high-level results for many calls to a &lt;code&gt;NSString&lt;/code&gt; getter in &lt;em&gt;uncontested&lt;/em&gt; cases (values in seconds):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성 액세스 구현에 중점을 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두지 않고&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 뒤로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;objc_msgSend&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 일반적인 용의자를 포함 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시키고&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경합되지 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않은&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 경우에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NSString&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; getter에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대한 많은 호출에 대한 실제 높은 수준의 결과를 조사합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(초 단위 값).&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e73cec755e1a5861f24f2339a99f042aded44c4" translate="yes" xml:space="preserve">
          <source>So these last two are the same:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막 두 개는 동일합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fa399823cc9a3b9c6fc88614e72860a2970f673" translate="yes" xml:space="preserve">
          <source>Such situation operation will perform serially.
 &lt;strong&gt;And Slow in performance&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 상황 작업은 순차적으로 수행됩니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 성능 저하&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aef6c1df292141223c4225f95d65f2f8dd8d1cd6" translate="yes" xml:space="preserve">
          <source>Suppose a task related to three properties are</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세 가지 속성과 관련된 작업이&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7fc22c24b2c8b9f7f69f63e17474f6fc605495d1" translate="yes" xml:space="preserve">
          <source>Suppose there is an atomic string property called &quot;name&quot;, and if you call &lt;code&gt;[self setName:@&quot;A&quot;]&lt;/code&gt; from thread A, call &lt;code&gt;[self setName:@&quot;B&quot;]&lt;/code&gt; from thread B, and call &lt;code&gt;[self name]&lt;/code&gt; from thread C, then all operations on different threads will be performed serially which means if one thread is executing a setter or getter, then other threads will wait.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 &quot;이름&quot;이라는 원자 문자열 속성이며, 당신이 호출하면 가정 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self setName:@&quot;A&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스레드 A에서 호출 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self setName:@&quot;B&quot;]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 스레드 B에서, 그리고 전화 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[self name]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 스레드 C의 경우 다른 스레드의 모든 작업이 순차적으로 수행되므로 한 스레드가 setter 또는 getter를 실행 중이면 다른 스레드가 대기합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64bbc7da00d041882553632c9d6151a6047024d2" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;default&lt;/strong&gt; is &lt;code&gt;atomic&lt;/code&gt;, this means it does cost you performance whenever you use the property, but it is thread safe. What Objective-C does, is set a lock, so only the actual thread may access the variable, as long as the setter/getter is executed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,이 방법은 당신이 속성을 사용할 때마다 당신에게 성능 비용 않지만, 스레드 안전합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Objective-C는 잠금을 설정하므로 setter / getter가 실행되는 한 실제 스레드 만 변수에 액세스 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d29141c6d63a5b7ea6a09f9b7af2c90594dc0ae" translate="yes" xml:space="preserve">
          <source>The atomic property ensures to retain a fully initialised value irrespective of how many threads are doing getter &amp;amp; setter on it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;atomic 속성은 getter &amp;amp; setter를 수행하는 스레드 수에 관계없이 완전히 초기화 된 값을 유지합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6640dea145fe359abf70ed10c4ea9eb6bb728dda" translate="yes" xml:space="preserve">
          <source>The best way to understand the difference is using the following example.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차이점을 이해하는 가장 좋은 방법은 다음 예제를 사용하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3134cf91b76122f389197dac0a38627d8e34e79b" translate="yes" xml:space="preserve">
          <source>The last two are identical; &quot;atomic&quot; is the default behavior (&lt;strike&gt;note that it is not actually a keyword; it is specified only by the absence of &lt;code&gt;nonatomic&lt;/code&gt;&lt;/strike&gt; -- &lt;code&gt;atomic&lt;/code&gt; was added as a keyword in recent versions of llvm/clang).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막 두 개는 동일합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;원자&quot;는 기본 동작입니다 ( &lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 키워드가 아니며 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부재로만 지정됨&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 최근 버전의 llvm / clang에서 키워드로 추가됨).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54da41fe44eb73968148a077b290f8b60c74912e" translate="yes" xml:space="preserve">
          <source>The nonatomic property specifies that synthesized accessors simply set or return a value directly, with no guarantees about what happens if that same value is accessed simultaneously from different threads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;nonatomic 속성은 합성 된 접근자가 단순히 값을 직접 설정하거나 반환하도록 지정합니다. 동일한 값이 다른 스레드에서 동시에 액세스되는 경우에 대한 보장은 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="96d01ce85b72880373e3c0dcd3f3bc35a68d5182" translate="yes" xml:space="preserve">
          <source>The syntax and semantics are already well-defined by other excellent answers to this question. Because &lt;em&gt;execution&lt;/em&gt; and &lt;em&gt;performance&lt;/em&gt; are not detailed well, I will add my answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구문과 의미는 이미이 질문에 대한 다른 훌륭한 답변으로 잘 정의되어 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때문에 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실행&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 잘 설명되지 않습니다, 나는 내 대답을 추가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9dd04fd3b87b8e6634cb35ae09b1210f69bb26fd" translate="yes" xml:space="preserve">
          <source>The truth is that they use spin lock to implement atomic property. The code as below:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;진실은 그들이 스핀 속성을 사용하여 원자 속성을 구현한다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래와 같은 코드 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90d87c12b9e2bb4e32e509af94e1f228c0cf3ed3" translate="yes" xml:space="preserve">
          <source>Then It will return value &quot;Datta&quot; for B</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 B에 대해 &quot;Datta&quot;값을 반환합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12a3f33c0a6d700d8d23d40a430ab7d0d07c038c" translate="yes" xml:space="preserve">
          <source>There are actually a large number of different variants of how these things work depending on whether the properties are scalar values or objects, and how retain, copy, readonly, nonatomic, etc interact. In general the property synthesizers just know how to do the &quot;right thing&quot; for all combinations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 속성이 스칼라 값인지 개체인지, 유지, 복사, 읽기 전용, 비 원자 등이 상호 작용하는 방식에 따라 이러한 방식이 작동하는 방식에는 여러 가지 변형이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 속성 신디사이저는 모든 조합에 대해 &quot;올바른 일&quot;을 수행하는 방법을 알고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ca1757c9d44592c31915b42da6f23bdd121ea3e" translate="yes" xml:space="preserve">
          <source>This is explained in Apple's &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;documentation&lt;/a&gt;, but below are some examples of what is actually happening.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 Apple의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문서에&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 설명되어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있지만 아래는 실제로 일어나는 일의 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="066c6b0a7801dd6a2523303a92225758599fcded" translate="yes" xml:space="preserve">
          <source>This makes property &quot;name&quot; read/write safe, but if another thread, D, calls &lt;code&gt;[name release]&lt;/code&gt; simultaneously then this operation might produce a crash because there is no setter/getter call involved here. Which means an object is read/write safe (ATOMIC), but not thread-safe as another threads can simultaneously send any type of messages to the object. The developer should ensure thread-safety for such objects.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 속성 &quot;name&quot;이 (가) 읽기 / 쓰기 안전 상태가되지만 다른 스레드 D가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[name release]&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 동시에 호출하면 여기에 관련된 setter / getter 호출이 없기 때문에이 작업으로 인해 충돌이 발생할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 다른 스레드가 동시에 모든 유형의 메시지를 객체에 보낼 수 있으므로 객체는 읽기 / 쓰기 안전 (ATOMIC)이지만 스레드로부터 안전하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개발자는 이러한 객체에 대한 스레드 안전성을 보장해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e11028386ce8d3ec51e22188331a6eee4d25d4eb" translate="yes" xml:space="preserve">
          <source>Thread safety:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0add02488dd9fb38cb10fde62581151af49ced0" translate="yes" xml:space="preserve">
          <source>To address this, you need a &lt;em&gt;transactional model&lt;/em&gt;.   I.e. some other kind of synchronization and/or exclusion that allows one to exclude access to &lt;code&gt;fullName&lt;/code&gt; while the dependent properties are being updated.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 해결하려면 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;트랜잭션 모델&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 필요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, 종속 속성이 업데이트되는 동안 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fullName&lt;/code&gt; 에&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 액세스를 제외시킬 수있는 다른 종류의 동기화 및 / 또는 제외입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5110af47a6444933e62ac77d9ec23d8337442dd9" translate="yes" xml:space="preserve">
          <source>To simplify the entire confusion, let us understand mutex lock.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 혼란을 단순화하기 위해 뮤텍스 잠금을 이해하자.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc1c0153c9c58e2e9e7658c0005457d1997dea11" translate="yes" xml:space="preserve">
          <source>Unlike Atomic, it doesn't ensure fully initialised object return each time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자와 달리 매번 완전히 초기화 된 객체 반환을 보장하지는 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b24c7b3b63fa45274145ca8bf271886c92e41e64" translate="yes" xml:space="preserve">
          <source>Vijayendra Tripathi has already given an example for a multi-threaded environment.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Vijayendra Tripathi는 이미 멀티 스레드 환경에 대한 예를 제시했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="282a30d041d8affe9efa43d4e1dc9b43e44779fb" translate="yes" xml:space="preserve">
          <source>We can use the above like</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위와 같이 사용할 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3ba9e816602170c61a435a2bd6558fcc1491c60" translate="yes" xml:space="preserve">
          <source>What &quot;atomic&quot; does &lt;strong&gt;not&lt;/strong&gt; do is make any guarantees about thread safety.  If thread A is calling the getter simultaneously with thread B and C calling the setter with different values, thread A may get any one of the three values returned -- the one prior to any setters being called or either of the values passed into the setters in B and C.  Likewise, the object may end up with the value from B or C, no way to tell.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;원자&quot;가하지 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;않는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 것은 스레드 안전을 보장하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 A가 스레드 B와 동시에 getter를 호출하고 C가 다른 값을 가진 setter를 호출하는 경우 스레드 A는 세 개의 값 중 하나를 리턴 할 수 있습니다 (세터가 호출되기 전의 값 또는 세터에 전달 된 값 중 하나). 마찬가지로, 객체는 알 수없는 방식으로 B 또는 C의 값으로 끝날 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75b417c352b35dcb29960132183fac99bea8692c" translate="yes" xml:space="preserve">
          <source>What do &lt;code&gt;atomic&lt;/code&gt; and &lt;code&gt;nonatomic&lt;/code&gt; mean in property declarations?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성 선언에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 무엇을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의미합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f88aa3645b681f6cb9c6ef6394fafdf9591974e9" translate="yes" xml:space="preserve">
          <source>What is the functional difference between these 3?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 3의 기능적 차이점은 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b724b678520bf6613baa4fd73257c08dd17931cd" translate="yes" xml:space="preserve">
          <source>What is the operational difference between these three?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 세 가지의 운영상의 차이점은 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f756614cb11bcdd5b59e27f02d997161f296ea51" translate="yes" xml:space="preserve">
          <source>What's the difference between the atomic and nonatomic attributes</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 속성과 비 원자 속성의 차이점&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c64b1d527fee8009f5adc6a83e6a239d59e0ea51" translate="yes" xml:space="preserve">
          <source>Where to use &lt;code&gt;atomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 위치 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7e7bc1f7a764eaa33b78b0b105cc9acc35d0b510" translate="yes" xml:space="preserve">
          <source>Where to use &lt;code&gt;nonatomic&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;nonatomic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용 위치 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54566271c0cda41c75f32f014925fd367b3560c7" translate="yes" xml:space="preserve">
          <source>With &quot;atomic&quot;, the synthesized setter/getter will ensure that a &lt;em&gt;whole&lt;/em&gt; value is always returned from the getter or set by the setter, regardless of setter activity on any other thread.   That is, if thread A is in the middle of the getter while thread B calls the setter, an actual viable value -- an autoreleased object, most likely -- will be returned to the caller in A.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;원자&quot;를 사용하면 합성 된 setter / getter는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 스레드의 setter 활동에 관계없이 getter에서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 값이 반환되거나 setter가 설정하도록합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 스레드 A가 게터의 중간에 있고 스레드 B가 세터를 호출하면 실제 실행 가능한 값 (자동 해제 된 개체)이 A의 호출자에게 반환됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c9a3225e3bb61264813e6bc22cf4e00afcb6175" translate="yes" xml:space="preserve">
          <source>Yes. Multithreading means: multiple threads can read a shared piece of data at the same time and we will not crash, yet it doesn't guarantee that you aren't reading from a non-autoreleased value. With thread safety, it's guaranteed that what you read is not auto-released. 
The reason that we don't make everything atomic by default is, that there is a performance cost and for most things don't really need thread safety. A few parts of our code need it and for those few parts, we need to write our code in a thread-safe way using locks, mutex or synchronization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멀티 스레딩은 여러 스레드가 동시에 공유 데이터 조각을 읽을 수 있으며 충돌하지는 않지만 자동 릴리스되지 않은 값에서 읽지 않는다는 보장은 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전성을 통해 읽은 내용이 자동으로 해제되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리가 기본적으로 모든 것을 원자 적으로 만들지 않는 이유는 성능 비용이 있고 대부분의 경우 스레드 안전이 필요하지 않기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드의 일부에는 필요하고 그 일부에는 잠금, 뮤텍스 또는 동기화를 사용하여 스레드 안전 방식으로 코드를 작성해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca7ec366447fc5ec19a0b9ad7e6b1fe0fb298" translate="yes" xml:space="preserve">
          <source>atomic (default)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원자 (기본값)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a63e825f62c5da736e35e342ff2c8a54bca26cd" translate="yes" xml:space="preserve">
          <source>courtesy
&lt;a href=&quot;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&quot;&gt;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&lt;/a&gt;</source>
          <target state="translated">courtesy
&lt;a href=&quot;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&quot;&gt;https://medium.com/@YogevSitton/atomic-vs-non-atomic-properties-crash-course-d11c23f4366c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f124574f61bdf32374632af0108e67664713163a" translate="yes" xml:space="preserve">
          <source>courtesy &lt;a href=&quot;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&quot;&gt;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예의 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://academy.realm.io/posts/tmi-objective-c-property-attributes/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32e276343305029c03cdcb3816d31d9b48ec3b8a" translate="yes" xml:space="preserve">
          <source>faster (for synthesized code, that is, for variables created using @property and @synthesize)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 빠름 (합성 코드, 즉 @property 및 @synthesize를 사용하여 생성 된 변수의 경우)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b87d9f5aa62d639719db3c1cba82e1a8056395ba" translate="yes" xml:space="preserve">
          <source>from thread &lt;strong&gt;B&lt;/strong&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea03bbce1bf33f2a2f1f731974a10c0b4d23d189" translate="yes" xml:space="preserve">
          <source>if the instance variable is gonna be accessed in a multithreaded environment.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다중 스레드 환경에서 인스턴스 변수에 액세스하는 경우&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a72dfc65f7a451001d4950d531af6251bac7c29" translate="yes" xml:space="preserve">
          <source>is NOT the default behavior</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 동작이 아닙니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f84f249f927c1237bd8d3f9d8beee88f0e82e524" translate="yes" xml:space="preserve">
          <source>is NOT thread safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3f9636d3c7898c47849a2e162812438d24bdcd9" translate="yes" xml:space="preserve">
          <source>is not fast, as it ensures the process is completed entirely</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로세스가 완전히 완료되도록 보장하기 때문에 빠르지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="73a390d781fdc2811cea29373d9b4ebafddb1cd6" translate="yes" xml:space="preserve">
          <source>is the default behavior</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 동작입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4490b997d646a855de50058e749d8a90da0b8e08" translate="yes" xml:space="preserve">
          <source>is thread safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f05572b4d0844e4f8ee101746d55eb4ac8f137e3" translate="yes" xml:space="preserve">
          <source>may result in unexpected behavior, when two different process access the same variable at the same time</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;서로 다른 두 프로세스가 동일한 변수에 동시에 액세스 할 때 예기치 않은 동작이 발생할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f5ed1fe4cc1bdb26194014d8b09d207046b8cce" translate="yes" xml:space="preserve">
          <source>nonatomic</source>
          <target state="translated">nonatomic</target>
        </trans-unit>
        <trans-unit id="c749558b48cd7f85853939c44d043c5ce6c52a24" translate="yes" xml:space="preserve">
          <source>not thread-safe</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;스레드 안전하지 않은&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4983137fc7b12c4757b165db2c0980a574bdd040" translate="yes" xml:space="preserve">
          <source>will ensure the present process is completed by the CPU, before another process accesses the variable</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 프로세스가 변수에 액세스하기 전에 현재 프로세스가 CPU에 의해 완료되도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
