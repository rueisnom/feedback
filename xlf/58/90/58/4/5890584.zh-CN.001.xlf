<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/5890584">
    <body>
      <group id="5890584">
        <trans-unit id="f2b66a421a0655a184b6c33aee83557ebbe684e9" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html&quot;&gt;Reference: Efficient reshaping using data.tables&lt;/a&gt;)</source>
          <target state="translated">（ &lt;a href=&quot;https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html&quot;&gt;参考：使用data.tables进行有效的重塑&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="b423d301648942b4bc78aa000ffd20a2cb941079" translate="yes" xml:space="preserve">
          <source>-&amp;gt; created another column for showing the functionality</source>
          <target state="translated">-&amp;gt;创建了另一列以显示功能</target>
        </trans-unit>
        <trans-unit id="8c93e36a63740a396b58f1cd3bd7092e779a3c01" translate="yes" xml:space="preserve">
          <source>-single column long -&amp;gt; wide</source>
          <target state="translated">-单列长-&amp;gt;宽</target>
        </trans-unit>
        <trans-unit id="3e02b6a3faf5bc2e9319e23e96e7bf00c9aec131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt; specifies wide or long format</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; 指定宽或长格式</target>
        </trans-unit>
        <trans-unit id="5d209b595770146d619b3879e4cefed470a176dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idvar&lt;/code&gt; is the column of classes that separates rows</source>
          <target state="translated">&lt;code&gt;idvar&lt;/code&gt; 是分隔行的类的列</target>
        </trans-unit>
        <trans-unit id="dbf2606d2abb216ebd3bf8194a72b13e5427c552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqldf&lt;/code&gt; package:</source>
          <target state="translated">&lt;code&gt;sqldf&lt;/code&gt; 软件包：</target>
        </trans-unit>
        <trans-unit id="b732c0054669b0f3697aff02c007f66aac2d1419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tidyr&lt;/code&gt; is a reframing of &lt;code&gt;reshape2&lt;/code&gt; designed to accompany the tidy data framework, and to work hand-in-hand with &lt;code&gt;magrittr&lt;/code&gt; and &lt;code&gt;dplyr&lt;/code&gt; to build a solid pipeline for data analysis.</source>
          <target state="translated">&lt;code&gt;tidyr&lt;/code&gt; 是 &lt;code&gt;reshape2&lt;/code&gt; 的改版,旨在配合整洁的数据框架，并与 &lt;code&gt;magrittr&lt;/code&gt; 和 &lt;code&gt;dplyr&lt;/code&gt; 携手合作 ，为数据分析构建坚实的管道。</target>
        </trans-unit>
        <trans-unit id="59f92604e7a9721fb8b4f780700116cc104a8d00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timevar&lt;/code&gt; is the column of classes to cast wide</source>
          <target state="translated">&lt;code&gt;timevar&lt;/code&gt; 是要广泛使用的类的列</target>
        </trans-unit>
        <trans-unit id="363785327e5d76185fca735eb93a3c3a46c80eca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v.names&lt;/code&gt; is the column containing numeric values</source>
          <target state="translated">&lt;code&gt;v.names&lt;/code&gt; 是包含数值的列</target>
        </trans-unit>
        <trans-unit id="8b48c85794bfb5c7ca45d586626d1f8ce4e83548" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Now, in 2019, tidyr v 1.0 has launched and set &lt;code&gt;spread&lt;/code&gt; and &lt;code&gt;gather&lt;/code&gt; on a deprecation path, preferring instead &lt;code&gt;pivot_wider&lt;/code&gt; and &lt;code&gt;pivot_longer&lt;/code&gt;, which you can find described &lt;a href=&quot;https://stackoverflow.com/a/57013551/903061&quot;&gt;in this answer&lt;/a&gt;. Read on if you want a brief glimpse into the brief life of &lt;code&gt;spread/gather&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;现在，在2019年，tidyr v 1.0已启动并设置了 &lt;code&gt;spread&lt;/code&gt; 和 &lt;code&gt;gather&lt;/code&gt; 的弃用路径，而更喜欢使用 &lt;code&gt;pivot_wider&lt;/code&gt; 和 &lt;code&gt;pivot_longer&lt;/code&gt; ，您可以&lt;a href=&quot;https://stackoverflow.com/a/57013551/903061&quot;&gt;在此答案中&lt;/a&gt;找到它们。 如果您想简要了解一下 &lt;code&gt;spread/gather&lt;/code&gt; 的短暂生活，请继续阅读。</target>
        </trans-unit>
        <trans-unit id="55cc92d6fbd3bc4d924c769f7115a4e5bd8a7f7c" translate="yes" xml:space="preserve">
          <source>And, as of data.table v1.9.6 we can cast on multiple columns</source>
          <target state="translated">而且,从data.table v1.9.6版的data.table开始,我们可以在多个列上投出</target>
        </trans-unit>
        <trans-unit id="c8f052b9cda47e8ce74251c074f38bcfe2a7a09f" translate="yes" xml:space="preserve">
          <source>Another option if performance is a concern is to use &lt;code&gt;data.table&lt;/code&gt;'s extension of &lt;code&gt;reshape2&lt;/code&gt;'s melt &amp;amp; dcast functions</source>
          <target state="translated">如果要考虑性能，则另一个选择是使用 &lt;code&gt;data.table&lt;/code&gt; 对 &lt;code&gt;reshape2&lt;/code&gt; 的melt＆dcast函数的扩展</target>
        </trans-unit>
        <trans-unit id="32adc54da7e1dd098f05014024de61a9f88fbe05" translate="yes" xml:space="preserve">
          <source>Base package:</source>
          <target state="translated">基础包。</target>
        </trans-unit>
        <trans-unit id="1f8d5da96d5ee502ef384d47dcdae51782a2e3c8" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://github.com/hadley/tidyr&quot;&gt;github&lt;/a&gt;,</source>
          <target state="translated">来自&lt;a href=&quot;https://github.com/hadley/tidyr&quot;&gt;github&lt;/a&gt; ，</target>
        </trans-unit>
        <trans-unit id="77c7c7ba946bfbd9be7a9ee608e586028b25bf2f" translate="yes" xml:space="preserve">
          <source>How to reshape data from long to wide format</source>
          <target state="translated">如何从长格式到宽格式的数据重塑数据</target>
        </trans-unit>
        <trans-unit id="95feb5be7cb2c1d8edbf0be2fd2f15bb3e5c1c78" translate="yes" xml:space="preserve">
          <source>I want to reshape it so that each unique &quot;name&quot; variable is a rowname, with the &quot;values&quot; as observations along that row and the &quot;numbers&quot; as colnames. Sort of like this:</source>
          <target state="translated">我想重塑它,使每个唯一的 &quot;name &quot;变量都是一个rowname,&quot;值 &quot;是沿该行的观测值,&quot;数字 &quot;是colnames。有点像这样。</target>
        </trans-unit>
        <trans-unit id="d9a3ccd40ef3877efe8a1b2cb4d6f770e62e7c0e" translate="yes" xml:space="preserve">
          <source>I'm having trouble rearranging the following data frame:</source>
          <target state="translated">我在重新整理下面的数据框时遇到了麻烦。</target>
        </trans-unit>
        <trans-unit id="1fd30b3bce62814bd717849f08ded001356603d4" translate="yes" xml:space="preserve">
          <source>I've looked at &lt;code&gt;melt&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; and a few other things, but none seem to do the job.</source>
          <target state="translated">我已经看过 &lt;code&gt;melt&lt;/code&gt; 和 &lt;code&gt;cast&lt;/code&gt; 以及其他一些东西，但是似乎没有一个能做得到。</target>
        </trans-unit>
        <trans-unit id="67d8bbe85b74ca1fe2c44834d30774330a464d0b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;idvar&lt;/code&gt; exists, create one before using the &lt;code&gt;reshape()&lt;/code&gt; function:</source>
          <target state="translated">如果不存在 &lt;code&gt;idvar&lt;/code&gt; ，请在使用 &lt;code&gt;reshape()&lt;/code&gt; 函数之前创建一个：</target>
        </trans-unit>
        <trans-unit id="22f98d9b19a256e05bc0cd6a1bb6e03c69bca481" translate="yes" xml:space="preserve">
          <source>It is easy to write many different operations in terms of the
  cdata primitives. These operators can work-in memory or at big data
  scale (with databases and Apache Spark; for big data use the
  cdata::moveValuesToRowsN() and cdata::moveValuesToColumnsN()
  variants). The transforms are controlled by a control table that
  itself is a diagram of (or picture of) the transform.</source>
          <target state="translated">在cdata基元方面,很容易写出许多不同的操作。这些操作符可以在内存中工作,也可以在大数据规模下工作(使用数据库和Apache Spark;对于大数据,使用cdata:::moveValuesToRowsN()和cdata:::moveValuesToColumnsN()变体)。这些变换由一个控制表控制,该表本身就是一个变换的图(或图片)。</target>
        </trans-unit>
        <trans-unit id="144e741b4c39fd81ed7915072c22a68ebeaf8e92" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;reshape2&lt;/code&gt; did less than reshape, &lt;code&gt;tidyr&lt;/code&gt; does less than &lt;code&gt;reshape2&lt;/code&gt;. It's designed specifically for tidying data, not the general reshaping that &lt;code&gt;reshape2&lt;/code&gt; does, or the general aggregation that reshape did. In particular, built-in methods only work for data frames, and &lt;code&gt;tidyr&lt;/code&gt; provides no margins or aggregation.</source>
          <target state="translated">就像 &lt;code&gt;reshape2&lt;/code&gt; 做不到一样， &lt;code&gt;tidyr&lt;/code&gt; &lt;code&gt;reshape2&lt;/code&gt; 。 它是专门为整理数据而设计的，而不是 &lt;code&gt;reshape2&lt;/code&gt; 进行的一般重塑或reshape2进行的一般聚合。 特别是，内置方法仅适用于数据帧， &lt;code&gt;tidyr&lt;/code&gt; 不提供边距或聚合。</target>
        </trans-unit>
        <trans-unit id="3c330efc8ae2749590fbcb23486dd883c59d7bc4" translate="yes" xml:space="preserve">
          <source>Just remember that &lt;code&gt;idvar&lt;/code&gt; is required! The &lt;code&gt;timevar&lt;/code&gt; and &lt;code&gt;v.names&lt;/code&gt; part is easy. The output of this function is more predictable than some of the others, as everything is explicitly defined.</source>
          <target state="translated">请记住， &lt;code&gt;idvar&lt;/code&gt; 是必需的！ &lt;code&gt;timevar&lt;/code&gt; 和 &lt;code&gt;v.names&lt;/code&gt; 部分很简单。 该函数的输出比其他一些函数更可预测，因为所有内容都已明确定义。</target>
        </trans-unit>
        <trans-unit id="7b370008864784686060818eff43542ed6216d81" translate="yes" xml:space="preserve">
          <source>Or using &lt;code&gt;reshape2&lt;/code&gt;</source>
          <target state="translated">或使用 &lt;code&gt;reshape2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef57e5ac4f5671078f6faf0de903013d96b5fb3f" translate="yes" xml:space="preserve">
          <source>Other two options:</source>
          <target state="translated">其他两个选项:</target>
        </trans-unit>
        <trans-unit id="7c776aa89da2f0d5f86aeab3955679d17f1de770" translate="yes" xml:space="preserve">
          <source>The base &lt;code&gt;reshape&lt;/code&gt; function works perfectly fine:</source>
          <target state="translated">基本 &lt;code&gt;reshape&lt;/code&gt; 功能可以正常工作：</target>
        </trans-unit>
        <trans-unit id="0ed9a8ad112ec9c8e0b3a0bfa9fd2e6a613cf44a" translate="yes" xml:space="preserve">
          <source>The new (in 2014) &lt;code&gt;tidyr&lt;/code&gt; package also does this simply, with &lt;code&gt;gather()&lt;/code&gt;/&lt;code&gt;spread()&lt;/code&gt; being the terms for &lt;code&gt;melt&lt;/code&gt;/&lt;code&gt;cast&lt;/code&gt;.</source>
          <target state="translated">新的（2014年） &lt;code&gt;tidyr&lt;/code&gt; 包也可以简单地做到这一点， &lt;code&gt;gather()&lt;/code&gt; / &lt;code&gt;spread()&lt;/code&gt; 是 &lt;code&gt;melt&lt;/code&gt; / &lt;code&gt;cast&lt;/code&gt; 的术语。</target>
        </trans-unit>
        <trans-unit id="d83d3182426e986c1d29038fb322bbd38cd8bfb2" translate="yes" xml:space="preserve">
          <source>The whole system is based on two primitives or operators
  cdata::moveValuesToRowsD() and cdata::moveValuesToColumnsD(). These
  operators have pivot, un-pivot, one-hot encode, transpose, moving
  multiple rows and columns, and many other transforms as simple special
  cases.</source>
          <target state="translated">整个系统基于两个基元或运算符cdata:::moveValuesToRowsD()和cdata:::moveValuesToColumnsD()两个基元或运算符。这些操作符有透视、非透视、单热编码、转置、移动多行和多列,以及许多其他的变换作为简单的特殊情况。</target>
        </trans-unit>
        <trans-unit id="8bf9bf881f1ad32b3180f6ade4bfb0d25ba9e77b" translate="yes" xml:space="preserve">
          <source>There's very powerful new package from genius data scientists at Win-Vector (folks that made &lt;code&gt;vtreat&lt;/code&gt;, &lt;code&gt;seplyr&lt;/code&gt; and &lt;code&gt;replyr&lt;/code&gt;) called &lt;code&gt;cdata&lt;/code&gt;. It implements &quot;coordinated data&quot; principles described in &lt;a href=&quot;https://github.com/WinVector/cdata/blob/master/extras/RowsAndColumns.md&quot;&gt;this document&lt;/a&gt; and also in this &lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;blog post&lt;/a&gt;. The idea is that regardless how you organize your data, it should be possible to identify individual data points using a system of &quot;data coordinates&quot;. Here's a excerpt from the recent blog post by John Mount:</source>
          <target state="translated">Win-Vector的天才数据科学家提供了一个非常强大的新程序包（制作 &lt;code&gt;vtreat&lt;/code&gt; ， &lt;code&gt;seplyr&lt;/code&gt; 和 &lt;code&gt;replyr&lt;/code&gt; ），称为 &lt;code&gt;cdata&lt;/code&gt; 。 它实现了&lt;a href=&quot;https://github.com/WinVector/cdata/blob/master/extras/RowsAndColumns.md&quot;&gt;本文档&lt;/a&gt;以及本&lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;博客文章中&lt;/a&gt;描述的&amp;ldquo;协调数据&amp;rdquo;原则。 这个想法是，无论您如何组织数据，都应该有可能使用&amp;ldquo;数据坐标&amp;rdquo;系统来识别单个数据点。 这是John Mount最近的博客文章的节选：</target>
        </trans-unit>
        <trans-unit id="15ae6a8db4ce297ef06455be3cfe1f8dfaaeef58" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reshape&lt;/code&gt; function:</source>
          <target state="translated">使用 &lt;code&gt;reshape&lt;/code&gt; 功能：</target>
        </trans-unit>
        <trans-unit id="716e5f0424b51cc0958fe5b0a70776fe077e97d1" translate="yes" xml:space="preserve">
          <source>Using base R &lt;code&gt;aggregate&lt;/code&gt; function:</source>
          <target state="translated">使用基数R &lt;code&gt;aggregate&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="db2d34eff67a4da9f9fedec623a7b05fafe765ba" translate="yes" xml:space="preserve">
          <source>Using your example dataframe, we could:</source>
          <target state="translated">使用你的示例数据框架,我们可以:</target>
        </trans-unit>
        <trans-unit id="a164e0f73cee51e074bfd5170f1b3ad81650de93" translate="yes" xml:space="preserve">
          <source>We will first build the control table (see &lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;blog post&lt;/a&gt; for details) and then perform the move of data from rows to columns.</source>
          <target state="translated">我们将首先构建控制表（有关详细信息，请参见&lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;博客文章&lt;/a&gt; ），然后执行数据从行到列的移动。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="efb2d954501863c2a58fba735f23397d425284ec" translate="yes" xml:space="preserve">
          <source>With the devel version of &lt;code&gt;tidyr&lt;/code&gt;&lt;code&gt;&amp;lsquo;0.8.3.9000&amp;rsquo;&lt;/code&gt;, there is &lt;code&gt;pivot_wider&lt;/code&gt; and &lt;code&gt;pivot_longer&lt;/code&gt; which is generalized to do the reshaping (long -&amp;gt; wide, wide -&amp;gt; long, respectively) from 1 to multiple columns.  Using the OP's data</source>
          <target state="translated">在 &lt;code&gt;tidyr&lt;/code&gt; '0.8.3.9000 &lt;code&gt;&amp;lsquo;0.8.3.9000&amp;rsquo;&lt;/code&gt; 的开发版本中，存在 &lt;code&gt;pivot_wider&lt;/code&gt; 和 &lt;code&gt;pivot_longer&lt;/code&gt; ，它们被概括为从1列更改为多列（长-&amp;gt;宽，宽-&amp;gt;长）。 使用OP的数据</target>
        </trans-unit>
        <trans-unit id="2a1d1e5bd82d0fd7df26169b22ad20aff853baeb" translate="yes" xml:space="preserve">
          <source>You can do this with the &lt;code&gt;reshape()&lt;/code&gt; function, or with the &lt;code&gt;melt()&lt;/code&gt; / &lt;code&gt;cast()&lt;/code&gt; functions in the reshape package. For the second option, example code is</source>
          <target state="translated">您可以使用 &lt;code&gt;reshape()&lt;/code&gt; 函数或reshape包中的 &lt;code&gt;melt()&lt;/code&gt; / &lt;code&gt;cast()&lt;/code&gt; 函数来完成此操作。 对于第二个选项，示例代码为</target>
        </trans-unit>
        <trans-unit id="446e1da4bffc55b3260320c1b4dbeec48a8a7ccc" translate="yes" xml:space="preserve">
          <source>if you want to go back from wide to long, only change Wide to Long, and no changes in objects.</source>
          <target state="translated">如果你想从宽到长,只改宽到长,不改变对象。</target>
        </trans-unit>
        <trans-unit id="5f5de958335b3f6a5d3ec3e7658e6a483d9d104f" translate="yes" xml:space="preserve">
          <source>much easier way!</source>
          <target state="translated">更简单的方法!</target>
        </trans-unit>
        <trans-unit id="8c29c224a25b16cff35e5ec4cbce49639805ad8c" translate="yes" xml:space="preserve">
          <source>the optional &lt;code&gt;sep&lt;/code&gt; argument is the separator used in between &lt;code&gt;timevar&lt;/code&gt; class names and &lt;code&gt;v.names&lt;/code&gt; in the output &lt;code&gt;data.frame&lt;/code&gt;.</source>
          <target state="translated">可选的 &lt;code&gt;sep&lt;/code&gt; 参数是在输出 &lt;code&gt;data.frame&lt;/code&gt; &lt;code&gt;v.names&lt;/code&gt; 中的 &lt;code&gt;timevar&lt;/code&gt; 类名称和v.name之间使用的分隔符。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
