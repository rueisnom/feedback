<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5890584">
    <body>
      <group id="5890584">
        <trans-unit id="f2b66a421a0655a184b6c33aee83557ebbe684e9" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html&quot;&gt;Reference: Efficient reshaping using data.tables&lt;/a&gt;)</source>
          <target state="translated">( &lt;a href=&quot;https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reshape.html&quot;&gt;참조 : data.tables를 사용하여 효율적인 재 형성&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b423d301648942b4bc78aa000ffd20a2cb941079" translate="yes" xml:space="preserve">
          <source>-&amp;gt; created another column for showing the functionality</source>
          <target state="translated">-&amp;gt; 기능을 보여주기 위해 다른 열을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="8c93e36a63740a396b58f1cd3bd7092e779a3c01" translate="yes" xml:space="preserve">
          <source>-single column long -&amp;gt; wide</source>
          <target state="translated">-단일 열-&amp;gt; 넓음</target>
        </trans-unit>
        <trans-unit id="3e02b6a3faf5bc2e9319e23e96e7bf00c9aec131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt; specifies wide or long format</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; 은 넓거나 긴 형식을 지정합니다</target>
        </trans-unit>
        <trans-unit id="5d209b595770146d619b3879e4cefed470a176dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idvar&lt;/code&gt; is the column of classes that separates rows</source>
          <target state="translated">&lt;code&gt;idvar&lt;/code&gt; 은 행을 구분하는 클래스의 열입니다.</target>
        </trans-unit>
        <trans-unit id="dbf2606d2abb216ebd3bf8194a72b13e5427c552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqldf&lt;/code&gt; package:</source>
          <target state="translated">&lt;code&gt;sqldf&lt;/code&gt; 패키지 :</target>
        </trans-unit>
        <trans-unit id="b732c0054669b0f3697aff02c007f66aac2d1419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tidyr&lt;/code&gt; is a reframing of &lt;code&gt;reshape2&lt;/code&gt; designed to accompany the tidy data framework, and to work hand-in-hand with &lt;code&gt;magrittr&lt;/code&gt; and &lt;code&gt;dplyr&lt;/code&gt; to build a solid pipeline for data analysis.</source>
          <target state="translated">&lt;code&gt;tidyr&lt;/code&gt; 는 깔끔한 데이터 프레임 워크와 함께 &lt;code&gt;magrittr&lt;/code&gt; 되고 &lt;code&gt;dplyr&lt;/code&gt; 및 dplyr 와 함께 데이터 분석을위한 견고한 파이프 라인을 구축하도록 설계된 &lt;code&gt;reshape2&lt;/code&gt; 의 재구성입니다.</target>
        </trans-unit>
        <trans-unit id="59f92604e7a9721fb8b4f780700116cc104a8d00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timevar&lt;/code&gt; is the column of classes to cast wide</source>
          <target state="translated">&lt;code&gt;timevar&lt;/code&gt; 은 광범위하게 캐스팅 할 클래스 열입니다.</target>
        </trans-unit>
        <trans-unit id="363785327e5d76185fca735eb93a3c3a46c80eca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v.names&lt;/code&gt; is the column containing numeric values</source>
          <target state="translated">&lt;code&gt;v.names&lt;/code&gt; 는 숫자 값을 포함하는 열입니다.</target>
        </trans-unit>
        <trans-unit id="8b48c85794bfb5c7ca45d586626d1f8ce4e83548" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Now, in 2019, tidyr v 1.0 has launched and set &lt;code&gt;spread&lt;/code&gt; and &lt;code&gt;gather&lt;/code&gt; on a deprecation path, preferring instead &lt;code&gt;pivot_wider&lt;/code&gt; and &lt;code&gt;pivot_longer&lt;/code&gt;, which you can find described &lt;a href=&quot;https://stackoverflow.com/a/57013551/903061&quot;&gt;in this answer&lt;/a&gt;. Read on if you want a brief glimpse into the brief life of &lt;code&gt;spread/gather&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 이제 2019 년 tidyr v 1.0이 시작 및 사용 중단 경로에서 &lt;code&gt;gather&lt;/code&gt; 및 수집 을 설정하고 대신 &lt;code&gt;pivot_wider&lt;/code&gt; 및 &lt;code&gt;pivot_longer&lt;/code&gt; 를 선호합니다. &lt;a href=&quot;https://stackoverflow.com/a/57013551/903061&quot;&gt;이 답변에&lt;/a&gt; 설명 되어 있습니다. 간단한 &lt;code&gt;spread/gather&lt;/code&gt; 수명을 간략히 살펴 보려면 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="55cc92d6fbd3bc4d924c769f7115a4e5bd8a7f7c" translate="yes" xml:space="preserve">
          <source>And, as of data.table v1.9.6 we can cast on multiple columns</source>
          <target state="translated">그리고 data.table v1.9.6부터 여러 열에 캐스트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c8f052b9cda47e8ce74251c074f38bcfe2a7a09f" translate="yes" xml:space="preserve">
          <source>Another option if performance is a concern is to use &lt;code&gt;data.table&lt;/code&gt;'s extension of &lt;code&gt;reshape2&lt;/code&gt;'s melt &amp;amp; dcast functions</source>
          <target state="translated">성능이 &lt;code&gt;data.table&lt;/code&gt; 경우 또 다른 옵션은 &lt;code&gt;reshape2&lt;/code&gt; 의 reshape2 확장 및 용융 기능 확장을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32adc54da7e1dd098f05014024de61a9f88fbe05" translate="yes" xml:space="preserve">
          <source>Base package:</source>
          <target state="translated">기본 패키지 :</target>
        </trans-unit>
        <trans-unit id="1f8d5da96d5ee502ef384d47dcdae51782a2e3c8" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://github.com/hadley/tidyr&quot;&gt;github&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;https://github.com/hadley/tidyr&quot;&gt;github&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="77c7c7ba946bfbd9be7a9ee608e586028b25bf2f" translate="yes" xml:space="preserve">
          <source>How to reshape data from long to wide format</source>
          <target state="translated">긴 형식에서 넓은 형식으로 데이터를 재구성하는 방법</target>
        </trans-unit>
        <trans-unit id="95feb5be7cb2c1d8edbf0be2fd2f15bb3e5c1c78" translate="yes" xml:space="preserve">
          <source>I want to reshape it so that each unique &quot;name&quot; variable is a rowname, with the &quot;values&quot; as observations along that row and the &quot;numbers&quot; as colnames. Sort of like this:</source>
          <target state="translated">각 고유 한 &quot;name&quot;변수가 행 이름이되도록 행 이름을 바꾸고 싶습니다. &quot;values&quot;는 해당 행을 따라 관측 값이되고 &quot;numbers&quot;는 colnames입니다. 이런 종류의 :</target>
        </trans-unit>
        <trans-unit id="d9a3ccd40ef3877efe8a1b2cb4d6f770e62e7c0e" translate="yes" xml:space="preserve">
          <source>I'm having trouble rearranging the following data frame:</source>
          <target state="translated">다음 데이터 프레임을 다시 정렬하는 데 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd30b3bce62814bd717849f08ded001356603d4" translate="yes" xml:space="preserve">
          <source>I've looked at &lt;code&gt;melt&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; and a few other things, but none seem to do the job.</source>
          <target state="translated">나는 &lt;code&gt;melt&lt;/code&gt; &lt;code&gt;cast&lt;/code&gt; 와 다른 것들을 보았지만 아무도 그 일을하는 것처럼 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67d8bbe85b74ca1fe2c44834d30774330a464d0b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;idvar&lt;/code&gt; exists, create one before using the &lt;code&gt;reshape()&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;idvar&lt;/code&gt; 이없는 경우 &lt;code&gt;reshape()&lt;/code&gt; 함수를 사용하기 전에 하나를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="22f98d9b19a256e05bc0cd6a1bb6e03c69bca481" translate="yes" xml:space="preserve">
          <source>It is easy to write many different operations in terms of the
  cdata primitives. These operators can work-in memory or at big data
  scale (with databases and Apache Spark; for big data use the
  cdata::moveValuesToRowsN() and cdata::moveValuesToColumnsN()
  variants). The transforms are controlled by a control table that
  itself is a diagram of (or picture of) the transform.</source>
          <target state="translated">cdata 프리미티브 측면에서 다양한 작업을 쉽게 작성할 수 있습니다. 이러한 연산자는 메모리 및 빅 데이터 규모로 작업 할 수 있습니다 (데이터베이스 및 Apache Spark의 경우 빅 데이터의 경우 cdata :: moveValuesToRowsN () 및 cdata :: moveValuesToColumnsN () 변형 사용). 변환은 그 자체가 변환의 다이어그램 (또는 그림) 인 제어 테이블에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="144e741b4c39fd81ed7915072c22a68ebeaf8e92" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;reshape2&lt;/code&gt; did less than reshape, &lt;code&gt;tidyr&lt;/code&gt; does less than &lt;code&gt;reshape2&lt;/code&gt;. It's designed specifically for tidying data, not the general reshaping that &lt;code&gt;reshape2&lt;/code&gt; does, or the general aggregation that reshape did. In particular, built-in methods only work for data frames, and &lt;code&gt;tidyr&lt;/code&gt; provides no margins or aggregation.</source>
          <target state="translated">&lt;code&gt;reshape2&lt;/code&gt; 가 reshape보다 덜한 것처럼 tidyr 은 &lt;code&gt;tidyr&lt;/code&gt; 보다 &lt;code&gt;reshape2&lt;/code&gt; 합니다. 이는 &lt;code&gt;reshape2&lt;/code&gt; 가 수행하는 일반적인 재구성이나 reshape이 수행 한 일반적인 집계가 아닌 데이터 정리를 위해 특별히 설계되었습니다. 특히 기본 제공 방법은 데이터 프레임에만 적용되며 &lt;code&gt;tidyr&lt;/code&gt; 은 여백이나 집계를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c330efc8ae2749590fbcb23486dd883c59d7bc4" translate="yes" xml:space="preserve">
          <source>Just remember that &lt;code&gt;idvar&lt;/code&gt; is required! The &lt;code&gt;timevar&lt;/code&gt; and &lt;code&gt;v.names&lt;/code&gt; part is easy. The output of this function is more predictable than some of the others, as everything is explicitly defined.</source>
          <target state="translated">&lt;code&gt;idvar&lt;/code&gt; 이 필요하다는 것을 기억하십시오! &lt;code&gt;timevar&lt;/code&gt; 및 &lt;code&gt;v.names&lt;/code&gt; 부분은 쉽습니다. 이 함수의 출력은 모든 것이 명시 적으로 정의되어 있기 때문에 다른 것보다 더 예측 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7b370008864784686060818eff43542ed6216d81" translate="yes" xml:space="preserve">
          <source>Or using &lt;code&gt;reshape2&lt;/code&gt;</source>
          <target state="translated">또는 &lt;code&gt;reshape2&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="ef57e5ac4f5671078f6faf0de903013d96b5fb3f" translate="yes" xml:space="preserve">
          <source>Other two options:</source>
          <target state="translated">다른 두 가지 옵션 :</target>
        </trans-unit>
        <trans-unit id="7c776aa89da2f0d5f86aeab3955679d17f1de770" translate="yes" xml:space="preserve">
          <source>The base &lt;code&gt;reshape&lt;/code&gt; function works perfectly fine:</source>
          <target state="translated">기본 &lt;code&gt;reshape&lt;/code&gt; 기능은 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0ed9a8ad112ec9c8e0b3a0bfa9fd2e6a613cf44a" translate="yes" xml:space="preserve">
          <source>The new (in 2014) &lt;code&gt;tidyr&lt;/code&gt; package also does this simply, with &lt;code&gt;gather()&lt;/code&gt;/&lt;code&gt;spread()&lt;/code&gt; being the terms for &lt;code&gt;melt&lt;/code&gt;/&lt;code&gt;cast&lt;/code&gt;.</source>
          <target state="translated">새로운 (2014 년) &lt;code&gt;tidyr&lt;/code&gt; 패키지는 간단하게 이것을 수행하며, collect &lt;code&gt;gather()&lt;/code&gt; / &lt;code&gt;spread()&lt;/code&gt; 가 &lt;code&gt;melt&lt;/code&gt; / &lt;code&gt;cast&lt;/code&gt; 의 용어입니다.</target>
        </trans-unit>
        <trans-unit id="d83d3182426e986c1d29038fb322bbd38cd8bfb2" translate="yes" xml:space="preserve">
          <source>The whole system is based on two primitives or operators
  cdata::moveValuesToRowsD() and cdata::moveValuesToColumnsD(). These
  operators have pivot, un-pivot, one-hot encode, transpose, moving
  multiple rows and columns, and many other transforms as simple special
  cases.</source>
          <target state="translated">전체 시스템은 두 개의 기본 요소 또는 연산자 cdata :: moveValuesToRowsD () 및 cdata :: moveValuesToColumnsD ()를 기반으로합니다. 이 연산자에는 피벗, 피벗 해제, 원핫 인코딩, 조옮김, 여러 행과 열 이동 및 기타 특수한 변형이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf9bf881f1ad32b3180f6ade4bfb0d25ba9e77b" translate="yes" xml:space="preserve">
          <source>There's very powerful new package from genius data scientists at Win-Vector (folks that made &lt;code&gt;vtreat&lt;/code&gt;, &lt;code&gt;seplyr&lt;/code&gt; and &lt;code&gt;replyr&lt;/code&gt;) called &lt;code&gt;cdata&lt;/code&gt;. It implements &quot;coordinated data&quot; principles described in &lt;a href=&quot;https://github.com/WinVector/cdata/blob/master/extras/RowsAndColumns.md&quot;&gt;this document&lt;/a&gt; and also in this &lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;blog post&lt;/a&gt;. The idea is that regardless how you organize your data, it should be possible to identify individual data points using a system of &quot;data coordinates&quot;. Here's a excerpt from the recent blog post by John Mount:</source>
          <target state="translated">&lt;code&gt;cdata&lt;/code&gt; 라는 Win-Vector ( &lt;code&gt;vtreat&lt;/code&gt; , &lt;code&gt;seplyr&lt;/code&gt; 및 &lt;code&gt;replyr&lt;/code&gt; 를 만든 사람들)의 천재 데이터 과학자들이 제공하는 매우 강력한 새 패키지가 있습니다. &lt;a href=&quot;https://github.com/WinVector/cdata/blob/master/extras/RowsAndColumns.md&quot;&gt;이 문서&lt;/a&gt; 와이 &lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;블로그 게시물&lt;/a&gt; 에 설명 된 &quot;조정 된 데이터&quot;원칙을 구현합니다. 아이디어는 데이터 구성 방법에 관계없이 &quot;데이터 좌표&quot;시스템을 사용하여 개별 데이터 요소를 식별 할 수 있어야한다는 것입니다. 다음은 John Mount의 최근 블로그 게시물에서 발췌 한 내용입니다.</target>
        </trans-unit>
        <trans-unit id="15ae6a8db4ce297ef06455be3cfe1f8dfaaeef58" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reshape&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;reshape&lt;/code&gt; 기능 사용 :</target>
        </trans-unit>
        <trans-unit id="716e5f0424b51cc0958fe5b0a70776fe077e97d1" translate="yes" xml:space="preserve">
          <source>Using base R &lt;code&gt;aggregate&lt;/code&gt; function:</source>
          <target state="translated">기본 R &lt;code&gt;aggregate&lt;/code&gt; 함수 사용 :</target>
        </trans-unit>
        <trans-unit id="db2d34eff67a4da9f9fedec623a7b05fafe765ba" translate="yes" xml:space="preserve">
          <source>Using your example dataframe, we could:</source>
          <target state="translated">예제 데이터 프레임을 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a164e0f73cee51e074bfd5170f1b3ad81650de93" translate="yes" xml:space="preserve">
          <source>We will first build the control table (see &lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;blog post&lt;/a&gt; for details) and then perform the move of data from rows to columns.</source>
          <target state="translated">먼저 제어 테이블을 작성하고 (자세한 내용은 &lt;a href=&quot;http://www.win-vector.com/blog/2017/03/coordinatized-data-a-fluid-data-specification/&quot;&gt;블로그 게시물&lt;/a&gt; 참조) 데이터를 행에서 열로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="efb2d954501863c2a58fba735f23397d425284ec" translate="yes" xml:space="preserve">
          <source>With the devel version of &lt;code&gt;tidyr&lt;/code&gt;&lt;code&gt;&amp;lsquo;0.8.3.9000&amp;rsquo;&lt;/code&gt;, there is &lt;code&gt;pivot_wider&lt;/code&gt; and &lt;code&gt;pivot_longer&lt;/code&gt; which is generalized to do the reshaping (long -&amp;gt; wide, wide -&amp;gt; long, respectively) from 1 to multiple columns.  Using the OP's data</source>
          <target state="translated">&lt;code&gt;tidyr&lt;/code&gt; &lt;code&gt;&amp;lsquo;0.8.3.9000&amp;rsquo;&lt;/code&gt; 의 devel 버전에는 &lt;code&gt;pivot_wider&lt;/code&gt; 및 &lt;code&gt;pivot_longer&lt;/code&gt; 가 있으며 1에서 여러 열로 재구성 (각각 long- &amp;gt; wide, wide- &amp;gt; long)을 수행하도록 일반화됩니다. OP의 데이터 사용</target>
        </trans-unit>
        <trans-unit id="2a1d1e5bd82d0fd7df26169b22ad20aff853baeb" translate="yes" xml:space="preserve">
          <source>You can do this with the &lt;code&gt;reshape()&lt;/code&gt; function, or with the &lt;code&gt;melt()&lt;/code&gt; / &lt;code&gt;cast()&lt;/code&gt; functions in the reshape package. For the second option, example code is</source>
          <target state="translated">&lt;code&gt;reshape()&lt;/code&gt; 함수 또는 reshape 패키지의 &lt;code&gt;melt()&lt;/code&gt; / &lt;code&gt;cast()&lt;/code&gt; 함수를 사용하여이 작업을 수행 할 수 있습니다. 두 번째 옵션의 경우 예제 코드는</target>
        </trans-unit>
        <trans-unit id="446e1da4bffc55b3260320c1b4dbeec48a8a7ccc" translate="yes" xml:space="preserve">
          <source>if you want to go back from wide to long, only change Wide to Long, and no changes in objects.</source>
          <target state="translated">넓게에서 길게 돌아가려면 객체에서 변경하지 않고 넓게 만 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5f5de958335b3f6a5d3ec3e7658e6a483d9d104f" translate="yes" xml:space="preserve">
          <source>much easier way!</source>
          <target state="translated">훨씬 쉬운 방법!</target>
        </trans-unit>
        <trans-unit id="8c29c224a25b16cff35e5ec4cbce49639805ad8c" translate="yes" xml:space="preserve">
          <source>the optional &lt;code&gt;sep&lt;/code&gt; argument is the separator used in between &lt;code&gt;timevar&lt;/code&gt; class names and &lt;code&gt;v.names&lt;/code&gt; in the output &lt;code&gt;data.frame&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;sep&lt;/code&gt; 인수는 &lt;code&gt;timevar&lt;/code&gt; 클래스 이름과 출력 &lt;code&gt;v.names&lt;/code&gt; 사이에 사용되는 구분 기호입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
