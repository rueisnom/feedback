<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/588004">
    <body>
      <group id="588004">
        <trans-unit id="9a77327f76e62f6925f45c2be16539ae6c9d0041" translate="yes" xml:space="preserve">
          <source>(Skip to the bottom for the TL;DR version)</source>
          <target state="translated">(Salta al final para la versión TL;DR)</target>
        </trans-unit>
        <trans-unit id="84f229d061d11f481f1f19df8986961ca0da2d64" translate="yes" xml:space="preserve">
          <source>(The difference between those two numbers is the &quot;smallest slice&quot; that we must decide to either include, which introduces an upward bias, or exclude, which introduces a downward bias. The technical term for that smallest slice is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_in_the_last_place&quot;&gt;ulp&lt;/a&gt;.)</source>
          <target state="translated">(La diferencia entre esos dos n&amp;uacute;meros es el &quot;segmento m&amp;aacute;s peque&amp;ntilde;o&quot; que debemos decidir incluir, que introduce un sesgo hacia arriba, o excluir, que introduce un sesgo hacia abajo. El t&amp;eacute;rmino t&amp;eacute;cnico para ese segmento m&amp;aacute;s peque&amp;ntilde;o es un &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_in_the_last_place&quot;&gt;ulp&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9b6d1bf18ecd6ade5e73ff28141534f5496bb1f2" translate="yes" xml:space="preserve">
          <source>** Of course, that's not exactly how floating-point numbers are stored in memory (they use a form of scientific notation). However, it does illustrate the point that binary floating-point precision errors tend to crop up because the &quot;real world&quot; numbers we are usually interested in working with are so often powers of ten - but only because we use a decimal number system day-to-day. This is also why we'll say things like 71% instead of &quot;5 out of every 7&quot; (71% is an approximation, since 5/7 can't be represented exactly with any decimal number).</source>
          <target state="translated">**Por supuesto,no es exactamente así como se almacenan en la memoria los números de punto flotante (utilizan una forma de notación científica).Sin embargo,sí ilustra el punto de que los errores de precisión binarios en coma flotante tienden a aparecer porque los números del &quot;mundo real&quot; con los que normalmente estamos interesados en trabajar son a menudo potencias de diez,pero sólo porque usamos un sistema de números decimales día a día.Es por esto también que diremos cosas como 71% en lugar de &quot;5 de cada 7&quot; (71% es una aproximación,ya que 57 no puede ser representado exactamente con ningún número decimal).</target>
        </trans-unit>
        <trans-unit id="46c3af8134de9a9765655ad80ac49c39423553fd" translate="yes" xml:space="preserve">
          <source>*15% and 34% are indeed huge, so always use BigDecimal when precision is of big importance. With 2 decimal digits (step 0.01) the situation worsens a bit more (18% and 36%).</source>
          <target state="translated">*15% y 34% son de hecho enormes,así que siempre usa BigDecimal cuando la precisión es de gran importancia.Con 2 dígitos decimales (paso 0,01)la situación empeora un poco más (18% y 36%).</target>
        </trans-unit>
        <trans-unit id="5b2e8d72a1ce0dbc9f2e00162aba5643d6cfbaec" translate="yes" xml:space="preserve">
          <source>... instead of:</source>
          <target state="translated">...en lugar de:</target>
        </trans-unit>
        <trans-unit id="8d173aa16ecb116af67a70b11ccf3319c4101b1a" translate="yes" xml:space="preserve">
          <source>0.1 converts to 0.1000000000000000055511151231257827021181583404541015625,</source>
          <target state="translated">0,1 se convierte en 0,1000000000000000055511151231257827021181583404541015625,</target>
        </trans-unit>
        <trans-unit id="fc11127f4be6e6f34950718f135c62cf3c856839" translate="yes" xml:space="preserve">
          <source>0.2 converts to 0.200000000000000011102230246251565404236316680908203125,</source>
          <target state="translated">0,2 se convierte en 0,200000000000000011102230246251565404236316680908203125,</target>
        </trans-unit>
        <trans-unit id="dd51d97fda6bb2ff93baf6b6621a7896bd5958f5" translate="yes" xml:space="preserve">
          <source>0.3 converts to 0.299999999999999988897769753748434595763683319091796875, and</source>
          <target state="translated">0,3 se convierte en 0,2999999999999988897769753748434595763683319091796875,y</target>
        </trans-unit>
        <trans-unit id="b16b3417bc17ee7e5d7eb955c6af5486031aa6cc" translate="yes" xml:space="preserve">
          <source>0.30000000000000004 converts to 0.3000000000000000444089209850062616169452667236328125.</source>
          <target state="translated">0,30000000000000004 se convierte en 0,3000000000000000444089209850062616169452667236328125.</target>
        </trans-unit>
        <trans-unit id="4a0ab3bf371766a011aeec8dab96140796667719" translate="yes" xml:space="preserve">
          <source>1. Overview</source>
          <target state="translated">1.Visión general</target>
        </trans-unit>
        <trans-unit id="280ddd4621ebc589f7f4d720fc9808f147099965" translate="yes" xml:space="preserve">
          <source>2. Standards</source>
          <target state="translated">2.normas</target>
        </trans-unit>
        <trans-unit id="f78082cab95c63bf0ca557926b7ee9c2fb55cdbf" translate="yes" xml:space="preserve">
          <source>3. Cause of Rounding Error in Division</source>
          <target state="translated">3.Causa del error de redondeo en la división</target>
        </trans-unit>
        <trans-unit id="2224e1de8ddee1360d6dbff9997ab8effced5fe5" translate="yes" xml:space="preserve">
          <source>4. Rounding Errors in Other Operations: Truncation</source>
          <target state="translated">4.4.Errores de redondeo en otras operaciones:Truncamiento</target>
        </trans-unit>
        <trans-unit id="983153e4c20b316f5664ccc0384312b6738b022a" translate="yes" xml:space="preserve">
          <source>5. Repeated Operations</source>
          <target state="translated">5.Operaciones repetidas</target>
        </trans-unit>
        <trans-unit id="8b9a12652ebaf55470a7b2d8569d105d465e8862" translate="yes" xml:space="preserve">
          <source>6. Summary</source>
          <target state="translated">6.Resumen</target>
        </trans-unit>
        <trans-unit id="7de70e9b0e9505394d0b85bbae95dc555ccf5cac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/62118/cato-johnston&quot;&gt;Cato Johnston&lt;/a&gt; (the question asker) asked why 0.1 + 0.2 != 0.3.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/62118/cato-johnston&quot;&gt;Cato Johnston&lt;/a&gt; (el que pregunta) pregunt&amp;oacute; por qu&amp;eacute; 0.1 + 0.2! = 0.3.</target>
        </trans-unit>
        <trans-unit id="2d2e7cb5a614c281b71ef36c79d5cb65b4ba2509" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.python.org/dev/peps/pep-0485/&quot;&gt;Since Python 3.5&lt;/a&gt; you can use &lt;code&gt;math.isclose()&lt;/code&gt; function for testing approximate equality:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0485/&quot;&gt;Desde Python 3.5&lt;/a&gt; puede usar la funci&amp;oacute;n &lt;code&gt;math.isclose()&lt;/code&gt; para probar la igualdad aproximada:</target>
        </trans-unit>
        <trans-unit id="401d8936879d8ca8394aee47a4c1ff1c1a185d3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt; in decimal, or</source>
          <target state="translated">&lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt; en decimal, o</target>
        </trans-unit>
        <trans-unit id="9ae555a82a2e499fc6d7d060a859ab15f217f180" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0.1&lt;/code&gt; in decimal, or</source>
          <target state="translated">&lt;code&gt;0.1&lt;/code&gt; en decimal, o</target>
        </trans-unit>
        <trans-unit id="938bfc27c36837e08b1fe976025499db2a6ca7de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0x1.99999999999999...p-4&lt;/code&gt; in an analogue of C99 hexfloat notation, where the &lt;code&gt;...&lt;/code&gt; represents an unending sequence of 9's.</source>
          <target state="translated">&lt;code&gt;0x1.99999999999999...p-4&lt;/code&gt; en un an&amp;aacute;logo de la notaci&amp;oacute;n de hex&amp;aacute;gono C99, donde &lt;code&gt;...&lt;/code&gt; representa una secuencia interminable de 9.</target>
        </trans-unit>
        <trans-unit id="89651913f83ecb14efed483cec782827a6bc114c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0x1.999999999999ap-4&lt;/code&gt; in &lt;a href=&quot;http://www.exploringbinary.com/hexadecimal-floating-point-constants/&quot;&gt;C99 hexfloat notation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;0x1.999999999999ap-4&lt;/code&gt; en &lt;a href=&quot;http://www.exploringbinary.com/hexadecimal-floating-point-constants/&quot;&gt;notaci&amp;oacute;n C99 hexfloat&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e817d9c8c705bf74fdcfcbf1e77b875d1d9ad5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Originally posted on Quora.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Publicado originalmente en Quora).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f786024ccd8f2f5e7d1892462aac5f45ffcefb9b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;1/10 = 0.0001100110011001100... (base 2)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;1/10 = 0.0001100110011001100 ... (base 2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="63b72feaf47b4ec3136591d2e2faba0c081c5044" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;1/3 = 0.333....&lt;/em&gt; and &lt;em&gt;2/3 = 0.666....&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;1/3 = 0.333 ....&lt;/em&gt; y &lt;em&gt;2/3 = 0.666 ....&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b00475b1e86d24dc6b485e60d7c73b28919a7639" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;1/5 = 0.0011001100110011001... (base 2)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;1/5 = 0.0011001100110011001 ... (base 2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16b45f9e57fbd951f4deea5d5a84d2d6a2e244b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;3/10 = 0.01001100110011... (base 2)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;3/10 = 0.01001100110011 ... (base 2)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8dcbfaacbdfbc6d2f50d8a56a068e40e1261d6e7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Dealing with it&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Lidiando con eso&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c628db72c8314407e7db73c5c8d371039653296" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;How did this happen?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iquest;C&amp;oacute;mo pas&amp;oacute; esto?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="114257217f3e4024fab9c8d736f74795530ded13" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In C++, why is the result of &lt;code&gt;cout &amp;lt;&amp;lt; x&lt;/code&gt; different from the value that a debugger is showing for &lt;code&gt;x&lt;/code&gt;?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;En C ++, &amp;iquest;por qu&amp;eacute; el resultado de &lt;code&gt;cout &amp;lt;&amp;lt; x&lt;/code&gt; diferente del valor que muestra un depurador para &lt;code&gt;x&lt;/code&gt; ?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb29457a5c4a57bd14902466b53747ea1841155b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Most answers here address this question in very dry, technical terms. I'd like to address this in terms that normal human beings can understand.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;La mayor&amp;iacute;a de las respuestas aqu&amp;iacute; abordan esta pregunta en t&amp;eacute;rminos t&amp;eacute;cnicos muy secos.&lt;/em&gt; &lt;em&gt;Me gustar&amp;iacute;a abordar esto en t&amp;eacute;rminos que los seres humanos normales puedan entender.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="812dea3da634f1bfe85f35d342dfc49090ae7e35" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;My answer is quite long, so I've split it into three sections. Since the question is about floating point mathematics, I've put the emphasis on what the machine actually does. I've also made it specific to double (64 bit) precision, but the argument applies equally to any floating point arithmetic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Mi respuesta es bastante larga, as&amp;iacute; que la he dividido en tres secciones.&lt;/em&gt; &lt;em&gt;Como la pregunta es acerca de las matem&amp;aacute;ticas de coma flotante, he puesto &amp;eacute;nfasis en lo que la m&amp;aacute;quina realmente hace.&lt;/em&gt; &lt;em&gt;Tambi&amp;eacute;n lo hice espec&amp;iacute;fico para la precisi&amp;oacute;n doble (64 bits), pero el argumento se aplica igualmente a cualquier aritm&amp;eacute;tica de coma flotante.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65bea6bb1ae17a4b9f7a3bd71f9fa6d20638dc20" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Summary&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Summary&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="410b8c8555b9687d089ded3e44b46bfe83e53270" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Thanks to @a_guest for pointing that out to me.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Gracias a @a_guest por se&amp;ntilde;alarme eso.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="419db0b8ed72e080cefb0589020b58af00048586" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a / (2&lt;sup&gt;n&lt;/sup&gt; x 5&lt;sup&gt;m&lt;/sup&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;a / (2 nx 5 &lt;sup&gt;m&lt;/sup&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03859a6a2231a6787e7d8d22083fb8ea3dd47552" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;a / 2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;a / 2 &lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8490feafcf8730008f92d1c10a76f3c806c53c2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;precision&lt;/em&gt; refers to the number of digits you want to preserve after the decimal point during addition.</source>
          <target state="translated">&lt;em&gt;La precisi&amp;oacute;n se&lt;/em&gt; refiere al n&amp;uacute;mero de d&amp;iacute;gitos que desea conservar despu&amp;eacute;s del punto decimal durante la suma.</target>
        </trans-unit>
        <trans-unit id="1e3ee7af3fba4d45fa593681a54a346b038b05dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.1 Division Rounding Error: Approximation of Reciprocal&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.1 Error de redondeo de divisi&amp;oacute;n: aproximaci&amp;oacute;n de rec&amp;iacute;proco&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e6bc1e3e005f88dbf93220a210a0fde73485d05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Hardware Designer's Perspective&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La perspectiva de un dise&amp;ntilde;ador de hardware&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a96efce74d6c9dba462233167c7749ee6864dd04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting to the point: the original question&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Llegando al punto: la pregunta original&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7791bf2ab0b52173b0ccf2e8bcaba860d7f299bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Math.sum&lt;/strong&gt; ( javascript )     .... kind of operator replacement</source>
          <target state="translated">&lt;strong&gt;Math.sum&lt;/strong&gt; (javascript) ... tipo de reemplazo del operador</target>
        </trans-unit>
        <trans-unit id="991cc4a1d9e4964b8a4f30616ab0b042a2270ceb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preamble&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Preamble&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c64deca575044ac6f1b7a2c724063d8e9be011c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Side Note: All positional (base-N) number systems share this problem with precision&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nota al margen: todos los sistemas de n&amp;uacute;meros posicionales (base-N) comparten este problema con precisi&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42c15268639d23d22e1869e6bd3d9e33364a9ea3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Side Side Note: Working with Floats in Programming&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nota lateral: Trabajar con flotadores en la programaci&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f7a6a4259ba35f3a392f787d9eda8541de9ad1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This happens because of the double-precision binary: IEEE 754 double-precision binary floating-point format: binary64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Esto sucede debido al binario de doble precisi&amp;oacute;n: formato de punto flotante binario de doble precisi&amp;oacute;n IEEE 754: binario64&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a74449c94d4167a6330ce9884c610a9f3e63e10a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Turning a double precision number to binary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Convertir un n&amp;uacute;mero de doble precisi&amp;oacute;n en binario&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42704c7e9e47a44a6be48d355b7d236b9cd0b77f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; - IEEE 754 allows for the concept of a &lt;a href=&quot;http://en.wikipedia.org/wiki/Signed_zero&quot;&gt;signed zero&lt;/a&gt; - &lt;code&gt;+0&lt;/code&gt; and &lt;code&gt;-0&lt;/code&gt; are treated differently: &lt;code&gt;1 / (+0)&lt;/code&gt; is positive infinity; &lt;code&gt;1 / (-0)&lt;/code&gt; is negative infinity. For zero values, the mantissa and exponent bits are all zero. Note: zero values (+0 and -0) are explicitly not classed as denormal&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; - IEEE 754 permite el concepto de un &lt;a href=&quot;http://en.wikipedia.org/wiki/Signed_zero&quot;&gt;cero con signo&lt;/a&gt; - &lt;code&gt;+0&lt;/code&gt; y &lt;code&gt;-0&lt;/code&gt; se tratan de manera diferente: &lt;code&gt;1 / (+0)&lt;/code&gt; es infinito positivo; &lt;code&gt;1 / (-0)&lt;/code&gt; es infinito negativo. Para valores cero, los bits de mantisa y exponente son todos cero. Nota: los valores cero (+0 y -0) no se clasifican expl&amp;iacute;citamente como &lt;sup&gt;2&lt;/sup&gt; normales.</target>
        </trans-unit>
        <trans-unit id="1a547f62556031e29e245098a0954c909bff3ea3" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; Douglas Crockford: &lt;a href=&quot;http://books.google.com/books?id=PXa2bby0oQ0C&amp;amp;pg=PA105&amp;amp;dq=douglas+crockford+javascript+good+parts+dollar+values+can+be+converted&amp;amp;rview=1&amp;amp;cd=1#v=onepage&amp;amp;q=&amp;amp;f=false&quot;&gt;&lt;strong&gt;JavaScript: The Good Parts&lt;/strong&gt;: Appendix A - Awful Parts (page 105)&lt;/a&gt;.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; Douglas Crockford: &lt;a href=&quot;http://books.google.com/books?id=PXa2bby0oQ0C&amp;amp;pg=PA105&amp;amp;dq=douglas+crockford+javascript+good+parts+dollar+values+can+be+converted&amp;amp;rview=1&amp;amp;cd=1#v=onepage&amp;amp;q=&amp;amp;f=false&quot;&gt;&lt;strong&gt;JavaScript: The Good Parts&lt;/strong&gt; : Ap&amp;eacute;ndice A - Awful Parts (p&amp;aacute;gina 105)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee1c19795ff8f472035c1d76b8687b9760c48eb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; - This is not the case for &lt;a href=&quot;http://en.wikipedia.org/wiki/Denormal_number&quot;&gt;denormal numbers&lt;/a&gt;, which have an offset exponent of zero (and an implied &lt;code&gt;0.&lt;/code&gt;). The range of denormal double precision numbers is d&lt;sub&gt;min&lt;/sub&gt; &amp;le; |x| &amp;le; d&lt;sub&gt;max&lt;/sub&gt;, where d&lt;sub&gt;min&lt;/sub&gt; (the smallest representable nonzero number) is 2&lt;sup&gt;-1023 - 51&lt;/sup&gt; (&amp;asymp; 4.94 * 10&lt;sup&gt;-324&lt;/sup&gt;) and d&lt;sub&gt;max&lt;/sub&gt; (the largest denormal number, for which the mantissa consists entirely of &lt;code&gt;1&lt;/code&gt;s) is 2&lt;sup&gt;-1023 + 1&lt;/sup&gt; - 2&lt;sup&gt;-1023 - 51&lt;/sup&gt; (&amp;asymp; 2.225 * 10&lt;sup&gt;-308&lt;/sup&gt;).</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; - Este no es el caso de los &lt;a href=&quot;http://en.wikipedia.org/wiki/Denormal_number&quot;&gt;n&amp;uacute;meros denormales&lt;/a&gt; , que tienen un exponente de compensaci&amp;oacute;n de cero (y un &lt;code&gt;0.&lt;/code&gt; impl&amp;iacute;cito). El rango de n&amp;uacute;meros de precisi&amp;oacute;n doble denormal es d &lt;sub&gt;min&lt;/sub&gt; &amp;le; | x | &amp;le; d &lt;sub&gt;max&lt;/sub&gt; , donde d &lt;sub&gt;min&lt;/sub&gt; (el n&amp;uacute;mero distinto de cero representable m&amp;aacute;s peque&amp;ntilde;o) es 2 &lt;sup&gt;-1023-51&lt;/sup&gt; (&amp;asymp; 4.94 * 10 &lt;sup&gt;-324&lt;/sup&gt; ) y d &lt;sub&gt;max&lt;/sub&gt; (el n&amp;uacute;mero denormal m&amp;aacute;s grande, para el cual la mantisa consiste completamente de &lt;code&gt;1&lt;/code&gt; s) es 2 &lt;sup&gt;- 1023 +&lt;/sup&gt; 1-2-1023-51 (&amp;asymp; 2.225 * &lt;sup&gt;10-308&lt;/sup&gt; ).</target>
        </trans-unit>
        <trans-unit id="e4b88838f3d945e3111f2ac846b7fe40186f08dc" translate="yes" xml:space="preserve">
          <source>A different question has been named as a duplicate to this one:</source>
          <target state="translated">Se ha nombrado una pregunta diferente como un duplicado de esta:</target>
        </trans-unit>
        <trans-unit id="67d09660cb9d94f97c922d190c9da304946bbc56" translate="yes" xml:space="preserve">
          <source>A fairly comprehensive treatment of floating-point arithmetic issues is &lt;a href=&quot;http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;&lt;em&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/em&gt;&lt;/a&gt;. For an easier-to-digest explanation, see &lt;a href=&quot;http://floating-point-gui.de&quot;&gt;floating-point-gui.de&lt;/a&gt;.</source>
          <target state="translated">Un tratamiento bastante completo de los problemas de aritm&amp;eacute;tica de coma flotante es &lt;a href=&quot;http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;&lt;em&gt;lo que todo inform&amp;aacute;tico debe saber sobre la aritm&amp;eacute;tica de coma flotante&lt;/em&gt;&lt;/a&gt; . Para una explicaci&amp;oacute;n m&amp;aacute;s f&amp;aacute;cil de digerir, vea &lt;a href=&quot;http://floating-point-gui.de&quot;&gt;floating-point-gui.de&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="292327f21cc858d8c2a42811ceaf2d0a17de5a22" translate="yes" xml:space="preserve">
          <source>A lot of good answers have been posted, but I'd like to append one more.</source>
          <target state="translated">Se han publicado muchas respuestas buenas,pero me gustaría añadir una más.</target>
        </trans-unit>
        <trans-unit id="87561d6f9557f1f5e17ba3afef835a06d4a73163" translate="yes" xml:space="preserve">
          <source>Adding the first two numbers manually or in a decimal calculator such as &lt;a href=&quot;https://www.mathsisfun.com/calculator-precision.html&quot;&gt;Full Precision Calculator&lt;/a&gt;, shows the exact sum of the actual inputs is 0.3000000000000000166533453693773481063544750213623046875.</source>
          <target state="translated">Agregar los primeros dos n&amp;uacute;meros manualmente o en una calculadora decimal, como la &lt;a href=&quot;https://www.mathsisfun.com/calculator-precision.html&quot;&gt;Calculadora de precisi&amp;oacute;n completa&lt;/a&gt; , muestra que la suma exacta de las entradas reales es 0.3000000000000000166533453693773481063544750213623046875.</target>
        </trans-unit>
        <trans-unit id="0a7ff54c3760c59eab90eb97d484608c8d05aaa7" translate="yes" xml:space="preserve">
          <source>After the code I attach a console session, in which I compute the sum of terms for both constants (minus PI and 999999999) that really exists in hardware, inserted there by the compiler.</source>
          <target state="translated">Después del código adjunto una sesión de consola,en la que calculo la suma de términos para ambas constantes (menos PI y 999999999)que realmente existe en el hardware,insertada allí por el compilador.</target>
        </trans-unit>
        <trans-unit id="d6dc17a99e9f681bdfd19158552338365662636c" translate="yes" xml:space="preserve">
          <source>Also note that we can decrease the power in the exponent by 52 and shift the point in the binary representation to the right by 52 places (much like 10&lt;sup&gt;-3&lt;/sup&gt; * 1.23 == 10&lt;sup&gt;-5&lt;/sup&gt; * 123). This then enables us to represent the binary representation as the exact value that it represents in the form a * 2&lt;sup&gt;p&lt;/sup&gt;. where 'a' is an integer.</source>
          <target state="translated">Tambi&amp;eacute;n tenga en cuenta que podemos disminuir la potencia en el exponente en 52 y desplazar el punto en la representaci&amp;oacute;n binaria a la derecha en 52 lugares (al igual que &lt;sup&gt;10-3&lt;/sup&gt; * 1.23 == &lt;sup&gt;10-5&lt;/sup&gt; * 123). Esto nos permite representar la representaci&amp;oacute;n binaria como el valor exacto que representa en la forma a * 2 &lt;sup&gt;p&lt;/sup&gt; . donde 'a' es un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="25c2f42952dddc1442cd3fea4ee45931c75bd99d" translate="yes" xml:space="preserve">
          <source>Also, on real number-crunching problems (the problems that FP was invented for on early, frightfully expensive computers) the physical constants of the universe and all other measurements are only known to a relatively small number of significant figures, so the entire problem space was &quot;inexact&quot; anyway. FP &quot;accuracy&quot; isn't a problem in this kind of application.</source>
          <target state="translated">Además,en los problemas reales de cálculo de números (los problemas para los que se inventó la FP en las primeras y espantosamente caras computadoras)las constantes físicas del universo y todas las demás mediciones sólo son conocidas por un número relativamente pequeño de cifras significativas,por lo que todo el espacio del problema era &quot;inexacto&quot; de todos modos.La &quot;exactitud&quot; de la FP no es un problema en este tipo de aplicaciones.</target>
        </trans-unit>
        <trans-unit id="85160f78ccb1d3807347386aa0d2ca7539bc234b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;IEEE 754 double-precision binary floating-point format (binary64)&lt;/a&gt; number represents a number of the form</source>
          <target state="translated">Un n&amp;uacute;mero de &lt;a href=&quot;http://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;formato de punto flotante binario de doble precisi&amp;oacute;n IEEE 754 (binary64)&lt;/a&gt; representa un n&amp;uacute;mero de la forma</target>
        </trans-unit>
        <trans-unit id="717a2779595b0983db47fc60af6d89e183d0f462" translate="yes" xml:space="preserve">
          <source>Another cause of the rounding errors in all operations are the different modes of truncation of the final answer that IEEE-754 allows. There's truncate, round-towards-zero, &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Rounding_modes&quot;&gt;round-to-nearest (default),&lt;/a&gt; round-down, and round-up. All methods introduce an element of error of less than one unit in the last place for a single operation. Over time and repeated operations, truncation also adds cumulatively to the resultant error. This truncation error is especially problematic in exponentiation, which involves some form of repeated multiplication.</source>
          <target state="translated">Otra causa de los errores de redondeo en todas las operaciones son los diferentes modos de truncamiento de la respuesta final que permite IEEE-754. Hay truncar, redondear hacia cero, &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Rounding_modes&quot;&gt;redondear al m&amp;aacute;s cercano (predeterminado),&lt;/a&gt; redondear hacia abajo y redondear hacia arriba. Todos los m&amp;eacute;todos introducen un elemento de error de menos de una unidad en el &amp;uacute;ltimo lugar para una sola operaci&amp;oacute;n. Con el tiempo y las operaciones repetidas, el truncamiento tambi&amp;eacute;n se suma acumulativamente al error resultante. Este error de truncamiento es especialmente problem&amp;aacute;tico en la exponenciaci&amp;oacute;n, que implica alguna forma de multiplicaci&amp;oacute;n repetida.</target>
        </trans-unit>
        <trans-unit id="9ead24f56ead1006e9506dd4e4f2be6e9b288737" translate="yes" xml:space="preserve">
          <source>Another way to look at this: Used are 64 bits to represent numbers. As consequence there is no way more than 2**64 = 18,446,744,073,709,551,616 different numbers can be precisely represented.</source>
          <target state="translated">Otra forma de ver esto:Se usan 64 bits para representar los números.Como consecuencia,no hay manera de que más de 2**64=18.446.744.073.709.551.616 números diferentes puedan ser representados con precisión.</target>
        </trans-unit>
        <trans-unit id="197629060526b0bc6ba54e0d54e8621c108bd09e" translate="yes" xml:space="preserve">
          <source>Applying it to the numbers in the question, treated as doubles:</source>
          <target state="translated">Aplicándolo a los números de la pregunta,tratados como dobles:</target>
        </trans-unit>
        <trans-unit id="acd3695ef743a5217426fec2538dd807e2248e19" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;https://www.w3schools.com/js/js_numbers.asp&quot;&gt;W3SCHOOLS&lt;/a&gt; suggests there is another solution too, you can multiply and divide to solve the problem above:</source>
          <target state="translated">Como &lt;a href=&quot;https://www.w3schools.com/js/js_numbers.asp&quot;&gt;W3SCHOOLS&lt;/a&gt; sugiere que tambi&amp;eacute;n hay otra soluci&amp;oacute;n, puede multiplicar y dividir para resolver el problema anterior:</target>
        </trans-unit>
        <trans-unit id="5c873182ceb9b32f52a27c7ab3af44165c7183f5" translate="yes" xml:space="preserve">
          <source>As a practical example, to avoid floating-point problems where accuracy is paramount, it is recommended&lt;sup&gt;1&lt;/sup&gt; to handle money as an integer representing the number of cents: &lt;code&gt;2550&lt;/code&gt; cents instead of &lt;code&gt;25.50&lt;/code&gt; dollars.</source>
          <target state="translated">Como ejemplo pr&amp;aacute;ctico, para evitar problemas de punto flotante donde la precisi&amp;oacute;n es primordial, se recomienda &lt;sup&gt;1&lt;/sup&gt; manejar el dinero como un n&amp;uacute;mero entero que representa el n&amp;uacute;mero de centavos: &lt;code&gt;2550&lt;/code&gt; centavos en lugar de &lt;code&gt;25.50&lt;/code&gt; d&amp;oacute;lares.</target>
        </trans-unit>
        <trans-unit id="14b3dd03f473733c807181d4f25005fdb4b3c92f" translate="yes" xml:space="preserve">
          <source>Binary &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;floating point&lt;/a&gt; math is like this. In most programming languages, it is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754#Basic_formats&quot;&gt;IEEE 754 standard&lt;/a&gt;. The crux of the problem is that numbers are represented in this format as a whole number times a power of two; rational numbers (such as &lt;code&gt;0.1&lt;/code&gt;, which is &lt;code&gt;1/10&lt;/code&gt;) whose denominator is not a power of two cannot be exactly represented.</source>
          <target state="translated">La matem&amp;aacute;tica de &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;punto flotante&lt;/a&gt; binario es as&amp;iacute;. En la mayor&amp;iacute;a de los lenguajes de programaci&amp;oacute;n, se basa en el &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754#Basic_formats&quot;&gt;est&amp;aacute;ndar IEEE 754&lt;/a&gt; . El quid del problema es que los n&amp;uacute;meros se representan en este formato como un n&amp;uacute;mero entero multiplicado por una potencia de dos; los n&amp;uacute;meros racionales (como &lt;code&gt;0.1&lt;/code&gt; , que es &lt;code&gt;1/10&lt;/code&gt; ) cuyo denominador no es una potencia de dos no pueden representarse exactamente.</target>
        </trans-unit>
        <trans-unit id="7422ac70577b1628784c436e3c108b8f745d86f7" translate="yes" xml:space="preserve">
          <source>But if you're okay with the idea that sometimes floating-point math is fuzzy in value and logic and errors can accumulate quickly, and you can write your requirements and tests to allow for that, then your code can frequently get by with what's in your FPU.</source>
          <target state="translated">Pero si te parece bien la idea de que a veces las matemáticas de punto flotante son confusas en cuanto a su valor y lógica y los errores pueden acumularse rápidamente,y puedes escribir tus requisitos y pruebas para tenerlo en cuenta,entonces tu código puede arreglárselas con frecuencia con lo que hay en tu FPU.</target>
        </trans-unit>
        <trans-unit id="55a69cb7e5983987538ca8b12860d952d6b39dfb" translate="yes" xml:space="preserve">
          <source>Can I just add; people always assume this to be a computer problem, but if you count with your hands (base 10), you can't get &lt;code&gt;(1/3+1/3=2/3)=true&lt;/code&gt; unless you have infinity to add 0.333... to 0.333... so just as with the &lt;code&gt;(1/10+2/10)!==3/10&lt;/code&gt; problem in base 2, you truncate it to 0.333 + 0.333 = 0.666 and probably round it to 0.667 which would be also be technically inaccurate.</source>
          <target state="translated">&amp;iquest;Puedo agregar? la gente siempre asume que se trata de un problema inform&amp;aacute;tico, pero si cuenta con las manos (base 10), no puede obtener &lt;code&gt;(1/3+1/3=2/3)=true&lt;/code&gt; menos que tenga infinito para agregar 0.333. .. a 0.333 ... as&amp;iacute; que al igual que con el problema &lt;code&gt;(1/10+2/10)!==3/10&lt;/code&gt; en la base 2, lo trunca a 0.333 + 0.333 = 0.666 y probablemente lo redondea a 0.667 que ser&amp;iacute;a Tambi&amp;eacute;n sea t&amp;eacute;cnicamente inexacto.</target>
        </trans-unit>
        <trans-unit id="82a3e020f14e0b35ca683a0e8ec46b87242aae47" translate="yes" xml:space="preserve">
          <source>Comparing the last few bits of a floating point number is inherently dangerous, as anyone who reads the famous &quot;&lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;&quot; (which covers all the major parts of this answer) will know.</source>
          <target state="translated">Comparar los &amp;uacute;ltimos bits de un n&amp;uacute;mero de coma flotante es inherentemente peligroso, como lo &lt;a href=&quot;http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;sabr&amp;aacute;&lt;/a&gt; cualquiera que lea el famoso &quot; Lo que todo inform&amp;aacute;tico debe saber sobre la aritm&amp;eacute;tica de coma flotante &quot; (que cubre todas las partes principales de esta respuesta).</target>
        </trans-unit>
        <trans-unit id="7b9418257eb36cecc68969da2f0e00be78afe4f0" translate="yes" xml:space="preserve">
          <source>Computers don't usually work in base 10, they work in base 2. You can still get exact results for some values, for example &lt;code&gt;0.5&lt;/code&gt; is &lt;code&gt;1 x 2⁻&amp;sup1;&lt;/code&gt; and &lt;code&gt;0.25&lt;/code&gt; is &lt;code&gt;1 x 2⁻&amp;sup2;&lt;/code&gt;, and adding them results in &lt;code&gt;3 x 2⁻&amp;sup2;&lt;/code&gt;, or &lt;code&gt;0.75&lt;/code&gt;. Exactly.</source>
          <target state="translated">Las computadoras generalmente no funcionan en la base 10, funcionan en la base 2. Todav&amp;iacute;a puede obtener resultados exactos para algunos valores, por ejemplo &lt;code&gt;0.5&lt;/code&gt; es &lt;code&gt;1 x 2⁻&amp;sup1;&lt;/code&gt; y &lt;code&gt;0.25&lt;/code&gt; es &lt;code&gt;1 x 2⁻&amp;sup2;&lt;/code&gt; , y sumarlos resulta en &lt;code&gt;3 x 2⁻&amp;sup2;&lt;/code&gt; , o &lt;code&gt;0.75&lt;/code&gt; . Exactamente.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="4adddd0410090df891e6fa4925fe03ba5adb5c9d" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
          <target state="translated">Considere el siguiente código:</target>
        </trans-unit>
        <trans-unit id="e7f1f3b25b7e705aa363815a9723229ad35c0cc4" translate="yes" xml:space="preserve">
          <source>Consider the following results:</source>
          <target state="translated">Considere los siguientes resultados:</target>
        </trans-unit>
        <trans-unit id="12b7b76dc8d2ea9eb4ff8748b10d88e4a85a6169" translate="yes" xml:space="preserve">
          <source>Converted back to decimal, these values are:</source>
          <target state="translated">Convertidos de nuevo a decimales,estos valores son:</target>
        </trans-unit>
        <trans-unit id="aeb57143b3ba83c7c3b04839d7f666efe4124f05" translate="yes" xml:space="preserve">
          <source>Converting the exponents to decimal, removing the offset, and re-adding the implied &lt;code&gt;1&lt;/code&gt; (in square brackets), 0.1 and 0.2 are:</source>
          <target state="translated">Convertir los exponentes a decimal, eliminar el desplazamiento y volver a agregar el &lt;code&gt;1&lt;/code&gt; impl&amp;iacute;cito (entre corchetes), 0.1 y 0.2 son:</target>
        </trans-unit>
        <trans-unit id="78e4c9a6d77baf375b421e266552930eb4f9337f" translate="yes" xml:space="preserve">
          <source>Count in ternary, and thirds are not a problem though - maybe some race with 15 fingers on each hand would ask why your decimal math was broken...</source>
          <target state="translated">Contar en ternario,y los tercios no son un problema sin embargo-tal vez alguna raza con 15 dedos en cada mano preguntaría por qué su matemática decimal se rompió...</target>
        </trans-unit>
        <trans-unit id="a3dd9179dce397e9e1b5fccb9b0cd27f6c3bd5cf" translate="yes" xml:space="preserve">
          <source>Damn! What are you going to do with those unwanted zeros after 9?
It's the time to convert it to float to make it as you desire:</source>
          <target state="translated">¡Maldita sea! ¿Qué vas a hacer con esos ceros no deseados después del 9? Es el momento de convertirlo en flotante para que sea como tú deseas:</target>
        </trans-unit>
        <trans-unit id="9e27f7f948ef21b303c1370a1dec7590701f7df7" translate="yes" xml:space="preserve">
          <source>Decimal numbers such as &lt;code&gt;0.1&lt;/code&gt;, &lt;code&gt;0.2&lt;/code&gt;, and &lt;code&gt;0.3&lt;/code&gt; are not represented exactly in binary encoded floating point types. The sum of the approximations for &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;0.2&lt;/code&gt; differs from the approximation used for &lt;code&gt;0.3&lt;/code&gt;, hence the falsehood of &lt;code&gt;0.1 + 0.2 == 0.3&lt;/code&gt; as can be seen more clearly here:</source>
          <target state="translated">Los n&amp;uacute;meros decimales como &lt;code&gt;0.1&lt;/code&gt; , &lt;code&gt;0.2&lt;/code&gt; y &lt;code&gt;0.3&lt;/code&gt; no se representan exactamente en tipos de coma flotante codificados en binario. La suma de las aproximaciones para &lt;code&gt;0.1&lt;/code&gt; y &lt;code&gt;0.2&lt;/code&gt; difiere de la aproximaci&amp;oacute;n utilizada para &lt;code&gt;0.3&lt;/code&gt; , de ah&amp;iacute; la falsedad de &lt;code&gt;0.1 + 0.2 == 0.3&lt;/code&gt; como se puede ver m&amp;aacute;s claramente aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="6b03123e729e0d99d8829d657b6396043e2860f2" translate="yes" xml:space="preserve">
          <source>Decimals are very nice when dealing with money: ten cents plus twenty cents are always exactly thirty cents:</source>
          <target state="translated">Los decimales son muy agradables cuando se trata de dinero:diez centavos más veinte centavos son siempre exactamente treinta centavos:</target>
        </trans-unit>
        <trans-unit id="343253c3ffda2f7f610024078888336d7bfcc2d8" translate="yes" xml:space="preserve">
          <source>Developers are usually instructed to do &lt;em&gt;&amp;lt; epsilon&lt;/em&gt; comparisons, better advice might be to round to integral values (in the C library: round() and roundf(), i.e., stay in the FP format) and then compare. Rounding to a specific decimal fraction length solves most problems with output.</source>
          <target state="translated">Los desarrolladores generalmente reciben instrucciones de hacer &lt;em&gt;&amp;lt;&lt;/em&gt; comparaciones &lt;em&gt;epsilon&lt;/em&gt; , un mejor consejo podr&amp;iacute;a ser redondear a valores integrales (en la biblioteca C: round () y roundf (), es decir, permanecer en el formato FP) y luego comparar. El redondeo a una longitud de fracci&amp;oacute;n decimal espec&amp;iacute;fica resuelve la mayor&amp;iacute;a de los problemas con la salida.</target>
        </trans-unit>
        <trans-unit id="dafd8ed5e4bb8b26b1f077f8e5b7a321cbc63112" translate="yes" xml:space="preserve">
          <source>Did you try the duct tape solution?</source>
          <target state="translated">¿Probaste la solución de cinta adhesiva?</target>
        </trans-unit>
        <trans-unit id="a8c0d91bbd12171df34d46bb5ca5e22a008105f7" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; do &lt;code&gt;if (x == y) { ... }&lt;/code&gt;</source>
          <target state="translated">No hacer &lt;code&gt;if (x == y) { ... }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49af704836c31c31268ad85bee269007d1863899" translate="yes" xml:space="preserve">
          <source>Double-precision binary floating-point is a commonly used format on PCs, due to its wider range over single-precision floating point, in spite of its performance and bandwidth cost. As with single-precision floating-point format, it lacks precision on integer numbers when compared with an integer format of the same size. It is commonly known simply as double. The IEEE 754 standard specifies a binary64 as having:</source>
          <target state="translated">El punto flotante binario de doble precisión es un formato comúnmente utilizado en las computadoras,debido a su mayor alcance sobre el punto flotante de precisión simple,a pesar de su rendimiento y costo de ancho de banda.Al igual que el formato de punto flotante de precisión simple,carece de precisión en los números enteros cuando se compara con un formato de números enteros del mismo tamaño.Se conoce comúnmente simplemente como doble.El estándar IEEE 754 especifica que un binario64 tiene:</target>
        </trans-unit>
        <trans-unit id="e94dc886af9a6005f7b61c7e670cccaf284c7871" translate="yes" xml:space="preserve">
          <source>Even simple numbers like 0.01, 0.02, 0.03, 0.04 ... 0.24 are not representable exactly as binary fractions. If you count up 0.01, .02, .03 ..., not until you get to 0.25 will you get the first fraction representable in base&lt;sub&gt;2&lt;/sub&gt;.  If you tried that using FP, your 0.01 would have been slightly off, so the only way to add 25 of them up to a nice exact 0.25 would have required a long chain of causality involving guard bits and rounding. It's hard to predict so we throw up our hands and say &lt;em&gt;&quot;FP is inexact&quot;,&lt;/em&gt; but that's not really true.</source>
          <target state="translated">Incluso los n&amp;uacute;meros simples como 0.01, 0.02, 0.03, 0.04 ... 0.24 no son representables exactamente como fracciones binarias. Si cuenta hasta 0.01, .02, .03 ..., hasta que llegue a 0.25 no obtendr&amp;aacute; la primera fracci&amp;oacute;n representable en la base &lt;sub&gt;2&lt;/sub&gt; . Si lo intentaste usando FP, tu 0.01 habr&amp;iacute;a estado ligeramente apagado, por lo que la &amp;uacute;nica forma de sumar 25 de ellos a un buen 0.25 exacto habr&amp;iacute;a requerido una larga cadena de causalidad que involucra bits de guarda y redondeo. Es dif&amp;iacute;cil de predecir, as&amp;iacute; que levantamos las manos y decimos &lt;em&gt;&quot;FP no es exacto&quot;,&lt;/em&gt; pero eso no es realmente cierto.</target>
        </trans-unit>
        <trans-unit id="bcc82060c0b5843a747559c24154d4b0cbe17504" translate="yes" xml:space="preserve">
          <source>Even though you can type &lt;code&gt;0.2&lt;/code&gt; easily, &lt;code&gt;FLT_RADIX&lt;/code&gt; and &lt;code&gt;DBL_RADIX&lt;/code&gt; is 2; not 10 for a computer with FPU which uses &quot;IEEE Standard for Binary Floating-Point Arithmetic (ISO/IEEE Std 754-1985)&quot;.</source>
          <target state="translated">Aunque puede escribir &lt;code&gt;0.2&lt;/code&gt; f&amp;aacute;cilmente, &lt;code&gt;FLT_RADIX&lt;/code&gt; y &lt;code&gt;DBL_RADIX&lt;/code&gt; es 2; no 10 para una computadora con FPU que utiliza el &quot;Est&amp;aacute;ndar IEEE para aritm&amp;eacute;tica de punto flotante binario (ISO / IEEE Std 754-1985)&quot;.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="f90ebb584a41f5789fdcea6141d54540d284f0c6" translate="yes" xml:space="preserve">
          <source>Exponent: 11 bits</source>
          <target state="translated">Exponente:11 bits</target>
        </trans-unit>
        <trans-unit id="119f8de999f99beecfdb18c6f4554359a130b523" translate="yes" xml:space="preserve">
          <source>Floating point arithmetic &lt;em&gt;is&lt;/em&gt; exact, unfortunately, it doesn't match up well with our usual base-10 number representation, so it turns out we are often giving it input that is slightly off from what we wrote.</source>
          <target state="translated">La aritm&amp;eacute;tica de punto flotante &lt;em&gt;es&lt;/em&gt; exacta, desafortunadamente, no coincide bien con nuestra representaci&amp;oacute;n habitual de n&amp;uacute;meros de base 10, por lo que resulta que a menudo le damos una entrada que est&amp;aacute; ligeramente fuera de lo que escribimos.</target>
        </trans-unit>
        <trans-unit id="565fecd9d4386f3183fb30121458f3c6a47002c6" translate="yes" xml:space="preserve">
          <source>Floating point numbers stored in the computer consist of two parts, an integer and an exponent that the base is taken to and multiplied by the integer part.</source>
          <target state="translated">Los números de punto flotante almacenados en la computadora consisten en dos partes,un entero y un exponente al que se lleva la base y se multiplica por la parte entera.</target>
        </trans-unit>
        <trans-unit id="124150fb130cdf0860699c9a2d7daf578bd58ed1" translate="yes" xml:space="preserve">
          <source>Floating point rounding error.  From &lt;a href=&quot;https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;:</source>
          <target state="translated">Error de redondeo de punto flotante. De &lt;a href=&quot;https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html&quot;&gt;lo que todo inform&amp;aacute;tico debe saber sobre la aritm&amp;eacute;tica de coma flotante&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="027c694de6b12a19a2844cf999e923212e996491" translate="yes" xml:space="preserve">
          <source>Floating point rounding errors. 0.1 cannot be represented as accurately in base-2 as in base-10 due to the missing prime factor of 5. Just as 1/3 takes an infinite number of digits to represent in decimal, but is &quot;0.1&quot; in base-3, 0.1 takes an infinite number of digits in base-2 where it does not in base-10. And computers don't have an infinite amount of memory.</source>
          <target state="translated">Errores de redondeo de punto flotante.0,1 no puede representarse con tanta precisión en la base-2 como en la base-10 debido a la falta del factor primario de 5.Así como 13 toma un número infinito de dígitos para representar en decimal,pero es &quot;0,1&quot; en base-3,0,1 toma un número infinito de dígitos en base-2 donde no lo hace en base-10.Y las computadoras no tienen una cantidad infinita de memoria.</target>
        </trans-unit>
        <trans-unit id="4448487d8eb4f64196dcf615ef11a481b88faaf8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;0.1&lt;/code&gt; in the standard &lt;code&gt;binary64&lt;/code&gt; format, the representation can be written exactly as</source>
          <target state="translated">Para &lt;code&gt;0.1&lt;/code&gt; en el formato est&amp;aacute;ndar &lt;code&gt;binary64&lt;/code&gt; , la representaci&amp;oacute;n se puede escribir exactamente como</target>
        </trans-unit>
        <trans-unit id="2eb8375a66f402510365e9906afeaf34cf9ace9f" translate="yes" xml:space="preserve">
          <source>For double-precision numbers (which is the precision that allows you to halve your pizza 53 times), the numbers immediately less and greater than 0.1 are 0.09999999999999999167332731531132594682276248931884765625 and 0.1000000000000000055511151231257827021181583404541015625. The latter is quite a bit closer to 0.1 than the former, so a numeric parser will, given an input of 0.1, favour the latter.</source>
          <target state="translated">En el caso de los números de doble precisión (que es la precisión que permite reducir la pizza a la mitad 53 veces),los números inmediatamente inferiores y superiores al 0,1 son 0,099999999999999167332731531132594682276248931884765625 y 0,1000000000000000055511151231257827021181583404541015625.El último está bastante más cerca de 0,1 que el primero,por lo que un analizador numérico,dada una entrada de 0,1,favorecerá al segundo.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8977c37ba4ab06faaeb4917f5aef431002e8e3a1" translate="yes" xml:space="preserve">
          <source>For these computations to be evaluated more reliably, you would need to use a decimal-based representation for floating point values. The C Standard does not specify such types by default but as an extension described in a &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1312.pdf&quot;&gt;technical Report&lt;/a&gt;.</source>
          <target state="translated">Para que estos c&amp;aacute;lculos se eval&amp;uacute;en de manera m&amp;aacute;s confiable, necesitar&amp;iacute;a usar una representaci&amp;oacute;n basada en decimales para los valores de coma flotante. El Est&amp;aacute;ndar C no especifica tales tipos por defecto, sino como una extensi&amp;oacute;n descrita en un &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1312.pdf&quot;&gt;Informe t&amp;eacute;cnico&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="438fbe9727771de7094dfe372c89a3c249901587" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://0.30000000000000004.com/&quot;&gt;https://0.30000000000000004.com/&lt;/a&gt;</source>
          <target state="translated">Desde &lt;a href=&quot;https://0.30000000000000004.com/&quot;&gt;https://0.30000000000000004.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2be387ecb7c744b80f6deca0a884e77b7dc5083" translate="yes" xml:space="preserve">
          <source>From an engineering perspective, most floating point operations will have some element of error since the hardware that does the floating point computations is only required to have an error of less than one half of one unit in the last place. Therefore, much hardware will stop at a precision that's only necessary to yield an error of less than one half of one unit in the last place for a &lt;em&gt;single operation&lt;/em&gt; which is especially problematic in floating point division. What constitutes a single operation depends upon how many operands the unit takes. For most, it is two, but some units take 3 or more operands. Because of this, there is no guarantee that repeated operations will result in a desirable error since the errors add up over time.</source>
          <target state="translated">Desde una perspectiva de ingenier&amp;iacute;a, la mayor&amp;iacute;a de las operaciones de punto flotante tendr&amp;aacute;n alg&amp;uacute;n elemento de error, ya que el hardware que realiza los c&amp;aacute;lculos de punto flotante solo debe tener un error de menos de la mitad de una unidad en el &amp;uacute;ltimo lugar. Por lo tanto, mucho hardware se detendr&amp;aacute; con una precisi&amp;oacute;n que solo es necesaria para generar un error de menos de la mitad de una unidad en el &amp;uacute;ltimo lugar para una &lt;em&gt;sola operaci&amp;oacute;n, lo&lt;/em&gt; cual es especialmente problem&amp;aacute;tico en la divisi&amp;oacute;n de coma flotante. Lo que constituye una sola operaci&amp;oacute;n depende de cu&amp;aacute;ntos operandos tome la unidad. Para la mayor&amp;iacute;a, son dos, pero algunas unidades toman 3 o m&amp;aacute;s operandos. Debido a esto, no hay garant&amp;iacute;a de que las operaciones repetidas den como resultado un error deseable ya que los errores se acumulan con el tiempo.</target>
        </trans-unit>
        <trans-unit id="71e6fce755adf54b2e2cee041a1ce78a23d295a2" translate="yes" xml:space="preserve">
          <source>From the Wikipedia page for &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Double-precision floating-point format&lt;/a&gt;:</source>
          <target state="translated">Desde la p&amp;aacute;gina de Wikipedia para el &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;formato de coma flotante de precisi&amp;oacute;n doble&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="13c8d9d9bb5ff174c47e9c103abdfb35251afc02" translate="yes" xml:space="preserve">
          <source>Given that nobody has mentioned this...</source>
          <target state="translated">Dado que nadie ha mencionado esto...</target>
        </trans-unit>
        <trans-unit id="b98e9326cacd57433010c27db8d9ac95dd07cf4d" translate="yes" xml:space="preserve">
          <source>Here is a console session in which I compute the real value of the float that exists in hardware.  I used &lt;code&gt;bc&lt;/code&gt; to print the sum of terms outputted by the main program.  One can insert that sum in python &lt;code&gt;repl&lt;/code&gt; or something similar also.</source>
          <target state="translated">Aqu&amp;iacute; hay una sesi&amp;oacute;n de consola en la que calculo el valor real del flotante que existe en el hardware. Utilic&amp;eacute; &lt;code&gt;bc&lt;/code&gt; para imprimir la suma de t&amp;eacute;rminos generados por el programa principal. Uno puede insertar esa suma en python &lt;code&gt;repl&lt;/code&gt; o algo similar tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="2408136ec0c44b738b07e0b8bf11d10f475c0d40" translate="yes" xml:space="preserve">
          <source>However, Math says there are already infinitely many decimals between 0 and 1. IEE 754 defines an encoding to use these 64 bits efficiently for a much larger number space plus NaN and +/- Infinity, so there are gaps between accurately represented numbers filled with numbers only approximated.</source>
          <target state="translated">Sin embargo,Matemáticas dice que ya hay infinitos decimales entre el 0 y el 1.El IEE 754 define una codificación para usar estos 64 bits de manera eficiente para un espacio numérico mucho mayor,más NaN y +-Infinito,por lo que hay huecos entre los números representados con precisión y rellenados con números sólo aproximados.</target>
        </trans-unit>
        <trans-unit id="46f05586e0302c09020d0bad2f9c90dcbc102d16" translate="yes" xml:space="preserve">
          <source>I believe I should add a hardware designer&amp;rsquo;s perspective to this since I design and build floating point hardware. Knowing the origin of the error may help in understanding what is happening in the software, and ultimately, I hope this helps explain the reasons for why floating point errors happen and seem to accumulate over time.</source>
          <target state="translated">Creo que deber&amp;iacute;a agregar la perspectiva de un dise&amp;ntilde;ador de hardware a esto ya que dise&amp;ntilde;o y construyo hardware de punto flotante. Conocer el origen del error puede ayudar a comprender lo que est&amp;aacute; sucediendo en el software y, en &amp;uacute;ltima instancia, espero que esto ayude a explicar las razones por las cuales los errores de coma flotante ocurren y parecen acumularse con el tiempo.</target>
        </trans-unit>
        <trans-unit id="139c3720a5570c1cec83ed7a353859c0807f05fc" translate="yes" xml:space="preserve">
          <source>I had the same problem in a scientific simulation project in c#, and I can tell you that if you ignore the butterfly effect it's gonna turn to a big fat dragon and bite you in the a**</source>
          <target state="translated">Tuve el mismo problema en un proyecto de simulación científica en c#,y puedo decirte que si ignoras el efecto mariposa se convertirá en un gran dragón gordo y te morderá en la a**.</target>
        </trans-unit>
        <trans-unit id="a07562d9120e098fcdb0a15f037dd208a8327be6" translate="yes" xml:space="preserve">
          <source>I just saw this interesting issue around floating points:</source>
          <target state="translated">Acabo de ver un asunto interesante sobre los puntos flotantes:</target>
        </trans-unit>
        <trans-unit id="c7cb01d8032bc4b8a88bb1e2f14b9cea42ff093e" translate="yes" xml:space="preserve">
          <source>I love the Pizza answer by &lt;a href=&quot;https://stackoverflow.com/users/13/chris-jester-young&quot;&gt;Chris&lt;/a&gt;, because it describes the actual problem, not just the usual handwaving about &quot;inaccuracy&quot;. If FP were simply &quot;inaccurate&quot;, we could &lt;em&gt;fix&lt;/em&gt; that and would have done it decades ago. The reason we haven't is because the FP format is compact and fast and it's the best way to crunch a lot of numbers. Also, it's a legacy from the space age and arms race and early attempts to solve big problems with very slow computers using small memory systems. (Sometimes, individual &lt;em&gt;magnetic cores&lt;/em&gt; for 1-bit storage, but that's &lt;a href=&quot;https://en.wikipedia.org/wiki/Magnetic-core_memory&quot;&gt;another story.&lt;/a&gt;)</source>
          <target state="translated">Me encanta la respuesta de &lt;a href=&quot;https://stackoverflow.com/users/13/chris-jester-young&quot;&gt;Chris de&lt;/a&gt; Pizza, porque describe el problema real, no solo el saludo habitual sobre la &quot;inexactitud&quot;. Si la PF fuera simplemente &quot;inexacta&quot;, podr&amp;iacute;amos &lt;em&gt;arreglar&lt;/em&gt; eso y lo habr&amp;iacute;amos hecho hace d&amp;eacute;cadas. La raz&amp;oacute;n por la que no lo hemos hecho es porque el formato FP es compacto y r&amp;aacute;pido, y es la mejor manera de calcular muchos n&amp;uacute;meros. Adem&amp;aacute;s, es un legado de la era espacial y la carrera armamentista y los primeros intentos de resolver grandes problemas con computadoras muy lentas que usan sistemas de memoria peque&amp;ntilde;os. (A veces, &lt;em&gt;n&amp;uacute;cleos magn&amp;eacute;ticos&lt;/em&gt; individuales para almacenamiento de 1 bit, pero esa es &lt;a href=&quot;https://en.wikipedia.org/wiki/Magnetic-core_memory&quot;&gt;otra historia&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="086419f7e4f00c4240acc2a8cf8724a0a0440d52" translate="yes" xml:space="preserve">
          <source>If it were rounded down to the equivalent of 0.3 the rounding error would be 0.0000000000000000277555756156289135105907917022705078125. Rounding up to the equivalent of 0.30000000000000004 also gives rounding error 0.0000000000000000277555756156289135105907917022705078125. The round-to-even tie breaker applies.</source>
          <target state="translated">Si se redondeara a la baja hasta el equivalente a 0,3,el error de redondeo sería 0,0000000000000000277555756156289135105907917022705078125.Si se redondea al equivalente de 0,300000000000000000004 también se obtiene un error de redondeo de 0,0000000000000000277555756156289135105907917022705078125.Se aplica el error de redondeo por exceso.</target>
        </trans-unit>
        <trans-unit id="fccfcfa3bf25426d4d6621dd068fd42d65e9ed23" translate="yes" xml:space="preserve">
          <source>If the computer were working in base 10, &lt;code&gt;0.1&lt;/code&gt; would be &lt;code&gt;1 x 10⁻&amp;sup1;&lt;/code&gt;, &lt;code&gt;0.2&lt;/code&gt; would be &lt;code&gt;2 x 10⁻&amp;sup1;&lt;/code&gt;, and &lt;code&gt;0.3&lt;/code&gt; would be &lt;code&gt;3 x 10⁻&amp;sup1;&lt;/code&gt;. Integer math is easy and exact, so adding &lt;code&gt;0.1 + 0.2&lt;/code&gt; will obviously result in &lt;code&gt;0.3&lt;/code&gt;.</source>
          <target state="translated">Si la computadora estuviera trabajando en la base 10, &lt;code&gt;0.1&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;1 x 10⁻&amp;sup1;&lt;/code&gt; , &lt;code&gt;0.2&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;2 x 10⁻&amp;sup1;&lt;/code&gt; y &lt;code&gt;0.3&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;3 x 10⁻&amp;sup1;&lt;/code&gt; . La matem&amp;aacute;tica entera es f&amp;aacute;cil y exacta, por lo que agregar &lt;code&gt;0.1 + 0.2&lt;/code&gt; obviamente resultar&amp;aacute; en &lt;code&gt;0.3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee2e12a76bfd81d38307a18631db4c3240b59b5c" translate="yes" xml:space="preserve">
          <source>If we truncated these to, say, seven bits, then we'd get</source>
          <target state="translated">Si truncamos esto a,digamos,siete bits,entonces obtendríamos</target>
        </trans-unit>
        <trans-unit id="57680ac773e9bbe3d4b63cff8433ef37f4eccd11" translate="yes" xml:space="preserve">
          <source>If you are just counting beans at a bank, software solutions that use decimal string representations in the first place work perfectly well. But you can't do quantum chromodynamics or aerodynamics that way.</source>
          <target state="translated">Si sólo estás contando frijoles en un banco,las soluciones de software que utilizan representaciones de cadenas decimales en primer lugar funcionan perfectamente.Pero no puedes hacer cromodinámica cuántica o aerodinámica de esa manera.</target>
        </trans-unit>
        <trans-unit id="5271cb4c5315d5f9a2c1b7d2e6439177b9ed5f51" translate="yes" xml:space="preserve">
          <source>If you need infinite precision (using the number &amp;pi;, for example, instead of one of its many shorter stand-ins), you should write or use a symbolic math program instead.</source>
          <target state="translated">Si necesita una precisi&amp;oacute;n infinita (usando el n&amp;uacute;mero &amp;pi;, por ejemplo, en lugar de uno de sus muchos sustitutos m&amp;aacute;s cortos), debe escribir o usar un programa matem&amp;aacute;tico simb&amp;oacute;lico en su lugar.</target>
        </trans-unit>
        <trans-unit id="aa080c09b62ae1dce37814f75cd51aab41b3d4c1" translate="yes" xml:space="preserve">
          <source>Imagine that you are trying to slice up pizzas. You have a robotic pizza cutter that can cut pizza slices &lt;em&gt;exactly&lt;/em&gt; in half. It can halve a whole pizza, or it can halve an existing slice, but in any case, the halving is always exact.</source>
          <target state="translated">Imagine que est&amp;aacute; tratando de cortar pizzas. Tiene un cortador de pizza rob&amp;oacute;tico que puede cortar rebanadas de pizza &lt;em&gt;exactamente&lt;/em&gt; por la mitad. Puede reducir a la mitad una pizza entera, o puede reducir a la mitad una rebanada existente, pero en cualquier caso, la reducci&amp;oacute;n a la mitad siempre es exacta.</target>
        </trans-unit>
        <trans-unit id="23fd14fd5cc6f36afaf62617f86f1c6323f8f5d0" translate="yes" xml:space="preserve">
          <source>Imagine working in base ten with, say, 8 digits of accuracy.  You check whether</source>
          <target state="translated">Imagina trabajar en la base diez con,digamos,8 dígitos de precisión.Compruebas si</target>
        </trans-unit>
        <trans-unit id="99cb5d12f8afe87e5f2199dd7832164a30028595" translate="yes" xml:space="preserve">
          <source>Imagine you are going to add up two float numbers like &lt;code&gt;0.2&lt;/code&gt; and &lt;code&gt;0.7&lt;/code&gt; here it is: &lt;code&gt;0.2 + 0.7 = 0.8999999999999999&lt;/code&gt;.</source>
          <target state="translated">Imagine que va a sumar dos n&amp;uacute;meros flotantes como &lt;code&gt;0.2&lt;/code&gt; y &lt;code&gt;0.7&lt;/code&gt; aqu&amp;iacute; est&amp;aacute;: &lt;code&gt;0.2 + 0.7 = 0.8999999999999999&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b1148919cbaacaaf9135169d3d2fdb6dafcf25" translate="yes" xml:space="preserve">
          <source>In addition to the other correct answers, you may want to consider scaling your values to avoid problems with floating-point arithmetic.</source>
          <target state="translated">Además de las otras respuestas correctas,puede considerar escalar sus valores para evitar problemas con la aritmética de punto flotante.</target>
        </trans-unit>
        <trans-unit id="d2b3c535762ccb723471ca3d19c266d59819e435" translate="yes" xml:space="preserve">
          <source>In base&lt;sub&gt;10&lt;/sub&gt; we can't represent &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;3&lt;/sub&gt;. But in binary, we can't do &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;10&lt;/sub&gt;&lt;em&gt;or&lt;/em&gt;&lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;3&lt;/sub&gt;.</source>
          <target state="translated">En la base &lt;sub&gt;10&lt;/sub&gt; no podemos representar &lt;sub&gt;1/3&lt;/sub&gt; . Pero en binario, no podemos hacer &lt;sub&gt;1/10&lt;/sub&gt; &lt;em&gt;o&lt;/em&gt; &lt;sub&gt;1/3&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="8f38a9914f49411cfba349dfdb8630e09f562340" translate="yes" xml:space="preserve">
          <source>In binary, we only get the &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; term, that is:</source>
          <target state="translated">En binario, solo obtenemos el t&amp;eacute;rmino &lt;em&gt;2 &lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; , es decir:</target>
        </trans-unit>
        <trans-unit id="4ef2cdaba6d234b05bee8a68976633267a094852" translate="yes" xml:space="preserve">
          <source>In contrast, the rational number &lt;code&gt;0.1&lt;/code&gt;, which is &lt;code&gt;1/10&lt;/code&gt;, can be written exactly as</source>
          <target state="translated">En contraste, el n&amp;uacute;mero racional &lt;code&gt;0.1&lt;/code&gt; , que es &lt;code&gt;1/10&lt;/code&gt; , se puede escribir exactamente como</target>
        </trans-unit>
        <trans-unit id="b961be3443aab68ceeec29a5220e6f9ed3ea8cb9" translate="yes" xml:space="preserve">
          <source>In order to offer The &lt;strong&gt;best solution&lt;/strong&gt; I can say I discovered following method:</source>
          <target state="translated">Para ofrecer la &lt;strong&gt;mejor soluci&amp;oacute;n&lt;/strong&gt; que puedo decir, descubr&amp;iacute; el siguiente m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="2e914e63df1d23846968db54c322cfcde5d441c1" translate="yes" xml:space="preserve">
          <source>In particular, 0.1 + 0.2 is really 0.1000000000000000055511151231257827021181583404541015625 + 0.200000000000000011102230246251565404236316680908203125 = 0.3000000000000000444089209850062616169452667236328125, whereas the number closest to 0.3 is actually 0.299999999999999988897769753748434595763683319091796875.</source>
          <target state="translated">En particular,0,1+0,2 es realmente 0,1000000000000000055511151231257827021181583404541015625+0,2000000000000000000011102230246251565404236316680908203125=0.30000000000000004440892098500626169452667236328125,mientras que el número más cercano al 0,3 es en realidad 0,29999999999988897769753748434595763683319091796875.</target>
        </trans-unit>
        <trans-unit id="4228e410bba6241e580bda13c93c5be682de4fe0" translate="yes" xml:space="preserve">
          <source>In practice, this problem of precision means you need to use rounding functions to round your floating point numbers off to however many decimal places you're interested in before you display them.</source>
          <target state="translated">En la práctica,este problema de precisión significa que hay que utilizar las funciones de redondeo para redondear los números en coma flotante a cuantos decimales le interesen antes de mostrarlos.</target>
        </trans-unit>
        <trans-unit id="ac42fff92fa17be820acdfc20ad21aaa24d67e47" translate="yes" xml:space="preserve">
          <source>In reality, this sum is only an approximation.  For the number 999,999,999  the compiler will insert in bit representation of the float the number 1,000,000,000</source>
          <target state="translated">En realidad,esta suma es sólo una aproximación.Para el número 999.999.999 el compilador insertará en representación de bits de la carroza el número 1.000.000.000</target>
        </trans-unit>
        <trans-unit id="d361ff6e0befd1e900ea2d2a691af9c88a12a12e" translate="yes" xml:space="preserve">
          <source>In short, the fundamental reason for the errors in floating point operations is a combination of the truncation in hardware, and the truncation of a reciprocal in the case of division. Since the IEEE-754 standard only requires an error of less than one half of one unit in the last place for a single operation, the floating point errors over repeated operations will add up unless corrected.</source>
          <target state="translated">En resumen,la razón fundamental de los errores en las operaciones en coma flotante es una combinación del truncamiento en el hardware,y el truncamiento de un recíproco en el caso de la división.Dado que la norma IEEE-754 sólo requiere un error de menos de la mitad de una unidad en el último lugar para una sola operación,los errores en coma flotante sobre operaciones repetidas se sumarán a menos que se corrijan.</target>
        </trans-unit>
        <trans-unit id="e5fabd55d2fd5b1b6baf316413574a320dcf8783" translate="yes" xml:space="preserve">
          <source>In the IEEE-754 standard, hardware designers are allowed any value of error/epsilon as long as it's less than one half of one unit in the last place, and the result only has to be less than one half of one unit in the last place for one operation. This explains why when there are repeated operations, the errors add up. For IEEE-754 double precision, this is the 54th bit, since 53 bits are used to represent the numeric part (normalized), also called the mantissa, of the floating point number (e.g. the 5.3 in 5.3e5). The next sections go into more detail on the causes of hardware error on various floating point operations.</source>
          <target state="translated">En el estándar IEEE-754,los diseñadores de hardware están autorizados a cualquier valor de errorepsilon siempre y cuando sea inferior a la mitad de una unidad en el último lugar,y el resultado sólo tiene que ser inferior a la mitad de una unidad en el último lugar para una operación.Esto explica por qué cuando hay operaciones repetidas,los errores se suman.En el caso de la doble precisión del IEEE-754,éste es el bit 54,ya que se utilizan 53 bits para representar la parte numérica (normalizada),también llamada mantisa,del número de punto flotante (por ejemplo,el 5.3 en 5.3e5).En las siguientes secciones se explican con más detalle las causas de los errores de hardware en diversas operaciones en coma flotante.</target>
        </trans-unit>
        <trans-unit id="d2adcf90f9007e61cdec953379088b5fa66be386" translate="yes" xml:space="preserve">
          <source>In the case of 0.2, the numbers are all the same, just scaled up by a factor of 2. Again, we favour the value that's slightly higher than 0.2.</source>
          <target state="translated">En el caso de 0,2,los números son todos iguales,sólo que aumentados por un factor de 2.Una vez más,favorecemos el valor que es ligeramente superior a 0,2.</target>
        </trans-unit>
        <trans-unit id="e4922ee598bf50ce8a8aa97294d719a5f025128d" translate="yes" xml:space="preserve">
          <source>In this example you need 2 digits precision so it should be &lt;code&gt;toFixed(2)&lt;/code&gt;, so what should be the paramter to fit every given float number?</source>
          <target state="translated">En este ejemplo, necesita una precisi&amp;oacute;n de 2 d&amp;iacute;gitos, por lo que debe estar en &lt;code&gt;toFixed(2)&lt;/code&gt; , entonces, &amp;iquest;cu&amp;aacute;l debe ser el par&amp;aacute;metro para adaptarse a cada n&amp;uacute;mero flotante dado?</target>
        </trans-unit>
        <trans-unit id="d307899e3a9faf88be765042e4c814a072993a93" translate="yes" xml:space="preserve">
          <source>Instead do &lt;code&gt;if (abs(x - y) &amp;lt; myToleranceValue) { ... }&lt;/code&gt;.</source>
          <target state="translated">En su lugar, haga &lt;code&gt;if (abs(x - y) &amp;lt; myToleranceValue) { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af2d9d553cd8ff9919717f84680c53a32ea7fd20" translate="yes" xml:space="preserve">
          <source>Is floating point math broken</source>
          <target state="translated">¿Está rota la matemática de punto flotante</target>
        </trans-unit>
        <trans-unit id="7ae4f138c29e2b8ddf6d3e604ad8ec17b30e1885" translate="yes" xml:space="preserve">
          <source>It's actually pretty simple. When you have a base 10 system (like ours), it can only express fractions that use a prime factor of the base. The prime factors of 10 are 2 and 5. So 1/2, 1/4, 1/5, 1/8, and 1/10 can all be expressed cleanly because the denominators all use prime factors of 10. In contrast, 1/3, 1/6, and 1/7 are all repeating decimals because their denominators use a prime factor of 3 or 7. In binary (or base 2), the only prime factor is 2. So you can only express fractions cleanly which only contain 2 as a prime factor. In binary, 1/2, 1/4, 1/8 would all be expressed cleanly as decimals. While, 1/5 or 1/10 would be repeating decimals. So 0.1 and 0.2 (1/10 and 1/5) while clean decimals in a base 10 system, are repeating decimals in the base 2 system the computer is operating in. When you do math on these repeating decimals, you end up with leftovers which carry over when you convert the computer's base 2 (binary) number into a more human readable base 10 number.</source>
          <target state="translated">En realidad es bastante simple.Cuando tienes un sistema de base 10 (como el nuestro),sólo puede expresar fracciones que usan un factor primario de la base.Los factores primos de 10 son 2 y 5.Así que 12,14,15,18 y 110 pueden expresarse limpiamente porque todos los denominadores usan factores primos de 10.Por el contrario,13,16 y 17 son todos decimales que se repiten porque sus denominadores usan un factor primario de 3 o 7.En binario (o base 2),el único factor primo es 2.Así que sólo se pueden expresar limpiamente las fracciones que sólo contienen 2 como factor primo.En binario,12,14,18 serían todos expresados limpiamente como decimales.Mientras que,15 o 110 serían decimales repetidos.Así que 0,1 y 0,2 (110 y 15)mientras que los decimales limpios en un sistema de base 10,son decimales que se repiten en el sistema de base 2 en el que opera el ordenador.Cuando haces matemáticas sobre estos decimales que se repiten,terminas con sobras que se acumulan cuando conviertes el número de base 2 (binario)de la computadora en un número de base 10 más legible para los humanos.</target>
        </trans-unit>
        <trans-unit id="9bedf433c947094cc3f7cbfb70b1b08a6b15157f" translate="yes" xml:space="preserve">
          <source>Just for fun, I played with the representation of floats, following the definitions from the Standard C99 and I wrote the code below.</source>
          <target state="translated">Sólo por diversión,jugué con la representación de las carrozas,siguiendo las definiciones de la Norma C99 y escribí el código a continuación.</target>
        </trans-unit>
        <trans-unit id="132f6e2254fa1dd608decdd2acee6a977411ff01" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;(0.2 + 0.1) * 10 / 10&lt;/code&gt; won't work at all although it seems the same!
I prefer the first solution since I can apply it as a function which converts the input float to accurate output float.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;(0.2 + 0.1) * 10 / 10&lt;/code&gt; no funcionar&amp;aacute; en absoluto, &amp;iexcl;aunque parezca lo mismo! Prefiero la primera soluci&amp;oacute;n, ya que puedo aplicarla como una funci&amp;oacute;n que convierte la entrada flotante en salida precisa.</target>
        </trans-unit>
        <trans-unit id="2799ad7660549a72b5a827dbb592f0ec6f37f29b" translate="yes" xml:space="preserve">
          <source>Let me explain why it's the best solution.
As others mentioned in above answers it's a good idea to use ready to use Javascript toFixed() function to solve the problem. But most likely you'll encounter with some problems.</source>
          <target state="translated">Déjame explicarte por qué es la mejor solución.Como otros mencionados en las respuestas anteriores es una buena idea usar la función ready to use Javascript toFixed()para resolver el problema.Pero lo más probable es que te encuentres con algunos problemas.</target>
        </trans-unit>
        <trans-unit id="a86e0321652ded6bea22752519aa3d0aa14fe1fd" translate="yes" xml:space="preserve">
          <source>Let's try it yourself:</source>
          <target state="translated">Intentémoslo tú mismo:</target>
        </trans-unit>
        <trans-unit id="71a6be33e3fd9f8758c62adc390facaf65d03f2f" translate="yes" xml:space="preserve">
          <source>Many of this question's numerous duplicates ask about the effects of floating point rounding on specific numbers. In practice, it is easier to get a feeling for how it works by looking at exact results of calculations of interest rather than by just reading about it. Some languages provide ways of doing that - such as converting a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;BigDecimal&lt;/code&gt; in Java.</source>
          <target state="translated">Muchos de los numerosos duplicados de esta pregunta se refieren a los efectos del redondeo de coma flotante en n&amp;uacute;meros espec&amp;iacute;ficos. En la pr&amp;aacute;ctica, es m&amp;aacute;s f&amp;aacute;cil tener una idea de c&amp;oacute;mo funciona mirando los resultados exactos de los c&amp;aacute;lculos de inter&amp;eacute;s en lugar de simplemente leer sobre ello. Algunos lenguajes proporcionan formas de hacerlo, como convertir un &lt;code&gt;float&lt;/code&gt; o &lt;code&gt;double&lt;/code&gt; a &lt;code&gt;BigDecimal&lt;/code&gt; en Java.</target>
        </trans-unit>
        <trans-unit id="8934b0ad8a8f5b6d10b480c6e3fb04ebd566c062" translate="yes" xml:space="preserve">
          <source>Many online converters exist to convert a double precision floating point number to binary (e.g. at &lt;a href=&quot;http://www.binaryconvert.com/convert_double.html&quot;&gt;binaryconvert.com&lt;/a&gt;), but here is some sample C# code to obtain the IEEE 754 representation for a double precision number (I separate the three parts with colons (&lt;code&gt;:&lt;/code&gt;):</source>
          <target state="translated">Existen muchos convertidores en l&amp;iacute;nea para convertir un n&amp;uacute;mero de coma flotante de precisi&amp;oacute;n doble a binario (por ejemplo, en &lt;a href=&quot;http://www.binaryconvert.com/convert_double.html&quot;&gt;binaryconvert.com&lt;/a&gt; ), pero aqu&amp;iacute; hay un c&amp;oacute;digo C # de muestra para obtener la representaci&amp;oacute;n IEEE 754 para un n&amp;uacute;mero de precisi&amp;oacute;n doble (separo las tres partes con dos puntos ( &lt;code&gt;:&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="5594903df7afb92532bede50aa19f8bc44b9b936" translate="yes" xml:space="preserve">
          <source>Math.sum accepts any number of arguments</source>
          <target state="translated">Math.sum acepta cualquier número de argumentos</target>
        </trans-unit>
        <trans-unit id="a7da8c89426f6244ba27410665d12c52debd6422" translate="yes" xml:space="preserve">
          <source>Model for store real numbers under the hood represent float numbers as</source>
          <target state="translated">El modelo para almacenar los números reales bajo el capó representa los números flotantes como</target>
        </trans-unit>
        <trans-unit id="3c239885b8ff7c9107ab26b704ba9e20dc93111d" translate="yes" xml:space="preserve">
          <source>Most calculators use additional &lt;a href=&quot;https://en.wikipedia.org/wiki/Guard_digit&quot;&gt;guard digits&lt;/a&gt; to get around this problem, which is how &lt;code&gt;0.1 + 0.2&lt;/code&gt; would give &lt;code&gt;0.3&lt;/code&gt;: the final few bits are rounded.</source>
          <target state="translated">La mayor&amp;iacute;a de las calculadoras usan &lt;a href=&quot;https://en.wikipedia.org/wiki/Guard_digit&quot;&gt;d&amp;iacute;gitos de protecci&amp;oacute;n&lt;/a&gt; adicionales para solucionar este problema, que es c&amp;oacute;mo &lt;code&gt;0.1 + 0.2&lt;/code&gt; dar&amp;iacute;a &lt;code&gt;0.3&lt;/code&gt; : los &amp;uacute;ltimos bits se redondean.</target>
        </trans-unit>
        <trans-unit id="b944713acbfeaefa185fd6b02b29866cbcd20f3a" translate="yes" xml:space="preserve">
          <source>Most experienced programmers, of course, know the real answer, which is that there is no way to piece together an &lt;em&gt;exact&lt;/em&gt; tenth or fifth of the pizza using those slices, no matter how finely you slice them. You can do a pretty good approximation, and if you add up the approximation of 0.1 with the approximation of 0.2, you get a pretty good approximation of 0.3, but it's still just that, an approximation.</source>
          <target state="translated">Los programadores m&amp;aacute;s experimentados, por supuesto, saben la respuesta real, que es que no hay forma de juntar &lt;em&gt;exactamente&lt;/em&gt; una d&amp;eacute;cima o quinta parte de la pizza usando esas rebanadas, sin importar cu&amp;aacute;n finamente las corte. Puede hacer una aproximaci&amp;oacute;n bastante buena, y si suma la aproximaci&amp;oacute;n de 0.1 con la aproximaci&amp;oacute;n de 0.2, obtendr&amp;aacute; una aproximaci&amp;oacute;n bastante buena de 0.3, pero sigue siendo solo eso, una aproximaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="db20f0baebe5ae74b4f5ca1ba310ce4d2dac041e" translate="yes" xml:space="preserve">
          <source>Most processors follow the &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE-754&lt;/a&gt; standard but some use denormalized, or different standards
. For example, there is a denormalized mode in IEEE-754 which allows representation of very small floating point numbers at the expense of precision. The following, however, will cover the normalized mode of IEEE-754 which is the typical mode of operation.</source>
          <target state="translated">La mayor&amp;iacute;a de los procesadores siguen el est&amp;aacute;ndar &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE-754&lt;/a&gt; , pero algunos usan est&amp;aacute;ndares desnormalizados o diferentes. Por ejemplo, hay un modo desnormalizado en IEEE-754 que permite la representaci&amp;oacute;n de n&amp;uacute;meros de coma flotante muy peque&amp;ntilde;os a expensas de la precisi&amp;oacute;n. Sin embargo, lo siguiente cubrir&amp;aacute; el modo normalizado de IEEE-754, que es el modo de operaci&amp;oacute;n t&amp;iacute;pico.</target>
        </trans-unit>
        <trans-unit id="5cf99f8f009932fb02161551e41e5b27ef9ccc1d" translate="yes" xml:space="preserve">
          <source>My workaround:</source>
          <target state="translated">Mi solución:</target>
        </trans-unit>
        <trans-unit id="fe2cee7e86246cc3c67f2c8393c324743271be71" translate="yes" xml:space="preserve">
          <source>Neither of these solutions is perfect (especially if we look at performances, or if we require a very high precision), but still they solve a great number of problems with binary floating point arithmetic.</source>
          <target state="translated">Ninguna de estas soluciones es perfecta (sobre todo si nos fijamos en los rendimientos,o si exigimos una precisión muy alta),pero aún así resuelven un gran número de problemas con la aritmética binaria de punto flotante.</target>
        </trans-unit>
        <trans-unit id="2b33a1cd6bfe955729a61c6c2378164276c976df" translate="yes" xml:space="preserve">
          <source>No, not broken, but most decimal fractions must be approximated</source>
          <target state="translated">No,no está roto,pero la mayoría de las fracciones decimales deben ser aproximadas</target>
        </trans-unit>
        <trans-unit id="64a768dd81380b6d830fc7ba6f606946def99de5" translate="yes" xml:space="preserve">
          <source>Not all numbers can be represented via &lt;strong&gt;floats&lt;/strong&gt;/&lt;strong&gt;doubles&lt;/strong&gt;
For example, the number &quot;0.2&quot; will be represented as &quot;0.200000003&quot; in single precision in IEEE754 float point standard.</source>
          <target state="translated">No todos los n&amp;uacute;meros se pueden representar mediante &lt;strong&gt;flotantes&lt;/strong&gt; / &lt;strong&gt;dobles.&lt;/strong&gt; Por ejemplo, el n&amp;uacute;mero &quot;0.2&quot; se representar&amp;aacute; como &quot;0.200000003&quot; en precisi&amp;oacute;n simple en el est&amp;aacute;ndar de coma flotante IEEE754.</target>
        </trans-unit>
        <trans-unit id="173f07d87b229443d640ce3489ba411e8746ea11" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; differ only in the last bit; &lt;code&gt;...0011&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; = &lt;code&gt;...0100&lt;/code&gt;. In this case, the value with the least significant bit of zero is &lt;em&gt;b&lt;/em&gt;, so the sum is:</source>
          <target state="translated">Tenga en cuenta que &lt;em&gt;ayb&lt;/em&gt; difieren solo en el &amp;uacute;ltimo bit; &lt;code&gt;...0011&lt;/code&gt; + &lt;code&gt;1&lt;/code&gt; = &lt;code&gt;...0100&lt;/code&gt; . En este caso, el valor con el bit menos significativo de cero es &lt;em&gt;b&lt;/em&gt; , por lo que la suma es:</target>
        </trans-unit>
        <trans-unit id="fb1682df5506dc738031d2049d0fe97e609c88dc" translate="yes" xml:space="preserve">
          <source>Note that the default rounding mode, round-to-nearest &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Rounding_modes&quot;&gt;even digit in the last place&lt;/a&gt;, guarantees an error of less than one half of one unit in the last place for one operation. Using the truncation, round-up, and round down alone may result in an error that is greater than one half of one unit in the last place, but less than one unit in the last place, so these modes are not recommended unless they are used in Interval Arithmetic.</source>
          <target state="translated">Tenga en cuenta que el modo de redondeo predeterminado, redondear al &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Rounding_modes&quot;&gt;d&amp;iacute;gito par&lt;/a&gt; m&amp;aacute;s cercano en el &amp;uacute;ltimo lugar , garantiza un error de menos de la mitad de una unidad en el &amp;uacute;ltimo lugar para una operaci&amp;oacute;n. El uso del truncamiento, redondeo y redondeo solo puede dar como resultado un error que es mayor que la mitad de una unidad en el &amp;uacute;ltimo lugar, pero menor que una unidad en el &amp;uacute;ltimo lugar, por lo que estos modos no se recomiendan a menos que sean utilizado en aritm&amp;eacute;tica de intervalos.</target>
        </trans-unit>
        <trans-unit id="e275cd62fb5f11144c70906280ad00b0caaae18d" translate="yes" xml:space="preserve">
          <source>Note that the mantissa is composed of recurring digits of &lt;code&gt;0011&lt;/code&gt;. This is &lt;strong&gt;key&lt;/strong&gt; to why there is any error to the calculations - 0.1, 0.2 and 0.3 cannot be represented in binary &lt;strong&gt;precisely&lt;/strong&gt; in a &lt;em&gt;finite&lt;/em&gt; number of binary bits any more than 1/9, 1/3 or 1/7 can be represented precisely in &lt;em&gt;decimal digits&lt;/em&gt;.</source>
          <target state="translated">Tenga en cuenta que la mantisa se compone de d&amp;iacute;gitos recurrentes de &lt;code&gt;0011&lt;/code&gt; . Esta es la &lt;strong&gt;clave de&lt;/strong&gt; por qu&amp;eacute; hay alg&amp;uacute;n error en los c&amp;aacute;lculos: 0.1, 0.2 y 0.3 no se pueden representar en binario &lt;strong&gt;precisamente&lt;/strong&gt; en un n&amp;uacute;mero &lt;em&gt;finito&lt;/em&gt; de bits binarios, no m&amp;aacute;s de 1/9, 1/3 o 1/7 se pueden representar con precisi&amp;oacute;n en &lt;em&gt;d&amp;iacute;gitos decimales&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1e48ccd7591a347088699ef49149eac61dd4272" translate="yes" xml:space="preserve">
          <source>Notice that in both cases, the approximations for 0.1 and 0.2 have a slight upward bias. If we add enough of these biases in, they will push the number further and further away from what we want, and in fact, in the case of 0.1 + 0.2, the bias is high enough that the resulting number is no longer the closest number to 0.3.</source>
          <target state="translated">Fíjese que en ambos casos,las aproximaciones para 0,1 y 0,2 tienen un ligero sesgo ascendente.Si añadimos suficientes de estos sesgos,empujarán el número cada vez más lejos de lo que queremos,y de hecho,en el caso de 0,1+0,2,el sesgo es lo suficientemente alto como para que el número resultante ya no sea el número más cercano a 0,3.</target>
        </trans-unit>
        <trans-unit id="9520be12da7f5411c118335231ed0c5f7a84ec09" translate="yes" xml:space="preserve">
          <source>Now that you found the solution, it's better to offer it as a function like this:</source>
          <target state="translated">Ahora que has encontrado la solución,es mejor ofrecerla como una función como esta:</target>
        </trans-unit>
        <trans-unit id="61b21a44286dfe92732888d44bc4a742729e3bcc" translate="yes" xml:space="preserve">
          <source>Now, how would you piece all the slices in such a way that would add up to one-tenth (0.1) or one-fifth (0.2) of a pizza? Really think about it, and try working it out. You can even try to use a real pizza, if you have a mythical precision pizza cutter at hand. :-)</source>
          <target state="translated">Ahora,¿cómo cortarías todas las rebanadas de tal manera que sumaran una décima (0.1)o una quinta (0.2)parte de una pizza? Piénsalo bien y trata de resolverlo.Incluso puedes intentar usar una pizza real,si tienes un mítico cortador de pizza de precisión a mano.:-)</target>
        </trans-unit>
        <trans-unit id="105e5e7696e347e9fea2b0bfb4ac95627ef03c36" translate="yes" xml:space="preserve">
          <source>One example would be</source>
          <target state="translated">Un ejemplo sería</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="a96f5425027bc80f50fbfd4f9264ef5dadb0389c" translate="yes" xml:space="preserve">
          <source>P.S. Some programming languages also provide pizza cutters that can &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal_floating_point&quot;&gt;split slices into exact tenths&lt;/a&gt;. Although such pizza cutters are uncommon, if you do have access to one, you should use it when it's important to be able to get exactly one-tenth or one-fifth of a slice.</source>
          <target state="translated">PD: algunos lenguajes de programaci&amp;oacute;n tambi&amp;eacute;n proporcionan cortadores de pizza que pueden &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal_floating_point&quot;&gt;dividir rebanadas en d&amp;eacute;cimas exactas&lt;/a&gt; . Aunque tales cortadores de pizza son poco comunes, si tiene acceso a uno, debe usarlo cuando sea importante poder obtener exactamente una d&amp;eacute;cima parte o un quinto de una rebanada.</target>
        </trans-unit>
        <trans-unit id="29dfe574f408d995f2185483c55dbffde4813a84" translate="yes" xml:space="preserve">
          <source>Plain old decimal (base 10) numbers have the same issues, which is why numbers like 1/3 end up as 0.333333333...</source>
          <target state="translated">Los viejos números decimales (base 10)tienen los mismos problemas,por lo que números como el 13 terminan como 0.333333333...</target>
        </trans-unit>
        <trans-unit id="27e3ae8dbaba8a0d1b82dbf5add12c954885d1e0" translate="yes" xml:space="preserve">
          <source>Python's &lt;a href=&quot;https://docs.python.org/dev/library/decimal.html&quot;&gt;&lt;code&gt;decimal&lt;/code&gt; module&lt;/a&gt; and Java's &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt; class&lt;/a&gt;, that represent numbers internally with decimal notation (as opposed to binary notation). Both have limited precision, so they are still error prone, however they solve most common problems with binary floating point arithmetic.</source>
          <target state="translated">El &lt;a href=&quot;https://docs.python.org/dev/library/decimal.html&quot;&gt;m&amp;oacute;dulo &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt; de Python y la &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;clase &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt; de Java, que representan n&amp;uacute;meros internamente con notaci&amp;oacute;n decimal (en oposici&amp;oacute;n a la notaci&amp;oacute;n binaria). Ambos tienen una precisi&amp;oacute;n limitada, por lo que todav&amp;iacute;a son propensos a errores, sin embargo, resuelven los problemas m&amp;aacute;s comunes con la aritm&amp;eacute;tica de coma flotante binaria.</target>
        </trans-unit>
        <trans-unit id="eb619cf9a5eaa0e9433e5e33fece2c06bd48ff6d" translate="yes" xml:space="preserve">
          <source>Python's &lt;a href=&quot;https://docs.python.org/dev/library/fractions.html&quot;&gt;&lt;code&gt;fractions&lt;/code&gt; module&lt;/a&gt; and Apache Common's &lt;a href=&quot;https://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/fraction/BigFraction.html&quot;&gt;&lt;code&gt;BigFraction&lt;/code&gt; class&lt;/a&gt;. Both represent rational numbers as &lt;code&gt;(numerator, denominator)&lt;/code&gt; pairs and they may give more accurate results than decimal floating point arithmetic.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/fractions.html&quot;&gt;M&amp;oacute;dulo de &lt;code&gt;fractions&lt;/code&gt; &lt;/a&gt; de Python y &lt;a href=&quot;https://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/fraction/BigFraction.html&quot;&gt;clase &lt;code&gt;BigFraction&lt;/code&gt; de&lt;/a&gt; Apache Common. Ambos representan n&amp;uacute;meros racionales como pares &lt;code&gt;(numerator, denominator)&lt;/code&gt; y pueden dar resultados m&amp;aacute;s precisos que la aritm&amp;eacute;tica de coma flotante decimal.</target>
        </trans-unit>
        <trans-unit id="3ac876068bdeda94095d3a7511721e8436f028d3" translate="yes" xml:space="preserve">
          <source>Python's &lt;code&gt;decimal&lt;/code&gt; module is based on &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_854-1987&quot;&gt;IEEE standard 854-1987&lt;/a&gt;.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;decimal&lt;/code&gt; de Python se basa en el &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_854-1987&quot;&gt;est&amp;aacute;ndar IEEE 854-1987&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c70cbcdb978515e306b58ad0407fb758f03a30" translate="yes" xml:space="preserve">
          <source>Returning to the floating point converter, the raw hexadecimal for 0.30000000000000004 is 3fd3333333333334, which ends in an even digit and therefore is the correct result.</source>
          <target state="translated">Volviendo al convertidor de punto flotante,el hexadecimal en bruto para 0,30000000000000004 es 3fd3333333333334,que termina en un dígito par y por lo tanto es el resultado correcto.</target>
        </trans-unit>
        <trans-unit id="92b1e4641ea8b0a754e7afa9dfb128e28b38b3b3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/basic_ios/init&quot;&gt;here&lt;/a&gt; for reference</source>
          <target state="translated">Ver &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/basic_ios/init&quot;&gt;aqu&amp;iacute;&lt;/a&gt; para referencia</target>
        </trans-unit>
        <trans-unit id="eb3bdffb7759683f4114fd367d5b967cb10277b0" translate="yes" xml:space="preserve">
          <source>Sign bit: 1 bit</source>
          <target state="translated">Bit del signo:1 bit</target>
        </trans-unit>
        <trans-unit id="8b804a9ed868fea0acf8c3224434cb421a49c76d" translate="yes" xml:space="preserve">
          <source>Significant precision: 53 bits (52 explicitly stored)</source>
          <target state="translated">Precisión significativa:53 bits (52 almacenados explícitamente)</target>
        </trans-unit>
        <trans-unit id="b1ccc6268f35cc5a5baa2d8213bd1bff5a0a1766" translate="yes" xml:space="preserve">
          <source>Since the hardware that does the floating point calculations only needs to yield a result with an error of less than one half of one unit in the last place for a single operation, the error will grow over repeated operations if not watched. This is the reason that in computations that require a bounded error, mathematicians use methods such as using the round-to-nearest &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Rounding_modes&quot;&gt;even digit in the last place&lt;/a&gt; of IEEE-754, because, over time, the errors are more likely to cancel each other out, and &lt;a href=&quot;http://en.wikipedia.org/wiki/Interval_arithmetic&quot;&gt;Interval Arithmetic&lt;/a&gt; combined with variations of the &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_754-2008#Rounding_rules&quot;&gt;IEEE 754 rounding modes&lt;/a&gt; to predict rounding errors, and correct them. Because of its low relative error compared to other rounding modes, round to nearest even digit (in the last place), is the default rounding mode of IEEE-754.</source>
          <target state="translated">Dado que el hardware que realiza los c&amp;aacute;lculos de coma flotante solo necesita obtener un resultado con un error de menos de la mitad de una unidad en el &amp;uacute;ltimo lugar para una sola operaci&amp;oacute;n, el error crecer&amp;aacute; en operaciones repetidas si no se observa. Esta es la raz&amp;oacute;n por la que en los c&amp;aacute;lculos que requieren un error acotado, los matem&amp;aacute;ticos usan m&amp;eacute;todos como el uso del &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Rounding_modes&quot;&gt;d&amp;iacute;gito par&lt;/a&gt; redondeado al m&amp;aacute;s cercano en el &amp;uacute;ltimo lugar de IEEE-754, porque, con el tiempo, es m&amp;aacute;s probable que los errores se cancelen entre s&amp;iacute; out, e &lt;a href=&quot;http://en.wikipedia.org/wiki/Interval_arithmetic&quot;&gt;Interval Arithmetic&lt;/a&gt; combinados con variaciones de los &lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_754-2008#Rounding_rules&quot;&gt;modos de redondeo IEEE 754&lt;/a&gt; para predecir errores de redondeo y corregirlos. Debido a su bajo error relativo en comparaci&amp;oacute;n con otros modos de redondeo, redondear al d&amp;iacute;gito par m&amp;aacute;s cercano (en &amp;uacute;ltimo lugar), es el modo de redondeo predeterminado de IEEE-754.</target>
        </trans-unit>
        <trans-unit id="4264ec05ffbfc8a229c5efdd658651538e8f7d77" translate="yes" xml:space="preserve">
          <source>Since the sum is not of the form 2&lt;sup&gt;n&lt;/sup&gt; * 1.{bbb} we increase the exponent by one and shift the decimal (&lt;em&gt;binary&lt;/em&gt;) point to get:</source>
          <target state="translated">Como la suma no es de la forma 2 &lt;sup&gt;n&lt;/sup&gt; * 1. {bbb} aumentamos el exponente en uno y desplazamos el punto decimal ( &lt;em&gt;binario&lt;/em&gt; ) para obtener:</target>
        </trans-unit>
        <trans-unit id="8fe15c45bd8b7e17a57d9e6c07bb827360bf9a63" translate="yes" xml:space="preserve">
          <source>Since this is a language-agnostic question, it needs language-agnostic tools, such as a &lt;a href=&quot;http://www.exploringbinary.com/floating-point-converter/&quot;&gt;Decimal to Floating-Point Converter&lt;/a&gt;.</source>
          <target state="translated">Como se trata de una pregunta independiente del idioma, necesita herramientas independientes del idioma, como un &lt;a href=&quot;http://www.exploringbinary.com/floating-point-converter/&quot;&gt;convertidor de decimal a coma flotante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c9a3661043362988247e665a5ff40a889bcfbde" translate="yes" xml:space="preserve">
          <source>Since this thread branched off a bit into a general discussion over current floating point implementations I'd add that there are projects on fixing their issues.</source>
          <target state="translated">Dado que este hilo se ramificó un poco en una discusión general sobre las actuales implementaciones de punto flotante,añadiría que hay proyectos para arreglar sus problemas.</target>
        </trans-unit>
        <trans-unit id="8d7e45d0733415a3bee40ed99c227b8a4fcc55c9" translate="yes" xml:space="preserve">
          <source>So in decimal, we can't represent &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;3&lt;/sub&gt;. Because base 10 includes 2 as a prime factor, every number we can write as a binary fraction &lt;em&gt;also&lt;/em&gt; can be written as a base 10 fraction. However, hardly anything we write as a base&lt;sub&gt;10&lt;/sub&gt; fraction is representable in binary. In the range from 0.01, 0.02, 0.03 ... 0.99, only &lt;em&gt;three&lt;/em&gt; numbers can be represented in our FP format: 0.25, 0.50, and 0.75, because they are 1/4, 1/2, and 3/4, all numbers with a prime factor using only the 2&lt;sup&gt;n&lt;/sup&gt; term.</source>
          <target state="translated">Entonces, en decimal, no podemos representar &lt;sub&gt;1/3&lt;/sub&gt; . Debido a que la base 10 incluye 2 como factor primo, cada n&amp;uacute;mero que podemos escribir como fracci&amp;oacute;n binaria &lt;em&gt;tambi&amp;eacute;n&lt;/em&gt; se puede escribir como una fracci&amp;oacute;n base 10. Sin embargo, casi nada de lo que escribimos como una fracci&amp;oacute;n base &lt;sub&gt;10&lt;/sub&gt; es representable en binario. En el rango de 0.01, 0.02, 0.03 ... 0.99, solo se pueden representar &lt;em&gt;tres&lt;/em&gt; n&amp;uacute;meros en nuestro formato FP: 0.25, 0.50 y 0.75, porque son 1/4, 1/2 y 3/4, todos los n&amp;uacute;meros con un factor primo usando solo el t&amp;eacute;rmino 2 &lt;sup&gt;n&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b724f7d5e93bef7ba979ca2b6db6331ea8ad1c" translate="yes" xml:space="preserve">
          <source>So it is a bit hard to represent such numbers exactly. Even if you specify this variable explicitly without any intermediate calculation.</source>
          <target state="translated">Así que es un poco difícil representar tales números con exactitud.Incluso si se especifica esta variable explícitamente sin ningún cálculo intermedio.</target>
        </trans-unit>
        <trans-unit id="6d0912fcda429b68b9e0994a73b85abb7d8f001c" translate="yes" xml:space="preserve">
          <source>So no: binary floating point numbers are not broken, they just happen to be as imperfect as every other base-N number system :)</source>
          <target state="translated">Así que no:los números binarios en coma flotante no se rompen,sólo resultan ser tan imperfectos como cualquier otro sistema de números de base N :)</target>
        </trans-unit>
        <trans-unit id="38123450cd5a2b687471df50e3e3541c514a8630" translate="yes" xml:space="preserve">
          <source>So when you write &lt;code&gt;float x = 999...&lt;/code&gt;, the compiler will transform that number in a bit representation printed by the function &lt;code&gt;xx&lt;/code&gt; such that the sum printed by the function &lt;code&gt;yy&lt;/code&gt; be equal to the given number.</source>
          <target state="translated">Entonces, cuando escribe &lt;code&gt;float x = 999...&lt;/code&gt; , el compilador transformar&amp;aacute; ese n&amp;uacute;mero en una representaci&amp;oacute;n de bits impresa por la funci&amp;oacute;n &lt;code&gt;xx&lt;/code&gt; de modo que la suma impresa por la funci&amp;oacute;n &lt;code&gt;yy&lt;/code&gt; sea ​​igual al n&amp;uacute;mero dado.</target>
        </trans-unit>
        <trans-unit id="459b7f35474c9c93ae8fcd79868b828ff68a08ab" translate="yes" xml:space="preserve">
          <source>So while every binary fraction can be written in decimal, the reverse is not true. And in fact most decimal fractions repeat in binary.</source>
          <target state="translated">Así que mientras que cada fracción binaria puede ser escrita en decimal,lo contrario no es cierto.Y de hecho la mayoría de las fracciones decimales se repiten en binario.</target>
        </trans-unit>
        <trans-unit id="0f7d8fe8c6fbc3cfacb76978a4bcc7cb719ecf0a" translate="yes" xml:space="preserve">
          <source>Some high level languages such as Python and Java come with tools to overcome binary floating point limitations. For example:</source>
          <target state="translated">Algunos lenguajes de alto nivel como Python y Java vienen con herramientas para superar las limitaciones del punto flotante binario.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="791b5e413bc079e206d5f368f16ef6fac171632c" translate="yes" xml:space="preserve">
          <source>Some statistics related to this famous double precision question.</source>
          <target state="translated">Algunas estadísticas relacionadas con esta famosa pregunta de doble precisión.</target>
        </trans-unit>
        <trans-unit id="ec3fa9530fa475d8f36d0f7a062d084a2bb45c03" translate="yes" xml:space="preserve">
          <source>Squeezing infinitely many real numbers into a finite number of bits requires an approximate representation. Although there are infinitely many integers, in most programs the result of integer computations can be stored in 32 bits. In contrast, given any fixed number of bits, most calculations with real numbers will produce quantities that cannot be exactly represented using that many bits. Therefore the result of a floating-point calculation must often be rounded in order to fit back into its finite representation. This rounding error is the characteristic feature of floating-point computation.</source>
          <target state="translated">Exprimir infinitamente muchos números reales en un número finito de bits requiere una representación aproximada.Aunque hay infinitamente muchos números enteros,en la mayoría de los programas el resultado de los cálculos de los números enteros puede ser almacenado en 32 bits.Por el contrario,dado cualquier número fijo de bits,la mayoría de los cálculos con números reales producirán cantidades que no pueden ser representadas exactamente usando tantos bits.Por lo tanto,el resultado de un cálculo en coma flotante debe redondearse a menudo para que vuelva a encajar en su representación finita.Este error de redondeo es el rasgo característico del cálculo en coma flotante.</target>
        </trans-unit>
        <trans-unit id="c141085414843405292b7e3811baac9439881af4" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;https://posithub.org/&quot;&gt;https://posithub.org/&lt;/a&gt; for example, which showcases a number type called posit (and its predecessor unum) that promises to offer better accuracy with fewer bits. If my understanding is correct, it also fixes the kind of problems in the question. Quite interesting project, the person behind it is a mathematician it &lt;a href=&quot;http://www.johngustafson.net/&quot;&gt;Dr. John Gustafson&lt;/a&gt;. The whole thing is open source, with many actual implementations in C/C++, Python, Julia and C# (&lt;a href=&quot;https://hastlayer.com/arithmetics&quot;&gt;https://hastlayer.com/arithmetics&lt;/a&gt;).</source>
          <target state="translated">Eche un vistazo a &lt;a href=&quot;https://posithub.org/&quot;&gt;https://posithub.org/&lt;/a&gt; por ejemplo, que muestra un tipo de n&amp;uacute;mero llamado posit (y su predecesor unum) que promete ofrecer una mejor precisi&amp;oacute;n con menos bits. Si mi comprensi&amp;oacute;n es correcta, tambi&amp;eacute;n soluciona el tipo de problemas en la pregunta. Proyecto bastante interesante, la persona detr&amp;aacute;s de &amp;eacute;l es un matem&amp;aacute;tico que es el &lt;a href=&quot;http://www.johngustafson.net/&quot;&gt;Dr. John Gustafson&lt;/a&gt; . Todo es de c&amp;oacute;digo abierto, con muchas implementaciones reales en C / C ++, Python, Julia y C # ( &lt;a href=&quot;https://hastlayer.com/arithmetics&quot;&gt;https://hastlayer.com/arithmetics&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8995c49b038cd4a41a4b96a4e4e6ee914279da4" translate="yes" xml:space="preserve">
          <source>That pizza cutter has very fine movements, and if you start with a whole pizza, then halve that, and continue halving the smallest slice each time, you can do the halving &lt;em&gt;53 times&lt;/em&gt; before the slice is too small for even its high-precision abilities. At that point, you can no longer halve that very thin slice, but must either include or exclude it as is.</source>
          <target state="translated">Ese cortador de pizza tiene movimientos muy finos, y si comienza con una pizza entera, luego divida en dos y contin&amp;uacute;e dividiendo la porci&amp;oacute;n m&amp;aacute;s peque&amp;ntilde;a cada vez, puede hacer la reducci&amp;oacute;n a la mitad &lt;em&gt;53 veces&lt;/em&gt; antes de que la porci&amp;oacute;n sea demasiado peque&amp;ntilde;a incluso para sus habilidades de alta precisi&amp;oacute;n . En ese punto, ya no puede reducir a la mitad ese corte muy delgado, sino que debe incluirlo o excluirlo tal como est&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9521ab333644ac6fc5a178f9282365b2b72a2e19" translate="yes" xml:space="preserve">
          <source>That's it.  The value of 999999999 is in fact</source>
          <target state="translated">Eso es todo.El valor de 999999999 es de hecho</target>
        </trans-unit>
        <trans-unit id="37fd206bff80a7a4aad65b53473445ec4e6045d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt; and &lt;code&gt;_Decimal128&lt;/code&gt; types might be available on your system (for example, &lt;a href=&quot;http://en.wikipedia.org/wiki/GNU_Compiler_Collection&quot;&gt;GCC&lt;/a&gt; supports them on &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/Decimal-Float.html&quot;&gt;selected targets&lt;/a&gt;, but &lt;a href=&quot;http://en.wikipedia.org/wiki/Clang&quot;&gt;Clang&lt;/a&gt; does not support them on &lt;a href=&quot;http://en.wikipedia.org/wiki/OS_X&quot;&gt;OS&amp;nbsp;X&lt;/a&gt;).</source>
          <target state="translated">Los &lt;code&gt;_Decimal32&lt;/code&gt; , &lt;code&gt;_Decimal64&lt;/code&gt; y &lt;code&gt;_Decimal128&lt;/code&gt; pueden estar disponibles en su sistema (por ejemplo, &lt;a href=&quot;http://en.wikipedia.org/wiki/GNU_Compiler_Collection&quot;&gt;GCC los&lt;/a&gt; admite en &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/Decimal-Float.html&quot;&gt;destinos seleccionados&lt;/a&gt; , pero &lt;a href=&quot;http://en.wikipedia.org/wiki/Clang&quot;&gt;Clang&lt;/a&gt; no los admite en &lt;a href=&quot;http://en.wikipedia.org/wiki/OS_X&quot;&gt;OS X&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8283a2be83322370e2eff49b9d2031176a2a623" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; in the question is a &lt;code&gt;float&lt;/code&gt; variable.</source>
          <target state="translated">La &lt;code&gt;x&lt;/code&gt; en la pregunta es una variable &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b94d896b02c25729113497c920111423c44c9588" translate="yes" xml:space="preserve">
          <source>The answer turns out to be that &lt;code&gt;cout&lt;/code&gt;'s default precision for &lt;code&gt;float&lt;/code&gt; is 6, so it rounds to 6 decimal digits.</source>
          <target state="translated">La respuesta es que la precisi&amp;oacute;n predeterminada de &lt;code&gt;cout&lt;/code&gt; para &lt;code&gt;float&lt;/code&gt; es 6, por lo que se redondea a 6 d&amp;iacute;gitos decimales.</target>
        </trans-unit>
        <trans-unit id="c1e1a2f14e6221a38e01e8ea88f8536a4a118f00" translate="yes" xml:space="preserve">
          <source>The binary representation of 0.1 and 0.2 are the &lt;em&gt;most accurate&lt;/em&gt; representations of the numbers allowable by IEEE 754. The addition of these representation, due to the default rounding mode, results in a value which differs only in the least-significant-bit.</source>
          <target state="translated">La representaci&amp;oacute;n binaria de 0.1 y 0.2 son las representaciones &lt;em&gt;m&amp;aacute;s precisas&lt;/em&gt; de los n&amp;uacute;meros permitidos por IEEE 754. La adici&amp;oacute;n de estas representaciones, debido al modo de redondeo predeterminado, da como resultado un valor que difiere solo en el bit menos significativo.</target>
        </trans-unit>
        <trans-unit id="dc3714342c0c169296b30554e4c7240280cd30d7" translate="yes" xml:space="preserve">
          <source>The code prints the binary representation of floats in 3 separated groups</source>
          <target state="translated">El código imprime la representación binaria de los flotadores en 3 grupos separados</target>
        </trans-unit>
        <trans-unit id="cb9787d2beabdc5d5af158f30db785c40d9c4be1" translate="yes" xml:space="preserve">
          <source>The constants &lt;code&gt;0.2&lt;/code&gt; and &lt;code&gt;0.3&lt;/code&gt; in your program will also be approximations to their true values.  It happens that the closest &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;0.2&lt;/code&gt; is larger than the rational number &lt;code&gt;0.2&lt;/code&gt; but that the closest &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;0.3&lt;/code&gt; is smaller than the rational number &lt;code&gt;0.3&lt;/code&gt;.  The sum of &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;0.2&lt;/code&gt; winds up being larger than the rational number &lt;code&gt;0.3&lt;/code&gt; and hence disagreeing with the constant in your code.</source>
          <target state="translated">Las constantes &lt;code&gt;0.2&lt;/code&gt; y &lt;code&gt;0.3&lt;/code&gt; en su programa tambi&amp;eacute;n ser&amp;aacute;n aproximaciones a sus valores verdaderos. Sucede que el &lt;code&gt;double&lt;/code&gt; m&amp;aacute;s cercano a &lt;code&gt;0.2&lt;/code&gt; es m&amp;aacute;s grande que el n&amp;uacute;mero racional &lt;code&gt;0.2&lt;/code&gt; pero que el &lt;code&gt;double&lt;/code&gt; m&amp;aacute;s cercano a &lt;code&gt;0.3&lt;/code&gt; es m&amp;aacute;s peque&amp;ntilde;o que el n&amp;uacute;mero racional &lt;code&gt;0.3&lt;/code&gt; . La suma de &lt;code&gt;0.1&lt;/code&gt; y &lt;code&gt;0.2&lt;/code&gt; termina siendo mayor que el n&amp;uacute;mero racional &lt;code&gt;0.3&lt;/code&gt; y, por lo tanto, no est&amp;aacute; de acuerdo con la constante en su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="aa4988ab132f87fefeb86fd1af7dafa6f7833b5a" translate="yes" xml:space="preserve">
          <source>The debugger shows &lt;code&gt;9.89999962&lt;/code&gt;, the output of &lt;code&gt;cout&lt;/code&gt; operation is &lt;code&gt;9.9&lt;/code&gt;.</source>
          <target state="translated">El depurador muestra &lt;code&gt;9.89999962&lt;/code&gt; , la salida de la operaci&amp;oacute;n &lt;code&gt;cout&lt;/code&gt; es &lt;code&gt;9.9&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217f6b6cf725f84a8efc542a480c3ef1cad6009d" translate="yes" xml:space="preserve">
          <source>The difference is exactly 2&lt;sup&gt;-54&lt;/sup&gt;, which is ~5.5511151231258 &amp;times; 10&lt;sup&gt;-17&lt;/sup&gt; - insignificant (for many applications) when compared to the original values.</source>
          <target state="translated">La diferencia es exactamente 2-54, que es ~ 5.5511151231258 &amp;times; 10-17 - insignificante (para muchas aplicaciones) en comparaci&amp;oacute;n con los valores originales.</target>
        </trans-unit>
        <trans-unit id="a43c42712f7d96522e8b0f31af33a5949c98d6ac" translate="yes" xml:space="preserve">
          <source>The displayed sum is what inside the hardware.  The value you obtain by computing it depends on the scale you set.  I did set the &lt;code&gt;scale&lt;/code&gt; factor to 15.  Mathematically, with infinite precision, it seems it is 1,000,000,000.</source>
          <target state="translated">La suma mostrada es lo que hay dentro del hardware. El valor que obtienes al calcularlo depende de la escala que establezcas. Establec&amp;iacute; el factor de &lt;code&gt;scale&lt;/code&gt; en 15. Matem&amp;aacute;ticamente, con precisi&amp;oacute;n infinita, parece que es 1,000,000,000.</target>
        </trans-unit>
        <trans-unit id="a93b23943bc3274c1d99364225ccdea1ccea1185" translate="yes" xml:space="preserve">
          <source>The exact situation is slightly more subtle because these numbers are typically stored in scientific notation.  So, for instance, instead of storing 1/10 as &lt;code&gt;0.0001100&lt;/code&gt; we may store it as something like &lt;code&gt;1.10011 * 2^-4&lt;/code&gt;, depending on how many bits we've allocated for the exponent and the mantissa.  This affects how many digits of precision you get for your calculations.</source>
          <target state="translated">La situaci&amp;oacute;n exacta es un poco m&amp;aacute;s sutil porque estos n&amp;uacute;meros generalmente se almacenan en notaci&amp;oacute;n cient&amp;iacute;fica. Entonces, por ejemplo, en lugar de almacenar 1/10 como &lt;code&gt;0.0001100&lt;/code&gt; , podemos almacenarlo como algo as&amp;iacute; como &lt;code&gt;1.10011 * 2^-4&lt;/code&gt; , dependiendo de cu&amp;aacute;ntos bits hayamos asignado para el exponente y la mantisa. Esto afecta cu&amp;aacute;ntos d&amp;iacute;gitos de precisi&amp;oacute;n obtienes para tus c&amp;aacute;lculos.</target>
        </trans-unit>
        <trans-unit id="de1b6c0fe71a68b90695b392838785ffd95aa6e3" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;0.1 + 0.2 === 0.3&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; in JavaScript, but fortunately integer arithmetic in floating-point is exact, so decimal representation errors can be avoided by scaling.</source>
          <target state="translated">La expresi&amp;oacute;n &lt;code&gt;0.1 + 0.2 === 0.3&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; en JavaScript, pero afortunadamente la aritm&amp;eacute;tica de enteros en coma flotante es exacta, por lo que los errores de representaci&amp;oacute;n decimal pueden evitarse mediante el escalado.</target>
        </trans-unit>
        <trans-unit id="429fc3ca14c02cbeba6e5198aedde1d7338c24e1" translate="yes" xml:space="preserve">
          <source>The first bit is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Sign_bit&quot;&gt;sign bit&lt;/a&gt;: &lt;code&gt;1&lt;/code&gt; if the number is negative, &lt;code&gt;0&lt;/code&gt; otherwise&lt;sup&gt;1&lt;/sup&gt;.</source>
          <target state="translated">El primer bit es el &lt;a href=&quot;http://en.wikipedia.org/wiki/Sign_bit&quot;&gt;bit de signo&lt;/a&gt; : &lt;code&gt;1&lt;/code&gt; si el n&amp;uacute;mero es negativo, &lt;code&gt;0&lt;/code&gt; de lo contrario &lt;sup&gt;1&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="069711b8888abcc0778a98d9c8f87b1230fc0f79" translate="yes" xml:space="preserve">
          <source>The kind of floating-point math that can be implemented in a digital computer necessarily uses an approximation of the real numbers and operations on them. (The &lt;em&gt;standard&lt;/em&gt; version runs to over fifty pages of documentation and has a committee to deal with its errata and further refinement.)</source>
          <target state="translated">El tipo de matem&amp;aacute;tica de punto flotante que se puede implementar en una computadora digital necesariamente usa una aproximaci&amp;oacute;n de los n&amp;uacute;meros reales y las operaciones en ellos. (La versi&amp;oacute;n &lt;em&gt;est&amp;aacute;ndar&lt;/em&gt; tiene m&amp;aacute;s de cincuenta p&amp;aacute;ginas de documentaci&amp;oacute;n y tiene un comit&amp;eacute; para encargarse de sus erratas y mejoras adicionales).</target>
        </trans-unit>
        <trans-unit id="5e8f519edb4b0ab1dc30849c2350c221631c53b5" translate="yes" xml:space="preserve">
          <source>The main cause of the error in floating point division is the division algorithms used to calculate the quotient. Most computer systems calculate division using multiplication by an inverse, mainly in &lt;code&gt;Z=X/Y&lt;/code&gt;, &lt;code&gt;Z = X * (1/Y)&lt;/code&gt;.  A division is computed iteratively i.e. each cycle computes some bits of the quotient until the desired precision is reached, which for IEEE-754 is anything with an error of less than one unit in the last place. The table of reciprocals of Y (1/Y) is known as the quotient selection table (QST) in the slow division, and the size in bits of the quotient selection table is usually the width of the radix, or a number of bits of the quotient computed in each iteration,  plus a few guard bits. For the IEEE-754 standard, double precision (64-bit), it would be the size of the radix of the divider, plus a few guard bits k, where &lt;code&gt;k&amp;gt;=2&lt;/code&gt;. So for example, a typical Quotient Selection Table for a divider that computes 2 bits of the quotient at a time (radix 4) would be &lt;code&gt;2+2= 4&lt;/code&gt; bits (plus a few optional bits).</source>
          <target state="translated">La causa principal del error en la divisi&amp;oacute;n de coma flotante son los algoritmos de divisi&amp;oacute;n utilizados para calcular el cociente. La mayor&amp;iacute;a de los sistemas inform&amp;aacute;ticos calculan la divisi&amp;oacute;n usando la multiplicaci&amp;oacute;n por un inverso, principalmente en &lt;code&gt;Z=X/Y&lt;/code&gt; , &lt;code&gt;Z = X * (1/Y)&lt;/code&gt; . Una divisi&amp;oacute;n se calcula iterativamente, es decir, cada ciclo calcula algunos bits del cociente hasta que se alcanza la precisi&amp;oacute;n deseada, lo que para IEEE-754 es cualquier cosa con un error de menos de una unidad en el &amp;uacute;ltimo lugar. La tabla de rec&amp;iacute;procos de Y (1 / Y) se conoce como la tabla de selecci&amp;oacute;n del cociente (QST) en la divisi&amp;oacute;n lenta, y el tama&amp;ntilde;o en bits de la tabla de selecci&amp;oacute;n del cociente suele ser el ancho de la ra&amp;iacute;z, o un n&amp;uacute;mero de bits de El cociente calculado en cada iteraci&amp;oacute;n, m&amp;aacute;s algunos bits de protecci&amp;oacute;n. Para el est&amp;aacute;ndar IEEE-754, doble precisi&amp;oacute;n (64 bits), ser&amp;iacute;a el tama&amp;ntilde;o de la ra&amp;iacute;z del divisor, m&amp;aacute;s unos pocos bits de protecci&amp;oacute;n k, donde &lt;code&gt;k&amp;gt;=2&lt;/code&gt; . Entonces, por ejemplo, una tabla de selecci&amp;oacute;n de cociente t&amp;iacute;pica para un divisor que calcula 2 bits del cociente a la vez (radix 4) ser&amp;iacute;a &lt;code&gt;2+2= 4&lt;/code&gt; bits (m&amp;aacute;s algunos bits opcionales).</target>
        </trans-unit>
        <trans-unit id="98a67d42a6af5d2090dc3a5053a67f6ad508ac3c" translate="yes" xml:space="preserve">
          <source>The next 11 bits are the &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponentiation&quot;&gt;exponent&lt;/a&gt;, which is &lt;a href=&quot;http://en.wikipedia.org/wiki/Offset_binary&quot;&gt;offset&lt;/a&gt; by 1023. In other words, after reading the exponent bits from a double-precision number, 1023 must be subtracted to obtain the power of two.</source>
          <target state="translated">Los siguientes 11 bits son el &lt;a href=&quot;http://en.wikipedia.org/wiki/Exponentiation&quot;&gt;exponente&lt;/a&gt; , que se &lt;a href=&quot;http://en.wikipedia.org/wiki/Offset_binary&quot;&gt;compensa&lt;/a&gt; con 1023. En otras palabras, despu&amp;eacute;s de leer los bits de exponente de un n&amp;uacute;mero de doble precisi&amp;oacute;n, se debe restar 1023 para obtener la potencia de dos.</target>
        </trans-unit>
        <trans-unit id="7bd1be1af16864d63e8e4e2dd6cd731c917703fa" translate="yes" xml:space="preserve">
          <source>The problem comes with numbers that can be represented exactly in base 10, but not in base 2. Those numbers need to be rounded to their closest equivalent. Assuming the very common IEEE 64-bit floating point format, the closest number to &lt;code&gt;0.1&lt;/code&gt; is &lt;code&gt;3602879701896397 x 2⁻⁵⁵&lt;/code&gt;, and the closest number to &lt;code&gt;0.2&lt;/code&gt; is &lt;code&gt;7205759403792794 x 2⁻⁵⁵&lt;/code&gt;; adding them together results in &lt;code&gt;10808639105689191 x 2⁻⁵⁵&lt;/code&gt;, or an exact decimal value of &lt;code&gt;0.3000000000000000444089209850062616169452667236328125&lt;/code&gt;. Floating point numbers are generally rounded for display.</source>
          <target state="translated">El problema viene con n&amp;uacute;meros que pueden representarse exactamente en la base 10, pero no en la base 2. Esos n&amp;uacute;meros deben redondearse a su equivalente m&amp;aacute;s cercano. Suponiendo el muy com&amp;uacute;n formato de coma flotante IEEE de 64 bits, el n&amp;uacute;mero m&amp;aacute;s cercano a &lt;code&gt;0.1&lt;/code&gt; es &lt;code&gt;3602879701896397 x 2⁻⁵⁵&lt;/code&gt; , y el n&amp;uacute;mero m&amp;aacute;s cercano a &lt;code&gt;0.2&lt;/code&gt; es &lt;code&gt;7205759403792794 x 2⁻⁵⁵&lt;/code&gt; ; &lt;code&gt;10808639105689191 x 2⁻⁵⁵&lt;/code&gt; juntos resulta en 10808639105689191 x 2⁻⁵⁵ , o un valor decimal exacto de &lt;code&gt;0.3000000000000000444089209850062616169452667236328125&lt;/code&gt; . Los n&amp;uacute;meros de punto flotante generalmente se redondean para su visualizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fc15ca46635e5191a5253547d7e67b8dfff4d9d3" translate="yes" xml:space="preserve">
          <source>The real value assumed by a given 64-bit double-precision datum with a given biased exponent and a 52-bit fraction is</source>
          <target state="translated">El valor real asumido por un dato dado de doble precisión de 64 bits con un exponente sesgado dado y una fracción de 52 bits es</target>
        </trans-unit>
        <trans-unit id="6c48d666356850a34b3ed56a627c4baa4371b82e" translate="yes" xml:space="preserve">
          <source>The remaining 52 bits are the &lt;a href=&quot;http://en.wikipedia.org/wiki/Significand&quot;&gt;significand&lt;/a&gt; (or mantissa). In the mantissa, an 'implied' &lt;code&gt;1.&lt;/code&gt; is always&lt;sup&gt;2&lt;/sup&gt; omitted since the most significant bit of any binary value is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Los 52 bits restantes son el &lt;a href=&quot;http://en.wikipedia.org/wiki/Significand&quot;&gt;significado&lt;/a&gt; (o mantisa). En la mantisa, un &quot;impl&amp;iacute;cito&quot; &lt;code&gt;1.&lt;/code&gt; siempre se omite &lt;sup&gt;2,&lt;/sup&gt; ya que el bit m&amp;aacute;s significativo de cualquier valor binario es &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c619f9812cce49ddbec068ed67d1e31806109213" translate="yes" xml:space="preserve">
          <source>The situation for binary numbers with a fixed number of bits is exactly analogous. As real numbers, we have</source>
          <target state="translated">La situación para los números binarios con un número fijo de bits es exactamente análoga.Como números reales,tenemos</target>
        </trans-unit>
        <trans-unit id="410bde0aed8816e1edf6c276a59f933a4741b733" translate="yes" xml:space="preserve">
          <source>The upshot is that because of these rounding errors you essentially never want to use == on floating-point numbers.  Instead, you can check if the absolute value of their difference is smaller than some fixed small number.</source>
          <target state="translated">El resultado es que,debido a estos errores de redondeo,esencialmente nunca quieres usar ==en los números de punto flotante.En su lugar,puedes comprobar si el valor absoluto de su diferencia es menor que algún número pequeño fijo.</target>
        </trans-unit>
        <trans-unit id="c3f1ba633847618bf6fb98771611c1a94db112dc" translate="yes" xml:space="preserve">
          <source>The whole issue really arises when people try to use FP for bean counting. It does work for that, but only if you stick to integral values, which kind of defeats the point of using it. &lt;em&gt;This is why we have all those decimal fraction software libraries.&lt;/em&gt;</source>
          <target state="translated">Todo el problema surge realmente cuando las personas intentan usar FP para el conteo de frijoles. Funciona para eso, pero solo si te apegas a los valores integrales, lo que de alguna manera frustra el punto de usarlo. &lt;em&gt;Es por eso que tenemos todas esas bibliotecas de software de fracci&amp;oacute;n decimal.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d808cc026a4e31fe6892bd37e2a4afe8b2d0a1c2" translate="yes" xml:space="preserve">
          <source>There are a majority of fractional numbers that cannot be represented precisely either in binary or in decimal or both. Result - A rounded up (but precise) number results.</source>
          <target state="translated">Hay una mayoría de números fraccionarios que no pueden ser representados con precisión ni en binario ni en decimal o ambos.Resultado-Un número redondeado (pero preciso)resulta.</target>
        </trans-unit>
        <trans-unit id="8cb434dd902f101ef41bbec16086530ea8d35b0d" translate="yes" xml:space="preserve">
          <source>There are now 53 bits in the mantissa (the 53rd is in square brackets in the line above). The default &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Rounding_floating-point_numbers&quot;&gt;rounding mode&lt;/a&gt; for IEEE 754 is '&lt;em&gt;Round to Nearest&lt;/em&gt;' - i.e. if a number &lt;em&gt;x&lt;/em&gt; falls between two values &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, the value where the least significant bit is zero is chosen.</source>
          <target state="translated">Ahora hay 53 bits en la mantisa (el 53 est&amp;aacute; entre corchetes en la l&amp;iacute;nea de arriba). El modo de &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Rounding_floating-point_numbers&quot;&gt;redondeo&lt;/a&gt; predeterminado para IEEE 754 es ' &lt;em&gt;Redondear al m&amp;aacute;s cercano&lt;/em&gt; ', es decir, si un n&amp;uacute;mero &lt;em&gt;x&lt;/em&gt; cae entre dos valores &lt;em&gt;a&lt;/em&gt; y &lt;em&gt;b&lt;/em&gt; , se elige el valor donde el bit menos significativo es cero.</target>
        </trans-unit>
        <trans-unit id="8a5c579792acf30f381ea21b217f8f45dcbf2591" translate="yes" xml:space="preserve">
          <source>This approximation is a mixture of approximations of different kinds, each of which can either be ignored or carefully accounted for due to its specific manner of deviation from exactitude. It also involves a number of explicit exceptional cases at both the hardware and software levels that most people walk right past while pretending not to notice.</source>
          <target state="translated">Esta aproximación es una mezcla de aproximaciones de diferentes tipos,cada una de las cuales puede ser ignorada o cuidadosamente contabilizada debido a su forma específica de desviación de la exactitud.También implica una serie de casos excepcionales explícitos tanto a nivel de hardware como de software que la mayoría de la gente pasa de largo mientras finge no darse cuenta.</target>
        </trans-unit>
        <trans-unit id="fa73b5a554bb0627f1ba0d745b75294785495d01" translate="yes" xml:space="preserve">
          <source>Those weird numbers appear because computers use binary(base 2) number system for calculation purposes, while we use decimal(base 10).</source>
          <target state="translated">Esos números raros aparecen porque las computadoras utilizan el sistema numérico binario(base 2)para los cálculos,mientras que nosotros utilizamos el decimal(base 10).</target>
        </trans-unit>
        <trans-unit id="5181ccaf1ee2c8739257e60d503eec3d8be665e6" translate="yes" xml:space="preserve">
          <source>To add two numbers, the exponent needs to be the same, i.e.:</source>
          <target state="translated">Para sumar dos números,el exponente tiene que ser el mismo,es decir:</target>
        </trans-unit>
        <trans-unit id="debb7281577780d4752f82cdabebcd636735a6dd" translate="yes" xml:space="preserve">
          <source>Truncating at eight decimal places, we get</source>
          <target state="translated">Truncando a ocho decimales,conseguimos</target>
        </trans-unit>
        <trans-unit id="34cefea3b795b99cb53c238c42c45eca37fb7b1a" translate="yes" xml:space="preserve">
          <source>Try to determine when errors occur and fix them with short if statements, it's not pretty but for some problems it is the only solution and this is one of them.</source>
          <target state="translated">Tratar de determinar cuando ocurren errores y corregirlos con afirmaciones cortas,no es bonito pero para algunos problemas es la única solución y esta es una de ellas.</target>
        </trans-unit>
        <trans-unit id="ac5454415e7599b3fa86d8e5365f65ffab330f36" translate="yes" xml:space="preserve">
          <source>Unfortunately 0.3 sits in a gap.</source>
          <target state="translated">Desafortunadamente 0,3 se encuentra en un hueco.</target>
        </trans-unit>
        <trans-unit id="1496a09c9b892ec5642faa5112f45b0d303e2129" translate="yes" xml:space="preserve">
          <source>We can clearly see a breakpoint when &lt;code&gt;2**53+1&lt;/code&gt; - all works fine until &lt;code&gt;2**53&lt;/code&gt;.</source>
          <target state="translated">Podemos ver claramente un punto de interrupci&amp;oacute;n cuando &lt;code&gt;2**53+1&lt;/code&gt; : todo funciona bien hasta &lt;code&gt;2**53&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a203fd809d4ad1cc5e5284e631e856900a9d174a" translate="yes" xml:space="preserve">
          <source>We constantly give the FP hardware something that seems simple in base 10 but is a repeating fraction in base 2.</source>
          <target state="translated">Constantemente le damos al hardware de FP algo que parece simple en base 10 pero que es una fracción repetitiva en base 2.</target>
        </trans-unit>
        <trans-unit id="90bb045aec56dda5712dc977aa590d5634f9d4f3" translate="yes" xml:space="preserve">
          <source>What reciprocals are in the quotient selection table depend on the &lt;a href=&quot;http://en.wikipedia.org/wiki/Division_%28digital%29&quot;&gt;division method&lt;/a&gt;: slow division such as SRT division, or fast division such as Goldschmidt division; each entry is modified according to the division algorithm in an attempt to yield the lowest possible error. In any case, though, all reciprocals are &lt;em&gt;approximations&lt;/em&gt; of the actual reciprocal and introduce some element of error. Both slow division and fast division methods calculate the quotient iteratively, i.e. some number of bits of the quotient are calculated each step, then the result is subtracted from the dividend, and the divider repeats the steps until the error is less than one half of one unit in the last place. Slow division methods calculate a fixed number of digits of the quotient in each step and are usually less expensive to build, and fast division methods calculate a variable number of digits per step and are usually more expensive to build. The most important part of the division methods is that most of them rely upon repeated multiplication by an &lt;em&gt;approximation&lt;/em&gt; of a reciprocal, so they are prone to error.</source>
          <target state="translated">Los rec&amp;iacute;procos en la tabla de selecci&amp;oacute;n del cociente dependen del &lt;a href=&quot;http://en.wikipedia.org/wiki/Division_%28digital%29&quot;&gt;m&amp;eacute;todo de divisi&amp;oacute;n&lt;/a&gt; : divisi&amp;oacute;n lenta, como la divisi&amp;oacute;n SRT, o divisi&amp;oacute;n r&amp;aacute;pida, como la divisi&amp;oacute;n Goldschmidt; cada entrada se modifica de acuerdo con el algoritmo de divisi&amp;oacute;n en un intento de producir el error m&amp;aacute;s bajo posible. En cualquier caso, sin embargo, todos los rec&amp;iacute;procos son &lt;em&gt;aproximaciones&lt;/em&gt; del rec&amp;iacute;proco real e introducen alg&amp;uacute;n elemento de error. Los m&amp;eacute;todos de divisi&amp;oacute;n lenta y divisi&amp;oacute;n r&amp;aacute;pida calculan el cociente de forma iterativa, es decir, se calcula cierto n&amp;uacute;mero de bits del cociente en cada paso, luego el resultado se resta del dividendo, y el divisor repite los pasos hasta que el error sea inferior a la mitad de uno Unidad en &amp;uacute;ltimo lugar. Los m&amp;eacute;todos de divisi&amp;oacute;n lenta calculan un n&amp;uacute;mero fijo de d&amp;iacute;gitos del cociente en cada paso y generalmente son menos costosos de construir, y los m&amp;eacute;todos de divisi&amp;oacute;n r&amp;aacute;pida calculan un n&amp;uacute;mero variable de d&amp;iacute;gitos por paso y generalmente son m&amp;aacute;s costosos de construir. La parte m&amp;aacute;s importante de los m&amp;eacute;todos de divisi&amp;oacute;n es que la mayor&amp;iacute;a de ellos se basan en la multiplicaci&amp;oacute;n repetida por una &lt;em&gt;aproximaci&amp;oacute;n&lt;/em&gt; de un rec&amp;iacute;proco, por lo que son propensos a errores.</target>
        </trans-unit>
        <trans-unit id="9af6bd16dcbaed2435e0ad81259607a927b61175" translate="yes" xml:space="preserve">
          <source>When adding all values (&lt;em&gt;a + b&lt;/em&gt;) using a step of 0.1 (from 0.1 to 100) we have &lt;strong&gt;~15% chance of precision error&lt;/strong&gt;. Note that the error could result in slightly bigger or smaller values.
Here are some examples:</source>
          <target state="translated">Al agregar todos los valores ( &lt;em&gt;a + b&lt;/em&gt; ) usando un paso de 0.1 (de 0.1 a 100) tenemos &lt;strong&gt;~ 15% de posibilidades de error de precisi&amp;oacute;n&lt;/strong&gt; . Tenga en cuenta que el error podr&amp;iacute;a dar lugar a valores ligeramente mayores o menores. Aqu&amp;iacute; hay unos ejemplos:</target>
        </trans-unit>
        <trans-unit id="d692b99fcf87e7edff857861503848f5a6fb925e" translate="yes" xml:space="preserve">
          <source>When subtracting all values (&lt;em&gt;a - b&lt;/em&gt; where &lt;em&gt;a &amp;gt; b&lt;/em&gt;) using a step of 0.1 (from 100 to 0.1) we have &lt;strong&gt;~34% chance of precision error&lt;/strong&gt;.
Here are some examples:</source>
          <target state="translated">Al restar todos los valores ( &lt;em&gt;a - b&lt;/em&gt; donde &lt;em&gt;a&amp;gt; b&lt;/em&gt; ) usando un paso de 0.1 (de 100 a 0.1) tenemos &lt;strong&gt;~ 34% de probabilidad de error de precisi&amp;oacute;n&lt;/strong&gt; . Aqu&amp;iacute; hay unos ejemplos:</target>
        </trans-unit>
        <trans-unit id="dad29e497d84d7d97e26e14b971f5527c35ad106" translate="yes" xml:space="preserve">
          <source>When we write in decimal, every fraction (specifically, every &lt;em&gt;terminating decimal)&lt;/em&gt; is a rational number of the form</source>
          <target state="translated">Cuando escribimos en decimal, cada fracci&amp;oacute;n (espec&amp;iacute;ficamente, cada &lt;em&gt;decimal final)&lt;/em&gt; es un n&amp;uacute;mero racional de la forma</target>
        </trans-unit>
        <trans-unit id="cb40a8a2fcac0429d8dc60783983d5e8b6477e35" translate="yes" xml:space="preserve">
          <source>When you convert .1 or 1/10 to base 2 (binary) you get a repeating pattern after the decimal point, just like trying to represent 1/3 in base 10.  The value is not exact, and therefore you can't do exact math with it using normal floating point methods.</source>
          <target state="translated">Cuando conviertes .1 o 110 a base 2 (binaria)obtienes un patrón de repetición después del punto decimal,como si intentaras representar 13 en base 10.El valor no es exacto,y por lo tanto no puedes hacer cálculos exactos con él usando los métodos normales de punto flotante.</target>
        </trans-unit>
        <trans-unit id="d4a55fd6552568d32b38f3c40d30b4c2bc522d88" translate="yes" xml:space="preserve">
          <source>Why do these inaccuracies happen?</source>
          <target state="translated">¿Por qué ocurren estas inexactitudes?</target>
        </trans-unit>
        <trans-unit id="66881614284e2ba88332cf86401c026f9088c6ae" translate="yes" xml:space="preserve">
          <source>Writing &lt;code&gt;0.1 + 0.2&lt;/code&gt; in a IEEE 754 binary representation (with colons separating the three parts) and comparing it to &lt;code&gt;0.3&lt;/code&gt;, this is (I've put the distinct bits in square brackets):</source>
          <target state="translated">Escribiendo &lt;code&gt;0.1 + 0.2&lt;/code&gt; en una representaci&amp;oacute;n binaria IEEE 754 (con dos puntos que separan las tres partes) y compar&amp;aacute;ndolo con &lt;code&gt;0.3&lt;/code&gt; , esto es (he puesto los distintos bits entre corchetes):</target>
        </trans-unit>
        <trans-unit id="24836426f0d15e21562f81deb9ad1c23bb7dfa13" translate="yes" xml:space="preserve">
          <source>Written in binary (with colons separating the three parts), the IEEE 754 representations of the values are:</source>
          <target state="translated">Escrito en binario (con dos puntos que separan las tres partes),las representaciones del IEEE 754 de los valores son:</target>
        </trans-unit>
        <trans-unit id="ff2de9d5beb4dd93e3d80141b6eae1dadd2675ee" translate="yes" xml:space="preserve">
          <source>You also need to replace equality tests with comparisons that allow some amount of tolerance, which means:</source>
          <target state="translated">También hay que sustituir las pruebas de igualdad por comparaciones que permitan un cierto grado de tolerancia,lo que significa:</target>
        </trans-unit>
        <trans-unit id="8a0f504f8802330bcd73041e639d23b64060aede" translate="yes" xml:space="preserve">
          <source>You can also check with &lt;code&gt;bc&lt;/code&gt; that -3.14 is also perturbed.  Do not forget to set a &lt;code&gt;scale&lt;/code&gt; factor in &lt;code&gt;bc&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede verificar con &lt;code&gt;bc&lt;/code&gt; que -3.14 tambi&amp;eacute;n est&amp;aacute; perturbado. No olvide establecer un factor de &lt;code&gt;scale&lt;/code&gt; en &lt;code&gt;bc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ff3e42e624592a61f01313f784d510526d8c60" translate="yes" xml:space="preserve">
          <source>You can use it this way:</source>
          <target state="translated">Puedes usarlo de esta manera:</target>
        </trans-unit>
        <trans-unit id="d5be9a6ea2f8a6e508af9e23eaa095f999692ed9" translate="yes" xml:space="preserve">
          <source>You might say let it be 10 in every situation then:</source>
          <target state="translated">Podrías decir que sea 10 en cada situación entonces:</target>
        </trans-unit>
        <trans-unit id="0b6f6f83839ca8e821efbbb35c9e1e1b3662a91c" translate="yes" xml:space="preserve">
          <source>You've just stumbled on a number (3/10) that happens to be easy to represent with the decimal system, but doesn't fit the binary system. It goes both ways (to some small degree) as well: 1/16 is an ugly number in decimal (0.0625), but in binary it looks as neat as a 10,000th does in decimal (0.0001)** - if we were in the habit of using a base-2 number system in our daily lives, you'd even look at that number and instinctively understand you could arrive there by halving something, halving it again, and again and again.</source>
          <target state="translated">Acabas de tropezar con un número (310)que resulta fácil de representar con el sistema decimal,pero que no encaja en el sistema binario.También va en ambos sentidos (en un pequeño grado):116 es un número feo en decimal (0,0625),pero en binario se ve tan bien como una 10.000a en decimal (0,0001)**-si tuviéramos el hábito de usar un sistema numérico de base-2 en nuestra vida diaria,incluso mirarías ese número y comprenderías instintivamente que puedes llegar allí reduciendo algo a la mitad,y otra vez,y otra vez y otra vez.</target>
        </trans-unit>
        <trans-unit id="ceb4d2a3636a0cc03450ad3fabafb42a06fc9c6a" translate="yes" xml:space="preserve">
          <source>Your expected result was &lt;code&gt;0.9&lt;/code&gt; it means you need a result with 1 digit precision in this case.
So you should have used &lt;code&gt;(0.2 + 0.7).tofixed(1)&lt;/code&gt;
but you can't just give a certain parameter to toFixed() since it depends on the given number, for instance</source>
          <target state="translated">Su resultado esperado fue &lt;code&gt;0.9&lt;/code&gt; , significa que necesita un resultado con precisi&amp;oacute;n de 1 d&amp;iacute;gito en este caso. Por lo tanto, deber&amp;iacute;a haber usado &lt;code&gt;(0.2 + 0.7).tofixed(1)&lt;/code&gt; pero no puede simplemente dar un cierto par&amp;aacute;metro a toFixed () ya que depende del n&amp;uacute;mero dado, por ejemplo</target>
        </trans-unit>
        <trans-unit id="ff6c01e4df0a5ca8aefe0c40e07d5e4feff2abb7" translate="yes" xml:space="preserve">
          <source>also note that Math.diff and Math.sum auto-detect the precision to use</source>
          <target state="translated">también hay que tener en cuenta que Math.diff y Math.sum detectan automáticamente la precisión para usar</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2cb33ad31829e0e19a43ec07f7a00e44d6300496" translate="yes" xml:space="preserve">
          <source>and after that it prints a sum, that, when summed with enough precision, it will show the value that really exists in hardware.</source>
          <target state="translated">y después de eso imprime una suma,que,cuando se suma con suficiente precisión,mostrará el valor que realmente existe en el hardware.</target>
        </trans-unit>
        <trans-unit id="2733dda989a75e652de2d2c22f2c0c6c32aceeee" translate="yes" xml:space="preserve">
          <source>and learn that this returns &lt;code&gt;false&lt;/code&gt;.  Why?  Well, as real numbers we have</source>
          <target state="translated">y aprende que esto devuelve &lt;code&gt;false&lt;/code&gt; . &amp;iquest;Por qu&amp;eacute;? Bueno, como n&amp;uacute;meros reales tenemos</target>
        </trans-unit>
        <trans-unit id="99e2d00acf76f763377d20265efa63bd193e4795" translate="yes" xml:space="preserve">
          <source>in 64 bits:</source>
          <target state="translated">en 64 bits:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="efa695af86576c8d47d0d32b2fff911c6f442850" translate="yes" xml:space="preserve">
          <source>the idea is to use Math instead operators to avoid float errors</source>
          <target state="translated">la idea es utilizar las matemáticas en lugar de los operadores para evitar los errores de flotación</target>
        </trans-unit>
        <trans-unit id="0b18dc6530e72b787150c3516e6eb9959c507b37" translate="yes" xml:space="preserve">
          <source>value = (-1)^s * (1.m&lt;sub&gt;51&lt;/sub&gt;m&lt;sub&gt;50&lt;/sub&gt;...m&lt;sub&gt;2&lt;/sub&gt;m&lt;sub&gt;1&lt;/sub&gt;m&lt;sub&gt;0&lt;/sub&gt;)&lt;sub&gt;2&lt;/sub&gt; * 2&lt;sup&gt;e-1023&lt;/sup&gt;</source>
          <target state="translated">valor = (-1) ^ s * (1.m &lt;sub&gt;51&lt;/sub&gt; m &lt;sub&gt;50&lt;/sub&gt; ... m &lt;sub&gt;2&lt;/sub&gt; m &lt;sub&gt;1&lt;/sub&gt; m &lt;sub&gt;0&lt;/sub&gt; ) &lt;sub&gt;2&lt;/sub&gt; * 2 &lt;sup&gt;e-1023&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d39bd96be9502f3ebbfa8d63484dcd808be51d4c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;abs&lt;/code&gt; is the absolute value. &lt;code&gt;myToleranceValue&lt;/code&gt; needs to be chosen for your particular application - and it will have a lot to do with how much &quot;wiggle room&quot; you are prepared to allow, and what the largest number you are going to be comparing may be (due to loss of precision issues). Beware of &quot;epsilon&quot; style constants in your language of choice. These are &lt;em&gt;not&lt;/em&gt; to be used as tolerance values.</source>
          <target state="translated">donde &lt;code&gt;abs&lt;/code&gt; es el valor absoluto. &lt;code&gt;myToleranceValue&lt;/code&gt; debe elegirse para su aplicaci&amp;oacute;n en particular, y tendr&amp;aacute; mucho que ver con la cantidad de &quot;margen de maniobra&quot; que est&amp;aacute; dispuesto a permitir y cu&amp;aacute;l puede ser el n&amp;uacute;mero m&amp;aacute;s grande que va a comparar (debido a la p&amp;eacute;rdida de precisi&amp;oacute;n cuestiones). Tenga cuidado con las constantes de estilo &quot;epsilon&quot; en el idioma que elija. Estos &lt;em&gt;no&lt;/em&gt; deben usarse como valores de tolerancia.</target>
        </trans-unit>
        <trans-unit id="636e0e25e23956183d01befb3188bbeda7dd79ab" translate="yes" xml:space="preserve">
          <source>whereas the binary representation of 0.3 is:</source>
          <target state="translated">mientras que la representación binaria de 0,3 es:</target>
        </trans-unit>
        <trans-unit id="a54c3657d718a97760530877785faf3f0af60915" translate="yes" xml:space="preserve">
          <source>which is, of course, different from &lt;code&gt;1.00000000&lt;/code&gt; by exactly &lt;code&gt;0.00000001&lt;/code&gt;.</source>
          <target state="translated">que es, por supuesto, diferente de &lt;code&gt;1.00000000&lt;/code&gt; por exactamente &lt;code&gt;0.00000001&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df6fbb7d0f8bd941c592564fd908669aafff2758" translate="yes" xml:space="preserve">
          <source>which only differs from the binary representation of the sum of 0.1 and 0.2 by 2&lt;sup&gt;-54&lt;/sup&gt;.</source>
          <target state="translated">que solo difiere de la representaci&amp;oacute;n binaria de la suma de 0.1 y 0.2 por 2 &lt;sup&gt;-54&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="054a411e4463eeebff1fb0a84361000a6d7e65a7" translate="yes" xml:space="preserve">
          <source>which, truncated to seven bits, is &lt;code&gt;0.0100110&lt;/code&gt;, and these differ by exactly &lt;code&gt;0.0000001&lt;/code&gt;.</source>
          <target state="translated">que, truncado a siete bits, es &lt;code&gt;0.0100110&lt;/code&gt; , y estos difieren exactamente en &lt;code&gt;0.0000001&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b30c99097f9b6a416b08022ec4f86195a695b8b" translate="yes" xml:space="preserve">
          <source>while on the other hand,</source>
          <target state="translated">mientras que por otro lado,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
