<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1568091">
    <body>
      <group id="1568091">
        <trans-unit id="811ef1a393584a7d8880f3ef855143bdd7cae4ff" translate="yes" xml:space="preserve">
          <source>(Time 1 is the direct way, Time 2 is the getter)</source>
          <target state="translated">(時間1は直通、時間2はゲッター)</target>
        </trans-unit>
        <trans-unit id="2674e860c37ef14352b7760e1bb68edd1812e340" translate="yes" xml:space="preserve">
          <source>1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ &quot;example&quot; code you'll notice me using &lt;code&gt;struct&lt;/code&gt; instead of &lt;code&gt;class&lt;/code&gt; everywhere.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1）データと動作を備えた基本オブジェクトのすべてのパブリックメンバーから始めます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これが、すべてのC ++の「サンプル」コード&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どこでも&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;なく&lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用していることに気付くのはこのためです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9afae1edbdd3713190c6b92e13771fa366eb26a3" translate="yes" xml:space="preserve">
          <source>10 million cycles:</source>
          <target state="translated">1000万サイクル。</target>
        </trans-unit>
        <trans-unit id="164834c50a9442cbf6258a5472c287b312c938dc" translate="yes" xml:space="preserve">
          <source>2) When an object's internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal &lt;code&gt;std::list&lt;/code&gt; in some kind of order), accessor type functions are written.  Because I'm programming by myself, I don't always set the member &lt;code&gt;private&lt;/code&gt; right away, but somewhere down the evolution of the class the member will be &quot;promoted&quot; to either &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2）データメンバーに対するオブジェクトの内部動作が十分に複雑になると（たとえば、内部&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をなんらかの順序で保持したい場合）、アクセサー型関数が記述されます。私は自分でプログラミングしているので、メンバーを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すぐに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;設定するわけではありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、クラスの進化のどこかで、メンバーは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;protected&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「昇格」されます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7892b3b7150042db597eb83df3fa2fc4d4a5356e" translate="yes" xml:space="preserve">
          <source>3) Classes that are fully fleshed out and have strict rules about their internals (ie &lt;em&gt;they&lt;/em&gt; know exactly what they are doing, and you are not to &quot;fuck&quot; (technical term) with its internals) are given the &lt;code&gt;class&lt;/code&gt; designation, default private members, and only a select few members are allowed to be &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3）完全に具体化されており、内部について厳格なルールがあるクラス（つまり&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;何をしているのかを正確に把握しており&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、内部で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「ファック」（専門用語）してはならない）には、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定、デフォルトのプライベートメンバー&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が与えられ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます、そして限られた数のメンバーだけが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;public&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;許可されています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b75455e8497af8e0568b85b084a32699e8ec694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Here are the some of the reasons I am aware of:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここに私が知っているいくつかの理由があります：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3cca966ff39b9fe1ddc20c0c05c5ab85772f223b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;Oh... cool, I guess?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クライアント&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：「あら&amp;hellip;&amp;hellip;かっこいいね？」&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da3e4c734e73e93fbd221e07e4b36c403db2d6c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;What can I do with an object of this class?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クライアント&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：「このクラスのオブジェクトで何ができるか？」&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="255733b7d5ec2727df67865b9399e6f16913e0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code to the interface, not the implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実装ではなくインターフェースへのコード&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3009decd56c1847ecaff29ac42deaeb96d7e5ed9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Designer&lt;/strong&gt;: &quot;You can read and write several variables.&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;デザイナー&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：「いくつかの変数を読み書きできます。」&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9327bbc5dd989bbd9c8de05113c4531259a85e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getter Methods:&lt;/strong&gt;&lt;em&gt;We can get access to private variables.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッターメソッド：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プライベート変数にアクセスできます。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49c576902394b2f88aa9c23003d5ca3259732bc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getters&lt;/strong&gt; and &lt;strong&gt;setters&lt;/strong&gt; are used to implement two of the fundamental aspects of Object Oriented Programming which are:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッター&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;セッター&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、オブジェクト指向プログラミングの2つの基本的な側面を実装するために使用されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75bf09d32278474950179c8e319e9ebd15d37d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interfaces only specify methods, not fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インターフェイスはフィールドではなくメソッドのみを指定します&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9db04f55b8e825e0380143c8c6459e9bd8ff383" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setter Methods:&lt;/strong&gt;&lt;em&gt;We can modify private fields.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;セッターメソッド：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プライベートフィールドを変更できます。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e77ba06d495a30414d7393b72695c1a32bd8ea5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are actually &lt;em&gt;many good reasons&lt;/em&gt; to consider using accessors&lt;/strong&gt; rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際に&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、クラスのフィールドを直接公開するのではなく、&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アクセサーの使用を検討する&lt;/font&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの正当な理由&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;があります&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -カプセル化の議論だけでなく、将来の変更を容易にすることもあります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9b3b8c7d55f7b60e6b667f7483bd9cd9c8e936e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* Even for that simple class, you may not necessarily want to allow setting the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values. If this is really a class, shouldn't it have methods like &lt;code&gt;translate&lt;/code&gt;, &lt;code&gt;rotate&lt;/code&gt;, etc.? If it's only a class because your language doesn't have records/structs/named tuples, then this isn't really a question of OO&amp;hellip;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;*その単純なクラスでも、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;設定を許可したくない場合があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これが本当にクラスである場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;translate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rotate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドが必要ではありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;か？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;言語にレコード/構造体/名前付きタプルがないためクラスだけの場合、これは実際にはオブジェクト指向の問題ではありません&amp;hellip;&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9f1c7ed63a610cca03dbe1fb9a5969b1641f70d2" translate="yes" xml:space="preserve">
          <source>A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it's clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.</source>
          <target state="translated">パブリックフィールドは、フィールドを返してそれに代入する以外は何もしないゲッターセッターのペアよりも悪くない。まず、(ほとんどの言語で)機能的な違いがないことは明らかです。違いがあるとすれば、保守性や可読性などの他の要素にあるはずです。</target>
        </trans-unit>
        <trans-unit id="9ef49733b07a04ac879a3131cf59a6bb592d931f" translate="yes" xml:space="preserve">
          <source>A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).</source>
          <target state="translated">液体がどのくらい入っていて、その容量が何なのか(ミリリットル単位)を保持している非常にシンプルなクラスです。</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="82749ef4d632eabe207c0f5bfe48e65659005062" translate="yes" xml:space="preserve">
          <source>Accessors and mutators also allow for encapsulation - if you aren't supposed to see the value once its set (perhaps it's set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.</source>
          <target state="translated">アクセサやミューテータはカプセル化も可能にしています。もし値が設定された後に見ることが想定されていない場合 (おそらくコンストラクタで設定され、その後メソッドで使用され、変更されることは想定されていない)、それは誰にも見られません。しかし、他のクラスに見られたり変更されたりすることを許すことができるのであれば、適切なアクセサやミューテータを提供することができます。</target>
        </trans-unit>
        <trans-unit id="a4355e16716c8eb9f55ad860a735f5c6eda863c4" translate="yes" xml:space="preserve">
          <source>Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That's how you can define and maintain useful invariants.</source>
          <target state="translated">このようなクラスにパススルーのゲッターセッターペアを追加しても何の価値もありません。他のクラスは、フィールドが既に提供している操作だけではなく、意味のある操作を提供すべきです。そうすることで、有用な不変量を定義し、維持することができます。</target>
        </trans-unit>
        <trans-unit id="3d5035c0f50aaed825f8024c67607f79c9d6f00e" translate="yes" xml:space="preserve">
          <source>Additionally, this is to &quot;future-proof&quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just &quot;set/get the field&quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.</source>
          <target state="translated">さらに、これはクラスを「将来に備える」ためのものです。特に、フィールドからプロパティへの変更はABIのブレークなので、後になって「フィールドをsetgetする」以上のロジックが必要だと判断した場合、ABIをブレークする必要がありますが、これはもちろんクラスに対して既にコンパイルされている他の何かの問題を引き起こします。</target>
        </trans-unit>
        <trans-unit id="81c4e73e61dcb9ef881221a8e3e6e510aaafccd3" translate="yes" xml:space="preserve">
          <source>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</source>
          <target state="translated">継承者がプロパティの振る舞いのセマンティクスを変更し、ゲッターセッターメソッドをオーバーライドして公開することを可能にします。</target>
        </trans-unit>
        <trans-unit id="57a93d1fb290ddf7a1dbf6a3c46ddb1f2bd05da4" translate="yes" xml:space="preserve">
          <source>Allowing the getter/setter to be passed around as lambda expressions rather than values.</source>
          <target state="translated">ゲッターセッターを値ではなくラムダ式として渡せるようにします。</target>
        </trans-unit>
        <trans-unit id="43274d4e786c79c30fbd5d48e83bf0480818a226" translate="yes" xml:space="preserve">
          <source>Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.</source>
          <target state="translated">また、サイクルの量を変えれば、通常の方法よりもゲッターが少し速くなります。これがお役に立てたなら幸いです。</target>
        </trans-unit>
        <trans-unit id="033534469fa80b3c8584bdbf1263c23f9a826be5" translate="yes" xml:space="preserve">
          <source>Also, it's important to follow the idioms of the language (or framework) you're using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that's bad. Some languages have stronger cultures around their conventions than others.&amp;mdash;and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、使用している言語（またはフレームワーク）のイディオムに従うことも重要です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;美しいRubyスタイルのコードをC＃で書くと、あなた以外の経験豊富なC＃開発者はそれを読むのに苦労するでしょう、それは悪いことです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一部の言語は、その慣習に関して他の言語よりも強い文化を持っています。そして、慣用的なゲッターがいかにスペクトルの反対側にあるJavaとPythonが偶然にも2つの最も強い文化を持っているのは偶然ではないかもしれません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d11a9b94f688fd1bb3e8236ba806a1a0de41e921" translate="yes" xml:space="preserve">
          <source>An oft-mentioned advantage of getter/setter pairs, isn't. There's this claim that you can change the implementation and your clients don't have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don't even need to know about it. However, adding validation to a setter is a change to its preconditions, &lt;strong&gt;a violation of the previous contract&lt;/strong&gt;, which was, quite simply, &quot;you can put anything in here, and you can get that same thing later from the getter&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッター/セッターのペアのよく言われる利点はそうではありません。実装を変更でき、クライアントを再コンパイルする必要がないという主張があります。おそらく、セッターを使用すると、検証などの機能を後で追加でき、クライアントはそれについて知る必要すらありません。ただし、検証をセッターに追加すると、前提条件が変更され&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、以前のコントラクトに違反します&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これは、簡単に言うと、「ここに何でも入れることができ、後でゲッターから同じものを取得できる」ということです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0528fa85939d91318183d46b3de68fa50d141cc4" translate="yes" xml:space="preserve">
          <source>And all these can have different ways to handle various whoopsies. The Bottle just checks and if it's overflowing it throws a RuntimeException. But that might be the wrong thing to do. 
(There is a useful discussion to be had about error handling, but I'm keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )</source>
          <target state="translated">そして、これらはすべて、様々なwhoopssiを処理するための異なる方法を持つことができます。ボトルはチェックするだけで、溢れている場合はRuntimeExceptionをスローします。しかし、それは間違っているかもしれません。(エラー処理については有益な議論がありますが、ここでは意図的に非常にシンプルにしています。コメント欄の人たちは、この単純なアプローチの欠点を指摘してくれるでしょう。))</target>
        </trans-unit>
        <trans-unit id="b3709a8d644d6848cb9e1e1b2612c33a14d466f8" translate="yes" xml:space="preserve">
          <source>And yes, it seems like we go from a very simple idea to getting much better answers quickly.</source>
          <target state="translated">そして、そうですね、非常に単純なアイデアから、より良い答えをすぐに得られるようになるようです。</target>
        </trans-unit>
        <trans-unit id="8c0adc3715c9771354c8ce3bffb1a2caa8b06842" translate="yes" xml:space="preserve">
          <source>Any validation you perform in there can only be context free, which validation rarely is in practice.</source>
          <target state="translated">そこで実行される検証はすべてコンテキストフリーであることができますが、実際にはそのような検証はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="47b2dd5b5d660068e61383ca22ea5c24356d49a6" translate="yes" xml:space="preserve">
          <source>Anywhere a value can be used, a method that returns that value can be added. Instead of:</source>
          <target state="translated">値を使用できる場所であれば、その値を返すメソッドを追加することができます。の代わりに</target>
        </trans-unit>
        <trans-unit id="ac6f0e579cd82854d73b7ba5e3dee370470c5bf1" translate="yes" xml:space="preserve">
          <source>As for the &quot;what if I want to change my implementation later?&quot; question (which is repeated multiple times in different wording in both the OP's question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn't support that. So this is really just the same case again.</source>
          <target state="translated">後から実装を変更したい場合は?&quot;という質問については(OPの質問と受け入れられた回答の両方で異なる言葉で何度も繰り返されています)、「実装を変更したい場合は?もし本当に純粋な実装の変更で、属性から始めたのであれば、インターフェースに影響を与えずにプロパティに変更することができます。もちろん、あなたの言語がそれをサポートしていない場合は別です。ですから、これは本当にまた同じケースです。</target>
        </trans-unit>
        <trans-unit id="43cacfbdc83927cc4b2aad1396ab0622fbf9274d" translate="yes" xml:space="preserve">
          <source>Because 2 weeks (months, years) from now when you realize that your setter needs to do &lt;strong&gt;more&lt;/strong&gt; than just set the value, you'll also realize that the property has been used directly in 238 other classes :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2週間（月、年）後、セッターが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値を設定する&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以上の&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことを行う必要があることに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;気づくと、プロパティが他の238のクラスで直接使用されていることにも気付くでしょう:-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e510c63de41dc0facb98c85d5c568e3eeeafd444" translate="yes" xml:space="preserve">
          <source>Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don't. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don't fight them.</source>
          <target state="translated">人間の読者以外にも、規則に従うことを要求するライブラリやツールがあり、従わないと生活が苦しくなります。Interface BuilderウィジェットをObjCプロパティ以外のものにフックしたり、ゲッターを使わずに特定のJavaモッキングライブラリを使ったりすることは、あなたの生活をより困難にしているだけです。ツールがあなたにとって重要なものであるならば、それらと争う必要はありません。</target>
        </trans-unit>
        <trans-unit id="fac3c0dab4aeb3d8c561a0f4789de6b3ef9c2a67" translate="yes" xml:space="preserve">
          <source>But nobody is ever doing general OO design. They're doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.</source>
          <target state="translated">しかし、誰も一般的な OO デザインをしているわけではありません。彼らがやっているのは、特定の言語での設計と実装です。そして、いくつかの言語では、ゲッターやセッターが役に立たないことはありません。</target>
        </trans-unit>
        <trans-unit id="34bfb1e4e8fe780f6179a91f408e1aeba2e095cb" translate="yes" xml:space="preserve">
          <source>But there's another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn't that be better? Since interfaces demand methods, this is also a good thing.</source>
          <target state="translated">しかし、もう一つ問題があります。もしボトルが1種類の容器にすぎなかったら?複数の容器があって、それぞれの容量や量の液体が入っていたらどうでしょうか?もしインターフェイスを作ることができれば、プログラムの残りの部分がそのインターフェイスを受け入れることができます。その方がいいのではないでしょうか?インターフェースはメソッドを要求するので、これもまた良いことです。</target>
        </trans-unit>
        <trans-unit id="5f581816971f55a0fe7fe755c1439b557642dd88" translate="yes" xml:space="preserve">
          <source>Code &lt;em&gt;evolves&lt;/em&gt;.  &lt;code&gt;private&lt;/code&gt; is great for when &lt;em&gt;you need data member protection&lt;/em&gt;.  Eventually all classes should be sort of &quot;miniprograms&quot; that have a well-defined interface &lt;em&gt;that you can't just screw with the internals of&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コードは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;進化し&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データメンバーの保護が必要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;な場合に最適です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。結局のところ、すべてのクラスは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、の内部をねじ込むことができない&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明確に定義されたインターフェース&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;持つ一種の「ミニプログラム」で&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ある必要があります&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77e195f98a65d1f5b54c0c97c7133a6067f84b7e" translate="yes" xml:space="preserve">
          <source>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</source>
          <target state="translated">プロパティのライフタイムとメモリ管理(廃棄)セマンティクスを制御します。</target>
        </trans-unit>
        <trans-unit id="451d8c398dac194d41c458e0b0ad881903b0f15e" translate="yes" xml:space="preserve">
          <source>Depends on your language.  You've tagged this &quot;object-oriented&quot; rather than &quot;Java&quot;, so I'd like to point out that ChssPly76's answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:</source>
          <target state="translated">あなたの言語に依存します。あなたはこれを「Java」ではなく「オブジェクト指向」とタグ付けしているので、ChssPly76さんの答えは言語に依存していることを指摘しておきます。例えばPythonでは、ゲッターやセッターを使う理由がありません。挙動を変更する必要がある場合は、基本的な属性アクセスの周りにゲッターとセッターをラップするプロパティを使用することができます。このようなものです。</target>
        </trans-unit>
        <trans-unit id="59b09c675389e93fb718c3607a2b33d8ced3dba3" translate="yes" xml:space="preserve">
          <source>Don't use getters setters unless needed for your current delivery I.e. Don't think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.</source>
          <target state="translated">現在の配送に必要な場合を除き、ゲッターセッターを使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="4811f53244f0f4eb1f508c3dce99ba627e7afab2" translate="yes" xml:space="preserve">
          <source>EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they're not as easy to understand if you're a newbie. We were all newbies, so I thought I'd try my hand at a more newbie friendly answer.</source>
          <target state="translated">EDIT:プログラミングを学んでいる人たちが何人もこの質問をしているので、私はこの質問に答えたのですが、ほとんどの回答は技術的には非常に優れているのですが、初心者の方にはわかりにくいものです。みんな初心者なので、もう少し初心者に優しい回答をしてみようと思いました。</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="045c9ac03fcd3840d51b0f2e3b7fc9b7a8a9f185" translate="yes" xml:space="preserve">
          <source>Encapsulation mantra</source>
          <target state="translated">マントラのカプセル化</target>
        </trans-unit>
        <trans-unit id="08518ebb827eeba5eb31bb4abc223904fb6d8e7c" translate="yes" xml:space="preserve">
          <source>Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.</source>
          <target state="translated">プロパティの取得または設定に関連する動作のカプセル化-これにより、後から追加機能(バリデーションなど)をより簡単に追加することができます。</target>
        </trans-unit>
        <trans-unit id="a273aa55c91241aef5cbe7c904175deb629c3048" translate="yes" xml:space="preserve">
          <source>Even if your language does have properties, there may be cases where they're insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can't substitute a computed property for an attribute.</source>
          <target state="translated">あなたの言語がプロパティを持っていたとしても、それが不十分であったり、不適切な場合があるかもしれません。例えば、サブクラスが属性のセマンティクスを制御できるようにしたい場合、動的アクセスのない言語では、サブクラスは計算されたプロパティを属性の代わりにすることはできません。</target>
        </trans-unit>
        <trans-unit id="e83595b7e6ea6eac5ba12ba0e0ea2bbad5c8a4f7" translate="yes" xml:space="preserve">
          <source>Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.</source>
          <target state="translated">ゲッターメソッドやセッターメソッドは便利ですが、使いすぎないように注意する必要があります。また、ゲッターメソッドはパブリックメンバのようにクラスの実装へのアクセスを提供します。OOP の実践では、クラス内のプロパティに直接アクセスすることは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="d63ca1863a03a6cc66be541e8b13351b917e9595" translate="yes" xml:space="preserve">
          <source>Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method</source>
          <target state="translated">ゲッターメソッドとセッターメソッドに新しい機能が追加されていなくても、後から考えを変えて、そのメソッドを</target>
        </trans-unit>
        <trans-unit id="67bba4f9917627abec7de3eae66ae2f912a2559b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;foo&lt;/code&gt; was public, I could easily set it to &lt;code&gt;null&lt;/code&gt; and then someone else could try to call a method on the object. But it's not there anymore! With a &lt;code&gt;setFoo&lt;/code&gt; method, I could ensure that &lt;code&gt;foo&lt;/code&gt; was never set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がパブリックの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、簡単に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に設定して、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他の誰かがオブジェクトのメソッドを呼び出そうとする可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、それはもうありません！&lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFoo&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法、私がいることを保証でき&lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; が&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に設定されていませんでした&lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476a63abfc2fa3c03aedf4736d5d9942e91d901f" translate="yes" xml:space="preserve">
          <source>From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: &lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト指向の設計の観点からは、クラスのカプセル化を弱めることにより、両方の選択肢がコードのメンテナンスに悪影響を与える可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ディスカッションについては、次の優れた記事を&lt;/font&gt;&lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ご覧&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。http&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//typicalprogrammer.com/？p = 23&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a74b1d741c07f0d10578559f597f6187841258b7" translate="yes" xml:space="preserve">
          <source>From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you've written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.</source>
          <target state="translated">OO理論的には、ゲッターやセッターは無用の長物です。クラスのインターフェイスはそれが何をするかであって、その状態が何であるかではありません。(そうでない場合、あなたは間違ったクラスを書いていることになります。)非常に単純なケースでは、クラスが何をするかというと、例えば点を長方形の座標で表現するだけで、*属性はインターフェースの一部です。しかし、非常に単純なケース以外では、属性もゲッターもセッターもインターフェースの一部ではありません。</target>
        </trans-unit>
        <trans-unit id="57ae158f2e8c761e3b5b8bb16e7dccf2d8f722c4" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.</source>
          <target state="translated">ゲッターメソッドとセッターメソッドはアクセサメソッドであり、一般的にはプライベートクラスのメンバを変更するためのパブリックインターフェースであることを意味します。ゲッターメソッドとセッターメソッドを使用してプロパティを定義します。ゲッターメソッドとセッターメソッドは、クラス内でメソッドとして定義していても、クラス外のプロパティとしてアクセスします。クラス外のプロパティは、クラス内のプロパティ名とは異なる名前を持つことができます。</target>
        </trans-unit>
        <trans-unit id="aee376df07aa660dacecd6260f852a6d918c4cd1" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are public interfaces to access private class members.</source>
          <target state="translated">ゲッターメソッドとセッターメソッドは、プライベートクラスのメンバにアクセスするためのパブリックインターフェースです。</target>
        </trans-unit>
        <trans-unit id="cba3e268c215d8706586fc9b9c009cffacae2d3a" translate="yes" xml:space="preserve">
          <source>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</source>
          <target state="translated">ゲッターとセッターは異なるアクセスレベルを許可することができます。</target>
        </trans-unit>
        <trans-unit id="a06c2f62c876887f1c33b514ac9a69553b2b6392" translate="yes" xml:space="preserve">
          <source>Great! And now we just change Bottle to this:</source>
          <target state="translated">いいね!そして今、我々はボトルをこれに変更します。</target>
        </trans-unit>
        <trans-unit id="de8d815e48132f09b9bca3cbd23f2f97e119a145" translate="yes" xml:space="preserve">
          <source>Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.</source>
          <target state="translated">ここでは、公開属性とは異なり、フルネームの実装詳細はユーザーから隠されており、ユーザーが直接アクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="3fa394821ab09cbccd5563100429404ca95e6440" translate="yes" xml:space="preserve">
          <source>Hiding the internal representation of the property while exposing a property using an alternative representation.</source>
          <target state="translated">代替表現を使用してプロパティを公開しながら、プロパティの内部表現を隠す。</target>
        </trans-unit>
        <trans-unit id="d2f4f5cef8a9ea91e08ca99ee45e39ac9dcd0ebe" translate="yes" xml:space="preserve">
          <source>I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class's evolution.</source>
          <target state="translated">このアプローチにより、クラスの進化の初期段階で多くのデータメンバーがマイグレーションされたり、シフトされたりしたときに、その場に座って宗教的にゲッターを書く必要がないことに気付きました。</target>
        </trans-unit>
        <trans-unit id="7ac905efee55cbf685e08af0da10c6d4468cd4fe" translate="yes" xml:space="preserve">
          <source>I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn't always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of &quot;slow&quot;, so you don't want to make a web service call if you don't have to.</source>
          <target state="translated">あるプロジェクトのベースページクラスで、いくつかの異なるウェブサービスコールからデータをロードしていたのですが、それらのウェブサービスコールのデータがすべての子ページで使われているとは限りませんでした。ウェブサービスは、あらゆる利点のために、「遅い」という新しい定義を開拓しているので、必要がなければウェブサービスコールをしたくありません。</target>
        </trans-unit>
        <trans-unit id="fec0ce430c9b50fa6a42a74bb5cc7bbe5070bd9d" translate="yes" xml:space="preserve">
          <source>I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.</source>
          <target state="translated">私は大規模なシステムをゲッター・セッターなしで書いていて、アクセス修飾子といくつかのメソッドだけでビズロジックを検証しています。あなたが絶対に必要な場合。何かを使用してください。</target>
        </trans-unit>
        <trans-unit id="b23c3487d24d1993bf58de911e47e2492ae65d64" translate="yes" xml:space="preserve">
          <source>I know it's a bit late, but I think there are some people who are interested in performance.</source>
          <target state="translated">遅くなりましたが、パフォーマンスに興味のある方もいらっしゃると思います。</target>
        </trans-unit>
        <trans-unit id="db14da99dc1a19fe0a1cec21c694b1166cec8396" translate="yes" xml:space="preserve">
          <source>I moved from public fields to getters, and now the getters check the cache, and if it's not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.</source>
          <target state="translated">公開フィールドからゲッターに移行し、ゲッターがキャッシュをチェックして、キャッシュがなければウェブサービスを呼び出すようになりました。そのため、少しのラッピングで、多くのウェブサービスの呼び出しを防ぐことができました。</target>
        </trans-unit>
        <trans-unit id="d44fc766ecbf5e63030bb952d02b5d6adbd46593" translate="yes" xml:space="preserve">
          <source>I spent quite a while thinking this over for the Java case, and I believe the real reasons are:</source>
          <target state="translated">Javaの件でかなりの時間をかけて考えたのですが、本当の理由はこれだと思います。</target>
        </trans-unit>
        <trans-unit id="2889b32bfcc03c8e80e260ed4b4716b29ae177b9" translate="yes" xml:space="preserve">
          <source>I would just like to throw the idea of annotation : @getter and @setter. With @getter, you should be able to obj = class.field but not class.field = obj. With @setter, vice versa. With @getter and @setter you should be able to do both. This would preserve encapsulation and reduce the time by not calling trivial methods at runtime.</source>
          <target state="translated">私はちょうどアノテーションのアイデアを投げたいと思います。ゲッターとセッター。ゲッターでは、obj=class.fieldはできるはずだが、class.field=objはできない。setterの場合はその逆です。ゲッターとセッターを使うと、両方ができるようになります。これにより、カプセル化を維持し、実行時につまらないメソッドを呼び出さないようにすることで、時間を短縮することができます。</target>
        </trans-unit>
        <trans-unit id="448e5ff21f920e7e7eae20ce3fd54ad0522d451c" translate="yes" xml:space="preserve">
          <source>I would not take advantage of ignorance of business owners of deep technical know how just because I think it's correct or I like the approach.</source>
          <target state="translated">私は、自分が正しいと思ったり、アプローチが好きだからといって、深い技術的なノウハウを持つ経営者の無知を利用することはありません。</target>
        </trans-unit>
        <trans-unit id="91a599d9c25706ea81b0f073fcd9ead9e1d48f03" translate="yes" xml:space="preserve">
          <source>I'll leave the definition of the BottleOverflowException as an exercise to the reader.</source>
          <target state="translated">BottleOverflowExceptionの定義は読者の方に練習としてお任せします。</target>
        </trans-unit>
        <trans-unit id="c0cfd8d8587de574184a35bdea413f3d36872445" translate="yes" xml:space="preserve">
          <source>I've done a little performance test. I wrote a class &quot;NumberHolder&quot; which, well, holds an Integer. You can either read that Integer by using the getter method
&lt;code&gt;anInstance.getNumber()&lt;/code&gt; or by directly accessing the number by using &lt;code&gt;anInstance.number&lt;/code&gt;. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I've got the following result:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;少しパフォーマンステストを行いました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Integerを保持するクラス「NumberHolder」を作成しました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたは、どちらかのgetterメソッドを使用して、その整数を読み取ることができ &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.getNumber()&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直接使用して番号にアクセスすることにより&lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.number&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私のプログラムは、両方の方法で1,000,000,000回数値を読み取ります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このプロセスが5回繰り返され、時間が印刷されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次の結果が得られました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0978c43bc2b11a6a993b548afff0b3b5ca45a92" translate="yes" xml:space="preserve">
          <source>If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, &lt;em&gt;no contract&lt;/em&gt;. Is that really object-oriented design? If all the class has is those getters and setters, it's just a dumb data holder, and dumb data holders should look like dumb data holders:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスがすべてのフィールドに対してこれらのダムゲッターとセッターを持っている場合、そのクラスは不変条件がまったくなく、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コントラクト&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それは本当にオブジェクト指向のデザインですか？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのクラスにそれらのゲッターとセッターがある場合、それは単なるデータホルダーであり、ダムデータホルダーはダムデータホルダーのように見えるはずです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46fb1f117749485f93dfde52629c12a6592e5f3e" translate="yes" xml:space="preserve">
          <source>If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I'm not 100% clear on how:</source>
          <target state="translated">ゲッターとセッターが単純なゲッター以上のことをしているのなら、これはすぐにわかるのですが、どのようにすればいいのか100%はわかりません。</target>
        </trans-unit>
        <trans-unit id="949e9da0978aaee4523cbb0c409b2bf0b89c3805" translate="yes" xml:space="preserve">
          <source>If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. &lt;em&gt;That's the exact opposite of encapsulation&lt;/em&gt; If that field could not really be set to anything from the start, why wasn't the validation there from the start?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それが契約ではなかった場合、インターフェイスはクライアントがオブジェクトを無効な状態にすることを許可していました。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それはカプセル化の正反対です。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのフィールドを最初から実際に何にも設定できない場合、なぜ最初から検証が行われなかったのですか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d442a6315e08af677c7d3f5fd084eb11ecca9ce5" translate="yes" xml:space="preserve">
          <source>If your language doesn't have properties, then the only way to represent something that's conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.</source>
          <target state="translated">あなたの言語がプロパティを持たない場合、概念的には属性ですが、実際に計算されたり検証されたりするものを表現する唯一の方法は、ゲッターやセッターを使うことです。</target>
        </trans-unit>
        <trans-unit id="c75e6d8a92da8554d6134d8d780910766638384b" translate="yes" xml:space="preserve">
          <source>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</source>
          <target state="translated">プロパティゲッターセッターに対して動作するように設計されたライブラリとの相互運用性が向上しました。</target>
        </trans-unit>
        <trans-unit id="a045af26b3882dcd948db97f36b10344affa5eda" translate="yes" xml:space="preserve">
          <source>In a pure object-oriented world getters and setters is a &lt;strong&gt;terrible anti-pattern&lt;/strong&gt;. Read this article: &lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;Getters/Setters. Evil. Period&lt;/a&gt;. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;純粋なオブジェクト指向の世界では、ゲッターとセッターは&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ひどいアンチパターン&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この記事を読む：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッター/セッター。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;悪の。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;期間&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;簡単に言えば、データ構造としてオブジェクトについて考えることをプログラマに奨励し、このタイプの考え方は純粋な手続き型（COBOLやCのような）です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクト指向言語では、データ構造はなく、動作を公開するオブジェクトのみです（属性/プロパティではありません！）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60ede22798c8886c1279c94029a7d8fbdb115073" translate="yes" xml:space="preserve">
          <source>In an object oriented language the methods, and their access modifiers, declare the interface for that object. Between the constructor and the accessor and mutator methods it is possible for the developer to control access to the internal state of an object. If the variables are simply declared public then there is no way to regulate that access.
And when we are using setters we can restrict the user for the input we need. Mean the feed for that very variable will come through a proper channel and the channel is predefined by us. So it's safer to use setters.</source>
          <target state="translated">オブジェクト指向言語では、メソッドとそのアクセス修飾子がそのオブジェクトのインターフェイスを宣言します。コンストラクタとアクセサメソッドとミューテータメソッドの間で、 開発者はオブジェクトの内部状態へのアクセスを制御することができます。もし変数が単に公開されているだけならば、そのアクセスを制御する方法はありません。また、セッターを使用している場合は、必要な入力に対してユーザーを制限することができます。つまり、その変数へのフィードは適切なチャネルを経由して送られてくることになり、チャネルは事前に定義されています。そのため、セッターを使った方が安全です。</target>
        </trans-unit>
        <trans-unit id="9570686c65057df9d5555a427b45dcb388eb1c6d" translate="yes" xml:space="preserve">
          <source>In languages which don't support &quot;properties&quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.</source>
          <target state="translated">プロパティ」をサポートしていない言語(C++、Java)や、フィールドをプロパティに変更する際にクライアントの再コンパイルが必要な言語(C#)では、getetメソッドを使用した方が修正が容易です。例えば、setFooメソッドにバリデーションロジックを追加しても、クラスのパブリックインターフェースを変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="49c146ae67da9fce98a67aa9876195255bf52355" translate="yes" xml:space="preserve">
          <source>In languages which support &quot;real&quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.</source>
          <target state="translated">リアル」なプロパティをサポートする言語(Python、Ruby、Smalltalkかも?)では、getetメソッドは意味がありません。</target>
        </trans-unit>
        <trans-unit id="9a756c26f5397e6bf09cb6c1e8673c721a0adcdc" translate="yes" xml:space="preserve">
          <source>In layman's terms</source>
          <target state="translated">平たく言えば</target>
        </trans-unit>
        <trans-unit id="03538993fd141670ce7112b8a39c0f3f3dcb7e47" translate="yes" xml:space="preserve">
          <source>In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.</source>
          <target state="translated">つまり、インターフェースでフィールドを指定するには、新しい値を書き込むためのメソッドと、現在の値を読み込むためのメソッドを提供するしかありません。</target>
        </trans-unit>
        <trans-unit id="665cb9197ac6f3430ff52c71c900a99810bbd645" translate="yes" xml:space="preserve">
          <source>Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.</source>
          <target state="translated">このクラスを継承することで、デフォルトの機能をオーバーライドすることができます。言い換えれば、実装を隠すだけでなく一貫性を持たせることで、呼び出し元を本当に混乱させることができます。</target>
        </trans-unit>
        <trans-unit id="2a50b3b7baaffbe0c2005cff92a6863837d540b1" translate="yes" xml:space="preserve">
          <source>Instead of</source>
          <target state="translated">の代わりに</target>
        </trans-unit>
        <trans-unit id="3a846f258ad5630d87aa074967dac3d41a23874d" translate="yes" xml:space="preserve">
          <source>Instead of doing this, we can create a bean &lt;code&gt;class(Person)&lt;/code&gt; with getter and setter methods.  So tomorrow we can just create objects of this Bean &lt;code&gt;class(Person class)&lt;/code&gt; whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これを行う代わりに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、getterメソッドとsetterメソッド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用してBean &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作成できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明日は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、新しい人物を追加する必要があるときはいつでも&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、このBean &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person class)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オブジェクトを作成できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（図を参照）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、Beanクラスのフィールドとメソッドを再利用しています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebdc6050b1ad6649a3451d6af5910e06b12430e3" translate="yes" xml:space="preserve">
          <source>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</source>
          <target state="translated">パブリック インターフェイスの変更からの絶縁-既存の消費者に影響を与えることなく、実装が変更されてもパブリック インターフェイスを一定に保つことができます。</target>
        </trans-unit>
        <trans-unit id="5ac0c56e853fb8f8f0be1b64596f6b59055cbdae" translate="yes" xml:space="preserve">
          <source>It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don't want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.</source>
          <target state="translated">これは、レイジーロードに便利です。問題のオブジェクトがデータベースに保存されていて、それを必要としない限り取りに行きたくないとします。オブジェクトがゲッターによって取得されている場合、誰かがそれを要求するまで内部オブジェクトはnullにすることができます。</target>
        </trans-unit>
        <trans-unit id="cc4afcf1103ef9d6c53108ff6cc9b9b18bdb3242" translate="yes" xml:space="preserve">
          <source>It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.</source>
          <target state="translated">これは多くの利点を提供します。その一つは、ゲッターセッターの実装を裏で変更することができるということですが、データ型が同じである限り、その値のコンシューマは動作し続けます。</target>
        </trans-unit>
        <trans-unit id="729e36d06a905476ea11f5c8b0c1812a73dff9ce" translate="yes" xml:space="preserve">
          <source>It's a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that's where your memory leak was occurring.</source>
          <target state="translated">セッターであることに気づくまでは、美しくシンプルなコードです。さて、そのセッターをたどってみると、 person.firstName、 person.lastName、 person.isHuman、 person.hassReallyCommonFirstName を設定し、 person.update()を呼び出してデータベースにクエリを送信していることがわかります。あ、そこでメモリリークが発生していましたね。</target>
        </trans-unit>
        <trans-unit id="16aa234236b2a7935d4484df427e10358d69a866" translate="yes" xml:space="preserve">
          <source>Let's say we have this simple class:</source>
          <target state="translated">このシンプルなクラスがあったとしましょう。</target>
        </trans-unit>
        <trans-unit id="c9377946989c0599e694f34e6e15b1e30f95e7bb" translate="yes" xml:space="preserve">
          <source>Lots of people talk about the advantages of getters and setters but I want to play devil's advocate. Right now I'm debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.</source>
          <target state="translated">多くの人がゲッターとセッターの利点について話していますが、私は悪魔の味方をしたいと思っています。今、私は非常に大規模なプログラムをデバッグしています。それは良いことのように見えるかもしれませんが、リバースエンジニアリングの悪夢です。</target>
        </trans-unit>
        <trans-unit id="1d38c1d25ba364989ccc66f32498e40bbffbe427" translate="yes" xml:space="preserve">
          <source>My 2 cents :)</source>
          <target state="translated">私の2セント :)</target>
        </trans-unit>
        <trans-unit id="89bcb9ce512e3a24b71ffdc4db2c607ef7562d71" translate="yes" xml:space="preserve">
          <source>Not only is &lt;code&gt;getVar()&lt;/code&gt; visually noisy, it gives this illusion that &lt;code&gt;gettingVar()&lt;/code&gt; is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of &lt;code&gt;var&lt;/code&gt; is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you're putting up these gates to &quot;protect&quot; something you insist is valuable, (the sanctity of &lt;code&gt;var&lt;/code&gt;) but yet even you concede &lt;code&gt;var&lt;/code&gt;'s protection isn't worth much by the ability for anyone to just come in and &lt;code&gt;set&lt;/code&gt;&lt;code&gt;var&lt;/code&gt; to whatever value they want, without you even peeking at what they are doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getVar()&lt;/code&gt; は&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;視覚的にノイズが多い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;だけでなく&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;gettingVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が実際よりも複雑なプロセスである&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;という錯覚を与え&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。 （クラスライターとして）&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の神聖さをどのように見なす&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;かは、パススルーセッターがある場合、クラスのユーザーを特に混乱させます-主張するものを「保護」するためにこれらのゲートを設置しているようです、（の神聖&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）が、まだも、あなたは認める&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の保護は、誰もがちょうどに来るとするための能力によってあまり価値がない&lt;/font&gt;&lt;/font&gt; &lt;code&gt;set&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたも、彼らがやっていることで覗きせずに、彼らが望むどのような値に。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25ccd6d1abfaa462958a3daf7b3c72739444cbb" translate="yes" xml:space="preserve">
          <source>Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.</source>
          <target state="translated">ここで、これがどれだけロバストになったかに注目してください。ボトルの代わりに LiquidContainer を受け入れることで、コード内のあらゆるタイプのコンテナを扱うことができるようになりました。そして、これらのボトルがどのようにこの種のものを扱うかは、すべて異なる可能性があります。状態が変化したときにディスクに書き出すボトルや、SQLデータベースに保存するボトル、GNUは何を知っているかわからないボトルなどがあります。</target>
        </trans-unit>
        <trans-unit id="ee14a6cb3f5a0e797943e0e6cf7bc7231a57d7bc" translate="yes" xml:space="preserve">
          <source>Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.</source>
          <target state="translated">コードの至る所でパブリックフィールドを使用していて、上記の要件が必要であることに気付いたとしたらどうでしょうか?セッターを修正するのではなく、パブリックフィールドの使用法を探してみてください。</target>
        </trans-unit>
        <trans-unit id="bea2afcb08c47bb55bd603ad05f6ae591ec6e48a" translate="yes" xml:space="preserve">
          <source>On the other hand, if the member is public, the tools don't make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.</source>
          <target state="translated">一方、メンバが公開されている場合、ツールではメンバへの読み書きアクセスをフィルタリングすることができません。そのため、そのメンバーのすべての用途を調べなければなりません。</target>
        </trans-unit>
        <trans-unit id="e9f8893e9b850ac172431cb049bc524b942b2431" translate="yes" xml:space="preserve">
          <source>One advantage of accessors and mutators is that you can perform validation.</source>
          <target state="translated">アクセサやミューテータの利点の一つは、バリデーションを実行できることです。</target>
        </trans-unit>
        <trans-unit id="91b95b7297fe9079d417e879ad5486deb384c22d" translate="yes" xml:space="preserve">
          <source>One aspect I missed in the answers so far, the access specification:</source>
          <target state="translated">これまでの回答の中で見逃していた一面、アクセスの仕様。</target>
        </trans-unit>
        <trans-unit id="10765ac54cefce78aa01ff15a00dd5d27040fc3d" translate="yes" xml:space="preserve">
          <source>One of the basic principals of OO design: &lt;strong&gt;Encapsulation!&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OO設計の基本原則の1つ：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;カプセル化！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b5607ce4ce1a004d9de9e90c6bbff2691c7ffe7" translate="yes" xml:space="preserve">
          <source>One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that's computationally expensive in a property.</source>
          <target state="translated">他にも(プロパティをサポートする言語では)、セッターやゲッターを使用することで、ある操作が非自明であることを暗示することができます。一般的に、プロパティで計算コストの高いことをするのは避けたいものです。</target>
        </trans-unit>
        <trans-unit id="76713a423e5722e517c06fbab6e7cfe5f4817367" translate="yes" xml:space="preserve">
          <source>One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.</source>
          <target state="translated">ゲッターセッターの比較的現代的な利点は、タグ付けされた(インデックス化された)コードエディタでのコードの閲覧が容易になることです。例えば、誰がメンバーを設定しているかを知りたい場合は、セッターの呼び出し階層を開くことができます。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="be9cbb9ed4b5c6641f5aa815d9709c0e21aceeaa" translate="yes" xml:space="preserve">
          <source>Please note also that you can't change the capacity of a bottle. It's now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can't limit the access to touching the innards.</source>
          <target state="translated">また、ボトルの容量変更はできませんのでご注意ください。これで定石になりました。intであれば、それを最終的なものと宣言することで、これを行うことができます。しかし、これがリストだったら、空にしたり、新しいものを追加したりすることができます。内臓に触れるアクセスを制限することはできません。</target>
        </trans-unit>
        <trans-unit id="36c1fd3f265a620d873362378468f7e90e8a20ae" translate="yes" xml:space="preserve">
          <source>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</source>
          <target state="translated">実行時にプロパティが変更されたときのデバッグインターセプトポイントを提供する-プロパティがいつ、どこで特定の値に変更されたかをデバッグするのは、言語によってはこれがないと非常に難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="3e2aa20a27ca3d6e7b23af75afca271955543ebe" translate="yes" xml:space="preserve">
          <source>Put another way: If you believe that consumers of your class shouldn't even know that you have a &lt;code&gt;spam&lt;/code&gt; attribute, much less be able to change it willy-nilly, then giving them a &lt;code&gt;set_spam&lt;/code&gt; method is the last thing you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の言い方をすると、あなたのクラスのコンシューマーがあなたが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;属性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を持っていることすら知らないはずであると信じているなら&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、はるかにそれを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;set_spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に変更することができず、彼らに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;set_spam&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を与える&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことはあなたがしたい最後のことです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2800b08281984434942ba5adcad8919a80ff4cc" translate="yes" xml:space="preserve">
          <source>Say you're looking through hundreds of lines of code and you come across this:</source>
          <target state="translated">何百行ものコードに目を通していて、これに出くわしたとしましょう。</target>
        </trans-unit>
        <trans-unit id="0fe6038ebdf6b117336c04451dc9e3876effcb5c" translate="yes" xml:space="preserve">
          <source>So I program as follows (assuming an &quot;agile&quot; type approach -- ie when I write code not knowing &lt;em&gt;exactly&lt;/em&gt; what it will be doing/don't have time or experience to plan an elaborate waterfall style interface set):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、私は次のようにプログラムします（「アジャイル」タイプのアプローチを想定しています。つまり、コードが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;何をするの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;か&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正確に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;わからない場合/手の込んだウォーターフォールスタイルのインターフェイスセットを計画する時間や経験がない場合）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9eda9489b827ab46566f12f43fa4c89312a585f" translate="yes" xml:space="preserve">
          <source>So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don't already have it.</source>
          <target state="translated">そのため、ゲッターを使えば、子ページごとに必要なものを探す手間が省けます。必要なものがあればゲッターを呼び、まだ持っていない場合はゲッターが探してくれます。</target>
        </trans-unit>
        <trans-unit id="3d0d9303819ce1ab413fffddd86f3afbed876b1f" translate="yes" xml:space="preserve">
          <source>So this is very rarely a general OO question; it's a language-specific question, with different answers for different languages (and different use cases).</source>
          <target state="translated">つまり、これは一般的な OO の質問ではなく、言語固有の質問であり、異なる言語(および異なるユースケース)に対して異なる答えを持っています。</target>
        </trans-unit>
        <trans-unit id="110215a582ce0c01e647e0ab38866bd28ab289f7" translate="yes" xml:space="preserve">
          <source>So you have:</source>
          <target state="translated">そうなんですね。</target>
        </trans-unit>
        <trans-unit id="84327f3567507ed383657990eb8c4dfa0d117dca" translate="yes" xml:space="preserve">
          <source>So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you're making the assumption that all the code assumed the contract for those methods was different.</source>
          <target state="translated">契約を破ってしまったので、コードベース内のすべてのファイルを変更することは避けたいことではありません。もしそれを避けるのであれば、すべてのコードがそれらのメソッドの契約が異なると仮定していることになります。</target>
        </trans-unit>
        <trans-unit id="cbead7356f0d8824aecb16d6a0262b6c772bd6e2" translate="yes" xml:space="preserve">
          <source>Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.</source>
          <target state="translated">いくつかのライブラリはこれを期待していますが、多くはありません-リフレクション、シリアライズ、モックオブジェクトはすべてパブリックフィールドで正常に動作します。</target>
        </trans-unit>
        <trans-unit id="b8d6ec5b172b09312ffab2762d5844c299a54132" translate="yes" xml:space="preserve">
          <source>Suppose we have an Employee class:</source>
          <target state="translated">Employeeクラスがあるとします。</target>
        </trans-unit>
        <trans-unit id="f0b6a967a2c05a11d643d0e4a7aa868f211882c5" translate="yes" xml:space="preserve">
          <source>Suppose we need to store the details of this &lt;code&gt;Person&lt;/code&gt;. This &lt;code&gt;Person&lt;/code&gt; has the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Doing this involves creating methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Now if we need create another person, it becomes necessary to create the methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;sex&lt;/code&gt; all over again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の詳細を保存する必要があるとし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。この&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールドがあります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これを行うには、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドを作成する必要が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。ここで別の人を作成する必要がある場合は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もう一度&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作成する必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3e474c35abac8c8e79adba6fbbab7a5646b1ac0" translate="yes" xml:space="preserve">
          <source>Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:</source>
          <target state="translated">ありがとうございます。さて、ゲッターとセッターを使わない理由を10個(ほぼ)紹介します。</target>
        </trans-unit>
        <trans-unit id="a29e9e3845b5c733ae0c153286a63607107be5fa" translate="yes" xml:space="preserve">
          <source>That said, &lt;em&gt;software development&lt;/em&gt; isn't about setting down that final version of the class as if you're pressing some cast iron statue on the first try.  While you're working with it, code is more like clay.  &lt;strong&gt;It evolves&lt;/strong&gt; as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はいえ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソフトウェア開発&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、最初の試行で鋳鉄の彫像を押しているかのように、クラスの最終バージョンを設定することではありません。作業している間、コードは粘土のようになります。 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それは&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたがそれを開発し、あなたが解決している問題領域についてさらに学ぶ&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;につれて進化&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;します。開発中、クラスは必要以上に相互に影響し合う可能性があり（分解を計画している依存関係）、結合したり、分離したりします。ですから、この論争は、宗教的に書こうとしない人たちにまで及ぶと思います。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fc364b2a3ee96e69b00f590088b9c6ef9c9b632" translate="yes" xml:space="preserve">
          <source>The encapsulation mantra is to make fields private and methods public.</source>
          <target state="translated">カプセル化のマントラは、フィールドを非公開にし、メソッドを公開することです。</target>
        </trans-unit>
        <trans-unit id="24c1a5142c379d866afbafbee078155a76918b88" translate="yes" xml:space="preserve">
          <source>The last three I'm just leaving (N/A or D/C)...</source>
          <target state="translated">最後の3つは出ていくだけなんですが(NAかDCか)...。</target>
        </trans-unit>
        <trans-unit id="7739aadce94ee1918ea9fc44988ea37dc88f140e" translate="yes" xml:space="preserve">
          <source>The two main ones are polymorphism, and validation. Even if it's just a stupid data structure.</source>
          <target state="translated">ポリモーフィズムとバリデーションの2本立てです。くだらないデータ構造だとしても</target>
        </trans-unit>
        <trans-unit id="b9a9f0d33bc8f65d834ed4cf962cc15baead1b5f" translate="yes" xml:space="preserve">
          <source>There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:</source>
          <target state="translated">理由はたくさんあります。私のお気に入りは、動作を変更したり、変数に設定できるものを規制する必要がある場合です。例えば、setSpeed(int speed)メソッドを持っていたとします。しかし、あなたは100の最大速度のみを設定することができます。あなたは次のようなことをします。</target>
        </trans-unit>
        <trans-unit id="524aa01135463f9e6500b1024feefe5ec35bdc47" translate="yes" xml:space="preserve">
          <source>There are reasons to use getters and setters, but if those reasons don't exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (&lt;em&gt;You Ain't Gonna Need It&lt;/em&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッターとセッターを使用する理由はありますが、それらの理由が存在しない場合は、偽のカプセル化の神の名前でゲッターとセッターのペアを作成することは良いことではありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ゲッターまたはセッターを作成する正当な理由には、検証やさまざまな内部表現など、後で行うことができる潜在的な変更としてしばしば言及されるものが含まれます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または、値はクライアントによって読み取り可能であるが書き込み可能ではない（たとえば、辞書のサイズを読み取る）必要があるため、単純なゲッターが適切な選択です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、これらの理由は、後で選択する可能性があるだけでなく、選択するときにも存在するはずです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはYAGNI（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;You Ai n't Gonna Need It&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インスタンスです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b6a012407992d0adb452537e445403437702a64" translate="yes" xml:space="preserve">
          <source>There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.</source>
          <target state="translated">ゲッターメソッドやセッターメソッドを使用する利点は、プロパティのようにアクセスできる洗練された機能を持つメンバーを作成できることなどです。また、読み取り専用のプロパティと書き込み専用のプロパティを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="5c8b73cc0e9f101f3c612ae902d16016395b6ff9" translate="yes" xml:space="preserve">
          <source>There is a good reason to consider using accessors is there is no property inheritance. See next example:</source>
          <target state="translated">アクセサの使用を検討するには、プロパティの継承がないことには理由があります。次の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="527645e19a15fbeecf356eccaa2e86a93ccde33b" translate="yes" xml:space="preserve">
          <source>There's also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.</source>
          <target state="translated">また、誰もが取り組んでいない3つ目のことがあります:ゲッターとセッターはメソッドコールを使用します。つまり、どこでも普通のメソッドと同じように見えるということです。DTO などのための奇妙な固有の構文を持つのではなく、どこでも同じものを使うことができます。</target>
        </trans-unit>
        <trans-unit id="18f126ceaf487ac6623f0c3bab85bbe1bcdce5fe" translate="yes" xml:space="preserve">
          <source>Think simple, easy, add complexity when needed.</source>
          <target state="translated">シンプルに考えて、簡単に、必要に応じて複雑さを追加します。</target>
        </trans-unit>
        <trans-unit id="6515a583147f1258a376ba45fbb548e8c25fcfa1" translate="yes" xml:space="preserve">
          <source>This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you're breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you're breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.</source>
          <target state="translated">この同じ議論は、これらのパススルー型ゲッターセッターペアの他の利点にも当てはまります:後になって設定されている値を変更しようと思ったら、契約を破っていることになります。もし派生クラスのデフォルト機能をオーバーライドした場合、いくつかの無害な変更(ロギングやその他の観測不可能な動作など)を超えた方法で、基底クラスの契約を破っていることになります。これは OO の信条の一つとされる Liskov Substitutability Principle に違反しています。</target>
        </trans-unit>
        <trans-unit id="05f52926063e95fcb6e5b9afd2e3d36583ed0188" translate="yes" xml:space="preserve">
          <source>Those methods are the infamous getter and setter....</source>
          <target state="translated">それらのメソッドは悪名高いゲッターとセッターです...。</target>
        </trans-unit>
        <trans-unit id="09878a7e0e4131a45151cbbe07487842d574b319" translate="yes" xml:space="preserve">
          <source>Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.</source>
          <target state="translated">一目見てローカルなコードを理解することは、ゲッターやセッターが壊れがちな読みやすさの重要な特性です。だからこそ、私はできる限りそれらを避け、それらを使うときには、それらが何をするかを最小限に抑えるようにしています。</target>
        </trans-unit>
        <trans-unit id="0eff2b28e1b8f812b912f6b07b88bbaa84ab213d" translate="yes" xml:space="preserve">
          <source>We use getters and setters:</source>
          <target state="translated">ゲッターとセッターを使います。</target>
        </trans-unit>
        <trans-unit id="5cdeb7802b982ac4d4c3fa7153f628c2667c933a" translate="yes" xml:space="preserve">
          <source>We'd end up with something like:</source>
          <target state="translated">最終的にはこんな感じになるだろう。</target>
        </trans-unit>
        <trans-unit id="10fa626645112c1ff717613b8f6c9dd7afc7b203" translate="yes" xml:space="preserve">
          <source>Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to &lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;STOP OVERUSING THE ACCESSORS&lt;/a&gt;&lt;/strong&gt;, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;まあ、変数/オブジェクトのカプセル化とセキュリティに必要な場合でも、それを追加したいだけです。実際のオブジェクト指向プログラムをコーディングしたい場合は、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ACCESSORSの過剰&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;な使用を&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;やめる&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。それらが本当に必要でない場合、それらは変数を公開する場合とほとんど同じになります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944804080828b744e35ec9aff8cde845d88d15f4" translate="yes" xml:space="preserve">
          <source>Well, you wouldn't expect that to work, right?
You want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.</source>
          <target state="translated">それがうまくいくとは思わないだろう?ある種の正気度チェックが欲しいんだろ?さらに悪いことに、もし私が最大容量を指定しなかったら?やれやれ、問題発生だ</target>
        </trans-unit>
        <trans-unit id="26aac9603bf87fbcf6a374fcbcc4557be0d4afa4" translate="yes" xml:space="preserve">
          <source>What happens when I do:</source>
          <target state="translated">そうするとどうなるのか。</target>
        </trans-unit>
        <trans-unit id="64e4e54e2b623a26f20e0a947aca9d4d41d5f2ff" translate="yes" xml:space="preserve">
          <source>What's the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?</source>
          <target state="translated">ゲッターやセッターを使用する利点は何ですか?</target>
        </trans-unit>
        <trans-unit id="bc1451039d4e3d9bf5c818e53a8cb441a696e201" translate="yes" xml:space="preserve">
          <source>When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you've directly accessed it.</source>
          <target state="translated">単に値を設定して取得するだけでなく、それ以上のことをする必要があることに気づいたときには、フィールドを非公開にするだけで、直接アクセスした場所がすぐにわかります。</target>
        </trans-unit>
        <trans-unit id="9b9c2e122eb7bcbff9d3e55249a64348b7c398a2" translate="yes" xml:space="preserve">
          <source>When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don't want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it's called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won't be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.</source>
          <target state="translated">クラスを書くときには、インスタンス変数をできるだけ多くプライベートにして、それに応じてゲッターメソッドやセッターメソッドを追加することを常に推奨します。これは、ユーザにクラス内の特定の変数を変更させたくない場合がいくつかあるからです。例えば、特定のクラスで作成されたインスタンスの数を追跡するプライベートなスタティックメソッドを持っている場合、ユーザがコードを使ってそのカウンタを変更することは望まないでしょう。コンストラクタ文だけが呼び出されるたびにその変数をインクリメントしなければなりません。このような状況では、プライベートなインスタンス変数を作成し、カウンタ変数に対してのみゲッターメソッドを許可することができます。セッターなしのゲッターを作成することは、クラス内の特定の変数を読み取り専用にする簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="4d347fb8867285cc6a44cfd1b9af0e1b9e8d0d52" translate="yes" xml:space="preserve">
          <source>Whereas the former takes a lot less boilerplate code.</source>
          <target state="translated">前者は、ボイラ・プレート・コードを大幅に減らすことができるのに対し、後者は、ボイラ・プレート・コードを大幅に減らすことができます。</target>
        </trans-unit>
        <trans-unit id="c5b5b0a202322fa3613116e9cbb7a5bf916b32a2" translate="yes" xml:space="preserve">
          <source>Why use getters and setters/accessors</source>
          <target state="translated">なぜゲッターとセッターアクセサを使うのか</target>
        </trans-unit>
        <trans-unit id="a23c4ec681b338f0e1fb882b204499718bf7417d" translate="yes" xml:space="preserve">
          <source>With 10 million cycles, the times are almost the same.
Here are 100 thousand (0.1 million) cycles:</source>
          <target state="translated">1,000万回のサイクルでは、ほぼ同じ回数になります。ここに10万回(0.1万回)のサイクルがあります。</target>
        </trans-unit>
        <trans-unit id="e79ce24276092380db82c3f8e4404e6712bb5095" translate="yes" xml:space="preserve">
          <source>You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.</source>
          <target state="translated">設定されている値を変更することができます-これは、呼び出し元が「そのまま保存してほしい」という値を渡したときに絶対的な悪夢です。</target>
        </trans-unit>
        <trans-unit id="a8c50aac8fd19a1ea4829de498fc35d71feadd5e" translate="yes" xml:space="preserve">
          <source>You can hide the internal representation - fantastic, so you're making sure that all these operations are symmetrical right?</source>
          <target state="translated">内部表現を隠すことができます-素晴らしいですね。</target>
        </trans-unit>
        <trans-unit id="2d6a0b7af8d1a9e87f51afd2f0f83ec48ca965c9" translate="yes" xml:space="preserve">
          <source>You may find more about them in Section 3.5 of &lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;Elegant Objects&lt;/a&gt; (my book about object-oriented programming).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらについては、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;エレガントオブジェクトの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;セクション3.5 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（オブジェクト指向プログラミングに関する私の本）を参照してください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20973387eacad480489a6f5295307c1dee98b593" translate="yes" xml:space="preserve">
          <source>You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.
The results:</source>
          <target state="translated">ご覧の通り、ゲッターの方が(ほとんど)いつも少し速いです。次に、異なるサイクル数で試してみました。100万回の代わりに、1000万回と0.1万回を使ってみました。結果は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a53b89844949d31aba6d3481e30d7696c0678c0c" translate="yes" xml:space="preserve">
          <source>You should use getters and setters when:</source>
          <target state="translated">ゲッターとセッターを使うべきなのは、次のようなときです。</target>
        </trans-unit>
        <trans-unit id="8e50d4342310f2eace5776eb8cfc9f9aa9776c1a" translate="yes" xml:space="preserve">
          <source>You're dealing with something that is conceptually an attribute, but:</source>
          <target state="translated">概念的には属性のようなものを扱っているが</target>
        </trans-unit>
        <trans-unit id="34fca68fe5cf9480f0a80d7c0c498c348f56c7dd" translate="yes" xml:space="preserve">
          <source>You've insulated your public interface from changes under the sheets - if you were designing an interface and weren't sure whether direct access to something was OK, then you should have kept designing.</source>
          <target state="translated">あなたは、シートの下の変更から公開インターフェースを絶縁しました-インターフェースを設計していて、何かに直接アクセスしても良いかどうか分からなかったのであれば、設計を続けるべきでした。</target>
        </trans-unit>
        <trans-unit id="3ceeaa00b6851469e15bf3447e9cd44a83c071a4" translate="yes" xml:space="preserve">
          <source>Your language doesn't have properties (or some similar mechanism, like Tcl's variable traces), or</source>
          <target state="translated">あなたの言語はプロパティを持っていない(または、Tclの変数トレースのようないくつかの類似のメカニズム)、または</target>
        </trans-unit>
        <trans-unit id="5abc216f8d207459eff730de712d1ae80e9f4266" translate="yes" xml:space="preserve">
          <source>Your language's (or sometimes your framework's) idiomatic conventions encourage getters or setters for this use case.</source>
          <target state="translated">あなたの言語 (あるいはフレームワークの)の慣用句は、このユースケースのためのゲッターやセッターを奨励しています。</target>
        </trans-unit>
        <trans-unit id="4a0520484ec8d35c906b8b68216ce4e15364da56" translate="yes" xml:space="preserve">
          <source>Your language's property support isn't sufficient for this use case, or</source>
          <target state="translated">あなたの言語のプロパティのサポートは、この使用ケースでは十分ではありません。</target>
        </trans-unit>
        <trans-unit id="25eba86acee0fb5d6e89e75ccf0a09f1599a6c92" translate="yes" xml:space="preserve">
          <source>better;</source>
          <target state="translated">better;</target>
        </trans-unit>
        <trans-unit id="5f8adcfcb2808cbefe8948076116555c4b76f193" translate="yes" xml:space="preserve">
          <source>faster.</source>
          <target state="translated">faster.</target>
        </trans-unit>
        <trans-unit id="cac0e0595d1759f6424ad536496e3c73b57e1223" translate="yes" xml:space="preserve">
          <source>for members you have only one access specification for both setting and getting</source>
          <target state="translated">メンバーの場合、設定と取得の両方でアクセス指定ができるのは1つだけです。</target>
        </trans-unit>
        <trans-unit id="b648b79089ac12bd90bd3cb58b4439f26f462e08" translate="yes" xml:space="preserve">
          <source>for reusability</source>
          <target state="translated">再利用可能</target>
        </trans-unit>
        <trans-unit id="4618d40a12eec35b743c0d33ec26c6ee634eb9ad" translate="yes" xml:space="preserve">
          <source>for setters and getters you can fine tune it and define it separately</source>
          <target state="translated">セッターとゲッターについては、微調整して個別に定義することができます。</target>
        </trans-unit>
        <trans-unit id="273bf92b0c3d89955ec505b2f149212919216d10" translate="yes" xml:space="preserve">
          <source>is any worse than:</source>
          <target state="translated">よりも悪いことはありません。</target>
        </trans-unit>
        <trans-unit id="dbe1b4e53e52bda3546c73c53e0d35d11158f6a4" translate="yes" xml:space="preserve">
          <source>safer; and</source>
          <target state="translated">より安全に。</target>
        </trans-unit>
        <trans-unit id="22d6eb61e8eb4da06f77da4c904a9784e7917342" translate="yes" xml:space="preserve">
          <source>to perform validation in later stages of programming</source>
          <target state="translated">プログラミングの後の段階で検証を行うために</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
