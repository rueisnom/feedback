<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1568091">
    <body>
      <group id="1568091">
        <trans-unit id="811ef1a393584a7d8880f3ef855143bdd7cae4ff" translate="yes" xml:space="preserve">
          <source>(Time 1 is the direct way, Time 2 is the getter)</source>
          <target state="translated">(El tiempo 1 es el camino directo,el tiempo 2 es el que lo consigue)</target>
        </trans-unit>
        <trans-unit id="2674e860c37ef14352b7760e1bb68edd1812e340" translate="yes" xml:space="preserve">
          <source>1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ &quot;example&quot; code you'll notice me using &lt;code&gt;struct&lt;/code&gt; instead of &lt;code&gt;class&lt;/code&gt; everywhere.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) Comience con todos los miembros p&amp;uacute;blicos para objetos b&amp;aacute;sicos con datos y comportamiento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es por eso que en todo mi c&amp;oacute;digo de &quot;ejemplo&quot; de C ++ me notar&amp;aacute;s usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; en&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lugar de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; en&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; todas partes.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9afae1edbdd3713190c6b92e13771fa366eb26a3" translate="yes" xml:space="preserve">
          <source>10 million cycles:</source>
          <target state="translated">10 millones de ciclos:</target>
        </trans-unit>
        <trans-unit id="164834c50a9442cbf6258a5472c287b312c938dc" translate="yes" xml:space="preserve">
          <source>2) When an object's internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal &lt;code&gt;std::list&lt;/code&gt; in some kind of order), accessor type functions are written.  Because I'm programming by myself, I don't always set the member &lt;code&gt;private&lt;/code&gt; right away, but somewhere down the evolution of the class the member will be &quot;promoted&quot; to either &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2) Cuando el comportamiento interno de un objeto para un miembro de datos se vuelve lo suficientemente complejo (por ejemplo, le gusta mantener una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; interna &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;en alg&amp;uacute;n tipo de orden), se escriben las funciones de tipo de acceso. Debido a que estoy programando solo, no siempre configuro el miembro como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; inmediato, pero en alg&amp;uacute;n momento de la evoluci&amp;oacute;n de la clase, el miembro ser&amp;aacute; &quot;promovido&quot; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;protected&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7892b3b7150042db597eb83df3fa2fc4d4a5356e" translate="yes" xml:space="preserve">
          <source>3) Classes that are fully fleshed out and have strict rules about their internals (ie &lt;em&gt;they&lt;/em&gt; know exactly what they are doing, and you are not to &quot;fuck&quot; (technical term) with its internals) are given the &lt;code&gt;class&lt;/code&gt; designation, default private members, and only a select few members are allowed to be &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) Las clases que est&amp;aacute;n completamente desarrolladas y tienen reglas estrictas sobre sus componentes internos (es decir &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; saben exactamente lo que est&amp;aacute;n haciendo, y usted no debe &quot;joder&quot; (t&amp;eacute;rmino t&amp;eacute;cnico) con sus &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;componentes &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;internos) reciben la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;designaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , miembros privados predeterminados , y solo unos pocos miembros seleccionados pueden ser &lt;/font&gt;&lt;/font&gt; &lt;code&gt;public&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b75455e8497af8e0568b85b084a32699e8ec694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Here are the some of the reasons I am aware of:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estas son algunas de las razones que conozco:&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3cca966ff39b9fe1ddc20c0c05c5ab85772f223b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;Oh... cool, I guess?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cliente&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;Oh ... genial, supongo?&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da3e4c734e73e93fbd221e07e4b36c403db2d6c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;What can I do with an object of this class?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cliente&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;&amp;iquest;Qu&amp;eacute; puedo hacer con un objeto de esta clase?&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="255733b7d5ec2727df67865b9399e6f16913e0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code to the interface, not the implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;digo para la interfaz, no la implementaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3009decd56c1847ecaff29ac42deaeb96d7e5ed9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Designer&lt;/strong&gt;: &quot;You can read and write several variables.&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dise&amp;ntilde;ador&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;Puedes leer y escribir varias variables&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9327bbc5dd989bbd9c8de05113c4531259a85e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getter Methods:&lt;/strong&gt;&lt;em&gt;We can get access to private variables.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;M&amp;eacute;todos Getter: &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;podemos obtener acceso a variables privadas.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49c576902394b2f88aa9c23003d5ca3259732bc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getters&lt;/strong&gt; and &lt;strong&gt;setters&lt;/strong&gt; are used to implement two of the fundamental aspects of Object Oriented Programming which are:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getters&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;setters&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se utilizan para implementar dos de los aspectos fundamentales de la Programaci&amp;oacute;n Orientada a Objetos que son:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75bf09d32278474950179c8e319e9ebd15d37d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interfaces only specify methods, not fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las interfaces solo especifican m&amp;eacute;todos, no campos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9db04f55b8e825e0380143c8c6459e9bd8ff383" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setter Methods:&lt;/strong&gt;&lt;em&gt;We can modify private fields.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;M&amp;eacute;todos de Setter: &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;podemos modificar campos privados.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e77ba06d495a30414d7393b72695c1a32bd8ea5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are actually &lt;em&gt;many good reasons&lt;/em&gt; to consider using accessors&lt;/strong&gt; rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En realidad, hay &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;muchas buenas razones&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para considerar el uso de accesores en&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lugar de exponer directamente los campos de una clase, m&amp;aacute;s all&amp;aacute; del argumento de encapsulaci&amp;oacute;n y facilitar los cambios futuros.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9b3b8c7d55f7b60e6b667f7483bd9cd9c8e936e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* Even for that simple class, you may not necessarily want to allow setting the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values. If this is really a class, shouldn't it have methods like &lt;code&gt;translate&lt;/code&gt;, &lt;code&gt;rotate&lt;/code&gt;, etc.? If it's only a class because your language doesn't have records/structs/named tuples, then this isn't really a question of OO&amp;hellip;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* Incluso para esa clase simple, es posible que no desee permitir establecer los &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valores &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; e &lt;/font&gt;&lt;/font&gt; &lt;code&gt;y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si esto es realmente una clase, &amp;iquest;no deber&amp;iacute;a tener m&amp;eacute;todos como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;translate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rotate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , etc.? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si es solo una clase porque su lenguaje no tiene registros / estructuras / tuplas con nombre, entonces esto no es realmente una cuesti&amp;oacute;n de OO ...&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9f1c7ed63a610cca03dbe1fb9a5969b1641f70d2" translate="yes" xml:space="preserve">
          <source>A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it's clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.</source>
          <target state="translated">Un campo público no es peor que un par de gettersetters que no hace nada más que devolver el campo y asignarlo.Primero,está claro que (en la mayoría de los idiomas)no hay ninguna diferencia funcional.Cualquier diferencia debe estar en otros factores,como la mantenibilidad o la legibilidad.</target>
        </trans-unit>
        <trans-unit id="9ef49733b07a04ac879a3131cf59a6bb592d931f" translate="yes" xml:space="preserve">
          <source>A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).</source>
          <target state="translated">Una clase muy simple que contiene cuánto líquido hay en ella,y cuál es su capacidad (en mililitros).</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="82749ef4d632eabe207c0f5bfe48e65659005062" translate="yes" xml:space="preserve">
          <source>Accessors and mutators also allow for encapsulation - if you aren't supposed to see the value once its set (perhaps it's set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.</source>
          <target state="translated">Los accesorios y los mutadores también permiten la encapsulación-si se supone que no se debe ver el valor una vez que se establece (tal vez se establece en el constructor y luego se utiliza por métodos,pero nunca se supone que se cambie),nunca será visto por nadie.Pero si puedes permitir que otras clases lo vean o lo cambien,puedes proporcionar el accesorio adecuado o el mutador.</target>
        </trans-unit>
        <trans-unit id="a4355e16716c8eb9f55ad860a735f5c6eda863c4" translate="yes" xml:space="preserve">
          <source>Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That's how you can define and maintain useful invariants.</source>
          <target state="translated">Agregar pares de pasantes a esta clase no agrega ningún valor.Otras clases deberían proporcionar operaciones significativas,no sólo operaciones que los campos ya proporcionan.Así es como puedes definir y mantener invariantes útiles.</target>
        </trans-unit>
        <trans-unit id="3d5035c0f50aaed825f8024c67607f79c9d6f00e" translate="yes" xml:space="preserve">
          <source>Additionally, this is to &quot;future-proof&quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just &quot;set/get the field&quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.</source>
          <target state="translated">Además,esto es para &quot;probar el futuro&quot; de su clase.En particular,cambiar de un campo a una propiedad es una ruptura ABI,así que si más tarde decides que necesitas más lógica que sólo &quot;ajustar el campo&quot;,entonces necesitas romper ABI,lo que por supuesto crea problemas para cualquier otra cosa ya compilada contra tu clase.</target>
        </trans-unit>
        <trans-unit id="81c4e73e61dcb9ef881221a8e3e6e510aaafccd3" translate="yes" xml:space="preserve">
          <source>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</source>
          <target state="translated">Permitiendo a los herederos cambiar la semántica de cómo la propiedad se comporta y se expone anulando los métodos de gettersetter.</target>
        </trans-unit>
        <trans-unit id="57a93d1fb290ddf7a1dbf6a3c46ddb1f2bd05da4" translate="yes" xml:space="preserve">
          <source>Allowing the getter/setter to be passed around as lambda expressions rather than values.</source>
          <target state="translated">Permitiendo que el &quot;gettersetter&quot; se pase como expresiones lambda en lugar de valores.</target>
        </trans-unit>
        <trans-unit id="43274d4e786c79c30fbd5d48e83bf0480818a226" translate="yes" xml:space="preserve">
          <source>Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.</source>
          <target state="translated">También con diferentes cantidades de ciclos,el getter es un poco más rápido que la forma regular.Espero que esto te haya ayudado.</target>
        </trans-unit>
        <trans-unit id="033534469fa80b3c8584bdbf1263c23f9a826be5" translate="yes" xml:space="preserve">
          <source>Also, it's important to follow the idioms of the language (or framework) you're using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that's bad. Some languages have stronger cultures around their conventions than others.&amp;mdash;and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, es importante seguir los modismos del lenguaje (o marco) que est&amp;aacute; utilizando. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si escribe un hermoso c&amp;oacute;digo de estilo Ruby en C #, cualquier desarrollador experimentado de C # que no sea usted tendr&amp;aacute; problemas para leerlo, y eso es malo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algunos lenguajes tienen culturas m&amp;aacute;s fuertes en torno a sus convenciones que otros. Y puede que no sea una coincidencia que Java y Python, que se encuentran en extremos opuestos del espectro por lo idiom&amp;aacute;ticos que son los captadores, tengan dos de las culturas m&amp;aacute;s fuertes.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d11a9b94f688fd1bb3e8236ba806a1a0de41e921" translate="yes" xml:space="preserve">
          <source>An oft-mentioned advantage of getter/setter pairs, isn't. There's this claim that you can change the implementation and your clients don't have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don't even need to know about it. However, adding validation to a setter is a change to its preconditions, &lt;strong&gt;a violation of the previous contract&lt;/strong&gt;, which was, quite simply, &quot;you can put anything in here, and you can get that same thing later from the getter&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una ventaja a menudo mencionada de los pares getter / setter, no lo es. Existe la afirmaci&amp;oacute;n de que puede cambiar la implementaci&amp;oacute;n y sus clientes no tienen que ser recompilados. Supuestamente, los configuradores le permiten agregar funcionalidades como validaci&amp;oacute;n m&amp;aacute;s adelante y sus clientes ni siquiera necesitan saberlo. Sin embargo, agregar validaci&amp;oacute;n a un colocador es un cambio en sus condiciones previas, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una violaci&amp;oacute;n del contrato anterior&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que era, simplemente, &quot;puede poner cualquier cosa aqu&amp;iacute;, y puede obtener lo mismo m&amp;aacute;s tarde del getter&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0528fa85939d91318183d46b3de68fa50d141cc4" translate="yes" xml:space="preserve">
          <source>And all these can have different ways to handle various whoopsies. The Bottle just checks and if it's overflowing it throws a RuntimeException. But that might be the wrong thing to do. 
(There is a useful discussion to be had about error handling, but I'm keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )</source>
          <target state="translated">Y todos estos pueden tener diferentes maneras de manejar varias feromonas.La botella sólo se comprueba y si se desborda lanza una excepción de tiempo de ejecución.Pero eso podría ser lo que no se hace.(Hay una discusión útil sobre el manejo de errores,pero lo mantengo muy simple aquí a propósito.La gente en los comentarios probablemente señalará las fallas de este enfoque simplista.;))</target>
        </trans-unit>
        <trans-unit id="b3709a8d644d6848cb9e1e1b2612c33a14d466f8" translate="yes" xml:space="preserve">
          <source>And yes, it seems like we go from a very simple idea to getting much better answers quickly.</source>
          <target state="translated">Y sí,parece que pasamos de una idea muy simple a obtener respuestas mucho mejores rápidamente.</target>
        </trans-unit>
        <trans-unit id="8c0adc3715c9771354c8ce3bffb1a2caa8b06842" translate="yes" xml:space="preserve">
          <source>Any validation you perform in there can only be context free, which validation rarely is in practice.</source>
          <target state="translated">Cualquier validación que se realice allí sólo puede ser libre de contexto,lo que rara vez se hace en la práctica.</target>
        </trans-unit>
        <trans-unit id="47b2dd5b5d660068e61383ca22ea5c24356d49a6" translate="yes" xml:space="preserve">
          <source>Anywhere a value can be used, a method that returns that value can be added. Instead of:</source>
          <target state="translated">En cualquier lugar donde se pueda utilizar un valor,se puede añadir un método que devuelva ese valor.En lugar de:</target>
        </trans-unit>
        <trans-unit id="ac6f0e579cd82854d73b7ba5e3dee370470c5bf1" translate="yes" xml:space="preserve">
          <source>As for the &quot;what if I want to change my implementation later?&quot; question (which is repeated multiple times in different wording in both the OP's question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn't support that. So this is really just the same case again.</source>
          <target state="translated">En cuanto a la pregunta &quot;¿qué pasa si quiero cambiar mi aplicación más tarde?&quot; (que se repite varias veces con diferente redacción tanto en la pregunta de la OP como en la respuesta aceptada):Si realmente se trata de un cambio de implementación puro,y se comenzó con un atributo,se puede cambiar a una propiedad sin afectar la interfaz.A menos,por supuesto,que tu lenguaje no soporte eso.Así que este es realmente el mismo caso otra vez.</target>
        </trans-unit>
        <trans-unit id="43cacfbdc83927cc4b2aad1396ab0622fbf9274d" translate="yes" xml:space="preserve">
          <source>Because 2 weeks (months, years) from now when you realize that your setter needs to do &lt;strong&gt;more&lt;/strong&gt; than just set the value, you'll also realize that the property has been used directly in 238 other classes :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debido a que dentro de 2 semanas (meses, a&amp;ntilde;os) a partir de ahora, cuando se d&amp;eacute; cuenta de que su setter necesita hacer &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;aacute;s&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que solo establecer el valor, tambi&amp;eacute;n se dar&amp;aacute; cuenta de que la propiedad se ha utilizado directamente en otras 238 clases :-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e510c63de41dc0facb98c85d5c568e3eeeafd444" translate="yes" xml:space="preserve">
          <source>Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don't. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don't fight them.</source>
          <target state="translated">Más allá de los lectores humanos,habrá bibliotecas y herramientas que esperan que sigas las convenciones,y que te hagan la vida más difícil si no lo haces.Enganchar los widgets del Interface Builder a cualquier cosa menos a las propiedades de ObjC,o usar ciertas librerías de burla de Java sin getters,sólo está haciendo tu vida más difícil.Si las herramientas son importantes para ti,no luches contra ellas.</target>
        </trans-unit>
        <trans-unit id="fac3c0dab4aeb3d8c561a0f4789de6b3ef9c2a67" translate="yes" xml:space="preserve">
          <source>But nobody is ever doing general OO design. They're doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.</source>
          <target state="translated">Pero nadie está haciendo nunca un diseño general de OO.Están haciendo el diseño,y la implementación,en un lenguaje específico.Y en algunos lenguajes,los getters y setters están lejos de ser inútiles.</target>
        </trans-unit>
        <trans-unit id="34bfb1e4e8fe780f6179a91f408e1aeba2e095cb" translate="yes" xml:space="preserve">
          <source>But there's another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn't that be better? Since interfaces demand methods, this is also a good thing.</source>
          <target state="translated">Pero también hay otro problema.¿Qué pasaría si las botellas fueran sólo un tipo de recipiente? ¿Y si tuviéramos varios contenedores,todos con capacidades y cantidades de líquido llenos? Si pudiéramos hacer una interfaz,podríamos dejar que el resto de nuestro programa la aceptara,y las botellas,los bidones y todo tipo de cosas funcionarían de forma intercambiable.¿No sería eso mejor? Ya que las interfaces exigen métodos,esto también es algo bueno.</target>
        </trans-unit>
        <trans-unit id="5f581816971f55a0fe7fe755c1439b557642dd88" translate="yes" xml:space="preserve">
          <source>Code &lt;em&gt;evolves&lt;/em&gt;.  &lt;code&gt;private&lt;/code&gt; is great for when &lt;em&gt;you need data member protection&lt;/em&gt;.  Eventually all classes should be sort of &quot;miniprograms&quot; that have a well-defined interface &lt;em&gt;that you can't just screw with the internals of&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El c&amp;oacute;digo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;evoluciona&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es ideal para cuando &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;necesita protecci&amp;oacute;n de miembro de datos&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Eventualmente, todas las clases deber&amp;iacute;an ser una especie de &quot;miniprogramas&quot; que tienen una interfaz bien definida &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;que no se puede simplemente atornillar con las partes internas&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77e195f98a65d1f5b54c0c97c7133a6067f84b7e" translate="yes" xml:space="preserve">
          <source>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</source>
          <target state="translated">El control de la vida útil y la semántica de la gestión de la memoria (eliminación)de la propiedad-particularmente importante en los entornos de memoria no gestionada (como C++u Objetivo-C).</target>
        </trans-unit>
        <trans-unit id="451d8c398dac194d41c458e0b0ad881903b0f15e" translate="yes" xml:space="preserve">
          <source>Depends on your language.  You've tagged this &quot;object-oriented&quot; rather than &quot;Java&quot;, so I'd like to point out that ChssPly76's answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:</source>
          <target state="translated">Depende de su idioma.Has etiquetado esto como &quot;orientado a objetos&quot; en lugar de &quot;Java&quot;,así que me gustaría señalar que la respuesta de ChssPly76 depende del lenguaje.En Python,por ejemplo,no hay razón para usar getters y setters.Si necesitas cambiar el comportamiento,puedes usar una propiedad,que envuelve un getter y setter alrededor del acceso a los atributos básicos.Algo como esto:</target>
        </trans-unit>
        <trans-unit id="59b09c675389e93fb718c3607a2b33d8ced3dba3" translate="yes" xml:space="preserve">
          <source>Don't use getters setters unless needed for your current delivery I.e. Don't think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.</source>
          <target state="translated">No utilice getters setters a menos que sea necesario para su entrega actual,es decir,no piense demasiado en lo que sucedería en el futuro,si alguna cosa a cambiar es una solicitud de cambio en la mayoría de las aplicaciones de producción,sistemas.</target>
        </trans-unit>
        <trans-unit id="4811f53244f0f4eb1f508c3dce99ba627e7afab2" translate="yes" xml:space="preserve">
          <source>EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they're not as easy to understand if you're a newbie. We were all newbies, so I thought I'd try my hand at a more newbie friendly answer.</source>
          <target state="translated">EDITORIAL:Respondí a esta pregunta porque hay un montón de gente aprendiendo programación preguntando esto,y la mayoría de las respuestas son muy competentes técnicamente,pero no son tan fáciles de entender si eres un novato.Todos éramos novatos,así que pensé en intentar una respuesta más amigable para los novatos.</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="045c9ac03fcd3840d51b0f2e3b7fc9b7a8a9f185" translate="yes" xml:space="preserve">
          <source>Encapsulation mantra</source>
          <target state="translated">Encapsulación del mantra</target>
        </trans-unit>
        <trans-unit id="08518ebb827eeba5eb31bb4abc223904fb6d8e7c" translate="yes" xml:space="preserve">
          <source>Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.</source>
          <target state="translated">Encapsulación del comportamiento asociado con la obtención o el establecimiento de la propiedad-esto permite una funcionalidad adicional (como la validación)para ser añadida más fácilmente más tarde.</target>
        </trans-unit>
        <trans-unit id="a273aa55c91241aef5cbe7c904175deb629c3048" translate="yes" xml:space="preserve">
          <source>Even if your language does have properties, there may be cases where they're insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can't substitute a computed property for an attribute.</source>
          <target state="translated">Incluso si su lenguaje tiene propiedades,puede haber casos en los que son insuficientes o inapropiadas.Por ejemplo,si quiere permitir que las subclases controlen la semántica de un atributo,en los idiomas sin acceso dinámico,una subclase no puede sustituir una propiedad calculada por un atributo.</target>
        </trans-unit>
        <trans-unit id="e83595b7e6ea6eac5ba12ba0e0ea2bbad5c8a4f7" translate="yes" xml:space="preserve">
          <source>Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.</source>
          <target state="translated">Aunque los métodos de getter y setter son útiles,hay que tener cuidado de no abusar de ellos porque,entre otras cosas,pueden dificultar el mantenimiento del código en determinadas situaciones.Además,proporcionan acceso a la implementación de su clase,como los miembros públicos.La práctica de OOP desalienta el acceso directo a las propiedades dentro de una clase.</target>
        </trans-unit>
        <trans-unit id="d63ca1863a03a6cc66be541e8b13351b917e9595" translate="yes" xml:space="preserve">
          <source>Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method</source>
          <target state="translated">Aunque los métodos de getter y setter no añaden nuevas funcionalidades,podemos cambiar de opinión y volver más tarde para hacer que ese método</target>
        </trans-unit>
        <trans-unit id="67bba4f9917627abec7de3eae66ae2f912a2559b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;foo&lt;/code&gt; was public, I could easily set it to &lt;code&gt;null&lt;/code&gt; and then someone else could try to call a method on the object. But it's not there anymore! With a &lt;code&gt;setFoo&lt;/code&gt; method, I could ensure that &lt;code&gt;foo&lt;/code&gt; was never set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; era p&amp;uacute;blico, podr&amp;iacute;a configurarlo f&amp;aacute;cilmente como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y luego alguien m&amp;aacute;s podr&amp;iacute;a intentar llamar a un m&amp;eacute;todo en el objeto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl;Pero ya no est&amp;aacute; all&amp;iacute;! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Con un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFoo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , podr&amp;iacute;a asegurarme de que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nunca se configurara como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476a63abfc2fa3c03aedf4736d5d9942e91d901f" translate="yes" xml:space="preserve">
          <source>From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: &lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde el punto de vista del dise&amp;ntilde;o de orientaci&amp;oacute;n a objetos, ambas alternativas pueden ser perjudiciales para el mantenimiento del c&amp;oacute;digo al debilitar la encapsulaci&amp;oacute;n de las clases. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para una discusi&amp;oacute;n, puede consultar este excelente art&amp;iacute;culo: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a74b1d741c07f0d10578559f597f6187841258b7" translate="yes" xml:space="preserve">
          <source>From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you've written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.</source>
          <target state="translated">Desde el punto de vista de la teoría de OO,los getters y setters son inútiles.La interfaz de su clase es lo que hace,no su estado.(Si no,has escrito la clase equivocada.)En casos muy simples,donde lo que hace una clase es sólo,por ejemplo,representar un punto en coordenadas rectangulares,*los atributos son parte de la interfaz;los getters y setters sólo nublan eso.Pero en cualquier cosa menos en casos muy simples,ni los atributos ni los getters y setters son parte de la interfaz.</target>
        </trans-unit>
        <trans-unit id="57ae158f2e8c761e3b5b8bb16e7dccf2d8f722c4" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.</source>
          <target state="translated">Los métodos de getter y setter son métodos de acceso,lo que significa que generalmente son una interfaz pública para cambiar los miembros de la clase privada.Los métodos getter y setter se utilizan para definir una propiedad.Accedes a los métodos getter y setter como propiedades fuera de la clase,aunque los definas dentro de la clase como métodos.Esas propiedades fuera de la clase pueden tener un nombre diferente del nombre de la propiedad en la clase.</target>
        </trans-unit>
        <trans-unit id="aee376df07aa660dacecd6260f852a6d918c4cd1" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are public interfaces to access private class members.</source>
          <target state="translated">Los métodos Getter y Setter son interfaces públicas para acceder a los miembros de la clase privada.</target>
        </trans-unit>
        <trans-unit id="cba3e268c215d8706586fc9b9c009cffacae2d3a" translate="yes" xml:space="preserve">
          <source>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</source>
          <target state="translated">Los getters y setters pueden permitir diferentes niveles de acceso,por ejemplo,el get puede ser público,pero el set puede ser protegido.</target>
        </trans-unit>
        <trans-unit id="a06c2f62c876887f1c33b514ac9a69553b2b6392" translate="yes" xml:space="preserve">
          <source>Great! And now we just change Bottle to this:</source>
          <target state="translated">¡Grandioso! Y ahora cambiamos a Botella por esto:</target>
        </trans-unit>
        <trans-unit id="de8d815e48132f09b9bca3cbd23f2f97e119a145" translate="yes" xml:space="preserve">
          <source>Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.</source>
          <target state="translated">En este caso,los detalles de implementación de Nombre Completo se ocultan al usuario y no son accesibles directamente al usuario,a diferencia de un atributo público.</target>
        </trans-unit>
        <trans-unit id="3fa394821ab09cbccd5563100429404ca95e6440" translate="yes" xml:space="preserve">
          <source>Hiding the internal representation of the property while exposing a property using an alternative representation.</source>
          <target state="translated">Ocultar la representación interna de la propiedad mientras se expone una propiedad usando una representación alternativa.</target>
        </trans-unit>
        <trans-unit id="d2f4f5cef8a9ea91e08ca99ee45e39ac9dcd0ebe" translate="yes" xml:space="preserve">
          <source>I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class's evolution.</source>
          <target state="translated">Creo que este enfoque me permite evitar sentarme y escribir religiosamente &quot;gettersetters&quot; cuando muchos miembros de los datos emigran,se desplazan,etc.durante las primeras etapas de la evolución de una clase.</target>
        </trans-unit>
        <trans-unit id="7ac905efee55cbf685e08af0da10c6d4468cd4fe" translate="yes" xml:space="preserve">
          <source>I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn't always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of &quot;slow&quot;, so you don't want to make a web service call if you don't have to.</source>
          <target state="translated">Tenía una clase de página base en un proyecto que se me entregó y que cargaba algunos datos de un par de llamadas de servicio web diferentes,pero los datos de esas llamadas de servicio web no siempre se usaban en todas las páginas de niños.Los servicios web,por todos los beneficios,son pioneros en nuevas definiciones de &quot;lento&quot;,así que no quieres hacer una llamada al servicio web si no tienes que hacerlo.</target>
        </trans-unit>
        <trans-unit id="fec0ce430c9b50fa6a42a74bb5cc7bbe5070bd9d" translate="yes" xml:space="preserve">
          <source>I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.</source>
          <target state="translated">Tengo un sistema masivo escrito sin getters setters sólo con modificadores de acceso y algunos métodos para validar la lógica del negocio.Si es absolutamente necesario.Usa cualquier cosa.</target>
        </trans-unit>
        <trans-unit id="b23c3487d24d1993bf58de911e47e2492ae65d64" translate="yes" xml:space="preserve">
          <source>I know it's a bit late, but I think there are some people who are interested in performance.</source>
          <target state="translated">Sé que es un poco tarde,pero creo que hay algunas personas que están interesadas en la actuación.</target>
        </trans-unit>
        <trans-unit id="db14da99dc1a19fe0a1cec21c694b1166cec8396" translate="yes" xml:space="preserve">
          <source>I moved from public fields to getters, and now the getters check the cache, and if it's not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.</source>
          <target state="translated">Pasé de los campos públicos a los getters,y ahora los getters comprueban el caché,y si no está ahí,llama al servicio web.Así que con un poco de envoltura,se evitaron muchas llamadas al servicio web.</target>
        </trans-unit>
        <trans-unit id="d44fc766ecbf5e63030bb952d02b5d6adbd46593" translate="yes" xml:space="preserve">
          <source>I spent quite a while thinking this over for the Java case, and I believe the real reasons are:</source>
          <target state="translated">Pasé bastante tiempo pensando en esto para el caso de Java,y creo que las verdaderas razones son:</target>
        </trans-unit>
        <trans-unit id="2889b32bfcc03c8e80e260ed4b4716b29ae177b9" translate="yes" xml:space="preserve">
          <source>I would just like to throw the idea of annotation : @getter and @setter. With @getter, you should be able to obj = class.field but not class.field = obj. With @setter, vice versa. With @getter and @setter you should be able to do both. This would preserve encapsulation and reduce the time by not calling trivial methods at runtime.</source>
          <target state="translated">Me gustaría lanzar la idea de la anotación:@getter y @setter.Con @getter,deberías ser capaz de obj=class.field pero no class.field=obj.Con @setter,viceversa.Con @getter y @setter deberías ser capaz de hacer ambas cosas.Esto preservaría la encapsulación y reduciría el tiempo al no llamar a métodos triviales en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="448e5ff21f920e7e7eae20ce3fd54ad0522d451c" translate="yes" xml:space="preserve">
          <source>I would not take advantage of ignorance of business owners of deep technical know how just because I think it's correct or I like the approach.</source>
          <target state="translated">No me aprovecharía de la ignorancia de los empresarios de profundo conocimiento técnico sólo porque creo que es correcto o me gusta el enfoque.</target>
        </trans-unit>
        <trans-unit id="91a599d9c25706ea81b0f073fcd9ead9e1d48f03" translate="yes" xml:space="preserve">
          <source>I'll leave the definition of the BottleOverflowException as an exercise to the reader.</source>
          <target state="translated">Dejaré la definición de la excepción de la botella como un ejercicio para el lector.</target>
        </trans-unit>
        <trans-unit id="c0cfd8d8587de574184a35bdea413f3d36872445" translate="yes" xml:space="preserve">
          <source>I've done a little performance test. I wrote a class &quot;NumberHolder&quot; which, well, holds an Integer. You can either read that Integer by using the getter method
&lt;code&gt;anInstance.getNumber()&lt;/code&gt; or by directly accessing the number by using &lt;code&gt;anInstance.number&lt;/code&gt;. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I've got the following result:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;He hecho una peque&amp;ntilde;a prueba de rendimiento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Escrib&amp;iacute; una clase &quot;NumberHolder&quot; que, bueno, contiene un n&amp;uacute;mero entero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede leer ese n&amp;uacute;mero entero utilizando el m&amp;eacute;todo getter &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.getNumber()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o accediendo directamente al n&amp;uacute;mero utilizando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mi programa lee el n&amp;uacute;mero 1,000,000,000 de veces, en ambos sentidos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ese proceso se repite cinco veces y se imprime el tiempo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tengo el siguiente resultado:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0978c43bc2b11a6a993b548afff0b3b5ca45a92" translate="yes" xml:space="preserve">
          <source>If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, &lt;em&gt;no contract&lt;/em&gt;. Is that really object-oriented design? If all the class has is those getters and setters, it's just a dumb data holder, and dumb data holders should look like dumb data holders:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si una clase tiene estos captadores y establecedores tontos para cada campo, entonces es una clase que no tiene invariantes, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ni contrato&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Es realmente un dise&amp;ntilde;o orientado a objetos? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si toda la clase tiene esos captadores y establecedores, es solo un titular de datos tontos, y los titulares de datos tontos deber&amp;iacute;an verse como titulares de datos tontos:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46fb1f117749485f93dfde52629c12a6592e5f3e" translate="yes" xml:space="preserve">
          <source>If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I'm not 100% clear on how:</source>
          <target state="translated">Si los getters y setters hacen algo más que el simple getset,puedo entender esto muy rápidamente,pero no tengo 100% claro cómo:</target>
        </trans-unit>
        <trans-unit id="949e9da0978aaee4523cbb0c409b2bf0b89c3805" translate="yes" xml:space="preserve">
          <source>If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. &lt;em&gt;That's the exact opposite of encapsulation&lt;/em&gt; If that field could not really be set to anything from the start, why wasn't the validation there from the start?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si ese no deber&amp;iacute;a haber sido el contrato, entonces la interfaz estaba permitiendo a los clientes poner el objeto en estados no v&amp;aacute;lidos. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Eso es exactamente lo opuesto a la encapsulaci&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Si ese campo no se pudo establecer realmente desde el principio, &amp;iquest;por qu&amp;eacute; no se realiz&amp;oacute; la validaci&amp;oacute;n desde el principio?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d442a6315e08af677c7d3f5fd084eb11ecca9ce5" translate="yes" xml:space="preserve">
          <source>If your language doesn't have properties, then the only way to represent something that's conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.</source>
          <target state="translated">Si su lenguaje no tiene propiedades,entonces la única manera de representar algo que es conceptualmente un atributo,pero que en realidad es computado,o validado,etc.,es a través de getters y setters.</target>
        </trans-unit>
        <trans-unit id="c75e6d8a92da8554d6134d8d780910766638384b" translate="yes" xml:space="preserve">
          <source>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</source>
          <target state="translated">La interoperabilidad mejorada con las bibliotecas que están diseñadas para operar en contra de las propiedades de los gettersetters-Burla,Serialización y WPF vienen a la mente.</target>
        </trans-unit>
        <trans-unit id="a045af26b3882dcd948db97f36b10344affa5eda" translate="yes" xml:space="preserve">
          <source>In a pure object-oriented world getters and setters is a &lt;strong&gt;terrible anti-pattern&lt;/strong&gt;. Read this article: &lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;Getters/Setters. Evil. Period&lt;/a&gt;. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En un mundo puro orientado a objetos, los captadores y establecedores son un &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;antipatr&amp;oacute;n terrible&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lea este art&amp;iacute;culo: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getters / Setters. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Periodo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En pocas palabras, alientan a los programadores a pensar en los objetos como estructuras de datos, y este tipo de pensamiento es puramente de procedimiento (como en COBOL o C). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En un lenguaje orientado a objetos no hay estructuras de datos, sino solo objetos que exponen el comportamiento (&amp;iexcl;no atributos / propiedades!)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60ede22798c8886c1279c94029a7d8fbdb115073" translate="yes" xml:space="preserve">
          <source>In an object oriented language the methods, and their access modifiers, declare the interface for that object. Between the constructor and the accessor and mutator methods it is possible for the developer to control access to the internal state of an object. If the variables are simply declared public then there is no way to regulate that access.
And when we are using setters we can restrict the user for the input we need. Mean the feed for that very variable will come through a proper channel and the channel is predefined by us. So it's safer to use setters.</source>
          <target state="translated">En un lenguaje orientado a objetos,los métodos,y sus modificadores de acceso,declaran la interfaz para ese objeto.Entre el constructor y el acceso y los métodos mutadores es posible para el desarrollador controlar el acceso al estado interno de un objeto.Si las variables se declaran simplemente públicas,entonces no hay forma de regular ese acceso.Y cuando estamos usando los constructores podemos restringir al usuario para la entrada que necesitamos.Significa que la alimentación de esa misma variable vendrá a través de un canal apropiado y el canal está predefinido por nosotros.Así que es más seguro usar reguladores.</target>
        </trans-unit>
        <trans-unit id="9570686c65057df9d5555a427b45dcb388eb1c6d" translate="yes" xml:space="preserve">
          <source>In languages which don't support &quot;properties&quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.</source>
          <target state="translated">En los lenguajes que no soportan &quot;propiedades&quot; (C++,Java)o que requieren la recompilación de los clientes al cambiar los campos a propiedades (C#),el uso de métodos de getset es más fácil de modificar.Por ejemplo,añadir una lógica de validación a un método setFoo no requerirá cambiar la interfaz pública de una clase.</target>
        </trans-unit>
        <trans-unit id="49c146ae67da9fce98a67aa9876195255bf52355" translate="yes" xml:space="preserve">
          <source>In languages which support &quot;real&quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.</source>
          <target state="translated">En los lenguajes que soportan propiedades &quot;reales&quot; (Python,Ruby,tal vez Smalltalk?)no tiene sentido usar métodos de getset.</target>
        </trans-unit>
        <trans-unit id="9a756c26f5397e6bf09cb6c1e8673c721a0adcdc" translate="yes" xml:space="preserve">
          <source>In layman's terms</source>
          <target state="translated">En términos simples</target>
        </trans-unit>
        <trans-unit id="03538993fd141670ce7112b8a39c0f3f3dcb7e47" translate="yes" xml:space="preserve">
          <source>In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.</source>
          <target state="translated">En otras palabras,la única forma en que se puede especificar un campo en una interfaz es proporcionando un método para escribir un nuevo valor y un método para leer el valor actual.</target>
        </trans-unit>
        <trans-unit id="665cb9197ac6f3430ff52c71c900a99810bbd645" translate="yes" xml:space="preserve">
          <source>Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.</source>
          <target state="translated">Heredando esta clase,puedes anular la funcionalidad por defecto-en otras palabras,puedes confundir REALMENTE a los llamantes no sólo ocultando la implementación sino haciéndola inconsistente.</target>
        </trans-unit>
        <trans-unit id="2a50b3b7baaffbe0c2005cff92a6863837d540b1" translate="yes" xml:space="preserve">
          <source>Instead of</source>
          <target state="translated">En lugar de</target>
        </trans-unit>
        <trans-unit id="3a846f258ad5630d87aa074967dac3d41a23874d" translate="yes" xml:space="preserve">
          <source>Instead of doing this, we can create a bean &lt;code&gt;class(Person)&lt;/code&gt; with getter and setter methods.  So tomorrow we can just create objects of this Bean &lt;code&gt;class(Person class)&lt;/code&gt; whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En lugar de hacer esto, podemos crear una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bean &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Persona)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con los m&amp;eacute;todos getter y setter. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; que ma&amp;ntilde;ana podemos crear objetos de esta &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person class)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Bean &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(clase Persona)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; siempre que necesitemos agregar una nueva persona (ver la figura). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, estamos reutilizando los campos y m&amp;eacute;todos de la clase bean, que es mucho mejor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebdc6050b1ad6649a3451d6af5910e06b12430e3" translate="yes" xml:space="preserve">
          <source>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</source>
          <target state="translated">Aislando su interfaz pública del cambio-permitiendo que la interfaz pública permanezca constante mientras la implementación cambia sin afectar a los consumidores existentes.</target>
        </trans-unit>
        <trans-unit id="5ac0c56e853fb8f8f0be1b64596f6b59055cbdae" translate="yes" xml:space="preserve">
          <source>It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don't want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.</source>
          <target state="translated">Puede ser útil para la carga perezosa.Digamos que el objeto en cuestión está almacenado en una base de datos,y no quieres ir a buscarlo a menos que lo necesites.Si el objeto es recuperado por un getter,entonces el objeto interno puede ser nulo hasta que alguien lo pida,entonces puedes ir a buscarlo en la primera llamada al getter.</target>
        </trans-unit>
        <trans-unit id="cc4afcf1103ef9d6c53108ff6cc9b9b18bdb3242" translate="yes" xml:space="preserve">
          <source>It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.</source>
          <target state="translated">Le da muchos beneficios,uno de los cuales es que puede cambiar la implementación del &quot;gettersetter&quot; entre bastidores,pero cualquier consumidor de ese valor seguirá trabajando mientras el tipo de datos siga siendo el mismo.</target>
        </trans-unit>
        <trans-unit id="729e36d06a905476ea11f5c8b0c1812a73dff9ce" translate="yes" xml:space="preserve">
          <source>It's a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that's where your memory leak was occurring.</source>
          <target state="translated">Es un hermoso y simple pedazo de código hasta que te das cuenta de que es un setter.Ahora,sigues a ese configurador y encuentras que también configura person.firstName,person.lastName,person.isHuman,person.hasReallyCommonFirstName,y llama person.update(),que envía una consulta a la base de datos,etc.Oh,ahí es donde estaba ocurriendo la fuga de memoria.</target>
        </trans-unit>
        <trans-unit id="16aa234236b2a7935d4484df427e10358d69a866" translate="yes" xml:space="preserve">
          <source>Let's say we have this simple class:</source>
          <target state="translated">Digamos que tenemos esta simple clase:</target>
        </trans-unit>
        <trans-unit id="c9377946989c0599e694f34e6e15b1e30f95e7bb" translate="yes" xml:space="preserve">
          <source>Lots of people talk about the advantages of getters and setters but I want to play devil's advocate. Right now I'm debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.</source>
          <target state="translated">Mucha gente habla de las ventajas de los getters y setters pero yo quiero hacer de abogado del diablo.Ahora mismo estoy depurando un programa muy grande en el que los programadores decidieron hacer todo tipo de getters y setters.Eso puede parecer bonito,pero es una pesadilla de ingeniería inversa.</target>
        </trans-unit>
        <trans-unit id="1d38c1d25ba364989ccc66f32498e40bbffbe427" translate="yes" xml:space="preserve">
          <source>My 2 cents :)</source>
          <target state="translated">Mis 2 centavos :)</target>
        </trans-unit>
        <trans-unit id="89bcb9ce512e3a24b71ffdc4db2c607ef7562d71" translate="yes" xml:space="preserve">
          <source>Not only is &lt;code&gt;getVar()&lt;/code&gt; visually noisy, it gives this illusion that &lt;code&gt;gettingVar()&lt;/code&gt; is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of &lt;code&gt;var&lt;/code&gt; is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you're putting up these gates to &quot;protect&quot; something you insist is valuable, (the sanctity of &lt;code&gt;var&lt;/code&gt;) but yet even you concede &lt;code&gt;var&lt;/code&gt;'s protection isn't worth much by the ability for anyone to just come in and &lt;code&gt;set&lt;/code&gt;&lt;code&gt;var&lt;/code&gt; to whatever value they want, without you even peeking at what they are doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no solo es &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;visualmente ruidoso, da la ilusi&amp;oacute;n de que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;gettingVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es de alguna manera un proceso m&amp;aacute;s complejo de lo que realmente es. La forma en que usted (como escritor de la clase) considera que la santidad de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es particularmente confusa para un usuario de su clase si tiene un configurador passthru, entonces parece que est&amp;aacute; colocando estas puertas para &quot;proteger&quot; algo que insiste es valioso , (la santidad de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) pero aun as&amp;iacute; usted reconoce que &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la protecci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no vale mucho por la capacidad de cualquiera de entrar y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;set&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; al valor que quiera, sin siquiera mirar lo que est&amp;aacute;n haciendo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25ccd6d1abfaa462958a3daf7b3c72739444cbb" translate="yes" xml:space="preserve">
          <source>Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.</source>
          <target state="translated">Ahora noten lo mucho más robusto que es esto.Podemos tratar con cualquier tipo de contenedor en nuestro código ahora aceptando el LiquidContainer en lugar de la botella.Y la forma en que estas botellas tratan con este tipo de cosas puede ser diferente.Puedes tener botellas que escriben su estado en el disco cuando cambia,o botellas que guardan en bases de datos SQL o GNU sabe qué más.</target>
        </trans-unit>
        <trans-unit id="ee14a6cb3f5a0e797943e0e6cf7bc7231a57d7bc" translate="yes" xml:space="preserve">
          <source>Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.</source>
          <target state="translated">¿Y si en TODOS los lugares de su código estuviera usando el campo público y se diera cuenta de que necesita el requisito anterior? Diviértete cazando cada uso del campo público en lugar de sólo modificar tu setter.</target>
        </trans-unit>
        <trans-unit id="bea2afcb08c47bb55bd603ad05f6ae591ec6e48a" translate="yes" xml:space="preserve">
          <source>On the other hand, if the member is public, the tools don't make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.</source>
          <target state="translated">Por otro lado,si el miembro es público,las herramientas no permiten filtrar el acceso de lectura y escritura al miembro.Así que tienes que recorrer todos los usos del miembro.</target>
        </trans-unit>
        <trans-unit id="e9f8893e9b850ac172431cb049bc524b942b2431" translate="yes" xml:space="preserve">
          <source>One advantage of accessors and mutators is that you can perform validation.</source>
          <target state="translated">Una de las ventajas de los accesorios y mutadores es que se puede realizar la validación.</target>
        </trans-unit>
        <trans-unit id="91b95b7297fe9079d417e879ad5486deb384c22d" translate="yes" xml:space="preserve">
          <source>One aspect I missed in the answers so far, the access specification:</source>
          <target state="translated">Un aspecto que he pasado por alto en las respuestas hasta ahora,la especificación del acceso:</target>
        </trans-unit>
        <trans-unit id="10765ac54cefce78aa01ff15a00dd5d27040fc3d" translate="yes" xml:space="preserve">
          <source>One of the basic principals of OO design: &lt;strong&gt;Encapsulation!&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Uno de los principios b&amp;aacute;sicos del dise&amp;ntilde;o OO: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iexcl;Encapsulaci&amp;oacute;n!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b5607ce4ce1a004d9de9e90c6bbff2691c7ffe7" translate="yes" xml:space="preserve">
          <source>One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that's computationally expensive in a property.</source>
          <target state="translated">Otro uso (en los idiomas que soportan las propiedades)es que los setters y getters pueden implicar que una operación no es trivial.Típicamente,se quiere evitar hacer algo que sea computacionalmente caro en una propiedad.</target>
        </trans-unit>
        <trans-unit id="76713a423e5722e517c06fbab6e7cfe5f4817367" translate="yes" xml:space="preserve">
          <source>One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.</source>
          <target state="translated">Una ventaja relativamente moderna de los getterssetters es que facilita la búsqueda de código en los editores de código etiquetados (indexados).Por ejemplo,si quieres ver quién configura un miembro,puedes abrir la jerarquía de llamadas del configurador.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="be9cbb9ed4b5c6641f5aa815d9709c0e21aceeaa" translate="yes" xml:space="preserve">
          <source>Please note also that you can't change the capacity of a bottle. It's now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can't limit the access to touching the innards.</source>
          <target state="translated">Tenga en cuenta también que no puede cambiar la capacidad de una botella.Ahora está grabada en piedra.Podrías hacer esto con un int,declarándolo definitivo.Pero si esto fuera una lista,podrías vaciarla,añadirle cosas nuevas,y así sucesivamente.No puedes limitar el acceso a tocar las tripas.</target>
        </trans-unit>
        <trans-unit id="36c1fd3f265a620d873362378468f7e90e8a20ae" translate="yes" xml:space="preserve">
          <source>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</source>
          <target state="translated">Proporcionar un punto de intercepción de depuración para cuando una propiedad cambia en tiempo de ejecución-depurar cuándo y dónde una propiedad cambió a un valor particular puede ser bastante difícil sin esto en algunos idiomas.</target>
        </trans-unit>
        <trans-unit id="3e2aa20a27ca3d6e7b23af75afca271955543ebe" translate="yes" xml:space="preserve">
          <source>Put another way: If you believe that consumers of your class shouldn't even know that you have a &lt;code&gt;spam&lt;/code&gt; attribute, much less be able to change it willy-nilly, then giving them a &lt;code&gt;set_spam&lt;/code&gt; method is the last thing you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dicho de otra manera: si crees que los consumidores de tu clase ni siquiera deber&amp;iacute;an saber que tienes un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;atributo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , mucho menos ser capaz de cambiarlo de forma involuntaria, entonces lo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;uacute;ltimo que quieres hacer es &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;darles un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;set_spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2800b08281984434942ba5adcad8919a80ff4cc" translate="yes" xml:space="preserve">
          <source>Say you're looking through hundreds of lines of code and you come across this:</source>
          <target state="translated">Digamos que estás buscando a través de cientos de líneas de código y te encuentras con esto:</target>
        </trans-unit>
        <trans-unit id="0fe6038ebdf6b117336c04451dc9e3876effcb5c" translate="yes" xml:space="preserve">
          <source>So I program as follows (assuming an &quot;agile&quot; type approach -- ie when I write code not knowing &lt;em&gt;exactly&lt;/em&gt; what it will be doing/don't have time or experience to plan an elaborate waterfall style interface set):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; que programo de la siguiente manera (suponiendo un enfoque de tipo &quot;&amp;aacute;gil&quot;, es decir, cuando escribo c&amp;oacute;digo sin saber &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;exactamente&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lo que har&amp;aacute; / no tengo tiempo o experiencia para planificar un elaborado conjunto de interfaces de estilo cascada):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9eda9489b827ab46566f12f43fa4c89312a585f" translate="yes" xml:space="preserve">
          <source>So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don't already have it.</source>
          <target state="translated">Así que el getter me salva de tratar de averiguar,en cada página de niños,lo que necesitaré.Si lo necesito,llamo al buscador,y va a buscarlo por mí si no lo tengo ya.</target>
        </trans-unit>
        <trans-unit id="3d0d9303819ce1ab413fffddd86f3afbed876b1f" translate="yes" xml:space="preserve">
          <source>So this is very rarely a general OO question; it's a language-specific question, with different answers for different languages (and different use cases).</source>
          <target state="translated">Por lo tanto,muy raramente se trata de una pregunta general de OO;es una pregunta específica del idioma,con diferentes respuestas para diferentes idiomas (y diferentes casos de uso).</target>
        </trans-unit>
        <trans-unit id="110215a582ce0c01e647e0ab38866bd28ab289f7" translate="yes" xml:space="preserve">
          <source>So you have:</source>
          <target state="translated">Así que lo has hecho:</target>
        </trans-unit>
        <trans-unit id="84327f3567507ed383657990eb8c4dfa0d117dca" translate="yes" xml:space="preserve">
          <source>So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you're making the assumption that all the code assumed the contract for those methods was different.</source>
          <target state="translated">Así que,ahora que has roto el contrato,cambiar cada archivo de la base de código es algo que deberías querer hacer,no evitar.Si lo evitas estás haciendo la suposición de que todo el código asumió que el contrato para esos métodos era diferente.</target>
        </trans-unit>
        <trans-unit id="cbead7356f0d8824aecb16d6a0262b6c772bd6e2" translate="yes" xml:space="preserve">
          <source>Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.</source>
          <target state="translated">Algunas bibliotecas esperan esto,pero no muchas:la reflexión,la serialización,los objetos de burla funcionan bien en los campos públicos.</target>
        </trans-unit>
        <trans-unit id="b8d6ec5b172b09312ffab2762d5844c299a54132" translate="yes" xml:space="preserve">
          <source>Suppose we have an Employee class:</source>
          <target state="translated">Supongamos que tenemos una clase para empleados:</target>
        </trans-unit>
        <trans-unit id="f0b6a967a2c05a11d643d0e4a7aa868f211882c5" translate="yes" xml:space="preserve">
          <source>Suppose we need to store the details of this &lt;code&gt;Person&lt;/code&gt;. This &lt;code&gt;Person&lt;/code&gt; has the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Doing this involves creating methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Now if we need create another person, it becomes necessary to create the methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;sex&lt;/code&gt; all over again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Supongamos que necesitamos almacenar los detalles de esta &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Esta &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene los campos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; o&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Hacer esto implica crear m&amp;eacute;todos para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; o&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Ahora, si necesitamos crear otra persona, es necesario crear los m&amp;eacute;todos para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; o&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nuevamente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3e474c35abac8c8e79adba6fbbab7a5646b1ac0" translate="yes" xml:space="preserve">
          <source>Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:</source>
          <target state="translated">Gracias,eso realmente aclaró mi pensamiento.Ahora aquí hay (casi)10 (casi)buenas razones para NO usar getters y setters:</target>
        </trans-unit>
        <trans-unit id="a29e9e3845b5c733ae0c153286a63607107be5fa" translate="yes" xml:space="preserve">
          <source>That said, &lt;em&gt;software development&lt;/em&gt; isn't about setting down that final version of the class as if you're pressing some cast iron statue on the first try.  While you're working with it, code is more like clay.  &lt;strong&gt;It evolves&lt;/strong&gt; as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dicho esto, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el desarrollo de software&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no se trata de establecer esa versi&amp;oacute;n final de la clase como si estuvieras presionando alguna estatua de hierro fundido en el primer intento. Mientras trabajas con &amp;eacute;l, el c&amp;oacute;digo es m&amp;aacute;s como arcilla. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Evoluciona a&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; medida que lo desarrolla y aprende m&amp;aacute;s sobre el dominio del problema que est&amp;aacute; resolviendo. Durante el desarrollo, las clases pueden interactuar entre s&amp;iacute; de lo que deber&amp;iacute;an (dependencia que planea descontar), fusionarse o separarse. As&amp;iacute; que creo que el debate se reduce a las personas que no quieren escribir religiosamente&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fc364b2a3ee96e69b00f590088b9c6ef9c9b632" translate="yes" xml:space="preserve">
          <source>The encapsulation mantra is to make fields private and methods public.</source>
          <target state="translated">El mantra de la encapsulación es hacer los campos privados y los métodos públicos.</target>
        </trans-unit>
        <trans-unit id="24c1a5142c379d866afbafbee078155a76918b88" translate="yes" xml:space="preserve">
          <source>The last three I'm just leaving (N/A or D/C)...</source>
          <target state="translated">Los últimos tres que estoy dejando (NA o DC)...</target>
        </trans-unit>
        <trans-unit id="7739aadce94ee1918ea9fc44988ea37dc88f140e" translate="yes" xml:space="preserve">
          <source>The two main ones are polymorphism, and validation. Even if it's just a stupid data structure.</source>
          <target state="translated">Los dos principales son el polimorfismo y la validación.Incluso si es sólo una estúpida estructura de datos.</target>
        </trans-unit>
        <trans-unit id="b9a9f0d33bc8f65d834ed4cf962cc15baead1b5f" translate="yes" xml:space="preserve">
          <source>There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:</source>
          <target state="translated">Hay muchas razones.Mi favorita es cuando necesitas cambiar el comportamiento o regular lo que puedes establecer en una variable.Por ejemplo,digamos que tienes un método setSpeed(int speed).Pero quieres que sólo puedas establecer una velocidad máxima de 100.Harías algo como:</target>
        </trans-unit>
        <trans-unit id="524aa01135463f9e6500b1024feefe5ec35bdc47" translate="yes" xml:space="preserve">
          <source>There are reasons to use getters and setters, but if those reasons don't exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (&lt;em&gt;You Ain't Gonna Need It&lt;/em&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Hay razones para usar getters y setters, pero si esas razones no existen, hacer pares getter / setter en nombre de dioses de encapsulaci&amp;oacute;n falsa no es algo bueno. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las razones v&amp;aacute;lidas para hacer captadores o establecedores incluyen las cosas que a menudo se mencionan como los posibles cambios que puede realizar m&amp;aacute;s adelante, como la validaci&amp;oacute;n o diferentes representaciones internas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O tal vez el valor deber&amp;iacute;a ser legible por los clientes pero no escribible (por ejemplo, leer el tama&amp;ntilde;o de un diccionario), por lo que un simple captador es una buena opci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero esas razones deber&amp;iacute;an estar ah&amp;iacute; cuando elijas, y no solo como algo potencial que podr&amp;iacute;as desear m&amp;aacute;s adelante. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta es una instancia de YAGNI ( &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No lo vas a necesitar&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b6a012407992d0adb452537e445403437702a64" translate="yes" xml:space="preserve">
          <source>There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.</source>
          <target state="translated">Hay algunas ventajas en el uso de los métodos de getter y setter,como la posibilidad de crear miembros con sofisticadas funcionalidades a las que se puede acceder como propiedades.También te permiten crear propiedades de sólo lectura y sólo escritura.</target>
        </trans-unit>
        <trans-unit id="5c8b73cc0e9f101f3c612ae902d16016395b6ff9" translate="yes" xml:space="preserve">
          <source>There is a good reason to consider using accessors is there is no property inheritance. See next example:</source>
          <target state="translated">Hay una buena razón para considerar el uso de accesorios es que no hay herencia de propiedad.Ver el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="527645e19a15fbeecf356eccaa2e86a93ccde33b" translate="yes" xml:space="preserve">
          <source>There's also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.</source>
          <target state="translated">También hay una tercera cosa que no todos han abordado:los getters y setters usan llamadas de método.Eso significa que se parecen a los métodos normales que se usan en todas partes.En lugar de tener una sintaxis específica rara para los DTOs y esas cosas,tienes lo mismo en todas partes.</target>
        </trans-unit>
        <trans-unit id="18f126ceaf487ac6623f0c3bab85bbe1bcdce5fe" translate="yes" xml:space="preserve">
          <source>Think simple, easy, add complexity when needed.</source>
          <target state="translated">Piensa simple,fácil,añade complejidad cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="6515a583147f1258a376ba45fbb548e8c25fcfa1" translate="yes" xml:space="preserve">
          <source>This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you're breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you're breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.</source>
          <target state="translated">Este mismo argumento se aplica a otras supuestas ventajas de estos pares de pass-through gettersetter:si más tarde decides cambiar el valor que se está fijando,estás rompiendo el contrato.Si anulas la funcionalidad por defecto en una clase derivada,de alguna manera más allá de unas pocas modificaciones inofensivas (como el registro u otro comportamiento no observable),estás rompiendo el contrato de la clase base.Eso es una violación del Principio de Sustituibilidad de Liskov,que es visto como uno de los principios de OO.</target>
        </trans-unit>
        <trans-unit id="05f52926063e95fcb6e5b9afd2e3d36583ed0188" translate="yes" xml:space="preserve">
          <source>Those methods are the infamous getter and setter....</source>
          <target state="translated">Esos métodos son el infame &quot;getter and setter&quot;...</target>
        </trans-unit>
        <trans-unit id="09878a7e0e4131a45151cbbe07487842d574b319" translate="yes" xml:space="preserve">
          <source>Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.</source>
          <target state="translated">Comprender un código local a primera vista es una propiedad importante de buena legibilidad que los receptores y fijadores tienden a romper.Por eso intento evitarlos cuando puedo,y minimizar lo que hacen cuando los uso.</target>
        </trans-unit>
        <trans-unit id="0eff2b28e1b8f812b912f6b07b88bbaa84ab213d" translate="yes" xml:space="preserve">
          <source>We use getters and setters:</source>
          <target state="translated">Usamos getters y setters:</target>
        </trans-unit>
        <trans-unit id="5cdeb7802b982ac4d4c3fa7153f628c2667c933a" translate="yes" xml:space="preserve">
          <source>We'd end up with something like:</source>
          <target state="translated">Terminaríamos con algo como:</target>
        </trans-unit>
        <trans-unit id="10fa626645112c1ff717613b8f6c9dd7afc7b203" translate="yes" xml:space="preserve">
          <source>Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to &lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;STOP OVERUSING THE ACCESSORS&lt;/a&gt;&lt;/strong&gt;, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bueno, solo quiero agregar que incluso si a veces son necesarias para la encapsulaci&amp;oacute;n y la seguridad de sus variables / objetos, si queremos codificar un programa orientado a objetos real, entonces debemos &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DEJAR DE USAR LOS ACCESORIOS&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , porque a veces dependemos mucho sobre ellos cuando no es realmente necesario y eso hace casi lo mismo que si pusi&amp;eacute;ramos las variables p&amp;uacute;blicas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944804080828b744e35ec9aff8cde845d88d15f4" translate="yes" xml:space="preserve">
          <source>Well, you wouldn't expect that to work, right?
You want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.</source>
          <target state="translated">Bueno,no esperarías que eso funcionara,¿verdad? Quieres que haya algún tipo de control de la cordura.Y peor aún,¿qué pasa si nunca he especificado la capacidad máxima? Oh,querido,tenemos un problema.</target>
        </trans-unit>
        <trans-unit id="26aac9603bf87fbcf6a374fcbcc4557be0d4afa4" translate="yes" xml:space="preserve">
          <source>What happens when I do:</source>
          <target state="translated">Lo que pasa cuando lo hago:</target>
        </trans-unit>
        <trans-unit id="64e4e54e2b623a26f20e0a947aca9d4d41d5f2ff" translate="yes" xml:space="preserve">
          <source>What's the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?</source>
          <target state="translated">¿Cuál es la ventaja de usar getters y setters-que sólo get and set-en lugar de usar simplemente campos públicos para esas variables?</target>
        </trans-unit>
        <trans-unit id="bc1451039d4e3d9bf5c818e53a8cb441a696e201" translate="yes" xml:space="preserve">
          <source>When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you've directly accessed it.</source>
          <target state="translated">Cuando te das cuenta de que necesitas hacer algo más que establecer y obtener el valor,puedes hacer que el campo sea privado,lo que te dirá instantáneamente dónde has accedido directamente.</target>
        </trans-unit>
        <trans-unit id="9b9c2e122eb7bcbff9d3e55249a64348b7c398a2" translate="yes" xml:space="preserve">
          <source>When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don't want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it's called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won't be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.</source>
          <target state="translated">Cuando escribes las clases,siempre se te anima a hacer privadas tantas variables de tu instancia como sea posible y añadir métodos de getter y setter en consecuencia.Esto se debe a que hay varias veces en las que puede que no quieras dejar que los usuarios cambien ciertas variables dentro de tus clases.Por ejemplo,si tienes un método estático privado que rastrea el número de instancias creadas para una clase específica,no querrás que un usuario modifique ese contador usando código.Sólo la sentencia constructora debe incrementar esa variable cada vez que se llame.En esta situación,puede crear una variable de instancia privada y permitir un método getter sólo para la variable del contador,lo que significa que los usuarios podrán recuperar el valor actual sólo mediante el método getter,y no podrán establecer nuevos valores mediante el método setter.Crear un getter sin un setter es una forma sencilla de hacer que ciertas variables de su clase sean de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="4d347fb8867285cc6a44cfd1b9af0e1b9e8d0d52" translate="yes" xml:space="preserve">
          <source>Whereas the former takes a lot less boilerplate code.</source>
          <target state="translated">Mientras que el primero requiere mucho menos código de calderilla.</target>
        </trans-unit>
        <trans-unit id="c5b5b0a202322fa3613116e9cbb7a5bf916b32a2" translate="yes" xml:space="preserve">
          <source>Why use getters and setters/accessors</source>
          <target state="translated">¿Por qué usar los getters y settersaccessors</target>
        </trans-unit>
        <trans-unit id="a23c4ec681b338f0e1fb882b204499718bf7417d" translate="yes" xml:space="preserve">
          <source>With 10 million cycles, the times are almost the same.
Here are 100 thousand (0.1 million) cycles:</source>
          <target state="translated">Con 10 millones de ciclos,los tiempos son casi los mismos.Aquí hay 100 mil (0,1 millones)de ciclos:</target>
        </trans-unit>
        <trans-unit id="e79ce24276092380db82c3f8e4404e6712bb5095" translate="yes" xml:space="preserve">
          <source>You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.</source>
          <target state="translated">Puedes cambiar el valor que se establece-esto es una absoluta pesadilla cuando la persona que llama te pasa un valor que ellos [horror de choque]quieren que guardes TAL CUAL.</target>
        </trans-unit>
        <trans-unit id="a8c50aac8fd19a1ea4829de498fc35d71feadd5e" translate="yes" xml:space="preserve">
          <source>You can hide the internal representation - fantastic, so you're making sure that all these operations are symmetrical right?</source>
          <target state="translated">Puedes ocultar la representación interna-fantástico,así que te aseguras de que todas estas operaciones son simétricas,¿verdad?</target>
        </trans-unit>
        <trans-unit id="2d6a0b7af8d1a9e87f51afd2f0f83ec48ca965c9" translate="yes" xml:space="preserve">
          <source>You may find more about them in Section 3.5 of &lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;Elegant Objects&lt;/a&gt; (my book about object-oriented programming).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede encontrar m&amp;aacute;s informaci&amp;oacute;n sobre ellos en la Secci&amp;oacute;n 3.5 de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Objetos elegantes&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (mi libro sobre programaci&amp;oacute;n orientada a objetos).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20973387eacad480489a6f5295307c1dee98b593" translate="yes" xml:space="preserve">
          <source>You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.
The results:</source>
          <target state="translated">Verás,el receptor es (casi)siempre un poco más rápido.Entonces lo intenté con diferentes números de ciclos.En lugar de 1 millón,usé 10 millones y 0,1 millones.Los resultados:</target>
        </trans-unit>
        <trans-unit id="a53b89844949d31aba6d3481e30d7696c0678c0c" translate="yes" xml:space="preserve">
          <source>You should use getters and setters when:</source>
          <target state="translated">Deberías usar getters y setters cuando..:</target>
        </trans-unit>
        <trans-unit id="8e50d4342310f2eace5776eb8cfc9f9aa9776c1a" translate="yes" xml:space="preserve">
          <source>You're dealing with something that is conceptually an attribute, but:</source>
          <target state="translated">Estás tratando con algo que es conceptualmente un atributo,pero:</target>
        </trans-unit>
        <trans-unit id="34fca68fe5cf9480f0a80d7c0c498c348f56c7dd" translate="yes" xml:space="preserve">
          <source>You've insulated your public interface from changes under the sheets - if you were designing an interface and weren't sure whether direct access to something was OK, then you should have kept designing.</source>
          <target state="translated">Si estabas diseñando una interfaz y no estabas seguro de si el acceso directo a algo estaba bien,entonces deberías haber seguido diseñando.</target>
        </trans-unit>
        <trans-unit id="3ceeaa00b6851469e15bf3447e9cd44a83c071a4" translate="yes" xml:space="preserve">
          <source>Your language doesn't have properties (or some similar mechanism, like Tcl's variable traces), or</source>
          <target state="translated">Su lenguaje no tiene propiedades (o algún mecanismo similar,como las trazas variables de Tcl),o</target>
        </trans-unit>
        <trans-unit id="5abc216f8d207459eff730de712d1ae80e9f4266" translate="yes" xml:space="preserve">
          <source>Your language's (or sometimes your framework's) idiomatic conventions encourage getters or setters for this use case.</source>
          <target state="translated">Las convenciones idiomáticas de su lenguaje (o a veces de su marco)alientan a los que se dedican a este caso de uso.</target>
        </trans-unit>
        <trans-unit id="4a0520484ec8d35c906b8b68216ce4e15364da56" translate="yes" xml:space="preserve">
          <source>Your language's property support isn't sufficient for this use case, or</source>
          <target state="translated">El apoyo a la propiedad de su idioma no es suficiente para este caso de uso,o</target>
        </trans-unit>
        <trans-unit id="25eba86acee0fb5d6e89e75ccf0a09f1599a6c92" translate="yes" xml:space="preserve">
          <source>better;</source>
          <target state="translated">better;</target>
        </trans-unit>
        <trans-unit id="5f8adcfcb2808cbefe8948076116555c4b76f193" translate="yes" xml:space="preserve">
          <source>faster.</source>
          <target state="translated">faster.</target>
        </trans-unit>
        <trans-unit id="cac0e0595d1759f6424ad536496e3c73b57e1223" translate="yes" xml:space="preserve">
          <source>for members you have only one access specification for both setting and getting</source>
          <target state="translated">para los miembros sólo tienes una especificación de acceso tanto para establecer como para obtener</target>
        </trans-unit>
        <trans-unit id="b648b79089ac12bd90bd3cb58b4439f26f462e08" translate="yes" xml:space="preserve">
          <source>for reusability</source>
          <target state="translated">para la reutilización</target>
        </trans-unit>
        <trans-unit id="4618d40a12eec35b743c0d33ec26c6ee634eb9ad" translate="yes" xml:space="preserve">
          <source>for setters and getters you can fine tune it and define it separately</source>
          <target state="translated">para los setters y getters puedes afinarlo y definirlo por separado</target>
        </trans-unit>
        <trans-unit id="273bf92b0c3d89955ec505b2f149212919216d10" translate="yes" xml:space="preserve">
          <source>is any worse than:</source>
          <target state="translated">es peor que:</target>
        </trans-unit>
        <trans-unit id="dbe1b4e53e52bda3546c73c53e0d35d11158f6a4" translate="yes" xml:space="preserve">
          <source>safer; and</source>
          <target state="translated">más seguro;y</target>
        </trans-unit>
        <trans-unit id="22d6eb61e8eb4da06f77da4c904a9784e7917342" translate="yes" xml:space="preserve">
          <source>to perform validation in later stages of programming</source>
          <target state="translated">para realizar la validación en etapas posteriores de la programación</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
