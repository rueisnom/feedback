<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1568091">
    <body>
      <group id="1568091">
        <trans-unit id="811ef1a393584a7d8880f3ef855143bdd7cae4ff" translate="yes" xml:space="preserve">
          <source>(Time 1 is the direct way, Time 2 is the getter)</source>
          <target state="translated">(Время 1-прямой путь,Время 2-геттер)</target>
        </trans-unit>
        <trans-unit id="2674e860c37ef14352b7760e1bb68edd1812e340" translate="yes" xml:space="preserve">
          <source>1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ &quot;example&quot; code you'll notice me using &lt;code&gt;struct&lt;/code&gt; instead of &lt;code&gt;class&lt;/code&gt; everywhere.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) Начните со всех открытых членов для основных объектов с данными и поведением. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот почему во всем моем &amp;laquo;примерном&amp;raquo; коде C ++ вы заметите, что я &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;везде &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использую &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вместо &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9afae1edbdd3713190c6b92e13771fa366eb26a3" translate="yes" xml:space="preserve">
          <source>10 million cycles:</source>
          <target state="translated">10 миллионов циклов:</target>
        </trans-unit>
        <trans-unit id="164834c50a9442cbf6258a5472c287b312c938dc" translate="yes" xml:space="preserve">
          <source>2) When an object's internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal &lt;code&gt;std::list&lt;/code&gt; in some kind of order), accessor type functions are written.  Because I'm programming by myself, I don't always set the member &lt;code&gt;private&lt;/code&gt; right away, but somewhere down the evolution of the class the member will be &quot;promoted&quot; to either &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2) Когда внутреннее поведение объекта для члена данных становится достаточно сложным (например, ему нравится хранить внутренний &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в некотором порядке), пишутся функции типа средства доступа. Поскольку я сам занимаюсь программированием, я не всегда сразу устанавливаю &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; члена &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, но где-то в процессе эволюции класса член будет &amp;laquo;повышен&amp;raquo; до уровня &lt;/font&gt;&lt;/font&gt; &lt;code&gt;protected&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7892b3b7150042db597eb83df3fa2fc4d4a5356e" translate="yes" xml:space="preserve">
          <source>3) Classes that are fully fleshed out and have strict rules about their internals (ie &lt;em&gt;they&lt;/em&gt; know exactly what they are doing, and you are not to &quot;fuck&quot; (technical term) with its internals) are given the &lt;code&gt;class&lt;/code&gt; designation, default private members, and only a select few members are allowed to be &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) Классы, которые полностью проработаны и имеют строгие правила в отношении своих внутренних элементов (то есть &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;они&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; точно знают, что они делают, и вы не должны &amp;laquo;трахать&amp;raquo; (технический термин) с его внутренними &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;элементами &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;), получают &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обозначение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , закрытые члены по умолчанию и только избранным членам разрешено быть &lt;/font&gt;&lt;/font&gt; &lt;code&gt;public&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b75455e8497af8e0568b85b084a32699e8ec694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Here are the some of the reasons I am aware of:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот некоторые из причин, которые мне известны:&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3cca966ff39b9fe1ddc20c0c05c5ab85772f223b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;Oh... cool, I guess?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Клиент&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;Ох ... круто, наверное?&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da3e4c734e73e93fbd221e07e4b36c403db2d6c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;What can I do with an object of this class?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Клиент&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &amp;laquo;Что я могу сделать с объектом этого класса?&amp;raquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="255733b7d5ec2727df67865b9399e6f16913e0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code to the interface, not the implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код для интерфейса, а не реализация&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3009decd56c1847ecaff29ac42deaeb96d7e5ed9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Designer&lt;/strong&gt;: &quot;You can read and write several variables.&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Дизайнер&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &amp;laquo;Вы можете читать и писать несколько переменных&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9327bbc5dd989bbd9c8de05113c4531259a85e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getter Methods:&lt;/strong&gt;&lt;em&gt;We can get access to private variables.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Методы получения: &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;мы можем получить доступ к закрытым переменным.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49c576902394b2f88aa9c23003d5ca3259732bc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getters&lt;/strong&gt; and &lt;strong&gt;setters&lt;/strong&gt; are used to implement two of the fundamental aspects of Object Oriented Programming which are:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Геттеры&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сеттеры&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; используются для реализации двух основных аспектов объектно-ориентированного программирования:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75bf09d32278474950179c8e319e9ebd15d37d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interfaces only specify methods, not fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Интерфейсы только указывают методы, а не поля&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9db04f55b8e825e0380143c8c6459e9bd8ff383" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setter Methods:&lt;/strong&gt;&lt;em&gt;We can modify private fields.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Методы установки: &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;мы можем изменять приватные поля.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e77ba06d495a30414d7393b72695c1a32bd8ea5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are actually &lt;em&gt;many good reasons&lt;/em&gt; to consider using accessors&lt;/strong&gt; rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На самом деле есть &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;много веских причин,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы рассмотреть вопрос об использовании методов доступа,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а не обнародовать поля класса - кроме аргумента инкапсуляции и облегчения будущих изменений.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9b3b8c7d55f7b60e6b667f7483bd9cd9c8e936e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* Even for that simple class, you may not necessarily want to allow setting the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values. If this is really a class, shouldn't it have methods like &lt;code&gt;translate&lt;/code&gt;, &lt;code&gt;rotate&lt;/code&gt;, etc.? If it's only a class because your language doesn't have records/structs/named tuples, then this isn't really a question of OO&amp;hellip;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* Даже для этого простого класса вам не обязательно разрешать установку &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;значений &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это действительно класс, разве не должно быть таких методов, как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;translate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rotate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и т. Д.? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это только класс, потому что ваш язык не имеет записей / структур / именованных кортежей, то это на самом деле не вопрос ОО&amp;hellip;&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9f1c7ed63a610cca03dbe1fb9a5969b1641f70d2" translate="yes" xml:space="preserve">
          <source>A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it's clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.</source>
          <target state="translated">Публичное поле не хуже геттерсеттерной пары,которая ничего не делает,кроме как возвращает поле и присваивает его.Во-первых,понятно,что (в большинстве языков)функциональной разницы нет.Любая разница должна быть связана с другими факторами,такими как удобство обслуживания или читабельность.</target>
        </trans-unit>
        <trans-unit id="9ef49733b07a04ac879a3131cf59a6bb592d931f" translate="yes" xml:space="preserve">
          <source>A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).</source>
          <target state="translated">Очень простой класс,который вмещает в себя столько жидкости,сколько в ней содержится,и каково ее количество (в миллилитрах).</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="82749ef4d632eabe207c0f5bfe48e65659005062" translate="yes" xml:space="preserve">
          <source>Accessors and mutators also allow for encapsulation - if you aren't supposed to see the value once its set (perhaps it's set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.</source>
          <target state="translated">Аксессуары и мутаторы также допускают инкапсуляцию-если вы не должны видеть значение после его установки (возможно,оно установлено в конструкторе и затем используется методами,но никогда не должно быть изменено),то оно никогда не будет видно никому.Но если вы можете разрешить другим классам видеть или изменять его,вы можете предоставить подходящий андор и андор мутатор.</target>
        </trans-unit>
        <trans-unit id="a4355e16716c8eb9f55ad860a735f5c6eda863c4" translate="yes" xml:space="preserve">
          <source>Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That's how you can define and maintain useful invariants.</source>
          <target state="translated">Добавление пар проходных геттерсеттеров к такому классу не добавляет никакой ценности.Другие классы должны предоставлять содержательные операции,а не только операции,которые уже предоставляют поля.Так можно определить и поддерживать полезные инварианты.</target>
        </trans-unit>
        <trans-unit id="3d5035c0f50aaed825f8024c67607f79c9d6f00e" translate="yes" xml:space="preserve">
          <source>Additionally, this is to &quot;future-proof&quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just &quot;set/get the field&quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.</source>
          <target state="translated">Кроме того,это для &quot;будущего&quot; вашего класса.В частности,переход от поля к свойству-это разрыв ABI,так что если вы позже решите,что вам нужно больше логики,чем просто &quot;setget the field&quot;,то вам нужно разбить ABI,что,конечно,создает проблемы для всего остального,что уже скомпилировано против вашего класса.</target>
        </trans-unit>
        <trans-unit id="81c4e73e61dcb9ef881221a8e3e6e510aaafccd3" translate="yes" xml:space="preserve">
          <source>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</source>
          <target state="translated">Позволяет наследникам изменять семантику того,как свойство ведет себя и подвергается воздействию,переопределяя методы геттерсеттера.</target>
        </trans-unit>
        <trans-unit id="57a93d1fb290ddf7a1dbf6a3c46ddb1f2bd05da4" translate="yes" xml:space="preserve">
          <source>Allowing the getter/setter to be passed around as lambda expressions rather than values.</source>
          <target state="translated">Позволяет передавать геттерсеттер в виде лямбда-выражений,а не значений.</target>
        </trans-unit>
        <trans-unit id="43274d4e786c79c30fbd5d48e83bf0480818a226" translate="yes" xml:space="preserve">
          <source>Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.</source>
          <target state="translated">Также при различном количестве циклов,геттер немного быстрее обычного.Надеюсь,это тебе помогло.</target>
        </trans-unit>
        <trans-unit id="033534469fa80b3c8584bdbf1263c23f9a826be5" translate="yes" xml:space="preserve">
          <source>Also, it's important to follow the idioms of the language (or framework) you're using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that's bad. Some languages have stronger cultures around their conventions than others.&amp;mdash;and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, важно следовать идиомам языка (или структуры), который вы используете. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы пишете красивый код в стиле Ruby на C #, любой опытный разработчик C #, кроме вас, будет испытывать трудности при его чтении, и это плохо. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Некоторые языки имеют более сильные культуры в своих соглашениях, чем другие. И это не может быть совпадением, что Java и Python, которые находятся на разных концах спектра того, насколько идиоматическими являются добытчики, имеют две из самых сильных культур.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d11a9b94f688fd1bb3e8236ba806a1a0de41e921" translate="yes" xml:space="preserve">
          <source>An oft-mentioned advantage of getter/setter pairs, isn't. There's this claim that you can change the implementation and your clients don't have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don't even need to know about it. However, adding validation to a setter is a change to its preconditions, &lt;strong&gt;a violation of the previous contract&lt;/strong&gt;, which was, quite simply, &quot;you can put anything in here, and you can get that same thing later from the getter&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Часто упоминаемое преимущество пар геттер / сеттер - это не так. Есть утверждение, что вы можете изменить реализацию, и ваши клиенты не должны перекомпилироваться. Предположительно, сеттеры позволяют вам добавлять функциональность, такую ​​как проверка, и вашим клиентам даже не нужно знать об этом. Однако добавление проверки к установщику является изменением его предварительных условий, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;нарушением предыдущего контракта&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , который, по сути, заключался в том, что &amp;laquo;вы можете положить сюда что-нибудь, и вы можете получить то же самое позже от получателя&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0528fa85939d91318183d46b3de68fa50d141cc4" translate="yes" xml:space="preserve">
          <source>And all these can have different ways to handle various whoopsies. The Bottle just checks and if it's overflowing it throws a RuntimeException. But that might be the wrong thing to do. 
(There is a useful discussion to be had about error handling, but I'm keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )</source>
          <target state="translated">И все это может иметь разные способы справиться с разными сумасбродствами.Бутылка просто проверяет,и если она переполнена,она бросает RuntimeException.Но это может быть неправильным.(Есть полезная дискуссия об обработке ошибок,но здесь я специально все упрощаю.Люди в комментариях,скорее всего,укажут на недостатки этого упрощенного подхода.;))</target>
        </trans-unit>
        <trans-unit id="b3709a8d644d6848cb9e1e1b2612c33a14d466f8" translate="yes" xml:space="preserve">
          <source>And yes, it seems like we go from a very simple idea to getting much better answers quickly.</source>
          <target state="translated">И да,кажется,что мы переходим от очень простой идеи к быстрому получению гораздо лучших ответов.</target>
        </trans-unit>
        <trans-unit id="8c0adc3715c9771354c8ce3bffb1a2caa8b06842" translate="yes" xml:space="preserve">
          <source>Any validation you perform in there can only be context free, which validation rarely is in practice.</source>
          <target state="translated">Любая валидация,которую вы там проводите,может быть только бесконтекстной,что редко встречается на практике.</target>
        </trans-unit>
        <trans-unit id="47b2dd5b5d660068e61383ca22ea5c24356d49a6" translate="yes" xml:space="preserve">
          <source>Anywhere a value can be used, a method that returns that value can be added. Instead of:</source>
          <target state="translated">Везде,где можно использовать значение,можно добавить метод,возвращающий это значение.Вместо этого:</target>
        </trans-unit>
        <trans-unit id="ac6f0e579cd82854d73b7ba5e3dee370470c5bf1" translate="yes" xml:space="preserve">
          <source>As for the &quot;what if I want to change my implementation later?&quot; question (which is repeated multiple times in different wording in both the OP's question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn't support that. So this is really just the same case again.</source>
          <target state="translated">Что касается вопроса &quot;что,если я хочу изменить свою реализацию позже?&quot; (который повторяется несколько раз в разных формулировках как в вопросе ОП,так и в принятом ответе):Если это действительно чистое изменение реализации,и вы начали с атрибута,вы можете изменить его на свойство,не затрагивая интерфейс.Если,конечно,ваш язык этого не поддерживает.Так что на самом деле это опять тот же самый случай.</target>
        </trans-unit>
        <trans-unit id="43cacfbdc83927cc4b2aad1396ab0622fbf9274d" translate="yes" xml:space="preserve">
          <source>Because 2 weeks (months, years) from now when you realize that your setter needs to do &lt;strong&gt;more&lt;/strong&gt; than just set the value, you'll also realize that the property has been used directly in 238 other classes :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Потому что через 2 недели (месяцы, годы), когда вы поймете, что ваш установщик должен делать &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;больше,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чем просто установить значение, вы также поймете, что свойство было использовано непосредственно в 238 других классах :-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e510c63de41dc0facb98c85d5c568e3eeeafd444" translate="yes" xml:space="preserve">
          <source>Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don't. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don't fight them.</source>
          <target state="translated">Помимо читателей-людей,существуют библиотеки и инструменты,которые ожидают,что вы будете следовать конвенциям и сделаете свою жизнь труднее,если вы этого не сделаете.Подключение виджетов Hooking Interface Builder к чему угодно,кроме свойств ObjC,или использование некоторых насмешливых библиотек Java без геттеров,только усложняет вашу жизнь.Если инструменты важны для вас,не боритесь с ними.</target>
        </trans-unit>
        <trans-unit id="fac3c0dab4aeb3d8c561a0f4789de6b3ef9c2a67" translate="yes" xml:space="preserve">
          <source>But nobody is ever doing general OO design. They're doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.</source>
          <target state="translated">Но никто никогда не занимается генеральным проектированием.Они занимаются проектированием и внедрением,на определенном языке.А в некоторых языках геттеры и сеттеры далеко не бесполезны.</target>
        </trans-unit>
        <trans-unit id="34bfb1e4e8fe780f6179a91f408e1aeba2e095cb" translate="yes" xml:space="preserve">
          <source>But there's another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn't that be better? Since interfaces demand methods, this is also a good thing.</source>
          <target state="translated">Но есть и другая проблема.Что если бы бутылки были всего лишь одним типом контейнеров? Что,если бы у нас было несколько контейнеров,все с емкостями и количеством жидкости? Если бы мы могли просто сделать интерфейс,мы могли бы позволить остальной части нашей программы принять этот интерфейс,и бутылки,канистры и всевозможные вещи просто работали бы взаимозаменяемо.Разве это не было бы лучше? Так как интерфейсы требуют методов,это тоже хорошо.</target>
        </trans-unit>
        <trans-unit id="5f581816971f55a0fe7fe755c1439b557642dd88" translate="yes" xml:space="preserve">
          <source>Code &lt;em&gt;evolves&lt;/em&gt;.  &lt;code&gt;private&lt;/code&gt; is great for when &lt;em&gt;you need data member protection&lt;/em&gt;.  Eventually all classes should be sort of &quot;miniprograms&quot; that have a well-defined interface &lt;em&gt;that you can't just screw with the internals of&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;развивается&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; отлично подходит, когда &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вам нужна защита членов данных&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . В конце концов, все классы должны быть своего рода &amp;laquo;минипрограммами&amp;raquo;, которые имеют четко определенный интерфейс, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;который вы не можете просто&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; испортить &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77e195f98a65d1f5b54c0c97c7133a6067f84b7e" translate="yes" xml:space="preserve">
          <source>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</source>
          <target state="translated">Управление семантикой времени жизни и управления памятью (утилизации)свойства-особенно важно в неуправляемых окружениях памяти (например,C++или Objective-C).</target>
        </trans-unit>
        <trans-unit id="451d8c398dac194d41c458e0b0ad881903b0f15e" translate="yes" xml:space="preserve">
          <source>Depends on your language.  You've tagged this &quot;object-oriented&quot; rather than &quot;Java&quot;, so I'd like to point out that ChssPly76's answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:</source>
          <target state="translated">Зависит от твоего языка.Вы пометили этот &quot;объектно-ориентированный&quot;,а не &quot;Java&quot;,поэтому я хотел бы отметить,что ответ ChssPly76 зависит от языка.На Python,например,нет причин использовать геттеры и сеттеры.Если нужно изменить поведение,можно использовать свойство,которое обёртывает геттер и сеттер вокруг доступа к базовому атрибуту.Что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="59b09c675389e93fb718c3607a2b33d8ced3dba3" translate="yes" xml:space="preserve">
          <source>Don't use getters setters unless needed for your current delivery I.e. Don't think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.</source>
          <target state="translated">Не используйте сеттеры геттеров,если они не нужны для вашей текущей поставки,т.е.не думайте слишком много о том,что случится в будущем,если что-то будет изменено,это запрос на изменение в большинстве производственных приложений,систем.</target>
        </trans-unit>
        <trans-unit id="4811f53244f0f4eb1f508c3dce99ba627e7afab2" translate="yes" xml:space="preserve">
          <source>EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they're not as easy to understand if you're a newbie. We were all newbies, so I thought I'd try my hand at a more newbie friendly answer.</source>
          <target state="translated">EDIT:Я ответил на этот вопрос,потому что есть куча людей,изучающих программирование,которые спрашивают об этом,и большинство ответов очень технически грамотны,но их не так легко понять,если вы новичок.Мы все были новичками,поэтому я решил попробовать свои силы в более дружелюбном ответе для новичков.</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="045c9ac03fcd3840d51b0f2e3b7fc9b7a8a9f185" translate="yes" xml:space="preserve">
          <source>Encapsulation mantra</source>
          <target state="translated">инкапсуляция Мантры</target>
        </trans-unit>
        <trans-unit id="08518ebb827eeba5eb31bb4abc223904fb6d8e7c" translate="yes" xml:space="preserve">
          <source>Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.</source>
          <target state="translated">Инкапсуляция поведения,связанного с получением или установкой свойства-это позволяет легче добавлять дополнительную функциональность (например,валидацию)позже.</target>
        </trans-unit>
        <trans-unit id="a273aa55c91241aef5cbe7c904175deb629c3048" translate="yes" xml:space="preserve">
          <source>Even if your language does have properties, there may be cases where they're insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can't substitute a computed property for an attribute.</source>
          <target state="translated">Даже если ваш язык обладает свойствами,могут быть случаи,когда они недостаточны или неуместны.Например,если Вы хотите разрешить подклассам управлять семантикой атрибута,в языках без динамического доступа,подкласс не может заменить вычисленное свойство атрибутом.</target>
        </trans-unit>
        <trans-unit id="e83595b7e6ea6eac5ba12ba0e0ea2bbad5c8a4f7" translate="yes" xml:space="preserve">
          <source>Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.</source>
          <target state="translated">Несмотря на то,что методы getter и setter полезны,следует быть осторожным,чтобы не злоупотреблять ими,так как,помимо прочего,они могут усложнить сопровождение кода в определенных ситуациях.Кроме того,они предоставляют доступ к реализации вашего класса,как и публичные члены.Практика ООП препятствует прямому доступу к свойствам внутри класса.</target>
        </trans-unit>
        <trans-unit id="d63ca1863a03a6cc66be541e8b13351b917e9595" translate="yes" xml:space="preserve">
          <source>Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method</source>
          <target state="translated">Несмотря на то,что методы геттера и сеттера не добавляют новой функциональности,мы можем передумать и вернуться позже,чтобы сделать этот метод</target>
        </trans-unit>
        <trans-unit id="67bba4f9917627abec7de3eae66ae2f912a2559b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;foo&lt;/code&gt; was public, I could easily set it to &lt;code&gt;null&lt;/code&gt; and then someone else could try to call a method on the object. But it's not there anymore! With a &lt;code&gt;setFoo&lt;/code&gt; method, I could ensure that &lt;code&gt;foo&lt;/code&gt; was never set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; было общедоступным, я мог бы легко установить его в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а затем кто-то другой мог бы попытаться вызвать метод объекта. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но его больше нет! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С помощью &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метода &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFoo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; я мог убедиться, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; никогда не был установлен на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476a63abfc2fa3c03aedf4736d5d9942e91d901f" translate="yes" xml:space="preserve">
          <source>From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: &lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С точки зрения проектно-ориентированного проектирования обе альтернативы могут повредить обслуживанию кода, ослабляя инкапсуляцию классов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для обсуждения вы можете заглянуть в эту прекрасную статью: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a74b1d741c07f0d10578559f597f6187841258b7" translate="yes" xml:space="preserve">
          <source>From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you've written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.</source>
          <target state="translated">С точки зрения теории OO,геттеры и сеттеры бесполезны.Интерфейс вашего класса-это то,что он делает,а не его состояние.(Если нет,то вы написали не тот класс.)В очень простых случаях,когда то,что делает класс,это просто,например,представляет точку в прямоугольных координатах*,атрибуты являются частью интерфейса;геттеры и сеттеры просто затуманивают это.Но ни в чём,кроме очень простых случаев,ни атрибуты,ни геттеры,ни сеттеры не являются частью интерфейса.</target>
        </trans-unit>
        <trans-unit id="57ae158f2e8c761e3b5b8bb16e7dccf2d8f722c4" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.</source>
          <target state="translated">Методы Getter и Setter являются методами доступа,что означает,что они,как правило,являются публичным интерфейсом для изменения членов приватного класса.Вы используете методы getter и setter для определения свойства.Вы получаете доступ к методам getter и setter как к свойствам вне класса,даже если вы определяете их внутри класса как методы.Эти свойства вне класса могут иметь другое имя,чем имя свойства в классе.</target>
        </trans-unit>
        <trans-unit id="aee376df07aa660dacecd6260f852a6d918c4cd1" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are public interfaces to access private class members.</source>
          <target state="translated">Методы Getter и Setter являются публичными интерфейсами для доступа к закрытым членам класса.</target>
        </trans-unit>
        <trans-unit id="cba3e268c215d8706586fc9b9c009cffacae2d3a" translate="yes" xml:space="preserve">
          <source>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</source>
          <target state="translated">Геттеры и сеттеры могут разрешать различные уровни доступа-например,геттер может быть публичным,но набор может быть защищен.</target>
        </trans-unit>
        <trans-unit id="a06c2f62c876887f1c33b514ac9a69553b2b6392" translate="yes" xml:space="preserve">
          <source>Great! And now we just change Bottle to this:</source>
          <target state="translated">Здорово! А теперь мы просто поменяем Бутылку на эту:</target>
        </trans-unit>
        <trans-unit id="de8d815e48132f09b9bca3cbd23f2f97e119a145" translate="yes" xml:space="preserve">
          <source>Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.</source>
          <target state="translated">Здесь детали реализации Full Name скрыты от пользователя и не доступны непосредственно пользователю,в отличие от публичного атрибута.</target>
        </trans-unit>
        <trans-unit id="3fa394821ab09cbccd5563100429404ca95e6440" translate="yes" xml:space="preserve">
          <source>Hiding the internal representation of the property while exposing a property using an alternative representation.</source>
          <target state="translated">Скрытие внутреннего представления имущества при выставке имущества с использованием альтернативного представления.</target>
        </trans-unit>
        <trans-unit id="d2f4f5cef8a9ea91e08ca99ee45e39ac9dcd0ebe" translate="yes" xml:space="preserve">
          <source>I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class's evolution.</source>
          <target state="translated">Я считаю,что такой подход позволяет мне избежать сидения и религиозного написания геттерсеттеров,когда многие члены данных мигрируют,перемещаются и т.д.на ранних стадиях эволюции класса.</target>
        </trans-unit>
        <trans-unit id="7ac905efee55cbf685e08af0da10c6d4468cd4fe" translate="yes" xml:space="preserve">
          <source>I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn't always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of &quot;slow&quot;, so you don't want to make a web service call if you don't have to.</source>
          <target state="translated">У меня был класс базовой страницы в проекте,который был передан мне и который загружал некоторые данные из пары разных вызовов веб-сервиса,но данные в этих вызовах веб-сервиса не всегда использовались на всех дочерних страницах.Веб-службы,при всех преимуществах,стали пионерами новых определений &quot;медленных&quot;,так что вы не захотите совершать вызов веб-службы,если вам это не нужно.</target>
        </trans-unit>
        <trans-unit id="fec0ce430c9b50fa6a42a74bb5cc7bbe5070bd9d" translate="yes" xml:space="preserve">
          <source>I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.</source>
          <target state="translated">У меня есть огромные системы,написанные без сеттеров геттеров только с модификаторами доступа и некоторыми методами проверки n выполняют biz логику.Если вам это было абсолютно необходимо.Используйте что угодно.</target>
        </trans-unit>
        <trans-unit id="b23c3487d24d1993bf58de911e47e2492ae65d64" translate="yes" xml:space="preserve">
          <source>I know it's a bit late, but I think there are some people who are interested in performance.</source>
          <target state="translated">Я знаю,что немного поздно,но я думаю,что есть люди,которые заинтересованы в выступлении.</target>
        </trans-unit>
        <trans-unit id="db14da99dc1a19fe0a1cec21c694b1166cec8396" translate="yes" xml:space="preserve">
          <source>I moved from public fields to getters, and now the getters check the cache, and if it's not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.</source>
          <target state="translated">Я перешел от публичных полей к геттерам,и теперь геттеры проверяют кэш,и если его нет,звоните в веб-службу.Так что с небольшой оберткой,многие звонки в веб-службу были предотвращены.</target>
        </trans-unit>
        <trans-unit id="d44fc766ecbf5e63030bb952d02b5d6adbd46593" translate="yes" xml:space="preserve">
          <source>I spent quite a while thinking this over for the Java case, and I believe the real reasons are:</source>
          <target state="translated">Я потратил довольно много времени на обдумывание этого дела для Java,и я считаю,что настоящие причины таковы:</target>
        </trans-unit>
        <trans-unit id="2889b32bfcc03c8e80e260ed4b4716b29ae177b9" translate="yes" xml:space="preserve">
          <source>I would just like to throw the idea of annotation : @getter and @setter. With @getter, you should be able to obj = class.field but not class.field = obj. With @setter, vice versa. With @getter and @setter you should be able to do both. This would preserve encapsulation and reduce the time by not calling trivial methods at runtime.</source>
          <target state="translated">Я просто хотел бы бросить идею аннотации:@getter и @setter.С помощью @getter вы должны иметь возможность obj=class.field,но не class.field=obj.С @setter,наоборот.С помощью @getter и @setter вы должны уметь делать и то,и другое.Это позволит сохранить инкапсуляцию и сократить время,не вызывая тривиальные методы во время выполнения.</target>
        </trans-unit>
        <trans-unit id="448e5ff21f920e7e7eae20ce3fd54ad0522d451c" translate="yes" xml:space="preserve">
          <source>I would not take advantage of ignorance of business owners of deep technical know how just because I think it's correct or I like the approach.</source>
          <target state="translated">Я бы не воспользовался невежеством владельцев бизнеса с глубокими техническими знаниями просто потому,что я считаю это правильным или мне нравится подход.</target>
        </trans-unit>
        <trans-unit id="91a599d9c25706ea81b0f073fcd9ead9e1d48f03" translate="yes" xml:space="preserve">
          <source>I'll leave the definition of the BottleOverflowException as an exercise to the reader.</source>
          <target state="translated">Я оставлю определение BottleOverflowException как упражнение для читателя.</target>
        </trans-unit>
        <trans-unit id="c0cfd8d8587de574184a35bdea413f3d36872445" translate="yes" xml:space="preserve">
          <source>I've done a little performance test. I wrote a class &quot;NumberHolder&quot; which, well, holds an Integer. You can either read that Integer by using the getter method
&lt;code&gt;anInstance.getNumber()&lt;/code&gt; or by directly accessing the number by using &lt;code&gt;anInstance.number&lt;/code&gt;. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I've got the following result:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я сделал небольшой тест производительности. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я написал класс &quot;NumberHolder&quot;, который, ну, в общем, содержит целое число. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете либо прочитать это Integer, используя метод &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.getNumber()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; либо напрямую получить доступ к номеру, используя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Моя программа читает число 1 000 000 000 раз обоими способами. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот процесс повторяется пять раз, и время печатается. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я получил следующий результат:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0978c43bc2b11a6a993b548afff0b3b5ca45a92" translate="yes" xml:space="preserve">
          <source>If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, &lt;em&gt;no contract&lt;/em&gt;. Is that really object-oriented design? If all the class has is those getters and setters, it's just a dumb data holder, and dumb data holders should look like dumb data holders:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если у класса есть эти тупые методы получения и установки для каждого поля, то это класс, который не имеет ни инвариантов, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ни контракта&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это действительно объектно-ориентированный дизайн? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если все, что есть в классе, это те геттеры и сеттеры, это просто тупой держатель данных, и тупые держатели данных должны выглядеть как тупые держатели данных:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46fb1f117749485f93dfde52629c12a6592e5f3e" translate="yes" xml:space="preserve">
          <source>If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I'm not 100% clear on how:</source>
          <target state="translated">Если геттеры и сеттеры когда-нибудь делают больше,чем просто геттеры,я могу разобраться в этом очень быстро,но я не на 100% понимаю,как:</target>
        </trans-unit>
        <trans-unit id="949e9da0978aaee4523cbb0c409b2bf0b89c3805" translate="yes" xml:space="preserve">
          <source>If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. &lt;em&gt;That's the exact opposite of encapsulation&lt;/em&gt; If that field could not really be set to anything from the start, why wasn't the validation there from the start?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это не должно было быть контрактом, то интерфейс позволял клиентам переводить объект в недопустимые состояния. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это полная противоположность инкапсуляции.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Если это поле не может быть действительно установлено с нуля с самого начала, почему не было проверки с самого начала?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d442a6315e08af677c7d3f5fd084eb11ecca9ce5" translate="yes" xml:space="preserve">
          <source>If your language doesn't have properties, then the only way to represent something that's conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.</source>
          <target state="translated">Если у вашего языка нет свойств,то единственный способ представить что-то,что концептуально является атрибутом,но на самом деле вычисляется,или проверяется,и т.д.,это через геттеры и сеттеры.</target>
        </trans-unit>
        <trans-unit id="c75e6d8a92da8554d6134d8d780910766638384b" translate="yes" xml:space="preserve">
          <source>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</source>
          <target state="translated">Улучшенная совместимость с библиотеками,которые предназначены для работы с геттерсеттерами свойств-на ум приходят насмешки,сериализация и WPF.</target>
        </trans-unit>
        <trans-unit id="a045af26b3882dcd948db97f36b10344affa5eda" translate="yes" xml:space="preserve">
          <source>In a pure object-oriented world getters and setters is a &lt;strong&gt;terrible anti-pattern&lt;/strong&gt;. Read this article: &lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;Getters/Setters. Evil. Period&lt;/a&gt;. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В чистом объектно-ориентированном мире геттеры и сеттеры это &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;страшный анти-паттерн&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Прочитайте эту статью: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getters / Setters. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Злой. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Период&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Короче говоря, они поощряют программистов думать об объектах как о структурах данных, и этот тип мышления является чисто процедурным (как в COBOL или C). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В объектно-ориентированном языке нет структур данных, а есть только объекты, демонстрирующие поведение (не атрибуты / свойства!)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60ede22798c8886c1279c94029a7d8fbdb115073" translate="yes" xml:space="preserve">
          <source>In an object oriented language the methods, and their access modifiers, declare the interface for that object. Between the constructor and the accessor and mutator methods it is possible for the developer to control access to the internal state of an object. If the variables are simply declared public then there is no way to regulate that access.
And when we are using setters we can restrict the user for the input we need. Mean the feed for that very variable will come through a proper channel and the channel is predefined by us. So it's safer to use setters.</source>
          <target state="translated">На объектно-ориентированном языке методы и модификаторы доступа к ним объявляют интерфейс для этого объекта.Между конструктором и методами доступа и мутаторами разработчик может контролировать доступ к внутреннему состоянию объекта.Если переменные просто объявлены публично,то нет никакого способа регулировать этот доступ.А когда мы используем сеттеры,мы можем ограничить пользователя на нужный нам вход.Это означает,что входная информация для этой самой переменной будет поступать по соответствующему каналу,а канал предопределен нами.Так что безопаснее использовать сеттеры.</target>
        </trans-unit>
        <trans-unit id="9570686c65057df9d5555a427b45dcb388eb1c6d" translate="yes" xml:space="preserve">
          <source>In languages which don't support &quot;properties&quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.</source>
          <target state="translated">В языках,которые не поддерживают &quot;свойства&quot; (C++,Java)или требуют перекомпиляции клиентов при изменении полей на свойства (C#),использование методов getet легче модифицировать.Например,добавление логики валидации в метод setFoo не потребует изменения публичного интерфейса класса.</target>
        </trans-unit>
        <trans-unit id="49c146ae67da9fce98a67aa9876195255bf52355" translate="yes" xml:space="preserve">
          <source>In languages which support &quot;real&quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.</source>
          <target state="translated">В языках,которые поддерживают &quot;реальные&quot; свойства (Python,Ruby,может быть Smalltalk?),нет смысла приобретать методы.</target>
        </trans-unit>
        <trans-unit id="9a756c26f5397e6bf09cb6c1e8673c721a0adcdc" translate="yes" xml:space="preserve">
          <source>In layman's terms</source>
          <target state="translated">В дилетантском плане</target>
        </trans-unit>
        <trans-unit id="03538993fd141670ce7112b8a39c0f3f3dcb7e47" translate="yes" xml:space="preserve">
          <source>In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.</source>
          <target state="translated">Другими словами,единственный способ указать поле в интерфейсе-это указать метод записи нового значения и метод чтения текущего значения.</target>
        </trans-unit>
        <trans-unit id="665cb9197ac6f3430ff52c71c900a99810bbd645" translate="yes" xml:space="preserve">
          <source>Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.</source>
          <target state="translated">Унаследовав этот класс,вы можете переопределить функциональность по умолчанию-другими словами,вы можете НЕОБХОДИМО запутать вызывающих абонентов,не только скрыв реализацию,но и сделав ее непоследовательной.</target>
        </trans-unit>
        <trans-unit id="2a50b3b7baaffbe0c2005cff92a6863837d540b1" translate="yes" xml:space="preserve">
          <source>Instead of</source>
          <target state="translated">вместо</target>
        </trans-unit>
        <trans-unit id="3a846f258ad5630d87aa074967dac3d41a23874d" translate="yes" xml:space="preserve">
          <source>Instead of doing this, we can create a bean &lt;code&gt;class(Person)&lt;/code&gt; with getter and setter methods.  So tomorrow we can just create objects of this Bean &lt;code&gt;class(Person class)&lt;/code&gt; whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вместо этого мы можем создать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bean &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Person)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с методами getter и setter. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому завтра мы можем просто создавать объекты этого &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person class)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Bean &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(класса Person)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; всякий раз, когда нам нужно добавить нового человека (см. Рисунок). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, мы повторно используем поля и методы класса bean, что намного лучше.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebdc6050b1ad6649a3451d6af5910e06b12430e3" translate="yes" xml:space="preserve">
          <source>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</source>
          <target state="translated">Изоляция вашего публичного интерфейса от изменений-позволяет публичному интерфейсу оставаться постоянным,в то время как внедрение меняется,не затрагивая существующих потребителей.</target>
        </trans-unit>
        <trans-unit id="5ac0c56e853fb8f8f0be1b64596f6b59055cbdae" translate="yes" xml:space="preserve">
          <source>It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don't want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.</source>
          <target state="translated">Он может быть полезен при ленивой загрузке.Скажем,объект хранится в базе данных,и вы не захотите идти за ним,если он вам не нужен.Если объект извлекается геттером,то внутренний объект может быть нулевым до тех пор,пока кто-то его не попросит,тогда вы можете пойти и получить его при первом же вызове геттера.</target>
        </trans-unit>
        <trans-unit id="cc4afcf1103ef9d6c53108ff6cc9b9b18bdb3242" translate="yes" xml:space="preserve">
          <source>It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.</source>
          <target state="translated">Это дает вам много преимуществ,одним из которых является то,что вы можете изменить реализацию геттерсеттера за кулисами,но любой потребитель этой ценности будет продолжать работать до тех пор,пока тип данных остается прежним.</target>
        </trans-unit>
        <trans-unit id="729e36d06a905476ea11f5c8b0c1812a73dff9ce" translate="yes" xml:space="preserve">
          <source>It's a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that's where your memory leak was occurring.</source>
          <target state="translated">Это красивый простой кусок кода,пока вы не поймете,что это сеттер.Теперь,вы следуете этому сеттеру и обнаружите,что он также устанавливает person.firstName,person.lastName,person.isHuman,person.hasReallyCommonFirstName,и вызывает person.update(),которая посылает запрос в базу данных,и т.д..Вот где произошла утечка памяти.</target>
        </trans-unit>
        <trans-unit id="16aa234236b2a7935d4484df427e10358d69a866" translate="yes" xml:space="preserve">
          <source>Let's say we have this simple class:</source>
          <target state="translated">Допустим,у нас есть этот простой урок:</target>
        </trans-unit>
        <trans-unit id="c9377946989c0599e694f34e6e15b1e30f95e7bb" translate="yes" xml:space="preserve">
          <source>Lots of people talk about the advantages of getters and setters but I want to play devil's advocate. Right now I'm debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.</source>
          <target state="translated">Многие говорят о преимуществах геттеров и сеттеров,но я хочу поиграть в дьявольского защитника.Сейчас я отлаживаю очень большую программу,где программисты решили сделать все геттеры и сеттеры.Это может показаться неплохим,но это реверс-инженерный кошмар.</target>
        </trans-unit>
        <trans-unit id="1d38c1d25ba364989ccc66f32498e40bbffbe427" translate="yes" xml:space="preserve">
          <source>My 2 cents :)</source>
          <target state="translated">Мои 2 цента :)</target>
        </trans-unit>
        <trans-unit id="89bcb9ce512e3a24b71ffdc4db2c607ef7562d71" translate="yes" xml:space="preserve">
          <source>Not only is &lt;code&gt;getVar()&lt;/code&gt; visually noisy, it gives this illusion that &lt;code&gt;gettingVar()&lt;/code&gt; is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of &lt;code&gt;var&lt;/code&gt; is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you're putting up these gates to &quot;protect&quot; something you insist is valuable, (the sanctity of &lt;code&gt;var&lt;/code&gt;) but yet even you concede &lt;code&gt;var&lt;/code&gt;'s protection isn't worth much by the ability for anyone to just come in and &lt;code&gt;set&lt;/code&gt;&lt;code&gt;var&lt;/code&gt; to whatever value they want, without you even peeking at what they are doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не только &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;визуально зашумлен, но и создает иллюзию того, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;gettingVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является более сложным процессом, чем на самом деле. То, как вы (как писатель класса) относитесь к святости &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , особенно сбивает с толку пользователя вашего класса, если у него есть промежуточный установщик - тогда похоже, что вы открываете эти ворота, чтобы &amp;laquo;защитить&amp;raquo; то, на чем вы настаиваете, ценно , (святость &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), но даже если вы признаете, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что защита &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не стоит того, чтобы кто-то мог просто войти и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;set&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на любое значение, которое он хочет, даже если вы даже не смотрите на то, что он делает.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25ccd6d1abfaa462958a3daf7b3c72739444cbb" translate="yes" xml:space="preserve">
          <source>Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.</source>
          <target state="translated">А теперь заметьте,насколько это надежнее.Теперь мы можем работать с любым типом контейнеров в нашем коде,принимая LiquidContainer вместо Bottle.И то,как эти бутылки справляются с такими вещами,может различаться.Можно иметь бутылки,которые записывают свое состояние на диск,когда оно меняется,или бутылки,которые хранятся в базах данных SQL или GNU знают,что еще.</target>
        </trans-unit>
        <trans-unit id="ee14a6cb3f5a0e797943e0e6cf7bc7231a57d7bc" translate="yes" xml:space="preserve">
          <source>Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.</source>
          <target state="translated">Что теперь,если КАКОГДА в вашем коде вы использовали публичное поле,а затем поняли,что вам нужно вышеуказанное требование? Получайте удовольствие,отслеживая каждое использование поля public вместо того,чтобы просто модифицировать свой сеттер.</target>
        </trans-unit>
        <trans-unit id="bea2afcb08c47bb55bd603ad05f6ae591ec6e48a" translate="yes" xml:space="preserve">
          <source>On the other hand, if the member is public, the tools don't make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.</source>
          <target state="translated">С другой стороны,если член является публичным,инструменты не позволяют отфильтровать доступ к чтению для члена.Таким образом,вам приходится перебирать все варианты использования этого члена.</target>
        </trans-unit>
        <trans-unit id="e9f8893e9b850ac172431cb049bc524b942b2431" translate="yes" xml:space="preserve">
          <source>One advantage of accessors and mutators is that you can perform validation.</source>
          <target state="translated">Одним из преимуществ аксессуаров и мутаторов является то,что вы можете выполнять проверку.</target>
        </trans-unit>
        <trans-unit id="91b95b7297fe9079d417e879ad5486deb384c22d" translate="yes" xml:space="preserve">
          <source>One aspect I missed in the answers so far, the access specification:</source>
          <target state="translated">Один аспект,который я пропустил в ответах,спецификация доступа:</target>
        </trans-unit>
        <trans-unit id="10765ac54cefce78aa01ff15a00dd5d27040fc3d" translate="yes" xml:space="preserve">
          <source>One of the basic principals of OO design: &lt;strong&gt;Encapsulation!&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Один из основных принципов ОО дизайна: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;инкапсуляция!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b5607ce4ce1a004d9de9e90c6bbff2691c7ffe7" translate="yes" xml:space="preserve">
          <source>One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that's computationally expensive in a property.</source>
          <target state="translated">Еще одно использование (в языках,поддерживающих свойства)-это то,что сеттеры и геттеры могут подразумевать,что операция является нетривиальной.Обычно,вы хотите избежать делать в свойстве что-то,что связано с большими вычислительными затратами.</target>
        </trans-unit>
        <trans-unit id="76713a423e5722e517c06fbab6e7cfe5f4817367" translate="yes" xml:space="preserve">
          <source>One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.</source>
          <target state="translated">Относительно современным преимуществом геттерссеттеров является то,что они облегчают просмотр кода в редакторах с тегами (индексированными).Например,если вы хотите посмотреть,кто устанавливает член,вы можете открыть иерархию вызовов сеттера.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="be9cbb9ed4b5c6641f5aa815d9709c0e21aceeaa" translate="yes" xml:space="preserve">
          <source>Please note also that you can't change the capacity of a bottle. It's now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can't limit the access to touching the innards.</source>
          <target state="translated">Пожалуйста,обратите внимание,что вместимость бутылки не может быть изменена.Теперь она установлена в камне.Ты можешь сделать это с помощью информатора,объявив его окончательным.Но если бы это был список,вы могли бы опустошить его,добавить в него новые вещи и так далее.Ты не можешь ограничить доступ к внутренности.</target>
        </trans-unit>
        <trans-unit id="36c1fd3f265a620d873362378468f7e90e8a20ae" translate="yes" xml:space="preserve">
          <source>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</source>
          <target state="translated">Обеспечение точки перехвата при отладке,когда какое-либо свойство изменяется во время выполнения-отладка,когда и где какое-либо свойство изменяется до определенного значения,на некоторых языках может быть довольно сложным без этого.</target>
        </trans-unit>
        <trans-unit id="3e2aa20a27ca3d6e7b23af75afca271955543ebe" translate="yes" xml:space="preserve">
          <source>Put another way: If you believe that consumers of your class shouldn't even know that you have a &lt;code&gt;spam&lt;/code&gt; attribute, much less be able to change it willy-nilly, then giving them a &lt;code&gt;set_spam&lt;/code&gt; method is the last thing you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другими словами: если вы считаете, что потребители вашего класса даже не должны знать, что у вас есть &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;атрибут &lt;/font&gt;&lt;/font&gt; &lt;code&gt;spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , тем более, что вы можете изменить его &lt;/font&gt;&lt;/font&gt; &lt;code&gt;set_spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , тогда предоставление им &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метода &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;set_spam&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это последнее, что вы хотите сделать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2800b08281984434942ba5adcad8919a80ff4cc" translate="yes" xml:space="preserve">
          <source>Say you're looking through hundreds of lines of code and you come across this:</source>
          <target state="translated">Скажем,что ты просматриваешь сотни строк кода и сталкиваешься с этим:</target>
        </trans-unit>
        <trans-unit id="0fe6038ebdf6b117336c04451dc9e3876effcb5c" translate="yes" xml:space="preserve">
          <source>So I program as follows (assuming an &quot;agile&quot; type approach -- ie when I write code not knowing &lt;em&gt;exactly&lt;/em&gt; what it will be doing/don't have time or experience to plan an elaborate waterfall style interface set):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому я программирую следующим образом (предполагая подход &amp;laquo;гибкого&amp;raquo; типа - то есть когда я пишу код, не зная &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;точно,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что он будет делать / не имеет времени или опыта для планирования сложного набора интерфейсов стилей водопада):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9eda9489b827ab46566f12f43fa4c89312a585f" translate="yes" xml:space="preserve">
          <source>So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don't already have it.</source>
          <target state="translated">Так что геттер спасает меня от попыток выяснить на каждой детской странице,что мне понадобится.Если она мне понадобится,я звоню геттеру,и он идет искать ее для меня,если у меня ее еще нет.</target>
        </trans-unit>
        <trans-unit id="3d0d9303819ce1ab413fffddd86f3afbed876b1f" translate="yes" xml:space="preserve">
          <source>So this is very rarely a general OO question; it's a language-specific question, with different answers for different languages (and different use cases).</source>
          <target state="translated">Таким образом,это очень редко является общим вопросом OO;это языковой вопрос,с разными ответами для разных языков (и разных случаев использования).</target>
        </trans-unit>
        <trans-unit id="110215a582ce0c01e647e0ab38866bd28ab289f7" translate="yes" xml:space="preserve">
          <source>So you have:</source>
          <target state="translated">Так и есть:</target>
        </trans-unit>
        <trans-unit id="84327f3567507ed383657990eb8c4dfa0d117dca" translate="yes" xml:space="preserve">
          <source>So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you're making the assumption that all the code assumed the contract for those methods was different.</source>
          <target state="translated">Итак,теперь,когда вы нарушили договор,изменение каждого файла в кодебазе-это то,чего вы должны хотеть,а не избегать.Если вы избегаете этого,вы делаете предположение,что все коды предполагали,что контракт на эти методы был разным.</target>
        </trans-unit>
        <trans-unit id="cbead7356f0d8824aecb16d6a0262b6c772bd6e2" translate="yes" xml:space="preserve">
          <source>Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.</source>
          <target state="translated">Некоторые библиотеки ожидают этого,но не многие-отражение,сериализация,насмешка над объектами-все это прекрасно работает с публичными полями.</target>
        </trans-unit>
        <trans-unit id="b8d6ec5b172b09312ffab2762d5844c299a54132" translate="yes" xml:space="preserve">
          <source>Suppose we have an Employee class:</source>
          <target state="translated">Предположим,у нас есть класс для сотрудников:</target>
        </trans-unit>
        <trans-unit id="f0b6a967a2c05a11d643d0e4a7aa868f211882c5" translate="yes" xml:space="preserve">
          <source>Suppose we need to store the details of this &lt;code&gt;Person&lt;/code&gt;. This &lt;code&gt;Person&lt;/code&gt; has the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Doing this involves creating methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Now if we need create another person, it becomes necessary to create the methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;sex&lt;/code&gt; all over again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, нам нужно хранить данные этого &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Этот &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поля &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Это включает в себя создание методов для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Теперь, если нам нужно создать другого человека, становится необходимым снова и снова создавать методы для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3e474c35abac8c8e79adba6fbbab7a5646b1ac0" translate="yes" xml:space="preserve">
          <source>Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:</source>
          <target state="translated">Спасибо,это действительно прояснило мои мысли.Теперь вот (почти)10 (почти)веских причин НЕ использовать геттеры и сеттеры:</target>
        </trans-unit>
        <trans-unit id="a29e9e3845b5c733ae0c153286a63607107be5fa" translate="yes" xml:space="preserve">
          <source>That said, &lt;em&gt;software development&lt;/em&gt; isn't about setting down that final version of the class as if you're pressing some cast iron statue on the first try.  While you're working with it, code is more like clay.  &lt;strong&gt;It evolves&lt;/strong&gt; as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;разработка программного обеспечения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не сводится к установке окончательной версии класса, как будто вы нажимаете на чугунную статую с первой попытки. Пока вы работаете с ним, код больше похож на глину. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он развивается по мере того,&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как вы его разрабатываете и узнаете больше о проблемной области, которую вы решаете. Во время разработки классы могут взаимодействовать друг с другом, чем они должны (зависимость, которую вы планируете выделить), объединяться или разделяться. Поэтому я думаю, что дискуссия сводится к людям, которые не хотят писать религиозно&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fc364b2a3ee96e69b00f590088b9c6ef9c9b632" translate="yes" xml:space="preserve">
          <source>The encapsulation mantra is to make fields private and methods public.</source>
          <target state="translated">Мантра инкапсуляции заключается в том,чтобы сделать поля частными и методы публичными.</target>
        </trans-unit>
        <trans-unit id="24c1a5142c379d866afbafbee078155a76918b88" translate="yes" xml:space="preserve">
          <source>The last three I'm just leaving (N/A or D/C)...</source>
          <target state="translated">Последние три я уже ухожу (NA или DC)...</target>
        </trans-unit>
        <trans-unit id="7739aadce94ee1918ea9fc44988ea37dc88f140e" translate="yes" xml:space="preserve">
          <source>The two main ones are polymorphism, and validation. Even if it's just a stupid data structure.</source>
          <target state="translated">Два основных-полиморфизм и валидация.Даже если это просто глупая структура данных.</target>
        </trans-unit>
        <trans-unit id="b9a9f0d33bc8f65d834ed4cf962cc15baead1b5f" translate="yes" xml:space="preserve">
          <source>There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:</source>
          <target state="translated">Есть много причин.Моя любимая-это когда нужно изменить поведение или регулировать то,что можно задать в переменной.Например,скажем,у вас был метод setSpeed(int speed).Но вы хотите,чтобы вы могли установить только максимальную скорость 100.Вы бы сделали что-нибудь в этом роде:</target>
        </trans-unit>
        <trans-unit id="524aa01135463f9e6500b1024feefe5ec35bdc47" translate="yes" xml:space="preserve">
          <source>There are reasons to use getters and setters, but if those reasons don't exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (&lt;em&gt;You Ain't Gonna Need It&lt;/em&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть причины использовать геттеры и сеттеры, но если этих причин не существует, создание пар геттер / сеттер во имя ложных богов инкапсуляции не очень хорошая вещь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Допустимые причины для создания или получения включают в себя такие вещи, которые часто упоминаются как потенциальные изменения, которые вы можете сделать позже, такие как проверка или другие внутренние представления. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Или, может быть, это значение должно быть доступно для чтения клиентами, но не доступно для записи (например, чтение размера словаря), поэтому простой метод получения - хороший выбор. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но эти причины должны быть, когда вы делаете выбор, а не просто как потенциальная вещь, которую вы можете захотеть позже. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это пример YAGNI (он &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тебе не нужен&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b6a012407992d0adb452537e445403437702a64" translate="yes" xml:space="preserve">
          <source>There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.</source>
          <target state="translated">Есть некоторые преимущества в использовании методов getter и setter,такие как возможность позволять вам создавать членов со сложной функциональностью,к которым вы можете получить доступ,как к свойствам.Они также позволяют создавать свойства только для чтения и записи.</target>
        </trans-unit>
        <trans-unit id="5c8b73cc0e9f101f3c612ae902d16016395b6ff9" translate="yes" xml:space="preserve">
          <source>There is a good reason to consider using accessors is there is no property inheritance. See next example:</source>
          <target state="translated">Существует веская причина рассматривать использование аксессуаров-это отсутствие наследования собственности.См.следующий пример:</target>
        </trans-unit>
        <trans-unit id="527645e19a15fbeecf356eccaa2e86a93ccde33b" translate="yes" xml:space="preserve">
          <source>There's also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.</source>
          <target state="translated">Есть также третья вещь,к которой не все обращались:геттеры и сеттеры используют вызовы методов.Это означает,что они выглядят как обычные методы везде.Вместо того,чтобы иметь странный специфический синтаксис для DTO и прочего,у вас везде одно и то же.</target>
        </trans-unit>
        <trans-unit id="18f126ceaf487ac6623f0c3bab85bbe1bcdce5fe" translate="yes" xml:space="preserve">
          <source>Think simple, easy, add complexity when needed.</source>
          <target state="translated">Думайте просто,легко,добавляйте сложности,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="6515a583147f1258a376ba45fbb548e8c25fcfa1" translate="yes" xml:space="preserve">
          <source>This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you're breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you're breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.</source>
          <target state="translated">Этот же аргумент применим и к другим предполагаемым преимуществам этих сквозных пар геттерсеттеров:если вы позже решите изменить установленное значение,вы нарушаете договор.Если вы переопределяете функциональность по умолчанию в производном классе,выходя за рамки нескольких безобидных модификаций (таких как протоколирование или другое ненаблюдаемое поведение),вы нарушаете договор базового класса.Это является нарушением принципа заменяемости Лискова,который рассматривается как один из принципов OO.</target>
        </trans-unit>
        <trans-unit id="05f52926063e95fcb6e5b9afd2e3d36583ed0188" translate="yes" xml:space="preserve">
          <source>Those methods are the infamous getter and setter....</source>
          <target state="translated">Эти методы-печально известные геттер и сеттер....</target>
        </trans-unit>
        <trans-unit id="09878a7e0e4131a45151cbbe07487842d574b319" translate="yes" xml:space="preserve">
          <source>Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.</source>
          <target state="translated">Понимание локальной части кода на первый взгляд является важным свойством хорошей читабельности,которое геттеры и сеттеры имеют тенденцию ломаться.Поэтому я стараюсь избегать их,когда могу,и минимизировать то,что они делают,когда я их использую.</target>
        </trans-unit>
        <trans-unit id="0eff2b28e1b8f812b912f6b07b88bbaa84ab213d" translate="yes" xml:space="preserve">
          <source>We use getters and setters:</source>
          <target state="translated">Мы используем геттеры и сеттеры:</target>
        </trans-unit>
        <trans-unit id="5cdeb7802b982ac4d4c3fa7153f628c2667c933a" translate="yes" xml:space="preserve">
          <source>We'd end up with something like:</source>
          <target state="translated">Мы бы закончили чем-то вроде:</target>
        </trans-unit>
        <trans-unit id="10fa626645112c1ff717613b8f6c9dd7afc7b203" translate="yes" xml:space="preserve">
          <source>Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to &lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;STOP OVERUSING THE ACCESSORS&lt;/a&gt;&lt;/strong&gt;, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ну, я просто хочу добавить, что даже если иногда они необходимы для инкапсуляции и безопасности ваших переменных / объектов, если мы хотим закодировать реальную объектно-ориентированную программу, нам нужно &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ОСТАНОВИТЬ ПРЕОДОЛЕНИЕ АКСЕССОРОВ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , потому что иногда мы сильно зависимы на них, когда это действительно не нужно, и это делает почти то же самое, как если бы мы сделали переменные общедоступными&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944804080828b744e35ec9aff8cde845d88d15f4" translate="yes" xml:space="preserve">
          <source>Well, you wouldn't expect that to work, right?
You want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.</source>
          <target state="translated">Ну,ты же не ожидал,что это сработает,верно? Ты хочешь,чтобы была какая-то проверка на вменяемость.И что еще хуже,что если я никогда не буду указывать максимальную вместимость? О боже,у нас проблема.</target>
        </trans-unit>
        <trans-unit id="26aac9603bf87fbcf6a374fcbcc4557be0d4afa4" translate="yes" xml:space="preserve">
          <source>What happens when I do:</source>
          <target state="translated">Что будет,когда я это сделаю:</target>
        </trans-unit>
        <trans-unit id="64e4e54e2b623a26f20e0a947aca9d4d41d5f2ff" translate="yes" xml:space="preserve">
          <source>What's the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?</source>
          <target state="translated">В чем преимущество использования геттеров и сеттеров-которые только получают и устанавливают-вместо того,чтобы просто использовать публичные поля для этих переменных?</target>
        </trans-unit>
        <trans-unit id="bc1451039d4e3d9bf5c818e53a8cb441a696e201" translate="yes" xml:space="preserve">
          <source>When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you've directly accessed it.</source>
          <target state="translated">Когда вы понимаете,что вам нужно сделать больше,чем просто установить и получить значение,вы можете просто сделать поле приватным,которое мгновенно скажет вам,где вы получили прямой доступ к нему.</target>
        </trans-unit>
        <trans-unit id="9b9c2e122eb7bcbff9d3e55249a64348b7c398a2" translate="yes" xml:space="preserve">
          <source>When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don't want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it's called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won't be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.</source>
          <target state="translated">При написании классов всегда рекомендуется делать как можно больше переменных вашего экземпляра приватными и добавлять методы getter и setter соответственно.Это связано с тем,что бывает несколько случаев,когда вы не хотите,чтобы пользователи меняли определенные переменные в ваших классах.Например,если у вас есть приватный статический метод,который отслеживает количество экземпляров,созданных для конкретного класса,вы не хотите,чтобы пользователь изменял этот счетчик с помощью кода.Только оператор конструктора должен увеличивать эту переменную при каждом ее вызове.В этой ситуации вы можете создать приватную переменную экземпляра и разрешить метод getter только для переменной счетчика,то есть пользователи смогут получать текущее значение только с помощью метода getter,и они не смогут устанавливать новые значения с помощью метода setter.Создание геттера без вычислителя-это простой способ сделать определенные переменные в вашем классе доступными только для чтения.</target>
        </trans-unit>
        <trans-unit id="4d347fb8867285cc6a44cfd1b9af0e1b9e8d0d52" translate="yes" xml:space="preserve">
          <source>Whereas the former takes a lot less boilerplate code.</source>
          <target state="translated">В то время как первый занимает намного меньше кода шаблона.</target>
        </trans-unit>
        <trans-unit id="c5b5b0a202322fa3613116e9cbb7a5bf916b32a2" translate="yes" xml:space="preserve">
          <source>Why use getters and setters/accessors</source>
          <target state="translated">Зачем использовать геттеры и сеттер-аксессуары.</target>
        </trans-unit>
        <trans-unit id="a23c4ec681b338f0e1fb882b204499718bf7417d" translate="yes" xml:space="preserve">
          <source>With 10 million cycles, the times are almost the same.
Here are 100 thousand (0.1 million) cycles:</source>
          <target state="translated">С 10 миллионами циклов время почти одинаково.Здесь 100 тысяч (0,1 миллиона)циклов:</target>
        </trans-unit>
        <trans-unit id="e79ce24276092380db82c3f8e4404e6712bb5095" translate="yes" xml:space="preserve">
          <source>You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.</source>
          <target state="translated">Вы можете изменить установленное значение-это абсолютный кошмар,когда звонящий передает вам значение,которое он [шокирует ужас]хочет,чтобы вы сохранили КАК ЕСТЬ.</target>
        </trans-unit>
        <trans-unit id="a8c50aac8fd19a1ea4829de498fc35d71feadd5e" translate="yes" xml:space="preserve">
          <source>You can hide the internal representation - fantastic, so you're making sure that all these operations are symmetrical right?</source>
          <target state="translated">Внутреннее представление можно скрыть-фантастика,значит,все эти операции симметричны,верно?</target>
        </trans-unit>
        <trans-unit id="2d6a0b7af8d1a9e87f51afd2f0f83ec48ca965c9" translate="yes" xml:space="preserve">
          <source>You may find more about them in Section 3.5 of &lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;Elegant Objects&lt;/a&gt; (my book about object-oriented programming).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете найти больше о них в Разделе 3.5 &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Элегантных объектов&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (моя книга об объектно-ориентированном программировании).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20973387eacad480489a6f5295307c1dee98b593" translate="yes" xml:space="preserve">
          <source>You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.
The results:</source>
          <target state="translated">Видишь ли,геттер (почти)всегда немного быстрее.Потом я попробовал с разным количеством циклов.Вместо 1 миллиона я использовал 10 миллионов и 0,1 миллиона.Результаты:</target>
        </trans-unit>
        <trans-unit id="a53b89844949d31aba6d3481e30d7696c0678c0c" translate="yes" xml:space="preserve">
          <source>You should use getters and setters when:</source>
          <target state="translated">Вы должны использовать геттеры и сеттеры,когда:</target>
        </trans-unit>
        <trans-unit id="8e50d4342310f2eace5776eb8cfc9f9aa9776c1a" translate="yes" xml:space="preserve">
          <source>You're dealing with something that is conceptually an attribute, but:</source>
          <target state="translated">Ты имеешь дело с чем-то,что концептуально является атрибутом,но..:</target>
        </trans-unit>
        <trans-unit id="34fca68fe5cf9480f0a80d7c0c498c348f56c7dd" translate="yes" xml:space="preserve">
          <source>You've insulated your public interface from changes under the sheets - if you were designing an interface and weren't sure whether direct access to something was OK, then you should have kept designing.</source>
          <target state="translated">Вы изолировали свой публичный интерфейс от изменений под листами-если вы проектировали интерфейс и не были уверены,что прямой доступ к чему-то в порядке,то вам следовало продолжить проектирование.</target>
        </trans-unit>
        <trans-unit id="3ceeaa00b6851469e15bf3447e9cd44a83c071a4" translate="yes" xml:space="preserve">
          <source>Your language doesn't have properties (or some similar mechanism, like Tcl's variable traces), or</source>
          <target state="translated">Ваш язык не имеет свойств (или какого-то похожего механизма,например,трассы переменных Tcl),или</target>
        </trans-unit>
        <trans-unit id="5abc216f8d207459eff730de712d1ae80e9f4266" translate="yes" xml:space="preserve">
          <source>Your language's (or sometimes your framework's) idiomatic conventions encourage getters or setters for this use case.</source>
          <target state="translated">Идиоматические конвенции вашего языка (а иногда и вашей структуры)поощряют геттеров или сеттеров в этом случае использования.</target>
        </trans-unit>
        <trans-unit id="4a0520484ec8d35c906b8b68216ce4e15364da56" translate="yes" xml:space="preserve">
          <source>Your language's property support isn't sufficient for this use case, or</source>
          <target state="translated">Поддержка собственности на вашем языке не достаточна для этого случая использования,или</target>
        </trans-unit>
        <trans-unit id="25eba86acee0fb5d6e89e75ccf0a09f1599a6c92" translate="yes" xml:space="preserve">
          <source>better;</source>
          <target state="translated">better;</target>
        </trans-unit>
        <trans-unit id="5f8adcfcb2808cbefe8948076116555c4b76f193" translate="yes" xml:space="preserve">
          <source>faster.</source>
          <target state="translated">faster.</target>
        </trans-unit>
        <trans-unit id="cac0e0595d1759f6424ad536496e3c73b57e1223" translate="yes" xml:space="preserve">
          <source>for members you have only one access specification for both setting and getting</source>
          <target state="translated">для членов у вас есть только одна спецификация доступа как для настройки,так и для получения</target>
        </trans-unit>
        <trans-unit id="b648b79089ac12bd90bd3cb58b4439f26f462e08" translate="yes" xml:space="preserve">
          <source>for reusability</source>
          <target state="translated">для многоразового использования</target>
        </trans-unit>
        <trans-unit id="4618d40a12eec35b743c0d33ec26c6ee634eb9ad" translate="yes" xml:space="preserve">
          <source>for setters and getters you can fine tune it and define it separately</source>
          <target state="translated">для сеттеров и геттеров можно тонко настроить и определить его отдельно.</target>
        </trans-unit>
        <trans-unit id="273bf92b0c3d89955ec505b2f149212919216d10" translate="yes" xml:space="preserve">
          <source>is any worse than:</source>
          <target state="translated">хуже,чем:</target>
        </trans-unit>
        <trans-unit id="dbe1b4e53e52bda3546c73c53e0d35d11158f6a4" translate="yes" xml:space="preserve">
          <source>safer; and</source>
          <target state="translated">безопаснее;и</target>
        </trans-unit>
        <trans-unit id="22d6eb61e8eb4da06f77da4c904a9784e7917342" translate="yes" xml:space="preserve">
          <source>to perform validation in later stages of programming</source>
          <target state="translated">проводить валидацию на более поздних этапах программирования</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
