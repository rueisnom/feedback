<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1568091">
    <body>
      <group id="1568091">
        <trans-unit id="811ef1a393584a7d8880f3ef855143bdd7cae4ff" translate="yes" xml:space="preserve">
          <source>(Time 1 is the direct way, Time 2 is the getter)</source>
          <target state="translated">(时间1是直接方式,时间2是获取者)</target>
        </trans-unit>
        <trans-unit id="2674e860c37ef14352b7760e1bb68edd1812e340" translate="yes" xml:space="preserve">
          <source>1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ &quot;example&quot; code you'll notice me using &lt;code&gt;struct&lt;/code&gt; instead of &lt;code&gt;class&lt;/code&gt; everywhere.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1）从所有具有数据和行为的基本对象的公共成员开始。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是为什么在我所有的C ++&amp;ldquo;示例&amp;rdquo;代码中，您都会注意到我在所有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;地方都&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; 的原因&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9afae1edbdd3713190c6b92e13771fa366eb26a3" translate="yes" xml:space="preserve">
          <source>10 million cycles:</source>
          <target state="translated">1000万个周期。</target>
        </trans-unit>
        <trans-unit id="164834c50a9442cbf6258a5472c287b312c938dc" translate="yes" xml:space="preserve">
          <source>2) When an object's internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal &lt;code&gt;std::list&lt;/code&gt; in some kind of order), accessor type functions are written.  Because I'm programming by myself, I don't always set the member &lt;code&gt;private&lt;/code&gt; right away, but somewhere down the evolution of the class the member will be &quot;promoted&quot; to either &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2）当对象的数据成员内部行为变得足够复杂时（例如，它喜欢按&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某种顺序&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保留内部&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），将编写访问器类型函数。因为我是一个人在编程，所以我并不总是立即将成员设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是在类演变的某个地方，该成员将被&amp;ldquo;提升&amp;rdquo;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;protected&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7892b3b7150042db597eb83df3fa2fc4d4a5356e" translate="yes" xml:space="preserve">
          <source>3) Classes that are fully fleshed out and have strict rules about their internals (ie &lt;em&gt;they&lt;/em&gt; know exactly what they are doing, and you are not to &quot;fuck&quot; (technical term) with its internals) are given the &lt;code&gt;class&lt;/code&gt; designation, default private members, and only a select few members are allowed to be &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3）完全充实并且对内部构造有严格规定的类（即，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确切地知道自己在做什么，并且您不希望对其内部进行&amp;ldquo;操蛋&amp;rdquo;（技术术语））被赋予&lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;名称，默认为私有成员，只有少数几个成员被允许&lt;/font&gt;&lt;/font&gt; &lt;code&gt;public&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b75455e8497af8e0568b85b084a32699e8ec694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Here are the some of the reasons I am aware of:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我知道的一些原因：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3cca966ff39b9fe1ddc20c0c05c5ab85772f223b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;Oh... cool, I guess?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;客户&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&amp;ldquo;哦，太酷了，我猜是吗？&amp;rdquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da3e4c734e73e93fbd221e07e4b36c403db2d6c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;What can I do with an object of this class?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;客户&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&amp;ldquo;我可以用这个类的对象做什么？&amp;rdquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="255733b7d5ec2727df67865b9399e6f16913e0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code to the interface, not the implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码到接口，而不是实现&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3009decd56c1847ecaff29ac42deaeb96d7e5ed9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Designer&lt;/strong&gt;: &quot;You can read and write several variables.&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设计器&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&amp;ldquo;您可以读写几个变量。&amp;rdquo;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9327bbc5dd989bbd9c8de05113c4531259a85e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getter Methods:&lt;/strong&gt;&lt;em&gt;We can get access to private variables.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getter方法：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们可以访问私有变量。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49c576902394b2f88aa9c23003d5ca3259732bc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getters&lt;/strong&gt; and &lt;strong&gt;setters&lt;/strong&gt; are used to implement two of the fundamental aspects of Object Oriented Programming which are:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用getter&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;setter&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来实现面向对象编程的两个基本方面：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75bf09d32278474950179c8e319e9ebd15d37d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interfaces only specify methods, not fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接口仅指定方法，不指定字段&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9db04f55b8e825e0380143c8c6459e9bd8ff383" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setter Methods:&lt;/strong&gt;&lt;em&gt;We can modify private fields.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设置方法：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们可以修改私有字段。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e77ba06d495a30414d7393b72695c1a32bd8ea5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are actually &lt;em&gt;many good reasons&lt;/em&gt; to consider using accessors&lt;/strong&gt; rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，有&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很多充分的理由&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑使用访问器，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是直接公开类的字段-除了封装的论点之外，并使将来的更改更容易。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9b3b8c7d55f7b60e6b667f7483bd9cd9c8e936e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* Even for that simple class, you may not necessarily want to allow setting the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values. If this is really a class, shouldn't it have methods like &lt;code&gt;translate&lt;/code&gt;, &lt;code&gt;rotate&lt;/code&gt;, etc.? If it's only a class because your language doesn't have records/structs/named tuples, then this isn't really a question of OO&amp;hellip;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;*即使对于那个简单的类，您也不一定要允许设置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果这确实是一个类，它是否不应该具有诸如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;translate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rotate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等方法？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果因为您的语言没有记录/结构/命名元组而只是一堂课，那么这实际上不是OO问题。&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9f1c7ed63a610cca03dbe1fb9a5969b1641f70d2" translate="yes" xml:space="preserve">
          <source>A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it's clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.</source>
          <target state="translated">一个公共字段不比一个getter对,除了返回该字段并赋值给它之外,什么都不做。首先,很明显(在大多数语言中)没有功能上的区别。任何差异一定是在其他因素上,比如可维护性或可读性。</target>
        </trans-unit>
        <trans-unit id="9ef49733b07a04ac879a3131cf59a6bb592d931f" translate="yes" xml:space="preserve">
          <source>A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).</source>
          <target state="translated">一个非常简单的类,它可以容纳多少液体,以及它的容量是多少(以毫升为单位)。</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="82749ef4d632eabe207c0f5bfe48e65659005062" translate="yes" xml:space="preserve">
          <source>Accessors and mutators also allow for encapsulation - if you aren't supposed to see the value once its set (perhaps it's set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.</source>
          <target state="translated">访问器和突变器也允许封装--如果你不应该看到这个值,一旦它被设置了,你就不应该看到它(也许它是在构造函数中设置的,然后被方法使用,但永远不应该被改变),那么它将永远不会被任何人看到。但如果你能允许其他类看到或改变它,你可以提供适当的访问器和突变器。</target>
        </trans-unit>
        <trans-unit id="a4355e16716c8eb9f55ad860a735f5c6eda863c4" translate="yes" xml:space="preserve">
          <source>Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That's how you can define and maintain useful invariants.</source>
          <target state="translated">在这样的类中加入直通式的取值器对不会增加任何价值。其他的类应该提供有意义的操作,而不只是字段已经提供的操作。这就是你如何定义和维护有用的不变性。</target>
        </trans-unit>
        <trans-unit id="3d5035c0f50aaed825f8024c67607f79c9d6f00e" translate="yes" xml:space="preserve">
          <source>Additionally, this is to &quot;future-proof&quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just &quot;set/get the field&quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.</source>
          <target state="translated">另外,这是为你的类做 &quot;未来防护&quot;。特别是,从字段到属性的改变是一个ABI的突破,所以如果你以后决定你需要更多的逻辑,而不仅仅是 &quot;setget the field&quot;,那么你就需要打破ABI,这当然会给其他已经编译到你的类带来问题。</target>
        </trans-unit>
        <trans-unit id="81c4e73e61dcb9ef881221a8e3e6e510aaafccd3" translate="yes" xml:space="preserve">
          <source>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</source>
          <target state="translated">允许继承者通过重写getetterter方法来改变属性行为的语义,并通过重写getetter方法来暴露。</target>
        </trans-unit>
        <trans-unit id="57a93d1fb290ddf7a1dbf6a3c46ddb1f2bd05da4" translate="yes" xml:space="preserve">
          <source>Allowing the getter/setter to be passed around as lambda expressions rather than values.</source>
          <target state="translated">允许以lambda表达式而不是值的形式传递getterter。</target>
        </trans-unit>
        <trans-unit id="43274d4e786c79c30fbd5d48e83bf0480818a226" translate="yes" xml:space="preserve">
          <source>Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.</source>
          <target state="translated">同样是用不同的循环量,获取器的速度比常规的方式要快一点。希望对你有帮助。</target>
        </trans-unit>
        <trans-unit id="033534469fa80b3c8584bdbf1263c23f9a826be5" translate="yes" xml:space="preserve">
          <source>Also, it's important to follow the idioms of the language (or framework) you're using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that's bad. Some languages have stronger cultures around their conventions than others.&amp;mdash;and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，遵循您使用的语言（或框架）的习惯用法也很重要。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您用C＃编写漂亮的Ruby风格的代码，那么除您之外的任何经验丰富的C＃开发人员都将很难阅读它，这很糟糕。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一些语言比其他语言具有更强的习惯文化。Java和Python在习惯用法的获取者方面处于相反的地位，碰巧拥有两种最强的文化，这并非巧合。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d11a9b94f688fd1bb3e8236ba806a1a0de41e921" translate="yes" xml:space="preserve">
          <source>An oft-mentioned advantage of getter/setter pairs, isn't. There's this claim that you can change the implementation and your clients don't have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don't even need to know about it. However, adding validation to a setter is a change to its preconditions, &lt;strong&gt;a violation of the previous contract&lt;/strong&gt;, which was, quite simply, &quot;you can put anything in here, and you can get that same thing later from the getter&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并非经常提到的getter / setter对的优点。有人声称您可以更改实现，而不必重新编译客户。据说，通过设置器，您可以稍后添加诸如验证之类的功能，而您的客户甚至不需要了解它。但是，将验证器添加到设置器中是对其先决条件的更改，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这违反了先前的合同&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这很简单，即&amp;ldquo;您可以在此处放置任何内容，稍后可以从获取器中获取相同的内容&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0528fa85939d91318183d46b3de68fa50d141cc4" translate="yes" xml:space="preserve">
          <source>And all these can have different ways to handle various whoopsies. The Bottle just checks and if it's overflowing it throws a RuntimeException. But that might be the wrong thing to do. 
(There is a useful discussion to be had about error handling, but I'm keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )</source>
          <target state="translated">而这些都可以有不同的方式来处理各种whoopsies。Bottle只是检查一下,如果溢出了就会抛出一个RuntimeException。但这可能是错误的处理方式。(关于错误处理,有一个有用的讨论,但我在这里故意把它保持得很简单。人们在评论中很可能会指出这种简单化的方法的缺陷。))</target>
        </trans-unit>
        <trans-unit id="b3709a8d644d6848cb9e1e1b2612c33a14d466f8" translate="yes" xml:space="preserve">
          <source>And yes, it seems like we go from a very simple idea to getting much better answers quickly.</source>
          <target state="translated">而且是的,我们似乎从一个非常简单的想法,很快就能得到更好的答案。</target>
        </trans-unit>
        <trans-unit id="8c0adc3715c9771354c8ce3bffb1a2caa8b06842" translate="yes" xml:space="preserve">
          <source>Any validation you perform in there can only be context free, which validation rarely is in practice.</source>
          <target state="translated">你在那里进行的任何验证都只能是无上下文的,而实际操作中很少有这样的验证。</target>
        </trans-unit>
        <trans-unit id="47b2dd5b5d660068e61383ca22ea5c24356d49a6" translate="yes" xml:space="preserve">
          <source>Anywhere a value can be used, a method that returns that value can be added. Instead of:</source>
          <target state="translated">任何可以使用值的地方,都可以添加一个返回该值的方法。而不是:</target>
        </trans-unit>
        <trans-unit id="ac6f0e579cd82854d73b7ba5e3dee370470c5bf1" translate="yes" xml:space="preserve">
          <source>As for the &quot;what if I want to change my implementation later?&quot; question (which is repeated multiple times in different wording in both the OP's question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn't support that. So this is really just the same case again.</source>
          <target state="translated">至于 &quot;如果我以后想改变实现怎么办?&quot;的问题(这个问题在OP的问题和接受的答案中都用不同的措辞重复了多次)。如果真的是纯粹的实现改变,而你一开始是改变属性,你可以把它改成属性,而不影响接口。当然,除非,你的语言不支持这种情况。所以,这真的又是同样的情况。</target>
        </trans-unit>
        <trans-unit id="43cacfbdc83927cc4b2aad1396ab0622fbf9274d" translate="yes" xml:space="preserve">
          <source>Because 2 weeks (months, years) from now when you realize that your setter needs to do &lt;strong&gt;more&lt;/strong&gt; than just set the value, you'll also realize that the property has been used directly in 238 other classes :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为从2现在周（月，年），当你意识到你的二传手需要做&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更多的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比刚才设置的值，你也会意识到，财产已经在其他238类直接使用:-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e510c63de41dc0facb98c85d5c568e3eeeafd444" translate="yes" xml:space="preserve">
          <source>Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don't. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don't fight them.</source>
          <target state="translated">除了人类读者,还有一些库和工具希望你遵循约定,如果你不遵循约定,就会让你的生活变得更加困难。将 Interface Builder widgets 挂钩到任何东西,但不使用 ObjC 属性,或者使用某些 Java mocking 库而不使用 getters,只会让你的生活更加困难。如果这些工具对你来说很重要,就不要和它们对抗。</target>
        </trans-unit>
        <trans-unit id="fac3c0dab4aeb3d8c561a0f4789de6b3ef9c2a67" translate="yes" xml:space="preserve">
          <source>But nobody is ever doing general OO design. They're doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.</source>
          <target state="translated">但是,没有人在做一般的OO设计。他们在做设计,和实现,在特定的语言中。而在某些语言中,getter和setter远非一无是处。</target>
        </trans-unit>
        <trans-unit id="34bfb1e4e8fe780f6179a91f408e1aeba2e095cb" translate="yes" xml:space="preserve">
          <source>But there's another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn't that be better? Since interfaces demand methods, this is also a good thing.</source>
          <target state="translated">但是,还有一个问题也在这里。如果瓶子只是一种容器呢?如果我们有几个容器,所有的容器都有容量和液体的数量呢?如果我们可以做一个接口,让我们的程序的其他部分接受这个接口,那么瓶子、罐子和各种东西就可以互换工作了。这样不是更好吗?既然接口需要方法,这也是一件好事。</target>
        </trans-unit>
        <trans-unit id="5f581816971f55a0fe7fe755c1439b557642dd88" translate="yes" xml:space="preserve">
          <source>Code &lt;em&gt;evolves&lt;/em&gt;.  &lt;code&gt;private&lt;/code&gt; is great for when &lt;em&gt;you need data member protection&lt;/em&gt;.  Eventually all classes should be sort of &quot;miniprograms&quot; that have a well-defined interface &lt;em&gt;that you can't just screw with the internals of&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不断发展&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要数据成员保护&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非常适合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。最终，所有类都应该是具有明确定义的接口的&amp;ldquo;小程序&amp;rdquo; &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您不能仅仅使用它们的内部结构&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77e195f98a65d1f5b54c0c97c7133a6067f84b7e" translate="yes" xml:space="preserve">
          <source>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</source>
          <target state="translated">控制属性的生命周期和内存管理(处置)语义--在非管理型内存环境(如C++或Objective-C)中尤其重要。</target>
        </trans-unit>
        <trans-unit id="451d8c398dac194d41c458e0b0ad881903b0f15e" translate="yes" xml:space="preserve">
          <source>Depends on your language.  You've tagged this &quot;object-oriented&quot; rather than &quot;Java&quot;, so I'd like to point out that ChssPly76's answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:</source>
          <target state="translated">这要看你的语言了。你把这个标记为 &quot;面向对象&quot;,而不是 &quot;Java&quot;,所以我想指出,ChssPly76的答案是依赖于语言的。比如在Python中,没有理由使用getters和setter。如果你需要改变行为,你可以使用一个属性,将getter和setter包裹在基本的属性访问中。类似于这样的东西。</target>
        </trans-unit>
        <trans-unit id="59b09c675389e93fb718c3607a2b33d8ced3dba3" translate="yes" xml:space="preserve">
          <source>Don't use getters setters unless needed for your current delivery I.e. Don't think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.</source>
          <target state="translated">不要使用getters设置器,除非你当前的交付需要,即不要过多的考虑未来会发生什么,如果有什么事情要改变,在大多数的生产应用、系统中,它是一个变更请求。</target>
        </trans-unit>
        <trans-unit id="4811f53244f0f4eb1f508c3dce99ba627e7afab2" translate="yes" xml:space="preserve">
          <source>EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they're not as easy to understand if you're a newbie. We were all newbies, so I thought I'd try my hand at a more newbie friendly answer.</source>
          <target state="translated">EDIT:我回答这个问题是因为有一堆学编程的人在问这个问题,而且大部分人的回答都很有技术含量,但是如果你是新手的话,就没有那么容易理解了。因为大家都是新手,所以我想我也可以试着给大家一个更适合新手的答案。</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="045c9ac03fcd3840d51b0f2e3b7fc9b7a8a9f185" translate="yes" xml:space="preserve">
          <source>Encapsulation mantra</source>
          <target state="translated">咒语封装</target>
        </trans-unit>
        <trans-unit id="08518ebb827eeba5eb31bb4abc223904fb6d8e7c" translate="yes" xml:space="preserve">
          <source>Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.</source>
          <target state="translated">封装了与获取或设置属性相关的行为----这允许以后更容易添加额外的功能(如验证)。</target>
        </trans-unit>
        <trans-unit id="a273aa55c91241aef5cbe7c904175deb629c3048" translate="yes" xml:space="preserve">
          <source>Even if your language does have properties, there may be cases where they're insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can't substitute a computed property for an attribute.</source>
          <target state="translated">即使你的语言确实有属性,也可能会出现属性不足或不合适的情况。例如,如果你想让子类控制一个属性的语义,在没有动态访问的语言中,子类不能用计算属性代替属性。</target>
        </trans-unit>
        <trans-unit id="e83595b7e6ea6eac5ba12ba0e0ea2bbad5c8a4f7" translate="yes" xml:space="preserve">
          <source>Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.</source>
          <target state="translated">尽管getter和setter方法很有用,但你应该注意不要过度使用它们,因为在其他问题中,它们会在某些情况下增加代码维护的难度。另外,它们提供了对你的类实现的访问,就像公共成员一样。OOP实践不鼓励直接访问类内的属性。</target>
        </trans-unit>
        <trans-unit id="d63ca1863a03a6cc66be541e8b13351b917e9595" translate="yes" xml:space="preserve">
          <source>Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method</source>
          <target state="translated">尽管getter和setter方法并没有增加新的功能,但我们可以改变主意,稍后再来使该方法</target>
        </trans-unit>
        <trans-unit id="67bba4f9917627abec7de3eae66ae2f912a2559b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;foo&lt;/code&gt; was public, I could easily set it to &lt;code&gt;null&lt;/code&gt; and then someone else could try to call a method on the object. But it's not there anymore! With a &lt;code&gt;setFoo&lt;/code&gt; method, I could ensure that &lt;code&gt;foo&lt;/code&gt; was never set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是公共的，则可以轻松地将其设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后其他人可以尝试在对象上调用方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是现在不存在了！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFoo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法，可以确保&lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;永远不会设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476a63abfc2fa3c03aedf4736d5d9942e91d901f" translate="yes" xml:space="preserve">
          <source>From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: &lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从面向对象的设计角度来看，这两种选择都可能通过削弱类的封装来破坏代码的维护。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要进行讨论，您可以阅读这篇出色的文章：&lt;/font&gt;&lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//typicalprogrammer.com/?p=23&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a74b1d741c07f0d10578559f597f6187841258b7" translate="yes" xml:space="preserve">
          <source>From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you've written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.</source>
          <target state="translated">从OO理论的角度来看,getter和setter是没有用的。你的类的接口是它做什么,而不是它的状态是什么。(如果不是,你写错了类。)在非常简单的情况下,类所做的事情只是,例如,用矩形坐标表示一个点,*属性是接口的一部分;getters和setters只是掩盖了这一点。但在非常简单的情况下,属性和getter和setter都不是接口的一部分。</target>
        </trans-unit>
        <trans-unit id="57ae158f2e8c761e3b5b8bb16e7dccf2d8f722c4" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.</source>
          <target state="translated">getter和setter方法是访问器方法,也就是说,它们一般是改变私有类成员的公共接口。你使用getter和setter方法来定义一个属性。即使你在类内定义了getter和setter方法作为类外的属性来访问,即使你在类内定义了它们作为方法。那些在类外的属性可以有一个与类中的属性名称不同的名称。</target>
        </trans-unit>
        <trans-unit id="aee376df07aa660dacecd6260f852a6d918c4cd1" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are public interfaces to access private class members.</source>
          <target state="translated">Getter和setter方法是访问私有类成员的公共接口。</target>
        </trans-unit>
        <trans-unit id="cba3e268c215d8706586fc9b9c009cffacae2d3a" translate="yes" xml:space="preserve">
          <source>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</source>
          <target state="translated">获取器和设置器可以允许不同的访问级别--例如,获取器可能是公共的,但设置器可能是受保护的。</target>
        </trans-unit>
        <trans-unit id="a06c2f62c876887f1c33b514ac9a69553b2b6392" translate="yes" xml:space="preserve">
          <source>Great! And now we just change Bottle to this:</source>
          <target state="translated">太好了!现在我们只要把瓶子改成这样</target>
        </trans-unit>
        <trans-unit id="de8d815e48132f09b9bca3cbd23f2f97e119a145" translate="yes" xml:space="preserve">
          <source>Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.</source>
          <target state="translated">这里的 &quot;全名 &quot;的实现细节是隐藏的,用户无法直接访问,不像公共属性。</target>
        </trans-unit>
        <trans-unit id="3fa394821ab09cbccd5563100429404ca95e6440" translate="yes" xml:space="preserve">
          <source>Hiding the internal representation of the property while exposing a property using an alternative representation.</source>
          <target state="translated">隐藏属性的内部表示,同时用另一种表示方式暴露属性的内部表示。</target>
        </trans-unit>
        <trans-unit id="d2f4f5cef8a9ea91e08ca99ee45e39ac9dcd0ebe" translate="yes" xml:space="preserve">
          <source>I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class's evolution.</source>
          <target state="translated">我发现这种方法可以让我避免在一个班级进化的初期,当很多数据成员被迁移出去、转移到其他地方去的时候,坐在那里虔诚地写着gettersetters。</target>
        </trans-unit>
        <trans-unit id="7ac905efee55cbf685e08af0da10c6d4468cd4fe" translate="yes" xml:space="preserve">
          <source>I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn't always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of &quot;slow&quot;, so you don't want to make a web service call if you don't have to.</source>
          <target state="translated">我有一个项目中的基础页面类,交给我的项目中,有几个不同的web服务调用加载一些数据,但这些web服务调用中的数据并不总是用于所有的子页面。Web服务,为了所有的好处,开创了 &quot;慢 &quot;的新定义,所以如果没有必要的话,你就不要去做一个Web服务调用。</target>
        </trans-unit>
        <trans-unit id="fec0ce430c9b50fa6a42a74bb5cc7bbe5070bd9d" translate="yes" xml:space="preserve">
          <source>I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.</source>
          <target state="translated">我有一个庞大的系统,没有getters设置器,只用访问修改器和一些方法来验证n执行business逻辑。如果你绝对需要的。用什么都可以。</target>
        </trans-unit>
        <trans-unit id="b23c3487d24d1993bf58de911e47e2492ae65d64" translate="yes" xml:space="preserve">
          <source>I know it's a bit late, but I think there are some people who are interested in performance.</source>
          <target state="translated">我知道时间有点晚了,但我觉得有些人对表演有兴趣。</target>
        </trans-unit>
        <trans-unit id="db14da99dc1a19fe0a1cec21c694b1166cec8396" translate="yes" xml:space="preserve">
          <source>I moved from public fields to getters, and now the getters check the cache, and if it's not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.</source>
          <target state="translated">我把公共字段改成了getters,现在getters检查缓存,如果不在,就调用web服务。所以稍微包装一下,就避免了很多web服务的调用。</target>
        </trans-unit>
        <trans-unit id="d44fc766ecbf5e63030bb952d02b5d6adbd46593" translate="yes" xml:space="preserve">
          <source>I spent quite a while thinking this over for the Java case, and I believe the real reasons are:</source>
          <target state="translated">我花了相当长的时间来思考这个问题,我相信真正的原因是。</target>
        </trans-unit>
        <trans-unit id="2889b32bfcc03c8e80e260ed4b4716b29ae177b9" translate="yes" xml:space="preserve">
          <source>I would just like to throw the idea of annotation : @getter and @setter. With @getter, you should be able to obj = class.field but not class.field = obj. With @setter, vice versa. With @getter and @setter you should be able to do both. This would preserve encapsulation and reduce the time by not calling trivial methods at runtime.</source>
          <target state="translated">我只想抛出一个注释的想法。@getter和@setter。用@getter,你应该可以obj=class.field,但不能用class.field=obj。使用@setter,反之亦然。使用 @getter 和 @setter,你应该可以同时进行。这将保留封装,并通过在运行时不调用琐碎的方法来减少时间。</target>
        </trans-unit>
        <trans-unit id="448e5ff21f920e7e7eae20ce3fd54ad0522d451c" translate="yes" xml:space="preserve">
          <source>I would not take advantage of ignorance of business owners of deep technical know how just because I think it's correct or I like the approach.</source>
          <target state="translated">我不会因为我觉得这样做是正确的,或者我喜欢这样的做法,就会利用企业主对深层次技术知识的无知,我也不会因为我觉得这样做是正确的,或者我喜欢这样的做法。</target>
        </trans-unit>
        <trans-unit id="91a599d9c25706ea81b0f073fcd9ead9e1d48f03" translate="yes" xml:space="preserve">
          <source>I'll leave the definition of the BottleOverflowException as an exercise to the reader.</source>
          <target state="translated">我将把BottleOverflowException的定义留给读者作为练习。</target>
        </trans-unit>
        <trans-unit id="c0cfd8d8587de574184a35bdea413f3d36872445" translate="yes" xml:space="preserve">
          <source>I've done a little performance test. I wrote a class &quot;NumberHolder&quot; which, well, holds an Integer. You can either read that Integer by using the getter method
&lt;code&gt;anInstance.getNumber()&lt;/code&gt; or by directly accessing the number by using &lt;code&gt;anInstance.number&lt;/code&gt;. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I've got the following result:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我做了一些性能测试。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我写了一个&amp;ldquo; NumberHolder&amp;rdquo;类，它拥有一个整数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以通过使用getter方法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.getNumber()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或通过使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直接访问该数字来&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;读取该Integer &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的程序通过两种方式读取该数字1,000,000,000次。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重复该过程五次，并打印时间。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我得到以下结果：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0978c43bc2b11a6a993b548afff0b3b5ca45a92" translate="yes" xml:space="preserve">
          <source>If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, &lt;em&gt;no contract&lt;/em&gt;. Is that really object-oriented design? If all the class has is those getters and setters, it's just a dumb data holder, and dumb data holders should look like dumb data holders:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果一个类的每个字段都具有这些愚蠢的获取器和设置器，则该类将没有任何不变式，也&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有合同&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那真的是面向对象的设计吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果班上所有的人都是那些getter和setter，那只是一个哑数据持有人，而哑数据持有人应该看起来像哑数据持有人：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46fb1f117749485f93dfde52629c12a6592e5f3e" translate="yes" xml:space="preserve">
          <source>If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I'm not 100% clear on how:</source>
          <target state="translated">如果说getter和setter曾经不仅仅是做简单的getset,我可以很快就弄清楚这个问题,但我并不是百分之百的清楚。</target>
        </trans-unit>
        <trans-unit id="949e9da0978aaee4523cbb0c409b2bf0b89c3805" translate="yes" xml:space="preserve">
          <source>If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. &lt;em&gt;That's the exact opposite of encapsulation&lt;/em&gt; If that field could not really be set to anything from the start, why wasn't the validation there from the start?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果这不应该是合同，则该接口允许客户端将对象置于无效状态。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这与封装完全相反。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果从一开始就无法将该字段真正设置为任何值，那么为什么从一开始就不进行验证呢？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d442a6315e08af677c7d3f5fd084eb11ecca9ce5" translate="yes" xml:space="preserve">
          <source>If your language doesn't have properties, then the only way to represent something that's conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.</source>
          <target state="translated">如果你的语言没有属性,那么唯一的方法就是通过getter和setter来表示概念上是属性的东西,但实际上是计算的,或者是验证的等等。</target>
        </trans-unit>
        <trans-unit id="c75e6d8a92da8554d6134d8d780910766638384b" translate="yes" xml:space="preserve">
          <source>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</source>
          <target state="translated">改进了与那些被设计成针对属性获取器的库的互操作性-Mocking、Serialization和WPF都会想到。</target>
        </trans-unit>
        <trans-unit id="a045af26b3882dcd948db97f36b10344affa5eda" translate="yes" xml:space="preserve">
          <source>In a pure object-oriented world getters and setters is a &lt;strong&gt;terrible anti-pattern&lt;/strong&gt;. Read this article: &lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;Getters/Setters. Evil. Period&lt;/a&gt;. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在纯粹的面向对象的世界中，吸气剂和吸气剂是一种&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可怕的反模式&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读本文：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getters / Setters。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;邪恶。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;期间&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简而言之，他们鼓励程序员考虑数据结构中的对象，而这种类型的考虑是纯过程性的（例如在COBOL或C中）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在面向对象的语言中，没有数据结构，只有暴露行为的对象（没有属性/属性！）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60ede22798c8886c1279c94029a7d8fbdb115073" translate="yes" xml:space="preserve">
          <source>In an object oriented language the methods, and their access modifiers, declare the interface for that object. Between the constructor and the accessor and mutator methods it is possible for the developer to control access to the internal state of an object. If the variables are simply declared public then there is no way to regulate that access.
And when we are using setters we can restrict the user for the input we need. Mean the feed for that very variable will come through a proper channel and the channel is predefined by us. So it's safer to use setters.</source>
          <target state="translated">在面向对象语言中,方法和它们的访问修饰符声明了对象的接口。在构造函数和访问器和突变器方法之间,开发者可以控制对对象内部状态的访问。如果简单地声明变量是公有的,那么就没有办法控制这种访问。而当我们使用setter时,我们可以限制用户对我们需要的输入进行限制。这意味着这个变量的输入将通过一个适当的通道,而这个通道是由我们预定义的。所以,使用setter是比较安全的。</target>
        </trans-unit>
        <trans-unit id="9570686c65057df9d5555a427b45dcb388eb1c6d" translate="yes" xml:space="preserve">
          <source>In languages which don't support &quot;properties&quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.</source>
          <target state="translated">在不支持 &quot;属性 &quot;的语言中(C++、Java),或者在将字段改成属性时需要重新编译客户端(C#),使用getset方法更容易修改。例如,在setFoo方法中添加验证逻辑,就不需要改变类的公共接口。</target>
        </trans-unit>
        <trans-unit id="49c146ae67da9fce98a67aa9876195255bf52355" translate="yes" xml:space="preserve">
          <source>In languages which support &quot;real&quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.</source>
          <target state="translated">在支持 &quot;真实 &quot;属性的语言中(Python,Ruby,也许是Smalltalk?),没有getset方法的意义。</target>
        </trans-unit>
        <trans-unit id="9a756c26f5397e6bf09cb6c1e8673c721a0adcdc" translate="yes" xml:space="preserve">
          <source>In layman's terms</source>
          <target state="translated">通俗点说,就是</target>
        </trans-unit>
        <trans-unit id="03538993fd141670ce7112b8a39c0f3f3dcb7e47" translate="yes" xml:space="preserve">
          <source>In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.</source>
          <target state="translated">换句话说,在接口中指定一个字段的唯一方法就是提供一个写新值的方法和一个读取当前值的方法。</target>
        </trans-unit>
        <trans-unit id="665cb9197ac6f3430ff52c71c900a99810bbd645" translate="yes" xml:space="preserve">
          <source>Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.</source>
          <target state="translated">继承这个类,你可以覆盖默认的功能--换句话说,你不仅可以通过隐藏实现,还可以使其不一致,从而使调用者感到困惑。</target>
        </trans-unit>
        <trans-unit id="2a50b3b7baaffbe0c2005cff92a6863837d540b1" translate="yes" xml:space="preserve">
          <source>Instead of</source>
          <target state="translated">而不是</target>
        </trans-unit>
        <trans-unit id="3a846f258ad5630d87aa074967dac3d41a23874d" translate="yes" xml:space="preserve">
          <source>Instead of doing this, we can create a bean &lt;code&gt;class(Person)&lt;/code&gt; with getter and setter methods.  So tomorrow we can just create objects of this Bean &lt;code&gt;class(Person class)&lt;/code&gt; whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替执行此操作，我们可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用getter和setter方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个bean &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，明天我们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只要有需要添加新人员时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就可以创建Bean &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person class)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我们正在重用bean类的字段和方法，这要好得多。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebdc6050b1ad6649a3451d6af5910e06b12430e3" translate="yes" xml:space="preserve">
          <source>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</source>
          <target state="translated">使你的公共接口不受变化的影响----让公共接口保持不变,而不影响现有的消费者。</target>
        </trans-unit>
        <trans-unit id="5ac0c56e853fb8f8f0be1b64596f6b59055cbdae" translate="yes" xml:space="preserve">
          <source>It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don't want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.</source>
          <target state="translated">它可以用于偷懒加载。假设这个对象存储在数据库中,除非你需要,否则你不想去获取它。如果这个对象是由getter检索的,那么内部的对象可以是空的,直到有人问起它,然后你就可以在第一次调用getter时去获取它。</target>
        </trans-unit>
        <trans-unit id="cc4afcf1103ef9d6c53108ff6cc9b9b18bdb3242" translate="yes" xml:space="preserve">
          <source>It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.</source>
          <target state="translated">它给你带来了很多好处,其中之一就是你可以在幕后改变取值器的实现,但只要数据类型不变,该值的任何消费者都会继续工作。</target>
        </trans-unit>
        <trans-unit id="729e36d06a905476ea11f5c8b0c1812a73dff9ce" translate="yes" xml:space="preserve">
          <source>It's a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that's where your memory leak was occurring.</source>
          <target state="translated">这段代码很简单,直到你意识到它是一个设置器。现在,你按照这个setter,发现它还设置了person.firstName,person.lastName,person.isHuman,person.hasReallyCommonFirstName,并调用person.update(),向数据库发送查询等。哦,这就是你的内存泄露的地方。</target>
        </trans-unit>
        <trans-unit id="16aa234236b2a7935d4484df427e10358d69a866" translate="yes" xml:space="preserve">
          <source>Let's say we have this simple class:</source>
          <target state="translated">假设我们有这样一个简单的班级。</target>
        </trans-unit>
        <trans-unit id="c9377946989c0599e694f34e6e15b1e30f95e7bb" translate="yes" xml:space="preserve">
          <source>Lots of people talk about the advantages of getters and setters but I want to play devil's advocate. Right now I'm debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.</source>
          <target state="translated">很多人都在谈论getter和setter的好处,但我想扮演魔鬼代言人。现在我正在调试一个非常大的程序,程序员们决定让所有的东西都用getter和setter。这似乎很好,但这是个反向工程的噩梦。</target>
        </trans-unit>
        <trans-unit id="1d38c1d25ba364989ccc66f32498e40bbffbe427" translate="yes" xml:space="preserve">
          <source>My 2 cents :)</source>
          <target state="translated">我的两分钱 :)</target>
        </trans-unit>
        <trans-unit id="89bcb9ce512e3a24b71ffdc4db2c607ef7562d71" translate="yes" xml:space="preserve">
          <source>Not only is &lt;code&gt;getVar()&lt;/code&gt; visually noisy, it gives this illusion that &lt;code&gt;gettingVar()&lt;/code&gt; is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of &lt;code&gt;var&lt;/code&gt; is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you're putting up these gates to &quot;protect&quot; something you insist is valuable, (the sanctity of &lt;code&gt;var&lt;/code&gt;) but yet even you concede &lt;code&gt;var&lt;/code&gt;'s protection isn't worth much by the ability for anyone to just come in and &lt;code&gt;set&lt;/code&gt;&lt;code&gt;var&lt;/code&gt; to whatever value they want, without you even peeking at what they are doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不仅&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;视觉上嘈杂，还给人一种幻觉，即&lt;/font&gt;&lt;/font&gt; &lt;code&gt;gettingVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在某种程度上比实际情况更复杂。如果您（作为班级编写者）如何看待&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的神圣性，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果它具有passthru设置器，这会让您的班级用户特别困惑-看来您正在建立这些大门来&amp;ldquo;保护&amp;rdquo;您坚持认为有价值的东西，（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的神圣性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），但是即使您也承认&lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的保护价值并不高，因为任何人只要进入&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;并将其&lt;/font&gt;&lt;/font&gt; &lt;code&gt;set&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为他们想要的任何值，而您甚至都不会窥视他们在做什么，就&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有太大的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;价值。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25ccd6d1abfaa462958a3daf7b3c72739444cbb" translate="yes" xml:space="preserve">
          <source>Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.</source>
          <target state="translated">现在注意到这是多么的健壮。我们现在可以通过接受LiquidContainer而不是Bottle来处理我们的代码中的任何类型的容器。而这些瓶子如何处理这类东西都可以有不同的处理方式。你可以让瓶子在状态发生变化时将状态写入磁盘,也可以让瓶子保存在SQL数据库或GNU知道其他的东西。</target>
        </trans-unit>
        <trans-unit id="ee14a6cb3f5a0e797943e0e6cf7bc7231a57d7bc" translate="yes" xml:space="preserve">
          <source>Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.</source>
          <target state="translated">现在,如果你的代码中的每一个地方都在使用公共字段,然后你发现你需要上述的要求呢?那你就会发现你需要上述的要求。</target>
        </trans-unit>
        <trans-unit id="bea2afcb08c47bb55bd603ad05f6ae591ec6e48a" translate="yes" xml:space="preserve">
          <source>On the other hand, if the member is public, the tools don't make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.</source>
          <target state="translated">另一方面,如果该成员是公共的,工具无法过滤对该成员的读写权限。因此,你必须对该会员的所有用途进行trudge,虽然会员的所有用途。</target>
        </trans-unit>
        <trans-unit id="e9f8893e9b850ac172431cb049bc524b942b2431" translate="yes" xml:space="preserve">
          <source>One advantage of accessors and mutators is that you can perform validation.</source>
          <target state="translated">访问器和突变器的一个优点是,你可以进行验证。</target>
        </trans-unit>
        <trans-unit id="91b95b7297fe9079d417e879ad5486deb384c22d" translate="yes" xml:space="preserve">
          <source>One aspect I missed in the answers so far, the access specification:</source>
          <target state="translated">到目前为止,我错过了一个方面的答案,就是访问规范。</target>
        </trans-unit>
        <trans-unit id="10765ac54cefce78aa01ff15a00dd5d27040fc3d" translate="yes" xml:space="preserve">
          <source>One of the basic principals of OO design: &lt;strong&gt;Encapsulation!&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OO设计的基本原理之一：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;封装！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b5607ce4ce1a004d9de9e90c6bbff2691c7ffe7" translate="yes" xml:space="preserve">
          <source>One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that's computationally expensive in a property.</source>
          <target state="translated">另一个用途(在支持属性的语言中)是,setter和getter可以暗示一个操作是非琐碎的。通常情况下,你要避免在属性中做任何计算成本高的操作。</target>
        </trans-unit>
        <trans-unit id="76713a423e5722e517c06fbab6e7cfe5f4817367" translate="yes" xml:space="preserve">
          <source>One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.</source>
          <target state="translated">getterssetters的一个相对现代的优点是,它使在标签化(索引化)代码编辑器中浏览代码变得更加容易。例如,如果你想看谁设置了一个成员,可以打开设置器的调用层次结构。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="be9cbb9ed4b5c6641f5aa815d9709c0e21aceeaa" translate="yes" xml:space="preserve">
          <source>Please note also that you can't change the capacity of a bottle. It's now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can't limit the access to touching the innards.</source>
          <target state="translated">还请注意,你不能改变一个瓶子的容量。它现在已经定下来了。你可以通过声明它是最终的,用一个int来做。但如果这是一个列表,你可以清空它,给它添加新的东西,以此类推。你不能限制触碰内脏的访问量。</target>
        </trans-unit>
        <trans-unit id="36c1fd3f265a620d873362378468f7e90e8a20ae" translate="yes" xml:space="preserve">
          <source>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</source>
          <target state="translated">当属性在运行时发生变化时,提供一个调试拦截点----在某些语言中,如果没有这个功能,调试属性何时、何地改变为特定的值是相当困难的。</target>
        </trans-unit>
        <trans-unit id="3e2aa20a27ca3d6e7b23af75afca271955543ebe" translate="yes" xml:space="preserve">
          <source>Put another way: If you believe that consumers of your class shouldn't even know that you have a &lt;code&gt;spam&lt;/code&gt; attribute, much less be able to change it willy-nilly, then giving them a &lt;code&gt;set_spam&lt;/code&gt; method is the last thing you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;换句话说，如果您认为类的使用者甚至不应该知道您拥有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;属性，那么就很难随意更改它，那么给他们提供&lt;/font&gt;&lt;/font&gt; &lt;code&gt;set_spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法是您要做的最后一件事。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2800b08281984434942ba5adcad8919a80ff4cc" translate="yes" xml:space="preserve">
          <source>Say you're looking through hundreds of lines of code and you come across this:</source>
          <target state="translated">说你在翻阅几百行代码的时候,遇到了这个。</target>
        </trans-unit>
        <trans-unit id="0fe6038ebdf6b117336c04451dc9e3876effcb5c" translate="yes" xml:space="preserve">
          <source>So I program as follows (assuming an &quot;agile&quot; type approach -- ie when I write code not knowing &lt;em&gt;exactly&lt;/em&gt; what it will be doing/don't have time or experience to plan an elaborate waterfall style interface set):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我按以下方式进行编程（假设采用&amp;ldquo;敏捷&amp;rdquo;类型的方法-即，当我编写的代码不&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;知道将要做什么/没有时间或经验来计划精心设计的瀑布样式接口集时）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9eda9489b827ab46566f12f43fa4c89312a585f" translate="yes" xml:space="preserve">
          <source>So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don't already have it.</source>
          <target state="translated">所以,getter让我不用在每一个子页面上想办法找出我需要的东西。如果我需要的话,我可以调用getter,如果我还没有,它就会帮我找到它。</target>
        </trans-unit>
        <trans-unit id="3d0d9303819ce1ab413fffddd86f3afbed876b1f" translate="yes" xml:space="preserve">
          <source>So this is very rarely a general OO question; it's a language-specific question, with different answers for different languages (and different use cases).</source>
          <target state="translated">所以这很少是一个一般的OO问题,这是一个针对语言的问题,不同的语言(和不同的用例)有不同的答案。</target>
        </trans-unit>
        <trans-unit id="110215a582ce0c01e647e0ab38866bd28ab289f7" translate="yes" xml:space="preserve">
          <source>So you have:</source>
          <target state="translated">所以你有。</target>
        </trans-unit>
        <trans-unit id="84327f3567507ed383657990eb8c4dfa0d117dca" translate="yes" xml:space="preserve">
          <source>So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you're making the assumption that all the code assumed the contract for those methods was different.</source>
          <target state="translated">所以,现在你既然打破了契约,改变代码库中的每一个文件都是你应该想做的事情,而不是回避。如果你避免了,你就等于做了一个假设,所有的代码都假设那些方法的契约是不同的。</target>
        </trans-unit>
        <trans-unit id="cbead7356f0d8824aecb16d6a0262b6c772bd6e2" translate="yes" xml:space="preserve">
          <source>Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.</source>
          <target state="translated">有些库期望这样做,但不是很多----反射、序列化、模拟对象都可以在公共字段中正常工作。</target>
        </trans-unit>
        <trans-unit id="b8d6ec5b172b09312ffab2762d5844c299a54132" translate="yes" xml:space="preserve">
          <source>Suppose we have an Employee class:</source>
          <target state="translated">假设我们有一个员工类。</target>
        </trans-unit>
        <trans-unit id="f0b6a967a2c05a11d643d0e4a7aa868f211882c5" translate="yes" xml:space="preserve">
          <source>Suppose we need to store the details of this &lt;code&gt;Person&lt;/code&gt;. This &lt;code&gt;Person&lt;/code&gt; has the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Doing this involves creating methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Now if we need create another person, it becomes necessary to create the methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;sex&lt;/code&gt; all over again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设我们需要存储此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的详细信息&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这样做涉及创建&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。现在，如果我们需要创建另一个人，则有必要重新创建&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3e474c35abac8c8e79adba6fbbab7a5646b1ac0" translate="yes" xml:space="preserve">
          <source>Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:</source>
          <target state="translated">谢谢,这真的澄清了我的想法。现在这里有10个(几乎)不使用getter和setter的好理由。</target>
        </trans-unit>
        <trans-unit id="a29e9e3845b5c733ae0c153286a63607107be5fa" translate="yes" xml:space="preserve">
          <source>That said, &lt;em&gt;software development&lt;/em&gt; isn't about setting down that final version of the class as if you're pressing some cast iron statue on the first try.  While you're working with it, code is more like clay.  &lt;strong&gt;It evolves&lt;/strong&gt; as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也就是说，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;软件开发&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不是要设置课程的最终版本，就好像您在第一次尝试时按了一些铸铁雕像一样。使用它时，代码更像黏土。 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它随着&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的开发而发展，并更多地了解您要解决的问题领域。在开发过程中，类可能会相互干扰（您打算排除的依赖性），合并在一起或分裂。因此，我认为辩论归结为那些不想信奉宗教信仰的人&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fc364b2a3ee96e69b00f590088b9c6ef9c9b632" translate="yes" xml:space="preserve">
          <source>The encapsulation mantra is to make fields private and methods public.</source>
          <target state="translated">封装的口号是让字段私有化,方法公开化。</target>
        </trans-unit>
        <trans-unit id="24c1a5142c379d866afbafbee078155a76918b88" translate="yes" xml:space="preserve">
          <source>The last three I'm just leaving (N/A or D/C)...</source>
          <target state="translated">后面的三个我刚走(NA或DC)......</target>
        </trans-unit>
        <trans-unit id="7739aadce94ee1918ea9fc44988ea37dc88f140e" translate="yes" xml:space="preserve">
          <source>The two main ones are polymorphism, and validation. Even if it's just a stupid data structure.</source>
          <target state="translated">主要有两个,一是多态性,二是验证性。哪怕只是一个愚蠢的数据结构。</target>
        </trans-unit>
        <trans-unit id="b9a9f0d33bc8f65d834ed4cf962cc15baead1b5f" translate="yes" xml:space="preserve">
          <source>There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:</source>
          <target state="translated">原因有很多。我最喜欢的一个是当你需要改变行为或规范你可以在变量上设置什么的时候。例如,假设你有一个setSpeed(int speed)方法。但你希望你只能设置一个最大速度为100。你会做这样的事情。</target>
        </trans-unit>
        <trans-unit id="524aa01135463f9e6500b1024feefe5ec35bdc47" translate="yes" xml:space="preserve">
          <source>There are reasons to use getters and setters, but if those reasons don't exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (&lt;em&gt;You Ain't Gonna Need It&lt;/em&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有使用getter和setter的理由，但是如果不存在这些理由，以假封装之神的名义创建getter / setter对将不是一件好事。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行getter或setter的有效理由包括经常提到的事情，这些事情是您以后可以进行的潜在更改，例如验证或不同的内部表示形式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或者，该值应该对客户端可读，但不可写（例如，读取字典的大小），因此，简单的getter方法是不错的选择。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，当您做出选择时，这些原因应该存在，而不仅仅是以后可能需要的潜在原因。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是YAGNI的一个实例（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您将不需要它&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b6a012407992d0adb452537e445403437702a64" translate="yes" xml:space="preserve">
          <source>There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.</source>
          <target state="translated">使用getter和setter方法有一些好处,比如可以让你创建具有复杂功能的成员,你可以像访问属性一样访问这些成员。它们还可以让你创建只读和只写属性。</target>
        </trans-unit>
        <trans-unit id="5c8b73cc0e9f101f3c612ae902d16016395b6ff9" translate="yes" xml:space="preserve">
          <source>There is a good reason to consider using accessors is there is no property inheritance. See next example:</source>
          <target state="translated">考虑使用访问器有一个很好的理由,那就是没有属性继承。请看下一个例子。</target>
        </trans-unit>
        <trans-unit id="527645e19a15fbeecf356eccaa2e86a93ccde33b" translate="yes" xml:space="preserve">
          <source>There's also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.</source>
          <target state="translated">还有第三点不是所有人都涉及到了:getter和setter使用方法调用。这意味着它们看起来就像其他地方的正常方法一样。而不是有奇怪的DTO之类的特殊语法,你在任何地方都是一样的。</target>
        </trans-unit>
        <trans-unit id="18f126ceaf487ac6623f0c3bab85bbe1bcdce5fe" translate="yes" xml:space="preserve">
          <source>Think simple, easy, add complexity when needed.</source>
          <target state="translated">想的简单,容易,需要时增加复杂性。</target>
        </trans-unit>
        <trans-unit id="6515a583147f1258a376ba45fbb548e8c25fcfa1" translate="yes" xml:space="preserve">
          <source>This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you're breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you're breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.</source>
          <target state="translated">同样的论点也适用于这些直通式取值器对的其他假定的优点:如果你以后决定改变被设置的值,你就是破坏了合约。如果你覆盖了派生类中的默认功能,在一些无害的修改(比如日志或其他不可观测行为)之外,你就违反了基类的契约。这就违反了Liskov Substitutability原则,这被视为OO的原则之一。</target>
        </trans-unit>
        <trans-unit id="05f52926063e95fcb6e5b9afd2e3d36583ed0188" translate="yes" xml:space="preserve">
          <source>Those methods are the infamous getter and setter....</source>
          <target state="translated">那些方法就是臭名昭著的getter和setter.....。</target>
        </trans-unit>
        <trans-unit id="09878a7e0e4131a45151cbbe07487842d574b319" translate="yes" xml:space="preserve">
          <source>Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.</source>
          <target state="translated">第一眼看懂一段局部代码是良好的可读性的重要属性,getter和setter容易被破坏。这就是为什么我在使用它们的时候尽量避免它们,尽量减少它们的作用。</target>
        </trans-unit>
        <trans-unit id="0eff2b28e1b8f812b912f6b07b88bbaa84ab213d" translate="yes" xml:space="preserve">
          <source>We use getters and setters:</source>
          <target state="translated">我们使用getter和setter。</target>
        </trans-unit>
        <trans-unit id="5cdeb7802b982ac4d4c3fa7153f628c2667c933a" translate="yes" xml:space="preserve">
          <source>We'd end up with something like:</source>
          <target state="translated">我们最终会有这样的结果:</target>
        </trans-unit>
        <trans-unit id="10fa626645112c1ff717613b8f6c9dd7afc7b203" translate="yes" xml:space="preserve">
          <source>Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to &lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;STOP OVERUSING THE ACCESSORS&lt;/a&gt;&lt;/strong&gt;, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好吧，我只是想补充一点，即使有时候它们对于变量/对象的封装和安全性是必需的，如果我们想编写一个真正的面向对象程序，那么我们就需要&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;停止过度使用这些访问者&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因为有时我们依赖很多在没有必要的时候，它们几乎和我们将变量公开一样。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944804080828b744e35ec9aff8cde845d88d15f4" translate="yes" xml:space="preserve">
          <source>Well, you wouldn't expect that to work, right?
You want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.</source>
          <target state="translated">好吧,你不会希望这样做能成功吧?你希望有某种理智的检查。更糟的是,如果我没有指定最大容量呢?哦,亲爱的,我们有一个问题。</target>
        </trans-unit>
        <trans-unit id="26aac9603bf87fbcf6a374fcbcc4557be0d4afa4" translate="yes" xml:space="preserve">
          <source>What happens when I do:</source>
          <target state="translated">当我这样做的时候会怎么样。</target>
        </trans-unit>
        <trans-unit id="64e4e54e2b623a26f20e0a947aca9d4d41d5f2ff" translate="yes" xml:space="preserve">
          <source>What's the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?</source>
          <target state="translated">使用getter和setter----只能获取和设置----而不是简单地使用公共字段来处理这些变量有什么好处?</target>
        </trans-unit>
        <trans-unit id="bc1451039d4e3d9bf5c818e53a8cb441a696e201" translate="yes" xml:space="preserve">
          <source>When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you've directly accessed it.</source>
          <target state="translated">当你意识到你需要做的不仅仅是设置和获取值的时候,你可以直接把这个字段做成私有化,这样就可以瞬间告诉你直接访问这个字段的位置。</target>
        </trans-unit>
        <trans-unit id="9b9c2e122eb7bcbff9d3e55249a64348b7c398a2" translate="yes" xml:space="preserve">
          <source>When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don't want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it's called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won't be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.</source>
          <target state="translated">当你编写类时,我们总是鼓励你尽可能多地将实例变量私有化,并相应地添加getter和setter方法。这是因为有几次你可能不想让用户改变你的类中的某些变量。例如,如果你有一个私有的静态方法来跟踪特定类创建的实例数,你不希望用户使用代码修改该计数器。只有构造函数语句应该在每次调用该变量时,才会递增该变量。在这种情况下,你可能会创建一个私有实例变量,并且只允许对计数器变量使用getter方法,这意味着用户只能通过使用getter方法来获取当前值,而不能使用setter方法来设置新的值。创建一个没有setter的getter方法是一种简单的方法,可以使类中的某些变量只读。</target>
        </trans-unit>
        <trans-unit id="4d347fb8867285cc6a44cfd1b9af0e1b9e8d0d52" translate="yes" xml:space="preserve">
          <source>Whereas the former takes a lot less boilerplate code.</source>
          <target state="translated">而前者所需要的模板代码要少得多。</target>
        </trans-unit>
        <trans-unit id="c5b5b0a202322fa3613116e9cbb7a5bf916b32a2" translate="yes" xml:space="preserve">
          <source>Why use getters and setters/accessors</source>
          <target state="translated">为什么使用getter和setteraccessors?</target>
        </trans-unit>
        <trans-unit id="a23c4ec681b338f0e1fb882b204499718bf7417d" translate="yes" xml:space="preserve">
          <source>With 10 million cycles, the times are almost the same.
Here are 100 thousand (0.1 million) cycles:</source>
          <target state="translated">以1000万个周期计算,时间基本相同。这里是10万(0.1万)周期。</target>
        </trans-unit>
        <trans-unit id="e79ce24276092380db82c3f8e4404e6712bb5095" translate="yes" xml:space="preserve">
          <source>You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.</source>
          <target state="translated">你可以改变被设置的值----当呼叫者传给你一个他们[惊恐]希望你将值存储为AS IS时,这绝对是个噩梦。</target>
        </trans-unit>
        <trans-unit id="a8c50aac8fd19a1ea4829de498fc35d71feadd5e" translate="yes" xml:space="preserve">
          <source>You can hide the internal representation - fantastic, so you're making sure that all these operations are symmetrical right?</source>
          <target state="translated">你可以隐藏内部表象--太棒了,所以你确定这些操作都是对称的吧?</target>
        </trans-unit>
        <trans-unit id="2d6a0b7af8d1a9e87f51afd2f0f83ec48ca965c9" translate="yes" xml:space="preserve">
          <source>You may find more about them in Section 3.5 of &lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;Elegant Objects&lt;/a&gt; (my book about object-oriented programming).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Elegant Objects的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 3.5节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（我的有关面向对象编程的书）中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;找到有关它们的更多信息&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20973387eacad480489a6f5295307c1dee98b593" translate="yes" xml:space="preserve">
          <source>You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.
The results:</source>
          <target state="translated">你看,getter(几乎)总是快一点。然后,我用不同的循环数进行了尝试。我没有用100万,而是用了1000万和0.1万。结果是:</target>
        </trans-unit>
        <trans-unit id="a53b89844949d31aba6d3481e30d7696c0678c0c" translate="yes" xml:space="preserve">
          <source>You should use getters and setters when:</source>
          <target state="translated">你应该使用getter和setter的时候。</target>
        </trans-unit>
        <trans-unit id="8e50d4342310f2eace5776eb8cfc9f9aa9776c1a" translate="yes" xml:space="preserve">
          <source>You're dealing with something that is conceptually an attribute, but:</source>
          <target state="translated">你所处理的东西在概念上是一种属性,但。</target>
        </trans-unit>
        <trans-unit id="34fca68fe5cf9480f0a80d7c0c498c348f56c7dd" translate="yes" xml:space="preserve">
          <source>You've insulated your public interface from changes under the sheets - if you were designing an interface and weren't sure whether direct access to something was OK, then you should have kept designing.</source>
          <target state="translated">你已经将你的公共界面与床单下的变化隔绝了--如果你在设计一个界面时,不确定直接访问某个东西是否可以,那么你应该继续设计。</target>
        </trans-unit>
        <trans-unit id="3ceeaa00b6851469e15bf3447e9cd44a83c071a4" translate="yes" xml:space="preserve">
          <source>Your language doesn't have properties (or some similar mechanism, like Tcl's variable traces), or</source>
          <target state="translated">你的语言没有属性(或类似的机制,比如Tcl的变量痕迹),或</target>
        </trans-unit>
        <trans-unit id="5abc216f8d207459eff730de712d1ae80e9f4266" translate="yes" xml:space="preserve">
          <source>Your language's (or sometimes your framework's) idiomatic conventions encourage getters or setters for this use case.</source>
          <target state="translated">你的语言(有时是你的框架)的成语惯例鼓励这种用例的getter或setter。</target>
        </trans-unit>
        <trans-unit id="4a0520484ec8d35c906b8b68216ce4e15364da56" translate="yes" xml:space="preserve">
          <source>Your language's property support isn't sufficient for this use case, or</source>
          <target state="translated">你的语言的属性支持对于这个用例来说并不充分,或者说</target>
        </trans-unit>
        <trans-unit id="25eba86acee0fb5d6e89e75ccf0a09f1599a6c92" translate="yes" xml:space="preserve">
          <source>better;</source>
          <target state="translated">better;</target>
        </trans-unit>
        <trans-unit id="5f8adcfcb2808cbefe8948076116555c4b76f193" translate="yes" xml:space="preserve">
          <source>faster.</source>
          <target state="translated">faster.</target>
        </trans-unit>
        <trans-unit id="cac0e0595d1759f6424ad536496e3c73b57e1223" translate="yes" xml:space="preserve">
          <source>for members you have only one access specification for both setting and getting</source>
          <target state="translated">对于会员来说,你只有一个访问规范,用于设置和获取</target>
        </trans-unit>
        <trans-unit id="b648b79089ac12bd90bd3cb58b4439f26f462e08" translate="yes" xml:space="preserve">
          <source>for reusability</source>
          <target state="translated">可重复使用</target>
        </trans-unit>
        <trans-unit id="4618d40a12eec35b743c0d33ec26c6ee634eb9ad" translate="yes" xml:space="preserve">
          <source>for setters and getters you can fine tune it and define it separately</source>
          <target state="translated">对于setter和getter,你可以对其进行微调并单独定义。</target>
        </trans-unit>
        <trans-unit id="273bf92b0c3d89955ec505b2f149212919216d10" translate="yes" xml:space="preserve">
          <source>is any worse than:</source>
          <target state="translated">是什么都不如。</target>
        </trans-unit>
        <trans-unit id="dbe1b4e53e52bda3546c73c53e0d35d11158f6a4" translate="yes" xml:space="preserve">
          <source>safer; and</source>
          <target state="translated">更安全;以及</target>
        </trans-unit>
        <trans-unit id="22d6eb61e8eb4da06f77da4c904a9784e7917342" translate="yes" xml:space="preserve">
          <source>to perform validation in later stages of programming</source>
          <target state="translated">以便在后期的程序设计中进行验证</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
