<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1568091">
    <body>
      <group id="1568091">
        <trans-unit id="811ef1a393584a7d8880f3ef855143bdd7cae4ff" translate="yes" xml:space="preserve">
          <source>(Time 1 is the direct way, Time 2 is the getter)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(시간 1은 직접적인 방법이고 시간 2는 게터입니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2674e860c37ef14352b7760e1bb68edd1812e340" translate="yes" xml:space="preserve">
          <source>1) Start with all public members for basic objects with data and behavior.  This is why in all my C++ &quot;example&quot; code you'll notice me using &lt;code&gt;struct&lt;/code&gt; instead of &lt;code&gt;class&lt;/code&gt; everywhere.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1) 데이터와 행동으로 기본 개체에 대한 모든 공개 멤버로 시작하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 모든 C ++ &quot;example&quot;코드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 &lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대신 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하는 것을 알 수있는 이유입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9afae1edbdd3713190c6b92e13771fa366eb26a3" translate="yes" xml:space="preserve">
          <source>10 million cycles:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;천만 사이클 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="164834c50a9442cbf6258a5472c287b312c938dc" translate="yes" xml:space="preserve">
          <source>2) When an object's internal behavior for a data member becomes complex enough, (for example, it likes to keep an internal &lt;code&gt;std::list&lt;/code&gt; in some kind of order), accessor type functions are written.  Because I'm programming by myself, I don't always set the member &lt;code&gt;private&lt;/code&gt; right away, but somewhere down the evolution of the class the member will be &quot;promoted&quot; to either &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2) 데이터 멤버에 대한 객체의 내부 동작이 충분히 복잡해지면 (예 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::list&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 내부 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: list&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 어떤 종류의 순서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로 유지하려는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 접근 자 유형 함수가 작성됩니다. 내가 직접 프로그래밍하고 있기 때문에 항상 멤버를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 설정하지는 않지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스의 발전이 어딘가에서 멤버는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;protected&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 &quot;승격&quot;됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7892b3b7150042db597eb83df3fa2fc4d4a5356e" translate="yes" xml:space="preserve">
          <source>3) Classes that are fully fleshed out and have strict rules about their internals (ie &lt;em&gt;they&lt;/em&gt; know exactly what they are doing, and you are not to &quot;fuck&quot; (technical term) with its internals) are given the &lt;code&gt;class&lt;/code&gt; designation, default private members, and only a select few members are allowed to be &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3) 완전히 구체화하고 자신의 내부에 대한 엄격한 규칙을 (즉이되는 클래스 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;들은&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 그들이 무엇을 정확히 알고, 당신이 &quot;씨발&quot;(전문 용어로하지 않습니다)의 내부와) 지정된되어 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; private 멤버를 기본값을 지정 일부 회원 만 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;public&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b75455e8497af8e0568b85b084a32699e8ec694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Here are the some of the reasons I am aware of:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 알고있는 몇 가지 이유는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3cca966ff39b9fe1ddc20c0c05c5ab85772f223b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;Oh... cool, I guess?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클라이언트&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;아 ... 근사한 것 같아?&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="da3e4c734e73e93fbd221e07e4b36c403db2d6c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Client&lt;/strong&gt;: &quot;What can I do with an object of this class?&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클라이언트&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;이 클래스의 객체로 무엇을 할 수 있습니까?&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="255733b7d5ec2727df67865b9399e6f16913e0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code to the interface, not the implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현이 아닌 인터페이스에 대한 코드&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3009decd56c1847ecaff29ac42deaeb96d7e5ed9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Designer&lt;/strong&gt;: &quot;You can read and write several variables.&quot;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디자이너&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &quot;여러 변수를 읽고 쓸 수 있습니다.&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9327bbc5dd989bbd9c8de05113c4531259a85e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getter Methods:&lt;/strong&gt;&lt;em&gt;We can get access to private variables.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getter 메서드 : &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인 변수에 액세스 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49c576902394b2f88aa9c23003d5ca3259732bc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getters&lt;/strong&gt; and &lt;strong&gt;setters&lt;/strong&gt; are used to implement two of the fundamental aspects of Object Oriented Programming which are:</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세터&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 다음과 같은 객체 지향 프로그래밍의 두 가지 기본 측면을 구현하는 데 사용됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75bf09d32278474950179c8e319e9ebd15d37d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interfaces only specify methods, not fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스는 필드가 아닌 메소드 만 지정합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9db04f55b8e825e0380143c8c6459e9bd8ff383" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setter Methods:&lt;/strong&gt;&lt;em&gt;We can modify private fields.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세터 메소드 : &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개인 필드를 수정할 수 있습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e77ba06d495a30414d7393b72695c1a32bd8ea5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are actually &lt;em&gt;many good reasons&lt;/em&gt; to consider using accessors&lt;/strong&gt; rather than directly exposing fields of a class - beyond just the argument of encapsulation and making future changes easier.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로이 있습니다 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 좋은 이유&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 접근을 사용하는 것을 고려하는&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 캡슐화 단지 인수를 넘어 미래를 쉽게 변경하기 -보다는 직접 클래스의 필드를 노출은.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9b3b8c7d55f7b60e6b667f7483bd9cd9c8e936e" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* Even for that simple class, you may not necessarily want to allow setting the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values. If this is really a class, shouldn't it have methods like &lt;code&gt;translate&lt;/code&gt;, &lt;code&gt;rotate&lt;/code&gt;, etc.? If it's only a class because your language doesn't have records/structs/named tuples, then this isn't really a question of OO&amp;hellip;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* 간단한 클래스라도 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 값을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;설정하지 않아도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 실제로 클래스라면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;translate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rotate&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 등의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메소드가 없어야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;귀하의 언어에 레코드 / 구조체 / 명명 된 튜플이 없기 때문에 클래스 일 경우 실제로 OO의 문제는 아닙니다 ...&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9f1c7ed63a610cca03dbe1fb9a5969b1641f70d2" translate="yes" xml:space="preserve">
          <source>A public field is not worse than a getter/setter pair that does nothing except returning the field and assigning to it. First, it's clear that (in most languages) there is no functional difference. Any difference must be in other factors, like maintainability or readability.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공개 필드는 필드를 반환하고 할당하는 것 외에는 아무것도하지 않는 getter / setter 쌍보다 나쁘지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫째, (대부분의 언어에서) 기능상의 차이가 없다는 것이 분명합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;차이는 유지 관리 성 또는 가독성과 같은 다른 요소에 있어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ef49733b07a04ac879a3131cf59a6bb592d931f" translate="yes" xml:space="preserve">
          <source>A very simple class that holds how much liquid is in it, and what its capacity is (in milliliters).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;액체의 양과 용량 (밀리리터)을 담는 매우 간단한 클래스입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="82749ef4d632eabe207c0f5bfe48e65659005062" translate="yes" xml:space="preserve">
          <source>Accessors and mutators also allow for encapsulation - if you aren't supposed to see the value once its set (perhaps it's set in the constructor and then used by methods, but never supposed to be changed), it will never been seen by anyone. But if you can allow other classes to see or change it, you can provide the proper accessor and/or mutator.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;접근 자와 뮤 테이터는 또한 캡슐화를 허용합니다. 값이 일단 설정되면 (생성자에서 설정되고 메소드에서 사용되지만 절대 변경되지 않아야 함) 값을 볼 수 없다면 아무도 볼 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 다른 클래스에서 보거나 변경하도록 허용하는 경우 적절한 접근 자 및 / 또는 뮤 테이터를 제공 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4355e16716c8eb9f55ad860a735f5c6eda863c4" translate="yes" xml:space="preserve">
          <source>Adding pass-through getter/setter pairs to such a class adds no value. Other classes should provide meaningful operations, not just operations that fields already provide. That's how you can define and maintain useful invariants.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 클래스에 패스 스루 게터 / 세터 쌍을 추가하면 값이 추가되지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 클래스는 필드가 이미 제공 한 작업뿐만 아니라 의미있는 작업을 제공해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 유용한 불변량을 정의하고 유지할 수있는 방법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3d5035c0f50aaed825f8024c67607f79c9d6f00e" translate="yes" xml:space="preserve">
          <source>Additionally, this is to &quot;future-proof&quot; your class. In particular, changing from a field to a property is an ABI break, so if you do later decide that you need more logic than just &quot;set/get the field&quot;, then you need to break ABI, which of course creates problems for anything else already compiled against your class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 이것은 수업을 &quot;미래에 대비&quot;하기위한 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히, 필드에서 속성으로 변경하는 것은 ABI 중단이므로 나중에 &quot;필드 설정 / 받기&quot;보다 더 많은 논리가 필요하다고 결정하면 ABI를 중단해야합니다. 그렇지 않으면 이미 클래스에 대해 컴파일되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81c4e73e61dcb9ef881221a8e3e6e510aaafccd3" translate="yes" xml:space="preserve">
          <source>Allowing inheritors to change the semantics of how the property behaves and is exposed by overriding the getter/setter methods.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상속자가 getter / setter 메서드를 재정 의하여 속성의 동작 및 노출 방식의 의미를 변경할 수 있도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57a93d1fb290ddf7a1dbf6a3c46ddb1f2bd05da4" translate="yes" xml:space="preserve">
          <source>Allowing the getter/setter to be passed around as lambda expressions rather than values.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter / setter를 값이 아닌 람다 식으로 전달할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43274d4e786c79c30fbd5d48e83bf0480818a226" translate="yes" xml:space="preserve">
          <source>Also with different amounts of cycles, the getter is a little bit faster than the regular way. I hope this helped you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 다른 사이클 양으로 인해 게터는 일반적인 방식보다 약간 빠릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 도움이 되었기를 바랍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="033534469fa80b3c8584bdbf1263c23f9a826be5" translate="yes" xml:space="preserve">
          <source>Also, it's important to follow the idioms of the language (or framework) you're using. If you write beautiful Ruby-style code in C#, any experienced C# developer other than you is going to have trouble reading it, and that's bad. Some languages have stronger cultures around their conventions than others.&amp;mdash;and it may not be a coincidence that Java and Python, which are on opposite ends of the spectrum for how idiomatic getters are, happen to have two of the strongest cultures.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 사용중인 언어 (또는 프레임 워크)의 관용구를 따르는 것이 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C #으로 멋진 루비 스타일 코드를 작성하면 경험이없는 C # 개발자가 코드를 읽는 데 어려움을 겪을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떤 언어는 다른 언어보다 관습에 대해 더 강한 문화를 가지고 있습니다. 관용 게터가 어떻게 다른 스펙트럼 끝에있는 Java와 Python이 가장 강한 문화 중 하나를 갖는 것은 우연이 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d11a9b94f688fd1bb3e8236ba806a1a0de41e921" translate="yes" xml:space="preserve">
          <source>An oft-mentioned advantage of getter/setter pairs, isn't. There's this claim that you can change the implementation and your clients don't have to be recompiled. Supposedly, setters let you add functionality like validation later on and your clients don't even need to know about it. However, adding validation to a setter is a change to its preconditions, &lt;strong&gt;a violation of the previous contract&lt;/strong&gt;, which was, quite simply, &quot;you can put anything in here, and you can get that same thing later from the getter&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter / setter 쌍의 장점은 그렇지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구현을 변경할 수 있으며 클라이언트를 다시 컴파일 할 필요가 없다는 주장이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 setter를 사용하면 나중에 유효성 검사와 같은 기능을 추가 할 수 있으며 클라이언트도 알 필요가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 세터에 유효성 검사를 추가하는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것은 이전 계약을 위반&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 전제 조건의 변경 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이는 단순히 &quot;여기에 아무 것도 넣을 수 있으며 나중에 게터에서 같은 것을 얻을 수 있습니다&quot;라는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0528fa85939d91318183d46b3de68fa50d141cc4" translate="yes" xml:space="preserve">
          <source>And all these can have different ways to handle various whoopsies. The Bottle just checks and if it's overflowing it throws a RuntimeException. But that might be the wrong thing to do. 
(There is a useful discussion to be had about error handling, but I'm keeping it very simple here on purpose. People in comments will likely point out the flaws of this simplistic approach. ;) )</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고이 모든 것들은 다양한 솜씨를 다루는 다른 방법을 가질 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;병은 단지 검사하고 넘치면 RuntimeException을 발생시킵니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 그것은 잘못된 일일 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(오류 처리에 관한 유용한 토론이 있지만 여기서는 매우 간단하게 설명하고 있습니다. 의견을 가진 사람들은이 단순한 접근 방식의 결함을 지적 할 것입니다.;))&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3709a8d644d6848cb9e1e1b2612c33a14d466f8" translate="yes" xml:space="preserve">
          <source>And yes, it seems like we go from a very simple idea to getting much better answers quickly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 그렇습니다. 우리는 매우 간단한 아이디어에서 훨씬 더 나은 답변을 빨리 얻는 것처럼 보입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0adc3715c9771354c8ce3bffb1a2caa8b06842" translate="yes" xml:space="preserve">
          <source>Any validation you perform in there can only be context free, which validation rarely is in practice.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;거기에서 수행하는 모든 유효성 검사에는 컨텍스트가 없을 수 있으며 실제로는 거의 유효하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47b2dd5b5d660068e61383ca22ea5c24356d49a6" translate="yes" xml:space="preserve">
          <source>Anywhere a value can be used, a method that returns that value can be added. Instead of:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값을 사용할 수있는 곳이면 해당 값을 반환하는 메소드를 추가 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신에:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac6f0e579cd82854d73b7ba5e3dee370470c5bf1" translate="yes" xml:space="preserve">
          <source>As for the &quot;what if I want to change my implementation later?&quot; question (which is repeated multiple times in different wording in both the OP's question and the accepted answer): If it really is a pure implementation change, and you started with an attribute, you can change it to a property without affecting the interface. Unless, of course, your language doesn't support that. So this is really just the same case again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;나중에 구현을 나중에 변경하려면 어떻게해야합니까?&quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;질문 (OP의 질문과 허용 된 답변 모두에서 다른 표현으로 여러 번 반복됨) : 실제로 순수한 구현 변경이고 속성으로 시작한 경우 인터페이스에 영향을 미치지 않고 속성으로 변경할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론, 당신의 언어가 그것을 지원하지 않는 한. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 이것은 다시 똑같은 경우입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="43cacfbdc83927cc4b2aad1396ab0622fbf9274d" translate="yes" xml:space="preserve">
          <source>Because 2 weeks (months, years) from now when you realize that your setter needs to do &lt;strong&gt;more&lt;/strong&gt; than just set the value, you'll also realize that the property has been used directly in 238 other classes :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지금부터 2 주 (월, 년) 동안 세터가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단순히 값을 설정하는 것보다 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 많은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 일을해야한다는 것을 깨달았 기 때문에이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성이 238 개의 다른 클래스에서 직접 사용되었다는 것을 알게 될 것입니다. :-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e510c63de41dc0facb98c85d5c568e3eeeafd444" translate="yes" xml:space="preserve">
          <source>Beyond human readers, there will be libraries and tools that expect you to follow the conventions, and make your life harder if you don't. Hooking Interface Builder widgets to anything but ObjC properties, or using certain Java mocking libraries without getters, is just making your life more difficult. If the tools are important to you, don't fight them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인간 독자 이외에도 규칙을 따르고 그렇지 않으면 인생을 더 힘들게 만드는 라이브러리와 도구가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Interface Builder 위젯을 ObjC 속성 이외의 것에 연결하거나 게터없이 특정 Java mocking 라이브러리를 사용하면 인생이 더 어려워집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도구가 당신에게 중요하다면, 싸우지 마십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fac3c0dab4aeb3d8c561a0f4789de6b3ef9c2a67" translate="yes" xml:space="preserve">
          <source>But nobody is ever doing general OO design. They're doing design, and implementation, in a specific language. And in some languages, getters and setters are far from useless.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 아무도 일반 OO 디자인을하고 있지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그들은 특정 언어로 디자인과 구현을하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 일부 언어에서는 게터와 세터가 쓸모가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34bfb1e4e8fe780f6179a91f408e1aeba2e095cb" translate="yes" xml:space="preserve">
          <source>But there's another problem too. What if bottles were just one type of container? What if we had several containers, all with capacities and amounts of liquid filled? If we could just make an interface, we could let the rest of our program accept that interface, and bottles, jerrycans and all sorts of stuff would just work interchangably. Wouldn't that be better? Since interfaces demand methods, this is also a good thing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 또 다른 문제가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;병이 단지 한 유형의 용기라면? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;용량과 액체가 채워진 용기가 여러 개인 경우 어떻게해야합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스를 만들 수 있다면 나머지 프로그램에서 해당 인터페이스를 받아 들일 수 있으며 병, jerrycans 및 모든 종류의 것들이 상호 교환 적으로 작동합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나아지지 않습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인터페이스는 메소드를 요구하기 때문에 이것도 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5f581816971f55a0fe7fe755c1439b557642dd88" translate="yes" xml:space="preserve">
          <source>Code &lt;em&gt;evolves&lt;/em&gt;.  &lt;code&gt;private&lt;/code&gt; is great for when &lt;em&gt;you need data member protection&lt;/em&gt;.  Eventually all classes should be sort of &quot;miniprograms&quot; that have a well-defined interface &lt;em&gt;that you can't just screw with the internals of&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;코드가 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;진화합니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 멤버 보호가 필요할&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 때 유용 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 결국 모든 클래스는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부적으로 조일 수없는&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 잘 정의 된 인터페이스 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가진 일종의 &quot;미니 프로그램&quot;이어야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77e195f98a65d1f5b54c0c97c7133a6067f84b7e" translate="yes" xml:space="preserve">
          <source>Controlling the lifetime and memory management (disposal) semantics of the property - particularly important in non-managed memory environments (like C++ or Objective-C).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성의 수명 및 메모리 관리 (처분) 시맨틱 제어-특히 관리되지 않는 메모리 환경 (예 : C ++ 또는 Objective-C)에서 중요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="451d8c398dac194d41c458e0b0ad881903b0f15e" translate="yes" xml:space="preserve">
          <source>Depends on your language.  You've tagged this &quot;object-oriented&quot; rather than &quot;Java&quot;, so I'd like to point out that ChssPly76's answer is language-dependent.  In Python, for instance, there is no reason to use getters and setters.  If you need to change the behavior, you can use a property, which wraps a getter and setter around basic attribute access.  Something like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언어에 따라 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Java&quot;가 아닌 &quot;object-oriented&quot;에 태그를 달았으므로 ChssPly76의 답변은 언어에 따라 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 파이썬에서는 게터와 세터를 사용할 이유가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동작을 변경해야하는 경우 기본 속성 액세스를 통해 getter 및 setter를 랩핑하는 특성을 사용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 같은:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="59b09c675389e93fb718c3607a2b33d8ced3dba3" translate="yes" xml:space="preserve">
          <source>Don't use getters setters unless needed for your current delivery I.e. Don't think too much about what would happen in the future, if any thing to be changed its a change request in most of the production applications, systems.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;현재 제공에 필요한 경우가 아니면 getters setter를 사용하지 마십시오. 즉, 대부분의 프로덕션 응용 프로그램, 시스템에서 변경 요청이 변경 될 경우 향후 어떤 일이 발생할지 너무 많이 생각하지 마십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4811f53244f0f4eb1f508c3dce99ba627e7afab2" translate="yes" xml:space="preserve">
          <source>EDIT: I answered this question because there are a bunch of people learning programming asking this, and most of the answers are very technically competent, but they're not as easy to understand if you're a newbie. We were all newbies, so I thought I'd try my hand at a more newbie friendly answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집 : 나는이 질문을하는 프로그래밍을 배우는 사람들이 많기 때문에이 질문에 대답했으며 대부분의 대답은 매우 기술적으로 유능하지만 초보자라면 이해하기 쉽지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 모두 초보자 였기 때문에 좀 더 친숙한 답변을 시도 할 것이라고 생각했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="045c9ac03fcd3840d51b0f2e3b7fc9b7a8a9f185" translate="yes" xml:space="preserve">
          <source>Encapsulation mantra</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캡슐화 만트라&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="08518ebb827eeba5eb31bb4abc223904fb6d8e7c" translate="yes" xml:space="preserve">
          <source>Encapsulation of behavior associated with getting or setting the property - this allows additional functionality (like validation) to be added more easily later.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성 가져 오기 또는 설정과 관련된 동작 캡슐화-유효성 검사와 같은 추가 기능을 나중에 더 쉽게 추가 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a273aa55c91241aef5cbe7c904175deb629c3048" translate="yes" xml:space="preserve">
          <source>Even if your language does have properties, there may be cases where they're insufficient or inappropriate. For example, if you want to allow subclasses to control the semantics of an attribute, in languages without dynamic access, a subclass can't substitute a computed property for an attribute.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언어에 속성이 있더라도 언어가 불충분하거나 부적절 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 동적 액세스가없는 언어에서 하위 클래스가 속성의 의미를 제어 할 수 있도록하려면 하위 클래스가 계산 된 속성을 속성으로 대체 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e83595b7e6ea6eac5ba12ba0e0ea2bbad5c8a4f7" translate="yes" xml:space="preserve">
          <source>Even though getter and setter methods are useful, you should be careful not to overuse them because, among other issues, they can make code maintenance more difficult in certain situations. Also, they provide access to your class implementation, like public members. OOP practice discourages direct access to properties within a class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 및 setter 메소드가 유용하지만 다른 문제 중에서도 특정 상황에서 코드 유지 보수를 더 어렵게 만들 수 있으므로 과도하게 사용하지 않도록주의해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 공개 멤버와 같은 클래스 구현에 대한 액세스를 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OOP 연습은 클래스 내의 속성에 대한 직접 액세스를 권장하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d63ca1863a03a6cc66be541e8b13351b917e9595" translate="yes" xml:space="preserve">
          <source>Even though the getter and setter methods do not add new functionality, we can change our mind come back later to make that method</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 및 setter 메소드가 새로운 기능을 추가하지 않더라도 나중에 다시 해당 메소드를 작성하도록 마음을 바꿀 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67bba4f9917627abec7de3eae66ae2f912a2559b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;foo&lt;/code&gt; was public, I could easily set it to &lt;code&gt;null&lt;/code&gt; and then someone else could try to call a method on the object. But it's not there anymore! With a &lt;code&gt;setFoo&lt;/code&gt; method, I could ensure that &lt;code&gt;foo&lt;/code&gt; was never set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 public이면 쉽게 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 설정하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 사람이 객체에서 메서드를 호출하려고 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 더 이상 존재하지 않습니다! &lt;/font&gt;&lt;/font&gt; &lt;code&gt;setFoo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 설정되지 않았 음을 확인할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="476a63abfc2fa3c03aedf4736d5d9942e91d901f" translate="yes" xml:space="preserve">
          <source>From a object orientation design standpoint both alternatives can be damaging to the maintenance of the code by weakening the encapsulation of the classes. For a discussion you can look into this excellent article: &lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 지향 디자인 관점에서 두 가지 대안 모두 클래스의 캡슐화를 약화시켜 코드 유지 관리에 손상을 줄 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;토론을 위해이 훌륭한 기사를 볼 수 있습니다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://typicalprogrammer.com/?p=23&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://typicalprogrammer.com/?p=23&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a74b1d741c07f0d10578559f597f6187841258b7" translate="yes" xml:space="preserve">
          <source>From an OO theory point of view, getters and setters are useless. The interface of your class is what it does, not what its state is. (If not, you've written the wrong class.) In very simple cases, where what a class does is just, e.g., represent a point in rectangular coordinates,* the attributes are part of the interface; getters and setters just cloud that. But in anything but very simple cases, neither the attributes nor getters and setters are part of the interface.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OO 이론의 관점에서, 게터와 세터는 쓸모가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스의 인터페이스는 상태가 아닌 클래스의 인터페이스입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(그렇지 않은 경우, 잘못된 클래스를 작성했습니다.) 매우 간단한 경우, 클래스가하는 일이 예를 들어 직사각형 좌표로 점을 나타내는 경우 * 속성은 인터페이스의 일부입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터와 세터는 단지 그것을 클라우드합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 매우 단순한 경우를 제외하고는 속성이나 게터 및 세터가 인터페이스의 일부가 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57ae158f2e8c761e3b5b8bb16e7dccf2d8f722c4" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are accessor methods, meaning that they are generally a public interface to change private class members. You use getter and setter methods to define a property. You access getter and setter methods as properties outside the class, even though you define them within the class as methods. Those properties outside the class can have a different name from the property name in the class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getter 및 Setter 메서드는 접근 자 메서드이므로 일반적으로 개인 클래스 멤버를 변경하는 공용 인터페이스입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 및 setter 메소드를 사용하여 특성을 정의하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 내에서 메소드로 정의하더라도 getter 및 setter 메소드는 클래스 외부의 특성으로 액세스합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스 외부의 속성은 클래스의 속성 이름과 다른 이름을 가질 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aee376df07aa660dacecd6260f852a6d918c4cd1" translate="yes" xml:space="preserve">
          <source>Getter and setter methods are public interfaces to access private class members.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getter 및 Setter 메서드는 개인 클래스 멤버에 액세스하기위한 공용 인터페이스입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cba3e268c215d8706586fc9b9c009cffacae2d3a" translate="yes" xml:space="preserve">
          <source>Getters and setters can allow different access levels - for example the get may be public, but the set could be protected.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getter와 Setter는 서로 다른 액세스 수준을 허용 할 수 있습니다. 예를 들어 get은 공개적이지만 집합은 보호 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a06c2f62c876887f1c33b514ac9a69553b2b6392" translate="yes" xml:space="preserve">
          <source>Great! And now we just change Bottle to this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;큰! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 병을 다음과 같이 변경합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de8d815e48132f09b9bca3cbd23f2f97e119a145" translate="yes" xml:space="preserve">
          <source>Here the implementation details of Full Name is hidden from the user and is not accessible directly to the user, unlike a public attribute.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 전체 이름의 구현 세부 사항은 사용자에게 표시되지 않으며 공용 속성과 달리 사용자가 직접 액세스 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fa394821ab09cbccd5563100429404ca95e6440" translate="yes" xml:space="preserve">
          <source>Hiding the internal representation of the property while exposing a property using an alternative representation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대체 표현을 사용하여 속성을 노출시키면서 속성의 내부 표현을 숨 깁니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2f4f5cef8a9ea91e08ca99ee45e39ac9dcd0ebe" translate="yes" xml:space="preserve">
          <source>I find this approach allows me to avoid sitting there and religiously writing getter/setters when a lot of data members get migrated out, shifted around, etc. during the early stages of a class's evolution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 접근법을 통해 클래스 진화의 초기 단계에서 많은 데이터 멤버가 마이그레이션되거나 이동하는 등 종교적인 게터 / 세터를 피할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7ac905efee55cbf685e08af0da10c6d4468cd4fe" translate="yes" xml:space="preserve">
          <source>I had a base page class in a project that was handed to me that was loading some data from a couple different web service calls, but the data in those web service calls wasn't always used in all child pages.  Web services, for all of the benefits, pioneer new definitions of &quot;slow&quot;, so you don't want to make a web service call if you don't have to.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 가지 다른 웹 서비스 호출에서 일부 데이터를로드하는 프로젝트에 기본 페이지 클래스가 있었지만 해당 웹 서비스 호출의 데이터가 항상 모든 하위 페이지에서 사용되는 것은 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;웹 서비스는 모든 이점을 위해 &quot;느린&quot;에 대한 새로운 정의를 개척하여 필요하지 않은 경우 웹 서비스 호출을 원하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fec0ce430c9b50fa6a42a74bb5cc7bbe5070bd9d" translate="yes" xml:space="preserve">
          <source>I have massive system written without getters setters only with access modifiers and some methods to validate n perform biz logic. If you absolutely needed the. Use anything.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;액세스 수정 자 및 n 비즈 로직을 검증하는 몇 가지 방법으로 만 getters setter없이 작성된 대규모 시스템이 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 절대적으로 필요한 경우. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무엇이든 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b23c3487d24d1993bf58de911e47e2492ae65d64" translate="yes" xml:space="preserve">
          <source>I know it's a bit late, but I think there are some people who are interested in performance.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;약간 늦었지만 성능에 관심이있는 사람들이 있다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db14da99dc1a19fe0a1cec21c694b1166cec8396" translate="yes" xml:space="preserve">
          <source>I moved from public fields to getters, and now the getters check the cache, and if it's not there call the web service.  So with a little wrapping, a lot of web service calls were prevented.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공개 필드에서 게터로 옮겼는데 이제 게터가 캐시를 확인하고 웹 서비스가 없으면 캐시를 확인합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 작은 줄 바꿈으로 많은 웹 서비스 호출이 방지되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d44fc766ecbf5e63030bb952d02b5d6adbd46593" translate="yes" xml:space="preserve">
          <source>I spent quite a while thinking this over for the Java case, and I believe the real reasons are:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 케이스에 대해 이것을 생각하는 데 꽤 오랜 시간을 보냈으며 실제 이유는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2889b32bfcc03c8e80e260ed4b4716b29ae177b9" translate="yes" xml:space="preserve">
          <source>I would just like to throw the idea of annotation : @getter and @setter. With @getter, you should be able to obj = class.field but not class.field = obj. With @setter, vice versa. With @getter and @setter you should be able to do both. This would preserve encapsulation and reduce the time by not calling trivial methods at runtime.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@getter 및 @setter : 주석 아이디어를 던지고 싶습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@getter를 사용하면 obj = class.field는 할 수 있지만 class.field = obj는 할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@setter를 사용하면 그 반대도 마찬가지입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@getter와 @setter를 사용하면 둘 다 할 수 있어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 런타임에 사소한 메서드를 호출하지 않아 캡슐화가 유지되고 시간이 줄어 듭니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="448e5ff21f920e7e7eae20ce3fd54ad0522d451c" translate="yes" xml:space="preserve">
          <source>I would not take advantage of ignorance of business owners of deep technical know how just because I think it's correct or I like the approach.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;심도 깊은 기술 소유자의 무지를 활용하지 않을 것입니다. 그것이 옳다고 생각하거나 접근 방식을 좋아한다는 이유 만 알고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="91a599d9c25706ea81b0f073fcd9ead9e1d48f03" translate="yes" xml:space="preserve">
          <source>I'll leave the definition of the BottleOverflowException as an exercise to the reader.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 BottleOverflowException의 정의를 독자에게 연습으로 남겨 둘 것이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0cfd8d8587de574184a35bdea413f3d36872445" translate="yes" xml:space="preserve">
          <source>I've done a little performance test. I wrote a class &quot;NumberHolder&quot; which, well, holds an Integer. You can either read that Integer by using the getter method
&lt;code&gt;anInstance.getNumber()&lt;/code&gt; or by directly accessing the number by using &lt;code&gt;anInstance.number&lt;/code&gt;. My programm reads the number 1,000,000,000 times, via both ways. That process is repeated five times and the time is printed. I've got the following result:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;약간의 성능 테스트를 수행했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 정수를 보유하고있는 &quot;NumberHolder&quot;클래스를 작성했다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 메소드 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.getNumber()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하거나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;anInstance.number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 사용하여 숫자에 직접 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여 해당 Integer를 읽을 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 프로그램은 두 가지 방법으로 1,000,000,000 번을 읽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 과정이 5 번 반복되고 시간이 인쇄됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같은 결과가 나타납니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a0978c43bc2b11a6a993b548afff0b3b5ca45a92" translate="yes" xml:space="preserve">
          <source>If a class has these dumb getters and setters for every field, then it is a class that has no invariants whatsoever, &lt;em&gt;no contract&lt;/em&gt;. Is that really object-oriented design? If all the class has is those getters and setters, it's just a dumb data holder, and dumb data holders should look like dumb data holders:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스가 모든 필드에 대해 이러한 벙어리 게터와 세터를 가지고 있다면, 그것은 불변성이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;없고 계약&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이없는 클래스입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 실제로 객체 지향 디자인입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 클래스에 게터와 세터가 있다면 바보 데이터 홀더 일뿐이며 바보 데이터 홀더는 바보 데이터 홀더처럼 보일 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="46fb1f117749485f93dfde52629c12a6592e5f3e" translate="yes" xml:space="preserve">
          <source>If getters and setters are ever doing more than just the simple get/set, I can figure this one out very quickly, but I'm not 100% clear on how:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter와 setter가 단순한 get / set 이상의 기능을 수행하는 경우이 정보를 매우 빠르게 파악할 수 있지만 방법에 대해서는 100 % 명확하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="949e9da0978aaee4523cbb0c409b2bf0b89c3805" translate="yes" xml:space="preserve">
          <source>If that should not have been the contract, then the interface was allowing clients to put the object in invalid states. &lt;em&gt;That's the exact opposite of encapsulation&lt;/em&gt; If that field could not really be set to anything from the start, why wasn't the validation there from the start?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 계약이 아니어야한다면, 인터페이스는 클라이언트가 객체를 유효하지 않은 상태로 놓을 수 있도록 허용 한 것입니다. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 캡슐화의 정반대입니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해당 필드를 실제로 시작부터 다른 것으로 설정할 수 없다면 왜 시작부터 검증이 이루어지지 않았습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d442a6315e08af677c7d3f5fd084eb11ecca9ce5" translate="yes" xml:space="preserve">
          <source>If your language doesn't have properties, then the only way to represent something that's conceptually an attribute, but is actually computed, or validated, etc., is through getters and setters.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언어에 속성이없는 경우 개념적으로 속성이지만 실제로 계산 또는 검증되는 것을 나타내는 유일한 방법은 getter 및 setter를 사용하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c75e6d8a92da8554d6134d8d780910766638384b" translate="yes" xml:space="preserve">
          <source>Improved interoperability with libraries that are designed to operate against property getter/setters - Mocking, Serialization, and WPF come to mind.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성 게터 / 세터에 대해 작동하도록 설계된 라이브러리와의 향상된 상호 운용성-Mocking, Serialization 및 WPF가 떠 오릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a045af26b3882dcd948db97f36b10344affa5eda" translate="yes" xml:space="preserve">
          <source>In a pure object-oriented world getters and setters is a &lt;strong&gt;terrible anti-pattern&lt;/strong&gt;. Read this article: &lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;Getters/Setters. Evil. Period&lt;/a&gt;. In a nutshell, they encourage programmers to think about objects as of data structures, and this type of thinking is pure procedural (like in COBOL or C). In an object-oriented language there are no data structures, but only objects that expose behavior (not attributes/properties!)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;순수한 객체 지향 세계에서 게터와 세터는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;끔찍한 안티 패턴&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Getters / Setters&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기사를 읽으십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;악. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기간&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단히 말해서 프로그래머는 데이터 구조를 기준으로 객체에 대해 생각하도록 장려하며 이러한 유형의 사고는 순수한 절차 적입니다 (COBOL 또는 C와 같이). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 지향 언어에는 데이터 구조가 없지만 동작을 노출하는 객체 만 있습니다 (속성 / 속성이 아님).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60ede22798c8886c1279c94029a7d8fbdb115073" translate="yes" xml:space="preserve">
          <source>In an object oriented language the methods, and their access modifiers, declare the interface for that object. Between the constructor and the accessor and mutator methods it is possible for the developer to control access to the internal state of an object. If the variables are simply declared public then there is no way to regulate that access.
And when we are using setters we can restrict the user for the input we need. Mean the feed for that very variable will come through a proper channel and the channel is predefined by us. So it's safer to use setters.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;객체 지향 언어에서 메소드 및 액세스 수정자는 해당 객체의 인터페이스를 선언합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;생성자와 액세서 및 뮤 테이터 메소드 사이에서 개발자가 오브젝트의 내부 상태에 대한 액세스를 제어 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;변수가 단순히 public으로 선언되면 해당 액세스를 조절할 방법이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 setter를 사용할 때 필요한 입력으로 사용자를 제한 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 변수에 대한 피드가 올바른 채널을 통해 전달되고 채널이 Google에 의해 사전 정의되어 있음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 세터를 사용하는 것이 더 안전합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9570686c65057df9d5555a427b45dcb388eb1c6d" translate="yes" xml:space="preserve">
          <source>In languages which don't support &quot;properties&quot; (C++, Java) or require recompilation of clients when changing fields to properties (C#), using get/set methods is easier to modify. For example, adding validation logic to a setFoo method will not require changing the public interface of a class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;속성&quot;(C ++, Java)을 지원하지 않거나 필드를 속성 (C #)으로 변경할 때 클라이언트를 다시 컴파일해야하는 언어에서는 get / set 메소드를 사용하는 것이 더 쉽습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, setFoo 메소드에 유효성 검증 로직을 추가하면 클래스의 공용 인터페이스를 변경할 필요가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49c146ae67da9fce98a67aa9876195255bf52355" translate="yes" xml:space="preserve">
          <source>In languages which support &quot;real&quot; properties (Python, Ruby, maybe Smalltalk?) there is no point to get/set methods.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;실제&quot;속성을 지원하는 언어 (Python, Ruby, 아마도 Smalltalk?)에서는 메소드를 가져 오거나 설정할 필요가 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a756c26f5397e6bf09cb6c1e8673c721a0adcdc" translate="yes" xml:space="preserve">
          <source>In layman's terms</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;평신도의 관점에서&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03538993fd141670ce7112b8a39c0f3f3dcb7e47" translate="yes" xml:space="preserve">
          <source>In other words, the only way you can specify a field in an interface is by providing a method for writing a new value and a method for reading the current value.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 인터페이스에서 필드를 지정할 수있는 유일한 방법은 새 값을 작성하는 방법과 현재 값을 읽는 방법을 제공하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="665cb9197ac6f3430ff52c71c900a99810bbd645" translate="yes" xml:space="preserve">
          <source>Inheriting this class, you can override default functionality - in other words you can REALLY confuse callers by not only hiding the implementation but making it inconsistent.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 클래스를 상속하면 기본 기능을 재정의 할 수 있습니다. 즉, 구현을 숨기고 일관성이 없어서 호출자를 혼란스럽게 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a50b3b7baaffbe0c2005cff92a6863837d540b1" translate="yes" xml:space="preserve">
          <source>Instead of</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신에&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a846f258ad5630d87aa074967dac3d41a23874d" translate="yes" xml:space="preserve">
          <source>Instead of doing this, we can create a bean &lt;code&gt;class(Person)&lt;/code&gt; with getter and setter methods.  So tomorrow we can just create objects of this Bean &lt;code&gt;class(Person class)&lt;/code&gt; whenever we need to add a new person (see the figure). Thus we are reusing the fields and methods of bean class, which is much better.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 수행하는 대신 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 및 setter 메소드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하여 Bean &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작성할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 내일 우리는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 사람을 추가해야 할 때마다이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bean &lt;/font&gt;&lt;/font&gt; &lt;code&gt;class(Person class)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 객체를 만들 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(그림 참조). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 빈 클래스의 필드와 메소드를 재사용하는 것이 훨씬 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ebdc6050b1ad6649a3451d6af5910e06b12430e3" translate="yes" xml:space="preserve">
          <source>Insulating your public interface from change - allowing the public interface to remain constant while the implementation changes without affecting existing consumers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;퍼블릭 인터페이스를 변경으로부터 보호-기존 소비자에게 영향을주지 않고 구현이 변경되는 동안 퍼블릭 인터페이스를 일정하게 유지할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ac0c56e853fb8f8f0be1b64596f6b59055cbdae" translate="yes" xml:space="preserve">
          <source>It can be useful for lazy-loading.  Say the object in question is stored in a database, and you don't want to go get it unless you need it.  If the object is retrieved by a getter, then the internal object can be null until somebody asks for it, then you can go get it on the first call to the getter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지연 로딩에 유용 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제의 객체가 데이터베이스에 저장되어 있고 필요하지 않으면 가져 가고 싶지 않다고 가정하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter가 객체를 검색하면 누군가가 요청할 때까지 내부 객체가 null 일 수 있습니다. 그러면 getter를 처음 호출 할 때 객체를 가져올 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc4afcf1103ef9d6c53108ff6cc9b9b18bdb3242" translate="yes" xml:space="preserve">
          <source>It gives you many benefits, one of which being that you can change the implementation of the getter/setter behind the scenes but any consumer of that value will continue to work as long as the data type remains the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 많은 이점을 제공합니다. 그중 하나는 배후에서 게터 / 세터의 구현을 변경할 수 있지만 그 값을 가진 소비자는 데이터 유형이 동일하게 유지되는 한 계속 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="729e36d06a905476ea11f5c8b0c1812a73dff9ce" translate="yes" xml:space="preserve">
          <source>It's a beautifully simply piece of code until you realize its a setter. Now, you follow that setter and find that it also sets person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName, and calls person.update(), which sends a query out to the database, etc. Oh, that's where your memory leak was occurring.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세터를 깨닫기 전까지는 아주 간단하게 코드 조각입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 해당 setter를 따라 person.firstName, person.lastName, person.isHuman, person.hasReallyCommonFirstName을 설정하고 person.update ()를 호출하여 데이터베이스로 쿼리를 보내는 등을 찾습니다. 메모리 누수가 발생한 위치&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16aa234236b2a7935d4484df427e10358d69a866" translate="yes" xml:space="preserve">
          <source>Let's say we have this simple class:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 간단한 클래스가 있다고 가정 해 봅시다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9377946989c0599e694f34e6e15b1e30f95e7bb" translate="yes" xml:space="preserve">
          <source>Lots of people talk about the advantages of getters and setters but I want to play devil's advocate. Right now I'm debugging a very large program where the programmers decided to make everything getters and setters. That might seem nice, but its a reverse-engineering nightmare.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 사람들이 게터와 세터의 장점에 대해 이야기하지만 저는 악마의 옹호자를하고 싶습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지금은 프로그래머가 모든 게터와 세터를 만들기로 결정한 매우 큰 프로그램을 디버깅하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멋지게 보일지 모르지만 리버스 엔지니어링의 악몽입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d38c1d25ba364989ccc66f32498e40bbffbe427" translate="yes" xml:space="preserve">
          <source>My 2 cents :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 2 센트 :)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89bcb9ce512e3a24b71ffdc4db2c607ef7562d71" translate="yes" xml:space="preserve">
          <source>Not only is &lt;code&gt;getVar()&lt;/code&gt; visually noisy, it gives this illusion that &lt;code&gt;gettingVar()&lt;/code&gt; is somehow a more complex process than it really is.  How you (as the class writer) regard the sanctity of &lt;code&gt;var&lt;/code&gt; is particularly confusing to a user of your class if it has a passthru setter -- then it looks like you're putting up these gates to &quot;protect&quot; something you insist is valuable, (the sanctity of &lt;code&gt;var&lt;/code&gt;) but yet even you concede &lt;code&gt;var&lt;/code&gt;'s protection isn't worth much by the ability for anyone to just come in and &lt;code&gt;set&lt;/code&gt;&lt;code&gt;var&lt;/code&gt; to whatever value they want, without you even peeking at what they are doing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;getVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 시각적으로 노이즈 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있을&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 뿐만 아니라 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;gettingVar()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 실제보다 복잡한 프로세스라는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;착각을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;줍니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . 당신이 (클래스 라이터로서) &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 신성도를 고려하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방법은 경유지 세터가있는 경우 클래스의 사용자에게 특히 혼란 스럽습니다. 그러면 당신이 주장하는 것을 &quot;보호&quot;하기 위해이 게이트를 세우는 것처럼 보입니다. , ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 신성함 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 그러나 당신은 심지어 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 보호는 누군가가 들어 와서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원하는 값으로 &lt;/font&gt; &lt;code&gt;var&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;set&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 능력에 의해 가치가 없다고 생각 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d25ccd6d1abfaa462958a3daf7b3c72739444cbb" translate="yes" xml:space="preserve">
          <source>Now notice how much more robust this is. We can deal with any type of container in our code now by accepting LiquidContainer instead of Bottle. And how these bottles deal with this sort of stuff can all differ. You can have bottles that write their state to disk when it changes, or bottles that save on SQL databases or GNU knows what else.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 이것이 훨씬 더 강력하다는 것을 알 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 Bottle 대신 LiquidContainer를 수락하면 코드에서 모든 유형의 컨테이너를 처리 할 수 ​​있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 병이 이런 종류의 물건을 다루는 방법은 모두 다를 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;상태가 변경 될 때 디스크에 상태를 기록하는 병이나 SQL 데이터베이스 또는 GNU에 저장된 병이 다른 것을 알고있을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee14a6cb3f5a0e797943e0e6cf7bc7231a57d7bc" translate="yes" xml:space="preserve">
          <source>Now what if EVERYWHERE in your code you were using the public field and then you realized you need the above requirement? Have fun hunting down every usage of the public field instead of just modifying your setter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 코드의 어디에나 퍼블릭 필드를 사용하고 있고 위의 요구 사항이 필요하다는 것을 깨달았다면 어떻게해야합니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세터를 수정하는 대신 퍼블릭 필드의 모든 사용법을 재미있게 찾아보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bea2afcb08c47bb55bd603ad05f6ae591ec6e48a" translate="yes" xml:space="preserve">
          <source>On the other hand, if the member is public, the tools don't make it possible to filter read/write access to the member. So you have to trudge though all uses of the member.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면, 멤버가 공개 인 경우 도구를 사용하면 멤버에 대한 읽기 / 쓰기 액세스를 필터링 할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 회원의 모든 용도를 망쳐 놓아야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9f8893e9b850ac172431cb049bc524b942b2431" translate="yes" xml:space="preserve">
          <source>One advantage of accessors and mutators is that you can perform validation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;접근 자와 뮤 테이터의 장점 중 하나는 유효성 검사를 수행 할 수 있다는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="91b95b7297fe9079d417e879ad5486deb384c22d" translate="yes" xml:space="preserve">
          <source>One aspect I missed in the answers so far, the access specification:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;지금까지 답변에서 놓친 한 가지 측면은 액세스 사양입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10765ac54cefce78aa01ff15a00dd5d27040fc3d" translate="yes" xml:space="preserve">
          <source>One of the basic principals of OO design: &lt;strong&gt;Encapsulation!&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OO 디자인의 기본 원칙 중 하나 : &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캡슐화!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b5607ce4ce1a004d9de9e90c6bbff2691c7ffe7" translate="yes" xml:space="preserve">
          <source>One other use (in languages that support properties) is that setters and getters can imply that an operation is non-trivial.  Typically, you want to avoid doing anything that's computationally expensive in a property.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성을 지원하는 언어에서 다른 용도로는 setter와 getter가 조작이 중요하지 않다는 것을 암시 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 속성에서 계산 비용이 많이 드는 작업은 피하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76713a423e5722e517c06fbab6e7cfe5f4817367" translate="yes" xml:space="preserve">
          <source>One relatively modern advantage of getters/setters is that is makes it easier to browse code in tagged (indexed) code editors. E.g. If you want to see who sets a member, you can open the call hierarchy of the setter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter / setter의 상대적으로 현대적인 이점 중 하나는 태그가있는 (색인이있는) 코드 편집기에서 코드를 쉽게 찾을 수 있다는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 누가 멤버를 설정하는지 보려면 세터의 통화 계층을 열 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="be9cbb9ed4b5c6641f5aa815d9709c0e21aceeaa" translate="yes" xml:space="preserve">
          <source>Please note also that you can't change the capacity of a bottle. It's now set in stone. You could do this with an int by declaring it final. But if this was a list, you could empty it, add new things to it, and so on. You can't limit the access to touching the innards.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;병의 용량은 변경할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 돌로 설정되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최종 선언하여 int 로이 작업을 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나이 목록 인 경우 목록을 비우고 새 항목을 추가하는 등의 작업을 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부를 만지는 것에 대한 액세스를 제한 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="36c1fd3f265a620d873362378468f7e90e8a20ae" translate="yes" xml:space="preserve">
          <source>Providing a debugging interception point for when a property changes at runtime - debugging when and where a property changed to a particular value can be quite difficult without this in some languages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;런타임에 속성이 변경 될 때 디버깅 차단 지점 제공-일부 언어에서는 속성이 특정 값으로 변경된 시점과 위치를 디버깅하기가 매우 어려울 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e2aa20a27ca3d6e7b23af75afca271955543ebe" translate="yes" xml:space="preserve">
          <source>Put another way: If you believe that consumers of your class shouldn't even know that you have a &lt;code&gt;spam&lt;/code&gt; attribute, much less be able to change it willy-nilly, then giving them a &lt;code&gt;set_spam&lt;/code&gt; method is the last thing you want to do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 방법을 넣어 : 당신이 가지고 클래스의 소비자가 알지도해야한다고 여겨지는 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;spam&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 속성을 훨씬 덜 다음 그들에게주는 다짜고짜를 변경할 수 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;set_spam&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 방법은 당신이 원하는 마지막 일이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d2800b08281984434942ba5adcad8919a80ff4cc" translate="yes" xml:space="preserve">
          <source>Say you're looking through hundreds of lines of code and you come across this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수백 줄의 코드를 살펴보고 다음과 같은 내용을 접한다고 가정 해보십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0fe6038ebdf6b117336c04451dc9e3876effcb5c" translate="yes" xml:space="preserve">
          <source>So I program as follows (assuming an &quot;agile&quot; type approach -- ie when I write code not knowing &lt;em&gt;exactly&lt;/em&gt; what it will be doing/don't have time or experience to plan an elaborate waterfall style interface set):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 다음과 같이 프로그래밍합니다 ( &quot;민첩한&quot;유형 접근을 가정합니다. 즉, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정확히&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 어떤 폭포 스타일 인터페이스 세트를 계획 할 시간이나 경험이 없는지 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정확히&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 알 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 없는 코드를 작성할 때 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a9eda9489b827ab46566f12f43fa4c89312a585f" translate="yes" xml:space="preserve">
          <source>So the getter saves me from trying to figure out, on each child page, what I will need.  If I need it, I call the getter, and it goes to find it for me if I don't already have it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 getter는 각 자식 페이지에서 필요한 내용을 파악하지 않아도됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필요한 경우 getter를 호출하고 아직없는 경우이를 찾으러갑니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3d0d9303819ce1ab413fffddd86f3afbed876b1f" translate="yes" xml:space="preserve">
          <source>So this is very rarely a general OO question; it's a language-specific question, with different answers for different languages (and different use cases).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 이것은 일반적인 OO 질문은 거의 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 언어 (및 다른 사용 사례)에 대해 다른 답변을 가진 언어 별 질문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="110215a582ce0c01e647e0ab38866bd28ab289f7" translate="yes" xml:space="preserve">
          <source>So you have:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 당신은 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="84327f3567507ed383657990eb8c4dfa0d117dca" translate="yes" xml:space="preserve">
          <source>So, now that you broke the contract, changing every file in the codebase is something you should want to do, not avoid. If you avoid it you're making the assumption that all the code assumed the contract for those methods was different.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 계약을 파기 했으므로 코드베이스의 모든 파일을 변경하는 것은 피해야 할 일입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;피하지 않으면 모든 코드가 해당 메소드의 계약이 다르다고 가정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cbead7356f0d8824aecb16d6a0262b6c772bd6e2" translate="yes" xml:space="preserve">
          <source>Some libraries expect this, but not many - reflection, serialization, mock objects all work just fine with public fields.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 라이브러리는 이것을 기대하지만 반사, 직렬화, 모의 객체는 모두 공공 장소에서 잘 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8d6ec5b172b09312ffab2762d5844c299a54132" translate="yes" xml:space="preserve">
          <source>Suppose we have an Employee class:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Employee 클래스가 있다고 가정하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f0b6a967a2c05a11d643d0e4a7aa868f211882c5" translate="yes" xml:space="preserve">
          <source>Suppose we need to store the details of this &lt;code&gt;Person&lt;/code&gt;. This &lt;code&gt;Person&lt;/code&gt; has the fields &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Doing this involves creating methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;sex&lt;/code&gt;. Now if we need create another person, it becomes necessary to create the methods for &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;sex&lt;/code&gt; all over again.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 세부 사항을 저장해야한다고 가정하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Person&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를가&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 집니다. 이를 위해서는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 방법을 만들어야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 이제 다른 사람을 만들어야한다면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sex&lt;/code&gt; 에&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 방법을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다시 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;만들어야 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d3e474c35abac8c8e79adba6fbbab7a5646b1ac0" translate="yes" xml:space="preserve">
          <source>Thanks, that really clarified my thinking. Now here is (almost) 10 (almost) good reasons NOT to use getters and setters:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고마워, 정말 내 생각을 명확히했다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 getter와 setter를 사용하지 말아야 할 10 가지 이유가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a29e9e3845b5c733ae0c153286a63607107be5fa" translate="yes" xml:space="preserve">
          <source>That said, &lt;em&gt;software development&lt;/em&gt; isn't about setting down that final version of the class as if you're pressing some cast iron statue on the first try.  While you're working with it, code is more like clay.  &lt;strong&gt;It evolves&lt;/strong&gt; as you develop it and learn more about the problem domain you are solving.  During development classes may interact with each other than they should (dependency you plan to factor out), merge together, or split apart.  So I think the debate boils down to people not wanting to religiously write</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;소프트웨어 개발&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 첫 번째 시도에서 주철 조각상을 누르는 것처럼 클래스의 최종 버전을 설정하는 것이 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작업하는 동안 코드는 점토와 비슷합니다. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 진화&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 당신이 그것을 개발하고 해결하는 문제 영역에 대해 더 배울 수있다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개발 과정에서 클래스는 서로 (인식 할 계획 인 의존성), 서로 합치거나 분리되는 것보다 서로 상호 작용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 나는 토론이 종교적으로 글을 쓰고 싶지 않은 사람들에게 귀결된다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fc364b2a3ee96e69b00f590088b9c6ef9c9b632" translate="yes" xml:space="preserve">
          <source>The encapsulation mantra is to make fields private and methods public.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캡슐화 만트라는 필드를 개인용 및 메소드를 공용으로 만드는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="24c1a5142c379d866afbafbee078155a76918b88" translate="yes" xml:space="preserve">
          <source>The last three I'm just leaving (N/A or D/C)...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 마지막으로 떠나는 마지막 3 명 (N / A 또는 D / C) ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7739aadce94ee1918ea9fc44988ea37dc88f140e" translate="yes" xml:space="preserve">
          <source>The two main ones are polymorphism, and validation. Even if it's just a stupid data structure.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 가지 주요한 것은 다형성과 검증입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바보 같은 데이터 구조 일지라도.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b9a9f0d33bc8f65d834ed4cf962cc15baead1b5f" translate="yes" xml:space="preserve">
          <source>There are many reasons. My favorite one is when you need to change the behavior or regulate what you can set on a variable. For instance, lets say you had a setSpeed(int speed) method. But you want that you can only set a maximum speed of 100. You would do something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 가지 이유가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 가장 좋아하는 것은 동작을 변경하거나 변수에 설정할 수있는 것을 조절해야 할 때입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 setSpeed ​​(int speed) 메서드가 있다고 가정 해 봅시다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 최대 속도 100 만 설정할 수 있기를 원합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="524aa01135463f9e6500b1024feefe5ec35bdc47" translate="yes" xml:space="preserve">
          <source>There are reasons to use getters and setters, but if those reasons don't exist, making getter/setter pairs in the name of false encapsulation gods is not a good thing. Valid reasons to make getters or setters include the things often mentioned as the potential changes you can make later, like validation or different internal representations. Or maybe the value should be readable by clients but not writable (for example, reading the size of a dictionary), so a simple getter is a nice choice. But those reasons should be there when you make the choice, and not just as a potential thing you may want later. This is an instance of YAGNI (&lt;em&gt;You Ain't Gonna Need It&lt;/em&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터와 세터를 사용해야 할 이유가 있지만, 그 이유가 존재하지 않으면 거짓 캡슐화 신의 이름으로 게터 / 세터 쌍을 만드는 것은 좋지 않습니다. 게터 나 세터를 만드는 유효한 이유에는 유효성 검사 또는 다른 내부 표현과 같이 나중에 변경할 수있는 잠재적 변경 사항으로 자주 언급되는 사항이 포함됩니다. 또는 클라이언트가 값을 읽을 수는 있지만 쓸 수 없어야합니다 (예 : 사전의 크기를 읽는 것). 간단한 getter를 선택하는 것이 좋습니다. 그러나 이러한 이유는 나중에 원하는 잠재적 인 것이 아니라 선택을 할 때 있어야합니다. 이것은 YAGNI의 인스턴스입니다 ( &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;You Ai n't Gonna Need It&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b6a012407992d0adb452537e445403437702a64" translate="yes" xml:space="preserve">
          <source>There are some advantages to using getter and setter methods, such as the ability to let you create members with sophisticated functionality that you can access like properties. They also let you create read-only and write-only properties.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getter 및 setter 메소드를 사용하면 몇 가지 장점이 있습니다. 예를 들어, 유사한 특성에 액세스 할 수있는 정교한 기능을 가진 멤버를 작성할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 읽기 전용 및 쓰기 전용 속성을 만들 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c8b73cc0e9f101f3c612ae902d16016395b6ff9" translate="yes" xml:space="preserve">
          <source>There is a good reason to consider using accessors is there is no property inheritance. See next example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속성 상속이 없기 때문에 접근자를 사용하는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 예를 참조하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="527645e19a15fbeecf356eccaa2e86a93ccde33b" translate="yes" xml:space="preserve">
          <source>There's also the third thing that not everyone has addressed: getters and setters use method calls. That means that they look like normal methods everywhere else does. Instead of having weird specific syntax for DTOs and stuff, you have the same thing everywhere.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 모든 사람이 다룰 수있는 것은 아닙니다. 게터와 세터는 메소드 호출을 사용합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 다른 곳에서는 일반적인 방법처럼 보입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DTO 및 물건에 대해 이상한 특정 구문을 사용하는 대신 모든 곳에서 동일한 내용을 갖습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18f126ceaf487ac6623f0c3bab85bbe1bcdce5fe" translate="yes" xml:space="preserve">
          <source>Think simple, easy, add complexity when needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단하고 쉽게 생각하고 필요할 때 복잡성을 추가하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6515a583147f1258a376ba45fbb548e8c25fcfa1" translate="yes" xml:space="preserve">
          <source>This same argument applies to other supposed advantages of these pass-through getter/setter pairs: if you later decide to change the value being set, you're breaking the contract. If you override the default functionality in a derived class, in a way beyond a few harmless modifications (like logging or other non-observable behaviour), you're breaking the contract of the base class. That is a violation of the Liskov Substitutability Principle, which is seen as one of the tenets of OO.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한 인수가 이러한 통과 게터 / 세터 쌍의 다른 가정 된 장점에도 적용됩니다. 나중에 설정중인 값을 변경하기로 결정하면 계약을 위반하게됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파생 클래스에서 기본 기능을 재정의하면 몇 가지 무해한 수정 (예 : 로깅 또는 기타 관찰 할 수없는 동작)을 넘어 서면 기본 클래스의 계약을 위반하게됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 OO의 신조 중 하나로 여겨지는 Liskov Substitutability Principle을 위반하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05f52926063e95fcb6e5b9afd2e3d36583ed0188" translate="yes" xml:space="preserve">
          <source>Those methods are the infamous getter and setter....</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 방법은 악명 높은 게터와 세터입니다 ....&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="09878a7e0e4131a45151cbbe07487842d574b319" translate="yes" xml:space="preserve">
          <source>Understanding a local piece of code at first glance is an important property of good readability that getters and setters tend to break. That is why I try to avoid them when I can, and minimize what they do when I use them.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로컬 코드를 한눈에 이해하는 것은 게터와 세터가 깨지기 쉬운 가독성의 중요한 특성입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇기 때문에 가능한 한 피하는 것을 피하고 사용하면하는 일을 최소화하려고합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0eff2b28e1b8f812b912f6b07b88bbaa84ab213d" translate="yes" xml:space="preserve">
          <source>We use getters and setters:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 getter와 setter를 사용합니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cdeb7802b982ac4d4c3fa7153f628c2667c933a" translate="yes" xml:space="preserve">
          <source>We'd end up with something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 다음과 같은 결과를 얻었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10fa626645112c1ff717613b8f6c9dd7afc7b203" translate="yes" xml:space="preserve">
          <source>Well i just want to add that even if sometimes they are necessary for the encapsulation and security of your variables/objects, if we want to code a real Object Oriented Program, then we need to &lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;STOP OVERUSING THE ACCESSORS&lt;/a&gt;&lt;/strong&gt;, cause sometimes we depend a lot on them when is not really necessary and that makes almost the same as if we put the variables public.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 때로는 변수 / 객체의 캡슐화 및 보안에 필요한 경우에도 실제 객체 지향 프로그램을 코딩하려는 경우 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-09-2003/jw-0905-toolbox.html?page=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;액세서리 오버 스톱&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중지&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 해야하며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때로는 우리가 많이 의존해야합니다. 실제로 필요하지 않을 때 변수를 공개하는 것과 거의 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944804080828b744e35ec9aff8cde845d88d15f4" translate="yes" xml:space="preserve">
          <source>Well, you wouldn't expect that to work, right?
You want there to be some kind of sanity check. And worse, what if I never specified the maximum capacity? Oh dear, we have a problem.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 당신은 작동하지 않을 것입니다, 그렇죠? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은 어떤 종류의 위생 검사를 원합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 더 이상 최대 용량을 지정하지 않으면 어떻게됩니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오, 문제가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26aac9603bf87fbcf6a374fcbcc4557be0d4afa4" translate="yes" xml:space="preserve">
          <source>What happens when I do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 할 때 어떻게됩니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="64e4e54e2b623a26f20e0a947aca9d4d41d5f2ff" translate="yes" xml:space="preserve">
          <source>What's the advantage of using getters and setters - that only get and set - instead of simply using public fields for those variables?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;변수에 공용 필드를 사용하는 대신 getter 및 setter를 사용하면 얻을 수있는 장점은 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc1451039d4e3d9bf5c818e53a8cb441a696e201" translate="yes" xml:space="preserve">
          <source>When you realize you need to do more than just set and get the value, you can just make the field private, which will instantly tell you where you've directly accessed it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단순히 값을 설정하고 얻는 것 이상의 일을해야한다는 것을 깨닫게되면 필드를 비공개로 설정하면 바로 액세스 한 위치를 즉시 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b9c2e122eb7bcbff9d3e55249a64348b7c398a2" translate="yes" xml:space="preserve">
          <source>When you write classes, you are always encouraged to make as many as possible of your instance variables private and add getter and setter methods accordingly. This is because there are several times when you may not want to let users change certain variables within your classes. For example, if you have a private static method that tracks the number of instances created for a specific class, you don't want a user to modify that counter using code. Only the constructor statement should increment that variable whenever it's called. In this situation, you might create a private instance variable and allow a getter method only for the counter variable, which means users are able to retrieve the current value only by using the getter method, and they won't be able to set new values using the setter method. Creating a getter without a setter is a simple way of making certain variables in your class read-only.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클래스를 작성할 때는 항상 가능한 많은 인스턴스 변수를 전용으로 설정하고 그에 따라 getter 및 setter 메소드를 추가하는 것이 좋습니다. 사용자가 클래스 내에서 특정 변수를 변경하지 못하게하려는 경우가 있기 때문입니다. 예를 들어 특정 클래스에 대해 생성 된 인스턴스 수를 추적하는 전용 정적 메서드가있는 경우 사용자가 코드를 사용하여 해당 카운터를 수정하지 못하게합니다. 생성자 명령문 만 호출 될 때마다 해당 변수를 증가시켜야합니다. 이 경우 개인 인스턴스 변수를 작성하고 카운터 변수에 대해서만 getter 메소드를 허용 할 수 있습니다. 즉, 사용자는 getter 메소드를 사용해야 만 현재 값을 검색 할 수 있으며 새 값을 설정할 수 없습니다. 세터 방법을 사용합니다.setter없이 getter를 작성하는 것은 클래스의 특정 변수를 읽기 전용으로 만드는 간단한 방법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d347fb8867285cc6a44cfd1b9af0e1b9e8d0d52" translate="yes" xml:space="preserve">
          <source>Whereas the former takes a lot less boilerplate code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전자는 상용구 코드가 훨씬 적습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c5b5b0a202322fa3613116e9cbb7a5bf916b32a2" translate="yes" xml:space="preserve">
          <source>Why use getters and setters/accessors</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;게터와 세터 / 액세서를 사용하는 이유&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a23c4ec681b338f0e1fb882b204499718bf7417d" translate="yes" xml:space="preserve">
          <source>With 10 million cycles, the times are almost the same.
Here are 100 thousand (0.1 million) cycles:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;천만 사이클로 시간은 거의 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10 만 사이클은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e79ce24276092380db82c3f8e4404e6712bb5095" translate="yes" xml:space="preserve">
          <source>You can change the value being set - this is an absolute nightmare when the caller passes you a value that they [shock horror] want you to store AS IS.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;설정되는 값을 변경할 수 있습니다. 이것은 발신자가 당신에게 [쇼크 호러]가 당신이있는 그대로 저장하기를 원하는 값을 전달할 때의 악몽입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8c50aac8fd19a1ea4829de498fc35d71feadd5e" translate="yes" xml:space="preserve">
          <source>You can hide the internal representation - fantastic, so you're making sure that all these operations are symmetrical right?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부 표현을 숨길 수 있습니다-환상적이므로 모든 작업이 대칭인지 확인하고 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d6a0b7af8d1a9e87f51afd2f0f83ec48ca965c9" translate="yes" xml:space="preserve">
          <source>You may find more about them in Section 3.5 of &lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;Elegant Objects&lt;/a&gt; (my book about object-oriented programming).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://www.yegor256.com/elegant-objects.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Elegant Objects의&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 3.5 절 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(객체 지향 프로그래밍에 관한 저서) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 더 많은 것을 찾을 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20973387eacad480489a6f5295307c1dee98b593" translate="yes" xml:space="preserve">
          <source>You see, the getter is (almost) always a bit faster. Then I tried with different numbers of cycles. Instead of 1 million, I used 10 million and 0.1 million.
The results:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알다시피, 게터는 (거의) 항상 조금 더 빠릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 다른 횟수의 사이클로 시도했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;백만 대신에 나는 천만 및 0.1만을 사용했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a53b89844949d31aba6d3481e30d7696c0678c0c" translate="yes" xml:space="preserve">
          <source>You should use getters and setters when:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음과 같은 경우 getter 및 setter를 사용해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8e50d4342310f2eace5776eb8cfc9f9aa9776c1a" translate="yes" xml:space="preserve">
          <source>You're dealing with something that is conceptually an attribute, but:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개념적으로 속성이있는 것을 다루고 있지만,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34fca68fe5cf9480f0a80d7c0c498c348f56c7dd" translate="yes" xml:space="preserve">
          <source>You've insulated your public interface from changes under the sheets - if you were designing an interface and weren't sure whether direct access to something was OK, then you should have kept designing.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시트 아래의 변경 사항으로부터 공용 인터페이스를 분리했습니다. 인터페이스를 디자인하고 있고 무언가에 직접 액세스 할 수 있는지 확실하지 않은 경우 계속 디자인해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ceeaa00b6851469e15bf3447e9cd44a83c071a4" translate="yes" xml:space="preserve">
          <source>Your language doesn't have properties (or some similar mechanism, like Tcl's variable traces), or</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언어에 속성 (또는 Tcl의 변수 추적과 같은 유사한 메커니즘)이 없거나&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5abc216f8d207459eff730de712d1ae80e9f4266" translate="yes" xml:space="preserve">
          <source>Your language's (or sometimes your framework's) idiomatic conventions encourage getters or setters for this use case.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;귀하의 언어 (또는 경우에 따라 프레임 워크)의 관용적 관습은이 사용 사례에 대해 게터 나 세터를 권장합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a0520484ec8d35c906b8b68216ce4e15364da56" translate="yes" xml:space="preserve">
          <source>Your language's property support isn't sufficient for this use case, or</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;귀하의 언어 속성 지원이이 사용 사례에 충분하지 않거나&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="25eba86acee0fb5d6e89e75ccf0a09f1599a6c92" translate="yes" xml:space="preserve">
          <source>better;</source>
          <target state="translated">better;</target>
        </trans-unit>
        <trans-unit id="5f8adcfcb2808cbefe8948076116555c4b76f193" translate="yes" xml:space="preserve">
          <source>faster.</source>
          <target state="translated">faster.</target>
        </trans-unit>
        <trans-unit id="cac0e0595d1759f6424ad536496e3c73b57e1223" translate="yes" xml:space="preserve">
          <source>for members you have only one access specification for both setting and getting</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;회원의 경우 설정 및 가져 오기에 대한 하나의 액세스 사양 만 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b648b79089ac12bd90bd3cb58b4439f26f462e08" translate="yes" xml:space="preserve">
          <source>for reusability</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;재사용 성&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4618d40a12eec35b743c0d33ec26c6ee634eb9ad" translate="yes" xml:space="preserve">
          <source>for setters and getters you can fine tune it and define it separately</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세터와 게터의 경우 세밀하게 조정하고 별도로 정의 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="273bf92b0c3d89955ec505b2f149212919216d10" translate="yes" xml:space="preserve">
          <source>is any worse than:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음보다 더 나쁘다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dbe1b4e53e52bda3546c73c53e0d35d11158f6a4" translate="yes" xml:space="preserve">
          <source>safer; and</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 안전한; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="22d6eb61e8eb4da06f77da4c904a9784e7917342" translate="yes" xml:space="preserve">
          <source>to perform validation in later stages of programming</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그래밍의 후기 단계에서 검증을 수행&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="04489a12bbaa6aebffb61ed2f524424ba8e1147e" translate="yes" xml:space="preserve">
          <source>use</source>
          <target state="translated">use</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
