<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/153724">
    <body>
      <group id="153724">
        <trans-unit id="e8a49d85a6103cb6baf79b15d479c77d9169a1d1" translate="yes" xml:space="preserve">
          <source>(For the sake of this example I am using a custom locale)</source>
          <target state="translated">(为了这个例子,我使用的是一个自定义的地方语言)</target>
        </trans-unit>
        <trans-unit id="ed4ed5de8fc99a9b44b7b7c487086d4fe381be7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://commons.apache.org/proper/commons-math/javadocs/api-3.5/org/apache/commons/math3/util/Precision.html&quot;&gt;Precision&lt;/a&gt; from Apache Commons Math</source>
          <target state="translated">Apache Commons Math的&lt;a href=&quot;http://commons.apache.org/proper/commons-math/javadocs/api-3.5/org/apache/commons/math3/util/Precision.html&quot;&gt;精度&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7998fa1328b8e99c3576358b030ec1a142c01696" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html#setRoundingMode%28java.math.RoundingMode%29&quot;&gt;DecimalFormat#setRoundingMode()&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html#setRoundingMode%28java.math.RoundingMode%29&quot;&gt;DecimalFormat#setRoundingMode()&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="53a7333b9280765dec1f386291ee2f3947c81ee4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dst.lbl.gov/ACSSoftware/colt/api/cern/jet/math/Functions.html&quot;&gt;Functions&lt;/a&gt; from Colt</source>
          <target state="translated">Colt的&lt;a href=&quot;http://dst.lbl.gov/ACSSoftware/colt/api/cern/jet/math/Functions.html&quot;&gt;功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfa9b4d2dc598552a40ec1b3f02b5d19029d0e0b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weka.sourceforge.net/doc.stable/weka/core/Utils.html#roundDouble(double,%20int)&quot;&gt;Utils&lt;/a&gt; from Weka</source>
          <target state="translated">来自Weka的&lt;a href=&quot;http://weka.sourceforge.net/doc.stable/weka/core/Utils.html#roundDouble(double,%20int)&quot;&gt;实用程序&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fb863e79c1c6d68f78e5f1b9fde3ac6c54c6224" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer:&lt;/em&gt; I am involved in the decimal4j project.</source>
          <target state="translated">&lt;em&gt;免责声明：&lt;/em&gt;我参与了October4j项目。</target>
        </trans-unit>
        <trans-unit id="1d8935fb73cb1285f8855582c2d416ad977d155a" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;A similar but fast and garbage-free method is provided by the &lt;code&gt;DoubleRounder&lt;/code&gt; utility in the decimal4j library:&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;DoubleRounder&lt;/code&gt; 实用程序在decimal4j库中提供了一种类似但快速且无垃圾的方法：&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="bcb15e3bc01228fddc8330537892be1f39a86a2d" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;However if you &lt;em&gt;do&lt;/em&gt; want to round the double value and get a &lt;code&gt;double&lt;/code&gt; value result, you can use &lt;code&gt;org.apache.commons.math3.util.Precision.round(..)&lt;/code&gt; as mentioned above. The implementation uses &lt;code&gt;BigDecimal&lt;/code&gt;, is slow and creates garbage.&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;但是，如果您想舍入双精度值并获得 &lt;code&gt;double&lt;/code&gt; 值结果，则可以使用上述的 &lt;code&gt;org.apache.commons.math3.util.Precision.round(..)&lt;/code&gt; 。&lt;/s&gt; &lt;s&gt;实现使用 &lt;code&gt;BigDecimal&lt;/code&gt; ，速度很慢，并且会创建垃圾。&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="7c52a5b8d2821b520eb72f81700edec9d526d45b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; To address some comments below I redid the modulus part of the test loop using &lt;code&gt;BigDecimal&lt;/code&gt; and &lt;code&gt;new MathContext(16)&lt;/code&gt; for the modulus operation as follows:</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;为了解决下面的一些评论，我使用 &lt;code&gt;BigDecimal&lt;/code&gt; 和 &lt;code&gt;new MathContext(16)&lt;/code&gt; 测试循环的模数部分，用于模数运算，如下所示：</target>
        </trans-unit>
        <trans-unit id="7fb87470f7539a26dec74a1340d032e54806e041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: The original answer does not address the accuracy of the double values. That is fine if you don't care much whether it rounds up or down. But if you want accurate rounding, then you need to take the expected accuracy of the values into account. Floating point values have a binary representation internally. That means that a value like 2.7735 does not actually have that exact value internally. It can be slightly larger or slightly smaller. If the internal value is slightly smaller, then it will not round up to 2.7740. To remedy that situation, you need to be aware of the accuracy of the values that you are working with, and add or subtract that value before rounding. For example, when you know that your values are accurate up to 6 digits, then to round half-way values up, add that accuracy to the value:</source>
          <target state="translated">&lt;strong&gt;编辑&lt;/strong&gt; ：原始答案未解决双精度值的准确性。 如果您不在乎它是向上还是向下，那很好。 但是，如果要精确舍入，则需要考虑值的预期准确性。 浮点值在内部具有二进制表示形式。 这意味着像2.7735这样的值实际上在内部没有该确切值。 它可以稍大或略小。 如果内部值稍小，则不会舍入到2.7740。 为了解决这种情况，您需要了解所使用的值的准确性，并在舍入之前添加或减去该值。 例如，当您知道自己的值在6位数字之内是正确的，然后将其四舍五入到该中间值时，将该精度加到该值上：</target>
        </trans-unit>
        <trans-unit id="a60e913b8822dda4ef9fd9c78b0a185910e84830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Exponential notation&lt;/strong&gt;: Start using exponential notation after a certain threshold</source>
          <target state="translated">&lt;strong&gt;指数表示法&lt;/strong&gt; ：在特定阈值之后开始使用指数表示法</target>
        </trans-unit>
        <trans-unit id="a2d53d29974214019ec09861ae4032c14fdc83c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Formatting&lt;/strong&gt;: Easily format a double to string with a certain number of decimal places</source>
          <target state="translated">&lt;strong&gt;格式化&lt;/strong&gt; ：轻松地将双精度格式转换为具有一定小数位数的字符串</target>
        </trans-unit>
        <trans-unit id="58de58c69dedbe6a21ddd94f8c66201ab80636cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here is the class&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;这是课程&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="f2375ef9b1da9276d6fafcbe53edbf50d1385c98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locale&lt;/strong&gt;: Format and parse using the default locale</source>
          <target state="translated">&lt;strong&gt;语言环境&lt;/strong&gt; ：使用默认语言环境设置格式和解析</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d418a1cc97d1d278ab2ef8e789111916297e4ed2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parsing&lt;/strong&gt;: Parse the formatted value back to double</source>
          <target state="translated">&lt;strong&gt;解析&lt;/strong&gt; ：将格式化的值解析回两倍</target>
        </trans-unit>
        <trans-unit id="29854fdb1978b4df4571fc65d5e6c439cb8fcf00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
As @iaforek pointed out DoubleRounder sometimes returns counterintuitive results. The reason is that it performs mathematically correct rounding. For instance &lt;code&gt;DoubleRounder.round(256.025d, 2)&lt;/code&gt; will be rounded down to 256.02 because the double value represented as 256.025d is somewhat smaller than the rational value 256.025 and hence will be rounded down.</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;正如@iaforek指出，DoubleRounder有时会返回违反直觉的结果。 原因是它执行数学上正确的舍入。 例如 &lt;code&gt;DoubleRounder.round(256.025d, 2)&lt;/code&gt; 将向下舍入为256.02，因为表示为256.025d的double值比有理值256.025小一些，因此将被舍入。</target>
        </trans-unit>
        <trans-unit id="122766c56bde93766b9ec54013195dd2dfaa1889" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage is pretty simple&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;用法很简单&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="42eeddaab3e1f8e5c463997d349d4d2b0a53f40e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;demo online.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在线演示。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="671c674354203f9a4adc8c5cd6e5971141e115c1" translate="yes" xml:space="preserve">
          <source>@Milhous: the decimal format for rounding is excellent:</source>
          <target state="translated">@Milhous:四舍五入的小数形式很好。</target>
        </trans-unit>
        <trans-unit id="c8fdc6d7e15991afe1a080edeebb5f49f84a57c7" translate="yes" xml:space="preserve">
          <source>A succinct solution:</source>
          <target state="translated">简明扼要的解决方案。</target>
        </trans-unit>
        <trans-unit id="9313715a06c284b35431a62be6a9f8f0eb4d5b6f" translate="yes" xml:space="preserve">
          <source>Another method is to use the &lt;code&gt;DecimalFormatter&lt;/code&gt;:</source>
          <target state="translated">另一种方法是使用 &lt;code&gt;DecimalFormatter&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bce8fdd56ec70c0d3e4427caceeb6f9f5aae12ea" translate="yes" xml:space="preserve">
          <source>Any decimal value is rounded down to the next integer. This method returns a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">任何十进制值都将四舍五入到下一个整数。 此方法返回 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d44ba4904869b3958c9b3d68bb073eb1ac2d55d" translate="yes" xml:space="preserve">
          <source>Any decimal value is rounded up to the next integer. It goes to the &lt;strong&gt;ceil&lt;/strong&gt;ing. This method returns a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">任何十进制值都将四舍五入到下一个整数。 到&lt;strong&gt;天花板&lt;/strong&gt; 。 此方法返回 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae16d68e49ec37da78f538086dcaa776281079c7" translate="yes" xml:space="preserve">
          <source>Apache Commons Mathematics Library homepage is: &lt;a href=&quot;http://commons.apache.org/proper/commons-math/index.html&quot;&gt;http://commons.apache.org/proper/commons-math/index.html&lt;/a&gt;</source>
          <target state="translated">Apache Commons Mathematics Library主页是： &lt;a href=&quot;http://commons.apache.org/proper/commons-math/index.html&quot;&gt;http&lt;/a&gt; : //commons.apache.org/proper/commons-math/index.html</target>
        </trans-unit>
        <trans-unit id="5fc05c32c957ac348eda7d5b925f68f7ab276330" translate="yes" xml:space="preserve">
          <source>As some others have noted, the correct answer is to use either &lt;code&gt;DecimalFormat&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt;. Floating-point doesn't &lt;em&gt;have&lt;/em&gt; decimal places so you cannot possibly round/truncate to a specific number of them in the first place. You have to work in a decimal radix, and that is what those two classes do.</source>
          <target state="translated">正如其他一些人指出的那样，正确的答案是使用 &lt;code&gt;DecimalFormat&lt;/code&gt; 或 &lt;code&gt;BigDecimal&lt;/code&gt; 。 浮点数没有小数位，因此您可能无法在第一位四舍五入/截断到特定数量的小数。 您必须使用十进制基数，这就是这两个类的作用。</target>
        </trans-unit>
        <trans-unit id="0fbe9b0f26458c36ff995dbad1802eca7ee9945e" translate="yes" xml:space="preserve">
          <source>As stated above, this rounds to the nearest whole number. &lt;code&gt;.5&lt;/code&gt; decimals round up.  This method returns an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">如上所述，此舍入为最接近的整数。 &lt;code&gt;.5&lt;/code&gt; 小数点后四舍五入。 此方法返回一个 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3901688f444dfec670680bd1f513052ad73f1001" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;value&lt;/code&gt; is a &lt;code&gt;double&lt;/code&gt;, you can do:</source>
          <target state="translated">假设 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;double&lt;/code&gt; ，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a80629c6bd6b08b0261959b55e21104540fff404" translate="yes" xml:space="preserve">
          <source>BigDecimal#setScale()</source>
          <target state="translated">BigDecimal#setScale()</target>
        </trans-unit>
        <trans-unit id="094a821a78159fabbf8dbd16217b6f3bc113e117" translate="yes" xml:space="preserve">
          <source>DecimalFormat is the best ways to output, but I don't prefer it. I always do this all the time, because it return the double value. So I can use it  more than just output.</source>
          <target state="translated">DecimalFormat是最好的输出方式,但我不喜欢这样做。我一直都是这样做的,因为它返回的是双值。所以我可以用它来输出更多的东西。</target>
        </trans-unit>
        <trans-unit id="4e749a054ad6b4b4e6d62f427b584962334f73f0" translate="yes" xml:space="preserve">
          <source>Defining this values:</source>
          <target state="translated">定义这个值。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2f65f8630426c4ed4fd9dd19e4214fc15682ef93" translate="yes" xml:space="preserve">
          <source>For those reasons and everything mentioned above in this post I &lt;strong&gt;cannot recommend to use DoubleRounder&lt;/strong&gt;.</source>
          <target state="translated">由于这些原因以及本文中上面提到的所有内容，我&lt;strong&gt;不建议使用DoubleRounder&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9cff78d444a4efe099a9b81b60b609cae30be12" translate="yes" xml:space="preserve">
          <source>Here is a suggestion of what libraries you can use if you want &lt;code&gt;double&lt;/code&gt; as a result. I wouldn't recommend it for string conversion, though, as double may not be able to represent what you want exactly (see e.g. &lt;a href=&quot;https://stackoverflow.com/q/3730019/2032064&quot;&gt;here&lt;/a&gt;):</source>
          <target state="translated">如果您希望将结果 &lt;code&gt;double&lt;/code&gt; ，这是可以使用哪些库的建议。 不过，我不建议将其用于字符串转换，因为double可能无法准确代表您想要的内容（请参见例如&lt;a href=&quot;https://stackoverflow.com/q/3730019/2032064&quot;&gt;此处&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="ffff53110ebaf8268e4bbf3333bddd4b375e23c7" translate="yes" xml:space="preserve">
          <source>Here is a summary of what you can use if you want the result as String:</source>
          <target state="translated">如果你希望结果为String,下面是一个总结。</target>
        </trans-unit>
        <trans-unit id="22686526469f672eb6453158ae54ec7220556a6a" translate="yes" xml:space="preserve">
          <source>How to round a number in Java</source>
          <target state="translated">如何在Java中对一个数字进行四舍五入</target>
        </trans-unit>
        <trans-unit id="0c6ad6147061b3e8fb0843e40c1811ee0019e7c2" translate="yes" xml:space="preserve">
          <source>How to round a number to n decimal places in Java</source>
          <target state="translated">如何在Java中将一个数字四舍五入到n位小数点后的方法</target>
        </trans-unit>
        <trans-unit id="ad93497a1aac8e144a5e5287aeb14ded45f15904" translate="yes" xml:space="preserve">
          <source>However as you can see this uses half-even rounding. That is it will round down if the previous digit is even. What I'd like is this:</source>
          <target state="translated">但是,正如你所看到的,这是用半数四舍五入。也就是说,如果前面的数字是偶数,它就会四舍五入。我想要的是这样的。</target>
        </trans-unit>
        <trans-unit id="bb7bde9d84a579e8508019fb3c56978e57a1f52b" translate="yes" xml:space="preserve">
          <source>Hypothetical: you have to implement a rounding mechanism into a GUI
program. To alter the accuracy / precision of a result output simply 
change the caret format (i.e. within the brackets).  So that:</source>
          <target state="translated">假设:你必须在GUI程序中实现一个四舍五入机制。要改变一个结果输出的精度精度,只需改变括号内的括号格式即可。这样一来。</target>
        </trans-unit>
        <trans-unit id="1016160673ec1d014154d12b2f34f71ebbeb09e3" translate="yes" xml:space="preserve">
          <source>I agree with the chosen answer to use &lt;code&gt;DecimalFormat&lt;/code&gt; --- or alternatively &lt;code&gt;BigDecimal&lt;/code&gt;.</source>
          <target state="translated">我同意选择使用 &lt;code&gt;DecimalFormat&lt;/code&gt; ---或 &lt;code&gt;BigDecimal&lt;/code&gt; 的答案。</target>
        </trans-unit>
        <trans-unit id="bc070f27d4b62a053029e95fe0fc4eccafac317f" translate="yes" xml:space="preserve">
          <source>I also would like only significant digits to be displayed - i.e. there should not be any trailing zeroes.</source>
          <target state="translated">我还希望只显示重要的数字----即不应该有任何尾数零。</target>
        </trans-unit>
        <trans-unit id="2a0870f41697a3968262011df9000f982fdc1aad" translate="yes" xml:space="preserve">
          <source>I am posting the following code as a counter-example to all the answers in this thread and indeed all over StackOverflow (and elsewhere) that recommend multiplication followed by truncation followed by division. It is incumbent on advocates of this technique to explain why the following code produces the wrong output in over 92% of cases.</source>
          <target state="translated">我贴出下面的代码,是为了反证这个线程中的所有答案,事实上,StackOverflow(和其他地方)上的所有答案都建议先乘法后截断再除法。这种技术的倡导者有责任解释为什么下面的代码在92%以上的情况下都会产生错误的输出。</target>
        </trans-unit>
        <trans-unit id="8e58c53c32829f245fe2cfeb49af6710173697c7" translate="yes" xml:space="preserve">
          <source>I came here just wanting a simple answer on how to round a number. This is a supplemental answer to provide that.</source>
          <target state="translated">我来到这里只是想得到一个简单的答案,如何将一个数字四舍五入。这是一个补充的答案,以提供这个问题。</target>
        </trans-unit>
        <trans-unit id="d6649c1b1a83dae75d1d6875241da65520e90d32" translate="yes" xml:space="preserve">
          <source>I do use BigDecimal for calculations, but bear in mind it is dependent on the size of
numbers you're dealing with.  In most of my implementations, I find parsing from double or
integer to Long is sufficient enough for very large number calculations.</source>
          <target state="translated">我确实使用BigDecimal进行计算,但请记住,这取决于你所处理的数字的大小。在我的大多数实现中,我发现从双倍或整数解析到Long已经足够用于非常大的数字计算了。</target>
        </trans-unit>
        <trans-unit id="f822a20fe4e34c783365fa306c4110b15beea656" translate="yes" xml:space="preserve">
          <source>I know one method of doing this is to use the &lt;code&gt;String.format&lt;/code&gt; method:</source>
          <target state="translated">我知道这样做的一种方法是使用 &lt;code&gt;String.format&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="a51fee6efb767fb1a5d5c4e6df30cfa04282d4e6" translate="yes" xml:space="preserve">
          <source>I would add that this method is very good at providing an actual
numeric, rounding mechanism - not only visually, but also when processing.</source>
          <target state="translated">我想补充的是,这种方法在提供实际的数字、四舍五入机制方面做得很好--不仅是视觉上的,在处理时也是如此。</target>
        </trans-unit>
        <trans-unit id="8bb95432f9793b9c54b240628c5e9e0d865f552e" translate="yes" xml:space="preserve">
          <source>If you need large decimal places value, you can use BigDecimal instead. Anyways &lt;code&gt;.0&lt;/code&gt; is important. Without it the rounding of 0.33333d5 return 0.33333 and only 9 digits are allows. The second function without &lt;code&gt;.0&lt;/code&gt; has problems with 0.30000 return 0.30000000000000004.</source>
          <target state="translated">如果需要较大的小数位值，则可以改用BigDecimal。 无论如何， &lt;code&gt;.0&lt;/code&gt; 很重要。 如果没有它，则将0.33333d5的舍入返回0.33333，并且仅允许9位数字。 不带 &lt;code&gt;.0&lt;/code&gt; 的第二个函数的问题是0.30000返回0.30000000000000004。</target>
        </trans-unit>
        <trans-unit id="ca9cee5995bf1fbb05e538266b5c505b1255e58f" translate="yes" xml:space="preserve">
          <source>If you really want decimal numbers for calculation (and not only for output), do not use a binary-based floating point format like double.</source>
          <target state="translated">如果你真的想用十进制数进行计算(而且不仅仅是输出),就不要用二进制的浮点格式,比如说双倍。</target>
        </trans-unit>
        <trans-unit id="59b3beef6db6e180d34521c7214e045c4d7fe959" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;DecimalFormat&lt;/code&gt; to convert &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;String&lt;/code&gt;, it's very straightforward:</source>
          <target state="translated">如果您使用 &lt;code&gt;DecimalFormat&lt;/code&gt; 将 &lt;code&gt;double&lt;/code&gt; 转换为 &lt;code&gt;String&lt;/code&gt; ，则非常简单：</target>
        </trans-unit>
        <trans-unit id="3993562e5e396270d29574d3f5aa171ef954e991" translate="yes" xml:space="preserve">
          <source>If you're using a technology that has a minimal JDK.  Here's a way without any Java libs:</source>
          <target state="translated">如果你使用的是有最小的JDK的技术。这里有一个没有任何Java libs的方法。</target>
        </trans-unit>
        <trans-unit id="813ed4d70e8d6abf3fa17aecb7f432ac6c12f2b0" translate="yes" xml:space="preserve">
          <source>In fact, I've
recently used parsed-to-Long to get accurate representations (as opposed to hex results)
in a GUI for numbers as big as ################################# characters (as an 
example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef69761016065df342a41f1ba61cbdee1af2e52f" translate="yes" xml:space="preserve">
          <source>In general, rounding is done by scaling: &lt;code&gt;round(num / p) * p&lt;/code&gt;</source>
          <target state="translated">通常，舍入是通过缩放来完成的： &lt;code&gt;round(num / p) * p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a22628f448e48449b4cbd2dcc834bd641e538d25" translate="yes" xml:space="preserve">
          <source>Just in case someone still needs help with this. This solution works perfectly for me.</source>
          <target state="translated">以防万一有人还需要帮助。这个解决方案对我来说非常有效。</target>
        </trans-unit>
        <trans-unit id="57c2383f2b5e00a3b3b4959445e4ce953597c3f8" translate="yes" xml:space="preserve">
          <source>Keep in mind that String.format() and DecimalFormat produce string using default Locale. So they may write formatted number with dot or comma as a separator between integer and decimal parts. To make sure that rounded String is in the format you want use java.text.NumberFormat as so:</source>
          <target state="translated">请记住,String.format()和DecimalFormat使用默认的Locale生成字符串。因此,它们可以在整数和小数部分之间用点或逗号作为分隔符来书写格式化的数字。为了确保四舍五入的String是你想要的格式,请使用java.text.NumberFormat如是。</target>
        </trans-unit>
        <trans-unit id="699a1ef8099139c81268f5f405b8f0f4c46b2e96" translate="yes" xml:space="preserve">
          <source>Numbers are rounded to the nearest whole number. A &lt;code&gt;.5&lt;/code&gt; value is rounded up. If you need different rounding behavior than that, you can use one of the other &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html&quot;&gt;Math&lt;/a&gt; functions. See the comparison below.</source>
          <target state="translated">数字四舍五入到最接近的整数。 &lt;code&gt;.5&lt;/code&gt; 值四舍五入。 如果您需要的舍入行为与此不同，则可以使用其他&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html&quot;&gt;Math&lt;/a&gt;函数之一。 请参阅下面的比较。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="49f49b27074cf3f26b0c8875804028f46bf61ac6" translate="yes" xml:space="preserve">
          <source>Output of this program:</source>
          <target state="translated">这个程序的输出。</target>
        </trans-unit>
        <trans-unit id="5039f5432d56d1e13f80715db5aca88a2c6282b2" translate="yes" xml:space="preserve">
          <source>Please read &lt;strong&gt;Update&lt;/strong&gt; below first!</source>
          <target state="translated">请先阅读下面的&lt;strong&gt;更新&lt;/strong&gt; ！</target>
        </trans-unit>
        <trans-unit id="0fbdea6269aecef5fa9fdaf328268cbf751985ec" translate="yes" xml:space="preserve">
          <source>Real's Java How-to &lt;a href=&quot;http://www.rgagnon.com/javadetails/java-0016.html&quot;&gt;posts&lt;/a&gt; this solution, which is also compatible for versions before Java 1.6.</source>
          <target state="translated">Real的Java How-to &lt;a href=&quot;http://www.rgagnon.com/javadetails/java-0016.html&quot;&gt;发布了&lt;/a&gt;此解决方案，该解决方案也与Java 1.6之前的版本兼容。</target>
        </trans-unit>
        <trans-unit id="617736e6e1429ee61ad9451ae4d7b278e27f4aab" translate="yes" xml:space="preserve">
          <source>Refer: &lt;a href=&quot;http://www.javabeat.net/precise-rounding-of-decimals-using-rounding-mode-enumeration/&quot;&gt;http://www.javabeat.net/precise-rounding-of-decimals-using-rounding-mode-enumeration/&lt;/a&gt;</source>
          <target state="translated">请参阅： &lt;a href=&quot;http://www.javabeat.net/precise-rounding-of-decimals-using-rounding-mode-enumeration/&quot;&gt;http&lt;/a&gt; : //www.javabeat.net/precise-rounding-of-decimals-using-rounding-mode-enumeration/</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="9d7d4e92c686c95f74062fdb56c346325d223bac" translate="yes" xml:space="preserve">
          <source>Rounding mode to round towards &quot;nearest neighbor&quot; unless both
  neighbors are equidistant, in which case round up.</source>
          <target state="translated">四舍五入模式向 &quot;最近的邻居 &quot;进位,除非两个邻居距离相等,在这种情况下,四舍五入。</target>
        </trans-unit>
        <trans-unit id="4685444141d2c8a4bc01b6c70d4c7e32098bb041" translate="yes" xml:space="preserve">
          <source>Sample program:</source>
          <target state="translated">样本方案。</target>
        </trans-unit>
        <trans-unit id="b3aa1e5752237278e1e5d2196cfa403d181e09b1" translate="yes" xml:space="preserve">
          <source>See
&lt;a href=&quot;https://github.com/tools4j/decimal4j/wiki/DoubleRounder-Utility&quot;&gt;https://github.com/tools4j/decimal4j/wiki/DoubleRounder-Utility&lt;/a&gt;</source>
          <target state="translated">See
&lt;a href=&quot;https://github.com/tools4j/decimal4j/wiki/DoubleRounder-Utility&quot;&gt;https://github.com/tools4j/decimal4j/wiki/DoubleRounder-Utility&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7c036e676470a3ae2e2886875d9e189ba8ad678" translate="yes" xml:space="preserve">
          <source>See also, &lt;a href=&quot;https://stackoverflow.com/a/22186845/212950&quot;&gt;https://stackoverflow.com/a/22186845/212950&lt;/a&gt;
Thanks to &lt;a href=&quot;https://stackoverflow.com/users/2984077/jpdymond&quot;&gt;jpdymond&lt;/a&gt; for offering this.</source>
          <target state="translated">另请参见， &lt;a href=&quot;https://stackoverflow.com/a/22186845/212950&quot;&gt;https:&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/users/2984077/jpdymond&quot;&gt;//stackoverflow.com/a/22186845/212950&lt;/a&gt;感谢jpdymond提供此功能。</target>
        </trans-unit>
        <trans-unit id="9dfb1a168c168173dc39ee347135b88e4d107763" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/util/Precision.html&quot;&gt;http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/util/Precision.html&lt;/a&gt;</source>
          <target state="translated">请参阅： &lt;a href=&quot;http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/util/Precision.html&quot;&gt;http&lt;/a&gt; : //commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/util/Precision.html</target>
        </trans-unit>
        <trans-unit id="435c6c0482cfd1a18690747fc07ef53adb8ab354" translate="yes" xml:space="preserve">
          <source>Since I found no complete answer on this theme I've put together a class that should handle this properly, with support for:</source>
          <target state="translated">由于我在这个主题上没有找到完整的答案,所以我整理了一个班级,应该可以妥善处理,支持。</target>
        </trans-unit>
        <trans-unit id="b220eddc131b29cf6a60e1ce86ca5b45dd6b5e0a" translate="yes" xml:space="preserve">
          <source>So after reading most of the answers, I realized most of them won't be precise, in fact using &lt;code&gt;BigDecimal&lt;/code&gt; seems like the best choice, but if you don't understand how the &lt;code&gt;RoundingMode&lt;/code&gt; works, you will inevitable lose precision. I figured this out when working with big numbers in a project and thought it could help others having trouble rounding numbers. For example.</source>
          <target state="translated">因此，在阅读了大多数答案之后，我意识到其中大多数都不是精确的，实际上，使用 &lt;code&gt;BigDecimal&lt;/code&gt; 似乎是最佳选择，但是如果您不了解 &lt;code&gt;RoundingMode&lt;/code&gt; 的工作方式，那么不可避免地会失去精度。 当在项目中处理大量数字时，我想出了这一点，并认为它可以帮助其他难以四舍五入的数字。 例如。</target>
        </trans-unit>
        <trans-unit id="2f076fa72b0c1e4b496f0dbaae174ed2d5e32d33" translate="yes" xml:space="preserve">
          <source>So essentially, the beauty of DecimalFormat is that it simultaneously handles the string 
appearance - as well as the level of rounding precision set. Ergo: you 
get two benefits for the price of one code implementation. ;)</source>
          <target state="translated">因此,从本质上说,DecimalFormat的好处在于它可以同时处理字符串的外观--以及四舍五入的精度设置。也就是说:用一个代码实现的代价换来两个好处。)</target>
        </trans-unit>
        <trans-unit id="82437e73582996ab5e0733d171ad0854ec6d9a4a" translate="yes" xml:space="preserve">
          <source>So knowing this, we realized that we won't be getting an exact rounding, unless we want to round towards &lt;em&gt;nearest neighbor&lt;/em&gt;. So, to accomplish an adequate round, we would need to loop from the &lt;code&gt;n-1&lt;/code&gt; decimal towards the desired decimals digits. For example.</source>
          <target state="translated">因此，知道了这一点，我们意识到除非获得四舍五入的结果，否则我们将不会获得精确的舍入。 因此，要完成足够的回合，我们需要从 &lt;code&gt;n-1&lt;/code&gt; 个小数到所需的小数位循环。 例如。</target>
        </trans-unit>
        <trans-unit id="e76011ef730e99e46d7bf791668b8fb84e5933c9" translate="yes" xml:space="preserve">
          <source>Suppose you have</source>
          <target state="translated">假设你有</target>
        </trans-unit>
        <trans-unit id="7ae503a3bf24f516aeee7921220b8cdbe935ee51" translate="yes" xml:space="preserve">
          <source>That's for 5 digits precision. The number of zeros indicate the number of decimals.</source>
          <target state="translated">那是指5位数的精度。0的数字表示小数点的个数。</target>
        </trans-unit>
        <trans-unit id="7acafc57906e43b71b12133d9f2dfb8f883f78e0" translate="yes" xml:space="preserve">
          <source>The code snippet below shows how to display n digits.  The trick is to set variable pp to 1 followed by n zeros.  In the example below, variable pp value has 5 zeros, so 5 digits will be displayed.</source>
          <target state="translated">下面的代码片段显示了如何显示n位数字。诀窍是将变量pp设置为1,后面是n个零。在下面的例子中,变量pp值有5个零,所以会显示5个数字。</target>
        </trans-unit>
        <trans-unit id="373c04cbbf15df2e9106189027003077b88b8f74" translate="yes" xml:space="preserve">
          <source>The example is taken from Farenda - &lt;a href=&quot;http://farenda.com/java/java-format-double-2-decimal-places/&quot;&gt;how to convert double to String correctly&lt;/a&gt;.</source>
          <target state="translated">该示例取自Farenda- &lt;a href=&quot;http://farenda.com/java/java-format-double-2-decimal-places/&quot;&gt;如何将double正确转换为String&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dece382c4f59eb72a6bf73e13bf55ea55888ca5" translate="yes" xml:space="preserve">
          <source>The internal implemetation of this method is:</source>
          <target state="translated">这种方法的内部实现是:</target>
        </trans-unit>
        <trans-unit id="9300667e4bcb60e21038f3c40079ee9f4cd03835" translate="yes" xml:space="preserve">
          <source>The most common case is to use &lt;code&gt;Math.round()&lt;/code&gt;.</source>
          <target state="translated">最常见的情况是使用 &lt;code&gt;Math.round()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a216a0d5dcbe57689d80065e9ebb794aa98fbc" translate="yes" xml:space="preserve">
          <source>The problem can be circumvented with a double rounding step to a higher precision first, but it is complicated and I am not going into the details here</source>
          <target state="translated">这个问题可以先用双圆台阶来规避,精度更高,但比较复杂,这里就不细说了。</target>
        </trans-unit>
        <trans-unit id="7328f216ec11f26899cae2e6b580b4aa8c4252ae" translate="yes" xml:space="preserve">
          <source>There are several &lt;code&gt;RoundingMode&lt;/code&gt; enum values to select from, depending upon the behaviour you require.</source>
          <target state="translated">有多个 &lt;code&gt;RoundingMode&lt;/code&gt; 枚举值可供选择，具体取决于您所需的行为。</target>
        </trans-unit>
        <trans-unit id="0b26e32c96a1204ddf3ccb7dc426b7f3d0b7b39c" translate="yes" xml:space="preserve">
          <source>This behaviour is very similar to that of the &lt;code&gt;BigDecimal(double)&lt;/code&gt; constructor (but not to &lt;code&gt;valueOf(double)&lt;/code&gt; which uses the string constructor).</source>
          <target state="translated">此行为与 &lt;code&gt;BigDecimal(double)&lt;/code&gt; 构造函数的行为非常相似（但与使用字符串构造函数的 &lt;code&gt;valueOf(double)&lt;/code&gt; 不同 ）。</target>
        </trans-unit>
        <trans-unit id="c746dbdfb142c756b65b2088b688baaadef0bbc7" translate="yes" xml:space="preserve">
          <source>This is similar to round in that decimal values round to the closest integer. However, unlike &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;.5&lt;/code&gt; values round to the even integer.  This method returns a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">这类似于舍入，即十进制值舍入到最接近的整数。 但是，与 &lt;code&gt;round&lt;/code&gt; 不同， &lt;code&gt;.5&lt;/code&gt; 值舍入为偶数整数。 此方法返回 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d223d6843a2db01219034bd85a3e6da6b601be0" translate="yes" xml:space="preserve">
          <source>This will end up giving us the expected output, which would be &lt;code&gt;1363.28&lt;/code&gt;.</source>
          <target state="translated">这最终将为我们提供预期的输出，即 &lt;code&gt;1363.28&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d46801e3a502c217ff6b30a9ead20f6fbec0358" translate="yes" xml:space="preserve">
          <source>To achieve this we can use this formatter:</source>
          <target state="translated">为了达到这个目的,我们可以使用这个formatter。</target>
        </trans-unit>
        <trans-unit id="961c59dbdaab1bf2d24f7a2fd7cd91f4c0b41044" translate="yes" xml:space="preserve">
          <source>To round down, subtract the accuracy.</source>
          <target state="translated">要四舍五入,减去准确度。</target>
        </trans-unit>
        <trans-unit id="e3964b71598e17afe6484093e39c4df23d9886bf" translate="yes" xml:space="preserve">
          <source>Try this: org.apache.commons.math3.util.Precision.round(double x, int scale)</source>
          <target state="translated">试试这个:org.apache.commons.math3.utilc.precision.round(double x,int scale)</target>
        </trans-unit>
        <trans-unit id="b662affd2e0c8a96428679db86d38945b478f920" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html#setRoundingMode(java.math.RoundingMode)&quot;&gt;&lt;code&gt;setRoundingMode&lt;/code&gt;&lt;/a&gt;, set the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt; explicitly to handle your issue with the half-even round, then use the format pattern for your required output.</source>
          <target state="translated">使用&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html#setRoundingMode(java.math.RoundingMode)&quot;&gt; &lt;code&gt;setRoundingMode&lt;/code&gt; &lt;/a&gt; ，显式设置&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt;以处理半个半个回合的问题，然后将格式模式用于所需的输出。</target>
        </trans-unit>
        <trans-unit id="c0e450c2393de2a7db451fda526d192cbca7be2d" translate="yes" xml:space="preserve">
          <source>Use this method to get always two decimals:</source>
          <target state="translated">用这个方法可以得到总是两位小数。</target>
        </trans-unit>
        <trans-unit id="7e36f20182475ffc4767765e0732e95521b8ffa3" translate="yes" xml:space="preserve">
          <source>Using the method we can get this results:</source>
          <target state="translated">使用该方法,我们可以得到这样的结果。</target>
        </trans-unit>
        <trans-unit id="0d769aa111bbdba8086e7cbe1f8f6cc06f763e2e" translate="yes" xml:space="preserve">
          <source>What I would like is a method to convert a double to a string which rounds using the half-up method - i.e. if the decimal to be rounded is 5, it always rounds up to the next number. This is the standard method of rounding most people expect in most situations.</source>
          <target state="translated">我想要的是一种将双倍数转换为字符串的方法,这种方法可以使用四舍五入法--即如果要四舍五入的小数是5,它总是四舍五入到下一个数字。这是大多数人在大多数情况下所期望的标准四舍五入方法。</target>
        </trans-unit>
        <trans-unit id="f4ca6a4b5fda776925a7c75f8a573555e85118e7" translate="yes" xml:space="preserve">
          <source>What is the best way to achieve this in Java?</source>
          <target state="translated">在Java中,有什么好的方法可以实现呢?</target>
        </trans-unit>
        <trans-unit id="972b3e0d7501505074925ea900d2a0a54ea9892f" translate="yes" xml:space="preserve">
          <source>Where &lt;em&gt;dp&lt;/em&gt; = decimal place you want,
and &lt;em&gt;value&lt;/em&gt; is a double.</source>
          <target state="translated">其中&lt;em&gt;dp&lt;/em&gt; =您想要的小数位， &lt;em&gt;值&lt;/em&gt;是双&lt;em&gt;精度&lt;/em&gt; &lt;em&gt;值&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="e012bd2854254580514f478d3bb60e50df1d66cc" translate="yes" xml:space="preserve">
          <source>Will output</source>
          <target state="translated">将输出</target>
        </trans-unit>
        <trans-unit id="9768ea29026752e4efa66679ec600186b67ca2b9" translate="yes" xml:space="preserve">
          <source>Will print in English locale (no matter what your locale is):
  0.99
  123.57
  123.00</source>
          <target state="translated">将以英语语言打印(不管你的语言是什么语言):0.99 123.57 123.00</target>
        </trans-unit>
        <trans-unit id="79a86963d5daca82c56ec0af8464032984ecc118" translate="yes" xml:space="preserve">
          <source>You can also use the</source>
          <target state="translated">你也可以使用</target>
        </trans-unit>
        <trans-unit id="189e1d3137395d10986897ccc001e20fc7fceed6" translate="yes" xml:space="preserve">
          <source>You can use BigDecimal</source>
          <target state="translated">你可以使用Big Decimal</target>
        </trans-unit>
        <trans-unit id="50ecf8c03654dc61716c0c90830f5d8e577f1050" translate="yes" xml:space="preserve">
          <source>You can use the DecimalFormat class.</source>
          <target state="translated">你可以使用DecimalFormat类。</target>
        </trans-unit>
        <trans-unit id="33642c0adaf033763fe76d86a33fc50ffaf1b5c5" translate="yes" xml:space="preserve">
          <source>You could use the following utility method-</source>
          <target state="translated">你可以使用以下实用方法--</target>
        </trans-unit>
        <trans-unit id="26da33a818de4f5ab909e5ca811994231d780c96" translate="yes" xml:space="preserve">
          <source>You would expect to get &lt;code&gt;1363.28&lt;/code&gt; as an output, but you will end up with &lt;code&gt;1363.27&lt;/code&gt;, which is not expected, if you don't know what the &lt;code&gt;RoundingMode&lt;/code&gt; is doing. So looking into the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html&quot;&gt;Oracle Docs&lt;/a&gt;, you will find the following description for &lt;code&gt;RoundingMode.HALF_UP&lt;/code&gt;.</source>
          <target state="translated">您可能希望获得 &lt;code&gt;1363.28&lt;/code&gt; 作为输出，但是如果您不知道 &lt;code&gt;RoundingMode&lt;/code&gt; 在做什么，则最终会得到 &lt;code&gt;1363.27&lt;/code&gt; ，这是不期望的。 因此，查看&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/math/RoundingMode.html&quot;&gt;Oracle文档&lt;/a&gt; ，您将找到 &lt;code&gt;RoundingMode.HALF_UP&lt;/code&gt; 的以下描述。</target>
        </trans-unit>
        <trans-unit id="608fe6be9c903d77bfd7cc325c39f618780d9bbd" translate="yes" xml:space="preserve">
          <source>[EDIT: also if the caret format is like so (&quot;#0.############&quot;) and you
enter a decimal, e.g. 3.1415926, for argument's sake, DecimalFormat
does not produce any garbage (e.g. trailing zeroes) and will return:
&lt;code&gt;3.1415926&lt;/code&gt; .. if you're that way inclined. Granted, it's a little verbose
for the liking of some dev's - but hey, it's got a low memory footprint
during processing and is very easy to implement.]</source>
          <target state="translated">[编辑：如果插入符格式也是如此（&amp;ldquo;＃0。#############&amp;rdquo;），并且您输入了一个小数，例如3.1415926，出于参数的考虑，DecimalFormat不会产生任何垃圾（例如尾随零），然后返回： &lt;code&gt;3.1415926&lt;/code&gt; ..如果您这样倾斜。 当然，对于某些开发人员而言，它有点冗长-但是，嘿，它在处理过程中的内存占用量很小，并且非常易于实现。]</target>
        </trans-unit>
        <trans-unit id="613af80c25dfbc9ef75ce605280571b9a518d632" translate="yes" xml:space="preserve">
          <source>ceil</source>
          <target state="translated">ceil</target>
        </trans-unit>
        <trans-unit id="3684c9d3c05e7bee19e2728c6a5b2bbccf0cd9c7" translate="yes" xml:space="preserve">
          <source>floor</source>
          <target state="translated">floor</target>
        </trans-unit>
        <trans-unit id="fe98c8a113255ae1bf3ed0aa0c2eb99f16f74837" translate="yes" xml:space="preserve">
          <source>gives the output:</source>
          <target state="translated">给出输出。</target>
        </trans-unit>
        <trans-unit id="44a75a7c936d7cc53886559df1b48a62ffcd22f0" translate="yes" xml:space="preserve">
          <source>here is my answer:</source>
          <target state="translated">这里是我的答案。</target>
        </trans-unit>
        <trans-unit id="585837f6244e30b72914a3ece74825e0e6f2ad22" translate="yes" xml:space="preserve">
          <source>or without BigDecimal</source>
          <target state="translated">或没有大十进制</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="9486cef00de9ecc8fdbd5e4c991f6d77bd681232" translate="yes" xml:space="preserve">
          <source>returns a &lt;code&gt; String &lt;/code&gt; with the desired output.</source>
          <target state="translated">返回具有所需输出的 &lt;code&gt; String &lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37b8dabf0b7bfae1c2eecb47a6afcd8bc92cc94c" translate="yes" xml:space="preserve">
          <source>returns:</source>
          <target state="translated">returns:</target>
        </trans-unit>
        <trans-unit id="5b8ef7192fe75d3e998925c2a6f950fa3bcbc5ba" translate="yes" xml:space="preserve">
          <source>rint</source>
          <target state="translated">rint</target>
        </trans-unit>
        <trans-unit id="f0590a6dd3663be108ff31f58d16b829a1284be6" translate="yes" xml:space="preserve">
          <source>round</source>
          <target state="translated">round</target>
        </trans-unit>
        <trans-unit id="564403f2736b3be7d078042d1bf5a794320d7993" translate="yes" xml:space="preserve">
          <source>to make sure you have the trailing 0's.</source>
          <target state="translated">以确保你的尾数为0。</target>
        </trans-unit>
        <trans-unit id="b9a4d336269dd6771b71e3ff95ac0f7719854c82" translate="yes" xml:space="preserve">
          <source>which is great, however it always displays numbers with 5 decimal places even if they are not significant:</source>
          <target state="translated">这很好,但是它总是显示小数点后5位的数字,即使这些数字不重要。</target>
        </trans-unit>
        <trans-unit id="9cef970864c306bd005e4f5bb7ea96c9ef80881d" translate="yes" xml:space="preserve">
          <source>will get you a &lt;code&gt;BigDecimal&lt;/code&gt;.  To get the string out of it, just call that &lt;code&gt;BigDecimal&lt;/code&gt;'s &lt;code&gt;toString&lt;/code&gt; method, or the &lt;code&gt;toPlainString&lt;/code&gt; method for Java 5+ for a plain format string.</source>
          <target state="translated">会给你一个 &lt;code&gt;BigDecimal&lt;/code&gt; 。 要从中获取字符串，只需调用该 &lt;code&gt;BigDecimal&lt;/code&gt; 的 &lt;code&gt;toString&lt;/code&gt; 方法，或者为纯格式字符串调用Java 5+的 &lt;code&gt;toPlainString&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a2048b21dbea50e2b999e38777aff3c3b8cc4f92" translate="yes" xml:space="preserve">
          <source>with both solutions &lt;code&gt;d == 9232.13&lt;/code&gt;</source>
          <target state="translated">两种解决方案 &lt;code&gt;d == 9232.13&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57161573ccaca2384e3af81b5e70cf6b6d0bdb20" translate="yes" xml:space="preserve">
          <source>would return as output: &lt;code&gt;0.912385&lt;/code&gt;</source>
          <target state="translated">将作为输出返回： &lt;code&gt;0.912385&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9236983092fe2060263570074f63530563eeb1e2" translate="yes" xml:space="preserve">
          <source>would return as output: &lt;code&gt;0.91239&lt;/code&gt;</source>
          <target state="translated">将作为输出返回： &lt;code&gt;0.91239&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4fd1761839265a76c01b8754899f4ae02128aac" translate="yes" xml:space="preserve">
          <source>would return as output: &lt;code&gt;0.9124&lt;/code&gt;</source>
          <target state="translated">将作为输出返回： &lt;code&gt;0.9124&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cbfbe230eae72a4f85a6fc0e071213485692b3b" translate="yes" xml:space="preserve">
          <source>you can use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
