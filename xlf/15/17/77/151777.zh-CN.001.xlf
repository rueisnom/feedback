<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/151777">
    <body>
      <group id="151777">
        <trans-unit id="b5a6667bdc2651683b8358b3c1f0022acc722ead" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;Android Official Documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;Android官方文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="121e52bb9dabd4a4d593ca4ed61c6d2e1b67c006" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.android.com/guide/topics/resources/runtime-changes&quot;&gt;Here&lt;/a&gt; you can find more information about this property.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/guide/topics/resources/runtime-changes&quot;&gt;在这里&lt;/a&gt;您可以找到有关此属性的更多信息。</target>
        </trans-unit>
        <trans-unit id="e09b501ef35b88635149e7d5e913ec8254ab4270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSaveInstanceState()&lt;/code&gt; for transient data (restored in &lt;code&gt;onCreate()&lt;/code&gt;/&lt;code&gt;onRestoreInstanceState()&lt;/code&gt;), &lt;code&gt;onPause()&lt;/code&gt; for persistent data (restored in &lt;code&gt;onResume()&lt;/code&gt;). 
From Android technical resources:</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState()&lt;/code&gt; 用于临时数据（已还原到 &lt;code&gt;onCreate()&lt;/code&gt; / &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 中 ）， &lt;code&gt;onPause()&lt;/code&gt; 用于永久性数据（已还原到 &lt;code&gt;onResume()&lt;/code&gt; 中 ）。 来自Android技术资源：</target>
        </trans-unit>
        <trans-unit id="a2f213488f4ad91a05649b221b4a76f2945e0137" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSaveInstanceState&lt;/code&gt; is called when the system needs memory and kills an application. It is not called when the user just closes the application. So I think application state should also be saved in &lt;code&gt;onPause&lt;/code&gt; It should be saved to some persistent storage like &lt;code&gt;Preferences&lt;/code&gt; or &lt;code&gt;Sqlite&lt;/code&gt;</source>
          <target state="translated">当系统需要内存并杀死应用程序时，将调用 &lt;code&gt;onSaveInstanceState&lt;/code&gt; 。 当用户只是关闭应用程序时，不会调用它。 所以我认为应用程序状态也应该保​​存在 &lt;code&gt;onPause&lt;/code&gt; 中,并且应该保存到一些持久性存储中，例如 &lt;code&gt;Preferences&lt;/code&gt; 或 &lt;code&gt;Sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c161538435224715d86d657b81f84cc9fbb5adb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example: Consider a case if you want to persist Json object.
create a model class with getters and setters .&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;示例：如果要保留Json对象，请考虑一种情况。&lt;/em&gt; &lt;em&gt;使用getter和setter创建模型类。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaf0364f5e75e39441ec278b941b829b093887b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Now in your activity in onCreate and onSaveInstanceState method do the following. It will look something like this:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;现在在活动中的onCreate和onSaveInstanceState方法中执行以下操作。&lt;/em&gt; &lt;em&gt;它看起来像这样：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f5a8c84807804c1921f9174da4957c65cc014f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OR&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OR&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a646b9c61792a35986803f119d93b24829a1064d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: For further clarification, here's the &lt;code&gt;onSaveInstanceState()&lt;/code&gt; documentation:</source>
          <target state="translated">&lt;strong&gt;编辑&lt;/strong&gt; ：为进一步说明，这是 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 文档：</target>
        </trans-unit>
        <trans-unit id="531228a2bc0f20f3ac96d63a93c3fdbe017a2e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This code was adapted from a library project named &lt;a href=&quot;https://github.com/CardinalNow/AndroidAutowire&quot;&gt;AndroidAutowire&lt;/a&gt; which is licensed under the &lt;a href=&quot;https://raw.githubusercontent.com/CardinalNow/AndroidAutowire/master/LICENSE&quot;&gt;MIT license&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此代码改编自名为&lt;a href=&quot;https://github.com/CardinalNow/AndroidAutowire&quot;&gt;androidautowire&lt;/a&gt;的库项目，该项目已获得&lt;a href=&quot;https://raw.githubusercontent.com/CardinalNow/AndroidAutowire/master/LICENSE&quot;&gt;MIT许可&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1f9035e2f998c877c4c7c905e5d6ca2f506d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE June 2013&lt;/strong&gt;: Months later, I have finally found the 'correct' solution. You don't need to manage any stateful startedApp flags yourself,  you can detect this from the framework and bail appropriately. I use this near the beginning of my LauncherActivity.onCreate:</source>
          <target state="translated">&lt;strong&gt;2013年6月的更新&lt;/strong&gt; ：几个月后，我终于找到了&amp;ldquo;正确的&amp;rdquo;解决方案。 您不需要自己管理任何有状态的startedApp标志，您可以从框架中检测到此问题并适当地保释。 我在LauncherActivity.onCreate的开始附近使用它：</target>
        </trans-unit>
        <trans-unit id="34b50dc93d3b4636712893ef0928656dedcdb95d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onPause()&lt;/strong&gt; and &lt;strong&gt;onResume()&lt;/strong&gt; are also complimentary methods. onPause() is always called when the Activity ends, even if we instigated that (with a finish() call for example). We will use this to save the current note back to the database. Good practice is to release any resources that can be released during an onPause() as well, to take up less resources when in the passive state.</source>
          <target state="translated">&lt;strong&gt;onPause（）&lt;/strong&gt;和&lt;strong&gt;onResume（）&lt;/strong&gt;也是互补方法。 即使在活动结束时总是调用onPause（），即使我们已经鼓吹了它（例如，使用finish（）调用）。 我们将使用它来将当前注释保存回数据库。 优良作法是也释放可以在onPause（）期间释放的任何资源，以便在处于被动状态时占用更少的资源。</target>
        </trans-unit>
        <trans-unit id="418e187325d12c8b5d58cc6c9697795f2ac77f1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onSaveInstanceState()&lt;/strong&gt; is called by Android if the Activity is being stopped and may be killed before it is resumed! This means it should store any state necessary to re-initialize to the same condition when the Activity is restarted. It is the counterpart to the onCreate() method, and in fact the savedInstanceState Bundle passed in to onCreate() is the same Bundle that you construct as outState in the onSaveInstanceState() method.</source>
          <target state="translated">如果Activity正在停止，则Android将调用&lt;strong&gt;onSaveInstanceState（），&lt;/strong&gt;并且在恢复之前可能将其杀死！ 这意味着在重新启动活动时，它应存储将其初始化为相同条件所需的任何状态。 它与onCreate（）方法相对应，实际上，传递给onCreate（）的saveInstanceState Bundle与您在onSaveInstanceState（）方法中构造为outState的Bundle相同。</target>
        </trans-unit>
        <trans-unit id="60da94f1b7e55dd3b016dadb7fd0b045e76894ff" translate="yes" xml:space="preserve">
          <source>@VVK - I partially disagree. Some ways of exiting an app don't trigger
  onSaveInstanceState (oSIS). This limits the usefulness of oSIS. Its
  worth supporting, for minimal OS resources, but if an app wants to
  return the user to the state they were in, no matter how the app was
  exited, it is necessary to use a persistent storage approach instead.
  &lt;strong&gt;I use onCreate to check for bundle, and if it is missing, then check&lt;/strong&gt;&lt;strong&gt;persistent storage.&lt;/strong&gt; This centralizes the decision making. I can
  recover from a crash, or back button exit or custom menu item Exit, or
  get back to screen user was on many days later. &amp;ndash; ToolmakerSteve Sep
  19 '15 at 10:38</source>
          <target state="translated">@VVK-我部分不同意。 退出应用程序的某些方式不会触发onSaveInstanceState（oSIS）。 这限制了oSIS的用途。 它值得支持，以减少操作系统资源，但是如果应用程序想要使用户返回到他们所处的状态，则无论应用程序如何退出，都必须使用持久性存储方法。 &lt;strong&gt;我使用onCreate来检查包，如果丢失，则检查&lt;/strong&gt; &lt;strong&gt;持久性存储。&lt;/strong&gt; 这样可以集中决策。 我可以从崩溃中恢复，也可以从后退按钮退出或自定义菜单项&amp;ldquo;退出&amp;rdquo;中恢复，也可以在许多天后恢复到屏幕上的用户状态。 &amp;ndash; ToolmakerSteve 15年9月19日在10:38</target>
        </trans-unit>
        <trans-unit id="acc0ef387cb88068d5d2c8cc5c71a4021ceeef0b" translate="yes" xml:space="preserve">
          <source>A simple call after that</source>
          <target state="translated">一个简单的电话之后</target>
        </trans-unit>
        <trans-unit id="12b9dbb2aada2ed26b959941246da918089eccee" translate="yes" xml:space="preserve">
          <source>Add default values if you don't want to have Optionals</source>
          <target state="translated">如果你不希望有Optionals,请添加默认值。</target>
        </trans-unit>
        <trans-unit id="991c54305f22a2f261d0a09b7e0a862bfc48a980" translate="yes" xml:space="preserve">
          <source>Although the accepted answer is correct, there is a faster and easier method to save the Activity state on Android using a library called &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;Icepick&lt;/a&gt;. Icepick is an annotation processor that takes care of all the boilerplate code used in saving and restoring state for you.</source>
          <target state="translated">尽管接受的答案是正确的，但是有一种更快更简便的方法，可以使用名为&lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;Icepick&lt;/a&gt;的库在Android上保存&amp;ldquo;活动&amp;rdquo;状态。 Icepick是一个注释处理器，负责为您保存和还原状态时使用的所有样板代码。</target>
        </trans-unit>
        <trans-unit id="586a6f24a6dd9d26a13c37c3705aaeab56867cff" translate="yes" xml:space="preserve">
          <source>Always call &lt;code&gt;super.onRestoreInstanceState(savedInstanceState);&lt;/code&gt; so that System restore the View hierarchy by default</source>
          <target state="translated">始终调用 &lt;code&gt;super.onRestoreInstanceState(savedInstanceState);&lt;/code&gt; 以便系统默认还原视图层次结构</target>
        </trans-unit>
        <trans-unit id="8c6424cb3c1d947f3fc1070af0cf32a0ad555cfa" translate="yes" xml:space="preserve">
          <source>And Google states itself, it is NOT even reliable.</source>
          <target state="translated">而谷歌自己声明,它甚至不可靠。</target>
        </trans-unit>
        <trans-unit id="21e287d983bd99580c83fdef5fecc083561d6b8d" translate="yes" xml:space="preserve">
          <source>And in activity2 on button click event I have done like this:</source>
          <target state="translated">而在活动2上的按钮点击事件,我是这样做的。</target>
        </trans-unit>
        <trans-unit id="3ddaa9003466a87f649d72b9838364f7478fd978" translate="yes" xml:space="preserve">
          <source>And in the activity1 on the button click event I have done like this:</source>
          <target state="translated">而在活动1上的按钮点击事件我是这样做的。</target>
        </trans-unit>
        <trans-unit id="b7d66b4989679ab6f5e706bf1bc385c9b0039dca" translate="yes" xml:space="preserve">
          <source>Android will destroy background activities when under memory pressure or after they've been in the background for an extended period of time.</source>
          <target state="translated">安卓在内存压力下,或者是在后台活动时间过长后,会破坏后台活动。</target>
        </trans-unit>
        <trans-unit id="36bfeab96e58c0402708e52b8b5899a9f71935d2" translate="yes" xml:space="preserve">
          <source>BUT - there is a very confusing bug which complicates all of this. Details are here:</source>
          <target state="translated">但是,有一个非常令人困惑的BUG使这一切变得复杂。详情请看这里。</target>
        </trans-unit>
        <trans-unit id="dc5abfe770ef0c8c7dfa135cc6f4c79eaf5a0f77" translate="yes" xml:space="preserve">
          <source>Basically, if your application is launched with the SingleTask flag, and then later on you launch it from the home screen or launcher menu, then that subsequent invocation will create a NEW task ... you'll effectively have two different instances of your app inhabiting the same stack ... which gets very strange very fast. This seems to happen when you launch your app during development (i.e. from Eclipse or Intellij), so developers run into this a lot. But also through some of the app store update mechanisms (so it impacts your users as well).</source>
          <target state="translated">基本上,如果你的应用程序是用SingleTask标志启动的,然后再从主屏幕或启动器菜单中启动它,那么随后的调用将创建一个新的任务...........你的应用程序实际上会有两个不同的实例居住在同一个堆栈中.........这就会很快变得非常奇怪。这似乎是在开发过程中(例如从Eclipse或Intellij)启动你的应用程序时发生的,所以开发人员经常会遇到这种情况。但也会通过一些应用商店的更新机制(所以它也会影响到你的用户)。</target>
        </trans-unit>
        <trans-unit id="1d322c996f5b54d3b8d6b9a87b4ef897e29cccb2" translate="yes" xml:space="preserve">
          <source>Because of memory and processing constraints inherent on mobile devices, I treat Android views in a similar way to a web page. The page does not maintain state, it is purely a presentation layer component whose only purpose is to present application state and accept user input. Recent trends in web app architecture employ the use of the age-old Model, View, Controller (MVC) pattern, where the page is the View, domain data is the model, and the controller sits behind a web service. The same pattern can be employed in Android with the View being, well ... the View, the model is your domain data, and the Controller is implemented as an Android bound service. Whenever you want a view to interact with the controller, bind to it on start/resume and unbind on stop/pause.</source>
          <target state="translated">由于移动设备固有的内存和处理能力的限制,我把Android视图的处理方式类似于网页。页面不维护状态,它纯粹是一个展示层组件,其唯一的目的是展示应用状态并接受用户输入。最近Web应用架构的趋势是使用了老式的模型、视图、控制器(MVC)模式,其中页面是视图,域数据是模型,控制器坐在Web服务后面。同样的模式也可以在Android中使用,View就是View,模型就是你的域数据,而Controller是作为Android绑定的服务实现的。每当你想让一个视图与控制器交互时,在startresume上绑定,停止时解除绑定。</target>
        </trans-unit>
        <trans-unit id="4d963cfab70d8c850b1221649bcc7b4d96d558d3" translate="yes" xml:space="preserve">
          <source>Bonus</source>
          <target state="translated">Bonus</target>
        </trans-unit>
        <trans-unit id="4e882f38eb219fb034343d97ef8fe4679c972b9d" translate="yes" xml:space="preserve">
          <source>Both methods are useful and valid and both are best suited for different scenarios:</source>
          <target state="translated">这两种方法都是有用的,也是有效的,都是最适合不同的场景。</target>
        </trans-unit>
        <trans-unit id="7f4c2a7d5e7a907e20ca9ba7f247ecdab6d275c9" translate="yes" xml:space="preserve">
          <source>Both methods get the same Bundle object, so it does not really matter where you write your restoring logic. The only difference is that in &lt;code&gt;onCreate(Bundle savedInstanceState)&lt;/code&gt; method you will have to give a null check while it is not needed in the latter case. Other answers have already code snippets. You can refer them.</source>
          <target state="translated">两种方法都具有相同的Bundle对象，因此在何处编写恢复逻辑并不重要。 唯一的区别是，在 &lt;code&gt;onCreate(Bundle savedInstanceState)&lt;/code&gt; 方法中，您将必须进行空检查，而在后一种情况下则不需要进行空检查。 其他答案已经编写了代码片段。 您可以参考他们。</target>
        </trans-unit>
        <trans-unit id="b96bc533da5dba9c055df06b23a9dfe3465313ce" translate="yes" xml:space="preserve">
          <source>Browsing across all these threads, I suspect that much of the time developers are talking about these two different issues simultaneously ... hence all the confusion and reports of &quot;this doesn't work for me&quot;.</source>
          <target state="translated">浏览所有这些线程,我怀疑很多时候开发者都在同时讨论这两个不同的问题...........因此,所有的混乱和 &quot;这对我来说不起作用 &quot;的报告。</target>
        </trans-unit>
        <trans-unit id="35c8e7cb5407b863eb1e734effa085a8ef96b4f5" translate="yes" xml:space="preserve">
          <source>But consider this if a user presses the back button. It is assumed that the user does not intend to come back to the Activity, hence in this case &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; will not be invoked by the system.
Point being you should consider all the scenarios while saving data.</source>
          <target state="translated">但是，如果用户按下&amp;ldquo;后退&amp;rdquo;按钮，请考虑一下。 假定用户不打算返回到Activity，因此在这种情况下，系统将不会调用 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 。 重要的是您在保存数据时应考虑所有方案。</target>
        </trans-unit>
        <trans-unit id="6cd192f3540cecdd5c288fd84d4b2b87990d9acc" translate="yes" xml:space="preserve">
          <source>By default System saves the View objects in the Bundle for example.</source>
          <target state="translated">默认情况下,系统会将View对象保存在Bundle中,例如。</target>
        </trans-unit>
        <trans-unit id="bab0ae1b477f7f1414851f1db2b6c48cb2fc0979" translate="yes" xml:space="preserve">
          <source>Configuration changes such as changing the orientation or phone language which may requires a new activity instance to be created.</source>
          <target state="translated">配置更改,如改变方向或手机语言,可能需要创建一个新的活动实例。</target>
        </trans-unit>
        <trans-unit id="c5e30d4ee8619bf7e71388dcf18fd6c8cd7ae045" translate="yes" xml:space="preserve">
          <source>Demo on default behavior</source>
          <target state="translated">默认行为演示</target>
        </trans-unit>
        <trans-unit id="ca5ab99ed4306f5101f437d71e563719d4d391d8" translate="yes" xml:space="preserve">
          <source>Doing something like this with Icepick:</source>
          <target state="translated">用Icepick做这样的事情。</target>
        </trans-unit>
        <trans-unit id="70da04e5dacca4f5d54f1e4e3f78086077168591" translate="yes" xml:space="preserve">
          <source>Ever wondered why the text in the &lt;code&gt;EditText&lt;/code&gt; gets saved automatically while an orientation change? Well, this answer is for you.</source>
          <target state="translated">有没有想过为什么更改方向时会自动保存 &lt;code&gt;EditText&lt;/code&gt; 中的文本？ 好吧，这个答案是给你的。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="f5d1834f3a0a2883e81e95e8e044ed16af7814f5" translate="yes" xml:space="preserve">
          <source>First, create an interface that will be used to annotate your instance variables:</source>
          <target state="translated">首先,创建一个接口,用于注释你的实例变量。</target>
        </trans-unit>
        <trans-unit id="9275071ec8c082fb5939a220a4c806fb676f22cc" translate="yes" xml:space="preserve">
          <source>First, setup the library in &lt;code&gt;app/build.gradle&lt;/code&gt;</source>
          <target state="translated">首先，在 &lt;code&gt;app/build.gradle&lt;/code&gt; 中设置库</target>
        </trans-unit>
        <trans-unit id="e894382ce8ee326bfc00b4ae1a6d8cd2b2e49c1a" translate="yes" xml:space="preserve">
          <source>First, to clarify the 'intended' behavior: onSaveInstance and onRestoreInstance are fragile and only for transient state. The intended usage (afaict) is to handle Activity recreation when the phone is rotated (orientation change). In other words, the intended usage is when your Activity is still logically 'on top', but still must be reinstantiated by the system. The saved Bundle is not persisted outside of the process/memory/gc, so you cannot really rely on this if your activity goes to the background. Yes, perhaps your Activity's memory will survive its trip to the background and escape GC, but this is not reliable (nor is it predictable).</source>
          <target state="translated">首先,澄清一下 &quot;预期的 &quot;行为:onSaveInstance和onRestoreInstance是脆弱的,只针对瞬时状态。预期的用法(afaict)是在手机旋转时(方向改变)处理Activity的再创造。换句话说,预期的用法是当你的Activity在逻辑上仍然是 &quot;在上面&quot;,但仍然必须由系统重新建立。而保存的Bundle是不会在processmemorygc之外持久化的,所以如果你的Activity转到后台,你就不能真正依赖这个。是的,也许你的Activity的内存会存活到后台并逃过GC,但这并不可靠(也不能预测)。</target>
        </trans-unit>
        <trans-unit id="64f2c7bb37c16a6a0039e3494222014af8f41b08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int currentScore&lt;/code&gt; in a GameActivity</source>
          <target state="translated">例如，GameActivity中的 &lt;code&gt;int currentScore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db598030521045d15ff8dae6d7226e2afcef7edc" translate="yes" xml:space="preserve">
          <source>For more long lived state, consider using a SQLite database, a file, or preferences.  See &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#SavingPersistentState&quot;&gt;Saving Persistent State&lt;/a&gt;.</source>
          <target state="translated">对于更长的状态，请考虑使用SQLite数据库，文件或首选项。 请参阅&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#SavingPersistentState&quot;&gt;保存持久状态&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2eba4b624aef5e3315520f49f987a708f2e8cf1" translate="yes" xml:space="preserve">
          <source>For more persistence use shared preferences. &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;read this article&lt;/a&gt;</source>
          <target state="translated">要获得更多持久性，请使用共享首选项。 &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;阅读这篇文章&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b1d44b58d9c7fd663747ff19bc4bb3d891ed0f7" translate="yes" xml:space="preserve">
          <source>For the above scenario what I have done is that in the manifest I made some changes like this:</source>
          <target state="translated">对于上述方案,我所做的是,在清单中,我做了一些像这样的修改。</target>
        </trans-unit>
        <trans-unit id="749062c95bcca68367075f43cf5f9eca84cfe184" translate="yes" xml:space="preserve">
          <source>Here is a comment from &lt;strong&gt;Steve Moseley&lt;/strong&gt;'s answer (by &lt;strong&gt;ToolmakerSteve&lt;/strong&gt;) that puts things into perspective (in the whole onSaveInstanceState vs onPause, east cost vs west cost saga)</source>
          <target state="translated">以下是&lt;strong&gt;史蒂夫&amp;middot;莫斯利&lt;/strong&gt; （ &lt;strong&gt;Steve Moseley&lt;/strong&gt; ）的回答（由&lt;strong&gt;ToolmakerSteve撰写&lt;/strong&gt; ）的评论，它把事情纳入了视角（总体而言，onSaveInstanceState与onPause，东成本与西成本的传奇故事）</target>
        </trans-unit>
        <trans-unit id="1a5aafd8c6994cde334b97c529424f3538a223f2" translate="yes" xml:space="preserve">
          <source>Home key press behaviour</source>
          <target state="translated">主页键的按压行为</target>
        </trans-unit>
        <trans-unit id="730b3a40fc65ec321f279a3d9d7b78388355e548" translate="yes" xml:space="preserve">
          <source>How to save an activity state using save instance state</source>
          <target state="translated">如何使用保存活动状态保存实例状态的方法</target>
        </trans-unit>
        <trans-unit id="99a21a34bbb6452c71f959f0db20b9a7c58d10e2" translate="yes" xml:space="preserve">
          <source>I battled through these threads for hours before I realized that my main issue was this bug, not the intended framework behavior. A great writeup and &lt;del&gt;workaround&lt;/del&gt; (UPDATE: see below) seems to be from user @kaciula in this answer:</source>
          <target state="translated">在意识到自己的主要问题是此错误而不是预期的框架行为之前，我在这些线程中进行了数小时的奋战。 一个伟大的文章和 &lt;del&gt; 解决方法 &lt;/del&gt; （更新：见下文）似乎来自用户@kaciula在此答案中：</target>
        </trans-unit>
        <trans-unit id="f2ad0ce289a11cde24e01a98220dd0e6a556deba" translate="yes" xml:space="preserve">
          <source>I believe this is the answer and this works fine for me. Correct me if I am wrong.</source>
          <target state="translated">我相信这就是答案,这对我来说很好用。如果我说错了,请纠正我。</target>
        </trans-unit>
        <trans-unit id="c88c21f9feae0ff7178652e747f96a57454d58a6" translate="yes" xml:space="preserve">
          <source>I really do not recommend to use second method. Since in one of my experience it was causing half of the device screen black while rotating from portrait to landscape and vice versa.</source>
          <target state="translated">我真的不建议使用第二种方法。因为在我的一个经验中,它导致了一半的设备屏幕从纵向旋转到横向旋转时,一半的屏幕是黑色的,反之亦然。</target>
        </trans-unit>
        <trans-unit id="6a234d5784cfaaa336f8de8adb7d5b12e7d6bb97" translate="yes" xml:space="preserve">
          <source>I think I found the answer. Let me tell what I have done in simple words:</source>
          <target state="translated">我想我找到了答案。让我用简单的话语告诉大家我所做的事情。</target>
        </trans-unit>
        <trans-unit id="d77e2f866a1e4f7218688b101ed8ed15b8edb6b8" translate="yes" xml:space="preserve">
          <source>I thought it would be enough for the simplest case, but it always responds with the first message, no matter how I navigate away from the app.</source>
          <target state="translated">我以为最简单的情况下就可以了,但无论我怎么导航离开APP,它总是以第一条消息来回应。</target>
        </trans-unit>
        <trans-unit id="9e6b9d43774c9c46f68431bb26579c42c30202fc" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;onSaveInstanceState&lt;/code&gt;and &lt;code&gt;onRestoreInstanceState&lt;/code&gt; as suggested above but I guess i could also or alternatively use my method to save the variable when it changes (e.g. using &lt;code&gt;putBoolean&lt;/code&gt;)</source>
          <target state="translated">我按照上面的建议使用 &lt;code&gt;onSaveInstanceState&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState&lt;/code&gt; ，但是我猜我也可以或者可以使用我的方法在变量更改时保存变量（例如，使用 &lt;code&gt;putBoolean&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="76a314ac895f1f34c454a7f19973a5048239551e" translate="yes" xml:space="preserve">
          <source>I'm sure the solution is as simple as overriding &lt;code&gt;onPause&lt;/code&gt; or something like that, but I've been poking away in the documentation for 30 minutes or so and haven't found anything obvious.</source>
          <target state="translated">我敢肯定解决方案就像覆盖 &lt;code&gt;onPause&lt;/code&gt; 或类似的东西一样简单，但是我已经在文档中戳了30分钟左右，并且没有发现任何明显的问题。</target>
        </trans-unit>
        <trans-unit id="ddecbedea0def1107a0a3a5048dec1201be09a90" translate="yes" xml:space="preserve">
          <source>I've been working on the Android SDK platform, and it is a little unclear how to save an application's state. So given this minor re-tooling of the 'Hello, Android' example:</source>
          <target state="translated">我在安卓SDK平台上工作,对于如何保存一个应用的状态有点不清楚。所以考虑到这个小编重新整理了一下'你好,Android'的例子。</target>
        </trans-unit>
        <trans-unit id="75fceb7e8de11f7e552300d6e3d417d93b26bbb7" translate="yes" xml:space="preserve">
          <source>Icepick can also generate the instance state code for custom Views:</source>
          <target state="translated">Icepick还可以为自定义View生成实例状态代码。</target>
        </trans-unit>
        <trans-unit id="9dbe5f85a41ab77aa42247c4ed3c82c2ca80a4e7" translate="yes" xml:space="preserve">
          <source>Icepick will work with any object that saves its state with a &lt;code&gt;Bundle&lt;/code&gt;.</source>
          <target state="translated">Icepick将与任何使用 &lt;code&gt;Bundle&lt;/code&gt; 保存其状态的对象一起使用。</target>
        </trans-unit>
        <trans-unit id="517a95f6798caf61fcd445878cad66a564d72f42" translate="yes" xml:space="preserve">
          <source>If you need another variable to be saved as a part of instance state you should &lt;strong&gt;OVERRIDE&lt;/strong&gt;&lt;code&gt;onSavedInstanceState(Bundle savedinstaneState)&lt;/code&gt; method.</source>
          <target state="translated">如果需要将另一个变量保存为实例状态的一部分，则应&lt;strong&gt;重写&lt;/strong&gt; &lt;code&gt;onSavedInstanceState(Bundle savedinstaneState)&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9c944080c2e6bce35a74fa1594e1a83ea91dbccd" translate="yes" xml:space="preserve">
          <source>If you save the state data in a persistent manner, it can be reloaded in an &lt;code&gt;onResume()&lt;/code&gt; or &lt;code&gt;onCreate()&lt;/code&gt; (or actually on any lifecycle call). This may or may not be desired behaviour. If you store it in a bundle in an &lt;code&gt;InstanceState&lt;/code&gt;, then it is transient and is only suitable for storing data for use in the same user &amp;lsquo;session&amp;rsquo; (I use the term session loosely) but not between &amp;lsquo;sessions&amp;rsquo;.</source>
          <target state="translated">如果以持久方式保存状态数据，则可以在 &lt;code&gt;onResume()&lt;/code&gt; 或 &lt;code&gt;onCreate()&lt;/code&gt; 中 （或实际上在任何生命周期调用中）重新加载状态数据。 这可能是或可能不是期望的行为。 如果将其存储在 &lt;code&gt;InstanceState&lt;/code&gt; 的捆绑包中，则它是瞬时的，仅适合存储在同一用户&amp;ldquo;会话&amp;rdquo;中使用的数据（我宽松地使用&amp;ldquo;会话&amp;rdquo;一词），但不适用于&amp;ldquo;会话&amp;rdquo;之间的数据。</target>
        </trans-unit>
        <trans-unit id="8ad4b28b513d33ae9c7dc4c7a579738551df044a" translate="yes" xml:space="preserve">
          <source>In manifest &lt;code&gt;android:configChanges=&quot;orientation|screenSize&quot;&lt;/code&gt;.</source>
          <target state="translated">在清单 &lt;code&gt;android:configChanges=&quot;orientation|screenSize&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5266f3aaddbb67db45817ea009b4ed42c15a5b6a" translate="yes" xml:space="preserve">
          <source>In most cases if you're just pressing home and then launching the app again the activity won't need to be re-created. It already exists in memory so onCreate() won't be called.</source>
          <target state="translated">在大多数情况下,如果你只是按下home键,然后再次启动应用程序,那么活动就不需要重新创建。它已经存在于内存中,所以onCreate()不会被调用。</target>
        </trans-unit>
        <trans-unit id="2ad9e5f9884ddec3aa54231745e738669a0d7ec6" translate="yes" xml:space="preserve">
          <source>In other words, put your save/restore code for persistent data in &lt;code&gt;onPause()&lt;/code&gt; and &lt;code&gt;onResume()&lt;/code&gt;!</source>
          <target state="translated">换句话说，将用于持久数据的保存/恢复代码放在 &lt;code&gt;onPause()&lt;/code&gt; 和 &lt;code&gt;onResume()&lt;/code&gt; 中 ！</target>
        </trans-unit>
        <trans-unit id="b5dbbbcb80aa47d7c86580e11c02bdad1f4b00d4" translate="yes" xml:space="preserve">
          <source>In some way SharedPreferences work similar like Bundles.
And naturally and at first such values have to be read from preferences.</source>
          <target state="translated">在某些方面,SharedPreferences的工作方式类似于Bundles。而且自然而然地,起初这样的值必须从偏好中读取。</target>
        </trans-unit>
        <trans-unit id="77c287bc0253e852d1896406c1926722161c7817" translate="yes" xml:space="preserve">
          <source>In the case of complex data you may use SQLite instead of using preferences.</source>
          <target state="translated">在复杂数据的情况下,你可以使用SQLite而不是使用首选项。</target>
        </trans-unit>
        <trans-unit id="71100fcc6f3f46f3aa97e956b192f7f4bbbdd94c" translate="yes" xml:space="preserve">
          <source>Instance state is a collection of &lt;strong&gt;key-value&lt;/strong&gt; pairs stored in a &lt;code&gt;Bundle&lt;/code&gt; object.</source>
          <target state="translated">实例状态是存储在 &lt;code&gt;Bundle&lt;/code&gt; 对象中的&lt;strong&gt;键/值&lt;/strong&gt;对的集合。</target>
        </trans-unit>
        <trans-unit id="e895203a0cd4ff2ef32040fe5c4ba822821dc215" translate="yes" xml:space="preserve">
          <source>Is the same as doing this:</source>
          <target state="translated">是等于这样做的。</target>
        </trans-unit>
        <trans-unit id="d54ecbfadf837ad212b0092e15eb1dea12e17ec4" translate="yes" xml:space="preserve">
          <source>It is not that one approach is better than the other, like everything, it is just important to understand what behaviour you require and to select the most appropriate approach.</source>
          <target state="translated">并不是说一种方法就一定比另一种方法好,就像所有的事情一样,只是要明白自己需要什么样的行为,选择最合适的方法。</target>
        </trans-unit>
        <trans-unit id="c4245e3acc2d772effaa7e57af89255710a3d475" translate="yes" xml:space="preserve">
          <source>It should look like this:</source>
          <target state="translated">它应该是这样的</target>
        </trans-unit>
        <trans-unit id="24af904f2496e7c00485a24dbbcabfc6b3c92acf" translate="yes" xml:space="preserve">
          <source>It works for Activities, Fragments or any object that needs to serialize its state on a Bundle (e.g. mortar's ViewPresenters)</source>
          <target state="translated">它适用于Activity、Fragments或任何需要在Bundle上序列化其状态的对象(如Mortar的ViewPresenters)。</target>
        </trans-unit>
        <trans-unit id="52c5e33f29f523034bcbe7459d9b211cb9d1aef4" translate="yes" xml:space="preserve">
          <source>It's recommended to let Android handle this for you than the manually handling.</source>
          <target state="translated">比起手动处理,建议让安卓来帮你处理。</target>
        </trans-unit>
        <trans-unit id="704addd02feecc9f6bcd16d23edb8dbea03f3462" translate="yes" xml:space="preserve">
          <source>Keeping object instances alive in memory between activities within application lifetime using a retained non-configuration instance</source>
          <target state="translated">使用保留的非配置实例,在应用程序生命周期内的不同活动之间在内存中保持对象实例的活力。</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="085096a1896830913423d1a424e00f124559ebde" translate="yes" xml:space="preserve">
          <source>Kotlin code:</source>
          <target state="translated">Kotlin代码。</target>
        </trans-unit>
        <trans-unit id="0fc2bf3ef7f1883184381af47c6a31e111a14eda" translate="yes" xml:space="preserve">
          <source>Life cycle graph</source>
          <target state="translated">生命周期图</target>
        </trans-unit>
        <trans-unit id="8ca6212634cffc24cab196f8d0e808011d5f1cb9" translate="yes" xml:space="preserve">
          <source>Meanwhile I do in general no more use</source>
          <target state="translated">同时,我一般不会再使用</target>
        </trans-unit>
        <trans-unit id="ef8f52e1b40ae0f56a531896c23f4f1189aa7456" translate="yes" xml:space="preserve">
          <source>More detail about the onRestoreInstanceState(Bundle savedinstaneState)</source>
          <target state="translated">关于onRestoreInstanceState(Bundle savedinstaneState)的更多详情</target>
        </trans-unit>
        <trans-unit id="cfeb0383f2d85dd601d9702766f8d5350467eb65" translate="yes" xml:space="preserve">
          <source>More detail about the onSavedInstanceState(Bundle savedinstaneState) while saving data</source>
          <target state="translated">更多关于保存数据时的onSavedInstanceState(Bundle savedinstaneState)的详细说明</target>
        </trans-unit>
        <trans-unit id="4c844a45d0aa045b41a1e782eb2ce348674c0c79" translate="yes" xml:space="preserve">
          <source>My colleague wrote an article explaining application state on Android devices including explanations on activity lifecycle and state information, how to store state information, and saving to state &lt;code&gt;Bundle&lt;/code&gt; and &lt;code&gt;SharedPreferences&lt;/code&gt; and &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;take a look at here&lt;/a&gt;.</source>
          <target state="translated">我的同事写了一篇文章，解释了Android设备上的应用程序状态，包括有关活动生命周期和状态信息，如何存储状态信息以及保存到状态 &lt;code&gt;Bundle&lt;/code&gt; 和 &lt;code&gt;SharedPreferences&lt;/code&gt; 的说明,并&lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;在此处查看&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="49325329f0baecd23c4f99c3e845a4775121d762" translate="yes" xml:space="preserve">
          <source>My problem was that I needed persistence only during the application lifetime (i.e. a single execution including starting other sub-activities within the same app and rotating the device etc). I tried various combinations of the above answers but did not get what I wanted in all situations. In the end what worked for me was to obtain a reference to the savedInstanceState during onCreate:</source>
          <target state="translated">我的问题是,我只需要在应用程序生命周期内的持久性(即一次执行包括启动同一应用程序内的其他子活动和旋转设备等)。我尝试了上述答案的各种组合,但并没有在所有情况下都能达到我想要的效果。最终,对我有效的方法是在onCreate过程中获取保存的InstanceState的引用。</target>
        </trans-unit>
        <trans-unit id="9056c458f0c2df28047ab602793e25b415237362" translate="yes" xml:space="preserve">
          <source>My way is to save any changes immediately in the preferences:</source>
          <target state="translated">我的方法是立即在偏好中保存任何更改。</target>
        </trans-unit>
        <trans-unit id="4ca8a9c67e5177d3e6fc8210f33c1485ca0b9bc6" translate="yes" xml:space="preserve">
          <source>Not sure if my solution is frowned upon or not, but I use a bound service to persist ViewModel state. Whether you store it in memory in the service or persist and retrieve it from a SQLite database depends on your requirements. This is what services of any flavor do, they provide services such as maintaining application state and abstract common business logic.</source>
          <target state="translated">不知道我的解决方案是否会让人皱起眉头,但我使用绑定服务来持久化ViewModel状态。是将其存储在服务的内存中,还是持久化并从SQLite数据库中检索,这取决于你的需求。这就是任何味道的服务所做的事情,它们提供的服务,比如维护应用状态和抽象通用业务逻辑等。</target>
        </trans-unit>
        <trans-unit id="c7f1130942e0e91dd7a38fc7fdb7894bebd63cb7" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; safe to use &lt;code&gt;onSaveInstanceState&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState&lt;/code&gt;&lt;strong&gt;for persistent data&lt;/strong&gt;, according to the documentation on Activity states in &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html&quot;&gt;http://developer.android.com/reference/android/app/Activity.html&lt;/a&gt;.</source>
          <target state="translated">请注意，根据&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html&quot;&gt;http://developer.android.com/reference/android/app/Activity.html中&lt;/a&gt;有关活动状态的文档， &lt;strong&gt;对永久数据&lt;/strong&gt;使用 &lt;code&gt;onSaveInstanceState&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState&lt;/code&gt; 是不安全的。</target>
        </trans-unit>
        <trans-unit id="09b63f649bd2ace083fd36fd2d9645d7e1e062c1" translate="yes" xml:space="preserve">
          <source>Note that it is important to save
  persistent data in &lt;code&gt;onPause()&lt;/code&gt; instead
  of &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt;
  because the later is not part of the
  lifecycle callbacks, so will not be
  called in every situation as described
  in its documentation.</source>
          <target state="translated">请注意，将持久性数据保存在 &lt;code&gt;onPause()&lt;/code&gt; 中而不是 &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt; 中非常重要，因为后者不是生命周期回调的一部分，因此不会在其文档中描述的每种情况下都被调用。</target>
        </trans-unit>
        <trans-unit id="0cb77d78680ec1ed5c4f901d861924bfa8c5521f" translate="yes" xml:space="preserve">
          <source>Now Android provides &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot;&gt;ViewModels&lt;/a&gt; for saving state, you should try to use that instead of saveInstanceState.</source>
          <target state="translated">现在，Android提供了用于保存状态的&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot;&gt;ViewModels&lt;/a&gt; ，您应该尝试使用它而不是saveInstanceState。</target>
        </trans-unit>
        <trans-unit id="a6da74abf95feae94e84fd2b5395c0db821fd4e2" translate="yes" xml:space="preserve">
          <source>Now it makes sense to do 2 ways in the view model.
if you want to save the first as a saved instance:
You can add state parameter in view model like this
&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&quot;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&lt;/a&gt;</source>
          <target state="translated">现在，在视图模型中执行两种方法很有意义。 如果要将第一个保存为已保存的实例：可以在视图模型中添加状态参数，例如&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&quot;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b482d346c633ff146bd076c14488a78af33e811" translate="yes" xml:space="preserve">
          <source>Now what will happen is that whatever the changes we have made in the activity2 will not be lost, and we can view activity2 in the same state as we left previously.</source>
          <target state="translated">现在会发生的事情是,无论我们在activity2中做了什么修改,都不会丢失,我们可以在之前离开的状态下查看activity2。</target>
        </trans-unit>
        <trans-unit id="6a14112d48e19613c3dddbf7368e0ce1363a59c2" translate="yes" xml:space="preserve">
          <source>Now, let's check this example below how to save state in Activity</source>
          <target state="translated">现在,让我们来看看下面这个例子,如何在Activity中保存状态。</target>
        </trans-unit>
        <trans-unit id="de3fb34c55a00a9d41d70d0999f54c3a74a48ce0" translate="yes" xml:space="preserve">
          <source>Or from a fragment.</source>
          <target state="translated">或者说是从碎片中得到的。</target>
        </trans-unit>
        <trans-unit id="06f2b17c80b04fc3bba81b7225ec80e78e29e10a" translate="yes" xml:space="preserve">
          <source>Quote from the docs:
&quot;This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.&quot;
&lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;Source&lt;/a&gt;</source>
          <target state="translated">来自文档的引言：&amp;ldquo;在活动可能被杀死之前调用此方法，以便将来在将来返回某个时间时可以恢复其状态。&amp;rdquo; &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;资源&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c84792233bf30b1abaae84c3f316f8fbe417b1c" translate="yes" xml:space="preserve">
          <source>Really &lt;code&gt;onSaveInstanceState()&lt;/code&gt; is called when the Activity goes to background.</source>
          <target state="translated">当Activity进入后台时，实际上会调用 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d79dfdc86ed9cf9d397fe92b6c3592f64052891a" translate="yes" xml:space="preserve">
          <source>Relevant links:</source>
          <target state="translated">相关链接:</target>
        </trans-unit>
        <trans-unit id="6bc7c4f49193a935253737078f1eac07e7695587" translate="yes" xml:space="preserve">
          <source>Retrieve variables</source>
          <target state="translated">检索变量</target>
        </trans-unit>
        <trans-unit id="9c6aa369a89289d712f7f69e210ed82b581ea4eb" translate="yes" xml:space="preserve">
          <source>Saving state is a kludge at best as far as I'm concerned. If you need to save persistent data, just use an &lt;a href=&quot;http://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt; database. Android makes it &lt;strong&gt;&lt;em&gt;SOOO&lt;/em&gt;&lt;/strong&gt; easy.</source>
          <target state="translated">就我而言，保存国家充其量不过是一件大事。 如果您需要保存持久数据，只需使用&lt;a href=&quot;http://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt;数据库。 Android使&lt;strong&gt;&lt;em&gt;SOOO&lt;/em&gt;&lt;/strong&gt;变得容易。</target>
        </trans-unit>
        <trans-unit id="c92afff79b309ecaa8f3fe0482edd2968fbf8d97" translate="yes" xml:space="preserve">
          <source>Scroll position in a &lt;code&gt;ListView&lt;/code&gt;, etc.</source>
          <target state="translated">在 &lt;code&gt;ListView&lt;/code&gt; 等中滚动位置</target>
        </trans-unit>
        <trans-unit id="a4ff04dedc4cda4bdb4655b6ebd20bec6039d37d" translate="yes" xml:space="preserve">
          <source>Simple quick to solve this problem is using &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;IcePick&lt;/a&gt;</source>
          <target state="translated">解决此问题的简单快速方法是使用&lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;IcePick&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88250f8b9af03b6fc0ff4db55effd8286a4f44ac" translate="yes" xml:space="preserve">
          <source>So by mistake if you forget to call
  &lt;code&gt;super.onSaveInstanceState(savedInstanceState);&lt;/code&gt;the default behavior
  will not work ie Text in EditText will not save.</source>
          <target state="translated">因此，如果您忘记调用 &lt;code&gt;super.onSaveInstanceState(savedInstanceState);&lt;/code&gt; ,则会出错。 默认行为将不起作用，即EditText中的Text将不会保存。</target>
        </trans-unit>
        <trans-unit id="b324a6316fa2e8039900ea43f658e28a4fe7d144" translate="yes" xml:space="preserve">
          <source>So if you have a scenario where there is meaningful 'user progress' or state that should be persisted between 'launches' of your application, the guidance is to use onPause and onResume. You must choose and prepare a persistent store yourself.</source>
          <target state="translated">所以,如果你有一个场景是有意义的 &quot;用户进度 &quot;或状态应该在你的应用程序 &quot;启动 &quot;之间持久化,指导意见是使用onPause和onResume。你必须自己选择并准备一个持久化存储。</target>
        </trans-unit>
        <trans-unit id="0a8c9cecf78e1520d6f30aa06c477eda5abb1c29" translate="yes" xml:space="preserve">
          <source>Something like this:</source>
          <target state="translated">像这样的事情。</target>
        </trans-unit>
        <trans-unit id="ed8609f2ffac41c2767325a80fa34324e524d978" translate="yes" xml:space="preserve">
          <source>Store local variable/UI control data between application instances (i.e. permanently) using shared preferences</source>
          <target state="translated">使用共享首选项在应用程序实例之间(即永久)存储本地变量UI控制数据</target>
        </trans-unit>
        <trans-unit id="1a601715666f11c667d333b1717a4c4b643c5c6a" translate="yes" xml:space="preserve">
          <source>Store local variable/UI control data for application lifetime (i.e. temporarily) using an instance state bundle</source>
          <target state="translated">使用实例状态包存储本地变量UI控制数据,用于应用程序的生命周期(即临时)。</target>
        </trans-unit>
        <trans-unit id="d652780d2ed12cc566103890d1ad4dfb3b59c3f0" translate="yes" xml:space="preserve">
          <source>Store variables</source>
          <target state="translated">存储变量</target>
        </trans-unit>
        <trans-unit id="21d3c43c3d2a040a19e4fdd5af7ebdb60fbc8672" translate="yes" xml:space="preserve">
          <source>Suppose I have two activities, activity1 and activity2 and I am navigating from activity1 to activity2 (I have done some works in activity2) and again back to activity 1 by clicking on a button in activity1. Now at this stage I wanted to go back to activity2 and I want to see my activity2 in the same condition when I last left activity2.</source>
          <target state="translated">假设我有两个活动,activity1和activity2,我正在从activity1导航到activity2(我在activity2中做了一些工作),然后通过点击activity1中的一个按钮再次回到activity1。现在在这个阶段,我想回到activity2,我希望看到activity2和上次离开activity2时一样的状态。</target>
        </trans-unit>
        <trans-unit id="9cd72c21a0b2397e877a53b771b57cc3db27e1a3" translate="yes" xml:space="preserve">
          <source>Text in &lt;code&gt;EditText&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EditText&lt;/code&gt; 中的文字</target>
        </trans-unit>
        <trans-unit id="5b27ab301625c3ec373095ab68b695692c5d22e9" translate="yes" xml:space="preserve">
          <source>The 'normal' or intended way to manage this issue is, itself, rather complicated with the duality of onPause/onResume and onSaveInstanceState/onRestoreInstanceState</source>
          <target state="translated">管理这个问题的 &quot;正常 &quot;或预期的方式本身就相当复杂,因为onPauseonResume和onSaveInstanceStateonRestoreInstanceState的双重性</target>
        </trans-unit>
        <trans-unit id="fdf846da153619f6f5b3e0c470032b5a1b71f8a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; is invoked by the system only when the user intends to come back to the Activity. For example, you are using App X and suddenly you get a call. You move to the caller app and come back to the app X. In this case the &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method will be invoked.</source>
          <target state="translated">仅当用户打算返回到活动时，才由系统调用 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 。 例如，您使用App X，突然接到电话。 您转到调用者应用程序，然后返回到应用程序X。在这种情况下，将调用 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="3136e1e0ea08c82d036d55e752142051b9080e2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSaveInstanceState(bundle)&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; methods are useful for data persistence merely while rotating the screen (orientation change).</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState(bundle)&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; 方法仅在旋转屏幕（方向更改） 时才对数据持久性有用。</target>
        </trans-unit>
        <trans-unit id="bfef643ce37d4fad3767445c87484ad25499c8fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savedInstanceState&lt;/code&gt; is only for saving state associated with a current instance of an Activity, for example current navigation or selection info, so that if Android destroys and recreates an Activity, it can come back as it was before.  See the documentation for &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)&quot;&gt;&lt;code&gt;onCreate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;&lt;code&gt;onSaveInstanceState&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;savedInstanceState&lt;/code&gt; 仅用于保存与Activity的当前实例相关联的状态，例如当前的导航或选择信息，因此，如果Android销毁并重新创建一个Activity，它可以像以前一样返回。 请参阅有关&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)&quot;&gt; &lt;code&gt;onCreate&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt; &lt;code&gt;onSaveInstanceState&lt;/code&gt; &lt;/a&gt;的文档</target>
        </trans-unit>
        <trans-unit id="7d3ce1e986fa6d341b2ac89952e63610b8bc7685" translate="yes" xml:space="preserve">
          <source>The Bundle is essentially a way of storing a NVP (&quot;Name-Value Pair&quot;) map, and it will get passed in to &lt;code&gt;onCreate()&lt;/code&gt; and also &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; where you would then extract the values from activity like this:</source>
          <target state="translated">捆绑包本质上是一种存储NVP（&amp;ldquo;名称-值对&amp;rdquo;）映射的方式，它将传递给 &lt;code&gt;onCreate()&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; ，然后您可以从其中提取值，如下所示：</target>
        </trans-unit>
        <trans-unit id="2b91d9e1904f244273815d75b9a180a3999ad78b" translate="yes" xml:space="preserve">
          <source>The article covers three approaches:</source>
          <target state="translated">这篇文章涵盖了三种方法。</target>
        </trans-unit>
        <trans-unit id="59994bcb0211e26e361677612a25b82f6263a391" translate="yes" xml:space="preserve">
          <source>The document states (in the 'Activity Lifecycle' section):</source>
          <target state="translated">该文件指出(在 &quot;活动生命周期 &quot;部分):</target>
        </trans-unit>
        <trans-unit id="e5c715e503afb2e388c5e07bc7beb922e01cf21e" translate="yes" xml:space="preserve">
          <source>The life cycle is for most activities too complicated and not necessary.</source>
          <target state="translated">生命周期对大多数活动来说太复杂,没有必要。</target>
        </trans-unit>
        <trans-unit id="e03abf264ad09fe480d3645d0ad3e6c80d18a3ac" translate="yes" xml:space="preserve">
          <source>The other answers are valuable in that they teach you the correct ways to store state but I didn't feel they really answered WHY your code wasn't working in the way you expected.</source>
          <target state="translated">其他的答案很有价值,因为他们教你正确的存储状态的方法,但我觉得他们没有真正回答为什么你的代码没有按照你期望的方式工作。</target>
        </trans-unit>
        <trans-unit id="ea853c5dbb9b05a675dbf62467c34a0c9ed85dc1" translate="yes" xml:space="preserve">
          <source>The user switches application and then comes back to the original and wants to pick up where they left off -  save and restore bundle data (such as application state data) in &lt;code&gt;onSaveInstanceState()&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; is usually adequate.</source>
          <target state="translated">用户切换应用程序，然后返回到原始位置，并希望从上次停止的地方继续工作-在 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 中保存和恢复捆绑数据（例如应用程序状态数据）通常就足够了。</target>
        </trans-unit>
        <trans-unit id="664f7f6cd00e964bf2ece8284a1a16728a7165a9" translate="yes" xml:space="preserve">
          <source>The user terminates the application and re-opens it at a later date, but the application needs to reload data from the last session &amp;ndash; this requires a persistent storage approach such as using SQLite.</source>
          <target state="translated">用户终止应用程序并在以后重新打开它，但是应用程序需要从上一个会话中重新加载数据&amp;ndash;这需要使用SQLite等持久存储方法。</target>
        </trans-unit>
        <trans-unit id="fbab7ef755b952309a2b4daa899a7fc7a56700a0" translate="yes" xml:space="preserve">
          <source>Then, create a class where reflection will be used to save values to the bundle:</source>
          <target state="translated">然后,创建一个类,在这个类中,反射将被用于将值保存到bundle中。</target>
        </trans-unit>
        <trans-unit id="e05c399bd3b713fd14819c61025cf239cdc9f4a3" translate="yes" xml:space="preserve">
          <source>There are basically two ways to implement this change.</source>
          <target state="translated">要实现这一变化,基本上有两种方法。</target>
        </trans-unit>
        <trans-unit id="7d0e409673cec86fa043a7ead7b9881a2eb5036f" translate="yes" xml:space="preserve">
          <source>There is a subtle Android Framework bug which greatly complicates application stack management during development, at least on legacy versions (not entirely sure if/when/how it was fixed). I'll discuss this bug below.</source>
          <target state="translated">有一个微妙的Android Framework bug,它极大地复杂了开发过程中的应用栈管理,至少在传统版本上是这样的(不完全确定是否在什么时候被修复了)。下面我将讨论这个bug。</target>
        </trans-unit>
        <trans-unit id="46ad321e7ce6bd857daf8414afc19b0370ddb6b9" translate="yes" xml:space="preserve">
          <source>There is a way to make Android save the states without implementing any method. Just add this line to your Manifest in Activity declaration:</source>
          <target state="translated">有一个方法可以让Android不实现任何方法就可以保存状态。只需在Activity声明中的Manifest中添加这一行。</target>
        </trans-unit>
        <trans-unit id="692777a292ae320362294cca80a4d6f9cccf34cf" translate="yes" xml:space="preserve">
          <source>There is an option under Settings -&amp;gt; Developer Options called &quot;Don't keep activities&quot;. When it's enabled Android will always destroy activities and recreate them when they're backgrounded. This is a great option to leave enabled when developing because it simulates the worst case scenario. ( A low memory device recycling your activities all the time ).</source>
          <target state="translated">在&amp;ldquo;设置&amp;rdquo;-&amp;gt;&amp;ldquo;开发人员选项&amp;rdquo;下有一个名为&amp;ldquo;不保留活动&amp;rdquo;的选项。 启用后，Android会始终销毁活动并在后台将其重新创建。 这是在开发时保持启用状态的绝佳选择，因为它会模拟最坏的情况。 （内存不足的设备会一直回收您的活动）。</target>
        </trans-unit>
        <trans-unit id="7bea05f76049cfe844c159e008e33b3cdad15d15" translate="yes" xml:space="preserve">
          <source>They are not even good while switching between applications (since the &lt;code&gt;onSaveInstanceState()&lt;/code&gt; method is called but &lt;code&gt;onCreate(bundle)&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; is not invoked again.</source>
          <target state="translated">它们在应用程序之间切换时甚至都不好（因为调用了 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 方法，但是不再再次调用 &lt;code&gt;onCreate(bundle)&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ba2aa884fd631b75bfa3cea504f24ca026a10a3" translate="yes" xml:space="preserve">
          <source>This approach gives you the added bonus of enforcing the Separation of Concern design principle in that all of you application business logic can be moved into your service which reduces duplicated logic across multiple views and allows the view to enforce another important design principle, Single Responsibility.</source>
          <target state="translated">这种方法给你带来了额外的好处,那就是你可以把所有的应用业务逻辑都移到你的服务中,减少了跨多个视图的重复逻辑,并允许视图执行另一个重要的设计原则--单一责任。</target>
        </trans-unit>
        <trans-unit id="1c26216b14217a3380648c7ae8c9e34dc0e4f79b" translate="yes" xml:space="preserve">
          <source>This is a classic 'gotcha' of Android development. There are two issues here:</source>
          <target state="translated">这是Android开发中的一个典型的 &quot;Gotcha &quot;问题。这里有两个问题。</target>
        </trans-unit>
        <trans-unit id="e54d3b795eaa3a1ea1ebc0c9870580be1ebc7d60" translate="yes" xml:space="preserve">
          <source>This method is called before an activity may be killed so that when it
  comes back some time in the future it can restore its state. For
  example, if activity B is launched in front of activity A, and at some
  point activity A is killed to reclaim resources, activity A will have
  a chance to save the current state of its user interface via this
  method so that when the user returns to activity A, the state of the
  user interface can be restored via &lt;code&gt;onCreate(Bundle)&lt;/code&gt; or
  &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt;.</source>
          <target state="translated">在活动被杀死之前将调用此方法，以便将来在将来返回某个时间时可以恢复其状态。 例如，如果在活动A的前面启动了活动B，并且在某个时候活动A被杀死以回收资源，则活动A将有机会通过此方法保存其用户界面的当前状态，以便当用户返回时对于活动A，可以通过 &lt;code&gt;onCreate(Bundle)&lt;/code&gt; 或 &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt; 恢复用户界面的状态。</target>
        </trans-unit>
        <trans-unit id="b4d6a7f29f8cc604160d04f5aa0b3c33d5a3b946" translate="yes" xml:space="preserve">
          <source>To answer the original question directly. savedInstancestate is null because your Activity is never being re-created.</source>
          <target state="translated">直接回答原来的问题,保存的Instancestate是空的,因为你的Activity永远不会被重新创建。</target>
        </trans-unit>
        <trans-unit id="ec9f8b80524ada5a79eb7a16caabdaee5b0a16b9" translate="yes" xml:space="preserve">
          <source>To get activity state data stored in &lt;code&gt;onCreate()&lt;/code&gt;, first you have to save data in savedInstanceState by overriding &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method.</source>
          <target state="translated">要获取存储在 &lt;code&gt;onCreate()&lt;/code&gt; 中的活动状态数据，首先必须通过重写 &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 方法将数据保存在saveInstanceState中。</target>
        </trans-unit>
        <trans-unit id="24e60a573f56cb1eba94bf31112b60354733fdc2" translate="yes" xml:space="preserve">
          <source>To help reduce boilerplate I use the following &lt;code&gt;interface&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; to read/write to a &lt;code&gt;Bundle&lt;/code&gt; for saving instance state.</source>
          <target state="translated">为了帮助减少样板，我使用以下 &lt;code&gt;interface&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 读取/写入 &lt;code&gt;Bundle&lt;/code&gt; 以保存实例状态。</target>
        </trans-unit>
        <trans-unit id="9fe0ffe2fbabae926ca82b75532206413f6d13cf" translate="yes" xml:space="preserve">
          <source>Using first method mentioned above , we can persist data when orientation is changed or any config change happens.
I know a way in which you can store any type of data inside savedInstance state object.</source>
          <target state="translated">使用上面提到的第一个方法,我们可以在改变方向或任何配置改变的时候持久化数据。我知道有一种方法可以将任何类型的数据存储在saveInstance状态对象中。</target>
        </trans-unit>
        <trans-unit id="708a9360bf26e47c630bb82671e52c1cb996099e" translate="yes" xml:space="preserve">
          <source>What to save and what not to?</source>
          <target state="translated">哪些该省,哪些不该省?</target>
        </trans-unit>
        <trans-unit id="5b3a304deee10af08a21c6160599ddf1fb716ab9" translate="yes" xml:space="preserve">
          <source>When activity destroy &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method gets called and there you save data you want to save. And you get same in &lt;code&gt;onCreate()&lt;/code&gt; when activity restart.(savedInstanceState wont be null since you have saved some data in it before activity get destroyed)</source>
          <target state="translated">当活动销毁时，将调用 &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 方法，在那里您保存了要保存的数据。 当活动重新启动时，您在 &lt;code&gt;onCreate()&lt;/code&gt; 中也会得到相同的内容。（savedInstanceState不会为null，因为在销毁活动之前已在其中保存了一些数据）</target>
        </trans-unit>
        <trans-unit id="fe000ca18fed19c86b29988523117d0fa3476fba" translate="yes" xml:space="preserve">
          <source>When an activity is created it's  onCreate() method is called.</source>
          <target state="translated">当一个活动被创建时,它的onCreate()方法被调用。</target>
        </trans-unit>
        <trans-unit id="7037321aeffdd9ea93756424ab6c502f36f7cda5" translate="yes" xml:space="preserve">
          <source>When an instance of an Activity gets destroyed and the System recreates a new instance (for example, configuration change). It tries to recreate it using a set of saved data of old Activity State (&lt;strong&gt;instance state&lt;/strong&gt;).</source>
          <target state="translated">当活动实例被销毁并且系统重新创建新实例（例如，配置更改）时。 它尝试使用一组旧的活动状态（ &lt;strong&gt;实例状态&lt;/strong&gt; ）的已保存数据来重新创建它。</target>
        </trans-unit>
        <trans-unit id="a1397a30190c4c1451dd4205b7628110696a74a5" translate="yes" xml:space="preserve">
          <source>When applying this concept, the activity just continues to use the last saved state, regardless of whether it was an initial open with reboots in between or a reopen due to the back stack.</source>
          <target state="translated">当应用这个概念时,活动只是继续使用上次保存的状态,而不管它是初始打开,中间有重启,还是由于后面的堆栈导致的重启。</target>
        </trans-unit>
        <trans-unit id="4fa62a378bcd4f7418b39cb8691bbce43dbd3718" translate="yes" xml:space="preserve">
          <source>When testing your hello world example there are a few ways to leave and return to the Activity.</source>
          <target state="translated">当测试你的hello世界范例时,有几种方法可以离开和返回到活动中。</target>
        </trans-unit>
        <trans-unit id="523c44f6aa55034d8ae4eedaf908d2bc7ebc117b" translate="yes" xml:space="preserve">
          <source>When you press the back button the Activity is finished. Re-launching the app is a brand new instance. You aren't resuming from the background at all.</source>
          <target state="translated">当你按下返回按钮后,活动就结束了。重新启动应用是一个全新的实例。你根本没有从后台重新启动。</target>
        </trans-unit>
        <trans-unit id="0245328997efbfaa4a6772efcd662e40be32fd87" translate="yes" xml:space="preserve">
          <source>When you press the home button or use the task switcher the Activity will go into the background. When navigating back to the application onCreate will only be called if the Activity had to be destroyed.</source>
          <target state="translated">当你按下主页按钮或使用任务切换器时,Activity将进入后台。当导航返回到应用程序时,只有在Activity必须被销毁时才会调用onCreate。</target>
        </trans-unit>
        <trans-unit id="bde74985ade4026a21de660516fb194d30c52a34" translate="yes" xml:space="preserve">
          <source>Which to choose for restoring Activity state?</source>
          <target state="translated">恢复活动状态要选择哪种?</target>
        </trans-unit>
        <trans-unit id="15f0fa1f93e4f5096a5df7aa7f2b635d5b2e0451" translate="yes" xml:space="preserve">
          <source>You must override &lt;code&gt;onSaveInstanceState&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState&lt;/code&gt; to store and retrieve your variables you want to be persistent</source>
          <target state="translated">您必须重写 &lt;code&gt;onSaveInstanceState&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState&lt;/code&gt; 来存储和检索要持久化的变量</target>
        </trans-unit>
        <trans-unit id="e284dcc6df7a14df80dad493541a1a48c5ccbbed" translate="yes" xml:space="preserve">
          <source>You need to override &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; and write the application state values you want to change to the &lt;code&gt;Bundle&lt;/code&gt; parameter like this:</source>
          <target state="translated">您需要重写 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; ,并将要更改的应用程序状态值写入 &lt;code&gt;Bundle&lt;/code&gt; 参数，如下所示：</target>
        </trans-unit>
        <trans-unit id="aafbe683885219a03d91994f495fe865456fdf92" translate="yes" xml:space="preserve">
          <source>You return to the app from the background after the OS has destroyed the activity.</source>
          <target state="translated">在操作系统破坏了活动后,你会从后台返回应用程序。</target>
        </trans-unit>
        <trans-unit id="9ee2d3fa32e8a81c76f202907661f73dd44acc09" translate="yes" xml:space="preserve">
          <source>You would usually use this technique to store instance values for your application (selections, unsaved text, etc.).</source>
          <target state="translated">你通常会使用这种技术来存储你的应用程序的实例值(选择、未保存的文本等)。</target>
        </trans-unit>
        <trans-unit id="14cc4f238e05194b2051e422ea411af3ff2c43b9" translate="yes" xml:space="preserve">
          <source>Your Activity will only be re-created with a state bundle when:</source>
          <target state="translated">你的活动只有在以下情况下才会被重新创建状态捆绑。</target>
        </trans-unit>
        <trans-unit id="401225f701851f15a91db5909f506dd01d4a7299" translate="yes" xml:space="preserve">
          <source>and then in &lt;code&gt;onCreate()&lt;/code&gt; or &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;</source>
          <target state="translated">然后在 &lt;code&gt;onCreate()&lt;/code&gt; 或 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="e744c62a1531a7d3816a29a305bdea75e0510e1a" translate="yes" xml:space="preserve">
          <source>and use that to obtain the contents of my variable when I needed it, along the lines of:</source>
          <target state="translated">并在我需要的时候用它来获取我的变量的内容,就像:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="d6d46a9486f34d2a4f4c16c5884630b54d1e5610" translate="yes" xml:space="preserve">
          <source>or you can save variables or object in view model, in this case the view model will hold the life cycle until the activity is destroyed.</source>
          <target state="translated">或者你可以在视图模型中保存变量或对象,在这种情况下,视图模型将保持生命周期,直到活动被破坏。</target>
        </trans-unit>
        <trans-unit id="9b199dd59ffbfb3b2470ec58e2251be7dd34f5cc" translate="yes" xml:space="preserve">
          <source>put your values in &quot;outState&quot; Bundle object like outState.putString(&quot;key&quot;,&quot;Welcome Back&quot;) and save by calling super.
When activity will be destroyed it's state get saved in Bundle object and can be restored after recreation in onCreate() or onRestoreInstanceState(). Bundle received in onCreate() and onRestoreInstanceState() are same.</source>
          <target state="translated">把你的值放到 &quot;outState &quot;Bundle对象中,比如outState.putString(&quot;key&quot;,&quot;Welcome Back&quot;),然后通过调用super来保存。当活动被销毁时,它的状态会被保存在Bundle对象中,并在onCreate()或onRestoreInstanceState()中恢复。在onCreate()和onRestoreInstanceState()中接收到的Bundle是一样的。</target>
        </trans-unit>
        <trans-unit id="e9bb9c4cea2c1b033a08233a06951da1b1dfe6e2" translate="yes" xml:space="preserve">
          <source>save:</source>
          <target state="translated">save:</target>
        </trans-unit>
        <trans-unit id="4a7cf61c20a4c3cd62e2773efce644abc579ccb4" translate="yes" xml:space="preserve">
          <source>savedInstanceState is an object of Bundle class which is null for the first time, but it contains values when it is recreated. To save Activity's state you have to override onSaveInstanceState().</source>
          <target state="translated">savedInstanceState是Bundle类的一个对象,第一次保存的时候是空的,但是当它被重新创建时,它包含了值。要保存Activity的状态,你必须覆盖onSaveInstanceState()。</target>
        </trans-unit>
        <trans-unit id="6730c072fe1012f6ae332fca56c1a746e8e87912" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;onSaveInstanceState()&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96901f983bdf1c877f70d5eee18accdaba69139f" translate="yes" xml:space="preserve">
          <source>you can use the &lt;code&gt;Live Data&lt;/code&gt; and &lt;code&gt;View Model&lt;/code&gt; For L&lt;code&gt;ifecycle Handel&lt;/code&gt; From &lt;code&gt;JetPack&lt;/code&gt;. see this Reference :</source>
          <target state="translated">您可以使用 &lt;code&gt;ifecycle Handel&lt;/code&gt; 的 &lt;code&gt;Live Data&lt;/code&gt; 和 &lt;code&gt;View Model&lt;/code&gt; 。 看到这个参考：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
