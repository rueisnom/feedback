<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/151777">
    <body>
      <group id="151777">
        <trans-unit id="b5a6667bdc2651683b8358b3c1f0022acc722ead" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;Android Official Documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;Android公式ドキュメント&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="121e52bb9dabd4a4d593ca4ed61c6d2e1b67c006" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.android.com/guide/topics/resources/runtime-changes&quot;&gt;Here&lt;/a&gt; you can find more information about this property.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/guide/topics/resources/runtime-changes&quot;&gt;ここで&lt;/a&gt;は、このプロパティの詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="e09b501ef35b88635149e7d5e913ec8254ab4270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSaveInstanceState()&lt;/code&gt; for transient data (restored in &lt;code&gt;onCreate()&lt;/code&gt;/&lt;code&gt;onRestoreInstanceState()&lt;/code&gt;), &lt;code&gt;onPause()&lt;/code&gt; for persistent data (restored in &lt;code&gt;onResume()&lt;/code&gt;). 
From Android technical resources:</source>
          <target state="translated">一時データの &lt;code&gt;onSaveInstanceState()&lt;/code&gt; （ &lt;code&gt;onCreate()&lt;/code&gt; / &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; で復元 &lt;code&gt;onPause()&lt;/code&gt; 、永続データの &lt;code&gt;onResume()&lt;/code&gt; 復元）。 Androidテクニカルリソースから：</target>
        </trans-unit>
        <trans-unit id="a2f213488f4ad91a05649b221b4a76f2945e0137" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSaveInstanceState&lt;/code&gt; is called when the system needs memory and kills an application. It is not called when the user just closes the application. So I think application state should also be saved in &lt;code&gt;onPause&lt;/code&gt; It should be saved to some persistent storage like &lt;code&gt;Preferences&lt;/code&gt; or &lt;code&gt;Sqlite&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState&lt;/code&gt; は、システムがメモリを必要としてアプリケーションを強制終了したときに呼び出されます。 ユーザーがアプリケーションを閉じただけでは呼び出されません。 したがって、アプリケーションの状態も &lt;code&gt;onPause&lt;/code&gt; に保存する必要があると思います &lt;code&gt;Sqlite&lt;/code&gt; やSqliteなどの永続ストレージに保存する必要があります</target>
        </trans-unit>
        <trans-unit id="c161538435224715d86d657b81f84cc9fbb5adb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example: Consider a case if you want to persist Json object.
create a model class with getters and setters .&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;例：Jsonオブジェクトを永続化する場合を考えます。&lt;/em&gt; &lt;em&gt;ゲッターとセッターを持つモデルクラスを作成します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaf0364f5e75e39441ec278b941b829b093887b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Now in your activity in onCreate and onSaveInstanceState method do the following. It will look something like this:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;次に、onCreateおよびonSaveInstanceStateメソッドのアクティビティで、次の手順を実行します。&lt;/em&gt; &lt;em&gt;次のようになります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f5a8c84807804c1921f9174da4957c65cc014f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OR&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OR&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a646b9c61792a35986803f119d93b24829a1064d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: For further clarification, here's the &lt;code&gt;onSaveInstanceState()&lt;/code&gt; documentation:</source>
          <target state="translated">&lt;strong&gt;編集&lt;/strong&gt; ：さらに明確にするために、ここに &lt;code&gt;onSaveInstanceState()&lt;/code&gt; のドキュメントがあります：</target>
        </trans-unit>
        <trans-unit id="531228a2bc0f20f3ac96d63a93c3fdbe017a2e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This code was adapted from a library project named &lt;a href=&quot;https://github.com/CardinalNow/AndroidAutowire&quot;&gt;AndroidAutowire&lt;/a&gt; which is licensed under the &lt;a href=&quot;https://raw.githubusercontent.com/CardinalNow/AndroidAutowire/master/LICENSE&quot;&gt;MIT license&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このコードは、 &lt;a href=&quot;https://raw.githubusercontent.com/CardinalNow/AndroidAutowire/master/LICENSE&quot;&gt;MIT&lt;/a&gt;ライセンスの下でライセンスされている&lt;a href=&quot;https://github.com/CardinalNow/AndroidAutowire&quot;&gt;AndroidAutowire&lt;/a&gt;という名前のライブラリプロジェクトから適応されました。</target>
        </trans-unit>
        <trans-unit id="c1f9035e2f998c877c4c7c905e5d6ca2f506d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE June 2013&lt;/strong&gt;: Months later, I have finally found the 'correct' solution. You don't need to manage any stateful startedApp flags yourself,  you can detect this from the framework and bail appropriately. I use this near the beginning of my LauncherActivity.onCreate:</source>
          <target state="translated">&lt;strong&gt;2013年6月更新&lt;/strong&gt; ：数か月後、ようやく「正しい」解決策が見つかりました。 ステートフルのstartedAppフラグを自分で管理する必要はありません。これをフレームワークから検出し、適切に保釈することができます。 LauncherActivity.onCreateの先頭近くでこれを使用します。</target>
        </trans-unit>
        <trans-unit id="34b50dc93d3b4636712893ef0928656dedcdb95d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onPause()&lt;/strong&gt; and &lt;strong&gt;onResume()&lt;/strong&gt; are also complimentary methods. onPause() is always called when the Activity ends, even if we instigated that (with a finish() call for example). We will use this to save the current note back to the database. Good practice is to release any resources that can be released during an onPause() as well, to take up less resources when in the passive state.</source>
          <target state="translated">&lt;strong&gt;onPause（）&lt;/strong&gt;と&lt;strong&gt;onResume（）&lt;/strong&gt;も補完的なメソッドです。 onPause（）は、（finish（）呼び出しなどで）開始した場合でも、アクティビティが終了すると常に呼び出されます。 これを使用して、現在のメモをデータベースに保存します。 onPause（）中に解放できるリソースも解放し、パッシブ状態のときに使用するリソースを少なくすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="418e187325d12c8b5d58cc6c9697795f2ac77f1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onSaveInstanceState()&lt;/strong&gt; is called by Android if the Activity is being stopped and may be killed before it is resumed! This means it should store any state necessary to re-initialize to the same condition when the Activity is restarted. It is the counterpart to the onCreate() method, and in fact the savedInstanceState Bundle passed in to onCreate() is the same Bundle that you construct as outState in the onSaveInstanceState() method.</source>
          <target state="translated">&lt;strong&gt;onSaveInstanceState（）&lt;/strong&gt;は、アクティビティが停止されている場合にAndroidによって呼び出され、再開される前に&lt;strong&gt;強制終了さ&lt;/strong&gt;れる可能性があります。 つまり、アクティビティが再起動されたときに同じ状態に再初期化するために必要な状態を保存する必要があります。 これは、onCreate（）メソッドに対応するものであり、実際に、onCreate（）に渡されるsavedInstanceState Bundleは、onSaveInstanceState（）メソッドでoutStateとして作成するバンドルと同じです。</target>
        </trans-unit>
        <trans-unit id="60da94f1b7e55dd3b016dadb7fd0b045e76894ff" translate="yes" xml:space="preserve">
          <source>@VVK - I partially disagree. Some ways of exiting an app don't trigger
  onSaveInstanceState (oSIS). This limits the usefulness of oSIS. Its
  worth supporting, for minimal OS resources, but if an app wants to
  return the user to the state they were in, no matter how the app was
  exited, it is necessary to use a persistent storage approach instead.
  &lt;strong&gt;I use onCreate to check for bundle, and if it is missing, then check&lt;/strong&gt;&lt;strong&gt;persistent storage.&lt;/strong&gt; This centralizes the decision making. I can
  recover from a crash, or back button exit or custom menu item Exit, or
  get back to screen user was on many days later. &amp;ndash; ToolmakerSteve Sep
  19 '15 at 10:38</source>
          <target state="translated">@VVK-部分的に同意しません。 アプリを終了するいくつかの方法は、onSaveInstanceState（oSIS）をトリガーしません。 これはoSISの有用性を制限します。 最小限のOSリソースでサポートする価値はありますが、アプリがユーザーを元の状態に戻したい場合は、アプリがどのように終了したかに関係なく、代わりに永続ストレージアプローチを使用する必要があります。 &lt;strong&gt;onCreateを使用してバンドルを確認し、見つからない場合は&lt;/strong&gt; &lt;strong&gt;永続ストレージを&lt;/strong&gt; &lt;strong&gt;確認し&lt;/strong&gt; &lt;strong&gt;ます。&lt;/strong&gt; これにより、意思決定が一元化されます。 クラッシュから回復したり、戻るボタンで終了したり、カスタムメニューアイテムである終了したり、ユーザーが何日か後に画面に戻ったりした。 &amp;ndash; ToolmakerSteve 2015年9月19日10:38</target>
        </trans-unit>
        <trans-unit id="acc0ef387cb88068d5d2c8cc5c71a4021ceeef0b" translate="yes" xml:space="preserve">
          <source>A simple call after that</source>
          <target state="translated">その後の簡単な呼び出し</target>
        </trans-unit>
        <trans-unit id="12b9dbb2aada2ed26b959941246da918089eccee" translate="yes" xml:space="preserve">
          <source>Add default values if you don't want to have Optionals</source>
          <target state="translated">Optionalsを使用したくない場合は、デフォルト値を追加します。</target>
        </trans-unit>
        <trans-unit id="991c54305f22a2f261d0a09b7e0a862bfc48a980" translate="yes" xml:space="preserve">
          <source>Although the accepted answer is correct, there is a faster and easier method to save the Activity state on Android using a library called &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;Icepick&lt;/a&gt;. Icepick is an annotation processor that takes care of all the boilerplate code used in saving and restoring state for you.</source>
          <target state="translated">受け入れられた答えは正しいですが、 &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;Icepick&lt;/a&gt;と呼ばれるライブラリを使用して、Androidでアクティビティの状態を保存するためのより速くて簡単な方法があります。 Icepickは、状態の保存と復元に使用されるすべての定型コードを処理する注釈プロセッサです。</target>
        </trans-unit>
        <trans-unit id="586a6f24a6dd9d26a13c37c3705aaeab56867cff" translate="yes" xml:space="preserve">
          <source>Always call &lt;code&gt;super.onRestoreInstanceState(savedInstanceState);&lt;/code&gt; so that System restore the View hierarchy by default</source>
          <target state="translated">常に &lt;code&gt;super.onRestoreInstanceState(savedInstanceState);&lt;/code&gt; を呼び出します。 システムがデフォルトでビュー階層を復元するように</target>
        </trans-unit>
        <trans-unit id="8c6424cb3c1d947f3fc1070af0cf32a0ad555cfa" translate="yes" xml:space="preserve">
          <source>And Google states itself, it is NOT even reliable.</source>
          <target state="translated">そして、Googleは自分自身を述べ、それは信頼性さえない。</target>
        </trans-unit>
        <trans-unit id="21e287d983bd99580c83fdef5fecc083561d6b8d" translate="yes" xml:space="preserve">
          <source>And in activity2 on button click event I have done like this:</source>
          <target state="translated">また、Activity2のボタンクリックイベントでは、このようにしています。</target>
        </trans-unit>
        <trans-unit id="3ddaa9003466a87f649d72b9838364f7478fd978" translate="yes" xml:space="preserve">
          <source>And in the activity1 on the button click event I have done like this:</source>
          <target state="translated">そして、ボタンクリックイベントのactivity1では、私はこのように行っています。</target>
        </trans-unit>
        <trans-unit id="b7d66b4989679ab6f5e706bf1bc385c9b0039dca" translate="yes" xml:space="preserve">
          <source>Android will destroy background activities when under memory pressure or after they've been in the background for an extended period of time.</source>
          <target state="translated">Androidは、メモリ圧迫下にある場合や、長時間バックグラウンドで活動した後に、バックグラウンドの活動を破壊します。</target>
        </trans-unit>
        <trans-unit id="36bfeab96e58c0402708e52b8b5899a9f71935d2" translate="yes" xml:space="preserve">
          <source>BUT - there is a very confusing bug which complicates all of this. Details are here:</source>
          <target state="translated">しかし-このすべてを複雑にしている非常に紛らわしいバグがあります。詳細はここにあります。</target>
        </trans-unit>
        <trans-unit id="dc5abfe770ef0c8c7dfa135cc6f4c79eaf5a0f77" translate="yes" xml:space="preserve">
          <source>Basically, if your application is launched with the SingleTask flag, and then later on you launch it from the home screen or launcher menu, then that subsequent invocation will create a NEW task ... you'll effectively have two different instances of your app inhabiting the same stack ... which gets very strange very fast. This seems to happen when you launch your app during development (i.e. from Eclipse or Intellij), so developers run into this a lot. But also through some of the app store update mechanisms (so it impacts your users as well).</source>
          <target state="translated">基本的に、アプリケーションがSingleTaskフラグで起動され、その後ホーム画面やランチャーメニューから起動した場合、その後の呼び出しは新しいタスクを作成します。これは開発中にアプリを起動したときに起こるようで(EclipseやIntellijなどから)、開発者はこれによく遭遇します。しかし、アプリストアのアップデートメカニズムのいくつかを通しても起こります(だから、ユーザーにも影響を与えます)。</target>
        </trans-unit>
        <trans-unit id="1d322c996f5b54d3b8d6b9a87b4ef897e29cccb2" translate="yes" xml:space="preserve">
          <source>Because of memory and processing constraints inherent on mobile devices, I treat Android views in a similar way to a web page. The page does not maintain state, it is purely a presentation layer component whose only purpose is to present application state and accept user input. Recent trends in web app architecture employ the use of the age-old Model, View, Controller (MVC) pattern, where the page is the View, domain data is the model, and the controller sits behind a web service. The same pattern can be employed in Android with the View being, well ... the View, the model is your domain data, and the Controller is implemented as an Android bound service. Whenever you want a view to interact with the controller, bind to it on start/resume and unbind on stop/pause.</source>
          <target state="translated">モバイルデバイスに固有のメモリと処理の制約のため、私は Android のビューを Web ページと似たような方法で扱います。ページは状態を維持するものではなく、純粋にアプリケーションの状態を提示し、ユーザーの入力を受け入れることだけを目的としたプレゼンテーション層のコンポーネントです。ウェブアプリのアーキテクチャにおける最近のトレンドは、古くからあるモデル、ビュー、コントローラ(MVC)パターンを採用しています。同じパターンをAndroidでも採用することができ、ビューはビュー、モデルはドメインデータ、コントローラはAndroidにバインドされたサービスとして実装されています。ビューをコントローラと対話させたいときはいつでも、startresumeでビューにバインドし、stoppauseでバインドを解除します。</target>
        </trans-unit>
        <trans-unit id="4d963cfab70d8c850b1221649bcc7b4d96d558d3" translate="yes" xml:space="preserve">
          <source>Bonus</source>
          <target state="translated">Bonus</target>
        </trans-unit>
        <trans-unit id="4e882f38eb219fb034343d97ef8fe4679c972b9d" translate="yes" xml:space="preserve">
          <source>Both methods are useful and valid and both are best suited for different scenarios:</source>
          <target state="translated">どちらの方法も有用で有効であり、どちらも異なるシナリオに最も適しています。</target>
        </trans-unit>
        <trans-unit id="7f4c2a7d5e7a907e20ca9ba7f247ecdab6d275c9" translate="yes" xml:space="preserve">
          <source>Both methods get the same Bundle object, so it does not really matter where you write your restoring logic. The only difference is that in &lt;code&gt;onCreate(Bundle savedInstanceState)&lt;/code&gt; method you will have to give a null check while it is not needed in the latter case. Other answers have already code snippets. You can refer them.</source>
          <target state="translated">どちらのメソッドも同じBundleオブジェクトを取得するため、復元ロジックをどこに記述するかは重要ではありません。 唯一の違いは、 &lt;code&gt;onCreate(Bundle savedInstanceState)&lt;/code&gt; メソッドでは、後者の場合は不要なnullチェックを指定する必要があることです。 他の回答にはすでにコードスニペットがあります。 あなたはそれらを参照することができます。</target>
        </trans-unit>
        <trans-unit id="b96bc533da5dba9c055df06b23a9dfe3465313ce" translate="yes" xml:space="preserve">
          <source>Browsing across all these threads, I suspect that much of the time developers are talking about these two different issues simultaneously ... hence all the confusion and reports of &quot;this doesn't work for me&quot;.</source>
          <target state="translated">これらすべてのスレッドを閲覧していると、多くの場合、開発者はこれら2つの異なる問題について同時に話しているのではないかと疑ってしまいます......それゆえに、すべての混乱や「これは私のために動作しません」という報告があります。</target>
        </trans-unit>
        <trans-unit id="35c8e7cb5407b863eb1e734effa085a8ef96b4f5" translate="yes" xml:space="preserve">
          <source>But consider this if a user presses the back button. It is assumed that the user does not intend to come back to the Activity, hence in this case &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; will not be invoked by the system.
Point being you should consider all the scenarios while saving data.</source>
          <target state="translated">ただし、ユーザーが戻るボタンを押した場合は、これを考慮してください。 ユーザーがアクティビティに戻るつもりはないと想定されているため、この場合、 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; はシステムによって呼び出されません。 ポイントは、データを保存するときにすべてのシナリオを考慮する必要があるということです。</target>
        </trans-unit>
        <trans-unit id="6cd192f3540cecdd5c288fd84d4b2b87990d9acc" translate="yes" xml:space="preserve">
          <source>By default System saves the View objects in the Bundle for example.</source>
          <target state="translated">デフォルトでは、Systemはビューオブジェクトを例えばバンドルに保存します。</target>
        </trans-unit>
        <trans-unit id="bab0ae1b477f7f1414851f1db2b6c48cb2fc0979" translate="yes" xml:space="preserve">
          <source>Configuration changes such as changing the orientation or phone language which may requires a new activity instance to be created.</source>
          <target state="translated">向きや電話の言語を変更するなどの設定変更は、新しいアクティビティのインスタンスを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="c5e30d4ee8619bf7e71388dcf18fd6c8cd7ae045" translate="yes" xml:space="preserve">
          <source>Demo on default behavior</source>
          <target state="translated">デフォルト動作のデモ</target>
        </trans-unit>
        <trans-unit id="ca5ab99ed4306f5101f437d71e563719d4d391d8" translate="yes" xml:space="preserve">
          <source>Doing something like this with Icepick:</source>
          <target state="translated">アイスピックでこんなことをして</target>
        </trans-unit>
        <trans-unit id="70da04e5dacca4f5d54f1e4e3f78086077168591" translate="yes" xml:space="preserve">
          <source>Ever wondered why the text in the &lt;code&gt;EditText&lt;/code&gt; gets saved automatically while an orientation change? Well, this answer is for you.</source>
          <target state="translated">&lt;code&gt;EditText&lt;/code&gt; のテキストが方向が変更されているときに自動的に保存されるのはなぜだろうと思ったことはありませんか？ さて、この答えはあなたのためです。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="f5d1834f3a0a2883e81e95e8e044ed16af7814f5" translate="yes" xml:space="preserve">
          <source>First, create an interface that will be used to annotate your instance variables:</source>
          <target state="translated">まず、インスタンス変数のアノテーションに使用するインターフェースを作成します。</target>
        </trans-unit>
        <trans-unit id="9275071ec8c082fb5939a220a4c806fb676f22cc" translate="yes" xml:space="preserve">
          <source>First, setup the library in &lt;code&gt;app/build.gradle&lt;/code&gt;</source>
          <target state="translated">まず、 &lt;code&gt;app/build.gradle&lt;/code&gt; にライブラリをセットアップします</target>
        </trans-unit>
        <trans-unit id="e894382ce8ee326bfc00b4ae1a6d8cd2b2e49c1a" translate="yes" xml:space="preserve">
          <source>First, to clarify the 'intended' behavior: onSaveInstance and onRestoreInstance are fragile and only for transient state. The intended usage (afaict) is to handle Activity recreation when the phone is rotated (orientation change). In other words, the intended usage is when your Activity is still logically 'on top', but still must be reinstantiated by the system. The saved Bundle is not persisted outside of the process/memory/gc, so you cannot really rely on this if your activity goes to the background. Yes, perhaps your Activity's memory will survive its trip to the background and escape GC, but this is not reliable (nor is it predictable).</source>
          <target state="translated">まず、「意図した」動作を明確にするために、onSaveInstance と onRestoreInstance は脆弱性があり、過渡的な状態でしか使えません。意図された使い方とは、携帯電話を回転させたとき(向きが変わったとき)に Activity を再作成するためのものです。言い換えれば、意図された使用法は、アクティビティが論理的にはまだ「上にある」が、システムによって再構築されなければならない場合です。保存されたバンドルはprocessmemorygcの外には保存されませんので、アクティビティがバックグラウンドになってしまった場合、これに頼ることはできません。はい、おそらくあなたのアクティビティのメモリはバックグラウンドへの旅を生き延びてGCを逃れるでしょうが、これは信頼できません(予測可能でもありません)。</target>
        </trans-unit>
        <trans-unit id="64f2c7bb37c16a6a0039e3494222014af8f41b08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int currentScore&lt;/code&gt; in a GameActivity</source>
          <target state="translated">たとえば、GameActivityの &lt;code&gt;int currentScore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db598030521045d15ff8dae6d7226e2afcef7edc" translate="yes" xml:space="preserve">
          <source>For more long lived state, consider using a SQLite database, a file, or preferences.  See &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#SavingPersistentState&quot;&gt;Saving Persistent State&lt;/a&gt;.</source>
          <target state="translated">より長持ちする状態については、SQLiteデータベース、ファイル、または設定の使用を検討してください。 &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#SavingPersistentState&quot;&gt;永続的な状態の保存を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c2eba4b624aef5e3315520f49f987a708f2e8cf1" translate="yes" xml:space="preserve">
          <source>For more persistence use shared preferences. &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;read this article&lt;/a&gt;</source>
          <target state="translated">持続性を高めるには、共有設定を使用します。 &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;この記事を読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b1d44b58d9c7fd663747ff19bc4bb3d891ed0f7" translate="yes" xml:space="preserve">
          <source>For the above scenario what I have done is that in the manifest I made some changes like this:</source>
          <target state="translated">上記のシナリオのために私が行ったことは、マニフェストの中で私はこのようにいくつかの変更を行ったということです。</target>
        </trans-unit>
        <trans-unit id="749062c95bcca68367075f43cf5f9eca84cfe184" translate="yes" xml:space="preserve">
          <source>Here is a comment from &lt;strong&gt;Steve Moseley&lt;/strong&gt;'s answer (by &lt;strong&gt;ToolmakerSteve&lt;/strong&gt;) that puts things into perspective (in the whole onSaveInstanceState vs onPause, east cost vs west cost saga)</source>
          <target state="translated">これは、物事を視点に置いた&lt;strong&gt;Steve Moseley&lt;/strong&gt;の回答（ToolmakerSteveによる）からのコメントです（onSaveInstanceStateとonPause全体で、東コストと西コストの比較）。</target>
        </trans-unit>
        <trans-unit id="1a5aafd8c6994cde334b97c529424f3538a223f2" translate="yes" xml:space="preserve">
          <source>Home key press behaviour</source>
          <target state="translated">ホームキーの押し方</target>
        </trans-unit>
        <trans-unit id="730b3a40fc65ec321f279a3d9d7b78388355e548" translate="yes" xml:space="preserve">
          <source>How to save an activity state using save instance state</source>
          <target state="translated">save instance stateを使用してアクティビティの状態を保存する方法</target>
        </trans-unit>
        <trans-unit id="99a21a34bbb6452c71f959f0db20b9a7c58d10e2" translate="yes" xml:space="preserve">
          <source>I battled through these threads for hours before I realized that my main issue was this bug, not the intended framework behavior. A great writeup and &lt;del&gt;workaround&lt;/del&gt; (UPDATE: see below) seems to be from user @kaciula in this answer:</source>
          <target state="translated">私の主な問題がこのバグであり、意図されたフレームワークの動作ではないことに気付く前に、私はこれらのスレッドを何時間も戦いました。 素晴らしい記事と &lt;del&gt; 回避策 &lt;/del&gt; （更新：以下を参照）この回答のユーザー@kaciulaからのようです：</target>
        </trans-unit>
        <trans-unit id="f2ad0ce289a11cde24e01a98220dd0e6a556deba" translate="yes" xml:space="preserve">
          <source>I believe this is the answer and this works fine for me. Correct me if I am wrong.</source>
          <target state="translated">私はこれが答えであり、これは私のために正常に動作すると信じています。間違っていたら訂正してください。</target>
        </trans-unit>
        <trans-unit id="c88c21f9feae0ff7178652e747f96a57454d58a6" translate="yes" xml:space="preserve">
          <source>I really do not recommend to use second method. Since in one of my experience it was causing half of the device screen black while rotating from portrait to landscape and vice versa.</source>
          <target state="translated">私は本当に2番目の方法を使用することをお勧めしません。私の経験の一つで、それは縦から横に回転している間にデバイスの画面の半分が黒くなる原因となっていたので、その逆もあります。</target>
        </trans-unit>
        <trans-unit id="6a234d5784cfaaa336f8de8adb7d5b12e7d6bb97" translate="yes" xml:space="preserve">
          <source>I think I found the answer. Let me tell what I have done in simple words:</source>
          <target state="translated">答えがわかったような気がします。私がしてきたことを簡単な言葉で語らせてください。</target>
        </trans-unit>
        <trans-unit id="d77e2f866a1e4f7218688b101ed8ed15b8edb6b8" translate="yes" xml:space="preserve">
          <source>I thought it would be enough for the simplest case, but it always responds with the first message, no matter how I navigate away from the app.</source>
          <target state="translated">一番シンプルなケースで十分だと思っていたのですが、どうやってアプリから離れてナビゲートしても、いつも最初のメッセージで返信してきます。</target>
        </trans-unit>
        <trans-unit id="9e6b9d43774c9c46f68431bb26579c42c30202fc" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;onSaveInstanceState&lt;/code&gt;and &lt;code&gt;onRestoreInstanceState&lt;/code&gt; as suggested above but I guess i could also or alternatively use my method to save the variable when it changes (e.g. using &lt;code&gt;putBoolean&lt;/code&gt;)</source>
          <target state="translated">上記のように &lt;code&gt;onSaveInstanceState&lt;/code&gt; と &lt;code&gt;onRestoreInstanceState&lt;/code&gt; を使用していますが、変数が変更されたときに（たとえば &lt;code&gt;putBoolean&lt;/code&gt; を使用して）変数を保存するためにメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="76a314ac895f1f34c454a7f19973a5048239551e" translate="yes" xml:space="preserve">
          <source>I'm sure the solution is as simple as overriding &lt;code&gt;onPause&lt;/code&gt; or something like that, but I've been poking away in the documentation for 30 minutes or so and haven't found anything obvious.</source>
          <target state="translated">ソリューションは &lt;code&gt;onPause&lt;/code&gt; またはそのようなものをオーバーライドするのと同じくらい簡単であると確信していますが、ドキュメントを30分ほど探し続けており、明らかなものは何も見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="ddecbedea0def1107a0a3a5048dec1201be09a90" translate="yes" xml:space="preserve">
          <source>I've been working on the Android SDK platform, and it is a little unclear how to save an application's state. So given this minor re-tooling of the 'Hello, Android' example:</source>
          <target state="translated">私はAndroid SDKプラットフォームで仕事をしてきましたが、アプリケーションの状態を保存する方法が少し不明瞭です。そこで、'Hello,Android' の例のこのマイナーなリツールを与えられました。</target>
        </trans-unit>
        <trans-unit id="75fceb7e8de11f7e552300d6e3d417d93b26bbb7" translate="yes" xml:space="preserve">
          <source>Icepick can also generate the instance state code for custom Views:</source>
          <target state="translated">Icepickは、カスタムビューのインスタンス状態コードを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="9dbe5f85a41ab77aa42247c4ed3c82c2ca80a4e7" translate="yes" xml:space="preserve">
          <source>Icepick will work with any object that saves its state with a &lt;code&gt;Bundle&lt;/code&gt;.</source>
          <target state="translated">Icepickは、 &lt;code&gt;Bundle&lt;/code&gt; で状態を保存するすべてのオブジェクトで機能します。</target>
        </trans-unit>
        <trans-unit id="517a95f6798caf61fcd445878cad66a564d72f42" translate="yes" xml:space="preserve">
          <source>If you need another variable to be saved as a part of instance state you should &lt;strong&gt;OVERRIDE&lt;/strong&gt;&lt;code&gt;onSavedInstanceState(Bundle savedinstaneState)&lt;/code&gt; method.</source>
          <target state="translated">別の変数をインスタンス状態の一部として保存する必要がある場合は、 &lt;code&gt;onSavedInstanceState(Bundle savedinstaneState)&lt;/code&gt; メソッドを&lt;strong&gt;オーバーライド&lt;/strong&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c944080c2e6bce35a74fa1594e1a83ea91dbccd" translate="yes" xml:space="preserve">
          <source>If you save the state data in a persistent manner, it can be reloaded in an &lt;code&gt;onResume()&lt;/code&gt; or &lt;code&gt;onCreate()&lt;/code&gt; (or actually on any lifecycle call). This may or may not be desired behaviour. If you store it in a bundle in an &lt;code&gt;InstanceState&lt;/code&gt;, then it is transient and is only suitable for storing data for use in the same user &amp;lsquo;session&amp;rsquo; (I use the term session loosely) but not between &amp;lsquo;sessions&amp;rsquo;.</source>
          <target state="translated">状態データを永続的に保存すると、 &lt;code&gt;onResume()&lt;/code&gt; または &lt;code&gt;onCreate()&lt;/code&gt; （または実際には任意のライフサイクル呼び出し）で再ロードできます。 これは望ましい動作である場合とそうでない場合があります。 &lt;code&gt;InstanceState&lt;/code&gt; のバンドルに保存する場合、それは一時的なものであり、同じユーザーの「セッション」で使用するデータを保存するのにのみ適しています（私は「セッション」という用語を大まかに使用します）。</target>
        </trans-unit>
        <trans-unit id="8ad4b28b513d33ae9c7dc4c7a579738551df044a" translate="yes" xml:space="preserve">
          <source>In manifest &lt;code&gt;android:configChanges=&quot;orientation|screenSize&quot;&lt;/code&gt;.</source>
          <target state="translated">マニフェスト &lt;code&gt;android:configChanges=&quot;orientation|screenSize&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5266f3aaddbb67db45817ea009b4ed42c15a5b6a" translate="yes" xml:space="preserve">
          <source>In most cases if you're just pressing home and then launching the app again the activity won't need to be re-created. It already exists in memory so onCreate() won't be called.</source>
          <target state="translated">ほとんどの場合、ホームボタンを押してから再びアプリを起動するだけであれば、アクティビティを再作成する必要はありません。アクティビティはすでにメモリ上に存在しているので、onCreate()は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="2ad9e5f9884ddec3aa54231745e738669a0d7ec6" translate="yes" xml:space="preserve">
          <source>In other words, put your save/restore code for persistent data in &lt;code&gt;onPause()&lt;/code&gt; and &lt;code&gt;onResume()&lt;/code&gt;!</source>
          <target state="translated">つまり、永続データの保存/復元コードを &lt;code&gt;onPause()&lt;/code&gt; および &lt;code&gt;onResume()&lt;/code&gt; に配置します。</target>
        </trans-unit>
        <trans-unit id="b5dbbbcb80aa47d7c86580e11c02bdad1f4b00d4" translate="yes" xml:space="preserve">
          <source>In some way SharedPreferences work similar like Bundles.
And naturally and at first such values have to be read from preferences.</source>
          <target state="translated">ある意味では SharedPreferences はバンドルと似たような働きをします。そして、当然のことながら、最初のうちはそのような値をプリファレンスから読み込まなければなりません。</target>
        </trans-unit>
        <trans-unit id="77c287bc0253e852d1896406c1926722161c7817" translate="yes" xml:space="preserve">
          <source>In the case of complex data you may use SQLite instead of using preferences.</source>
          <target state="translated">複雑なデータの場合は、環境設定を使用せずにSQLiteを使用することができます。</target>
        </trans-unit>
        <trans-unit id="71100fcc6f3f46f3aa97e956b192f7f4bbbdd94c" translate="yes" xml:space="preserve">
          <source>Instance state is a collection of &lt;strong&gt;key-value&lt;/strong&gt; pairs stored in a &lt;code&gt;Bundle&lt;/code&gt; object.</source>
          <target state="translated">インスタンス状態は、 &lt;code&gt;Bundle&lt;/code&gt; オブジェクトに格納されている&lt;strong&gt;キーと値の&lt;/strong&gt;ペアのコレクションです。</target>
        </trans-unit>
        <trans-unit id="e895203a0cd4ff2ef32040fe5c4ba822821dc215" translate="yes" xml:space="preserve">
          <source>Is the same as doing this:</source>
          <target state="translated">これをやっているのと同じです。</target>
        </trans-unit>
        <trans-unit id="d54ecbfadf837ad212b0092e15eb1dea12e17ec4" translate="yes" xml:space="preserve">
          <source>It is not that one approach is better than the other, like everything, it is just important to understand what behaviour you require and to select the most appropriate approach.</source>
          <target state="translated">何でもそうですが、一つのアプローチが他よりも優れているというわけではなく、自分がどのような行動を求めているのかを理解し、最適なアプローチを選択することが大切なだけなのです。</target>
        </trans-unit>
        <trans-unit id="c4245e3acc2d772effaa7e57af89255710a3d475" translate="yes" xml:space="preserve">
          <source>It should look like this:</source>
          <target state="translated">こんな感じになるはずです。</target>
        </trans-unit>
        <trans-unit id="24af904f2496e7c00485a24dbbcabfc6b3c92acf" translate="yes" xml:space="preserve">
          <source>It works for Activities, Fragments or any object that needs to serialize its state on a Bundle (e.g. mortar's ViewPresenters)</source>
          <target state="translated">これは、アクティビティやフラグメントなど、バンドル上で状態をシリアライズする必要があるオブジェクト(例:モルタルのViewPresenters)に対して動作します。</target>
        </trans-unit>
        <trans-unit id="52c5e33f29f523034bcbe7459d9b211cb9d1aef4" translate="yes" xml:space="preserve">
          <source>It's recommended to let Android handle this for you than the manually handling.</source>
          <target state="translated">手動で処理するよりもAndroidに任せた方がいいですね。</target>
        </trans-unit>
        <trans-unit id="704addd02feecc9f6bcd16d23edb8dbea03f3462" translate="yes" xml:space="preserve">
          <source>Keeping object instances alive in memory between activities within application lifetime using a retained non-configuration instance</source>
          <target state="translated">保持された非構成インスタンスを使用して、アプリケーションのライフタイム内のアクティビティの間にオブジェクトインスタンスをメモリ内で存続させる</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="085096a1896830913423d1a424e00f124559ebde" translate="yes" xml:space="preserve">
          <source>Kotlin code:</source>
          <target state="translated">コトリンコード。</target>
        </trans-unit>
        <trans-unit id="0fc2bf3ef7f1883184381af47c6a31e111a14eda" translate="yes" xml:space="preserve">
          <source>Life cycle graph</source>
          <target state="translated">ライフサイクルグラフ</target>
        </trans-unit>
        <trans-unit id="8ca6212634cffc24cab196f8d0e808011d5f1cb9" translate="yes" xml:space="preserve">
          <source>Meanwhile I do in general no more use</source>
          <target state="translated">一方、私は一般的にこれ以上の使用を行いません</target>
        </trans-unit>
        <trans-unit id="ef8f52e1b40ae0f56a531896c23f4f1189aa7456" translate="yes" xml:space="preserve">
          <source>More detail about the onRestoreInstanceState(Bundle savedinstaneState)</source>
          <target state="translated">onRestoreInstanceState(Bundle savedinstaneState)の詳細情報</target>
        </trans-unit>
        <trans-unit id="cfeb0383f2d85dd601d9702766f8d5350467eb65" translate="yes" xml:space="preserve">
          <source>More detail about the onSavedInstanceState(Bundle savedinstaneState) while saving data</source>
          <target state="translated">データ保存中のonSavedInstanceState(Bundle savedinstaneState)の詳細はこちら</target>
        </trans-unit>
        <trans-unit id="4c844a45d0aa045b41a1e782eb2ce348674c0c79" translate="yes" xml:space="preserve">
          <source>My colleague wrote an article explaining application state on Android devices including explanations on activity lifecycle and state information, how to store state information, and saving to state &lt;code&gt;Bundle&lt;/code&gt; and &lt;code&gt;SharedPreferences&lt;/code&gt; and &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;take a look at here&lt;/a&gt;.</source>
          <target state="translated">私の同僚は、アクティビティのライフサイクルと状態情報の説明、状態情報の保存方法、状態の &lt;code&gt;Bundle&lt;/code&gt; と &lt;code&gt;SharedPreferences&lt;/code&gt; への保存など、Androidデバイスでのアプリケーションの状態を説明する記事を書き、 &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;こちらをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="49325329f0baecd23c4f99c3e845a4775121d762" translate="yes" xml:space="preserve">
          <source>My problem was that I needed persistence only during the application lifetime (i.e. a single execution including starting other sub-activities within the same app and rotating the device etc). I tried various combinations of the above answers but did not get what I wanted in all situations. In the end what worked for me was to obtain a reference to the savedInstanceState during onCreate:</source>
          <target state="translated">私の問題は、アプリケーションのライフタイム中(つまり、同じアプリ内で他のサブアクティビティを開始したり、デバイスを回転させたりすることを含む単一の実行)にのみ永続性が必要なことでした。上記の回答の様々な組み合わせを試してみましたが、すべての状況で私が望むものを得ることはできませんでした。最終的にうまくいったのは、onCreate時にsaveInstanceStateへの参照を取得することでした。</target>
        </trans-unit>
        <trans-unit id="9056c458f0c2df28047ab602793e25b415237362" translate="yes" xml:space="preserve">
          <source>My way is to save any changes immediately in the preferences:</source>
          <target state="translated">私の方法は、環境設定で変更した内容をすぐに保存することです。</target>
        </trans-unit>
        <trans-unit id="4ca8a9c67e5177d3e6fc8210f33c1485ca0b9bc6" translate="yes" xml:space="preserve">
          <source>Not sure if my solution is frowned upon or not, but I use a bound service to persist ViewModel state. Whether you store it in memory in the service or persist and retrieve it from a SQLite database depends on your requirements. This is what services of any flavor do, they provide services such as maintaining application state and abstract common business logic.</source>
          <target state="translated">私の解決策が嫌われているかどうかはわかりませんが、私はバインドされたサービスを使用して ViewModel の状態を永続化しています。それをサービスのメモリに保存するか、SQLite データベースから永続化して取得するかは要件によります。これはどのようなフレーバーのサービスであっても、アプリケーションの状態を維持したり、抽象的な一般的なビジネスロジックを提供するなどのサービスを提供しています。</target>
        </trans-unit>
        <trans-unit id="c7f1130942e0e91dd7a38fc7fdb7894bebd63cb7" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; safe to use &lt;code&gt;onSaveInstanceState&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState&lt;/code&gt;&lt;strong&gt;for persistent data&lt;/strong&gt;, according to the documentation on Activity states in &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html&quot;&gt;http://developer.android.com/reference/android/app/Activity.html&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html&quot;&gt;http://developer.android.com/reference/android/app/Activity.htmlの&lt;/a&gt;アクティビティの状態に関するドキュメントによると、 &lt;strong&gt;永続データに&lt;/strong&gt; &lt;code&gt;onSaveInstanceState&lt;/code&gt; と &lt;code&gt;onRestoreInstanceState&lt;/code&gt; を使用するのは安全では&lt;strong&gt;&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="09b63f649bd2ace083fd36fd2d9645d7e1e062c1" translate="yes" xml:space="preserve">
          <source>Note that it is important to save
  persistent data in &lt;code&gt;onPause()&lt;/code&gt; instead
  of &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt;
  because the later is not part of the
  lifecycle callbacks, so will not be
  called in every situation as described
  in its documentation.</source>
          <target state="translated">永続データは &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt; &lt;code&gt;onPause()&lt;/code&gt; ではなくonPause（）に保存することが重要です。 後者はライフサイクルコールバックの一部ではないため、ドキュメントで説明されているように、すべての状況で呼び出されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="0cb77d78680ec1ed5c4f901d861924bfa8c5521f" translate="yes" xml:space="preserve">
          <source>Now Android provides &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot;&gt;ViewModels&lt;/a&gt; for saving state, you should try to use that instead of saveInstanceState.</source>
          <target state="translated">Androidは状態を保存するための&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot;&gt;ViewModel&lt;/a&gt;を提供するようになったので、saveInstanceStateの代わりにそれを使用してみてください。</target>
        </trans-unit>
        <trans-unit id="a6da74abf95feae94e84fd2b5395c0db821fd4e2" translate="yes" xml:space="preserve">
          <source>Now it makes sense to do 2 ways in the view model.
if you want to save the first as a saved instance:
You can add state parameter in view model like this
&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&quot;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&lt;/a&gt;</source>
          <target state="translated">ここで、ビューモデルで2つの方法を実行することには意味があります。 最初のものを保存済みインスタンスとして保存したい場合： &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&quot;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#javaの&lt;/a&gt;ようなビューモデルに状態パラメーターを追加できます。</target>
        </trans-unit>
        <trans-unit id="9b482d346c633ff146bd076c14488a78af33e811" translate="yes" xml:space="preserve">
          <source>Now what will happen is that whatever the changes we have made in the activity2 will not be lost, and we can view activity2 in the same state as we left previously.</source>
          <target state="translated">これで何が起こるかというと、アクティビティ2で行った変更が失われることはなく、以前と同じ状態でアクティビティ2を表示することができるようになります。</target>
        </trans-unit>
        <trans-unit id="6a14112d48e19613c3dddbf7368e0ce1363a59c2" translate="yes" xml:space="preserve">
          <source>Now, let's check this example below how to save state in Activity</source>
          <target state="translated">では、以下の例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="de3fb34c55a00a9d41d70d0999f54c3a74a48ce0" translate="yes" xml:space="preserve">
          <source>Or from a fragment.</source>
          <target state="translated">あるいは断片から。</target>
        </trans-unit>
        <trans-unit id="06f2b17c80b04fc3bba81b7225ec80e78e29e10a" translate="yes" xml:space="preserve">
          <source>Quote from the docs:
&quot;This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.&quot;
&lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;Source&lt;/a&gt;</source>
          <target state="translated">ドキュメントからの引用：「このメソッドは、アクティビティが強制終了される前に呼び出されるので、しばらくして戻ってきたときに状態を復元できます。」 &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;ソース&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c84792233bf30b1abaae84c3f316f8fbe417b1c" translate="yes" xml:space="preserve">
          <source>Really &lt;code&gt;onSaveInstanceState()&lt;/code&gt; is called when the Activity goes to background.</source>
          <target state="translated">実際には、アクティビティがバックグラウンドになると &lt;code&gt;onSaveInstanceState()&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d79dfdc86ed9cf9d397fe92b6c3592f64052891a" translate="yes" xml:space="preserve">
          <source>Relevant links:</source>
          <target state="translated">関連リンク。</target>
        </trans-unit>
        <trans-unit id="6bc7c4f49193a935253737078f1eac07e7695587" translate="yes" xml:space="preserve">
          <source>Retrieve variables</source>
          <target state="translated">変数の取得</target>
        </trans-unit>
        <trans-unit id="9c6aa369a89289d712f7f69e210ed82b581ea4eb" translate="yes" xml:space="preserve">
          <source>Saving state is a kludge at best as far as I'm concerned. If you need to save persistent data, just use an &lt;a href=&quot;http://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt; database. Android makes it &lt;strong&gt;&lt;em&gt;SOOO&lt;/em&gt;&lt;/strong&gt; easy.</source>
          <target state="translated">状態を保存することは、私に関する限り、せいぜい怠惰です。 永続的なデータを保存する必要がある場合は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt;データベースを使用してください。 Androidを&lt;strong&gt;&lt;em&gt;使え&lt;/em&gt;&lt;/strong&gt;ば、 &lt;strong&gt;&lt;em&gt;とても&lt;/em&gt;&lt;/strong&gt;簡単です。</target>
        </trans-unit>
        <trans-unit id="c92afff79b309ecaa8f3fe0482edd2968fbf8d97" translate="yes" xml:space="preserve">
          <source>Scroll position in a &lt;code&gt;ListView&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;ListView&lt;/code&gt; などでのスクロール位置</target>
        </trans-unit>
        <trans-unit id="a4ff04dedc4cda4bdb4655b6ebd20bec6039d37d" translate="yes" xml:space="preserve">
          <source>Simple quick to solve this problem is using &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;IcePick&lt;/a&gt;</source>
          <target state="translated">この問題を簡単にすばやく解決するには、 &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;IcePick&lt;/a&gt;を使用します</target>
        </trans-unit>
        <trans-unit id="88250f8b9af03b6fc0ff4db55effd8286a4f44ac" translate="yes" xml:space="preserve">
          <source>So by mistake if you forget to call
  &lt;code&gt;super.onSaveInstanceState(savedInstanceState);&lt;/code&gt;the default behavior
  will not work ie Text in EditText will not save.</source>
          <target state="translated">したがって、誤って &lt;code&gt;super.onSaveInstanceState(savedInstanceState);&lt;/code&gt; を呼び出すのを忘れた場合は、 デフォルトの動作は機能しません。つまり、EditTextのテキストは保存されません。</target>
        </trans-unit>
        <trans-unit id="b324a6316fa2e8039900ea43f658e28a4fe7d144" translate="yes" xml:space="preserve">
          <source>So if you have a scenario where there is meaningful 'user progress' or state that should be persisted between 'launches' of your application, the guidance is to use onPause and onResume. You must choose and prepare a persistent store yourself.</source>
          <target state="translated">そのため、アプリケーションの「起動」の間に意味のある「ユーザーの進行状況」や状態が永続化されるべきシナリオがある場合、ガイダンスは onPause と onResume を使用することです。永続ストアは自分で選択して用意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a8c9cecf78e1520d6f30aa06c477eda5abb1c29" translate="yes" xml:space="preserve">
          <source>Something like this:</source>
          <target state="translated">こんな感じです。</target>
        </trans-unit>
        <trans-unit id="ed8609f2ffac41c2767325a80fa34324e524d978" translate="yes" xml:space="preserve">
          <source>Store local variable/UI control data between application instances (i.e. permanently) using shared preferences</source>
          <target state="translated">共有環境設定を使用して、アプリケーションインスタンス間で(永久に)ローカル変数UIコントロールデータを保存します。</target>
        </trans-unit>
        <trans-unit id="1a601715666f11c667d333b1717a4c4b643c5c6a" translate="yes" xml:space="preserve">
          <source>Store local variable/UI control data for application lifetime (i.e. temporarily) using an instance state bundle</source>
          <target state="translated">インスタンス状態バンドルを使用して、アプリケーションの寿命のために(つまり一時的に)ローカル変数UI制御データを保存します。</target>
        </trans-unit>
        <trans-unit id="d652780d2ed12cc566103890d1ad4dfb3b59c3f0" translate="yes" xml:space="preserve">
          <source>Store variables</source>
          <target state="translated">変数を保存する</target>
        </trans-unit>
        <trans-unit id="21d3c43c3d2a040a19e4fdd5af7ebdb60fbc8672" translate="yes" xml:space="preserve">
          <source>Suppose I have two activities, activity1 and activity2 and I am navigating from activity1 to activity2 (I have done some works in activity2) and again back to activity 1 by clicking on a button in activity1. Now at this stage I wanted to go back to activity2 and I want to see my activity2 in the same condition when I last left activity2.</source>
          <target state="translated">アクティビティ1とアクティビティ2の2つのアクティビティがあり、アクティビティ1からアクティビティ2に移動し(アクティビティ2でいくつかの作業をした)、アクティビティ1のボタンをクリックして再びアクティビティ1に戻ったとします。さて、この段階で私は活動2に戻りたいと思い、最後に活動2を離れた時と同じ状態で活動2を見たいと思います。</target>
        </trans-unit>
        <trans-unit id="9cd72c21a0b2397e877a53b771b57cc3db27e1a3" translate="yes" xml:space="preserve">
          <source>Text in &lt;code&gt;EditText&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EditText&lt;/code&gt; のテキスト</target>
        </trans-unit>
        <trans-unit id="5b27ab301625c3ec373095ab68b695692c5d22e9" translate="yes" xml:space="preserve">
          <source>The 'normal' or intended way to manage this issue is, itself, rather complicated with the duality of onPause/onResume and onSaveInstanceState/onRestoreInstanceState</source>
          <target state="translated">この問題を管理するための「通常の」または意図された方法は、それ自体が onPauseonResume と onSaveInstanceStateonRestoreInstanceState の二重性を持っており、かなり複雑です。</target>
        </trans-unit>
        <trans-unit id="fdf846da153619f6f5b3e0c470032b5a1b71f8a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; is invoked by the system only when the user intends to come back to the Activity. For example, you are using App X and suddenly you get a call. You move to the caller app and come back to the app X. In this case the &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method will be invoked.</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; は、ユーザーがアクティビティに戻る予定がある場合にのみシステムによって呼び出されます。 たとえば、App Xを使用していて、突然電話がかかってきたとします。 呼び出し元のアプリに移動し、アプリXに戻ります。この場合、 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; メソッドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3136e1e0ea08c82d036d55e752142051b9080e2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSaveInstanceState(bundle)&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; methods are useful for data persistence merely while rotating the screen (orientation change).</source>
          <target state="translated">&lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; メソッドとonRestoreInstanceState（bundle）メソッドは、画面を回転している間（向きの変更）だけのデータ永続化に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bfef643ce37d4fad3767445c87484ad25499c8fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savedInstanceState&lt;/code&gt; is only for saving state associated with a current instance of an Activity, for example current navigation or selection info, so that if Android destroys and recreates an Activity, it can come back as it was before.  See the documentation for &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)&quot;&gt;&lt;code&gt;onCreate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;&lt;code&gt;onSaveInstanceState&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;savedInstanceState&lt;/code&gt; は、アクティビティの現在のインスタンス（現在のナビゲーションや選択情報など）に関連付けられた状態を保存するためだけのものであるため、Androidがアクティビティを破棄して再作成した場合、以前の状態に戻ることができます。 &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)&quot;&gt; &lt;code&gt;onCreate&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt; &lt;code&gt;onSaveInstanceState&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください</target>
        </trans-unit>
        <trans-unit id="7d3ce1e986fa6d341b2ac89952e63610b8bc7685" translate="yes" xml:space="preserve">
          <source>The Bundle is essentially a way of storing a NVP (&quot;Name-Value Pair&quot;) map, and it will get passed in to &lt;code&gt;onCreate()&lt;/code&gt; and also &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; where you would then extract the values from activity like this:</source>
          <target state="translated">バンドルは基本的にNVP（「名前と値のペア」）マップを格納する方法であり、 &lt;code&gt;onCreate()&lt;/code&gt; と &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; に渡され、次のようなアクティビティから値を抽出します。</target>
        </trans-unit>
        <trans-unit id="2b91d9e1904f244273815d75b9a180a3999ad78b" translate="yes" xml:space="preserve">
          <source>The article covers three approaches:</source>
          <target state="translated">記事では3つのアプローチを取り上げています。</target>
        </trans-unit>
        <trans-unit id="59994bcb0211e26e361677612a25b82f6263a391" translate="yes" xml:space="preserve">
          <source>The document states (in the 'Activity Lifecycle' section):</source>
          <target state="translated">この文書には、(「活動のライフサイクル」の項で)記載されています。</target>
        </trans-unit>
        <trans-unit id="e5c715e503afb2e388c5e07bc7beb922e01cf21e" translate="yes" xml:space="preserve">
          <source>The life cycle is for most activities too complicated and not necessary.</source>
          <target state="translated">ライフサイクルは、ほとんどの活動にとって、あまりにも複雑で必要のないものです。</target>
        </trans-unit>
        <trans-unit id="e03abf264ad09fe480d3645d0ad3e6c80d18a3ac" translate="yes" xml:space="preserve">
          <source>The other answers are valuable in that they teach you the correct ways to store state but I didn't feel they really answered WHY your code wasn't working in the way you expected.</source>
          <target state="translated">他の回答は、状態を格納するための正しい方法を教えてくれるという点では貴重なものですが、あなたのコードが期待した通りに動作しない理由については、本当に答えてくれているとは感じませんでした。</target>
        </trans-unit>
        <trans-unit id="ea853c5dbb9b05a675dbf62467c34a0c9ed85dc1" translate="yes" xml:space="preserve">
          <source>The user switches application and then comes back to the original and wants to pick up where they left off -  save and restore bundle data (such as application state data) in &lt;code&gt;onSaveInstanceState()&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; is usually adequate.</source>
          <target state="translated">ユーザーがアプリケーションを切り替えてから元の状態に &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 、 中断したところから &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 場合-通常、 onSaveInstanceState（）とonRestoreInstanceState（）でバンドルデータ（アプリケーションの状態データなど）を保存して復元すれば十分です。</target>
        </trans-unit>
        <trans-unit id="664f7f6cd00e964bf2ece8284a1a16728a7165a9" translate="yes" xml:space="preserve">
          <source>The user terminates the application and re-opens it at a later date, but the application needs to reload data from the last session &amp;ndash; this requires a persistent storage approach such as using SQLite.</source>
          <target state="translated">ユーザーはアプリケーションを終了し、後日再オープンしますが、アプリケーションは最後のセッションからデータを再ロードする必要があります。これには、SQLiteを使用するなどの永続的なストレージアプローチが必要です。</target>
        </trans-unit>
        <trans-unit id="fbab7ef755b952309a2b4daa899a7fc7a56700a0" translate="yes" xml:space="preserve">
          <source>Then, create a class where reflection will be used to save values to the bundle:</source>
          <target state="translated">次に、バンドルに値を保存するためにリフレクションを使用するクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="e05c399bd3b713fd14819c61025cf239cdc9f4a3" translate="yes" xml:space="preserve">
          <source>There are basically two ways to implement this change.</source>
          <target state="translated">この変更を実施するには、基本的に2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="7d0e409673cec86fa043a7ead7b9881a2eb5036f" translate="yes" xml:space="preserve">
          <source>There is a subtle Android Framework bug which greatly complicates application stack management during development, at least on legacy versions (not entirely sure if/when/how it was fixed). I'll discuss this bug below.</source>
          <target state="translated">Android Framework の微妙なバグがあり、少なくともレガシーバージョンでは、開発中のアプリケーションスタック管理を大幅に複雑にしています (いつどのように修正されたのかは完全にはわかりません)。以下にこのバグについて説明します。</target>
        </trans-unit>
        <trans-unit id="46ad321e7ce6bd857daf8414afc19b0370ddb6b9" translate="yes" xml:space="preserve">
          <source>There is a way to make Android save the states without implementing any method. Just add this line to your Manifest in Activity declaration:</source>
          <target state="translated">メソッドを実装せずにAndroidに状態を保存させる方法があります。Manifest in Activity宣言にこの行を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="692777a292ae320362294cca80a4d6f9cccf34cf" translate="yes" xml:space="preserve">
          <source>There is an option under Settings -&amp;gt; Developer Options called &quot;Don't keep activities&quot;. When it's enabled Android will always destroy activities and recreate them when they're backgrounded. This is a great option to leave enabled when developing because it simulates the worst case scenario. ( A low memory device recycling your activities all the time ).</source>
          <target state="translated">[設定]-&amp;gt; [開発者向けオプション]の下に、[アクティビティを保持しない]というオプションがあります。 有効にすると、Androidは常にアクティビティを破棄し、バックグラウンドでそれらを再作成します。 これは最悪のシナリオをシミュレートするため、開発時に有効のままにしておくのに最適なオプションです。 （常にあなたの活動をリサイクルする低メモリデバイス）。</target>
        </trans-unit>
        <trans-unit id="7bea05f76049cfe844c159e008e33b3cdad15d15" translate="yes" xml:space="preserve">
          <source>They are not even good while switching between applications (since the &lt;code&gt;onSaveInstanceState()&lt;/code&gt; method is called but &lt;code&gt;onCreate(bundle)&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; is not invoked again.</source>
          <target state="translated">アプリケーションの切り替え中は、 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; メソッドが呼び出されても、 &lt;code&gt;onCreate(bundle)&lt;/code&gt; および &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; が再度呼び出されないため、 これらは適切ではありません。</target>
        </trans-unit>
        <trans-unit id="2ba2aa884fd631b75bfa3cea504f24ca026a10a3" translate="yes" xml:space="preserve">
          <source>This approach gives you the added bonus of enforcing the Separation of Concern design principle in that all of you application business logic can be moved into your service which reduces duplicated logic across multiple views and allows the view to enforce another important design principle, Single Responsibility.</source>
          <target state="translated">このアプローチでは、すべてのアプリケーションのビジネスロジックをサービスに移動させることができるので、複数のビューにまたがる重複したロジックを減らし、もう一つの重要な設計原則である単一責任を実施することができるという点で、「懸念の分離」設計原則を実施するという付加的なボーナスが得られます。</target>
        </trans-unit>
        <trans-unit id="1c26216b14217a3380648c7ae8c9e34dc0e4f79b" translate="yes" xml:space="preserve">
          <source>This is a classic 'gotcha' of Android development. There are two issues here:</source>
          <target state="translated">これはAndroid開発の典型的な「ガチャ」です。ここには2つの問題があります。</target>
        </trans-unit>
        <trans-unit id="e54d3b795eaa3a1ea1ebc0c9870580be1ebc7d60" translate="yes" xml:space="preserve">
          <source>This method is called before an activity may be killed so that when it
  comes back some time in the future it can restore its state. For
  example, if activity B is launched in front of activity A, and at some
  point activity A is killed to reclaim resources, activity A will have
  a chance to save the current state of its user interface via this
  method so that when the user returns to activity A, the state of the
  user interface can be restored via &lt;code&gt;onCreate(Bundle)&lt;/code&gt; or
  &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt;.</source>
          <target state="translated">このメソッドは、アクティビティが強制終了される前に呼び出されるため、アクティビティがいつか戻ったときに、その状態を復元できます。 たとえば、アクティビティBがアクティビティAの前で起動され、ある時点でアクティビティAがリソースを再利用するために強制終了された場合、アクティビティAは、このメソッドを介してユーザーインターフェイスの現在の状態を保存できるため、ユーザーが戻ったときにアクティビティAでは、ユーザーインターフェイスの状態を &lt;code&gt;onCreate(Bundle)&lt;/code&gt; または &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt; で復元できます。</target>
        </trans-unit>
        <trans-unit id="b4d6a7f29f8cc604160d04f5aa0b3c33d5a3b946" translate="yes" xml:space="preserve">
          <source>To answer the original question directly. savedInstancestate is null because your Activity is never being re-created.</source>
          <target state="translated">元の質問に直接答えるためには、あなたのアクティビティが再作成されることはないので、savedInstancestateはnullです。</target>
        </trans-unit>
        <trans-unit id="ec9f8b80524ada5a79eb7a16caabdaee5b0a16b9" translate="yes" xml:space="preserve">
          <source>To get activity state data stored in &lt;code&gt;onCreate()&lt;/code&gt;, first you have to save data in savedInstanceState by overriding &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;onCreate()&lt;/code&gt; に保存されているアクティビティ状態データを取得するには、まず &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; メソッドをオーバーライドして、savedInstanceStateにデータを保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="24e60a573f56cb1eba94bf31112b60354733fdc2" translate="yes" xml:space="preserve">
          <source>To help reduce boilerplate I use the following &lt;code&gt;interface&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; to read/write to a &lt;code&gt;Bundle&lt;/code&gt; for saving instance state.</source>
          <target state="translated">ボイラープレートを削減するために、インスタンスの状態を保存するために、次の &lt;code&gt;interface&lt;/code&gt; と &lt;code&gt;class&lt;/code&gt; を使用して、 &lt;code&gt;Bundle&lt;/code&gt; 読み取り/書き込みを行います。</target>
        </trans-unit>
        <trans-unit id="9fe0ffe2fbabae926ca82b75532206413f6d13cf" translate="yes" xml:space="preserve">
          <source>Using first method mentioned above , we can persist data when orientation is changed or any config change happens.
I know a way in which you can store any type of data inside savedInstance state object.</source>
          <target state="translated">上記の最初のメソッドを使えば、方向が変わった時や設定変更があった時にデータを保持することができます。これを利用して、任意のタイプのデータをsavedInstanceの状態オブジェクトに保存する方法を知っています。</target>
        </trans-unit>
        <trans-unit id="708a9360bf26e47c630bb82671e52c1cb996099e" translate="yes" xml:space="preserve">
          <source>What to save and what not to?</source>
          <target state="translated">何を貯めて何を貯めないのか?</target>
        </trans-unit>
        <trans-unit id="5b3a304deee10af08a21c6160599ddf1fb716ab9" translate="yes" xml:space="preserve">
          <source>When activity destroy &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method gets called and there you save data you want to save. And you get same in &lt;code&gt;onCreate()&lt;/code&gt; when activity restart.(savedInstanceState wont be null since you have saved some data in it before activity get destroyed)</source>
          <target state="translated">アクティビティが &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; メソッドを破棄すると、保存したいデータが保存されます。 そして、アクティビティの再開時に &lt;code&gt;onCreate()&lt;/code&gt; でも同じになります（アクティビティが破棄される前にデータを保存してあるので、savedInstanceStateはnullになりません）。</target>
        </trans-unit>
        <trans-unit id="fe000ca18fed19c86b29988523117d0fa3476fba" translate="yes" xml:space="preserve">
          <source>When an activity is created it's  onCreate() method is called.</source>
          <target state="translated">アクティビティが作成されると、onCreate()メソッドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7037321aeffdd9ea93756424ab6c502f36f7cda5" translate="yes" xml:space="preserve">
          <source>When an instance of an Activity gets destroyed and the System recreates a new instance (for example, configuration change). It tries to recreate it using a set of saved data of old Activity State (&lt;strong&gt;instance state&lt;/strong&gt;).</source>
          <target state="translated">アクティビティのインスタンスが破棄され、システムが新しいインスタンスを再作成したとき（構成の変更など）。 古いアクティビティ状態（ &lt;strong&gt;インスタンス状態&lt;/strong&gt; ）の保存されたデータのセットを使用して、それを再作成しようとし&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1397a30190c4c1451dd4205b7628110696a74a5" translate="yes" xml:space="preserve">
          <source>When applying this concept, the activity just continues to use the last saved state, regardless of whether it was an initial open with reboots in between or a reopen due to the back stack.</source>
          <target state="translated">この概念を適用すると、アクティビティは、間にリブートを挟んだ初期オープンであったか、バックスタックによる再オープンであったかにかかわらず、最後に保存された状態を使用し続けます。</target>
        </trans-unit>
        <trans-unit id="4fa62a378bcd4f7418b39cb8691bbce43dbd3718" translate="yes" xml:space="preserve">
          <source>When testing your hello world example there are a few ways to leave and return to the Activity.</source>
          <target state="translated">ハローワールドの例をテストする際には、アクティビティから離れたり戻ったりする方法がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="523c44f6aa55034d8ae4eedaf908d2bc7ebc117b" translate="yes" xml:space="preserve">
          <source>When you press the back button the Activity is finished. Re-launching the app is a brand new instance. You aren't resuming from the background at all.</source>
          <target state="translated">戻るボタンを押すとアクティビティが終了します。アプリを再起動すると、新しいインスタンスになります。バックグラウンドから再開しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="0245328997efbfaa4a6772efcd662e40be32fd87" translate="yes" xml:space="preserve">
          <source>When you press the home button or use the task switcher the Activity will go into the background. When navigating back to the application onCreate will only be called if the Activity had to be destroyed.</source>
          <target state="translated">ホームボタンを押したり、タスクスイッチャーを使用したりすると、アクティビティはバックグラウンドになります。アプリケーションに戻るときに onCreate が呼び出されるのは、アクティビティが破棄されなければならない場合のみです。</target>
        </trans-unit>
        <trans-unit id="bde74985ade4026a21de660516fb194d30c52a34" translate="yes" xml:space="preserve">
          <source>Which to choose for restoring Activity state?</source>
          <target state="translated">アクティビティの状態を回復させるためには、どちらを選択すればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="15f0fa1f93e4f5096a5df7aa7f2b635d5b2e0451" translate="yes" xml:space="preserve">
          <source>You must override &lt;code&gt;onSaveInstanceState&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState&lt;/code&gt; to store and retrieve your variables you want to be persistent</source>
          <target state="translated">永続化する変数を保存および取得するには、 &lt;code&gt;onSaveInstanceState&lt;/code&gt; および &lt;code&gt;onRestoreInstanceState&lt;/code&gt; をオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="e284dcc6df7a14df80dad493541a1a48c5ccbbed" translate="yes" xml:space="preserve">
          <source>You need to override &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; and write the application state values you want to change to the &lt;code&gt;Bundle&lt;/code&gt; parameter like this:</source>
          <target state="translated">次のように、 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; をオーバーライドして、変更するアプリケーションの状態値を &lt;code&gt;Bundle&lt;/code&gt; パラメータに書き込む必要があります。</target>
        </trans-unit>
        <trans-unit id="aafbe683885219a03d91994f495fe865456fdf92" translate="yes" xml:space="preserve">
          <source>You return to the app from the background after the OS has destroyed the activity.</source>
          <target state="translated">OSがアクティビティを破棄した後、バックグラウンドからアプリに戻ります。</target>
        </trans-unit>
        <trans-unit id="9ee2d3fa32e8a81c76f202907661f73dd44acc09" translate="yes" xml:space="preserve">
          <source>You would usually use this technique to store instance values for your application (selections, unsaved text, etc.).</source>
          <target state="translated">通常、このテクニックを使用してアプリケーションのインスタンス値を保存します(選択範囲、保存されていないテキストなど)。</target>
        </trans-unit>
        <trans-unit id="14cc4f238e05194b2051e422ea411af3ff2c43b9" translate="yes" xml:space="preserve">
          <source>Your Activity will only be re-created with a state bundle when:</source>
          <target state="translated">アクティビティがステートバンドルで再作成されるのは、以下の場合のみです。</target>
        </trans-unit>
        <trans-unit id="401225f701851f15a91db5909f506dd01d4a7299" translate="yes" xml:space="preserve">
          <source>and then in &lt;code&gt;onCreate()&lt;/code&gt; or &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;</source>
          <target state="translated">そして &lt;code&gt;onCreate()&lt;/code&gt; または &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e744c62a1531a7d3816a29a305bdea75e0510e1a" translate="yes" xml:space="preserve">
          <source>and use that to obtain the contents of my variable when I needed it, along the lines of:</source>
          <target state="translated">の行に沿って、必要なときに変数の内容を取得するためにそれを使用します。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="d6d46a9486f34d2a4f4c16c5884630b54d1e5610" translate="yes" xml:space="preserve">
          <source>or you can save variables or object in view model, in this case the view model will hold the life cycle until the activity is destroyed.</source>
          <target state="translated">または、変数やオブジェクトをビューモデルに保存することができます。この場合、ビューモデルはアクティビティが破棄されるまでライフサイクルを保持します。</target>
        </trans-unit>
        <trans-unit id="9b199dd59ffbfb3b2470ec58e2251be7dd34f5cc" translate="yes" xml:space="preserve">
          <source>put your values in &quot;outState&quot; Bundle object like outState.putString(&quot;key&quot;,&quot;Welcome Back&quot;) and save by calling super.
When activity will be destroyed it's state get saved in Bundle object and can be restored after recreation in onCreate() or onRestoreInstanceState(). Bundle received in onCreate() and onRestoreInstanceState() are same.</source>
          <target state="translated">outState.putString(&quot;key&quot;,&quot;Welcome Back&quot;)のように、BundleオブジェクトのoutStateに値を入れて、superを呼んで保存します。アクティビティが破棄されるとBundleオブジェクトに保存され、onCreate()やonRestoreInstanceState()で再作成した後に復元することができます。onCreate()とonRestoreInstanceState()で受け取るバンドルは同じです。</target>
        </trans-unit>
        <trans-unit id="e9bb9c4cea2c1b033a08233a06951da1b1dfe6e2" translate="yes" xml:space="preserve">
          <source>save:</source>
          <target state="translated">save:</target>
        </trans-unit>
        <trans-unit id="4a7cf61c20a4c3cd62e2773efce644abc579ccb4" translate="yes" xml:space="preserve">
          <source>savedInstanceState is an object of Bundle class which is null for the first time, but it contains values when it is recreated. To save Activity's state you have to override onSaveInstanceState().</source>
          <target state="translated">savedInstanceStateはBundleクラスのオブジェクトで、初回はnullですが、再作成時には値が入っています。Activityの状態を保存するにはonSaveInstanceState()をオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="6730c072fe1012f6ae332fca56c1a746e8e87912" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;onSaveInstanceState()&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState()&lt;/code&gt; および &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="96901f983bdf1c877f70d5eee18accdaba69139f" translate="yes" xml:space="preserve">
          <source>you can use the &lt;code&gt;Live Data&lt;/code&gt; and &lt;code&gt;View Model&lt;/code&gt; For L&lt;code&gt;ifecycle Handel&lt;/code&gt; From &lt;code&gt;JetPack&lt;/code&gt;. see this Reference :</source>
          <target state="translated">&lt;code&gt;ifecycle Handel&lt;/code&gt; L ifecycle Handelの &lt;code&gt;Live Data&lt;/code&gt; と &lt;code&gt;View Model&lt;/code&gt; を使用できます。 このリファレンスを参照してください：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
