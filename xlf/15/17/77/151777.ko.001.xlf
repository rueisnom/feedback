<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/151777">
    <body>
      <group id="151777">
        <trans-unit id="b5a6667bdc2651683b8358b3c1f0022acc722ead" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;Android Official Documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle#saras&quot;&gt;안드로이드 공식 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="121e52bb9dabd4a4d593ca4ed61c6d2e1b67c006" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.android.com/guide/topics/resources/runtime-changes&quot;&gt;Here&lt;/a&gt; you can find more information about this property.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/guide/topics/resources/runtime-changes&quot;&gt;여기이&lt;/a&gt; 속성에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09b501ef35b88635149e7d5e913ec8254ab4270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSaveInstanceState()&lt;/code&gt; for transient data (restored in &lt;code&gt;onCreate()&lt;/code&gt;/&lt;code&gt;onRestoreInstanceState()&lt;/code&gt;), &lt;code&gt;onPause()&lt;/code&gt; for persistent data (restored in &lt;code&gt;onResume()&lt;/code&gt;). 
From Android technical resources:</source>
          <target state="translated">임시 데이터의 경우 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; ( &lt;code&gt;onCreate()&lt;/code&gt; / &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 복원 됨 ), 영구 데이터의 경우 &lt;code&gt;onPause()&lt;/code&gt; ( &lt;code&gt;onResume()&lt;/code&gt; 복원 됨 ) Android 기술 리소스에서 :</target>
        </trans-unit>
        <trans-unit id="a2f213488f4ad91a05649b221b4a76f2945e0137" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSaveInstanceState&lt;/code&gt; is called when the system needs memory and kills an application. It is not called when the user just closes the application. So I think application state should also be saved in &lt;code&gt;onPause&lt;/code&gt; It should be saved to some persistent storage like &lt;code&gt;Preferences&lt;/code&gt; or &lt;code&gt;Sqlite&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState&lt;/code&gt; 는 시스템에 메모리가 필요하고 응용 프로그램을 종료 할 때 호출됩니다. 사용자가 응용 프로그램을 닫을 때 호출되지 않습니다. 따라서 응용 프로그램 상태도 &lt;code&gt;onPause&lt;/code&gt; 에 저장되어야한다고 생각합니다 .Preference 또는 &lt;code&gt;Sqlite&lt;/code&gt; 와 같은 영구 저장소에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="c161538435224715d86d657b81f84cc9fbb5adb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example: Consider a case if you want to persist Json object.
create a model class with getters and setters .&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;예 : Json 객체를 유지하려는 경우를 고려하십시오.&lt;/em&gt; &lt;em&gt;getter 및 setter가있는 모델 클래스를 작성하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aaf0364f5e75e39441ec278b941b829b093887b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Now in your activity in onCreate and onSaveInstanceState method do the following. It will look something like this:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이제 onCreate 및 onSaveInstanceState 메소드의 활동에서 다음을 수행하십시오.&lt;/em&gt; &lt;em&gt;다음과 같이 보일 것입니다 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f5a8c84807804c1921f9174da4957c65cc014f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OR&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OR&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a646b9c61792a35986803f119d93b24829a1064d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;: For further clarification, here's the &lt;code&gt;onSaveInstanceState()&lt;/code&gt; documentation:</source>
          <target state="translated">&lt;strong&gt;편집&lt;/strong&gt; : 자세한 설명을 위해 다음은 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 설명서입니다.</target>
        </trans-unit>
        <trans-unit id="531228a2bc0f20f3ac96d63a93c3fdbe017a2e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This code was adapted from a library project named &lt;a href=&quot;https://github.com/CardinalNow/AndroidAutowire&quot;&gt;AndroidAutowire&lt;/a&gt; which is licensed under the &lt;a href=&quot;https://raw.githubusercontent.com/CardinalNow/AndroidAutowire/master/LICENSE&quot;&gt;MIT license&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 코드는 &lt;a href=&quot;https://raw.githubusercontent.com/CardinalNow/AndroidAutowire/master/LICENSE&quot;&gt;MIT 라이센스에&lt;/a&gt; 따라 라이센스가 부여 된 &lt;a href=&quot;https://github.com/CardinalNow/AndroidAutowire&quot;&gt;AndroidAutowire&lt;/a&gt; 라는 라이브러리 프로젝트에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1f9035e2f998c877c4c7c905e5d6ca2f506d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE June 2013&lt;/strong&gt;: Months later, I have finally found the 'correct' solution. You don't need to manage any stateful startedApp flags yourself,  you can detect this from the framework and bail appropriately. I use this near the beginning of my LauncherActivity.onCreate:</source>
          <target state="translated">&lt;strong&gt;2013 년 6 월 업데이트&lt;/strong&gt; : 몇 달 후 마침내 '올바른'솔루션을 찾았습니다. Stateful startedApp 플래그를 직접 관리 할 필요는 없으며 프레임 워크에서이를 감지하여 적절하게 구제 할 수 있습니다. 내 LauncherActivity.onCreate의 시작 부분 근처에서 이것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="34b50dc93d3b4636712893ef0928656dedcdb95d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onPause()&lt;/strong&gt; and &lt;strong&gt;onResume()&lt;/strong&gt; are also complimentary methods. onPause() is always called when the Activity ends, even if we instigated that (with a finish() call for example). We will use this to save the current note back to the database. Good practice is to release any resources that can be released during an onPause() as well, to take up less resources when in the passive state.</source>
          <target state="translated">&lt;strong&gt;onPause ()&lt;/strong&gt; 및 &lt;strong&gt;onResume ()&lt;/strong&gt; 도 무료 메소드입니다. onPause ()는 Activity가 종료 될 때 항상 호출됩니다 (예 : finish () 호출로). 이것을 사용하여 현재 메모를 데이터베이스에 다시 저장합니다. 모범 사례는 onPause () 중에 해제 할 수있는 모든 리소스를 해제하여 수동 상태에있을 때 더 적은 리소스를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="418e187325d12c8b5d58cc6c9697795f2ac77f1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;onSaveInstanceState()&lt;/strong&gt; is called by Android if the Activity is being stopped and may be killed before it is resumed! This means it should store any state necessary to re-initialize to the same condition when the Activity is restarted. It is the counterpart to the onCreate() method, and in fact the savedInstanceState Bundle passed in to onCreate() is the same Bundle that you construct as outState in the onSaveInstanceState() method.</source>
          <target state="translated">&lt;strong&gt;onSaveInstanceState ()&lt;/strong&gt; 는 활동이 중지되고 Android가 다시 시작하기 전에 종료 될 수 있으면 Android에서 호출합니다! 즉, 활동이 다시 시작될 때 동일한 상태로 다시 초기화하는 데 필요한 모든 상태를 저장해야합니다. onCreate () 메소드에 대응되며 실제로 onCreate ()에 전달 된 savedInstanceState 번들은 onSaveInstanceState () 메소드에서 outState로 구성하는 동일한 번들입니다.</target>
        </trans-unit>
        <trans-unit id="60da94f1b7e55dd3b016dadb7fd0b045e76894ff" translate="yes" xml:space="preserve">
          <source>@VVK - I partially disagree. Some ways of exiting an app don't trigger
  onSaveInstanceState (oSIS). This limits the usefulness of oSIS. Its
  worth supporting, for minimal OS resources, but if an app wants to
  return the user to the state they were in, no matter how the app was
  exited, it is necessary to use a persistent storage approach instead.
  &lt;strong&gt;I use onCreate to check for bundle, and if it is missing, then check&lt;/strong&gt;&lt;strong&gt;persistent storage.&lt;/strong&gt; This centralizes the decision making. I can
  recover from a crash, or back button exit or custom menu item Exit, or
  get back to screen user was on many days later. &amp;ndash; ToolmakerSteve Sep
  19 '15 at 10:38</source>
          <target state="translated">@VVK-부분적으로 동의하지 않습니다. 앱을 종료하는 몇 가지 방법은 onSaveInstanceState (oSIS)를 트리거하지 않습니다. 이것은 oSIS의 유용성을 제한합니다. 최소한의 OS 리소스를 지원할 가치가 있지만, 앱이 종료 된 상태에 관계없이 앱이 사용자를 원래 상태로 되돌리려면 영구 저장소 접근 방식을 사용해야합니다. &lt;strong&gt;onCreate를 사용하여 번들을 확인하고 누락 된 경우&lt;/strong&gt; &lt;strong&gt;영구 저장소&lt;/strong&gt; &lt;strong&gt;를 확인하십시오&lt;/strong&gt; &lt;strong&gt;.&lt;/strong&gt; 이것은 의사 결정을 중앙 집중화합니다. 충돌에서 복구하거나 뒤로 버튼 종료 또는 사용자 정의 메뉴 항목 종료를 복구하거나 며칠 후 화면 사용자로 돌아갈 수 있습니다. &amp;ndash; ToolmakerSteve 9 월 19 일 15시 10 분 38 초</target>
        </trans-unit>
        <trans-unit id="acc0ef387cb88068d5d2c8cc5c71a4021ceeef0b" translate="yes" xml:space="preserve">
          <source>A simple call after that</source>
          <target state="translated">그 후 간단한 전화</target>
        </trans-unit>
        <trans-unit id="12b9dbb2aada2ed26b959941246da918089eccee" translate="yes" xml:space="preserve">
          <source>Add default values if you don't want to have Optionals</source>
          <target state="translated">옵션을 원하지 않으면 기본값을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="991c54305f22a2f261d0a09b7e0a862bfc48a980" translate="yes" xml:space="preserve">
          <source>Although the accepted answer is correct, there is a faster and easier method to save the Activity state on Android using a library called &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;Icepick&lt;/a&gt;. Icepick is an annotation processor that takes care of all the boilerplate code used in saving and restoring state for you.</source>
          <target state="translated">허용되는 답변은 정확하지만 &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;Icepick&lt;/a&gt; 이라는 라이브러리를 사용하여 Android에서 활동 상태를 저장하는 더 빠르고 쉬운 방법이 있습니다. Icepick은 상태 저장 및 복원에 사용되는 모든 상용구 코드를 관리하는 주석 처리기입니다.</target>
        </trans-unit>
        <trans-unit id="586a6f24a6dd9d26a13c37c3705aaeab56867cff" translate="yes" xml:space="preserve">
          <source>Always call &lt;code&gt;super.onRestoreInstanceState(savedInstanceState);&lt;/code&gt; so that System restore the View hierarchy by default</source>
          <target state="translated">항상 &lt;code&gt;super.onRestoreInstanceState(savedInstanceState);&lt;/code&gt; 호출하십시오 . 시스템이 기본적으로 View 계층 구조를 복원하도록</target>
        </trans-unit>
        <trans-unit id="8c6424cb3c1d947f3fc1070af0cf32a0ad555cfa" translate="yes" xml:space="preserve">
          <source>And Google states itself, it is NOT even reliable.</source>
          <target state="translated">그리고 구글은 그 자체로는 신뢰할 수 없다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="21e287d983bd99580c83fdef5fecc083561d6b8d" translate="yes" xml:space="preserve">
          <source>And in activity2 on button click event I have done like this:</source>
          <target state="translated">그리고 버튼 클릭 이벤트의 activity2에서 다음과 같이했습니다.</target>
        </trans-unit>
        <trans-unit id="3ddaa9003466a87f649d72b9838364f7478fd978" translate="yes" xml:space="preserve">
          <source>And in the activity1 on the button click event I have done like this:</source>
          <target state="translated">그리고 버튼 클릭 이벤트의 activity1에서 다음과 같이했습니다.</target>
        </trans-unit>
        <trans-unit id="b7d66b4989679ab6f5e706bf1bc385c9b0039dca" translate="yes" xml:space="preserve">
          <source>Android will destroy background activities when under memory pressure or after they've been in the background for an extended period of time.</source>
          <target state="translated">Android는 메모리가 부족하거나 오랜 시간 동안 백그라운드에서 활동 한 후에 백그라운드 활동을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="36bfeab96e58c0402708e52b8b5899a9f71935d2" translate="yes" xml:space="preserve">
          <source>BUT - there is a very confusing bug which complicates all of this. Details are here:</source>
          <target state="translated">그러나이 모든 것을 복잡하게 만드는 매우 혼란스러운 버그가 있습니다. 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc5abfe770ef0c8c7dfa135cc6f4c79eaf5a0f77" translate="yes" xml:space="preserve">
          <source>Basically, if your application is launched with the SingleTask flag, and then later on you launch it from the home screen or launcher menu, then that subsequent invocation will create a NEW task ... you'll effectively have two different instances of your app inhabiting the same stack ... which gets very strange very fast. This seems to happen when you launch your app during development (i.e. from Eclipse or Intellij), so developers run into this a lot. But also through some of the app store update mechanisms (so it impacts your users as well).</source>
          <target state="translated">기본적으로 응용 프로그램이 SingleTask 플래그로 시작된 다음 나중에 홈 화면이나 시작 관리자 메뉴에서 시작하면 이후에 호출하면 새로운 작업이 생성됩니다. 실제로 두 가지 다른 앱 인스턴스가 있습니다. 같은 스택에 거주하는 것은 매우 이상합니다. 이는 개발 중 (예 : Eclipse 또는 Intellij에서) 앱을 시작할 때 발생하는 것으로 보이므로 개발자가이 문제를 많이 겪게됩니다. 또한 일부 앱 스토어 업데이트 메커니즘을 통해 사용자에게도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="1d322c996f5b54d3b8d6b9a87b4ef897e29cccb2" translate="yes" xml:space="preserve">
          <source>Because of memory and processing constraints inherent on mobile devices, I treat Android views in a similar way to a web page. The page does not maintain state, it is purely a presentation layer component whose only purpose is to present application state and accept user input. Recent trends in web app architecture employ the use of the age-old Model, View, Controller (MVC) pattern, where the page is the View, domain data is the model, and the controller sits behind a web service. The same pattern can be employed in Android with the View being, well ... the View, the model is your domain data, and the Controller is implemented as an Android bound service. Whenever you want a view to interact with the controller, bind to it on start/resume and unbind on stop/pause.</source>
          <target state="translated">모바일 장치에 고유 한 메모리 및 처리 제한으로 인해 웹 페이지와 유사한 방식으로 Android보기를 처리합니다. 이 페이지는 상태를 유지하지 않으며 순전히 응용 프로그램 상태를 표시하고 사용자 입력을 받아들이는 것이 목적인 프리젠 테이션 레이어 구성 요소입니다. 웹 앱 아키텍처의 최신 트렌드는 오래된 MVC (Model, View, Controller) 패턴을 사용합니다. 여기서 페이지는보기이고 도메인 데이터는 모델이며 컨트롤러는 웹 서비스 뒤에 있습니다. 뷰는 모델과 도메인 데이터이며 컨트롤러는 안드로이드 바운드 서비스로 구현됩니다. 보기가 컨트롤러와 상호 작용하기를 원할 때마다 시작 / 다시 시작시 바인딩하고 중지 / 일시 중지시 바인드 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="4d963cfab70d8c850b1221649bcc7b4d96d558d3" translate="yes" xml:space="preserve">
          <source>Bonus</source>
          <target state="translated">Bonus</target>
        </trans-unit>
        <trans-unit id="4e882f38eb219fb034343d97ef8fe4679c972b9d" translate="yes" xml:space="preserve">
          <source>Both methods are useful and valid and both are best suited for different scenarios:</source>
          <target state="translated">두 방법 모두 유용하고 유효하며 서로 다른 시나리오에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="7f4c2a7d5e7a907e20ca9ba7f247ecdab6d275c9" translate="yes" xml:space="preserve">
          <source>Both methods get the same Bundle object, so it does not really matter where you write your restoring logic. The only difference is that in &lt;code&gt;onCreate(Bundle savedInstanceState)&lt;/code&gt; method you will have to give a null check while it is not needed in the latter case. Other answers have already code snippets. You can refer them.</source>
          <target state="translated">두 메소드 모두 동일한 Bundle 오브젝트를 가져 오므로 실제로 복원 논리를 작성하는 위치는 중요하지 않습니다. 유일한 차이점은 &lt;code&gt;onCreate(Bundle savedInstanceState)&lt;/code&gt; 메소드에서 후자의 경우 필요하지 않은 경우 null 검사를 제공해야한다는 것입니다. 다른 답변에는 이미 코드 스 니펫이 있습니다. 당신은 그들을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b96bc533da5dba9c055df06b23a9dfe3465313ce" translate="yes" xml:space="preserve">
          <source>Browsing across all these threads, I suspect that much of the time developers are talking about these two different issues simultaneously ... hence all the confusion and reports of &quot;this doesn't work for me&quot;.</source>
          <target state="translated">이 모든 스레드를 탐색하면서 개발자들이이 두 가지 다른 문제에 대해 동시에 이야기하고 있다고 생각합니다. 따라서 &quot;혼란되지 않습니다&quot;라는 모든 혼란과보고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="35c8e7cb5407b863eb1e734effa085a8ef96b4f5" translate="yes" xml:space="preserve">
          <source>But consider this if a user presses the back button. It is assumed that the user does not intend to come back to the Activity, hence in this case &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; will not be invoked by the system.
Point being you should consider all the scenarios while saving data.</source>
          <target state="translated">그러나 사용자가 뒤로 버튼을 누르면 이것을 고려하십시오. 사용자가 액티비티로 돌아 오지 않으려는 경우,이 경우 시스템에서 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 를 호출하지 않습니다. 데이터를 저장하는 동안 모든 시나리오를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cd192f3540cecdd5c288fd84d4b2b87990d9acc" translate="yes" xml:space="preserve">
          <source>By default System saves the View objects in the Bundle for example.</source>
          <target state="translated">기본적으로 시스템은 예를 들어 View 객체를 번들에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="bab0ae1b477f7f1414851f1db2b6c48cb2fc0979" translate="yes" xml:space="preserve">
          <source>Configuration changes such as changing the orientation or phone language which may requires a new activity instance to be created.</source>
          <target state="translated">방향 또는 전화 언어 변경과 같은 구성 변경으로 인해 새 활동 인스턴스를 작성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e30d4ee8619bf7e71388dcf18fd6c8cd7ae045" translate="yes" xml:space="preserve">
          <source>Demo on default behavior</source>
          <target state="translated">기본 행동에 대한 데모</target>
        </trans-unit>
        <trans-unit id="ca5ab99ed4306f5101f437d71e563719d4d391d8" translate="yes" xml:space="preserve">
          <source>Doing something like this with Icepick:</source>
          <target state="translated">Icepick으로 다음과 같은 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="70da04e5dacca4f5d54f1e4e3f78086077168591" translate="yes" xml:space="preserve">
          <source>Ever wondered why the text in the &lt;code&gt;EditText&lt;/code&gt; gets saved automatically while an orientation change? Well, this answer is for you.</source>
          <target state="translated">방향이 변경되는 동안 &lt;code&gt;EditText&lt;/code&gt; 의 텍스트가 자동으로 저장되는 이유가 궁금하십니까? 이 답변은 당신을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="f5d1834f3a0a2883e81e95e8e044ed16af7814f5" translate="yes" xml:space="preserve">
          <source>First, create an interface that will be used to annotate your instance variables:</source>
          <target state="translated">먼저 인스턴스 변수에 주석을 달 때 사용할 인터페이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9275071ec8c082fb5939a220a4c806fb676f22cc" translate="yes" xml:space="preserve">
          <source>First, setup the library in &lt;code&gt;app/build.gradle&lt;/code&gt;</source>
          <target state="translated">먼저 &lt;code&gt;app/build.gradle&lt;/code&gt; 에서 라이브러리를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e894382ce8ee326bfc00b4ae1a6d8cd2b2e49c1a" translate="yes" xml:space="preserve">
          <source>First, to clarify the 'intended' behavior: onSaveInstance and onRestoreInstance are fragile and only for transient state. The intended usage (afaict) is to handle Activity recreation when the phone is rotated (orientation change). In other words, the intended usage is when your Activity is still logically 'on top', but still must be reinstantiated by the system. The saved Bundle is not persisted outside of the process/memory/gc, so you cannot really rely on this if your activity goes to the background. Yes, perhaps your Activity's memory will survive its trip to the background and escape GC, but this is not reliable (nor is it predictable).</source>
          <target state="translated">먼저 '의도 된'동작을 명확히하기 위해 onSaveInstance 및 onRestoreInstance는 취약하며 일시적인 상태에 대해서만 가능합니다. 의도 된 사용법 (afaict)은 전화가 회전 할 때 활동 방향을 조정하는 것입니다 (방향 변경). 다시 말해, 의도 된 사용법은 활동이 여전히 논리적으로 '상단'이지만 시스템에 의해 다시 인스턴스화되어야하는 경우입니다. 저장된 번들은 프로세스 / 메모리 / gc 외부에 유지되지 않으므로 활동이 백그라운드로 진행되는 경우 실제로이를 신뢰할 수 없습니다. 네, 아마도 당신의 활동의 기억은 배경으로의 여행에서 살아남아 GC를 벗어날 것이지만, 이것은 신뢰할 수 없습니다 (예측도 불가능합니다).</target>
        </trans-unit>
        <trans-unit id="64f2c7bb37c16a6a0039e3494222014af8f41b08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int currentScore&lt;/code&gt; in a GameActivity</source>
          <target state="translated">예를 들어 GameActivity의 &lt;code&gt;int currentScore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db598030521045d15ff8dae6d7226e2afcef7edc" translate="yes" xml:space="preserve">
          <source>For more long lived state, consider using a SQLite database, a file, or preferences.  See &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#SavingPersistentState&quot;&gt;Saving Persistent State&lt;/a&gt;.</source>
          <target state="translated">수명이 길면 SQLite 데이터베이스, 파일 또는 환경 설정을 사용하십시오. &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#SavingPersistentState&quot;&gt;영구 상태 저장을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2eba4b624aef5e3315520f49f987a708f2e8cf1" translate="yes" xml:space="preserve">
          <source>For more persistence use shared preferences. &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;read this article&lt;/a&gt;</source>
          <target state="translated">지속성을 높이려면 공유 환경 설정을 사용하십시오. &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;이 기사를 읽으십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b1d44b58d9c7fd663747ff19bc4bb3d891ed0f7" translate="yes" xml:space="preserve">
          <source>For the above scenario what I have done is that in the manifest I made some changes like this:</source>
          <target state="translated">위의 시나리오에서 내가 한 일은 매니페스트에서 다음과 같이 변경했다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="749062c95bcca68367075f43cf5f9eca84cfe184" translate="yes" xml:space="preserve">
          <source>Here is a comment from &lt;strong&gt;Steve Moseley&lt;/strong&gt;'s answer (by &lt;strong&gt;ToolmakerSteve&lt;/strong&gt;) that puts things into perspective (in the whole onSaveInstanceState vs onPause, east cost vs west cost saga)</source>
          <target state="translated">여기에 &lt;strong&gt;Steve Moseley&lt;/strong&gt; 의 답변 ( &lt;strong&gt;ToolmakerSteve&lt;/strong&gt; )이 의견을 제시합니다 (전체 onSaveInstanceState 대 onPause, 동쪽 비용 대 서쪽 비용 사가)</target>
        </trans-unit>
        <trans-unit id="1a5aafd8c6994cde334b97c529424f3538a223f2" translate="yes" xml:space="preserve">
          <source>Home key press behaviour</source>
          <target state="translated">홈 키 누름 동작</target>
        </trans-unit>
        <trans-unit id="730b3a40fc65ec321f279a3d9d7b78388355e548" translate="yes" xml:space="preserve">
          <source>How to save an activity state using save instance state</source>
          <target state="translated">인스턴스 상태 저장을 사용하여 활동 상태를 저장하는 방법</target>
        </trans-unit>
        <trans-unit id="99a21a34bbb6452c71f959f0db20b9a7c58d10e2" translate="yes" xml:space="preserve">
          <source>I battled through these threads for hours before I realized that my main issue was this bug, not the intended framework behavior. A great writeup and &lt;del&gt;workaround&lt;/del&gt; (UPDATE: see below) seems to be from user @kaciula in this answer:</source>
          <target state="translated">내 주요 문제가 의도 된 프레임 워크 동작이 아니라이 버그라는 것을 깨닫기 전에 몇 시간 동안이 스레드를 해결했습니다. 훌륭한 글쓰기와 &lt;del&gt; 해결 방법 &lt;/del&gt; (업데이트 : 아래 참조)는이 답변에서 사용자 @kaciula의 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="f2ad0ce289a11cde24e01a98220dd0e6a556deba" translate="yes" xml:space="preserve">
          <source>I believe this is the answer and this works fine for me. Correct me if I am wrong.</source>
          <target state="translated">나는 이것이 답이라고 생각하며 이것은 나에게 잘 작동한다. 내가 틀렸다면 나를 바로 잡으십시오.</target>
        </trans-unit>
        <trans-unit id="c88c21f9feae0ff7178652e747f96a57454d58a6" translate="yes" xml:space="preserve">
          <source>I really do not recommend to use second method. Since in one of my experience it was causing half of the device screen black while rotating from portrait to landscape and vice versa.</source>
          <target state="translated">나는 두 번째 방법을 사용하지 않는 것이 좋습니다. 내 경험 중 하나에서 세로에서 가로로 또는 그 반대로 회전하면서 장치 화면의 절반이 검은 색으로 표시되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a234d5784cfaaa336f8de8adb7d5b12e7d6bb97" translate="yes" xml:space="preserve">
          <source>I think I found the answer. Let me tell what I have done in simple words:</source>
          <target state="translated">나는 대답을 찾았다 고 생각한다. 내가 한 일을 간단한 단어로 말해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="d77e2f866a1e4f7218688b101ed8ed15b8edb6b8" translate="yes" xml:space="preserve">
          <source>I thought it would be enough for the simplest case, but it always responds with the first message, no matter how I navigate away from the app.</source>
          <target state="translated">가장 간단한 경우에는 충분하다고 생각했지만 앱에서 어떻게 탐색하든 항상 첫 번째 메시지로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="9e6b9d43774c9c46f68431bb26579c42c30202fc" translate="yes" xml:space="preserve">
          <source>I use &lt;code&gt;onSaveInstanceState&lt;/code&gt;and &lt;code&gt;onRestoreInstanceState&lt;/code&gt; as suggested above but I guess i could also or alternatively use my method to save the variable when it changes (e.g. using &lt;code&gt;putBoolean&lt;/code&gt;)</source>
          <target state="translated">위에서 제안한대로 &lt;code&gt;onSaveInstanceState&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState&lt;/code&gt; 를 사용하지만 변수가 변경되면 변수를 저장하기 위해 또는 다른 방법으로 메소드를 사용할 수도 있습니다 (예 : &lt;code&gt;putBoolean&lt;/code&gt; 사용)</target>
        </trans-unit>
        <trans-unit id="76a314ac895f1f34c454a7f19973a5048239551e" translate="yes" xml:space="preserve">
          <source>I'm sure the solution is as simple as overriding &lt;code&gt;onPause&lt;/code&gt; or something like that, but I've been poking away in the documentation for 30 minutes or so and haven't found anything obvious.</source>
          <target state="translated">솔루션이 &lt;code&gt;onPause&lt;/code&gt; 또는 그와 비슷한 것을 재정의하는 것처럼 간단하다고 확신하지만 30 분 정도 문서를 파헤 쳐서 명확한 것을 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="ddecbedea0def1107a0a3a5048dec1201be09a90" translate="yes" xml:space="preserve">
          <source>I've been working on the Android SDK platform, and it is a little unclear how to save an application's state. So given this minor re-tooling of the 'Hello, Android' example:</source>
          <target state="translated">Android SDK 플랫폼에서 작업 중이며 응용 프로그램의 상태를 저장하는 방법이 약간 불분명합니다. 따라서 'Hello, Android'예제를 약간만 수정하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75fceb7e8de11f7e552300d6e3d417d93b26bbb7" translate="yes" xml:space="preserve">
          <source>Icepick can also generate the instance state code for custom Views:</source>
          <target state="translated">Icepick은 또한 사용자 정의 뷰에 대한 인스턴스 상태 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbe5f85a41ab77aa42247c4ed3c82c2ca80a4e7" translate="yes" xml:space="preserve">
          <source>Icepick will work with any object that saves its state with a &lt;code&gt;Bundle&lt;/code&gt;.</source>
          <target state="translated">Icepick은 &lt;code&gt;Bundle&lt;/code&gt; 로 상태를 저장하는 모든 객체와 작동합니다.</target>
        </trans-unit>
        <trans-unit id="517a95f6798caf61fcd445878cad66a564d72f42" translate="yes" xml:space="preserve">
          <source>If you need another variable to be saved as a part of instance state you should &lt;strong&gt;OVERRIDE&lt;/strong&gt;&lt;code&gt;onSavedInstanceState(Bundle savedinstaneState)&lt;/code&gt; method.</source>
          <target state="translated">인스턴스 상태의 일부로 다른 변수를 저장해야하는 경우 &lt;code&gt;onSavedInstanceState(Bundle savedinstaneState)&lt;/code&gt; 메서드를 덮어 써야 합니다.</target>
        </trans-unit>
        <trans-unit id="9c944080c2e6bce35a74fa1594e1a83ea91dbccd" translate="yes" xml:space="preserve">
          <source>If you save the state data in a persistent manner, it can be reloaded in an &lt;code&gt;onResume()&lt;/code&gt; or &lt;code&gt;onCreate()&lt;/code&gt; (or actually on any lifecycle call). This may or may not be desired behaviour. If you store it in a bundle in an &lt;code&gt;InstanceState&lt;/code&gt;, then it is transient and is only suitable for storing data for use in the same user &amp;lsquo;session&amp;rsquo; (I use the term session loosely) but not between &amp;lsquo;sessions&amp;rsquo;.</source>
          <target state="translated">상태 데이터를 지속적으로 저장하면 &lt;code&gt;onResume()&lt;/code&gt; 또는 &lt;code&gt;onCreate()&lt;/code&gt; (또는 실제로는 모든 수명주기 호출)에 다시로드 될 수 있습니다. 이것은 바람직한 행동 일 수도 있고 아닐 수도 있습니다. &lt;code&gt;InstanceState&lt;/code&gt; 의 번들에 저장하면 일시적이며 동일한 사용자 '세션'(세션이라는 용어를 느슨하게 사용)에서 사용하기 위해 데이터를 저장하는 데 적합하지만 '세션'사이에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ad4b28b513d33ae9c7dc4c7a579738551df044a" translate="yes" xml:space="preserve">
          <source>In manifest &lt;code&gt;android:configChanges=&quot;orientation|screenSize&quot;&lt;/code&gt;.</source>
          <target state="translated">매니페스트 &lt;code&gt;android:configChanges=&quot;orientation|screenSize&quot;&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="5266f3aaddbb67db45817ea009b4ed42c15a5b6a" translate="yes" xml:space="preserve">
          <source>In most cases if you're just pressing home and then launching the app again the activity won't need to be re-created. It already exists in memory so onCreate() won't be called.</source>
          <target state="translated">대부분의 경우 집을 눌렀다가 앱을 다시 시작하면 활동을 다시 만들 필요가 없습니다. 메모리에 이미 존재하므로 onCreate ()가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ad9e5f9884ddec3aa54231745e738669a0d7ec6" translate="yes" xml:space="preserve">
          <source>In other words, put your save/restore code for persistent data in &lt;code&gt;onPause()&lt;/code&gt; and &lt;code&gt;onResume()&lt;/code&gt;!</source>
          <target state="translated">즉, 영구 데이터에 대한 저장 / 복원 코드를 &lt;code&gt;onPause()&lt;/code&gt; 및 &lt;code&gt;onResume()&lt;/code&gt; 넣습니다.</target>
        </trans-unit>
        <trans-unit id="b5dbbbcb80aa47d7c86580e11c02bdad1f4b00d4" translate="yes" xml:space="preserve">
          <source>In some way SharedPreferences work similar like Bundles.
And naturally and at first such values have to be read from preferences.</source>
          <target state="translated">어떤 방식 으로든 SharedPreferences는 번들과 유사하게 작동합니다. 그리고 자연스럽고 처음에는 이러한 값을 선호도에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="77c287bc0253e852d1896406c1926722161c7817" translate="yes" xml:space="preserve">
          <source>In the case of complex data you may use SQLite instead of using preferences.</source>
          <target state="translated">복잡한 데이터의 경우 환경 설정을 사용하는 대신 SQLite를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71100fcc6f3f46f3aa97e956b192f7f4bbbdd94c" translate="yes" xml:space="preserve">
          <source>Instance state is a collection of &lt;strong&gt;key-value&lt;/strong&gt; pairs stored in a &lt;code&gt;Bundle&lt;/code&gt; object.</source>
          <target state="translated">인스턴스 상태는 &lt;code&gt;Bundle&lt;/code&gt; 객체에 저장된 &lt;strong&gt;키-값&lt;/strong&gt; 쌍의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="e895203a0cd4ff2ef32040fe5c4ba822821dc215" translate="yes" xml:space="preserve">
          <source>Is the same as doing this:</source>
          <target state="translated">이 작업을 수행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d54ecbfadf837ad212b0092e15eb1dea12e17ec4" translate="yes" xml:space="preserve">
          <source>It is not that one approach is better than the other, like everything, it is just important to understand what behaviour you require and to select the most appropriate approach.</source>
          <target state="translated">하나의 접근 방식이 다른 것보다 낫다는 것은 아닙니다. 필요한 행동을 이해하고 가장 적절한 접근 방식을 선택하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c4245e3acc2d772effaa7e57af89255710a3d475" translate="yes" xml:space="preserve">
          <source>It should look like this:</source>
          <target state="translated">다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="24af904f2496e7c00485a24dbbcabfc6b3c92acf" translate="yes" xml:space="preserve">
          <source>It works for Activities, Fragments or any object that needs to serialize its state on a Bundle (e.g. mortar's ViewPresenters)</source>
          <target state="translated">액티비티, 프래그먼트 또는 번들에서 상태를 직렬화해야하는 모든 오브젝트 (예 : 박격포의 ViewPresenters)에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="52c5e33f29f523034bcbe7459d9b211cb9d1aef4" translate="yes" xml:space="preserve">
          <source>It's recommended to let Android handle this for you than the manually handling.</source>
          <target state="translated">수동으로 처리하는 것보다 Android에서이를 처리하도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="704addd02feecc9f6bcd16d23edb8dbea03f3462" translate="yes" xml:space="preserve">
          <source>Keeping object instances alive in memory between activities within application lifetime using a retained non-configuration instance</source>
          <target state="translated">유지되지 않은 비 구성 인스턴스를 사용하여 응용 프로그램 수명 내 활동간에 메모리에 객체 인스턴스를 유지</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="085096a1896830913423d1a424e00f124559ebde" translate="yes" xml:space="preserve">
          <source>Kotlin code:</source>
          <target state="translated">코 틀린 코드 :</target>
        </trans-unit>
        <trans-unit id="0fc2bf3ef7f1883184381af47c6a31e111a14eda" translate="yes" xml:space="preserve">
          <source>Life cycle graph</source>
          <target state="translated">수명주기 그래프</target>
        </trans-unit>
        <trans-unit id="8ca6212634cffc24cab196f8d0e808011d5f1cb9" translate="yes" xml:space="preserve">
          <source>Meanwhile I do in general no more use</source>
          <target state="translated">한편 나는 일반적으로 더 이상 사용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="ef8f52e1b40ae0f56a531896c23f4f1189aa7456" translate="yes" xml:space="preserve">
          <source>More detail about the onRestoreInstanceState(Bundle savedinstaneState)</source>
          <target state="translated">onRestoreInstanceState (Bundle savedinstaneState)에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="cfeb0383f2d85dd601d9702766f8d5350467eb65" translate="yes" xml:space="preserve">
          <source>More detail about the onSavedInstanceState(Bundle savedinstaneState) while saving data</source>
          <target state="translated">데이터를 저장하는 동안 onSavedInstanceState (Bundle savedinstaneState)에 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="4c844a45d0aa045b41a1e782eb2ce348674c0c79" translate="yes" xml:space="preserve">
          <source>My colleague wrote an article explaining application state on Android devices including explanations on activity lifecycle and state information, how to store state information, and saving to state &lt;code&gt;Bundle&lt;/code&gt; and &lt;code&gt;SharedPreferences&lt;/code&gt; and &lt;a href=&quot;http://www.eigo.co.uk/Managing-State-in-an-Android-Activity.aspx&quot;&gt;take a look at here&lt;/a&gt;.</source>
          <target state="translated">동료가 활동 수명주기 및 상태 정보에 대한 설명, 상태 정보를 저장하는 방법, 상태 &lt;code&gt;Bundle&lt;/code&gt; 및 &lt;code&gt;SharedPreferences&lt;/code&gt; 에 저장하는 방법을 비롯하여 Android 디바이스의 애플리케이션 상태를 설명하는 기사를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="49325329f0baecd23c4f99c3e845a4775121d762" translate="yes" xml:space="preserve">
          <source>My problem was that I needed persistence only during the application lifetime (i.e. a single execution including starting other sub-activities within the same app and rotating the device etc). I tried various combinations of the above answers but did not get what I wanted in all situations. In the end what worked for me was to obtain a reference to the savedInstanceState during onCreate:</source>
          <target state="translated">내 문제는 응용 프로그램 수명 동안에 만 지속성이 필요하다는 것입니다 (예 : 동일한 응용 프로그램 내에서 다른 하위 활동 시작 및 장치 회전 등 단일 실행). 위의 답변을 다양하게 조합했지만 모든 상황에서 원하는 것을 얻지 못했습니다. 결국 나를 위해 일한 것은 onCreate 중에 savedInstanceState에 대한 참조를 얻는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="9056c458f0c2df28047ab602793e25b415237362" translate="yes" xml:space="preserve">
          <source>My way is to save any changes immediately in the preferences:</source>
          <target state="translated">내 방법은 변경 사항을 환경 설정에 즉시 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ca8a9c67e5177d3e6fc8210f33c1485ca0b9bc6" translate="yes" xml:space="preserve">
          <source>Not sure if my solution is frowned upon or not, but I use a bound service to persist ViewModel state. Whether you store it in memory in the service or persist and retrieve it from a SQLite database depends on your requirements. This is what services of any flavor do, they provide services such as maintaining application state and abstract common business logic.</source>
          <target state="translated">솔루션이 찌그러 지는지 확실하지 않지만 바운드 서비스를 사용하여 ViewModel 상태를 유지합니다. 서비스의 메모리에 저장하거나 SQLite 데이터베이스에서 유지 및 검색하는지 여부는 요구 사항에 따라 다릅니다. 이것은 어떤 풍미의 서비스가하는지, 애플리케이션 상태 및 추상적 인 공통 비즈니스 로직 유지와 같은 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c7f1130942e0e91dd7a38fc7fdb7894bebd63cb7" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; safe to use &lt;code&gt;onSaveInstanceState&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState&lt;/code&gt;&lt;strong&gt;for persistent data&lt;/strong&gt;, according to the documentation on Activity states in &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html&quot;&gt;http://developer.android.com/reference/android/app/Activity.html&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html&quot;&gt;http://developer.android.com/reference/android/app/Activity.html의&lt;/a&gt; 활동 상태에 대한 문서에 따라 &lt;strong&gt;지속 데이터에&lt;/strong&gt; &lt;code&gt;onSaveInstanceState&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState&lt;/code&gt; 를 사용하는 &lt;strong&gt;&lt;em&gt;것은&lt;/em&gt;&lt;/strong&gt; 안전 &lt;strong&gt;&lt;em&gt;하지 않습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="09b63f649bd2ace083fd36fd2d9645d7e1e062c1" translate="yes" xml:space="preserve">
          <source>Note that it is important to save
  persistent data in &lt;code&gt;onPause()&lt;/code&gt; instead
  of &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt;
  because the later is not part of the
  lifecycle callbacks, so will not be
  called in every situation as described
  in its documentation.</source>
          <target state="translated">후자는 수명주기 콜백의 일부가 아니므로 문서에 설명 된대로 모든 상황에서 호출되지는 않으므로 &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt; &lt;code&gt;onPause()&lt;/code&gt; 대신 onPause () 에 영구 데이터를 저장하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0cb77d78680ec1ed5c4f901d861924bfa8c5521f" translate="yes" xml:space="preserve">
          <source>Now Android provides &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot;&gt;ViewModels&lt;/a&gt; for saving state, you should try to use that instead of saveInstanceState.</source>
          <target state="translated">이제 Android는 상태 저장을위한 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/saving-states&quot;&gt;ViewModel&lt;/a&gt; 을 제공하므로 saveInstanceState 대신 해당 모델을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="a6da74abf95feae94e84fd2b5395c0db821fd4e2" translate="yes" xml:space="preserve">
          <source>Now it makes sense to do 2 ways in the view model.
if you want to save the first as a saved instance:
You can add state parameter in view model like this
&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&quot;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&lt;/a&gt;</source>
          <target state="translated">이제 뷰 모델에서 두 가지 방법을 수행하는 것이 좋습니다. 첫 번째를 저장된 인스턴스로 저장하려는 경우 : &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&quot;&gt;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate#java&lt;/a&gt; 와 같이 뷰 모델에 상태 매개 변수를 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9b482d346c633ff146bd076c14488a78af33e811" translate="yes" xml:space="preserve">
          <source>Now what will happen is that whatever the changes we have made in the activity2 will not be lost, and we can view activity2 in the same state as we left previously.</source>
          <target state="translated">이제 어떻게 될지는 activity2에서 변경 한 내용이 손실되지 않고 activity2를 이전 상태와 동일한 상태로 볼 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a14112d48e19613c3dddbf7368e0ce1363a59c2" translate="yes" xml:space="preserve">
          <source>Now, let's check this example below how to save state in Activity</source>
          <target state="translated">이제 액티비티에 상태를 저장하는 방법을 아래 예제에서 확인하겠습니다</target>
        </trans-unit>
        <trans-unit id="de3fb34c55a00a9d41d70d0999f54c3a74a48ce0" translate="yes" xml:space="preserve">
          <source>Or from a fragment.</source>
          <target state="translated">또는 조각에서.</target>
        </trans-unit>
        <trans-unit id="06f2b17c80b04fc3bba81b7225ec80e78e29e10a" translate="yes" xml:space="preserve">
          <source>Quote from the docs:
&quot;This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.&quot;
&lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;Source&lt;/a&gt;</source>
          <target state="translated">문서에서 인용 : &quot;이 메소드는 활동이 종료되기 전에 호출되므로 나중에 다시 돌아올 때 상태를 복원 할 수 있습니다.&quot; &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;출처&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c84792233bf30b1abaae84c3f316f8fbe417b1c" translate="yes" xml:space="preserve">
          <source>Really &lt;code&gt;onSaveInstanceState()&lt;/code&gt; is called when the Activity goes to background.</source>
          <target state="translated">실제로 &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 는 Activity가 백그라운드로 갈 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d79dfdc86ed9cf9d397fe92b6c3592f64052891a" translate="yes" xml:space="preserve">
          <source>Relevant links:</source>
          <target state="translated">관련 링크 :</target>
        </trans-unit>
        <trans-unit id="6bc7c4f49193a935253737078f1eac07e7695587" translate="yes" xml:space="preserve">
          <source>Retrieve variables</source>
          <target state="translated">변수 검색</target>
        </trans-unit>
        <trans-unit id="9c6aa369a89289d712f7f69e210ed82b581ea4eb" translate="yes" xml:space="preserve">
          <source>Saving state is a kludge at best as far as I'm concerned. If you need to save persistent data, just use an &lt;a href=&quot;http://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt; database. Android makes it &lt;strong&gt;&lt;em&gt;SOOO&lt;/em&gt;&lt;/strong&gt; easy.</source>
          <target state="translated">내가 아는 한 저축 상태는 최고입니다. 영구 데이터를 저장해야하는 경우 &lt;a href=&quot;http://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt; 데이터베이스를 사용하십시오. Android는 &lt;strong&gt;&lt;em&gt;SOOO를&lt;/em&gt;&lt;/strong&gt; 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c92afff79b309ecaa8f3fe0482edd2968fbf8d97" translate="yes" xml:space="preserve">
          <source>Scroll position in a &lt;code&gt;ListView&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;ListView&lt;/code&gt; 등에서 스크롤 위치</target>
        </trans-unit>
        <trans-unit id="a4ff04dedc4cda4bdb4655b6ebd20bec6039d37d" translate="yes" xml:space="preserve">
          <source>Simple quick to solve this problem is using &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;IcePick&lt;/a&gt;</source>
          <target state="translated">이 문제를 해결하기위한 간단한 빠른 방법은 &lt;a href=&quot;https://github.com/frankiesardo/icepick&quot;&gt;IcePick을&lt;/a&gt; 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="88250f8b9af03b6fc0ff4db55effd8286a4f44ac" translate="yes" xml:space="preserve">
          <source>So by mistake if you forget to call
  &lt;code&gt;super.onSaveInstanceState(savedInstanceState);&lt;/code&gt;the default behavior
  will not work ie Text in EditText will not save.</source>
          <target state="translated">따라서 실수로 &lt;code&gt;super.onSaveInstanceState(savedInstanceState);&lt;/code&gt; 기본 동작이 작동하지 않습니다. 즉 EditText의 텍스트가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b324a6316fa2e8039900ea43f658e28a4fe7d144" translate="yes" xml:space="preserve">
          <source>So if you have a scenario where there is meaningful 'user progress' or state that should be persisted between 'launches' of your application, the guidance is to use onPause and onResume. You must choose and prepare a persistent store yourself.</source>
          <target state="translated">따라서 응용 프로그램의 '시작'간에 의미있는 '사용자 진행률'또는 상태가 유지되어야하는 시나리오가있는 경우 onPause 및 onResume을 사용하는 것이 좋습니다. 영구 저장소를 직접 선택하고 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a8c9cecf78e1520d6f30aa06c477eda5abb1c29" translate="yes" xml:space="preserve">
          <source>Something like this:</source>
          <target state="translated">이 같은:</target>
        </trans-unit>
        <trans-unit id="ed8609f2ffac41c2767325a80fa34324e524d978" translate="yes" xml:space="preserve">
          <source>Store local variable/UI control data between application instances (i.e. permanently) using shared preferences</source>
          <target state="translated">공유 환경 설정을 사용하여 애플리케이션 인스턴스간에 (즉, 영구적으로) 로컬 변수 / UI 제어 데이터 저장</target>
        </trans-unit>
        <trans-unit id="1a601715666f11c667d333b1717a4c4b643c5c6a" translate="yes" xml:space="preserve">
          <source>Store local variable/UI control data for application lifetime (i.e. temporarily) using an instance state bundle</source>
          <target state="translated">인스턴스 상태 번들을 사용하여 애플리케이션 수명 동안 (즉, 일시적으로) 로컬 변수 / UI 제어 데이터 저장</target>
        </trans-unit>
        <trans-unit id="d652780d2ed12cc566103890d1ad4dfb3b59c3f0" translate="yes" xml:space="preserve">
          <source>Store variables</source>
          <target state="translated">변수 저장</target>
        </trans-unit>
        <trans-unit id="21d3c43c3d2a040a19e4fdd5af7ebdb60fbc8672" translate="yes" xml:space="preserve">
          <source>Suppose I have two activities, activity1 and activity2 and I am navigating from activity1 to activity2 (I have done some works in activity2) and again back to activity 1 by clicking on a button in activity1. Now at this stage I wanted to go back to activity2 and I want to see my activity2 in the same condition when I last left activity2.</source>
          <target state="translated">activity1과 activity2라는 두 가지 활동이 있고 activity1에서 activity2로 탐색하고 (activity2에서 일부 작업을 수행 한 후) activity1의 단추를 클릭하여 다시 활동 1로 돌아 간다고 가정하십시오. 이제이 단계에서 나는 activity2로 돌아가고 싶었고 마지막으로 activity2를 떠났을 때와 같은 상태로 activity2를보고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="9cd72c21a0b2397e877a53b771b57cc3db27e1a3" translate="yes" xml:space="preserve">
          <source>Text in &lt;code&gt;EditText&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EditText&lt;/code&gt; 의 텍스트</target>
        </trans-unit>
        <trans-unit id="5b27ab301625c3ec373095ab68b695692c5d22e9" translate="yes" xml:space="preserve">
          <source>The 'normal' or intended way to manage this issue is, itself, rather complicated with the duality of onPause/onResume and onSaveInstanceState/onRestoreInstanceState</source>
          <target state="translated">이 문제를 관리하는 '정상적인'방법은 onPause / onResume과 onSaveInstanceState / onRestoreInstanceState의 이중성 때문에 다소 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="fdf846da153619f6f5b3e0c470032b5a1b71f8a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; is invoked by the system only when the user intends to come back to the Activity. For example, you are using App X and suddenly you get a call. You move to the caller app and come back to the app X. In this case the &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method will be invoked.</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 는 사용자가 활동으로 돌아 오려고 할 때만 시스템에서 호출합니다. 예를 들어 App X를 사용하고 있는데 갑자기 전화를받습니다. 호출자 앱으로 이동하고 앱 X로 돌아옵니다.이 경우 &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3136e1e0ea08c82d036d55e752142051b9080e2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSaveInstanceState(bundle)&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; methods are useful for data persistence merely while rotating the screen (orientation change).</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState(bundle)&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; 메소드는 화면을 회전하는 동안 (방향 변경) 데이터 지속성에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bfef643ce37d4fad3767445c87484ad25499c8fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savedInstanceState&lt;/code&gt; is only for saving state associated with a current instance of an Activity, for example current navigation or selection info, so that if Android destroys and recreates an Activity, it can come back as it was before.  See the documentation for &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)&quot;&gt;&lt;code&gt;onCreate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt;&lt;code&gt;onSaveInstanceState&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;savedInstanceState&lt;/code&gt; 는 현재 탐색 또는 선택 정보와 같은 활동의 현재 인스턴스와 연관된 상태를 저장하기위한 것이므로 Android가 활동을 삭제하고 다시 작성하면 이전과 같이 돌아올 수 있습니다. &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)&quot;&gt; &lt;code&gt;onCreate&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)&quot;&gt; &lt;code&gt;onSaveInstanceState&lt;/code&gt; 에&lt;/a&gt; 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d3ce1e986fa6d341b2ac89952e63610b8bc7685" translate="yes" xml:space="preserve">
          <source>The Bundle is essentially a way of storing a NVP (&quot;Name-Value Pair&quot;) map, and it will get passed in to &lt;code&gt;onCreate()&lt;/code&gt; and also &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; where you would then extract the values from activity like this:</source>
          <target state="translated">번들은 기본적으로 NVP ( &quot;이름-값 쌍&quot;) 맵을 저장하는 방법이며 &lt;code&gt;onCreate()&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 로 전달되어 다음과 같이 활동에서 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2b91d9e1904f244273815d75b9a180a3999ad78b" translate="yes" xml:space="preserve">
          <source>The article covers three approaches:</source>
          <target state="translated">이 기사는 세 가지 접근 방식을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="59994bcb0211e26e361677612a25b82f6263a391" translate="yes" xml:space="preserve">
          <source>The document states (in the 'Activity Lifecycle' section):</source>
          <target state="translated">문서에는 '활동 수명주기'섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c715e503afb2e388c5e07bc7beb922e01cf21e" translate="yes" xml:space="preserve">
          <source>The life cycle is for most activities too complicated and not necessary.</source>
          <target state="translated">수명주기는 대부분의 활동에서 너무 복잡하고 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03abf264ad09fe480d3645d0ad3e6c80d18a3ac" translate="yes" xml:space="preserve">
          <source>The other answers are valuable in that they teach you the correct ways to store state but I didn't feel they really answered WHY your code wasn't working in the way you expected.</source>
          <target state="translated">다른 답변은 상태를 저장하는 올바른 방법을 가르쳐 준다는 점에서 가치가 있지만 코드가 예상대로 작동하지 않는 이유는 실제로 답변하지 않았다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ea853c5dbb9b05a675dbf62467c34a0c9ed85dc1" translate="yes" xml:space="preserve">
          <source>The user switches application and then comes back to the original and wants to pick up where they left off -  save and restore bundle data (such as application state data) in &lt;code&gt;onSaveInstanceState()&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; is usually adequate.</source>
          <target state="translated">사용자가 응용 프로그램을 전환 한 다음 원래 상태로 돌아와서 중단 된 부분을 선택하려고합니다. &lt;code&gt;onSaveInstanceState()&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; 번들 데이터 (응용 프로그램 상태 데이터 등)를 저장 및 복원하는 것이 일반적으로 적합합니다.</target>
        </trans-unit>
        <trans-unit id="664f7f6cd00e964bf2ece8284a1a16728a7165a9" translate="yes" xml:space="preserve">
          <source>The user terminates the application and re-opens it at a later date, but the application needs to reload data from the last session &amp;ndash; this requires a persistent storage approach such as using SQLite.</source>
          <target state="translated">사용자는 애플리케이션을 종료하고 나중에 다시 열어야하지만 애플리케이션은 마지막 세션에서 데이터를 다시로드해야합니다.이를 위해서는 SQLite 사용과 같은 지속적인 스토리지 접근이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fbab7ef755b952309a2b4daa899a7fc7a56700a0" translate="yes" xml:space="preserve">
          <source>Then, create a class where reflection will be used to save values to the bundle:</source>
          <target state="translated">그런 다음 리플렉션을 사용하여 값을 번들에 저장하는 클래스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e05c399bd3b713fd14819c61025cf239cdc9f4a3" translate="yes" xml:space="preserve">
          <source>There are basically two ways to implement this change.</source>
          <target state="translated">기본적으로이 변경을 구현하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d0e409673cec86fa043a7ead7b9881a2eb5036f" translate="yes" xml:space="preserve">
          <source>There is a subtle Android Framework bug which greatly complicates application stack management during development, at least on legacy versions (not entirely sure if/when/how it was fixed). I'll discuss this bug below.</source>
          <target state="translated">최소한 레거시 버전에서 (개발이 언제 / 어떻게 / 어떻게 해결되었는지는 확실하지 않음) 개발 중에 애플리케이션 스택 관리를 크게 복잡하게하는 미묘한 Android Framework 버그가 있습니다. 아래에서이 버그에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="46ad321e7ce6bd857daf8414afc19b0370ddb6b9" translate="yes" xml:space="preserve">
          <source>There is a way to make Android save the states without implementing any method. Just add this line to your Manifest in Activity declaration:</source>
          <target state="translated">메소드를 구현하지 않고 Android에서 상태를 저장하는 방법이 있습니다. 다음 선언을 활동 선언의 매니페스트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="692777a292ae320362294cca80a4d6f9cccf34cf" translate="yes" xml:space="preserve">
          <source>There is an option under Settings -&amp;gt; Developer Options called &quot;Don't keep activities&quot;. When it's enabled Android will always destroy activities and recreate them when they're backgrounded. This is a great option to leave enabled when developing because it simulates the worst case scenario. ( A low memory device recycling your activities all the time ).</source>
          <target state="translated">설정-&amp;gt; 개발자 옵션 아래에 &quot;활동을 유지하지 마십시오&quot;라는 옵션이 있습니다. 활성화되면 Android는 항상 활동을 파괴하고 배경이있을 때 다시 생성합니다. 최악의 시나리오를 시뮬레이트하기 때문에 개발시 활성화 상태로 두는 것이 좋습니다. (당신의 활동을 항상 재활용하는 저용량 메모리 장치).</target>
        </trans-unit>
        <trans-unit id="7bea05f76049cfe844c159e008e33b3cdad15d15" translate="yes" xml:space="preserve">
          <source>They are not even good while switching between applications (since the &lt;code&gt;onSaveInstanceState()&lt;/code&gt; method is called but &lt;code&gt;onCreate(bundle)&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; is not invoked again.</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState()&lt;/code&gt; 메소드가 호출되었지만 &lt;code&gt;onCreate(bundle)&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState(bundle)&lt;/code&gt; 이 다시 호출되지 않기 때문에 애플리케이션 간 전환 중에도 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ba2aa884fd631b75bfa3cea504f24ca026a10a3" translate="yes" xml:space="preserve">
          <source>This approach gives you the added bonus of enforcing the Separation of Concern design principle in that all of you application business logic can be moved into your service which reduces duplicated logic across multiple views and allows the view to enforce another important design principle, Single Responsibility.</source>
          <target state="translated">이 접근 방식을 사용하면 모든 응용 프로그램 비즈니스 논리를 서비스로 이동하여 여러 뷰에서 중복 된 논리를 줄이고 뷰에서 다른 중요한 설계 원칙 인 단일 책임을 적용 할 수 있다는 점에서 분리 분리 설계 원칙을 강화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c26216b14217a3380648c7ae8c9e34dc0e4f79b" translate="yes" xml:space="preserve">
          <source>This is a classic 'gotcha' of Android development. There are two issues here:</source>
          <target state="translated">이것은 안드로이드 개발의 고전적인 'gotcha'입니다. 여기에는 두 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54d3b795eaa3a1ea1ebc0c9870580be1ebc7d60" translate="yes" xml:space="preserve">
          <source>This method is called before an activity may be killed so that when it
  comes back some time in the future it can restore its state. For
  example, if activity B is launched in front of activity A, and at some
  point activity A is killed to reclaim resources, activity A will have
  a chance to save the current state of its user interface via this
  method so that when the user returns to activity A, the state of the
  user interface can be restored via &lt;code&gt;onCreate(Bundle)&lt;/code&gt; or
  &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 활동이 종료되기 전에 호출되므로 나중에 일정 시간이 지나면 상태를 복원 할 수 있습니다. 예를 들어, 활동 B가 활동 A 앞에서 시작되고 어떤 시점에서 활동 A가 자원을 재생하기 위해 종료 된 경우 활동 A는이 메소드를 통해 사용자 인터페이스의 현재 상태를 저장하여 사용자가 리턴 할 때 활동 A에 대한 사용자 인터페이스의 상태는 &lt;code&gt;onCreate(Bundle)&lt;/code&gt; 또는 &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt; 통해 복원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d6a7f29f8cc604160d04f5aa0b3c33d5a3b946" translate="yes" xml:space="preserve">
          <source>To answer the original question directly. savedInstancestate is null because your Activity is never being re-created.</source>
          <target state="translated">원래 질문에 직접 대답합니다. 활동이 다시 작성되지 않으므로 savedInstancestate가 널입니다.</target>
        </trans-unit>
        <trans-unit id="ec9f8b80524ada5a79eb7a16caabdaee5b0a16b9" translate="yes" xml:space="preserve">
          <source>To get activity state data stored in &lt;code&gt;onCreate()&lt;/code&gt;, first you have to save data in savedInstanceState by overriding &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;onCreate()&lt;/code&gt; 저장된 활동 상태 데이터를 가져 오려면 먼저 &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 메소드를 대체하여 savedInstanceState에 데이터를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="24e60a573f56cb1eba94bf31112b60354733fdc2" translate="yes" xml:space="preserve">
          <source>To help reduce boilerplate I use the following &lt;code&gt;interface&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; to read/write to a &lt;code&gt;Bundle&lt;/code&gt; for saving instance state.</source>
          <target state="translated">상용구를 줄이기 위해 다음 &lt;code&gt;interface&lt;/code&gt; 와 &lt;code&gt;class&lt;/code&gt; 를 사용하여 인스턴스 상태를 저장하기 위해 &lt;code&gt;Bundle&lt;/code&gt; 에 읽기 / 쓰기를합니다.</target>
        </trans-unit>
        <trans-unit id="9fe0ffe2fbabae926ca82b75532206413f6d13cf" translate="yes" xml:space="preserve">
          <source>Using first method mentioned above , we can persist data when orientation is changed or any config change happens.
I know a way in which you can store any type of data inside savedInstance state object.</source>
          <target state="translated">위에서 언급 한 첫 번째 방법을 사용하면 방향이 변경되거나 구성 변경이 발생할 때 데이터를 유지할 수 있습니다. savedInstance 상태 객체에 모든 유형의 데이터를 저장할 수있는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="708a9360bf26e47c630bb82671e52c1cb996099e" translate="yes" xml:space="preserve">
          <source>What to save and what not to?</source>
          <target state="translated">무엇을 저장하고 무엇을하지 말아야합니까?</target>
        </trans-unit>
        <trans-unit id="5b3a304deee10af08a21c6160599ddf1fb716ab9" translate="yes" xml:space="preserve">
          <source>When activity destroy &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; method gets called and there you save data you want to save. And you get same in &lt;code&gt;onCreate()&lt;/code&gt; when activity restart.(savedInstanceState wont be null since you have saved some data in it before activity get destroyed)</source>
          <target state="translated">활동이 파괴되면 &lt;code&gt;SaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 메소드가 호출되고 거기에 저장하려는 데이터를 저장합니다. 그리고 활동이 다시 시작되면 &lt;code&gt;onCreate()&lt;/code&gt; 에서 동일하게 나타납니다. (활동이 파괴되기 전에 일부 데이터를 저장했기 때문에 saveedInstanceState는 null이 아닙니다)</target>
        </trans-unit>
        <trans-unit id="fe000ca18fed19c86b29988523117d0fa3476fba" translate="yes" xml:space="preserve">
          <source>When an activity is created it's  onCreate() method is called.</source>
          <target state="translated">활동이 작성되면 onCreate () 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7037321aeffdd9ea93756424ab6c502f36f7cda5" translate="yes" xml:space="preserve">
          <source>When an instance of an Activity gets destroyed and the System recreates a new instance (for example, configuration change). It tries to recreate it using a set of saved data of old Activity State (&lt;strong&gt;instance state&lt;/strong&gt;).</source>
          <target state="translated">활동 인스턴스가 소멸되고 시스템이 새 인스턴스 (예 : 구성 변경)를 다시 작성하는 경우 이전 활동 상태 ( &lt;strong&gt;instance state&lt;/strong&gt; )의 저장된 데이터 세트를 사용하여이를 재 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a1397a30190c4c1451dd4205b7628110696a74a5" translate="yes" xml:space="preserve">
          <source>When applying this concept, the activity just continues to use the last saved state, regardless of whether it was an initial open with reboots in between or a reopen due to the back stack.</source>
          <target state="translated">이 개념을 적용 할 때 액티비티가 처음으로 열린 상태인지 아니면 다시 스택으로 인해 다시 열린 지 여부에 관계없이 활동은 마지막으로 저장된 상태를 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4fa62a378bcd4f7418b39cb8691bbce43dbd3718" translate="yes" xml:space="preserve">
          <source>When testing your hello world example there are a few ways to leave and return to the Activity.</source>
          <target state="translated">Hello World 예제를 테스트 할 때 몇 가지 방법으로 활동을 종료하고 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523c44f6aa55034d8ae4eedaf908d2bc7ebc117b" translate="yes" xml:space="preserve">
          <source>When you press the back button the Activity is finished. Re-launching the app is a brand new instance. You aren't resuming from the background at all.</source>
          <target state="translated">뒤로 버튼을 누르면 활동이 완료됩니다. 앱을 다시 시작하는 것은 새로운 사례입니다. 당신은 전혀 백그라운드에서 재개되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0245328997efbfaa4a6772efcd662e40be32fd87" translate="yes" xml:space="preserve">
          <source>When you press the home button or use the task switcher the Activity will go into the background. When navigating back to the application onCreate will only be called if the Activity had to be destroyed.</source>
          <target state="translated">홈 버튼을 누르거나 작업 전환기를 사용하면 활동이 배경으로 이동합니다. 응용 프로그램으로 돌아갈 때 onCreate는 활동을 파괴 해야하는 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bde74985ade4026a21de660516fb194d30c52a34" translate="yes" xml:space="preserve">
          <source>Which to choose for restoring Activity state?</source>
          <target state="translated">활동 상태를 복원하기 위해 선택할 수있는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="15f0fa1f93e4f5096a5df7aa7f2b635d5b2e0451" translate="yes" xml:space="preserve">
          <source>You must override &lt;code&gt;onSaveInstanceState&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState&lt;/code&gt; to store and retrieve your variables you want to be persistent</source>
          <target state="translated">지속하려는 변수를 저장하고 검색하려면 &lt;code&gt;onSaveInstanceState&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState&lt;/code&gt; 를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="e284dcc6df7a14df80dad493541a1a48c5ccbbed" translate="yes" xml:space="preserve">
          <source>You need to override &lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; and write the application state values you want to change to the &lt;code&gt;Bundle&lt;/code&gt; parameter like this:</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState(Bundle savedInstanceState)&lt;/code&gt; 를 재정의하고 다음과 같이 &lt;code&gt;Bundle&lt;/code&gt; 매개 변수에 변경하려는 애플리케이션 상태 값을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="aafbe683885219a03d91994f495fe865456fdf92" translate="yes" xml:space="preserve">
          <source>You return to the app from the background after the OS has destroyed the activity.</source>
          <target state="translated">OS가 활동을 파괴 한 후 백그라운드에서 앱으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9ee2d3fa32e8a81c76f202907661f73dd44acc09" translate="yes" xml:space="preserve">
          <source>You would usually use this technique to store instance values for your application (selections, unsaved text, etc.).</source>
          <target state="translated">일반적으로이 기술을 사용하여 애플리케이션의 인스턴스 값 (선택, 저장되지 않은 텍스트 등)을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="14cc4f238e05194b2051e422ea411af3ff2c43b9" translate="yes" xml:space="preserve">
          <source>Your Activity will only be re-created with a state bundle when:</source>
          <target state="translated">다음과 같은 경우에만 활동이 상태 번들로 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="401225f701851f15a91db5909f506dd01d4a7299" translate="yes" xml:space="preserve">
          <source>and then in &lt;code&gt;onCreate()&lt;/code&gt; or &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;</source>
          <target state="translated">그런 다음 &lt;code&gt;onCreate()&lt;/code&gt; 또는 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e744c62a1531a7d3816a29a305bdea75e0510e1a" translate="yes" xml:space="preserve">
          <source>and use that to obtain the contents of my variable when I needed it, along the lines of:</source>
          <target state="translated">그리고 필요할 때 내 변수의 내용을 얻으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="d6d46a9486f34d2a4f4c16c5884630b54d1e5610" translate="yes" xml:space="preserve">
          <source>or you can save variables or object in view model, in this case the view model will hold the life cycle until the activity is destroyed.</source>
          <target state="translated">또는 뷰 모델에 변수 또는 객체를 저장할 수 있습니다.이 경우 뷰 모델은 활동이 파괴 될 때까지 수명주기를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9b199dd59ffbfb3b2470ec58e2251be7dd34f5cc" translate="yes" xml:space="preserve">
          <source>put your values in &quot;outState&quot; Bundle object like outState.putString(&quot;key&quot;,&quot;Welcome Back&quot;) and save by calling super.
When activity will be destroyed it's state get saved in Bundle object and can be restored after recreation in onCreate() or onRestoreInstanceState(). Bundle received in onCreate() and onRestoreInstanceState() are same.</source>
          <target state="translated">outState.putString ( &quot;key&quot;, &quot;Welcome Back&quot;)과 같은 &quot;outState&quot;Bundle 객체에 값을 넣고 super를 호출하여 저장합니다. 활동이 파괴되면 상태는 Bundle 객체에 저장되고 onCreate () 또는 onRestoreInstanceState ()에서 재생 후 복원 할 수 있습니다. onCreate () 및 onRestoreInstanceState ()에서 수신 된 번들은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e9bb9c4cea2c1b033a08233a06951da1b1dfe6e2" translate="yes" xml:space="preserve">
          <source>save:</source>
          <target state="translated">save:</target>
        </trans-unit>
        <trans-unit id="4a7cf61c20a4c3cd62e2773efce644abc579ccb4" translate="yes" xml:space="preserve">
          <source>savedInstanceState is an object of Bundle class which is null for the first time, but it contains values when it is recreated. To save Activity's state you have to override onSaveInstanceState().</source>
          <target state="translated">savedInstanceState는 처음으로 null 인 Bundle 클래스의 객체이지만 다시 생성 될 때 값을 포함합니다. 활동 상태를 저장하려면 onSaveInstanceState ()를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="6730c072fe1012f6ae332fca56c1a746e8e87912" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;onSaveInstanceState()&lt;/code&gt; and &lt;code&gt;onRestoreInstanceState()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onSaveInstanceState()&lt;/code&gt; 및 &lt;code&gt;onRestoreInstanceState()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96901f983bdf1c877f70d5eee18accdaba69139f" translate="yes" xml:space="preserve">
          <source>you can use the &lt;code&gt;Live Data&lt;/code&gt; and &lt;code&gt;View Model&lt;/code&gt; For L&lt;code&gt;ifecycle Handel&lt;/code&gt; From &lt;code&gt;JetPack&lt;/code&gt;. see this Reference :</source>
          <target state="translated">&lt;code&gt;JetPack&lt;/code&gt; 의 &lt;code&gt;Live Data&lt;/code&gt; &lt;code&gt;ifecycle Handel&lt;/code&gt; 의 라이브 데이터 및 &lt;code&gt;View Model&lt;/code&gt; 사용할 수 있습니다. 이 참조를 참조하십시오 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
