<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/15666048">
    <body>
      <group id="15666048">
        <trans-unit id="64a58ac5bcfe347c123a856c3f7ac41a16c18e93" translate="yes" xml:space="preserve">
          <source>&quot; Hello world &quot; example with &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt; &amp;ldquo; Hello world&amp;rdquo;示例：</target>
        </trans-unit>
        <trans-unit id="27ab96a759e2b4ef1d829c8525ca087d26314532" translate="yes" xml:space="preserve">
          <source>&quot;$injector is used to retrieve object instances as defined by &lt;strong&gt;provider&lt;/strong&gt;&quot; not service, not factory but provider.</source>
          <target state="translated">&amp;ldquo; $ injector用于检索由&lt;strong&gt;提供程序&lt;/strong&gt;定义的对象实例，而不是服务，不是工厂而是提供程序。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="47d91685928f3bdbd8a6e0bbabc322e70072c356" translate="yes" xml:space="preserve">
          <source>*Again if any portion of the above code is confusing, check out the Factory section where I explain what it all does it greater details.</source>
          <target state="translated">*如果以上代码中的任何部分让人感到困惑,请查看 &quot;工厂 &quot;部分,在这里我将详细解释它的作用。</target>
        </trans-unit>
        <trans-unit id="f4d91701275cfa2997fcf5752d0f40b1c281d19d" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;service&lt;/code&gt; for most cases of default</source>
          <target state="translated">1.大多数情况下的默认服务</target>
        </trans-unit>
        <trans-unit id="b474cc94e43caf4ce704bf9f973a68251b25cd13" translate="yes" xml:space="preserve">
          <source>1.Provider object is created using constructor function we defined in our provider function.</source>
          <target state="translated">1.提供者对象是使用我们在提供者函数中定义的构造函数创建的。</target>
        </trans-unit>
        <trans-unit id="4c2cfdc84411546e36f7e4d88a4a92785dd9ead0" translate="yes" xml:space="preserve">
          <source>1.Services are singleton objects that are created when necessary and are never cleaned up until the end of the application life-cycle (when the browser is closed). Controllers are destroyed and cleaned up when they are no longer needed.</source>
          <target state="translated">1.服务是在必要时创建的单子对象,直到应用程序生命周期结束(浏览器关闭时)才会被清理掉。当不再需要的时候,控制器就会被销毁和清理。</target>
        </trans-unit>
        <trans-unit id="4edf8c51b9d95a7ca3a85d5aeca515c293064266" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;factory&lt;/code&gt; used to create the service that specific instance</source>
          <target state="translated">2. &lt;code&gt;factory&lt;/code&gt; 用来创建特定实例的服务</target>
        </trans-unit>
        <trans-unit id="d01f9f1efa5be666f175edf0f3d066f99322711a" translate="yes" xml:space="preserve">
          <source>2.The easiest way to create a service is by using the factory() method.
The factory() method allows us to define a service by returning an object that contains service functions and service data. The service definition function is where we place our injectable services, such as $http and $q.
Ex:</source>
          <target state="translated">2.创建服务最简单的方法是使用factory()方法。factory()方法允许我们通过返回一个包含服务函数和服务数据的对象来定义服务。服务定义函数就是我们将可注入服务的地方,比如$http和$q。比如说。</target>
        </trans-unit>
        <trans-unit id="81049cf8d158fd8f6aa9e09fb3f7674dc7278ae0" translate="yes" xml:space="preserve">
          <source>2.The function we passed in app.config(), get executed. This is called config phase, and here we have a chance to customize our service.</source>
          <target state="translated">2、我们在app.config()中传递的函数,得到执行。这就是所谓的config阶段,在这里我们有机会定制我们的服务。</target>
        </trans-unit>
        <trans-unit id="e06f9e5bc87b677a928a701f0b17b557a83c7cd8" translate="yes" xml:space="preserve">
          <source>3.Finally service instance is created by calling $get method of serviceProvider.</source>
          <target state="translated">3.最后通过调用serviceProvider的$get方法创建服务实例。</target>
        </trans-unit>
        <trans-unit id="10247f3761146ad3fd29f8f04438a385637cbd75" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt;  (&amp;lt;-- GOOD)
&lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673（&amp;lt;-&lt;/a&gt;很好） &lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96509fbd15a55d9f8c6b0f16f86f369bd1959c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;'s stored value comes from running &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 的存储值来自运行 &lt;code&gt;fn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9806d20accdcf4a7d7bf03bac15b08c0e80af8cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;&amp;rsquo;s stored value comes from &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 的储值来自 &lt;code&gt;new&lt;/code&gt; &lt;code&gt;fn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c10d4a6de0cf092cde9d6b1c37da584005618d85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;&amp;rsquo;s stored value comes from first getting an instance by &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;, and then running a &lt;code&gt;$get&lt;/code&gt; method of the instance.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 的存储值来自于首先通过 &lt;code&gt;new&lt;/code&gt; &lt;code&gt;fn&lt;/code&gt; 获取实例，然后运行该实例的 &lt;code&gt;$get&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f37e6ab171ca302e86496ad45c7c8b082187c7b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lazily Instantiated&lt;/em&gt;: If it is not injected it won't be instantiated ever. So to use it will have to inject it to a module.</source>
          <target state="translated">&lt;em&gt;延迟实例化&lt;/em&gt; ：如果未注入，则永远不会实例化。 因此，要使用它，必须将其注入模块。</target>
        </trans-unit>
        <trans-unit id="bbc415a0718bc792ec75efc2d5784a6b2ed76fb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Singleton&lt;/em&gt;: If injected to multiple modules, all will have access to only one particular instance. That is why very convenient to share data across different controllers.</source>
          <target state="translated">&lt;em&gt;单例&lt;/em&gt; ：如果注入到多个模块，则所有人都只能访问一个特定实例。 这就是为什么在不同的控制器之间共享数据非常方便。</target>
        </trans-unit>
        <trans-unit id="de74c279e2d766663b22cc4a4bef8ec70061c8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）工厂&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1920da3aedb3ed95be87c557b3978bf5d2066e0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; When you&amp;rsquo;re using a &lt;strong&gt;Factory&lt;/strong&gt; you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.</source>
          <target state="translated">&lt;strong&gt;1）&lt;/strong&gt;使用&lt;strong&gt;Factory时，&lt;/strong&gt;您将创建一个对象，向其添加属性，然后返回该对象。 当您将此工厂传递到控制器中时，对象上的那些属性现在将通过工厂在该控制器中可用。</target>
        </trans-unit>
        <trans-unit id="bf79a918a5f8400f69451d6c86a9de8622bc5f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）服务&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fa71875fc3e6ae341d7d13637af55d62c8e9c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; When you&amp;rsquo;re using &lt;strong&gt;Service&lt;/strong&gt;, AngularJS instantiates it behind the scenes with the &amp;lsquo;new&amp;rsquo; keyword. Because of that, you&amp;rsquo;ll add properties to &amp;lsquo;this&amp;rsquo; and the service will return &amp;lsquo;this&amp;rsquo;. When you pass the service into your controller, those properties on &amp;lsquo;this&amp;rsquo; will now be available on that controller through your service.</source>
          <target state="translated">&lt;strong&gt;2）&lt;/strong&gt;当您使用&lt;strong&gt;Service时&lt;/strong&gt; ，AngularJS使用'new'关键字在后台实例化它。 因此，您将向'this'添加属性，服务将返回'this'。 当您将服务传递到控制器中时，&amp;ldquo; this&amp;rdquo;上的那些属性现在将通过您的服务在该控制器上可用。</target>
        </trans-unit>
        <trans-unit id="e5e4c731a8abb79b43eb7b7ad7722ae53bd1e526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3）提供者&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7891b22be8f5ced507d3b35a1a21c59dd69ef84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt;&lt;strong&gt;Providers&lt;/strong&gt; are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.</source>
          <target state="translated">&lt;strong&gt;3）&lt;/strong&gt; &lt;strong&gt;提供程序&lt;/strong&gt;是您可以传递给.config（）函数的唯一服务。 当您想为服务对象提供模块范围的配置之前，请使用提供程序。</target>
        </trans-unit>
        <trans-unit id="f7a0bc6a5e55d68fca9019cb4c62b65667302df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Is they do same or have same behaviour?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;他们是相同的行为还是相同的行为？&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a51970d21894731b55def79e30e17e9251193f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Should I use service or factory? What&amp;rsquo;s the difference?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;我应该使用服务还是工厂？&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;有什么不同？&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61bce34778beb7a07d2ad51ff5e0491a8fe2ce06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And for beginner understand:-&lt;/strong&gt; This may not correct use case but in high level this is what usecase for these three.</source>
          <target state="translated">&lt;strong&gt;对于初学者来说，&lt;/strong&gt;这可能不是正确的用例，但从总体上讲，这是这三个用例的用例。</target>
        </trans-unit>
        <trans-unit id="49456beeefd4b18f05312ca85704d73c7cc3b7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; the purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.</source>
          <target state="translated">&lt;strong&gt;AngularJS Factory：Factory&lt;/strong&gt;的目的也与Service相同，但是在这种情况下，我们创建一个新对象并添加函数作为该对象的属性，最后返回该对象。</target>
        </trans-unit>
        <trans-unit id="42188f33ed58db2766909a9db9de01785a8ee47d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Provider:&lt;/strong&gt; the purpose of this is again same however Provider gives the output of it's $get function.</source>
          <target state="translated">&lt;strong&gt;AngularJS Provider：这样做&lt;/strong&gt;的目的还是相同的，但是Provider给出了$ get函数的输出。</target>
        </trans-unit>
        <trans-unit id="9a762ecbec3e860f39ad0b1b9673d2ba4d24939f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Service:&lt;/strong&gt; is used for sharing utility functions with the service reference in the controller. Service is singleton in nature so for one service only one instance is created in the browser and the same reference is used throughout the page.</source>
          <target state="translated">&lt;strong&gt;AngularJS服务：&lt;/strong&gt;用于与控制器中的服务引用共享实用程序功能。 服务本质上是单例的，因此对于一项服务，在浏览器中仅创建一个实例，并且在整个页面中使用相同的引用。</target>
        </trans-unit>
        <trans-unit id="ba46456a9f8e88791102b2d89c6c02c5e47d2e18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful with &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;注意 &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf2cbd4114b4edf85514bcf9f1a8b65ee626a848" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best answers from SO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SO的最佳答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867130b32fc3b28fc8ec819aa9caaebbdcd1a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both are Singletons&lt;/strong&gt;: Whenever Angular find these as a dependency first time,it create a single instance of service/factory. Once the instance is created, same instance is used forever.</source>
          <target state="translated">&lt;strong&gt;两者都是Singletons&lt;/strong&gt; ：每当Angular第一次将它们作为依赖项时，它都会创建服务/工厂的单个实例。 创建实例后，将永远使用同一实例。</target>
        </trans-unit>
        <trans-unit id="2bfbaa084726b82d3658a48125aa6f2be3899ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be used to model an object with behavior&lt;/strong&gt;: They can both have methods, internal state variables, and so on. Though the way you write that code will differ.</source>
          <target state="translated">&lt;strong&gt;可用于对具有行为的对象进行建模&lt;/strong&gt; ：它们都可以具有方法，内部状态变量等。 尽管您编写该代码的方式会有所不同。</target>
        </trans-unit>
        <trans-unit id="0b8047b6c925051a75984184c3eab229c2a494da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Constant&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b230b0c6b04da427893e313b7c0e9d5aef5ada3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FACTORY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FACTORY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de8ae60c5e367749c74c70c938263e7f3a66bc7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factories:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="129b6a9da449d3568001d3e4449436c7a83896d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;工厂功能：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa83955bc8ebbae5eb9b7e4bea195c0e27d81128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt;
  You simply create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;工厂：&lt;/strong&gt;您只需在工厂内部创建一个对象并将其返回即可。</target>
        </trans-unit>
        <trans-unit id="223321a46b7f883db5389221c0e026bc67b2f8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt; The factory you actually create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;工厂：&lt;/strong&gt;您实际上是在工厂内部创建对象并将其返回的工厂。</target>
        </trans-unit>
        <trans-unit id="4b5add3c153ec4e23637c1d8bfc69736e94082eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factory&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74ccee4a3bcbc7b9bc42b630b85b5d7fe42f6f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; and &lt;strong&gt;Service&lt;/strong&gt; are the most commonly used recipes. The only difference between them is that the &lt;strong&gt;Service&lt;/strong&gt; recipe works better for objects of a custom type, while the &lt;strong&gt;Factory&lt;/strong&gt; can produce JavaScript primitives and functions.</source>
          <target state="translated">&lt;strong&gt;工厂&lt;/strong&gt;和&lt;strong&gt;服务&lt;/strong&gt;是最常用的配方。 它们之间的唯一区别是， &lt;strong&gt;服务&lt;/strong&gt;配方对于自定义类型的对象更有效，而&lt;strong&gt;Factory&lt;/strong&gt;可以生成JavaScript原语和函数。</target>
        </trans-unit>
        <trans-unit id="af69167d5e31ec4171b3b71e86c23e55eb8b3ef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; use a factory function which return a service instance.
&lt;strong&gt;serviceInstance = fnFactory();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;工厂&lt;/strong&gt;使用返回服务实例的工厂函数。 &lt;strong&gt;serviceInstance = fnFactory（）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d42eff7ec39af4e9117015764522229b8db7933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;: The value you are providing needs to be calculated based on other data.</source>
          <target state="translated">&lt;strong&gt;工厂&lt;/strong&gt; ：您提供的值需要根据其他数据进行计算。</target>
        </trans-unit>
        <trans-unit id="15a7f656197166d5af0768e868e3d0738e892b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051543166b882d0c0302b61c6fccd2ef13890dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does provider syntax internally work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;提供程序语法在内部如何工作？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f24bbfd879178823cf1a6f4fa4db8fd25d88804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to create a service?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何创建服务？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15472d9a104bad65c0d954254428090db1217241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazily instantiated&lt;/strong&gt; &amp;ndash; Angular only instantiates a service/factory when an application component depends on it.</source>
          <target state="translated">&lt;strong&gt;延迟实例化&lt;/strong&gt; &amp;ndash; Angular仅在应用程序组件依赖它时才实例化服务/工厂。</target>
        </trans-unit>
        <trans-unit id="4fc1597dfe992d87dcc418262208d7b520cc2ad4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="048671a3c07af864b3160d99c16b04e4022573ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非TL; DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c27c9c6e707014afaaa93121ac5aee4552e03e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PROVIDER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PROVIDER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e9a7279f005fa392f0780ed27247cdff005c85f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;提供者功能：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2f1801fb48bf71dd7299a789ae89b7ca28c73fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9463ee84dc44104bf418d730d2dc12c20735e2ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="034f13e153a713ef6e1f67d027f037acfcdca111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; defines a providerConstructor function, this providerConstructor function defines a factory function &lt;strong&gt;$get&lt;/strong&gt; . Angular calls $get() to create the service object. Provider syntax has an added advantage of configuring the service object before it get instantiated.
&lt;strong&gt;serviceInstance = $get();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt;定义了providerConstructor函数，此providerConstructor函数定义了工厂函数&lt;strong&gt;$ get&lt;/strong&gt; 。 Angular调用$ get（）创建服务对象。 提供程序语法还具有在实例化服务对象之前对其进行配置的另一个优点。 &lt;strong&gt;serviceInstance = $ get（）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58cb452a8449a0480646f34b32c4f0b2da41ff86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">&lt;strong&gt;提供者&lt;/strong&gt;是最复杂的配方类型。 除非您要构建需要全局配置的可重用代码段，否则不需要它。</target>
        </trans-unit>
        <trans-unit id="af542f111be3a6b9b5eb1bba21844f854821a94c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; recipe is used mostly in the app config, before the app has fully started/initialized.</source>
          <target state="translated">在应用程序已完全启动/初始化之前， &lt;strong&gt;提供者&lt;/strong&gt;配方主要用于应用程序配置中。</target>
        </trans-unit>
        <trans-unit id="5a61e7a67bd37a0cf34633a672f8ef4ac61746cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;: You want to be able to configure, during the config phase, the object that is going to be created before it&amp;rsquo;s created. Use the Provider mostly in the app config, before the app has fully initialized.</source>
          <target state="translated">&lt;strong&gt;提供者&lt;/strong&gt; ：您希望能够在配置阶段配置要在创建对象之前创建的对象。 在应用程序完全初始化之前，主要在应用程序配置中使用提供程序。</target>
        </trans-unit>
        <trans-unit id="1ab8bcf5f1f62f6d12fe01bbd3797bf5f9edaf2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a Value from a &lt;code&gt;Service&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;从 &lt;code&gt;Service&lt;/code&gt; 返回值&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="d8b225479a57e32c9b9bbce57b80db8803839e1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVICE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;SERVICE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="1723b4864b43191225849524b7490ba00136326d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service vs provider vs factory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;服务vs提供者vs工厂：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddf188521bbad55d877526ca526e747468a9d8b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c48ba497f0f940a447148665d013066e3821706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3625561b5600fccb382876ffa98f2e89623ad206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; is all about &lt;code&gt;new&lt;/code&gt; keyword actually which as we know does 4 things:</source>
          <target state="translated">&lt;strong&gt;服务&lt;/strong&gt;实际上是关于 &lt;code&gt;new&lt;/code&gt; 关键字的，据我们所知，它做四件事：</target>
        </trans-unit>
        <trans-unit id="643dc71e1844f583afedf84a3c290ed53ca1a986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; use a constructor function and Angular invoke this constructor function using 'new' keyword for creating the service instance.
&lt;strong&gt;serviceInstance = new fnServiceConstructor();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;服务&lt;/strong&gt;使用构造函数，Angular使用&amp;ldquo; new&amp;rdquo;关键字调用此构造函数以创建服务实例。 &lt;strong&gt;serviceInstance =新的fnServiceConstructor（）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="934fb2b4d6b5561f358e2ea098b02b599fac1ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;: You are returning an object with methods.</source>
          <target state="translated">&lt;strong&gt;服务&lt;/strong&gt; ：您正在返回带有方法的对象。</target>
        </trans-unit>
        <trans-unit id="917d24961ee3bd9397cee700d2697066bdc8ebc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Services:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b86f1f47c5d0e8ae25c0b4bfeddc837fbe553961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Singletons&lt;/strong&gt; &amp;ndash; Each component
  dependent on a service gets a reference to the single instance
  generated by the service factory.</source>
          <target state="translated">&lt;strong&gt;单例&lt;/strong&gt; &amp;ndash;依赖于服务的每个组件都将引用由服务工厂生成的单个实例。</target>
        </trans-unit>
        <trans-unit id="236552a9e0c737f0dce61f3fd278300c81df52c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;工厂源代码&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dca20d5f0cc36fd7219eb42b9a3bd59a5f14fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;服务源代码&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3ab06d46eba0ea55e3a63532b502c8e68aaf041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntactic Sugar is the difference&lt;/strong&gt;. Only provider is needed. Or in other words only provider is the real angular, all other ones are derived(to reduce code). There is a simple version as well, called Value()  which returns just the value, no calculation or function. Even Value is derived from provider!</source>
          <target state="translated">&lt;strong&gt;语法糖是与众不同的&lt;/strong&gt; 。 只需要提供者。 或者换句话说，只有提供者是真正的角度，所有其他提供者都是派生的（以减少代码）。 还有一个简单的版本，称为Value（），它仅返回值，不返回计算或函数。 价值甚至来自提供者！</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5f0f8f2415dfbd7ea64cb1c92c78ef8982eb6db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The major differences among Services, Factories, and Providers are their complexities. Services are the simplest form, Factories are a little more robust, and Providers are configurable at runtime.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;服务，工厂和提供者之间的主要区别在于它们的复杂性。&lt;/strong&gt; &lt;strong&gt;服务是最简单的形式，工厂则更健壮，提供者可以在运行时进行配置。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5265dba3d641afcb7e0148f9229e5a29c5cbf0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding AngularJS Factory, Service and Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;了解AngularJS工厂，服务和提供者&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="372f60334aa5d8918e891d52c780ab816ff7ba23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="761726747ff7c1d3bd1aef8307caf8babe873bd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4167298ff7e32e5b1773e3433a0f0e71939b8a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Service:&lt;/strong&gt;
In AngularJS, &lt;strong&gt;Service&lt;/strong&gt; is nothing but a singleton JavaScript object which can store some useful methods or properties. This singleton object is created per ngApp(Angular app) basis and it is shared among all the controllers within current app. When Angularjs instantiate a service object, it register this service object with a unique service name. So each time when we need service instance, Angular search the registry for this service name, and it returns the reference to service object. Such that we can invoke method, access properties etc on the service object.
You may have question whether you can also put properties, methods on scope object of controllers! So why you need service object? Answers is: services are shared among multiple controller scope. If you put some properties/methods in a controller's scope object , it will be available to current scope only. But when you define methods, properties on service object, it will be available globally and can be accessed in any  controller's scope by injecting that service.</source>
          <target state="translated">&lt;strong&gt;什么是服务：&lt;/strong&gt;在AngularJS中， &lt;strong&gt;服务&lt;/strong&gt;不过是可以存储一些有用方法或属性的单例JavaScript对象。 该单例对象是基于ngApp（Angular应用）创建的，并且在当前应用内的所有控制器之间共享。 Angularjs实例化服务对象时，会使用唯一的服务名称注册该服务对象。 因此，每当我们需要服务实例时，Angular都会在注册表中搜索该服务名称，然后它将对服务对象的引用返回。 这样我们就可以在服务对象上调用方法，访问属性等。 您可能会质疑是否还可以将属性，方法放在控制器的作用域对象上！ 那么为什么需要服务对象？ 答案是：服务在多个控制器范围之间共享。 如果将某些属性/方法放在控制器的作用域对象中，则该属性/方法仅对当前作用域可用。 但是，当您定义服务对象上的方法和属性时，它将在全局范围内可用，并且可以通过注入该服务在任何控制器的作用域中进行访问。</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e41544278c3c3cd14f313568ad2ca9b33654a735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7c38fc9331c68d06c6051d868ab8034c6a1b71f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5fb6e5fc13a01937ae02611fcad859574413d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index.html&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;index.html&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd88803cf5db529cfe7cb230c25afc9af0e166" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;provider:&lt;/strong&gt; The provider there&amp;rsquo;s a $get you define and it can be used to get the object that returns the data.</source>
          <target state="translated">&lt;strong&gt;provider：&lt;/strong&gt;提供程序，您可以定义一个$ get，它可以用来获取返回数据的对象。</target>
        </trans-unit>
        <trans-unit id="8592d58f6159c5178f21fdbf4b05247f87defaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;service:&lt;/strong&gt; The service you just have a standard function that uses the this keyword to define function.</source>
          <target state="translated">&lt;strong&gt;service：&lt;/strong&gt;您只具有使用this关键字定义功能的标准功能的服务。</target>
        </trans-unit>
        <trans-unit id="6460b1c41e40026d826a70fb0ec47b36aaed8244" translate="yes" xml:space="preserve">
          <source>A factory is a plain old function that returns a value. The return value is what gets injected into things that depend on the factory. A typical factory pattern in Angular is to return an object with functions as properties, like this:</source>
          <target state="translated">工厂是一个普通的老函数,它是一个返回值的函数。返回值就是被注入到依赖工厂的东西中的东西。在Angular中,一个典型的工厂模式是将函数作为属性返回一个对象,就像这样。</target>
        </trans-unit>
        <trans-unit id="6654378b8441365d9dbee921cd9c4b6d04ad1238" translate="yes" xml:space="preserve">
          <source>A factory is function where you can manipulate/add logic before creating an object, then the newly created object gets returned.</source>
          <target state="translated">工厂是一个函数,你可以在创建一个对象之前操作add逻辑,然后返回新创建的对象。</target>
        </trans-unit>
        <trans-unit id="92657294903a95f8b7ea12e4be26ab19bd209d60" translate="yes" xml:space="preserve">
          <source>A more general value, that is possible to be computed right away. It works by passing a function to AngularJS with the logic needed to compute the value and AngularJS executes it, and it saves the return value in the named variable.</source>
          <target state="translated">一个比较一般的值,就是可以马上计算出来的。它的工作原理是,将一个函数传给AngularJS,其中包含计算值所需的逻辑,AngularJS会执行它,并将返回值保存在命名的变量中。</target>
        </trans-unit>
        <trans-unit id="c98519712b1bcd2194f1ab8049f9c95b677e57e2" translate="yes" xml:space="preserve">
          <source>A provider
= must contain a property called $get (+Factory, + Service, + Value)</source>
          <target state="translated">提供器=必须包含一个名为 $get (+Factory,+Service,+Value)的属性。</target>
        </trans-unit>
        <trans-unit id="70cc8179c33c6143e3fd269921c56cce6794df6a" translate="yes" xml:space="preserve">
          <source>A provider is used to create a configurable service object. You can configure the service setting from config function. It returns a value by using the &lt;code&gt;$get()&lt;/code&gt; function. The &lt;code&gt;$get&lt;/code&gt; function gets executed on the run phase in angular.</source>
          <target state="translated">提供程序用于创建可配置的服务对象。 您可以从配置功能配置服务设置。 它通过使用 &lt;code&gt;$get()&lt;/code&gt; 函数返回一个值。 &lt;code&gt;$get&lt;/code&gt; 函数在运行阶段以角度执行。</target>
        </trans-unit>
        <trans-unit id="2690ab0e17349d256212ca0a5c254ff9f7224715" translate="yes" xml:space="preserve">
          <source>A provider that can
instantiate + do something = Service (+ Factory, + Value)</source>
          <target state="translated">一个可以实例化+做事的提供者=服务(+工厂,+值)</target>
        </trans-unit>
        <trans-unit id="1552cdef3a8c9efd2ca6378e425896d47cd0a7d2" translate="yes" xml:space="preserve">
          <source>A provider that can just
instantiate and return = Factory (+ Value)</source>
          <target state="translated">一个可以直接实例化并返回=Factory (+Value)的提供者</target>
        </trans-unit>
        <trans-unit id="5bac4ef74fca1e1f11c40a61c18eb5751a56a24e" translate="yes" xml:space="preserve">
          <source>A provider that can return value = Value</source>
          <target state="translated">可以返回value=Value的提供者</target>
        </trans-unit>
        <trans-unit id="daa9ad8c9da39c96b0cd1b5e9b85ad76ef92e025" translate="yes" xml:space="preserve">
          <source>A service is a constructor function, and Angular will instantiate it by calling new &lt;code&gt;yourServiceName()&lt;/code&gt;. This means a couple of things.</source>
          <target state="translated">服务是构造函数，Angular将通过调用new &lt;code&gt;yourServiceName()&lt;/code&gt; 实例化该服务。 这意味着几件事情。</target>
        </trans-unit>
        <trans-unit id="f30916da78a012d617c7c608b91dd4f9e4ccb7cc" translate="yes" xml:space="preserve">
          <source>A service is a more stripped-down version of &lt;em&gt;factory&lt;/em&gt; which is valid only when the value is an object, and it allows for writing any logic directly in the function (as if it would be a constructor), as well as declaring and accessing the object properties using the &lt;em&gt;this&lt;/em&gt; keyword.</source>
          <target state="translated">服务是&lt;em&gt;工厂&lt;/em&gt;的简化版本，仅当值是对象时才有效，并且它允许直接在函数中编写任何逻辑（就像它将是构造函数一样），以及声明和访问使用&lt;em&gt;this&lt;/em&gt;关键字的对象属性。</target>
        </trans-unit>
        <trans-unit id="e010047a835b4f08a52ebcf31da9133c3b0c83eb" translate="yes" xml:space="preserve">
          <source>Ability to use other services (have dependencies)</source>
          <target state="translated">使用其他服务的能力(有依赖性)</target>
        </trans-unit>
        <trans-unit id="90d836d3d0cb6acecac1372abfaeed5f7a898db3" translate="yes" xml:space="preserve">
          <source>After reading all these post It created more confuse for me.. But still all is worthfull information.. finally I found following table which will give information with simple comparision</source>
          <target state="translated">看完这些帖子后,让我更加困惑......但是所有的信息还是很有价值的.....最后我找到了下面的表格,它可以提供简单的对比信息</target>
        </trans-unit>
        <trans-unit id="eba926c51e345f5492b036b8fb2838c80ca0f326" translate="yes" xml:space="preserve">
          <source>Ajax call or third party integrations needs to be &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">Ajax呼叫或第三方集成需要&lt;strong&gt;服务&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="db39b22c1144a74c69ee802842ea57e37d383130" translate="yes" xml:space="preserve">
          <source>All Services are &lt;strong&gt;singletons&lt;/strong&gt;; they get instantiated once per app. They can be &lt;strong&gt;of any type&lt;/strong&gt;, whether it be a primitive, object literal, function, or even an instance of a custom type.</source>
          <target state="translated">所有服务都是&lt;strong&gt;单身人士&lt;/strong&gt; ; 每个应用实例化一次。 它们可以是&lt;strong&gt;任何类型&lt;/strong&gt; ，无论是原语，对象文字，函数，还是自定义类型的实例。</target>
        </trans-unit>
        <trans-unit id="44b4a8e5249ee92bb57692eb4f38230e89ca0b32" translate="yes" xml:space="preserve">
          <source>All of these are used to share reusable singleton objects. It helps to share reusable code across your app/various components/modules.</source>
          <target state="translated">所有这些都是用来共享可重用的单体对象。它有助于在你的应用程序中共享可重用的代码。</target>
        </trans-unit>
        <trans-unit id="15074bf6692ab4d76bbae6a637a1292c7beea479" translate="yes" xml:space="preserve">
          <source>All special purpose objects except for the Controller are defined via Factory recipes.</source>
          <target state="translated">除了控制器以外,所有的特殊用途对象都是通过工厂食谱定义的。</target>
        </trans-unit>
        <trans-unit id="1797d93eba62a3e50c0f75705fc2654c1c5d7cc1" translate="yes" xml:space="preserve">
          <source>All the good answers already. I would like to add few more points on &lt;strong&gt;Service&lt;/strong&gt; and &lt;strong&gt;Factory&lt;/strong&gt;. Along with the difference between service/factory. And  one can also have questions like:</source>
          <target state="translated">所有的好答案已经。 我想在&lt;strong&gt;Service&lt;/strong&gt;和&lt;strong&gt;Factory&lt;/strong&gt;上添加更多点。 以及服务/工厂之间的差异。 还有一个问题，例如：</target>
        </trans-unit>
        <trans-unit id="644fa5425851502f8b0f2b6d2e894a7a71bc764b" translate="yes" xml:space="preserve">
          <source>An additional clarification is that factories can create functions/primitives, while services cannot. Check out this &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; based on Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt;.</source>
          <target state="translated">另外需要说明的是，工厂可以创建函数/基元，而服务不能。 查看基于Epokk的jsFiddle： &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/skeller88/PxdSP/1351/ 。</target>
        </trans-unit>
        <trans-unit id="1698cdf07eaa30b1f4d2eb589b401f5aa7c167b5" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Factory&lt;/strong&gt; is all about Factory Pattern - contains functions that return Objects like that Service.</source>
          <target state="translated">而&lt;strong&gt;Factory&lt;/strong&gt;就是关于Factory Pattern的-包含返回诸如Service之类的对象的函数。</target>
        </trans-unit>
        <trans-unit id="087105228646ef19c5b815759ef3bd7c8d79035e" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Value, Factory, Service and Constant&lt;/strong&gt; (4 ways) - the syntactic sugar over &lt;strong&gt;Provider&lt;/strong&gt; way/recepie.</source>
          <target state="translated">和&lt;strong&gt;价值，工厂，服务和常量&lt;/strong&gt; （4种方式）- &lt;strong&gt;提供者&lt;/strong&gt;方式/收入之上的语法糖。</target>
        </trans-unit>
        <trans-unit id="a4a0d683875e15a20d100e9c4f3cabe527897b12" translate="yes" xml:space="preserve">
          <source>And a better answer would be this:
&quot;An Angular service is created by a service factory. These service factories are functions which, in turn, are created by a service provider. The service providers are constructor functions. When instantiated they must contain a property called $get, which holds the service factory function.&quot;</source>
          <target state="translated">而更好的答案应该是这样的。&quot;一个Angular服务是由服务工厂创建的。这些服务工厂是函数,而这些服务工厂又是由服务提供者创建的。这些服务提供者是构造函数。当它们被实例化时,必须包含一个名为$get的属性,它持有服务工厂函数。&quot;</target>
        </trans-unit>
        <trans-unit id="6e1a1be7a3c89b4a49965d6931152adc8b79b49f" translate="yes" xml:space="preserve">
          <source>And this simple/short video: covers also &lt;strong&gt;Provider&lt;/strong&gt;: &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (there you see can see how they go from factory to provider)</source>
          <target state="translated">这个简单/简短的视频：还介绍了&lt;strong&gt;提供者&lt;/strong&gt; ： &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https&lt;/a&gt; : //www.youtube.com/watch?v=HvTZbQ_hUZY （您可以看到他们如何从工厂转到提供者）</target>
        </trans-unit>
        <trans-unit id="5e753d8417cbbaa903d75c9067f03b753d972dae" translate="yes" xml:space="preserve">
          <source>Angular injection gives us the first hint in reaching this conclusion.</source>
          <target state="translated">Angular injection给了我们得出这个结论的第一个提示。</target>
        </trans-unit>
        <trans-unit id="c0fbc9b675108602e2b9fac4e8674fd1d9ad2553" translate="yes" xml:space="preserve">
          <source>AngularJS provide different methods to register a service. Here we will concentrate on three methods factory(..),service(..),provider(..);</source>
          <target state="translated">AngularJS提供了不同的方法来注册一个服务。这里我们将集中讨论三个方法 factory(...)、service(...)、provider(...)。</target>
        </trans-unit>
        <trans-unit id="a2a043dede3ac539ee64b89b2d49b7bd51e23891" translate="yes" xml:space="preserve">
          <source>AngularJS provides &lt;strong&gt;'factory('serviceName', fnFactory)'&lt;/strong&gt; method which takes two parameter, serviceName and a JavaScript function. Angular creates service instance by invoking the function &lt;strong&gt;fnFactory()&lt;/strong&gt; such as below.</source>
          <target state="translated">AngularJS提供了&lt;strong&gt;'factory（'serviceName'，fnFactory）'&lt;/strong&gt;方法，该方法&lt;strong&gt;带有&lt;/strong&gt;两个参数，serviceName和一个JavaScript函数。 Angular通过调用如下函数&lt;strong&gt;fnFactory（）&lt;/strong&gt;创建服务实例。</target>
        </trans-unit>
        <trans-unit id="67487acbc494fde4c0ecdb230e55c47bdc819cc5" translate="yes" xml:space="preserve">
          <source>AngularJS: Service vs provider vs factory</source>
          <target state="translated">AngularJS:服务VS提供者VS工厂</target>
        </trans-unit>
        <trans-unit id="62b46f141dc945f1baeeda1b182a386db6799d55" translate="yes" xml:space="preserve">
          <source>Answers for above 1 and 2 questions:</source>
          <target state="translated">以上1、2题的答案。</target>
        </trans-unit>
        <trans-unit id="f5181cbde0884af842b881fdae06a3ba0616e0a1" translate="yes" xml:space="preserve">
          <source>As a side note, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; are all derived from provider.</source>
          <target state="translated">附带说明一下， &lt;code&gt;service&lt;/code&gt; ， &lt;code&gt;factory&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 都是从provider派生的。</target>
        </trans-unit>
        <trans-unit id="b8e0a3698c74b06188537beb6504f05ed6da8541" translate="yes" xml:space="preserve">
          <source>As mentioned before, the whole point of creating a service with Provider is to be able to alter some variables through the app.config function before the final object is passed to the rest of the application. Let&amp;rsquo;s see an example of that.</source>
          <target state="translated">如前所述，使用Provider创建服务的全部目的是能够在最终对象传递给应用程序的其余部分之前通过app.config函数更改某些变量。 让我们来看一个例子。</target>
        </trans-unit>
        <trans-unit id="ac8bd4adf742322d3119e359d466fd027d4a144c" translate="yes" xml:space="preserve">
          <source>As pointed out by several people here correctly a factory, provider, service, and even value and constant are versions of the same thing. You can dissect the more general &lt;code&gt;provider&lt;/code&gt; into all of them. Like so:</source>
          <target state="translated">正如这里的几个人所指出的那样，工厂，提供者，服务，甚至价值和常数都是同一事物的版本。 您可以将更一般的 &lt;code&gt;provider&lt;/code&gt; 分解为所有提供程序 。 像这样：</target>
        </trans-unit>
        <trans-unit id="7ac115d7759453df5c7a6ee0d961bac591936f70" translate="yes" xml:space="preserve">
          <source>Basically all of the mentioned types (service, factory, provider, etc.) are just creating and configuring global variables (that are of course global to the entire application), just as old fashioned global variables were.</source>
          <target state="translated">基本上所有提到的类型(服务、工厂、提供者等)都只是在创建和配置全局变量(当然是对整个应用程序的全局变量),就像老式的全局变量一样。</target>
        </trans-unit>
        <trans-unit id="76a6d228807b2f0db9ca8817dcc7b6fe1992e7f5" translate="yes" xml:space="preserve">
          <source>Below &lt;strong&gt;setArtist&lt;/strong&gt; accepts an artist and allows you to set the artist. &lt;strong&gt;getArtist&lt;/strong&gt; returns the artist. &lt;strong&gt;callItunes&lt;/strong&gt; first calls makeUrl() in order to build the URL we&amp;rsquo;ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying &amp;lsquo;There was an error&amp;rsquo;.</source>
          <target state="translated">在&lt;strong&gt;setArtist&lt;/strong&gt;下方，接受一位艺术家，并允许您设置该艺术家。 &lt;strong&gt;getArtist&lt;/strong&gt;返回艺术家。 &lt;strong&gt;callItunes&lt;/strong&gt;首先调用makeUrl（）来构建将用于$ http请求的URL。 然后，它设置一个Promise对象，使用最终URL发出$ http请求，然后由于$ http返回Promise，因此我们可以在请求后调用.success或.error。 然后，我们用iTunes数据解决诺言，或者通过显示&amp;ldquo;出现错误&amp;rdquo;的消息来拒绝诺言。</target>
        </trans-unit>
        <trans-unit id="ecc9654f84abda3f226923e7181cd6dedcabf706" translate="yes" xml:space="preserve">
          <source>Below is code for how you can think about what the &amp;lsquo;new&amp;rsquo; keyword is actually doing in JavaScript. It&amp;rsquo;s basically a code example of the above paragraph. I&amp;rsquo;ve put the &amp;lsquo;interpreter view&amp;rsquo; or the way the interpreter sees the code inside of notes.</source>
          <target state="translated">下面的代码说明了如何思考'new'关键字在JavaScript中的实际作用。 这基本上是上一段的代码示例。 我已经将&amp;ldquo;解释器视图&amp;rdquo;或解释器在便笺内看到代码的方式放入了。</target>
        </trans-unit>
        <trans-unit id="baeffb61d23b4b1a1faec7ea79fc7982401fe040" translate="yes" xml:space="preserve">
          <source>But if you declare an AngularJS &quot;value&quot; (for example., &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt;), you can inject it into services and factories, but NOT into the provider-creating function. You can, however, inject it into the &lt;code&gt;$get&lt;/code&gt; function that you define for your provider. This is mentioned in the AngularJS documentation, but it's easy to miss. You can find it on the %provide page in the sections on the value and constant methods.</source>
          <target state="translated">但是，如果您声明AngularJS&amp;ldquo;值&amp;rdquo;（例如， &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt; ），则可以将其注入服务和工厂，但不能注入提供者创建函数。 但是，您可以将其注入为提供程序定义的 &lt;code&gt;$get&lt;/code&gt; 函数中。 AngularJS文档中提到了这一点，但很容易遗漏。 您可以在％provide页面上的value和常量方法部分中找到它。</target>
        </trans-unit>
        <trans-unit id="e1cc6d183fce2197bb4d499453f325c6ce15d621" translate="yes" xml:space="preserve">
          <source>But that is way too wordy. A shorter way to write this would be &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</source>
          <target state="translated">但这太罗word了。 &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt; 可以写成一个简短的方法。</target>
        </trans-unit>
        <trans-unit id="b0b23422a6346dcd33f9ef7c177b5c4c2e0c0ba5" translate="yes" xml:space="preserve">
          <source>But what if we wanted to configure the &lt;code&gt;Greeter&lt;/code&gt; class before the injection? Then we could write</source>
          <target state="translated">但是，如果我们想在注射之前配置 &lt;code&gt;Greeter&lt;/code&gt; 类，该怎么办？ 然后我们可以写</target>
        </trans-unit>
        <trans-unit id="83edd94ef1f4218a2a09268ba1c79454b4d8ce41" translate="yes" xml:space="preserve">
          <source>But what if you want to be more OO and have a class called Greeter?</source>
          <target state="translated">但是,如果你想更OO一点,有一个班级叫Greeter怎么办?</target>
        </trans-unit>
        <trans-unit id="bead6ae023dd1ddfc66d0c3554dd68115419ed4a" translate="yes" xml:space="preserve">
          <source>Code posted here is copied straight from the above source, to benefit readers.</source>
          <target state="translated">这里发布的代码是直接从上面的源头复制过来的,让读者受益。</target>
        </trans-unit>
        <trans-unit id="d3a3e026964278d33abfaf0d31b51f4e99ed0a5a" translate="yes" xml:space="preserve">
          <source>Defining and using Service, Factory and Provider are explained at &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;中解释和定义了服务，工厂和提供者</target>
        </trans-unit>
        <trans-unit id="1d0d609d4405f2baa362951b7009d2417093fd7d" translate="yes" xml:space="preserve">
          <source>Delayed/lazy initialization</source>
          <target state="translated">Delayedlazy初始化</target>
        </trans-unit>
        <trans-unit id="cb560adb9a207096df4103f0ce35af068e58441a" translate="yes" xml:space="preserve">
          <source>Due to how JavaScript constructors work, if you return a complex value &lt;code&gt;(i.e., an Object)&lt;/code&gt; from a &lt;code&gt;constructor&lt;/code&gt; function, the caller will get that Object instead of the this instance.</source>
          <target state="translated">由于JavaScript构造函数的工作原理，如果您从 &lt;code&gt;constructor&lt;/code&gt; 函数返回复杂的值 &lt;code&gt;(i.e., an Object)&lt;/code&gt; ，则调用者将获得该Object而不是this实例。</target>
        </trans-unit>
        <trans-unit id="0ce56bb9d7649bd1affa9d15ef3b25e94ed4bf16" translate="yes" xml:space="preserve">
          <source>Essentially, Provider, Factory, and Service are all Services. A Factory is a special case of a Service when all you need is a $get() function, allowing you to write it with less code.</source>
          <target state="translated">本质上,Provider、Factory和Service都是Service。Factory是Service的一个特殊情况,当你只需要一个$get()函数时,Factory是Service的一个特殊情况,它允许你用更少的代码来编写。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="5871c248f6153cd0a547c43f6815327faa66746e" translate="yes" xml:space="preserve">
          <source>Factories are the most popular way to create and configure a service. There&amp;rsquo;s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below.</source>
          <target state="translated">工厂是创建和配置服务的最流行方法。 实际上，TL; DR所说的不多。 您只需创建一个对象，向其添加属性，然后返回该对象。 然后，当您将工厂传递到控制器中时，对象上的那些属性现在将通过工厂在该控制器中可用。 下面是一个更广泛的示例。</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="c8e6696140d2e75575a027e3db926b81e7fa86b8" translate="yes" xml:space="preserve">
          <source>Factory and Service are the most commonly used recipes. The only difference between them is that the Service recipe works better for objects of a custom type, while the Factory can produce JavaScript primitives and functions.</source>
          <target state="translated">Factory和Service是最常用的口诀。它们之间唯一的区别是,Service口诀对于自定义类型的对象效果更好,而Factory可以产生JavaScript基元和函数。</target>
        </trans-unit>
        <trans-unit id="7ee844ac41ac4ad9686ec614f908d3bdcb5b3e81" translate="yes" xml:space="preserve">
          <source>Factory is a class. Use factories if you want to provide custom classes for your code (can't be done with services because they are already instantiated).</source>
          <target state="translated">Factory是一个类。如果你想为你的代码提供自定义类(不能用服务来做,因为服务已经被实例化了),就使用workshop。</target>
        </trans-unit>
        <trans-unit id="c43d055974d1f89c7db6d2a6f06d9706cf84359d" translate="yes" xml:space="preserve">
          <source>Features of Factory:</source>
          <target state="translated">工厂的特点。</target>
        </trans-unit>
        <trans-unit id="8f233e0733ea2bd7573612519e22b6483ee2aae2" translate="yes" xml:space="preserve">
          <source>Features of Provider:</source>
          <target state="translated">供应商的特点。</target>
        </trans-unit>
        <trans-unit id="8b33d5b1a4171b12f08419f5a3175c6118df72b0" translate="yes" xml:space="preserve">
          <source>Features of Service:</source>
          <target state="translated">服务的特点。</target>
        </trans-unit>
        <trans-unit id="555321235e9eb2d0c7b4fff9ef2c877ead66f84d" translate="yes" xml:space="preserve">
          <source>Finally the UI which works with any of the above services:</source>
          <target state="translated">最后是与上述任何一个服务配合使用的UI。</target>
        </trans-unit>
        <trans-unit id="aa41b2f6147d97e7462dbecaf90f19a90ed1b067" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s create our Constructor.</source>
          <target state="translated">首先，让我们创建构造函数。</target>
        </trans-unit>
        <trans-unit id="dfb58a29f6c2cb946fda2080d277aff94876b78f" translate="yes" xml:space="preserve">
          <source>First let's have a look at the syntax:</source>
          <target state="translated">首先让我们来看一下语法。</target>
        </trans-unit>
        <trans-unit id="16ae293f476b801e0ec98c3b0c772f3098dc7e49" translate="yes" xml:space="preserve">
          <source>First of all, let's talk about &lt;strong&gt;services&lt;/strong&gt; in AngularJS!</source>
          <target state="translated">首先，让我们谈谈AngularJS中的&lt;strong&gt;服务&lt;/strong&gt; ！</target>
        </trans-unit>
        <trans-unit id="f626e9e8c764b63df367572217b72dfec8d3d0d8" translate="yes" xml:space="preserve">
          <source>First of all: &lt;strong&gt;Provider&lt;/strong&gt; is the way/recipe to create a &lt;code&gt;service&lt;/code&gt; (singleton object) that suppose to be injected by $injector (how AngulaJS goes about IoC pattern).</source>
          <target state="translated">首先： &lt;strong&gt;提供者&lt;/strong&gt;是创建 &lt;code&gt;service&lt;/code&gt; （单对象）的方式/方法，该服务应该由$ injector注入（AngulaJS如何处理IoC模式）。</target>
        </trans-unit>
        <trans-unit id="a7d7fe2894bd6c66d071f952d684e2326b49b1e5" translate="yes" xml:space="preserve">
          <source>First things first, let&amp;rsquo;s create our &amp;lsquo;private&amp;rsquo; and helper function. This should look very familiar since we did the exact same thing with our factory. I won&amp;rsquo;t explain what each line does here because I did that in the factory example, if you&amp;rsquo;re confused, re-read the factory example.</source>
          <target state="translated">首先，让我们创建我们的&amp;ldquo;私有&amp;rdquo;和助手功能。 这应该看起来非常熟悉，因为我们对工厂进行了完全相同的操作。 我不会在这里解释每行的功能，因为我在工厂示例中做了此操作，如果您感到困惑，请重新阅读工厂示例。</target>
        </trans-unit>
        <trans-unit id="274879ea02d1b32f25fdcf0d6f4b8638ad84e454" translate="yes" xml:space="preserve">
          <source>First we set up our Provider in a similar way we did with our Service and Factory. The variables below are our &amp;lsquo;private&amp;rsquo; and helper function.</source>
          <target state="translated">首先，我们以与服务和工厂类似的方式设置提供商。 下面的变量是我们的&amp;ldquo;私有&amp;rdquo;和帮助函数。</target>
        </trans-unit>
        <trans-unit id="0f18e05a1a2cf2fab2012ea1acb85960d14f94f3" translate="yes" xml:space="preserve">
          <source>Follows the factory design pattern. The factory is a central place that produces new objects or functions.</source>
          <target state="translated">遵循工厂的设计模式。工厂是生产新的物品或功能的中心场所。</target>
        </trans-unit>
        <trans-unit id="124166829dcd8ce12e68c97aa74ddc87e6f4700c" translate="yes" xml:space="preserve">
          <source>For Data manipulations create it as &lt;strong&gt;factory&lt;/strong&gt;</source>
          <target state="translated">对于数据操作，将其创建为&lt;strong&gt;工厂&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d4008d04bf8dc913dd361a11d1dbf2dd7fff6d9" translate="yes" xml:space="preserve">
          <source>For basic scenarios factory&amp;amp;Service behaves same.</source>
          <target state="translated">对于基本方案，factory＆Service的行为相同。</target>
        </trans-unit>
        <trans-unit id="be44b8b9aee8e49c0f525f0d589dc7ae0563c459" translate="yes" xml:space="preserve">
          <source>For me the best and the simplest way of understanding the difference is:</source>
          <target state="translated">对我来说,最好的也是最简单的理解方式,那就是区别。</target>
        </trans-unit>
        <trans-unit id="56ff743259acbed742d59f1071ec5c09de91c4a2" translate="yes" xml:space="preserve">
          <source>For me, the revelation came when I realized that they all work the same way: by running something &lt;strong&gt;once&lt;/strong&gt;, storing the value they get, and then cough up &lt;strong&gt;that same stored value&lt;/strong&gt; when referenced through &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">对我来说，当我意识到它们都以相同的方式工作时，就得到了启示：通过运行&lt;strong&gt;一次&lt;/strong&gt; ，存储它们获得的值，然后在通过&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依赖注入&lt;/a&gt;引用时&lt;strong&gt;，&lt;/strong&gt;咳出&lt;strong&gt;相同的存储值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27ee14ba7c9338b5357168645fc5fca69baff87" translate="yes" xml:space="preserve">
          <source>For more details, see a post I wrote on the difference: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</source>
          <target state="translated">有关更多详细信息，请参阅我撰写的有关差异的文章： &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http&lt;/a&gt; : //www.shanemkeller.com/tldr-services-vs-factories-in-angular/</target>
        </trans-unit>
        <trans-unit id="bd35023ca5fbcbbe13f3b8c3e423caa7232e2d3e" translate="yes" xml:space="preserve">
          <source>For the most part, just stick with using factories for everything.
  Their behavior is easier to understand. There&amp;rsquo;s no choice to make
  about whether to return a value or not, and furthermore, no bugs to be
  introduced if you do the wrong thing.</source>
          <target state="translated">在大多数情况下，只需坚持使用工厂进行所有操作即可。 他们的行为更容易理解。 没有选择是否返回值，而且如果执行错误的操作，也不会引入任何错误。</target>
        </trans-unit>
        <trans-unit id="6bc24d8b9740765e38f68d62a235ac7b05a3ba82" translate="yes" xml:space="preserve">
          <source>From Docs &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Service/Factory&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">从文档&lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;服务/工厂&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="f49fa588c62b7f2f5abba55d1b95ecf06f622095" translate="yes" xml:space="preserve">
          <source>From the AngularJS mailing list I got &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;an amazing thread&lt;/a&gt; that explains service vs factory vs provider and their injection usage. Compiling the answers:</source>
          <target state="translated">从AngularJS邮件列表中，我得到了&lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;一个很棒的线程&lt;/a&gt; ，它解释了服务，工厂，提供者及其注入用法。 汇编答案：</target>
        </trans-unit>
        <trans-unit id="fd7022a8753e6add51e2b9d2c29e59c134d3fba6" translate="yes" xml:space="preserve">
          <source>Functions and instance variables will be properties of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">函数和实例变量将是 &lt;code&gt;this&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="bc7b97dbb27777de72af8d9af9dd816e007cb47e" translate="yes" xml:space="preserve">
          <source>Here is a simpler example.  I'm using a few third party libraries that expect a &quot;Position&quot; object exposing latitude and longitude, but via different object properties.  I didn't want to hack the vendor code, so I adjusted the &quot;Position&quot; objects I was passing around.</source>
          <target state="translated">这里有一个比较简单的例子。我在使用一些第三方库,期望有一个 &quot;Position &quot;对象来暴露经纬度,但通过不同的对象属性。我不想黑掉供应商的代码,所以我调整了一下我所传递的 &quot;位置 &quot;对象。</target>
        </trans-unit>
        <trans-unit id="ae278ffeba6cafa1c3d2a70eeb6622299cb946ec" translate="yes" xml:space="preserve">
          <source>Here is a summary of when to use each:</source>
          <target state="translated">下面就为大家总结一下什么时候使用各。</target>
        </trans-unit>
        <trans-unit id="c9a8b09d58f2e8e0771d8f78424d27f226d92eae" translate="yes" xml:space="preserve">
          <source>Here is some broilerplate code I've come up with as a code-template for object factory in AngularjS.  I've used a Car/CarFactory as an example to illustrate.  Makes for simple implementation code in the controller.</source>
          <target state="translated">下面是我在AngularjS中的对象工厂的代码-模板。我用了一个CarCarCarFactory作为例子来说明。在控制器中,这是个简单的实现代码。</target>
        </trans-unit>
        <trans-unit id="489ba797946b9923375b0c16c73874f3a39fb591" translate="yes" xml:space="preserve">
          <source>Here you&amp;rsquo;ll notice we&amp;rsquo;re not attaching those variables/function to &amp;lsquo;service&amp;rsquo;. We&amp;rsquo;re simply creating them in order to either use or modify them later.</source>
          <target state="translated">在这里，您会注意到我们没有将这些变量/功能附加到&amp;ldquo;服务&amp;rdquo;上。 我们只是创建它们，以便以后使用或修改它们。</target>
        </trans-unit>
        <trans-unit id="00a6aa13d323a6c412ee902d5b3d4d2d1ab4fe03" translate="yes" xml:space="preserve">
          <source>Here's a great further explanation by Misko:</source>
          <target state="translated">以下是米斯科的进一步解释。</target>
        </trans-unit>
        <trans-unit id="da5246469f32f79cb4f5e21f982157b5bf8fb944" translate="yes" xml:space="preserve">
          <source>Here's the article this image is from:</source>
          <target state="translated">这里是这篇文章的图片来源。</target>
        </trans-unit>
        <trans-unit id="850ac93122b4715c223580cbbd975d246cb16f45" translate="yes" xml:space="preserve">
          <source>Hope this has cleared up your understanding about &lt;strong&gt;Factory, Service and Provider&lt;/strong&gt;.</source>
          <target state="translated">希望这清除了您对&lt;strong&gt;Factory，Service和Provider的&lt;/strong&gt;理解。</target>
        </trans-unit>
        <trans-unit id="1c040a989c90c935f04c9d9df515887605a02c08" translate="yes" xml:space="preserve">
          <source>How AngularJS instantiates particular components (simplified):</source>
          <target state="translated">AngularJS如何实例化特定组件(简化)。</target>
        </trans-unit>
        <trans-unit id="c385f140fdcc5112262dbad26d8a3223347e8d51" translate="yes" xml:space="preserve">
          <source>I am trying to keep it simple. It's all about basic JavaScript concept.</source>
          <target state="translated">我在努力保持简单。这都是关于基本的JavaScript概念。</target>
        </trans-unit>
        <trans-unit id="29ca2a8a57db27d862d4085e8c93784f8e59cb96" translate="yes" xml:space="preserve">
          <source>I came across this video which explains clearly about factory, service and provider methodologies for developing AngularJS Custom Services:</source>
          <target state="translated">我遇到了这个视频,它清楚地解释了开发AngularJS自定义服务的工厂、服务和提供者方法论。</target>
        </trans-unit>
        <trans-unit id="37a6f10678b28516c544ad2d07c57f10ba034f15" translate="yes" xml:space="preserve">
          <source>I know a lot of excellent answer but I have to share my experience of using</source>
          <target state="translated">我知道很多优秀的答案,但我不得不分享一下我的使用经验。</target>
        </trans-unit>
        <trans-unit id="9310dd05ba382096e00103255eac7688e44ef73b" translate="yes" xml:space="preserve">
          <source>I noticed something interesting when playing around with providers.</source>
          <target state="translated">我在玩供应商的时候注意到一个有趣的事情。</target>
        </trans-unit>
        <trans-unit id="86c3d8da7c12380d33b628011f4dc967a20694c5" translate="yes" xml:space="preserve">
          <source>I still refer to them as &amp;ldquo;services&amp;rdquo; when I&amp;rsquo;m talking about injecting
  them as dependencies, though.</source>
          <target state="translated">但是，当我谈论将它们作为依赖项注入时，我仍然将它们称为&amp;ldquo;服务&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b0314451a42f81ae46c88a72d5644b737ddc515b" translate="yes" xml:space="preserve">
          <source>If you want to use in angular module config function should created as &lt;strong&gt;provider&lt;/strong&gt;</source>
          <target state="translated">如果要在角度模块中使用，则应将配置函数创建为&lt;strong&gt;提供程序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="760bfbfabac6439646276d21d21c1e88b0f1b52a" translate="yes" xml:space="preserve">
          <source>In the constructor function we can use 'this' keyword for adding properties/methods to the service object.
example:</source>
          <target state="translated">在构造函数中,我们可以使用'this'关键字为服务对象添加propertiesmethods。</target>
        </trans-unit>
        <trans-unit id="c5401a20db45adfe8456a9fe2493978105e9f5da" translate="yes" xml:space="preserve">
          <source>In the controller above we&amp;rsquo;re injecting in the &amp;lsquo;myFactory&amp;rsquo; service. We then set properties on our $scope object with data from &amp;lsquo;myFactory&amp;rsquo;. The only tricky code above is if you&amp;rsquo;ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You&amp;rsquo;ll notice our controller is very &amp;lsquo;thin&amp;rsquo; (This is a good coding practise). All of our logic and persistent data is located in our service, not in our controller.</source>
          <target state="translated">在上面的控制器中，我们正在注入&amp;ldquo; myFactory&amp;rdquo;服务。 然后，使用来自&amp;ldquo; myFactory&amp;rdquo;的数据在$ scope对象上设置属性。 上面唯一棘手的代码是，如果您以前从未处理过诺言。 由于callItunes返回了承诺，因此我们可以使用.then（）方法，并且仅在iTunes数据满足承诺后，才可以设置$ scope.data.artistData。 您会注意到我们的控制器非常&amp;ldquo;薄&amp;rdquo;（这是一个很好的编码实践）。 我们所有的逻辑和持久数据都位于我们的服务中，而不是我们的控制器中。</target>
        </trans-unit>
        <trans-unit id="ad7c151fc09de45e372af1a2de7be6c6b7781661" translate="yes" xml:space="preserve">
          <source>In the service, we create function names as property with &lt;em&gt;this&lt;/em&gt; object.</source>
          <target state="translated">在服务中，我们使用&lt;em&gt;此&lt;/em&gt;对象将函数名称创建为属性。</target>
        </trans-unit>
        <trans-unit id="ca27a70fdef565576b6c87e2f47e6b4dd70d0118" translate="yes" xml:space="preserve">
          <source>In this case the injector simply returns the value as is. But what if you want to compute the value? Then use a factory</source>
          <target state="translated">在这种情况下,喷射器只需返回原样的值。但是,如果你想计算这个值呢?那就用一个出厂时的</target>
        </trans-unit>
        <trans-unit id="ce56ab93a5137d82e8def783797ed2029027acad" translate="yes" xml:space="preserve">
          <source>It can be just a collection of functions like a class. Hence, it can be instantiated in different controllers when you are injecting it inside your controller/factory/directive functions. It is instantiated only once per app.</source>
          <target state="translated">它可以只是一个函数的集合,就像一个类一样。因此,当你在controllerfactorydirective函数中注入它时,它可以在不同的控制器中实例化。它在每个应用程序中只被实例化一次。</target>
        </trans-unit>
        <trans-unit id="5b20c360213ae1af905212996e857c3ffcf8c5ac" translate="yes" xml:space="preserve">
          <source>It works like using a combination of &lt;em&gt;service&lt;/em&gt; and &lt;em&gt;provider&lt;/em&gt;, by passing to provider a function that has properties declared using the &lt;em&gt;this&lt;/em&gt; keyword, which can be used from the &lt;code&gt;app.config&lt;/code&gt;.</source>
          <target state="translated">通过将具有使用&lt;em&gt;this&lt;/em&gt;关键字声明的属性的函数传递给提供程序，该函数就像将&lt;em&gt;service&lt;/em&gt;和&lt;em&gt;provider&lt;/em&gt;组合使用，可以从 &lt;code&gt;app.config&lt;/code&gt; 中使用它 。</target>
        </trans-unit>
        <trans-unit id="68eb0b5a5293d5d11d5a247852531e63d5c542a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use the factory in our application as we can simply inject it where we need it at run-time.</source>
          <target state="translated">在我们的应用程序中使用工厂很容易，因为我们可以在运行时将其简单地注入到需要的地方。</target>
        </trans-unit>
        <trans-unit id="5e6ceae9d10cdf11f4c911a2da17d4ac57381842" translate="yes" xml:space="preserve">
          <source>It's the another way, we can register a service. The only difference is the way AngularJS tries to instantiate the service object. This time angular uses 'new' keyword and call the constructor function something like below.</source>
          <target state="translated">这是另一种方式,我们可以注册一个服务。唯一不同的是AngularJS尝试实例化服务对象的方式。这一次Angular使用了 &quot;new &quot;关键字,并调用构造函数如下。</target>
        </trans-unit>
        <trans-unit id="f8bf660b8496971437b76589be4961ef8c377635" translate="yes" xml:space="preserve">
          <source>JS Fiddle Demo</source>
          <target state="translated">JS Fiddle演示</target>
        </trans-unit>
        <trans-unit id="0e399439c408eca064ae4becd7265accff216db8" translate="yes" xml:space="preserve">
          <source>Just to clarify things, from the AngularJS source, you can see a service just calls the factory function which in turn calls the provider function:</source>
          <target state="translated">只是为了澄清一下,从AngularJS源码中,你可以看到一个服务只是调用了工厂函数,而工厂函数又反过来调用了提供者函数。</target>
        </trans-unit>
        <trans-unit id="7de5f61ab2c0b942cc33db2f46d0c4b470d32a4e" translate="yes" xml:space="preserve">
          <source>Let's again have a look at the Syntax first:</source>
          <target state="translated">我们再来看一下语法,先来看看语法。</target>
        </trans-unit>
        <trans-unit id="0fec230ed8200309bfc8c6866e454394b38359c7" translate="yes" xml:space="preserve">
          <source>Let's discuss the three ways of handling business logic in AngularJS in a simple way: (&lt;strong&gt;Inspired by Yaakov's Coursera AngularJS course&lt;/strong&gt;)</source>
          <target state="translated">让我们以一种简单的方式来讨论在AngularJS中处理业务逻辑的三种方式：（ &lt;strong&gt;受Yaakov的Coursera AngularJS课程的启发&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="fa350ad45511dbe39a4d035e7a10563f5896422d" translate="yes" xml:space="preserve">
          <source>Lets start with the difference between Service and factory:</source>
          <target state="translated">让我们从服务和工厂的区别入手。</target>
        </trans-unit>
        <trans-unit id="778a430f691a6018fcf57447a71b7c8cd2109696" translate="yes" xml:space="preserve">
          <source>Like I mentioned before, once you really understand what &amp;lsquo;new&amp;rsquo; does, Services are almost identical to factories in AngularJS.</source>
          <target state="translated">就像我之前提到的，一旦您真正了解了&amp;ldquo;新&amp;rdquo;功能，服务就几乎与AngularJS中的工厂相同。</target>
        </trans-unit>
        <trans-unit id="25c6b479772ad22656b96f68f104741b92338f0a" translate="yes" xml:space="preserve">
          <source>Little late to the party.  But I thought this is more helpful for who would like to learn (or have clarity) on developing Angular JS Custom Services using factory, service and provider methodologies.</source>
          <target state="translated">来的有点晚了。但我想这对那些想学习(或者说对使用工厂、服务和提供者方法论来开发Angular JS自定义服务的人来说更有帮助。</target>
        </trans-unit>
        <trans-unit id="4bd48a3b50a9f231823114ba704dfccf0bd973da" translate="yes" xml:space="preserve">
          <source>My clarification on this matter:</source>
          <target state="translated">我对这个问题的澄清。</target>
        </trans-unit>
        <trans-unit id="fbf210c3ae8711990847a3d950af4119f3209adb" translate="yes" xml:space="preserve">
          <source>My understanding is very simple below.</source>
          <target state="translated">我的理解很简单如下。</target>
        </trans-unit>
        <trans-unit id="69f7e11da9f849693995d92816d880bd6fdc64e1" translate="yes" xml:space="preserve">
          <source>Not only produces singleton, but customizable services.</source>
          <target state="translated">不单单是生产单子,还有可定制的服务。</target>
        </trans-unit>
        <trans-unit id="982fb0ca939387b6254256e3ab0dfb3a7cc84d6c" translate="yes" xml:space="preserve">
          <source>Not only we can create a factory that's dynamically configurable, but at the time of using the factory, with the provider method, we could custom configure the factory just once at the bootstrapping of our entire application.</source>
          <target state="translated">不仅我们可以创建一个可以动态配置的工厂,而且在使用工厂的时候,通过provider方法,我们可以在整个应用的启动时,只需要在整个应用的启动时自定义配置一次工厂。</target>
        </trans-unit>
        <trans-unit id="672bd2d09c7ed72a3eac6c27958d21691133d0dc" translate="yes" xml:space="preserve">
          <source>Note that it is possible to return a object (in which case it will function similar to a &lt;em&gt;service&lt;/em&gt;) or a function (that will be saved in the variable as a callback function).</source>
          <target state="translated">请注意，可以返回一个对象（在这种情况下，其功能将类似于&lt;em&gt;service&lt;/em&gt; ）或一个函数（将作为回调函数保存在变量中）。</target>
        </trans-unit>
        <trans-unit id="5b1a8bd7c0a880872f4d9c7b867ae61242c0dfa0" translate="yes" xml:space="preserve">
          <source>Now having this knowledge of what the &amp;lsquo;new&amp;rsquo; keyword really does in JavaScript, creating a Service in AngularJS should be easier to understand.</source>
          <target state="translated">了解了'new'关键字在JavaScript中的实际作用后，在AngularJS中创建服务应该更容易理解。</target>
        </trans-unit>
        <trans-unit id="d741df1b012ea25d838dc2c21bf70522da5f8512" translate="yes" xml:space="preserve">
          <source>Now just like in our factory and Service, setArtist, getArtist, and callItunes will be available in whichever controller we pass myProvider into. Here&amp;rsquo;s the myProvider controller (which is almost exactly the same as our factory/Service controller).</source>
          <target state="translated">现在就像在我们的工厂和服务中一样，无论将myProvider传递给哪个控制器，都可以使用setArtist，getArtist和callItunes。 这是myProvider控制器（与我们的factory / Service控制器几乎完全相同）。</target>
        </trans-unit>
        <trans-unit id="698af625bfcb4e8f8fcb2e7bcb26d8b5f98e4503" translate="yes" xml:space="preserve">
          <source>Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here&amp;rsquo;s the myService controller (which is almost exactly the same as our factory controller).</source>
          <target state="translated">现在就像在我们的工厂中一样，无论将myService传递给哪个控制器，都可以使用setArtist，getArtist和callItunes。 这是myService控制器（与我们的工厂控制器几乎完全相同）。</target>
        </trans-unit>
        <trans-unit id="33179f320db64f96208e8896db6147d2739c655b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a method onto our Person&amp;rsquo;s prototype so it will be available on every instance of our Person &amp;lsquo;class&amp;rsquo;.</source>
          <target state="translated">现在，让我们在Person的原型上添加一个方法，以便该方法在Person的&amp;ldquo;类&amp;rdquo;的每个实例上可用。</target>
        </trans-unit>
        <trans-unit id="4e56b2bbd2bcd8c15e0879964355623ffab1f7bb" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add some &amp;lsquo;private&amp;rsquo; variables to our callback function. These won&amp;rsquo;t be directly accessible from the controller, but we will eventually set up some getter/setter methods on &amp;lsquo;service&amp;rsquo; to be able to alter these &amp;lsquo;private&amp;rsquo; variables when needed.</source>
          <target state="translated">现在，让我们在回调函数中添加一些&amp;ldquo;私有&amp;rdquo;变量。 这些将不能从控制器直接访问，但是我们最终将在&amp;ldquo;服务&amp;rdquo;上设置一些getter / setter方法，以便能够在需要时更改这些&amp;ldquo;私有&amp;rdquo;变量。</target>
        </trans-unit>
        <trans-unit id="b83d5faac981eb0e79df8c1e9fbac8b90b76a95f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what actually is happening when you use the &amp;lsquo;new&amp;rsquo; keyword in JavaScript. First thing you should notice is that after using &amp;lsquo;new&amp;rsquo; in our example, we&amp;rsquo;re able to call a method (sayName) on &amp;lsquo;tyler&amp;rsquo; just as if it were an object - that&amp;rsquo;s because it is. 
So first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says &amp;ldquo;OK, I&amp;rsquo;m going to look on the &amp;lsquo;tyler&amp;rsquo; object we just created, locate the sayName function, then call it. Wait a minute, I don&amp;rsquo;t see it here - all I see is name and age, let me check the prototype. Yup, looks like it&amp;rsquo;s on the prototype, let me call it.&amp;rdquo;.</source>
          <target state="translated">现在，让我们看一下在JavaScript中使用'new'关键字时实际发生的情况。 您应该注意的第一件事是，在我们的示例中使用了&amp;ldquo; new&amp;rdquo;之后，我们就可以像对待对象一样在&amp;ldquo; tyler&amp;rdquo;上调用方法（sayName），这是因为。 所以首先，我们知道我们的Person构造函数正在返回一个对象，无论我们是否可以在代码中看到它。 其次，我们知道，因为我们的sayName函数位于原型上，而不是直接位于Person实例上，所以Person函数返回的对象必须在失败的查找时委派给其原型。 用更简单的术语来说，当我们调用tyler.sayName（）时，解释器会说：&amp;ldquo;好，我要看一下我们刚创建的'tyler'对象，找到sayName函数，然后调用它。 请稍等，我在这里看不到-我看到的只是名字和年龄，让我检查一下原型。 是的，看起来好像在原型上，让我称呼它。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fb6577ce21f8b4d96fd20a371037e7c8ed7c6760" translate="yes" xml:space="preserve">
          <source>Now our factory is complete. We are now able to inject &amp;lsquo;myFactory&amp;rsquo; into any controller and we&amp;rsquo;ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes).</source>
          <target state="translated">现在我们的工厂完成了。 现在，我们可以将&amp;ldquo; myFactory&amp;rdquo;注入任何控制器，然后可以调用附加到服务对象（setArtist，getArtist和callItunes）的方法。</target>
        </trans-unit>
        <trans-unit id="2dd7216c3d216047524da229ce33e07f854c5b20" translate="yes" xml:space="preserve">
          <source>Now that our helper/private variables and function are in place, let&amp;rsquo;s add some properties to the &amp;lsquo;service&amp;rsquo; object. Whatever we put on &amp;lsquo;service&amp;rsquo; can be directly used inside whichever controller we pass &amp;lsquo;myFactory&amp;rsquo; into.</source>
          <target state="translated">现在我们的帮助器/私有变量和函数已经到位，让我们向&amp;ldquo;服务&amp;rdquo;对象添加一些属性。 无论我们放置&amp;ldquo;服务&amp;rdquo;是什么，都可以在传递&amp;ldquo; myFactory&amp;rdquo;的任何控制器中直接使用。</target>
        </trans-unit>
        <trans-unit id="39ddb2f22b7fced081ba8ea176229ca0ac8d8309" translate="yes" xml:space="preserve">
          <source>Now that we have our Person constructor function and our sayName function on its prototype, let&amp;rsquo;s actually create an instance of Person then call the sayName function.</source>
          <target state="translated">现在，我们在其原型上具有Person构造函数和sayName函数，让我们实际创建Person的实例，然后调用sayName函数。</target>
        </trans-unit>
        <trans-unit id="ec51346deab58cf2c25c7d6a3cb4af41dc640f10" translate="yes" xml:space="preserve">
          <source>Now the full Provider code looks like this</source>
          <target state="translated">现在,完整的供应商代码看起来像这样</target>
        </trans-unit>
        <trans-unit id="a8c5c01dc8cb0c4ad9e61b2d0177736881556303" translate="yes" xml:space="preserve">
          <source>Now using the above two in the controller:</source>
          <target state="translated">现在在控制器中使用以上两个。</target>
        </trans-unit>
        <trans-unit id="554f3e5b70223d89fd87ed55eb8c7fa0aea6edc3" translate="yes" xml:space="preserve">
          <source>Now whatever properties we attach to &amp;lsquo;service&amp;rsquo; will be available to us when we pass &amp;lsquo;myFactory&amp;rsquo; into our controller.</source>
          <target state="translated">现在，当我们将&amp;ldquo; myFactory&amp;rdquo;传递到控制器中时，我们附加到&amp;ldquo;服务&amp;rdquo;的任何属性都将可用。</target>
        </trans-unit>
        <trans-unit id="8db4bcee9cc90896dbc924721630384540a94c50" translate="yes" xml:space="preserve">
          <source>Now you can see how &amp;lsquo;thingFromConfig&amp;rsquo; is as empty string in our provider, but when that shows up in the DOM, it will be &amp;lsquo;This sentence was set&amp;hellip;&amp;rsquo;.</source>
          <target state="translated">现在，您可以看到'thingFromConfig'在我们的提供程序中如何为空字符串，但是当它显示在DOM中时，它将是'此句子已设置...'。</target>
        </trans-unit>
        <trans-unit id="ec62b54ee6ce720c21f33325f4f0a65c82d69fdb" translate="yes" xml:space="preserve">
          <source>Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance&amp;rsquo;s name.</source>
          <target state="translated">现在，因为我们将sayName函数放在原型上，所以Person的每个实例都将能够调用sayName函数，以警告该实例的名称。</target>
        </trans-unit>
        <trans-unit id="11f40cd81d972474ebbd1638f071afb14e360695" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll attach all of our methods that will be available in our controller to &amp;lsquo;this&amp;rsquo;.</source>
          <target state="translated">现在，我们将在控制器中可用的所有方法附加到&amp;ldquo; this&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f06e2a3c653d42f7111fe26d1c705865f3c86c73" translate="yes" xml:space="preserve">
          <source>Only provider will be available in config phase of angular, while
  service &amp;amp; factory are not.</source>
          <target state="translated">在角度配置阶段仅提供者可用，而服务和工厂则不可用。</target>
        </trans-unit>
        <trans-unit id="dfdb4f5263d92c8b24c27c443665ded6f3f279be" translate="yes" xml:space="preserve">
          <source>Perhaps the biggest thing to know when dealing with creating a Service is that that it&amp;rsquo;s instantiated with the &amp;lsquo;new&amp;rsquo; keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren&amp;rsquo;t too familiar with what the &amp;lsquo;new&amp;rsquo; keyword actually does, let&amp;rsquo;s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service.</source>
          <target state="translated">也许在创建服务时要知道的最大事情就是使用&amp;ldquo; new&amp;rdquo;关键字实例化了它。 对于您的JavaScript专家来说，这应该为您提供代码本质的一个重要提示。 对于那些在JavaScript中具有有限背景的人或不太熟悉'new'关键字实际功能的人，让我们回顾一些JavaScript基础知识，这些基础知识最终将帮助我们理解服务的性质。</target>
        </trans-unit>
        <trans-unit id="7ceee3f3615a2bbe4ce0ac5a269a311e4821daf4" translate="yes" xml:space="preserve">
          <source>Provider</source>
          <target state="translated">Provider</target>
        </trans-unit>
        <trans-unit id="53d2419e2fad27c745ab7837fb34c5b4cb3b5535" translate="yes" xml:space="preserve">
          <source>Provider is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">Provider是最复杂的配方类型。你不需要它,除非你正在构建一个需要全局配置的可重用代码。</target>
        </trans-unit>
        <trans-unit id="d3f6c702cb3e12640d8a58f3b97ac66d45f4b833" translate="yes" xml:space="preserve">
          <source>Provider is the most flexible method of creating services in Angular.</source>
          <target state="translated">Provider是Angular中最灵活的创建服务的方法。</target>
        </trans-unit>
        <trans-unit id="955559753eafb5cc8b4506201a86bbe417ec9d05" translate="yes" xml:space="preserve">
          <source>Provider() function is the another way for creating services. Let we are interested to create a service which just display some greeting message to the user. But we also want to provide a functionality such that user can set their own greeting message. In technical terms we want to create configurable services. How can we do this ? There must be a way, so that app could pass their custom greeting messages and Angularjs would make it available to factory/constructor function which create our services instance.
In such a case provider() function do the job. using provider() function we can create configurable services.</source>
          <target state="translated">Provider()函数是创建服务的另一种方法。让我们有兴趣创建一个服务,它只是向用户显示一些问候信息。但是我们也希望提供一个功能,让用户可以设置自己的问候语。从技术角度来说,我们希望创建一个可配置的服务。我们如何才能做到这一点呢?必须要有一个方法,让应用程序可以传递他们的自定义问候语,然后Angularjs会将其提供给创建服务实例的factory-constructor函数。在这种情况下,provider()函数就可以完成这个工作。</target>
        </trans-unit>
        <trans-unit id="87b7c08baed1c8e93db95b79bcdca55b631dd7bb" translate="yes" xml:space="preserve">
          <source>Providers</source>
          <target state="translated">Providers</target>
        </trans-unit>
        <trans-unit id="2d56985193e8bf2d6ab8849ef7c57e0e5dde4a2b" translate="yes" xml:space="preserve">
          <source>Providers allow you to configure the provider &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; AngularJS calls the &lt;code&gt;$get&lt;/code&gt; method to get the injectible.</source>
          <target state="translated">提供程序允许您&lt;strong&gt;&lt;em&gt;在&lt;/em&gt;&lt;/strong&gt; AngularJS调用 &lt;code&gt;$get&lt;/code&gt; 方法获取可注射对象&lt;strong&gt;&lt;em&gt;之前&lt;/em&gt;&lt;/strong&gt;配置提供程序。</target>
        </trans-unit>
        <trans-unit id="fa42b9d0b7dbcb3ea427607354fff8602303c4c8" translate="yes" xml:space="preserve">
          <source>Providers have the advantage that they can be configured during the module configuration phase.</source>
          <target state="translated">供应商的优势在于可以在模块配置阶段进行配置。</target>
        </trans-unit>
        <trans-unit id="8d9b9399c4d6be5dbb075743c0ee3d595b3daf9b" translate="yes" xml:space="preserve">
          <source>Result: When declaring factoryName as an injectable argument you will be provided with &lt;strong&gt;the value that is returned by invoking the function reference passed to module.factory&lt;/strong&gt;.</source>
          <target state="translated">结果：当将factoryName声明为可注入参数时，将为您提供&lt;strong&gt;通过调用传递给module.factory的函数引用而返回的值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b8055b0f238e713bbe09a1f5142a3a9c4180d28" translate="yes" xml:space="preserve">
          <source>Result: When declaring providerName as an injectable argument &lt;strong&gt;you will be provided with&lt;/strong&gt;&lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt;. The constructor function is instantiated before the $get method is called - &lt;code&gt;ProviderFunction&lt;/code&gt; is  the function reference passed to module.provider.</source>
          <target state="translated">结果：在将providerName声明为可注入参数时&lt;strong&gt;，将为您提供&lt;/strong&gt; &lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt; 。 在调用$ get方法之前先实例化构造函数-ProviderFunction是传递给module.provider的函数引用。</target>
        </trans-unit>
        <trans-unit id="c70fc6d0d8618584e9490ed45c73cb37b4246b1e" translate="yes" xml:space="preserve">
          <source>Result: When declaring serviceName as an injectable argument &lt;strong&gt;you will be provided with an instance of the function. In other words&lt;/strong&gt;&lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt;.</source>
          <target state="translated">结果：在将serviceName声明为可注入参数时&lt;strong&gt;，将为您提供该函数的实例。&lt;/strong&gt; &lt;strong&gt;换句话说，&lt;/strong&gt; &lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c830a908226f52c7631bae300c0e26abb3631d0" translate="yes" xml:space="preserve">
          <source>Sample Example:</source>
          <target state="translated">例子:</target>
        </trans-unit>
        <trans-unit id="381df071be6ca5ac8d6e5e18ab012360963bd4a9" translate="yes" xml:space="preserve">
          <source>Sample code for creating service using provide syntax:</source>
          <target state="translated">使用 provide 语法创建服务的代码示例。</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">说我们有。</target>
        </trans-unit>
        <trans-unit id="11dc1a4e11a2784e2b6de73a9022cddbb6721f42" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;the provider documentation&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;提供商文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f4ab1a2559d02916ca6b754d342e20711e3cfca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;here&lt;/a&gt; for the provided code.</source>
          <target state="translated">有关提供的代码，请参见&lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;此处&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5030396a200088699db9b35f53a60b75ca0f61ed" translate="yes" xml:space="preserve">
          <source>Service Function:</source>
          <target state="translated">服务功能:</target>
        </trans-unit>
        <trans-unit id="6210fa9c0a7b05e22abb7fcb5a13962309ea102d" translate="yes" xml:space="preserve">
          <source>Service initialization</source>
          <target state="translated">服务初始化</target>
        </trans-unit>
        <trans-unit id="9d10e77416b918cf3662445c6e88c578fa4569c9" translate="yes" xml:space="preserve">
          <source>Service is an singleton object instance. Use services if you want to provide a singleton object for your code.</source>
          <target state="translated">服务是一个单子对象实例。如果你想为你的代码提供一个单子对象,请使用service。</target>
        </trans-unit>
        <trans-unit id="61835754249fef2e2b45059d3bbd0d0e5cdde58d" translate="yes" xml:space="preserve">
          <source>Service/Factory behavior is very similar, and some people will say
  that either one is fine. That&amp;rsquo;s somewhat true, but I find it easier to
  follow the advice of John Papa&amp;rsquo;s style guide and just stick with
  factories.**</source>
          <target state="translated">服务/工厂的行为非常相似，有些人会说任何一个都可以。 确实有些道理，但我发现遵循约翰&amp;middot;帕帕（John Papa）的风格指南的建议更容易，而且坚持使用工厂即可。**</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="c1e289d3853bb8c7d8a915f54b7abf6bb6594091" translate="yes" xml:space="preserve">
          <source>Simply while looking at the services think about the array prototype. A service is a function which instantiates a new object using the 'new' keyword. You can add properties and functions to a service object by using the &lt;code&gt;this&lt;/code&gt; keyword. Unlike a factory, it doesn't return anything (it returns an object which contains methods/properties).</source>
          <target state="translated">在查看服务时，只需考虑一下阵列原型。 服务是使用'new'关键字实例化新对象的功能。 您可以使用 &lt;code&gt;this&lt;/code&gt; 关键字将属性和功能添加到服务对象。 与工厂不同，它不返回任何内容（它返回包含方法/属性的对象）。</target>
        </trans-unit>
        <trans-unit id="62854845263bf068dddccd96ecb184fb8ea7a590" translate="yes" xml:space="preserve">
          <source>Since the constructed service is an object, the methods inside it can refer to this when they&amp;rsquo;re called:</source>
          <target state="translated">由于构造的服务是一个对象，因此其中的方法在调用时可以引用此对象：</target>
        </trans-unit>
        <trans-unit id="155220d0a18e305b7ea66fb35c4da7270fc65257" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;factory&lt;/code&gt; is a function which is responsible for creating the value. Notice that the factory function can ask for other dependencies.</source>
          <target state="translated">因此， &lt;code&gt;factory&lt;/code&gt; 是负责创造价值的功能。 注意，工厂函数可以要求其他依赖项。</target>
        </trans-unit>
        <trans-unit id="4d857556fc3e68491091f75ba684105c6782e0e5" translate="yes" xml:space="preserve">
          <source>So all together the code for creating a Person constructor, adding a function to it&amp;rsquo;s prototype, creating a Person instance, and then calling the function on its prototype looks like this.</source>
          <target state="translated">因此，所有用于创建Person构造函数，向其原型添加函数，创建Person实例，然后在其原型上调用该函数的代码都如下所示。</target>
        </trans-unit>
        <trans-unit id="08c3828d081a8d7efafeefc62c0878e780b4e133" translate="yes" xml:space="preserve">
          <source>So basically in both cases you eventually get a providers $get set to your function you provided , but you can give anything extra than $get as you can originally provide in provider() for config block</source>
          <target state="translated">所以基本上在这两种情况下,你最终会得到一个提供商$get设置为你提供的函数,但你可以给任何额外的东西,比如你可以在properator()中提供任何额外的配置块</target>
        </trans-unit>
        <trans-unit id="27e3723bbf080ae2fb322bd7eb8909b1557894e4" translate="yes" xml:space="preserve">
          <source>So if there are three controller scope, let it be controllerA, controllerB and controllerC, all will share same service instance.</source>
          <target state="translated">所以如果有三个控制器范围,让它是控制器A、控制器B和控制器C,都将共享同一个服务实例。</target>
        </trans-unit>
        <trans-unit id="dd81d4d697436b2952af0ee10fd0dd2ca080a3d2" translate="yes" xml:space="preserve">
          <source>So master provider and injector and all will fall in place :) . And it gets interesting in Typescript when $get can be implemented in a provider by inheriting from IServiceProvider.</source>
          <target state="translated">因此,主供应商和喷油器和所有的一切都将落到实处 :)。.当$get可以通过继承IServiceProvider的方式在提供者中实现时,在Typescript中就变得有趣了。</target>
        </trans-unit>
        <trans-unit id="cb9d6754283c9f37208464bd5837389aa5b0ad15" translate="yes" xml:space="preserve">
          <source>So when Angular constructs your service with new MyService(), it&amp;rsquo;ll get that api object instead of the MyService instance.</source>
          <target state="translated">因此，当Angular使用新的MyService（）构造您的服务时，它将获取该api对象而不是MyService实例。</target>
        </trans-unit>
        <trans-unit id="c72cf4ede28e8dd19525b9079025b0772ccc130b" translate="yes" xml:space="preserve">
          <source>So why such complications, why can't we just use provider and forget everything else? It is supposed to help us write code easily and communicate better. And toungue-in-cheek reply would be, the more complex it gets the better selling a framework will be.</source>
          <target state="translated">那么,为什么会有这么复杂的问题,为什么我们不能只用 provider,而忘记其他的一切呢?它应该是为了帮助我们写代码更容易,沟通更好。而toungue-in-cheek的回答是,越复杂的框架越好卖。</target>
        </trans-unit>
        <trans-unit id="d26ab8fdbfba98e5ec328de0fd5fd8b3ec1253e1" translate="yes" xml:space="preserve">
          <source>So, for the service, what becomes the AngularJS component is the object instance of the class which is represented by service declaration function. For the factory, it is the result returned from the factory declaration function. The factory may behave the same as the service:</source>
          <target state="translated">所以,对于服务来说,成为AngularJS组件的是服务声明函数所代表的类的对象实例。而对于工厂来说,则是工厂声明函数返回的结果。工厂的行为可能和服务一样。</target>
        </trans-unit>
        <trans-unit id="e62f1055fa34e381a967d48cc84251a3806ed36c" translate="yes" xml:space="preserve">
          <source>Source Code: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</source>
          <target state="translated">源代码： &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http&lt;/a&gt; : //www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service</target>
        </trans-unit>
        <trans-unit id="9924e31c2dd752407f7714733eb09ad7aaef9362" translate="yes" xml:space="preserve">
          <source>Summary from &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular docs&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular文档的&lt;/a&gt;摘要：</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="8a29d9bf1a1e71cf529fe97431e96a86eaf41f44" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</source>
          <target state="translated">语法： &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194b446e2c1fb5fc04741acabf05acbc4af47aec" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</source>
          <target state="translated">语法： &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92324397a45dd6d31034d314cd7fc546cabef2b8" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</source>
          <target state="translated">语法： &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84dd638523da34b8795dead37b56820cfba7075e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$get&lt;/code&gt; is a function that is directly attached to the provider instance. That function is a &lt;strong&gt;factory&lt;/strong&gt; function. In other words, it's just like the one that we use to &lt;em&gt;provide&lt;/em&gt; to the &lt;code&gt;.factory&lt;/code&gt; method. In that function, we create our own service. &lt;strong&gt;This &lt;code&gt;$get&lt;/code&gt; property, that's a function, is what makes the provider a provider&lt;/strong&gt;. &lt;em&gt;AngularJS expects the provider to have a $get property whose value is a function that Angular will treat as a factory function.&lt;/em&gt; But what makes this whole provider setup very special, is the fact that we can provide some &lt;code&gt;config&lt;/code&gt; object inside the service provider, and that usually comes with defaults that we can later overwrite in the step, where we can configure the entire application.</source>
          <target state="translated">&lt;code&gt;$get&lt;/code&gt; 是直接附加到提供程序实例的函数。 该功能是&lt;strong&gt;出厂&lt;/strong&gt;功能。 换句话说，它就像我们用来&lt;em&gt;提供&lt;/em&gt;给 &lt;code&gt;.factory&lt;/code&gt; 方法的那样。 在该功能中，我们创建了自己的服务。 &lt;strong&gt;这个 &lt;code&gt;$get&lt;/code&gt; 属性，就是一个函数，使提供者成为提供者&lt;/strong&gt; 。 &lt;em&gt;AngularJS希望提供程序具有$ get属性，其值是Angular将其视为工厂函数的函数。&lt;/em&gt; 但是，使整个提供程序设置非常特别的原因是，我们可以在服务提供程序内部提供一些 &lt;code&gt;config&lt;/code&gt; 对象，并且通常带有默认值，以后我们可以在该步骤中覆盖该默认值，在此步骤中，我们可以配置整个应用程序。</target>
        </trans-unit>
        <trans-unit id="7b6548f429604df735e1a44693ef40e85b8e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.service()&lt;/code&gt; method is a &lt;strong&gt;factory&lt;/strong&gt; that always produces the same type of service, which is a singleton, and without any easy way to configure it's behavior. That &lt;code&gt;.service()&lt;/code&gt; method is usually used as a shortcut for something that doesn't require any configuration whatsoever.</source>
          <target state="translated">&lt;code&gt;.service()&lt;/code&gt; 方法是一个&lt;strong&gt;工厂&lt;/strong&gt; ，它总是产生相同类型的服务，即单例服务，并且没有任何简单的方法来配置其行为。 该 &lt;code&gt;.service()&lt;/code&gt; 方法通常用作不需要任何配置的快捷方式。</target>
        </trans-unit>
        <trans-unit id="a49ec85e38178c060ff6013773473704cdd2007a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, and &lt;code&gt;provider&lt;/code&gt; methods are all providers. They teach the Injector how to instantiate the Services.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; ， &lt;code&gt;factory&lt;/code&gt; ， &lt;code&gt;service&lt;/code&gt; ， &lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;provider&lt;/code&gt; 方法都是提供程序。 他们教注入器如何实例化服务。</target>
        </trans-unit>
        <trans-unit id="025bc59091687d744c1dd87ac4446f1a3ea99b14" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Constant recipe&lt;/strong&gt; is just like the Value recipe except it allows you to define services that are available in the &lt;strong&gt;config&lt;/strong&gt; phase. Sooner than services created using the Value recipe. Unlike Values, they cannot be decorated using &lt;code&gt;decorator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;常量配方&lt;/strong&gt;类似于值配方，不同之处在于它允许您定义&lt;strong&gt;配置&lt;/strong&gt;阶段可用的服务。 比使用&amp;ldquo;价值&amp;rdquo;配方创建的服务要早。 与值不同，它们不能使用 &lt;code&gt;decorator&lt;/code&gt; 装饰 。</target>
        </trans-unit>
        <trans-unit id="3cf81a424905d80f0814719f3aa86cbdefa28b91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Factory recipe&lt;/strong&gt; gives the Injector a factory function that it calls when it needs to instantiate the service. When called, the &lt;strong&gt;factory function&lt;/strong&gt; creates and returns the service instance. The dependencies of the Service are injected as the functions' arguments. So using this recipe adds the following abilities:</source>
          <target state="translated">&lt;strong&gt;Factory配方&lt;/strong&gt;为Injector提供了需要实例化服务的工厂函数。 调用时， &lt;strong&gt;工厂函数将&lt;/strong&gt;创建并返回服务实例。 服务的依赖项作为函数的参数注入。 因此，使用此配方可添加以下功能：</target>
        </trans-unit>
        <trans-unit id="b86e7115a91b56187a5fe0143ed257a341995e64" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider recipe&lt;/strong&gt; is usually &lt;strong&gt;overkill&lt;/strong&gt;. It adds one more layer of indirection by allowing you to configure the creation of the factory.</source>
          <target state="translated">&lt;strong&gt;提供者的配方&lt;/strong&gt;通常是&lt;strong&gt;多余的&lt;/strong&gt; 。 通过允许您配置工厂的创建，它又增加了一层间接。</target>
        </trans-unit>
        <trans-unit id="cad58aeb7205a606c508335ce156288e7da6f573" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider&lt;/strong&gt; recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">&lt;strong&gt;提供者&lt;/strong&gt;配方是核心配方类型，其他所有配方都只是语法糖。</target>
        </trans-unit>
        <trans-unit id="17bb816a792f8c3e9c45f68c21dac545bc7fc6e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Service recipe&lt;/strong&gt; is almost the same as the Factory recipe, but here the Injector invokes a &lt;strong&gt;constructor&lt;/strong&gt; with the new operator instead of a factory function.</source>
          <target state="translated">&lt;strong&gt;Service配方&lt;/strong&gt;与Factory配方几乎相同，但是在这里Injector使用new运算符而不是factory函数调用&lt;strong&gt;构造&lt;/strong&gt;函数。</target>
        </trans-unit>
        <trans-unit id="0f6f2e7cab552a54a9d8929a09e98e95cc4cfb9f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Value Recipe&lt;/strong&gt; is the simplest case, where you instantiate the Service yourself and provide the &lt;strong&gt;instantiated value&lt;/strong&gt; to the injector.</source>
          <target state="translated">&lt;strong&gt;值配方&lt;/strong&gt;是最简单的情况，您可以自己实例化服务并将&lt;strong&gt;实例化的值&lt;/strong&gt;提供给注射器。</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">Provider配方是核心配方类型,其他的都只是在上面加了语法糖。</target>
        </trans-unit>
        <trans-unit id="c20c67a4543a337b871e95eaa0aa2230110f9cde" translate="yes" xml:space="preserve">
          <source>The biggest thing to remember about Providers is that they&amp;rsquo;re the only service that you can pass into the app.config portion of your application. This is of huge importance if you&amp;rsquo;re needing to alter some portion of your service object before it&amp;rsquo;s available everywhere else in your application. Although very similar to Services/Factories, there are a few differences which we&amp;rsquo;ll discuss.</source>
          <target state="translated">关于提供程序，要记住的最大事情是，它们是您可以传递到应用程序的app.config部分中的唯一服务。 如果您需要更改服务对象的某些部分，然后才能在应用程序中的其他任何地方使用它，那么这非常重要。 尽管与服务/工厂非常相似，但是我们将讨论一些区别。</target>
        </trans-unit>
        <trans-unit id="a2a3557bc4924e63f2d2ce284fc4ba7adf38dc02" translate="yes" xml:space="preserve">
          <source>The biggest thing to understand when creating a Service is knowing that Services are instantiated with the &amp;lsquo;new&amp;rsquo; keyword. Combining that knowledge with our examples above, you should now recognize that you&amp;rsquo;ll be attaching your properties and methods directly to &amp;lsquo;this&amp;rsquo; which will then be returned from the Service itself. Let&amp;rsquo;s take a look at this in action.</source>
          <target state="translated">创建服务时要了解的最大事情是知道服务已使用'new'关键字实例化。 将这些知识与上面的示例相结合，您现在应该认识到，您将把属性和方法直接附加到&amp;ldquo; this&amp;rdquo;，然后将从服务本身返回该属性和方法。 让我们看看实际情况。</target>
        </trans-unit>
        <trans-unit id="ee97831b61259806e326d0d7c322a8ac829781ee" translate="yes" xml:space="preserve">
          <source>The code for &quot;factory&quot; based custom service is as follows (which goes with both sync and async versions along with calling http service):</source>
          <target state="translated">基于 &quot;工厂 &quot;的自定义服务的代码如下(它与同步和异步版本以及调用http服务一起使用)。</target>
        </trans-unit>
        <trans-unit id="dbceb93948d3b88153505159e94a72b7b46ceaf3" translate="yes" xml:space="preserve">
          <source>The code for &quot;provider&quot; methodology for Custom Services (this is necessary, if you would like to develop service which could be configured):</source>
          <target state="translated">定制服务的 &quot;提供者 &quot;方法的代码(如果你想开发可以配置的服务,这是必要的)。</target>
        </trans-unit>
        <trans-unit id="20100b8b1bb6246809bfd0d54c74369163ea60ef" translate="yes" xml:space="preserve">
          <source>The code for &quot;service&quot; methodology for Custom Services (this is pretty similar to 'factory', but different from syntax point of view):</source>
          <target state="translated">自定义服务的 &quot;服务 &quot;方法论的代码(这和 &quot;工厂 &quot;很相似,但从语法的角度看是不同的)。</target>
        </trans-unit>
        <trans-unit id="1f5224c76a4a9f42aeda5250ed57bd05696a3d3c" translate="yes" xml:space="preserve">
          <source>The difference between the three is that:</source>
          <target state="translated">三者之间的区别在于。</target>
        </trans-unit>
        <trans-unit id="80c0d58f7ad22390cf6e79a7ead32b51a9279f3b" translate="yes" xml:space="preserve">
          <source>The factory 'class' example is provided in the comments around, as well as provider difference.</source>
          <target state="translated">在周围的注释中提供了工厂 &quot;类 &quot;的例子,以及提供者的区别。</target>
        </trans-unit>
        <trans-unit id="29223deeb9a116b14e0df19e98f9ac9f789b7dbd" translate="yes" xml:space="preserve">
          <source>The factory can also return an object with a method that can be invoked:</source>
          <target state="translated">工厂也可以返回一个可以被调用的方法的对象。</target>
        </trans-unit>
        <trans-unit id="c72bcb74f28a11248fb075ce43662f6ac919dc7d" translate="yes" xml:space="preserve">
          <source>The factory can then be used throughout the application with custom settings. In other words, we can configure this factory before the application starts. In fact in the angular documentation it is mentioned that the provider method is what actually gets executed behind the scenes when we configure our services with either &lt;code&gt;.service&lt;/code&gt; or &lt;code&gt;.factory&lt;/code&gt; methods.</source>
          <target state="translated">然后，可以使用自定义设置在整个应用程序中使用工厂。 换句话说，我们可以在应用程序启动之前配置此工厂。 实际上，在角度文档中提到，当我们使用 &lt;code&gt;.service&lt;/code&gt; 或 &lt;code&gt;.factory&lt;/code&gt; 方法配置服务时，provider方法实际上是在后台执行的。</target>
        </trans-unit>
        <trans-unit id="70f2a456ca8dd7dbc5919aa27331c81f32a961f4" translate="yes" xml:space="preserve">
          <source>The factory returns a function that can be invoked:</source>
          <target state="translated">该工厂返回一个可以被调用的函数。</target>
        </trans-unit>
        <trans-unit id="294c451a3bc3bc52035a0a1ff0d80aadf5cf8464" translate="yes" xml:space="preserve">
          <source>The injected value for a factory dependency is the factory&amp;rsquo;s return
  value, and it doesn&amp;rsquo;t have to be an object. It could be a function</source>
          <target state="translated">工厂依赖项的注入值是工厂的返回值，并且不必是对象。 它可能是一个功能</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services
and special purpose objects</source>
          <target state="translated">注入器使用配方来创建两种类型的对象:服务和特殊目的对象。</target>
        </trans-unit>
        <trans-unit id="2a5bdc6259273898183df356d5f764744dcb6660" translate="yes" xml:space="preserve">
          <source>The lowest level way to create a service is by using the provide() method. This is the only way to create a service that we can configure using the .config() function.
Unlike the previous to methods, we&amp;rsquo;ll set the injectables in a defined this.$get() function definition.</source>
          <target state="translated">创建服务的最低级别方法是使用Provide（）方法。 这是创建可以使用.config（）函数配置的服务的唯一方法。 与之前的方法不同，我们将在已定义的this。$ get（）函数定义中设置可注入对象。</target>
        </trans-unit>
        <trans-unit id="33cea9a6904f984abbc8f96a6114e14b3b574e31" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider
  recipe. The &lt;strong&gt;remaining four&lt;/strong&gt; recipe types &amp;mdash; Value, Factory, Service and
  Constant &amp;mdash; &lt;strong&gt;are just syntactic sugar on top of a provider recipe&lt;/strong&gt;.</source>
          <target state="translated">提供程序最详细，但也最全面。 &lt;strong&gt;其余四种&lt;/strong&gt;配方类型-值，工厂，服务和常量- &lt;strong&gt;只是提供者配方之上的语法糖&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="348c5cf5eea19f952edd139e0384878a13cc16b3" translate="yes" xml:space="preserve">
          <source>The passed function can define a object and return that object. AngularJS simply stores this object reference to a variable which is passed as first argument. Anything which is returned from fnFactory will be bound to serviceInstance . Instead of returning object , we can also return function, values etc, Whatever we will return , will be available to service instance.</source>
          <target state="translated">传入的函数可以定义一个对象并返回该对象。AngularJS只需将这个对象引用存储到一个变量中,这个变量作为第一个参数被传递给它。任何从fnFactory返回的东西都会被绑定到serviceInstance。而不是返回对象,我们也可以返回函数、值等,无论我们要返回的是什么,都会被服务实例所利用。</target>
        </trans-unit>
        <trans-unit id="d2510f9c93a099e17ccd62f31f88b7b395fab6a8" translate="yes" xml:space="preserve">
          <source>The service returns an object with a method that can be invoked:</source>
          <target state="translated">该服务返回一个具有可以被调用的方法的对象。</target>
        </trans-unit>
        <trans-unit id="c22685b3257f9741c0336da5fe8df717ac146fa0" translate="yes" xml:space="preserve">
          <source>The service() method, on the other hand allows us to create a service by defining a constructor function. We can use a prototypical object to define our service, instead of a raw javascript object.
Similar to the factory() method, we&amp;rsquo;ll also set the injectables in the function definition.</source>
          <target state="translated">另一方面，service（）方法允许我们通过定义构造函数来创建服务。 我们可以使用原型对象来定义我们的服务，而不是使用原始javascript对象。 与factory（）方法类似，我们还将在函数定义中设置可注入对象。</target>
        </trans-unit>
        <trans-unit id="6d15e1717ce86b0987b078987bab5ad9e89e8630" translate="yes" xml:space="preserve">
          <source>The simplest way of thinking is the following one:</source>
          <target state="translated">最简单的思维方式是下面这种。</target>
        </trans-unit>
        <trans-unit id="d37bdb33569628feda26fad99fde289973152425" translate="yes" xml:space="preserve">
          <source>Then it needs to have a separate &lt;em&gt;$.get&lt;/em&gt; function which is executed by AngularJS after setting the above properties via the &lt;code&gt;app.config&lt;/code&gt; file , and this &lt;em&gt;$.get&lt;/em&gt; function behaves just as the &lt;em&gt;factory&lt;/em&gt; above, in that its return value is used to initialize the &quot;global&quot; variables.</source>
          <target state="translated">然后，它需要有一个单独的&lt;em&gt;$ .get&lt;/em&gt;函数，该函数由AngularJS在通过 &lt;code&gt;app.config&lt;/code&gt; 文件设置上述属性后执行，并且此&lt;em&gt;$ .get&lt;/em&gt;函数的行为与上述&lt;em&gt;工厂相同&lt;/em&gt; ，其返回值用于初始化&amp;ldquo;全局&amp;rdquo;变量。</target>
        </trans-unit>
        <trans-unit id="b32fe2094a05734d73d634537bd5399d06168766" translate="yes" xml:space="preserve">
          <source>Then to instantiate you would have to write</source>
          <target state="translated">那么要实例化,你必须写出</target>
        </trans-unit>
        <trans-unit id="3dbd87f48f38a7cd7438dff5c9c9a17a54a72326" translate="yes" xml:space="preserve">
          <source>Then we can do this:</source>
          <target state="translated">那么我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="26ab2c621cf3a4ad1aed6bc59c8cac976a8891fc" translate="yes" xml:space="preserve">
          <source>Then we could ask for 'greeter' in controller like this</source>
          <target state="translated">然后,我们可以在控制器中请求 &quot;问候&quot;,就像这样的方式</target>
        </trans-unit>
        <trans-unit id="73c6e7a10f2e40affaa0702fd4636afb5ef0a445" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt;,
&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">有五种配方类型定义了如何创建对象： &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt; ， &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt; ， &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt; ， &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, 
Factory, Service, Provider and Constant.</source>
          <target state="translated">有五种配方类型定义了如何创建对象。值、工厂、服务、提供者和常量。</target>
        </trans-unit>
        <trans-unit id="a3abfbafa21284370080781426e7f10765c626b1" translate="yes" xml:space="preserve">
          <source>There are good answers already, but I just want to share this one.</source>
          <target state="translated">已经有很好的答案了,但我只想分享这一个。</target>
        </trans-unit>
        <trans-unit id="cbe50089e98dca4865d62e4d5d431a2ad1e1d31e" translate="yes" xml:space="preserve">
          <source>There are many levels of complications in creating the values for the &quot;global variables&quot;:</source>
          <target state="translated">在创建 &quot;全局变量 &quot;的值时,有很多层次的复杂因素。</target>
        </trans-unit>
        <trans-unit id="cfe4afb9db4aa26d7132e641470f68bed3f4242c" translate="yes" xml:space="preserve">
          <source>There is &lt;code&gt;Service vs Factory&lt;/code&gt; part has been covered:
&lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</source>
          <target state="translated">涵盖了&amp;ldquo; &lt;code&gt;Service vs Factory&lt;/code&gt; 部分： &lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https&lt;/a&gt; : //www.youtube.com/watch?v=BLzNCkPn3ao</target>
        </trans-unit>
        <trans-unit id="a8ee704f9be11c360a8332f959f17604faeec8af" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;$get&lt;/code&gt; object that you define and it can be used to get the object that returns data.</source>
          <target state="translated">您定义了一个 &lt;code&gt;$get&lt;/code&gt; 对象，该对象可用于获取返回数据的对象。</target>
        </trans-unit>
        <trans-unit id="5a7068b6dda657b5b0908bbb1b5b47f54867579f" translate="yes" xml:space="preserve">
          <source>This answer address the topic/question</source>
          <target state="translated">本题考查的是:&quot;本题的答案是</target>
        </trans-unit>
        <trans-unit id="d2ca6aed8a94daf45ebec515f35b4ef0c7e37069" translate="yes" xml:space="preserve">
          <source>This defines an actual constant that should not be modified during the entire application, just like constants in other languages are (something that JavaScript lacks).</source>
          <target state="translated">这定义了一个实际的常量,在整个应用程序中不应该被修改,就像其他语言中的常量一样(JavaScript所缺乏的)。</target>
        </trans-unit>
        <trans-unit id="23068a44ce8e025468c6a880cdc354c2346311bc" translate="yes" xml:space="preserve">
          <source>This is a modifiable value or object, and it serves as some global variable, that can even be injected when creating other services or factories (see further on these). However, it must be a &quot;&lt;em&gt;literal value&lt;/em&gt;&quot;, which means that one has to write out the actual value, and cannot use any computation or programming logic (in other words &lt;em&gt;39&lt;/em&gt; or &lt;em&gt;myText&lt;/em&gt; or &lt;em&gt;{prop: &quot;value&quot;}&lt;/em&gt; are OK, but &lt;em&gt;2 +2&lt;/em&gt; is not).</source>
          <target state="translated">这是一个可修改的值或对象，它用作某些全局变量，甚至可以在创建其他服务或工厂时注入（请参阅有关这些内容的更多信息）。 但是，它必须是&amp;ldquo; &lt;em&gt;文字值&lt;/em&gt; &amp;rdquo;，这意味着必须写出实际值，并且不能使用任何计算或编程逻辑（换句话说，可以使用&lt;em&gt;39&lt;/em&gt;或&lt;em&gt;myText&lt;/em&gt;或&lt;em&gt;{prop：&amp;ldquo; value&amp;rdquo;}）&lt;/em&gt; ，但是&lt;em&gt;2 +2&lt;/em&gt;不是）。</target>
        </trans-unit>
        <trans-unit id="7c23aa97141e4f8d46377a4215db03016a94f612" translate="yes" xml:space="preserve">
          <source>This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the &amp;lsquo;new&amp;rsquo; keyword, &amp;lsquo;this&amp;rsquo; will be bound to the newly created object.</source>
          <target state="translated">这是典型的JavaScript构造函数。 现在，每当我们使用&amp;ldquo; new&amp;rdquo;关键字调用Person函数时，&amp;ldquo; this&amp;rdquo;将绑定到新创建的对象。</target>
        </trans-unit>
        <trans-unit id="dfb8cea8751eb472adb742095a7b2c6e23a67444" translate="yes" xml:space="preserve">
          <source>This is the behavior for any complex values (objects, functions) but not for primitive types.</source>
          <target state="translated">这是对任何复杂值(对象、函数)的行为,但对基元类型没有。</target>
        </trans-unit>
        <trans-unit id="f1e7c9cd5dc0b108189dc22be56ae3d9ed503494" translate="yes" xml:space="preserve">
          <source>This is very confusing part for newbie and I have tried to clarify it in easy words</source>
          <target state="translated">对于新手来说,这部分是非常混乱的,我试图用简单的语言来说明一下</target>
        </trans-unit>
        <trans-unit id="0071c8fa9a8db22cbf7fe7086f0e4a422890b5c6" translate="yes" xml:space="preserve">
          <source>This is why we use &lt;code&gt;this&lt;/code&gt; in services, and define a &lt;code&gt;this.$get&lt;/code&gt; in providers.</source>
          <target state="translated">这就是为什么我们在服务中使用 &lt;code&gt;this&lt;/code&gt; 并在提供程序中定义 &lt;code&gt;this.$get&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="337dbda194e27c65c3b59a20fcfe6f20bce044b3" translate="yes" xml:space="preserve">
          <source>This means that you can basically copy-paste the factory example from below, replace &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;service&lt;/code&gt;, and it&amp;rsquo;ll work:</source>
          <target state="translated">这意味着您基本上可以从下面复制粘贴工厂示例，用 &lt;code&gt;service&lt;/code&gt; 替换 &lt;code&gt;factory&lt;/code&gt; ，它将起作用：</target>
        </trans-unit>
        <trans-unit id="bcb15b94b5801e9e5561df693ee7def2f99bdaf9" translate="yes" xml:space="preserve">
          <source>To really see the changes that occur when you invoke a function with the &amp;lsquo;new&amp;rsquo; keyword, let&amp;rsquo;s create a function and invoke it with the &amp;lsquo;new&amp;rsquo; keyword, then let&amp;rsquo;s show what the interpreter does when it sees the &amp;lsquo;new&amp;rsquo; keyword. The end results will both be the same.</source>
          <target state="translated">为了真正看到使用'new'关键字调用函数时发生的更改，让我们创建一个函数并使用'new'关键字调用它，然后让我们展示当解释器看到'new'关键字时执行的操作。 最终结果将是相同的。</target>
        </trans-unit>
        <trans-unit id="f002fd0a5d473826ead53b980392d6392a7e2430" translate="yes" xml:space="preserve">
          <source>Unlike a service which is a simplified version of &lt;em&gt;factory&lt;/em&gt;, a provider is a more complex, but more flexible way of initializing the &quot;global&quot; variables, with the biggest flexibility being the option to set values from the app.config.</source>
          <target state="translated">与服务是&lt;em&gt;工厂&lt;/em&gt;的简化版本不同，提供程序是一种更复杂但更灵活的初始化&amp;ldquo;全局&amp;rdquo;变量的方式，最大的灵活性是可以从app.config设置值。</target>
        </trans-unit>
        <trans-unit id="864ea43a8c2da87a50b0e143c273a5376c32245f" translate="yes" xml:space="preserve">
          <source>Unlike what we originally did with the Factory example, we don&amp;rsquo;t need to create an object then return that object because, like mentioned many times before, we used the &amp;lsquo;new&amp;rsquo; keyword so the interpreter will create that object, have it delegate to it&amp;rsquo;s prototype, then return it for us without us having to do the work.</source>
          <target state="translated">与我们最初对Factory示例所做的不同，我们不需要创建对象然后返回该对象，因为就像之前多次提到的那样，我们使用了'new'关键字，因此解释器将创建该对象，并将其委托给它是原型，然后无需我们进行工作即可将其退还给我们。</target>
        </trans-unit>
        <trans-unit id="b49caeb887a29a8bada2966d7c2590d853f20723" translate="yes" xml:space="preserve">
          <source>Usage (as an injectable in a controller)</source>
          <target state="translated">用途(作为控制器中的注射剂)</target>
        </trans-unit>
        <trans-unit id="879ae7be1e519b410069e2f401b1f3f754b21f05" translate="yes" xml:space="preserve">
          <source>Usage (configuring the provider before &lt;code&gt;$get&lt;/code&gt; is called to create the injectable)</source>
          <target state="translated">用法（在调用 &lt;code&gt;$get&lt;/code&gt; 创建可注射对象之前配置提供程序）</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="4022b8a59a0d0d2ca89f1ecfac78f71d1bc33304" translate="yes" xml:space="preserve">
          <source>Use it when you need to share a single object throughout the application. For example, authenticated user details, share-able methods/data, Utility functions etc.</source>
          <target state="translated">当你需要在整个应用程序中共享一个对象时使用它。例如,认证的用户详细信息,可共享的方法数据,实用程序函数等。</target>
        </trans-unit>
        <trans-unit id="c140efc7adf0e2b8a74e6393e081cb7475561437" translate="yes" xml:space="preserve">
          <source>Use this link for code reference</source>
          <target state="translated">请使用此链接作为代码参考</target>
        </trans-unit>
        <trans-unit id="be9209121182255216aaa47dfd1cae1b29bb43e3" translate="yes" xml:space="preserve">
          <source>Using as reference this page and the &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentation&lt;/a&gt; (which seems to have greatly improved since the last time I looked), I put together the following real(-ish) world demo which uses 4 of the 5 flavours of provider; Value, Constant, Factory and full blown Provider.</source>
          <target state="translated">将此页面和&lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;文档&lt;/a&gt; （自上次浏览以来，似乎已得到很大的改进）作为参考，我整理了以下真实（-ish）世界演示，该演示使用了5种提供者中的4种。 值，常量，出厂和完整提供程序。</target>
        </trans-unit>
        <trans-unit id="7f1b9dfcd80673ff780bfe6c9e4b747b202f04d5" translate="yes" xml:space="preserve">
          <source>Using the factory() in our app</source>
          <target state="translated">在我们的应用程序中使用 factory()</target>
        </trans-unit>
        <trans-unit id="93312e4afaa947b3a60bfa6bea40f131935883a5" translate="yes" xml:space="preserve">
          <source>Visibility of injectables is different for providers than it is for services and factories. If you declare an AngularJS &quot;constant&quot; (for example, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt;), you can inject it into services, factories, and providers.</source>
          <target state="translated">提供者与服务和工厂的注射剂可见性不同。 如果您声明AngularJS为&amp;ldquo;常数&amp;rdquo;（例如， &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt; ），则可以将其注入服务，工厂和提供者。</target>
        </trans-unit>
        <trans-unit id="d22cafa4fcd376a2f27d8c4831e76c2f8fa630f7" translate="yes" xml:space="preserve">
          <source>We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven&amp;rsquo;t had much experience using promises in AngularJS, I highly recommend doing a deep dive on them.</source>
          <target state="translated">我们将创建只返回或设置艺术家的setArtist和getArtist方法。 我们还将创建一个方法，该方法将使用创建的URL调用iTunes API。 此方法将返回一个诺言，一旦数据从iTunes API返回，诺言就将履行。 如果您在AngularJS中使用诺言没有太多经验，我强烈建议您对它们进行深入研究。</target>
        </trans-unit>
        <trans-unit id="c68ba4741829821c5273926306c848fe58e787c7" translate="yes" xml:space="preserve">
          <source>We can create configurable services using provider syntax as given below.</source>
          <target state="translated">我们可以使用下面给出的提供者语法创建可配置服务。</target>
        </trans-unit>
        <trans-unit id="dbe235285ce55886f522548de7d34e5b6a156187" translate="yes" xml:space="preserve">
          <source>We can define a factory function as below.</source>
          <target state="translated">我们可以定义一个工厂的功能如下。</target>
        </trans-unit>
        <trans-unit id="9dc701ea399c4055cce4573cf97749a703eb7d4a" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Provider&lt;/code&gt; and &lt;code&gt;Factory&lt;/code&gt; in AngularJS?</source>
          <target state="translated">AngularJS中的 &lt;code&gt;Service&lt;/code&gt; ， &lt;code&gt;Provider&lt;/code&gt; 和 &lt;code&gt;Factory&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="1d97deb201bb1447c8de5b02c7b3a99898edb8b5" translate="yes" xml:space="preserve">
          <source>When Angular injects this &lt;code&gt;MyService&lt;/code&gt; service into a controller that
  depends on it, that controller will get a &lt;code&gt;MyService&lt;/code&gt; that it can call
  functions on, e.g. MyService.aServiceMethod ().</source>
          <target state="translated">当Angular将此 &lt;code&gt;MyService&lt;/code&gt; 服务注入依赖于它的控制器时，该控制器将获得一个 &lt;code&gt;MyService&lt;/code&gt; ，它可以在其上调用函数，例如MyService.aServiceMethod（）。</target>
        </trans-unit>
        <trans-unit id="71e6a586496bb64a15227083621aef43a2714aea" translate="yes" xml:space="preserve">
          <source>When creating a service with Provider, the only properties/methods that will be available in your controller are those properties/methods which are returned from the $get() function. The code below puts $get on &amp;lsquo;this&amp;rsquo; (which we know will eventually be returned from that function). Now, that $get function returns all the methods/properties we want to be available in the controller. Here&amp;rsquo;s a code example.</source>
          <target state="translated">使用Provider创建服务时，控制器中唯一可用的属性/方法是从$ get（）函数返回的属性/方法。 下面的代码将$ get放在&amp;ldquo; this&amp;rdquo;上（我们知道该最终将从该函数返回）。 现在，该$ get函数返回我们希望在控制器中可用的所有方法/属性。 这是一个代码示例。</target>
        </trans-unit>
        <trans-unit id="3bc3b865d96d4a3942513d9897a3bb409a798a5a" translate="yes" xml:space="preserve">
          <source>When making a &lt;code&gt;service()&lt;/code&gt; it return you providing a factory() with a &lt;code&gt;function&lt;/code&gt; that injects the &lt;code&gt;constructor&lt;/code&gt; (return the instance of the constructor you provided in your service) and returns it</source>
          <target state="translated">进行 &lt;code&gt;service()&lt;/code&gt; 时 ，返回给您提供的factory（）具有注入 &lt;code&gt;constructor&lt;/code&gt; &lt;code&gt;function&lt;/code&gt; 的函数 （返回在服务中提供的构造函数的实例）并返回</target>
        </trans-unit>
        <trans-unit id="d6d43abc5bb66cd755013d3ef82d0ae0e0cc46c8" translate="yes" xml:space="preserve">
          <source>When you make a &lt;code&gt;factory()&lt;/code&gt; it sets you &lt;code&gt;function&lt;/code&gt; provided in second argument to provider's &lt;code&gt;$get&lt;/code&gt; and return it(&lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt;),</source>
          <target state="translated">当您创建 &lt;code&gt;factory()&lt;/code&gt; 时,它将设置您在提供程序的 &lt;code&gt;$get&lt;/code&gt; 第二个参数中提供的函数，并返回该 &lt;code&gt;function&lt;/code&gt; （ &lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="45f317e75b95e397ea00208400104d4fe8bf5e18" translate="yes" xml:space="preserve">
          <source>When you need to provide module-wise configuration for your service object before making it available, eg. suppose you want to set your API URL on basis of your Environment like &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;stage&lt;/code&gt; or &lt;code&gt;prod&lt;/code&gt;</source>
          <target state="translated">需要在使服务对象可用之前为它提供模块方式的配置时，例如。 假设您想根据自己的环境（例如 &lt;code&gt;dev&lt;/code&gt; ， &lt;code&gt;stage&lt;/code&gt; 或 &lt;code&gt;prod&lt;/code&gt; )设置API URL</target>
        </trans-unit>
        <trans-unit id="2d9813216aceb4fb52c9772759aad11c548dbb06" translate="yes" xml:space="preserve">
          <source>Which means there&amp;rsquo;s something like a cache object inside AngularJS, whose value of each injection is only assigned once, when they've been injected the first time, and where:</source>
          <target state="translated">这意味着在AngularJS中有一个类似于缓存对象的东西，每次注入的值仅在第一次注入时分配一次，其中：</target>
        </trans-unit>
        <trans-unit id="9a5bdc65b2c24b100cbcaaaa5059622b099681ae" translate="yes" xml:space="preserve">
          <source>While global variables are not recommended, the real usage of these global variables is to provide &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, by passing the variable to the relevant controller.</source>
          <target state="translated">尽管不建议使用全局变量，但这些全局变量的实际用法是通过将变量传递给相关控制器来提供&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依赖项注入&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5f5a2ae1fcba7052d4d70638cf84ffe0eb2743b" translate="yes" xml:space="preserve">
          <source>Working &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;demo&lt;/a&gt;.</source>
          <target state="translated">工作&lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;演示&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5b3d2c4eb971fcbd43812638af12c7dc4437f9c" translate="yes" xml:space="preserve">
          <source>Working Demo</source>
          <target state="translated">工作演示</target>
        </trans-unit>
        <trans-unit id="9fd4dd933fe260f137acd6eae3ea36eb6536140b" translate="yes" xml:space="preserve">
          <source>You can think of Providers as having three sections. The first section is the &amp;lsquo;private&amp;rsquo; variables/functions that will be modified/set later (shown above). The second section is the variables/functions that will be available in your app.config function and are therefore available to alter before they&amp;rsquo;re available anywhere else (also shown above). It&amp;rsquo;s important to note that those variables need to be attached to the &amp;lsquo;this&amp;rsquo; keyword. In our example, only &amp;lsquo;thingFromConfig&amp;rsquo; will be available to alter in the app.config. The third section (shown below) is all the variables/functions that will be available in your controller when you pass in the &amp;lsquo;myProvider&amp;rsquo; service into that specific controller.</source>
          <target state="translated">您可以将提供者分为三个部分。 第一部分是&amp;ldquo;私有&amp;rdquo;变量/函数，稍后将对其进行修改/设置（如上所示）。 第二部分是变量/函数，这些变量/函数将在您的app.config函数中可用，因此在它们在其他任何地方可用之前就可以更改（也如上所示）。 重要的是要注意，这些变量需要附加到'this'关键字。 在我们的示例中，只有'thingFromConfig'可以在app.config中进行更改。 第三部分（如下所示）是当您将&amp;ldquo; myProvider&amp;rdquo;服务传递到该特定控制器中时，控制器中将可用的所有变量/函数。</target>
        </trans-unit>
        <trans-unit id="8b95d0adc56d83fa7498365437f66e79ee788966" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to return a value. When Angular calls &lt;code&gt;new yourServiceName(&lt;/code&gt;), it&amp;rsquo;ll receive the &lt;code&gt;this&lt;/code&gt; object with all the properties you put on it.</source>
          <target state="translated">您不需要返回值。 当Angular调用 &lt;code&gt;new yourServiceName(&lt;/code&gt; ）时，它将收到带有所有属性的 &lt;code&gt;this&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="3fe544a5098b0be6e451614ad5ff4af0887aea93" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will cache and inject the return value when the factory is requested.</source>
          <target state="translated">你给AngularJS一个函数,AngularJS会在请求工厂时缓存并注入返回值。</target>
        </trans-unit>
        <trans-unit id="7733853022202a91bba391de813e5ef65f7cfeb5" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will call &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; to instantiate it. It is the instance that AngularJS creates that will be cached and injected when the service is requested. Since &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; was used to instantiate the service, the keyword &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; is valid and refers to the instance.</source>
          <target state="translated">您给AngularJS一个函数，AngularJS将调用&lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt;来实例化它。 AngularJS创建的实例将在请求服务时进行缓存和注入。 由于使用&lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt;来实例化服务，因此关键字&lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt;是有效的并引用实例。</target>
        </trans-unit>
        <trans-unit id="a2a1ff92c50375a3fdf5b1809ff8ea225aab5a9c" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, and AngularJS will call its &lt;code&gt;$get&lt;/code&gt; function. It is the return value from the &lt;code&gt;$get&lt;/code&gt; function that will be cached and injected when the service is requested.</source>
          <target state="translated">您为AngularJS提供一个函数，AngularJS将调用其 &lt;code&gt;$get&lt;/code&gt; 函数。 &lt;code&gt;$get&lt;/code&gt; 函数的返回值将在请求服务时进行缓存和注入。</target>
        </trans-unit>
        <trans-unit id="3876a0940a5a7dd665609735ebfa32e7f6e1bcc3" translate="yes" xml:space="preserve">
          <source>You just have a standard function that uses this keyword to define a function.</source>
          <target state="translated">你只要有一个标准的函数,用这个关键词定义一个函数就可以了。</target>
        </trans-unit>
        <trans-unit id="866717a4969cced464a5c0ae6684faada33bde94" translate="yes" xml:space="preserve">
          <source>You might be tempted to call &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; in a promise chain, for instance if you initialized the score by grabbing it from the server: &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; The trouble with this is that &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; will be called with &lt;code&gt;this&lt;/code&gt; bound to &lt;code&gt;null&lt;/code&gt; and you&amp;rsquo;ll get errors. The better way would be &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt;.
Whether you choose to use this in your service methods or not, be careful how you call them.</source>
          <target state="translated">您可能很想在承诺链中调用 &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; ，例如，如果通过从服务器获取分数来初始化分数： &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; 麻烦的是，将调用 &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; 并将其绑定为 &lt;code&gt;null&lt;/code&gt; ,并且会出现错误。 更好的方法是 &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt; 。 无论您是否选择在服务方法中使用此功能，请谨慎使用它们。</target>
        </trans-unit>
        <trans-unit id="bea982bb9c2f6821b3f44edf8dad402dddc73177" translate="yes" xml:space="preserve">
          <source>You should use the Provider recipe only when you want to expose an API
  for application-wide configuration that must be made before the
  application starts. This is usually interesting only for reusable
  services whose behavior might need to vary slightly between
  applications.</source>
          <target state="translated">只有当你想在应用程序启动前必须为整个应用程序的配置公开一个API时,你才应该使用Provider配方。这通常只对可重用的服务感兴趣,因为这些服务的行为可能需要在不同的应用程序之间略有不同。</target>
        </trans-unit>
        <trans-unit id="c5956833324972c28737ee048ed90ebe091ca59b" translate="yes" xml:space="preserve">
          <source>_artist is the artist we wish to lookup</source>
          <target state="translated">艺术家是我们要查询的艺术家。</target>
        </trans-unit>
        <trans-unit id="72921d9d0e40db1cd6390dcc0077ecda67c652ba" translate="yes" xml:space="preserve">
          <source>_finalUrl is the final and fully built URL to which we&amp;rsquo;ll make the call to iTunes</source>
          <target state="translated">_finalUrl是我们将呼叫iTunes的最终且完全构建的URL</target>
        </trans-unit>
        <trans-unit id="0bfda8d377c2609cd9d50c5b636b767072ce4e18" translate="yes" xml:space="preserve">
          <source>ability to use other services (have dependencies)</source>
          <target state="translated">使用其他服务的能力(有依赖性)</target>
        </trans-unit>
        <trans-unit id="6a925e5ed5ce5e858b8242994457f2ab7ac71782" translate="yes" xml:space="preserve">
          <source>all you get is &lt;code&gt;provider&lt;/code&gt; but there is no property/method other than &lt;code&gt;$get&lt;/code&gt;</source>
          <target state="translated">您获得的只是 &lt;code&gt;provider&lt;/code&gt; 但是除了 &lt;code&gt;$get&lt;/code&gt; 之外没有其他属性/方法</target>
        </trans-unit>
        <trans-unit id="0d27b037fa89342a90ff5d6df4947c9eece46029" translate="yes" xml:space="preserve">
          <source>and returns &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">并返回 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="402433d1fb629334beefb9cb164a7a1c035c71e7" translate="yes" xml:space="preserve">
          <source>and using:</source>
          <target state="translated">并使用:</target>
        </trans-unit>
        <trans-unit id="427c1761ab15aa547603cd68334d242a2d5523d9" translate="yes" xml:space="preserve">
          <source>baseUrl is the base URL that the iTunes API requires</source>
          <target state="translated">baseUrl是iTunes API要求的基本URL。</target>
        </trans-unit>
        <trans-unit id="2cdaa8f3ceef76f1dc730a6b60c06476e795c676" translate="yes" xml:space="preserve">
          <source>basically what happens is</source>
          <target state="translated">基本上是</target>
        </trans-unit>
        <trans-unit id="b50ae779a31c55dd00a1f71d908a312cbc40af0a" translate="yes" xml:space="preserve">
          <source>connects &lt;code&gt;context&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">连接 &lt;code&gt;context&lt;/code&gt; 与 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54bf3f1ce25250844230f2deb1ca4ace3b97b315" translate="yes" xml:space="preserve">
          <source>creates brand new object</source>
          <target state="translated">创建新对象</target>
        </trans-unit>
        <trans-unit id="deb0c5efabe5381fec4da90741ac9ac67289b4ec" translate="yes" xml:space="preserve">
          <source>delayed/lazy initialization</source>
          <target state="translated">迟钝的初始化</target>
        </trans-unit>
        <trans-unit id="0188b442c8481c48fffbded6f20f1d6cded3c775" translate="yes" xml:space="preserve">
          <source>how Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe?</source>
          <target state="translated">工厂，服务和常量的用法如何&amp;mdash;仅仅是提供方配方上的语法糖？</target>
        </trans-unit>
        <trans-unit id="8f55d557046d81d78de7516299b50060cdf7c55b" translate="yes" xml:space="preserve">
          <source>how factory ,servic and providers are simailar internally</source>
          <target state="translated">工厂、服务机构和供应商内部如何相似</target>
        </trans-unit>
        <trans-unit id="ce1ed02a506c79b6518185593802fbb4aaa54d8a" translate="yes" xml:space="preserve">
          <source>links it to its &lt;code&gt;prototype&lt;/code&gt; object</source>
          <target state="translated">将其链接到其 &lt;code&gt;prototype&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="1e4306c581e1c078a3c92df9bd0a6162776ce8e8" translate="yes" xml:space="preserve">
          <source>makeUrl is a function that will create and return our iTunes friendly URL.</source>
          <target state="translated">makeUrl是一个函数,它将创建并返回我们的iTunes友好的URL。</target>
        </trans-unit>
        <trans-unit id="ba23da34d1e3b19225a60f4a7206e21e32aad969" translate="yes" xml:space="preserve">
          <source>of that &lt;code&gt;provider&lt;/code&gt;(means you can't configure this)</source>
          <target state="translated">该 &lt;code&gt;provider&lt;/code&gt; （表示您无法配置此名称）</target>
        </trans-unit>
        <trans-unit id="6192271d0d781e240956f0b4f5271f3d5d92ac46" translate="yes" xml:space="preserve">
          <source>service initialization</source>
          <target state="translated">服务初始化</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
