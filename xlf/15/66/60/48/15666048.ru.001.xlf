<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/15666048">
    <body>
      <group id="15666048">
        <trans-unit id="64a58ac5bcfe347c123a856c3f7ac41a16c18e93" translate="yes" xml:space="preserve">
          <source>&quot; Hello world &quot; example with &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt;:</source>
          <target state="translated">Пример &quot;Hello world&quot; с &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27ab96a759e2b4ef1d829c8525ca087d26314532" translate="yes" xml:space="preserve">
          <source>&quot;$injector is used to retrieve object instances as defined by &lt;strong&gt;provider&lt;/strong&gt;&quot; not service, not factory but provider.</source>
          <target state="translated">&amp;laquo;$ injector используется для извлечения экземпляров объекта, как определено &lt;strong&gt;поставщиком&lt;/strong&gt; &amp;raquo;, не службой, не фабрикой, а провайдером.</target>
        </trans-unit>
        <trans-unit id="47d91685928f3bdbd8a6e0bbabc322e70072c356" translate="yes" xml:space="preserve">
          <source>*Again if any portion of the above code is confusing, check out the Factory section where I explain what it all does it greater details.</source>
          <target state="translated">*Получите,если какая-то часть вышеуказанного кода запуталась,посмотрите раздел Factory,где я объясняю,что все это делает более подробно.</target>
        </trans-unit>
        <trans-unit id="f4d91701275cfa2997fcf5752d0f40b1c281d19d" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;service&lt;/code&gt; for most cases of default</source>
          <target state="translated">1. &lt;code&gt;service&lt;/code&gt; для большинства случаев дефолта</target>
        </trans-unit>
        <trans-unit id="b474cc94e43caf4ce704bf9f973a68251b25cd13" translate="yes" xml:space="preserve">
          <source>1.Provider object is created using constructor function we defined in our provider function.</source>
          <target state="translated">1.Provider объект создается с помощью функции конструктора,которую мы определили в функции провайдера.</target>
        </trans-unit>
        <trans-unit id="4c2cfdc84411546e36f7e4d88a4a92785dd9ead0" translate="yes" xml:space="preserve">
          <source>1.Services are singleton objects that are created when necessary and are never cleaned up until the end of the application life-cycle (when the browser is closed). Controllers are destroyed and cleaned up when they are no longer needed.</source>
          <target state="translated">1.Сервисы-это однотонные объекты,которые создаются при необходимости и никогда не очищаются до конца жизненного цикла приложения (когда браузер закрыт).Контроллеры уничтожаются и очищаются,когда в них больше нет необходимости.</target>
        </trans-unit>
        <trans-unit id="4edf8c51b9d95a7ca3a85d5aeca515c293064266" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;factory&lt;/code&gt; used to create the service that specific instance</source>
          <target state="translated">2. &lt;code&gt;factory&lt;/code&gt; используемая для создания службы этого конкретного экземпляра</target>
        </trans-unit>
        <trans-unit id="d01f9f1efa5be666f175edf0f3d066f99322711a" translate="yes" xml:space="preserve">
          <source>2.The easiest way to create a service is by using the factory() method.
The factory() method allows us to define a service by returning an object that contains service functions and service data. The service definition function is where we place our injectable services, such as $http and $q.
Ex:</source>
          <target state="translated">2 Самый простой способ создания сервиса-использование метода factory().Метод factory()позволяет определить сервис,возвращая объект,содержащий служебные функции и служебные данные.Функция определения сервиса-это место,где мы размещаем наши инъектируемые сервисы,такие как $http и $q.Ex:</target>
        </trans-unit>
        <trans-unit id="81049cf8d158fd8f6aa9e09fb3f7674dc7278ae0" translate="yes" xml:space="preserve">
          <source>2.The function we passed in app.config(), get executed. This is called config phase, and here we have a chance to customize our service.</source>
          <target state="translated">2 Функция,которую мы передали в app.config(),выполняется.Это называется фазой config,и здесь у нас есть возможность настроить наш сервис.</target>
        </trans-unit>
        <trans-unit id="e06f9e5bc87b677a928a701f0b17b557a83c7cd8" translate="yes" xml:space="preserve">
          <source>3.Finally service instance is created by calling $get method of serviceProvider.</source>
          <target state="translated">3.Наконец,экземпляр сервиса создается вызовом метода $get serviceProvider.</target>
        </trans-unit>
        <trans-unit id="10247f3761146ad3fd29f8f04438a385637cbd75" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt;  (&amp;lt;-- GOOD)
&lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt; (&amp;lt;- ХОРОШО) &lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96509fbd15a55d9f8c6b0f16f86f369bd1959c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;'s stored value comes from running &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">сохраненное значение приходит из запуска &lt;code&gt;fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9806d20accdcf4a7d7bf03bac15b08c0e80af8cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;&amp;rsquo;s stored value comes from &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">Сохранённое значение &lt;code&gt;b&lt;/code&gt; исходит из &lt;code&gt;new&lt;/code&gt; &lt;code&gt;fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10d4a6de0cf092cde9d6b1c37da584005618d85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;&amp;rsquo;s stored value comes from first getting an instance by &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;, and then running a &lt;code&gt;$get&lt;/code&gt; method of the instance.</source>
          <target state="translated">Хранимое значение &lt;code&gt;c&lt;/code&gt; приходит с первого получения экземпляра &lt;code&gt;new&lt;/code&gt; ing &lt;code&gt;fn&lt;/code&gt; , а затем запускает метод &lt;code&gt;$get&lt;/code&gt; экземпляра.</target>
        </trans-unit>
        <trans-unit id="f37e6ab171ca302e86496ad45c7c8b082187c7b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lazily Instantiated&lt;/em&gt;: If it is not injected it won't be instantiated ever. So to use it will have to inject it to a module.</source>
          <target state="translated">&lt;em&gt;Ленивый экземпляр&lt;/em&gt; : если он не введен, он никогда не будет создан. Таким образом, чтобы использовать его, придется ввести его в модуль.</target>
        </trans-unit>
        <trans-unit id="bbc415a0718bc792ec75efc2d5784a6b2ed76fb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Singleton&lt;/em&gt;: If injected to multiple modules, all will have access to only one particular instance. That is why very convenient to share data across different controllers.</source>
          <target state="translated">&lt;em&gt;Синглтон&lt;/em&gt; : если внедрено в несколько модулей, все будут иметь доступ только к одному конкретному экземпляру. Именно поэтому очень удобно обмениваться данными между разными контроллерами.</target>
        </trans-unit>
        <trans-unit id="de74c279e2d766663b22cc4a4bef8ec70061c8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) Фабрика&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1920da3aedb3ed95be87c557b3978bf5d2066e0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; When you&amp;rsquo;re using a &lt;strong&gt;Factory&lt;/strong&gt; you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.</source>
          <target state="translated">&lt;strong&gt;1)&lt;/strong&gt; Когда вы используете &lt;strong&gt;Factory,&lt;/strong&gt; вы создаете объект, добавляете к нему свойства, а затем возвращаете тот же объект. Когда вы передадите эту фабрику в свой контроллер, эти свойства объекта теперь будут доступны в этом контроллере через вашу фабрику.</target>
        </trans-unit>
        <trans-unit id="bf79a918a5f8400f69451d6c86a9de8622bc5f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) Сервис&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fa71875fc3e6ae341d7d13637af55d62c8e9c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; When you&amp;rsquo;re using &lt;strong&gt;Service&lt;/strong&gt;, AngularJS instantiates it behind the scenes with the &amp;lsquo;new&amp;rsquo; keyword. Because of that, you&amp;rsquo;ll add properties to &amp;lsquo;this&amp;rsquo; and the service will return &amp;lsquo;this&amp;rsquo;. When you pass the service into your controller, those properties on &amp;lsquo;this&amp;rsquo; will now be available on that controller through your service.</source>
          <target state="translated">&lt;strong&gt;2)&lt;/strong&gt; Когда вы используете &lt;strong&gt;Сервис&lt;/strong&gt; , AngularJS создает его за кулисами с ключевым словом &amp;laquo;new&amp;raquo;. Из-за этого вы добавите свойства в &amp;laquo;this&amp;raquo;, и сервис вернет &amp;laquo;this&amp;raquo;. Когда вы передаете сервис в свой контроллер, эти свойства в этом элементе теперь будут доступны на этом контроллере через ваш сервис.</target>
        </trans-unit>
        <trans-unit id="e5e4c731a8abb79b43eb7b7ad7722ae53bd1e526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) Провайдер&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7891b22be8f5ced507d3b35a1a21c59dd69ef84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt;&lt;strong&gt;Providers&lt;/strong&gt; are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.</source>
          <target state="translated">&lt;strong&gt;3)&lt;/strong&gt; &lt;strong&gt;Поставщики&lt;/strong&gt; - это единственная услуга, которую вы можете передать в функцию .config (). Используйте провайдера, если вы хотите предоставить конфигурацию всего модуля для объекта службы, прежде чем сделать его доступным.</target>
        </trans-unit>
        <trans-unit id="f7a0bc6a5e55d68fca9019cb4c62b65667302df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Is they do same or have same behaviour?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Они одинаковы или ведут себя одинаково?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a51970d21894731b55def79e30e17e9251193f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Should I use service or factory? What&amp;rsquo;s the difference?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Должен ли я использовать сервис или фабрику?&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Какая разница?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61bce34778beb7a07d2ad51ff5e0491a8fe2ce06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And for beginner understand:-&lt;/strong&gt; This may not correct use case but in high level this is what usecase for these three.</source>
          <target state="translated">&lt;strong&gt;И для начинающего понять: -&lt;/strong&gt; Это может не исправить вариант использования, но на высоком уровне это то, что сценарий использования для этих трех.</target>
        </trans-unit>
        <trans-unit id="49456beeefd4b18f05312ca85704d73c7cc3b7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; the purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.</source>
          <target state="translated">&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; назначение Factory также совпадает с Service, однако в этом случае мы создаем новый объект и добавляем функции в качестве свойств этого объекта, а в конце возвращаем этот объект.</target>
        </trans-unit>
        <trans-unit id="42188f33ed58db2766909a9db9de01785a8ee47d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Provider:&lt;/strong&gt; the purpose of this is again same however Provider gives the output of it's $get function.</source>
          <target state="translated">&lt;strong&gt;Провайдер AngularJS:&lt;/strong&gt; цель этого снова та же, однако провайдер выводит свою функцию $ get.</target>
        </trans-unit>
        <trans-unit id="9a762ecbec3e860f39ad0b1b9673d2ba4d24939f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Service:&lt;/strong&gt; is used for sharing utility functions with the service reference in the controller. Service is singleton in nature so for one service only one instance is created in the browser and the same reference is used throughout the page.</source>
          <target state="translated">&lt;strong&gt;Служба AngularJS:&lt;/strong&gt; используется для совместного использования служебных функций со ссылкой на службу в контроллере. Служба является одноэлементной по своей природе, поэтому для одного сервиса в браузере создается только один экземпляр, и одна и та же ссылка используется на всей странице.</target>
        </trans-unit>
        <trans-unit id="ba46456a9f8e88791102b2d89c6c02c5e47d2e18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful with &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Будьте осторожны с &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="bf2cbd4114b4edf85514bcf9f1a8b65ee626a848" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best answers from SO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Лучшие ответы от SO:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867130b32fc3b28fc8ec819aa9caaebbdcd1a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both are Singletons&lt;/strong&gt;: Whenever Angular find these as a dependency first time,it create a single instance of service/factory. Once the instance is created, same instance is used forever.</source>
          <target state="translated">&lt;strong&gt;Оба являются синглетонами&lt;/strong&gt; : всякий раз, когда Angular находит их как зависимость в первый раз, он создает один экземпляр сервиса / фабрики. Как только экземпляр создан, тот же экземпляр используется навсегда.</target>
        </trans-unit>
        <trans-unit id="2bfbaa084726b82d3658a48125aa6f2be3899ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be used to model an object with behavior&lt;/strong&gt;: They can both have methods, internal state variables, and so on. Though the way you write that code will differ.</source>
          <target state="translated">&lt;strong&gt;Может использоваться для моделирования объекта с поведением&lt;/strong&gt; : у них могут быть методы, внутренние переменные состояния и т. Д. Хотя способ написания этого кода будет отличаться.</target>
        </trans-unit>
        <trans-unit id="0b8047b6c925051a75984184c3eab229c2a494da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Constant&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b230b0c6b04da427893e313b7c0e9d5aef5ada3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FACTORY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FACTORY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de8ae60c5e367749c74c70c938263e7f3a66bc7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factories:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="129b6a9da449d3568001d3e4449436c7a83896d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Заводская функция:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa83955bc8ebbae5eb9b7e4bea195c0e27d81128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt;
  You simply create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;Фабрика:&lt;/strong&gt; вы просто создаете объект внутри фабрики и возвращаете его.</target>
        </trans-unit>
        <trans-unit id="223321a46b7f883db5389221c0e026bc67b2f8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt; The factory you actually create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;Фабрика:&lt;/strong&gt; фабрика, на которой вы фактически создаете объект внутри фабрики и возвращаете его.</target>
        </trans-unit>
        <trans-unit id="4b5add3c153ec4e23637c1d8bfc69736e94082eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factory&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74ccee4a3bcbc7b9bc42b630b85b5d7fe42f6f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; and &lt;strong&gt;Service&lt;/strong&gt; are the most commonly used recipes. The only difference between them is that the &lt;strong&gt;Service&lt;/strong&gt; recipe works better for objects of a custom type, while the &lt;strong&gt;Factory&lt;/strong&gt; can produce JavaScript primitives and functions.</source>
          <target state="translated">&lt;strong&gt;Фабрика&lt;/strong&gt; и &lt;strong&gt;Сервис&lt;/strong&gt; - самые распространенные рецепты. Единственная разница между ними заключается в том, что рецепт &lt;strong&gt;Service&lt;/strong&gt; работает лучше для объектов пользовательского типа, тогда как &lt;strong&gt;Factory&lt;/strong&gt; может создавать примитивы и функции JavaScript.</target>
        </trans-unit>
        <trans-unit id="af69167d5e31ec4171b3b71e86c23e55eb8b3ef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; use a factory function which return a service instance.
&lt;strong&gt;serviceInstance = fnFactory();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Фабрика&lt;/strong&gt; использует фабричную функцию, которая возвращает экземпляр службы. &lt;strong&gt;serviceInstance = fnFactory ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d42eff7ec39af4e9117015764522229b8db7933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;: The value you are providing needs to be calculated based on other data.</source>
          <target state="translated">&lt;strong&gt;Фабрика&lt;/strong&gt; : предоставляемое вами значение должно быть рассчитано на основе других данных.</target>
        </trans-unit>
        <trans-unit id="15a7f656197166d5af0768e868e3d0738e892b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051543166b882d0c0302b61c6fccd2ef13890dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does provider syntax internally work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как работает синтаксис провайдера?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f24bbfd879178823cf1a6f4fa4db8fd25d88804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to create a service?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как создать сервис?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15472d9a104bad65c0d954254428090db1217241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazily instantiated&lt;/strong&gt; &amp;ndash; Angular only instantiates a service/factory when an application component depends on it.</source>
          <target state="translated">&lt;strong&gt;Ленивый экземпляр&lt;/strong&gt; - Angular создает экземпляр сервиса / фабрики только тогда, когда от него зависит компонент приложения.</target>
        </trans-unit>
        <trans-unit id="4fc1597dfe992d87dcc418262208d7b520cc2ad4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="048671a3c07af864b3160d99c16b04e4022573ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Не TL; DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c27c9c6e707014afaaa93121ac5aee4552e03e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PROVIDER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PROVIDER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e9a7279f005fa392f0780ed27247cdff005c85f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Функция провайдера:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2f1801fb48bf71dd7299a789ae89b7ca28c73fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9463ee84dc44104bf418d730d2dc12c20735e2ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="034f13e153a713ef6e1f67d027f037acfcdca111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; defines a providerConstructor function, this providerConstructor function defines a factory function &lt;strong&gt;$get&lt;/strong&gt; . Angular calls $get() to create the service object. Provider syntax has an added advantage of configuring the service object before it get instantiated.
&lt;strong&gt;serviceInstance = $get();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt; определяет функцию providerConstructor, эта функция providerConstructor определяет фабричную функцию &lt;strong&gt;$ get&lt;/strong&gt; . Angular вызывает $ get () для создания объекта службы. Синтаксис провайдера имеет дополнительное преимущество в настройке объекта службы перед его созданием. &lt;strong&gt;serviceInstance = $ get ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58cb452a8449a0480646f34b32c4f0b2da41ff86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">&lt;strong&gt;Поставщик&lt;/strong&gt; - самый сложный тип рецепта. Вам это не нужно, если вы не создаете многократно используемый фрагмент кода, который требует глобальной настройки.</target>
        </trans-unit>
        <trans-unit id="af542f111be3a6b9b5eb1bba21844f854821a94c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; recipe is used mostly in the app config, before the app has fully started/initialized.</source>
          <target state="translated">Рецепт &lt;strong&gt;провайдера&lt;/strong&gt; используется в основном в конфигурации приложения, прежде чем приложение полностью запустится / инициализируется.</target>
        </trans-unit>
        <trans-unit id="5a61e7a67bd37a0cf34633a672f8ef4ac61746cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;: You want to be able to configure, during the config phase, the object that is going to be created before it&amp;rsquo;s created. Use the Provider mostly in the app config, before the app has fully initialized.</source>
          <target state="translated">&lt;strong&gt;Поставщик&lt;/strong&gt; : вы хотите иметь возможность настроить на этапе настройки объект, который будет создан до его создания. Используйте поставщика в основном в конфигурации приложения, прежде чем приложение будет полностью инициализировано.</target>
        </trans-unit>
        <trans-unit id="1ab8bcf5f1f62f6d12fe01bbd3797bf5f9edaf2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a Value from a &lt;code&gt;Service&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Возврат значения из &lt;code&gt;Service&lt;/code&gt; &lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d8b225479a57e32c9b9bbce57b80db8803839e1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVICE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;SERVICE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="1723b4864b43191225849524b7490ba00136326d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service vs provider vs factory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сервис против провайдера против фабрики:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddf188521bbad55d877526ca526e747468a9d8b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c48ba497f0f940a447148665d013066e3821706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3625561b5600fccb382876ffa98f2e89623ad206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; is all about &lt;code&gt;new&lt;/code&gt; keyword actually which as we know does 4 things:</source>
          <target state="translated">&lt;strong&gt;Сервис&lt;/strong&gt; - это все о &lt;code&gt;new&lt;/code&gt; ключевом слове, которое, как мы знаем, делает 4 вещи:</target>
        </trans-unit>
        <trans-unit id="643dc71e1844f583afedf84a3c290ed53ca1a986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; use a constructor function and Angular invoke this constructor function using 'new' keyword for creating the service instance.
&lt;strong&gt;serviceInstance = new fnServiceConstructor();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сервис&lt;/strong&gt; использует функцию конструктора, и Angular вызывает эту функцию конструктора, используя ключевое слово &amp;laquo;new&amp;raquo; для создания экземпляра сервиса. &lt;strong&gt;serviceInstance = new fnServiceConstructor ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="934fb2b4d6b5561f358e2ea098b02b599fac1ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;: You are returning an object with methods.</source>
          <target state="translated">&lt;strong&gt;Сервис&lt;/strong&gt; : вы возвращаете объект с методами.</target>
        </trans-unit>
        <trans-unit id="917d24961ee3bd9397cee700d2697066bdc8ebc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Services:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b86f1f47c5d0e8ae25c0b4bfeddc837fbe553961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Singletons&lt;/strong&gt; &amp;ndash; Each component
  dependent on a service gets a reference to the single instance
  generated by the service factory.</source>
          <target state="translated">&lt;strong&gt;Singletons&lt;/strong&gt; - каждый компонент, зависящий от сервиса, получает ссылку на один экземпляр, сгенерированный фабрикой сервисов.</target>
        </trans-unit>
        <trans-unit id="236552a9e0c737f0dce61f3fd278300c81df52c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Исходный код фабрики&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dca20d5f0cc36fd7219eb42b9a3bd59a5f14fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Исходный код сервиса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3ab06d46eba0ea55e3a63532b502c8e68aaf041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntactic Sugar is the difference&lt;/strong&gt;. Only provider is needed. Or in other words only provider is the real angular, all other ones are derived(to reduce code). There is a simple version as well, called Value()  which returns just the value, no calculation or function. Even Value is derived from provider!</source>
          <target state="translated">&lt;strong&gt;Синтаксический сахар - это разница&lt;/strong&gt; . Нужен только провайдер. Или, другими словами, реальным углом является только поставщик, все остальные являются производными (чтобы уменьшить код). Существует также простая версия, называемая Value (), которая возвращает только значение, без вычисления или функции. Четное значение получено от поставщика!</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5f0f8f2415dfbd7ea64cb1c92c78ef8982eb6db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The major differences among Services, Factories, and Providers are their complexities. Services are the simplest form, Factories are a little more robust, and Providers are configurable at runtime.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Основными различиями между Сервисами, Фабриками и Поставщиками являются их сложности.&lt;/strong&gt; &lt;strong&gt;Сервисы - это самая простая форма, фабрики немного более устойчивы, а провайдеры настраиваются во время выполнения.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5265dba3d641afcb7e0148f9229e5a29c5cbf0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding AngularJS Factory, Service and Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Понимание AngularJS Factory, Сервис и Поставщик&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="372f60334aa5d8918e891d52c780ab816ff7ba23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="761726747ff7c1d3bd1aef8307caf8babe873bd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4167298ff7e32e5b1773e3433a0f0e71939b8a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Service:&lt;/strong&gt;
In AngularJS, &lt;strong&gt;Service&lt;/strong&gt; is nothing but a singleton JavaScript object which can store some useful methods or properties. This singleton object is created per ngApp(Angular app) basis and it is shared among all the controllers within current app. When Angularjs instantiate a service object, it register this service object with a unique service name. So each time when we need service instance, Angular search the registry for this service name, and it returns the reference to service object. Such that we can invoke method, access properties etc on the service object.
You may have question whether you can also put properties, methods on scope object of controllers! So why you need service object? Answers is: services are shared among multiple controller scope. If you put some properties/methods in a controller's scope object , it will be available to current scope only. But when you define methods, properties on service object, it will be available globally and can be accessed in any  controller's scope by injecting that service.</source>
          <target state="translated">&lt;strong&gt;Что такое Сервис:&lt;/strong&gt; В AngularJS &lt;strong&gt;Сервис&lt;/strong&gt; - это не что иное, как одноэлементный объект JavaScript, который может хранить некоторые полезные методы или свойства. Этот одноэлементный объект создается на основе ngApp (приложения Angular) и используется всеми контроллерами в текущем приложении. Когда Angularjs создает объект службы, он регистрирует этот объект службы с уникальным именем службы. Поэтому каждый раз, когда нам нужен экземпляр службы, Angular ищет в реестре это имя службы и возвращает ссылку на объект службы. Так что мы можем вызывать метод, обращаться к свойствам и т. Д. На объекте службы. У вас может возникнуть вопрос, можете ли вы также поместить свойства, методы в объектную область контроллеров! Так зачем вам сервисный объект? Ответы таковы: службы распределяются между несколькими контроллерами. Если вы поместите некоторые свойства / методы в объект области видимости контроллера, он будет доступен только для текущей области видимости. Но когда вы определяете методы, свойства объекта службы, он будет доступен глобально и может быть доступен в любой области контроллера путем внедрения этой службы.</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e41544278c3c3cd14f313568ad2ca9b33654a735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7c38fc9331c68d06c6051d868ab8034c6a1b71f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5fb6e5fc13a01937ae02611fcad859574413d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index.html&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;index.html&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd88803cf5db529cfe7cb230c25afc9af0e166" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;provider:&lt;/strong&gt; The provider there&amp;rsquo;s a $get you define and it can be used to get the object that returns the data.</source>
          <target state="translated">&lt;strong&gt;провайдер: в качестве&lt;/strong&gt; провайдера вы определяете $ get, и его можно использовать для получения объекта, который возвращает данные.</target>
        </trans-unit>
        <trans-unit id="8592d58f6159c5178f21fdbf4b05247f87defaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;service:&lt;/strong&gt; The service you just have a standard function that uses the this keyword to define function.</source>
          <target state="translated">&lt;strong&gt;service:&lt;/strong&gt; служба, у вас просто есть стандартная функция, которая использует ключевое слово this для определения функции.</target>
        </trans-unit>
        <trans-unit id="6460b1c41e40026d826a70fb0ec47b36aaed8244" translate="yes" xml:space="preserve">
          <source>A factory is a plain old function that returns a value. The return value is what gets injected into things that depend on the factory. A typical factory pattern in Angular is to return an object with functions as properties, like this:</source>
          <target state="translated">Завод-это обычная старая функция,которая возвращает значение.Возвращаемое значение-это то,что впрыскивается в вещи,зависящие от завода.Типичный заводской образец в Angular (Угловой)-это возврат объекта с такими функциями,как свойства:</target>
        </trans-unit>
        <trans-unit id="6654378b8441365d9dbee921cd9c4b6d04ad1238" translate="yes" xml:space="preserve">
          <source>A factory is function where you can manipulate/add logic before creating an object, then the newly created object gets returned.</source>
          <target state="translated">Фабрика-это функция,в которой вы можете манипулировать логикойadd перед созданием объекта,после чего вновь созданный объект будет возвращен.</target>
        </trans-unit>
        <trans-unit id="92657294903a95f8b7ea12e4be26ab19bd209d60" translate="yes" xml:space="preserve">
          <source>A more general value, that is possible to be computed right away. It works by passing a function to AngularJS with the logic needed to compute the value and AngularJS executes it, and it saves the return value in the named variable.</source>
          <target state="translated">Более общее значение,которое можно вычислить сразу.Она работает,передавая функцию AngularJS с логикой,необходимой для вычисления значения,а AngularJS выполняет ее,и сохраняет возвращаемое значение в именованной переменной.</target>
        </trans-unit>
        <trans-unit id="c98519712b1bcd2194f1ab8049f9c95b677e57e2" translate="yes" xml:space="preserve">
          <source>A provider
= must contain a property called $get (+Factory, + Service, + Value)</source>
          <target state="translated">Провайдер=должен содержать свойство,называемое $get (+Фабрика,+Сервис,+Ценность).</target>
        </trans-unit>
        <trans-unit id="70cc8179c33c6143e3fd269921c56cce6794df6a" translate="yes" xml:space="preserve">
          <source>A provider is used to create a configurable service object. You can configure the service setting from config function. It returns a value by using the &lt;code&gt;$get()&lt;/code&gt; function. The &lt;code&gt;$get&lt;/code&gt; function gets executed on the run phase in angular.</source>
          <target state="translated">Поставщик используется для создания настраиваемого объекта службы. Вы можете настроить параметры сервиса из функции конфигурации. Возвращает значение с помощью функции &lt;code&gt;$get()&lt;/code&gt; . Функция &lt;code&gt;$get&lt;/code&gt; выполняется в фазе выполнения в угловых.</target>
        </trans-unit>
        <trans-unit id="2690ab0e17349d256212ca0a5c254ff9f7224715" translate="yes" xml:space="preserve">
          <source>A provider that can
instantiate + do something = Service (+ Factory, + Value)</source>
          <target state="translated">Провайдер,который может инстанцировать+что-то сделать=Услуга (+Фабрика,+Значение).</target>
        </trans-unit>
        <trans-unit id="1552cdef3a8c9efd2ca6378e425896d47cd0a7d2" translate="yes" xml:space="preserve">
          <source>A provider that can just
instantiate and return = Factory (+ Value)</source>
          <target state="translated">Провайдер,который может просто инстанцировать и вернуть=Завод (+Значение).</target>
        </trans-unit>
        <trans-unit id="5bac4ef74fca1e1f11c40a61c18eb5751a56a24e" translate="yes" xml:space="preserve">
          <source>A provider that can return value = Value</source>
          <target state="translated">Провайдер,который может вернуть значение=Значение</target>
        </trans-unit>
        <trans-unit id="daa9ad8c9da39c96b0cd1b5e9b85ad76ef92e025" translate="yes" xml:space="preserve">
          <source>A service is a constructor function, and Angular will instantiate it by calling new &lt;code&gt;yourServiceName()&lt;/code&gt;. This means a couple of things.</source>
          <target state="translated">Служба является функцией конструктора, и Angular создаст ее экземпляр, вызвав new &lt;code&gt;yourServiceName()&lt;/code&gt; . Это означает пару вещей.</target>
        </trans-unit>
        <trans-unit id="f30916da78a012d617c7c608b91dd4f9e4ccb7cc" translate="yes" xml:space="preserve">
          <source>A service is a more stripped-down version of &lt;em&gt;factory&lt;/em&gt; which is valid only when the value is an object, and it allows for writing any logic directly in the function (as if it would be a constructor), as well as declaring and accessing the object properties using the &lt;em&gt;this&lt;/em&gt; keyword.</source>
          <target state="translated">Служба - это более урезанная версия &lt;em&gt;фабрики,&lt;/em&gt; которая действует только тогда, когда значение является объектом, и она позволяет писать любую логику непосредственно в функции (как если бы она была конструктором), а также объявлять и получать доступ к свойства объекта с использованием &lt;em&gt;этого&lt;/em&gt; ключевого слова.</target>
        </trans-unit>
        <trans-unit id="e010047a835b4f08a52ebcf31da9133c3b0c83eb" translate="yes" xml:space="preserve">
          <source>Ability to use other services (have dependencies)</source>
          <target state="translated">Возможность пользоваться другими услугами (иметь зависимости)</target>
        </trans-unit>
        <trans-unit id="90d836d3d0cb6acecac1372abfaeed5f7a898db3" translate="yes" xml:space="preserve">
          <source>After reading all these post It created more confuse for me.. But still all is worthfull information.. finally I found following table which will give information with simple comparision</source>
          <target state="translated">После прочтения всех этих постов это создало мне еще большую путаницу...Но все равно все стоит информации...наконец-то я нашел следующую таблицу,которая даст информацию с простым сравнением.</target>
        </trans-unit>
        <trans-unit id="eba926c51e345f5492b036b8fb2838c80ca0f326" translate="yes" xml:space="preserve">
          <source>Ajax call or third party integrations needs to be &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">Ajax-вызов или сторонние интеграции должны быть &lt;strong&gt;сервисными&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="db39b22c1144a74c69ee802842ea57e37d383130" translate="yes" xml:space="preserve">
          <source>All Services are &lt;strong&gt;singletons&lt;/strong&gt;; they get instantiated once per app. They can be &lt;strong&gt;of any type&lt;/strong&gt;, whether it be a primitive, object literal, function, or even an instance of a custom type.</source>
          <target state="translated">Все Сервисы являются &lt;strong&gt;одиночными&lt;/strong&gt; ; они создаются один раз за приложение. Они могут быть &lt;strong&gt;любого типа&lt;/strong&gt; , будь то примитив, литерал объекта, функция или даже экземпляр пользовательского типа.</target>
        </trans-unit>
        <trans-unit id="44b4a8e5249ee92bb57692eb4f38230e89ca0b32" translate="yes" xml:space="preserve">
          <source>All of these are used to share reusable singleton objects. It helps to share reusable code across your app/various components/modules.</source>
          <target state="translated">Все они используются для совместного использования однокнопочных объектов многоразового использования.Это помогает обмениваться многократно используемым кодом между вашими модулями.</target>
        </trans-unit>
        <trans-unit id="15074bf6692ab4d76bbae6a637a1292c7beea479" translate="yes" xml:space="preserve">
          <source>All special purpose objects except for the Controller are defined via Factory recipes.</source>
          <target state="translated">Все объекты специального назначения,кроме контроллера,определяются по заводским рецептам.</target>
        </trans-unit>
        <trans-unit id="1797d93eba62a3e50c0f75705fc2654c1c5d7cc1" translate="yes" xml:space="preserve">
          <source>All the good answers already. I would like to add few more points on &lt;strong&gt;Service&lt;/strong&gt; and &lt;strong&gt;Factory&lt;/strong&gt;. Along with the difference between service/factory. And  one can also have questions like:</source>
          <target state="translated">Все хорошие ответы уже. Я хотел бы добавить еще несколько пунктов на &lt;strong&gt;Сервис&lt;/strong&gt; и &lt;strong&gt;Фабрика&lt;/strong&gt; . Вместе с разницей между сервисом / фабрикой. И можно также иметь такие вопросы, как:</target>
        </trans-unit>
        <trans-unit id="644fa5425851502f8b0f2b6d2e894a7a71bc764b" translate="yes" xml:space="preserve">
          <source>An additional clarification is that factories can create functions/primitives, while services cannot. Check out this &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; based on Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt;.</source>
          <target state="translated">Дополнительным разъяснением является то, что фабрики могут создавать функции / примитивы, а службы - нет. Проверьте это &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; на основе Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1698cdf07eaa30b1f4d2eb589b401f5aa7c167b5" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Factory&lt;/strong&gt; is all about Factory Pattern - contains functions that return Objects like that Service.</source>
          <target state="translated">А &lt;strong&gt;Factory&lt;/strong&gt; - это все о Factory Pattern - она ​​содержит функции, которые возвращают объекты, подобные этой службе.</target>
        </trans-unit>
        <trans-unit id="087105228646ef19c5b815759ef3bd7c8d79035e" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Value, Factory, Service and Constant&lt;/strong&gt; (4 ways) - the syntactic sugar over &lt;strong&gt;Provider&lt;/strong&gt; way/recepie.</source>
          <target state="translated">И &lt;strong&gt;Value, Factory, Service и Constant&lt;/strong&gt; (4 способа) - синтаксический сахар по сравнению с &lt;strong&gt;Provider&lt;/strong&gt; way / recepie.</target>
        </trans-unit>
        <trans-unit id="a4a0d683875e15a20d100e9c4f3cabe527897b12" translate="yes" xml:space="preserve">
          <source>And a better answer would be this:
&quot;An Angular service is created by a service factory. These service factories are functions which, in turn, are created by a service provider. The service providers are constructor functions. When instantiated they must contain a property called $get, which holds the service factory function.&quot;</source>
          <target state="translated">И лучшим ответом будет вот это:&quot;Угловой сервис&quot; создается сервисной фабрикой.Эти сервисные фабрики-это функции,которые,в свою очередь,создаются поставщиком услуг&quot;.Поставщики услуг-это функции конструктора.Когда они инстанциированы,они должны содержать свойство $get,которое содержит функцию сервисной фабрики&quot;.</target>
        </trans-unit>
        <trans-unit id="6e1a1be7a3c89b4a49965d6931152adc8b79b49f" translate="yes" xml:space="preserve">
          <source>And this simple/short video: covers also &lt;strong&gt;Provider&lt;/strong&gt;: &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (there you see can see how they go from factory to provider)</source>
          <target state="translated">И это простое / короткое видео: также охватывает поставщика.</target>
        </trans-unit>
        <trans-unit id="5e753d8417cbbaa903d75c9067f03b753d972dae" translate="yes" xml:space="preserve">
          <source>Angular injection gives us the first hint in reaching this conclusion.</source>
          <target state="translated">Угловая инъекция дает нам первый намек на этот вывод.</target>
        </trans-unit>
        <trans-unit id="c0fbc9b675108602e2b9fac4e8674fd1d9ad2553" translate="yes" xml:space="preserve">
          <source>AngularJS provide different methods to register a service. Here we will concentrate on three methods factory(..),service(..),provider(..);</source>
          <target state="translated">AngularJS предоставляет различные методы регистрации сервиса.Здесь мы сконцентрируемся на трех методах:factory(...),service(...),provider(...);</target>
        </trans-unit>
        <trans-unit id="a2a043dede3ac539ee64b89b2d49b7bd51e23891" translate="yes" xml:space="preserve">
          <source>AngularJS provides &lt;strong&gt;'factory('serviceName', fnFactory)'&lt;/strong&gt; method which takes two parameter, serviceName and a JavaScript function. Angular creates service instance by invoking the function &lt;strong&gt;fnFactory()&lt;/strong&gt; such as below.</source>
          <target state="translated">AngularJS предоставляет метод &lt;strong&gt;factory ('serviceName', fnFactory) ',&lt;/strong&gt; который принимает два параметра, serviceName и функцию JavaScript. Angular создает экземпляр службы, вызывая функцию &lt;strong&gt;fnFactory (),&lt;/strong&gt; например ниже.</target>
        </trans-unit>
        <trans-unit id="67487acbc494fde4c0ecdb230e55c47bdc819cc5" translate="yes" xml:space="preserve">
          <source>AngularJS: Service vs provider vs factory</source>
          <target state="translated">AngularJS:Сервис против провайдера против фабрики</target>
        </trans-unit>
        <trans-unit id="62b46f141dc945f1baeeda1b182a386db6799d55" translate="yes" xml:space="preserve">
          <source>Answers for above 1 and 2 questions:</source>
          <target state="translated">Ответы на вопросы выше 1 и 2:</target>
        </trans-unit>
        <trans-unit id="f5181cbde0884af842b881fdae06a3ba0616e0a1" translate="yes" xml:space="preserve">
          <source>As a side note, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; are all derived from provider.</source>
          <target state="translated">Как примечание, &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;factory&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; все получены от поставщика.</target>
        </trans-unit>
        <trans-unit id="b8e0a3698c74b06188537beb6504f05ed6da8541" translate="yes" xml:space="preserve">
          <source>As mentioned before, the whole point of creating a service with Provider is to be able to alter some variables through the app.config function before the final object is passed to the rest of the application. Let&amp;rsquo;s see an example of that.</source>
          <target state="translated">Как упоминалось ранее, весь смысл создания службы с помощью Provider заключается в том, чтобы иметь возможность изменять некоторые переменные с помощью функции app.config до того, как конечный объект будет передан остальной части приложения. Давайте посмотрим пример этого.</target>
        </trans-unit>
        <trans-unit id="ac8bd4adf742322d3119e359d466fd027d4a144c" translate="yes" xml:space="preserve">
          <source>As pointed out by several people here correctly a factory, provider, service, and even value and constant are versions of the same thing. You can dissect the more general &lt;code&gt;provider&lt;/code&gt; into all of them. Like so:</source>
          <target state="translated">Как правильно указали некоторые люди, фабрика, поставщик, сервис и даже значение и константа являются версиями одного и того же. Вы можете разделить более общего &lt;code&gt;provider&lt;/code&gt; на всех из них. Вот так:</target>
        </trans-unit>
        <trans-unit id="7ac115d7759453df5c7a6ee0d961bac591936f70" translate="yes" xml:space="preserve">
          <source>Basically all of the mentioned types (service, factory, provider, etc.) are just creating and configuring global variables (that are of course global to the entire application), just as old fashioned global variables were.</source>
          <target state="translated">В основном все упомянутые типы (сервис,фабрика,провайдер и т.д.)просто создают и настраивают глобальные переменные (которые,конечно,являются глобальными для всего приложения),точно так же,как и старомодные глобальные переменные.</target>
        </trans-unit>
        <trans-unit id="76a6d228807b2f0db9ca8817dcc7b6fe1992e7f5" translate="yes" xml:space="preserve">
          <source>Below &lt;strong&gt;setArtist&lt;/strong&gt; accepts an artist and allows you to set the artist. &lt;strong&gt;getArtist&lt;/strong&gt; returns the artist. &lt;strong&gt;callItunes&lt;/strong&gt; first calls makeUrl() in order to build the URL we&amp;rsquo;ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying &amp;lsquo;There was an error&amp;rsquo;.</source>
          <target state="translated">Ниже &lt;strong&gt;setArtist&lt;/strong&gt; принимает художника и позволяет установить художника. &lt;strong&gt;getArtist&lt;/strong&gt; возвращает художника. &lt;strong&gt;callItunes&lt;/strong&gt; сначала вызывает makeUrl (), чтобы создать URL, который мы будем использовать с нашим запросом $ http. Затем он устанавливает объект обещания, делает запрос $ http с нашим окончательным URL, затем, так как $ http возвращает обещание, мы можем вызвать .success или .error после нашего запроса. Затем мы разрешаем наше обещание с помощью данных iTunes или отклоняем его с сообщением &amp;laquo;Произошла ошибка&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ecc9654f84abda3f226923e7181cd6dedcabf706" translate="yes" xml:space="preserve">
          <source>Below is code for how you can think about what the &amp;lsquo;new&amp;rsquo; keyword is actually doing in JavaScript. It&amp;rsquo;s basically a code example of the above paragraph. I&amp;rsquo;ve put the &amp;lsquo;interpreter view&amp;rsquo; or the way the interpreter sees the code inside of notes.</source>
          <target state="translated">Ниже приведен код того, как вы можете думать о том, что на самом деле делает ключевое слово &amp;laquo;новый&amp;raquo; в JavaScript. Это в основном пример кода вышеупомянутого абзаца. Я поместил &amp;laquo;представление интерпретатора&amp;raquo; или то, как интерпретатор видит код внутри заметок.</target>
        </trans-unit>
        <trans-unit id="baeffb61d23b4b1a1faec7ea79fc7982401fe040" translate="yes" xml:space="preserve">
          <source>But if you declare an AngularJS &quot;value&quot; (for example., &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt;), you can inject it into services and factories, but NOT into the provider-creating function. You can, however, inject it into the &lt;code&gt;$get&lt;/code&gt; function that you define for your provider. This is mentioned in the AngularJS documentation, but it's easy to miss. You can find it on the %provide page in the sections on the value and constant methods.</source>
          <target state="translated">Но если вы объявляете AngularJS &amp;laquo;значение&amp;raquo; (например, &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt; ), вы можете внедрить его в службы и фабрики, но НЕ в функцию создания провайдера , Однако вы можете добавить его в функцию &lt;code&gt;$get&lt;/code&gt; которую вы определили для своего провайдера. Это упоминается в документации AngularJS, но это легко пропустить. Вы можете найти его на странице% provide в разделах о методах value и constant.</target>
        </trans-unit>
        <trans-unit id="e1cc6d183fce2197bb4d499453f325c6ce15d621" translate="yes" xml:space="preserve">
          <source>But that is way too wordy. A shorter way to write this would be &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</source>
          <target state="translated">Но это слишком многословно. Короче, чтобы написать это, было бы обеспечить &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0b23422a6346dcd33f9ef7c177b5c4c2e0c0ba5" translate="yes" xml:space="preserve">
          <source>But what if we wanted to configure the &lt;code&gt;Greeter&lt;/code&gt; class before the injection? Then we could write</source>
          <target state="translated">Но что, если мы хотим настроить класс &lt;code&gt;Greeter&lt;/code&gt; перед инъекцией? Тогда мы могли бы написать</target>
        </trans-unit>
        <trans-unit id="83edd94ef1f4218a2a09268ba1c79454b4d8ce41" translate="yes" xml:space="preserve">
          <source>But what if you want to be more OO and have a class called Greeter?</source>
          <target state="translated">Но что,если ты хочешь быть больше OO и иметь класс под названием Greeter?</target>
        </trans-unit>
        <trans-unit id="bead6ae023dd1ddfc66d0c3554dd68115419ed4a" translate="yes" xml:space="preserve">
          <source>Code posted here is copied straight from the above source, to benefit readers.</source>
          <target state="translated">Код,размещенный здесь,скопирован прямо из вышеуказанного источника,для удобства читателей.</target>
        </trans-unit>
        <trans-unit id="d3a3e026964278d33abfaf0d31b51f4e99ed0a5a" translate="yes" xml:space="preserve">
          <source>Defining and using Service, Factory and Provider are explained at &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;</source>
          <target state="translated">Определение и использование Сервиса, Фабрики и Поставщика объясняется по адресу &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d0d609d4405f2baa362951b7009d2417093fd7d" translate="yes" xml:space="preserve">
          <source>Delayed/lazy initialization</source>
          <target state="translated">Задержка инициализации</target>
        </trans-unit>
        <trans-unit id="cb560adb9a207096df4103f0ce35af068e58441a" translate="yes" xml:space="preserve">
          <source>Due to how JavaScript constructors work, if you return a complex value &lt;code&gt;(i.e., an Object)&lt;/code&gt; from a &lt;code&gt;constructor&lt;/code&gt; function, the caller will get that Object instead of the this instance.</source>
          <target state="translated">Из-за того, как работают конструкторы JavaScript, если вы возвращаете сложное значение &lt;code&gt;(i.e., an Object)&lt;/code&gt; из функции &lt;code&gt;constructor&lt;/code&gt; , вызывающая сторона получит этот объект вместо экземпляра this.</target>
        </trans-unit>
        <trans-unit id="0ce56bb9d7649bd1affa9d15ef3b25e94ed4bf16" translate="yes" xml:space="preserve">
          <source>Essentially, Provider, Factory, and Service are all Services. A Factory is a special case of a Service when all you need is a $get() function, allowing you to write it with less code.</source>
          <target state="translated">По существу,поставщик,фабрика и сервис-это все Услуги.Фабрика-это особый случай Услуги,когда все,что вам нужно-это функция $get(),позволяющая писать ее с меньшим количеством кода.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="5871c248f6153cd0a547c43f6815327faa66746e" translate="yes" xml:space="preserve">
          <source>Factories are the most popular way to create and configure a service. There&amp;rsquo;s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below.</source>
          <target state="translated">Фабрики являются наиболее популярным способом создания и настройки сервиса. Там действительно не намного больше, чем то, что сказал TL; DR. Вы просто создаете объект, добавляете к нему свойства, а затем возвращаете тот же объект. Затем, когда вы передадите фабрику в свой контроллер, эти свойства объекта теперь будут доступны в этом контроллере через вашу фабрику. Более подробный пример приведен ниже.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="c8e6696140d2e75575a027e3db926b81e7fa86b8" translate="yes" xml:space="preserve">
          <source>Factory and Service are the most commonly used recipes. The only difference between them is that the Service recipe works better for objects of a custom type, while the Factory can produce JavaScript primitives and functions.</source>
          <target state="translated">Фабрика и сервис являются наиболее часто используемыми рецептами.Единственное различие между ними в том,что сервисный рецепт лучше работает для объектов пользовательского типа,в то время как Фабрика может производить JavaScript примитивы и функции.</target>
        </trans-unit>
        <trans-unit id="7ee844ac41ac4ad9686ec614f908d3bdcb5b3e81" translate="yes" xml:space="preserve">
          <source>Factory is a class. Use factories if you want to provide custom classes for your code (can't be done with services because they are already instantiated).</source>
          <target state="translated">Фабрика-это класс.Используйте фабрики,если вы хотите предоставить пользовательские классы для вашего кода (не может быть сделано с услугами,потому что они уже инстанциированы).</target>
        </trans-unit>
        <trans-unit id="c43d055974d1f89c7db6d2a6f06d9706cf84359d" translate="yes" xml:space="preserve">
          <source>Features of Factory:</source>
          <target state="translated">Особенности фабрики:</target>
        </trans-unit>
        <trans-unit id="8f233e0733ea2bd7573612519e22b6483ee2aae2" translate="yes" xml:space="preserve">
          <source>Features of Provider:</source>
          <target state="translated">Особенности провайдера:</target>
        </trans-unit>
        <trans-unit id="8b33d5b1a4171b12f08419f5a3175c6118df72b0" translate="yes" xml:space="preserve">
          <source>Features of Service:</source>
          <target state="translated">Особенности обслуживания:</target>
        </trans-unit>
        <trans-unit id="555321235e9eb2d0c7b4fff9ef2c877ead66f84d" translate="yes" xml:space="preserve">
          <source>Finally the UI which works with any of the above services:</source>
          <target state="translated">Наконец,пользовательский интерфейс,который работает с любой из вышеперечисленных служб:</target>
        </trans-unit>
        <trans-unit id="aa41b2f6147d97e7462dbecaf90f19a90ed1b067" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s create our Constructor.</source>
          <target state="translated">Сначала давайте создадим наш конструктор.</target>
        </trans-unit>
        <trans-unit id="dfb58a29f6c2cb946fda2080d277aff94876b78f" translate="yes" xml:space="preserve">
          <source>First let's have a look at the syntax:</source>
          <target state="translated">Сначала давайте посмотрим на синтаксис:</target>
        </trans-unit>
        <trans-unit id="16ae293f476b801e0ec98c3b0c772f3098dc7e49" translate="yes" xml:space="preserve">
          <source>First of all, let's talk about &lt;strong&gt;services&lt;/strong&gt; in AngularJS!</source>
          <target state="translated">Прежде всего, давайте поговорим об &lt;strong&gt;услугах&lt;/strong&gt; в AngularJS!</target>
        </trans-unit>
        <trans-unit id="f626e9e8c764b63df367572217b72dfec8d3d0d8" translate="yes" xml:space="preserve">
          <source>First of all: &lt;strong&gt;Provider&lt;/strong&gt; is the way/recipe to create a &lt;code&gt;service&lt;/code&gt; (singleton object) that suppose to be injected by $injector (how AngulaJS goes about IoC pattern).</source>
          <target state="translated">Прежде всего: &lt;strong&gt;Provider&lt;/strong&gt; - это способ / рецепт для создания &lt;code&gt;service&lt;/code&gt; (одноэлементный объект), который предполагается внедрить с помощью $ injector (как AngulaJS использует шаблон IoC).</target>
        </trans-unit>
        <trans-unit id="a7d7fe2894bd6c66d071f952d684e2326b49b1e5" translate="yes" xml:space="preserve">
          <source>First things first, let&amp;rsquo;s create our &amp;lsquo;private&amp;rsquo; and helper function. This should look very familiar since we did the exact same thing with our factory. I won&amp;rsquo;t explain what each line does here because I did that in the factory example, if you&amp;rsquo;re confused, re-read the factory example.</source>
          <target state="translated">Прежде всего, давайте создадим нашу &amp;laquo;приватную&amp;raquo; и вспомогательную функцию. Это должно выглядеть очень знакомо, так как мы сделали то же самое с нашей фабрикой. Я не буду объяснять, что здесь делает каждая строка, потому что я сделал это в заводском примере, если вы не уверены, перечитайте заводской пример.</target>
        </trans-unit>
        <trans-unit id="274879ea02d1b32f25fdcf0d6f4b8638ad84e454" translate="yes" xml:space="preserve">
          <source>First we set up our Provider in a similar way we did with our Service and Factory. The variables below are our &amp;lsquo;private&amp;rsquo; and helper function.</source>
          <target state="translated">Сначала мы настраиваем нашего провайдера аналогично тому, как мы работали с нашим сервисом и фабрикой. Переменные ниже - это наша &amp;laquo;приватная&amp;raquo; и вспомогательная функция.</target>
        </trans-unit>
        <trans-unit id="0f18e05a1a2cf2fab2012ea1acb85960d14f94f3" translate="yes" xml:space="preserve">
          <source>Follows the factory design pattern. The factory is a central place that produces new objects or functions.</source>
          <target state="translated">Соблюдает заводской образец дизайна.Фабрика является центральным местом,где создаются новые объекты или функции.</target>
        </trans-unit>
        <trans-unit id="124166829dcd8ce12e68c97aa74ddc87e6f4700c" translate="yes" xml:space="preserve">
          <source>For Data manipulations create it as &lt;strong&gt;factory&lt;/strong&gt;</source>
          <target state="translated">Для манипулирования данными создайте его как &lt;strong&gt;фабрику&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d4008d04bf8dc913dd361a11d1dbf2dd7fff6d9" translate="yes" xml:space="preserve">
          <source>For basic scenarios factory&amp;amp;Service behaves same.</source>
          <target state="translated">Для базовых сценариев фабрика и сервис ведут себя одинаково.</target>
        </trans-unit>
        <trans-unit id="be44b8b9aee8e49c0f525f0d589dc7ae0563c459" translate="yes" xml:space="preserve">
          <source>For me the best and the simplest way of understanding the difference is:</source>
          <target state="translated">Для меня лучший и самый простой способ понять разницу:</target>
        </trans-unit>
        <trans-unit id="56ff743259acbed742d59f1071ec5c09de91c4a2" translate="yes" xml:space="preserve">
          <source>For me, the revelation came when I realized that they all work the same way: by running something &lt;strong&gt;once&lt;/strong&gt;, storing the value they get, and then cough up &lt;strong&gt;that same stored value&lt;/strong&gt; when referenced through &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">Для меня откровение пришло, когда я понял, что все они работают одинаково: запустив что-то &lt;strong&gt;один раз&lt;/strong&gt; , сохраняя полученное значение, а затем обработав &lt;strong&gt;то же самое сохраненное значение,&lt;/strong&gt; когда на него ссылаются посредством &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;внедрения зависимостей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b27ee14ba7c9338b5357168645fc5fca69baff87" translate="yes" xml:space="preserve">
          <source>For more details, see a post I wrote on the difference: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</source>
          <target state="translated">Для получения дополнительной информации см. Сообщение, которое я написал о разнице: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd35023ca5fbcbbe13f3b8c3e423caa7232e2d3e" translate="yes" xml:space="preserve">
          <source>For the most part, just stick with using factories for everything.
  Their behavior is easier to understand. There&amp;rsquo;s no choice to make
  about whether to return a value or not, and furthermore, no bugs to be
  introduced if you do the wrong thing.</source>
          <target state="translated">По большей части, просто используйте фабрики для всего. Их поведение легче понять. Нет никакого выбора, возвращать ли значение или нет, и, кроме того, нет ошибок, если вы поступите неправильно.</target>
        </trans-unit>
        <trans-unit id="6bc24d8b9740765e38f68d62a235ac7b05a3ba82" translate="yes" xml:space="preserve">
          <source>From Docs &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Service/Factory&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">Из Документов &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Сервис / Фабрика&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f49fa588c62b7f2f5abba55d1b95ecf06f622095" translate="yes" xml:space="preserve">
          <source>From the AngularJS mailing list I got &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;an amazing thread&lt;/a&gt; that explains service vs factory vs provider and their injection usage. Compiling the answers:</source>
          <target state="translated">Из списка рассылки AngularJS я получил &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;удивительную ветку, в&lt;/a&gt; которой рассказывается о сервисе, фабрике, провайдере и их использовании. Составление ответов:</target>
        </trans-unit>
        <trans-unit id="fd7022a8753e6add51e2b9d2c29e59c134d3fba6" translate="yes" xml:space="preserve">
          <source>Functions and instance variables will be properties of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Функции и переменные экземпляра будут свойствами &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7b97dbb27777de72af8d9af9dd816e007cb47e" translate="yes" xml:space="preserve">
          <source>Here is a simpler example.  I'm using a few third party libraries that expect a &quot;Position&quot; object exposing latitude and longitude, but via different object properties.  I didn't want to hack the vendor code, so I adjusted the &quot;Position&quot; objects I was passing around.</source>
          <target state="translated">Вот более простой пример.Я использую несколько сторонних библиотек,которые ожидают,что объект &quot;Position&quot; выставит широту и долготу,но с помощью различных свойств объекта.Я не хотел взламывать код производителя,поэтому настроил передаваемые объекты &quot;Position&quot;.</target>
        </trans-unit>
        <trans-unit id="ae278ffeba6cafa1c3d2a70eeb6622299cb946ec" translate="yes" xml:space="preserve">
          <source>Here is a summary of when to use each:</source>
          <target state="translated">Вот краткое описание того,когда использовать каждый из них:</target>
        </trans-unit>
        <trans-unit id="c9a8b09d58f2e8e0771d8f78424d27f226d92eae" translate="yes" xml:space="preserve">
          <source>Here is some broilerplate code I've come up with as a code-template for object factory in AngularjS.  I've used a Car/CarFactory as an example to illustrate.  Makes for simple implementation code in the controller.</source>
          <target state="translated">Вот код бройлера,который я придумал как код-шаблон для фабрики объектов в AngularjS.В качестве примера я использовал CarCarFactory.Делает код простой реализации в контроллере.</target>
        </trans-unit>
        <trans-unit id="489ba797946b9923375b0c16c73874f3a39fb591" translate="yes" xml:space="preserve">
          <source>Here you&amp;rsquo;ll notice we&amp;rsquo;re not attaching those variables/function to &amp;lsquo;service&amp;rsquo;. We&amp;rsquo;re simply creating them in order to either use or modify them later.</source>
          <target state="translated">Здесь вы заметите, что мы не привязываем эти переменные / функцию к 'service'. Мы просто создаем их, чтобы потом использовать или модифицировать их.</target>
        </trans-unit>
        <trans-unit id="00a6aa13d323a6c412ee902d5b3d4d2d1ab4fe03" translate="yes" xml:space="preserve">
          <source>Here's a great further explanation by Misko:</source>
          <target state="translated">Вот отличное дальнейшее объяснение от Мишко:</target>
        </trans-unit>
        <trans-unit id="da5246469f32f79cb4f5e21f982157b5bf8fb944" translate="yes" xml:space="preserve">
          <source>Here's the article this image is from:</source>
          <target state="translated">Вот статья,из которой это изображение:</target>
        </trans-unit>
        <trans-unit id="850ac93122b4715c223580cbbd975d246cb16f45" translate="yes" xml:space="preserve">
          <source>Hope this has cleared up your understanding about &lt;strong&gt;Factory, Service and Provider&lt;/strong&gt;.</source>
          <target state="translated">Надеюсь, что это прояснило ваше понимание о &lt;strong&gt;фабрике, обслуживании и поставщике&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c040a989c90c935f04c9d9df515887605a02c08" translate="yes" xml:space="preserve">
          <source>How AngularJS instantiates particular components (simplified):</source>
          <target state="translated">Как AngularJS конкретизирует отдельные компоненты (упрощенно):</target>
        </trans-unit>
        <trans-unit id="c385f140fdcc5112262dbad26d8a3223347e8d51" translate="yes" xml:space="preserve">
          <source>I am trying to keep it simple. It's all about basic JavaScript concept.</source>
          <target state="translated">Я пытаюсь все упростить.Все дело в базовой концепции JavaScript.</target>
        </trans-unit>
        <trans-unit id="29ca2a8a57db27d862d4085e8c93784f8e59cb96" translate="yes" xml:space="preserve">
          <source>I came across this video which explains clearly about factory, service and provider methodologies for developing AngularJS Custom Services:</source>
          <target state="translated">Я наткнулся на это видео,которое четко объясняет о заводских,сервисных и провайдерских методологиях для разработки AngularJS Custom Services:</target>
        </trans-unit>
        <trans-unit id="37a6f10678b28516c544ad2d07c57f10ba034f15" translate="yes" xml:space="preserve">
          <source>I know a lot of excellent answer but I have to share my experience of using</source>
          <target state="translated">Я знаю много отличных ответов,но я должен поделиться своим опытом использования</target>
        </trans-unit>
        <trans-unit id="9310dd05ba382096e00103255eac7688e44ef73b" translate="yes" xml:space="preserve">
          <source>I noticed something interesting when playing around with providers.</source>
          <target state="translated">Я заметил кое-что интересное,когда играл с провайдерами.</target>
        </trans-unit>
        <trans-unit id="86c3d8da7c12380d33b628011f4dc967a20694c5" translate="yes" xml:space="preserve">
          <source>I still refer to them as &amp;ldquo;services&amp;rdquo; when I&amp;rsquo;m talking about injecting
  them as dependencies, though.</source>
          <target state="translated">Однако я все еще называю их &amp;laquo;услугами&amp;raquo;, когда говорю о внедрении их как зависимостей.</target>
        </trans-unit>
        <trans-unit id="b0314451a42f81ae46c88a72d5644b737ddc515b" translate="yes" xml:space="preserve">
          <source>If you want to use in angular module config function should created as &lt;strong&gt;provider&lt;/strong&gt;</source>
          <target state="translated">Если вы хотите использовать в модуле конфигурации угловой модуль должен быть создан в качестве &lt;strong&gt;поставщика&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="760bfbfabac6439646276d21d21c1e88b0f1b52a" translate="yes" xml:space="preserve">
          <source>In the constructor function we can use 'this' keyword for adding properties/methods to the service object.
example:</source>
          <target state="translated">В функции конструктора можно использовать ключевое слово 'this' для добавления свойств-методов к объекту обслуживания.пример:</target>
        </trans-unit>
        <trans-unit id="c5401a20db45adfe8456a9fe2493978105e9f5da" translate="yes" xml:space="preserve">
          <source>In the controller above we&amp;rsquo;re injecting in the &amp;lsquo;myFactory&amp;rsquo; service. We then set properties on our $scope object with data from &amp;lsquo;myFactory&amp;rsquo;. The only tricky code above is if you&amp;rsquo;ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You&amp;rsquo;ll notice our controller is very &amp;lsquo;thin&amp;rsquo; (This is a good coding practise). All of our logic and persistent data is located in our service, not in our controller.</source>
          <target state="translated">В вышеприведенном контроллере мы вводим в службу myFactory. Затем мы устанавливаем свойства нашего объекта $ scope с данными из myFactory. Единственный сложный код выше, если вы никогда не имели дело с обещаниями раньше. Поскольку callItunes возвращает обещание, мы можем использовать метод .then () и устанавливать $ scope.data.artistData только после того, как наше обещание будет выполнено с данными iTunes. Вы заметите, что наш контроллер очень &amp;laquo;тонкий&amp;raquo; (это хорошая практика кодирования). Вся наша логика и постоянные данные находятся в нашем сервисе, а не в нашем контроллере.</target>
        </trans-unit>
        <trans-unit id="ad7c151fc09de45e372af1a2de7be6c6b7781661" translate="yes" xml:space="preserve">
          <source>In the service, we create function names as property with &lt;em&gt;this&lt;/em&gt; object.</source>
          <target state="translated">В сервисе мы создаем имена функций как свойство &lt;em&gt;этого&lt;/em&gt; объекта.</target>
        </trans-unit>
        <trans-unit id="ca27a70fdef565576b6c87e2f47e6b4dd70d0118" translate="yes" xml:space="preserve">
          <source>In this case the injector simply returns the value as is. But what if you want to compute the value? Then use a factory</source>
          <target state="translated">В этом случае инжектор просто возвращает значение как есть.Но что,если вы хотите вычислить значение? Тогда используйте завод</target>
        </trans-unit>
        <trans-unit id="ce56ab93a5137d82e8def783797ed2029027acad" translate="yes" xml:space="preserve">
          <source>It can be just a collection of functions like a class. Hence, it can be instantiated in different controllers when you are injecting it inside your controller/factory/directive functions. It is instantiated only once per app.</source>
          <target state="translated">Это может быть просто набор функций,как класс.Следовательно,она может быть инстанциирована в различных контроллерах,когда вы впрыскиваете ее в свои контроллер-радирективные функции.Он инстанцируется только один раз на приложение.</target>
        </trans-unit>
        <trans-unit id="5b20c360213ae1af905212996e857c3ffcf8c5ac" translate="yes" xml:space="preserve">
          <source>It works like using a combination of &lt;em&gt;service&lt;/em&gt; and &lt;em&gt;provider&lt;/em&gt;, by passing to provider a function that has properties declared using the &lt;em&gt;this&lt;/em&gt; keyword, which can be used from the &lt;code&gt;app.config&lt;/code&gt;.</source>
          <target state="translated">Это работает как использование комбинации &lt;em&gt;службы&lt;/em&gt; и &lt;em&gt;провайдера&lt;/em&gt; , передавая провайдеру функцию, свойства которой объявлены с использованием ключевого слова &lt;em&gt;this&lt;/em&gt; , которое можно использовать из &lt;code&gt;app.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68eb0b5a5293d5d11d5a247852531e63d5c542a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use the factory in our application as we can simply inject it where we need it at run-time.</source>
          <target state="translated">В нашем приложении легко использовать фабрику, поскольку мы можем просто внедрить ее туда, где она нам нужна во время выполнения.</target>
        </trans-unit>
        <trans-unit id="5e6ceae9d10cdf11f4c911a2da17d4ac57381842" translate="yes" xml:space="preserve">
          <source>It's the another way, we can register a service. The only difference is the way AngularJS tries to instantiate the service object. This time angular uses 'new' keyword and call the constructor function something like below.</source>
          <target state="translated">Это другой способ,мы можем зарегистрировать услугу.Единственное отличие заключается в том,как AngularJS пытается инстанцировать объект сервиса.В этот раз Angular использует ключевое слово 'new' и вызывает функцию конструктора,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="f8bf660b8496971437b76589be4961ef8c377635" translate="yes" xml:space="preserve">
          <source>JS Fiddle Demo</source>
          <target state="translated">JS Демонстрация скрипки</target>
        </trans-unit>
        <trans-unit id="0e399439c408eca064ae4becd7265accff216db8" translate="yes" xml:space="preserve">
          <source>Just to clarify things, from the AngularJS source, you can see a service just calls the factory function which in turn calls the provider function:</source>
          <target state="translated">Просто чтобы прояснить ситуацию,из источника AngularJS можно увидеть услугу,которая просто вызывает заводскую функцию,которая,в свою очередь,вызывает функцию провайдера:</target>
        </trans-unit>
        <trans-unit id="7de5f61ab2c0b942cc33db2f46d0c4b470d32a4e" translate="yes" xml:space="preserve">
          <source>Let's again have a look at the Syntax first:</source>
          <target state="translated">Давайте сначала еще раз взглянем на синтаксис:</target>
        </trans-unit>
        <trans-unit id="0fec230ed8200309bfc8c6866e454394b38359c7" translate="yes" xml:space="preserve">
          <source>Let's discuss the three ways of handling business logic in AngularJS in a simple way: (&lt;strong&gt;Inspired by Yaakov's Coursera AngularJS course&lt;/strong&gt;)</source>
          <target state="translated">Давайте обсудим три способа простой обработки бизнес-логики в AngularJS: ( &lt;strong&gt;Вдохновленный курсом Яакова Coursera AngularJS&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="fa350ad45511dbe39a4d035e7a10563f5896422d" translate="yes" xml:space="preserve">
          <source>Lets start with the difference between Service and factory:</source>
          <target state="translated">Начнем с разницы между Сервисом и заводом:</target>
        </trans-unit>
        <trans-unit id="778a430f691a6018fcf57447a71b7c8cd2109696" translate="yes" xml:space="preserve">
          <source>Like I mentioned before, once you really understand what &amp;lsquo;new&amp;rsquo; does, Services are almost identical to factories in AngularJS.</source>
          <target state="translated">Как я уже упоминал ранее, когда вы действительно понимаете, что делает &amp;laquo;новое&amp;raquo;, Сервисы практически идентичны фабрикам в AngularJS.</target>
        </trans-unit>
        <trans-unit id="25c6b479772ad22656b96f68f104741b92338f0a" translate="yes" xml:space="preserve">
          <source>Little late to the party.  But I thought this is more helpful for who would like to learn (or have clarity) on developing Angular JS Custom Services using factory, service and provider methodologies.</source>
          <target state="translated">Немного опоздал на вечеринку.Но я подумал,что это более полезно для тех,кто хотел бы узнать (или иметь ясность)о разработке Angular JS Custom Services с использованием заводских,сервисных и провайдерских методологий.</target>
        </trans-unit>
        <trans-unit id="4bd48a3b50a9f231823114ba704dfccf0bd973da" translate="yes" xml:space="preserve">
          <source>My clarification on this matter:</source>
          <target state="translated">Мое разъяснение по этому вопросу:</target>
        </trans-unit>
        <trans-unit id="fbf210c3ae8711990847a3d950af4119f3209adb" translate="yes" xml:space="preserve">
          <source>My understanding is very simple below.</source>
          <target state="translated">Мое понимание ниже очень простое.</target>
        </trans-unit>
        <trans-unit id="69f7e11da9f849693995d92816d880bd6fdc64e1" translate="yes" xml:space="preserve">
          <source>Not only produces singleton, but customizable services.</source>
          <target state="translated">Не только производит одноэлементные,но и настраиваемые услуги.</target>
        </trans-unit>
        <trans-unit id="982fb0ca939387b6254256e3ab0dfb3a7cc84d6c" translate="yes" xml:space="preserve">
          <source>Not only we can create a factory that's dynamically configurable, but at the time of using the factory, with the provider method, we could custom configure the factory just once at the bootstrapping of our entire application.</source>
          <target state="translated">Мы не только можем создать фабрику,которая динамически настраивается,но и во время использования фабрики,с помощью метода провайдера,мы можем настроить фабрику всего один раз при загрузке всего нашего приложения.</target>
        </trans-unit>
        <trans-unit id="672bd2d09c7ed72a3eac6c27958d21691133d0dc" translate="yes" xml:space="preserve">
          <source>Note that it is possible to return a object (in which case it will function similar to a &lt;em&gt;service&lt;/em&gt;) or a function (that will be saved in the variable as a callback function).</source>
          <target state="translated">Обратите внимание, что можно вернуть объект (в этом случае он будет функционировать аналогично &lt;em&gt;службе&lt;/em&gt; ) или функцию (которая будет сохранена в переменной как функция обратного вызова).</target>
        </trans-unit>
        <trans-unit id="5b1a8bd7c0a880872f4d9c7b867ae61242c0dfa0" translate="yes" xml:space="preserve">
          <source>Now having this knowledge of what the &amp;lsquo;new&amp;rsquo; keyword really does in JavaScript, creating a Service in AngularJS should be easier to understand.</source>
          <target state="translated">Теперь, имея представление о том, что на самом деле делает ключевое слово &amp;laquo;new&amp;raquo; в JavaScript, создание службы в AngularJS должно быть проще для понимания.</target>
        </trans-unit>
        <trans-unit id="d741df1b012ea25d838dc2c21bf70522da5f8512" translate="yes" xml:space="preserve">
          <source>Now just like in our factory and Service, setArtist, getArtist, and callItunes will be available in whichever controller we pass myProvider into. Here&amp;rsquo;s the myProvider controller (which is almost exactly the same as our factory/Service controller).</source>
          <target state="translated">Теперь, как и на нашей фабрике, Service, setArtist, getArtist и callItunes будут доступны в любом контроллере, в который мы передаем myProvider. Вот контроллер myProvider (который почти такой же, как наш заводской / сервисный контроллер).</target>
        </trans-unit>
        <trans-unit id="698af625bfcb4e8f8fcb2e7bcb26d8b5f98e4503" translate="yes" xml:space="preserve">
          <source>Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here&amp;rsquo;s the myService controller (which is almost exactly the same as our factory controller).</source>
          <target state="translated">Теперь, как и на нашей фабрике, setArtist, getArtist и callItunes будут доступны в любом контроллере, в который мы передаем myService. Вот контроллер myService (который почти такой же, как наш заводской контроллер).</target>
        </trans-unit>
        <trans-unit id="33179f320db64f96208e8896db6147d2739c655b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a method onto our Person&amp;rsquo;s prototype so it will be available on every instance of our Person &amp;lsquo;class&amp;rsquo;.</source>
          <target state="translated">Теперь давайте добавим метод в прототип нашего Person, чтобы он был доступен для каждого экземпляра нашего класса Person.</target>
        </trans-unit>
        <trans-unit id="4e56b2bbd2bcd8c15e0879964355623ffab1f7bb" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add some &amp;lsquo;private&amp;rsquo; variables to our callback function. These won&amp;rsquo;t be directly accessible from the controller, but we will eventually set up some getter/setter methods on &amp;lsquo;service&amp;rsquo; to be able to alter these &amp;lsquo;private&amp;rsquo; variables when needed.</source>
          <target state="translated">Теперь давайте добавим некоторые &amp;laquo;закрытые&amp;raquo; переменные в нашу функцию обратного вызова. Они не будут напрямую доступны из контроллера, но мы в конечном итоге настроим некоторые методы получения / установки для &amp;laquo;службы&amp;raquo;, чтобы иметь возможность изменять эти &amp;laquo;частные&amp;raquo; переменные при необходимости.</target>
        </trans-unit>
        <trans-unit id="b83d5faac981eb0e79df8c1e9fbac8b90b76a95f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what actually is happening when you use the &amp;lsquo;new&amp;rsquo; keyword in JavaScript. First thing you should notice is that after using &amp;lsquo;new&amp;rsquo; in our example, we&amp;rsquo;re able to call a method (sayName) on &amp;lsquo;tyler&amp;rsquo; just as if it were an object - that&amp;rsquo;s because it is. 
So first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says &amp;ldquo;OK, I&amp;rsquo;m going to look on the &amp;lsquo;tyler&amp;rsquo; object we just created, locate the sayName function, then call it. Wait a minute, I don&amp;rsquo;t see it here - all I see is name and age, let me check the prototype. Yup, looks like it&amp;rsquo;s on the prototype, let me call it.&amp;rdquo;.</source>
          <target state="translated">Теперь давайте посмотрим, что на самом деле происходит, когда вы используете ключевое слово &amp;laquo;new&amp;raquo; в JavaScript. Первое, на что вы должны обратить внимание, это то, что после использования &amp;laquo;new&amp;raquo; в нашем примере мы можем вызвать метод (sayName) для &amp;laquo;tyler&amp;raquo; так же, как если бы это был объект - это потому, что он есть. Итак, во-первых, мы знаем, что наш конструктор Person возвращает объект, видим ли мы это в коде или нет. Во-вторых, мы знаем, что поскольку наша функция sayName расположена в прототипе, а не непосредственно в экземпляре Person, объект, который возвращает функция Person, должен делегировать своему прототипу при неудачных поисках. Проще говоря, когда мы вызываем tyler.sayName (), интерпретатор говорит: &amp;laquo;Хорошо, я собираюсь посмотреть на только что созданный объект&amp;laquo; tyler &amp;raquo;, найти функцию sayName и затем вызвать ее. Подожди, я не вижу этого здесь - все, что я вижу, это имя и возраст, позволь мне проверить прототип. Да, похоже, что это на прототипе, позвольте мне назвать это &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fb6577ce21f8b4d96fd20a371037e7c8ed7c6760" translate="yes" xml:space="preserve">
          <source>Now our factory is complete. We are now able to inject &amp;lsquo;myFactory&amp;rsquo; into any controller and we&amp;rsquo;ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes).</source>
          <target state="translated">Теперь наша фабрика завершена. Теперь мы можем внедрить 'myFactory' в любой контроллер, и тогда мы сможем вызывать наши методы, которые мы прикрепили к нашему сервисному объекту (setArtist, getArtist и callItunes).</target>
        </trans-unit>
        <trans-unit id="2dd7216c3d216047524da229ce33e07f854c5b20" translate="yes" xml:space="preserve">
          <source>Now that our helper/private variables and function are in place, let&amp;rsquo;s add some properties to the &amp;lsquo;service&amp;rsquo; object. Whatever we put on &amp;lsquo;service&amp;rsquo; can be directly used inside whichever controller we pass &amp;lsquo;myFactory&amp;rsquo; into.</source>
          <target state="translated">Теперь, когда наши вспомогательные / закрытые переменные и функции на месте, давайте добавим некоторые свойства к объекту 'service'. Все, что мы ставим на &amp;laquo;сервис&amp;raquo;, можно напрямую использовать внутри любого контроллера, в который мы передаем &amp;laquo;myFactory&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="39ddb2f22b7fced081ba8ea176229ca0ac8d8309" translate="yes" xml:space="preserve">
          <source>Now that we have our Person constructor function and our sayName function on its prototype, let&amp;rsquo;s actually create an instance of Person then call the sayName function.</source>
          <target state="translated">Теперь, когда у нас есть функция конструктора Person и наша функция sayName в ее прототипе, давайте создадим экземпляр Person, а затем вызовем функцию sayName.</target>
        </trans-unit>
        <trans-unit id="ec51346deab58cf2c25c7d6a3cb4af41dc640f10" translate="yes" xml:space="preserve">
          <source>Now the full Provider code looks like this</source>
          <target state="translated">Теперь полный код провайдера выглядит так</target>
        </trans-unit>
        <trans-unit id="a8c5c01dc8cb0c4ad9e61b2d0177736881556303" translate="yes" xml:space="preserve">
          <source>Now using the above two in the controller:</source>
          <target state="translated">Теперь используйте два вышеперечисленных в контроллере:</target>
        </trans-unit>
        <trans-unit id="554f3e5b70223d89fd87ed55eb8c7fa0aea6edc3" translate="yes" xml:space="preserve">
          <source>Now whatever properties we attach to &amp;lsquo;service&amp;rsquo; will be available to us when we pass &amp;lsquo;myFactory&amp;rsquo; into our controller.</source>
          <target state="translated">Теперь любые свойства, которые мы прикрепляем к &amp;laquo;сервису&amp;raquo;, будут нам доступны, когда мы передадим &amp;laquo;myFactory&amp;raquo; в наш контроллер.</target>
        </trans-unit>
        <trans-unit id="8db4bcee9cc90896dbc924721630384540a94c50" translate="yes" xml:space="preserve">
          <source>Now you can see how &amp;lsquo;thingFromConfig&amp;rsquo; is as empty string in our provider, but when that shows up in the DOM, it will be &amp;lsquo;This sentence was set&amp;hellip;&amp;rsquo;.</source>
          <target state="translated">Теперь вы можете видеть, что &amp;laquo;thingFromConfig&amp;raquo; - это пустая строка в нашем провайдере, но когда она появится в DOM, это будет &amp;laquo;Это предложение было установлено&amp;hellip;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ec62b54ee6ce720c21f33325f4f0a65c82d69fdb" translate="yes" xml:space="preserve">
          <source>Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance&amp;rsquo;s name.</source>
          <target state="translated">Теперь, поскольку мы поместили функцию sayName в прототип, каждый экземпляр Person сможет вызывать функцию sayName, чтобы предупредить имя этого экземпляра.</target>
        </trans-unit>
        <trans-unit id="11f40cd81d972474ebbd1638f071afb14e360695" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll attach all of our methods that will be available in our controller to &amp;lsquo;this&amp;rsquo;.</source>
          <target state="translated">Теперь мы прикрепим все наши методы, которые будут доступны в нашем контроллере, к &amp;laquo;this&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f06e2a3c653d42f7111fe26d1c705865f3c86c73" translate="yes" xml:space="preserve">
          <source>Only provider will be available in config phase of angular, while
  service &amp;amp; factory are not.</source>
          <target state="translated">Только поставщик будет доступен в фазе конфигурации angular, а сервис и фабрика - нет.</target>
        </trans-unit>
        <trans-unit id="dfdb4f5263d92c8b24c27c443665ded6f3f279be" translate="yes" xml:space="preserve">
          <source>Perhaps the biggest thing to know when dealing with creating a Service is that that it&amp;rsquo;s instantiated with the &amp;lsquo;new&amp;rsquo; keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren&amp;rsquo;t too familiar with what the &amp;lsquo;new&amp;rsquo; keyword actually does, let&amp;rsquo;s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service.</source>
          <target state="translated">Возможно, самая важная вещь, которую нужно знать при создании Сервиса, это то, что он создается с помощью ключевого слова &amp;laquo;new&amp;raquo;. Для вас, гуру JavaScript, это должно дать вам подсказку о природе кода. Для тех из вас, кто имеет ограниченный опыт работы с JavaScript или тех, кто не слишком знаком с тем, что на самом деле делает ключевое слово &amp;laquo;new&amp;raquo;, давайте рассмотрим некоторые основы JavaScript, которые в конечном итоге помогут нам понять природу Сервиса.</target>
        </trans-unit>
        <trans-unit id="7ceee3f3615a2bbe4ce0ac5a269a311e4821daf4" translate="yes" xml:space="preserve">
          <source>Provider</source>
          <target state="translated">Provider</target>
        </trans-unit>
        <trans-unit id="53d2419e2fad27c745ab7837fb34c5b4cb3b5535" translate="yes" xml:space="preserve">
          <source>Provider is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">Поставщик-самый сложный тип рецепта.Он вам не нужен,если только вы не собираете многоразовый код,который нуждается в глобальной настройке.</target>
        </trans-unit>
        <trans-unit id="d3f6c702cb3e12640d8a58f3b97ac66d45f4b833" translate="yes" xml:space="preserve">
          <source>Provider is the most flexible method of creating services in Angular.</source>
          <target state="translated">Провайдер является наиболее гибким методом создания сервисов на языке Angular.</target>
        </trans-unit>
        <trans-unit id="955559753eafb5cc8b4506201a86bbe417ec9d05" translate="yes" xml:space="preserve">
          <source>Provider() function is the another way for creating services. Let we are interested to create a service which just display some greeting message to the user. But we also want to provide a functionality such that user can set their own greeting message. In technical terms we want to create configurable services. How can we do this ? There must be a way, so that app could pass their custom greeting messages and Angularjs would make it available to factory/constructor function which create our services instance.
In such a case provider() function do the job. using provider() function we can create configurable services.</source>
          <target state="translated">Функция Provider()-это другой способ создания сервисов.Пусть нам будет интересно создать сервис,который просто выводит на экран приветственное сообщение пользователю.Но мы также хотим предоставить функциональность,позволяющую пользователю устанавливать свое собственное приветствие.С технической точки зрения мы хотим создать настраиваемые службы.Как мы можем это сделать? Должен быть способ,чтобы приложение могло передавать свои пользовательские приветственные сообщения,а Angularjs сделает его доступным для функции factoryconstructor,которая создает наш экземпляр сервиса.В таком случае функция provider()выполняет эту работу.Используя функцию provider()мы можем создавать настраиваемые сервисы.</target>
        </trans-unit>
        <trans-unit id="87b7c08baed1c8e93db95b79bcdca55b631dd7bb" translate="yes" xml:space="preserve">
          <source>Providers</source>
          <target state="translated">Providers</target>
        </trans-unit>
        <trans-unit id="2d56985193e8bf2d6ab8849ef7c57e0e5dde4a2b" translate="yes" xml:space="preserve">
          <source>Providers allow you to configure the provider &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; AngularJS calls the &lt;code&gt;$get&lt;/code&gt; method to get the injectible.</source>
          <target state="translated">Провайдеры позволяют вам настроить провайдера &lt;strong&gt;&lt;em&gt;до того, как&lt;/em&gt;&lt;/strong&gt; AngularJS вызовет метод &lt;code&gt;$get&lt;/code&gt; чтобы получить инъекцию.</target>
        </trans-unit>
        <trans-unit id="fa42b9d0b7dbcb3ea427607354fff8602303c4c8" translate="yes" xml:space="preserve">
          <source>Providers have the advantage that they can be configured during the module configuration phase.</source>
          <target state="translated">Преимущество поставщиков заключается в том,что они могут быть сконфигурированы на этапе конфигурации модуля.</target>
        </trans-unit>
        <trans-unit id="8d9b9399c4d6be5dbb075743c0ee3d595b3daf9b" translate="yes" xml:space="preserve">
          <source>Result: When declaring factoryName as an injectable argument you will be provided with &lt;strong&gt;the value that is returned by invoking the function reference passed to module.factory&lt;/strong&gt;.</source>
          <target state="translated">Результат: при объявлении factoryName в качестве вводимого аргумента вам будет предоставлено &lt;strong&gt;значение, возвращаемое путем вызова ссылки на функцию, переданной в module.factory&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8b8055b0f238e713bbe09a1f5142a3a9c4180d28" translate="yes" xml:space="preserve">
          <source>Result: When declaring providerName as an injectable argument &lt;strong&gt;you will be provided with&lt;/strong&gt;&lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt;. The constructor function is instantiated before the $get method is called - &lt;code&gt;ProviderFunction&lt;/code&gt; is  the function reference passed to module.provider.</source>
          <target state="translated">Результат: при объявлении providerName в качестве вводимого аргумента &lt;strong&gt;вам будет предоставлено&lt;/strong&gt; &lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt; . Функция конструктора создается перед вызовом метода $ get - &lt;code&gt;ProviderFunction&lt;/code&gt; - это ссылка на функцию, переданную в module.provider.</target>
        </trans-unit>
        <trans-unit id="c70fc6d0d8618584e9490ed45c73cb37b4246b1e" translate="yes" xml:space="preserve">
          <source>Result: When declaring serviceName as an injectable argument &lt;strong&gt;you will be provided with an instance of the function. In other words&lt;/strong&gt;&lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt;.</source>
          <target state="translated">Результат: при объявлении serviceName в качестве вводимого аргумента &lt;strong&gt;вам будет предоставлен экземпляр функции.&lt;/strong&gt; &lt;strong&gt;Другими словами,&lt;/strong&gt; &lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c830a908226f52c7631bae300c0e26abb3631d0" translate="yes" xml:space="preserve">
          <source>Sample Example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="381df071be6ca5ac8d6e5e18ab012360963bd4a9" translate="yes" xml:space="preserve">
          <source>Sample code for creating service using provide syntax:</source>
          <target state="translated">Пример кода для создания сервиса с использованием синтаксиса Provide:</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">Скажи,что так и есть:</target>
        </trans-unit>
        <trans-unit id="11dc1a4e11a2784e2b6de73a9022cddbb6721f42" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;the provider documentation&lt;/a&gt;.</source>
          <target state="translated">Смотрите &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;документацию поставщика&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f4ab1a2559d02916ca6b754d342e20711e3cfca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;here&lt;/a&gt; for the provided code.</source>
          <target state="translated">Смотрите &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;здесь&lt;/a&gt; для предоставленного кода.</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5030396a200088699db9b35f53a60b75ca0f61ed" translate="yes" xml:space="preserve">
          <source>Service Function:</source>
          <target state="translated">Сервисная функция:</target>
        </trans-unit>
        <trans-unit id="6210fa9c0a7b05e22abb7fcb5a13962309ea102d" translate="yes" xml:space="preserve">
          <source>Service initialization</source>
          <target state="translated">Инициализация услуги</target>
        </trans-unit>
        <trans-unit id="9d10e77416b918cf3662445c6e88c578fa4569c9" translate="yes" xml:space="preserve">
          <source>Service is an singleton object instance. Use services if you want to provide a singleton object for your code.</source>
          <target state="translated">Сервис-это однотонный экземпляр объекта.Используйте сервисы,если вы хотите предоставить одноэлементный объект для вашего кода.</target>
        </trans-unit>
        <trans-unit id="61835754249fef2e2b45059d3bbd0d0e5cdde58d" translate="yes" xml:space="preserve">
          <source>Service/Factory behavior is very similar, and some people will say
  that either one is fine. That&amp;rsquo;s somewhat true, but I find it easier to
  follow the advice of John Papa&amp;rsquo;s style guide and just stick with
  factories.**</source>
          <target state="translated">Поведение Service / Factory очень похоже, и некоторые люди скажут, что любой из них в порядке. Это несколько верно, но мне легче следовать советам руководства по стилю Джона Папы и просто придерживаться заводов. **</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="c1e289d3853bb8c7d8a915f54b7abf6bb6594091" translate="yes" xml:space="preserve">
          <source>Simply while looking at the services think about the array prototype. A service is a function which instantiates a new object using the 'new' keyword. You can add properties and functions to a service object by using the &lt;code&gt;this&lt;/code&gt; keyword. Unlike a factory, it doesn't return anything (it returns an object which contains methods/properties).</source>
          <target state="translated">Просто, глядя на сервисы, подумайте о прототипе массива. Служба - это функция, которая создает новый объект, используя ключевое слово &amp;laquo;new&amp;raquo;. Вы можете добавить свойства и функции к объекту службы, используя ключевое слово &lt;code&gt;this&lt;/code&gt; . В отличие от фабрики, он ничего не возвращает (он возвращает объект, который содержит методы / свойства).</target>
        </trans-unit>
        <trans-unit id="62854845263bf068dddccd96ecb184fb8ea7a590" translate="yes" xml:space="preserve">
          <source>Since the constructed service is an object, the methods inside it can refer to this when they&amp;rsquo;re called:</source>
          <target state="translated">Поскольку созданный сервис является объектом, методы внутри него могут ссылаться на него при вызове:</target>
        </trans-unit>
        <trans-unit id="155220d0a18e305b7ea66fb35c4da7270fc65257" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;factory&lt;/code&gt; is a function which is responsible for creating the value. Notice that the factory function can ask for other dependencies.</source>
          <target state="translated">Таким образом, &lt;code&gt;factory&lt;/code&gt; - это функция, которая отвечает за создание стоимости. Обратите внимание, что фабричная функция может запрашивать другие зависимости.</target>
        </trans-unit>
        <trans-unit id="4d857556fc3e68491091f75ba684105c6782e0e5" translate="yes" xml:space="preserve">
          <source>So all together the code for creating a Person constructor, adding a function to it&amp;rsquo;s prototype, creating a Person instance, and then calling the function on its prototype looks like this.</source>
          <target state="translated">Таким образом, весь код для создания конструктора Person, добавления функции к его прототипу, создания экземпляра Person и последующего вызова функции для его прототипа выглядит следующим образом.</target>
        </trans-unit>
        <trans-unit id="08c3828d081a8d7efafeefc62c0878e780b4e133" translate="yes" xml:space="preserve">
          <source>So basically in both cases you eventually get a providers $get set to your function you provided , but you can give anything extra than $get as you can originally provide in provider() for config block</source>
          <target state="translated">Так что в обоих случаях вы в конечном итоге получаете набор провайдеров $get для своей функции,которую вы предоставили,но вы можете дать что угодно,кроме $get,как вы можете первоначально предоставить в provider()для конфигурационного блока.</target>
        </trans-unit>
        <trans-unit id="27e3723bbf080ae2fb322bd7eb8909b1557894e4" translate="yes" xml:space="preserve">
          <source>So if there are three controller scope, let it be controllerA, controllerB and controllerC, all will share same service instance.</source>
          <target state="translated">Итак,если есть три области видимости контроллера,пусть это будут контроллерА,контроллерВ и контроллерС,то все они будут использовать один и тот же экземпляр службы.</target>
        </trans-unit>
        <trans-unit id="dd81d4d697436b2952af0ee10fd0dd2ca080a3d2" translate="yes" xml:space="preserve">
          <source>So master provider and injector and all will fall in place :) . And it gets interesting in Typescript when $get can be implemented in a provider by inheriting from IServiceProvider.</source>
          <target state="translated">Так что главный провайдер и инжектор и все встанут на свои места :).И становится интересно в Typescript,когда $get можно реализовать в провайдере,унаследовав от IServiceProvider.</target>
        </trans-unit>
        <trans-unit id="cb9d6754283c9f37208464bd5837389aa5b0ad15" translate="yes" xml:space="preserve">
          <source>So when Angular constructs your service with new MyService(), it&amp;rsquo;ll get that api object instead of the MyService instance.</source>
          <target state="translated">Поэтому, когда Angular создает ваш сервис с новым MyService (), он получает этот объект API вместо экземпляра MyService.</target>
        </trans-unit>
        <trans-unit id="c72cf4ede28e8dd19525b9079025b0772ccc130b" translate="yes" xml:space="preserve">
          <source>So why such complications, why can't we just use provider and forget everything else? It is supposed to help us write code easily and communicate better. And toungue-in-cheek reply would be, the more complex it gets the better selling a framework will be.</source>
          <target state="translated">Так почему же такие сложности,почему мы не можем просто воспользоваться провайдером и забыть обо всем остальном? Это должно помочь нам легко писать код и лучше общаться.И чем сложнее будет ответ,тем лучше будет продаваться фреймворк.</target>
        </trans-unit>
        <trans-unit id="d26ab8fdbfba98e5ec328de0fd5fd8b3ec1253e1" translate="yes" xml:space="preserve">
          <source>So, for the service, what becomes the AngularJS component is the object instance of the class which is represented by service declaration function. For the factory, it is the result returned from the factory declaration function. The factory may behave the same as the service:</source>
          <target state="translated">Таким образом,для сервиса то,что становится компонентом AngularJS,является экземпляром объекта класса,который представлен функцией объявления сервиса.Для завода это результат,возвращаемый функцией заводского объявления.Завод может вести себя так же,как и служба:</target>
        </trans-unit>
        <trans-unit id="e62f1055fa34e381a967d48cc84251a3806ed36c" translate="yes" xml:space="preserve">
          <source>Source Code: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</source>
          <target state="translated">Исходный код: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9924e31c2dd752407f7714733eb09ad7aaef9362" translate="yes" xml:space="preserve">
          <source>Summary from &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular docs&lt;/a&gt;:</source>
          <target state="translated">Резюме из &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;угловых документов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="8a29d9bf1a1e71cf529fe97431e96a86eaf41f44" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</source>
          <target state="translated">Синтаксис: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194b446e2c1fb5fc04741acabf05acbc4af47aec" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</source>
          <target state="translated">Синтаксис: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92324397a45dd6d31034d314cd7fc546cabef2b8" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</source>
          <target state="translated">Синтаксис: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84dd638523da34b8795dead37b56820cfba7075e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$get&lt;/code&gt; is a function that is directly attached to the provider instance. That function is a &lt;strong&gt;factory&lt;/strong&gt; function. In other words, it's just like the one that we use to &lt;em&gt;provide&lt;/em&gt; to the &lt;code&gt;.factory&lt;/code&gt; method. In that function, we create our own service. &lt;strong&gt;This &lt;code&gt;$get&lt;/code&gt; property, that's a function, is what makes the provider a provider&lt;/strong&gt;. &lt;em&gt;AngularJS expects the provider to have a $get property whose value is a function that Angular will treat as a factory function.&lt;/em&gt; But what makes this whole provider setup very special, is the fact that we can provide some &lt;code&gt;config&lt;/code&gt; object inside the service provider, and that usually comes with defaults that we can later overwrite in the step, where we can configure the entire application.</source>
          <target state="translated">&lt;code&gt;$get&lt;/code&gt; - это функция, которая напрямую связана с экземпляром провайдера. Эта функция является &lt;strong&gt;заводской&lt;/strong&gt; функцией. Другими словами, он похож на тот, который мы используем для &lt;em&gt;предоставления&lt;/em&gt; метода &lt;code&gt;.factory&lt;/code&gt; . В этой функции мы создаем наш собственный сервис. &lt;strong&gt;Это свойство &lt;code&gt;$get&lt;/code&gt; , это функция, которая делает провайдера провайдером&lt;/strong&gt; . &lt;em&gt;AngularJS ожидает, что у провайдера будет свойство $ get, значением которого является функция, которую Angular будет рассматривать как фабричную функцию.&lt;/em&gt; Но что делает всю эту настройку провайдера очень особенной, так это то, что мы можем предоставить некоторый объект &lt;code&gt;config&lt;/code&gt; внутри поставщика услуг, и это обычно идет со значениями по умолчанию, которые мы можем позже перезаписать на шаге, где мы можем сконфигурировать все приложение.</target>
        </trans-unit>
        <trans-unit id="7b6548f429604df735e1a44693ef40e85b8e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.service()&lt;/code&gt; method is a &lt;strong&gt;factory&lt;/strong&gt; that always produces the same type of service, which is a singleton, and without any easy way to configure it's behavior. That &lt;code&gt;.service()&lt;/code&gt; method is usually used as a shortcut for something that doesn't require any configuration whatsoever.</source>
          <target state="translated">Метод &lt;code&gt;.service()&lt;/code&gt; - это &lt;strong&gt;фабрика,&lt;/strong&gt; которая всегда производит один и тот же тип сервиса, который является одноэлементным, и без какого-либо простого способа настроить его поведение. Этот &lt;code&gt;.service()&lt;/code&gt; обычно используется как ярлык для чего-то, что не требует какой-либо настройки.</target>
        </trans-unit>
        <trans-unit id="a49ec85e38178c060ff6013773473704cdd2007a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, and &lt;code&gt;provider&lt;/code&gt; methods are all providers. They teach the Injector how to instantiate the Services.</source>
          <target state="translated">Методы &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;factory&lt;/code&gt; , &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;constant&lt;/code&gt; и &lt;code&gt;provider&lt;/code&gt; являются провайдерами. Они учат Инжектора, как создавать Услуги.</target>
        </trans-unit>
        <trans-unit id="025bc59091687d744c1dd87ac4446f1a3ea99b14" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Constant recipe&lt;/strong&gt; is just like the Value recipe except it allows you to define services that are available in the &lt;strong&gt;config&lt;/strong&gt; phase. Sooner than services created using the Value recipe. Unlike Values, they cannot be decorated using &lt;code&gt;decorator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Рецепт Constant&lt;/strong&gt; точно так же, как и рецепт Value, за исключением того, что он позволяет вам определять сервисы, доступные на этапе &lt;strong&gt;конфигурации&lt;/strong&gt; . Раньше, чем сервисы, созданные с использованием рецепта Value. В отличие от значений, их нельзя декорировать с помощью &lt;code&gt;decorator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf81a424905d80f0814719f3aa86cbdefa28b91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Factory recipe&lt;/strong&gt; gives the Injector a factory function that it calls when it needs to instantiate the service. When called, the &lt;strong&gt;factory function&lt;/strong&gt; creates and returns the service instance. The dependencies of the Service are injected as the functions' arguments. So using this recipe adds the following abilities:</source>
          <target state="translated">&lt;strong&gt;Фабричный рецепт&lt;/strong&gt; дает Injector заводскую функцию, которую он вызывает, когда ему нужно создать экземпляр службы. При вызове &lt;strong&gt;фабричная функция&lt;/strong&gt; создает и возвращает экземпляр службы. Зависимости Сервиса вводятся как аргументы функций. Поэтому использование этого рецепта добавляет следующие способности:</target>
        </trans-unit>
        <trans-unit id="b86e7115a91b56187a5fe0143ed257a341995e64" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider recipe&lt;/strong&gt; is usually &lt;strong&gt;overkill&lt;/strong&gt;. It adds one more layer of indirection by allowing you to configure the creation of the factory.</source>
          <target state="translated">&lt;strong&gt;Рецепт провайдера,&lt;/strong&gt; как правило, &lt;strong&gt;излишним&lt;/strong&gt; . Он добавляет еще один уровень косвенности, позволяя настроить создание фабрики.</target>
        </trans-unit>
        <trans-unit id="cad58aeb7205a606c508335ce156288e7da6f573" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider&lt;/strong&gt; recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">Рецепт &lt;strong&gt;провайдера&lt;/strong&gt; является основным типом рецепта, а все остальные - просто синтаксический сахар.</target>
        </trans-unit>
        <trans-unit id="17bb816a792f8c3e9c45f68c21dac545bc7fc6e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Service recipe&lt;/strong&gt; is almost the same as the Factory recipe, but here the Injector invokes a &lt;strong&gt;constructor&lt;/strong&gt; with the new operator instead of a factory function.</source>
          <target state="translated">&lt;strong&gt;Рецепт Сервиса&lt;/strong&gt; почти совпадает с рецептом Фабрики, но здесь Инжектор вызывает &lt;strong&gt;конструктор&lt;/strong&gt; с новым оператором вместо фабричной функции.</target>
        </trans-unit>
        <trans-unit id="0f6f2e7cab552a54a9d8929a09e98e95cc4cfb9f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Value Recipe&lt;/strong&gt; is the simplest case, where you instantiate the Service yourself and provide the &lt;strong&gt;instantiated value&lt;/strong&gt; to the injector.</source>
          <target state="translated">&lt;strong&gt;Рецепт значения&lt;/strong&gt; - это простейший случай, когда вы сами создаете экземпляр Сервиса и предоставляете &lt;strong&gt;созданное значение&lt;/strong&gt; инжектору.</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">Рецепт поставщика является основным типом рецепта,а все остальные просто синтаксический сахар на нем.</target>
        </trans-unit>
        <trans-unit id="c20c67a4543a337b871e95eaa0aa2230110f9cde" translate="yes" xml:space="preserve">
          <source>The biggest thing to remember about Providers is that they&amp;rsquo;re the only service that you can pass into the app.config portion of your application. This is of huge importance if you&amp;rsquo;re needing to alter some portion of your service object before it&amp;rsquo;s available everywhere else in your application. Although very similar to Services/Factories, there are a few differences which we&amp;rsquo;ll discuss.</source>
          <target state="translated">Самое важное, что следует помнить о провайдерах, это то, что они являются единственной службой, которую вы можете передать в часть app.config вашего приложения. Это имеет огромное значение, если вам нужно изменить какую-то часть вашего сервисного объекта, прежде чем он станет доступен везде в вашем приложении. Хотя они очень похожи на Услуги / Фабрики, есть несколько различий, которые мы обсудим.</target>
        </trans-unit>
        <trans-unit id="a2a3557bc4924e63f2d2ce284fc4ba7adf38dc02" translate="yes" xml:space="preserve">
          <source>The biggest thing to understand when creating a Service is knowing that Services are instantiated with the &amp;lsquo;new&amp;rsquo; keyword. Combining that knowledge with our examples above, you should now recognize that you&amp;rsquo;ll be attaching your properties and methods directly to &amp;lsquo;this&amp;rsquo; which will then be returned from the Service itself. Let&amp;rsquo;s take a look at this in action.</source>
          <target state="translated">Самая важная вещь, которую нужно понять при создании Сервиса, это знать, что Сервисы создаются с ключевым словом &amp;laquo;new&amp;raquo;. Объединяя эти знания с нашими примерами выше, вы должны теперь признать, что вы будете привязывать свои свойства и методы непосредственно к &amp;laquo;this&amp;raquo;, которое затем будет возвращено из самой Службы. Давайте посмотрим на это в действии.</target>
        </trans-unit>
        <trans-unit id="ee97831b61259806e326d0d7c322a8ac829781ee" translate="yes" xml:space="preserve">
          <source>The code for &quot;factory&quot; based custom service is as follows (which goes with both sync and async versions along with calling http service):</source>
          <target state="translated">Код для &quot;заводского&quot; пользовательского сервиса выглядит следующим образом (который идет как с синхронизацией,так и с асинхронизацией вместе с вызовом http-службы):</target>
        </trans-unit>
        <trans-unit id="dbceb93948d3b88153505159e94a72b7b46ceaf3" translate="yes" xml:space="preserve">
          <source>The code for &quot;provider&quot; methodology for Custom Services (this is necessary, if you would like to develop service which could be configured):</source>
          <target state="translated">Код для &quot;провайдерской&quot; методологии для Custom Services (это необходимо,если вы хотите разработать услугу,которую можно настроить):</target>
        </trans-unit>
        <trans-unit id="20100b8b1bb6246809bfd0d54c74369163ea60ef" translate="yes" xml:space="preserve">
          <source>The code for &quot;service&quot; methodology for Custom Services (this is pretty similar to 'factory', but different from syntax point of view):</source>
          <target state="translated">Код для &quot;сервисной&quot; методологии для Custom Services (это довольно похоже на &quot;фабрику&quot;,но отличается от синтаксиса):</target>
        </trans-unit>
        <trans-unit id="1f5224c76a4a9f42aeda5250ed57bd05696a3d3c" translate="yes" xml:space="preserve">
          <source>The difference between the three is that:</source>
          <target state="translated">Разница между ними в том,что</target>
        </trans-unit>
        <trans-unit id="80c0d58f7ad22390cf6e79a7ead32b51a9279f3b" translate="yes" xml:space="preserve">
          <source>The factory 'class' example is provided in the comments around, as well as provider difference.</source>
          <target state="translated">Пример заводского 'класса' приведен в комментариях вокруг,а также разница в провайдерах.</target>
        </trans-unit>
        <trans-unit id="29223deeb9a116b14e0df19e98f9ac9f789b7dbd" translate="yes" xml:space="preserve">
          <source>The factory can also return an object with a method that can be invoked:</source>
          <target state="translated">Завод также может возвращать объект методом,который может быть вызван:</target>
        </trans-unit>
        <trans-unit id="c72bcb74f28a11248fb075ce43662f6ac919dc7d" translate="yes" xml:space="preserve">
          <source>The factory can then be used throughout the application with custom settings. In other words, we can configure this factory before the application starts. In fact in the angular documentation it is mentioned that the provider method is what actually gets executed behind the scenes when we configure our services with either &lt;code&gt;.service&lt;/code&gt; or &lt;code&gt;.factory&lt;/code&gt; methods.</source>
          <target state="translated">Завод может быть использован во всем приложении с пользовательскими настройками. Другими словами, мы можем настроить эту фабрику до запуска приложения. Фактически в угловой документации упоминается, что метод провайдера - это то, что фактически выполняется за кулисами, когда мы конфигурируем наши сервисы &lt;code&gt;.service&lt;/code&gt; или &lt;code&gt;.factory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f2a456ca8dd7dbc5919aa27331c81f32a961f4" translate="yes" xml:space="preserve">
          <source>The factory returns a function that can be invoked:</source>
          <target state="translated">Завод возвращает функцию,которая может быть вызвана:</target>
        </trans-unit>
        <trans-unit id="294c451a3bc3bc52035a0a1ff0d80aadf5cf8464" translate="yes" xml:space="preserve">
          <source>The injected value for a factory dependency is the factory&amp;rsquo;s return
  value, and it doesn&amp;rsquo;t have to be an object. It could be a function</source>
          <target state="translated">Введенное значение для фабричной зависимости - это возвращаемое фабрикой значение, и оно не обязательно должно быть объектом. Это может быть функцией</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services
and special purpose objects</source>
          <target state="translated">Инжектор использует рецепты для создания двух типов объектов:объектов обслуживания и объектов специального назначения</target>
        </trans-unit>
        <trans-unit id="2a5bdc6259273898183df356d5f764744dcb6660" translate="yes" xml:space="preserve">
          <source>The lowest level way to create a service is by using the provide() method. This is the only way to create a service that we can configure using the .config() function.
Unlike the previous to methods, we&amp;rsquo;ll set the injectables in a defined this.$get() function definition.</source>
          <target state="translated">Самым низким способом создания сервиса является использование метода provide (). Это единственный способ создать службу, которую мы можем настроить с помощью функции .config (). В отличие от предыдущих методов, мы будем устанавливать инъецируемые объекты в определенном определении функции. $ Get ().</target>
        </trans-unit>
        <trans-unit id="33cea9a6904f984abbc8f96a6114e14b3b574e31" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider
  recipe. The &lt;strong&gt;remaining four&lt;/strong&gt; recipe types &amp;mdash; Value, Factory, Service and
  Constant &amp;mdash; &lt;strong&gt;are just syntactic sugar on top of a provider recipe&lt;/strong&gt;.</source>
          <target state="translated">Наиболее многословным, но и наиболее полным является рецепт провайдера. &lt;strong&gt;Остальные четыре&lt;/strong&gt; типа рецептов - Value, Factory, Service и Constant - &lt;strong&gt;просто синтаксический сахар поверх рецепта поставщика&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="348c5cf5eea19f952edd139e0384878a13cc16b3" translate="yes" xml:space="preserve">
          <source>The passed function can define a object and return that object. AngularJS simply stores this object reference to a variable which is passed as first argument. Anything which is returned from fnFactory will be bound to serviceInstance . Instead of returning object , we can also return function, values etc, Whatever we will return , will be available to service instance.</source>
          <target state="translated">Переданная функция может определить объект и вернуть его.AngularJS просто сохраняет ссылку этого объекта на переменную,которая передается в качестве первого аргумента.Все,что возвращается из fnFactory,будет привязано к serviceInstance.Вместо того,чтобы возвращать объект,мы также можем вернуть функцию,значения и т.д.Что бы мы ни возвращали,оно будет доступно экземпляру serviceInstance.</target>
        </trans-unit>
        <trans-unit id="d2510f9c93a099e17ccd62f31f88b7b395fab6a8" translate="yes" xml:space="preserve">
          <source>The service returns an object with a method that can be invoked:</source>
          <target state="translated">Служба возвращает объект методом,который может быть вызван:</target>
        </trans-unit>
        <trans-unit id="c22685b3257f9741c0336da5fe8df717ac146fa0" translate="yes" xml:space="preserve">
          <source>The service() method, on the other hand allows us to create a service by defining a constructor function. We can use a prototypical object to define our service, instead of a raw javascript object.
Similar to the factory() method, we&amp;rsquo;ll also set the injectables in the function definition.</source>
          <target state="translated">Метод service (), с другой стороны, позволяет нам создавать сервис, определяя функцию конструктора. Мы можем использовать прототипный объект для определения нашего сервиса вместо необработанного объекта JavaScript. Подобно методу factory (), мы также установим инъецируемые элементы в определении функции.</target>
        </trans-unit>
        <trans-unit id="6d15e1717ce86b0987b078987bab5ad9e89e8630" translate="yes" xml:space="preserve">
          <source>The simplest way of thinking is the following one:</source>
          <target state="translated">Самый простой способ мышления-следующий:</target>
        </trans-unit>
        <trans-unit id="d37bdb33569628feda26fad99fde289973152425" translate="yes" xml:space="preserve">
          <source>Then it needs to have a separate &lt;em&gt;$.get&lt;/em&gt; function which is executed by AngularJS after setting the above properties via the &lt;code&gt;app.config&lt;/code&gt; file , and this &lt;em&gt;$.get&lt;/em&gt; function behaves just as the &lt;em&gt;factory&lt;/em&gt; above, in that its return value is used to initialize the &quot;global&quot; variables.</source>
          <target state="translated">Затем ему нужно иметь отдельную функцию &lt;em&gt;$ .get,&lt;/em&gt; которая выполняется AngularJS после установки вышеуказанных свойств через файл &lt;code&gt;app.config&lt;/code&gt; , и эта функция &lt;em&gt;$ .get&lt;/em&gt; ведет себя так же, как &lt;em&gt;фабрика&lt;/em&gt; выше, поскольку ее возвращаемое значение используется для инициализации &amp;laquo;глобальные&amp;raquo; переменные.</target>
        </trans-unit>
        <trans-unit id="b32fe2094a05734d73d634537bd5399d06168766" translate="yes" xml:space="preserve">
          <source>Then to instantiate you would have to write</source>
          <target state="translated">Тогда,чтобы воплотить это в жизнь,тебе придется написать.</target>
        </trans-unit>
        <trans-unit id="3dbd87f48f38a7cd7438dff5c9c9a17a54a72326" translate="yes" xml:space="preserve">
          <source>Then we can do this:</source>
          <target state="translated">Тогда мы сможем это сделать:</target>
        </trans-unit>
        <trans-unit id="26ab2c621cf3a4ad1aed6bc59c8cac976a8891fc" translate="yes" xml:space="preserve">
          <source>Then we could ask for 'greeter' in controller like this</source>
          <target state="translated">Тогда мы могли бы попросить &quot;greeter&quot; в контроллере вот так.</target>
        </trans-unit>
        <trans-unit id="73c6e7a10f2e40affaa0702fd4636afb5ef0a445" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt;,
&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Существует пять типов рецептов, которые определяют, как создавать объекты: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; и &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, 
Factory, Service, Provider and Constant.</source>
          <target state="translated">Существует пять типов рецептов,которые определяют,как создавать объекты:Ценность,Фабрика,Услуга,Поставщик и Постоянный.</target>
        </trans-unit>
        <trans-unit id="a3abfbafa21284370080781426e7f10765c626b1" translate="yes" xml:space="preserve">
          <source>There are good answers already, but I just want to share this one.</source>
          <target state="translated">Уже есть хорошие ответы,но я просто хочу поделиться этим.</target>
        </trans-unit>
        <trans-unit id="cbe50089e98dca4865d62e4d5d431a2ad1e1d31e" translate="yes" xml:space="preserve">
          <source>There are many levels of complications in creating the values for the &quot;global variables&quot;:</source>
          <target state="translated">Существует множество уровней сложности при создании значений для &quot;глобальных переменных&quot;:</target>
        </trans-unit>
        <trans-unit id="cfe4afb9db4aa26d7132e641470f68bed3f4242c" translate="yes" xml:space="preserve">
          <source>There is &lt;code&gt;Service vs Factory&lt;/code&gt; part has been covered:
&lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</source>
          <target state="translated">Существует &lt;code&gt;Service vs Factory&lt;/code&gt; &amp;raquo;: &lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8ee704f9be11c360a8332f959f17604faeec8af" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;$get&lt;/code&gt; object that you define and it can be used to get the object that returns data.</source>
          <target state="translated">Существует определенный объект &lt;code&gt;$get&lt;/code&gt; , который можно использовать для получения объекта, который возвращает данные.</target>
        </trans-unit>
        <trans-unit id="5a7068b6dda657b5b0908bbb1b5b47f54867579f" translate="yes" xml:space="preserve">
          <source>This answer address the topic/question</source>
          <target state="translated">Этот ответ касается вопросов темы</target>
        </trans-unit>
        <trans-unit id="d2ca6aed8a94daf45ebec515f35b4ef0c7e37069" translate="yes" xml:space="preserve">
          <source>This defines an actual constant that should not be modified during the entire application, just like constants in other languages are (something that JavaScript lacks).</source>
          <target state="translated">Это определяет действительную константу,которую не следует изменять во время всего приложения,как это делают константы в других языках (то,чего не хватает JavaScript).</target>
        </trans-unit>
        <trans-unit id="23068a44ce8e025468c6a880cdc354c2346311bc" translate="yes" xml:space="preserve">
          <source>This is a modifiable value or object, and it serves as some global variable, that can even be injected when creating other services or factories (see further on these). However, it must be a &quot;&lt;em&gt;literal value&lt;/em&gt;&quot;, which means that one has to write out the actual value, and cannot use any computation or programming logic (in other words &lt;em&gt;39&lt;/em&gt; or &lt;em&gt;myText&lt;/em&gt; or &lt;em&gt;{prop: &quot;value&quot;}&lt;/em&gt; are OK, but &lt;em&gt;2 +2&lt;/em&gt; is not).</source>
          <target state="translated">Это изменяемое значение или объект, и он служит некоторой глобальной переменной, которую можно даже вставить при создании других служб или фабрик (см. Далее). Однако это должно быть &amp;laquo; &lt;em&gt;буквальное значение&lt;/em&gt; &amp;raquo;, что означает, что нужно выписать фактическое значение и не может использовать какую-либо логику вычислений или программирования (другими словами, &lt;em&gt;39&lt;/em&gt; или &lt;em&gt;myText&lt;/em&gt; или &lt;em&gt;{prop: &amp;laquo;value&amp;raquo;}&lt;/em&gt; в порядке, но &lt;em&gt;2 +2&lt;/em&gt; нет).</target>
        </trans-unit>
        <trans-unit id="7c23aa97141e4f8d46377a4215db03016a94f612" translate="yes" xml:space="preserve">
          <source>This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the &amp;lsquo;new&amp;rsquo; keyword, &amp;lsquo;this&amp;rsquo; will be bound to the newly created object.</source>
          <target state="translated">Это типичная функция конструктора JavaScript. Теперь всякий раз, когда мы вызываем функцию Person с помощью ключевого слова new, this будет привязано к вновь созданному объекту.</target>
        </trans-unit>
        <trans-unit id="dfb8cea8751eb472adb742095a7b2c6e23a67444" translate="yes" xml:space="preserve">
          <source>This is the behavior for any complex values (objects, functions) but not for primitive types.</source>
          <target state="translated">Это поведение для любых сложных значений (объектов,функций),но не для примитивных типов.</target>
        </trans-unit>
        <trans-unit id="f1e7c9cd5dc0b108189dc22be56ae3d9ed503494" translate="yes" xml:space="preserve">
          <source>This is very confusing part for newbie and I have tried to clarify it in easy words</source>
          <target state="translated">Это очень запутанная часть для новичка,и я попытался прояснить ее простыми словами.</target>
        </trans-unit>
        <trans-unit id="0071c8fa9a8db22cbf7fe7086f0e4a422890b5c6" translate="yes" xml:space="preserve">
          <source>This is why we use &lt;code&gt;this&lt;/code&gt; in services, and define a &lt;code&gt;this.$get&lt;/code&gt; in providers.</source>
          <target state="translated">Вот почему мы используем &lt;code&gt;this&lt;/code&gt; в сервисах и определяем &lt;code&gt;this.$get&lt;/code&gt; в провайдерах.</target>
        </trans-unit>
        <trans-unit id="337dbda194e27c65c3b59a20fcfe6f20bce044b3" translate="yes" xml:space="preserve">
          <source>This means that you can basically copy-paste the factory example from below, replace &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;service&lt;/code&gt;, and it&amp;rsquo;ll work:</source>
          <target state="translated">Это означает, что вы можете скопировать и вставить фабричный пример снизу, заменить &lt;code&gt;factory&lt;/code&gt; на &lt;code&gt;service&lt;/code&gt; , и он будет работать:</target>
        </trans-unit>
        <trans-unit id="bcb15b94b5801e9e5561df693ee7def2f99bdaf9" translate="yes" xml:space="preserve">
          <source>To really see the changes that occur when you invoke a function with the &amp;lsquo;new&amp;rsquo; keyword, let&amp;rsquo;s create a function and invoke it with the &amp;lsquo;new&amp;rsquo; keyword, then let&amp;rsquo;s show what the interpreter does when it sees the &amp;lsquo;new&amp;rsquo; keyword. The end results will both be the same.</source>
          <target state="translated">Чтобы действительно увидеть изменения, которые происходят при вызове функции с ключевым словом &amp;laquo;new&amp;raquo;, давайте создадим функцию и вызовем ее с ключевым словом &amp;laquo;new&amp;raquo;, а затем покажем, что делает интерпретатор, когда видит ключевое слово &amp;laquo;new&amp;raquo;. Конечные результаты будут одинаковыми.</target>
        </trans-unit>
        <trans-unit id="f002fd0a5d473826ead53b980392d6392a7e2430" translate="yes" xml:space="preserve">
          <source>Unlike a service which is a simplified version of &lt;em&gt;factory&lt;/em&gt;, a provider is a more complex, but more flexible way of initializing the &quot;global&quot; variables, with the biggest flexibility being the option to set values from the app.config.</source>
          <target state="translated">В отличие от сервиса, который является упрощенной версией &lt;em&gt;фабрики&lt;/em&gt; , провайдер является более сложным, но более гибким способом инициализации &amp;laquo;глобальных&amp;raquo; переменных, с самой большой гибкостью, являющейся возможностью устанавливать значения из app.config.</target>
        </trans-unit>
        <trans-unit id="864ea43a8c2da87a50b0e143c273a5376c32245f" translate="yes" xml:space="preserve">
          <source>Unlike what we originally did with the Factory example, we don&amp;rsquo;t need to create an object then return that object because, like mentioned many times before, we used the &amp;lsquo;new&amp;rsquo; keyword so the interpreter will create that object, have it delegate to it&amp;rsquo;s prototype, then return it for us without us having to do the work.</source>
          <target state="translated">В отличие от того, что мы изначально делали с примером Factory, нам не нужно создавать объект, а затем возвращать этот объект, потому что, как упоминалось много раз ранее, мы использовали ключевое слово &amp;laquo;new&amp;raquo;, поэтому интерпретатор создаст этот объект, предоставив ему делегирование это прототип, а затем верните его нам без необходимости выполнять работу.</target>
        </trans-unit>
        <trans-unit id="b49caeb887a29a8bada2966d7c2590d853f20723" translate="yes" xml:space="preserve">
          <source>Usage (as an injectable in a controller)</source>
          <target state="translated">Использование (как инжектор в контроллере)</target>
        </trans-unit>
        <trans-unit id="879ae7be1e519b410069e2f401b1f3f754b21f05" translate="yes" xml:space="preserve">
          <source>Usage (configuring the provider before &lt;code&gt;$get&lt;/code&gt; is called to create the injectable)</source>
          <target state="translated">Использование (настройка поставщика перед вызовом &lt;code&gt;$get&lt;/code&gt; для создания инъекционного)</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="4022b8a59a0d0d2ca89f1ecfac78f71d1bc33304" translate="yes" xml:space="preserve">
          <source>Use it when you need to share a single object throughout the application. For example, authenticated user details, share-able methods/data, Utility functions etc.</source>
          <target state="translated">Используйте его,когда необходимо совместно использовать один объект во всем приложении.Например,аутентифицированные данные пользователя,данные методов с общим доступом,функции утилиты и т.д.</target>
        </trans-unit>
        <trans-unit id="c140efc7adf0e2b8a74e6393e081cb7475561437" translate="yes" xml:space="preserve">
          <source>Use this link for code reference</source>
          <target state="translated">Используйте эту ссылку для получения кода</target>
        </trans-unit>
        <trans-unit id="be9209121182255216aaa47dfd1cae1b29bb43e3" translate="yes" xml:space="preserve">
          <source>Using as reference this page and the &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentation&lt;/a&gt; (which seems to have greatly improved since the last time I looked), I put together the following real(-ish) world demo which uses 4 of the 5 flavours of provider; Value, Constant, Factory and full blown Provider.</source>
          <target state="translated">Используя в качестве ссылки эту страницу и &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;документацию&lt;/a&gt; (которая, кажется, значительно улучшилась с тех пор, как я смотрел в последний раз), я собрал следующую (-ish) демонстрацию мира, в которой используются 4 из 5 вариантов провайдера; Значение, Постоянный, Заводской и полномасштабный Провайдер.</target>
        </trans-unit>
        <trans-unit id="7f1b9dfcd80673ff780bfe6c9e4b747b202f04d5" translate="yes" xml:space="preserve">
          <source>Using the factory() in our app</source>
          <target state="translated">Использование функции factory()в нашем приложении</target>
        </trans-unit>
        <trans-unit id="93312e4afaa947b3a60bfa6bea40f131935883a5" translate="yes" xml:space="preserve">
          <source>Visibility of injectables is different for providers than it is for services and factories. If you declare an AngularJS &quot;constant&quot; (for example, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt;), you can inject it into services, factories, and providers.</source>
          <target state="translated">Видимость инъекционных препаратов различна для поставщиков, чем для служб и предприятий. Если вы объявите AngularJS &amp;laquo;константой&amp;raquo; (например, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt; ), вы можете внедрить его в службы, фабрики и поставщиков.</target>
        </trans-unit>
        <trans-unit id="d22cafa4fcd376a2f27d8c4831e76c2f8fa630f7" translate="yes" xml:space="preserve">
          <source>We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven&amp;rsquo;t had much experience using promises in AngularJS, I highly recommend doing a deep dive on them.</source>
          <target state="translated">Мы собираемся создать методы setArtist и getArtist, которые просто возвращают или устанавливают художника. Мы также собираемся создать метод, который будет вызывать iTunes API с нашим созданным URL. Этот метод возвращает обещание, которое будет выполнено, как только данные вернутся из iTunes API. Если у вас не было большого опыта использования обещаний в AngularJS, я настоятельно рекомендую глубоко погрузиться в них.</target>
        </trans-unit>
        <trans-unit id="c68ba4741829821c5273926306c848fe58e787c7" translate="yes" xml:space="preserve">
          <source>We can create configurable services using provider syntax as given below.</source>
          <target state="translated">Мы можем создавать настраиваемые услуги,используя синтаксис провайдера,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="dbe235285ce55886f522548de7d34e5b6a156187" translate="yes" xml:space="preserve">
          <source>We can define a factory function as below.</source>
          <target state="translated">Мы можем определить заводскую функцию,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="9dc701ea399c4055cce4573cf97749a703eb7d4a" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Provider&lt;/code&gt; and &lt;code&gt;Factory&lt;/code&gt; in AngularJS?</source>
          <target state="translated">Каковы различия между &lt;code&gt;Service&lt;/code&gt; , &lt;code&gt;Provider&lt;/code&gt; и &lt;code&gt;Factory&lt;/code&gt; в AngularJS?</target>
        </trans-unit>
        <trans-unit id="1d97deb201bb1447c8de5b02c7b3a99898edb8b5" translate="yes" xml:space="preserve">
          <source>When Angular injects this &lt;code&gt;MyService&lt;/code&gt; service into a controller that
  depends on it, that controller will get a &lt;code&gt;MyService&lt;/code&gt; that it can call
  functions on, e.g. MyService.aServiceMethod ().</source>
          <target state="translated">Когда Angular внедряет эту службу &lt;code&gt;MyService&lt;/code&gt; в контроллер, который зависит от него, этот контроллер получает &lt;code&gt;MyService&lt;/code&gt; ,к которому он может вызывать функции, например MyService.aServiceMethod ().</target>
        </trans-unit>
        <trans-unit id="71e6a586496bb64a15227083621aef43a2714aea" translate="yes" xml:space="preserve">
          <source>When creating a service with Provider, the only properties/methods that will be available in your controller are those properties/methods which are returned from the $get() function. The code below puts $get on &amp;lsquo;this&amp;rsquo; (which we know will eventually be returned from that function). Now, that $get function returns all the methods/properties we want to be available in the controller. Here&amp;rsquo;s a code example.</source>
          <target state="translated">При создании службы с помощью Provider в вашем контроллере будут доступны только те свойства / методы, которые возвращаются из функции $ get (). Приведенный ниже код помещает $ get в this (которое, как мы знаем, будет возвращено из этой функции). Теперь эта функция $ get возвращает все методы / свойства, которые мы хотим быть доступными в контроллере. Вот пример кода.</target>
        </trans-unit>
        <trans-unit id="3bc3b865d96d4a3942513d9897a3bb409a798a5a" translate="yes" xml:space="preserve">
          <source>When making a &lt;code&gt;service()&lt;/code&gt; it return you providing a factory() with a &lt;code&gt;function&lt;/code&gt; that injects the &lt;code&gt;constructor&lt;/code&gt; (return the instance of the constructor you provided in your service) and returns it</source>
          <target state="translated">При создании &lt;code&gt;service()&lt;/code&gt; он возвращает вас, предоставляя factory () &lt;code&gt;function&lt;/code&gt; которая внедряет &lt;code&gt;constructor&lt;/code&gt; (возвращает экземпляр конструктора, который вы предоставили в вашем сервисе) и возвращает его</target>
        </trans-unit>
        <trans-unit id="d6d43abc5bb66cd755013d3ef82d0ae0e0cc46c8" translate="yes" xml:space="preserve">
          <source>When you make a &lt;code&gt;factory()&lt;/code&gt; it sets you &lt;code&gt;function&lt;/code&gt; provided in second argument to provider's &lt;code&gt;$get&lt;/code&gt; and return it(&lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt;),</source>
          <target state="translated">Когда вы создаете &lt;code&gt;factory()&lt;/code&gt; он устанавливает &lt;code&gt;function&lt;/code&gt; предоставленную во втором аргументе, в &lt;code&gt;$get&lt;/code&gt; провайдера и возвращает его ( &lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="45f317e75b95e397ea00208400104d4fe8bf5e18" translate="yes" xml:space="preserve">
          <source>When you need to provide module-wise configuration for your service object before making it available, eg. suppose you want to set your API URL on basis of your Environment like &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;stage&lt;/code&gt; or &lt;code&gt;prod&lt;/code&gt;</source>
          <target state="translated">Когда вам нужно предоставить модульную конфигурацию для вашего сервисного объекта, прежде чем сделать его доступным, например. Предположим, вы хотите установить URL своего API на основе вашей среды, такой как &lt;code&gt;dev&lt;/code&gt; , &lt;code&gt;stage&lt;/code&gt; или &lt;code&gt;prod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d9813216aceb4fb52c9772759aad11c548dbb06" translate="yes" xml:space="preserve">
          <source>Which means there&amp;rsquo;s something like a cache object inside AngularJS, whose value of each injection is only assigned once, when they've been injected the first time, and where:</source>
          <target state="translated">Это означает, что внутри AngularJS есть что-то вроде объекта кэша, значение которого для каждой инъекции присваивается только один раз, когда они были введены впервые, и где</target>
        </trans-unit>
        <trans-unit id="9a5bdc65b2c24b100cbcaaaa5059622b099681ae" translate="yes" xml:space="preserve">
          <source>While global variables are not recommended, the real usage of these global variables is to provide &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, by passing the variable to the relevant controller.</source>
          <target state="translated">Хотя глобальные переменные не рекомендуются, реальное использование этих глобальных переменных заключается в обеспечении &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;внедрения зависимости&lt;/a&gt; путем передачи переменной соответствующему контроллеру.</target>
        </trans-unit>
        <trans-unit id="b5f5a2ae1fcba7052d4d70638cf84ffe0eb2743b" translate="yes" xml:space="preserve">
          <source>Working &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;demo&lt;/a&gt;.</source>
          <target state="translated">Рабочая &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;демка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b3d2c4eb971fcbd43812638af12c7dc4437f9c" translate="yes" xml:space="preserve">
          <source>Working Demo</source>
          <target state="translated">Рабочая демонстрация</target>
        </trans-unit>
        <trans-unit id="9fd4dd933fe260f137acd6eae3ea36eb6536140b" translate="yes" xml:space="preserve">
          <source>You can think of Providers as having three sections. The first section is the &amp;lsquo;private&amp;rsquo; variables/functions that will be modified/set later (shown above). The second section is the variables/functions that will be available in your app.config function and are therefore available to alter before they&amp;rsquo;re available anywhere else (also shown above). It&amp;rsquo;s important to note that those variables need to be attached to the &amp;lsquo;this&amp;rsquo; keyword. In our example, only &amp;lsquo;thingFromConfig&amp;rsquo; will be available to alter in the app.config. The third section (shown below) is all the variables/functions that will be available in your controller when you pass in the &amp;lsquo;myProvider&amp;rsquo; service into that specific controller.</source>
          <target state="translated">Вы можете думать о провайдерах как о трех разделах. Первый раздел - это &amp;laquo;закрытые&amp;raquo; переменные / функции, которые будут изменены / установлены позже (показано выше). Второй раздел - это переменные / функции, которые будут доступны в вашей функции app.config и, следовательно, доступны для изменения до того, как они станут доступны где-либо еще (также показано выше). Важно отметить, что эти переменные должны быть присоединены к ключевому слову this. В нашем примере, только 'thingFromConfig' будет доступен для изменения в app.config. Третий раздел (показанный ниже) - это все переменные / функции, которые будут доступны в вашем контроллере, когда вы передадите службу myProvider в этот конкретный контроллер.</target>
        </trans-unit>
        <trans-unit id="8b95d0adc56d83fa7498365437f66e79ee788966" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to return a value. When Angular calls &lt;code&gt;new yourServiceName(&lt;/code&gt;), it&amp;rsquo;ll receive the &lt;code&gt;this&lt;/code&gt; object with all the properties you put on it.</source>
          <target state="translated">Вам не нужно возвращать значение. Когда Angular вызывает &lt;code&gt;new yourServiceName(&lt;/code&gt; ), он получит объект &lt;code&gt;this&lt;/code&gt; со всеми свойствами, которые вы наделили на него.</target>
        </trans-unit>
        <trans-unit id="3fe544a5098b0be6e451614ad5ff4af0887aea93" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will cache and inject the return value when the factory is requested.</source>
          <target state="translated">Вы даете AngularJS функцию,AngularJS будет кэшировать и впрыскивать возвращаемое значение при запросе фабрики.</target>
        </trans-unit>
        <trans-unit id="7733853022202a91bba391de813e5ef65f7cfeb5" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will call &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; to instantiate it. It is the instance that AngularJS creates that will be cached and injected when the service is requested. Since &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; was used to instantiate the service, the keyword &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; is valid and refers to the instance.</source>
          <target state="translated">Вы даете AngularJS функцию, AngularJS вызовет &lt;strong&gt;&lt;em&gt;new,&lt;/em&gt;&lt;/strong&gt; чтобы создать ее экземпляр. Это экземпляр, который создает AngularJS, который будет кэшироваться и вставляться при запросе сервиса. Поскольку &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; использовался для создания экземпляра службы, ключевое слово &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; является действительным и относится к экземпляру.</target>
        </trans-unit>
        <trans-unit id="a2a1ff92c50375a3fdf5b1809ff8ea225aab5a9c" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, and AngularJS will call its &lt;code&gt;$get&lt;/code&gt; function. It is the return value from the &lt;code&gt;$get&lt;/code&gt; function that will be cached and injected when the service is requested.</source>
          <target state="translated">Вы даете AngularJS функцию, и AngularJS будет вызывать ее функцию &lt;code&gt;$get&lt;/code&gt; . Это возвращаемое значение из функции &lt;code&gt;$get&lt;/code&gt; которое будет кэшироваться и вставляться при запросе службы.</target>
        </trans-unit>
        <trans-unit id="3876a0940a5a7dd665609735ebfa32e7f6e1bcc3" translate="yes" xml:space="preserve">
          <source>You just have a standard function that uses this keyword to define a function.</source>
          <target state="translated">У вас просто есть стандартная функция,которая использует это ключевое слово для определения функции.</target>
        </trans-unit>
        <trans-unit id="866717a4969cced464a5c0ae6684faada33bde94" translate="yes" xml:space="preserve">
          <source>You might be tempted to call &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; in a promise chain, for instance if you initialized the score by grabbing it from the server: &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; The trouble with this is that &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; will be called with &lt;code&gt;this&lt;/code&gt; bound to &lt;code&gt;null&lt;/code&gt; and you&amp;rsquo;ll get errors. The better way would be &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt;.
Whether you choose to use this in your service methods or not, be careful how you call them.</source>
          <target state="translated">У вас может возникнуть соблазн вызвать &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; в цепочке обещаний, например, если вы инициализировали счет, взяв его с сервера: &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; Проблема в том, что &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; будет вызываться с &lt;code&gt;null&lt;/code&gt; и вы получите ошибки. Лучше всего было бы &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt; . Если вы решите использовать это в своих методах обслуживания или нет, будьте осторожны, как вы их называете.</target>
        </trans-unit>
        <trans-unit id="bea982bb9c2f6821b3f44edf8dad402dddc73177" translate="yes" xml:space="preserve">
          <source>You should use the Provider recipe only when you want to expose an API
  for application-wide configuration that must be made before the
  application starts. This is usually interesting only for reusable
  services whose behavior might need to vary slightly between
  applications.</source>
          <target state="translated">Рецепт провайдера следует использовать только в том случае,если вы хотите разоблачить API для настройки всего приложения,что должно быть сделано до запуска приложения.Обычно это интересно только для многоразовых сервисов,поведение которых может немного отличаться в зависимости от приложения.</target>
        </trans-unit>
        <trans-unit id="c5956833324972c28737ee048ed90ebe091ca59b" translate="yes" xml:space="preserve">
          <source>_artist is the artist we wish to lookup</source>
          <target state="translated">Художник-это художник,за которым мы хотим присмотреться.</target>
        </trans-unit>
        <trans-unit id="72921d9d0e40db1cd6390dcc0077ecda67c652ba" translate="yes" xml:space="preserve">
          <source>_finalUrl is the final and fully built URL to which we&amp;rsquo;ll make the call to iTunes</source>
          <target state="translated">_finalUrl - это окончательный и полностью созданный URL, по которому мы сделаем звонок в iTunes.</target>
        </trans-unit>
        <trans-unit id="0bfda8d377c2609cd9d50c5b636b767072ce4e18" translate="yes" xml:space="preserve">
          <source>ability to use other services (have dependencies)</source>
          <target state="translated">возможность пользоваться другими услугами (иметь зависимости)</target>
        </trans-unit>
        <trans-unit id="6a925e5ed5ce5e858b8242994457f2ab7ac71782" translate="yes" xml:space="preserve">
          <source>all you get is &lt;code&gt;provider&lt;/code&gt; but there is no property/method other than &lt;code&gt;$get&lt;/code&gt;</source>
          <target state="translated">все, что вы получаете, это &lt;code&gt;provider&lt;/code&gt; но нет другого свойства / метода, кроме &lt;code&gt;$get&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d27b037fa89342a90ff5d6df4947c9eece46029" translate="yes" xml:space="preserve">
          <source>and returns &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">и возвращает &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="402433d1fb629334beefb9cb164a7a1c035c71e7" translate="yes" xml:space="preserve">
          <source>and using:</source>
          <target state="translated">и использующий:</target>
        </trans-unit>
        <trans-unit id="427c1761ab15aa547603cd68334d242a2d5523d9" translate="yes" xml:space="preserve">
          <source>baseUrl is the base URL that the iTunes API requires</source>
          <target state="translated">baseUrl-это базовый URL,который требуется для iTunes API.</target>
        </trans-unit>
        <trans-unit id="2cdaa8f3ceef76f1dc730a6b60c06476e795c676" translate="yes" xml:space="preserve">
          <source>basically what happens is</source>
          <target state="translated">в сущности,то,что происходит</target>
        </trans-unit>
        <trans-unit id="b50ae779a31c55dd00a1f71d908a312cbc40af0a" translate="yes" xml:space="preserve">
          <source>connects &lt;code&gt;context&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">связывает &lt;code&gt;context&lt;/code&gt; с &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54bf3f1ce25250844230f2deb1ca4ace3b97b315" translate="yes" xml:space="preserve">
          <source>creates brand new object</source>
          <target state="translated">создает совершенно новый объект</target>
        </trans-unit>
        <trans-unit id="deb0c5efabe5381fec4da90741ac9ac67289b4ec" translate="yes" xml:space="preserve">
          <source>delayed/lazy initialization</source>
          <target state="translated">инициализация запаздывания</target>
        </trans-unit>
        <trans-unit id="0188b442c8481c48fffbded6f20f1d6cded3c775" translate="yes" xml:space="preserve">
          <source>how Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe?</source>
          <target state="translated">как Factory, Service и Constant - просто синтаксический сахар поверх рецепта поставщика?</target>
        </trans-unit>
        <trans-unit id="8f55d557046d81d78de7516299b50060cdf7c55b" translate="yes" xml:space="preserve">
          <source>how factory ,servic and providers are simailar internally</source>
          <target state="translated">как фабрика,сервис и провайдеры являются симайларами внутри.</target>
        </trans-unit>
        <trans-unit id="ce1ed02a506c79b6518185593802fbb4aaa54d8a" translate="yes" xml:space="preserve">
          <source>links it to its &lt;code&gt;prototype&lt;/code&gt; object</source>
          <target state="translated">связывает его с его &lt;code&gt;prototype&lt;/code&gt; объекта</target>
        </trans-unit>
        <trans-unit id="1e4306c581e1c078a3c92df9bd0a6162776ce8e8" translate="yes" xml:space="preserve">
          <source>makeUrl is a function that will create and return our iTunes friendly URL.</source>
          <target state="translated">makeUrl-это функция,которая создаст и вернет наш iTunes дружественный URL.</target>
        </trans-unit>
        <trans-unit id="ba23da34d1e3b19225a60f4a7206e21e32aad969" translate="yes" xml:space="preserve">
          <source>of that &lt;code&gt;provider&lt;/code&gt;(means you can't configure this)</source>
          <target state="translated">этого &lt;code&gt;provider&lt;/code&gt; (означает, что вы не можете настроить это)</target>
        </trans-unit>
        <trans-unit id="6192271d0d781e240956f0b4f5271f3d5d92ac46" translate="yes" xml:space="preserve">
          <source>service initialization</source>
          <target state="translated">инициализация услуги</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
