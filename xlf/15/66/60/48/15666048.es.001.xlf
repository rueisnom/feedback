<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/15666048">
    <body>
      <group id="15666048">
        <trans-unit id="64a58ac5bcfe347c123a856c3f7ac41a16c18e93" translate="yes" xml:space="preserve">
          <source>&quot; Hello world &quot; example with &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt;:</source>
          <target state="translated">Ejemplo de &quot;Hola mundo&quot; con &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27ab96a759e2b4ef1d829c8525ca087d26314532" translate="yes" xml:space="preserve">
          <source>&quot;$injector is used to retrieve object instances as defined by &lt;strong&gt;provider&lt;/strong&gt;&quot; not service, not factory but provider.</source>
          <target state="translated">&quot;$ injector se usa para recuperar instancias de objetos seg&amp;uacute;n lo definido por el &lt;strong&gt;proveedor&lt;/strong&gt; &quot;, no servicio, no f&amp;aacute;brica sino proveedor.</target>
        </trans-unit>
        <trans-unit id="47d91685928f3bdbd8a6e0bbabc322e70072c356" translate="yes" xml:space="preserve">
          <source>*Again if any portion of the above code is confusing, check out the Factory section where I explain what it all does it greater details.</source>
          <target state="translated">*Otra vez si alguna parte del código anterior es confuso,mira la sección de Fábrica donde explico qué es lo que hace con más detalles.</target>
        </trans-unit>
        <trans-unit id="f4d91701275cfa2997fcf5752d0f40b1c281d19d" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;service&lt;/code&gt; for most cases of default</source>
          <target state="translated">1. &lt;code&gt;service&lt;/code&gt; para la mayor&amp;iacute;a de los casos de incumplimiento</target>
        </trans-unit>
        <trans-unit id="b474cc94e43caf4ce704bf9f973a68251b25cd13" translate="yes" xml:space="preserve">
          <source>1.Provider object is created using constructor function we defined in our provider function.</source>
          <target state="translated">1.El objeto proveedor se crea usando la función constructora que definimos en nuestra función de proveedor.</target>
        </trans-unit>
        <trans-unit id="4c2cfdc84411546e36f7e4d88a4a92785dd9ead0" translate="yes" xml:space="preserve">
          <source>1.Services are singleton objects that are created when necessary and are never cleaned up until the end of the application life-cycle (when the browser is closed). Controllers are destroyed and cleaned up when they are no longer needed.</source>
          <target state="translated">1.Los servicios son objetos de un solo botón que se crean cuando es necesario y nunca se limpian hasta el final del ciclo de vida de la aplicación (cuando se cierra el navegador).Los controladores se destruyen y se limpian cuando ya no son necesarios.</target>
        </trans-unit>
        <trans-unit id="4edf8c51b9d95a7ca3a85d5aeca515c293064266" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;factory&lt;/code&gt; used to create the service that specific instance</source>
          <target state="translated">2. &lt;code&gt;factory&lt;/code&gt; utilizada para crear el servicio esa instancia espec&amp;iacute;fica</target>
        </trans-unit>
        <trans-unit id="d01f9f1efa5be666f175edf0f3d066f99322711a" translate="yes" xml:space="preserve">
          <source>2.The easiest way to create a service is by using the factory() method.
The factory() method allows us to define a service by returning an object that contains service functions and service data. The service definition function is where we place our injectable services, such as $http and $q.
Ex:</source>
          <target state="translated">2.La forma más fácil de crear un servicio es usando el método factory().El método factory()nos permite definir un servicio devolviendo un objeto que contiene funciones de servicio y datos de servicio.La función de definición de servicio es donde colocamos nuestros servicios inyectables,como $http y $q.Ex:</target>
        </trans-unit>
        <trans-unit id="81049cf8d158fd8f6aa9e09fb3f7674dc7278ae0" translate="yes" xml:space="preserve">
          <source>2.The function we passed in app.config(), get executed. This is called config phase, and here we have a chance to customize our service.</source>
          <target state="translated">2.La función que pasamos en app.config(),se ejecuta.Esto se llama fase de configuración,y aquí tenemos la oportunidad de personalizar nuestro servicio.</target>
        </trans-unit>
        <trans-unit id="e06f9e5bc87b677a928a701f0b17b557a83c7cd8" translate="yes" xml:space="preserve">
          <source>3.Finally service instance is created by calling $get method of serviceProvider.</source>
          <target state="translated">3.Finalmente la instancia de servicio se crea llamando a $get method of serviceProvider.</target>
        </trans-unit>
        <trans-unit id="10247f3761146ad3fd29f8f04438a385637cbd75" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt;  (&amp;lt;-- GOOD)
&lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt; (&amp;lt;- BUENO) &lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96509fbd15a55d9f8c6b0f16f86f369bd1959c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;'s stored value comes from running &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">El valor almacenado de a proviene de ejecutar &lt;code&gt;fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9806d20accdcf4a7d7bf03bac15b08c0e80af8cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;&amp;rsquo;s stored value comes from &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">El valor almacenado de &lt;code&gt;b&lt;/code&gt; proviene del &lt;code&gt;new&lt;/code&gt; ing &lt;code&gt;fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10d4a6de0cf092cde9d6b1c37da584005618d85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;&amp;rsquo;s stored value comes from first getting an instance by &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;, and then running a &lt;code&gt;$get&lt;/code&gt; method of the instance.</source>
          <target state="translated">El valor almacenado de &lt;code&gt;c&lt;/code&gt; proviene de obtener primero una instancia mediante el &lt;code&gt;new&lt;/code&gt; ing &lt;code&gt;fn&lt;/code&gt; , y luego ejecutar un m&amp;eacute;todo &lt;code&gt;$get&lt;/code&gt; de la instancia.</target>
        </trans-unit>
        <trans-unit id="f37e6ab171ca302e86496ad45c7c8b082187c7b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lazily Instantiated&lt;/em&gt;: If it is not injected it won't be instantiated ever. So to use it will have to inject it to a module.</source>
          <target state="translated">&lt;em&gt;Instancia perezosa&lt;/em&gt; : si no se inyecta, no se instanciar&amp;aacute; nunca. Entonces, para usarlo, tendr&amp;aacute; que inyectarlo en un m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="bbc415a0718bc792ec75efc2d5784a6b2ed76fb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Singleton&lt;/em&gt;: If injected to multiple modules, all will have access to only one particular instance. That is why very convenient to share data across different controllers.</source>
          <target state="translated">&lt;em&gt;Singleton&lt;/em&gt; : si se inyecta en varios m&amp;oacute;dulos, todos tendr&amp;aacute;n acceso a una sola instancia en particular. Por eso es muy conveniente compartir datos entre diferentes controladores.</target>
        </trans-unit>
        <trans-unit id="de74c279e2d766663b22cc4a4bef8ec70061c8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) F&amp;aacute;brica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1920da3aedb3ed95be87c557b3978bf5d2066e0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; When you&amp;rsquo;re using a &lt;strong&gt;Factory&lt;/strong&gt; you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.</source>
          <target state="translated">&lt;strong&gt;1)&lt;/strong&gt; Cuando usa una &lt;strong&gt;F&amp;aacute;brica&lt;/strong&gt; , crea un objeto, le agrega propiedades y luego devuelve el mismo objeto. Cuando pasa esta f&amp;aacute;brica a su controlador, esas propiedades en el objeto ahora estar&amp;aacute;n disponibles en ese controlador a trav&amp;eacute;s de su f&amp;aacute;brica.</target>
        </trans-unit>
        <trans-unit id="bf79a918a5f8400f69451d6c86a9de8622bc5f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) servicio&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fa71875fc3e6ae341d7d13637af55d62c8e9c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; When you&amp;rsquo;re using &lt;strong&gt;Service&lt;/strong&gt;, AngularJS instantiates it behind the scenes with the &amp;lsquo;new&amp;rsquo; keyword. Because of that, you&amp;rsquo;ll add properties to &amp;lsquo;this&amp;rsquo; and the service will return &amp;lsquo;this&amp;rsquo;. When you pass the service into your controller, those properties on &amp;lsquo;this&amp;rsquo; will now be available on that controller through your service.</source>
          <target state="translated">&lt;strong&gt;2)&lt;/strong&gt; Cuando usa el &lt;strong&gt;Servicio&lt;/strong&gt; , AngularJS lo instancia detr&amp;aacute;s de escena con la palabra clave 'nuevo'. Debido a eso, agregar&amp;aacute; propiedades a 'this' y el servicio devolver&amp;aacute; 'this'. Cuando pasa el servicio a su controlador, esas propiedades en 'esto' ahora estar&amp;aacute;n disponibles en ese controlador a trav&amp;eacute;s de su servicio.</target>
        </trans-unit>
        <trans-unit id="e5e4c731a8abb79b43eb7b7ad7722ae53bd1e526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) Proveedor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7891b22be8f5ced507d3b35a1a21c59dd69ef84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt;&lt;strong&gt;Providers&lt;/strong&gt; are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.</source>
          <target state="translated">&lt;strong&gt;3) Los&lt;/strong&gt; &lt;strong&gt;proveedores&lt;/strong&gt; son el &amp;uacute;nico servicio que puede pasar a su funci&amp;oacute;n .config (). Utilice un proveedor cuando desee proporcionar una configuraci&amp;oacute;n de todo el m&amp;oacute;dulo para su objeto de servicio antes de ponerlo a disposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f7a0bc6a5e55d68fca9019cb4c62b65667302df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Is they do same or have same behaviour?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&amp;iquest;Est&amp;aacute;n haciendo lo mismo o tienen el mismo comportamiento?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a51970d21894731b55def79e30e17e9251193f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Should I use service or factory? What&amp;rsquo;s the difference?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&amp;iquest;Debo usar el servicio o la f&amp;aacute;brica?&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;&amp;iquest;Cual es la diferencia?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61bce34778beb7a07d2ad51ff5e0491a8fe2ce06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And for beginner understand:-&lt;/strong&gt; This may not correct use case but in high level this is what usecase for these three.</source>
          <target state="translated">&lt;strong&gt;Y para los principiantes, comprendan: -&lt;/strong&gt; Esto puede no ser un caso de uso correcto, pero en un nivel alto esto es el caso de uso de estos tres.</target>
        </trans-unit>
        <trans-unit id="49456beeefd4b18f05312ca85704d73c7cc3b7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; the purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.</source>
          <target state="translated">&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; el prop&amp;oacute;sito de Factory tambi&amp;eacute;n es el mismo que el Servicio, sin embargo, en este caso creamos un nuevo objeto y agregamos funciones como propiedades de este objeto y al final devolvemos este objeto.</target>
        </trans-unit>
        <trans-unit id="42188f33ed58db2766909a9db9de01785a8ee47d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Provider:&lt;/strong&gt; the purpose of this is again same however Provider gives the output of it's $get function.</source>
          <target state="translated">&lt;strong&gt;Proveedor de AngularJS:&lt;/strong&gt; el prop&amp;oacute;sito de esto es nuevamente el mismo, sin embargo, el proveedor proporciona la salida de su funci&amp;oacute;n $ get.</target>
        </trans-unit>
        <trans-unit id="9a762ecbec3e860f39ad0b1b9673d2ba4d24939f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Service:&lt;/strong&gt; is used for sharing utility functions with the service reference in the controller. Service is singleton in nature so for one service only one instance is created in the browser and the same reference is used throughout the page.</source>
          <target state="translated">&lt;strong&gt;Servicio AngularJS:&lt;/strong&gt; se utiliza para compartir funciones de utilidad con la referencia de servicio en el controlador. El servicio es de naturaleza &amp;uacute;nica, por lo que para un servicio solo se crea una instancia en el navegador y se usa la misma referencia en toda la p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="ba46456a9f8e88791102b2d89c6c02c5e47d2e18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful with &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Ten cuidado con &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="bf2cbd4114b4edf85514bcf9f1a8b65ee626a848" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best answers from SO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Las mejores respuestas de SO:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867130b32fc3b28fc8ec819aa9caaebbdcd1a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both are Singletons&lt;/strong&gt;: Whenever Angular find these as a dependency first time,it create a single instance of service/factory. Once the instance is created, same instance is used forever.</source>
          <target state="translated">&lt;strong&gt;Ambos son Singletons&lt;/strong&gt; : cada vez que Angular los encuentra como una dependencia por primera vez, crea una &amp;uacute;nica instancia de servicio / f&amp;aacute;brica. Una vez que se crea la instancia, la misma instancia se usa para siempre.</target>
        </trans-unit>
        <trans-unit id="2bfbaa084726b82d3658a48125aa6f2be3899ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be used to model an object with behavior&lt;/strong&gt;: They can both have methods, internal state variables, and so on. Though the way you write that code will differ.</source>
          <target state="translated">&lt;strong&gt;Se puede usar para modelar un objeto con comportamiento&lt;/strong&gt; : ambos pueden tener m&amp;eacute;todos, variables de estado interno, etc. Aunque la forma en que escribes ese c&amp;oacute;digo ser&amp;aacute; diferente.</target>
        </trans-unit>
        <trans-unit id="0b8047b6c925051a75984184c3eab229c2a494da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Constant&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b230b0c6b04da427893e313b7c0e9d5aef5ada3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FACTORY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FACTORY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de8ae60c5e367749c74c70c938263e7f3a66bc7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factories:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="129b6a9da449d3568001d3e4449436c7a83896d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funci&amp;oacute;n de f&amp;aacute;brica:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa83955bc8ebbae5eb9b7e4bea195c0e27d81128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt;
  You simply create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;F&amp;aacute;brica:&lt;/strong&gt; Simplemente crea un objeto dentro de la f&amp;aacute;brica y lo devuelve.</target>
        </trans-unit>
        <trans-unit id="223321a46b7f883db5389221c0e026bc67b2f8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt; The factory you actually create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;F&amp;aacute;brica:&lt;/strong&gt; la f&amp;aacute;brica en la que realmente crea un objeto dentro de la f&amp;aacute;brica y la devuelve.</target>
        </trans-unit>
        <trans-unit id="4b5add3c153ec4e23637c1d8bfc69736e94082eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factory&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74ccee4a3bcbc7b9bc42b630b85b5d7fe42f6f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; and &lt;strong&gt;Service&lt;/strong&gt; are the most commonly used recipes. The only difference between them is that the &lt;strong&gt;Service&lt;/strong&gt; recipe works better for objects of a custom type, while the &lt;strong&gt;Factory&lt;/strong&gt; can produce JavaScript primitives and functions.</source>
          <target state="translated">&lt;strong&gt;F&amp;aacute;brica&lt;/strong&gt; y &lt;strong&gt;servicio&lt;/strong&gt; son las recetas m&amp;aacute;s utilizadas. La &amp;uacute;nica diferencia entre ellos es que la receta de &lt;strong&gt;Servicio&lt;/strong&gt; funciona mejor para objetos de un tipo personalizado, mientras que &lt;strong&gt;Factory&lt;/strong&gt; puede producir funciones y primitivas de JavaScript.</target>
        </trans-unit>
        <trans-unit id="af69167d5e31ec4171b3b71e86c23e55eb8b3ef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; use a factory function which return a service instance.
&lt;strong&gt;serviceInstance = fnFactory();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factory&lt;/strong&gt; usa una funci&amp;oacute;n de f&amp;aacute;brica que devuelve una instancia de servicio. &lt;strong&gt;serviceInstance = fnFactory ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d42eff7ec39af4e9117015764522229b8db7933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;: The value you are providing needs to be calculated based on other data.</source>
          <target state="translated">&lt;strong&gt;F&amp;aacute;brica&lt;/strong&gt; : el valor que proporciona debe calcularse en funci&amp;oacute;n de otros datos.</target>
        </trans-unit>
        <trans-unit id="15a7f656197166d5af0768e868e3d0738e892b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051543166b882d0c0302b61c6fccd2ef13890dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does provider syntax internally work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;C&amp;oacute;mo funciona internamente la sintaxis del proveedor?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f24bbfd879178823cf1a6f4fa4db8fd25d88804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to create a service?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;C&amp;oacute;mo crear un servicio?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15472d9a104bad65c0d954254428090db1217241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazily instantiated&lt;/strong&gt; &amp;ndash; Angular only instantiates a service/factory when an application component depends on it.</source>
          <target state="translated">&lt;strong&gt;Instancia perezosa&lt;/strong&gt; : Angular solo crea una instancia de un servicio / f&amp;aacute;brica cuando un componente de la aplicaci&amp;oacute;n depende de &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="4fc1597dfe992d87dcc418262208d7b520cc2ad4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="048671a3c07af864b3160d99c16b04e4022573ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No TL; DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c27c9c6e707014afaaa93121ac5aee4552e03e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PROVIDER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PROVIDER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e9a7279f005fa392f0780ed27247cdff005c85f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funci&amp;oacute;n de proveedor:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2f1801fb48bf71dd7299a789ae89b7ca28c73fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9463ee84dc44104bf418d730d2dc12c20735e2ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="034f13e153a713ef6e1f67d027f037acfcdca111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; defines a providerConstructor function, this providerConstructor function defines a factory function &lt;strong&gt;$get&lt;/strong&gt; . Angular calls $get() to create the service object. Provider syntax has an added advantage of configuring the service object before it get instantiated.
&lt;strong&gt;serviceInstance = $get();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El proveedor&lt;/strong&gt; define una funci&amp;oacute;n providerConstructor, esta funci&amp;oacute;n providerConstructor define una funci&amp;oacute;n de f&amp;aacute;brica &lt;strong&gt;$ get&lt;/strong&gt; . Llamadas angulares $ get () para crear el objeto de servicio. La sintaxis del proveedor tiene una ventaja adicional de configurar el objeto de servicio antes de que se instancia. &lt;strong&gt;serviceInstance = $ get ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58cb452a8449a0480646f34b32c4f0b2da41ff86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">&lt;strong&gt;El proveedor&lt;/strong&gt; es el tipo de receta m&amp;aacute;s complejo. No lo necesita a menos que est&amp;eacute; creando un c&amp;oacute;digo reutilizable que necesite una configuraci&amp;oacute;n global.</target>
        </trans-unit>
        <trans-unit id="af542f111be3a6b9b5eb1bba21844f854821a94c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; recipe is used mostly in the app config, before the app has fully started/initialized.</source>
          <target state="translated">&lt;strong&gt;La&lt;/strong&gt; receta del &lt;strong&gt;proveedor&lt;/strong&gt; se usa principalmente en la configuraci&amp;oacute;n de la aplicaci&amp;oacute;n, antes de que la aplicaci&amp;oacute;n se haya iniciado / inicializado por completo.</target>
        </trans-unit>
        <trans-unit id="5a61e7a67bd37a0cf34633a672f8ef4ac61746cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;: You want to be able to configure, during the config phase, the object that is going to be created before it&amp;rsquo;s created. Use the Provider mostly in the app config, before the app has fully initialized.</source>
          <target state="translated">&lt;strong&gt;Proveedor&lt;/strong&gt; : desea poder configurar, durante la fase de configuraci&amp;oacute;n, el objeto que se va a crear antes de crearlo. Use el proveedor principalmente en la configuraci&amp;oacute;n de la aplicaci&amp;oacute;n, antes de que la aplicaci&amp;oacute;n se haya inicializado por completo.</target>
        </trans-unit>
        <trans-unit id="1ab8bcf5f1f62f6d12fe01bbd3797bf5f9edaf2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a Value from a &lt;code&gt;Service&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Devoluci&amp;oacute;n de un valor de un &lt;code&gt;Service&lt;/code&gt; &lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d8b225479a57e32c9b9bbce57b80db8803839e1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVICE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;SERVICE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="1723b4864b43191225849524b7490ba00136326d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service vs provider vs factory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Servicio vs proveedor vs f&amp;aacute;brica:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddf188521bbad55d877526ca526e747468a9d8b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c48ba497f0f940a447148665d013066e3821706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3625561b5600fccb382876ffa98f2e89623ad206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; is all about &lt;code&gt;new&lt;/code&gt; keyword actually which as we know does 4 things:</source>
          <target state="translated">&lt;strong&gt;El servicio&lt;/strong&gt; se trata de una &lt;code&gt;new&lt;/code&gt; palabra clave que, como sabemos, hace 4 cosas:</target>
        </trans-unit>
        <trans-unit id="643dc71e1844f583afedf84a3c290ed53ca1a986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; use a constructor function and Angular invoke this constructor function using 'new' keyword for creating the service instance.
&lt;strong&gt;serviceInstance = new fnServiceConstructor();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El servicio&lt;/strong&gt; usa una funci&amp;oacute;n de constructor y Angular invoca esta funci&amp;oacute;n de constructor usando la palabra clave 'new' para crear la instancia de servicio. &lt;strong&gt;serviceInstance = new fnServiceConstructor ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="934fb2b4d6b5561f358e2ea098b02b599fac1ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;: You are returning an object with methods.</source>
          <target state="translated">&lt;strong&gt;Servicio&lt;/strong&gt; : est&amp;aacute; devolviendo un objeto con m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="917d24961ee3bd9397cee700d2697066bdc8ebc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Services:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b86f1f47c5d0e8ae25c0b4bfeddc837fbe553961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Singletons&lt;/strong&gt; &amp;ndash; Each component
  dependent on a service gets a reference to the single instance
  generated by the service factory.</source>
          <target state="translated">&lt;strong&gt;Singletons&lt;/strong&gt; : cada componente que depende de un servicio obtiene una referencia a la instancia &amp;uacute;nica generada por la f&amp;aacute;brica de servicios.</target>
        </trans-unit>
        <trans-unit id="236552a9e0c737f0dce61f3fd278300c81df52c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;digo fuente de f&amp;aacute;brica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dca20d5f0cc36fd7219eb42b9a3bd59a5f14fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;digo fuente de servicio&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3ab06d46eba0ea55e3a63532b502c8e68aaf041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntactic Sugar is the difference&lt;/strong&gt;. Only provider is needed. Or in other words only provider is the real angular, all other ones are derived(to reduce code). There is a simple version as well, called Value()  which returns just the value, no calculation or function. Even Value is derived from provider!</source>
          <target state="translated">&lt;strong&gt;El az&amp;uacute;car sint&amp;aacute;ctico es la diferencia&lt;/strong&gt; . Solo se necesita proveedor. O, en otras palabras, el &amp;uacute;nico proveedor es el angular real, todos los dem&amp;aacute;s se derivan (para reducir el c&amp;oacute;digo). Tambi&amp;eacute;n hay una versi&amp;oacute;n simple, llamada Value () que devuelve solo el valor, sin c&amp;aacute;lculo ni funci&amp;oacute;n. &amp;iexcl;Incluso el valor se deriva del proveedor!</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5f0f8f2415dfbd7ea64cb1c92c78ef8982eb6db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The major differences among Services, Factories, and Providers are their complexities. Services are the simplest form, Factories are a little more robust, and Providers are configurable at runtime.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Las principales diferencias entre servicios, f&amp;aacute;bricas y proveedores son sus complejidades.&lt;/strong&gt; &lt;strong&gt;Los servicios son la forma m&amp;aacute;s simple, las f&amp;aacute;bricas son un poco m&amp;aacute;s robustas y los proveedores son configurables en tiempo de ejecuci&amp;oacute;n.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5265dba3d641afcb7e0148f9229e5a29c5cbf0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding AngularJS Factory, Service and Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Comprensi&amp;oacute;n de AngularJS Factory, Service y Provider&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="372f60334aa5d8918e891d52c780ab816ff7ba23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="761726747ff7c1d3bd1aef8307caf8babe873bd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4167298ff7e32e5b1773e3433a0f0e71939b8a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Service:&lt;/strong&gt;
In AngularJS, &lt;strong&gt;Service&lt;/strong&gt; is nothing but a singleton JavaScript object which can store some useful methods or properties. This singleton object is created per ngApp(Angular app) basis and it is shared among all the controllers within current app. When Angularjs instantiate a service object, it register this service object with a unique service name. So each time when we need service instance, Angular search the registry for this service name, and it returns the reference to service object. Such that we can invoke method, access properties etc on the service object.
You may have question whether you can also put properties, methods on scope object of controllers! So why you need service object? Answers is: services are shared among multiple controller scope. If you put some properties/methods in a controller's scope object , it will be available to current scope only. But when you define methods, properties on service object, it will be available globally and can be accessed in any  controller's scope by injecting that service.</source>
          <target state="translated">&lt;strong&gt;Qu&amp;eacute; es el servicio:&lt;/strong&gt; en AngularJS, el &lt;strong&gt;servicio&lt;/strong&gt; no es m&amp;aacute;s que un objeto JavaScript &amp;uacute;nico que puede almacenar algunos m&amp;eacute;todos o propiedades &amp;uacute;tiles. Este objeto singleton se crea por ngApp (aplicaci&amp;oacute;n angular) y se comparte entre todos los controladores dentro de la aplicaci&amp;oacute;n actual. Cuando Angularjs crea una instancia de un objeto de servicio, registra este objeto de servicio con un nombre de servicio &amp;uacute;nico. Entonces, cada vez que necesitamos una instancia de servicio, Angular busca en el registro este nombre de servicio y devuelve la referencia al objeto de servicio. De modo que podamos invocar el m&amp;eacute;todo, acceder a propiedades, etc. en el objeto de servicio. &amp;iexcl;Puede tener dudas sobre si tambi&amp;eacute;n puede poner propiedades, m&amp;eacute;todos en el objeto de alcance de los controladores! Entonces, &amp;iquest;por qu&amp;eacute; necesita un objeto de servicio? Las respuestas son: los servicios se comparten entre el alcance del controlador m&amp;uacute;ltiple. Si coloca algunas propiedades / m&amp;eacute;todos en el objeto de alcance de un controlador, estar&amp;aacute; disponible solo para el alcance actual. Pero cuando define m&amp;eacute;todos, propiedades en el objeto de servicio, estar&amp;aacute; disponible globalmente y se puede acceder en el alcance de cualquier controlador inyectando ese servicio.</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e41544278c3c3cd14f313568ad2ca9b33654a735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7c38fc9331c68d06c6051d868ab8034c6a1b71f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5fb6e5fc13a01937ae02611fcad859574413d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index.html&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;index.html&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd88803cf5db529cfe7cb230c25afc9af0e166" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;provider:&lt;/strong&gt; The provider there&amp;rsquo;s a $get you define and it can be used to get the object that returns the data.</source>
          <target state="translated">&lt;strong&gt;proveedor:&lt;/strong&gt; El proveedor tiene un $ get que usted define y puede usarse para obtener el objeto que devuelve los datos.</target>
        </trans-unit>
        <trans-unit id="8592d58f6159c5178f21fdbf4b05247f87defaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;service:&lt;/strong&gt; The service you just have a standard function that uses the this keyword to define function.</source>
          <target state="translated">&lt;strong&gt;servicio:&lt;/strong&gt; el servicio solo tiene una funci&amp;oacute;n est&amp;aacute;ndar que utiliza la palabra clave this para definir la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6460b1c41e40026d826a70fb0ec47b36aaed8244" translate="yes" xml:space="preserve">
          <source>A factory is a plain old function that returns a value. The return value is what gets injected into things that depend on the factory. A typical factory pattern in Angular is to return an object with functions as properties, like this:</source>
          <target state="translated">Una fábrica es una simple función que devuelve un valor.El valor de retorno es lo que se inyecta en las cosas que dependen de la fábrica.Un patrón típico de fábrica en Angular es devolver un objeto con funciones como propiedades,como esta:</target>
        </trans-unit>
        <trans-unit id="6654378b8441365d9dbee921cd9c4b6d04ad1238" translate="yes" xml:space="preserve">
          <source>A factory is function where you can manipulate/add logic before creating an object, then the newly created object gets returned.</source>
          <target state="translated">Una fábrica es una función en la que se puede manipular la lógica antes de crear un objeto,luego el objeto recién creado es devuelto.</target>
        </trans-unit>
        <trans-unit id="92657294903a95f8b7ea12e4be26ab19bd209d60" translate="yes" xml:space="preserve">
          <source>A more general value, that is possible to be computed right away. It works by passing a function to AngularJS with the logic needed to compute the value and AngularJS executes it, and it saves the return value in the named variable.</source>
          <target state="translated">Un valor más general,que es posible calcular de inmediato.Funciona pasando una función a AngularJS con la lógica necesaria para calcular el valor y AngularJS la ejecuta,y guarda el valor de retorno en la variable nombrada.</target>
        </trans-unit>
        <trans-unit id="c98519712b1bcd2194f1ab8049f9c95b677e57e2" translate="yes" xml:space="preserve">
          <source>A provider
= must contain a property called $get (+Factory, + Service, + Value)</source>
          <target state="translated">Un proveedor=debe contener una propiedad llamada $get (+Fábrica,+Servicio,+Valor)</target>
        </trans-unit>
        <trans-unit id="70cc8179c33c6143e3fd269921c56cce6794df6a" translate="yes" xml:space="preserve">
          <source>A provider is used to create a configurable service object. You can configure the service setting from config function. It returns a value by using the &lt;code&gt;$get()&lt;/code&gt; function. The &lt;code&gt;$get&lt;/code&gt; function gets executed on the run phase in angular.</source>
          <target state="translated">Un proveedor se utiliza para crear un objeto de servicio configurable. Puede configurar el servicio desde la funci&amp;oacute;n config. Devuelve un valor utilizando la funci&amp;oacute;n &lt;code&gt;$get()&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;$get&lt;/code&gt; se ejecuta en la fase de ejecuci&amp;oacute;n en angular.</target>
        </trans-unit>
        <trans-unit id="2690ab0e17349d256212ca0a5c254ff9f7224715" translate="yes" xml:space="preserve">
          <source>A provider that can
instantiate + do something = Service (+ Factory, + Value)</source>
          <target state="translated">Un proveedor que puede instanciar+hacer algo=Servicio (+Fábrica,+Valor)</target>
        </trans-unit>
        <trans-unit id="1552cdef3a8c9efd2ca6378e425896d47cd0a7d2" translate="yes" xml:space="preserve">
          <source>A provider that can just
instantiate and return = Factory (+ Value)</source>
          <target state="translated">Un proveedor que puede simplemente instanciar y regresar=Fábrica (+Valor)</target>
        </trans-unit>
        <trans-unit id="5bac4ef74fca1e1f11c40a61c18eb5751a56a24e" translate="yes" xml:space="preserve">
          <source>A provider that can return value = Value</source>
          <target state="translated">Un proveedor que puede devolver el valor=Valor</target>
        </trans-unit>
        <trans-unit id="daa9ad8c9da39c96b0cd1b5e9b85ad76ef92e025" translate="yes" xml:space="preserve">
          <source>A service is a constructor function, and Angular will instantiate it by calling new &lt;code&gt;yourServiceName()&lt;/code&gt;. This means a couple of things.</source>
          <target state="translated">Un servicio es una funci&amp;oacute;n constructora, y Angular lo instanciar&amp;aacute; llamando al nuevo &lt;code&gt;yourServiceName()&lt;/code&gt; . Esto significa un par de cosas.</target>
        </trans-unit>
        <trans-unit id="f30916da78a012d617c7c608b91dd4f9e4ccb7cc" translate="yes" xml:space="preserve">
          <source>A service is a more stripped-down version of &lt;em&gt;factory&lt;/em&gt; which is valid only when the value is an object, and it allows for writing any logic directly in the function (as if it would be a constructor), as well as declaring and accessing the object properties using the &lt;em&gt;this&lt;/em&gt; keyword.</source>
          <target state="translated">Un servicio es una versi&amp;oacute;n m&amp;aacute;s simplificada de &lt;em&gt;f&amp;aacute;brica&lt;/em&gt; que es v&amp;aacute;lida solo cuando el valor es un objeto, y permite escribir cualquier l&amp;oacute;gica directamente en la funci&amp;oacute;n (como si fuera un constructor), as&amp;iacute; como declarar y acceder al propiedades de objeto utilizando la palabra clave &lt;em&gt;this&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e010047a835b4f08a52ebcf31da9133c3b0c83eb" translate="yes" xml:space="preserve">
          <source>Ability to use other services (have dependencies)</source>
          <target state="translated">Capacidad de utilizar otros servicios (tener dependencias)</target>
        </trans-unit>
        <trans-unit id="90d836d3d0cb6acecac1372abfaeed5f7a898db3" translate="yes" xml:space="preserve">
          <source>After reading all these post It created more confuse for me.. But still all is worthfull information.. finally I found following table which will give information with simple comparision</source>
          <target state="translated">Después de leer todos estos mensajes me creó más confusión...Pero aún así todo es información valiosa ...finalmente encontré la siguiente tabla que dará información con una simple comparación</target>
        </trans-unit>
        <trans-unit id="eba926c51e345f5492b036b8fb2838c80ca0f326" translate="yes" xml:space="preserve">
          <source>Ajax call or third party integrations needs to be &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">La llamada Ajax o las integraciones de terceros deben ser &lt;strong&gt;servicio&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="db39b22c1144a74c69ee802842ea57e37d383130" translate="yes" xml:space="preserve">
          <source>All Services are &lt;strong&gt;singletons&lt;/strong&gt;; they get instantiated once per app. They can be &lt;strong&gt;of any type&lt;/strong&gt;, whether it be a primitive, object literal, function, or even an instance of a custom type.</source>
          <target state="translated">Todos los servicios son &lt;strong&gt;singletons&lt;/strong&gt; ; se instancian una vez por aplicaci&amp;oacute;n. Pueden ser &lt;strong&gt;de cualquier tipo&lt;/strong&gt; , ya sea primitivo, literal de objeto, funci&amp;oacute;n o incluso una instancia de un tipo personalizado.</target>
        </trans-unit>
        <trans-unit id="44b4a8e5249ee92bb57692eb4f38230e89ca0b32" translate="yes" xml:space="preserve">
          <source>All of these are used to share reusable singleton objects. It helps to share reusable code across your app/various components/modules.</source>
          <target state="translated">Todos ellos se utilizan para compartir objetos reutilizables de un solo uso.Ayuda a compartir el código reutilizable a través de sus diversos módulos de componentes.</target>
        </trans-unit>
        <trans-unit id="15074bf6692ab4d76bbae6a637a1292c7beea479" translate="yes" xml:space="preserve">
          <source>All special purpose objects except for the Controller are defined via Factory recipes.</source>
          <target state="translated">Todos los objetos de propósito especial,excepto el Controlador,se definen a través de las recetas de la Fábrica.</target>
        </trans-unit>
        <trans-unit id="1797d93eba62a3e50c0f75705fc2654c1c5d7cc1" translate="yes" xml:space="preserve">
          <source>All the good answers already. I would like to add few more points on &lt;strong&gt;Service&lt;/strong&gt; and &lt;strong&gt;Factory&lt;/strong&gt;. Along with the difference between service/factory. And  one can also have questions like:</source>
          <target state="translated">Todas las buenas respuestas ya. Me gustar&amp;iacute;a agregar algunos puntos m&amp;aacute;s en &lt;strong&gt;Servicio&lt;/strong&gt; y &lt;strong&gt;F&amp;aacute;brica&lt;/strong&gt; . Junto con la diferencia entre servicio / f&amp;aacute;brica. Y uno tambi&amp;eacute;n puede tener preguntas como:</target>
        </trans-unit>
        <trans-unit id="644fa5425851502f8b0f2b6d2e894a7a71bc764b" translate="yes" xml:space="preserve">
          <source>An additional clarification is that factories can create functions/primitives, while services cannot. Check out this &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; based on Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt;.</source>
          <target state="translated">Una aclaraci&amp;oacute;n adicional es que las f&amp;aacute;bricas pueden crear funciones / primitivas, mientras que los servicios no. Echa un vistazo a este &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; basado en Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1698cdf07eaa30b1f4d2eb589b401f5aa7c167b5" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Factory&lt;/strong&gt; is all about Factory Pattern - contains functions that return Objects like that Service.</source>
          <target state="translated">Y &lt;strong&gt;Factory&lt;/strong&gt; se trata de Factory Pattern: contiene funciones que devuelven objetos como ese Servicio.</target>
        </trans-unit>
        <trans-unit id="087105228646ef19c5b815759ef3bd7c8d79035e" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Value, Factory, Service and Constant&lt;/strong&gt; (4 ways) - the syntactic sugar over &lt;strong&gt;Provider&lt;/strong&gt; way/recepie.</source>
          <target state="translated">Y &lt;strong&gt;Valor, F&amp;aacute;brica, Servicio y Constante&lt;/strong&gt; (4 formas): el az&amp;uacute;car sint&amp;aacute;ctico sobre la forma / recepci&amp;oacute;n del &lt;strong&gt;Proveedor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a4a0d683875e15a20d100e9c4f3cabe527897b12" translate="yes" xml:space="preserve">
          <source>And a better answer would be this:
&quot;An Angular service is created by a service factory. These service factories are functions which, in turn, are created by a service provider. The service providers are constructor functions. When instantiated they must contain a property called $get, which holds the service factory function.&quot;</source>
          <target state="translated">Y una mejor respuesta sería esta:&quot;Un servicio angular es creado por una fábrica de servicios.Estas fábricas de servicios son funciones que,a su vez,son creadas por un proveedor de servicios.Los proveedores de servicios son funciones de construcción.Cuando se instancian deben contener una propiedad llamada $get,que contiene la función de la fábrica de servicios.&quot;</target>
        </trans-unit>
        <trans-unit id="6e1a1be7a3c89b4a49965d6931152adc8b79b49f" translate="yes" xml:space="preserve">
          <source>And this simple/short video: covers also &lt;strong&gt;Provider&lt;/strong&gt;: &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (there you see can see how they go from factory to provider)</source>
          <target state="translated">Y este video simple / corto: cubre tambi&amp;eacute;n &lt;strong&gt;Proveedor&lt;/strong&gt; : &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (all&amp;iacute; puede ver c&amp;oacute;mo van de f&amp;aacute;brica a proveedor)</target>
        </trans-unit>
        <trans-unit id="5e753d8417cbbaa903d75c9067f03b753d972dae" translate="yes" xml:space="preserve">
          <source>Angular injection gives us the first hint in reaching this conclusion.</source>
          <target state="translated">La inyección angular nos da la primera pista para llegar a esta conclusión.</target>
        </trans-unit>
        <trans-unit id="c0fbc9b675108602e2b9fac4e8674fd1d9ad2553" translate="yes" xml:space="preserve">
          <source>AngularJS provide different methods to register a service. Here we will concentrate on three methods factory(..),service(..),provider(..);</source>
          <target state="translated">AngularJS proporciona diferentes métodos para registrar un servicio.Aquí nos concentraremos en tres métodos:factory(..),service(..),provider(..);</target>
        </trans-unit>
        <trans-unit id="a2a043dede3ac539ee64b89b2d49b7bd51e23891" translate="yes" xml:space="preserve">
          <source>AngularJS provides &lt;strong&gt;'factory('serviceName', fnFactory)'&lt;/strong&gt; method which takes two parameter, serviceName and a JavaScript function. Angular creates service instance by invoking the function &lt;strong&gt;fnFactory()&lt;/strong&gt; such as below.</source>
          <target state="translated">AngularJS proporciona &lt;strong&gt;el&lt;/strong&gt; m&amp;eacute;todo &lt;strong&gt;'factory (' serviceName ', fnFactory)'&lt;/strong&gt; que toma dos par&amp;aacute;metros, serviceName y una funci&amp;oacute;n de JavaScript. Angular crea una instancia de servicio invocando la funci&amp;oacute;n &lt;strong&gt;fnFactory ()&lt;/strong&gt; como se muestra a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="67487acbc494fde4c0ecdb230e55c47bdc819cc5" translate="yes" xml:space="preserve">
          <source>AngularJS: Service vs provider vs factory</source>
          <target state="translated">AngularJS:Servicio vs.Proveedor vs.Fábrica</target>
        </trans-unit>
        <trans-unit id="62b46f141dc945f1baeeda1b182a386db6799d55" translate="yes" xml:space="preserve">
          <source>Answers for above 1 and 2 questions:</source>
          <target state="translated">Respuestas para las preguntas anteriores 1 y 2:</target>
        </trans-unit>
        <trans-unit id="f5181cbde0884af842b881fdae06a3ba0616e0a1" translate="yes" xml:space="preserve">
          <source>As a side note, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; are all derived from provider.</source>
          <target state="translated">Como nota al margen, el &lt;code&gt;service&lt;/code&gt; , la &lt;code&gt;factory&lt;/code&gt; y el &lt;code&gt;value&lt;/code&gt; se derivan del proveedor.</target>
        </trans-unit>
        <trans-unit id="b8e0a3698c74b06188537beb6504f05ed6da8541" translate="yes" xml:space="preserve">
          <source>As mentioned before, the whole point of creating a service with Provider is to be able to alter some variables through the app.config function before the final object is passed to the rest of the application. Let&amp;rsquo;s see an example of that.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, el objetivo de crear un servicio con el Proveedor es poder alterar algunas variables a trav&amp;eacute;s de la funci&amp;oacute;n app.config antes de que el objeto final se pase al resto de la aplicaci&amp;oacute;n. Veamos un ejemplo de eso.</target>
        </trans-unit>
        <trans-unit id="ac8bd4adf742322d3119e359d466fd027d4a144c" translate="yes" xml:space="preserve">
          <source>As pointed out by several people here correctly a factory, provider, service, and even value and constant are versions of the same thing. You can dissect the more general &lt;code&gt;provider&lt;/code&gt; into all of them. Like so:</source>
          <target state="translated">Como se&amp;ntilde;alan varias personas aqu&amp;iacute; correctamente, una f&amp;aacute;brica, un proveedor, un servicio e incluso un valor constante son versiones de lo mismo. Puede diseccionar el &lt;code&gt;provider&lt;/code&gt; m&amp;aacute;s general en todos ellos. Al igual que:</target>
        </trans-unit>
        <trans-unit id="7ac115d7759453df5c7a6ee0d961bac591936f70" translate="yes" xml:space="preserve">
          <source>Basically all of the mentioned types (service, factory, provider, etc.) are just creating and configuring global variables (that are of course global to the entire application), just as old fashioned global variables were.</source>
          <target state="translated">Básicamente todos los tipos mencionados (servicio,fábrica,proveedor,etc.)sólo crean y configuran variables globales (que por supuesto son globales para toda la aplicación),tal como lo eran las antiguas variables globales.</target>
        </trans-unit>
        <trans-unit id="76a6d228807b2f0db9ca8817dcc7b6fe1992e7f5" translate="yes" xml:space="preserve">
          <source>Below &lt;strong&gt;setArtist&lt;/strong&gt; accepts an artist and allows you to set the artist. &lt;strong&gt;getArtist&lt;/strong&gt; returns the artist. &lt;strong&gt;callItunes&lt;/strong&gt; first calls makeUrl() in order to build the URL we&amp;rsquo;ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying &amp;lsquo;There was an error&amp;rsquo;.</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;strong&gt;setArtist&lt;/strong&gt; acepta un artista y le permite configurarlo. &lt;strong&gt;getArtist&lt;/strong&gt; devuelve el artista. &lt;strong&gt;callItunes&lt;/strong&gt; primero llama a makeUrl () para construir la URL que usaremos con nuestra solicitud $ http. Luego configura un objeto de promesa, realiza una solicitud de $ http con nuestra url final, luego, debido a que $ http devuelve una promesa, podemos llamar a .success o .error despu&amp;eacute;s de nuestra solicitud. Luego resolvemos nuestra promesa con los datos de iTunes, o la rechazamos con un mensaje que dice 'Hubo un error'.</target>
        </trans-unit>
        <trans-unit id="ecc9654f84abda3f226923e7181cd6dedcabf706" translate="yes" xml:space="preserve">
          <source>Below is code for how you can think about what the &amp;lsquo;new&amp;rsquo; keyword is actually doing in JavaScript. It&amp;rsquo;s basically a code example of the above paragraph. I&amp;rsquo;ve put the &amp;lsquo;interpreter view&amp;rsquo; or the way the interpreter sees the code inside of notes.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un c&amp;oacute;digo de c&amp;oacute;mo puede pensar qu&amp;eacute; est&amp;aacute; haciendo la palabra clave 'nueva' en JavaScript. B&amp;aacute;sicamente es un ejemplo de c&amp;oacute;digo del p&amp;aacute;rrafo anterior. Puse la 'vista del int&amp;eacute;rprete' o la forma en que el int&amp;eacute;rprete ve el c&amp;oacute;digo dentro de las notas.</target>
        </trans-unit>
        <trans-unit id="baeffb61d23b4b1a1faec7ea79fc7982401fe040" translate="yes" xml:space="preserve">
          <source>But if you declare an AngularJS &quot;value&quot; (for example., &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt;), you can inject it into services and factories, but NOT into the provider-creating function. You can, however, inject it into the &lt;code&gt;$get&lt;/code&gt; function that you define for your provider. This is mentioned in the AngularJS documentation, but it's easy to miss. You can find it on the %provide page in the sections on the value and constant methods.</source>
          <target state="translated">Pero si declara un &quot;valor&quot; de AngularJS (por ejemplo, &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt; ), puede inyectarlo en servicios y f&amp;aacute;bricas, pero NO en la funci&amp;oacute;n de creaci&amp;oacute;n de proveedores. . Sin embargo, puede inyectarlo en la funci&amp;oacute;n &lt;code&gt;$get&lt;/code&gt; que defina para su proveedor. Esto se menciona en la documentaci&amp;oacute;n de AngularJS, pero es f&amp;aacute;cil pasarlo por alto. Puede encontrarlo en la p&amp;aacute;gina% provide en las secciones sobre el valor y los m&amp;eacute;todos constantes.</target>
        </trans-unit>
        <trans-unit id="e1cc6d183fce2197bb4d499453f325c6ce15d621" translate="yes" xml:space="preserve">
          <source>But that is way too wordy. A shorter way to write this would be &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</source>
          <target state="translated">Pero eso es demasiado prolijo. Una forma m&amp;aacute;s corta de escribir esto ser&amp;iacute;a &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0b23422a6346dcd33f9ef7c177b5c4c2e0c0ba5" translate="yes" xml:space="preserve">
          <source>But what if we wanted to configure the &lt;code&gt;Greeter&lt;/code&gt; class before the injection? Then we could write</source>
          <target state="translated">Pero, &amp;iquest;y si quisi&amp;eacute;ramos configurar la clase &lt;code&gt;Greeter&lt;/code&gt; antes de la inyecci&amp;oacute;n? Entonces podr&amp;iacute;amos escribir</target>
        </trans-unit>
        <trans-unit id="83edd94ef1f4218a2a09268ba1c79454b4d8ce41" translate="yes" xml:space="preserve">
          <source>But what if you want to be more OO and have a class called Greeter?</source>
          <target state="translated">¿Pero qué pasa si quieres ser más OO y tener una clase llamada Greeter?</target>
        </trans-unit>
        <trans-unit id="bead6ae023dd1ddfc66d0c3554dd68115419ed4a" translate="yes" xml:space="preserve">
          <source>Code posted here is copied straight from the above source, to benefit readers.</source>
          <target state="translated">El código publicado aquí se copia directamente de la fuente anterior,para beneficiar a los lectores.</target>
        </trans-unit>
        <trans-unit id="d3a3e026964278d33abfaf0d31b51f4e99ed0a5a" translate="yes" xml:space="preserve">
          <source>Defining and using Service, Factory and Provider are explained at &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;</source>
          <target state="translated">La definici&amp;oacute;n y el uso del Servicio, F&amp;aacute;brica y Proveedor se explican en &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d0d609d4405f2baa362951b7009d2417093fd7d" translate="yes" xml:space="preserve">
          <source>Delayed/lazy initialization</source>
          <target state="translated">Inicialización retardada</target>
        </trans-unit>
        <trans-unit id="cb560adb9a207096df4103f0ce35af068e58441a" translate="yes" xml:space="preserve">
          <source>Due to how JavaScript constructors work, if you return a complex value &lt;code&gt;(i.e., an Object)&lt;/code&gt; from a &lt;code&gt;constructor&lt;/code&gt; function, the caller will get that Object instead of the this instance.</source>
          <target state="translated">Debido a c&amp;oacute;mo funcionan los constructores de JavaScript, si devuelve un valor complejo &lt;code&gt;(i.e., an Object)&lt;/code&gt; de una funci&amp;oacute;n de &lt;code&gt;constructor&lt;/code&gt; , la persona que llama obtendr&amp;aacute; ese Objeto en lugar de esta instancia.</target>
        </trans-unit>
        <trans-unit id="0ce56bb9d7649bd1affa9d15ef3b25e94ed4bf16" translate="yes" xml:space="preserve">
          <source>Essentially, Provider, Factory, and Service are all Services. A Factory is a special case of a Service when all you need is a $get() function, allowing you to write it with less code.</source>
          <target state="translated">Esencialmente,el proveedor,la fábrica y el servicio son todos servicios.Una Fábrica es un caso especial de un Servicio cuando todo lo que necesitas es una función $get(),que te permite escribirlo con menos código.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="5871c248f6153cd0a547c43f6815327faa66746e" translate="yes" xml:space="preserve">
          <source>Factories are the most popular way to create and configure a service. There&amp;rsquo;s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below.</source>
          <target state="translated">Las f&amp;aacute;bricas son la forma m&amp;aacute;s popular de crear y configurar un servicio. Realmente no hay mucho m&amp;aacute;s de lo que dice el TL; DR. Simplemente crea un objeto, le agrega propiedades y luego devuelve el mismo objeto. Luego, cuando pase la f&amp;aacute;brica a su controlador, esas propiedades en el objeto ahora estar&amp;aacute;n disponibles en ese controlador a trav&amp;eacute;s de su f&amp;aacute;brica. Un ejemplo m&amp;aacute;s extenso est&amp;aacute; abajo.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="c8e6696140d2e75575a027e3db926b81e7fa86b8" translate="yes" xml:space="preserve">
          <source>Factory and Service are the most commonly used recipes. The only difference between them is that the Service recipe works better for objects of a custom type, while the Factory can produce JavaScript primitives and functions.</source>
          <target state="translated">La fábrica y el servicio son las recetas más utilizadas.La única diferencia entre ellas es que la receta de Servicio funciona mejor para objetos de tipo personalizado,mientras que la Fábrica puede producir primitivas y funciones de JavaScript.</target>
        </trans-unit>
        <trans-unit id="7ee844ac41ac4ad9686ec614f908d3bdcb5b3e81" translate="yes" xml:space="preserve">
          <source>Factory is a class. Use factories if you want to provide custom classes for your code (can't be done with services because they are already instantiated).</source>
          <target state="translated">La fábrica es una clase.Usa las fábricas si quieres proporcionar clases personalizadas para tu código (no se puede hacer con los servicios porque ya están instanciados).</target>
        </trans-unit>
        <trans-unit id="c43d055974d1f89c7db6d2a6f06d9706cf84359d" translate="yes" xml:space="preserve">
          <source>Features of Factory:</source>
          <target state="translated">Características de la fábrica:</target>
        </trans-unit>
        <trans-unit id="8f233e0733ea2bd7573612519e22b6483ee2aae2" translate="yes" xml:space="preserve">
          <source>Features of Provider:</source>
          <target state="translated">Características del proveedor:</target>
        </trans-unit>
        <trans-unit id="8b33d5b1a4171b12f08419f5a3175c6118df72b0" translate="yes" xml:space="preserve">
          <source>Features of Service:</source>
          <target state="translated">Características del servicio:</target>
        </trans-unit>
        <trans-unit id="555321235e9eb2d0c7b4fff9ef2c877ead66f84d" translate="yes" xml:space="preserve">
          <source>Finally the UI which works with any of the above services:</source>
          <target state="translated">Finalmente,la UI que trabaja con cualquiera de los servicios anteriores:</target>
        </trans-unit>
        <trans-unit id="aa41b2f6147d97e7462dbecaf90f19a90ed1b067" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s create our Constructor.</source>
          <target state="translated">Primero creemos nuestro Constructor.</target>
        </trans-unit>
        <trans-unit id="dfb58a29f6c2cb946fda2080d277aff94876b78f" translate="yes" xml:space="preserve">
          <source>First let's have a look at the syntax:</source>
          <target state="translated">Primero echemos un vistazo a la sintaxis:</target>
        </trans-unit>
        <trans-unit id="16ae293f476b801e0ec98c3b0c772f3098dc7e49" translate="yes" xml:space="preserve">
          <source>First of all, let's talk about &lt;strong&gt;services&lt;/strong&gt; in AngularJS!</source>
          <target state="translated">En primer lugar, &amp;iexcl;hablemos de los &lt;strong&gt;servicios&lt;/strong&gt; en AngularJS!</target>
        </trans-unit>
        <trans-unit id="f626e9e8c764b63df367572217b72dfec8d3d0d8" translate="yes" xml:space="preserve">
          <source>First of all: &lt;strong&gt;Provider&lt;/strong&gt; is the way/recipe to create a &lt;code&gt;service&lt;/code&gt; (singleton object) that suppose to be injected by $injector (how AngulaJS goes about IoC pattern).</source>
          <target state="translated">En primer lugar: el &lt;strong&gt;proveedor&lt;/strong&gt; es la forma / receta para crear un &lt;code&gt;service&lt;/code&gt; (objeto singleton) que se supone que es inyectado por $ injector (c&amp;oacute;mo AngulaJS aplica el patr&amp;oacute;n IoC).</target>
        </trans-unit>
        <trans-unit id="a7d7fe2894bd6c66d071f952d684e2326b49b1e5" translate="yes" xml:space="preserve">
          <source>First things first, let&amp;rsquo;s create our &amp;lsquo;private&amp;rsquo; and helper function. This should look very familiar since we did the exact same thing with our factory. I won&amp;rsquo;t explain what each line does here because I did that in the factory example, if you&amp;rsquo;re confused, re-read the factory example.</source>
          <target state="translated">Primero lo primero, creemos nuestra funci&amp;oacute;n 'privada' y auxiliar. Esto deber&amp;iacute;a parecer muy familiar ya que hicimos exactamente lo mismo con nuestra f&amp;aacute;brica. No explicar&amp;eacute; qu&amp;eacute; hace cada l&amp;iacute;nea aqu&amp;iacute; porque lo hice en el ejemplo de f&amp;aacute;brica, si est&amp;aacute; confundido, vuelva a leer el ejemplo de f&amp;aacute;brica.</target>
        </trans-unit>
        <trans-unit id="274879ea02d1b32f25fdcf0d6f4b8638ad84e454" translate="yes" xml:space="preserve">
          <source>First we set up our Provider in a similar way we did with our Service and Factory. The variables below are our &amp;lsquo;private&amp;rsquo; and helper function.</source>
          <target state="translated">Primero configuramos nuestro Proveedor de una manera similar a como lo hicimos con nuestro Servicio y F&amp;aacute;brica. Las siguientes variables son nuestra funci&amp;oacute;n 'privada' y auxiliar.</target>
        </trans-unit>
        <trans-unit id="0f18e05a1a2cf2fab2012ea1acb85960d14f94f3" translate="yes" xml:space="preserve">
          <source>Follows the factory design pattern. The factory is a central place that produces new objects or functions.</source>
          <target state="translated">Sigue el patrón de diseño de la fábrica.La fábrica es un lugar central que produce nuevos objetos o funciones.</target>
        </trans-unit>
        <trans-unit id="124166829dcd8ce12e68c97aa74ddc87e6f4700c" translate="yes" xml:space="preserve">
          <source>For Data manipulations create it as &lt;strong&gt;factory&lt;/strong&gt;</source>
          <target state="translated">Para manipulaciones de datos, cr&amp;eacute;elo como &lt;strong&gt;f&amp;aacute;brica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d4008d04bf8dc913dd361a11d1dbf2dd7fff6d9" translate="yes" xml:space="preserve">
          <source>For basic scenarios factory&amp;amp;Service behaves same.</source>
          <target state="translated">Para escenarios b&amp;aacute;sicos, la f&amp;aacute;brica y el servicio se comportan igual.</target>
        </trans-unit>
        <trans-unit id="be44b8b9aee8e49c0f525f0d589dc7ae0563c459" translate="yes" xml:space="preserve">
          <source>For me the best and the simplest way of understanding the difference is:</source>
          <target state="translated">Para mí,la mejor y más simple manera de entender la diferencia es:</target>
        </trans-unit>
        <trans-unit id="56ff743259acbed742d59f1071ec5c09de91c4a2" translate="yes" xml:space="preserve">
          <source>For me, the revelation came when I realized that they all work the same way: by running something &lt;strong&gt;once&lt;/strong&gt;, storing the value they get, and then cough up &lt;strong&gt;that same stored value&lt;/strong&gt; when referenced through &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">Para m&amp;iacute;, la revelaci&amp;oacute;n lleg&amp;oacute; cuando me di cuenta de que todos funcionan de la misma manera: ejecutando algo &lt;strong&gt;una vez&lt;/strong&gt; , almacenando el valor que obtienen, y luego tosiendo &lt;strong&gt;ese mismo valor almacenado&lt;/strong&gt; cuando se hace referencia a trav&amp;eacute;s de &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;la inyecci&amp;oacute;n de dependencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b27ee14ba7c9338b5357168645fc5fca69baff87" translate="yes" xml:space="preserve">
          <source>For more details, see a post I wrote on the difference: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</source>
          <target state="translated">Para m&amp;aacute;s detalles, vea una publicaci&amp;oacute;n que escrib&amp;iacute; sobre la diferencia: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd35023ca5fbcbbe13f3b8c3e423caa7232e2d3e" translate="yes" xml:space="preserve">
          <source>For the most part, just stick with using factories for everything.
  Their behavior is easier to understand. There&amp;rsquo;s no choice to make
  about whether to return a value or not, and furthermore, no bugs to be
  introduced if you do the wrong thing.</source>
          <target state="translated">En su mayor parte, simplemente use las f&amp;aacute;bricas para todo. Su comportamiento es m&amp;aacute;s f&amp;aacute;cil de entender. No hay que elegir si devolver un valor o no, y adem&amp;aacute;s, no se introducir&amp;aacute;n errores si haces lo incorrecto.</target>
        </trans-unit>
        <trans-unit id="6bc24d8b9740765e38f68d62a235ac7b05a3ba82" translate="yes" xml:space="preserve">
          <source>From Docs &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Service/Factory&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">Del &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Servicio de&lt;/strong&gt;&lt;/a&gt; Documentos &lt;strong&gt;/ F&amp;aacute;brica&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f49fa588c62b7f2f5abba55d1b95ecf06f622095" translate="yes" xml:space="preserve">
          <source>From the AngularJS mailing list I got &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;an amazing thread&lt;/a&gt; that explains service vs factory vs provider and their injection usage. Compiling the answers:</source>
          <target state="translated">De la lista de correo de AngularJS obtuve &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;un hilo incre&amp;iacute;ble&lt;/a&gt; que explica el servicio vs f&amp;aacute;brica vs proveedor y su uso de inyecci&amp;oacute;n. Compilando las respuestas:</target>
        </trans-unit>
        <trans-unit id="fd7022a8753e6add51e2b9d2c29e59c134d3fba6" translate="yes" xml:space="preserve">
          <source>Functions and instance variables will be properties of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Las funciones y las variables de instancia ser&amp;aacute;n propiedades de &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7b97dbb27777de72af8d9af9dd816e007cb47e" translate="yes" xml:space="preserve">
          <source>Here is a simpler example.  I'm using a few third party libraries that expect a &quot;Position&quot; object exposing latitude and longitude, but via different object properties.  I didn't want to hack the vendor code, so I adjusted the &quot;Position&quot; objects I was passing around.</source>
          <target state="translated">Aquí hay un ejemplo más simple.Estoy usando unas pocas bibliotecas de terceros que esperan un objeto de &quot;Posición&quot; que exponga la latitud y la longitud,pero a través de diferentes propiedades del objeto.No quise hackear el código del proveedor,así que ajusté los objetos de &quot;Posición&quot; que estaba pasando.</target>
        </trans-unit>
        <trans-unit id="ae278ffeba6cafa1c3d2a70eeb6622299cb946ec" translate="yes" xml:space="preserve">
          <source>Here is a summary of when to use each:</source>
          <target state="translated">Aquí hay un resumen de cuándo usar cada uno:</target>
        </trans-unit>
        <trans-unit id="c9a8b09d58f2e8e0771d8f78424d27f226d92eae" translate="yes" xml:space="preserve">
          <source>Here is some broilerplate code I've come up with as a code-template for object factory in AngularjS.  I've used a Car/CarFactory as an example to illustrate.  Makes for simple implementation code in the controller.</source>
          <target state="translated">Aquí hay un código de placa de parrilla que se me ocurrió como una plantilla de código para la fábrica de objetos en AngularjS.He usado un CarCarFactory como ejemplo para ilustrarlo.Hace que la implementación del código en el controlador sea sencilla.</target>
        </trans-unit>
        <trans-unit id="489ba797946b9923375b0c16c73874f3a39fb591" translate="yes" xml:space="preserve">
          <source>Here you&amp;rsquo;ll notice we&amp;rsquo;re not attaching those variables/function to &amp;lsquo;service&amp;rsquo;. We&amp;rsquo;re simply creating them in order to either use or modify them later.</source>
          <target state="translated">Aqu&amp;iacute; notar&amp;aacute; que no estamos asociando esas variables / funciones a 'servicio'. Simplemente los estamos creando para usarlos o modificarlos m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="00a6aa13d323a6c412ee902d5b3d4d2d1ab4fe03" translate="yes" xml:space="preserve">
          <source>Here's a great further explanation by Misko:</source>
          <target state="translated">Aquí hay una gran explicación adicional de Misko:</target>
        </trans-unit>
        <trans-unit id="da5246469f32f79cb4f5e21f982157b5bf8fb944" translate="yes" xml:space="preserve">
          <source>Here's the article this image is from:</source>
          <target state="translated">Aquí está el artículo del que proviene esta imagen:</target>
        </trans-unit>
        <trans-unit id="850ac93122b4715c223580cbbd975d246cb16f45" translate="yes" xml:space="preserve">
          <source>Hope this has cleared up your understanding about &lt;strong&gt;Factory, Service and Provider&lt;/strong&gt;.</source>
          <target state="translated">Espero que esto haya aclarado su comprensi&amp;oacute;n sobre &lt;strong&gt;F&amp;aacute;brica, Servicio y Proveedor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c040a989c90c935f04c9d9df515887605a02c08" translate="yes" xml:space="preserve">
          <source>How AngularJS instantiates particular components (simplified):</source>
          <target state="translated">Cómo AngularJS instanciar componentes particulares (simplificado):</target>
        </trans-unit>
        <trans-unit id="c385f140fdcc5112262dbad26d8a3223347e8d51" translate="yes" xml:space="preserve">
          <source>I am trying to keep it simple. It's all about basic JavaScript concept.</source>
          <target state="translated">Estoy tratando de mantenerlo simple.Se trata de un concepto básico de JavaScript.</target>
        </trans-unit>
        <trans-unit id="29ca2a8a57db27d862d4085e8c93784f8e59cb96" translate="yes" xml:space="preserve">
          <source>I came across this video which explains clearly about factory, service and provider methodologies for developing AngularJS Custom Services:</source>
          <target state="translated">Me encontré con este video que explica claramente sobre la fábrica,el servicio y las metodologías de los proveedores para desarrollar los servicios personalizados de AngularJS:</target>
        </trans-unit>
        <trans-unit id="37a6f10678b28516c544ad2d07c57f10ba034f15" translate="yes" xml:space="preserve">
          <source>I know a lot of excellent answer but I have to share my experience of using</source>
          <target state="translated">Sé un montón de excelentes respuestas pero tengo que compartir mi experiencia en el uso de</target>
        </trans-unit>
        <trans-unit id="9310dd05ba382096e00103255eac7688e44ef73b" translate="yes" xml:space="preserve">
          <source>I noticed something interesting when playing around with providers.</source>
          <target state="translated">Noté algo interesante cuando jugaba con los proveedores.</target>
        </trans-unit>
        <trans-unit id="86c3d8da7c12380d33b628011f4dc967a20694c5" translate="yes" xml:space="preserve">
          <source>I still refer to them as &amp;ldquo;services&amp;rdquo; when I&amp;rsquo;m talking about injecting
  them as dependencies, though.</source>
          <target state="translated">Sin embargo, todav&amp;iacute;a me refiero a ellos como &quot;servicios&quot; cuando estoy hablando de inyectarlos como dependencias.</target>
        </trans-unit>
        <trans-unit id="b0314451a42f81ae46c88a72d5644b737ddc515b" translate="yes" xml:space="preserve">
          <source>If you want to use in angular module config function should created as &lt;strong&gt;provider&lt;/strong&gt;</source>
          <target state="translated">Si desea usar en el m&amp;oacute;dulo angular, la funci&amp;oacute;n de configuraci&amp;oacute;n debe crearse como &lt;strong&gt;proveedor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="760bfbfabac6439646276d21d21c1e88b0f1b52a" translate="yes" xml:space="preserve">
          <source>In the constructor function we can use 'this' keyword for adding properties/methods to the service object.
example:</source>
          <target state="translated">En la función de constructor podemos usar 'esta' palabra clave para añadir propiedades-métodos al objeto de servicio.ejemplo:</target>
        </trans-unit>
        <trans-unit id="c5401a20db45adfe8456a9fe2493978105e9f5da" translate="yes" xml:space="preserve">
          <source>In the controller above we&amp;rsquo;re injecting in the &amp;lsquo;myFactory&amp;rsquo; service. We then set properties on our $scope object with data from &amp;lsquo;myFactory&amp;rsquo;. The only tricky code above is if you&amp;rsquo;ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You&amp;rsquo;ll notice our controller is very &amp;lsquo;thin&amp;rsquo; (This is a good coding practise). All of our logic and persistent data is located in our service, not in our controller.</source>
          <target state="translated">En el controlador anterior, estamos inyectando en el servicio 'myFactory'. Luego establecemos propiedades en nuestro objeto $ scope con datos de 'myFactory'. El &amp;uacute;nico c&amp;oacute;digo complicado anterior es si nunca antes ha tratado con promesas. Debido a que callItunes est&amp;aacute; devolviendo una promesa, podemos usar el m&amp;eacute;todo .then () y solo establecer $ scope.data.artistData una vez que nuestra promesa se cumpla con los datos de iTunes. Notar&amp;aacute;s que nuestro controlador es muy 'delgado' (esta es una buena pr&amp;aacute;ctica de codificaci&amp;oacute;n). Todos nuestros datos l&amp;oacute;gicos y persistentes se encuentran en nuestro servicio, no en nuestro controlador.</target>
        </trans-unit>
        <trans-unit id="ad7c151fc09de45e372af1a2de7be6c6b7781661" translate="yes" xml:space="preserve">
          <source>In the service, we create function names as property with &lt;em&gt;this&lt;/em&gt; object.</source>
          <target state="translated">En el servicio, creamos nombres de funciones como propiedad con &lt;em&gt;este&lt;/em&gt; objeto.</target>
        </trans-unit>
        <trans-unit id="ca27a70fdef565576b6c87e2f47e6b4dd70d0118" translate="yes" xml:space="preserve">
          <source>In this case the injector simply returns the value as is. But what if you want to compute the value? Then use a factory</source>
          <target state="translated">En este caso el inyector simplemente devuelve el valor tal cual.¿Pero qué pasa si quieres calcular el valor? Entonces usa una fábrica</target>
        </trans-unit>
        <trans-unit id="ce56ab93a5137d82e8def783797ed2029027acad" translate="yes" xml:space="preserve">
          <source>It can be just a collection of functions like a class. Hence, it can be instantiated in different controllers when you are injecting it inside your controller/factory/directive functions. It is instantiated only once per app.</source>
          <target state="translated">Puede ser sólo una colección de funciones como una clase.Por lo tanto,puede ser instanciado en diferentes controladores cuando lo inyectas dentro de tus funciones directivas del controlador.Se instancian sólo una vez por aplicación.</target>
        </trans-unit>
        <trans-unit id="5b20c360213ae1af905212996e857c3ffcf8c5ac" translate="yes" xml:space="preserve">
          <source>It works like using a combination of &lt;em&gt;service&lt;/em&gt; and &lt;em&gt;provider&lt;/em&gt;, by passing to provider a function that has properties declared using the &lt;em&gt;this&lt;/em&gt; keyword, which can be used from the &lt;code&gt;app.config&lt;/code&gt;.</source>
          <target state="translated">Funciona como usar una combinaci&amp;oacute;n de &lt;em&gt;servicio&lt;/em&gt; y &lt;em&gt;proveedor&lt;/em&gt; , pasando al proveedor una funci&amp;oacute;n que tiene propiedades declaradas usando la palabra clave &lt;em&gt;this&lt;/em&gt; , que se puede usar desde &lt;code&gt;app.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68eb0b5a5293d5d11d5a247852531e63d5c542a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use the factory in our application as we can simply inject it where we need it at run-time.</source>
          <target state="translated">Es f&amp;aacute;cil usar la f&amp;aacute;brica en nuestra aplicaci&amp;oacute;n, ya que simplemente podemos inyectarla donde la necesitamos en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5e6ceae9d10cdf11f4c911a2da17d4ac57381842" translate="yes" xml:space="preserve">
          <source>It's the another way, we can register a service. The only difference is the way AngularJS tries to instantiate the service object. This time angular uses 'new' keyword and call the constructor function something like below.</source>
          <target state="translated">Es la otra forma,podemos registrar un servicio.La única diferencia es la forma en que AngularJS trata de instanciar el objeto de servicio.Esta vez Angular usa una palabra clave &quot;nueva&quot; y llama a la función constructora algo así como abajo.</target>
        </trans-unit>
        <trans-unit id="f8bf660b8496971437b76589be4961ef8c377635" translate="yes" xml:space="preserve">
          <source>JS Fiddle Demo</source>
          <target state="translated">Demostración de JS Fiddle</target>
        </trans-unit>
        <trans-unit id="0e399439c408eca064ae4becd7265accff216db8" translate="yes" xml:space="preserve">
          <source>Just to clarify things, from the AngularJS source, you can see a service just calls the factory function which in turn calls the provider function:</source>
          <target state="translated">Sólo para aclarar las cosas,desde la fuente de AngularJS,se puede ver que un servicio sólo llama a la función de fábrica que a su vez llama a la función de proveedor:</target>
        </trans-unit>
        <trans-unit id="7de5f61ab2c0b942cc33db2f46d0c4b470d32a4e" translate="yes" xml:space="preserve">
          <source>Let's again have a look at the Syntax first:</source>
          <target state="translated">Echemos otra vez un vistazo a la sintaxis primero:</target>
        </trans-unit>
        <trans-unit id="0fec230ed8200309bfc8c6866e454394b38359c7" translate="yes" xml:space="preserve">
          <source>Let's discuss the three ways of handling business logic in AngularJS in a simple way: (&lt;strong&gt;Inspired by Yaakov's Coursera AngularJS course&lt;/strong&gt;)</source>
          <target state="translated">Analicemos las tres formas de manejar la l&amp;oacute;gica de negocios en AngularJS de una manera simple: ( &lt;strong&gt;Inspirado en el curso Coursera AngularJS de Yaakov&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="fa350ad45511dbe39a4d035e7a10563f5896422d" translate="yes" xml:space="preserve">
          <source>Lets start with the difference between Service and factory:</source>
          <target state="translated">Empecemos con la diferencia entre el servicio y la fábrica:</target>
        </trans-unit>
        <trans-unit id="778a430f691a6018fcf57447a71b7c8cd2109696" translate="yes" xml:space="preserve">
          <source>Like I mentioned before, once you really understand what &amp;lsquo;new&amp;rsquo; does, Services are almost identical to factories in AngularJS.</source>
          <target state="translated">Como mencion&amp;eacute; antes, una vez que realmente comprende lo que hace &quot;nuevo&quot;, los Servicios son casi id&amp;eacute;nticos a las f&amp;aacute;bricas en AngularJS.</target>
        </trans-unit>
        <trans-unit id="25c6b479772ad22656b96f68f104741b92338f0a" translate="yes" xml:space="preserve">
          <source>Little late to the party.  But I thought this is more helpful for who would like to learn (or have clarity) on developing Angular JS Custom Services using factory, service and provider methodologies.</source>
          <target state="translated">Un poco tarde para la fiesta.Pero pensé que esto es más útil para quien quiera aprender (o tener claridad)sobre el desarrollo de Servicios Personalizados de JS Angular usando metodologías de fábrica,servicio y proveedor.</target>
        </trans-unit>
        <trans-unit id="4bd48a3b50a9f231823114ba704dfccf0bd973da" translate="yes" xml:space="preserve">
          <source>My clarification on this matter:</source>
          <target state="translated">Mi aclaración sobre este asunto:</target>
        </trans-unit>
        <trans-unit id="fbf210c3ae8711990847a3d950af4119f3209adb" translate="yes" xml:space="preserve">
          <source>My understanding is very simple below.</source>
          <target state="translated">Mi entendimiento es muy simple abajo.</target>
        </trans-unit>
        <trans-unit id="69f7e11da9f849693995d92816d880bd6fdc64e1" translate="yes" xml:space="preserve">
          <source>Not only produces singleton, but customizable services.</source>
          <target state="translated">No sólo produce singleton,sino servicios personalizables.</target>
        </trans-unit>
        <trans-unit id="982fb0ca939387b6254256e3ab0dfb3a7cc84d6c" translate="yes" xml:space="preserve">
          <source>Not only we can create a factory that's dynamically configurable, but at the time of using the factory, with the provider method, we could custom configure the factory just once at the bootstrapping of our entire application.</source>
          <target state="translated">No sólo podemos crear una fábrica que sea configurable dinámicamente,sino que en el momento de usar la fábrica,con el método del proveedor,podríamos configurar la fábrica a medida una sola vez en el arranque de toda nuestra aplicación.</target>
        </trans-unit>
        <trans-unit id="672bd2d09c7ed72a3eac6c27958d21691133d0dc" translate="yes" xml:space="preserve">
          <source>Note that it is possible to return a object (in which case it will function similar to a &lt;em&gt;service&lt;/em&gt;) or a function (that will be saved in the variable as a callback function).</source>
          <target state="translated">Tenga en cuenta que es posible devolver un objeto (en cuyo caso funcionar&amp;aacute; de manera similar a un &lt;em&gt;servicio&lt;/em&gt; ) o una funci&amp;oacute;n (que se guardar&amp;aacute; en la variable como una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada).</target>
        </trans-unit>
        <trans-unit id="5b1a8bd7c0a880872f4d9c7b867ae61242c0dfa0" translate="yes" xml:space="preserve">
          <source>Now having this knowledge of what the &amp;lsquo;new&amp;rsquo; keyword really does in JavaScript, creating a Service in AngularJS should be easier to understand.</source>
          <target state="translated">Ahora que conocemos lo que realmente hace la 'nueva' palabra clave en JavaScript, crear un Servicio en AngularJS deber&amp;iacute;a ser m&amp;aacute;s f&amp;aacute;cil de entender.</target>
        </trans-unit>
        <trans-unit id="d741df1b012ea25d838dc2c21bf70522da5f8512" translate="yes" xml:space="preserve">
          <source>Now just like in our factory and Service, setArtist, getArtist, and callItunes will be available in whichever controller we pass myProvider into. Here&amp;rsquo;s the myProvider controller (which is almost exactly the same as our factory/Service controller).</source>
          <target state="translated">Ahora, al igual que en nuestra f&amp;aacute;brica y servicio, setArtist, getArtist y callItunes estar&amp;aacute;n disponibles en cualquier controlador al que le pasemos myProvider. Aqu&amp;iacute; est&amp;aacute; el controlador myProvider (que es casi exactamente el mismo que nuestro controlador de f&amp;aacute;brica / servicio).</target>
        </trans-unit>
        <trans-unit id="698af625bfcb4e8f8fcb2e7bcb26d8b5f98e4503" translate="yes" xml:space="preserve">
          <source>Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here&amp;rsquo;s the myService controller (which is almost exactly the same as our factory controller).</source>
          <target state="translated">Ahora, al igual que en nuestra f&amp;aacute;brica, setArtist, getArtist y callItunes estar&amp;aacute;n disponibles en cualquier controlador al que pasamos myService. Aqu&amp;iacute; est&amp;aacute; el controlador myService (que es casi exactamente el mismo que nuestro controlador de f&amp;aacute;brica).</target>
        </trans-unit>
        <trans-unit id="33179f320db64f96208e8896db6147d2739c655b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a method onto our Person&amp;rsquo;s prototype so it will be available on every instance of our Person &amp;lsquo;class&amp;rsquo;.</source>
          <target state="translated">Ahora agreguemos un m&amp;eacute;todo al prototipo de nuestra Persona para que est&amp;eacute; disponible en cada instancia de nuestra 'clase' de Persona.</target>
        </trans-unit>
        <trans-unit id="4e56b2bbd2bcd8c15e0879964355623ffab1f7bb" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add some &amp;lsquo;private&amp;rsquo; variables to our callback function. These won&amp;rsquo;t be directly accessible from the controller, but we will eventually set up some getter/setter methods on &amp;lsquo;service&amp;rsquo; to be able to alter these &amp;lsquo;private&amp;rsquo; variables when needed.</source>
          <target state="translated">Ahora agreguemos algunas variables 'privadas' a nuestra funci&amp;oacute;n de devoluci&amp;oacute;n de llamada. No ser&amp;aacute; accesible directamente desde el controlador, pero eventualmente configuraremos algunos m&amp;eacute;todos getter / setter en 'servicio' para poder alterar estas variables 'privadas' cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="b83d5faac981eb0e79df8c1e9fbac8b90b76a95f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what actually is happening when you use the &amp;lsquo;new&amp;rsquo; keyword in JavaScript. First thing you should notice is that after using &amp;lsquo;new&amp;rsquo; in our example, we&amp;rsquo;re able to call a method (sayName) on &amp;lsquo;tyler&amp;rsquo; just as if it were an object - that&amp;rsquo;s because it is. 
So first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says &amp;ldquo;OK, I&amp;rsquo;m going to look on the &amp;lsquo;tyler&amp;rsquo; object we just created, locate the sayName function, then call it. Wait a minute, I don&amp;rsquo;t see it here - all I see is name and age, let me check the prototype. Yup, looks like it&amp;rsquo;s on the prototype, let me call it.&amp;rdquo;.</source>
          <target state="translated">Ahora echemos un vistazo a lo que realmente est&amp;aacute; sucediendo cuando usa la palabra clave 'nuevo' en JavaScript. Lo primero que debe notar es que despu&amp;eacute;s de usar 'nuevo' en nuestro ejemplo, podemos llamar a un m&amp;eacute;todo (sayName) en 'tyler' como si fuera un objeto, eso es porque lo es. Primero, sabemos que nuestro constructor de Persona est&amp;aacute; devolviendo un objeto, ya sea que podamos ver eso en el c&amp;oacute;digo o no. En segundo lugar, sabemos que debido a que nuestra funci&amp;oacute;n sayName se encuentra en el prototipo y no directamente en la instancia de Person, el objeto que devuelve la funci&amp;oacute;n Person debe delegarse en su prototipo en b&amp;uacute;squedas fallidas. En t&amp;eacute;rminos m&amp;aacute;s simples, cuando llamamos a tyler.sayName () el int&amp;eacute;rprete dice &quot;OK, voy a buscar el objeto 'tyler' que acabamos de crear, ubicar la funci&amp;oacute;n sayName y luego llamarla. Espera un minuto, no lo veo aqu&amp;iacute;, todo lo que veo es el nombre y la edad, d&amp;eacute;jame revisar el prototipo. S&amp;iacute;, parece que est&amp;aacute; en el prototipo, d&amp;eacute;jenme llamarlo &quot;.</target>
        </trans-unit>
        <trans-unit id="fb6577ce21f8b4d96fd20a371037e7c8ed7c6760" translate="yes" xml:space="preserve">
          <source>Now our factory is complete. We are now able to inject &amp;lsquo;myFactory&amp;rsquo; into any controller and we&amp;rsquo;ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes).</source>
          <target state="translated">Ahora nuestra f&amp;aacute;brica est&amp;aacute; completa. Ahora podemos inyectar 'myFactory' en cualquier controlador y luego podremos llamar a nuestros m&amp;eacute;todos que adjuntamos a nuestro objeto de servicio (setArtist, getArtist y callItunes).</target>
        </trans-unit>
        <trans-unit id="2dd7216c3d216047524da229ce33e07f854c5b20" translate="yes" xml:space="preserve">
          <source>Now that our helper/private variables and function are in place, let&amp;rsquo;s add some properties to the &amp;lsquo;service&amp;rsquo; object. Whatever we put on &amp;lsquo;service&amp;rsquo; can be directly used inside whichever controller we pass &amp;lsquo;myFactory&amp;rsquo; into.</source>
          <target state="translated">Ahora que nuestras variables y funciones auxiliares / privadas est&amp;aacute;n en su lugar, agreguemos algunas propiedades al objeto 'servicio'. Todo lo que ponemos en 'servicio' se puede usar directamente en cualquier controlador al que le pasemos 'myFactory'.</target>
        </trans-unit>
        <trans-unit id="39ddb2f22b7fced081ba8ea176229ca0ac8d8309" translate="yes" xml:space="preserve">
          <source>Now that we have our Person constructor function and our sayName function on its prototype, let&amp;rsquo;s actually create an instance of Person then call the sayName function.</source>
          <target state="translated">Ahora que tenemos nuestra funci&amp;oacute;n de constructor Person y nuestra funci&amp;oacute;n sayName en su prototipo, creemos una instancia de Person y luego llamemos a la funci&amp;oacute;n sayName.</target>
        </trans-unit>
        <trans-unit id="ec51346deab58cf2c25c7d6a3cb4af41dc640f10" translate="yes" xml:space="preserve">
          <source>Now the full Provider code looks like this</source>
          <target state="translated">Ahora el código completo del Proveedor se ve así</target>
        </trans-unit>
        <trans-unit id="a8c5c01dc8cb0c4ad9e61b2d0177736881556303" translate="yes" xml:space="preserve">
          <source>Now using the above two in the controller:</source>
          <target state="translated">Ahora usando los dos anteriores en el controlador:</target>
        </trans-unit>
        <trans-unit id="554f3e5b70223d89fd87ed55eb8c7fa0aea6edc3" translate="yes" xml:space="preserve">
          <source>Now whatever properties we attach to &amp;lsquo;service&amp;rsquo; will be available to us when we pass &amp;lsquo;myFactory&amp;rsquo; into our controller.</source>
          <target state="translated">Ahora, cualquier propiedad que adjuntemos al 'servicio' estar&amp;aacute; disponible cuando pasemos 'myFactory' a nuestro controlador.</target>
        </trans-unit>
        <trans-unit id="8db4bcee9cc90896dbc924721630384540a94c50" translate="yes" xml:space="preserve">
          <source>Now you can see how &amp;lsquo;thingFromConfig&amp;rsquo; is as empty string in our provider, but when that shows up in the DOM, it will be &amp;lsquo;This sentence was set&amp;hellip;&amp;rsquo;.</source>
          <target state="translated">Ahora puede ver c&amp;oacute;mo 'thingFromConfig' es una cadena vac&amp;iacute;a en nuestro proveedor, pero cuando eso aparezca en el DOM, ser&amp;aacute; 'Esta oraci&amp;oacute;n se estableci&amp;oacute; ...'.</target>
        </trans-unit>
        <trans-unit id="ec62b54ee6ce720c21f33325f4f0a65c82d69fdb" translate="yes" xml:space="preserve">
          <source>Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance&amp;rsquo;s name.</source>
          <target state="translated">Ahora, como ponemos la funci&amp;oacute;n sayName en el prototipo, cada instancia de Person podr&amp;aacute; llamar a la funci&amp;oacute;n sayName para alertar el nombre de esa instancia.</target>
        </trans-unit>
        <trans-unit id="11f40cd81d972474ebbd1638f071afb14e360695" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll attach all of our methods that will be available in our controller to &amp;lsquo;this&amp;rsquo;.</source>
          <target state="translated">Ahora, adjuntaremos todos nuestros m&amp;eacute;todos que estar&amp;aacute;n disponibles en nuestro controlador a 'esto'.</target>
        </trans-unit>
        <trans-unit id="f06e2a3c653d42f7111fe26d1c705865f3c86c73" translate="yes" xml:space="preserve">
          <source>Only provider will be available in config phase of angular, while
  service &amp;amp; factory are not.</source>
          <target state="translated">Solo el proveedor estar&amp;aacute; disponible en la fase de configuraci&amp;oacute;n de angular, mientras que el servicio y la f&amp;aacute;brica no.</target>
        </trans-unit>
        <trans-unit id="dfdb4f5263d92c8b24c27c443665ded6f3f279be" translate="yes" xml:space="preserve">
          <source>Perhaps the biggest thing to know when dealing with creating a Service is that that it&amp;rsquo;s instantiated with the &amp;lsquo;new&amp;rsquo; keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren&amp;rsquo;t too familiar with what the &amp;lsquo;new&amp;rsquo; keyword actually does, let&amp;rsquo;s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service.</source>
          <target state="translated">Quiz&amp;aacute;s lo m&amp;aacute;s importante que se debe saber cuando se trata de crear un Servicio es que se instancia con la palabra clave 'nueva'. Para sus gur&amp;uacute;s de JavaScript, esto deber&amp;iacute;a darle una gran pista sobre la naturaleza del c&amp;oacute;digo. Para aquellos de ustedes con antecedentes limitados en JavaScript o para aquellos que no est&amp;aacute;n demasiado familiarizados con lo que realmente hace la 'nueva' palabra clave, revisemos algunos fundamentos de JavaScript que eventualmente nos ayudar&amp;aacute;n a comprender la naturaleza de un Servicio.</target>
        </trans-unit>
        <trans-unit id="7ceee3f3615a2bbe4ce0ac5a269a311e4821daf4" translate="yes" xml:space="preserve">
          <source>Provider</source>
          <target state="translated">Provider</target>
        </trans-unit>
        <trans-unit id="53d2419e2fad27c745ab7837fb34c5b4cb3b5535" translate="yes" xml:space="preserve">
          <source>Provider is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">El proveedor es el tipo de receta más complejo.No lo necesitas a menos que estés construyendo un pedazo de código reutilizable que necesite una configuración global.</target>
        </trans-unit>
        <trans-unit id="d3f6c702cb3e12640d8a58f3b97ac66d45f4b833" translate="yes" xml:space="preserve">
          <source>Provider is the most flexible method of creating services in Angular.</source>
          <target state="translated">El proveedor es el método más flexible de crear servicios en Angular.</target>
        </trans-unit>
        <trans-unit id="955559753eafb5cc8b4506201a86bbe417ec9d05" translate="yes" xml:space="preserve">
          <source>Provider() function is the another way for creating services. Let we are interested to create a service which just display some greeting message to the user. But we also want to provide a functionality such that user can set their own greeting message. In technical terms we want to create configurable services. How can we do this ? There must be a way, so that app could pass their custom greeting messages and Angularjs would make it available to factory/constructor function which create our services instance.
In such a case provider() function do the job. using provider() function we can create configurable services.</source>
          <target state="translated">La función Provider()es la otra forma de crear servicios.Nos interesa crear un servicio que sólo muestre algún mensaje de saludo al usuario.Pero también queremos proporcionar una funcionalidad tal que el usuario pueda establecer su propio mensaje de saludo.En términos técnicos queremos crear servicios configurables.¿Cómo podemos hacerlo? Debe haber una manera,para que la aplicación pueda pasar sus mensajes de saludo personalizados y Angularjs lo ponga a disposición de la función factoryconstructor que crea nuestra instancia de servicios.En tal caso la función provider()hace el trabajo.Usando la función provider()podemos crear servicios configurables.</target>
        </trans-unit>
        <trans-unit id="87b7c08baed1c8e93db95b79bcdca55b631dd7bb" translate="yes" xml:space="preserve">
          <source>Providers</source>
          <target state="translated">Providers</target>
        </trans-unit>
        <trans-unit id="2d56985193e8bf2d6ab8849ef7c57e0e5dde4a2b" translate="yes" xml:space="preserve">
          <source>Providers allow you to configure the provider &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; AngularJS calls the &lt;code&gt;$get&lt;/code&gt; method to get the injectible.</source>
          <target state="translated">Los proveedores le permiten configurar el proveedor &lt;strong&gt;&lt;em&gt;antes de que&lt;/em&gt;&lt;/strong&gt; AngularJS llame al m&amp;eacute;todo &lt;code&gt;$get&lt;/code&gt; para obtener el inyectable.</target>
        </trans-unit>
        <trans-unit id="fa42b9d0b7dbcb3ea427607354fff8602303c4c8" translate="yes" xml:space="preserve">
          <source>Providers have the advantage that they can be configured during the module configuration phase.</source>
          <target state="translated">Los proveedores tienen la ventaja de que pueden ser configurados durante la fase de configuración de los módulos.</target>
        </trans-unit>
        <trans-unit id="8d9b9399c4d6be5dbb075743c0ee3d595b3daf9b" translate="yes" xml:space="preserve">
          <source>Result: When declaring factoryName as an injectable argument you will be provided with &lt;strong&gt;the value that is returned by invoking the function reference passed to module.factory&lt;/strong&gt;.</source>
          <target state="translated">Resultado: al declarar factoryName como argumento inyectable, se le proporcionar&amp;aacute; &lt;strong&gt;el valor que se devuelve invocando la referencia de funci&amp;oacute;n pasada a module.factory&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8b8055b0f238e713bbe09a1f5142a3a9c4180d28" translate="yes" xml:space="preserve">
          <source>Result: When declaring providerName as an injectable argument &lt;strong&gt;you will be provided with&lt;/strong&gt;&lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt;. The constructor function is instantiated before the $get method is called - &lt;code&gt;ProviderFunction&lt;/code&gt; is  the function reference passed to module.provider.</source>
          <target state="translated">Resultado: al declarar providerName como argumento inyectable, &lt;strong&gt;se le proporcionar&amp;aacute;&lt;/strong&gt; &lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt; . La funci&amp;oacute;n de constructor se instancia antes de que se llame al m&amp;eacute;todo $ get: &lt;code&gt;ProviderFunction&lt;/code&gt; es la referencia de funci&amp;oacute;n que se pasa a module.provider.</target>
        </trans-unit>
        <trans-unit id="c70fc6d0d8618584e9490ed45c73cb37b4246b1e" translate="yes" xml:space="preserve">
          <source>Result: When declaring serviceName as an injectable argument &lt;strong&gt;you will be provided with an instance of the function. In other words&lt;/strong&gt;&lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt;.</source>
          <target state="translated">Resultado: al declarar serviceName como argumento inyectable, &lt;strong&gt;se le proporcionar&amp;aacute; una instancia de la funci&amp;oacute;n.&lt;/strong&gt; &lt;strong&gt;En otras palabras,&lt;/strong&gt; &lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c830a908226f52c7631bae300c0e26abb3631d0" translate="yes" xml:space="preserve">
          <source>Sample Example:</source>
          <target state="translated">Ejemplo de muestra:</target>
        </trans-unit>
        <trans-unit id="381df071be6ca5ac8d6e5e18ab012360963bd4a9" translate="yes" xml:space="preserve">
          <source>Sample code for creating service using provide syntax:</source>
          <target state="translated">Ejemplo de código para crear un servicio utilizando la sintaxis de la oferta:</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">Digamos que sí:</target>
        </trans-unit>
        <trans-unit id="11dc1a4e11a2784e2b6de73a9022cddbb6721f42" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;the provider documentation&lt;/a&gt;.</source>
          <target state="translated">Consulte &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;la documentaci&amp;oacute;n del proveedor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f4ab1a2559d02916ca6b754d342e20711e3cfca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;here&lt;/a&gt; for the provided code.</source>
          <target state="translated">Vea &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;aqu&amp;iacute;&lt;/a&gt; el c&amp;oacute;digo provisto.</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5030396a200088699db9b35f53a60b75ca0f61ed" translate="yes" xml:space="preserve">
          <source>Service Function:</source>
          <target state="translated">Función de servicio:</target>
        </trans-unit>
        <trans-unit id="6210fa9c0a7b05e22abb7fcb5a13962309ea102d" translate="yes" xml:space="preserve">
          <source>Service initialization</source>
          <target state="translated">Inicialización del servicio</target>
        </trans-unit>
        <trans-unit id="9d10e77416b918cf3662445c6e88c578fa4569c9" translate="yes" xml:space="preserve">
          <source>Service is an singleton object instance. Use services if you want to provide a singleton object for your code.</source>
          <target state="translated">El servicio es una instancia de objeto único.Use servicios si quiere proporcionar un objeto único para su código.</target>
        </trans-unit>
        <trans-unit id="61835754249fef2e2b45059d3bbd0d0e5cdde58d" translate="yes" xml:space="preserve">
          <source>Service/Factory behavior is very similar, and some people will say
  that either one is fine. That&amp;rsquo;s somewhat true, but I find it easier to
  follow the advice of John Papa&amp;rsquo;s style guide and just stick with
  factories.**</source>
          <target state="translated">El comportamiento del Servicio / F&amp;aacute;brica es muy similar, y algunas personas dir&amp;aacute;n que cualquiera de los dos est&amp;aacute; bien. Eso es algo cierto, pero me resulta m&amp;aacute;s f&amp;aacute;cil seguir los consejos de la gu&amp;iacute;a de estilo de John Papa y seguir con las f&amp;aacute;bricas. **</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="c1e289d3853bb8c7d8a915f54b7abf6bb6594091" translate="yes" xml:space="preserve">
          <source>Simply while looking at the services think about the array prototype. A service is a function which instantiates a new object using the 'new' keyword. You can add properties and functions to a service object by using the &lt;code&gt;this&lt;/code&gt; keyword. Unlike a factory, it doesn't return anything (it returns an object which contains methods/properties).</source>
          <target state="translated">Simplemente mientras mira los servicios piense en el prototipo de matriz. Un servicio es una funci&amp;oacute;n que instancia un nuevo objeto usando la palabra clave 'nuevo'. Puede agregar propiedades y funciones a un objeto de servicio utilizando la palabra clave &lt;code&gt;this&lt;/code&gt; . A diferencia de una f&amp;aacute;brica, no devuelve nada (devuelve un objeto que contiene m&amp;eacute;todos / propiedades).</target>
        </trans-unit>
        <trans-unit id="62854845263bf068dddccd96ecb184fb8ea7a590" translate="yes" xml:space="preserve">
          <source>Since the constructed service is an object, the methods inside it can refer to this when they&amp;rsquo;re called:</source>
          <target state="translated">Como el servicio construido es un objeto, los m&amp;eacute;todos dentro de &amp;eacute;l pueden referirse a esto cuando se los llama:</target>
        </trans-unit>
        <trans-unit id="155220d0a18e305b7ea66fb35c4da7270fc65257" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;factory&lt;/code&gt; is a function which is responsible for creating the value. Notice that the factory function can ask for other dependencies.</source>
          <target state="translated">Entonces &lt;code&gt;factory&lt;/code&gt; es una funci&amp;oacute;n responsable de crear el valor. Tenga en cuenta que la funci&amp;oacute;n de f&amp;aacute;brica puede solicitar otras dependencias.</target>
        </trans-unit>
        <trans-unit id="4d857556fc3e68491091f75ba684105c6782e0e5" translate="yes" xml:space="preserve">
          <source>So all together the code for creating a Person constructor, adding a function to it&amp;rsquo;s prototype, creating a Person instance, and then calling the function on its prototype looks like this.</source>
          <target state="translated">As&amp;iacute; que, en conjunto, el c&amp;oacute;digo para crear un constructor de Persona, agregar una funci&amp;oacute;n a su prototipo, crear una instancia de Persona y luego llamar a la funci&amp;oacute;n en su prototipo se ve as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="08c3828d081a8d7efafeefc62c0878e780b4e133" translate="yes" xml:space="preserve">
          <source>So basically in both cases you eventually get a providers $get set to your function you provided , but you can give anything extra than $get as you can originally provide in provider() for config block</source>
          <target state="translated">Así que,básicamente,en ambos casos,se obtiene un conjunto de $get del proveedor a la función que usted proporcionó,pero puede dar cualquier cosa extra que no sea $get como puede proporcionar originalmente en provider()para el bloque de configuración.</target>
        </trans-unit>
        <trans-unit id="27e3723bbf080ae2fb322bd7eb8909b1557894e4" translate="yes" xml:space="preserve">
          <source>So if there are three controller scope, let it be controllerA, controllerB and controllerC, all will share same service instance.</source>
          <target state="translated">Así que si hay tres controladores de alcance,que sean el controladorA,el controladorB y el controladorC,todos compartirán la misma instancia de servicio.</target>
        </trans-unit>
        <trans-unit id="dd81d4d697436b2952af0ee10fd0dd2ca080a3d2" translate="yes" xml:space="preserve">
          <source>So master provider and injector and all will fall in place :) . And it gets interesting in Typescript when $get can be implemented in a provider by inheriting from IServiceProvider.</source>
          <target state="translated">Así que el proveedor maestro y el inyector y todo caerá en su lugar :).Y se pone interesante en Typescript cuando $get puede ser implementado en un proveedor al heredar de IServiceProvider.</target>
        </trans-unit>
        <trans-unit id="cb9d6754283c9f37208464bd5837389aa5b0ad15" translate="yes" xml:space="preserve">
          <source>So when Angular constructs your service with new MyService(), it&amp;rsquo;ll get that api object instead of the MyService instance.</source>
          <target state="translated">Entonces, cuando Angular construya su servicio con el nuevo MyService (), obtendr&amp;aacute; ese objeto api en lugar de la instancia de MyService.</target>
        </trans-unit>
        <trans-unit id="c72cf4ede28e8dd19525b9079025b0772ccc130b" translate="yes" xml:space="preserve">
          <source>So why such complications, why can't we just use provider and forget everything else? It is supposed to help us write code easily and communicate better. And toungue-in-cheek reply would be, the more complex it gets the better selling a framework will be.</source>
          <target state="translated">Entonces,¿por qué tales complicaciones,por qué no podemos usar el proveedor y olvidarnos de todo lo demás? Se supone que nos ayuda a escribir código fácilmente y a comunicarnos mejor.Y la respuesta de toungue-en-cheek sería,cuanto más complejo sea,mejor será la venta de un marco de trabajo.</target>
        </trans-unit>
        <trans-unit id="d26ab8fdbfba98e5ec328de0fd5fd8b3ec1253e1" translate="yes" xml:space="preserve">
          <source>So, for the service, what becomes the AngularJS component is the object instance of the class which is represented by service declaration function. For the factory, it is the result returned from the factory declaration function. The factory may behave the same as the service:</source>
          <target state="translated">Así,para el servicio,lo que se convierte en el componente AngularJS es la instancia de objeto de la clase que está representada por la función de declaración de servicio.Para la fábrica,es el resultado devuelto de la función de declaración de fábrica.La fábrica puede comportarse de la misma manera que el servicio:</target>
        </trans-unit>
        <trans-unit id="e62f1055fa34e381a967d48cc84251a3806ed36c" translate="yes" xml:space="preserve">
          <source>Source Code: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</source>
          <target state="translated">C&amp;oacute;digo fuente: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9924e31c2dd752407f7714733eb09ad7aaef9362" translate="yes" xml:space="preserve">
          <source>Summary from &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular docs&lt;/a&gt;:</source>
          <target state="translated">Resumen de &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentos angulares&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="8a29d9bf1a1e71cf529fe97431e96a86eaf41f44" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</source>
          <target state="translated">Sintaxis: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194b446e2c1fb5fc04741acabf05acbc4af47aec" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</source>
          <target state="translated">Sintaxis: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92324397a45dd6d31034d314cd7fc546cabef2b8" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</source>
          <target state="translated">Sintaxis: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84dd638523da34b8795dead37b56820cfba7075e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$get&lt;/code&gt; is a function that is directly attached to the provider instance. That function is a &lt;strong&gt;factory&lt;/strong&gt; function. In other words, it's just like the one that we use to &lt;em&gt;provide&lt;/em&gt; to the &lt;code&gt;.factory&lt;/code&gt; method. In that function, we create our own service. &lt;strong&gt;This &lt;code&gt;$get&lt;/code&gt; property, that's a function, is what makes the provider a provider&lt;/strong&gt;. &lt;em&gt;AngularJS expects the provider to have a $get property whose value is a function that Angular will treat as a factory function.&lt;/em&gt; But what makes this whole provider setup very special, is the fact that we can provide some &lt;code&gt;config&lt;/code&gt; object inside the service provider, and that usually comes with defaults that we can later overwrite in the step, where we can configure the entire application.</source>
          <target state="translated">&lt;code&gt;$get&lt;/code&gt; es una funci&amp;oacute;n que se adjunta directamente a la instancia del proveedor. Esa funci&amp;oacute;n es una funci&amp;oacute;n de &lt;strong&gt;f&amp;aacute;brica&lt;/strong&gt; . En otras palabras, es como el que usamos para &lt;em&gt;proporcionar&lt;/em&gt; el m&amp;eacute;todo &lt;code&gt;.factory&lt;/code&gt; . En esa funci&amp;oacute;n, creamos nuestro propio servicio. &lt;strong&gt;Esta propiedad &lt;code&gt;$get&lt;/code&gt; , esa es una funci&amp;oacute;n, es lo que hace al proveedor un proveedor&lt;/strong&gt; . &lt;em&gt;AngularJS espera que el proveedor tenga una propiedad $ get cuyo valor es una funci&amp;oacute;n que Angular tratar&amp;aacute; como una funci&amp;oacute;n de f&amp;aacute;brica.&lt;/em&gt; Pero lo que hace que toda la configuraci&amp;oacute;n de este proveedor sea muy especial es el hecho de que podemos proporcionar alg&amp;uacute;n objeto de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n dentro del proveedor de servicios, y eso generalmente viene con valores predeterminados que luego podemos sobrescribir en el paso, donde podemos configurar toda la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7b6548f429604df735e1a44693ef40e85b8e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.service()&lt;/code&gt; method is a &lt;strong&gt;factory&lt;/strong&gt; that always produces the same type of service, which is a singleton, and without any easy way to configure it's behavior. That &lt;code&gt;.service()&lt;/code&gt; method is usually used as a shortcut for something that doesn't require any configuration whatsoever.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;.service()&lt;/code&gt; es una &lt;strong&gt;f&amp;aacute;brica&lt;/strong&gt; que siempre produce el mismo tipo de servicio, que es un singleton, y sin ninguna forma f&amp;aacute;cil de configurar su comportamiento. Ese m&amp;eacute;todo &lt;code&gt;.service()&lt;/code&gt; se usa generalmente como un acceso directo para algo que no requiere ninguna configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a49ec85e38178c060ff6013773473704cdd2007a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, and &lt;code&gt;provider&lt;/code&gt; methods are all providers. They teach the Injector how to instantiate the Services.</source>
          <target state="translated">Los m&amp;eacute;todos de &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;factory&lt;/code&gt; , &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;constant&lt;/code&gt; e y &lt;code&gt;provider&lt;/code&gt; son todos proveedores. Ense&amp;ntilde;an al Inyector a crear instancias de los Servicios.</target>
        </trans-unit>
        <trans-unit id="025bc59091687d744c1dd87ac4446f1a3ea99b14" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Constant recipe&lt;/strong&gt; is just like the Value recipe except it allows you to define services that are available in the &lt;strong&gt;config&lt;/strong&gt; phase. Sooner than services created using the Value recipe. Unlike Values, they cannot be decorated using &lt;code&gt;decorator&lt;/code&gt;.</source>
          <target state="translated">La &lt;strong&gt;receta constante&lt;/strong&gt; es igual que la receta de valor, excepto que le permite definir los servicios que est&amp;aacute;n disponibles en la fase de &lt;strong&gt;configuraci&amp;oacute;n&lt;/strong&gt; . M&amp;aacute;s pronto que los servicios creados con la receta Value. A diferencia de los valores, no se pueden decorar con &lt;code&gt;decorator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf81a424905d80f0814719f3aa86cbdefa28b91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Factory recipe&lt;/strong&gt; gives the Injector a factory function that it calls when it needs to instantiate the service. When called, the &lt;strong&gt;factory function&lt;/strong&gt; creates and returns the service instance. The dependencies of the Service are injected as the functions' arguments. So using this recipe adds the following abilities:</source>
          <target state="translated">La &lt;strong&gt;receta de f&amp;aacute;brica&lt;/strong&gt; le da al inyector una funci&amp;oacute;n de f&amp;aacute;brica a la que llama cuando necesita instanciar el servicio. Cuando se llama, la &lt;strong&gt;funci&amp;oacute;n de f&amp;aacute;brica&lt;/strong&gt; crea y devuelve la instancia de servicio. Las dependencias del Servicio se inyectan como argumentos de las funciones. Entonces, usar esta receta agrega las siguientes habilidades:</target>
        </trans-unit>
        <trans-unit id="b86e7115a91b56187a5fe0143ed257a341995e64" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider recipe&lt;/strong&gt; is usually &lt;strong&gt;overkill&lt;/strong&gt;. It adds one more layer of indirection by allowing you to configure the creation of the factory.</source>
          <target state="translated">La &lt;strong&gt;receta del proveedor&lt;/strong&gt; suele ser &lt;strong&gt;exagerada&lt;/strong&gt; . Agrega una capa m&amp;aacute;s de indirecci&amp;oacute;n al permitirle configurar la creaci&amp;oacute;n de la f&amp;aacute;brica.</target>
        </trans-unit>
        <trans-unit id="cad58aeb7205a606c508335ce156288e7da6f573" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider&lt;/strong&gt; recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">La receta del &lt;strong&gt;proveedor&lt;/strong&gt; es el tipo de receta principal y todas las dem&amp;aacute;s son simplemente az&amp;uacute;car sint&amp;aacute;ctica.</target>
        </trans-unit>
        <trans-unit id="17bb816a792f8c3e9c45f68c21dac545bc7fc6e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Service recipe&lt;/strong&gt; is almost the same as the Factory recipe, but here the Injector invokes a &lt;strong&gt;constructor&lt;/strong&gt; with the new operator instead of a factory function.</source>
          <target state="translated">La &lt;strong&gt;receta de servicio&lt;/strong&gt; es casi la misma que la receta de f&amp;aacute;brica, pero aqu&amp;iacute; el inyector invoca un &lt;strong&gt;constructor&lt;/strong&gt; con el nuevo operador en lugar de una funci&amp;oacute;n de f&amp;aacute;brica.</target>
        </trans-unit>
        <trans-unit id="0f6f2e7cab552a54a9d8929a09e98e95cc4cfb9f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Value Recipe&lt;/strong&gt; is the simplest case, where you instantiate the Service yourself and provide the &lt;strong&gt;instantiated value&lt;/strong&gt; to the injector.</source>
          <target state="translated">La &lt;strong&gt;receta de valor&lt;/strong&gt; es el caso m&amp;aacute;s simple, en el que crea una instancia del servicio usted mismo y proporciona el &lt;strong&gt;valor instanciado&lt;/strong&gt; al inyector.</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">La receta del Proveedor es el tipo de receta principal y todas las demás son sólo azúcar sintáctica en ella.</target>
        </trans-unit>
        <trans-unit id="c20c67a4543a337b871e95eaa0aa2230110f9cde" translate="yes" xml:space="preserve">
          <source>The biggest thing to remember about Providers is that they&amp;rsquo;re the only service that you can pass into the app.config portion of your application. This is of huge importance if you&amp;rsquo;re needing to alter some portion of your service object before it&amp;rsquo;s available everywhere else in your application. Although very similar to Services/Factories, there are a few differences which we&amp;rsquo;ll discuss.</source>
          <target state="translated">Lo m&amp;aacute;s importante que debe recordar acerca de los proveedores es que son el &amp;uacute;nico servicio que puede pasar a la parte app.config de su aplicaci&amp;oacute;n. Esto es de gran importancia si necesita modificar alguna parte de su objeto de servicio antes de que est&amp;eacute; disponible en cualquier otro lugar de su aplicaci&amp;oacute;n. Aunque es muy similar a los Servicios / F&amp;aacute;bricas, hay algunas diferencias que discutiremos.</target>
        </trans-unit>
        <trans-unit id="a2a3557bc4924e63f2d2ce284fc4ba7adf38dc02" translate="yes" xml:space="preserve">
          <source>The biggest thing to understand when creating a Service is knowing that Services are instantiated with the &amp;lsquo;new&amp;rsquo; keyword. Combining that knowledge with our examples above, you should now recognize that you&amp;rsquo;ll be attaching your properties and methods directly to &amp;lsquo;this&amp;rsquo; which will then be returned from the Service itself. Let&amp;rsquo;s take a look at this in action.</source>
          <target state="translated">Lo m&amp;aacute;s importante para entender al crear un Servicio es saber que los Servicios se instancian con la palabra clave 'nueva'. Combinando ese conocimiento con nuestros ejemplos anteriores, ahora debe reconocer que adjuntar&amp;aacute; sus propiedades y m&amp;eacute;todos directamente a 'esto', que luego ser&amp;aacute; devuelto por el Servicio mismo. Echemos un vistazo a esto en acci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ee97831b61259806e326d0d7c322a8ac829781ee" translate="yes" xml:space="preserve">
          <source>The code for &quot;factory&quot; based custom service is as follows (which goes with both sync and async versions along with calling http service):</source>
          <target state="translated">El código para el servicio personalizado basado en la &quot;fábrica&quot; es el siguiente (que va con las versiones de sincronización y asíncrona junto con el servicio de llamada http):</target>
        </trans-unit>
        <trans-unit id="dbceb93948d3b88153505159e94a72b7b46ceaf3" translate="yes" xml:space="preserve">
          <source>The code for &quot;provider&quot; methodology for Custom Services (this is necessary, if you would like to develop service which could be configured):</source>
          <target state="translated">El código de la metodología de &quot;proveedor&quot; para los servicios personalizados (esto es necesario,si se desea desarrollar un servicio que pueda ser configurado):</target>
        </trans-unit>
        <trans-unit id="20100b8b1bb6246809bfd0d54c74369163ea60ef" translate="yes" xml:space="preserve">
          <source>The code for &quot;service&quot; methodology for Custom Services (this is pretty similar to 'factory', but different from syntax point of view):</source>
          <target state="translated">El código de la metodología de &quot;servicio&quot; para los servicios personalizados (esto es bastante similar a &quot;fábrica&quot;,pero diferente desde el punto de vista de la sintaxis):</target>
        </trans-unit>
        <trans-unit id="1f5224c76a4a9f42aeda5250ed57bd05696a3d3c" translate="yes" xml:space="preserve">
          <source>The difference between the three is that:</source>
          <target state="translated">La diferencia entre los tres es que:</target>
        </trans-unit>
        <trans-unit id="80c0d58f7ad22390cf6e79a7ead32b51a9279f3b" translate="yes" xml:space="preserve">
          <source>The factory 'class' example is provided in the comments around, as well as provider difference.</source>
          <target state="translated">El ejemplo de la &quot;clase&quot; de la fábrica se proporciona en los comentarios de alrededor,así como la diferencia de proveedores.</target>
        </trans-unit>
        <trans-unit id="29223deeb9a116b14e0df19e98f9ac9f789b7dbd" translate="yes" xml:space="preserve">
          <source>The factory can also return an object with a method that can be invoked:</source>
          <target state="translated">La fábrica también puede devolver un objeto con un método que puede ser invocado:</target>
        </trans-unit>
        <trans-unit id="c72bcb74f28a11248fb075ce43662f6ac919dc7d" translate="yes" xml:space="preserve">
          <source>The factory can then be used throughout the application with custom settings. In other words, we can configure this factory before the application starts. In fact in the angular documentation it is mentioned that the provider method is what actually gets executed behind the scenes when we configure our services with either &lt;code&gt;.service&lt;/code&gt; or &lt;code&gt;.factory&lt;/code&gt; methods.</source>
          <target state="translated">La f&amp;aacute;brica se puede utilizar en toda la aplicaci&amp;oacute;n con configuraciones personalizadas. En otras palabras, podemos configurar esta f&amp;aacute;brica antes de que se inicie la aplicaci&amp;oacute;n. De hecho, en la documentaci&amp;oacute;n angular se menciona que el m&amp;eacute;todo del proveedor es lo que realmente se ejecuta detr&amp;aacute;s de escena cuando configuramos nuestros servicios con los m&amp;eacute;todos &lt;code&gt;.service&lt;/code&gt; o &lt;code&gt;.factory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f2a456ca8dd7dbc5919aa27331c81f32a961f4" translate="yes" xml:space="preserve">
          <source>The factory returns a function that can be invoked:</source>
          <target state="translated">La fábrica devuelve una función que puede ser invocada:</target>
        </trans-unit>
        <trans-unit id="294c451a3bc3bc52035a0a1ff0d80aadf5cf8464" translate="yes" xml:space="preserve">
          <source>The injected value for a factory dependency is the factory&amp;rsquo;s return
  value, and it doesn&amp;rsquo;t have to be an object. It could be a function</source>
          <target state="translated">El valor inyectado para una dependencia de f&amp;aacute;brica es el valor de retorno de la f&amp;aacute;brica, y no tiene que ser un objeto. Podr&amp;iacute;a ser una funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services
and special purpose objects</source>
          <target state="translated">El inyector utiliza recetas para crear dos tipos de objetos:servicios y objetos con fines especiales</target>
        </trans-unit>
        <trans-unit id="2a5bdc6259273898183df356d5f764744dcb6660" translate="yes" xml:space="preserve">
          <source>The lowest level way to create a service is by using the provide() method. This is the only way to create a service that we can configure using the .config() function.
Unlike the previous to methods, we&amp;rsquo;ll set the injectables in a defined this.$get() function definition.</source>
          <target state="translated">La forma de nivel m&amp;aacute;s bajo para crear un servicio es mediante el m&amp;eacute;todo provide (). Esta es la &amp;uacute;nica forma de crear un servicio que podemos configurar usando la funci&amp;oacute;n .config (). A diferencia de los m&amp;eacute;todos anteriores, configuraremos los inyectables en una definici&amp;oacute;n definida de esta funci&amp;oacute;n. $ Get ().</target>
        </trans-unit>
        <trans-unit id="33cea9a6904f984abbc8f96a6114e14b3b574e31" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider
  recipe. The &lt;strong&gt;remaining four&lt;/strong&gt; recipe types &amp;mdash; Value, Factory, Service and
  Constant &amp;mdash; &lt;strong&gt;are just syntactic sugar on top of a provider recipe&lt;/strong&gt;.</source>
          <target state="translated">La m&amp;aacute;s detallada, pero tambi&amp;eacute;n la m&amp;aacute;s completa, es una receta de Proveedor. Los &lt;strong&gt;cuatro&lt;/strong&gt; tipos de receta &lt;strong&gt;restantes&lt;/strong&gt; - Valor, F&amp;aacute;brica, Servicio y Constante - &lt;strong&gt;son solo az&amp;uacute;car sint&amp;aacute;ctico adem&amp;aacute;s de una receta de proveedor&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="348c5cf5eea19f952edd139e0384878a13cc16b3" translate="yes" xml:space="preserve">
          <source>The passed function can define a object and return that object. AngularJS simply stores this object reference to a variable which is passed as first argument. Anything which is returned from fnFactory will be bound to serviceInstance . Instead of returning object , we can also return function, values etc, Whatever we will return , will be available to service instance.</source>
          <target state="translated">La función pasada puede definir un objeto y devolverlo.AngularJS simplemente almacena esta referencia de objeto a una variable que se pasa como primer argumento.Cualquier cosa que sea devuelta desde fnFactory estará ligada a serviceInstance.En lugar de devolver el objeto,también podemos devolver la función,los valores,etc.Lo que devolvamos,estará disponible para la instancia de servicio.</target>
        </trans-unit>
        <trans-unit id="d2510f9c93a099e17ccd62f31f88b7b395fab6a8" translate="yes" xml:space="preserve">
          <source>The service returns an object with a method that can be invoked:</source>
          <target state="translated">El servicio devuelve un objeto con un método que puede ser invocado:</target>
        </trans-unit>
        <trans-unit id="c22685b3257f9741c0336da5fe8df717ac146fa0" translate="yes" xml:space="preserve">
          <source>The service() method, on the other hand allows us to create a service by defining a constructor function. We can use a prototypical object to define our service, instead of a raw javascript object.
Similar to the factory() method, we&amp;rsquo;ll also set the injectables in the function definition.</source>
          <target state="translated">El m&amp;eacute;todo service (), por otro lado, nos permite crear un servicio definiendo una funci&amp;oacute;n constructora. Podemos usar un objeto protot&amp;iacute;pico para definir nuestro servicio, en lugar de un objeto javascript sin procesar. Similar al m&amp;eacute;todo factory (), tambi&amp;eacute;n configuraremos los inyectables en la definici&amp;oacute;n de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6d15e1717ce86b0987b078987bab5ad9e89e8630" translate="yes" xml:space="preserve">
          <source>The simplest way of thinking is the following one:</source>
          <target state="translated">La forma más simple de pensar es la siguiente:</target>
        </trans-unit>
        <trans-unit id="d37bdb33569628feda26fad99fde289973152425" translate="yes" xml:space="preserve">
          <source>Then it needs to have a separate &lt;em&gt;$.get&lt;/em&gt; function which is executed by AngularJS after setting the above properties via the &lt;code&gt;app.config&lt;/code&gt; file , and this &lt;em&gt;$.get&lt;/em&gt; function behaves just as the &lt;em&gt;factory&lt;/em&gt; above, in that its return value is used to initialize the &quot;global&quot; variables.</source>
          <target state="translated">Luego, debe tener una funci&amp;oacute;n &lt;em&gt;$ .get&lt;/em&gt; separada que AngularJS ejecuta despu&amp;eacute;s de establecer las propiedades anteriores a trav&amp;eacute;s del archivo &lt;code&gt;app.config&lt;/code&gt; , y esta funci&amp;oacute;n &lt;em&gt;$ .get se&lt;/em&gt; comporta como la &lt;em&gt;f&amp;aacute;brica&lt;/em&gt; anterior, ya que su valor de retorno se usa para inicializar las variables &quot;globales&quot;.</target>
        </trans-unit>
        <trans-unit id="b32fe2094a05734d73d634537bd5399d06168766" translate="yes" xml:space="preserve">
          <source>Then to instantiate you would have to write</source>
          <target state="translated">Entonces para instanciar tendrías que escribir</target>
        </trans-unit>
        <trans-unit id="3dbd87f48f38a7cd7438dff5c9c9a17a54a72326" translate="yes" xml:space="preserve">
          <source>Then we can do this:</source>
          <target state="translated">Entonces podemos hacer esto:</target>
        </trans-unit>
        <trans-unit id="26ab2c621cf3a4ad1aed6bc59c8cac976a8891fc" translate="yes" xml:space="preserve">
          <source>Then we could ask for 'greeter' in controller like this</source>
          <target state="translated">Entonces podríamos pedir un &quot;saludador&quot; en un controlador como este</target>
        </trans-unit>
        <trans-unit id="73c6e7a10f2e40affaa0702fd4636afb5ef0a445" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt;,
&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">Hay cinco tipos de recetas que definen c&amp;oacute;mo crear objetos: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Valor&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;F&amp;aacute;brica&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Servicio&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Proveedor&lt;/a&gt;&lt;/strong&gt; y &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constante&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, 
Factory, Service, Provider and Constant.</source>
          <target state="translated">Hay cinco tipos de recetas que definen cómo crear objetos:Valor,Fábrica,Servicio,Proveedor y Constante.</target>
        </trans-unit>
        <trans-unit id="a3abfbafa21284370080781426e7f10765c626b1" translate="yes" xml:space="preserve">
          <source>There are good answers already, but I just want to share this one.</source>
          <target state="translated">Ya hay buenas respuestas,pero sólo quiero compartir ésta.</target>
        </trans-unit>
        <trans-unit id="cbe50089e98dca4865d62e4d5d431a2ad1e1d31e" translate="yes" xml:space="preserve">
          <source>There are many levels of complications in creating the values for the &quot;global variables&quot;:</source>
          <target state="translated">Hay muchos niveles de complicaciones en la creación de los valores de las &quot;variables globales&quot;:</target>
        </trans-unit>
        <trans-unit id="cfe4afb9db4aa26d7132e641470f68bed3f4242c" translate="yes" xml:space="preserve">
          <source>There is &lt;code&gt;Service vs Factory&lt;/code&gt; part has been covered:
&lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</source>
          <target state="translated">Hay una parte de &lt;code&gt;Service vs Factory&lt;/code&gt; cubierta: &lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8ee704f9be11c360a8332f959f17604faeec8af" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;$get&lt;/code&gt; object that you define and it can be used to get the object that returns data.</source>
          <target state="translated">Hay un objeto &lt;code&gt;$get&lt;/code&gt; que usted define y puede usarse para obtener el objeto que devuelve datos.</target>
        </trans-unit>
        <trans-unit id="5a7068b6dda657b5b0908bbb1b5b47f54867579f" translate="yes" xml:space="preserve">
          <source>This answer address the topic/question</source>
          <target state="translated">Esta respuesta responde a la pregunta del tema</target>
        </trans-unit>
        <trans-unit id="d2ca6aed8a94daf45ebec515f35b4ef0c7e37069" translate="yes" xml:space="preserve">
          <source>This defines an actual constant that should not be modified during the entire application, just like constants in other languages are (something that JavaScript lacks).</source>
          <target state="translated">Esto define una constante real que no debe ser modificada durante toda la aplicación,como lo son las constantes en otros lenguajes (algo de lo que carece JavaScript).</target>
        </trans-unit>
        <trans-unit id="23068a44ce8e025468c6a880cdc354c2346311bc" translate="yes" xml:space="preserve">
          <source>This is a modifiable value or object, and it serves as some global variable, that can even be injected when creating other services or factories (see further on these). However, it must be a &quot;&lt;em&gt;literal value&lt;/em&gt;&quot;, which means that one has to write out the actual value, and cannot use any computation or programming logic (in other words &lt;em&gt;39&lt;/em&gt; or &lt;em&gt;myText&lt;/em&gt; or &lt;em&gt;{prop: &quot;value&quot;}&lt;/em&gt; are OK, but &lt;em&gt;2 +2&lt;/em&gt; is not).</source>
          <target state="translated">Este es un valor u objeto modificable, y sirve como una variable global, que incluso puede inyectarse al crear otros servicios o f&amp;aacute;bricas (ver m&amp;aacute;s sobre estos). Sin embargo, debe ser un &quot; &lt;em&gt;valor literal&lt;/em&gt; &quot;, lo que significa que uno tiene que escribir el valor real y no puede usar ninguna l&amp;oacute;gica de c&amp;aacute;lculo o programaci&amp;oacute;n (en otras palabras, &lt;em&gt;39&lt;/em&gt; o &lt;em&gt;myText&lt;/em&gt; o &lt;em&gt;{prop: &quot;value&quot;}&lt;/em&gt; est&amp;aacute;n bien, pero &lt;em&gt;2 +2&lt;/em&gt; no lo es).</target>
        </trans-unit>
        <trans-unit id="7c23aa97141e4f8d46377a4215db03016a94f612" translate="yes" xml:space="preserve">
          <source>This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the &amp;lsquo;new&amp;rsquo; keyword, &amp;lsquo;this&amp;rsquo; will be bound to the newly created object.</source>
          <target state="translated">Esta es una funci&amp;oacute;n t&amp;iacute;pica de constructor de JavaScript. Ahora, cada vez que invoquemos la funci&amp;oacute;n Persona usando la palabra clave 'nuevo', 'esto' estar&amp;aacute; vinculado al objeto reci&amp;eacute;n creado.</target>
        </trans-unit>
        <trans-unit id="dfb8cea8751eb472adb742095a7b2c6e23a67444" translate="yes" xml:space="preserve">
          <source>This is the behavior for any complex values (objects, functions) but not for primitive types.</source>
          <target state="translated">Este es el comportamiento para cualquier valor complejo (objetos,funciones)pero no para los tipos primitivos.</target>
        </trans-unit>
        <trans-unit id="f1e7c9cd5dc0b108189dc22be56ae3d9ed503494" translate="yes" xml:space="preserve">
          <source>This is very confusing part for newbie and I have tried to clarify it in easy words</source>
          <target state="translated">Esta es una parte muy confusa para el novato y he tratado de aclararla con palabras fáciles</target>
        </trans-unit>
        <trans-unit id="0071c8fa9a8db22cbf7fe7086f0e4a422890b5c6" translate="yes" xml:space="preserve">
          <source>This is why we use &lt;code&gt;this&lt;/code&gt; in services, and define a &lt;code&gt;this.$get&lt;/code&gt; in providers.</source>
          <target state="translated">Es por eso que usamos &lt;code&gt;this&lt;/code&gt; en los servicios, y definimos &lt;code&gt;this.$get&lt;/code&gt; en proveedores.</target>
        </trans-unit>
        <trans-unit id="337dbda194e27c65c3b59a20fcfe6f20bce044b3" translate="yes" xml:space="preserve">
          <source>This means that you can basically copy-paste the factory example from below, replace &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;service&lt;/code&gt;, and it&amp;rsquo;ll work:</source>
          <target state="translated">Esto significa que b&amp;aacute;sicamente puede copiar y pegar el ejemplo de f&amp;aacute;brica desde abajo, reemplazar la &lt;code&gt;factory&lt;/code&gt; con &lt;code&gt;service&lt;/code&gt; , y funcionar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="bcb15b94b5801e9e5561df693ee7def2f99bdaf9" translate="yes" xml:space="preserve">
          <source>To really see the changes that occur when you invoke a function with the &amp;lsquo;new&amp;rsquo; keyword, let&amp;rsquo;s create a function and invoke it with the &amp;lsquo;new&amp;rsquo; keyword, then let&amp;rsquo;s show what the interpreter does when it sees the &amp;lsquo;new&amp;rsquo; keyword. The end results will both be the same.</source>
          <target state="translated">Para ver realmente los cambios que ocurren cuando invoca una funci&amp;oacute;n con la palabra clave 'nueva', creemos una funci&amp;oacute;n e invoqu&amp;eacute;mosla con la palabra clave 'nueva', luego muestremos qu&amp;eacute; hace el int&amp;eacute;rprete cuando ve la palabra clave 'nueva'. Los resultados finales ser&amp;aacute;n los mismos.</target>
        </trans-unit>
        <trans-unit id="f002fd0a5d473826ead53b980392d6392a7e2430" translate="yes" xml:space="preserve">
          <source>Unlike a service which is a simplified version of &lt;em&gt;factory&lt;/em&gt;, a provider is a more complex, but more flexible way of initializing the &quot;global&quot; variables, with the biggest flexibility being the option to set values from the app.config.</source>
          <target state="translated">A diferencia de un servicio que es una versi&amp;oacute;n simplificada de &lt;em&gt;f&amp;aacute;brica&lt;/em&gt; , un proveedor es una forma m&amp;aacute;s compleja pero m&amp;aacute;s flexible de inicializar las variables &quot;globales&quot;, siendo la mayor flexibilidad la opci&amp;oacute;n de establecer valores desde app.config.</target>
        </trans-unit>
        <trans-unit id="864ea43a8c2da87a50b0e143c273a5376c32245f" translate="yes" xml:space="preserve">
          <source>Unlike what we originally did with the Factory example, we don&amp;rsquo;t need to create an object then return that object because, like mentioned many times before, we used the &amp;lsquo;new&amp;rsquo; keyword so the interpreter will create that object, have it delegate to it&amp;rsquo;s prototype, then return it for us without us having to do the work.</source>
          <target state="translated">A diferencia de lo que hicimos originalmente con el ejemplo de Factory, no necesitamos crear un objeto y luego devolverlo porque, como se mencion&amp;oacute; muchas veces antes, usamos la palabra clave 'new' para que el int&amp;eacute;rprete cree ese objeto, haga que delegue en es prototipo, luego devu&amp;eacute;lvanoslo sin que tengamos que hacer el trabajo.</target>
        </trans-unit>
        <trans-unit id="b49caeb887a29a8bada2966d7c2590d853f20723" translate="yes" xml:space="preserve">
          <source>Usage (as an injectable in a controller)</source>
          <target state="translated">Uso (como inyectable en un controlador)</target>
        </trans-unit>
        <trans-unit id="879ae7be1e519b410069e2f401b1f3f754b21f05" translate="yes" xml:space="preserve">
          <source>Usage (configuring the provider before &lt;code&gt;$get&lt;/code&gt; is called to create the injectable)</source>
          <target state="translated">Uso (configurar el proveedor antes &lt;code&gt;$get&lt;/code&gt; se llame $ get para crear el inyectable)</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="4022b8a59a0d0d2ca89f1ecfac78f71d1bc33304" translate="yes" xml:space="preserve">
          <source>Use it when you need to share a single object throughout the application. For example, authenticated user details, share-able methods/data, Utility functions etc.</source>
          <target state="translated">Úsalo cuando necesites compartir un solo objeto en toda la aplicación.Por ejemplo,detalles de usuario autentificados,datos de métodos compartibles,funciones de utilidad,etc.</target>
        </trans-unit>
        <trans-unit id="c140efc7adf0e2b8a74e6393e081cb7475561437" translate="yes" xml:space="preserve">
          <source>Use this link for code reference</source>
          <target state="translated">Utilice este enlace para la referencia del código</target>
        </trans-unit>
        <trans-unit id="be9209121182255216aaa47dfd1cae1b29bb43e3" translate="yes" xml:space="preserve">
          <source>Using as reference this page and the &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentation&lt;/a&gt; (which seems to have greatly improved since the last time I looked), I put together the following real(-ish) world demo which uses 4 of the 5 flavours of provider; Value, Constant, Factory and full blown Provider.</source>
          <target state="translated">Utilizando como referencia esta p&amp;aacute;gina y la &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; (que parece haber mejorado mucho desde la &amp;uacute;ltima vez que mir&amp;eacute;), arm&amp;eacute; la siguiente demostraci&amp;oacute;n mundial real (-ish) que utiliza 4 de los 5 sabores de proveedor; Valor, constante, f&amp;aacute;brica y proveedor completo.</target>
        </trans-unit>
        <trans-unit id="7f1b9dfcd80673ff780bfe6c9e4b747b202f04d5" translate="yes" xml:space="preserve">
          <source>Using the factory() in our app</source>
          <target state="translated">Usando la fábrica()en nuestra aplicación</target>
        </trans-unit>
        <trans-unit id="93312e4afaa947b3a60bfa6bea40f131935883a5" translate="yes" xml:space="preserve">
          <source>Visibility of injectables is different for providers than it is for services and factories. If you declare an AngularJS &quot;constant&quot; (for example, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt;), you can inject it into services, factories, and providers.</source>
          <target state="translated">La visibilidad de los inyectables es diferente para los proveedores que para los servicios y las f&amp;aacute;bricas. Si declara una &quot;constante&quot; de AngularJS (por ejemplo, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt; ), puede inyectarla en servicios, f&amp;aacute;bricas y proveedores.</target>
        </trans-unit>
        <trans-unit id="d22cafa4fcd376a2f27d8c4831e76c2f8fa630f7" translate="yes" xml:space="preserve">
          <source>We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven&amp;rsquo;t had much experience using promises in AngularJS, I highly recommend doing a deep dive on them.</source>
          <target state="translated">Vamos a crear m&amp;eacute;todos setArtist y getArtist que simplemente devuelven o configuran al artista. Tambi&amp;eacute;n vamos a crear un m&amp;eacute;todo que llamar&amp;aacute; a la API de iTunes con nuestra URL creada. Este m&amp;eacute;todo devolver&amp;aacute; una promesa que se cumplir&amp;aacute; una vez que los datos hayan regresado de la API de iTunes. Si no ha tenido mucha experiencia usando promesas en AngularJS, le recomiendo que profundice en ellas.</target>
        </trans-unit>
        <trans-unit id="c68ba4741829821c5273926306c848fe58e787c7" translate="yes" xml:space="preserve">
          <source>We can create configurable services using provider syntax as given below.</source>
          <target state="translated">Podemos crear servicios configurables utilizando la sintaxis del proveedor como se indica a continuación.</target>
        </trans-unit>
        <trans-unit id="dbe235285ce55886f522548de7d34e5b6a156187" translate="yes" xml:space="preserve">
          <source>We can define a factory function as below.</source>
          <target state="translated">Podemos definir una función de fábrica como la siguiente.</target>
        </trans-unit>
        <trans-unit id="9dc701ea399c4055cce4573cf97749a703eb7d4a" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Provider&lt;/code&gt; and &lt;code&gt;Factory&lt;/code&gt; in AngularJS?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son las diferencias entre un &lt;code&gt;Service&lt;/code&gt; , un &lt;code&gt;Provider&lt;/code&gt; y una &lt;code&gt;Factory&lt;/code&gt; en AngularJS?</target>
        </trans-unit>
        <trans-unit id="1d97deb201bb1447c8de5b02c7b3a99898edb8b5" translate="yes" xml:space="preserve">
          <source>When Angular injects this &lt;code&gt;MyService&lt;/code&gt; service into a controller that
  depends on it, that controller will get a &lt;code&gt;MyService&lt;/code&gt; that it can call
  functions on, e.g. MyService.aServiceMethod ().</source>
          <target state="translated">Cuando Angular inyecta este servicio &lt;code&gt;MyService&lt;/code&gt; en un controlador que depende de &amp;eacute;l, ese controlador obtendr&amp;aacute; un &lt;code&gt;MyService&lt;/code&gt; al que puede llamar funciones, por ejemplo, MyService.aServiceMethod ().</target>
        </trans-unit>
        <trans-unit id="71e6a586496bb64a15227083621aef43a2714aea" translate="yes" xml:space="preserve">
          <source>When creating a service with Provider, the only properties/methods that will be available in your controller are those properties/methods which are returned from the $get() function. The code below puts $get on &amp;lsquo;this&amp;rsquo; (which we know will eventually be returned from that function). Now, that $get function returns all the methods/properties we want to be available in the controller. Here&amp;rsquo;s a code example.</source>
          <target state="translated">Al crear un servicio con el Proveedor, las &amp;uacute;nicas propiedades / m&amp;eacute;todos que estar&amp;aacute;n disponibles en su controlador son aquellas propiedades / m&amp;eacute;todos que se devuelven de la funci&amp;oacute;n $ get (). El siguiente c&amp;oacute;digo pone $ get en 'this' (que sabemos que eventualmente ser&amp;aacute; devuelto por esa funci&amp;oacute;n). Ahora, esa funci&amp;oacute;n $ get devuelve todos los m&amp;eacute;todos / propiedades que queremos que est&amp;eacute;n disponibles en el controlador. Aqu&amp;iacute; hay un ejemplo de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="3bc3b865d96d4a3942513d9897a3bb409a798a5a" translate="yes" xml:space="preserve">
          <source>When making a &lt;code&gt;service()&lt;/code&gt; it return you providing a factory() with a &lt;code&gt;function&lt;/code&gt; that injects the &lt;code&gt;constructor&lt;/code&gt; (return the instance of the constructor you provided in your service) and returns it</source>
          <target state="translated">Al hacer un &lt;code&gt;service()&lt;/code&gt; le devuelve una f&amp;aacute;brica () con una &lt;code&gt;function&lt;/code&gt; que inyecta el &lt;code&gt;constructor&lt;/code&gt; (devuelve la instancia del constructor que proporcion&amp;oacute; en su servicio) y lo devuelve</target>
        </trans-unit>
        <trans-unit id="d6d43abc5bb66cd755013d3ef82d0ae0e0cc46c8" translate="yes" xml:space="preserve">
          <source>When you make a &lt;code&gt;factory()&lt;/code&gt; it sets you &lt;code&gt;function&lt;/code&gt; provided in second argument to provider's &lt;code&gt;$get&lt;/code&gt; and return it(&lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt;),</source>
          <target state="translated">Cuando crea una &lt;code&gt;factory()&lt;/code&gt; , establece su &lt;code&gt;function&lt;/code&gt; provista en el segundo argumento del proveedor &lt;code&gt;$get&lt;/code&gt; y devuelve ( &lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="45f317e75b95e397ea00208400104d4fe8bf5e18" translate="yes" xml:space="preserve">
          <source>When you need to provide module-wise configuration for your service object before making it available, eg. suppose you want to set your API URL on basis of your Environment like &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;stage&lt;/code&gt; or &lt;code&gt;prod&lt;/code&gt;</source>
          <target state="translated">Cuando necesite proporcionar una configuraci&amp;oacute;n de m&amp;oacute;dulo inteligente para su objeto de servicio antes de ponerlo a disposici&amp;oacute;n, por ejemplo. supongamos que desea establecer su URL de API en funci&amp;oacute;n de su entorno como &lt;code&gt;dev&lt;/code&gt; , &lt;code&gt;stage&lt;/code&gt; o &lt;code&gt;prod&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d9813216aceb4fb52c9772759aad11c548dbb06" translate="yes" xml:space="preserve">
          <source>Which means there&amp;rsquo;s something like a cache object inside AngularJS, whose value of each injection is only assigned once, when they've been injected the first time, and where:</source>
          <target state="translated">Lo que significa que hay algo as&amp;iacute; como un objeto de cach&amp;eacute; dentro de AngularJS, cuyo valor de cada inyecci&amp;oacute;n solo se asigna una vez, cuando se inyectaron la primera vez y d&amp;oacute;nde:</target>
        </trans-unit>
        <trans-unit id="9a5bdc65b2c24b100cbcaaaa5059622b099681ae" translate="yes" xml:space="preserve">
          <source>While global variables are not recommended, the real usage of these global variables is to provide &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, by passing the variable to the relevant controller.</source>
          <target state="translated">Si bien no se recomiendan las variables globales, el uso real de estas variables globales es proporcionar &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;inyecci&amp;oacute;n de dependencia&lt;/a&gt; , pasando la variable al controlador relevante.</target>
        </trans-unit>
        <trans-unit id="b5f5a2ae1fcba7052d4d70638cf84ffe0eb2743b" translate="yes" xml:space="preserve">
          <source>Working &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;demo&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;Demo de&lt;/a&gt; trabajo.</target>
        </trans-unit>
        <trans-unit id="c5b3d2c4eb971fcbd43812638af12c7dc4437f9c" translate="yes" xml:space="preserve">
          <source>Working Demo</source>
          <target state="translated">Demo de trabajo</target>
        </trans-unit>
        <trans-unit id="9fd4dd933fe260f137acd6eae3ea36eb6536140b" translate="yes" xml:space="preserve">
          <source>You can think of Providers as having three sections. The first section is the &amp;lsquo;private&amp;rsquo; variables/functions that will be modified/set later (shown above). The second section is the variables/functions that will be available in your app.config function and are therefore available to alter before they&amp;rsquo;re available anywhere else (also shown above). It&amp;rsquo;s important to note that those variables need to be attached to the &amp;lsquo;this&amp;rsquo; keyword. In our example, only &amp;lsquo;thingFromConfig&amp;rsquo; will be available to alter in the app.config. The third section (shown below) is all the variables/functions that will be available in your controller when you pass in the &amp;lsquo;myProvider&amp;rsquo; service into that specific controller.</source>
          <target state="translated">Puede pensar que los Proveedores tienen tres secciones. La primera secci&amp;oacute;n son las variables / funciones 'privadas' que se modificar&amp;aacute;n / establecer&amp;aacute;n m&amp;aacute;s tarde (como se muestra arriba). La segunda secci&amp;oacute;n son las variables / funciones que estar&amp;aacute;n disponibles en su funci&amp;oacute;n app.config y, por lo tanto, est&amp;aacute;n disponibles para modificar antes de que est&amp;eacute;n disponibles en cualquier otro lugar (tambi&amp;eacute;n se muestra arriba). Es importante tener en cuenta que esas variables deben adjuntarse a la palabra clave 'this'. En nuestro ejemplo, solo 'thingFromConfig' estar&amp;aacute; disponible para modificar en la app.config. La tercera secci&amp;oacute;n (que se muestra a continuaci&amp;oacute;n) es todas las variables / funciones que estar&amp;aacute;n disponibles en su controlador cuando pase el servicio 'myProvider' a ese controlador espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="8b95d0adc56d83fa7498365437f66e79ee788966" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to return a value. When Angular calls &lt;code&gt;new yourServiceName(&lt;/code&gt;), it&amp;rsquo;ll receive the &lt;code&gt;this&lt;/code&gt; object with all the properties you put on it.</source>
          <target state="translated">No necesita devolver un valor. Cuando Angular llama al &lt;code&gt;new yourServiceName(&lt;/code&gt; ), recibir&amp;aacute; el objeto &lt;code&gt;this&lt;/code&gt; con todas las propiedades que le pones.</target>
        </trans-unit>
        <trans-unit id="3fe544a5098b0be6e451614ad5ff4af0887aea93" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will cache and inject the return value when the factory is requested.</source>
          <target state="translated">Si le das una función a AngularJS,AngularJS se almacenará e inyectará el valor de retorno cuando la fábrica lo solicite.</target>
        </trans-unit>
        <trans-unit id="7733853022202a91bba391de813e5ef65f7cfeb5" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will call &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; to instantiate it. It is the instance that AngularJS creates that will be cached and injected when the service is requested. Since &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; was used to instantiate the service, the keyword &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; is valid and refers to the instance.</source>
          <target state="translated">Le das a AngularJS una funci&amp;oacute;n, AngularJS llamar&amp;aacute; a &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; para instanciarla. Es la instancia que crea AngularJS la que se almacenar&amp;aacute; en cach&amp;eacute; e inyectar&amp;aacute; cuando se solicite el servicio. Como se us&amp;oacute; &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; para instanciar el servicio, la palabra clave &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; es v&amp;aacute;lida y se refiere a la instancia.</target>
        </trans-unit>
        <trans-unit id="a2a1ff92c50375a3fdf5b1809ff8ea225aab5a9c" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, and AngularJS will call its &lt;code&gt;$get&lt;/code&gt; function. It is the return value from the &lt;code&gt;$get&lt;/code&gt; function that will be cached and injected when the service is requested.</source>
          <target state="translated">Le das a AngularJS una funci&amp;oacute;n, y AngularJS llamar&amp;aacute; a su funci&amp;oacute;n &lt;code&gt;$get&lt;/code&gt; . Es el valor de retorno de la funci&amp;oacute;n &lt;code&gt;$get&lt;/code&gt; que se almacenar&amp;aacute; en cach&amp;eacute; e inyectar&amp;aacute; cuando se solicite el servicio.</target>
        </trans-unit>
        <trans-unit id="3876a0940a5a7dd665609735ebfa32e7f6e1bcc3" translate="yes" xml:space="preserve">
          <source>You just have a standard function that uses this keyword to define a function.</source>
          <target state="translated">Sólo tienes una función estándar que utiliza esta palabra clave para definir una función.</target>
        </trans-unit>
        <trans-unit id="866717a4969cced464a5c0ae6684faada33bde94" translate="yes" xml:space="preserve">
          <source>You might be tempted to call &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; in a promise chain, for instance if you initialized the score by grabbing it from the server: &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; The trouble with this is that &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; will be called with &lt;code&gt;this&lt;/code&gt; bound to &lt;code&gt;null&lt;/code&gt; and you&amp;rsquo;ll get errors. The better way would be &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt;.
Whether you choose to use this in your service methods or not, be careful how you call them.</source>
          <target state="translated">Es posible que &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; tentaci&amp;oacute;n de llamar a ScoreKeeper.setScore en una cadena de promesa, por ejemplo, si inicializ&amp;oacute; el puntaje &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; del servidor: $ http.get ('/ score'). Luego (ScoreKeeper.setScore). El problema con esto es que se &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; a ScoreKeeper.setScore con &lt;code&gt;this&lt;/code&gt; vinculado a &lt;code&gt;null&lt;/code&gt; y obtendr&amp;aacute; errores. La mejor manera ser&amp;iacute;a &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt; . Ya sea que elija usar esto en sus m&amp;eacute;todos de servicio o no, tenga cuidado de c&amp;oacute;mo los llama.</target>
        </trans-unit>
        <trans-unit id="bea982bb9c2f6821b3f44edf8dad402dddc73177" translate="yes" xml:space="preserve">
          <source>You should use the Provider recipe only when you want to expose an API
  for application-wide configuration that must be made before the
  application starts. This is usually interesting only for reusable
  services whose behavior might need to vary slightly between
  applications.</source>
          <target state="translated">Debe utilizar la receta del Proveedor sólo cuando desee exponer una API para la configuración de toda la aplicación que debe realizarse antes de que ésta se inicie.Esto suele ser interesante sólo para los servicios reutilizables cuyo comportamiento podría tener que variar ligeramente entre aplicaciones.</target>
        </trans-unit>
        <trans-unit id="c5956833324972c28737ee048ed90ebe091ca59b" translate="yes" xml:space="preserve">
          <source>_artist is the artist we wish to lookup</source>
          <target state="translated">El artista es el artista que queremos buscar...</target>
        </trans-unit>
        <trans-unit id="72921d9d0e40db1cd6390dcc0077ecda67c652ba" translate="yes" xml:space="preserve">
          <source>_finalUrl is the final and fully built URL to which we&amp;rsquo;ll make the call to iTunes</source>
          <target state="translated">_finalUrl es la URL final y totalmente construida a la que haremos la llamada a iTunes</target>
        </trans-unit>
        <trans-unit id="0bfda8d377c2609cd9d50c5b636b767072ce4e18" translate="yes" xml:space="preserve">
          <source>ability to use other services (have dependencies)</source>
          <target state="translated">capacidad de utilizar otros servicios (tener dependencias)</target>
        </trans-unit>
        <trans-unit id="6a925e5ed5ce5e858b8242994457f2ab7ac71782" translate="yes" xml:space="preserve">
          <source>all you get is &lt;code&gt;provider&lt;/code&gt; but there is no property/method other than &lt;code&gt;$get&lt;/code&gt;</source>
          <target state="translated">todo lo que obtienes es &lt;code&gt;provider&lt;/code&gt; pero no hay otra propiedad / m&amp;eacute;todo que no sea &lt;code&gt;$get&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d27b037fa89342a90ff5d6df4947c9eece46029" translate="yes" xml:space="preserve">
          <source>and returns &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">y devuelve &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="402433d1fb629334beefb9cb164a7a1c035c71e7" translate="yes" xml:space="preserve">
          <source>and using:</source>
          <target state="translated">y consumiendo:</target>
        </trans-unit>
        <trans-unit id="427c1761ab15aa547603cd68334d242a2d5523d9" translate="yes" xml:space="preserve">
          <source>baseUrl is the base URL that the iTunes API requires</source>
          <target state="translated">baseUrl es la URL base que el API de iTunes requiere</target>
        </trans-unit>
        <trans-unit id="2cdaa8f3ceef76f1dc730a6b60c06476e795c676" translate="yes" xml:space="preserve">
          <source>basically what happens is</source>
          <target state="translated">básicamente lo que pasa es</target>
        </trans-unit>
        <trans-unit id="b50ae779a31c55dd00a1f71d908a312cbc40af0a" translate="yes" xml:space="preserve">
          <source>connects &lt;code&gt;context&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">conecta el &lt;code&gt;context&lt;/code&gt; o a &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54bf3f1ce25250844230f2deb1ca4ace3b97b315" translate="yes" xml:space="preserve">
          <source>creates brand new object</source>
          <target state="translated">crea un nuevo objeto</target>
        </trans-unit>
        <trans-unit id="deb0c5efabe5381fec4da90741ac9ac67289b4ec" translate="yes" xml:space="preserve">
          <source>delayed/lazy initialization</source>
          <target state="translated">inicialización retardada</target>
        </trans-unit>
        <trans-unit id="0188b442c8481c48fffbded6f20f1d6cded3c775" translate="yes" xml:space="preserve">
          <source>how Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo Factory, Service y Constant - son solo az&amp;uacute;car sint&amp;aacute;ctico sobre la receta de un proveedor?</target>
        </trans-unit>
        <trans-unit id="8f55d557046d81d78de7516299b50060cdf7c55b" translate="yes" xml:space="preserve">
          <source>how factory ,servic and providers are simailar internally</source>
          <target state="translated">cómo la fábrica,el servicio y los proveedores se simailan internamente</target>
        </trans-unit>
        <trans-unit id="ce1ed02a506c79b6518185593802fbb4aaa54d8a" translate="yes" xml:space="preserve">
          <source>links it to its &lt;code&gt;prototype&lt;/code&gt; object</source>
          <target state="translated">lo vincula a su objeto &lt;code&gt;prototype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e4306c581e1c078a3c92df9bd0a6162776ce8e8" translate="yes" xml:space="preserve">
          <source>makeUrl is a function that will create and return our iTunes friendly URL.</source>
          <target state="translated">makeUrl es una función que creará y devolverá nuestra URL amigable de iTunes.</target>
        </trans-unit>
        <trans-unit id="ba23da34d1e3b19225a60f4a7206e21e32aad969" translate="yes" xml:space="preserve">
          <source>of that &lt;code&gt;provider&lt;/code&gt;(means you can't configure this)</source>
          <target state="translated">de ese &lt;code&gt;provider&lt;/code&gt; (significa que no puede configurar esto)</target>
        </trans-unit>
        <trans-unit id="6192271d0d781e240956f0b4f5271f3d5d92ac46" translate="yes" xml:space="preserve">
          <source>service initialization</source>
          <target state="translated">inicialización del servicio</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
