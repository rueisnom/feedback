<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/15666048">
    <body>
      <group id="15666048">
        <trans-unit id="64a58ac5bcfe347c123a856c3f7ac41a16c18e93" translate="yes" xml:space="preserve">
          <source>&quot; Hello world &quot; example with &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt; 使用した「Hello World」の例：</target>
        </trans-unit>
        <trans-unit id="27ab96a759e2b4ef1d829c8525ca087d26314532" translate="yes" xml:space="preserve">
          <source>&quot;$injector is used to retrieve object instances as defined by &lt;strong&gt;provider&lt;/strong&gt;&quot; not service, not factory but provider.</source>
          <target state="translated">&quot;$ injectorは、サービスではなく、プロバイダーではなく&lt;strong&gt;プロバイダー&lt;/strong&gt;によって定義されたオブジェクトインスタンスを取得するために使用されます。</target>
        </trans-unit>
        <trans-unit id="47d91685928f3bdbd8a6e0bbabc322e70072c356" translate="yes" xml:space="preserve">
          <source>*Again if any portion of the above code is confusing, check out the Factory section where I explain what it all does it greater details.</source>
          <target state="translated">*上記のコードのいずれかの部分が混乱している場合は、私はそれがすべてそれ以上の詳細を行うには何を説明する工場のセクションをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="f4d91701275cfa2997fcf5752d0f40b1c281d19d" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;service&lt;/code&gt; for most cases of default</source>
          <target state="translated">1.デフォルトのほとんどの場合の &lt;code&gt;service&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b474cc94e43caf4ce704bf9f973a68251b25cd13" translate="yes" xml:space="preserve">
          <source>1.Provider object is created using constructor function we defined in our provider function.</source>
          <target state="translated">1.プロバイダ関数で定義したコンストラクタ関数を使用してプロバイダオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="4c2cfdc84411546e36f7e4d88a4a92785dd9ead0" translate="yes" xml:space="preserve">
          <source>1.Services are singleton objects that are created when necessary and are never cleaned up until the end of the application life-cycle (when the browser is closed). Controllers are destroyed and cleaned up when they are no longer needed.</source>
          <target state="translated">1.サービスは、必要なときに作成され、アプリケーションのライフサイクルが終了するまで(ブラウザが閉じられるまで)クリーンアップされることのないシングルトンオブジェクトです。コントローラは不要になったときに破棄され、クリーンアップされます。</target>
        </trans-unit>
        <trans-unit id="4edf8c51b9d95a7ca3a85d5aeca515c293064266" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;factory&lt;/code&gt; used to create the service that specific instance</source>
          <target state="translated">2.特定のインスタンスのサービスを作成するために使用される &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01f9f1efa5be666f175edf0f3d066f99322711a" translate="yes" xml:space="preserve">
          <source>2.The easiest way to create a service is by using the factory() method.
The factory() method allows us to define a service by returning an object that contains service functions and service data. The service definition function is where we place our injectable services, such as $http and $q.
Ex:</source>
          <target state="translated">2.サービスを作成する最も簡単な方法は、factory()メソッドを使用することです。factory()メソッドでは、サービス関数とサービスデータを含むオブジェクトを返すことで、サービスを定義することができます。サービス定義関数は、$http や $q などの注入可能なサービスを配置する場所です。たとえば、$http や $q などの注入可能なサービスを配置します。</target>
        </trans-unit>
        <trans-unit id="81049cf8d158fd8f6aa9e09fb3f7674dc7278ae0" translate="yes" xml:space="preserve">
          <source>2.The function we passed in app.config(), get executed. This is called config phase, and here we have a chance to customize our service.</source>
          <target state="translated">2.app.config()で渡した関数が実行されます。これはconfigフェーズと呼ばれるもので、ここではサービスをカスタマイズする機会があります。</target>
        </trans-unit>
        <trans-unit id="e06f9e5bc87b677a928a701f0b17b557a83c7cd8" translate="yes" xml:space="preserve">
          <source>3.Finally service instance is created by calling $get method of serviceProvider.</source>
          <target state="translated">3.最後にserviceProviderの$getメソッドを呼び出してサービスインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="10247f3761146ad3fd29f8f04438a385637cbd75" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt;  (&amp;lt;-- GOOD)
&lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673（&amp;lt;-GOOD）https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96509fbd15a55d9f8c6b0f16f86f369bd1959c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;'s stored value comes from running &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の保存された値は、 &lt;code&gt;fn&lt;/code&gt; の実行から取得されます。</target>
        </trans-unit>
        <trans-unit id="9806d20accdcf4a7d7bf03bac15b08c0e80af8cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;&amp;rsquo;s stored value comes from &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; の格納値は、 &lt;code&gt;new&lt;/code&gt; ing &lt;code&gt;fn&lt;/code&gt; から取得されます。</target>
        </trans-unit>
        <trans-unit id="c10d4a6de0cf092cde9d6b1c37da584005618d85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;&amp;rsquo;s stored value comes from first getting an instance by &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;, and then running a &lt;code&gt;$get&lt;/code&gt; method of the instance.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の格納された値は、最初に &lt;code&gt;new&lt;/code&gt; ing &lt;code&gt;fn&lt;/code&gt; によってインスタンスを取得し、次にインスタンスの &lt;code&gt;$get&lt;/code&gt; メソッドを実行することから取得されます。</target>
        </trans-unit>
        <trans-unit id="f37e6ab171ca302e86496ad45c7c8b082187c7b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lazily Instantiated&lt;/em&gt;: If it is not injected it won't be instantiated ever. So to use it will have to inject it to a module.</source>
          <target state="translated">&lt;em&gt;遅延インスタンス化&lt;/em&gt; ：注入されない場合、インスタンス化されません。 したがって、それを使用するには、モジュールに注入する必要があります。</target>
        </trans-unit>
        <trans-unit id="bbc415a0718bc792ec75efc2d5784a6b2ed76fb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Singleton&lt;/em&gt;: If injected to multiple modules, all will have access to only one particular instance. That is why very convenient to share data across different controllers.</source>
          <target state="translated">&lt;em&gt;シングルトン&lt;/em&gt; ：複数のモジュールに注入された場合、すべてが特定の1つのインスタンスにのみアクセスできます。 これが、異なるコントローラ間でデータを共有するのに非常に便利な理由です。</target>
        </trans-unit>
        <trans-unit id="de74c279e2d766663b22cc4a4bef8ec70061c8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）工場&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1920da3aedb3ed95be87c557b3978bf5d2066e0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; When you&amp;rsquo;re using a &lt;strong&gt;Factory&lt;/strong&gt; you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.</source>
          <target state="translated">&lt;strong&gt;1）&lt;/strong&gt; &lt;strong&gt;ファクトリ&lt;/strong&gt;を使用している場合、オブジェクトを作成し、それにプロパティを追加してから、同じオブジェクトを返します。 このファクトリをコントローラーに渡すと、オブジェクトのこれらのプロパティは、ファクトリを介してそのコントローラーで使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="bf79a918a5f8400f69451d6c86a9de8622bc5f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）サービス&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fa71875fc3e6ae341d7d13637af55d62c8e9c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; When you&amp;rsquo;re using &lt;strong&gt;Service&lt;/strong&gt;, AngularJS instantiates it behind the scenes with the &amp;lsquo;new&amp;rsquo; keyword. Because of that, you&amp;rsquo;ll add properties to &amp;lsquo;this&amp;rsquo; and the service will return &amp;lsquo;this&amp;rsquo;. When you pass the service into your controller, those properties on &amp;lsquo;this&amp;rsquo; will now be available on that controller through your service.</source>
          <target state="translated">&lt;strong&gt;2）&lt;/strong&gt; &lt;strong&gt;Service&lt;/strong&gt;を使用している場合、AngularJSは 'new'キーワードを使用して&lt;strong&gt;サービスを&lt;/strong&gt;バックグラウンドでインスタンス化します。 そのため、プロパティを「this」に追加すると、サービスは「this」を返します。 サービスをコントローラーに渡すと、「this」のこれらのプロパティは、サービスを通じてそのコントローラーで使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="e5e4c731a8abb79b43eb7b7ad7722ae53bd1e526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3）プロバイダー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7891b22be8f5ced507d3b35a1a21c59dd69ef84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt;&lt;strong&gt;Providers&lt;/strong&gt; are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.</source>
          <target state="translated">&lt;strong&gt;3）&lt;/strong&gt; &lt;strong&gt;プロバイダー&lt;/strong&gt;は、.config（）関数に渡すことができる唯一のサービスです。 サービスオブジェクトを使用可能にする前にモジュール全体の構成をサービスオブジェクトに提供する場合は、プロバイダーを使用します。</target>
        </trans-unit>
        <trans-unit id="f7a0bc6a5e55d68fca9019cb4c62b65667302df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Is they do same or have same behaviour?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;彼らは同じことをしますか、それとも同じ行動をしますか？&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a51970d21894731b55def79e30e17e9251193f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Should I use service or factory? What&amp;rsquo;s the difference?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;サービスまたは工場を使用する必要がありますか？&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;違いは何ですか？&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61bce34778beb7a07d2ad51ff5e0491a8fe2ce06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And for beginner understand:-&lt;/strong&gt; This may not correct use case but in high level this is what usecase for these three.</source>
          <target state="translated">&lt;strong&gt;そして、初心者のために理解してください：-&lt;/strong&gt;これはユースケースを修正しないかもしれませんが、高レベルではこれはこれら3つのユースケースです</target>
        </trans-unit>
        <trans-unit id="49456beeefd4b18f05312ca85704d73c7cc3b7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; the purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.</source>
          <target state="translated">&lt;strong&gt;AngularJS Factory：Factory&lt;/strong&gt;の目的もServiceと同じですが、この場合、新しいオブジェクトを作成し、このオブジェクトのプロパティとして関数を追加し、最後にこのオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="42188f33ed58db2766909a9db9de01785a8ee47d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Provider:&lt;/strong&gt; the purpose of this is again same however Provider gives the output of it's $get function.</source>
          <target state="translated">&lt;strong&gt;AngularJSプロバイダー：&lt;/strong&gt;目的は同じですが、プロバイダーは$ get関数の出力を提供します。</target>
        </trans-unit>
        <trans-unit id="9a762ecbec3e860f39ad0b1b9673d2ba4d24939f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Service:&lt;/strong&gt; is used for sharing utility functions with the service reference in the controller. Service is singleton in nature so for one service only one instance is created in the browser and the same reference is used throughout the page.</source>
          <target state="translated">&lt;strong&gt;AngularJSサービス：&lt;/strong&gt;コントローラーのサービス参照とユーティリティ関数を共有するために使用されます。 サービスは本質的にシングルトンであるため、1つのサービスについてはブラウザーで1つのインスタンスのみが作成され、ページ全体で同じ参照が使用されます。</target>
        </trans-unit>
        <trans-unit id="ba46456a9f8e88791102b2d89c6c02c5e47d2e18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful with &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; 注意してください&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf2cbd4114b4edf85514bcf9f1a8b65ee626a848" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best answers from SO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SOからの最良の回答：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867130b32fc3b28fc8ec819aa9caaebbdcd1a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both are Singletons&lt;/strong&gt;: Whenever Angular find these as a dependency first time,it create a single instance of service/factory. Once the instance is created, same instance is used forever.</source>
          <target state="translated">&lt;strong&gt;どちらもシングルトン&lt;/strong&gt;です。Angularがこれらを初めて依存関係として検出するたびに、サービス/ファクトリの単一のインスタンスが作成されます。 インスタンスが作成されると、同じインスタンスが永久に使用されます。</target>
        </trans-unit>
        <trans-unit id="2bfbaa084726b82d3658a48125aa6f2be3899ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be used to model an object with behavior&lt;/strong&gt;: They can both have methods, internal state variables, and so on. Though the way you write that code will differ.</source>
          <target state="translated">&lt;strong&gt;動作のあるオブジェクトをモデル化するために使用できます。&lt;/strong&gt;どちらもメソッド、内部状態変数などを持つことができます。 ただし、そのコードの記述方法は異なります。</target>
        </trans-unit>
        <trans-unit id="0b8047b6c925051a75984184c3eab229c2a494da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Constant&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b230b0c6b04da427893e313b7c0e9d5aef5ada3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FACTORY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FACTORY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de8ae60c5e367749c74c70c938263e7f3a66bc7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factories:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="129b6a9da449d3568001d3e4449436c7a83896d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;工場機能：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa83955bc8ebbae5eb9b7e4bea195c0e27d81128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt;
  You simply create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;ファクトリー：ファクトリー&lt;/strong&gt;内にオブジェクトを作成し、それを返すだけです。</target>
        </trans-unit>
        <trans-unit id="223321a46b7f883db5389221c0e026bc67b2f8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt; The factory you actually create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;ファクトリー：ファクトリーの&lt;/strong&gt;内部で実際にオブジェクトを作成して返すファクトリー。</target>
        </trans-unit>
        <trans-unit id="4b5add3c153ec4e23637c1d8bfc69736e94082eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factory&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74ccee4a3bcbc7b9bc42b630b85b5d7fe42f6f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; and &lt;strong&gt;Service&lt;/strong&gt; are the most commonly used recipes. The only difference between them is that the &lt;strong&gt;Service&lt;/strong&gt; recipe works better for objects of a custom type, while the &lt;strong&gt;Factory&lt;/strong&gt; can produce JavaScript primitives and functions.</source>
          <target state="translated">&lt;strong&gt;工場&lt;/strong&gt;と&lt;strong&gt;サービス&lt;/strong&gt;は、最も一般的に使用されるレシピです。 それらの唯一の違いは、 &lt;strong&gt;ファクトリ&lt;/strong&gt;がJavaScriptプリミティブと関数を生成できるのに対して、 &lt;strong&gt;サービス&lt;/strong&gt;レシピはカスタムタイプのオブジェクトに対してより適切に機能することです。</target>
        </trans-unit>
        <trans-unit id="af69167d5e31ec4171b3b71e86c23e55eb8b3ef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; use a factory function which return a service instance.
&lt;strong&gt;serviceInstance = fnFactory();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ファクトリ&lt;/strong&gt;は、サービスインスタンスを返すファクトリ関数を使用します。 &lt;strong&gt;serviceInstance = fnFactory（）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d42eff7ec39af4e9117015764522229b8db7933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;: The value you are providing needs to be calculated based on other data.</source>
          <target state="translated">&lt;strong&gt;工場&lt;/strong&gt; ：提供する値は、他のデータに基づいて計算する必要があります。</target>
        </trans-unit>
        <trans-unit id="15a7f656197166d5af0768e868e3d0738e892b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051543166b882d0c0302b61c6fccd2ef13890dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does provider syntax internally work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロバイダーの構文は内部的にどのように機能しますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f24bbfd879178823cf1a6f4fa4db8fd25d88804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to create a service?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;サービスを作成するには？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15472d9a104bad65c0d954254428090db1217241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazily instantiated&lt;/strong&gt; &amp;ndash; Angular only instantiates a service/factory when an application component depends on it.</source>
          <target state="translated">&lt;strong&gt;遅延インスタンス化&lt;/strong&gt; &amp;ndash; Angularは、アプリケーションコンポーネントが依存している場合にのみサービス/ファクトリをインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="4fc1597dfe992d87dcc418262208d7b520cc2ad4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="048671a3c07af864b3160d99c16b04e4022573ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;非TL; DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c27c9c6e707014afaaa93121ac5aee4552e03e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PROVIDER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PROVIDER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e9a7279f005fa392f0780ed27247cdff005c85f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロバイダー機能：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2f1801fb48bf71dd7299a789ae89b7ca28c73fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9463ee84dc44104bf418d730d2dc12c20735e2ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="034f13e153a713ef6e1f67d027f037acfcdca111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; defines a providerConstructor function, this providerConstructor function defines a factory function &lt;strong&gt;$get&lt;/strong&gt; . Angular calls $get() to create the service object. Provider syntax has an added advantage of configuring the service object before it get instantiated.
&lt;strong&gt;serviceInstance = $get();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロバイダー&lt;/strong&gt;はproviderConstructor関数を定義し、このproviderConstructor関数はファクトリー関数&lt;strong&gt;$ getを&lt;/strong&gt;定義し&lt;strong&gt;ます&lt;/strong&gt; 。 Angularは$ get（）を呼び出してサービスオブジェクトを作成します。 プロバイダーの構文には、インスタンス化される前にサービスオブジェクトを設定できるという利点があります。 &lt;strong&gt;serviceInstance = $ get（）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58cb452a8449a0480646f34b32c4f0b2da41ff86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">&lt;strong&gt;プロバイダー&lt;/strong&gt;は最も複雑なレシピタイプです。 グローバル構成を必要とする再利用可能なコードを作成する場合を除き、必要はありません。</target>
        </trans-unit>
        <trans-unit id="af542f111be3a6b9b5eb1bba21844f854821a94c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; recipe is used mostly in the app config, before the app has fully started/initialized.</source>
          <target state="translated">&lt;strong&gt;プロバイダー&lt;/strong&gt;レシピは、アプリが完全に起動/初期化される前に、主にアプリ構成で使用されます。</target>
        </trans-unit>
        <trans-unit id="5a61e7a67bd37a0cf34633a672f8ef4ac61746cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;: You want to be able to configure, during the config phase, the object that is going to be created before it&amp;rsquo;s created. Use the Provider mostly in the app config, before the app has fully initialized.</source>
          <target state="translated">&lt;strong&gt;プロバイダー&lt;/strong&gt; ：構成フェーズ中に、作成される前に作成されるオブジェクトを構成できるようにする必要があります。 アプリが完全に初期化される前に、主にアプリ構成でプロバイダーを使用します。</target>
        </trans-unit>
        <trans-unit id="1ab8bcf5f1f62f6d12fe01bbd3797bf5f9edaf2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a Value from a &lt;code&gt;Service&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Service&lt;/code&gt; から値を返す&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="d8b225479a57e32c9b9bbce57b80db8803839e1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVICE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;SERVICE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="1723b4864b43191225849524b7490ba00136326d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service vs provider vs factory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;サービスvsプロバイダーvs工場：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddf188521bbad55d877526ca526e747468a9d8b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c48ba497f0f940a447148665d013066e3821706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3625561b5600fccb382876ffa98f2e89623ad206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; is all about &lt;code&gt;new&lt;/code&gt; keyword actually which as we know does 4 things:</source>
          <target state="translated">&lt;strong&gt;サービス&lt;/strong&gt;とは、実際には &lt;code&gt;new&lt;/code&gt; キーワードに関するものであり、私たちが知っているように4つのことを行います。</target>
        </trans-unit>
        <trans-unit id="643dc71e1844f583afedf84a3c290ed53ca1a986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; use a constructor function and Angular invoke this constructor function using 'new' keyword for creating the service instance.
&lt;strong&gt;serviceInstance = new fnServiceConstructor();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;サービス&lt;/strong&gt;はコンストラクター関数を使用し、Angularはサービスインスタンスを作成するために 'new'キーワードを使用してこのコンストラクター関数を呼び出します。 &lt;strong&gt;serviceInstance = new fnServiceConstructor（）;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="934fb2b4d6b5561f358e2ea098b02b599fac1ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;: You are returning an object with methods.</source>
          <target state="translated">&lt;strong&gt;サービス&lt;/strong&gt; ：メソッドを使用してオブジェクトを返しています。</target>
        </trans-unit>
        <trans-unit id="917d24961ee3bd9397cee700d2697066bdc8ebc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Services:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b86f1f47c5d0e8ae25c0b4bfeddc837fbe553961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Singletons&lt;/strong&gt; &amp;ndash; Each component
  dependent on a service gets a reference to the single instance
  generated by the service factory.</source>
          <target state="translated">&lt;strong&gt;シングルトン&lt;/strong&gt; &amp;ndash;サービスに依存する各コンポーネントは、サービスファクトリによって生成された単一のインスタンスへの参照を取得します。</target>
        </trans-unit>
        <trans-unit id="236552a9e0c737f0dce61f3fd278300c81df52c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;工場のソースコード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dca20d5f0cc36fd7219eb42b9a3bd59a5f14fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;サービスのソースコード&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3ab06d46eba0ea55e3a63532b502c8e68aaf041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntactic Sugar is the difference&lt;/strong&gt;. Only provider is needed. Or in other words only provider is the real angular, all other ones are derived(to reduce code). There is a simple version as well, called Value()  which returns just the value, no calculation or function. Even Value is derived from provider!</source>
          <target state="translated">&lt;strong&gt;構文糖は違い&lt;/strong&gt;です。 プロバイダーのみが必要です。 または言い換えれば、プロバイダーのみが実際の角度であり、他のすべてのものは（コードを削減するために）導出されます。 Value（）と呼ばれる単純なバージョンもあり、これは値だけを返し、計算や関数は返しません。 値もプロバイダーから派生しています！</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5f0f8f2415dfbd7ea64cb1c92c78ef8982eb6db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The major differences among Services, Factories, and Providers are their complexities. Services are the simplest form, Factories are a little more robust, and Providers are configurable at runtime.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;サービス、ファクトリー、プロバイダーの主な違いは、それらの複雑さです。&lt;/strong&gt; &lt;strong&gt;サービスは最も単純な形式であり、ファクトリーはもう少し堅牢であり、プロバイダーは実行時に構成可能です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5265dba3d641afcb7e0148f9229e5a29c5cbf0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding AngularJS Factory, Service and Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJSファクトリ、サービス、プロバイダーについて&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="372f60334aa5d8918e891d52c780ab816ff7ba23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="761726747ff7c1d3bd1aef8307caf8babe873bd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4167298ff7e32e5b1773e3433a0f0e71939b8a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Service:&lt;/strong&gt;
In AngularJS, &lt;strong&gt;Service&lt;/strong&gt; is nothing but a singleton JavaScript object which can store some useful methods or properties. This singleton object is created per ngApp(Angular app) basis and it is shared among all the controllers within current app. When Angularjs instantiate a service object, it register this service object with a unique service name. So each time when we need service instance, Angular search the registry for this service name, and it returns the reference to service object. Such that we can invoke method, access properties etc on the service object.
You may have question whether you can also put properties, methods on scope object of controllers! So why you need service object? Answers is: services are shared among multiple controller scope. If you put some properties/methods in a controller's scope object , it will be available to current scope only. But when you define methods, properties on service object, it will be available globally and can be accessed in any  controller's scope by injecting that service.</source>
          <target state="translated">&lt;strong&gt;サービスとは何か：&lt;/strong&gt; AngularJSでは、 &lt;strong&gt;サービス&lt;/strong&gt;は、いくつかの便利なメソッドやプロパティを格納できる単一のJavaScriptオブジェクトにすぎません。 このシングルトンオブジェクトはngApp（Angular app）ベースで作成され、現在のアプリ内のすべてのコントローラー間で共有されます。 Angularjsはサービスオブジェクトをインスタンス化するときに、このサービスオブジェクトを一意のサービス名で登録します。 したがって、サービスインスタンスが必要になるたびに、Angularはレジストリでこのサービス名を検索し、サービスオブジェクトへの参照を返します。 そのため、サービスオブジェクトのメソッドを呼び出したり、プロパティにアクセスしたりできます。 コントローラのスコープオブジェクトにプロパティ、メソッドを配置できるかどうか疑問に思うかもしれません！ では、なぜサービスオブジェクトが必要なのでしょうか。 答えは次のとおりです。サービスは複数のコントローラースコープ間で共有されます。 一部のプロパティ/メソッドをコントローラーのスコープオブジェクトに配置すると、現在のスコープでのみ使用できるようになります。 ただし、サービスオブジェクトのメソッド、プロパティを定義すると、グローバルに使用できるようになり、そのサービスを注入することにより、任意のコントローラーのスコープでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e41544278c3c3cd14f313568ad2ca9b33654a735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7c38fc9331c68d06c6051d868ab8034c6a1b71f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5fb6e5fc13a01937ae02611fcad859574413d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index.html&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;index.html&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd88803cf5db529cfe7cb230c25afc9af0e166" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;provider:&lt;/strong&gt; The provider there&amp;rsquo;s a $get you define and it can be used to get the object that returns the data.</source>
          <target state="translated">&lt;strong&gt;プロバイダー：&lt;/strong&gt;プロバイダーには定義した$ getがあり、データを返すオブジェクトを取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="8592d58f6159c5178f21fdbf4b05247f87defaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;service:&lt;/strong&gt; The service you just have a standard function that uses the this keyword to define function.</source>
          <target state="translated">&lt;strong&gt;service：&lt;/strong&gt; thisキーワードを使用して関数を定義する標準関数のみのサービス。</target>
        </trans-unit>
        <trans-unit id="6460b1c41e40026d826a70fb0ec47b36aaed8244" translate="yes" xml:space="preserve">
          <source>A factory is a plain old function that returns a value. The return value is what gets injected into things that depend on the factory. A typical factory pattern in Angular is to return an object with functions as properties, like this:</source>
          <target state="translated">ファクトリーは値を返す古い関数です。戻り値はファクトリに依存するものに注入されます。Angularにおける典型的なファクトリーのパターンは、以下のように関数をプロパティとしてオブジェクトを返すことです。</target>
        </trans-unit>
        <trans-unit id="6654378b8441365d9dbee921cd9c4b6d04ad1238" translate="yes" xml:space="preserve">
          <source>A factory is function where you can manipulate/add logic before creating an object, then the newly created object gets returned.</source>
          <target state="translated">ファクトリーとは、オブジェクトを作成する前にaddロジックを操作して、新しく作成したオブジェクトを返す機能です。</target>
        </trans-unit>
        <trans-unit id="92657294903a95f8b7ea12e4be26ab19bd209d60" translate="yes" xml:space="preserve">
          <source>A more general value, that is possible to be computed right away. It works by passing a function to AngularJS with the logic needed to compute the value and AngularJS executes it, and it saves the return value in the named variable.</source>
          <target state="translated">より一般的な値で、すぐに計算することが可能です。値を計算するのに必要なロジックを持った関数をAngularJSに渡してAngularJSが実行することで動作し、戻り値を名前付き変数に保存します。</target>
        </trans-unit>
        <trans-unit id="c98519712b1bcd2194f1ab8049f9c95b677e57e2" translate="yes" xml:space="preserve">
          <source>A provider
= must contain a property called $get (+Factory, + Service, + Value)</source>
          <target state="translated">プロバイダ=は、$get (+Factory,+Service,+Value)というプロパティを含まなければなりません。</target>
        </trans-unit>
        <trans-unit id="70cc8179c33c6143e3fd269921c56cce6794df6a" translate="yes" xml:space="preserve">
          <source>A provider is used to create a configurable service object. You can configure the service setting from config function. It returns a value by using the &lt;code&gt;$get()&lt;/code&gt; function. The &lt;code&gt;$get&lt;/code&gt; function gets executed on the run phase in angular.</source>
          <target state="translated">プロバイダーは、構成可能なサービスオブジェクトを作成するために使用されます。 設定機能からサービス設定を行うことができます。 &lt;code&gt;$get()&lt;/code&gt; 関数を使用して値を返します。 &lt;code&gt;$get&lt;/code&gt; 関数は、実行フェーズで角度で実行されます。</target>
        </trans-unit>
        <trans-unit id="2690ab0e17349d256212ca0a5c254ff9f7224715" translate="yes" xml:space="preserve">
          <source>A provider that can
instantiate + do something = Service (+ Factory, + Value)</source>
          <target state="translated">インスタンス化+何かをすることができるプロバイダ=サービス(+ファクトリー、+バリュー</target>
        </trans-unit>
        <trans-unit id="1552cdef3a8c9efd2ca6378e425896d47cd0a7d2" translate="yes" xml:space="preserve">
          <source>A provider that can just
instantiate and return = Factory (+ Value)</source>
          <target state="translated">インスタンス化して返すだけのプロバイダ=ファクトリー(+値)</target>
        </trans-unit>
        <trans-unit id="5bac4ef74fca1e1f11c40a61c18eb5751a56a24e" translate="yes" xml:space="preserve">
          <source>A provider that can return value = Value</source>
          <target state="translated">値を返すことができるプロバイダ=Value</target>
        </trans-unit>
        <trans-unit id="daa9ad8c9da39c96b0cd1b5e9b85ad76ef92e025" translate="yes" xml:space="preserve">
          <source>A service is a constructor function, and Angular will instantiate it by calling new &lt;code&gt;yourServiceName()&lt;/code&gt;. This means a couple of things.</source>
          <target state="translated">サービスはコンストラクター関数であり、Angularはnew &lt;code&gt;yourServiceName()&lt;/code&gt; を呼び出してサービスをインスタンス化します。 これはいくつかのことを意味します。</target>
        </trans-unit>
        <trans-unit id="f30916da78a012d617c7c608b91dd4f9e4ccb7cc" translate="yes" xml:space="preserve">
          <source>A service is a more stripped-down version of &lt;em&gt;factory&lt;/em&gt; which is valid only when the value is an object, and it allows for writing any logic directly in the function (as if it would be a constructor), as well as declaring and accessing the object properties using the &lt;em&gt;this&lt;/em&gt; keyword.</source>
          <target state="translated">サービスは、値がオブジェクトである場合にのみ有効な、より簡略化されたバージョンの&lt;em&gt;ファクトリ&lt;/em&gt;であり、関数内に直接ロジックを記述し（コンストラクターであるかのように）、宣言とアクセスを行うことができます。 &lt;em&gt;this&lt;/em&gt;キーワードを使用したオブジェクトプロパティ。</target>
        </trans-unit>
        <trans-unit id="e010047a835b4f08a52ebcf31da9133c3b0c83eb" translate="yes" xml:space="preserve">
          <source>Ability to use other services (have dependencies)</source>
          <target state="translated">他のサービスを利用できる(依存関係がある</target>
        </trans-unit>
        <trans-unit id="90d836d3d0cb6acecac1372abfaeed5f7a898db3" translate="yes" xml:space="preserve">
          <source>After reading all these post It created more confuse for me.. But still all is worthfull information.. finally I found following table which will give information with simple comparision</source>
          <target state="translated">すべてのこれらのポストを読んだ後、それは私のためのより多くの混乱を作成しました。しかし、まだすべてが価値のある情報です...最終的に私は簡単な比較で情報を与える次の表を見つけました。</target>
        </trans-unit>
        <trans-unit id="eba926c51e345f5492b036b8fb2838c80ca0f326" translate="yes" xml:space="preserve">
          <source>Ajax call or third party integrations needs to be &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">Ajaxコールまたはサードパーティ統合は&lt;strong&gt;サービスである&lt;/strong&gt;必要があり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="db39b22c1144a74c69ee802842ea57e37d383130" translate="yes" xml:space="preserve">
          <source>All Services are &lt;strong&gt;singletons&lt;/strong&gt;; they get instantiated once per app. They can be &lt;strong&gt;of any type&lt;/strong&gt;, whether it be a primitive, object literal, function, or even an instance of a custom type.</source>
          <target state="translated">すべてのサービスは&lt;strong&gt;シングルトン&lt;/strong&gt;です。 アプリごとに1回インスタンス化されます。 プリミティブ、オブジェクトリテラル、関数、カスタムタイプのインスタンスなど、 &lt;strong&gt;どのタイプでもかまいません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="44b4a8e5249ee92bb57692eb4f38230e89ca0b32" translate="yes" xml:space="preserve">
          <source>All of these are used to share reusable singleton objects. It helps to share reusable code across your app/various components/modules.</source>
          <target state="translated">これらはすべて、再利用可能なシングルトンオブジェクトを共有するために使用されます。これは、アプリ内の様々なコンポーネントモジュール間で再利用可能なコードを共有するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="15074bf6692ab4d76bbae6a637a1292c7beea479" translate="yes" xml:space="preserve">
          <source>All special purpose objects except for the Controller are defined via Factory recipes.</source>
          <target state="translated">コントローラ以外のすべての特殊目的オブジェクトは、ファクトリーレシピを介して定義されています。</target>
        </trans-unit>
        <trans-unit id="1797d93eba62a3e50c0f75705fc2654c1c5d7cc1" translate="yes" xml:space="preserve">
          <source>All the good answers already. I would like to add few more points on &lt;strong&gt;Service&lt;/strong&gt; and &lt;strong&gt;Factory&lt;/strong&gt;. Along with the difference between service/factory. And  one can also have questions like:</source>
          <target state="translated">すべての良い答えはすでに。 &lt;strong&gt;サービス&lt;/strong&gt;と&lt;strong&gt;ファクトリー&lt;/strong&gt;についてもう少しポイントを追加したいと思います。 サービス/工場の違いとともに。 また、次のような質問をすることもできます。</target>
        </trans-unit>
        <trans-unit id="644fa5425851502f8b0f2b6d2e894a7a71bc764b" translate="yes" xml:space="preserve">
          <source>An additional clarification is that factories can create functions/primitives, while services cannot. Check out this &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; based on Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt;.</source>
          <target state="translated">さらに明確にすると、サービスでは作成できないのに、工場では機能/プリミティブを作成できます。 &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;Epokkに&lt;/a&gt;基づくこのjsFiddleをチェックしてください： &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http&lt;/a&gt; ://jsfiddle.net/skeller88/PxdSP/1351/。</target>
        </trans-unit>
        <trans-unit id="1698cdf07eaa30b1f4d2eb589b401f5aa7c167b5" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Factory&lt;/strong&gt; is all about Factory Pattern - contains functions that return Objects like that Service.</source>
          <target state="translated">そして&lt;strong&gt;ファクトリー&lt;/strong&gt;はすべてファクトリーパターンに関するものです-そのサービスのようなオブジェクトを返す関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="087105228646ef19c5b815759ef3bd7c8d79035e" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Value, Factory, Service and Constant&lt;/strong&gt; (4 ways) - the syntactic sugar over &lt;strong&gt;Provider&lt;/strong&gt; way/recepie.</source>
          <target state="translated">そして、 &lt;strong&gt;Value、Factory、Service、Constant&lt;/strong&gt; （4つの方法）- &lt;strong&gt;プロバイダーの&lt;/strong&gt;方法/レセプトに対する構文上の砂糖。</target>
        </trans-unit>
        <trans-unit id="a4a0d683875e15a20d100e9c4f3cabe527897b12" translate="yes" xml:space="preserve">
          <source>And a better answer would be this:
&quot;An Angular service is created by a service factory. These service factories are functions which, in turn, are created by a service provider. The service providers are constructor functions. When instantiated they must contain a property called $get, which holds the service factory function.&quot;</source>
          <target state="translated">そして、より良い答えはこれでしょう。&quot;Angularのサービスはサービスファクトリによって作成されます。これらのサービスファクトリは関数であり、サービスプロバイダによって作成されます。サービスプロバイダはコンストラクタ関数です。インスタンスを作成する際には、サービスファクトリの関数を保持する$getというプロパティを含まなければなりません。&quot;</target>
        </trans-unit>
        <trans-unit id="6e1a1be7a3c89b4a49965d6931152adc8b79b49f" translate="yes" xml:space="preserve">
          <source>And this simple/short video: covers also &lt;strong&gt;Provider&lt;/strong&gt;: &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (there you see can see how they go from factory to provider)</source>
          <target state="translated">そして、このシンプルな/短いビデオ： &lt;strong&gt;プロバイダー&lt;/strong&gt;もカバーしてい&lt;strong&gt;ます&lt;/strong&gt; ： &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https&lt;/a&gt; : //www.youtube.com/watch?v=HvTZbQ_hUZY （工場からプロバイダーにどのように移行するかを見ることができます）</target>
        </trans-unit>
        <trans-unit id="5e753d8417cbbaa903d75c9067f03b753d972dae" translate="yes" xml:space="preserve">
          <source>Angular injection gives us the first hint in reaching this conclusion.</source>
          <target state="translated">角入射は、この結論に到達するための最初のヒントを与えてくれます。</target>
        </trans-unit>
        <trans-unit id="c0fbc9b675108602e2b9fac4e8674fd1d9ad2553" translate="yes" xml:space="preserve">
          <source>AngularJS provide different methods to register a service. Here we will concentrate on three methods factory(..),service(..),provider(..);</source>
          <target state="translated">AngularJSにはサービスを登録するための様々なメソッドが用意されています。ここではfactory(...),service(...),provider(...)の3つのメソッドに絞って紹介します。</target>
        </trans-unit>
        <trans-unit id="a2a043dede3ac539ee64b89b2d49b7bd51e23891" translate="yes" xml:space="preserve">
          <source>AngularJS provides &lt;strong&gt;'factory('serviceName', fnFactory)'&lt;/strong&gt; method which takes two parameter, serviceName and a JavaScript function. Angular creates service instance by invoking the function &lt;strong&gt;fnFactory()&lt;/strong&gt; such as below.</source>
          <target state="translated">AngularJSは、serviceNameとJavaScript関数の2つのパラメーターを取る&lt;strong&gt;'factory（' serviceName '、fnFactory）'&lt;/strong&gt;メソッドを提供します。 Angularは、以下のような関数&lt;strong&gt;fnFactory（）&lt;/strong&gt;を呼び出すことでサービスインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="67487acbc494fde4c0ecdb230e55c47bdc819cc5" translate="yes" xml:space="preserve">
          <source>AngularJS: Service vs provider vs factory</source>
          <target state="translated">AngularJS:サービス vs プロバイダー vs ファクトリー</target>
        </trans-unit>
        <trans-unit id="62b46f141dc945f1baeeda1b182a386db6799d55" translate="yes" xml:space="preserve">
          <source>Answers for above 1 and 2 questions:</source>
          <target state="translated">上記1、2の質問の解答です。</target>
        </trans-unit>
        <trans-unit id="f5181cbde0884af842b881fdae06a3ba0616e0a1" translate="yes" xml:space="preserve">
          <source>As a side note, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; are all derived from provider.</source>
          <target state="translated">補足として、 &lt;code&gt;service&lt;/code&gt; 、 &lt;code&gt;factory&lt;/code&gt; 、および &lt;code&gt;value&lt;/code&gt; はすべてプロバイダーから派生しています。</target>
        </trans-unit>
        <trans-unit id="b8e0a3698c74b06188537beb6504f05ed6da8541" translate="yes" xml:space="preserve">
          <source>As mentioned before, the whole point of creating a service with Provider is to be able to alter some variables through the app.config function before the final object is passed to the rest of the application. Let&amp;rsquo;s see an example of that.</source>
          <target state="translated">前述のように、プロバイダーを使用してサービスを作成する全体のポイントは、最終オブジェクトがアプリケーションの残りの部分に渡される前に、app.config関数を介していくつかの変数を変更できるようにすることです。 その例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ac8bd4adf742322d3119e359d466fd027d4a144c" translate="yes" xml:space="preserve">
          <source>As pointed out by several people here correctly a factory, provider, service, and even value and constant are versions of the same thing. You can dissect the more general &lt;code&gt;provider&lt;/code&gt; into all of them. Like so:</source>
          <target state="translated">ここで数人の人々が正しく指摘しているように、ファクトリ、プロバイダー、サービス、さらには価値と定数さえも同じもののバージョンです。 より一般的な &lt;code&gt;provider&lt;/code&gt; をそれらすべてに分解することができます。 そのようです：</target>
        </trans-unit>
        <trans-unit id="7ac115d7759453df5c7a6ee0d961bac591936f70" translate="yes" xml:space="preserve">
          <source>Basically all of the mentioned types (service, factory, provider, etc.) are just creating and configuring global variables (that are of course global to the entire application), just as old fashioned global variables were.</source>
          <target state="translated">基本的には、前述のすべてのタイプ(サービス、ファクトリー、プロバイダなど)は、昔ながらのグローバル変数がそうであったように、グローバル変数を作成して設定しているだけです(もちろん、アプリケーション全体に対してグローバルです)。</target>
        </trans-unit>
        <trans-unit id="76a6d228807b2f0db9ca8817dcc7b6fe1992e7f5" translate="yes" xml:space="preserve">
          <source>Below &lt;strong&gt;setArtist&lt;/strong&gt; accepts an artist and allows you to set the artist. &lt;strong&gt;getArtist&lt;/strong&gt; returns the artist. &lt;strong&gt;callItunes&lt;/strong&gt; first calls makeUrl() in order to build the URL we&amp;rsquo;ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying &amp;lsquo;There was an error&amp;rsquo;.</source>
          <target state="translated">以下の&lt;strong&gt;setArtist&lt;/strong&gt;はアーティストを受け入れ、アーティストを設定できます。 &lt;strong&gt;getArtist&lt;/strong&gt;はアーティストを返します。 &lt;strong&gt;callItunesは、&lt;/strong&gt;最初にmakeUrl（）を呼び出して、$ httpリクエストで使用するURLを作成します。 次に、promiseオブジェクトを設定し、最終的なURLを使用して$ httpリクエストを作成します。$ httpはpromiseを返すため、リクエストの後に.successまたは.errorを呼び出すことができます。 その後、iTunesデータで約束を解決するか、「エラーが発生しました」というメッセージで拒否します。</target>
        </trans-unit>
        <trans-unit id="ecc9654f84abda3f226923e7181cd6dedcabf706" translate="yes" xml:space="preserve">
          <source>Below is code for how you can think about what the &amp;lsquo;new&amp;rsquo; keyword is actually doing in JavaScript. It&amp;rsquo;s basically a code example of the above paragraph. I&amp;rsquo;ve put the &amp;lsquo;interpreter view&amp;rsquo; or the way the interpreter sees the code inside of notes.</source>
          <target state="translated">以下は、「新しい」キーワードが実際にJavaScriptで何をしているのかを考える方法のコードです。 これは基本的に、上の段落のコード例です。 「インタープリタービュー」、つまりインタープリターがコードをノート内に表示する方法を示しました。</target>
        </trans-unit>
        <trans-unit id="baeffb61d23b4b1a1faec7ea79fc7982401fe040" translate="yes" xml:space="preserve">
          <source>But if you declare an AngularJS &quot;value&quot; (for example., &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt;), you can inject it into services and factories, but NOT into the provider-creating function. You can, however, inject it into the &lt;code&gt;$get&lt;/code&gt; function that you define for your provider. This is mentioned in the AngularJS documentation, but it's easy to miss. You can find it on the %provide page in the sections on the value and constant methods.</source>
          <target state="translated">ただし、AngularJSの「値」を宣言する場合（たとえば、 &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt; ）、サービスとファクトリーに注入できますが、プロバイダー作成関数には注入できません。 ただし、プロバイダー用に定義した &lt;code&gt;$get&lt;/code&gt; 関数に挿入することはできます。 これはAngularJSのドキュメントで言及されていますが、見落としがちです。 これは、％provideページのvalueメソッドとconstantメソッドのセクションにあります。</target>
        </trans-unit>
        <trans-unit id="e1cc6d183fce2197bb4d499453f325c6ce15d621" translate="yes" xml:space="preserve">
          <source>But that is way too wordy. A shorter way to write this would be &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</source>
          <target state="translated">しかし、それは言い過ぎです。 これを書く短い方法は、 &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0b23422a6346dcd33f9ef7c177b5c4c2e0c0ba5" translate="yes" xml:space="preserve">
          <source>But what if we wanted to configure the &lt;code&gt;Greeter&lt;/code&gt; class before the injection? Then we could write</source>
          <target state="translated">しかし、注入の前に &lt;code&gt;Greeter&lt;/code&gt; クラスを構成したい場合はどうでしょうか。 次に、</target>
        </trans-unit>
        <trans-unit id="83edd94ef1f4218a2a09268ba1c79454b4d8ce41" translate="yes" xml:space="preserve">
          <source>But what if you want to be more OO and have a class called Greeter?</source>
          <target state="translated">でも、もっとOOになってGreeterというクラスがあったらどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="bead6ae023dd1ddfc66d0c3554dd68115419ed4a" translate="yes" xml:space="preserve">
          <source>Code posted here is copied straight from the above source, to benefit readers.</source>
          <target state="translated">ここに掲載されているコードは、読者のために、上記のソースからそのままコピーしています。</target>
        </trans-unit>
        <trans-unit id="d3a3e026964278d33abfaf0d31b51f4e99ed0a5a" translate="yes" xml:space="preserve">
          <source>Defining and using Service, Factory and Provider are explained at &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;</source>
          <target state="translated">サービス、ファクトリー、プロバイダーの定義と使用については、 &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http：//www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-providerで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="1d0d609d4405f2baa362951b7009d2417093fd7d" translate="yes" xml:space="preserve">
          <source>Delayed/lazy initialization</source>
          <target state="translated">遅延遅延初期化</target>
        </trans-unit>
        <trans-unit id="cb560adb9a207096df4103f0ce35af068e58441a" translate="yes" xml:space="preserve">
          <source>Due to how JavaScript constructors work, if you return a complex value &lt;code&gt;(i.e., an Object)&lt;/code&gt; from a &lt;code&gt;constructor&lt;/code&gt; function, the caller will get that Object instead of the this instance.</source>
          <target state="translated">JavaScriptコンストラクターの仕組みにより、 &lt;code&gt;constructor&lt;/code&gt; 関数から複雑な値 &lt;code&gt;(i.e., an Object)&lt;/code&gt; を返す場合、呼び出し元は、このインスタンスの代わりにそのオブジェクトを取得します。</target>
        </trans-unit>
        <trans-unit id="0ce56bb9d7649bd1affa9d15ef3b25e94ed4bf16" translate="yes" xml:space="preserve">
          <source>Essentially, Provider, Factory, and Service are all Services. A Factory is a special case of a Service when all you need is a $get() function, allowing you to write it with less code.</source>
          <target state="translated">基本的に、プロバイダ、ファクトリ、およびサービスはすべてサービスです。ファクトリーはサービスの特殊なケースで、必要なのは $get()関数だけなので、より少ないコードで書くことができます。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="5871c248f6153cd0a547c43f6815327faa66746e" translate="yes" xml:space="preserve">
          <source>Factories are the most popular way to create and configure a service. There&amp;rsquo;s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below.</source>
          <target state="translated">ファクトリは、サービスを作成および構成する最も一般的な方法です。 TL; DRが言った以上のことは本当にありません。 オブジェクトを作成し、プロパティを追加して、同じオブジェクトを返すだけです。 次に、ファクトリをコントローラーに渡すと、オブジェクトのこれらのプロパティは、ファクトリを介してそのコントローラーで使用できるようになります。 より広範な例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="c8e6696140d2e75575a027e3db926b81e7fa86b8" translate="yes" xml:space="preserve">
          <source>Factory and Service are the most commonly used recipes. The only difference between them is that the Service recipe works better for objects of a custom type, while the Factory can produce JavaScript primitives and functions.</source>
          <target state="translated">Factory と Service は最も一般的に使用されるレシピです。これらの間の唯一の違いは、FactoryがJavaScriptのプリミティブや関数を生成できるのに対し、Serviceレシピはカスタムタイプのオブジェクトに対してよりよく機能するということです。</target>
        </trans-unit>
        <trans-unit id="7ee844ac41ac4ad9686ec614f908d3bdcb5b3e81" translate="yes" xml:space="preserve">
          <source>Factory is a class. Use factories if you want to provide custom classes for your code (can't be done with services because they are already instantiated).</source>
          <target state="translated">ファクトリーはクラスです。コードにカスタムクラスを提供したい場合はファクトリーを使用します (すでにインスタンス化されているため、サービスではできません)。</target>
        </trans-unit>
        <trans-unit id="c43d055974d1f89c7db6d2a6f06d9706cf84359d" translate="yes" xml:space="preserve">
          <source>Features of Factory:</source>
          <target state="translated">工場の特徴。</target>
        </trans-unit>
        <trans-unit id="8f233e0733ea2bd7573612519e22b6483ee2aae2" translate="yes" xml:space="preserve">
          <source>Features of Provider:</source>
          <target state="translated">プロバイダーの特徴。</target>
        </trans-unit>
        <trans-unit id="8b33d5b1a4171b12f08419f5a3175c6118df72b0" translate="yes" xml:space="preserve">
          <source>Features of Service:</source>
          <target state="translated">サービスの特徴。</target>
        </trans-unit>
        <trans-unit id="555321235e9eb2d0c7b4fff9ef2c877ead66f84d" translate="yes" xml:space="preserve">
          <source>Finally the UI which works with any of the above services:</source>
          <target state="translated">最後に上記のサービスのいずれかと連携するUIです。</target>
        </trans-unit>
        <trans-unit id="aa41b2f6147d97e7462dbecaf90f19a90ed1b067" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s create our Constructor.</source>
          <target state="translated">まず、コンストラクタを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="dfb58a29f6c2cb946fda2080d277aff94876b78f" translate="yes" xml:space="preserve">
          <source>First let's have a look at the syntax:</source>
          <target state="translated">まずは構文を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="16ae293f476b801e0ec98c3b0c772f3098dc7e49" translate="yes" xml:space="preserve">
          <source>First of all, let's talk about &lt;strong&gt;services&lt;/strong&gt; in AngularJS!</source>
          <target state="translated">まず最初に、AngularJSの&lt;strong&gt;サービス&lt;/strong&gt;について話しましょう！</target>
        </trans-unit>
        <trans-unit id="f626e9e8c764b63df367572217b72dfec8d3d0d8" translate="yes" xml:space="preserve">
          <source>First of all: &lt;strong&gt;Provider&lt;/strong&gt; is the way/recipe to create a &lt;code&gt;service&lt;/code&gt; (singleton object) that suppose to be injected by $injector (how AngulaJS goes about IoC pattern).</source>
          <target state="translated">まず第一に、 &lt;strong&gt;プロバイダー&lt;/strong&gt;は、$ injectorによって注入されることを想定した &lt;code&gt;service&lt;/code&gt; （シングルトンオブジェクト）を作成する方法/レシピです（AngulaJSがIoCパターンを処理する方法）。</target>
        </trans-unit>
        <trans-unit id="a7d7fe2894bd6c66d071f952d684e2326b49b1e5" translate="yes" xml:space="preserve">
          <source>First things first, let&amp;rsquo;s create our &amp;lsquo;private&amp;rsquo; and helper function. This should look very familiar since we did the exact same thing with our factory. I won&amp;rsquo;t explain what each line does here because I did that in the factory example, if you&amp;rsquo;re confused, re-read the factory example.</source>
          <target state="translated">まず最初に、「プライベート」およびヘルパー関数を作成しましょう。 私たちの工場でもまったく同じことをしたので、これは非常に見覚えがあるはずです。 ここでは、各行が何をするかについては説明しません。工場の例でそれを行ったからです。混乱している場合は、工場の例をもう一度読んでください。</target>
        </trans-unit>
        <trans-unit id="274879ea02d1b32f25fdcf0d6f4b8638ad84e454" translate="yes" xml:space="preserve">
          <source>First we set up our Provider in a similar way we did with our Service and Factory. The variables below are our &amp;lsquo;private&amp;rsquo; and helper function.</source>
          <target state="translated">まず、サービスとファクトリーで行ったのと同じ方法でプロバイダーをセットアップします。 以下の変数は、「プライベート」およびヘルパー関数です。</target>
        </trans-unit>
        <trans-unit id="0f18e05a1a2cf2fab2012ea1acb85960d14f94f3" translate="yes" xml:space="preserve">
          <source>Follows the factory design pattern. The factory is a central place that produces new objects or functions.</source>
          <target state="translated">工場のデザインパターンに従う。工場は、新しいモノや機能を生み出す中心的な場所です。</target>
        </trans-unit>
        <trans-unit id="124166829dcd8ce12e68c97aa74ddc87e6f4700c" translate="yes" xml:space="preserve">
          <source>For Data manipulations create it as &lt;strong&gt;factory&lt;/strong&gt;</source>
          <target state="translated">データ操作については、 &lt;strong&gt;ファクトリ&lt;/strong&gt;として作成します</target>
        </trans-unit>
        <trans-unit id="5d4008d04bf8dc913dd361a11d1dbf2dd7fff6d9" translate="yes" xml:space="preserve">
          <source>For basic scenarios factory&amp;amp;Service behaves same.</source>
          <target state="translated">基本的なシナリオでは、factory＆Serviceは同じように動作します。</target>
        </trans-unit>
        <trans-unit id="be44b8b9aee8e49c0f525f0d589dc7ae0563c459" translate="yes" xml:space="preserve">
          <source>For me the best and the simplest way of understanding the difference is:</source>
          <target state="translated">私にとっては、この違いを理解するのに最適でシンプルな方法です。</target>
        </trans-unit>
        <trans-unit id="56ff743259acbed742d59f1071ec5c09de91c4a2" translate="yes" xml:space="preserve">
          <source>For me, the revelation came when I realized that they all work the same way: by running something &lt;strong&gt;once&lt;/strong&gt;, storing the value they get, and then cough up &lt;strong&gt;that same stored value&lt;/strong&gt; when referenced through &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">私にとって、啓示は、すべてが同じように機能することに気付いたときに起こりました。何かを&lt;strong&gt;一度&lt;/strong&gt;実行し、取得した値を格納し、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依存関係の注入&lt;/a&gt;を通じて参照&lt;strong&gt;された&lt;/strong&gt;ときに&lt;strong&gt;、同じ格納された値を&lt;/strong&gt;消去する&lt;strong&gt;こと&lt;/strong&gt; によって 。</target>
        </trans-unit>
        <trans-unit id="b27ee14ba7c9338b5357168645fc5fca69baff87" translate="yes" xml:space="preserve">
          <source>For more details, see a post I wrote on the difference: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</source>
          <target state="translated">詳細については、違いについて書いた投稿を参照して&lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;ください。http&lt;/a&gt; ： //www.shanemkeller.com/tldr-services-vs-factories-in-angular/</target>
        </trans-unit>
        <trans-unit id="bd35023ca5fbcbbe13f3b8c3e423caa7232e2d3e" translate="yes" xml:space="preserve">
          <source>For the most part, just stick with using factories for everything.
  Their behavior is easier to understand. There&amp;rsquo;s no choice to make
  about whether to return a value or not, and furthermore, no bugs to be
  introduced if you do the wrong thing.</source>
          <target state="translated">ほとんどの場合、すべてに工場を使用することに固執します。 彼らの行動は理解しやすいです。 値を返すかどうかを決める選択肢はありません。さらに、間違った操作を行ってもバグが発生することはありません。</target>
        </trans-unit>
        <trans-unit id="6bc24d8b9740765e38f68d62a235ac7b05a3ba82" translate="yes" xml:space="preserve">
          <source>From Docs &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Service/Factory&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">ドキュメント&lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;サービス/ファクトリから&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="f49fa588c62b7f2f5abba55d1b95ecf06f622095" translate="yes" xml:space="preserve">
          <source>From the AngularJS mailing list I got &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;an amazing thread&lt;/a&gt; that explains service vs factory vs provider and their injection usage. Compiling the answers:</source>
          <target state="translated">AngularJSメーリングリストから、サービス、ファクトリ、プロバイダー、およびそれらのインジェクションの使用法を説明&lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;する素晴らしいスレッド&lt;/a&gt;を受け取りました 。 答えをまとめる：</target>
        </trans-unit>
        <trans-unit id="fd7022a8753e6add51e2b9d2c29e59c134d3fba6" translate="yes" xml:space="preserve">
          <source>Functions and instance variables will be properties of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">関数とインスタンス変数は &lt;code&gt;this&lt;/code&gt; のプロパティになります。</target>
        </trans-unit>
        <trans-unit id="bc7b97dbb27777de72af8d9af9dd816e007cb47e" translate="yes" xml:space="preserve">
          <source>Here is a simpler example.  I'm using a few third party libraries that expect a &quot;Position&quot; object exposing latitude and longitude, but via different object properties.  I didn't want to hack the vendor code, so I adjusted the &quot;Position&quot; objects I was passing around.</source>
          <target state="translated">ここにもっと簡単な例があります。私は、緯度と経度を公開する &quot;Position &quot;オブジェクトを期待するいくつかのサードパーティのライブラリを使用していますが、異なるオブジェクトのプロパティを介しています。ベンダーのコードをハックしたくなかったので、私が渡していた &quot;Position&quot; オブジェクトを調整しました。</target>
        </trans-unit>
        <trans-unit id="ae278ffeba6cafa1c3d2a70eeb6622299cb946ec" translate="yes" xml:space="preserve">
          <source>Here is a summary of when to use each:</source>
          <target state="translated">それぞれどのような時に使うのかをまとめてみました。</target>
        </trans-unit>
        <trans-unit id="c9a8b09d58f2e8e0771d8f78424d27f226d92eae" translate="yes" xml:space="preserve">
          <source>Here is some broilerplate code I've come up with as a code-template for object factory in AngularjS.  I've used a Car/CarFactory as an example to illustrate.  Makes for simple implementation code in the controller.</source>
          <target state="translated">AngularjSのオブジェクトファクトリのコードテンプレートとして思いついたブロイラープレートのコードを紹介します。例としてCarCarFactoryを使っています。コントローラの実装コードが簡単になります。</target>
        </trans-unit>
        <trans-unit id="489ba797946b9923375b0c16c73874f3a39fb591" translate="yes" xml:space="preserve">
          <source>Here you&amp;rsquo;ll notice we&amp;rsquo;re not attaching those variables/function to &amp;lsquo;service&amp;rsquo;. We&amp;rsquo;re simply creating them in order to either use or modify them later.</source>
          <target state="translated">ここでは、これらの変数/関数を「サービス」にアタッチしていないことに気づくでしょう。 後で使用または変更するために、単に作成しています。</target>
        </trans-unit>
        <trans-unit id="00a6aa13d323a6c412ee902d5b3d4d2d1ab4fe03" translate="yes" xml:space="preserve">
          <source>Here's a great further explanation by Misko:</source>
          <target state="translated">ここで、ミスコの素晴らしい追加説明があります。</target>
        </trans-unit>
        <trans-unit id="da5246469f32f79cb4f5e21f982157b5bf8fb944" translate="yes" xml:space="preserve">
          <source>Here's the article this image is from:</source>
          <target state="translated">この画像の記事はこちらです。</target>
        </trans-unit>
        <trans-unit id="850ac93122b4715c223580cbbd975d246cb16f45" translate="yes" xml:space="preserve">
          <source>Hope this has cleared up your understanding about &lt;strong&gt;Factory, Service and Provider&lt;/strong&gt;.</source>
          <target state="translated">これ&lt;strong&gt;により、工場、サービス、プロバイダー&lt;/strong&gt;に関する理解が深まったことを願ってい&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c040a989c90c935f04c9d9df515887605a02c08" translate="yes" xml:space="preserve">
          <source>How AngularJS instantiates particular components (simplified):</source>
          <target state="translated">AngularJSが特定のコンポーネントをどのようにインスタンス化するか(簡略化)。</target>
        </trans-unit>
        <trans-unit id="c385f140fdcc5112262dbad26d8a3223347e8d51" translate="yes" xml:space="preserve">
          <source>I am trying to keep it simple. It's all about basic JavaScript concept.</source>
          <target state="translated">シンプルなものを心がけています。JavaScriptの基本的な考え方が全てです。</target>
        </trans-unit>
        <trans-unit id="29ca2a8a57db27d862d4085e8c93784f8e59cb96" translate="yes" xml:space="preserve">
          <source>I came across this video which explains clearly about factory, service and provider methodologies for developing AngularJS Custom Services:</source>
          <target state="translated">AngularJSのカスタムサービスを開発するためのファクトリー、サービス、プロバイダの方法論をわかりやすく説明しているこの動画に出くわしました。</target>
        </trans-unit>
        <trans-unit id="37a6f10678b28516c544ad2d07c57f10ba034f15" translate="yes" xml:space="preserve">
          <source>I know a lot of excellent answer but I have to share my experience of using</source>
          <target state="translated">多くの優れた回答を知っていますが、私の経験を共有する必要があります</target>
        </trans-unit>
        <trans-unit id="9310dd05ba382096e00103255eac7688e44ef73b" translate="yes" xml:space="preserve">
          <source>I noticed something interesting when playing around with providers.</source>
          <target state="translated">プロバイダーをいじっていて面白いことに気がつきました。</target>
        </trans-unit>
        <trans-unit id="86c3d8da7c12380d33b628011f4dc967a20694c5" translate="yes" xml:space="preserve">
          <source>I still refer to them as &amp;ldquo;services&amp;rdquo; when I&amp;rsquo;m talking about injecting
  them as dependencies, though.</source>
          <target state="translated">ただし、依存関係として挿入することを話しているときは、「サービス」と呼んでいます。</target>
        </trans-unit>
        <trans-unit id="b0314451a42f81ae46c88a72d5644b737ddc515b" translate="yes" xml:space="preserve">
          <source>If you want to use in angular module config function should created as &lt;strong&gt;provider&lt;/strong&gt;</source>
          <target state="translated">角度モジュールで使用する場合は、構成関数を&lt;strong&gt;プロバイダー&lt;/strong&gt;として作成する必要があり&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="760bfbfabac6439646276d21d21c1e88b0f1b52a" translate="yes" xml:space="preserve">
          <source>In the constructor function we can use 'this' keyword for adding properties/methods to the service object.
example:</source>
          <target state="translated">コンストラクタ関数では、サービスオブジェクトにプロパティメソッドを追加するために 'this' キーワードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c5401a20db45adfe8456a9fe2493978105e9f5da" translate="yes" xml:space="preserve">
          <source>In the controller above we&amp;rsquo;re injecting in the &amp;lsquo;myFactory&amp;rsquo; service. We then set properties on our $scope object with data from &amp;lsquo;myFactory&amp;rsquo;. The only tricky code above is if you&amp;rsquo;ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You&amp;rsquo;ll notice our controller is very &amp;lsquo;thin&amp;rsquo; (This is a good coding practise). All of our logic and persistent data is located in our service, not in our controller.</source>
          <target state="translated">上記のコントローラーでは、「myFactory」サービスに注入しています。 次に、「myFactory」からのデータを使用して$ scopeオブジェクトにプロパティを設定します。 上記の唯一のトリッキーなコードは、これまでに約束を扱ったことがない場合です。 callItunesがpromiseを返すため、.then（）メソッドを使用して、iTunesデータでpromiseが満たされた場合にのみ$ scope.data.artistDataを設定できます。 コントローラーが非常に「薄い」ことに気づくでしょう（これは優れたコーディングの実践です）。 ロジックと永続データはすべて、コントローラーではなくサービスにあります。</target>
        </trans-unit>
        <trans-unit id="ad7c151fc09de45e372af1a2de7be6c6b7781661" translate="yes" xml:space="preserve">
          <source>In the service, we create function names as property with &lt;em&gt;this&lt;/em&gt; object.</source>
          <target state="translated">サービスでは、 &lt;em&gt;この&lt;/em&gt;オブジェクトのプロパティとして関数名を作成します。</target>
        </trans-unit>
        <trans-unit id="ca27a70fdef565576b6c87e2f47e6b4dd70d0118" translate="yes" xml:space="preserve">
          <source>In this case the injector simply returns the value as is. But what if you want to compute the value? Then use a factory</source>
          <target state="translated">この場合、インジェクタは単に値をそのまま返します。しかし、値を計算したい場合はどうしますか? その場合は、ファクトリの</target>
        </trans-unit>
        <trans-unit id="ce56ab93a5137d82e8def783797ed2029027acad" translate="yes" xml:space="preserve">
          <source>It can be just a collection of functions like a class. Hence, it can be instantiated in different controllers when you are injecting it inside your controller/factory/directive functions. It is instantiated only once per app.</source>
          <target state="translated">これは、クラスのような関数の集まりにすぎません。そのため、controllerfactorirective関数の中に注入する際に、異なるコントローラでインスタンス化することができます。インスタンス化されるのはアプリごとに一度だけです。</target>
        </trans-unit>
        <trans-unit id="5b20c360213ae1af905212996e857c3ffcf8c5ac" translate="yes" xml:space="preserve">
          <source>It works like using a combination of &lt;em&gt;service&lt;/em&gt; and &lt;em&gt;provider&lt;/em&gt;, by passing to provider a function that has properties declared using the &lt;em&gt;this&lt;/em&gt; keyword, which can be used from the &lt;code&gt;app.config&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;この&lt;/em&gt;キーワードは、 &lt;code&gt;app.config&lt;/code&gt; から使用できる&lt;em&gt;this&lt;/em&gt;キーワードを使用して宣言されたプロパティを持つ関数をプロバイダーに渡すことで、 &lt;em&gt;サービス&lt;/em&gt;と&lt;em&gt;プロバイダーを&lt;/em&gt;組み合わせて使用​​するように機能します。</target>
        </trans-unit>
        <trans-unit id="68eb0b5a5293d5d11d5a247852531e63d5c542a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use the factory in our application as we can simply inject it where we need it at run-time.</source>
          <target state="translated">実行時に必要な場所に注入するだけなので、アプリケーションでファクトリを使用するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="5e6ceae9d10cdf11f4c911a2da17d4ac57381842" translate="yes" xml:space="preserve">
          <source>It's the another way, we can register a service. The only difference is the way AngularJS tries to instantiate the service object. This time angular uses 'new' keyword and call the constructor function something like below.</source>
          <target state="translated">もう一つの方法ですが、サービスを登録することができます。唯一の違いはAngularJSがサービスオブジェクトをインスタンス化しようとする方法です。今回のAngularは'new'キーワードを使って、以下のようなコンストラクタ関数を呼び出しています。</target>
        </trans-unit>
        <trans-unit id="f8bf660b8496971437b76589be4961ef8c377635" translate="yes" xml:space="preserve">
          <source>JS Fiddle Demo</source>
          <target state="translated">JSフィドルのデモ</target>
        </trans-unit>
        <trans-unit id="0e399439c408eca064ae4becd7265accff216db8" translate="yes" xml:space="preserve">
          <source>Just to clarify things, from the AngularJS source, you can see a service just calls the factory function which in turn calls the provider function:</source>
          <target state="translated">AngularJSのソースを見てみると、サービスはファクトリー関数を呼び出しているだけで、それに続いてプロバイダ関数を呼び出していることがわかります。</target>
        </trans-unit>
        <trans-unit id="7de5f61ab2c0b942cc33db2f46d0c4b470d32a4e" translate="yes" xml:space="preserve">
          <source>Let's again have a look at the Syntax first:</source>
          <target state="translated">もう一度、最初に構文を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0fec230ed8200309bfc8c6866e454394b38359c7" translate="yes" xml:space="preserve">
          <source>Let's discuss the three ways of handling business logic in AngularJS in a simple way: (&lt;strong&gt;Inspired by Yaakov's Coursera AngularJS course&lt;/strong&gt;)</source>
          <target state="translated">AngularJSのビジネスロジックを簡単な方法で処理する3つの方法について説明します。</target>
        </trans-unit>
        <trans-unit id="fa350ad45511dbe39a4d035e7a10563f5896422d" translate="yes" xml:space="preserve">
          <source>Lets start with the difference between Service and factory:</source>
          <target state="translated">サービスと工場の違いから始めましょう。</target>
        </trans-unit>
        <trans-unit id="778a430f691a6018fcf57447a71b7c8cd2109696" translate="yes" xml:space="preserve">
          <source>Like I mentioned before, once you really understand what &amp;lsquo;new&amp;rsquo; does, Services are almost identical to factories in AngularJS.</source>
          <target state="translated">前に述べたように、「新しい」機能を実際に理解すると、サービスはAngularJSのファクトリとほぼ同じになります。</target>
        </trans-unit>
        <trans-unit id="25c6b479772ad22656b96f68f104741b92338f0a" translate="yes" xml:space="preserve">
          <source>Little late to the party.  But I thought this is more helpful for who would like to learn (or have clarity) on developing Angular JS Custom Services using factory, service and provider methodologies.</source>
          <target state="translated">パーティーに少し遅れています。しかし、ファクトリー、サービス、プロバイダのメソドロジーを使用してAngular JSカスタムサービスを開発することについて学びたい(または明確にしたい)人には、これがより役立つと思いました。</target>
        </trans-unit>
        <trans-unit id="4bd48a3b50a9f231823114ba704dfccf0bd973da" translate="yes" xml:space="preserve">
          <source>My clarification on this matter:</source>
          <target state="translated">この件で私が明確にしたこと</target>
        </trans-unit>
        <trans-unit id="fbf210c3ae8711990847a3d950af4119f3209adb" translate="yes" xml:space="preserve">
          <source>My understanding is very simple below.</source>
          <target state="translated">私の理解は以下のように非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="69f7e11da9f849693995d92816d880bd6fdc64e1" translate="yes" xml:space="preserve">
          <source>Not only produces singleton, but customizable services.</source>
          <target state="translated">シングルトンを生成するだけでなく、カスタマイズ可能なサービスを提供しています。</target>
        </trans-unit>
        <trans-unit id="982fb0ca939387b6254256e3ab0dfb3a7cc84d6c" translate="yes" xml:space="preserve">
          <source>Not only we can create a factory that's dynamically configurable, but at the time of using the factory, with the provider method, we could custom configure the factory just once at the bootstrapping of our entire application.</source>
          <target state="translated">動的に設定可能なファクトリーを作成できるだけでなく、ファクトリーを利用する際には、プロバイダメソッドを利用することで、アプリケーション全体のブートストラップ時に一度だけファクトリーをカスタム設定することができました。</target>
        </trans-unit>
        <trans-unit id="672bd2d09c7ed72a3eac6c27958d21691133d0dc" translate="yes" xml:space="preserve">
          <source>Note that it is possible to return a object (in which case it will function similar to a &lt;em&gt;service&lt;/em&gt;) or a function (that will be saved in the variable as a callback function).</source>
          <target state="translated">オブジェクト（ &lt;em&gt;サービスの&lt;/em&gt;場合と同様に機能する）または関数（コールバック関数として変数に保存される）を返すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5b1a8bd7c0a880872f4d9c7b867ae61242c0dfa0" translate="yes" xml:space="preserve">
          <source>Now having this knowledge of what the &amp;lsquo;new&amp;rsquo; keyword really does in JavaScript, creating a Service in AngularJS should be easier to understand.</source>
          <target state="translated">これで、JavaScriptで「新しい」キーワードが実際に何を行うかについての知識が得られたので、AngularJSでサービスを作成する方が理解しやすいはずです。</target>
        </trans-unit>
        <trans-unit id="d741df1b012ea25d838dc2c21bf70522da5f8512" translate="yes" xml:space="preserve">
          <source>Now just like in our factory and Service, setArtist, getArtist, and callItunes will be available in whichever controller we pass myProvider into. Here&amp;rsquo;s the myProvider controller (which is almost exactly the same as our factory/Service controller).</source>
          <target state="translated">これで、ファクトリとServiceのように、setArtist、getArtist、callItunesは、myProviderを渡すどのコントローラーでも使用できるようになります。 これがmyProviderコントローラーです（これは、ファクトリー/サービスコントローラーとほぼ同じです）。</target>
        </trans-unit>
        <trans-unit id="698af625bfcb4e8f8fcb2e7bcb26d8b5f98e4503" translate="yes" xml:space="preserve">
          <source>Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here&amp;rsquo;s the myService controller (which is almost exactly the same as our factory controller).</source>
          <target state="translated">これで、ファクトリと同様に、setServiceist、getArtist、およびcallItunesは、myServiceを渡すどのコントローラーでも使用できるようになります。 これがmyServiceコントローラーです（これは、出荷時のコントローラーとほぼ同じです）。</target>
        </trans-unit>
        <trans-unit id="33179f320db64f96208e8896db6147d2739c655b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a method onto our Person&amp;rsquo;s prototype so it will be available on every instance of our Person &amp;lsquo;class&amp;rsquo;.</source>
          <target state="translated">次に、Personのプロトタイプにメソッドを追加して、Personの「クラス」のすべてのインスタンスで使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="4e56b2bbd2bcd8c15e0879964355623ffab1f7bb" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add some &amp;lsquo;private&amp;rsquo; variables to our callback function. These won&amp;rsquo;t be directly accessible from the controller, but we will eventually set up some getter/setter methods on &amp;lsquo;service&amp;rsquo; to be able to alter these &amp;lsquo;private&amp;rsquo; variables when needed.</source>
          <target state="translated">次に、いくつかの「プライベート」変数をコールバック関数に追加しましょう。 これらはコントローラーから直接アクセスできませんが、必要に応じてこれらの「プライベート」変数を変更できるように、「サービス」にゲッター/セッターメソッドを最終的に設定します。</target>
        </trans-unit>
        <trans-unit id="b83d5faac981eb0e79df8c1e9fbac8b90b76a95f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what actually is happening when you use the &amp;lsquo;new&amp;rsquo; keyword in JavaScript. First thing you should notice is that after using &amp;lsquo;new&amp;rsquo; in our example, we&amp;rsquo;re able to call a method (sayName) on &amp;lsquo;tyler&amp;rsquo; just as if it were an object - that&amp;rsquo;s because it is. 
So first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says &amp;ldquo;OK, I&amp;rsquo;m going to look on the &amp;lsquo;tyler&amp;rsquo; object we just created, locate the sayName function, then call it. Wait a minute, I don&amp;rsquo;t see it here - all I see is name and age, let me check the prototype. Yup, looks like it&amp;rsquo;s on the prototype, let me call it.&amp;rdquo;.</source>
          <target state="translated">次に、JavaScriptで「new」キーワードを使用したときに実際に何が起こっているかを見てみましょう。 最初に気付くべきことは、この例で「new」を使用した後、まるでオブジェクトであるかのように、「tyler」でメソッド（sayName）を呼び出すことができるということです。 したがって、最初に、Personコンストラクターがオブジェクトを返していることがわかります。コードでそれを確認できるかどうかは関係ありません。 次に、sayName関数は直接Personインスタンスではなくプロトタイプにあるため、Person関数が返すオブジェクトは、ルックアップが失敗したときにそのプロトタイプに委任されている必要があることがわかります。 より簡単に言えば、tyler.sayName（）を呼び出すと、インタープリターは「OK、先ほど作成した 'tyler'オブジェクトを調べて、sayName関数を見つけて呼び出します。 ちょっと待ってください、ここには表示されません-表示されるのは名前と年齢だけです。プロトタイプを確認してみましょう。 うん、それはプロトタイプにあるように見えます。私はそれを呼ばせてください。」</target>
        </trans-unit>
        <trans-unit id="fb6577ce21f8b4d96fd20a371037e7c8ed7c6760" translate="yes" xml:space="preserve">
          <source>Now our factory is complete. We are now able to inject &amp;lsquo;myFactory&amp;rsquo; into any controller and we&amp;rsquo;ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes).</source>
          <target state="translated">これで工場が完成しました。 これで 'myFactory'を任意のコントローラーに挿入できるようになり、サービスオブジェクト（setArtist、getArtist、callItunes）にアタッチしたメソッドを呼び出すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="2dd7216c3d216047524da229ce33e07f854c5b20" translate="yes" xml:space="preserve">
          <source>Now that our helper/private variables and function are in place, let&amp;rsquo;s add some properties to the &amp;lsquo;service&amp;rsquo; object. Whatever we put on &amp;lsquo;service&amp;rsquo; can be directly used inside whichever controller we pass &amp;lsquo;myFactory&amp;rsquo; into.</source>
          <target state="translated">ヘルパー/プライベート変数と関数が用意できたので、「サービス」オブジェクトにいくつかのプロパティを追加しましょう。 「サービス」に設定したものはすべて、「myFactory」を渡すどのコントローラー内でも直接使用できます。</target>
        </trans-unit>
        <trans-unit id="39ddb2f22b7fced081ba8ea176229ca0ac8d8309" translate="yes" xml:space="preserve">
          <source>Now that we have our Person constructor function and our sayName function on its prototype, let&amp;rsquo;s actually create an instance of Person then call the sayName function.</source>
          <target state="translated">Personコンストラクター関数とsayName関数がそのプロトタイプにあるので、実際にPersonのインスタンスを作成してから、sayName関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ec51346deab58cf2c25c7d6a3cb4af41dc640f10" translate="yes" xml:space="preserve">
          <source>Now the full Provider code looks like this</source>
          <target state="translated">これで、プロバイダのコードは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a8c5c01dc8cb0c4ad9e61b2d0177736881556303" translate="yes" xml:space="preserve">
          <source>Now using the above two in the controller:</source>
          <target state="translated">今、コントローラで上記の2つを使用しています。</target>
        </trans-unit>
        <trans-unit id="554f3e5b70223d89fd87ed55eb8c7fa0aea6edc3" translate="yes" xml:space="preserve">
          <source>Now whatever properties we attach to &amp;lsquo;service&amp;rsquo; will be available to us when we pass &amp;lsquo;myFactory&amp;rsquo; into our controller.</source>
          <target state="translated">これで、「myFactory」をコントローラーに渡すと、「service」にアタッチするすべてのプロパティを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="8db4bcee9cc90896dbc924721630384540a94c50" translate="yes" xml:space="preserve">
          <source>Now you can see how &amp;lsquo;thingFromConfig&amp;rsquo; is as empty string in our provider, but when that shows up in the DOM, it will be &amp;lsquo;This sentence was set&amp;hellip;&amp;rsquo;.</source>
          <target state="translated">これで、プロバイダーで「thingFromConfig」が空の文字列としてどのように表示されるかがわかりますが、それがDOMに表示されると、「この文は設定されました...」になります。</target>
        </trans-unit>
        <trans-unit id="ec62b54ee6ce720c21f33325f4f0a65c82d69fdb" translate="yes" xml:space="preserve">
          <source>Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance&amp;rsquo;s name.</source>
          <target state="translated">これで、sayName関数をプロトタイプに配置したので、Personのすべてのインスタンスは、sayName関数を呼び出して、そのインスタンスの名前を警告できます。</target>
        </trans-unit>
        <trans-unit id="11f40cd81d972474ebbd1638f071afb14e360695" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll attach all of our methods that will be available in our controller to &amp;lsquo;this&amp;rsquo;.</source>
          <target state="translated">ここで、コントローラーで使用できるすべてのメソッドを「this」にアタッチします。</target>
        </trans-unit>
        <trans-unit id="f06e2a3c653d42f7111fe26d1c705865f3c86c73" translate="yes" xml:space="preserve">
          <source>Only provider will be available in config phase of angular, while
  service &amp;amp; factory are not.</source>
          <target state="translated">Angularの設定フェーズではプロバイダーのみが利用可能になりますが、サービスとファクトリーは利用できません。</target>
        </trans-unit>
        <trans-unit id="dfdb4f5263d92c8b24c27c443665ded6f3f279be" translate="yes" xml:space="preserve">
          <source>Perhaps the biggest thing to know when dealing with creating a Service is that that it&amp;rsquo;s instantiated with the &amp;lsquo;new&amp;rsquo; keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren&amp;rsquo;t too familiar with what the &amp;lsquo;new&amp;rsquo; keyword actually does, let&amp;rsquo;s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service.</source>
          <target state="translated">おそらく、サービスの作成を処理する際に知っておくべき最大のことは、「新しい」キーワードでインスタンス化されるということです。 JavaScriptの達人にとって、これはコードの性質に大きなヒントを与えるはずです。 JavaScriptのバックグラウンドが限られている方や、「新しい」キーワードの実際の機能に慣れていない方のために、サービスの性質を理解するのに役立つJavaScriptの基礎を復習しましょう。</target>
        </trans-unit>
        <trans-unit id="7ceee3f3615a2bbe4ce0ac5a269a311e4821daf4" translate="yes" xml:space="preserve">
          <source>Provider</source>
          <target state="translated">Provider</target>
        </trans-unit>
        <trans-unit id="53d2419e2fad27c745ab7837fb34c5b4cb3b5535" translate="yes" xml:space="preserve">
          <source>Provider is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">プロバイダーは最も複雑なレシピタイプです。グローバルな設定を必要とする再利用可能なコードを構築しているのでなければ、必要ありません。</target>
        </trans-unit>
        <trans-unit id="d3f6c702cb3e12640d8a58f3b97ac66d45f4b833" translate="yes" xml:space="preserve">
          <source>Provider is the most flexible method of creating services in Angular.</source>
          <target state="translated">プロバイダはAngularで最も柔軟にサービスを作成する方法です。</target>
        </trans-unit>
        <trans-unit id="955559753eafb5cc8b4506201a86bbe417ec9d05" translate="yes" xml:space="preserve">
          <source>Provider() function is the another way for creating services. Let we are interested to create a service which just display some greeting message to the user. But we also want to provide a functionality such that user can set their own greeting message. In technical terms we want to create configurable services. How can we do this ? There must be a way, so that app could pass their custom greeting messages and Angularjs would make it available to factory/constructor function which create our services instance.
In such a case provider() function do the job. using provider() function we can create configurable services.</source>
          <target state="translated">Provider()関数は、サービスを作成するためのもう一つの方法です。ここでは、ユーザーに挨拶文を表示するだけのサービスを作りたいとします。しかし、ユーザーが自分のグリーティングメッセージを設定できるような機能も提供したいと考えています。技術的には、設定可能なサービスを作りたいと考えています。どうすればいいのでしょうか?アプリが独自のグリーティングメッセージを渡し、Angularjsがそれをサービスインスタンスを作成するFactoryconstructor関数で利用できるようにする方法があるはずです。そのような場合にはプロバイダ()関数を使うことで、設定可能なサービスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="87b7c08baed1c8e93db95b79bcdca55b631dd7bb" translate="yes" xml:space="preserve">
          <source>Providers</source>
          <target state="translated">Providers</target>
        </trans-unit>
        <trans-unit id="2d56985193e8bf2d6ab8849ef7c57e0e5dde4a2b" translate="yes" xml:space="preserve">
          <source>Providers allow you to configure the provider &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; AngularJS calls the &lt;code&gt;$get&lt;/code&gt; method to get the injectible.</source>
          <target state="translated">プロバイダーを使用すると、AngularJSが &lt;code&gt;$get&lt;/code&gt; メソッドを呼び出して注射を取得する&lt;strong&gt;&lt;em&gt;前&lt;/em&gt;&lt;/strong&gt;にプロバイダーを構成できます。</target>
        </trans-unit>
        <trans-unit id="fa42b9d0b7dbcb3ea427607354fff8602303c4c8" translate="yes" xml:space="preserve">
          <source>Providers have the advantage that they can be configured during the module configuration phase.</source>
          <target state="translated">プロバイダは、モジュール構成フェーズで構成できるという利点があります。</target>
        </trans-unit>
        <trans-unit id="8d9b9399c4d6be5dbb075743c0ee3d595b3daf9b" translate="yes" xml:space="preserve">
          <source>Result: When declaring factoryName as an injectable argument you will be provided with &lt;strong&gt;the value that is returned by invoking the function reference passed to module.factory&lt;/strong&gt;.</source>
          <target state="translated">結果：factoryNameを注入可能な引数として宣言すると&lt;strong&gt;、module.factoryに渡された関数参照を呼び出すことによって返される値&lt;/strong&gt;が提供さ&lt;strong&gt;れます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b8055b0f238e713bbe09a1f5142a3a9c4180d28" translate="yes" xml:space="preserve">
          <source>Result: When declaring providerName as an injectable argument &lt;strong&gt;you will be provided with&lt;/strong&gt;&lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt;. The constructor function is instantiated before the $get method is called - &lt;code&gt;ProviderFunction&lt;/code&gt; is  the function reference passed to module.provider.</source>
          <target state="translated">結果：providerNameを注入可能な引数として宣言&lt;strong&gt;すると、&lt;/strong&gt; &lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt; &lt;strong&gt;が提供され&lt;/strong&gt; ます 。 $ getメソッドが呼び出される前にコンストラクター関数がインスタンス化されます。ProviderFunctionは、module.providerに渡される関数参照です。</target>
        </trans-unit>
        <trans-unit id="c70fc6d0d8618584e9490ed45c73cb37b4246b1e" translate="yes" xml:space="preserve">
          <source>Result: When declaring serviceName as an injectable argument &lt;strong&gt;you will be provided with an instance of the function. In other words&lt;/strong&gt;&lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt;.</source>
          <target state="translated">結果：serviceNameを注入可能な引数として宣言&lt;strong&gt;すると、関数のインスタンスが提供されます。&lt;/strong&gt; &lt;strong&gt;つまり、&lt;/strong&gt; &lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4c830a908226f52c7631bae300c0e26abb3631d0" translate="yes" xml:space="preserve">
          <source>Sample Example:</source>
          <target state="translated">サンプル例。</target>
        </trans-unit>
        <trans-unit id="381df071be6ca5ac8d6e5e18ab012360963bd4a9" translate="yes" xml:space="preserve">
          <source>Sample code for creating service using provide syntax:</source>
          <target state="translated">提供構文を使用してサービスを作成するためのサンプルコードです。</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">あると言ってくれ</target>
        </trans-unit>
        <trans-unit id="11dc1a4e11a2784e2b6de73a9022cddbb6721f42" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;the provider documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;プロバイダーのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7f4ab1a2559d02916ca6b754d342e20711e3cfca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;here&lt;/a&gt; for the provided code.</source>
          <target state="translated">提供されているコードについては、 &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5030396a200088699db9b35f53a60b75ca0f61ed" translate="yes" xml:space="preserve">
          <source>Service Function:</source>
          <target state="translated">サービス機能。</target>
        </trans-unit>
        <trans-unit id="6210fa9c0a7b05e22abb7fcb5a13962309ea102d" translate="yes" xml:space="preserve">
          <source>Service initialization</source>
          <target state="translated">サービスの初期化</target>
        </trans-unit>
        <trans-unit id="9d10e77416b918cf3662445c6e88c578fa4569c9" translate="yes" xml:space="preserve">
          <source>Service is an singleton object instance. Use services if you want to provide a singleton object for your code.</source>
          <target state="translated">サービスはシングルトンオブジェクトのインスタンスです。コードにシングルトンオブジェクトを提供したい場合は、サービスを使用します。</target>
        </trans-unit>
        <trans-unit id="61835754249fef2e2b45059d3bbd0d0e5cdde58d" translate="yes" xml:space="preserve">
          <source>Service/Factory behavior is very similar, and some people will say
  that either one is fine. That&amp;rsquo;s somewhat true, but I find it easier to
  follow the advice of John Papa&amp;rsquo;s style guide and just stick with
  factories.**</source>
          <target state="translated">サービス/ファクトリーの動作は非常によく似ており、一部の人々はどちらかで問題ないと言います。 確かにそうですが、John Papaのスタイルガイドのアドバイスに従い、ファクトリーを使用する方が簡単だと思います。**</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="c1e289d3853bb8c7d8a915f54b7abf6bb6594091" translate="yes" xml:space="preserve">
          <source>Simply while looking at the services think about the array prototype. A service is a function which instantiates a new object using the 'new' keyword. You can add properties and functions to a service object by using the &lt;code&gt;this&lt;/code&gt; keyword. Unlike a factory, it doesn't return anything (it returns an object which contains methods/properties).</source>
          <target state="translated">単にサービスを見ながら、アレイのプロトタイプについて考えます。 サービスは、「new」キーワードを使用して新しいオブジェクトをインスタンス化する関数です。 &lt;code&gt;this&lt;/code&gt; キーワードを使用して、サービスオブジェクトにプロパティと関数を追加できます。 ファクトリとは異なり、何も返しません（メソッド/プロパティを含むオブジェクトを返します）。</target>
        </trans-unit>
        <trans-unit id="62854845263bf068dddccd96ecb184fb8ea7a590" translate="yes" xml:space="preserve">
          <source>Since the constructed service is an object, the methods inside it can refer to this when they&amp;rsquo;re called:</source>
          <target state="translated">構築されたサービスはオブジェクトであるため、その内部のメソッドは、呼び出されたときにこれを参照できます。</target>
        </trans-unit>
        <trans-unit id="155220d0a18e305b7ea66fb35c4da7270fc65257" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;factory&lt;/code&gt; is a function which is responsible for creating the value. Notice that the factory function can ask for other dependencies.</source>
          <target state="translated">つまり、 &lt;code&gt;factory&lt;/code&gt; は値を作成する機能です。 ファクトリ関数が他の依存関係を要求できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4d857556fc3e68491091f75ba684105c6782e0e5" translate="yes" xml:space="preserve">
          <source>So all together the code for creating a Person constructor, adding a function to it&amp;rsquo;s prototype, creating a Person instance, and then calling the function on its prototype looks like this.</source>
          <target state="translated">したがって、Personコンストラクタを作成し、そのプロトタイプに関数を追加し、Personインスタンスを作成し、そのプロトタイプで関数を呼び出すためのコードはすべて、次のようになります。</target>
        </trans-unit>
        <trans-unit id="08c3828d081a8d7efafeefc62c0878e780b4e133" translate="yes" xml:space="preserve">
          <source>So basically in both cases you eventually get a providers $get set to your function you provided , but you can give anything extra than $get as you can originally provide in provider() for config block</source>
          <target state="translated">基本的にはどちらの場合も、最終的にはプロバイダに $get が設定されますが、設定ブロックの provider()で指定したように、$get 以外のものを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="27e3723bbf080ae2fb322bd7eb8909b1557894e4" translate="yes" xml:space="preserve">
          <source>So if there are three controller scope, let it be controllerA, controllerB and controllerC, all will share same service instance.</source>
          <target state="translated">つまり、3つのコントローラスコープがある場合、コントローラA、コントローラB、コントローラCの3つであれば、すべて同じサービスインスタンスを共有することになります。</target>
        </trans-unit>
        <trans-unit id="dd81d4d697436b2952af0ee10fd0dd2ca080a3d2" translate="yes" xml:space="preserve">
          <source>So master provider and injector and all will fall in place :) . And it gets interesting in Typescript when $get can be implemented in a provider by inheriting from IServiceProvider.</source>
          <target state="translated">だから、マスタープロバイダとインジェクタとすべての場所に落ちるでしょう :)..また、TypeScriptでは、IServiceProviderを継承して$getをプロバイダに実装すると面白いことになります。</target>
        </trans-unit>
        <trans-unit id="cb9d6754283c9f37208464bd5837389aa5b0ad15" translate="yes" xml:space="preserve">
          <source>So when Angular constructs your service with new MyService(), it&amp;rsquo;ll get that api object instead of the MyService instance.</source>
          <target state="translated">したがって、Angularがnew MyService（）を使用してサービスを構築すると、MyServiceインスタンスの代わりにそのAPIオブジェクトが取得されます。</target>
        </trans-unit>
        <trans-unit id="c72cf4ede28e8dd19525b9079025b0772ccc130b" translate="yes" xml:space="preserve">
          <source>So why such complications, why can't we just use provider and forget everything else? It is supposed to help us write code easily and communicate better. And toungue-in-cheek reply would be, the more complex it gets the better selling a framework will be.</source>
          <target state="translated">では、なぜそのような複雑さがあるのか、なぜプロバイダを使って他のことはすべて忘れてしまえばいいのでしょうか?プロバイダはコードを書きやすくするためのものであり、コミュニケーションを円滑にするためのものです。そして、複雑になればなるほどフレームワークは売れやすくなる、というのがトゥーンゲインチークの答えでしょう。</target>
        </trans-unit>
        <trans-unit id="d26ab8fdbfba98e5ec328de0fd5fd8b3ec1253e1" translate="yes" xml:space="preserve">
          <source>So, for the service, what becomes the AngularJS component is the object instance of the class which is represented by service declaration function. For the factory, it is the result returned from the factory declaration function. The factory may behave the same as the service:</source>
          <target state="translated">つまり、サービスの場合、AngularJSコンポーネントになるのはサービス宣言関数で表されるクラスのオブジェクトインスタンスです。ファクトリーの場合は、ファクトリー宣言関数から返された結果です。ファクトリーはサービスと同じように振る舞うことができます。</target>
        </trans-unit>
        <trans-unit id="e62f1055fa34e381a967d48cc84251a3806ed36c" translate="yes" xml:space="preserve">
          <source>Source Code: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</source>
          <target state="translated">ソースコード： &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http&lt;/a&gt; : //www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service</target>
        </trans-unit>
        <trans-unit id="9924e31c2dd752407f7714733eb09ad7aaef9362" translate="yes" xml:space="preserve">
          <source>Summary from &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular docs&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular docs&lt;/a&gt;からの要約：</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="8a29d9bf1a1e71cf529fe97431e96a86eaf41f44" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</source>
          <target state="translated">構文： &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194b446e2c1fb5fc04741acabf05acbc4af47aec" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</source>
          <target state="translated">構文： &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92324397a45dd6d31034d314cd7fc546cabef2b8" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</source>
          <target state="translated">構文： &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84dd638523da34b8795dead37b56820cfba7075e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$get&lt;/code&gt; is a function that is directly attached to the provider instance. That function is a &lt;strong&gt;factory&lt;/strong&gt; function. In other words, it's just like the one that we use to &lt;em&gt;provide&lt;/em&gt; to the &lt;code&gt;.factory&lt;/code&gt; method. In that function, we create our own service. &lt;strong&gt;This &lt;code&gt;$get&lt;/code&gt; property, that's a function, is what makes the provider a provider&lt;/strong&gt;. &lt;em&gt;AngularJS expects the provider to have a $get property whose value is a function that Angular will treat as a factory function.&lt;/em&gt; But what makes this whole provider setup very special, is the fact that we can provide some &lt;code&gt;config&lt;/code&gt; object inside the service provider, and that usually comes with defaults that we can later overwrite in the step, where we can configure the entire application.</source>
          <target state="translated">&lt;code&gt;$get&lt;/code&gt; は、プロバイダーインスタンスに直接アタッチされる関数です。 その関数は&lt;strong&gt;ファクトリ&lt;/strong&gt;関数です。 つまり、 &lt;code&gt;.factory&lt;/code&gt; メソッドに&lt;em&gt;提供するため&lt;/em&gt;に使用&lt;em&gt;する&lt;/em&gt;ものと同じです。 その関数では、独自のサービスを作成します。 &lt;strong&gt;この &lt;code&gt;$get&lt;/code&gt; プロパティは関数であり、プロバイダーをプロバイダーにします&lt;/strong&gt; 。 &lt;em&gt;AngularJSは、プロバイダーが$ getプロパティを持ち、その値がAngularがファクトリー関数として扱う関数であることを期待しています。&lt;/em&gt; しかし、このプロバイダー全体のセットアップを非常に特別なものにしているのは、サービスプロバイダー内にいくつかの構成オブジェクトを提供できることであり、通常は、アプリケーション全体を構成できるステップで後で上書きできるデフォルトが付属しています。</target>
        </trans-unit>
        <trans-unit id="7b6548f429604df735e1a44693ef40e85b8e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.service()&lt;/code&gt; method is a &lt;strong&gt;factory&lt;/strong&gt; that always produces the same type of service, which is a singleton, and without any easy way to configure it's behavior. That &lt;code&gt;.service()&lt;/code&gt; method is usually used as a shortcut for something that doesn't require any configuration whatsoever.</source>
          <target state="translated">&lt;code&gt;.service()&lt;/code&gt; メソッドは、常に同じタイプのサービス（シングルトン）を生成する&lt;strong&gt;ファクトリ&lt;/strong&gt;であり、その動作を簡単に設定する方法はありません。 その &lt;code&gt;.service()&lt;/code&gt; メソッドは通常、設定をまったく必要としないもののショートカットとして使用されます。</target>
        </trans-unit>
        <trans-unit id="a49ec85e38178c060ff6013773473704cdd2007a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, and &lt;code&gt;provider&lt;/code&gt; methods are all providers. They teach the Injector how to instantiate the Services.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 、 &lt;code&gt;factory&lt;/code&gt; 、 &lt;code&gt;service&lt;/code&gt; 、 &lt;code&gt;constant&lt;/code&gt; 、および &lt;code&gt;provider&lt;/code&gt; メソッドはすべてプロバイダーです。 彼らはインジェクターにサービスをインスタンス化する方法を教えます。</target>
        </trans-unit>
        <trans-unit id="025bc59091687d744c1dd87ac4446f1a3ea99b14" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Constant recipe&lt;/strong&gt; is just like the Value recipe except it allows you to define services that are available in the &lt;strong&gt;config&lt;/strong&gt; phase. Sooner than services created using the Value recipe. Unlike Values, they cannot be decorated using &lt;code&gt;decorator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;定数レシピ&lt;/strong&gt;は、構成フェーズで使用可能なサービスを定義できることを除いて、値&lt;strong&gt;レシピ&lt;/strong&gt;と同じです。 Valueレシピを使用して作成されたサービスよりも早く。 値とは異なり、 &lt;code&gt;decorator&lt;/code&gt; を使用して装飾することはできません。</target>
        </trans-unit>
        <trans-unit id="3cf81a424905d80f0814719f3aa86cbdefa28b91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Factory recipe&lt;/strong&gt; gives the Injector a factory function that it calls when it needs to instantiate the service. When called, the &lt;strong&gt;factory function&lt;/strong&gt; creates and returns the service instance. The dependencies of the Service are injected as the functions' arguments. So using this recipe adds the following abilities:</source>
          <target state="translated">&lt;strong&gt;Factoryレシピ&lt;/strong&gt;は、Injectorにサービスをインスタンス化する必要があるときに呼び出すファクトリ関数を提供します。 呼び出されると、 &lt;strong&gt;ファクトリ関数&lt;/strong&gt;はサービスインスタンスを作成して返します。 サービスの依存関係は、関数の引数として挿入されます。 したがって、このレシピを使用すると、次の能力が追加されます。</target>
        </trans-unit>
        <trans-unit id="b86e7115a91b56187a5fe0143ed257a341995e64" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider recipe&lt;/strong&gt; is usually &lt;strong&gt;overkill&lt;/strong&gt;. It adds one more layer of indirection by allowing you to configure the creation of the factory.</source>
          <target state="translated">&lt;strong&gt;プロバイダーのレシピ&lt;/strong&gt;は通常&lt;strong&gt;過剰&lt;/strong&gt;です。 ファクトリの作成を構成できるようにすることで、間接層が1つ追加されます。</target>
        </trans-unit>
        <trans-unit id="cad58aeb7205a606c508335ce156288e7da6f573" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider&lt;/strong&gt; recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">&lt;strong&gt;プロバイダー&lt;/strong&gt;レシピはコアレシピタイプであり、他のすべてのレシピは構文上の砂糖です。</target>
        </trans-unit>
        <trans-unit id="17bb816a792f8c3e9c45f68c21dac545bc7fc6e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Service recipe&lt;/strong&gt; is almost the same as the Factory recipe, but here the Injector invokes a &lt;strong&gt;constructor&lt;/strong&gt; with the new operator instead of a factory function.</source>
          <target state="translated">&lt;strong&gt;Serviceレシピ&lt;/strong&gt;はFactory &lt;strong&gt;レシピ&lt;/strong&gt;とほとんど同じですが、インジェクターはファクトリー関数の代わりにnewオペレーターを使用して&lt;strong&gt;コンストラクター&lt;/strong&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="0f6f2e7cab552a54a9d8929a09e98e95cc4cfb9f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Value Recipe&lt;/strong&gt; is the simplest case, where you instantiate the Service yourself and provide the &lt;strong&gt;instantiated value&lt;/strong&gt; to the injector.</source>
          <target state="translated">&lt;strong&gt;バリューレシピ&lt;/strong&gt;は最も簡単なケースで、サービスを自分で&lt;strong&gt;インスタンス化し&lt;/strong&gt; 、 &lt;strong&gt;インスタンス化した値&lt;/strong&gt;をインジェクターに提供し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">プロバイダーレシピはコアレシピタイプであり、他のすべてのものはその上の構文上の砂糖です。</target>
        </trans-unit>
        <trans-unit id="c20c67a4543a337b871e95eaa0aa2230110f9cde" translate="yes" xml:space="preserve">
          <source>The biggest thing to remember about Providers is that they&amp;rsquo;re the only service that you can pass into the app.config portion of your application. This is of huge importance if you&amp;rsquo;re needing to alter some portion of your service object before it&amp;rsquo;s available everywhere else in your application. Although very similar to Services/Factories, there are a few differences which we&amp;rsquo;ll discuss.</source>
          <target state="translated">プロバイダーについて覚えておくべき最大のことは、プロバイダーがアプリケーションのapp.config部分に渡すことができる唯一のサービスであることです。 これは、サービスオブジェクトの一部をアプリケーションのほかの場所で使用できるようにする前に変更する必要がある場合に非常に重要です。 サービス/工場に非常に似ていますが、これから説明するいくつかの違いがあります。</target>
        </trans-unit>
        <trans-unit id="a2a3557bc4924e63f2d2ce284fc4ba7adf38dc02" translate="yes" xml:space="preserve">
          <source>The biggest thing to understand when creating a Service is knowing that Services are instantiated with the &amp;lsquo;new&amp;rsquo; keyword. Combining that knowledge with our examples above, you should now recognize that you&amp;rsquo;ll be attaching your properties and methods directly to &amp;lsquo;this&amp;rsquo; which will then be returned from the Service itself. Let&amp;rsquo;s take a look at this in action.</source>
          <target state="translated">サービスを作成するときに理解する最大のことは、サービスが「新しい」キーワードでインスタンス化されることを知ることです。 その知識と上記の例を組み合わせると、プロパティとメソッドを直接「this」にアタッチし、サービス自体から返されることを認識できるはずです。 これを実際に見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ee97831b61259806e326d0d7c322a8ac829781ee" translate="yes" xml:space="preserve">
          <source>The code for &quot;factory&quot; based custom service is as follows (which goes with both sync and async versions along with calling http service):</source>
          <target state="translated">ファクトリーベースのカスタムサービスのコードは以下のようになります(同期版と非同期版の両方に対応し、httpサービスを呼び出すことができます)。</target>
        </trans-unit>
        <trans-unit id="dbceb93948d3b88153505159e94a72b7b46ceaf3" translate="yes" xml:space="preserve">
          <source>The code for &quot;provider&quot; methodology for Custom Services (this is necessary, if you would like to develop service which could be configured):</source>
          <target state="translated">カスタムサービスの「プロバイダ」の方法論のためのコード(これは、あなたが設定可能なサービスを開発したい場合は、必要です)。</target>
        </trans-unit>
        <trans-unit id="20100b8b1bb6246809bfd0d54c74369163ea60ef" translate="yes" xml:space="preserve">
          <source>The code for &quot;service&quot; methodology for Custom Services (this is pretty similar to 'factory', but different from syntax point of view):</source>
          <target state="translated">カスタムサービスの「サービス」の方法論のためのコード(これは「ファクトリー」とかなり似ていますが、構文的には異なります)。</target>
        </trans-unit>
        <trans-unit id="1f5224c76a4a9f42aeda5250ed57bd05696a3d3c" translate="yes" xml:space="preserve">
          <source>The difference between the three is that:</source>
          <target state="translated">この3つの違いは</target>
        </trans-unit>
        <trans-unit id="80c0d58f7ad22390cf6e79a7ead32b51a9279f3b" translate="yes" xml:space="preserve">
          <source>The factory 'class' example is provided in the comments around, as well as provider difference.</source>
          <target state="translated">ファクトリーの「クラス」の例は、プロバイダの違いと同様に、周りのコメントで提供されています。</target>
        </trans-unit>
        <trans-unit id="29223deeb9a116b14e0df19e98f9ac9f789b7dbd" translate="yes" xml:space="preserve">
          <source>The factory can also return an object with a method that can be invoked:</source>
          <target state="translated">ファクトリーは、呼び出し可能なメソッドを持つオブジェクトを返すこともできます。</target>
        </trans-unit>
        <trans-unit id="c72bcb74f28a11248fb075ce43662f6ac919dc7d" translate="yes" xml:space="preserve">
          <source>The factory can then be used throughout the application with custom settings. In other words, we can configure this factory before the application starts. In fact in the angular documentation it is mentioned that the provider method is what actually gets executed behind the scenes when we configure our services with either &lt;code&gt;.service&lt;/code&gt; or &lt;code&gt;.factory&lt;/code&gt; methods.</source>
          <target state="translated">その後、ファクトリをカスタム設定でアプリケーション全体で使用できます。 つまり、アプリケーションを起動する前にこのファクトリを構成できます。 実際、角度付きのドキュメントでは、 &lt;code&gt;.service&lt;/code&gt; または &lt;code&gt;.factory&lt;/code&gt; メソッドのいずれかでサービスを構成するときに、プロバイダーメソッドが実際に舞台裏で実行されることが言及されています。</target>
        </trans-unit>
        <trans-unit id="70f2a456ca8dd7dbc5919aa27331c81f32a961f4" translate="yes" xml:space="preserve">
          <source>The factory returns a function that can be invoked:</source>
          <target state="translated">ファクトリーは、呼び出し可能な関数を返します。</target>
        </trans-unit>
        <trans-unit id="294c451a3bc3bc52035a0a1ff0d80aadf5cf8464" translate="yes" xml:space="preserve">
          <source>The injected value for a factory dependency is the factory&amp;rsquo;s return
  value, and it doesn&amp;rsquo;t have to be an object. It could be a function</source>
          <target state="translated">ファクトリー依存関係に注入された値は、ファクトリーの戻り値であり、オブジェクトである必要はありません。 関数かもしれません</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services
and special purpose objects</source>
          <target state="translated">インジェクタはレシピを使用して、サービスと特別目的のオブジェクトの 2 種類のオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="2a5bdc6259273898183df356d5f764744dcb6660" translate="yes" xml:space="preserve">
          <source>The lowest level way to create a service is by using the provide() method. This is the only way to create a service that we can configure using the .config() function.
Unlike the previous to methods, we&amp;rsquo;ll set the injectables in a defined this.$get() function definition.</source>
          <target state="translated">サービスを作成する最低レベルの方法は、provide（）メソッドを使用することです。 これは、.config（）関数を使用して構成できるサービスを作成する唯一の方法です。 以前のtoメソッドとは異なり、定義済みのthis。$ get（）関数定義で注入可能オブジェクトを設定します。</target>
        </trans-unit>
        <trans-unit id="33cea9a6904f984abbc8f96a6114e14b3b574e31" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider
  recipe. The &lt;strong&gt;remaining four&lt;/strong&gt; recipe types &amp;mdash; Value, Factory, Service and
  Constant &amp;mdash; &lt;strong&gt;are just syntactic sugar on top of a provider recipe&lt;/strong&gt;.</source>
          <target state="translated">最も冗長で最も包括的なものは、プロバイダーレシピです。 &lt;strong&gt;残りの4つの&lt;/strong&gt;レシピタイプ（Value、Factory、Service、およびConstant） &lt;strong&gt;は、プロバイダーレシピに加えて、単なる構文上の砂糖です&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="348c5cf5eea19f952edd139e0384878a13cc16b3" translate="yes" xml:space="preserve">
          <source>The passed function can define a object and return that object. AngularJS simply stores this object reference to a variable which is passed as first argument. Anything which is returned from fnFactory will be bound to serviceInstance . Instead of returning object , we can also return function, values etc, Whatever we will return , will be available to service instance.</source>
          <target state="translated">渡された関数はオブジェクトを定義し、そのオブジェクトを返すことができます。AngularJSはこのオブジェクトの参照を第一引数として渡された変数に格納するだけです。fnFactoryから返されるものは何でもserviceInstanceにバインドされます。オブジェクトを返す代わりに、関数や値などを返すこともできます。</target>
        </trans-unit>
        <trans-unit id="d2510f9c93a099e17ccd62f31f88b7b395fab6a8" translate="yes" xml:space="preserve">
          <source>The service returns an object with a method that can be invoked:</source>
          <target state="translated">サービスは、呼び出し可能なメソッドを持つオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="c22685b3257f9741c0336da5fe8df717ac146fa0" translate="yes" xml:space="preserve">
          <source>The service() method, on the other hand allows us to create a service by defining a constructor function. We can use a prototypical object to define our service, instead of a raw javascript object.
Similar to the factory() method, we&amp;rsquo;ll also set the injectables in the function definition.</source>
          <target state="translated">一方、service（）メソッドを使用すると、コンストラクター関数を定義してサービスを作成できます。 未加工のJavaScriptオブジェクトの代わりに、プロトタイプオブジェクトを使用してサービスを定義できます。 factory（）メソッドと同様に、関数定義でインジェクタブルも設定します。</target>
        </trans-unit>
        <trans-unit id="6d15e1717ce86b0987b078987bab5ad9e89e8630" translate="yes" xml:space="preserve">
          <source>The simplest way of thinking is the following one:</source>
          <target state="translated">一番シンプルな考え方としては、次のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="d37bdb33569628feda26fad99fde289973152425" translate="yes" xml:space="preserve">
          <source>Then it needs to have a separate &lt;em&gt;$.get&lt;/em&gt; function which is executed by AngularJS after setting the above properties via the &lt;code&gt;app.config&lt;/code&gt; file , and this &lt;em&gt;$.get&lt;/em&gt; function behaves just as the &lt;em&gt;factory&lt;/em&gt; above, in that its return value is used to initialize the &quot;global&quot; variables.</source>
          <target state="translated">次に、 &lt;em&gt;app.config&lt;/em&gt;ファイルを介して上記のプロパティを設定した後、AngularJSによって実行される個別の&lt;em&gt;$ .get&lt;/em&gt;関数が必要です。この&lt;em&gt;$ .get&lt;/em&gt;関数は、戻り値を使用して初期化されるため、上記の&lt;em&gt;ファクトリと&lt;/em&gt;同じように動作します。 「グローバル」変数。</target>
        </trans-unit>
        <trans-unit id="b32fe2094a05734d73d634537bd5399d06168766" translate="yes" xml:space="preserve">
          <source>Then to instantiate you would have to write</source>
          <target state="translated">インスタンス化するには、次のように書く必要があります。</target>
        </trans-unit>
        <trans-unit id="3dbd87f48f38a7cd7438dff5c9c9a17a54a72326" translate="yes" xml:space="preserve">
          <source>Then we can do this:</source>
          <target state="translated">ならば、こうすればいい。</target>
        </trans-unit>
        <trans-unit id="26ab2c621cf3a4ad1aed6bc59c8cac976a8891fc" translate="yes" xml:space="preserve">
          <source>Then we could ask for 'greeter' in controller like this</source>
          <target state="translated">そうすれば、このようにコントローラに'greeter'を要求することができます。</target>
        </trans-unit>
        <trans-unit id="73c6e7a10f2e40affaa0702fd4636afb5ef0a445" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt;,
&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">オブジェクトの作成方法を定義する5つのレシピタイプがあります： &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt;および&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, 
Factory, Service, Provider and Constant.</source>
          <target state="translated">オブジェクトの作成方法を定義する5つのレシピタイプがあります。Value、Factory、Service、Provider、Constantです。</target>
        </trans-unit>
        <trans-unit id="a3abfbafa21284370080781426e7f10765c626b1" translate="yes" xml:space="preserve">
          <source>There are good answers already, but I just want to share this one.</source>
          <target state="translated">すでに良い回答があるのですが、これだけは共有したいと思います。</target>
        </trans-unit>
        <trans-unit id="cbe50089e98dca4865d62e4d5d431a2ad1e1d31e" translate="yes" xml:space="preserve">
          <source>There are many levels of complications in creating the values for the &quot;global variables&quot;:</source>
          <target state="translated">グローバル変数」の値の作成には、多くのレベルの複雑さがあります。</target>
        </trans-unit>
        <trans-unit id="cfe4afb9db4aa26d7132e641470f68bed3f4242c" translate="yes" xml:space="preserve">
          <source>There is &lt;code&gt;Service vs Factory&lt;/code&gt; part has been covered:
&lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Service vs Factory&lt;/code&gt; 部分がカバーされています： &lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https&lt;/a&gt; : //www.youtube.com/watch?v=BLzNCkPn3ao</target>
        </trans-unit>
        <trans-unit id="a8ee704f9be11c360a8332f959f17604faeec8af" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;$get&lt;/code&gt; object that you define and it can be used to get the object that returns data.</source>
          <target state="translated">定義する &lt;code&gt;$get&lt;/code&gt; オブジェクトがあり、データを返すオブジェクトを取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5a7068b6dda657b5b0908bbb1b5b47f54867579f" translate="yes" xml:space="preserve">
          <source>This answer address the topic/question</source>
          <target state="translated">この答えは、topicquestionをアドレスします。</target>
        </trans-unit>
        <trans-unit id="d2ca6aed8a94daf45ebec515f35b4ef0c7e37069" translate="yes" xml:space="preserve">
          <source>This defines an actual constant that should not be modified during the entire application, just like constants in other languages are (something that JavaScript lacks).</source>
          <target state="translated">これは、他の言語の定数がそうであるように(JavaScriptに欠けているもの)、アプリケーション全体で変更されるべきではない実際の定数を定義しています。</target>
        </trans-unit>
        <trans-unit id="23068a44ce8e025468c6a880cdc354c2346311bc" translate="yes" xml:space="preserve">
          <source>This is a modifiable value or object, and it serves as some global variable, that can even be injected when creating other services or factories (see further on these). However, it must be a &quot;&lt;em&gt;literal value&lt;/em&gt;&quot;, which means that one has to write out the actual value, and cannot use any computation or programming logic (in other words &lt;em&gt;39&lt;/em&gt; or &lt;em&gt;myText&lt;/em&gt; or &lt;em&gt;{prop: &quot;value&quot;}&lt;/em&gt; are OK, but &lt;em&gt;2 +2&lt;/em&gt; is not).</source>
          <target state="translated">これは変更可能な値またはオブジェクトであり、いくつかのグローバル変数として機能し、他のサービスまたはファクトリを作成するときに挿入することもできます（これらの詳細を参照）。 ただし、これは「 &lt;em&gt;リテラル値&lt;/em&gt; 」である必要があります。つまり、実際の値を書き出す必要があり、計算またはプログラミングロジックを使用できません（つまり、 &lt;em&gt;39&lt;/em&gt;または&lt;em&gt;myText&lt;/em&gt;または&lt;em&gt;{prop： &quot;value&quot;}&lt;/em&gt;は問題ありませんが、 &lt;em&gt;2 +2&lt;/em&gt;はそうではありません）。</target>
        </trans-unit>
        <trans-unit id="7c23aa97141e4f8d46377a4215db03016a94f612" translate="yes" xml:space="preserve">
          <source>This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the &amp;lsquo;new&amp;rsquo; keyword, &amp;lsquo;this&amp;rsquo; will be bound to the newly created object.</source>
          <target state="translated">これは、典型的なJavaScriptコンストラクター関数です。 これで、「new」キーワードを使用してPerson関数を呼び出すたびに、「this」が新しく作成されたオブジェクトにバインドされます。</target>
        </trans-unit>
        <trans-unit id="dfb8cea8751eb472adb742095a7b2c6e23a67444" translate="yes" xml:space="preserve">
          <source>This is the behavior for any complex values (objects, functions) but not for primitive types.</source>
          <target state="translated">これは、任意の複雑な値(オブジェクト、関数)に対しては動作しますが、プリミティブ型に対しては動作しません。</target>
        </trans-unit>
        <trans-unit id="f1e7c9cd5dc0b108189dc22be56ae3d9ed503494" translate="yes" xml:space="preserve">
          <source>This is very confusing part for newbie and I have tried to clarify it in easy words</source>
          <target state="translated">これは初心者にとっては非常に混乱する部分であり、私は簡単な言葉でそれを明確にしようとしました。</target>
        </trans-unit>
        <trans-unit id="0071c8fa9a8db22cbf7fe7086f0e4a422890b5c6" translate="yes" xml:space="preserve">
          <source>This is why we use &lt;code&gt;this&lt;/code&gt; in services, and define a &lt;code&gt;this.$get&lt;/code&gt; in providers.</source>
          <target state="translated">これがサービスで &lt;code&gt;this&lt;/code&gt; を使用し、プロバイダーで &lt;code&gt;this.$get&lt;/code&gt; を定義する理由です。</target>
        </trans-unit>
        <trans-unit id="337dbda194e27c65c3b59a20fcfe6f20bce044b3" translate="yes" xml:space="preserve">
          <source>This means that you can basically copy-paste the factory example from below, replace &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;service&lt;/code&gt;, and it&amp;rsquo;ll work:</source>
          <target state="translated">つまり、基本的にはファクトリーの例を下からコピーして貼り付け、 &lt;code&gt;factory&lt;/code&gt; を &lt;code&gt;service&lt;/code&gt; に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="bcb15b94b5801e9e5561df693ee7def2f99bdaf9" translate="yes" xml:space="preserve">
          <source>To really see the changes that occur when you invoke a function with the &amp;lsquo;new&amp;rsquo; keyword, let&amp;rsquo;s create a function and invoke it with the &amp;lsquo;new&amp;rsquo; keyword, then let&amp;rsquo;s show what the interpreter does when it sees the &amp;lsquo;new&amp;rsquo; keyword. The end results will both be the same.</source>
          <target state="translated">「new」キーワードを使用して関数を呼び出したときに発生する変更を実際に確認するには、関数を作成して「new」キーワードを使用して呼び出し、次に「new」キーワードを検出したときにインタープリターが何を行うかを見てみましょう。 最終結果はどちらも同じになります。</target>
        </trans-unit>
        <trans-unit id="f002fd0a5d473826ead53b980392d6392a7e2430" translate="yes" xml:space="preserve">
          <source>Unlike a service which is a simplified version of &lt;em&gt;factory&lt;/em&gt;, a provider is a more complex, but more flexible way of initializing the &quot;global&quot; variables, with the biggest flexibility being the option to set values from the app.config.</source>
          <target state="translated">&lt;em&gt;factoryの&lt;/em&gt;簡略化されたバージョンであるサービスとは異なり、プロバイダーは「グローバル」変数を初期化するより複雑ですがより柔軟な方法であり、最大の柔軟性はapp.configから値を設定するオプションです。</target>
        </trans-unit>
        <trans-unit id="864ea43a8c2da87a50b0e143c273a5376c32245f" translate="yes" xml:space="preserve">
          <source>Unlike what we originally did with the Factory example, we don&amp;rsquo;t need to create an object then return that object because, like mentioned many times before, we used the &amp;lsquo;new&amp;rsquo; keyword so the interpreter will create that object, have it delegate to it&amp;rsquo;s prototype, then return it for us without us having to do the work.</source>
          <target state="translated">最初にFactoryの例で行ったのとは異なり、オブジェクトを作成してからそのオブジェクトを返す必要はありません。これまでに何度も言及したように、「new」キーワードを使用してインタープリターがそのオブジェクトを作成し、デリゲートしているためですこれはプロトタイプであり、作業を行わなくても返却できます。</target>
        </trans-unit>
        <trans-unit id="b49caeb887a29a8bada2966d7c2590d853f20723" translate="yes" xml:space="preserve">
          <source>Usage (as an injectable in a controller)</source>
          <target state="translated">用途(コントローラ内の注射剤として</target>
        </trans-unit>
        <trans-unit id="879ae7be1e519b410069e2f401b1f3f754b21f05" translate="yes" xml:space="preserve">
          <source>Usage (configuring the provider before &lt;code&gt;$get&lt;/code&gt; is called to create the injectable)</source>
          <target state="translated">使用法（インジェクタブルを作成する &lt;code&gt;$get&lt;/code&gt; に$ getが呼び出される前にプロバイダーを構成する）</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="4022b8a59a0d0d2ca89f1ecfac78f71d1bc33304" translate="yes" xml:space="preserve">
          <source>Use it when you need to share a single object throughout the application. For example, authenticated user details, share-able methods/data, Utility functions etc.</source>
          <target state="translated">アプリケーション全体で単一のオブジェクトを共有する必要がある場合に使用します。例えば、認証されたユーザーの詳細、共有可能なメソッドデータ、ユーティリティ関数などです。</target>
        </trans-unit>
        <trans-unit id="c140efc7adf0e2b8a74e6393e081cb7475561437" translate="yes" xml:space="preserve">
          <source>Use this link for code reference</source>
          <target state="translated">コードの参照には、このリンクを使用してください。</target>
        </trans-unit>
        <trans-unit id="be9209121182255216aaa47dfd1cae1b29bb43e3" translate="yes" xml:space="preserve">
          <source>Using as reference this page and the &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentation&lt;/a&gt; (which seems to have greatly improved since the last time I looked), I put together the following real(-ish) world demo which uses 4 of the 5 flavours of provider; Value, Constant, Factory and full blown Provider.</source>
          <target state="translated">このページと&lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;ドキュメント&lt;/a&gt; （前回見たときから大幅に改善されているようです）を参考にして、プロバイダーの5つのフレーバーのうち4つを使用する次の実際の（-ish）ワールドデモをまとめました。 バリュー、コンスタント、ファクトリー、本格的なプロバイダー。</target>
        </trans-unit>
        <trans-unit id="7f1b9dfcd80673ff780bfe6c9e4b747b202f04d5" translate="yes" xml:space="preserve">
          <source>Using the factory() in our app</source>
          <target state="translated">アプリで factory()を使用する</target>
        </trans-unit>
        <trans-unit id="93312e4afaa947b3a60bfa6bea40f131935883a5" translate="yes" xml:space="preserve">
          <source>Visibility of injectables is different for providers than it is for services and factories. If you declare an AngularJS &quot;constant&quot; (for example, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt;), you can inject it into services, factories, and providers.</source>
          <target state="translated">注射剤の可視性は、プロバイダーとサービスおよび工場では異なります。 AngularJSの「定数」を宣言する場合（たとえば、 &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt; ）、それをサービス、ファクトリー、プロバイダーに注入できます。</target>
        </trans-unit>
        <trans-unit id="d22cafa4fcd376a2f27d8c4831e76c2f8fa630f7" translate="yes" xml:space="preserve">
          <source>We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven&amp;rsquo;t had much experience using promises in AngularJS, I highly recommend doing a deep dive on them.</source>
          <target state="translated">アーティストを返すか設定するだけのsetArtistメソッドとgetArtistメソッドを作成します。 また、作成したURLでiTunes APIを呼び出すメソッドを作成します。 このメソッドは、iTunes APIからデータが返されると満たされるpromiseを返します。 AngularJSでpromiseを使用した経験があまりない場合は、promiseについて詳しく説明することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="c68ba4741829821c5273926306c848fe58e787c7" translate="yes" xml:space="preserve">
          <source>We can create configurable services using provider syntax as given below.</source>
          <target state="translated">以下に示すように、プロバイダの構文を使用して設定可能なサービスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="dbe235285ce55886f522548de7d34e5b6a156187" translate="yes" xml:space="preserve">
          <source>We can define a factory function as below.</source>
          <target state="translated">ファクトリー機能は以下のように定義することができます。</target>
        </trans-unit>
        <trans-unit id="9dc701ea399c4055cce4573cf97749a703eb7d4a" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Provider&lt;/code&gt; and &lt;code&gt;Factory&lt;/code&gt; in AngularJS?</source>
          <target state="translated">AngularJSの &lt;code&gt;Service&lt;/code&gt; 、 &lt;code&gt;Provider&lt;/code&gt; 、 &lt;code&gt;Factory&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="1d97deb201bb1447c8de5b02c7b3a99898edb8b5" translate="yes" xml:space="preserve">
          <source>When Angular injects this &lt;code&gt;MyService&lt;/code&gt; service into a controller that
  depends on it, that controller will get a &lt;code&gt;MyService&lt;/code&gt; that it can call
  functions on, e.g. MyService.aServiceMethod ().</source>
          <target state="translated">Angularがこの &lt;code&gt;MyService&lt;/code&gt; サービスを依存するコントローラーに注入すると、そのコントローラーはMyService.aServiceMethod（）などの関数を呼び出すことができる &lt;code&gt;MyService&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="71e6a586496bb64a15227083621aef43a2714aea" translate="yes" xml:space="preserve">
          <source>When creating a service with Provider, the only properties/methods that will be available in your controller are those properties/methods which are returned from the $get() function. The code below puts $get on &amp;lsquo;this&amp;rsquo; (which we know will eventually be returned from that function). Now, that $get function returns all the methods/properties we want to be available in the controller. Here&amp;rsquo;s a code example.</source>
          <target state="translated">プロバイダーでサービスを作成する場合、コントローラーで使用できるのは、$ get（）関数から返されるプロパティ/メソッドのみです。 以下のコードは$ getを 'this'に配置します（これは最終的にその関数から返されることがわかっています）。 これで、$ get関数はコントローラーで使用できるようにするすべてのメソッド/プロパティを返します。 これがコード例です。</target>
        </trans-unit>
        <trans-unit id="3bc3b865d96d4a3942513d9897a3bb409a798a5a" translate="yes" xml:space="preserve">
          <source>When making a &lt;code&gt;service()&lt;/code&gt; it return you providing a factory() with a &lt;code&gt;function&lt;/code&gt; that injects the &lt;code&gt;constructor&lt;/code&gt; (return the instance of the constructor you provided in your service) and returns it</source>
          <target state="translated">&lt;code&gt;service()&lt;/code&gt; を作成すると、 &lt;code&gt;constructor&lt;/code&gt; を注入する &lt;code&gt;function&lt;/code&gt; をfactory（）に提供して返します（サービスで提供したコンストラクターのインスタンスを返します）。</target>
        </trans-unit>
        <trans-unit id="d6d43abc5bb66cd755013d3ef82d0ae0e0cc46c8" translate="yes" xml:space="preserve">
          <source>When you make a &lt;code&gt;factory()&lt;/code&gt; it sets you &lt;code&gt;function&lt;/code&gt; provided in second argument to provider's &lt;code&gt;$get&lt;/code&gt; and return it(&lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt;),</source>
          <target state="translated">&lt;code&gt;factory()&lt;/code&gt; を作成すると、2番目の引数で提供された &lt;code&gt;function&lt;/code&gt; がプロバイダーの &lt;code&gt;$get&lt;/code&gt; に設定され、それが返されます（ &lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt; ）、</target>
        </trans-unit>
        <trans-unit id="45f317e75b95e397ea00208400104d4fe8bf5e18" translate="yes" xml:space="preserve">
          <source>When you need to provide module-wise configuration for your service object before making it available, eg. suppose you want to set your API URL on basis of your Environment like &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;stage&lt;/code&gt; or &lt;code&gt;prod&lt;/code&gt;</source>
          <target state="translated">サービスオブジェクトを使用可能にする前に、モジュールごとに構成する必要がある場合。 &lt;code&gt;dev&lt;/code&gt; 、 &lt;code&gt;stage&lt;/code&gt; 、 &lt;code&gt;prod&lt;/code&gt; などの環境に基づいてAPI URLを設定するとします</target>
        </trans-unit>
        <trans-unit id="2d9813216aceb4fb52c9772759aad11c548dbb06" translate="yes" xml:space="preserve">
          <source>Which means there&amp;rsquo;s something like a cache object inside AngularJS, whose value of each injection is only assigned once, when they've been injected the first time, and where:</source>
          <target state="translated">これは、AngularJS内にキャッシュオブジェクトのようなものがあることを意味します。各インジェクションの値は、最初にインジェクションされたときに一度だけ割り当てられます。</target>
        </trans-unit>
        <trans-unit id="9a5bdc65b2c24b100cbcaaaa5059622b099681ae" translate="yes" xml:space="preserve">
          <source>While global variables are not recommended, the real usage of these global variables is to provide &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, by passing the variable to the relevant controller.</source>
          <target state="translated">グローバル変数は推奨されませんが、これらのグローバル変数の実際の使用法は、変数を関連するコントローラーに渡すことにより、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;依存性注入&lt;/a&gt;を提供することです。</target>
        </trans-unit>
        <trans-unit id="b5f5a2ae1fcba7052d4d70638cf84ffe0eb2743b" translate="yes" xml:space="preserve">
          <source>Working &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;demo&lt;/a&gt;.</source>
          <target state="translated">作業&lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;デモ&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5b3d2c4eb971fcbd43812638af12c7dc4437f9c" translate="yes" xml:space="preserve">
          <source>Working Demo</source>
          <target state="translated">ワーキングデモ</target>
        </trans-unit>
        <trans-unit id="9fd4dd933fe260f137acd6eae3ea36eb6536140b" translate="yes" xml:space="preserve">
          <source>You can think of Providers as having three sections. The first section is the &amp;lsquo;private&amp;rsquo; variables/functions that will be modified/set later (shown above). The second section is the variables/functions that will be available in your app.config function and are therefore available to alter before they&amp;rsquo;re available anywhere else (also shown above). It&amp;rsquo;s important to note that those variables need to be attached to the &amp;lsquo;this&amp;rsquo; keyword. In our example, only &amp;lsquo;thingFromConfig&amp;rsquo; will be available to alter in the app.config. The third section (shown below) is all the variables/functions that will be available in your controller when you pass in the &amp;lsquo;myProvider&amp;rsquo; service into that specific controller.</source>
          <target state="translated">プロバイダーは3つのセクションがあると考えることができます。 最初のセクションは、後で変更/設定される「プライベート」変数/関数です（上記を参照）。 2番目のセクションは、app.config関数で使用できる変数/関数です。そのため、他の場所で使用できるようになる前に変更することができます（上記にも示します）。 これらの変数は 'this'キーワードに付加する必要があることに注意することが重要です。 この例では、app.configで変更できるのは 'thingFromConfig'のみです。 3番目のセクション（下に表示）は、 'myProvider'サービスを特定のコントローラーに渡したときにコントローラーで使用できるすべての変数/関数です。</target>
        </trans-unit>
        <trans-unit id="8b95d0adc56d83fa7498365437f66e79ee788966" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to return a value. When Angular calls &lt;code&gt;new yourServiceName(&lt;/code&gt;), it&amp;rsquo;ll receive the &lt;code&gt;this&lt;/code&gt; object with all the properties you put on it.</source>
          <target state="translated">値を返す必要はありません。 Angularが &lt;code&gt;new yourServiceName(&lt;/code&gt; ）を呼び出すと、配置したすべてのプロパティを含む &lt;code&gt;this&lt;/code&gt; オブジェクトを受け取ります。</target>
        </trans-unit>
        <trans-unit id="3fe544a5098b0be6e451614ad5ff4af0887aea93" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will cache and inject the return value when the factory is requested.</source>
          <target state="translated">AngularJSに関数を与えると、AngularJSがキャッシュして、ファクトリーが要求されたときに戻り値を注入してくれます。</target>
        </trans-unit>
        <trans-unit id="7733853022202a91bba391de813e5ef65f7cfeb5" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will call &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; to instantiate it. It is the instance that AngularJS creates that will be cached and injected when the service is requested. Since &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; was used to instantiate the service, the keyword &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; is valid and refers to the instance.</source>
          <target state="translated">AngularJSに関数を与えると、AngularJSは&lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt;を呼び出してインスタンス化します。 AngularJSが作成するインスタンスは、サービスが要求されたときにキャッシュされ、挿入されます。 &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt;はサービスのインスタンス化に使用されたため、キーワード&lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt;は有効であり、インスタンスを参照します。</target>
        </trans-unit>
        <trans-unit id="a2a1ff92c50375a3fdf5b1809ff8ea225aab5a9c" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, and AngularJS will call its &lt;code&gt;$get&lt;/code&gt; function. It is the return value from the &lt;code&gt;$get&lt;/code&gt; function that will be cached and injected when the service is requested.</source>
          <target state="translated">AngularJSに関数を与えると、AngularJSはその &lt;code&gt;$get&lt;/code&gt; 関数を呼び出します。 これは、サービスが要求されたときにキャッシュされて注入される &lt;code&gt;$get&lt;/code&gt; 関数からの戻り値です。</target>
        </trans-unit>
        <trans-unit id="3876a0940a5a7dd665609735ebfa32e7f6e1bcc3" translate="yes" xml:space="preserve">
          <source>You just have a standard function that uses this keyword to define a function.</source>
          <target state="translated">このキーワードを使って関数を定義する標準関数を持っているだけです。</target>
        </trans-unit>
        <trans-unit id="866717a4969cced464a5c0ae6684faada33bde94" translate="yes" xml:space="preserve">
          <source>You might be tempted to call &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; in a promise chain, for instance if you initialized the score by grabbing it from the server: &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; The trouble with this is that &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; will be called with &lt;code&gt;this&lt;/code&gt; bound to &lt;code&gt;null&lt;/code&gt; and you&amp;rsquo;ll get errors. The better way would be &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt;.
Whether you choose to use this in your service methods or not, be careful how you call them.</source>
          <target state="translated">たとえば、サーバーから &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; てスコアを初期化した場合、 $ http.get（ '/ score'）。then（ScoreKeeper.setScore）のように、Promiseチェーンで &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; を呼び出したくなるかもしれません。 この問題は、 &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; にバインドされて呼び出され、エラーが発生することです。 より良い方法は &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt; です。 これをサービスメソッドで使用するかどうかに関係なく、それらを呼び出す方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="bea982bb9c2f6821b3f44edf8dad402dddc73177" translate="yes" xml:space="preserve">
          <source>You should use the Provider recipe only when you want to expose an API
  for application-wide configuration that must be made before the
  application starts. This is usually interesting only for reusable
  services whose behavior might need to vary slightly between
  applications.</source>
          <target state="translated">アプリケーションが起動する前に行わなければならないアプリケーション全体のコンフィギュレーションのためのAPIを公開したい場合にのみ、プロバイダレシピを使うべきです。これは通常、アプリケーション間で動作を少し変える必要があるかもしれない再利用可能なサービスのためだけに興味深いものです。</target>
        </trans-unit>
        <trans-unit id="c5956833324972c28737ee048ed90ebe091ca59b" translate="yes" xml:space="preserve">
          <source>_artist is the artist we wish to lookup</source>
          <target state="translated">artistは検索したいアーティストです。</target>
        </trans-unit>
        <trans-unit id="72921d9d0e40db1cd6390dcc0077ecda67c652ba" translate="yes" xml:space="preserve">
          <source>_finalUrl is the final and fully built URL to which we&amp;rsquo;ll make the call to iTunes</source>
          <target state="translated">_finalUrlは、iTunesを呼び出す最終的な完全に構築されたURLです。</target>
        </trans-unit>
        <trans-unit id="0bfda8d377c2609cd9d50c5b636b767072ce4e18" translate="yes" xml:space="preserve">
          <source>ability to use other services (have dependencies)</source>
          <target state="translated">他サービス利用能力</target>
        </trans-unit>
        <trans-unit id="6a925e5ed5ce5e858b8242994457f2ab7ac71782" translate="yes" xml:space="preserve">
          <source>all you get is &lt;code&gt;provider&lt;/code&gt; but there is no property/method other than &lt;code&gt;$get&lt;/code&gt;</source>
          <target state="translated">あなたが得るすべては &lt;code&gt;provider&lt;/code&gt; が、 &lt;code&gt;$get&lt;/code&gt; 以外のプロパティ/メソッドはありません</target>
        </trans-unit>
        <trans-unit id="0d27b037fa89342a90ff5d6df4947c9eece46029" translate="yes" xml:space="preserve">
          <source>and returns &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; を返します</target>
        </trans-unit>
        <trans-unit id="402433d1fb629334beefb9cb164a7a1c035c71e7" translate="yes" xml:space="preserve">
          <source>and using:</source>
          <target state="translated">と使用しています。</target>
        </trans-unit>
        <trans-unit id="427c1761ab15aa547603cd68334d242a2d5523d9" translate="yes" xml:space="preserve">
          <source>baseUrl is the base URL that the iTunes API requires</source>
          <target state="translated">baseUrl は、iTunes API が必要とするベース URL です。</target>
        </trans-unit>
        <trans-unit id="2cdaa8f3ceef76f1dc730a6b60c06476e795c676" translate="yes" xml:space="preserve">
          <source>basically what happens is</source>
          <target state="translated">基本的にどうなるかというと</target>
        </trans-unit>
        <trans-unit id="b50ae779a31c55dd00a1f71d908a312cbc40af0a" translate="yes" xml:space="preserve">
          <source>connects &lt;code&gt;context&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; を &lt;code&gt;this&lt;/code&gt; 接続します</target>
        </trans-unit>
        <trans-unit id="54bf3f1ce25250844230f2deb1ca4ace3b97b315" translate="yes" xml:space="preserve">
          <source>creates brand new object</source>
          <target state="translated">新しいオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="deb0c5efabe5381fec4da90741ac9ac67289b4ec" translate="yes" xml:space="preserve">
          <source>delayed/lazy initialization</source>
          <target state="translated">遅延遅延初期化</target>
        </trans-unit>
        <trans-unit id="0188b442c8481c48fffbded6f20f1d6cded3c775" translate="yes" xml:space="preserve">
          <source>how Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe?</source>
          <target state="translated">どのようにファクトリ、サービス、および定数&amp;mdash;プロバイダーのレシピに加えて、単なる構文上の砂糖ですか？</target>
        </trans-unit>
        <trans-unit id="8f55d557046d81d78de7516299b50060cdf7c55b" translate="yes" xml:space="preserve">
          <source>how factory ,servic and providers are simailar internally</source>
          <target state="translated">どのように工場、サービスおよび提供者が内部的に simailar であるか</target>
        </trans-unit>
        <trans-unit id="ce1ed02a506c79b6518185593802fbb4aaa54d8a" translate="yes" xml:space="preserve">
          <source>links it to its &lt;code&gt;prototype&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; オブジェクトにリンクします</target>
        </trans-unit>
        <trans-unit id="1e4306c581e1c078a3c92df9bd0a6162776ce8e8" translate="yes" xml:space="preserve">
          <source>makeUrl is a function that will create and return our iTunes friendly URL.</source>
          <target state="translated">makeUrl は、iTunes と親和性の高い URL を作成して返す関数です。</target>
        </trans-unit>
        <trans-unit id="ba23da34d1e3b19225a60f4a7206e21e32aad969" translate="yes" xml:space="preserve">
          <source>of that &lt;code&gt;provider&lt;/code&gt;(means you can't configure this)</source>
          <target state="translated">その &lt;code&gt;provider&lt;/code&gt; （これを構成できないことを意味します）</target>
        </trans-unit>
        <trans-unit id="6192271d0d781e240956f0b4f5271f3d5d92ac46" translate="yes" xml:space="preserve">
          <source>service initialization</source>
          <target state="translated">サービス初期化</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
