<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/15666048">
    <body>
      <group id="15666048">
        <trans-unit id="64a58ac5bcfe347c123a856c3f7ac41a16c18e93" translate="yes" xml:space="preserve">
          <source>&quot; Hello world &quot; example with &lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; / &lt;code&gt;service&lt;/code&gt; / &lt;code&gt;provider&lt;/code&gt; &quot;Hello World&quot;예제 :</target>
        </trans-unit>
        <trans-unit id="27ab96a759e2b4ef1d829c8525ca087d26314532" translate="yes" xml:space="preserve">
          <source>&quot;$injector is used to retrieve object instances as defined by &lt;strong&gt;provider&lt;/strong&gt;&quot; not service, not factory but provider.</source>
          <target state="translated">&quot;$ injector는 팩토리가 아닌 제공자가 아닌 서비스 &lt;strong&gt;제공자가&lt;/strong&gt; 정의한 오브젝트 인스턴스를 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47d91685928f3bdbd8a6e0bbabc322e70072c356" translate="yes" xml:space="preserve">
          <source>*Again if any portion of the above code is confusing, check out the Factory section where I explain what it all does it greater details.</source>
          <target state="translated">* 위 코드의 일부가 혼란 스러우면 팩토리 섹션에서 자세한 내용을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f4d91701275cfa2997fcf5752d0f40b1c281d19d" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;service&lt;/code&gt; for most cases of default</source>
          <target state="translated">1. 대부분의 채무 불이행에 대한 &lt;code&gt;service&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b474cc94e43caf4ce704bf9f973a68251b25cd13" translate="yes" xml:space="preserve">
          <source>1.Provider object is created using constructor function we defined in our provider function.</source>
          <target state="translated">1. 제공자 객체는 제공자 함수에서 정의한 생성자 함수를 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2cfdc84411546e36f7e4d88a4a92785dd9ead0" translate="yes" xml:space="preserve">
          <source>1.Services are singleton objects that are created when necessary and are never cleaned up until the end of the application life-cycle (when the browser is closed). Controllers are destroyed and cleaned up when they are no longer needed.</source>
          <target state="translated">1. 서비스는 필요할 때 만들어지고 응용 프로그램 수명주기가 끝날 때까지 (브라우저가 닫힐 때까지) 정리되지 않는 단일 개체입니다. 컨트롤러가 더 이상 필요하지 않으면 폐기 및 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="4edf8c51b9d95a7ca3a85d5aeca515c293064266" translate="yes" xml:space="preserve">
          <source>2. &lt;code&gt;factory&lt;/code&gt; used to create the service that specific instance</source>
          <target state="translated">2. 특정 인스턴스가 서비스를 생성하는 데 사용되는 &lt;code&gt;factory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01f9f1efa5be666f175edf0f3d066f99322711a" translate="yes" xml:space="preserve">
          <source>2.The easiest way to create a service is by using the factory() method.
The factory() method allows us to define a service by returning an object that contains service functions and service data. The service definition function is where we place our injectable services, such as $http and $q.
Ex:</source>
          <target state="translated">2. 서비스를 생성하는 가장 쉬운 방법은 factory () 메소드를 사용하는 것입니다. factory () 메소드를 사용하면 서비스 기능 및 서비스 데이터가 포함 된 객체를 반환하여 서비스를 정의 할 수 있습니다. 서비스 정의 기능은 $ http 및 $ q와 같이 주사 가능한 서비스를 배치하는 곳입니다. 전의:</target>
        </trans-unit>
        <trans-unit id="81049cf8d158fd8f6aa9e09fb3f7674dc7278ae0" translate="yes" xml:space="preserve">
          <source>2.The function we passed in app.config(), get executed. This is called config phase, and here we have a chance to customize our service.</source>
          <target state="translated">2.app.config ()에 전달한 함수가 실행됩니다. 이를 구성 단계라고하며 여기에서 서비스를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06f9e5bc87b677a928a701f0b17b557a83c7cd8" translate="yes" xml:space="preserve">
          <source>3.Finally service instance is created by calling $get method of serviceProvider.</source>
          <target state="translated">3. 마지막으로 serviceProvider의 $ get 메소드를 호출하여 서비스 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="10247f3761146ad3fd29f8f04438a385637cbd75" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt;  (&amp;lt;-- GOOD)
&lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/26924234/165673&quot;&gt;https://stackoverflow.com/a/26924234/165673&lt;/a&gt; (&amp;lt;-GOOD) &lt;a href=&quot;https://stackoverflow.com/a/27263882/165673&quot;&gt;https://stackoverflow.com/a/27263882/165673&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96509fbd15a55d9f8c6b0f16f86f369bd1959c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;'s stored value comes from running &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">저장된 값은 &lt;code&gt;fn&lt;/code&gt; 을 실행하여 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9806d20accdcf4a7d7bf03bac15b08c0e80af8cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;&amp;rsquo;s stored value comes from &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 저장된 값은 &lt;code&gt;new&lt;/code&gt; &lt;code&gt;fn&lt;/code&gt; 에서 나옵니다.</target>
        </trans-unit>
        <trans-unit id="c10d4a6de0cf092cde9d6b1c37da584005618d85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;&amp;rsquo;s stored value comes from first getting an instance by &lt;code&gt;new&lt;/code&gt;ing &lt;code&gt;fn&lt;/code&gt;, and then running a &lt;code&gt;$get&lt;/code&gt; method of the instance.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 의 저장된 값은 먼저 &lt;code&gt;fn&lt;/code&gt; 을 &lt;code&gt;new&lt;/code&gt; 하여 인스턴스를 가져온 다음 인스턴스의 &lt;code&gt;$get&lt;/code&gt; 메소드를 실행하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f37e6ab171ca302e86496ad45c7c8b082187c7b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Lazily Instantiated&lt;/em&gt;: If it is not injected it won't be instantiated ever. So to use it will have to inject it to a module.</source>
          <target state="translated">&lt;em&gt;지연 인스턴스화&lt;/em&gt; : 주입되지 않으면 인스턴스화되지 않습니다. 따라서 그것을 사용하려면 그것을 모듈에 주입해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbc415a0718bc792ec75efc2d5784a6b2ed76fb4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Singleton&lt;/em&gt;: If injected to multiple modules, all will have access to only one particular instance. That is why very convenient to share data across different controllers.</source>
          <target state="translated">&lt;em&gt;싱글 톤&lt;/em&gt; : 여러 모듈에 주입 된 경우 모두 하나의 특정 인스턴스에만 액세스 할 수 있습니다. 여러 컨트롤러간에 데이터를 공유하는 것이 매우 편리한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="de74c279e2d766663b22cc4a4bef8ec70061c8a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 공장&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1920da3aedb3ed95be87c557b3978bf5d2066e0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1)&lt;/strong&gt; When you&amp;rsquo;re using a &lt;strong&gt;Factory&lt;/strong&gt; you create an object, add properties to it, then return that same object. When you pass this factory into your controller, those properties on the object will now be available in that controller through your factory.</source>
          <target state="translated">&lt;strong&gt;1)&lt;/strong&gt; &lt;strong&gt;팩토리&lt;/strong&gt; 를 사용할 때 객체를 생성하고 속성을 추가 한 다음 동일한 객체를 반환합니다. 이 팩토리를 컨트롤러에 전달하면 이제 해당 컨트롤러에서 팩토리를 통해 객체의 해당 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf79a918a5f8400f69451d6c86a9de8622bc5f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) 서비스&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08fa71875fc3e6ae341d7d13637af55d62c8e9c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2)&lt;/strong&gt; When you&amp;rsquo;re using &lt;strong&gt;Service&lt;/strong&gt;, AngularJS instantiates it behind the scenes with the &amp;lsquo;new&amp;rsquo; keyword. Because of that, you&amp;rsquo;ll add properties to &amp;lsquo;this&amp;rsquo; and the service will return &amp;lsquo;this&amp;rsquo;. When you pass the service into your controller, those properties on &amp;lsquo;this&amp;rsquo; will now be available on that controller through your service.</source>
          <target state="translated">&lt;strong&gt;2)&lt;/strong&gt; &lt;strong&gt;Service를&lt;/strong&gt; 사용할 때 AngularJS는 'new'키워드를 사용하여 장면 뒤에서 인스턴스화합니다. 이 때문에 'this'에 속성을 추가하면 서비스는 'this'를 반환합니다. 서비스를 컨트롤러에 전달하면 이제 'this'에 대한 해당 속성을 서비스를 통해 해당 컨트롤러에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e4c731a8abb79b43eb7b7ad7722ae53bd1e526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) 공급자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7891b22be8f5ced507d3b35a1a21c59dd69ef84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3)&lt;/strong&gt;&lt;strong&gt;Providers&lt;/strong&gt; are the only service you can pass into your .config() function. Use a provider when you want to provide module-wide configuration for your service object before making it available.</source>
          <target state="translated">&lt;strong&gt;3)&lt;/strong&gt; &lt;strong&gt;공급자&lt;/strong&gt; 는 .config () 함수에 전달할 수있는 유일한 서비스입니다. 서비스 오브젝트를 사용하기 전에 모듈 전체 구성을 제공하려는 경우 제공자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7a0bc6a5e55d68fca9019cb4c62b65667302df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Is they do same or have same behaviour?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;그들은 같은 행동을합니까?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57a51970d21894731b55def79e30e17e9251193f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Should I use service or factory? What&amp;rsquo;s the difference?&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;서비스 또는 공장을 사용해야합니까?&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;차이점이 뭐야?&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61bce34778beb7a07d2ad51ff5e0491a8fe2ce06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;And for beginner understand:-&lt;/strong&gt; This may not correct use case but in high level this is what usecase for these three.</source>
          <target state="translated">&lt;strong&gt;초보자에게는 다음과 같이 이해하십시오 .-&lt;/strong&gt; 이것은 유스 케이스를 정정하지 않을 수도 있지만 높은 수준에서는 이것이 세 가지 유스 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="49456beeefd4b18f05312ca85704d73c7cc3b7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Factory:&lt;/strong&gt; the purpose of Factory is also same as Service however in this case we create a new object and add functions as properties of this object and at the end we return this object.</source>
          <target state="translated">&lt;strong&gt;AngularJS Factory : Factory&lt;/strong&gt; 의 목적은 Service와 동일하지만이 경우 새 객체를 만들고 함수를이 객체의 속성으로 추가하고 결국이 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42188f33ed58db2766909a9db9de01785a8ee47d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Provider:&lt;/strong&gt; the purpose of this is again same however Provider gives the output of it's $get function.</source>
          <target state="translated">&lt;strong&gt;AngularJS 제공자 : 이것&lt;/strong&gt; 의 목적은 다시 동일하지만 제공자는 $ get 함수의 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a762ecbec3e860f39ad0b1b9673d2ba4d24939f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AngularJS Service:&lt;/strong&gt; is used for sharing utility functions with the service reference in the controller. Service is singleton in nature so for one service only one instance is created in the browser and the same reference is used throughout the page.</source>
          <target state="translated">&lt;strong&gt;AngularJS 서비스 :&lt;/strong&gt; 컨트롤러의 서비스 참조와 유틸리티 기능을 공유하는 데 사용됩니다. 서비스는 본질적으로 싱글 톤이므로 하나의 서비스에 대해 하나의 인스턴스 만 브라우저에 작성되며 페이지 전체에서 동일한 참조가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba46456a9f8e88791102b2d89c6c02c5e47d2e18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful with &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;this&lt;/code&gt; 조심 하십시오&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="bf2cbd4114b4edf85514bcf9f1a8b65ee626a848" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best answers from SO:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그래서 최고의 답변 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867130b32fc3b28fc8ec819aa9caaebbdcd1a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Both are Singletons&lt;/strong&gt;: Whenever Angular find these as a dependency first time,it create a single instance of service/factory. Once the instance is created, same instance is used forever.</source>
          <target state="translated">&lt;strong&gt;둘 다 싱글 톤입니다&lt;/strong&gt; : Angular가 처음으로 이것을 종속성으로 찾을 때마다 단일 서비스 / 팩토리 인스턴스를 만듭니다. 인스턴스가 생성되면 동일한 인스턴스가 영원히 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bfbaa084726b82d3658a48125aa6f2be3899ae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be used to model an object with behavior&lt;/strong&gt;: They can both have methods, internal state variables, and so on. Though the way you write that code will differ.</source>
          <target state="translated">&lt;strong&gt;동작이있는 객체를 모델링하는 데 사용할 수 있습니다&lt;/strong&gt; . 메소드, 내부 상태 변수 등을 모두 가질 수 있습니다. 그 코드를 작성하는 방법은 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8047b6c925051a75984184c3eab229c2a494da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Constant&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b230b0c6b04da427893e313b7c0e9d5aef5ada3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FACTORY&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;FACTORY&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de8ae60c5e367749c74c70c938263e7f3a66bc7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factories:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="129b6a9da449d3568001d3e4449436c7a83896d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공장 기능 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa83955bc8ebbae5eb9b7e4bea195c0e27d81128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt;
  You simply create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;팩토리 : 팩토리&lt;/strong&gt; 내부에 객체를 만들어 반환하면됩니다.</target>
        </trans-unit>
        <trans-unit id="223321a46b7f883db5389221c0e026bc67b2f8e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory:&lt;/strong&gt; The factory you actually create an object inside of the factory and return it.</source>
          <target state="translated">&lt;strong&gt;팩토리 :&lt;/strong&gt; 팩토리 내부에 실제로 객체를 생성하여 반환 한 팩토리입니다.</target>
        </trans-unit>
        <trans-unit id="4b5add3c153ec4e23637c1d8bfc69736e94082eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factory&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74ccee4a3bcbc7b9bc42b630b85b5d7fe42f6f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; and &lt;strong&gt;Service&lt;/strong&gt; are the most commonly used recipes. The only difference between them is that the &lt;strong&gt;Service&lt;/strong&gt; recipe works better for objects of a custom type, while the &lt;strong&gt;Factory&lt;/strong&gt; can produce JavaScript primitives and functions.</source>
          <target state="translated">&lt;strong&gt;공장&lt;/strong&gt; 과 &lt;strong&gt;서비스&lt;/strong&gt; 는 가장 일반적으로 사용되는 레시피입니다. 이들 간의 유일한 차이점은 &lt;strong&gt;서비스&lt;/strong&gt; 레시피가 사용자 정의 유형의 객체에 더 효과적이며 &lt;strong&gt;팩토리&lt;/strong&gt; 는 JavaScript 기본 요소 및 함수를 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="af69167d5e31ec4171b3b71e86c23e55eb8b3ef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt; use a factory function which return a service instance.
&lt;strong&gt;serviceInstance = fnFactory();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;팩토리&lt;/strong&gt; 는 서비스 인스턴스를 반환하는 팩토리 함수를 사용합니다. &lt;strong&gt;serviceInstance = fnFactory ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d42eff7ec39af4e9117015764522229b8db7933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory&lt;/strong&gt;: The value you are providing needs to be calculated based on other data.</source>
          <target state="translated">&lt;strong&gt;공장&lt;/strong&gt; : 제공하는 값은 다른 데이터를 기반으로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="15a7f656197166d5af0768e868e3d0738e892b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTML:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTML:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="051543166b882d0c0302b61c6fccd2ef13890dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does provider syntax internally work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공급자 구문은 내부적으로 어떻게 작동합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f24bbfd879178823cf1a6f4fa4db8fd25d88804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How to create a service?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서비스를 만드는 방법?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15472d9a104bad65c0d954254428090db1217241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lazily instantiated&lt;/strong&gt; &amp;ndash; Angular only instantiates a service/factory when an application component depends on it.</source>
          <target state="translated">&lt;strong&gt;지연 인스턴스화&lt;/strong&gt; &amp;ndash; Angular는 응용 프로그램 구성 요소가 종속 된 경우에만 서비스 / 공장을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="4fc1597dfe992d87dcc418262208d7b520cc2ad4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="048671a3c07af864b3160d99c16b04e4022573ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비 TL; DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e5c27c9c6e707014afaaa93121ac5aee4552e03e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PROVIDER&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PROVIDER&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e9a7279f005fa392f0780ed27247cdff005c85f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공급자 기능 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2f1801fb48bf71dd7299a789ae89b7ca28c73fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9463ee84dc44104bf418d730d2dc12c20735e2ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Provider&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="034f13e153a713ef6e1f67d027f037acfcdca111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; defines a providerConstructor function, this providerConstructor function defines a factory function &lt;strong&gt;$get&lt;/strong&gt; . Angular calls $get() to create the service object. Provider syntax has an added advantage of configuring the service object before it get instantiated.
&lt;strong&gt;serviceInstance = $get();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공급자&lt;/strong&gt; 는 providerConstructor 함수를 정의하고이 providerConstructor 함수는 팩토리 함수 &lt;strong&gt;$ get을&lt;/strong&gt; 정의합니다. Angular는 $ get ()을 호출하여 서비스 객체를 만듭니다. 공급자 구문에는 서비스 개체를 인스턴스화하기 전에 구성 할 수있는 이점이 있습니다. &lt;strong&gt;serviceInstance = $ get ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58cb452a8449a0480646f34b32c4f0b2da41ff86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">&lt;strong&gt;공급자&lt;/strong&gt; 는 가장 복잡한 레시피 유형입니다. 전역 구성이 필요한 재사용 가능한 코드를 작성하지 않는 한 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af542f111be3a6b9b5eb1bba21844f854821a94c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt; recipe is used mostly in the app config, before the app has fully started/initialized.</source>
          <target state="translated">&lt;strong&gt;공급자&lt;/strong&gt; 레시피는 앱이 완전히 시작 / 초기화되기 전에 대부분 앱 구성에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a61e7a67bd37a0cf34633a672f8ef4ac61746cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Provider&lt;/strong&gt;: You want to be able to configure, during the config phase, the object that is going to be created before it&amp;rsquo;s created. Use the Provider mostly in the app config, before the app has fully initialized.</source>
          <target state="translated">&lt;strong&gt;공급자&lt;/strong&gt; : 구성 단계에서 생성 될 개체를 생성하기 전에 구성 할 수 있습니다. 앱이 완전히 초기화되기 전에 대부분 앱 구성에서 제공자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab8bcf5f1f62f6d12fe01bbd3797bf5f9edaf2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a Value from a &lt;code&gt;Service&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Service&lt;/code&gt; 에서 값 반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8b225479a57e32c9b9bbce57b80db8803839e1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SERVICE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;SERVICE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="1723b4864b43191225849524b7490ba00136326d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service vs provider vs factory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서비스 대 공급자 대 공장 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddf188521bbad55d877526ca526e747468a9d8b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c48ba497f0f940a447148665d013066e3821706" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Service&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3625561b5600fccb382876ffa98f2e89623ad206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; is all about &lt;code&gt;new&lt;/code&gt; keyword actually which as we know does 4 things:</source>
          <target state="translated">&lt;strong&gt;서비스&lt;/strong&gt; 는 실제로 &lt;code&gt;new&lt;/code&gt; 키워드에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="643dc71e1844f583afedf84a3c290ed53ca1a986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt; use a constructor function and Angular invoke this constructor function using 'new' keyword for creating the service instance.
&lt;strong&gt;serviceInstance = new fnServiceConstructor();&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서비스&lt;/strong&gt; 는 생성자 함수를 사용하며 Angular는 서비스 인스턴스 작성을 위해 'new'키워드를 사용하여이 생성자 함수를 호출합니다. &lt;strong&gt;serviceInstance = 새 fnServiceConstructor ();&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="934fb2b4d6b5561f358e2ea098b02b599fac1ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Service&lt;/strong&gt;: You are returning an object with methods.</source>
          <target state="translated">&lt;strong&gt;서비스&lt;/strong&gt; : 메소드가있는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="917d24961ee3bd9397cee700d2697066bdc8ebc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Services:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Services:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b86f1f47c5d0e8ae25c0b4bfeddc837fbe553961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Singletons&lt;/strong&gt; &amp;ndash; Each component
  dependent on a service gets a reference to the single instance
  generated by the service factory.</source>
          <target state="translated">&lt;strong&gt;싱글 톤&lt;/strong&gt; &amp;ndash; 서비스에 종속 된 각 구성 요소는 서비스 팩토리에서 생성 된 단일 인스턴스에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="236552a9e0c737f0dce61f3fd278300c81df52c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of factory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공장의 소스 코드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dca20d5f0cc36fd7219eb42b9a3bd59a5f14fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source code of service&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서비스 소스 코드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb070431451825a43dbcb68523c4e1049f4a93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3ab06d46eba0ea55e3a63532b502c8e68aaf041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntactic Sugar is the difference&lt;/strong&gt;. Only provider is needed. Or in other words only provider is the real angular, all other ones are derived(to reduce code). There is a simple version as well, called Value()  which returns just the value, no calculation or function. Even Value is derived from provider!</source>
          <target state="translated">&lt;strong&gt;구문 설탕은 차이&lt;/strong&gt; 입니다. 공급자 만 필요합니다. 즉, 공급자만이 실제 각도이며 다른 모든 공급자가 파생됩니다 (코드를 줄이기 위해). Value ()라는 간단한 버전도 있습니다.이 버전은 계산이나 함수없이 값만 반환합니다. 균등 한 가치는 공급자로부터 도출됩니다!</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5f0f8f2415dfbd7ea64cb1c92c78ef8982eb6db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The major differences among Services, Factories, and Providers are their complexities. Services are the simplest form, Factories are a little more robust, and Providers are configurable at runtime.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서비스, ​​공장 및 공급자 간의 주요 차이점은 복잡성입니다.&lt;/strong&gt; &lt;strong&gt;서비스는 가장 간단한 형태이며 공장은 좀 더 강력하며 공급자는 런타임에 구성 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5265dba3d641afcb7e0148f9229e5a29c5cbf0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding AngularJS Factory, Service and Provider&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;AngularJS 팩토리, 서비스 및 제공자 이해&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="372f60334aa5d8918e891d52c780ab816ff7ba23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="761726747ff7c1d3bd1aef8307caf8babe873bd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4167298ff7e32e5b1773e3433a0f0e71939b8a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Service:&lt;/strong&gt;
In AngularJS, &lt;strong&gt;Service&lt;/strong&gt; is nothing but a singleton JavaScript object which can store some useful methods or properties. This singleton object is created per ngApp(Angular app) basis and it is shared among all the controllers within current app. When Angularjs instantiate a service object, it register this service object with a unique service name. So each time when we need service instance, Angular search the registry for this service name, and it returns the reference to service object. Such that we can invoke method, access properties etc on the service object.
You may have question whether you can also put properties, methods on scope object of controllers! So why you need service object? Answers is: services are shared among multiple controller scope. If you put some properties/methods in a controller's scope object , it will be available to current scope only. But when you define methods, properties on service object, it will be available globally and can be accessed in any  controller's scope by injecting that service.</source>
          <target state="translated">&lt;strong&gt;서비스 란?&lt;/strong&gt; AngularJS에서 &lt;strong&gt;서비스&lt;/strong&gt; 는 유용한 메소드 나 속성을 저장할 수있는 싱글 톤 JavaScript 객체 일뿐입니다. 이 싱글 톤 객체는 ngApp (Angular app) 단위로 생성되며 현재 앱 내의 모든 컨트롤러간에 공유됩니다. Angularjs는 서비스 객체를 인스턴스화 할 때이 서비스 객체를 고유 한 서비스 이름으로 등록합니다. 따라서 서비스 인스턴스가 필요할 때마다 Angular는이 서비스 이름의 레지스트리를 검색하고 서비스 객체에 대한 참조를 반환합니다. 서비스 객체에서 메소드를 호출하고 속성에 액세스 할 수 있도록합니다. 컨트롤러의 스코프 객체에 속성, 메소드를 넣을 수 있는지에 대한 의문이 생길 수 있습니다! 왜 서비스 객체가 필요합니까? 답은 여러 컨트롤러 범위에서 서비스를 공유한다는 것입니다. 컨트롤러의 범위 객체에 일부 속성 / 메소드를 넣으면 현재 범위에서만 사용할 수 있습니다. 그러나 서비스 객체에서 메소드, 프로퍼티를 정의 할 때, 메소드는 전역 적으로 사용 가능하며 해당 서비스를 주입하여 모든 컨트롤러 범위에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c92774ebded9b58a09fe3b3e5ebcdde0dc9b25c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e41544278c3c3cd14f313568ad2ca9b33654a735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app.js&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;app.js&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7c38fc9331c68d06c6051d868ab8034c6a1b71f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5fb6e5fc13a01937ae02611fcad859574413d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index.html&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;index.html&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd88803cf5db529cfe7cb230c25afc9af0e166" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;provider:&lt;/strong&gt; The provider there&amp;rsquo;s a $get you define and it can be used to get the object that returns the data.</source>
          <target state="translated">&lt;strong&gt;provider :&lt;/strong&gt; 정의한 $ get가있는 제공자이며 데이터를 리턴하는 오브젝트를 가져 오는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8592d58f6159c5178f21fdbf4b05247f87defaab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;service:&lt;/strong&gt; The service you just have a standard function that uses the this keyword to define function.</source>
          <target state="translated">&lt;strong&gt;service :&lt;/strong&gt; this 키워드를 사용하여 함수를 정의하는 표준 함수가있는 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="6460b1c41e40026d826a70fb0ec47b36aaed8244" translate="yes" xml:space="preserve">
          <source>A factory is a plain old function that returns a value. The return value is what gets injected into things that depend on the factory. A typical factory pattern in Angular is to return an object with functions as properties, like this:</source>
          <target state="translated">팩토리는 값을 반환하는 평범한 오래된 함수입니다. 반환 값은 팩토리에 의존하는 것에 주입되는 것입니다. Angular의 일반적인 팩토리 패턴은 다음과 같이 함수로 속성을 가진 객체를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6654378b8441365d9dbee921cd9c4b6d04ad1238" translate="yes" xml:space="preserve">
          <source>A factory is function where you can manipulate/add logic before creating an object, then the newly created object gets returned.</source>
          <target state="translated">팩토리는 객체를 생성하기 전에 로직을 조작 / 추가 할 수있는 기능으로 새로 생성 된 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="92657294903a95f8b7ea12e4be26ab19bd209d60" translate="yes" xml:space="preserve">
          <source>A more general value, that is possible to be computed right away. It works by passing a function to AngularJS with the logic needed to compute the value and AngularJS executes it, and it saves the return value in the named variable.</source>
          <target state="translated">보다 일반적인 가치는 바로 계산할 수 있습니다. 값을 계산하는 데 필요한 논리를 사용하여 AngularJS에 함수를 전달하여 작동하며 AngularJS가이를 실행하고 이름 지정된 변수에 반환 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="c98519712b1bcd2194f1ab8049f9c95b677e57e2" translate="yes" xml:space="preserve">
          <source>A provider
= must contain a property called $get (+Factory, + Service, + Value)</source>
          <target state="translated">공급자 = $ get (+ Factory, + Service, + Value)라는 속성을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="70cc8179c33c6143e3fd269921c56cce6794df6a" translate="yes" xml:space="preserve">
          <source>A provider is used to create a configurable service object. You can configure the service setting from config function. It returns a value by using the &lt;code&gt;$get()&lt;/code&gt; function. The &lt;code&gt;$get&lt;/code&gt; function gets executed on the run phase in angular.</source>
          <target state="translated">공급자는 구성 가능한 서비스 개체를 만드는 데 사용됩니다. 구성 기능에서 서비스 설정을 구성 할 수 있습니다. &lt;code&gt;$get()&lt;/code&gt; 함수를 사용하여 값을 리턴합니다. &lt;code&gt;$get&lt;/code&gt; 함수는 실행 단계에서 각도로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2690ab0e17349d256212ca0a5c254ff9f7224715" translate="yes" xml:space="preserve">
          <source>A provider that can
instantiate + do something = Service (+ Factory, + Value)</source>
          <target state="translated">인스턴스화 + 무언가를 할 수있는 제공자 = 서비스 (+ Factory, + Value)</target>
        </trans-unit>
        <trans-unit id="1552cdef3a8c9efd2ca6378e425896d47cd0a7d2" translate="yes" xml:space="preserve">
          <source>A provider that can just
instantiate and return = Factory (+ Value)</source>
          <target state="translated">인스턴스화하고 반환 할 수있는 공급자 = Factory (+ Value)</target>
        </trans-unit>
        <trans-unit id="5bac4ef74fca1e1f11c40a61c18eb5751a56a24e" translate="yes" xml:space="preserve">
          <source>A provider that can return value = Value</source>
          <target state="translated">value = Value를 반환 할 수있는 공급자</target>
        </trans-unit>
        <trans-unit id="daa9ad8c9da39c96b0cd1b5e9b85ad76ef92e025" translate="yes" xml:space="preserve">
          <source>A service is a constructor function, and Angular will instantiate it by calling new &lt;code&gt;yourServiceName()&lt;/code&gt;. This means a couple of things.</source>
          <target state="translated">서비스는 생성자 함수이며 Angular는 new &lt;code&gt;yourServiceName()&lt;/code&gt; 을 호출하여 인스턴스화합니다. 이것은 몇 가지를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f30916da78a012d617c7c608b91dd4f9e4ccb7cc" translate="yes" xml:space="preserve">
          <source>A service is a more stripped-down version of &lt;em&gt;factory&lt;/em&gt; which is valid only when the value is an object, and it allows for writing any logic directly in the function (as if it would be a constructor), as well as declaring and accessing the object properties using the &lt;em&gt;this&lt;/em&gt; keyword.</source>
          <target state="translated">서비스는 값이 객체 일 때만 유효한 더 박탈 된 &lt;em&gt;팩토리&lt;/em&gt; 버전으로, 함수에 직접 로직을 작성 (생성자 인 것처럼)하고 선언 및 액세스 할 수 있습니다. &lt;em&gt;this&lt;/em&gt; 키워드를 사용하는 객체 속성.</target>
        </trans-unit>
        <trans-unit id="e010047a835b4f08a52ebcf31da9133c3b0c83eb" translate="yes" xml:space="preserve">
          <source>Ability to use other services (have dependencies)</source>
          <target state="translated">다른 서비스를 사용할 수있는 기능 (종속성이 있음)</target>
        </trans-unit>
        <trans-unit id="90d836d3d0cb6acecac1372abfaeed5f7a898db3" translate="yes" xml:space="preserve">
          <source>After reading all these post It created more confuse for me.. But still all is worthfull information.. finally I found following table which will give information with simple comparision</source>
          <target state="translated">이 모든 게시물을 읽은 후에는 더 혼란 스러웠습니다. 그러나 여전히 모든 것이 가치있는 정보입니다 .. 마지막으로 간단한 비교로 정보를 제공하는 다음 표를 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="eba926c51e345f5492b036b8fb2838c80ca0f326" translate="yes" xml:space="preserve">
          <source>Ajax call or third party integrations needs to be &lt;strong&gt;service&lt;/strong&gt;.</source>
          <target state="translated">Ajax 통화 또는 타사 통합 &lt;strong&gt;서비스가&lt;/strong&gt; 필요합니다.</target>
        </trans-unit>
        <trans-unit id="db39b22c1144a74c69ee802842ea57e37d383130" translate="yes" xml:space="preserve">
          <source>All Services are &lt;strong&gt;singletons&lt;/strong&gt;; they get instantiated once per app. They can be &lt;strong&gt;of any type&lt;/strong&gt;, whether it be a primitive, object literal, function, or even an instance of a custom type.</source>
          <target state="translated">모든 서비스는 &lt;strong&gt;싱글 톤입니다&lt;/strong&gt; . 앱마다 한 번씩 인스턴스화됩니다. 프리미티브, 객체 리터럴, 함수 또는 사용자 정의 유형의 인스턴스이든 관계없이 &lt;strong&gt;모든 유형&lt;/strong&gt; 이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b4a8e5249ee92bb57692eb4f38230e89ca0b32" translate="yes" xml:space="preserve">
          <source>All of these are used to share reusable singleton objects. It helps to share reusable code across your app/various components/modules.</source>
          <target state="translated">이들 모두는 재사용 가능한 싱글 톤 객체를 공유하는 데 사용됩니다. 앱 / 다양한 구성 요소 / 모듈에서 재사용 가능한 코드를 공유하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="15074bf6692ab4d76bbae6a637a1292c7beea479" translate="yes" xml:space="preserve">
          <source>All special purpose objects except for the Controller are defined via Factory recipes.</source>
          <target state="translated">컨트롤러를 제외한 모든 특수 목적 객체는 공장 레시피를 통해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1797d93eba62a3e50c0f75705fc2654c1c5d7cc1" translate="yes" xml:space="preserve">
          <source>All the good answers already. I would like to add few more points on &lt;strong&gt;Service&lt;/strong&gt; and &lt;strong&gt;Factory&lt;/strong&gt;. Along with the difference between service/factory. And  one can also have questions like:</source>
          <target state="translated">모든 좋은 답변은 이미 있습니다. &lt;strong&gt;Service&lt;/strong&gt; 및 &lt;strong&gt;Factory&lt;/strong&gt; 에 몇 가지 포인트를 더 추가하고 싶습니다. 서비스 / 공장의 차이점과 함께. 또한 다음과 같은 질문이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="644fa5425851502f8b0f2b6d2e894a7a71bc764b" translate="yes" xml:space="preserve">
          <source>An additional clarification is that factories can create functions/primitives, while services cannot. Check out this &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle&lt;/a&gt; based on Epokk's: &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt;.</source>
          <target state="translated">추가 설명은 팩토리는 기능 / 프리미티브를 작성할 수 있지만 서비스는 작성할 수 없다는 것입니다. Epokk를 기반으로 한이 &lt;a href=&quot;http://jsfiddle.net/&quot;&gt;jsFiddle을&lt;/a&gt; 확인하십시오 : &lt;a href=&quot;http://jsfiddle.net/skeller88/PxdSP/1351/&quot;&gt;http://jsfiddle.net/skeller88/PxdSP/1351/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1698cdf07eaa30b1f4d2eb589b401f5aa7c167b5" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Factory&lt;/strong&gt; is all about Factory Pattern - contains functions that return Objects like that Service.</source>
          <target state="translated">그리고 &lt;strong&gt;팩토리&lt;/strong&gt; 는 팩토리 패턴에 관한 것입니다-그 서비스와 같은 객체를 반환하는 함수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="087105228646ef19c5b815759ef3bd7c8d79035e" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;Value, Factory, Service and Constant&lt;/strong&gt; (4 ways) - the syntactic sugar over &lt;strong&gt;Provider&lt;/strong&gt; way/recepie.</source>
          <target state="translated">그리고 &lt;strong&gt;Value, Factory, Service 및 Constant&lt;/strong&gt; (4 가지 방법) &amp;ndash; &lt;strong&gt;공급자&lt;/strong&gt; 방식 / 수령에 대한 구문 설탕.</target>
        </trans-unit>
        <trans-unit id="a4a0d683875e15a20d100e9c4f3cabe527897b12" translate="yes" xml:space="preserve">
          <source>And a better answer would be this:
&quot;An Angular service is created by a service factory. These service factories are functions which, in turn, are created by a service provider. The service providers are constructor functions. When instantiated they must contain a property called $get, which holds the service factory function.&quot;</source>
          <target state="translated">&quot;각도 서비스는 서비스 팩토리에 의해 작성됩니다. 이러한 서비스 팩토리는 서비스 제공자가 작성하는 함수입니다. 서비스 제공자는 생성자 함수입니다. 인스턴스화 될 때 특성을 포함해야합니다. 서비스 팩토리 기능을 보유한 $ get이라고합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="6e1a1be7a3c89b4a49965d6931152adc8b79b49f" translate="yes" xml:space="preserve">
          <source>And this simple/short video: covers also &lt;strong&gt;Provider&lt;/strong&gt;: &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (there you see can see how they go from factory to provider)</source>
          <target state="translated">그리고이 간단한 / 짧은 비디오 : &lt;strong&gt;공급자&lt;/strong&gt; 도 &lt;strong&gt;다루십시오&lt;/strong&gt; : &lt;a href=&quot;https://www.youtube.com/watch?v=HvTZbQ_hUZY&quot;&gt;https://www.youtube.com/watch?v=HvTZbQ_hUZY&lt;/a&gt; (공장에서 공급자로 이동하는 방법을 볼 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="5e753d8417cbbaa903d75c9067f03b753d972dae" translate="yes" xml:space="preserve">
          <source>Angular injection gives us the first hint in reaching this conclusion.</source>
          <target state="translated">각도 주입은이 결론에 도달하는 첫 번째 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c0fbc9b675108602e2b9fac4e8674fd1d9ad2553" translate="yes" xml:space="preserve">
          <source>AngularJS provide different methods to register a service. Here we will concentrate on three methods factory(..),service(..),provider(..);</source>
          <target state="translated">AngularJS는 서비스를 등록하는 다른 방법을 제공합니다. 여기서 우리는 세 가지 방법 factory (..), service (..), provider (..)에 집중할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2a043dede3ac539ee64b89b2d49b7bd51e23891" translate="yes" xml:space="preserve">
          <source>AngularJS provides &lt;strong&gt;'factory('serviceName', fnFactory)'&lt;/strong&gt; method which takes two parameter, serviceName and a JavaScript function. Angular creates service instance by invoking the function &lt;strong&gt;fnFactory()&lt;/strong&gt; such as below.</source>
          <target state="translated">AngularJS는 serviceName과 JavaScript 함수라는 두 개의 매개 변수를 사용하는 &lt;strong&gt;'factory ('serviceName ', fnFactory)'&lt;/strong&gt; 메서드를 제공합니다. Angular는 아래와 같이 &lt;strong&gt;fnFactory ()&lt;/strong&gt; 함수를 호출하여 서비스 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="67487acbc494fde4c0ecdb230e55c47bdc819cc5" translate="yes" xml:space="preserve">
          <source>AngularJS: Service vs provider vs factory</source>
          <target state="translated">AngularJS : 서비스 대 공급자 대 팩토리</target>
        </trans-unit>
        <trans-unit id="62b46f141dc945f1baeeda1b182a386db6799d55" translate="yes" xml:space="preserve">
          <source>Answers for above 1 and 2 questions:</source>
          <target state="translated">위의 1 및 2 질문에 대한 답변 :</target>
        </trans-unit>
        <trans-unit id="f5181cbde0884af842b881fdae06a3ba0616e0a1" translate="yes" xml:space="preserve">
          <source>As a side note, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; are all derived from provider.</source>
          <target state="translated">부수적으로, &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;factory&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 는 모두 제공자에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="b8e0a3698c74b06188537beb6504f05ed6da8541" translate="yes" xml:space="preserve">
          <source>As mentioned before, the whole point of creating a service with Provider is to be able to alter some variables through the app.config function before the final object is passed to the rest of the application. Let&amp;rsquo;s see an example of that.</source>
          <target state="translated">앞에서 언급했듯이 Provider를 사용하여 서비스를 만드는 요점은 최종 객체가 나머지 응용 프로그램으로 전달되기 전에 app.config 함수를 통해 일부 변수를 변경할 수 있다는 것입니다. 그 예를 보자.</target>
        </trans-unit>
        <trans-unit id="ac8bd4adf742322d3119e359d466fd027d4a144c" translate="yes" xml:space="preserve">
          <source>As pointed out by several people here correctly a factory, provider, service, and even value and constant are versions of the same thing. You can dissect the more general &lt;code&gt;provider&lt;/code&gt; into all of them. Like so:</source>
          <target state="translated">여기서 여러 사람들이 지적했듯이 정확하게 공장, 공급자, 서비스 및 심지어 가치와 상수는 동일한 버전입니다. 보다 일반적인 &lt;code&gt;provider&lt;/code&gt; 를 모두에게 해부 할 수 있습니다. 이렇게 :</target>
        </trans-unit>
        <trans-unit id="7ac115d7759453df5c7a6ee0d961bac591936f70" translate="yes" xml:space="preserve">
          <source>Basically all of the mentioned types (service, factory, provider, etc.) are just creating and configuring global variables (that are of course global to the entire application), just as old fashioned global variables were.</source>
          <target state="translated">기본적으로 언급 된 모든 유형 (서비스, 팩토리, 공급자 등)은 구식 전역 변수와 마찬가지로 전역 변수 (물론 전체 응용 프로그램에 전역)를 만들고 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="76a6d228807b2f0db9ca8817dcc7b6fe1992e7f5" translate="yes" xml:space="preserve">
          <source>Below &lt;strong&gt;setArtist&lt;/strong&gt; accepts an artist and allows you to set the artist. &lt;strong&gt;getArtist&lt;/strong&gt; returns the artist. &lt;strong&gt;callItunes&lt;/strong&gt; first calls makeUrl() in order to build the URL we&amp;rsquo;ll use with our $http request. Then it sets up a promise object, makes an $http request with our final url, then because $http returns a promise, we are able to call .success or .error after our request. We then resolve our promise with the iTunes data, or we reject it with a message saying &amp;lsquo;There was an error&amp;rsquo;.</source>
          <target state="translated">아래 &lt;strong&gt;setArtist&lt;/strong&gt; 는 아티스트를 허용하며 아티스트를 설정할 수 있습니다. &lt;strong&gt;getArtist&lt;/strong&gt; 는 아티스트를 반환합니다. &lt;strong&gt;callItunes&lt;/strong&gt; 는 $ http 요청에 사용할 URL을 만들기 위해 makeUrl ()을 먼저 호출합니다. 그런 다음 promise 객체를 설정하고 최종 URL로 $ http 요청을 한 다음 $ http는 promise를 반환하므로 요청 후 .success 또는 .error를 호출 할 수 있습니다. 그런 다음 iTunes 데이터로 약속을 해결하거나 '오류가 발생했습니다'라는 메시지와 함께 거부합니다.</target>
        </trans-unit>
        <trans-unit id="ecc9654f84abda3f226923e7181cd6dedcabf706" translate="yes" xml:space="preserve">
          <source>Below is code for how you can think about what the &amp;lsquo;new&amp;rsquo; keyword is actually doing in JavaScript. It&amp;rsquo;s basically a code example of the above paragraph. I&amp;rsquo;ve put the &amp;lsquo;interpreter view&amp;rsquo; or the way the interpreter sees the code inside of notes.</source>
          <target state="translated">아래는 JavaScript에서 'new'키워드가 실제로하는 일에 대해 어떻게 생각할 수 있는지에 대한 코드입니다. 기본적으로 위 단락의 코드 예입니다. 나는 '인터프리터 뷰'또는 인터프리터가 코드 내부의 코드를 보는 방식을 넣었습니다.</target>
        </trans-unit>
        <trans-unit id="baeffb61d23b4b1a1faec7ea79fc7982401fe040" translate="yes" xml:space="preserve">
          <source>But if you declare an AngularJS &quot;value&quot; (for example., &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt;), you can inject it into services and factories, but NOT into the provider-creating function. You can, however, inject it into the &lt;code&gt;$get&lt;/code&gt; function that you define for your provider. This is mentioned in the AngularJS documentation, but it's easy to miss. You can find it on the %provide page in the sections on the value and constant methods.</source>
          <target state="translated">그러나 AngularJS &quot;value&quot;(예 : &lt;code&gt;myApp.value('b', {name: 'Jones'});&lt;/code&gt; )를 선언하면 서비스 및 팩토리에 삽입 할 수 있지만 제공자 작성 함수에는 삽입 할 수 없습니다. . 그러나 제공자에 대해 정의한 &lt;code&gt;$get&lt;/code&gt; 함수에 삽입 할 수 있습니다. 이것은 AngularJS 문서에 언급되어 있지만 놓치기 쉽습니다. % provide 페이지의 value 및 constant 메소드 섹션에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1cc6d183fce2197bb4d499453f325c6ce15d621" translate="yes" xml:space="preserve">
          <source>But that is way too wordy. A shorter way to write this would be &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</source>
          <target state="translated">그러나 그것은 너무 장황합니다. 이것을 작성하는 더 짧은 방법은 &lt;code&gt;provider.service('greeter', Greeter);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0b23422a6346dcd33f9ef7c177b5c4c2e0c0ba5" translate="yes" xml:space="preserve">
          <source>But what if we wanted to configure the &lt;code&gt;Greeter&lt;/code&gt; class before the injection? Then we could write</source>
          <target state="translated">그러나 주입 전에 &lt;code&gt;Greeter&lt;/code&gt; 클래스를 구성하려면 어떻게해야합니까? 그럼 우리는 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83edd94ef1f4218a2a09268ba1c79454b4d8ce41" translate="yes" xml:space="preserve">
          <source>But what if you want to be more OO and have a class called Greeter?</source>
          <target state="translated">그러나 더 많은 OO가되고 Greeter라는 클래스를 원한다면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="bead6ae023dd1ddfc66d0c3554dd68115419ed4a" translate="yes" xml:space="preserve">
          <source>Code posted here is copied straight from the above source, to benefit readers.</source>
          <target state="translated">여기에 게시 된 코드는 독자에게 도움이되도록 위의 소스에서 직접 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a3e026964278d33abfaf0d31b51f4e99ed0a5a" translate="yes" xml:space="preserve">
          <source>Defining and using Service, Factory and Provider are explained at &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&lt;/a&gt;</source>
          <target state="translated">Service, Factory 및 Provider 정의 및 사용은 &lt;a href=&quot;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider&quot;&gt;http://www.dotnetfunda.com/articles/show/3156/difference-between-angularjs-service-factory-and-provider에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d0d609d4405f2baa362951b7009d2417093fd7d" translate="yes" xml:space="preserve">
          <source>Delayed/lazy initialization</source>
          <target state="translated">지연 / 지연 초기화</target>
        </trans-unit>
        <trans-unit id="cb560adb9a207096df4103f0ce35af068e58441a" translate="yes" xml:space="preserve">
          <source>Due to how JavaScript constructors work, if you return a complex value &lt;code&gt;(i.e., an Object)&lt;/code&gt; from a &lt;code&gt;constructor&lt;/code&gt; function, the caller will get that Object instead of the this instance.</source>
          <target state="translated">JavaScript 생성자가 작동하는 방식으로 인해 &lt;code&gt;constructor&lt;/code&gt; 함수에서 복잡한 값 &lt;code&gt;(i.e., an Object)&lt;/code&gt; 을 반환하면 호출자가이 인스턴스 대신 해당 Object를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0ce56bb9d7649bd1affa9d15ef3b25e94ed4bf16" translate="yes" xml:space="preserve">
          <source>Essentially, Provider, Factory, and Service are all Services. A Factory is a special case of a Service when all you need is a $get() function, allowing you to write it with less code.</source>
          <target state="translated">기본적으로 공급자, 공장 및 서비스는 모두 서비스입니다. 팩토리는 $ get () 함수 만 있으면 더 적은 코드로 작성할 수있는 서비스의 특별한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="5871c248f6153cd0a547c43f6815327faa66746e" translate="yes" xml:space="preserve">
          <source>Factories are the most popular way to create and configure a service. There&amp;rsquo;s really not much more than what the TL;DR said. You just create an object, add properties to it, then return that same object. Then when you pass the factory into your controller, those properties on the object will now be available in that controller through your factory. A more extensive example is below.</source>
          <target state="translated">팩토리는 서비스를 생성하고 구성하는 가장 보편적 인 방법입니다. TL; DR이 말한 것 이상은 실제로 없습니다. 객체를 생성하고 속성을 추가 한 다음 동일한 객체를 반환하면됩니다. 그런 다음 팩토리를 컨트롤러로 전달하면 이제 해당 컨트롤러의 팩토리를 통해 객체의 해당 속성을 사용할 수 있습니다. 보다 광범위한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="c8e6696140d2e75575a027e3db926b81e7fa86b8" translate="yes" xml:space="preserve">
          <source>Factory and Service are the most commonly used recipes. The only difference between them is that the Service recipe works better for objects of a custom type, while the Factory can produce JavaScript primitives and functions.</source>
          <target state="translated">공장과 서비스는 가장 일반적으로 사용되는 레시피입니다. 이들 간의 유일한 차이점은 서비스 레시피가 사용자 정의 유형의 객체에 더 효과적이며 팩토리는 JavaScript 기본 요소 및 함수를 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ee844ac41ac4ad9686ec614f908d3bdcb5b3e81" translate="yes" xml:space="preserve">
          <source>Factory is a class. Use factories if you want to provide custom classes for your code (can't be done with services because they are already instantiated).</source>
          <target state="translated">공장은 수업입니다. 코드에 대한 사용자 정의 클래스를 제공하려면 팩토리를 사용하십시오 (이미 인스턴스화되어 있으므로 서비스로 수행 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="c43d055974d1f89c7db6d2a6f06d9706cf84359d" translate="yes" xml:space="preserve">
          <source>Features of Factory:</source>
          <target state="translated">공장 특징 :</target>
        </trans-unit>
        <trans-unit id="8f233e0733ea2bd7573612519e22b6483ee2aae2" translate="yes" xml:space="preserve">
          <source>Features of Provider:</source>
          <target state="translated">공급자의 특징 :</target>
        </trans-unit>
        <trans-unit id="8b33d5b1a4171b12f08419f5a3175c6118df72b0" translate="yes" xml:space="preserve">
          <source>Features of Service:</source>
          <target state="translated">서비스 특징 :</target>
        </trans-unit>
        <trans-unit id="555321235e9eb2d0c7b4fff9ef2c877ead66f84d" translate="yes" xml:space="preserve">
          <source>Finally the UI which works with any of the above services:</source>
          <target state="translated">마지막으로 위의 서비스 중 하나에서 작동하는 UI :</target>
        </trans-unit>
        <trans-unit id="aa41b2f6147d97e7462dbecaf90f19a90ed1b067" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s create our Constructor.</source>
          <target state="translated">먼저 생성자를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="dfb58a29f6c2cb946fda2080d277aff94876b78f" translate="yes" xml:space="preserve">
          <source>First let's have a look at the syntax:</source>
          <target state="translated">먼저 문법을 보자 :</target>
        </trans-unit>
        <trans-unit id="16ae293f476b801e0ec98c3b0c772f3098dc7e49" translate="yes" xml:space="preserve">
          <source>First of all, let's talk about &lt;strong&gt;services&lt;/strong&gt; in AngularJS!</source>
          <target state="translated">우선 AngularJS의 &lt;strong&gt;서비스&lt;/strong&gt; 에 대해 이야기합시다!</target>
        </trans-unit>
        <trans-unit id="f626e9e8c764b63df367572217b72dfec8d3d0d8" translate="yes" xml:space="preserve">
          <source>First of all: &lt;strong&gt;Provider&lt;/strong&gt; is the way/recipe to create a &lt;code&gt;service&lt;/code&gt; (singleton object) that suppose to be injected by $injector (how AngulaJS goes about IoC pattern).</source>
          <target state="translated">우선 : &lt;strong&gt;제공자&lt;/strong&gt; 는 $ injector (AngulaJS가 IoC 패턴을 처리하는 방법)에 의해 주입되는 &lt;code&gt;service&lt;/code&gt; (단일 오브젝트)를 작성하는 방법 / 레시피입니다.</target>
        </trans-unit>
        <trans-unit id="a7d7fe2894bd6c66d071f952d684e2326b49b1e5" translate="yes" xml:space="preserve">
          <source>First things first, let&amp;rsquo;s create our &amp;lsquo;private&amp;rsquo; and helper function. This should look very familiar since we did the exact same thing with our factory. I won&amp;rsquo;t explain what each line does here because I did that in the factory example, if you&amp;rsquo;re confused, re-read the factory example.</source>
          <target state="translated">먼저, '비공개'및 도우미 기능을 만들어 봅시다. 우리가 공장과 똑같은 일을했기 때문에 이것은 매우 친숙하게 보일 것입니다. 팩토리 예제에서 각 행이 무엇을하는지 설명하지 않겠습니다. 혼란 스러우면 팩토리 예제를 다시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="274879ea02d1b32f25fdcf0d6f4b8638ad84e454" translate="yes" xml:space="preserve">
          <source>First we set up our Provider in a similar way we did with our Service and Factory. The variables below are our &amp;lsquo;private&amp;rsquo; and helper function.</source>
          <target state="translated">먼저 우리는 서비스 및 공장과 비슷한 방식으로 공급자를 설정했습니다. 아래 변수는 '비공개'및 도우미 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0f18e05a1a2cf2fab2012ea1acb85960d14f94f3" translate="yes" xml:space="preserve">
          <source>Follows the factory design pattern. The factory is a central place that produces new objects or functions.</source>
          <target state="translated">공장 설계 패턴을 따릅니다. 공장은 새로운 물건이나 기능을 생산하는 중심 장소입니다.</target>
        </trans-unit>
        <trans-unit id="124166829dcd8ce12e68c97aa74ddc87e6f4700c" translate="yes" xml:space="preserve">
          <source>For Data manipulations create it as &lt;strong&gt;factory&lt;/strong&gt;</source>
          <target state="translated">데이터 조작을 위해 &lt;strong&gt;공장으로&lt;/strong&gt; 생성</target>
        </trans-unit>
        <trans-unit id="5d4008d04bf8dc913dd361a11d1dbf2dd7fff6d9" translate="yes" xml:space="preserve">
          <source>For basic scenarios factory&amp;amp;Service behaves same.</source>
          <target state="translated">기본 시나리오의 경우 factory &amp;amp; Service가 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be44b8b9aee8e49c0f525f0d589dc7ae0563c459" translate="yes" xml:space="preserve">
          <source>For me the best and the simplest way of understanding the difference is:</source>
          <target state="translated">나에게 차이점을 이해하는 가장 좋고 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56ff743259acbed742d59f1071ec5c09de91c4a2" translate="yes" xml:space="preserve">
          <source>For me, the revelation came when I realized that they all work the same way: by running something &lt;strong&gt;once&lt;/strong&gt;, storing the value they get, and then cough up &lt;strong&gt;that same stored value&lt;/strong&gt; when referenced through &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">저에게 계시는 그들이 모두 같은 방식으로 작동한다는 것을 깨달았을 때 나타났습니다. 무언가를 &lt;strong&gt;한 번&lt;/strong&gt; 실행하고 얻은 값을 저장 한 다음 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;의존성 주입을&lt;/a&gt; 통해 참조 할 때 &lt;strong&gt;동일한 저장된 값&lt;/strong&gt; 을 기침합니다.</target>
        </trans-unit>
        <trans-unit id="b27ee14ba7c9338b5357168645fc5fca69baff87" translate="yes" xml:space="preserve">
          <source>For more details, see a post I wrote on the difference: &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 차이점에 대해 쓴 게시물을 참조하십시오. &lt;a href=&quot;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&quot;&gt;http://www.shanemkeller.com/tldr-services-vs-factories-in-angular/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd35023ca5fbcbbe13f3b8c3e423caa7232e2d3e" translate="yes" xml:space="preserve">
          <source>For the most part, just stick with using factories for everything.
  Their behavior is easier to understand. There&amp;rsquo;s no choice to make
  about whether to return a value or not, and furthermore, no bugs to be
  introduced if you do the wrong thing.</source>
          <target state="translated">대부분의 경우 모든 것을 위해 팩토리를 사용하십시오. 그들의 행동은 이해하기 쉽습니다. 값을 반환할지 여부를 선택할 수 없으며 잘못된 일을한다면 버그가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bc24d8b9740765e38f68d62a235ac7b05a3ba82" translate="yes" xml:space="preserve">
          <source>From Docs &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Service/Factory&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">Docs &lt;a href=&quot;https://docs.angularjs.org/guide/services&quot;&gt;&lt;strong&gt;Service / Factory에서&lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f49fa588c62b7f2f5abba55d1b95ecf06f622095" translate="yes" xml:space="preserve">
          <source>From the AngularJS mailing list I got &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;an amazing thread&lt;/a&gt; that explains service vs factory vs provider and their injection usage. Compiling the answers:</source>
          <target state="translated">AngularJS 메일 링리스트에서 서비스 대 팩토리 대 공급자 및 주입 사용법을 설명 &lt;a href=&quot;https://groups.google.com/forum/#!msg/angular/56sdORWEoqg/HuZsOsMvKv4J&quot;&gt;하는 놀라운 스레드&lt;/a&gt; 를 얻었습니다. 답변을 컴파일 :</target>
        </trans-unit>
        <trans-unit id="fd7022a8753e6add51e2b9d2c29e59c134d3fba6" translate="yes" xml:space="preserve">
          <source>Functions and instance variables will be properties of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">함수와 인스턴스 변수는 &lt;code&gt;this&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="bc7b97dbb27777de72af8d9af9dd816e007cb47e" translate="yes" xml:space="preserve">
          <source>Here is a simpler example.  I'm using a few third party libraries that expect a &quot;Position&quot; object exposing latitude and longitude, but via different object properties.  I didn't want to hack the vendor code, so I adjusted the &quot;Position&quot; objects I was passing around.</source>
          <target state="translated">다음은 더 간단한 예입니다. 위도 및 경도를 노출하지만 다른 객체 속성을 통해 &quot;위치&quot;객체를 기대하는 타사 라이브러리를 사용하고 있습니다. 공급 업체 코드를 해킹하고 싶지 않아서 전달중인 &quot;Position&quot;개체를 조정했습니다.</target>
        </trans-unit>
        <trans-unit id="ae278ffeba6cafa1c3d2a70eeb6622299cb946ec" translate="yes" xml:space="preserve">
          <source>Here is a summary of when to use each:</source>
          <target state="translated">다음은 각각 사용시기에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="c9a8b09d58f2e8e0771d8f78424d27f226d92eae" translate="yes" xml:space="preserve">
          <source>Here is some broilerplate code I've come up with as a code-template for object factory in AngularjS.  I've used a Car/CarFactory as an example to illustrate.  Makes for simple implementation code in the controller.</source>
          <target state="translated">다음은 AngularjS에서 객체 팩토리의 코드 템플릿으로 제시 한 브로일러 플레이트 코드입니다. 설명하기 위해 Car / CarFactory를 예로 사용했습니다. 컨트롤러에서 간단한 구현 코드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="489ba797946b9923375b0c16c73874f3a39fb591" translate="yes" xml:space="preserve">
          <source>Here you&amp;rsquo;ll notice we&amp;rsquo;re not attaching those variables/function to &amp;lsquo;service&amp;rsquo;. We&amp;rsquo;re simply creating them in order to either use or modify them later.</source>
          <target state="translated">여기서는 변수 / 함수를 'service'에 첨부하지 않습니다. 나중에 사용하거나 수정하기 위해 단순히 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="00a6aa13d323a6c412ee902d5b3d4d2d1ab4fe03" translate="yes" xml:space="preserve">
          <source>Here's a great further explanation by Misko:</source>
          <target state="translated">Misko의 훌륭한 추가 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da5246469f32f79cb4f5e21f982157b5bf8fb944" translate="yes" xml:space="preserve">
          <source>Here's the article this image is from:</source>
          <target state="translated">이 이미지의 기사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="850ac93122b4715c223580cbbd975d246cb16f45" translate="yes" xml:space="preserve">
          <source>Hope this has cleared up your understanding about &lt;strong&gt;Factory, Service and Provider&lt;/strong&gt;.</source>
          <target state="translated">이것이 &lt;strong&gt;공장, 서비스 및 공급자에&lt;/strong&gt; 대한 이해를 &lt;strong&gt;명확하게 해주길 바랍니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c040a989c90c935f04c9d9df515887605a02c08" translate="yes" xml:space="preserve">
          <source>How AngularJS instantiates particular components (simplified):</source>
          <target state="translated">AngularJS가 특정 컴포넌트를 인스턴스화하는 방법 (단순화) :</target>
        </trans-unit>
        <trans-unit id="c385f140fdcc5112262dbad26d8a3223347e8d51" translate="yes" xml:space="preserve">
          <source>I am trying to keep it simple. It's all about basic JavaScript concept.</source>
          <target state="translated">간단하게 유지하려고합니다. 기본 JavaScript 개념에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="29ca2a8a57db27d862d4085e8c93784f8e59cb96" translate="yes" xml:space="preserve">
          <source>I came across this video which explains clearly about factory, service and provider methodologies for developing AngularJS Custom Services:</source>
          <target state="translated">AngularJS 사용자 정의 서비스를 개발하기위한 팩토리, 서비스 및 제공자 방법에 대해 명확하게 설명하는이 비디오를 보았습니다.</target>
        </trans-unit>
        <trans-unit id="37a6f10678b28516c544ad2d07c57f10ba034f15" translate="yes" xml:space="preserve">
          <source>I know a lot of excellent answer but I have to share my experience of using</source>
          <target state="translated">나는 훌륭한 답변을 많이 알고 있지만 사용 경험을 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="9310dd05ba382096e00103255eac7688e44ef73b" translate="yes" xml:space="preserve">
          <source>I noticed something interesting when playing around with providers.</source>
          <target state="translated">프로 바이더와 놀아 볼 때 흥미로운 것을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="86c3d8da7c12380d33b628011f4dc967a20694c5" translate="yes" xml:space="preserve">
          <source>I still refer to them as &amp;ldquo;services&amp;rdquo; when I&amp;rsquo;m talking about injecting
  them as dependencies, though.</source>
          <target state="translated">그래도 의존성으로 주입하는 것에 대해 이야기 할 때 여전히 &quot;서비스&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="b0314451a42f81ae46c88a72d5644b737ddc515b" translate="yes" xml:space="preserve">
          <source>If you want to use in angular module config function should created as &lt;strong&gt;provider&lt;/strong&gt;</source>
          <target state="translated">각도 모듈에서 사용하려면 구성 기능을 &lt;strong&gt;공급자로&lt;/strong&gt; 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="760bfbfabac6439646276d21d21c1e88b0f1b52a" translate="yes" xml:space="preserve">
          <source>In the constructor function we can use 'this' keyword for adding properties/methods to the service object.
example:</source>
          <target state="translated">생성자 함수에서 서비스 객체에 속성 / 메소드를 추가하기 위해 'this'키워드를 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c5401a20db45adfe8456a9fe2493978105e9f5da" translate="yes" xml:space="preserve">
          <source>In the controller above we&amp;rsquo;re injecting in the &amp;lsquo;myFactory&amp;rsquo; service. We then set properties on our $scope object with data from &amp;lsquo;myFactory&amp;rsquo;. The only tricky code above is if you&amp;rsquo;ve never dealt with promises before. Because callItunes is returning a promise, we are able to use the .then() method and only set $scope.data.artistData once our promise is fulfilled with the iTunes data. You&amp;rsquo;ll notice our controller is very &amp;lsquo;thin&amp;rsquo; (This is a good coding practise). All of our logic and persistent data is located in our service, not in our controller.</source>
          <target state="translated">위의 컨트롤러에서 우리는 'myFactory'서비스에 주입하고 있습니다. 그런 다음 'myFactory'의 데이터를 사용하여 $ scope 객체의 속성을 설정합니다. 위의 유일한 까다로운 코드는 이전에 약속을 다루지 않은 경우입니다. callItunes가 약속을 반환하므로 .then () 메서드를 사용하고 iTunes 데이터로 약속이 이행 된 후에 만 ​​$ scope.data.artistData를 설정할 수 있습니다. 컨트롤러가 매우 얇다는 것을 알 수 있습니다 (이것은 좋은 코딩 연습입니다). 모든 논리 및 영구 데이터는 컨트롤러가 아닌 서비스에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7c151fc09de45e372af1a2de7be6c6b7781661" translate="yes" xml:space="preserve">
          <source>In the service, we create function names as property with &lt;em&gt;this&lt;/em&gt; object.</source>
          <target state="translated">서비스 &lt;em&gt;에서이&lt;/em&gt; 객체를 사용하여 함수 이름을 속성으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ca27a70fdef565576b6c87e2f47e6b4dd70d0118" translate="yes" xml:space="preserve">
          <source>In this case the injector simply returns the value as is. But what if you want to compute the value? Then use a factory</source>
          <target state="translated">이 경우 인젝터는 단순히 값을 그대로 반환합니다. 그러나 값을 계산하려면 어떻게해야합니까? 그런 다음 공장을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="ce56ab93a5137d82e8def783797ed2029027acad" translate="yes" xml:space="preserve">
          <source>It can be just a collection of functions like a class. Hence, it can be instantiated in different controllers when you are injecting it inside your controller/factory/directive functions. It is instantiated only once per app.</source>
          <target state="translated">클래스와 같은 함수 모음 일 수 있습니다. 따라서 컨트롤러 / 공장 / 지시 기능 내부에 주입 할 때 다른 컨트롤러에서 인스턴스화 할 수 있습니다. 앱당 한 번만 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="5b20c360213ae1af905212996e857c3ffcf8c5ac" translate="yes" xml:space="preserve">
          <source>It works like using a combination of &lt;em&gt;service&lt;/em&gt; and &lt;em&gt;provider&lt;/em&gt;, by passing to provider a function that has properties declared using the &lt;em&gt;this&lt;/em&gt; keyword, which can be used from the &lt;code&gt;app.config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;app.config&lt;/code&gt; 에서 사용할 수있는 &lt;em&gt;this&lt;/em&gt; 키워드를 사용하여 선언 된 속성이있는 함수를 공급자에게 전달하여 &lt;em&gt;service&lt;/em&gt; 와 &lt;em&gt;provider&lt;/em&gt; 의 조합을 사용하는 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="68eb0b5a5293d5d11d5a247852531e63d5c542a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use the factory in our application as we can simply inject it where we need it at run-time.</source>
          <target state="translated">런타임에 필요한 곳에 간단히 주입 할 수 있으므로 응용 프로그램에서 팩토리를 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="5e6ceae9d10cdf11f4c911a2da17d4ac57381842" translate="yes" xml:space="preserve">
          <source>It's the another way, we can register a service. The only difference is the way AngularJS tries to instantiate the service object. This time angular uses 'new' keyword and call the constructor function something like below.</source>
          <target state="translated">다른 방법으로 서비스를 등록 할 수 있습니다. 유일한 차이점은 AngularJS가 서비스 객체를 인스턴스화하는 방식입니다. 이번에는 angular는 'new'키워드를 사용하고 아래와 같이 생성자 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f8bf660b8496971437b76589be4961ef8c377635" translate="yes" xml:space="preserve">
          <source>JS Fiddle Demo</source>
          <target state="translated">JS 피들 데모</target>
        </trans-unit>
        <trans-unit id="0e399439c408eca064ae4becd7265accff216db8" translate="yes" xml:space="preserve">
          <source>Just to clarify things, from the AngularJS source, you can see a service just calls the factory function which in turn calls the provider function:</source>
          <target state="translated">간단히 설명하기 위해 AngularJS 소스에서 서비스가 팩토리 함수를 호출하고 제공자 함수를 호출하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7de5f61ab2c0b942cc33db2f46d0c4b470d32a4e" translate="yes" xml:space="preserve">
          <source>Let's again have a look at the Syntax first:</source>
          <target state="translated">구문을 먼저 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0fec230ed8200309bfc8c6866e454394b38359c7" translate="yes" xml:space="preserve">
          <source>Let's discuss the three ways of handling business logic in AngularJS in a simple way: (&lt;strong&gt;Inspired by Yaakov's Coursera AngularJS course&lt;/strong&gt;)</source>
          <target state="translated">간단한 방법으로 AngularJS에서 비즈니스 로직을 처리하는 세 가지 방법을 논의 해 봅시다 : ( &lt;strong&gt;Yaakov의 Coursera AngularJS 과정에서 영감을 얻음&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="fa350ad45511dbe39a4d035e7a10563f5896422d" translate="yes" xml:space="preserve">
          <source>Lets start with the difference between Service and factory:</source>
          <target state="translated">서비스와 팩토리의 차이점부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="778a430f691a6018fcf57447a71b7c8cd2109696" translate="yes" xml:space="preserve">
          <source>Like I mentioned before, once you really understand what &amp;lsquo;new&amp;rsquo; does, Services are almost identical to factories in AngularJS.</source>
          <target state="translated">앞에서 언급했듯이 '새로운'기능을 실제로 이해하면 서비스는 AngularJS의 공장과 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="25c6b479772ad22656b96f68f104741b92338f0a" translate="yes" xml:space="preserve">
          <source>Little late to the party.  But I thought this is more helpful for who would like to learn (or have clarity) on developing Angular JS Custom Services using factory, service and provider methodologies.</source>
          <target state="translated">파티에 늦었 어 그러나 나는 이것이 공장, 서비스 및 공급자 방법론을 사용하여 Angular JS Custom Services를 개발하는 것을 배우거나 명확하게하려는 사람에게 더 도움이된다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="4bd48a3b50a9f231823114ba704dfccf0bd973da" translate="yes" xml:space="preserve">
          <source>My clarification on this matter:</source>
          <target state="translated">이 문제에 대한 나의 설명 :</target>
        </trans-unit>
        <trans-unit id="fbf210c3ae8711990847a3d950af4119f3209adb" translate="yes" xml:space="preserve">
          <source>My understanding is very simple below.</source>
          <target state="translated">내 이해는 아래에서 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="69f7e11da9f849693995d92816d880bd6fdc64e1" translate="yes" xml:space="preserve">
          <source>Not only produces singleton, but customizable services.</source>
          <target state="translated">싱글 톤뿐만 아니라 맞춤형 서비스도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="982fb0ca939387b6254256e3ab0dfb3a7cc84d6c" translate="yes" xml:space="preserve">
          <source>Not only we can create a factory that's dynamically configurable, but at the time of using the factory, with the provider method, we could custom configure the factory just once at the bootstrapping of our entire application.</source>
          <target state="translated">동적으로 구성 할 수있는 팩토리를 만들 수있을뿐만 아니라 팩토리를 사용할 때 제공자 메소드를 사용하여 전체 애플리케이션의 부트 스트랩에서 팩토리를 한 번만 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672bd2d09c7ed72a3eac6c27958d21691133d0dc" translate="yes" xml:space="preserve">
          <source>Note that it is possible to return a object (in which case it will function similar to a &lt;em&gt;service&lt;/em&gt;) or a function (that will be saved in the variable as a callback function).</source>
          <target state="translated">객체 (이 경우 &lt;em&gt;서비스&lt;/em&gt; 와 비슷한 기능을 함) 또는 함수 (변수를 콜백 함수로 저장함)를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b1a8bd7c0a880872f4d9c7b867ae61242c0dfa0" translate="yes" xml:space="preserve">
          <source>Now having this knowledge of what the &amp;lsquo;new&amp;rsquo; keyword really does in JavaScript, creating a Service in AngularJS should be easier to understand.</source>
          <target state="translated">이제 'new'키워드가 JavaScript에서 실제로 수행하는 작업에 대한 지식이 있으면 AngularJS에서 서비스를 작성하는 것이 이해하기 쉬워야합니다.</target>
        </trans-unit>
        <trans-unit id="d741df1b012ea25d838dc2c21bf70522da5f8512" translate="yes" xml:space="preserve">
          <source>Now just like in our factory and Service, setArtist, getArtist, and callItunes will be available in whichever controller we pass myProvider into. Here&amp;rsquo;s the myProvider controller (which is almost exactly the same as our factory/Service controller).</source>
          <target state="translated">이제 팩토리 및 서비스에서와 마찬가지로 setArtist, getArtist 및 callItunes는 myProvider를 전달하는 컨트롤러에서 사용할 수 있습니다. 다음은 myProvider 컨트롤러입니다 (공장 / 서비스 컨트롤러와 거의 동일).</target>
        </trans-unit>
        <trans-unit id="698af625bfcb4e8f8fcb2e7bcb26d8b5f98e4503" translate="yes" xml:space="preserve">
          <source>Now just like in our factory, setArtist, getArtist, and callItunes will be available in whichever controller we pass myService into. Here&amp;rsquo;s the myService controller (which is almost exactly the same as our factory controller).</source>
          <target state="translated">이제 팩토리에서와 마찬가지로 setArtist, getArtist 및 callItunes는 myService를 전달하는 컨트롤러에서 사용할 수 있습니다. 다음은 myService 컨트롤러입니다 (공장 컨트롤러와 거의 동일).</target>
        </trans-unit>
        <trans-unit id="33179f320db64f96208e8896db6147d2739c655b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a method onto our Person&amp;rsquo;s prototype so it will be available on every instance of our Person &amp;lsquo;class&amp;rsquo;.</source>
          <target state="translated">이제 Person의 프로토 타입에 메소드를 추가하여 Person '클래스'의 모든 인스턴스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e56b2bbd2bcd8c15e0879964355623ffab1f7bb" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add some &amp;lsquo;private&amp;rsquo; variables to our callback function. These won&amp;rsquo;t be directly accessible from the controller, but we will eventually set up some getter/setter methods on &amp;lsquo;service&amp;rsquo; to be able to alter these &amp;lsquo;private&amp;rsquo; variables when needed.</source>
          <target state="translated">이제 콜백 함수에 '비공개'변수를 추가하겠습니다. 이것들은 컨트롤러에서 직접 액세스 할 수는 없지만 결국 'service'에서 getter / setter 메소드를 설정하여 필요할 때 이러한 'private'변수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83d5faac981eb0e79df8c1e9fbac8b90b76a95f" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at what actually is happening when you use the &amp;lsquo;new&amp;rsquo; keyword in JavaScript. First thing you should notice is that after using &amp;lsquo;new&amp;rsquo; in our example, we&amp;rsquo;re able to call a method (sayName) on &amp;lsquo;tyler&amp;rsquo; just as if it were an object - that&amp;rsquo;s because it is. 
So first, we know that our Person constructor is returning an object, whether we can see that in the code or not. Second, we know that because our sayName function is located on the prototype and not directly on the Person instance, the object that the Person function is returning must be delegating to its prototype on failed lookups. In more simple terms, when we call tyler.sayName() the interpreter says &amp;ldquo;OK, I&amp;rsquo;m going to look on the &amp;lsquo;tyler&amp;rsquo; object we just created, locate the sayName function, then call it. Wait a minute, I don&amp;rsquo;t see it here - all I see is name and age, let me check the prototype. Yup, looks like it&amp;rsquo;s on the prototype, let me call it.&amp;rdquo;.</source>
          <target state="translated">이제 JavaScript에서 'new'키워드를 사용할 때 실제로 어떤 일이 발생하는지 살펴 보겠습니다. 첫 번째로 주목해야 할 것은 예제에서 'new'를 사용한 후에는 마치 'tyler'에서 객체 인 것처럼 메소드 (sayName)를 호출 할 수 있다는 것입니다. 그 이유 때문입니다. 먼저, Person 생성자가 코드에서 볼 수 있는지 여부에 관계없이 Person 생성자가 객체를 반환한다는 것을 알고 있습니다. 둘째, sayName 함수는 Person 인스턴스가 아닌 프로토 타입에 있으므로 Person 함수가 반환하는 객체는 실패한 조회에서 프로토 타입에 위임되어야합니다. 더 간단한 용어로, tyler.sayName ()을 호출하면 인터프리터는&amp;ldquo;OK, 방금 만든 'tyler'객체를보고 sayName 함수를 찾은 다음 호출합니다. 잠깐만 요, 여기 보이지 않습니다. 이름과 나이 만 있으면 프로토 타입을 확인할 수 있습니다. 예, 프로토 타입에있는 것 같습니다.&amp;rdquo;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="fb6577ce21f8b4d96fd20a371037e7c8ed7c6760" translate="yes" xml:space="preserve">
          <source>Now our factory is complete. We are now able to inject &amp;lsquo;myFactory&amp;rsquo; into any controller and we&amp;rsquo;ll then be able to call our methods that we attached to our service object (setArtist, getArtist, and callItunes).</source>
          <target state="translated">이제 우리 공장은 완성되었습니다. 이제 모든 컨트롤러에 'myFactory'를 삽입 할 수 있으며 서비스 객체 (setArtist, getArtist 및 callItunes)에 첨부 한 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd7216c3d216047524da229ce33e07f854c5b20" translate="yes" xml:space="preserve">
          <source>Now that our helper/private variables and function are in place, let&amp;rsquo;s add some properties to the &amp;lsquo;service&amp;rsquo; object. Whatever we put on &amp;lsquo;service&amp;rsquo; can be directly used inside whichever controller we pass &amp;lsquo;myFactory&amp;rsquo; into.</source>
          <target state="translated">헬퍼 / 프라이빗 변수와 함수가 준비되었으므로 'service'객체에 속성을 추가해 봅시다. 우리가 '서비스'에 넣은 것은 'myFactory'를 전달하는 컨트롤러 내에서 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39ddb2f22b7fced081ba8ea176229ca0ac8d8309" translate="yes" xml:space="preserve">
          <source>Now that we have our Person constructor function and our sayName function on its prototype, let&amp;rsquo;s actually create an instance of Person then call the sayName function.</source>
          <target state="translated">이제 Person 생성자 함수와 프로토 타입에 sayName 함수가 있으므로 Person 인스턴스를 만든 다음 sayName 함수를 호출 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ec51346deab58cf2c25c7d6a3cb4af41dc640f10" translate="yes" xml:space="preserve">
          <source>Now the full Provider code looks like this</source>
          <target state="translated">이제 전체 제공자 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="a8c5c01dc8cb0c4ad9e61b2d0177736881556303" translate="yes" xml:space="preserve">
          <source>Now using the above two in the controller:</source>
          <target state="translated">이제 컨트롤러에서 위의 두 가지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="554f3e5b70223d89fd87ed55eb8c7fa0aea6edc3" translate="yes" xml:space="preserve">
          <source>Now whatever properties we attach to &amp;lsquo;service&amp;rsquo; will be available to us when we pass &amp;lsquo;myFactory&amp;rsquo; into our controller.</source>
          <target state="translated">이제 'myFactory'를 컨트롤러에 전달하면 'service'에 첨부 한 모든 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8db4bcee9cc90896dbc924721630384540a94c50" translate="yes" xml:space="preserve">
          <source>Now you can see how &amp;lsquo;thingFromConfig&amp;rsquo; is as empty string in our provider, but when that shows up in the DOM, it will be &amp;lsquo;This sentence was set&amp;hellip;&amp;rsquo;.</source>
          <target state="translated">이제 제공자에서 'thingFromConfig'가 빈 문자열로 어떻게 나타나는지 알 수 있지만 DOM에 표시되면 '이 문장이 설정되었습니다&amp;hellip;'가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec62b54ee6ce720c21f33325f4f0a65c82d69fdb" translate="yes" xml:space="preserve">
          <source>Now, because we put the sayName function on the prototype, every instance of Person will be able to call the sayName function in order alert that instance&amp;rsquo;s name.</source>
          <target state="translated">이제 프로토 타입에 sayName 함수를 추가 했으므로 Person의 모든 인스턴스는 해당 인스턴스 이름을 알리기 위해 sayName 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f40cd81d972474ebbd1638f071afb14e360695" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll attach all of our methods that will be available in our controller to &amp;lsquo;this&amp;rsquo;.</source>
          <target state="translated">이제 컨트롤러에서 사용할 수있는 모든 메소드를 'this'에 첨부하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f06e2a3c653d42f7111fe26d1c705865f3c86c73" translate="yes" xml:space="preserve">
          <source>Only provider will be available in config phase of angular, while
  service &amp;amp; factory are not.</source>
          <target state="translated">angular의 구성 단계에서는 공급자 만 사용할 수 있지만 서비스 및 팩토리는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfdb4f5263d92c8b24c27c443665ded6f3f279be" translate="yes" xml:space="preserve">
          <source>Perhaps the biggest thing to know when dealing with creating a Service is that that it&amp;rsquo;s instantiated with the &amp;lsquo;new&amp;rsquo; keyword. For you JavaScript gurus this should give you a big hint into the nature of the code. For those of  you with a limited background in JavaScript or for those who aren&amp;rsquo;t too familiar with what the &amp;lsquo;new&amp;rsquo; keyword actually does, let&amp;rsquo;s review some JavaScript fundamentals that will eventually help us in understanding the nature of a Service.</source>
          <target state="translated">아마도 서비스 생성을 처리 할 때 알아야 할 가장 큰 것은 '새로운'키워드로 인스턴스화된다는 것입니다. JavaScript 전문가에게는 코드의 특성에 대한 큰 힌트를 제공해야합니다. JavaScript에 대한 배경 지식이 제한적인 사용자 또는 'new'키워드의 실제 기능에 익숙하지 않은 사용자를 위해 서비스의 본질을 이해하는 데 도움이되는 JavaScript 기본 사항을 검토하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7ceee3f3615a2bbe4ce0ac5a269a311e4821daf4" translate="yes" xml:space="preserve">
          <source>Provider</source>
          <target state="translated">Provider</target>
        </trans-unit>
        <trans-unit id="53d2419e2fad27c745ab7837fb34c5b4cb3b5535" translate="yes" xml:space="preserve">
          <source>Provider is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">공급자는 가장 복잡한 레시피 유형입니다. 전역 구성이 필요한 재사용 가능한 코드를 작성하지 않는 한 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3f6c702cb3e12640d8a58f3b97ac66d45f4b833" translate="yes" xml:space="preserve">
          <source>Provider is the most flexible method of creating services in Angular.</source>
          <target state="translated">공급자는 Angular에서 가장 유연한 서비스 생성 방법입니다.</target>
        </trans-unit>
        <trans-unit id="955559753eafb5cc8b4506201a86bbe417ec9d05" translate="yes" xml:space="preserve">
          <source>Provider() function is the another way for creating services. Let we are interested to create a service which just display some greeting message to the user. But we also want to provide a functionality such that user can set their own greeting message. In technical terms we want to create configurable services. How can we do this ? There must be a way, so that app could pass their custom greeting messages and Angularjs would make it available to factory/constructor function which create our services instance.
In such a case provider() function do the job. using provider() function we can create configurable services.</source>
          <target state="translated">Provider () 함수는 서비스를 만드는 또 다른 방법입니다. 사용자에게 인사말 메시지 만 표시하는 서비스를 만들려고합니다. 그러나 사용자가 자신의 인사말 메시지를 설정할 수있는 기능도 제공하려고합니다. 기술적 인 관점에서 우리는 구성 가능한 서비스를 만들고 싶습니다. 우리는 어떻게 이것을 할 수 있습니까? 앱이 사용자 지정 인사말 메시지를 전달할 수 있고 Angularjs가 서비스 인스턴스를 생성하는 팩토리 / 생성자 기능에서 사용할 수 있도록하는 방법이 있어야합니다. 이러한 경우 provider () 함수가 작업을 수행하십시오. provider () 함수를 사용하여 구성 가능한 서비스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b7c08baed1c8e93db95b79bcdca55b631dd7bb" translate="yes" xml:space="preserve">
          <source>Providers</source>
          <target state="translated">Providers</target>
        </trans-unit>
        <trans-unit id="2d56985193e8bf2d6ab8849ef7c57e0e5dde4a2b" translate="yes" xml:space="preserve">
          <source>Providers allow you to configure the provider &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; AngularJS calls the &lt;code&gt;$get&lt;/code&gt; method to get the injectible.</source>
          <target state="translated">제공자는 AngularJS가 &lt;code&gt;$get&lt;/code&gt; 메소드를 호출하여 인젝터 블을 얻기 &lt;strong&gt;&lt;em&gt;전에&lt;/em&gt;&lt;/strong&gt; 제공자를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa42b9d0b7dbcb3ea427607354fff8602303c4c8" translate="yes" xml:space="preserve">
          <source>Providers have the advantage that they can be configured during the module configuration phase.</source>
          <target state="translated">공급자는 모듈 구성 단계에서 구성 할 수 있다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d9b9399c4d6be5dbb075743c0ee3d595b3daf9b" translate="yes" xml:space="preserve">
          <source>Result: When declaring factoryName as an injectable argument you will be provided with &lt;strong&gt;the value that is returned by invoking the function reference passed to module.factory&lt;/strong&gt;.</source>
          <target state="translated">결과 : factoryName을 주입 가능한 인수로 선언하면 module.factory에 &lt;strong&gt;전달 된 함수 참조를 호출하여 리턴되는 값이&lt;/strong&gt; 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8055b0f238e713bbe09a1f5142a3a9c4180d28" translate="yes" xml:space="preserve">
          <source>Result: When declaring providerName as an injectable argument &lt;strong&gt;you will be provided with&lt;/strong&gt;&lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt;. The constructor function is instantiated before the $get method is called - &lt;code&gt;ProviderFunction&lt;/code&gt; is  the function reference passed to module.provider.</source>
          <target state="translated">결과 : providerName을 주입 가능한 인수로 선언하면 &lt;code&gt;(new ProviderFunction()).$get()&lt;/code&gt; 됩니다. 생성자 함수는 $ get 메소드가 호출되기 전에 인스턴스화됩니다. &lt;code&gt;ProviderFunction&lt;/code&gt; 은 module.provider에 전달 된 함수 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c70fc6d0d8618584e9490ed45c73cb37b4246b1e" translate="yes" xml:space="preserve">
          <source>Result: When declaring serviceName as an injectable argument &lt;strong&gt;you will be provided with an instance of the function. In other words&lt;/strong&gt;&lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt;.</source>
          <target state="translated">결과 : serviceName을 주입 가능한 인수로 선언 &lt;strong&gt;하면 함수의 인스턴스가 제공됩니다.&lt;/strong&gt; &lt;strong&gt;다시 말해&lt;/strong&gt; &lt;code&gt;new FunctionYouPassedToService()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c830a908226f52c7631bae300c0e26abb3631d0" translate="yes" xml:space="preserve">
          <source>Sample Example:</source>
          <target state="translated">샘플 예 :</target>
        </trans-unit>
        <trans-unit id="381df071be6ca5ac8d6e5e18ab012360963bd4a9" translate="yes" xml:space="preserve">
          <source>Sample code for creating service using provide syntax:</source>
          <target state="translated">제공 구문을 사용하여 서비스를 작성하기위한 샘플 코드 :</target>
        </trans-unit>
        <trans-unit id="48b99d56be6c851af2a3af055d69bee4d9b017c7" translate="yes" xml:space="preserve">
          <source>Say we have:</source>
          <target state="translated">우리가 가지고 있다고합시다.</target>
        </trans-unit>
        <trans-unit id="11dc1a4e11a2784e2b6de73a9022cddbb6721f42" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;the provider documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.angularjs.org/guide/providers&quot;&gt;공급자 설명서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f4ab1a2559d02916ca6b754d342e20711e3cfca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;here&lt;/a&gt; for the provided code.</source>
          <target state="translated">제공된 코드는 &lt;a href=&quot;http://jsbin.com/ohamub/1/edit&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="329cb8b6ba8c427be7c09b298295c655415c7ac9" translate="yes" xml:space="preserve">
          <source>Service</source>
          <target state="translated">Service</target>
        </trans-unit>
        <trans-unit id="5030396a200088699db9b35f53a60b75ca0f61ed" translate="yes" xml:space="preserve">
          <source>Service Function:</source>
          <target state="translated">서비스 기능 :</target>
        </trans-unit>
        <trans-unit id="6210fa9c0a7b05e22abb7fcb5a13962309ea102d" translate="yes" xml:space="preserve">
          <source>Service initialization</source>
          <target state="translated">서비스 초기화</target>
        </trans-unit>
        <trans-unit id="9d10e77416b918cf3662445c6e88c578fa4569c9" translate="yes" xml:space="preserve">
          <source>Service is an singleton object instance. Use services if you want to provide a singleton object for your code.</source>
          <target state="translated">서비스는 싱글 톤 객체 인스턴스입니다. 코드에 싱글 톤 객체를 제공하려면 서비스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="61835754249fef2e2b45059d3bbd0d0e5cdde58d" translate="yes" xml:space="preserve">
          <source>Service/Factory behavior is very similar, and some people will say
  that either one is fine. That&amp;rsquo;s somewhat true, but I find it easier to
  follow the advice of John Papa&amp;rsquo;s style guide and just stick with
  factories.**</source>
          <target state="translated">서비스 / 공장 동작은 매우 유사하며 어떤 사람들은 둘 중 어느 쪽이든 괜찮다고 말할 것입니다. 다소 사실이지만 John Papa의 스타일 가이드의 조언을 따르고 공장을 고수하는 것이 더 쉽다는 것을 알았습니다. **</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="c1e289d3853bb8c7d8a915f54b7abf6bb6594091" translate="yes" xml:space="preserve">
          <source>Simply while looking at the services think about the array prototype. A service is a function which instantiates a new object using the 'new' keyword. You can add properties and functions to a service object by using the &lt;code&gt;this&lt;/code&gt; keyword. Unlike a factory, it doesn't return anything (it returns an object which contains methods/properties).</source>
          <target state="translated">서비스를 보면서 간단히 어레이 프로토 타입에 대해 생각하십시오. 서비스는 'new'키워드를 사용하여 새 객체를 인스턴스화하는 기능입니다. &lt;code&gt;this&lt;/code&gt; 키워드를 사용하여 서비스 객체에 속성과 기능을 추가 할 수 있습니다. 팩토리와 달리 아무것도 반환하지 않습니다 (메소드 / 속성을 포함하는 객체를 반환합니다).</target>
        </trans-unit>
        <trans-unit id="62854845263bf068dddccd96ecb184fb8ea7a590" translate="yes" xml:space="preserve">
          <source>Since the constructed service is an object, the methods inside it can refer to this when they&amp;rsquo;re called:</source>
          <target state="translated">생성 된 서비스는 객체이기 때문에 호출 된 내부의 메소드는이를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="155220d0a18e305b7ea66fb35c4da7270fc65257" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;factory&lt;/code&gt; is a function which is responsible for creating the value. Notice that the factory function can ask for other dependencies.</source>
          <target state="translated">따라서 &lt;code&gt;factory&lt;/code&gt; 는 값을 생성하는 기능입니다. 팩토리 기능은 다른 종속성을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d857556fc3e68491091f75ba684105c6782e0e5" translate="yes" xml:space="preserve">
          <source>So all together the code for creating a Person constructor, adding a function to it&amp;rsquo;s prototype, creating a Person instance, and then calling the function on its prototype looks like this.</source>
          <target state="translated">따라서 Person 생성자를 생성하고 프로토 타입에 함수를 추가하고 Person 인스턴스를 생성 한 다음 프로토 타입에서 함수를 호출하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08c3828d081a8d7efafeefc62c0878e780b4e133" translate="yes" xml:space="preserve">
          <source>So basically in both cases you eventually get a providers $get set to your function you provided , but you can give anything extra than $get as you can originally provide in provider() for config block</source>
          <target state="translated">따라서 기본적으로 두 경우 모두 공급자가 제공 한 기능으로 $ get set을 얻지 만 구성 블록에 대해 provider ()에서 원래 제공 할 수 있으므로 $ get 이외의 것을 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="27e3723bbf080ae2fb322bd7eb8909b1557894e4" translate="yes" xml:space="preserve">
          <source>So if there are three controller scope, let it be controllerA, controllerB and controllerC, all will share same service instance.</source>
          <target state="translated">따라서 컨트롤러 범위가 세 개인 경우 controllerA, controllerB 및 controllerC로 지정하면 모두 동일한 서비스 인스턴스를 공유하게됩니다.</target>
        </trans-unit>
        <trans-unit id="dd81d4d697436b2952af0ee10fd0dd2ca080a3d2" translate="yes" xml:space="preserve">
          <source>So master provider and injector and all will fall in place :) . And it gets interesting in Typescript when $get can be implemented in a provider by inheriting from IServiceProvider.</source>
          <target state="translated">따라서 마스터 제공자와 인젝터 및 모든 것이 제자리에 놓입니다. 그리고 IServiceProvider에서 상속하여 $ get을 공급자에서 구현할 수 있으면 Typescript에서 흥미로워집니다.</target>
        </trans-unit>
        <trans-unit id="cb9d6754283c9f37208464bd5837389aa5b0ad15" translate="yes" xml:space="preserve">
          <source>So when Angular constructs your service with new MyService(), it&amp;rsquo;ll get that api object instead of the MyService instance.</source>
          <target state="translated">따라서 Angular가 새로운 MyService ()를 사용하여 서비스를 구성하면 MyService 인스턴스 대신 해당 api 객체를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c72cf4ede28e8dd19525b9079025b0772ccc130b" translate="yes" xml:space="preserve">
          <source>So why such complications, why can't we just use provider and forget everything else? It is supposed to help us write code easily and communicate better. And toungue-in-cheek reply would be, the more complex it gets the better selling a framework will be.</source>
          <target state="translated">그렇다면 왜 그러한 합병증이 발생합니까? 왜 우리는 공급자를 사용하고 다른 모든 것을 잊을 수 없습니까? 쉽게 코드를 작성하고 더 잘 의사 소통 할 수 있도록 도와줍니다. 그리고 멍청한 뺨의 대답은 더 복잡할수록 프레임 워크가 더 잘 팔릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="d26ab8fdbfba98e5ec328de0fd5fd8b3ec1253e1" translate="yes" xml:space="preserve">
          <source>So, for the service, what becomes the AngularJS component is the object instance of the class which is represented by service declaration function. For the factory, it is the result returned from the factory declaration function. The factory may behave the same as the service:</source>
          <target state="translated">따라서 서비스의 경우 AngularJS 구성 요소가되는 것은 서비스 선언 함수로 표시되는 클래스의 객체 인스턴스입니다. 팩토리의 경우 팩토리 선언 함수에서 리턴 된 결과입니다. 공장은 서비스와 동일하게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62f1055fa34e381a967d48cc84251a3806ed36c" translate="yes" xml:space="preserve">
          <source>Source Code: &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</source>
          <target state="translated">소스 코드 : &lt;a href=&quot;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&quot;&gt;http://www.techcbt.com/Post/353/Angular-JS-basics/how-to-develop-angularjs-custom-service&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9924e31c2dd752407f7714733eb09ad7aaef9362" translate="yes" xml:space="preserve">
          <source>Summary from &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular docs&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;Angular 문서의&lt;/a&gt; 요약 :</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="8a29d9bf1a1e71cf529fe97431e96a86eaf41f44" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</source>
          <target state="translated">구문 : &lt;code&gt;module.factory( 'factoryName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194b446e2c1fb5fc04741acabf05acbc4af47aec" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</source>
          <target state="translated">구문 : &lt;code&gt;module.provider( 'providerName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92324397a45dd6d31034d314cd7fc546cabef2b8" translate="yes" xml:space="preserve">
          <source>Syntax: &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</source>
          <target state="translated">구문 : &lt;code&gt;module.service( 'serviceName', function );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84dd638523da34b8795dead37b56820cfba7075e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$get&lt;/code&gt; is a function that is directly attached to the provider instance. That function is a &lt;strong&gt;factory&lt;/strong&gt; function. In other words, it's just like the one that we use to &lt;em&gt;provide&lt;/em&gt; to the &lt;code&gt;.factory&lt;/code&gt; method. In that function, we create our own service. &lt;strong&gt;This &lt;code&gt;$get&lt;/code&gt; property, that's a function, is what makes the provider a provider&lt;/strong&gt;. &lt;em&gt;AngularJS expects the provider to have a $get property whose value is a function that Angular will treat as a factory function.&lt;/em&gt; But what makes this whole provider setup very special, is the fact that we can provide some &lt;code&gt;config&lt;/code&gt; object inside the service provider, and that usually comes with defaults that we can later overwrite in the step, where we can configure the entire application.</source>
          <target state="translated">&lt;code&gt;$get&lt;/code&gt; 은 제공자 인스턴스에 직접 첨부되는 함수입니다. 그 기능은 &lt;strong&gt;공장&lt;/strong&gt; 기능입니다. 다시 말해, &lt;code&gt;.factory&lt;/code&gt; 메소드에 &lt;em&gt;제공&lt;/em&gt; 하는 것과 같습니다 . 이 기능에서 우리는 우리 자신의 서비스를 만듭니다. &lt;strong&gt;이 &lt;code&gt;$get&lt;/code&gt; 속성은 함수이므로 공급자를 공급자로&lt;/strong&gt; 만듭니다. &lt;em&gt;AngularJS는 프로 바이더가 Angular가 팩토리 함수로 취급 할 함수 인 $ get 속성을 가질 것을 기대합니다.&lt;/em&gt; 그러나이 전체 제공자 설정을 매우 특별하게 만드는 것은 서비스 제공자 내부에 일부 &lt;code&gt;config&lt;/code&gt; 오브젝트를 제공 할 수 있다는 사실이며, 일반적으로 전체 애플리케이션을 구성 할 수있는 단계에서 나중에 겹쳐 쓸 수있는 기본값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7b6548f429604df735e1a44693ef40e85b8e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.service()&lt;/code&gt; method is a &lt;strong&gt;factory&lt;/strong&gt; that always produces the same type of service, which is a singleton, and without any easy way to configure it's behavior. That &lt;code&gt;.service()&lt;/code&gt; method is usually used as a shortcut for something that doesn't require any configuration whatsoever.</source>
          <target state="translated">&lt;code&gt;.service()&lt;/code&gt; 메소드는 단일 유형 인 동일한 유형의 서비스를 항상 생성하는 &lt;strong&gt;팩토리&lt;/strong&gt; 이며 동작을 구성하는 쉬운 방법이 없습니다. &lt;code&gt;.service()&lt;/code&gt; 메소드는 일반적으로 구성이 필요없는 것에 대한 바로 가기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a49ec85e38178c060ff6013773473704cdd2007a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;factory&lt;/code&gt;, &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, and &lt;code&gt;provider&lt;/code&gt; methods are all providers. They teach the Injector how to instantiate the Services.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; , &lt;code&gt;factory&lt;/code&gt; , &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;constant&lt;/code&gt; 및 &lt;code&gt;provider&lt;/code&gt; 메소드는 모두 제공자입니다. 그들은 인젝터에게 서비스를 인스턴스화하는 방법을 가르칩니다.</target>
        </trans-unit>
        <trans-unit id="025bc59091687d744c1dd87ac4446f1a3ea99b14" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Constant recipe&lt;/strong&gt; is just like the Value recipe except it allows you to define services that are available in the &lt;strong&gt;config&lt;/strong&gt; phase. Sooner than services created using the Value recipe. Unlike Values, they cannot be decorated using &lt;code&gt;decorator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;상수 레시피&lt;/strong&gt; 는 &lt;strong&gt;구성&lt;/strong&gt; 단계에서 사용 가능한 서비스를 정의 할 수 있다는 점을 제외하고는 값 레시피와 같습니다. Value 레시피를 사용하여 생성 된 서비스보다 빨리. Values와 달리 &lt;code&gt;decorator&lt;/code&gt; 를 사용하여 꾸밀 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cf81a424905d80f0814719f3aa86cbdefa28b91" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Factory recipe&lt;/strong&gt; gives the Injector a factory function that it calls when it needs to instantiate the service. When called, the &lt;strong&gt;factory function&lt;/strong&gt; creates and returns the service instance. The dependencies of the Service are injected as the functions' arguments. So using this recipe adds the following abilities:</source>
          <target state="translated">&lt;strong&gt;팩토리 레시피&lt;/strong&gt; 는 인젝터에 서비스를 인스턴스화해야 할 때 호출하는 팩토리 기능을 제공합니다. 호출되면 &lt;strong&gt;팩토리 함수&lt;/strong&gt; 는 서비스 인스턴스를 작성하고 리턴합니다. 서비스의 종속성은 함수의 인수로 삽입됩니다. 이 레시피를 사용하면 다음과 같은 능력이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b86e7115a91b56187a5fe0143ed257a341995e64" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider recipe&lt;/strong&gt; is usually &lt;strong&gt;overkill&lt;/strong&gt;. It adds one more layer of indirection by allowing you to configure the creation of the factory.</source>
          <target state="translated">&lt;strong&gt;공급자 레시피&lt;/strong&gt; 는 일반적으로 &lt;strong&gt;과잉&lt;/strong&gt; 입니다. 팩토리 작성을 구성 할 수 있도록하여 간접 계층을 하나 더 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cad58aeb7205a606c508335ce156288e7da6f573" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Provider&lt;/strong&gt; recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">&lt;strong&gt;공급자&lt;/strong&gt; 레시피는 핵심 레시피 유형이며 다른 모든 유형은 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="17bb816a792f8c3e9c45f68c21dac545bc7fc6e8" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Service recipe&lt;/strong&gt; is almost the same as the Factory recipe, but here the Injector invokes a &lt;strong&gt;constructor&lt;/strong&gt; with the new operator instead of a factory function.</source>
          <target state="translated">&lt;strong&gt;서비스 레시피&lt;/strong&gt; 는 팩토리 레시피와 거의 동일하지만 여기서 인젝터는 팩토리 함수 대신 새 연산자를 사용하여 &lt;strong&gt;생성자&lt;/strong&gt; 를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0f6f2e7cab552a54a9d8929a09e98e95cc4cfb9f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Value Recipe&lt;/strong&gt; is the simplest case, where you instantiate the Service yourself and provide the &lt;strong&gt;instantiated value&lt;/strong&gt; to the injector.</source>
          <target state="translated">&lt;strong&gt;가치 레시피&lt;/strong&gt; 는 서비스를 직접 &lt;strong&gt;인스턴스화&lt;/strong&gt; 하고 인젝터에 &lt;strong&gt;인스턴스화 된 값&lt;/strong&gt; 을 제공하는 가장 간단한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="5c03e42c5800d984cbbf4b29ceb9ec72c21a0335" translate="yes" xml:space="preserve">
          <source>The Provider recipe is the core recipe type and all the other ones are just syntactic sugar on it.</source>
          <target state="translated">공급자 레시피는 핵심 레시피 유형이며 다른 모든 유형은 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="c20c67a4543a337b871e95eaa0aa2230110f9cde" translate="yes" xml:space="preserve">
          <source>The biggest thing to remember about Providers is that they&amp;rsquo;re the only service that you can pass into the app.config portion of your application. This is of huge importance if you&amp;rsquo;re needing to alter some portion of your service object before it&amp;rsquo;s available everywhere else in your application. Although very similar to Services/Factories, there are a few differences which we&amp;rsquo;ll discuss.</source>
          <target state="translated">공급자에 대해 기억해야 할 가장 큰 것은 공급자가 응용 프로그램의 app.config 부분에 전달할 수있는 유일한 서비스라는 것입니다. 애플리케이션의 다른 곳에서 사용하기 전에 서비스 오브젝트의 일부를 변경해야하는 경우 이는 매우 중요합니다. 서비스 / 공장과 매우 ​​유사하지만 논의 할 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a3557bc4924e63f2d2ce284fc4ba7adf38dc02" translate="yes" xml:space="preserve">
          <source>The biggest thing to understand when creating a Service is knowing that Services are instantiated with the &amp;lsquo;new&amp;rsquo; keyword. Combining that knowledge with our examples above, you should now recognize that you&amp;rsquo;ll be attaching your properties and methods directly to &amp;lsquo;this&amp;rsquo; which will then be returned from the Service itself. Let&amp;rsquo;s take a look at this in action.</source>
          <target state="translated">서비스를 만들 때 이해해야 할 가장 큰 것은 서비스가 'new'키워드로 인스턴스화된다는 것입니다. 위의 예제와 그 지식을 결합하여 이제 속성과 메소드를 'this'에 직접 첨부하여 서비스 자체에서 반환한다는 것을 인식해야합니다. 이것을 실제로 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="ee97831b61259806e326d0d7c322a8ac829781ee" translate="yes" xml:space="preserve">
          <source>The code for &quot;factory&quot; based custom service is as follows (which goes with both sync and async versions along with calling http service):</source>
          <target state="translated">&quot;공장&quot;기반 사용자 정의 서비스의 코드는 다음과 같습니다 (http 서비스 호출과 함께 동기화 및 비동기 버전 모두와 함께 제공됨).</target>
        </trans-unit>
        <trans-unit id="dbceb93948d3b88153505159e94a72b7b46ceaf3" translate="yes" xml:space="preserve">
          <source>The code for &quot;provider&quot; methodology for Custom Services (this is necessary, if you would like to develop service which could be configured):</source>
          <target state="translated">사용자 지정 서비스에 대한 &quot;제공자&quot;방법론 코드 (구성 할 수있는 서비스를 개발하려는 경우 필요) :</target>
        </trans-unit>
        <trans-unit id="20100b8b1bb6246809bfd0d54c74369163ea60ef" translate="yes" xml:space="preserve">
          <source>The code for &quot;service&quot; methodology for Custom Services (this is pretty similar to 'factory', but different from syntax point of view):</source>
          <target state="translated">커스텀 서비스를위한 &quot;서비스&quot;방법론 코드 (이것은 '공장'과 비슷하지만 구문 관점과는 다릅니다) :</target>
        </trans-unit>
        <trans-unit id="1f5224c76a4a9f42aeda5250ed57bd05696a3d3c" translate="yes" xml:space="preserve">
          <source>The difference between the three is that:</source>
          <target state="translated">세 가지의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80c0d58f7ad22390cf6e79a7ead32b51a9279f3b" translate="yes" xml:space="preserve">
          <source>The factory 'class' example is provided in the comments around, as well as provider difference.</source>
          <target state="translated">팩토리 '클래스'예제는 주석과 공급자 차이에 대한 주석으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="29223deeb9a116b14e0df19e98f9ac9f789b7dbd" translate="yes" xml:space="preserve">
          <source>The factory can also return an object with a method that can be invoked:</source>
          <target state="translated">팩토리는 호출 할 수있는 메소드를 사용하여 오브젝트를 리턴 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c72bcb74f28a11248fb075ce43662f6ac919dc7d" translate="yes" xml:space="preserve">
          <source>The factory can then be used throughout the application with custom settings. In other words, we can configure this factory before the application starts. In fact in the angular documentation it is mentioned that the provider method is what actually gets executed behind the scenes when we configure our services with either &lt;code&gt;.service&lt;/code&gt; or &lt;code&gt;.factory&lt;/code&gt; methods.</source>
          <target state="translated">그런 다음 사용자 정의 설정으로 응용 프로그램 전체에서 공장을 사용할 수 있습니다. 다시 말해, 응용 프로그램이 시작되기 전에이 팩토리를 구성 할 수 있습니다. 실제로 앵귤러 문서에서는 제공자 메소드가 &lt;code&gt;.service&lt;/code&gt; 또는 &lt;code&gt;.factory&lt;/code&gt; 메소드로 서비스를 구성 할 때 실제로 뒤에서 실행되는 것으로 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="70f2a456ca8dd7dbc5919aa27331c81f32a961f4" translate="yes" xml:space="preserve">
          <source>The factory returns a function that can be invoked:</source>
          <target state="translated">팩토리는 호출 할 수있는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="294c451a3bc3bc52035a0a1ff0d80aadf5cf8464" translate="yes" xml:space="preserve">
          <source>The injected value for a factory dependency is the factory&amp;rsquo;s return
  value, and it doesn&amp;rsquo;t have to be an object. It could be a function</source>
          <target state="translated">팩토리 의존성에 대한 주입 된 값은 팩토리의 반환 값이며 객체 일 필요는 없습니다. 그것은 기능이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6273feccee525d43053ba5dbf6fca985976d17e5" translate="yes" xml:space="preserve">
          <source>The injector uses recipes to create two types of objects: services
and special purpose objects</source>
          <target state="translated">인젝터는 레시피를 사용하여 서비스 및 특수 목적 오브젝트의 두 가지 유형의 오브젝트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2a5bdc6259273898183df356d5f764744dcb6660" translate="yes" xml:space="preserve">
          <source>The lowest level way to create a service is by using the provide() method. This is the only way to create a service that we can configure using the .config() function.
Unlike the previous to methods, we&amp;rsquo;ll set the injectables in a defined this.$get() function definition.</source>
          <target state="translated">서비스를 작성하는 가장 낮은 레벨의 방법은 provide () 메소드를 사용하는 것입니다. 이것이 .config () 함수를 사용하여 구성 할 수있는 서비스를 만드는 유일한 방법입니다. 이전 to 메소드와 달리, 정의 된 this. $ get () 함수 정의에서 인젝터 블을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="33cea9a6904f984abbc8f96a6114e14b3b574e31" translate="yes" xml:space="preserve">
          <source>The most verbose, but also the most comprehensive one is a Provider
  recipe. The &lt;strong&gt;remaining four&lt;/strong&gt; recipe types &amp;mdash; Value, Factory, Service and
  Constant &amp;mdash; &lt;strong&gt;are just syntactic sugar on top of a provider recipe&lt;/strong&gt;.</source>
          <target state="translated">가장 장황하지만 가장 포괄적 인 것은 제공자 레시피입니다. &lt;strong&gt;나머지 4 가지&lt;/strong&gt; 레시피 유형 (Value, Factory, Service 및 Constant &lt;strong&gt;)은 제공자 레시피 위에있는 구문 설탕 일뿐&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="348c5cf5eea19f952edd139e0384878a13cc16b3" translate="yes" xml:space="preserve">
          <source>The passed function can define a object and return that object. AngularJS simply stores this object reference to a variable which is passed as first argument. Anything which is returned from fnFactory will be bound to serviceInstance . Instead of returning object , we can also return function, values etc, Whatever we will return , will be available to service instance.</source>
          <target state="translated">전달 된 함수는 객체를 정의하고 해당 객체를 반환 할 수 있습니다. AngularJS는 단순히이 객체 참조를 첫 번째 인수로 전달되는 변수에 저장합니다. fnFactory에서 반환 된 것은 serviceInstance에 바인딩됩니다. 객체를 반환하는 대신 함수, 값 등을 반환 할 수도 있습니다. 반환 할 내용은 서비스 인스턴스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2510f9c93a099e17ccd62f31f88b7b395fab6a8" translate="yes" xml:space="preserve">
          <source>The service returns an object with a method that can be invoked:</source>
          <target state="translated">서비스는 호출 할 수있는 메소드가있는 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c22685b3257f9741c0336da5fe8df717ac146fa0" translate="yes" xml:space="preserve">
          <source>The service() method, on the other hand allows us to create a service by defining a constructor function. We can use a prototypical object to define our service, instead of a raw javascript object.
Similar to the factory() method, we&amp;rsquo;ll also set the injectables in the function definition.</source>
          <target state="translated">반면에 service () 메소드를 사용하면 생성자 함수를 정의하여 서비스를 작성할 수 있습니다. 원시 자바 스크립트 객체 대신 프로토 타입 객체를 사용하여 서비스를 정의 할 수 있습니다. factory () 메소드와 유사하게 함수 정의에서 인젝터 블도 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6d15e1717ce86b0987b078987bab5ad9e89e8630" translate="yes" xml:space="preserve">
          <source>The simplest way of thinking is the following one:</source>
          <target state="translated">가장 간단한 사고 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d37bdb33569628feda26fad99fde289973152425" translate="yes" xml:space="preserve">
          <source>Then it needs to have a separate &lt;em&gt;$.get&lt;/em&gt; function which is executed by AngularJS after setting the above properties via the &lt;code&gt;app.config&lt;/code&gt; file , and this &lt;em&gt;$.get&lt;/em&gt; function behaves just as the &lt;em&gt;factory&lt;/em&gt; above, in that its return value is used to initialize the &quot;global&quot; variables.</source>
          <target state="translated">그런 다음 &lt;code&gt;app.config&lt;/code&gt; 파일을 통해 위의 속성을 설정 한 후 AngularJS에 의해 실행되는 별도의 &lt;em&gt;$ .get&lt;/em&gt; 함수가 필요 &lt;em&gt;하며이&lt;/em&gt; &lt;em&gt;$ .get&lt;/em&gt; 함수는 반환 값이 초기화하는 데 사용되므로 위의 &lt;em&gt;팩토리와&lt;/em&gt; 같이 작동합니다 &quot;전역&quot;변수.</target>
        </trans-unit>
        <trans-unit id="b32fe2094a05734d73d634537bd5399d06168766" translate="yes" xml:space="preserve">
          <source>Then to instantiate you would have to write</source>
          <target state="translated">그런 다음 인스턴스화하려면 다음을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3dbd87f48f38a7cd7438dff5c9c9a17a54a72326" translate="yes" xml:space="preserve">
          <source>Then we can do this:</source>
          <target state="translated">그런 다음 우리는 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="26ab2c621cf3a4ad1aed6bc59c8cac976a8891fc" translate="yes" xml:space="preserve">
          <source>Then we could ask for 'greeter' in controller like this</source>
          <target state="translated">그런 다음 컨트롤러에서 '인사'를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73c6e7a10f2e40affaa0702fd4636afb5ef0a445" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt;,
&lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">객체 생성 방법을 정의하는 5 가지 레시피 유형이 있습니다 : &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#value-recipe&quot;&gt;Value&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#factory-recipe&quot;&gt;Factory&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#service-recipe&quot;&gt;Service&lt;/a&gt;&lt;/strong&gt; , &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#provider-recipe&quot;&gt;Provider&lt;/a&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;a href=&quot;https://docs.angularjs.org/guide/providers#constant-recipe&quot;&gt;Constant&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="016247ec0111e77189147435add0171b2c62c098" translate="yes" xml:space="preserve">
          <source>There are five recipe types that define how to create objects: Value, 
Factory, Service, Provider and Constant.</source>
          <target state="translated">객체 생성 방법을 정의하는 5 가지 레시피 유형이 있습니다 : Value, Factory, Service, Provider 및 Constant.</target>
        </trans-unit>
        <trans-unit id="a3abfbafa21284370080781426e7f10765c626b1" translate="yes" xml:space="preserve">
          <source>There are good answers already, but I just want to share this one.</source>
          <target state="translated">이미 좋은 답변이 있지만이 답변을 공유하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="cbe50089e98dca4865d62e4d5d431a2ad1e1d31e" translate="yes" xml:space="preserve">
          <source>There are many levels of complications in creating the values for the &quot;global variables&quot;:</source>
          <target state="translated">&quot;전역 변수&quot;에 대한 값을 작성하는 데 많은 수준의 복잡성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe4afb9db4aa26d7132e641470f68bed3f4242c" translate="yes" xml:space="preserve">
          <source>There is &lt;code&gt;Service vs Factory&lt;/code&gt; part has been covered:
&lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Service vs Factory&lt;/code&gt; 부분은 다음과 같습니다. &lt;a href=&quot;https://www.youtube.com/watch?v=BLzNCkPn3ao&quot;&gt;https://www.youtube.com/watch?v=BLzNCkPn3ao&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8ee704f9be11c360a8332f959f17604faeec8af" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;$get&lt;/code&gt; object that you define and it can be used to get the object that returns data.</source>
          <target state="translated">정의한 &lt;code&gt;$get&lt;/code&gt; 객체가 있으며 데이터를 반환하는 객체를 가져 오는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a7068b6dda657b5b0908bbb1b5b47f54867579f" translate="yes" xml:space="preserve">
          <source>This answer address the topic/question</source>
          <target state="translated">이 답변은 주제 / 질문을 다룹니다</target>
        </trans-unit>
        <trans-unit id="d2ca6aed8a94daf45ebec515f35b4ef0c7e37069" translate="yes" xml:space="preserve">
          <source>This defines an actual constant that should not be modified during the entire application, just like constants in other languages are (something that JavaScript lacks).</source>
          <target state="translated">이것은 다른 언어의 상수 (JavaScript가없는 것)처럼 전체 응용 프로그램 중에 수정해서는 안되는 실제 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="23068a44ce8e025468c6a880cdc354c2346311bc" translate="yes" xml:space="preserve">
          <source>This is a modifiable value or object, and it serves as some global variable, that can even be injected when creating other services or factories (see further on these). However, it must be a &quot;&lt;em&gt;literal value&lt;/em&gt;&quot;, which means that one has to write out the actual value, and cannot use any computation or programming logic (in other words &lt;em&gt;39&lt;/em&gt; or &lt;em&gt;myText&lt;/em&gt; or &lt;em&gt;{prop: &quot;value&quot;}&lt;/em&gt; are OK, but &lt;em&gt;2 +2&lt;/em&gt; is not).</source>
          <target state="translated">이것은 수정 가능한 값 또는 객체이며 다른 서비스 또는 팩토리를 만들 때 주입 될 수있는 전역 변수 역할을합니다 (자세한 내용 참조). 그러나 &quot; &lt;em&gt;리터럴 값&lt;/em&gt; &quot;이어야합니다. 즉, 실제 값을 써야하며 계산 또는 프로그래밍 논리를 사용할 수 없습니다 (즉, &lt;em&gt;39&lt;/em&gt; 또는 &lt;em&gt;myText&lt;/em&gt; 또는 &lt;em&gt;{prop : &quot;value&quot;}&lt;/em&gt; 는 괜찮습니다). &lt;em&gt;2 +2&lt;/em&gt; 는 아닙니다).</target>
        </trans-unit>
        <trans-unit id="7c23aa97141e4f8d46377a4215db03016a94f612" translate="yes" xml:space="preserve">
          <source>This is a typical JavaScript constructor function. Now whenever we invoke the Person function using the &amp;lsquo;new&amp;rsquo; keyword, &amp;lsquo;this&amp;rsquo; will be bound to the newly created object.</source>
          <target state="translated">이것은 일반적인 JavaScript 생성자 함수입니다. 이제 'new'키워드를 사용하여 Person 함수를 호출 할 때마다 'this'는 새로 작성된 오브젝트에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="dfb8cea8751eb472adb742095a7b2c6e23a67444" translate="yes" xml:space="preserve">
          <source>This is the behavior for any complex values (objects, functions) but not for primitive types.</source>
          <target state="translated">이것은 복잡한 값 (객체, 함수)에 대한 동작이지만 기본 유형에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e7c9cd5dc0b108189dc22be56ae3d9ed503494" translate="yes" xml:space="preserve">
          <source>This is very confusing part for newbie and I have tried to clarify it in easy words</source>
          <target state="translated">이것은 초보자에게는 매우 혼란스러운 부분이며 쉬운 말로 명확하게하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="0071c8fa9a8db22cbf7fe7086f0e4a422890b5c6" translate="yes" xml:space="preserve">
          <source>This is why we use &lt;code&gt;this&lt;/code&gt; in services, and define a &lt;code&gt;this.$get&lt;/code&gt; in providers.</source>
          <target state="translated">이것이 우리가 서비스에서 &lt;code&gt;this&lt;/code&gt; 사용하고 공급자에서 &lt;code&gt;this.$get&lt;/code&gt; 을 정의하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="337dbda194e27c65c3b59a20fcfe6f20bce044b3" translate="yes" xml:space="preserve">
          <source>This means that you can basically copy-paste the factory example from below, replace &lt;code&gt;factory&lt;/code&gt; with &lt;code&gt;service&lt;/code&gt;, and it&amp;rsquo;ll work:</source>
          <target state="translated">이것은 기본적으로 아래에서 팩토리 예제를 복사하여 붙여 넣을 수 있으며 &lt;code&gt;factory&lt;/code&gt; 를 &lt;code&gt;service&lt;/code&gt; 로 바꾸면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bcb15b94b5801e9e5561df693ee7def2f99bdaf9" translate="yes" xml:space="preserve">
          <source>To really see the changes that occur when you invoke a function with the &amp;lsquo;new&amp;rsquo; keyword, let&amp;rsquo;s create a function and invoke it with the &amp;lsquo;new&amp;rsquo; keyword, then let&amp;rsquo;s show what the interpreter does when it sees the &amp;lsquo;new&amp;rsquo; keyword. The end results will both be the same.</source>
          <target state="translated">'new'키워드로 함수를 호출 할 때 발생하는 변경 사항을 실제로 보려면 함수를 작성하고 'new'키워드를 사용하여 호출 한 다음 'new'키워드를 볼 때 인터프리터가 수행하는 작업을 보여 드리겠습니다. 최종 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f002fd0a5d473826ead53b980392d6392a7e2430" translate="yes" xml:space="preserve">
          <source>Unlike a service which is a simplified version of &lt;em&gt;factory&lt;/em&gt;, a provider is a more complex, but more flexible way of initializing the &quot;global&quot; variables, with the biggest flexibility being the option to set values from the app.config.</source>
          <target state="translated">&lt;em&gt;팩토리&lt;/em&gt; 의 단순화 된 버전 인 서비스와 달리, 제공자는 &quot;글로벌&quot;변수를 초기화하는 더 복잡하지만 더 유연한 방법이며, 가장 큰 유연성은 app.config에서 값을 설정하는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="864ea43a8c2da87a50b0e143c273a5376c32245f" translate="yes" xml:space="preserve">
          <source>Unlike what we originally did with the Factory example, we don&amp;rsquo;t need to create an object then return that object because, like mentioned many times before, we used the &amp;lsquo;new&amp;rsquo; keyword so the interpreter will create that object, have it delegate to it&amp;rsquo;s prototype, then return it for us without us having to do the work.</source>
          <target state="translated">우리가 팩토리 예제로 원래했던 것과는 달리, 우리는 객체를 생성 할 필요가 없습니다. 이전에 여러 번 언급했듯이 인터프리터가 해당 객체를 생성하고 위임 할 수 있도록 'new'키워드를 사용했기 때문입니다. 그것은 프로토 타입이고, 우리가 작업을하지 않아도 우리를 위해 그것을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="b49caeb887a29a8bada2966d7c2590d853f20723" translate="yes" xml:space="preserve">
          <source>Usage (as an injectable in a controller)</source>
          <target state="translated">사용법 (컨트롤러에 주 사용으로)</target>
        </trans-unit>
        <trans-unit id="879ae7be1e519b410069e2f401b1f3f754b21f05" translate="yes" xml:space="preserve">
          <source>Usage (configuring the provider before &lt;code&gt;$get&lt;/code&gt; is called to create the injectable)</source>
          <target state="translated">사용법 (injectable을 만들기 &lt;code&gt;$get&lt;/code&gt; 을 호출하기 전에 공급자 구성)</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="4022b8a59a0d0d2ca89f1ecfac78f71d1bc33304" translate="yes" xml:space="preserve">
          <source>Use it when you need to share a single object throughout the application. For example, authenticated user details, share-able methods/data, Utility functions etc.</source>
          <target state="translated">응용 프로그램 전체에서 단일 객체를 공유해야 할 때 사용하십시오. 예를 들어, 인증 된 사용자 정보, 공유 가능한 방법 / 데이터, 유틸리티 기능 등</target>
        </trans-unit>
        <trans-unit id="c140efc7adf0e2b8a74e6393e081cb7475561437" translate="yes" xml:space="preserve">
          <source>Use this link for code reference</source>
          <target state="translated">코드 참조를 위해이 링크를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="be9209121182255216aaa47dfd1cae1b29bb43e3" translate="yes" xml:space="preserve">
          <source>Using as reference this page and the &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;documentation&lt;/a&gt; (which seems to have greatly improved since the last time I looked), I put together the following real(-ish) world demo which uses 4 of the 5 flavours of provider; Value, Constant, Factory and full blown Provider.</source>
          <target state="translated">이 페이지와 &lt;a href=&quot;https://docs.angularjs.org/guide/providers&quot;&gt;문서&lt;/a&gt; (마지막으로 본 이후 크게 향상 된 것 같습니다)를 참조로 사용하여 5 가지 종류의 공급자 중 4 가지를 사용하는 다음과 같은 실제 (-ish) 세계 데모를 작성했습니다. 가치, 상수, 공장 및 완전 공급 업체.</target>
        </trans-unit>
        <trans-unit id="7f1b9dfcd80673ff780bfe6c9e4b747b202f04d5" translate="yes" xml:space="preserve">
          <source>Using the factory() in our app</source>
          <target state="translated">앱에서 factory () 사용하기</target>
        </trans-unit>
        <trans-unit id="93312e4afaa947b3a60bfa6bea40f131935883a5" translate="yes" xml:space="preserve">
          <source>Visibility of injectables is different for providers than it is for services and factories. If you declare an AngularJS &quot;constant&quot; (for example, &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt;), you can inject it into services, factories, and providers.</source>
          <target state="translated">주사제의 가시성은 서비스 및 공장과는 공급자가 다릅니다. AngularJS &quot;constant&quot;(예 : &lt;code&gt;myApp.constant('a', 'Robert');&lt;/code&gt; )를 선언하면이를 서비스, 팩토리 및 제공자에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d22cafa4fcd376a2f27d8c4831e76c2f8fa630f7" translate="yes" xml:space="preserve">
          <source>We are going to create setArtist and getArtist methods that simply return or set the artist. We are also going to create a method that will call the iTunes API with our created URL. This method is going to return a promise that will fulfill once the data has come back from the iTunes API. If you haven&amp;rsquo;t had much experience using promises in AngularJS, I highly recommend doing a deep dive on them.</source>
          <target state="translated">아티스트를 반환하거나 설정하는 setArtist 및 getArtist 메소드를 작성하려고합니다. 또한 생성 된 URL을 사용하여 iTunes API를 호출하는 메소드를 작성하려고합니다. 이 방법은 일단 데이터가 iTunes API에서 돌아 오면 이행 할 수있는 약속을 반환합니다. AngularJS에서 약속을 사용한 경험이 많지 않은 경우 약속을 자세히 살펴 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c68ba4741829821c5273926306c848fe58e787c7" translate="yes" xml:space="preserve">
          <source>We can create configurable services using provider syntax as given below.</source>
          <target state="translated">아래와 같이 제공자 구문을 사용하여 구성 가능한 서비스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe235285ce55886f522548de7d34e5b6a156187" translate="yes" xml:space="preserve">
          <source>We can define a factory function as below.</source>
          <target state="translated">팩토리 함수를 아래와 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dc701ea399c4055cce4573cf97749a703eb7d4a" translate="yes" xml:space="preserve">
          <source>What are the differences between a &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Provider&lt;/code&gt; and &lt;code&gt;Factory&lt;/code&gt; in AngularJS?</source>
          <target state="translated">AngularJS에서 &lt;code&gt;Service&lt;/code&gt; , &lt;code&gt;Provider&lt;/code&gt; 및 &lt;code&gt;Factory&lt;/code&gt; 의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1d97deb201bb1447c8de5b02c7b3a99898edb8b5" translate="yes" xml:space="preserve">
          <source>When Angular injects this &lt;code&gt;MyService&lt;/code&gt; service into a controller that
  depends on it, that controller will get a &lt;code&gt;MyService&lt;/code&gt; that it can call
  functions on, e.g. MyService.aServiceMethod ().</source>
          <target state="translated">Angular가이 &lt;code&gt;MyService&lt;/code&gt; 서비스를이 서비스에 의존하는 컨트롤러에 주입하면 해당 컨트롤러는 함수를 호출 할 수있는 &lt;code&gt;MyService&lt;/code&gt; 를 가져옵니다 (예 : MyService.aServiceMethod ()).</target>
        </trans-unit>
        <trans-unit id="71e6a586496bb64a15227083621aef43a2714aea" translate="yes" xml:space="preserve">
          <source>When creating a service with Provider, the only properties/methods that will be available in your controller are those properties/methods which are returned from the $get() function. The code below puts $get on &amp;lsquo;this&amp;rsquo; (which we know will eventually be returned from that function). Now, that $get function returns all the methods/properties we want to be available in the controller. Here&amp;rsquo;s a code example.</source>
          <target state="translated">Provider로 서비스를 생성 할 때 컨트롤러에서 사용할 수있는 유일한 속성 / 방법은 $ get () 함수에서 반환되는 속성 / 방법입니다. 아래 코드는 $ get을 'this'에 넣습니다 (우리는 결국 해당 함수에서 반환 됨). 이제 $ get 함수는 컨트롤러에서 사용할 수있는 모든 메서드 / 속성을 반환합니다. 다음은 코드 예입니다.</target>
        </trans-unit>
        <trans-unit id="3bc3b865d96d4a3942513d9897a3bb409a798a5a" translate="yes" xml:space="preserve">
          <source>When making a &lt;code&gt;service()&lt;/code&gt; it return you providing a factory() with a &lt;code&gt;function&lt;/code&gt; that injects the &lt;code&gt;constructor&lt;/code&gt; (return the instance of the constructor you provided in your service) and returns it</source>
          <target state="translated">&lt;code&gt;service()&lt;/code&gt; 만들면 &lt;code&gt;constructor&lt;/code&gt; 를 주입하는 &lt;code&gt;function&lt;/code&gt; 와 함께 factory ()를 제공하고 (서비스에서 제공 한 생성자의 인스턴스를 반환) 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6d43abc5bb66cd755013d3ef82d0ae0e0cc46c8" translate="yes" xml:space="preserve">
          <source>When you make a &lt;code&gt;factory()&lt;/code&gt; it sets you &lt;code&gt;function&lt;/code&gt; provided in second argument to provider's &lt;code&gt;$get&lt;/code&gt; and return it(&lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt;),</source>
          <target state="translated">&lt;code&gt;factory()&lt;/code&gt; 를 만들면 공급자의 &lt;code&gt;$get&lt;/code&gt; 에 두 번째 인수로 제공된 &lt;code&gt;function&lt;/code&gt; 설정하고 반환합니다 ( &lt;code&gt;provider(name, {$get:factoryFn })&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="45f317e75b95e397ea00208400104d4fe8bf5e18" translate="yes" xml:space="preserve">
          <source>When you need to provide module-wise configuration for your service object before making it available, eg. suppose you want to set your API URL on basis of your Environment like &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;stage&lt;/code&gt; or &lt;code&gt;prod&lt;/code&gt;</source>
          <target state="translated">서비스 개체를 사용하기 전에 모듈 단위 구성을 제공해야하는 경우 (예 : &lt;code&gt;dev&lt;/code&gt; , &lt;code&gt;stage&lt;/code&gt; 또는 &lt;code&gt;prod&lt;/code&gt; 와 같은 환경을 기반으로 API URL을 설정한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2d9813216aceb4fb52c9772759aad11c548dbb06" translate="yes" xml:space="preserve">
          <source>Which means there&amp;rsquo;s something like a cache object inside AngularJS, whose value of each injection is only assigned once, when they've been injected the first time, and where:</source>
          <target state="translated">이는 AngularJS 내부에 캐시 객체와 같은 것을 의미합니다. 각 주입 값은 처음 주입되었을 때 한 번만 할당되며 어디서 :</target>
        </trans-unit>
        <trans-unit id="9a5bdc65b2c24b100cbcaaaa5059622b099681ae" translate="yes" xml:space="preserve">
          <source>While global variables are not recommended, the real usage of these global variables is to provide &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;dependency injection&lt;/a&gt;, by passing the variable to the relevant controller.</source>
          <target state="translated">전역 변수는 권장되지 않지만 이러한 전역 변수의 실제 사용법은 변수를 관련 컨트롤러에 전달하여 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;종속성 주입&lt;/a&gt; 을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5f5a2ae1fcba7052d4d70638cf84ffe0eb2743b" translate="yes" xml:space="preserve">
          <source>Working &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;demo&lt;/a&gt;.</source>
          <target state="translated">작업 &lt;a href=&quot;http://jsfiddle.net/net_uk_sweet/6ubnppnu/1/&quot;&gt;데모&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b3d2c4eb971fcbd43812638af12c7dc4437f9c" translate="yes" xml:space="preserve">
          <source>Working Demo</source>
          <target state="translated">실무 데모</target>
        </trans-unit>
        <trans-unit id="9fd4dd933fe260f137acd6eae3ea36eb6536140b" translate="yes" xml:space="preserve">
          <source>You can think of Providers as having three sections. The first section is the &amp;lsquo;private&amp;rsquo; variables/functions that will be modified/set later (shown above). The second section is the variables/functions that will be available in your app.config function and are therefore available to alter before they&amp;rsquo;re available anywhere else (also shown above). It&amp;rsquo;s important to note that those variables need to be attached to the &amp;lsquo;this&amp;rsquo; keyword. In our example, only &amp;lsquo;thingFromConfig&amp;rsquo; will be available to alter in the app.config. The third section (shown below) is all the variables/functions that will be available in your controller when you pass in the &amp;lsquo;myProvider&amp;rsquo; service into that specific controller.</source>
          <target state="translated">제공자는 3 개의 섹션이 있다고 생각할 수 있습니다. 첫 번째 섹션은 나중에 수정 / 설정 될 '비공개'변수 / 함수입니다 (위 그림 참조). 두 번째 섹션은 app.config 함수에서 사용할 수있는 변수 / 함수이므로 다른 곳에서 사용 가능하기 전에 변경할 수 있습니다 (위에 표시됨). 이러한 변수는 'this'키워드에 첨부해야합니다. 이 예에서는 app.config에서 'thingFromConfig'만 변경할 수 있습니다. 세 번째 섹션 (아래 참조)은 'myProvider'서비스를 특정 컨트롤러로 전달할 때 컨트롤러에서 사용할 수있는 모든 변수 / 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8b95d0adc56d83fa7498365437f66e79ee788966" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to return a value. When Angular calls &lt;code&gt;new yourServiceName(&lt;/code&gt;), it&amp;rsquo;ll receive the &lt;code&gt;this&lt;/code&gt; object with all the properties you put on it.</source>
          <target state="translated">값을 반환하지 않아도됩니다. Angular가 &lt;code&gt;new yourServiceName(&lt;/code&gt; )을 호출하면 모든 속성 &lt;code&gt;this&lt;/code&gt; 객체를받습니다.</target>
        </trans-unit>
        <trans-unit id="3fe544a5098b0be6e451614ad5ff4af0887aea93" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will cache and inject the return value when the factory is requested.</source>
          <target state="translated">AngularJS에 함수를 제공하면 AngularJS는 팩토리가 요청 될 때 리턴 값을 캐시하고 주입합니다.</target>
        </trans-unit>
        <trans-unit id="7733853022202a91bba391de813e5ef65f7cfeb5" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, AngularJS will call &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; to instantiate it. It is the instance that AngularJS creates that will be cached and injected when the service is requested. Since &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; was used to instantiate the service, the keyword &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; is valid and refers to the instance.</source>
          <target state="translated">AngularJS에 함수를 제공하면 AngularJS는 &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; 를 호출하여 인스턴스화합니다. AngularJS가 작성하는 인스턴스는 서비스가 요청 될 때 캐시되고 주입됩니다. &lt;strong&gt;&lt;em&gt;new&lt;/em&gt;&lt;/strong&gt; 가 서비스를 인스턴스화하는 데 사용되었으므로 &lt;strong&gt;&lt;em&gt;this&lt;/em&gt;&lt;/strong&gt; 키워드는 유효하며 인스턴스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a2a1ff92c50375a3fdf5b1809ff8ea225aab5a9c" translate="yes" xml:space="preserve">
          <source>You give AngularJS a function, and AngularJS will call its &lt;code&gt;$get&lt;/code&gt; function. It is the return value from the &lt;code&gt;$get&lt;/code&gt; function that will be cached and injected when the service is requested.</source>
          <target state="translated">AngularJS에 함수를 제공하면 AngularJS는 &lt;code&gt;$get&lt;/code&gt; 함수를 호출합니다. 서비스가 요청 될 때 캐시되고 주입되는 &lt;code&gt;$get&lt;/code&gt; 함수의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="3876a0940a5a7dd665609735ebfa32e7f6e1bcc3" translate="yes" xml:space="preserve">
          <source>You just have a standard function that uses this keyword to define a function.</source>
          <target state="translated">이 키워드를 사용하여 함수를 정의하는 표준 함수 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="866717a4969cced464a5c0ae6684faada33bde94" translate="yes" xml:space="preserve">
          <source>You might be tempted to call &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; in a promise chain, for instance if you initialized the score by grabbing it from the server: &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; The trouble with this is that &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; will be called with &lt;code&gt;this&lt;/code&gt; bound to &lt;code&gt;null&lt;/code&gt; and you&amp;rsquo;ll get errors. The better way would be &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt;.
Whether you choose to use this in your service methods or not, be careful how you call them.</source>
          <target state="translated">서버에서 점수를 &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore).&lt;/code&gt; 와 같이 약속 체인에서 &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; 를 호출하려는 유혹이있을 수 있습니다 . 이 문제는 &lt;code&gt;null&lt;/code&gt; 에 바인딩 된 &lt;code&gt;ScoreKeeper.setScore&lt;/code&gt; 가 호출되고 오류가 발생한다는 것입니다. 더 좋은 방법은 &lt;code&gt;$http.get('/score').then(ScoreKeeper.setScore.bind(ScoreKeeper))&lt;/code&gt; 입니다. 이를 서비스 방법에 사용하기로 선택했는지 여부에 관계없이 호출 방법에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="bea982bb9c2f6821b3f44edf8dad402dddc73177" translate="yes" xml:space="preserve">
          <source>You should use the Provider recipe only when you want to expose an API
  for application-wide configuration that must be made before the
  application starts. This is usually interesting only for reusable
  services whose behavior might need to vary slightly between
  applications.</source>
          <target state="translated">응용 프로그램을 시작하기 전에 작성해야하는 응용 프로그램 전체 구성에 대한 API를 노출하려는 경우에만 제공자 레시피를 사용해야합니다. 이는 일반적으로 응용 프로그램마다 동작이 약간 씩 다를 수있는 재사용 가능한 서비스에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c5956833324972c28737ee048ed90ebe091ca59b" translate="yes" xml:space="preserve">
          <source>_artist is the artist we wish to lookup</source>
          <target state="translated">_artist는 검색하고자하는 아티스트입니다.</target>
        </trans-unit>
        <trans-unit id="72921d9d0e40db1cd6390dcc0077ecda67c652ba" translate="yes" xml:space="preserve">
          <source>_finalUrl is the final and fully built URL to which we&amp;rsquo;ll make the call to iTunes</source>
          <target state="translated">_finalUrl은 iTunes를 호출 할 최종 완성 된 URL입니다.</target>
        </trans-unit>
        <trans-unit id="0bfda8d377c2609cd9d50c5b636b767072ce4e18" translate="yes" xml:space="preserve">
          <source>ability to use other services (have dependencies)</source>
          <target state="translated">다른 서비스를 사용할 수있는 능력</target>
        </trans-unit>
        <trans-unit id="6a925e5ed5ce5e858b8242994457f2ab7ac71782" translate="yes" xml:space="preserve">
          <source>all you get is &lt;code&gt;provider&lt;/code&gt; but there is no property/method other than &lt;code&gt;$get&lt;/code&gt;</source>
          <target state="translated">당신이 얻는 것은 &lt;code&gt;provider&lt;/code&gt; 이지만 &lt;code&gt;$get&lt;/code&gt; 이외의 속성 / 방법은 없습니다</target>
        </trans-unit>
        <trans-unit id="0d27b037fa89342a90ff5d6df4947c9eece46029" translate="yes" xml:space="preserve">
          <source>and returns &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">그리고 &lt;code&gt;this&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="402433d1fb629334beefb9cb164a7a1c035c71e7" translate="yes" xml:space="preserve">
          <source>and using:</source>
          <target state="translated">그리고 사용 :</target>
        </trans-unit>
        <trans-unit id="427c1761ab15aa547603cd68334d242a2d5523d9" translate="yes" xml:space="preserve">
          <source>baseUrl is the base URL that the iTunes API requires</source>
          <target state="translated">baseUrl은 iTunes API에 필요한 기본 URL입니다</target>
        </trans-unit>
        <trans-unit id="2cdaa8f3ceef76f1dc730a6b60c06476e795c676" translate="yes" xml:space="preserve">
          <source>basically what happens is</source>
          <target state="translated">기본적으로 일어나는 일은</target>
        </trans-unit>
        <trans-unit id="b50ae779a31c55dd00a1f71d908a312cbc40af0a" translate="yes" xml:space="preserve">
          <source>connects &lt;code&gt;context&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; 를 연결 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54bf3f1ce25250844230f2deb1ca4ace3b97b315" translate="yes" xml:space="preserve">
          <source>creates brand new object</source>
          <target state="translated">새로운 물건을 만듭니다</target>
        </trans-unit>
        <trans-unit id="deb0c5efabe5381fec4da90741ac9ac67289b4ec" translate="yes" xml:space="preserve">
          <source>delayed/lazy initialization</source>
          <target state="translated">지연 / 지연 초기화</target>
        </trans-unit>
        <trans-unit id="0188b442c8481c48fffbded6f20f1d6cded3c775" translate="yes" xml:space="preserve">
          <source>how Factory, Service and Constant &amp;mdash; are just syntactic sugar on top of a provider recipe?</source>
          <target state="translated">어떻게 Factory, Service 및 Constant &amp;mdash; 공급자 레시피 위에 구문 설탕입니까?</target>
        </trans-unit>
        <trans-unit id="8f55d557046d81d78de7516299b50060cdf7c55b" translate="yes" xml:space="preserve">
          <source>how factory ,servic and providers are simailar internally</source>
          <target state="translated">공장, 서비스 및 공급자가 내부적으로 어떻게 simailar인가</target>
        </trans-unit>
        <trans-unit id="ce1ed02a506c79b6518185593802fbb4aaa54d8a" translate="yes" xml:space="preserve">
          <source>links it to its &lt;code&gt;prototype&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; 객체에 연결</target>
        </trans-unit>
        <trans-unit id="1e4306c581e1c078a3c92df9bd0a6162776ce8e8" translate="yes" xml:space="preserve">
          <source>makeUrl is a function that will create and return our iTunes friendly URL.</source>
          <target state="translated">makeUrl은 iTunes 친화적 인 URL을 생성하고 반환하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ba23da34d1e3b19225a60f4a7206e21e32aad969" translate="yes" xml:space="preserve">
          <source>of that &lt;code&gt;provider&lt;/code&gt;(means you can't configure this)</source>
          <target state="translated">해당 &lt;code&gt;provider&lt;/code&gt; (이것을 구성 할 수 없음을 의미)</target>
        </trans-unit>
        <trans-unit id="6192271d0d781e240956f0b4f5271f3d5d92ac46" translate="yes" xml:space="preserve">
          <source>service initialization</source>
          <target state="translated">서비스 초기화</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
