<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/15112125">
    <body>
      <group id="15112125">
        <trans-unit id="bb13107891e34020b269948fd348a93b39b4cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array[sum]&lt;/code&gt; gives you the string.</source>
          <target state="translated">&lt;code&gt;array[sum]&lt;/code&gt; 为您提供字符串。</target>
        </trans-unit>
        <trans-unit id="00588cd0b67586a0cf5791fdbf34e87aeb48bde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x or y or z&lt;/code&gt; would evaluate to the first argument that is 'truthy', e.g. not &lt;code&gt;False&lt;/code&gt;, numeric 0 or empty (see &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;boolean expressions&lt;/a&gt; for details on what Python considers false in a boolean context).</source>
          <target state="translated">&lt;code&gt;x or y or z&lt;/code&gt; 将求值为&amp;ldquo;真实&amp;rdquo;的第一个参数，例如，不是 &lt;code&gt;False&lt;/code&gt; ，数字0或空（有关&lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;布尔&lt;/a&gt;值上下文中Python认为是false的详细信息，请参见布尔表达式 ）。</target>
        </trans-unit>
        <trans-unit id="7333a0715f136dc925dd2e84ffcbba4920732a15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are otherwise evaluated on their own (&lt;code&gt;False&lt;/code&gt; if &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; otherwise).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 单独评估（如果为 &lt;code&gt;0&lt;/code&gt; ，则为 &lt;code&gt;False&lt;/code&gt; ，否则为 &lt;code&gt;True&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a927e3bcbbb2295c65e1e58e0e35bd1f4c7006df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I test one variable against multiple values?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何针对多个值测试一个变量？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a411154b01054dc56c3b27fc9ca455c9da17006" translate="yes" xml:space="preserve">
          <source>A much more generalized approach is this:</source>
          <target state="translated">更为笼统的做法是:</target>
        </trans-unit>
        <trans-unit id="e613cc0a40046d91ea55a26346590841af7fd423" translate="yes" xml:space="preserve">
          <source>After this you may form predefined array where index of string elements would correspond to ready string.</source>
          <target state="translated">在这之后,你可以形成预定义的数组,其中字符串元素的索引将对应于准备好的字符串。</target>
        </trans-unit>
        <trans-unit id="95917ca908e6a3eb5ee61cafb13cfde8ae85cc8b" translate="yes" xml:space="preserve">
          <source>All of the excellent answers provided here concentrate on the specific requirement of the original poster and concentrate on the &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; solution put forward by Martijn Pieters.</source>
          <target state="translated">这里提供的所有出色答案都集中于原始海报的特定要求，并集中于Martijn Pieters提出的 &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; 解决方案。</target>
        </trans-unit>
        <trans-unit id="6428e53a1aeab2edcca1712fc8659b2bade6a9ae" translate="yes" xml:space="preserve">
          <source>Another lazy way I found is :</source>
          <target state="translated">我找到的另一个偷懒方法是:</target>
        </trans-unit>
        <trans-unit id="9019a09f9020d12c4c096c111a5eb6ce502a60af" translate="yes" xml:space="preserve">
          <source>Another option for checking if there is a non-zero (or False) value in a list:</source>
          <target state="translated">另一个检查列表中是否有非零(或False)值的选项。</target>
        </trans-unit>
        <trans-unit id="463015b4b607a45b6c5d9adefdb7bafe8183b458" translate="yes" xml:space="preserve">
          <source>As stated by Martijn Pieters, the correct, and fastest, format is:</source>
          <target state="translated">正如Martijn Pieters所言,正确、最快的格式是:</target>
        </trans-unit>
        <trans-unit id="b240cced7ab44159f960aafdc13c958949221c61" translate="yes" xml:space="preserve">
          <source>BTW lots of &lt;code&gt;if&lt;/code&gt;s could be written as something like this</source>
          <target state="translated">顺便说一句， &lt;code&gt;if&lt;/code&gt; 可以这样写</target>
        </trans-unit>
        <trans-unit id="6713674f00a4357f6ef85c6bce361231e4a206d2" translate="yes" xml:space="preserve">
          <source>Bool is an inbuilt function in python which basically does the command of verifying a boolean statement (If you don't know what that is, it is what you are trying to make in your if statement right now :))</source>
          <target state="translated">Bool是python中的一个内置函数,它基本上可以完成验证一个布尔语句的命令(如果你不知道那是什么,那就是你现在要在if语句中做的)。</target>
        </trans-unit>
        <trans-unit id="41b6db522df83ba9a596e29f6f04d041013d9cf2" translate="yes" xml:space="preserve">
          <source>But I dont think, you like it. :)
And this way is ugly.</source>
          <target state="translated">但我不认为,你喜欢。)这条路很难看。</target>
        </trans-unit>
        <trans-unit id="f4385a198702e69c09bb82aff84c16ebf742dbdb" translate="yes" xml:space="preserve">
          <source>But we want to have</source>
          <target state="translated">但是,我们要有</target>
        </trans-unit>
        <trans-unit id="a27faa698dab470f11161204c4a25e5d0917c8c9" translate="yes" xml:space="preserve">
          <source>Change our conditions as:</source>
          <target state="translated">改变我们的条件为:</target>
        </trans-unit>
        <trans-unit id="b780eb53e7528543c4484d24e4b30675cddf5319" translate="yes" xml:space="preserve">
          <source>Connect these formulas by following logic:</source>
          <target state="translated">按照下面的逻辑,将这些公式连接起来。</target>
        </trans-unit>
        <trans-unit id="23c906d120f6bb0d28e6c4b2296e9f78b4cc0aa1" translate="yes" xml:space="preserve">
          <source>Create mapping of values (in the order you want to check):</source>
          <target state="translated">创建值的映射(按你想检查的顺序)。</target>
        </trans-unit>
        <trans-unit id="b3d64112baa428adb20e8915b333e2ce6d199205" translate="yes" xml:space="preserve">
          <source>Declare variables:</source>
          <target state="translated">申报变量。</target>
        </trans-unit>
        <trans-unit id="9b5b165b041692889344ce235bb138eb7edbf45a" translate="yes" xml:space="preserve">
          <source>Equivalent:</source>
          <target state="translated">Equivalent:</target>
        </trans-unit>
        <trans-unit id="3206d3885141933ea46755b030e35361dd3aa53a" translate="yes" xml:space="preserve">
          <source>Finally, use the &lt;code&gt;map&lt;/code&gt; function to create an iterator:</source>
          <target state="translated">最后，使用 &lt;code&gt;map&lt;/code&gt; 函数创建一个迭代器：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="2e3f8c6b28df06279983427242677e0abbd1fa8a" translate="yes" xml:space="preserve">
          <source>How to test multiple variables against a value</source>
          <target state="translated">如何对一个值进行多变量测试</target>
        </trans-unit>
        <trans-unit id="1690068d3a18b79788b305f1805dff9306aea1d4" translate="yes" xml:space="preserve">
          <source>However, even if this were &lt;em&gt;not&lt;/em&gt; the case, and the expression &lt;code&gt;x or y or z == 1&lt;/code&gt; was actually interpreted as &lt;code&gt;(x or y or z) == 1&lt;/code&gt; instead, this would still not do what you expect it to do.</source>
          <target state="translated">但是，即使&lt;em&gt;不是&lt;/em&gt;这种情况，并且表达式 &lt;code&gt;x or y or z == 1&lt;/code&gt; 实际上被解释为 &lt;code&gt;(x or y or z) == 1&lt;/code&gt; ，这仍然不会执行您期望的操作。</target>
        </trans-unit>
        <trans-unit id="c9063492569248924935d1ea9f7cfe6e496aa7dc" translate="yes" xml:space="preserve">
          <source>I think this will handle it better:</source>
          <target state="translated">我觉得这样处理起来会更好。</target>
        </trans-unit>
        <trans-unit id="e7fdd1510849adc6b77d33436dfb1654ceeac78f" translate="yes" xml:space="preserve">
          <source>I'm trying to make a function that will compare multiple variables to an integer and output a string of three letters. I was wondering if there was a way to translate this into Python. So say:</source>
          <target state="translated">我想做一个函数,将多个变量与整数进行比较,并输出一个由三个字母组成的字符串。我想知道有没有一种方法可以将其翻译成Python。这么说吧。</target>
        </trans-unit>
        <trans-unit id="7d80561cbf65d1c0ea7a693c438c4e00577ceedc" translate="yes" xml:space="preserve">
          <source>If this is what you want, the final line can be changed to:</source>
          <target state="translated">如果这是你想要的,最后一行可以改成。</target>
        </trans-unit>
        <trans-unit id="c69952c7d8f578cbfed512cc34620dae72d52a3e" translate="yes" xml:space="preserve">
          <source>If you ARE very very lazy, you can put the values inside an array. Such as</source>
          <target state="translated">如果你非常非常懒,你可以把值放在数组里面。比如说</target>
        </trans-unit>
        <trans-unit id="72a74a2a2fd5c0f05ff83572f16db3bbe8acbc27" translate="yes" xml:space="preserve">
          <source>If you want to use if, else statements following is another solution:</source>
          <target state="translated">如果你想用如果,下面的 else语句是另一种解决方案。</target>
        </trans-unit>
        <trans-unit id="dceda35d497532579aeab70981b2e030e46924a2" translate="yes" xml:space="preserve">
          <source>Imports:</source>
          <target state="translated">Imports:</target>
        </trans-unit>
        <trans-unit id="6b27f3e9d1c3cfdf2ca592d7828d05fc3e224af9" translate="yes" xml:space="preserve">
          <source>Is something like this possible?</source>
          <target state="translated">这样的事情有可能吗?</target>
        </trans-unit>
        <trans-unit id="2bfaf3bf3b08cf7e4ccd8996e5fed256fbd43ffe" translate="yes" xml:space="preserve">
          <source>It can be done easily as</source>
          <target state="translated">它可以很容易完成,因为</target>
        </trans-unit>
        <trans-unit id="866644b51b9d40ebeffc45ee2336b9f986861514" translate="yes" xml:space="preserve">
          <source>It should be noted however, as mentioned by &lt;code&gt;@codeforester&lt;/code&gt;, that word boundries are lost with this method, as in:</source>
          <target state="translated">但是应注意，如 &lt;code&gt;@codeforester&lt;/code&gt; 所述 ，此方法会丢失单词边界，例如：</target>
        </trans-unit>
        <trans-unit id="0c7d38a7015e5383cb6fc3ee40ad8694bcba4672" translate="yes" xml:space="preserve">
          <source>Let's map to bits: &lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt;</source>
          <target state="translated">让我们映射 &lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt; ： 'c'：1'd'：0xb10'e'：0xb100'f'：0xb1000</target>
        </trans-unit>
        <trans-unit id="b76db2cdb6855d81571463add9d07d4e3fcf49f0" translate="yes" xml:space="preserve">
          <source>Looks like you're building some kind of Caesar cipher.</source>
          <target state="translated">看来你在建立某种凯撒密码。</target>
        </trans-unit>
        <trans-unit id="8be0a31f87a698daba296424953326b97e6ca455" translate="yes" xml:space="preserve">
          <source>Maybe you need direct formula for output bits set.</source>
          <target state="translated">也许你需要直接用公式输出位设置。</target>
        </trans-unit>
        <trans-unit id="db2986760ee39be8694759a7e5ec189dead87b8f" translate="yes" xml:space="preserve">
          <source>Not sure if it's a desired side effect of your code, but the order of your output will always be sorted.</source>
          <target state="translated">不知道这是否是你的代码所希望的副作用,但你的输出顺序总是会被排序。</target>
        </trans-unit>
        <trans-unit id="8bb632d18f18c3ca5e853e32c7ff5745a62aec16" translate="yes" xml:space="preserve">
          <source>One generalization of the previous expression is based on the answer from &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt;:</source>
          <target state="translated">先前表达式的一种概括是基于&lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt;的答案：</target>
        </trans-unit>
        <trans-unit id="e90d1db2c08d51cdaf3208d19c329897e23d3bf2" translate="yes" xml:space="preserve">
          <source>One line solution:</source>
          <target state="translated">一条线的解决方案。</target>
        </trans-unit>
        <trans-unit id="b9e703ebdcfd19c006b401c977efdb5773365151" translate="yes" xml:space="preserve">
          <source>One more thing, your</source>
          <target state="translated">还有一件事,你的</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="1a9aedec59b804a602ad84ba70cbffa39d7afe06" translate="yes" xml:space="preserve">
          <source>Relation of isc (is 'c'):</source>
          <target state="translated">ISC的关系(是'C')。</target>
        </trans-unit>
        <trans-unit id="c47635a32643194fa5c1d73ffb3364cb2ce7e2a8" translate="yes" xml:space="preserve">
          <source>Set is the good approach here, because it orders the variables, what seems to be your goal here. &lt;code&gt;{z,y,x}&lt;/code&gt; is &lt;code&gt;{0,1,3}&lt;/code&gt; whatever the order of the parameters.</source>
          <target state="translated">Set在这里是一种很好的方法，因为它对变量进行排序，这似乎是您的目标。 无论参数的顺序如何 &lt;code&gt;{z,y,x}&lt;/code&gt; 均为 &lt;code&gt;{0,1,3}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5bddac5fdbd073da63065edd9f73643283d8644" translate="yes" xml:space="preserve">
          <source>So for the values &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt;, &lt;code&gt;x or y or z&lt;/code&gt; would resolve to &lt;code&gt;2&lt;/code&gt;, because that is the first true-like value in the arguments. Then &lt;code&gt;2 == 1&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;, even though &lt;code&gt;y == 1&lt;/code&gt; would be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">因此对于值 &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt; y = 1； z = 0 ， &lt;code&gt;x or y or z&lt;/code&gt; 将解析为 &lt;code&gt;2&lt;/code&gt; ，因为这是参数中的第一个真值。 那么，即使 &lt;code&gt;y == 1&lt;/code&gt; 为 &lt;code&gt;True&lt;/code&gt; ， &lt;code&gt;2 == 1&lt;/code&gt; 也将为 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="3c900b3d5f08fdcdc1f78f0317f9c51f8053bb56" translate="yes" xml:space="preserve">
          <source>Test if the string &quot;Wild&quot; is in multiple values</source>
          <target state="translated">测试字符串 &quot;Wild &quot;是否有多个值</target>
        </trans-unit>
        <trans-unit id="c927be0e598ed66db0dc371da49441cdc8cadf17" translate="yes" xml:space="preserve">
          <source>The direct way to write &lt;code&gt;x or y or z == 0&lt;/code&gt; is</source>
          <target state="translated">写 &lt;code&gt;x or y or z == 0&lt;/code&gt; 的直接方法是</target>
        </trans-unit>
        <trans-unit id="fc79ed71050b9a0c16fbfdf7c524bf2d41b13800" translate="yes" xml:space="preserve">
          <source>The most mnemonic way of representing your pseudo-code in Python would be:</source>
          <target state="translated">用Python表示你的伪代码的最形象的方式是。</target>
        </trans-unit>
        <trans-unit id="04b4257a2c3bf690535db945de6a3fab6f05b7ed" translate="yes" xml:space="preserve">
          <source>The other way (a better) is:</source>
          <target state="translated">另一种方式(更好)是:</target>
        </trans-unit>
        <trans-unit id="3791bfd4543d9a856e18c50dbc04720b33ace4b2" translate="yes" xml:space="preserve">
          <source>The same would apply to the inverse; testing multiple values against a single variable; &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; would fail for the same reasons. Use &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; or &lt;code&gt;x in {1, 2, 3}&lt;/code&gt;.</source>
          <target state="translated">反之亦然。 针对单个变量测试多个值； &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; 会由于相同的原因而失败。 &lt;code&gt;x in {1, 2, 3}&lt;/code&gt; 使用 &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; 或x 。</target>
        </trans-unit>
        <trans-unit id="41fa9fcaf3429d85247374d4e6bd0000c1558845" translate="yes" xml:space="preserve">
          <source>The solution provided will not work for partial hits if using strings for example:</source>
          <target state="translated">如果使用字符串,所提供的解决方案对于部分点击率将不起作用。</target>
        </trans-unit>
        <trans-unit id="68d01441f9f74a616b4d6a83968653d4293606f8" translate="yes" xml:space="preserve">
          <source>The upshot being, be careful with your search criteria if using this method and be aware that it does have this limitation.</source>
          <target state="translated">最后的结果是,如果使用这种方法,要小心你的搜索标准,并注意它确实有这个限制。</target>
        </trans-unit>
        <trans-unit id="6b968f041fb97521d879885b45db4504e7a1b225" translate="yes" xml:space="preserve">
          <source>Then, when checking for the values (in the original order), use &lt;code&gt;next()&lt;/code&gt;:</source>
          <target state="translated">然后，在检查值时（按原始顺序），请使用 &lt;code&gt;next()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="244cf7d4aacadf87fa117ebf501e2c69320b9911" translate="yes" xml:space="preserve">
          <source>This code may be helpful</source>
          <target state="translated">这个代码可能会有帮助</target>
        </trans-unit>
        <trans-unit id="b603f08a1f26476f174439270377be0254a39c6b" translate="yes" xml:space="preserve">
          <source>This has an advantage over the &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; because &lt;code&gt;operator&lt;/code&gt; is an inbuilt module and is faster and more efficient than using &lt;code&gt;lambda&lt;/code&gt; which has to create a custom in-place function.</source>
          <target state="translated">与 &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; 相比，它具有一个优势，因为 &lt;code&gt;operator&lt;/code&gt; 是一个内置模块，比使用必须创建自定义就地函数的 &lt;code&gt;lambda&lt;/code&gt; 更快，更高效。</target>
        </trans-unit>
        <trans-unit id="b76b3b60499b4c2e88bf9b78e6177bbe474e3aec" translate="yes" xml:space="preserve">
          <source>This is due to &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;operator precedence&lt;/a&gt;. The &lt;code&gt;or&lt;/code&gt; operator has a lower precedence than the &lt;code&gt;==&lt;/code&gt; test, so the latter is evaluated &lt;em&gt;first&lt;/em&gt;.</source>
          <target state="translated">这是由于&lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;运算符的优先级&lt;/a&gt; 。 &lt;code&gt;or&lt;/code&gt; 运算符的优先级比 &lt;code&gt;==&lt;/code&gt; 测试低，因此&lt;em&gt;首先&lt;/em&gt;评估后者。</target>
        </trans-unit>
        <trans-unit id="64ddaf83d2f60c93d468c3e3ed9699c922958fe5" translate="yes" xml:space="preserve">
          <source>This way, the whole solution is O(n).</source>
          <target state="translated">这样一来,整个解是O(n)。</target>
        </trans-unit>
        <trans-unit id="976528b0a8c35bea07e6bc2601aec4299b2bbaa5" translate="yes" xml:space="preserve">
          <source>This will help you.</source>
          <target state="translated">这将帮助你。</target>
        </trans-unit>
        <trans-unit id="e02cbb19fa7a225098185240eafb7f7ac151e94f" translate="yes" xml:space="preserve">
          <source>This will work, but &lt;em&gt;if&lt;/em&gt; you are comfortable using dictionaries (see what I did there), you can clean this up by making an initial dictionary mapping the numbers to the letters you want, then just using a for-loop:</source>
          <target state="translated">这将起作用，但是&lt;em&gt;如果&lt;/em&gt;您习惯使用字典（请参阅我在那做的事情），则可以通过制作一个初始字典将数字映射到所需字母来进行清理，然后仅使用for循环即可：</target>
        </trans-unit>
        <trans-unit id="9f43c35e265188c85ff1afeb217ad718c6c95ddf" translate="yes" xml:space="preserve">
          <source>To check if a value is contained within a set of variables you can use the inbuilt modules           &lt;code&gt;itertools&lt;/code&gt; and &lt;code&gt;operator&lt;/code&gt;.</source>
          <target state="translated">要检查一组变量中是否包含值，可以使用内置模块 &lt;code&gt;itertools&lt;/code&gt; 和 &lt;code&gt;operator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09e954d89ce8c7bc163dfa546dbd624e5392f2f1" translate="yes" xml:space="preserve">
          <source>To test multiple values with one variable: &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</source>
          <target state="translated">要使用一个变量测试多个值： &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc35f0f0fd5eec1aaf32678ec2edbf03c38ad94" translate="yes" xml:space="preserve">
          <source>To test multiple variables with one single value: &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</source>
          <target state="translated">要用一个值测试多个变量： &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="383327b199376946b76f635409e672afc9428011" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;itertools&lt;/code&gt; to allow repetition of the variables:</source>
          <target state="translated">使用 &lt;code&gt;itertools&lt;/code&gt; 允许重复变量：</target>
        </trans-unit>
        <trans-unit id="da0755287f2d9299b4491cae5b9510ea0010f29b" translate="yes" xml:space="preserve">
          <source>Use math if formula &lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&lt;/a&gt;</source>
          <target state="translated">如果公式&lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&lt;/a&gt;使用数学</target>
        </trans-unit>
        <trans-unit id="e1a45a1688e274b044e5e867e0b1b31411fbb885" translate="yes" xml:space="preserve">
          <source>Using his advice you would now have separate if-statements so that Python will read each statement whether the former were &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. Such as:</source>
          <target state="translated">根据他的建议，您现在将拥有单独的if语句，以便Python可以读取每个语句，无论前者是 &lt;code&gt;True&lt;/code&gt; 还是 &lt;code&gt;False&lt;/code&gt; 。 如：</target>
        </trans-unit>
        <trans-unit id="fa259d374a6e092a09201c87a89ba6bbe7a0a01b" translate="yes" xml:space="preserve">
          <source>What they ignore is the broader implication of the question:</source>
          <target state="translated">他们忽视的是这个问题的更广泛的含义。</target>
        </trans-unit>
        <trans-unit id="465745f8cd0620d2b944ef260d792fc24f700e94" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;or&lt;/code&gt;, python sees each side of the operator as &lt;em&gt;separate&lt;/em&gt; expressions. The expression &lt;code&gt;x or y == 1&lt;/code&gt; is treated as first a boolean test for &lt;code&gt;x&lt;/code&gt;, then if that is False, the expression &lt;code&gt;y == 1&lt;/code&gt; is tested.</source>
          <target state="translated">当您使用 &lt;code&gt;or&lt;/code&gt; ，python会将运算符的每一面视为&lt;em&gt;单独的&lt;/em&gt;表达式。 表达式 &lt;code&gt;x or y == 1&lt;/code&gt; 首先被视为 &lt;code&gt;x&lt;/code&gt; 的布尔测试，然后如果它为False，则测试表达式 &lt;code&gt;y == 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f4f2e41824dc0d2846681f279f695d252a4904" translate="yes" xml:space="preserve">
          <source>While the pattern for testing multiple values</source>
          <target state="translated">虽然测试多值的模式</target>
        </trans-unit>
        <trans-unit id="04351719ba6eeda9d512f672fb8d394087b1da53" translate="yes" xml:space="preserve">
          <source>While this expression returns the right result it is not as readable as the first expression :-(</source>
          <target state="translated">虽然这个表达式返回了正确的结果,但它的可读性不如第一个表达式 :-(</target>
        </trans-unit>
        <trans-unit id="601535d04ee42bf736205a2ff11e82514bc43d41" translate="yes" xml:space="preserve">
          <source>Without dict, try this solution:</source>
          <target state="translated">没有dict,试试这个方案。</target>
        </trans-unit>
        <trans-unit id="d029b61b50b6116720d778dd5928e522a41cc72a" translate="yes" xml:space="preserve">
          <source>You can also put the numbers and letters in a dictionary and do it, but this is probably a LOT more complicated than simply if statements. That's what you get for trying to be extra lazy :)</source>
          <target state="translated">你也可以把数字和字母放到字典里去做,但这可能比简单的if语句要复杂得多。这就是你想偷懒的结果:)</target>
        </trans-unit>
        <trans-unit id="78915cb2d48c3749414c1966fb19060e5b9f882f" translate="yes" xml:space="preserve">
          <source>You can shorten that using a containment test against &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;a tuple&lt;/a&gt;:</source>
          <target state="translated">您可以使用针对&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;元组&lt;/a&gt;的容纳测试来缩短该时间：</target>
        </trans-unit>
        <trans-unit id="b5c68d801513922b97394cc0e56a9e3610a25c00" translate="yes" xml:space="preserve">
          <source>You can try the method shown below. In this method, you will have the freedom to specify/input the number of variables that you wish to enter.</source>
          <target state="translated">你可以尝试下图所示的方法。在这个方法中,你可以自由地指定你想输入的变量数量。</target>
        </trans-unit>
        <trans-unit id="ebeccd592c6dfdcd746344abcf9e515154d74a0c" translate="yes" xml:space="preserve">
          <source>You can unite this</source>
          <target state="translated">你可以把这个统一起来</target>
        </trans-unit>
        <trans-unit id="dfa11c78453d0ec1b15421a18df356fec7612bec" translate="yes" xml:space="preserve">
          <source>You can use dictionary :</source>
          <target state="translated">你可以使用字典。</target>
        </trans-unit>
        <trans-unit id="beb91eb796448d63880344240682408a11304d5e" translate="yes" xml:space="preserve">
          <source>You misunderstand how boolean expressions work; they don't work like an English sentence and guess that you are talking about the same comparison for all names here. You are looking for:</source>
          <target state="translated">你误解了布尔表达式的工作原理;它们的工作原理不像英文句子那样,猜想你在这里说的是所有的名字都是一样的比较。你要找的是。</target>
        </trans-unit>
        <trans-unit id="ab683f096ab964a499ae8d8fde3d963f4031ce86" translate="yes" xml:space="preserve">
          <source>Your problem is more easily addressed with a dictionary structure like:</source>
          <target state="translated">你的问题更容易用字典结构来解决,比如说:</target>
        </trans-unit>
        <trans-unit id="a344f069b3775d64cdc3efb7aab823d855e6f4db" translate="yes" xml:space="preserve">
          <source>[c]: &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[c] ：( &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d05021da9336e43f730afddf3adad2188ed178e" translate="yes" xml:space="preserve">
          <source>[d]: &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[d]： &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d496d3b60cd5b31edb48f670e7aaf9dd3d6898d1" translate="yes" xml:space="preserve">
          <source>and gives:</source>
          <target state="translated">并给予。</target>
        </trans-unit>
        <trans-unit id="706bcd4df4cc5b853edc6bed42ba01c222aa137f" translate="yes" xml:space="preserve">
          <source>and you'll have a total equation
express sum and you have total formula of sum</source>
          <target state="translated">你就会有一个总等式表达式的总和,你就有了总和的总公式</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="ff787af4ae3cbab89d3875936b8cea159bbf1b2c" translate="yes" xml:space="preserve">
          <source>for this scenario it's easiest to convert to a string</source>
          <target state="translated">在这种情况下,最简单的方法是转换为字符串。</target>
        </trans-unit>
        <trans-unit id="a38ef392dd476dd325dae11a6aaa28e439e53f31" translate="yes" xml:space="preserve">
          <source>in one variable.</source>
          <target state="translated">在一个变量中。</target>
        </trans-unit>
        <trans-unit id="0c0690d6bac0cddb8d2eb4dc2ab0532025f7f332" translate="yes" xml:space="preserve">
          <source>is very readable and is working in many situation, there is one pitfall:</source>
          <target state="translated">是很有可读性的,在很多情况下都是有效的,有一个隐患。</target>
        </trans-unit>
        <trans-unit id="b08e37624dce70b48b2a8b003d7ebb49075ab69e" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;and&lt;/code&gt; is the sum of squares of equations</source>
          <target state="translated">逻辑 &lt;code&gt;and&lt;/code&gt; 是方程的平方和</target>
        </trans-unit>
        <trans-unit id="50e930613ab6595d07ceb13b02a5a5b7e5384f24" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;or&lt;/code&gt; is the product of equations</source>
          <target state="translated">逻辑 &lt;code&gt;or&lt;/code&gt; 为方程的乘积</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="4c4561e5cc6655de9370d5a62358173a345d902b" translate="yes" xml:space="preserve">
          <source>or better still:</source>
          <target state="translated">或者更好的是:</target>
        </trans-unit>
        <trans-unit id="e71003c6b7dd4093ce139ac0c51a6ba38d54a439" translate="yes" xml:space="preserve">
          <source>outputs</source>
          <target state="translated">outputs</target>
        </trans-unit>
        <trans-unit id="dc6e8247c55b9549a60ed2c399a59de52d6eb88c" translate="yes" xml:space="preserve">
          <source>the 3 letters &lt;code&gt;rot&lt;/code&gt; do exist in combination in the list but not as an individual word. Testing for &quot; rot &quot; would fail but if one of the list items were &quot;rot in hell&quot;, that would fail as well.</source>
          <target state="translated">&lt;code&gt;rot&lt;/code&gt; 的3个字母确实存在于列表中，但不是单个单词。 测试&amp;ldquo;腐烂&amp;rdquo;将失败，但是如果列表项之一是&amp;ldquo;地狱腐烂&amp;rdquo;，那也将失败。</target>
        </trans-unit>
        <trans-unit id="763e6fd8133d4e806ea0b3c7576ce67fc1973840" translate="yes" xml:space="preserve">
          <source>the program will check if the variable is not null. Another way to write the above statement (which makes more sense) is</source>
          <target state="translated">程序将检查该变量是否为空。上述语句的另一种写法(更有意义)是</target>
        </trans-unit>
        <trans-unit id="0d4ee4cc805fe94d1e25296222661ee3d0480bcc" translate="yes" xml:space="preserve">
          <source>then sum&amp;amp;1 is c, sum&amp;amp;2 is d, sum&amp;amp;4 is e, sum&amp;amp;5 is f</source>
          <target state="translated">那么sum＆1是c，sum＆2是d，sum＆4是e，sum＆5是f</target>
        </trans-unit>
        <trans-unit id="4da38f55e44fda425afee7c334f3bbb00da18fa3" translate="yes" xml:space="preserve">
          <source>using &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt;a &lt;code&gt;set&lt;/code&gt;&lt;/a&gt; to take advantage of the constant-cost membership test (&lt;code&gt;in&lt;/code&gt; takes a fixed amount of time whatever the left-hand operand is).</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt;来利用不变成本成员资格测试（无论左侧操作数是多少，都花费固定的时间）。</target>
        </trans-unit>
        <trans-unit id="9e7a7eba74ea8ce2cd328d7a815f59efbd72dcb3" translate="yes" xml:space="preserve">
          <source>which can be written as</source>
          <target state="translated">可写成</target>
        </trans-unit>
        <trans-unit id="9488fbc5a7f3e90e0acdddfadc35548836dda8cd" translate="yes" xml:space="preserve">
          <source>which would return a list of</source>
          <target state="translated">这将返回一个列表</target>
        </trans-unit>
        <trans-unit id="564d92856586976259f387ac0dc96b269f78b744" translate="yes" xml:space="preserve">
          <source>will compile, but not in the way you want it to. When you simply put a variable in an if statement (example)</source>
          <target state="translated">会编译,但不是以你希望的方式编译。当你简单地在if语句中放入一个变量时(例子)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
