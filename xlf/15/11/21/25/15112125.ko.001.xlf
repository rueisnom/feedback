<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/15112125">
    <body>
      <group id="15112125">
        <trans-unit id="bb13107891e34020b269948fd348a93b39b4cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array[sum]&lt;/code&gt; gives you the string.</source>
          <target state="translated">&lt;code&gt;array[sum]&lt;/code&gt; 은 문자열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00588cd0b67586a0cf5791fdbf34e87aeb48bde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x or y or z&lt;/code&gt; would evaluate to the first argument that is 'truthy', e.g. not &lt;code&gt;False&lt;/code&gt;, numeric 0 or empty (see &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;boolean expressions&lt;/a&gt; for details on what Python considers false in a boolean context).</source>
          <target state="translated">&lt;code&gt;x or y or z&lt;/code&gt; 는 'truthy'인 첫 번째 인수 (예 : &lt;code&gt;False&lt;/code&gt; , 숫자 0 또는 비어 있지 않음)로 평가됩니다 (부울 컨텍스트에서 Python이 false로 간주하는 항목에 대한 자세한 내용은 &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;부울 표현식&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="7333a0715f136dc925dd2e84ffcbba4920732a15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are otherwise evaluated on their own (&lt;code&gt;False&lt;/code&gt; if &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; otherwise).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 자체적으로 평가됩니다 ( &lt;code&gt;0&lt;/code&gt; 이면 &lt;code&gt;False&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;True&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a927e3bcbbb2295c65e1e58e0e35bd1f4c7006df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I test one variable against multiple values?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;여러 값에 대해 하나의 변수를 어떻게 테스트합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a411154b01054dc56c3b27fc9ca455c9da17006" translate="yes" xml:space="preserve">
          <source>A much more generalized approach is this:</source>
          <target state="translated">훨씬 더 일반적인 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e613cc0a40046d91ea55a26346590841af7fd423" translate="yes" xml:space="preserve">
          <source>After this you may form predefined array where index of string elements would correspond to ready string.</source>
          <target state="translated">그런 다음 문자열 요소의 색인이 준비된 문자열에 해당하는 사전 정의 된 배열을 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95917ca908e6a3eb5ee61cafb13cfde8ae85cc8b" translate="yes" xml:space="preserve">
          <source>All of the excellent answers provided here concentrate on the specific requirement of the original poster and concentrate on the &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; solution put forward by Martijn Pieters.</source>
          <target state="translated">여기에 제공된 모든 훌륭한 답변은 원래 포스터의 특정 요구 사항에 집중하고 Martijn Pieters가 제시 한 &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; 솔루션의 if 1에 집중합니다.</target>
        </trans-unit>
        <trans-unit id="6428e53a1aeab2edcca1712fc8659b2bade6a9ae" translate="yes" xml:space="preserve">
          <source>Another lazy way I found is :</source>
          <target state="translated">내가 찾은 또 다른 게으른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9019a09f9020d12c4c096c111a5eb6ce502a60af" translate="yes" xml:space="preserve">
          <source>Another option for checking if there is a non-zero (or False) value in a list:</source>
          <target state="translated">목록에 0이 아닌 값 (또는 False)이 있는지 확인하는 또 다른 옵션 :</target>
        </trans-unit>
        <trans-unit id="463015b4b607a45b6c5d9adefdb7bafe8183b458" translate="yes" xml:space="preserve">
          <source>As stated by Martijn Pieters, the correct, and fastest, format is:</source>
          <target state="translated">Martijn Pieters가 말했듯이 정확하고 빠른 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b240cced7ab44159f960aafdc13c958949221c61" translate="yes" xml:space="preserve">
          <source>BTW lots of &lt;code&gt;if&lt;/code&gt;s could be written as something like this</source>
          <target state="translated">BTW 많은 &lt;code&gt;if&lt;/code&gt; s를 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6713674f00a4357f6ef85c6bce361231e4a206d2" translate="yes" xml:space="preserve">
          <source>Bool is an inbuilt function in python which basically does the command of verifying a boolean statement (If you don't know what that is, it is what you are trying to make in your if statement right now :))</source>
          <target state="translated">Bool은 기본적으로 boolean 문을 확인하는 명령을 수행하는 Python의 기본 제공 함수입니다 (무엇이 무엇인지 모르는 경우 if 문에서 바로 만들려고합니다 :))</target>
        </trans-unit>
        <trans-unit id="41b6db522df83ba9a596e29f6f04d041013d9cf2" translate="yes" xml:space="preserve">
          <source>But I dont think, you like it. :)
And this way is ugly.</source>
          <target state="translated">그러나 나는 당신이 그것을 좋아한다고 생각하지 않습니다. :) 그리고이 방법은 못생긴입니다.</target>
        </trans-unit>
        <trans-unit id="f4385a198702e69c09bb82aff84c16ebf742dbdb" translate="yes" xml:space="preserve">
          <source>But we want to have</source>
          <target state="translated">하지만 우리는 갖고 싶어</target>
        </trans-unit>
        <trans-unit id="a27faa698dab470f11161204c4a25e5d0917c8c9" translate="yes" xml:space="preserve">
          <source>Change our conditions as:</source>
          <target state="translated">다음과 같이 조건을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b780eb53e7528543c4484d24e4b30675cddf5319" translate="yes" xml:space="preserve">
          <source>Connect these formulas by following logic:</source>
          <target state="translated">다음 논리에 따라이 공식을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="23c906d120f6bb0d28e6c4b2296e9f78b4cc0aa1" translate="yes" xml:space="preserve">
          <source>Create mapping of values (in the order you want to check):</source>
          <target state="translated">확인하려는 순서대로 값의 맵핑을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b3d64112baa428adb20e8915b333e2ce6d199205" translate="yes" xml:space="preserve">
          <source>Declare variables:</source>
          <target state="translated">변수 선언 :</target>
        </trans-unit>
        <trans-unit id="9b5b165b041692889344ce235bb138eb7edbf45a" translate="yes" xml:space="preserve">
          <source>Equivalent:</source>
          <target state="translated">Equivalent:</target>
        </trans-unit>
        <trans-unit id="3206d3885141933ea46755b030e35361dd3aa53a" translate="yes" xml:space="preserve">
          <source>Finally, use the &lt;code&gt;map&lt;/code&gt; function to create an iterator:</source>
          <target state="translated">마지막으로 &lt;code&gt;map&lt;/code&gt; 함수를 사용하여 반복자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e3f8c6b28df06279983427242677e0abbd1fa8a" translate="yes" xml:space="preserve">
          <source>How to test multiple variables against a value</source>
          <target state="translated">값에 대해 여러 변수를 테스트하는 방법</target>
        </trans-unit>
        <trans-unit id="1690068d3a18b79788b305f1805dff9306aea1d4" translate="yes" xml:space="preserve">
          <source>However, even if this were &lt;em&gt;not&lt;/em&gt; the case, and the expression &lt;code&gt;x or y or z == 1&lt;/code&gt; was actually interpreted as &lt;code&gt;(x or y or z) == 1&lt;/code&gt; instead, this would still not do what you expect it to do.</source>
          <target state="translated">그러나 이것이 사실이 &lt;em&gt;아니고&lt;/em&gt; 표현식 &lt;code&gt;x or y or z == 1&lt;/code&gt; 이 실제로 &lt;code&gt;(x or y or z) == 1&lt;/code&gt; 로 해석 된 경우에도 예상 한대로 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9063492569248924935d1ea9f7cfe6e496aa7dc" translate="yes" xml:space="preserve">
          <source>I think this will handle it better:</source>
          <target state="translated">나는 이것이 더 잘 처리 할 것이라고 생각한다.</target>
        </trans-unit>
        <trans-unit id="e7fdd1510849adc6b77d33436dfb1654ceeac78f" translate="yes" xml:space="preserve">
          <source>I'm trying to make a function that will compare multiple variables to an integer and output a string of three letters. I was wondering if there was a way to translate this into Python. So say:</source>
          <target state="translated">여러 변수를 정수와 비교하고 세 글자의 문자열을 출력하는 함수를 만들려고합니다. 이것을 파이썬으로 번역하는 방법이 있는지 궁금합니다. 이렇게 말하십시오 :</target>
        </trans-unit>
        <trans-unit id="7d80561cbf65d1c0ea7a693c438c4e00577ceedc" translate="yes" xml:space="preserve">
          <source>If this is what you want, the final line can be changed to:</source>
          <target state="translated">이것이 원하는 경우 마지막 줄을 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69952c7d8f578cbfed512cc34620dae72d52a3e" translate="yes" xml:space="preserve">
          <source>If you ARE very very lazy, you can put the values inside an array. Such as</source>
          <target state="translated">매우 게으른 경우 값을 배열 안에 넣을 수 있습니다. 와 같은</target>
        </trans-unit>
        <trans-unit id="72a74a2a2fd5c0f05ff83572f16db3bbe8acbc27" translate="yes" xml:space="preserve">
          <source>If you want to use if, else statements following is another solution:</source>
          <target state="translated">if를 사용하려는 경우 else 다음 문은 다른 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="dceda35d497532579aeab70981b2e030e46924a2" translate="yes" xml:space="preserve">
          <source>Imports:</source>
          <target state="translated">Imports:</target>
        </trans-unit>
        <trans-unit id="6b27f3e9d1c3cfdf2ca592d7828d05fc3e224af9" translate="yes" xml:space="preserve">
          <source>Is something like this possible?</source>
          <target state="translated">이와 같은 것이 가능합니까?</target>
        </trans-unit>
        <trans-unit id="2bfaf3bf3b08cf7e4ccd8996e5fed256fbd43ffe" translate="yes" xml:space="preserve">
          <source>It can be done easily as</source>
          <target state="translated">그것은 쉽게 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="866644b51b9d40ebeffc45ee2336b9f986861514" translate="yes" xml:space="preserve">
          <source>It should be noted however, as mentioned by &lt;code&gt;@codeforester&lt;/code&gt;, that word boundries are lost with this method, as in:</source>
          <target state="translated">그러나 &lt;code&gt;@codeforester&lt;/code&gt; 에서 언급했듯이 다음과 같이이 방법으로 단어 경계 가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="0c7d38a7015e5383cb6fc3ee40ad8694bcba4672" translate="yes" xml:space="preserve">
          <source>Let's map to bits: &lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76db2cdb6855d81571463add9d07d4e3fcf49f0" translate="yes" xml:space="preserve">
          <source>Looks like you're building some kind of Caesar cipher.</source>
          <target state="translated">일종의 시저 암호를 작성하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="8be0a31f87a698daba296424953326b97e6ca455" translate="yes" xml:space="preserve">
          <source>Maybe you need direct formula for output bits set.</source>
          <target state="translated">출력 비트 세트에 대한 직접적인 공식이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2986760ee39be8694759a7e5ec189dead87b8f" translate="yes" xml:space="preserve">
          <source>Not sure if it's a desired side effect of your code, but the order of your output will always be sorted.</source>
          <target state="translated">그것이 코드의 원하는 부작용인지 확실하지 않지만 출력 순서는 항상 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8bb632d18f18c3ca5e853e32c7ff5745a62aec16" translate="yes" xml:space="preserve">
          <source>One generalization of the previous expression is based on the answer from &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt;:</source>
          <target state="translated">이전 표현의 일반화는 &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt; 의 답변을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e90d1db2c08d51cdaf3208d19c329897e23d3bf2" translate="yes" xml:space="preserve">
          <source>One line solution:</source>
          <target state="translated">한 줄 솔루션 :</target>
        </trans-unit>
        <trans-unit id="b9e703ebdcfd19c006b401c977efdb5773365151" translate="yes" xml:space="preserve">
          <source>One more thing, your</source>
          <target state="translated">한가지 더</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="1a9aedec59b804a602ad84ba70cbffa39d7afe06" translate="yes" xml:space="preserve">
          <source>Relation of isc (is 'c'):</source>
          <target state="translated">isc의 관계 ( 'c') :</target>
        </trans-unit>
        <trans-unit id="c47635a32643194fa5c1d73ffb3364cb2ce7e2a8" translate="yes" xml:space="preserve">
          <source>Set is the good approach here, because it orders the variables, what seems to be your goal here. &lt;code&gt;{z,y,x}&lt;/code&gt; is &lt;code&gt;{0,1,3}&lt;/code&gt; whatever the order of the parameters.</source>
          <target state="translated">변수를 주문하기 때문에 여기에 목표가있는 것 같습니다. &lt;code&gt;{z,y,x}&lt;/code&gt; 는 매개 변수의 순서에 관계없이 &lt;code&gt;{0,1,3}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5bddac5fdbd073da63065edd9f73643283d8644" translate="yes" xml:space="preserve">
          <source>So for the values &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt;, &lt;code&gt;x or y or z&lt;/code&gt; would resolve to &lt;code&gt;2&lt;/code&gt;, because that is the first true-like value in the arguments. Then &lt;code&gt;2 == 1&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;, even though &lt;code&gt;y == 1&lt;/code&gt; would be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">따라서 값 &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt; y = 1; z = 0 , &lt;code&gt;x or y or z&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 로 해석됩니다. 이는 인수에서 첫 번째와 같은 값이기 때문입니다. &lt;code&gt;y == 1&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 일지라도 &lt;code&gt;2 == 1&lt;/code&gt; 은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="3c900b3d5f08fdcdc1f78f0317f9c51f8053bb56" translate="yes" xml:space="preserve">
          <source>Test if the string &quot;Wild&quot; is in multiple values</source>
          <target state="translated">&quot;Wild&quot;문자열이 여러 값인지 확인</target>
        </trans-unit>
        <trans-unit id="c927be0e598ed66db0dc371da49441cdc8cadf17" translate="yes" xml:space="preserve">
          <source>The direct way to write &lt;code&gt;x or y or z == 0&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;x or y or z == 0&lt;/code&gt; 을 쓰는 직접적인 방법은</target>
        </trans-unit>
        <trans-unit id="fc79ed71050b9a0c16fbfdf7c524bf2d41b13800" translate="yes" xml:space="preserve">
          <source>The most mnemonic way of representing your pseudo-code in Python would be:</source>
          <target state="translated">파이썬에서 의사 코드를 표현하는 가장 니모닉 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04b4257a2c3bf690535db945de6a3fab6f05b7ed" translate="yes" xml:space="preserve">
          <source>The other way (a better) is:</source>
          <target state="translated">다른 방법 (더 나은)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3791bfd4543d9a856e18c50dbc04720b33ace4b2" translate="yes" xml:space="preserve">
          <source>The same would apply to the inverse; testing multiple values against a single variable; &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; would fail for the same reasons. Use &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; or &lt;code&gt;x in {1, 2, 3}&lt;/code&gt;.</source>
          <target state="translated">반대의 경우도 마찬가지입니다. 단일 변수에 대해 여러 값을 테스트하는 단계; &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; 은 같은 이유로 실패합니다. &lt;code&gt;x in {1, 2, 3}&lt;/code&gt; &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; 또는 x를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="41fa9fcaf3429d85247374d4e6bd0000c1558845" translate="yes" xml:space="preserve">
          <source>The solution provided will not work for partial hits if using strings for example:</source>
          <target state="translated">문자열을 사용하는 경우 제공된 솔루션이 부분 적중에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68d01441f9f74a616b4d6a83968653d4293606f8" translate="yes" xml:space="preserve">
          <source>The upshot being, be careful with your search criteria if using this method and be aware that it does have this limitation.</source>
          <target state="translated">결과적으로이 방법을 사용하는 경우 검색 기준에주의하고이 제한이 있음을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b968f041fb97521d879885b45db4504e7a1b225" translate="yes" xml:space="preserve">
          <source>Then, when checking for the values (in the original order), use &lt;code&gt;next()&lt;/code&gt;:</source>
          <target state="translated">그런 다음 원래 순서대로 값을 확인할 때 &lt;code&gt;next()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="244cf7d4aacadf87fa117ebf501e2c69320b9911" translate="yes" xml:space="preserve">
          <source>This code may be helpful</source>
          <target state="translated">이 코드는 도움이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b603f08a1f26476f174439270377be0254a39c6b" translate="yes" xml:space="preserve">
          <source>This has an advantage over the &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; because &lt;code&gt;operator&lt;/code&gt; is an inbuilt module and is faster and more efficient than using &lt;code&gt;lambda&lt;/code&gt; which has to create a custom in-place function.</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 는 내장 모듈이며 사용자 지정 위치 내 함수를 작성 &lt;code&gt;lambda&lt;/code&gt; 를 사용하는 것보다 빠르고 효율적이기 때문에 &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; 비해 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76b3b60499b4c2e88bf9b78e6177bbe474e3aec" translate="yes" xml:space="preserve">
          <source>This is due to &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;operator precedence&lt;/a&gt;. The &lt;code&gt;or&lt;/code&gt; operator has a lower precedence than the &lt;code&gt;==&lt;/code&gt; test, so the latter is evaluated &lt;em&gt;first&lt;/em&gt;.</source>
          <target state="translated">이는 &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;운영자 우선 순위 때문&lt;/a&gt; 입니다. &lt;code&gt;or&lt;/code&gt; 연산자는 &lt;code&gt;==&lt;/code&gt; 테스트보다 우선 순위가 낮으므로 후자가 &lt;em&gt;먼저&lt;/em&gt; 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="64ddaf83d2f60c93d468c3e3ed9699c922958fe5" translate="yes" xml:space="preserve">
          <source>This way, the whole solution is O(n).</source>
          <target state="translated">이런 식으로 전체 솔루션은 O (n)입니다.</target>
        </trans-unit>
        <trans-unit id="976528b0a8c35bea07e6bc2601aec4299b2bbaa5" translate="yes" xml:space="preserve">
          <source>This will help you.</source>
          <target state="translated">도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="e02cbb19fa7a225098185240eafb7f7ac151e94f" translate="yes" xml:space="preserve">
          <source>This will work, but &lt;em&gt;if&lt;/em&gt; you are comfortable using dictionaries (see what I did there), you can clean this up by making an initial dictionary mapping the numbers to the letters you want, then just using a for-loop:</source>
          <target state="translated">이것은 효과가 있지만 사전을 사용하는 것이 편한 &lt;em&gt;경우&lt;/em&gt; (내가 한 일을 참조하십시오) 숫자를 원하는 문자에 매핑 한 다음 for-loop를 사용하여 초기 사전을 만들어 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f43c35e265188c85ff1afeb217ad718c6c95ddf" translate="yes" xml:space="preserve">
          <source>To check if a value is contained within a set of variables you can use the inbuilt modules           &lt;code&gt;itertools&lt;/code&gt; and &lt;code&gt;operator&lt;/code&gt;.</source>
          <target state="translated">값이 변수 세트에 포함되어 있는지 확인하려면 내장 모듈 &lt;code&gt;itertools&lt;/code&gt; 및 &lt;code&gt;operator&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09e954d89ce8c7bc163dfa546dbd624e5392f2f1" translate="yes" xml:space="preserve">
          <source>To test multiple values with one variable: &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</source>
          <target state="translated">하나의 변수로 여러 값을 테스트하려면 : &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc35f0f0fd5eec1aaf32678ec2edbf03c38ad94" translate="yes" xml:space="preserve">
          <source>To test multiple variables with one single value: &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</source>
          <target state="translated">하나의 단일 값으로 여러 변수를 테스트하려면 &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="383327b199376946b76f635409e672afc9428011" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;itertools&lt;/code&gt; to allow repetition of the variables:</source>
          <target state="translated">&lt;code&gt;itertools&lt;/code&gt; 를 사용하여 변수 반복을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="da0755287f2d9299b4491cae5b9510ea0010f29b" translate="yes" xml:space="preserve">
          <source>Use math if formula &lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&lt;/a&gt;</source>
          <target state="translated">수식 &lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315 인&lt;/a&gt; 경우 수학 사용</target>
        </trans-unit>
        <trans-unit id="e1a45a1688e274b044e5e867e0b1b31411fbb885" translate="yes" xml:space="preserve">
          <source>Using his advice you would now have separate if-statements so that Python will read each statement whether the former were &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. Such as:</source>
          <target state="translated">그의 조언을 사용하면 이제는 별도의 if 문을 가지므로 Python은 전자가 &lt;code&gt;True&lt;/code&gt; 인지 &lt;code&gt;False&lt;/code&gt; 인지 각 문장을 읽습니다. 같은 :</target>
        </trans-unit>
        <trans-unit id="fa259d374a6e092a09201c87a89ba6bbe7a0a01b" translate="yes" xml:space="preserve">
          <source>What they ignore is the broader implication of the question:</source>
          <target state="translated">그들이 무시하는 것은 질문의 광범위한 의미입니다.</target>
        </trans-unit>
        <trans-unit id="465745f8cd0620d2b944ef260d792fc24f700e94" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;or&lt;/code&gt;, python sees each side of the operator as &lt;em&gt;separate&lt;/em&gt; expressions. The expression &lt;code&gt;x or y == 1&lt;/code&gt; is treated as first a boolean test for &lt;code&gt;x&lt;/code&gt;, then if that is False, the expression &lt;code&gt;y == 1&lt;/code&gt; is tested.</source>
          <target state="translated">또는를 사용하면 파이썬은 연산자의 각면을 &lt;em&gt;별도의&lt;/em&gt; 표현식으로 간주합니다. &lt;code&gt;x or y == 1&lt;/code&gt; 표현식은 먼저 &lt;code&gt;x&lt;/code&gt; 에 대한 부울 테스트로 처리 된 다음 False 인 경우 &lt;code&gt;y == 1&lt;/code&gt; 표현식이 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="25f4f2e41824dc0d2846681f279f695d252a4904" translate="yes" xml:space="preserve">
          <source>While the pattern for testing multiple values</source>
          <target state="translated">여러 값을 테스트하기위한 패턴</target>
        </trans-unit>
        <trans-unit id="04351719ba6eeda9d512f672fb8d394087b1da53" translate="yes" xml:space="preserve">
          <source>While this expression returns the right result it is not as readable as the first expression :-(</source>
          <target state="translated">이 표현식은 올바른 결과를 반환하지만 첫 번째 표현식만큼 읽을 수 없습니다 :-(</target>
        </trans-unit>
        <trans-unit id="601535d04ee42bf736205a2ff11e82514bc43d41" translate="yes" xml:space="preserve">
          <source>Without dict, try this solution:</source>
          <target state="translated">dict 없이이 솔루션을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="d029b61b50b6116720d778dd5928e522a41cc72a" translate="yes" xml:space="preserve">
          <source>You can also put the numbers and letters in a dictionary and do it, but this is probably a LOT more complicated than simply if statements. That's what you get for trying to be extra lazy :)</source>
          <target state="translated">숫자와 문자를 사전에 넣어서 할 수도 있지만 이것은 아마도 if 문보다 훨씬 복잡 할 것입니다. 그것은 당신이 여분의 게 으르려고 노력하면서 얻는 것입니다 :)</target>
        </trans-unit>
        <trans-unit id="78915cb2d48c3749414c1966fb19060e5b9f882f" translate="yes" xml:space="preserve">
          <source>You can shorten that using a containment test against &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;a tuple&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;튜플&lt;/a&gt; 에 대해 포함 테스트를 사용하면 단축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c68d801513922b97394cc0e56a9e3610a25c00" translate="yes" xml:space="preserve">
          <source>You can try the method shown below. In this method, you will have the freedom to specify/input the number of variables that you wish to enter.</source>
          <target state="translated">아래 표시된 방법을 시도해 볼 수 있습니다. 이 방법에서는 입력하고자하는 변수의 수를 자유롭게 지정 / 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebeccd592c6dfdcd746344abcf9e515154d74a0c" translate="yes" xml:space="preserve">
          <source>You can unite this</source>
          <target state="translated">당신은 이것을 묶을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dfa11c78453d0ec1b15421a18df356fec7612bec" translate="yes" xml:space="preserve">
          <source>You can use dictionary :</source>
          <target state="translated">당신은 사전을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="beb91eb796448d63880344240682408a11304d5e" translate="yes" xml:space="preserve">
          <source>You misunderstand how boolean expressions work; they don't work like an English sentence and guess that you are talking about the same comparison for all names here. You are looking for:</source>
          <target state="translated">부울 표현식의 작동 방식을 오해합니다. 그들은 영어 문장처럼 작동하지 않으며 여기에서 모든 이름에 대해 동일한 비교에 대해 이야기하고 있다고 생각합니다. 당신이 찾고있는:</target>
        </trans-unit>
        <trans-unit id="ab683f096ab964a499ae8d8fde3d963f4031ce86" translate="yes" xml:space="preserve">
          <source>Your problem is more easily addressed with a dictionary structure like:</source>
          <target state="translated">다음과 같은 사전 구조로 문제를보다 쉽게 ​​해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a344f069b3775d64cdc3efb7aab823d855e6f4db" translate="yes" xml:space="preserve">
          <source>[c]: &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[c] : &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d05021da9336e43f730afddf3adad2188ed178e" translate="yes" xml:space="preserve">
          <source>[d]: &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[d] : &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d496d3b60cd5b31edb48f670e7aaf9dd3d6898d1" translate="yes" xml:space="preserve">
          <source>and gives:</source>
          <target state="translated">그리고 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="706bcd4df4cc5b853edc6bed42ba01c222aa137f" translate="yes" xml:space="preserve">
          <source>and you'll have a total equation
express sum and you have total formula of sum</source>
          <target state="translated">그리고 당신은 총 방정식 표현 합계를 가질 것이고 당신은 합계의 총 공식을 가질 것입니다</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="ff787af4ae3cbab89d3875936b8cea159bbf1b2c" translate="yes" xml:space="preserve">
          <source>for this scenario it's easiest to convert to a string</source>
          <target state="translated">이 시나리오에서는 문자열로 변환하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="a38ef392dd476dd325dae11a6aaa28e439e53f31" translate="yes" xml:space="preserve">
          <source>in one variable.</source>
          <target state="translated">하나의 변수로.</target>
        </trans-unit>
        <trans-unit id="0c0690d6bac0cddb8d2eb4dc2ab0532025f7f332" translate="yes" xml:space="preserve">
          <source>is very readable and is working in many situation, there is one pitfall:</source>
          <target state="translated">매우 읽기 쉽고 많은 상황에서 작동하고 있으며 한 가지 함정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b08e37624dce70b48b2a8b003d7ebb49075ab69e" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;and&lt;/code&gt; is the sum of squares of equations</source>
          <target state="translated">논리는 방정식의 제곱의 합입니다</target>
        </trans-unit>
        <trans-unit id="50e930613ab6595d07ceb13b02a5a5b7e5384f24" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;or&lt;/code&gt; is the product of equations</source>
          <target state="translated">논리 &lt;code&gt;or&lt;/code&gt; 방정식의 곱</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="4c4561e5cc6655de9370d5a62358173a345d902b" translate="yes" xml:space="preserve">
          <source>or better still:</source>
          <target state="translated">또는 더 나은 방법 :</target>
        </trans-unit>
        <trans-unit id="e71003c6b7dd4093ce139ac0c51a6ba38d54a439" translate="yes" xml:space="preserve">
          <source>outputs</source>
          <target state="translated">outputs</target>
        </trans-unit>
        <trans-unit id="dc6e8247c55b9549a60ed2c399a59de52d6eb88c" translate="yes" xml:space="preserve">
          <source>the 3 letters &lt;code&gt;rot&lt;/code&gt; do exist in combination in the list but not as an individual word. Testing for &quot; rot &quot; would fail but if one of the list items were &quot;rot in hell&quot;, that would fail as well.</source>
          <target state="translated">3 개의 문자 &lt;code&gt;rot&lt;/code&gt; 은 목록에 조합되어 있지만 개별 단어로는 존재하지 않습니다. &quot;rot&quot;에 대한 테스트는 실패하지만 목록 항목 중 하나가 &quot;hell in hell&quot;인 경우에도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="763e6fd8133d4e806ea0b3c7576ce67fc1973840" translate="yes" xml:space="preserve">
          <source>the program will check if the variable is not null. Another way to write the above statement (which makes more sense) is</source>
          <target state="translated">프로그램은 변수가 null이 아닌지 확인합니다. 위의 진술을 작성하는 또 다른 방법은 (더 의미가 있습니다)</target>
        </trans-unit>
        <trans-unit id="0d4ee4cc805fe94d1e25296222661ee3d0480bcc" translate="yes" xml:space="preserve">
          <source>then sum&amp;amp;1 is c, sum&amp;amp;2 is d, sum&amp;amp;4 is e, sum&amp;amp;5 is f</source>
          <target state="translated">sum &amp;amp; 1은 c, sum &amp;amp; 2는 d, sum &amp;amp; 4는 e, sum &amp;amp; 5는 f</target>
        </trans-unit>
        <trans-unit id="4da38f55e44fda425afee7c334f3bbb00da18fa3" translate="yes" xml:space="preserve">
          <source>using &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt;a &lt;code&gt;set&lt;/code&gt;&lt;/a&gt; to take advantage of the constant-cost membership test (&lt;code&gt;in&lt;/code&gt; takes a fixed amount of time whatever the left-hand operand is).</source>
          <target state="translated">고정 비용 멤버쉽 테스트를 활용하기 위해 &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 사용 (왼쪽 피연산자에 관계없이 고정 된 시간이 걸립니다).</target>
        </trans-unit>
        <trans-unit id="9e7a7eba74ea8ce2cd328d7a815f59efbd72dcb3" translate="yes" xml:space="preserve">
          <source>which can be written as</source>
          <target state="translated">이것은 다음과 같이 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9488fbc5a7f3e90e0acdddfadc35548836dda8cd" translate="yes" xml:space="preserve">
          <source>which would return a list of</source>
          <target state="translated">어떤 목록을 반환합니다</target>
        </trans-unit>
        <trans-unit id="564d92856586976259f387ac0dc96b269f78b744" translate="yes" xml:space="preserve">
          <source>will compile, but not in the way you want it to. When you simply put a variable in an if statement (example)</source>
          <target state="translated">컴파일하지만 원하는 방식으로 컴파일하지는 않습니다. if 문에 변수를 넣을 때 (예)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
