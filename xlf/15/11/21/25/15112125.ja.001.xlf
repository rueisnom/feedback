<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/15112125">
    <body>
      <group id="15112125">
        <trans-unit id="bb13107891e34020b269948fd348a93b39b4cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array[sum]&lt;/code&gt; gives you the string.</source>
          <target state="translated">&lt;code&gt;array[sum]&lt;/code&gt; は文字列を提供します。</target>
        </trans-unit>
        <trans-unit id="00588cd0b67586a0cf5791fdbf34e87aeb48bde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x or y or z&lt;/code&gt; would evaluate to the first argument that is 'truthy', e.g. not &lt;code&gt;False&lt;/code&gt;, numeric 0 or empty (see &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;boolean expressions&lt;/a&gt; for details on what Python considers false in a boolean context).</source>
          <target state="translated">&lt;code&gt;x or y or z&lt;/code&gt; は、「真」である最初の引数に評価されます。たとえば、 &lt;code&gt;False&lt;/code&gt; 、数値0または空ではありません（ブールコンテキストでPythonがfalseと見なすものの詳細については、 &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;ブール式&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="7333a0715f136dc925dd2e84ffcbba4920732a15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are otherwise evaluated on their own (&lt;code&gt;False&lt;/code&gt; if &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; otherwise).</source>
          <target state="translated">それ以外の場合、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; は独自に評価されます（ &lt;code&gt;0&lt;/code&gt; の場合は &lt;code&gt;False&lt;/code&gt; 、それ以外の場合は &lt;code&gt;True&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a927e3bcbbb2295c65e1e58e0e35bd1f4c7006df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I test one variable against multiple values?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1つの変数を複数の値に対してテストするにはどうすればよいですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a411154b01054dc56c3b27fc9ca455c9da17006" translate="yes" xml:space="preserve">
          <source>A much more generalized approach is this:</source>
          <target state="translated">より一般化したアプローチはこれだ。</target>
        </trans-unit>
        <trans-unit id="e613cc0a40046d91ea55a26346590841af7fd423" translate="yes" xml:space="preserve">
          <source>After this you may form predefined array where index of string elements would correspond to ready string.</source>
          <target state="translated">この後、文字列要素のインデックスが用意された文字列に対応するように、あらかじめ定義された配列を形成することができます。</target>
        </trans-unit>
        <trans-unit id="95917ca908e6a3eb5ee61cafb13cfde8ae85cc8b" translate="yes" xml:space="preserve">
          <source>All of the excellent answers provided here concentrate on the specific requirement of the original poster and concentrate on the &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; solution put forward by Martijn Pieters.</source>
          <target state="translated">ここで提供される優れた回答はすべて、元のポスターの特定の要件に集中し、Martijn Pietersによって提案された &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; ソリューションに集中します。</target>
        </trans-unit>
        <trans-unit id="6428e53a1aeab2edcca1712fc8659b2bade6a9ae" translate="yes" xml:space="preserve">
          <source>Another lazy way I found is :</source>
          <target state="translated">私が見つけたもう一つの怠惰な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9019a09f9020d12c4c096c111a5eb6ce502a60af" translate="yes" xml:space="preserve">
          <source>Another option for checking if there is a non-zero (or False) value in a list:</source>
          <target state="translated">リストの中に 0 以外の値 (または False)があるかどうかをチェックするための別のオプション。</target>
        </trans-unit>
        <trans-unit id="463015b4b607a45b6c5d9adefdb7bafe8183b458" translate="yes" xml:space="preserve">
          <source>As stated by Martijn Pieters, the correct, and fastest, format is:</source>
          <target state="translated">Martijn Pieters が述べているように、正しい、そして最速のフォーマットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b240cced7ab44159f960aafdc13c958949221c61" translate="yes" xml:space="preserve">
          <source>BTW lots of &lt;code&gt;if&lt;/code&gt;s could be written as something like this</source>
          <target state="translated">ところで &lt;code&gt;if&lt;/code&gt; sはこのようなものとして書くことができます</target>
        </trans-unit>
        <trans-unit id="6713674f00a4357f6ef85c6bce361231e4a206d2" translate="yes" xml:space="preserve">
          <source>Bool is an inbuilt function in python which basically does the command of verifying a boolean statement (If you don't know what that is, it is what you are trying to make in your if statement right now :))</source>
          <target state="translated">Bool は python に組み込まれた関数で、基本的には boolean 文を検証するコマンドを実行します (それが何かわからない場合は、今あなたが if 文の中で作ろうとしているものです :)</target>
        </trans-unit>
        <trans-unit id="41b6db522df83ba9a596e29f6f04d041013d9cf2" translate="yes" xml:space="preserve">
          <source>But I dont think, you like it. :)
And this way is ugly.</source>
          <target state="translated">しかし、私はあなたがそれを好きだとは思いません。)そして、この方法は醜いです。</target>
        </trans-unit>
        <trans-unit id="f4385a198702e69c09bb82aff84c16ebf742dbdb" translate="yes" xml:space="preserve">
          <source>But we want to have</source>
          <target state="translated">しかし、私たちは</target>
        </trans-unit>
        <trans-unit id="a27faa698dab470f11161204c4a25e5d0917c8c9" translate="yes" xml:space="preserve">
          <source>Change our conditions as:</source>
          <target state="translated">私たちの条件を変更します。</target>
        </trans-unit>
        <trans-unit id="b780eb53e7528543c4484d24e4b30675cddf5319" translate="yes" xml:space="preserve">
          <source>Connect these formulas by following logic:</source>
          <target state="translated">これらの式を以下のロジックで繋げてください。</target>
        </trans-unit>
        <trans-unit id="23c906d120f6bb0d28e6c4b2296e9f78b4cc0aa1" translate="yes" xml:space="preserve">
          <source>Create mapping of values (in the order you want to check):</source>
          <target state="translated">値のマッピングを作成します(チェックしたい順に)。</target>
        </trans-unit>
        <trans-unit id="b3d64112baa428adb20e8915b333e2ce6d199205" translate="yes" xml:space="preserve">
          <source>Declare variables:</source>
          <target state="translated">変数を宣言します。</target>
        </trans-unit>
        <trans-unit id="9b5b165b041692889344ce235bb138eb7edbf45a" translate="yes" xml:space="preserve">
          <source>Equivalent:</source>
          <target state="translated">Equivalent:</target>
        </trans-unit>
        <trans-unit id="3206d3885141933ea46755b030e35361dd3aa53a" translate="yes" xml:space="preserve">
          <source>Finally, use the &lt;code&gt;map&lt;/code&gt; function to create an iterator:</source>
          <target state="translated">最後に、 &lt;code&gt;map&lt;/code&gt; 関数を使用してイテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="2e3f8c6b28df06279983427242677e0abbd1fa8a" translate="yes" xml:space="preserve">
          <source>How to test multiple variables against a value</source>
          <target state="translated">複数の変数を値に対してテストする方法</target>
        </trans-unit>
        <trans-unit id="1690068d3a18b79788b305f1805dff9306aea1d4" translate="yes" xml:space="preserve">
          <source>However, even if this were &lt;em&gt;not&lt;/em&gt; the case, and the expression &lt;code&gt;x or y or z == 1&lt;/code&gt; was actually interpreted as &lt;code&gt;(x or y or z) == 1&lt;/code&gt; instead, this would still not do what you expect it to do.</source>
          <target state="translated">ただし、これが&lt;em&gt;当てはまらず&lt;/em&gt; 、式 &lt;code&gt;x or y or z == 1&lt;/code&gt; が実際には &lt;code&gt;(x or y or z) == 1&lt;/code&gt; として解釈されたとしても、期待どおりには動作しません。</target>
        </trans-unit>
        <trans-unit id="c9063492569248924935d1ea9f7cfe6e496aa7dc" translate="yes" xml:space="preserve">
          <source>I think this will handle it better:</source>
          <target state="translated">こちらの方が扱いやすいと思います。</target>
        </trans-unit>
        <trans-unit id="e7fdd1510849adc6b77d33436dfb1654ceeac78f" translate="yes" xml:space="preserve">
          <source>I'm trying to make a function that will compare multiple variables to an integer and output a string of three letters. I was wondering if there was a way to translate this into Python. So say:</source>
          <target state="translated">複数の変数を整数と比較して3文字の文字列を出力する関数を作ろうとしています。これをPythonに変換する方法はないかと思っていました。と言うことで。</target>
        </trans-unit>
        <trans-unit id="7d80561cbf65d1c0ea7a693c438c4e00577ceedc" translate="yes" xml:space="preserve">
          <source>If this is what you want, the final line can be changed to:</source>
          <target state="translated">これであれば、最終行を変更することができます。</target>
        </trans-unit>
        <trans-unit id="c69952c7d8f578cbfed512cc34620dae72d52a3e" translate="yes" xml:space="preserve">
          <source>If you ARE very very lazy, you can put the values inside an array. Such as</source>
          <target state="translated">もしあなたが非常に怠け者であれば、値を配列の中に入れることができます。例えば</target>
        </trans-unit>
        <trans-unit id="72a74a2a2fd5c0f05ff83572f16db3bbe8acbc27" translate="yes" xml:space="preserve">
          <source>If you want to use if, else statements following is another solution:</source>
          <target state="translated">if,elseステートメントを使用したい場合は、次の別の解決策です。</target>
        </trans-unit>
        <trans-unit id="dceda35d497532579aeab70981b2e030e46924a2" translate="yes" xml:space="preserve">
          <source>Imports:</source>
          <target state="translated">Imports:</target>
        </trans-unit>
        <trans-unit id="6b27f3e9d1c3cfdf2ca592d7828d05fc3e224af9" translate="yes" xml:space="preserve">
          <source>Is something like this possible?</source>
          <target state="translated">このようなことは可能なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="2bfaf3bf3b08cf7e4ccd8996e5fed256fbd43ffe" translate="yes" xml:space="preserve">
          <source>It can be done easily as</source>
          <target state="translated">として簡単に行うことができます。</target>
        </trans-unit>
        <trans-unit id="866644b51b9d40ebeffc45ee2336b9f986861514" translate="yes" xml:space="preserve">
          <source>It should be noted however, as mentioned by &lt;code&gt;@codeforester&lt;/code&gt;, that word boundries are lost with this method, as in:</source>
          <target state="translated">ただし、 &lt;code&gt;@codeforester&lt;/code&gt; で言及されているように、このメソッドでは次のように単語の境界が失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0c7d38a7015e5383cb6fc3ee40ad8694bcba4672" translate="yes" xml:space="preserve">
          <source>Let's map to bits: &lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt;</source>
          <target state="translated">ビットにマッピングしてみましょう： &lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76db2cdb6855d81571463add9d07d4e3fcf49f0" translate="yes" xml:space="preserve">
          <source>Looks like you're building some kind of Caesar cipher.</source>
          <target state="translated">シーザーの暗号を作っているようだな</target>
        </trans-unit>
        <trans-unit id="8be0a31f87a698daba296424953326b97e6ca455" translate="yes" xml:space="preserve">
          <source>Maybe you need direct formula for output bits set.</source>
          <target state="translated">出力ビット数の直接計算式が必要なのかもしれません。</target>
        </trans-unit>
        <trans-unit id="db2986760ee39be8694759a7e5ec189dead87b8f" translate="yes" xml:space="preserve">
          <source>Not sure if it's a desired side effect of your code, but the order of your output will always be sorted.</source>
          <target state="translated">あなたのコードの望ましい副作用かどうかはわかりませんが、出力の順番は常にソートされます。</target>
        </trans-unit>
        <trans-unit id="8bb632d18f18c3ca5e853e32c7ff5745a62aec16" translate="yes" xml:space="preserve">
          <source>One generalization of the previous expression is based on the answer from &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt;:</source>
          <target state="translated">前の表現の一般化の1つは、 &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt;からの回答に基づいています。</target>
        </trans-unit>
        <trans-unit id="e90d1db2c08d51cdaf3208d19c329897e23d3bf2" translate="yes" xml:space="preserve">
          <source>One line solution:</source>
          <target state="translated">一行ソリューション。</target>
        </trans-unit>
        <trans-unit id="b9e703ebdcfd19c006b401c977efdb5773365151" translate="yes" xml:space="preserve">
          <source>One more thing, your</source>
          <target state="translated">もう一つ、あなたの</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="1a9aedec59b804a602ad84ba70cbffa39d7afe06" translate="yes" xml:space="preserve">
          <source>Relation of isc (is 'c'):</source>
          <target state="translated">iscの関係(is 'c')。</target>
        </trans-unit>
        <trans-unit id="c47635a32643194fa5c1d73ffb3364cb2ce7e2a8" translate="yes" xml:space="preserve">
          <source>Set is the good approach here, because it orders the variables, what seems to be your goal here. &lt;code&gt;{z,y,x}&lt;/code&gt; is &lt;code&gt;{0,1,3}&lt;/code&gt; whatever the order of the parameters.</source>
          <target state="translated">Setは、変数を順序付けるので、ここでの良いアプローチです。 &lt;code&gt;{z,y,x}&lt;/code&gt; は、パラメーターの順序に &lt;code&gt;{0,1,3}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d5bddac5fdbd073da63065edd9f73643283d8644" translate="yes" xml:space="preserve">
          <source>So for the values &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt;, &lt;code&gt;x or y or z&lt;/code&gt; would resolve to &lt;code&gt;2&lt;/code&gt;, because that is the first true-like value in the arguments. Then &lt;code&gt;2 == 1&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;, even though &lt;code&gt;y == 1&lt;/code&gt; would be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">したがって、値 &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt; y = 1; z = 0 、 &lt;code&gt;x or y or z&lt;/code&gt; は &lt;code&gt;2&lt;/code&gt; に解決されます。これは、それが引数の最初の真のような値だからです。 &lt;code&gt;y == 1&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; であっても、 &lt;code&gt;2 == 1&lt;/code&gt; は &lt;code&gt;False&lt;/code&gt; になります 。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="3c900b3d5f08fdcdc1f78f0317f9c51f8053bb56" translate="yes" xml:space="preserve">
          <source>Test if the string &quot;Wild&quot; is in multiple values</source>
          <target state="translated">文字列 &quot;Wild &quot;が複数の値を持つかどうかをテストする</target>
        </trans-unit>
        <trans-unit id="c927be0e598ed66db0dc371da49441cdc8cadf17" translate="yes" xml:space="preserve">
          <source>The direct way to write &lt;code&gt;x or y or z == 0&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;x or y or z == 0&lt;/code&gt; 直接書き込む方法は、</target>
        </trans-unit>
        <trans-unit id="fc79ed71050b9a0c16fbfdf7c524bf2d41b13800" translate="yes" xml:space="preserve">
          <source>The most mnemonic way of representing your pseudo-code in Python would be:</source>
          <target state="translated">Pythonで疑似コードを表現する最もニーモニックな方法は次のようになります。</target>
        </trans-unit>
        <trans-unit id="04b4257a2c3bf690535db945de6a3fab6f05b7ed" translate="yes" xml:space="preserve">
          <source>The other way (a better) is:</source>
          <target state="translated">もう一つの方法(ベター)は</target>
        </trans-unit>
        <trans-unit id="3791bfd4543d9a856e18c50dbc04720b33ace4b2" translate="yes" xml:space="preserve">
          <source>The same would apply to the inverse; testing multiple values against a single variable; &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; would fail for the same reasons. Use &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; or &lt;code&gt;x in {1, 2, 3}&lt;/code&gt;.</source>
          <target state="translated">同じことが逆にも当てはまります。 単一の変数に対して複数の値をテストします。 &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; は、同じ理由で失敗します。 &lt;code&gt;x in {1, 2, 3}&lt;/code&gt; &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; またはxを使用します。</target>
        </trans-unit>
        <trans-unit id="41fa9fcaf3429d85247374d4e6bd0000c1558845" translate="yes" xml:space="preserve">
          <source>The solution provided will not work for partial hits if using strings for example:</source>
          <target state="translated">文字列を使用している場合など、部分的なヒットに対しては、提供されている解決策は動作しません。</target>
        </trans-unit>
        <trans-unit id="68d01441f9f74a616b4d6a83968653d4293606f8" translate="yes" xml:space="preserve">
          <source>The upshot being, be careful with your search criteria if using this method and be aware that it does have this limitation.</source>
          <target state="translated">この方法を使用している場合は、検索条件に注意して、それがこの制限を持っていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6b968f041fb97521d879885b45db4504e7a1b225" translate="yes" xml:space="preserve">
          <source>Then, when checking for the values (in the original order), use &lt;code&gt;next()&lt;/code&gt;:</source>
          <target state="translated">次に、値を（元の順序で）チェックするときに、 &lt;code&gt;next()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="244cf7d4aacadf87fa117ebf501e2c69320b9911" translate="yes" xml:space="preserve">
          <source>This code may be helpful</source>
          <target state="translated">このコードは役に立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="b603f08a1f26476f174439270377be0254a39c6b" translate="yes" xml:space="preserve">
          <source>This has an advantage over the &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; because &lt;code&gt;operator&lt;/code&gt; is an inbuilt module and is faster and more efficient than using &lt;code&gt;lambda&lt;/code&gt; which has to create a custom in-place function.</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; は組み込みモジュールであり、カスタムインプレース関数を作成する必要がある &lt;code&gt;lambda&lt;/code&gt; を使用するよりも高速で効率的であるため、これは &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; よりも優れています。</target>
        </trans-unit>
        <trans-unit id="b76b3b60499b4c2e88bf9b78e6177bbe474e3aec" translate="yes" xml:space="preserve">
          <source>This is due to &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;operator precedence&lt;/a&gt;. The &lt;code&gt;or&lt;/code&gt; operator has a lower precedence than the &lt;code&gt;==&lt;/code&gt; test, so the latter is evaluated &lt;em&gt;first&lt;/em&gt;.</source>
          <target state="translated">これは、 &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;演算子の優先順位&lt;/a&gt;によるものです。 &lt;code&gt;or&lt;/code&gt; 演算子は &lt;code&gt;==&lt;/code&gt; テストよりも優先順位が低いため、後者が&lt;em&gt;最初に&lt;/em&gt;評価されます。</target>
        </trans-unit>
        <trans-unit id="64ddaf83d2f60c93d468c3e3ed9699c922958fe5" translate="yes" xml:space="preserve">
          <source>This way, the whole solution is O(n).</source>
          <target state="translated">このようにして、全体の解はO(n)である。</target>
        </trans-unit>
        <trans-unit id="976528b0a8c35bea07e6bc2601aec4299b2bbaa5" translate="yes" xml:space="preserve">
          <source>This will help you.</source>
          <target state="translated">これはあなたのお役に立てるでしょう。</target>
        </trans-unit>
        <trans-unit id="e02cbb19fa7a225098185240eafb7f7ac151e94f" translate="yes" xml:space="preserve">
          <source>This will work, but &lt;em&gt;if&lt;/em&gt; you are comfortable using dictionaries (see what I did there), you can clean this up by making an initial dictionary mapping the numbers to the letters you want, then just using a for-loop:</source>
          <target state="translated">これは機能しますが、辞書を使い慣れている場合は（ここで何をしたかを参照）、最初の辞書で数字と必要な文字をマッピングし、forループを使用するだけでこれをクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="9f43c35e265188c85ff1afeb217ad718c6c95ddf" translate="yes" xml:space="preserve">
          <source>To check if a value is contained within a set of variables you can use the inbuilt modules           &lt;code&gt;itertools&lt;/code&gt; and &lt;code&gt;operator&lt;/code&gt;.</source>
          <target state="translated">値が変数のセット内に含まれているかどうかを確認するには、組み込みモジュール &lt;code&gt;itertools&lt;/code&gt; および &lt;code&gt;operator&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="09e954d89ce8c7bc163dfa546dbd624e5392f2f1" translate="yes" xml:space="preserve">
          <source>To test multiple values with one variable: &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</source>
          <target state="translated">1つの変数で複数の値をテストするには： &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc35f0f0fd5eec1aaf32678ec2edbf03c38ad94" translate="yes" xml:space="preserve">
          <source>To test multiple variables with one single value: &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</source>
          <target state="translated">1つの値で複数の変数をテストするには： &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="383327b199376946b76f635409e672afc9428011" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;itertools&lt;/code&gt; to allow repetition of the variables:</source>
          <target state="translated">&lt;code&gt;itertools&lt;/code&gt; を使用して、変数の繰り返しを許可します。</target>
        </trans-unit>
        <trans-unit id="da0755287f2d9299b4491cae5b9510ea0010f29b" translate="yes" xml:space="preserve">
          <source>Use math if formula &lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&lt;/a&gt;</source>
          <target state="translated">式&lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315の&lt;/a&gt;場合は数学を使用</target>
        </trans-unit>
        <trans-unit id="e1a45a1688e274b044e5e867e0b1b31411fbb885" translate="yes" xml:space="preserve">
          <source>Using his advice you would now have separate if-statements so that Python will read each statement whether the former were &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. Such as:</source>
          <target state="translated">彼のアドバイスを使用すると、前のステートメントが &lt;code&gt;True&lt;/code&gt; であるか &lt;code&gt;False&lt;/code&gt; であるかに関係なく、Pythonが各ステートメントを読み取るように、個別のifステートメントを持つことになります。 といった：</target>
        </trans-unit>
        <trans-unit id="fa259d374a6e092a09201c87a89ba6bbe7a0a01b" translate="yes" xml:space="preserve">
          <source>What they ignore is the broader implication of the question:</source>
          <target state="translated">彼らが無視しているのは、この問題のより広い意味合いです。</target>
        </trans-unit>
        <trans-unit id="465745f8cd0620d2b944ef260d792fc24f700e94" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;or&lt;/code&gt;, python sees each side of the operator as &lt;em&gt;separate&lt;/em&gt; expressions. The expression &lt;code&gt;x or y == 1&lt;/code&gt; is treated as first a boolean test for &lt;code&gt;x&lt;/code&gt;, then if that is False, the expression &lt;code&gt;y == 1&lt;/code&gt; is tested.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; を使用すると 、Pythonは演算子の両側を&lt;em&gt;別々の&lt;/em&gt;式として認識&lt;em&gt;し&lt;/em&gt;ます。 式 &lt;code&gt;x or y == 1&lt;/code&gt; は最初に &lt;code&gt;x&lt;/code&gt; のブールテストとして扱われ、それがFalseの場合、式 &lt;code&gt;y == 1&lt;/code&gt; がテストされます。</target>
        </trans-unit>
        <trans-unit id="25f4f2e41824dc0d2846681f279f695d252a4904" translate="yes" xml:space="preserve">
          <source>While the pattern for testing multiple values</source>
          <target state="translated">複数の値をテストするパターンがある一方で</target>
        </trans-unit>
        <trans-unit id="04351719ba6eeda9d512f672fb8d394087b1da53" translate="yes" xml:space="preserve">
          <source>While this expression returns the right result it is not as readable as the first expression :-(</source>
          <target state="translated">この式は正しい結果を返しますが、最初の式ほど読みやすくはありません。</target>
        </trans-unit>
        <trans-unit id="601535d04ee42bf736205a2ff11e82514bc43d41" translate="yes" xml:space="preserve">
          <source>Without dict, try this solution:</source>
          <target state="translated">ディクトがなければ、この解決策を試してみてください。</target>
        </trans-unit>
        <trans-unit id="d029b61b50b6116720d778dd5928e522a41cc72a" translate="yes" xml:space="preserve">
          <source>You can also put the numbers and letters in a dictionary and do it, but this is probably a LOT more complicated than simply if statements. That's what you get for trying to be extra lazy :)</source>
          <target state="translated">数字や文字を辞書に入れて実行することもできますが、これは単純なif文よりもLOT以上に複雑です。それは、あなたが余分な怠け者になろうとしているために得られるものです :)</target>
        </trans-unit>
        <trans-unit id="78915cb2d48c3749414c1966fb19060e5b9f882f" translate="yes" xml:space="preserve">
          <source>You can shorten that using a containment test against &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;a tuple&lt;/a&gt;:</source>
          <target state="translated">あなたは&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;タプル&lt;/a&gt;に対する包含テストを使用してそれを短くすることができます：</target>
        </trans-unit>
        <trans-unit id="b5c68d801513922b97394cc0e56a9e3610a25c00" translate="yes" xml:space="preserve">
          <source>You can try the method shown below. In this method, you will have the freedom to specify/input the number of variables that you wish to enter.</source>
          <target state="translated">以下のような方法を試してみてください。この方法では、入力する変数の数を自由に指定することができます。</target>
        </trans-unit>
        <trans-unit id="ebeccd592c6dfdcd746344abcf9e515154d74a0c" translate="yes" xml:space="preserve">
          <source>You can unite this</source>
          <target state="translated">あなたはこれを統一することができます。</target>
        </trans-unit>
        <trans-unit id="dfa11c78453d0ec1b15421a18df356fec7612bec" translate="yes" xml:space="preserve">
          <source>You can use dictionary :</source>
          <target state="translated">あなたは辞書を使用することができます。</target>
        </trans-unit>
        <trans-unit id="beb91eb796448d63880344240682408a11304d5e" translate="yes" xml:space="preserve">
          <source>You misunderstand how boolean expressions work; they don't work like an English sentence and guess that you are talking about the same comparison for all names here. You are looking for:</source>
          <target state="translated">あなたはブーリアン式がどのように機能するかを誤解しています。あなたが探しているのは</target>
        </trans-unit>
        <trans-unit id="ab683f096ab964a499ae8d8fde3d963f4031ce86" translate="yes" xml:space="preserve">
          <source>Your problem is more easily addressed with a dictionary structure like:</source>
          <target state="translated">あなたの問題は、次のような辞書構造を使えば、より簡単に解決できます。</target>
        </trans-unit>
        <trans-unit id="a344f069b3775d64cdc3efb7aab823d855e6f4db" translate="yes" xml:space="preserve">
          <source>[c]: &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[c]：（ &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d05021da9336e43f730afddf3adad2188ed178e" translate="yes" xml:space="preserve">
          <source>[d]: &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[d]： &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d496d3b60cd5b31edb48f670e7aaf9dd3d6898d1" translate="yes" xml:space="preserve">
          <source>and gives:</source>
          <target state="translated">と与える。</target>
        </trans-unit>
        <trans-unit id="706bcd4df4cc5b853edc6bed42ba01c222aa137f" translate="yes" xml:space="preserve">
          <source>and you'll have a total equation
express sum and you have total formula of sum</source>
          <target state="translated">で、合計式を表す和を持っているでしょうし、和の合計式を持っているでしょう。</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="ff787af4ae3cbab89d3875936b8cea159bbf1b2c" translate="yes" xml:space="preserve">
          <source>for this scenario it's easiest to convert to a string</source>
          <target state="translated">このシナリオでは、文字列に変換するのが最も簡単です。</target>
        </trans-unit>
        <trans-unit id="a38ef392dd476dd325dae11a6aaa28e439e53f31" translate="yes" xml:space="preserve">
          <source>in one variable.</source>
          <target state="translated">を1つの変数にまとめています。</target>
        </trans-unit>
        <trans-unit id="0c0690d6bac0cddb8d2eb4dc2ab0532025f7f332" translate="yes" xml:space="preserve">
          <source>is very readable and is working in many situation, there is one pitfall:</source>
          <target state="translated">は非常に読みやすく、多くの場面で活躍していますが、1つだけ落とし穴があります。</target>
        </trans-unit>
        <trans-unit id="b08e37624dce70b48b2a8b003d7ebb49075ab69e" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;and&lt;/code&gt; is the sum of squares of equations</source>
          <target state="translated">論理 &lt;code&gt;and&lt;/code&gt; あり、方程式の二乗の合計です</target>
        </trans-unit>
        <trans-unit id="50e930613ab6595d07ceb13b02a5a5b7e5384f24" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;or&lt;/code&gt; is the product of equations</source>
          <target state="translated">論理 &lt;code&gt;or&lt;/code&gt; 方程式の積</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="4c4561e5cc6655de9370d5a62358173a345d902b" translate="yes" xml:space="preserve">
          <source>or better still:</source>
          <target state="translated">というか、もっといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="e71003c6b7dd4093ce139ac0c51a6ba38d54a439" translate="yes" xml:space="preserve">
          <source>outputs</source>
          <target state="translated">outputs</target>
        </trans-unit>
        <trans-unit id="dc6e8247c55b9549a60ed2c399a59de52d6eb88c" translate="yes" xml:space="preserve">
          <source>the 3 letters &lt;code&gt;rot&lt;/code&gt; do exist in combination in the list but not as an individual word. Testing for &quot; rot &quot; would fail but if one of the list items were &quot;rot in hell&quot;, that would fail as well.</source>
          <target state="translated">&lt;code&gt;rot&lt;/code&gt; の3文字はリストに組み合わせて存在しますが、個別の単語としては存在しません。 「rot」のテストは失敗しますが、リスト項目の1つが「地獄で腐敗」した場合、それも失敗します。</target>
        </trans-unit>
        <trans-unit id="763e6fd8133d4e806ea0b3c7576ce67fc1973840" translate="yes" xml:space="preserve">
          <source>the program will check if the variable is not null. Another way to write the above statement (which makes more sense) is</source>
          <target state="translated">は変数がNULLでないかどうかをチェックします。上記の文を書くもう一つの方法は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="0d4ee4cc805fe94d1e25296222661ee3d0480bcc" translate="yes" xml:space="preserve">
          <source>then sum&amp;amp;1 is c, sum&amp;amp;2 is d, sum&amp;amp;4 is e, sum&amp;amp;5 is f</source>
          <target state="translated">次に、sum＆1はc、sum＆2はd、sum＆4はe、sum＆5はf</target>
        </trans-unit>
        <trans-unit id="4da38f55e44fda425afee7c334f3bbb00da18fa3" translate="yes" xml:space="preserve">
          <source>using &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt;a &lt;code&gt;set&lt;/code&gt;&lt;/a&gt; to take advantage of the constant-cost membership test (&lt;code&gt;in&lt;/code&gt; takes a fixed amount of time whatever the left-hand operand is).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt;を使用して 、一定コストのメンバーシップテストを利用 &lt;code&gt;in&lt;/code&gt; ます（ inには、左側のオペランドが何であれ、一定の時間がかかります）。</target>
        </trans-unit>
        <trans-unit id="9e7a7eba74ea8ce2cd328d7a815f59efbd72dcb3" translate="yes" xml:space="preserve">
          <source>which can be written as</source>
          <target state="translated">と書くことができます。</target>
        </trans-unit>
        <trans-unit id="9488fbc5a7f3e90e0acdddfadc35548836dda8cd" translate="yes" xml:space="preserve">
          <source>which would return a list of</source>
          <target state="translated">のリストを返します。</target>
        </trans-unit>
        <trans-unit id="564d92856586976259f387ac0dc96b269f78b744" translate="yes" xml:space="preserve">
          <source>will compile, but not in the way you want it to. When you simply put a variable in an if statement (example)</source>
          <target state="translated">はコンパイルされますが、あなたが望む方法ではありません。if 文の中に変数を入れただけの場合 (例)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
