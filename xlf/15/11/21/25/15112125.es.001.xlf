<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/15112125">
    <body>
      <group id="15112125">
        <trans-unit id="bb13107891e34020b269948fd348a93b39b4cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array[sum]&lt;/code&gt; gives you the string.</source>
          <target state="translated">&lt;code&gt;array[sum]&lt;/code&gt; te da la cadena.</target>
        </trans-unit>
        <trans-unit id="00588cd0b67586a0cf5791fdbf34e87aeb48bde5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x or y or z&lt;/code&gt; would evaluate to the first argument that is 'truthy', e.g. not &lt;code&gt;False&lt;/code&gt;, numeric 0 or empty (see &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;boolean expressions&lt;/a&gt; for details on what Python considers false in a boolean context).</source>
          <target state="translated">&lt;code&gt;x or y or z&lt;/code&gt; evaluar&amp;iacute;an el primer argumento que es 'verdadero', por ejemplo, no &lt;code&gt;False&lt;/code&gt; , num&amp;eacute;rico 0 o vac&amp;iacute;o (ver &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#boolean-operations&quot;&gt;expresiones booleanas&lt;/a&gt; para detalles sobre lo que Python considera falso en un contexto booleano).</target>
        </trans-unit>
        <trans-unit id="7333a0715f136dc925dd2e84ffcbba4920732a15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are otherwise evaluated on their own (&lt;code&gt;False&lt;/code&gt; if &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; otherwise).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; de lo contrario se eval&amp;uacute;an por s&amp;iacute; mismos ( &lt;code&gt;False&lt;/code&gt; si &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;True&lt;/code&gt; contrario).</target>
        </trans-unit>
        <trans-unit id="a927e3bcbbb2295c65e1e58e0e35bd1f4c7006df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I test one variable against multiple values?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;C&amp;oacute;mo pruebo una variable contra varios valores?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a411154b01054dc56c3b27fc9ca455c9da17006" translate="yes" xml:space="preserve">
          <source>A much more generalized approach is this:</source>
          <target state="translated">Un enfoque mucho más generalizado es este:</target>
        </trans-unit>
        <trans-unit id="e613cc0a40046d91ea55a26346590841af7fd423" translate="yes" xml:space="preserve">
          <source>After this you may form predefined array where index of string elements would correspond to ready string.</source>
          <target state="translated">Después de esto puede formar un conjunto predefinido donde el índice de elementos de cadena correspondería a la cadena lista.</target>
        </trans-unit>
        <trans-unit id="95917ca908e6a3eb5ee61cafb13cfde8ae85cc8b" translate="yes" xml:space="preserve">
          <source>All of the excellent answers provided here concentrate on the specific requirement of the original poster and concentrate on the &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; solution put forward by Martijn Pieters.</source>
          <target state="translated">Todas las excelentes respuestas proporcionadas aqu&amp;iacute; se concentran en el requisito espec&amp;iacute;fico del p&amp;oacute;ster original y se concentran en la soluci&amp;oacute;n &lt;code&gt;if 1 in {x,y,z}&lt;/code&gt; presentada por Martijn Pieters.</target>
        </trans-unit>
        <trans-unit id="6428e53a1aeab2edcca1712fc8659b2bade6a9ae" translate="yes" xml:space="preserve">
          <source>Another lazy way I found is :</source>
          <target state="translated">Otro camino perezoso que encontré es..:</target>
        </trans-unit>
        <trans-unit id="9019a09f9020d12c4c096c111a5eb6ce502a60af" translate="yes" xml:space="preserve">
          <source>Another option for checking if there is a non-zero (or False) value in a list:</source>
          <target state="translated">Otra opción para comprobar si hay un valor distinto de cero (o falso)en una lista:</target>
        </trans-unit>
        <trans-unit id="463015b4b607a45b6c5d9adefdb7bafe8183b458" translate="yes" xml:space="preserve">
          <source>As stated by Martijn Pieters, the correct, and fastest, format is:</source>
          <target state="translated">Como dijo Martijn Pieters,el formato correcto y más rápido es:</target>
        </trans-unit>
        <trans-unit id="b240cced7ab44159f960aafdc13c958949221c61" translate="yes" xml:space="preserve">
          <source>BTW lots of &lt;code&gt;if&lt;/code&gt;s could be written as something like this</source>
          <target state="translated">Por cierto, muchos s podr&amp;iacute;an escribirse como algo as&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="6713674f00a4357f6ef85c6bce361231e4a206d2" translate="yes" xml:space="preserve">
          <source>Bool is an inbuilt function in python which basically does the command of verifying a boolean statement (If you don't know what that is, it is what you are trying to make in your if statement right now :))</source>
          <target state="translated">Bool es una función incorporada en python que básicamente hace el comando de verificar una declaración booleana (Si no sabes lo que es,es lo que estás tratando de hacer en tu declaración if ahora mismo :))</target>
        </trans-unit>
        <trans-unit id="41b6db522df83ba9a596e29f6f04d041013d9cf2" translate="yes" xml:space="preserve">
          <source>But I dont think, you like it. :)
And this way is ugly.</source>
          <target state="translated">Pero no creo que te guste.:)Y este camino es feo.</target>
        </trans-unit>
        <trans-unit id="f4385a198702e69c09bb82aff84c16ebf742dbdb" translate="yes" xml:space="preserve">
          <source>But we want to have</source>
          <target state="translated">Pero queremos tener</target>
        </trans-unit>
        <trans-unit id="a27faa698dab470f11161204c4a25e5d0917c8c9" translate="yes" xml:space="preserve">
          <source>Change our conditions as:</source>
          <target state="translated">Cambiar nuestras condiciones como:</target>
        </trans-unit>
        <trans-unit id="b780eb53e7528543c4484d24e4b30675cddf5319" translate="yes" xml:space="preserve">
          <source>Connect these formulas by following logic:</source>
          <target state="translated">Conecta estas fórmulas siguiendo la lógica:</target>
        </trans-unit>
        <trans-unit id="23c906d120f6bb0d28e6c4b2296e9f78b4cc0aa1" translate="yes" xml:space="preserve">
          <source>Create mapping of values (in the order you want to check):</source>
          <target state="translated">Crear un mapeo de valores (en el orden que quieras comprobar):</target>
        </trans-unit>
        <trans-unit id="b3d64112baa428adb20e8915b333e2ce6d199205" translate="yes" xml:space="preserve">
          <source>Declare variables:</source>
          <target state="translated">Declare las variables:</target>
        </trans-unit>
        <trans-unit id="9b5b165b041692889344ce235bb138eb7edbf45a" translate="yes" xml:space="preserve">
          <source>Equivalent:</source>
          <target state="translated">Equivalent:</target>
        </trans-unit>
        <trans-unit id="3206d3885141933ea46755b030e35361dd3aa53a" translate="yes" xml:space="preserve">
          <source>Finally, use the &lt;code&gt;map&lt;/code&gt; function to create an iterator:</source>
          <target state="translated">Finalmente, use la funci&amp;oacute;n de &lt;code&gt;map&lt;/code&gt; a para crear un iterador:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="2e3f8c6b28df06279983427242677e0abbd1fa8a" translate="yes" xml:space="preserve">
          <source>How to test multiple variables against a value</source>
          <target state="translated">Cómo probar múltiples variables contra un valor</target>
        </trans-unit>
        <trans-unit id="1690068d3a18b79788b305f1805dff9306aea1d4" translate="yes" xml:space="preserve">
          <source>However, even if this were &lt;em&gt;not&lt;/em&gt; the case, and the expression &lt;code&gt;x or y or z == 1&lt;/code&gt; was actually interpreted as &lt;code&gt;(x or y or z) == 1&lt;/code&gt; instead, this would still not do what you expect it to do.</source>
          <target state="translated">Sin embargo, incluso si este &lt;em&gt;no fuera&lt;/em&gt; el caso, y la expresi&amp;oacute;n &lt;code&gt;x or y or z == 1&lt;/code&gt; realidad se interpretara como &lt;code&gt;(x or y or z) == 1&lt;/code&gt; , esto no har&amp;iacute;a lo que espera que haga.</target>
        </trans-unit>
        <trans-unit id="c9063492569248924935d1ea9f7cfe6e496aa7dc" translate="yes" xml:space="preserve">
          <source>I think this will handle it better:</source>
          <target state="translated">Creo que esto lo manejará mejor:</target>
        </trans-unit>
        <trans-unit id="e7fdd1510849adc6b77d33436dfb1654ceeac78f" translate="yes" xml:space="preserve">
          <source>I'm trying to make a function that will compare multiple variables to an integer and output a string of three letters. I was wondering if there was a way to translate this into Python. So say:</source>
          <target state="translated">Estoy tratando de hacer una función que compare múltiples variables con un número entero y produzca una cadena de tres letras.Me preguntaba si había una manera de traducir esto a Python.Digamos:</target>
        </trans-unit>
        <trans-unit id="7d80561cbf65d1c0ea7a693c438c4e00577ceedc" translate="yes" xml:space="preserve">
          <source>If this is what you want, the final line can be changed to:</source>
          <target state="translated">Si esto es lo que quieres,la línea final puede ser cambiada a:</target>
        </trans-unit>
        <trans-unit id="c69952c7d8f578cbfed512cc34620dae72d52a3e" translate="yes" xml:space="preserve">
          <source>If you ARE very very lazy, you can put the values inside an array. Such as</source>
          <target state="translated">Si eres muy,muy perezoso,puedes poner los valores dentro de una matriz.Como por ejemplo</target>
        </trans-unit>
        <trans-unit id="72a74a2a2fd5c0f05ff83572f16db3bbe8acbc27" translate="yes" xml:space="preserve">
          <source>If you want to use if, else statements following is another solution:</source>
          <target state="translated">Si quieres usar &quot;si&quot;,las declaraciones que siguen son otra solución:</target>
        </trans-unit>
        <trans-unit id="dceda35d497532579aeab70981b2e030e46924a2" translate="yes" xml:space="preserve">
          <source>Imports:</source>
          <target state="translated">Imports:</target>
        </trans-unit>
        <trans-unit id="6b27f3e9d1c3cfdf2ca592d7828d05fc3e224af9" translate="yes" xml:space="preserve">
          <source>Is something like this possible?</source>
          <target state="translated">¿Es posible algo así?</target>
        </trans-unit>
        <trans-unit id="2bfaf3bf3b08cf7e4ccd8996e5fed256fbd43ffe" translate="yes" xml:space="preserve">
          <source>It can be done easily as</source>
          <target state="translated">Se puede hacer fácilmente como</target>
        </trans-unit>
        <trans-unit id="866644b51b9d40ebeffc45ee2336b9f986861514" translate="yes" xml:space="preserve">
          <source>It should be noted however, as mentioned by &lt;code&gt;@codeforester&lt;/code&gt;, that word boundries are lost with this method, as in:</source>
          <target state="translated">Sin embargo, debe tenerse en cuenta, como mencion&amp;oacute; &lt;code&gt;@codeforester&lt;/code&gt; , que los l&amp;iacute;mites de palabras se pierden con este m&amp;eacute;todo, como en:</target>
        </trans-unit>
        <trans-unit id="0c7d38a7015e5383cb6fc3ee40ad8694bcba4672" translate="yes" xml:space="preserve">
          <source>Let's map to bits: &lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'c':1 'd':0xb10 'e':0xb100 'f':0xb1000&lt;/code&gt; bits: 'c': 1 'd': 0xb10 'e': 0xb100 'f': 0xb1000</target>
        </trans-unit>
        <trans-unit id="b76db2cdb6855d81571463add9d07d4e3fcf49f0" translate="yes" xml:space="preserve">
          <source>Looks like you're building some kind of Caesar cipher.</source>
          <target state="translated">Parece que estás construyendo algún tipo de cifrado César.</target>
        </trans-unit>
        <trans-unit id="8be0a31f87a698daba296424953326b97e6ca455" translate="yes" xml:space="preserve">
          <source>Maybe you need direct formula for output bits set.</source>
          <target state="translated">Tal vez necesites una fórmula directa para el conjunto de bits de salida.</target>
        </trans-unit>
        <trans-unit id="db2986760ee39be8694759a7e5ec189dead87b8f" translate="yes" xml:space="preserve">
          <source>Not sure if it's a desired side effect of your code, but the order of your output will always be sorted.</source>
          <target state="translated">No estoy seguro de si es un efecto secundario deseado de su código,pero el orden de su salida siempre será ordenado.</target>
        </trans-unit>
        <trans-unit id="8bb632d18f18c3ca5e853e32c7ff5745a62aec16" translate="yes" xml:space="preserve">
          <source>One generalization of the previous expression is based on the answer from &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt;:</source>
          <target state="translated">Una generalizaci&amp;oacute;n de la expresi&amp;oacute;n anterior se basa en la respuesta de &lt;a href=&quot;https://stackoverflow.com/a/30430962/5599281&quot;&gt;ytpillai&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e90d1db2c08d51cdaf3208d19c329897e23d3bf2" translate="yes" xml:space="preserve">
          <source>One line solution:</source>
          <target state="translated">Solución de una línea:</target>
        </trans-unit>
        <trans-unit id="b9e703ebdcfd19c006b401c977efdb5773365151" translate="yes" xml:space="preserve">
          <source>One more thing, your</source>
          <target state="translated">Una cosa más,tu</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="1a9aedec59b804a602ad84ba70cbffa39d7afe06" translate="yes" xml:space="preserve">
          <source>Relation of isc (is 'c'):</source>
          <target state="translated">Relación de isc (es 'c'):</target>
        </trans-unit>
        <trans-unit id="c47635a32643194fa5c1d73ffb3364cb2ce7e2a8" translate="yes" xml:space="preserve">
          <source>Set is the good approach here, because it orders the variables, what seems to be your goal here. &lt;code&gt;{z,y,x}&lt;/code&gt; is &lt;code&gt;{0,1,3}&lt;/code&gt; whatever the order of the parameters.</source>
          <target state="translated">Establecer es el buen enfoque aqu&amp;iacute;, porque ordena las variables, lo que parece ser su objetivo aqu&amp;iacute;. &lt;code&gt;{z,y,x}&lt;/code&gt; es &lt;code&gt;{0,1,3}&lt;/code&gt; sea ​​cual sea el orden de los par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="d5bddac5fdbd073da63065edd9f73643283d8644" translate="yes" xml:space="preserve">
          <source>So for the values &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt;, &lt;code&gt;x or y or z&lt;/code&gt; would resolve to &lt;code&gt;2&lt;/code&gt;, because that is the first true-like value in the arguments. Then &lt;code&gt;2 == 1&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;, even though &lt;code&gt;y == 1&lt;/code&gt; would be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Entonces para los valores &lt;code&gt;x = 2; y = 1; z = 0&lt;/code&gt; y = 1; z = 0 , &lt;code&gt;x or y or z&lt;/code&gt; se resolver&amp;iacute;an a &lt;code&gt;2&lt;/code&gt; , porque ese es el primer valor verdadero en los argumentos. Entonces &lt;code&gt;2 == 1&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;False&lt;/code&gt; , aunque &lt;code&gt;y == 1&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="3c900b3d5f08fdcdc1f78f0317f9c51f8053bb56" translate="yes" xml:space="preserve">
          <source>Test if the string &quot;Wild&quot; is in multiple values</source>
          <target state="translated">Pruebe si la cadena &quot;Wild&quot; está en múltiples valores</target>
        </trans-unit>
        <trans-unit id="c927be0e598ed66db0dc371da49441cdc8cadf17" translate="yes" xml:space="preserve">
          <source>The direct way to write &lt;code&gt;x or y or z == 0&lt;/code&gt; is</source>
          <target state="translated">La forma directa de escribir &lt;code&gt;x or y or z == 0&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="fc79ed71050b9a0c16fbfdf7c524bf2d41b13800" translate="yes" xml:space="preserve">
          <source>The most mnemonic way of representing your pseudo-code in Python would be:</source>
          <target state="translated">La forma más mnemotécnica de representar su pseudo-código en Python sería:</target>
        </trans-unit>
        <trans-unit id="04b4257a2c3bf690535db945de6a3fab6f05b7ed" translate="yes" xml:space="preserve">
          <source>The other way (a better) is:</source>
          <target state="translated">La otra forma (una mejor)es:</target>
        </trans-unit>
        <trans-unit id="3791bfd4543d9a856e18c50dbc04720b33ace4b2" translate="yes" xml:space="preserve">
          <source>The same would apply to the inverse; testing multiple values against a single variable; &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; would fail for the same reasons. Use &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; or &lt;code&gt;x in {1, 2, 3}&lt;/code&gt;.</source>
          <target state="translated">Lo mismo se aplicar&amp;iacute;a a la inversa; probar m&amp;uacute;ltiples valores contra una sola variable; &lt;code&gt;x == 1 or 2 or 3&lt;/code&gt; fallar&amp;iacute;an por las mismas razones. Use &lt;code&gt;x == 1 or x == 2 or x == 3&lt;/code&gt; o &lt;code&gt;x in {1, 2, 3}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41fa9fcaf3429d85247374d4e6bd0000c1558845" translate="yes" xml:space="preserve">
          <source>The solution provided will not work for partial hits if using strings for example:</source>
          <target state="translated">La solución proporcionada no funcionará para los golpes parciales si se utilizan cuerdas,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="68d01441f9f74a616b4d6a83968653d4293606f8" translate="yes" xml:space="preserve">
          <source>The upshot being, be careful with your search criteria if using this method and be aware that it does have this limitation.</source>
          <target state="translated">El resultado es que hay que tener cuidado con los criterios de búsqueda si se utiliza este método y tener en cuenta que tiene esta limitación.</target>
        </trans-unit>
        <trans-unit id="6b968f041fb97521d879885b45db4504e7a1b225" translate="yes" xml:space="preserve">
          <source>Then, when checking for the values (in the original order), use &lt;code&gt;next()&lt;/code&gt;:</source>
          <target state="translated">Luego, al verificar los valores (en el orden original), use &lt;code&gt;next()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="244cf7d4aacadf87fa117ebf501e2c69320b9911" translate="yes" xml:space="preserve">
          <source>This code may be helpful</source>
          <target state="translated">Este código puede ser útil</target>
        </trans-unit>
        <trans-unit id="b603f08a1f26476f174439270377be0254a39c6b" translate="yes" xml:space="preserve">
          <source>This has an advantage over the &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; because &lt;code&gt;operator&lt;/code&gt; is an inbuilt module and is faster and more efficient than using &lt;code&gt;lambda&lt;/code&gt; which has to create a custom in-place function.</source>
          <target state="translated">Esto tiene una ventaja sobre el &lt;code&gt;lambda x: x in (variables)&lt;/code&gt; porque el &lt;code&gt;operator&lt;/code&gt; es un m&amp;oacute;dulo incorporado y es m&amp;aacute;s r&amp;aacute;pido y m&amp;aacute;s eficiente que usar &lt;code&gt;lambda&lt;/code&gt; , que tiene que crear una funci&amp;oacute;n in situ personalizada.</target>
        </trans-unit>
        <trans-unit id="b76b3b60499b4c2e88bf9b78e6177bbe474e3aec" translate="yes" xml:space="preserve">
          <source>This is due to &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;operator precedence&lt;/a&gt;. The &lt;code&gt;or&lt;/code&gt; operator has a lower precedence than the &lt;code&gt;==&lt;/code&gt; test, so the latter is evaluated &lt;em&gt;first&lt;/em&gt;.</source>
          <target state="translated">Esto se debe a la &lt;a href=&quot;http://docs.python.org/2/reference/expressions.html#operator-precedence&quot;&gt;precedencia del operador&lt;/a&gt; . El operador &lt;code&gt;or&lt;/code&gt; tiene una precedencia menor que la prueba &lt;code&gt;==&lt;/code&gt; , por lo que este &amp;uacute;ltimo se eval&amp;uacute;a &lt;em&gt;primero&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64ddaf83d2f60c93d468c3e3ed9699c922958fe5" translate="yes" xml:space="preserve">
          <source>This way, the whole solution is O(n).</source>
          <target state="translated">De esta manera,la solución completa es O(n).</target>
        </trans-unit>
        <trans-unit id="976528b0a8c35bea07e6bc2601aec4299b2bbaa5" translate="yes" xml:space="preserve">
          <source>This will help you.</source>
          <target state="translated">Esto te ayudará.</target>
        </trans-unit>
        <trans-unit id="e02cbb19fa7a225098185240eafb7f7ac151e94f" translate="yes" xml:space="preserve">
          <source>This will work, but &lt;em&gt;if&lt;/em&gt; you are comfortable using dictionaries (see what I did there), you can clean this up by making an initial dictionary mapping the numbers to the letters you want, then just using a for-loop:</source>
          <target state="translated">Esto funcionar&amp;aacute;, pero &lt;em&gt;si&lt;/em&gt; se siente c&amp;oacute;modo usando diccionarios (vea lo que hice all&amp;iacute;), puede limpiar esto haciendo un diccionario inicial que asigne los n&amp;uacute;meros a las letras que desea, luego simplemente usando un bucle for:</target>
        </trans-unit>
        <trans-unit id="9f43c35e265188c85ff1afeb217ad718c6c95ddf" translate="yes" xml:space="preserve">
          <source>To check if a value is contained within a set of variables you can use the inbuilt modules           &lt;code&gt;itertools&lt;/code&gt; and &lt;code&gt;operator&lt;/code&gt;.</source>
          <target state="translated">Para verificar si un valor est&amp;aacute; contenido dentro de un conjunto de variables, puede usar las &lt;code&gt;itertools&lt;/code&gt; y el &lt;code&gt;operator&lt;/code&gt; integrados de los m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="09e954d89ce8c7bc163dfa546dbd624e5392f2f1" translate="yes" xml:space="preserve">
          <source>To test multiple values with one variable: &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</source>
          <target state="translated">Para probar m&amp;uacute;ltiples valores con una variable: &lt;code&gt;if a in {1, 2, 3}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc35f0f0fd5eec1aaf32678ec2edbf03c38ad94" translate="yes" xml:space="preserve">
          <source>To test multiple variables with one single value: &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</source>
          <target state="translated">Para probar m&amp;uacute;ltiples variables con un solo valor: &lt;code&gt;if 1 in {a,b,c}:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="383327b199376946b76f635409e672afc9428011" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;itertools&lt;/code&gt; to allow repetition of the variables:</source>
          <target state="translated">Use &lt;code&gt;itertools&lt;/code&gt; para permitir la repetici&amp;oacute;n de las variables:</target>
        </trans-unit>
        <trans-unit id="da0755287f2d9299b4491cae5b9510ea0010f29b" translate="yes" xml:space="preserve">
          <source>Use math if formula &lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&lt;/a&gt;</source>
          <target state="translated">Use las matem&amp;aacute;ticas si la f&amp;oacute;rmula &lt;a href=&quot;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&quot;&gt;https://youtu.be/KAdKCgBGK0k?list=PLnI9xbPdZUAmUL8htSl6vToPQRRN3hhFp&amp;amp;t=315&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1a45a1688e274b044e5e867e0b1b31411fbb885" translate="yes" xml:space="preserve">
          <source>Using his advice you would now have separate if-statements so that Python will read each statement whether the former were &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. Such as:</source>
          <target state="translated">Usando su consejo, ahora tendr&amp;iacute;a declaraciones if separadas para que Python lea cada declaraci&amp;oacute;n si las primeras eran &lt;code&gt;True&lt;/code&gt; o &lt;code&gt;False&lt;/code&gt; . Como:</target>
        </trans-unit>
        <trans-unit id="fa259d374a6e092a09201c87a89ba6bbe7a0a01b" translate="yes" xml:space="preserve">
          <source>What they ignore is the broader implication of the question:</source>
          <target state="translated">Lo que ignoran es la implicación más amplia de la cuestión:</target>
        </trans-unit>
        <trans-unit id="465745f8cd0620d2b944ef260d792fc24f700e94" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;or&lt;/code&gt;, python sees each side of the operator as &lt;em&gt;separate&lt;/em&gt; expressions. The expression &lt;code&gt;x or y == 1&lt;/code&gt; is treated as first a boolean test for &lt;code&gt;x&lt;/code&gt;, then if that is False, the expression &lt;code&gt;y == 1&lt;/code&gt; is tested.</source>
          <target state="translated">Cuando usa &lt;code&gt;or&lt;/code&gt; , python ve cada lado del operador como expresiones &lt;em&gt;separadas&lt;/em&gt; . La expresi&amp;oacute;n &lt;code&gt;x or y == 1&lt;/code&gt; se trata primero como una prueba booleana para &lt;code&gt;x&lt;/code&gt; , luego, si eso es Falso, se prueba la expresi&amp;oacute;n &lt;code&gt;y == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25f4f2e41824dc0d2846681f279f695d252a4904" translate="yes" xml:space="preserve">
          <source>While the pattern for testing multiple values</source>
          <target state="translated">Mientras que el patrón para probar valores múltiples</target>
        </trans-unit>
        <trans-unit id="04351719ba6eeda9d512f672fb8d394087b1da53" translate="yes" xml:space="preserve">
          <source>While this expression returns the right result it is not as readable as the first expression :-(</source>
          <target state="translated">Aunque esta expresión devuelve el resultado correcto,no es tan legible como la primera expresión :-(</target>
        </trans-unit>
        <trans-unit id="601535d04ee42bf736205a2ff11e82514bc43d41" translate="yes" xml:space="preserve">
          <source>Without dict, try this solution:</source>
          <target state="translated">Sin dictados,intente esta solución:</target>
        </trans-unit>
        <trans-unit id="d029b61b50b6116720d778dd5928e522a41cc72a" translate="yes" xml:space="preserve">
          <source>You can also put the numbers and letters in a dictionary and do it, but this is probably a LOT more complicated than simply if statements. That's what you get for trying to be extra lazy :)</source>
          <target state="translated">También puedes poner los números y las letras en un diccionario y hacerlo,pero esto es probablemente MUCHO más complicado que simplemente si las declaraciones.Eso es lo que obtienes por tratar de ser extra perezoso :)</target>
        </trans-unit>
        <trans-unit id="78915cb2d48c3749414c1966fb19060e5b9f882f" translate="yes" xml:space="preserve">
          <source>You can shorten that using a containment test against &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;a tuple&lt;/a&gt;:</source>
          <target state="translated">Puede acortar eso usando una prueba de contenci&amp;oacute;n contra &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences&quot;&gt;una tupla&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b5c68d801513922b97394cc0e56a9e3610a25c00" translate="yes" xml:space="preserve">
          <source>You can try the method shown below. In this method, you will have the freedom to specify/input the number of variables that you wish to enter.</source>
          <target state="translated">Puede probar el método que se muestra a continuación.En este método,usted tendrá la libertad de especificar el número de variables que desea introducir.</target>
        </trans-unit>
        <trans-unit id="ebeccd592c6dfdcd746344abcf9e515154d74a0c" translate="yes" xml:space="preserve">
          <source>You can unite this</source>
          <target state="translated">Puedes unir esto</target>
        </trans-unit>
        <trans-unit id="dfa11c78453d0ec1b15421a18df356fec7612bec" translate="yes" xml:space="preserve">
          <source>You can use dictionary :</source>
          <target state="translated">Puedes usar el diccionario:</target>
        </trans-unit>
        <trans-unit id="beb91eb796448d63880344240682408a11304d5e" translate="yes" xml:space="preserve">
          <source>You misunderstand how boolean expressions work; they don't work like an English sentence and guess that you are talking about the same comparison for all names here. You are looking for:</source>
          <target state="translated">No entiendes cómo funcionan las expresiones booleanas;no funcionan como una frase en inglés y supongo que estás hablando de la misma comparación para todos los nombres aquí.Lo que está buscando:</target>
        </trans-unit>
        <trans-unit id="ab683f096ab964a499ae8d8fde3d963f4031ce86" translate="yes" xml:space="preserve">
          <source>Your problem is more easily addressed with a dictionary structure like:</source>
          <target state="translated">Su problema se aborda más fácilmente con una estructura de diccionario como:</target>
        </trans-unit>
        <trans-unit id="a344f069b3775d64cdc3efb7aab823d855e6f4db" translate="yes" xml:space="preserve">
          <source>[c]: &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[c]: &lt;code&gt;(xyz=0 and isc=1) or (((xyz=0 and isc=1) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d05021da9336e43f730afddf3adad2188ed178e" translate="yes" xml:space="preserve">
          <source>[d]: &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</source>
          <target state="translated">[d]: &lt;code&gt;((x-1)(y-1)(z-1)=0 and isc=2) or (((xyz=0 and isd=2) or (isc=0)) and (isc=0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d496d3b60cd5b31edb48f670e7aaf9dd3d6898d1" translate="yes" xml:space="preserve">
          <source>and gives:</source>
          <target state="translated">y da:</target>
        </trans-unit>
        <trans-unit id="706bcd4df4cc5b853edc6bed42ba01c222aa137f" translate="yes" xml:space="preserve">
          <source>and you'll have a total equation
express sum and you have total formula of sum</source>
          <target state="translated">y tendrás una ecuación total que exprese la suma y tendrás la fórmula total de la suma</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="ff787af4ae3cbab89d3875936b8cea159bbf1b2c" translate="yes" xml:space="preserve">
          <source>for this scenario it's easiest to convert to a string</source>
          <target state="translated">para este escenario es más fácil convertirlo en una cadena</target>
        </trans-unit>
        <trans-unit id="a38ef392dd476dd325dae11a6aaa28e439e53f31" translate="yes" xml:space="preserve">
          <source>in one variable.</source>
          <target state="translated">en una variable.</target>
        </trans-unit>
        <trans-unit id="0c0690d6bac0cddb8d2eb4dc2ab0532025f7f332" translate="yes" xml:space="preserve">
          <source>is very readable and is working in many situation, there is one pitfall:</source>
          <target state="translated">es muy legible y funciona en muchas situaciones,hay una trampa:</target>
        </trans-unit>
        <trans-unit id="b08e37624dce70b48b2a8b003d7ebb49075ab69e" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;and&lt;/code&gt; is the sum of squares of equations</source>
          <target state="translated">l&amp;oacute;gica &lt;code&gt;and&lt;/code&gt; es la suma de cuadrados de ecuaciones</target>
        </trans-unit>
        <trans-unit id="50e930613ab6595d07ceb13b02a5a5b7e5384f24" translate="yes" xml:space="preserve">
          <source>logic &lt;code&gt;or&lt;/code&gt; is the product of equations</source>
          <target state="translated">l&amp;oacute;gica &lt;code&gt;or&lt;/code&gt; es el producto de ecuaciones</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="4c4561e5cc6655de9370d5a62358173a345d902b" translate="yes" xml:space="preserve">
          <source>or better still:</source>
          <target state="translated">o mejor aún:</target>
        </trans-unit>
        <trans-unit id="e71003c6b7dd4093ce139ac0c51a6ba38d54a439" translate="yes" xml:space="preserve">
          <source>outputs</source>
          <target state="translated">outputs</target>
        </trans-unit>
        <trans-unit id="dc6e8247c55b9549a60ed2c399a59de52d6eb88c" translate="yes" xml:space="preserve">
          <source>the 3 letters &lt;code&gt;rot&lt;/code&gt; do exist in combination in the list but not as an individual word. Testing for &quot; rot &quot; would fail but if one of the list items were &quot;rot in hell&quot;, that would fail as well.</source>
          <target state="translated">Las 3 letras &lt;code&gt;rot&lt;/code&gt; existen en combinaci&amp;oacute;n en la lista pero no como una palabra individual. La prueba de &quot;podredumbre&quot; fallar&amp;iacute;a, pero si uno de los elementos de la lista fuera &quot;podredumbre&quot;, tambi&amp;eacute;n fallar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="763e6fd8133d4e806ea0b3c7576ce67fc1973840" translate="yes" xml:space="preserve">
          <source>the program will check if the variable is not null. Another way to write the above statement (which makes more sense) is</source>
          <target state="translated">el programa comprobará si la variable no es nula.Otra forma de escribir la declaración anterior (que tiene más sentido)es</target>
        </trans-unit>
        <trans-unit id="0d4ee4cc805fe94d1e25296222661ee3d0480bcc" translate="yes" xml:space="preserve">
          <source>then sum&amp;amp;1 is c, sum&amp;amp;2 is d, sum&amp;amp;4 is e, sum&amp;amp;5 is f</source>
          <target state="translated">entonces sum &amp;amp; 1 es c, sum &amp;amp; 2 es d, sum &amp;amp; 4 es e, sum &amp;amp; 5 es f</target>
        </trans-unit>
        <trans-unit id="4da38f55e44fda425afee7c334f3bbb00da18fa3" translate="yes" xml:space="preserve">
          <source>using &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt;a &lt;code&gt;set&lt;/code&gt;&lt;/a&gt; to take advantage of the constant-cost membership test (&lt;code&gt;in&lt;/code&gt; takes a fixed amount of time whatever the left-hand operand is).</source>
          <target state="translated">usando &lt;a href=&quot;https://docs.python.org/3/tutorial/datastructures.html#sets&quot;&gt;un &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; para aprovechar la prueba de membres&amp;iacute;a de costo constante ( &lt;code&gt;in&lt;/code&gt; un tiempo fijo, cualquiera que sea el operando de la izquierda).</target>
        </trans-unit>
        <trans-unit id="9e7a7eba74ea8ce2cd328d7a815f59efbd72dcb3" translate="yes" xml:space="preserve">
          <source>which can be written as</source>
          <target state="translated">que puede escribirse como</target>
        </trans-unit>
        <trans-unit id="9488fbc5a7f3e90e0acdddfadc35548836dda8cd" translate="yes" xml:space="preserve">
          <source>which would return a list of</source>
          <target state="translated">que devolvería una lista de</target>
        </trans-unit>
        <trans-unit id="564d92856586976259f387ac0dc96b269f78b744" translate="yes" xml:space="preserve">
          <source>will compile, but not in the way you want it to. When you simply put a variable in an if statement (example)</source>
          <target state="translated">se compilará,pero no de la manera que tú quieres.Cuando simplemente pones una variable en una declaración if (ejemplo)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
