<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/25203556">
    <body>
      <group id="25203556">
        <trans-unit id="c510d2e3eb78822e59de418242697b0036a06cff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;APIClient Initial Interface&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;APIClient初始接口&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fbc4cfbb8ed3c2e9e2e87bc959f96f26da6f10a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Completion Handler&lt;/strong&gt;
Inside set of block is executed and returned when source is available, Handler will wait until response comes so that UI can be updated after.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完成处理程序&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 内部的一组代码块在源可用时执行并返回，处理程序将等到响应到来之后才可以更新UI。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="96be8c32566abc60744917724e7efde3788f70b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Delegates&lt;/strong&gt;
Set of methods will get triggered when delegate is been called, Source must be provided via methods itself</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;委托&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 调用委托时将触发一组方法，必须通过方法本身提供源&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a52349be59d2dc0787abf428431179d1c994582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notification&lt;/strong&gt;
Bunch of information is triggered over all the app, Listner can retrieve n make use of that info. Async way of getting info through out the project.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通知&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 信息束在所有应用程序上触发，Listner可以检索n个信息。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过项目获取信息的异步​​方式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30e598d68bea586c7b116fd407356708bc4f521f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Swift 4.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;迅捷4.0&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f61d88d5c22ed9179275db42ae2b2a5f30ba3e95" translate="yes" xml:space="preserve">
          <source>An alternative approach would be to return a callback that will provide the data you need as soon as it is ready.</source>
          <target state="translated">另一种方法是返回一个回调,一旦准备好了,就会立即提供你所需要的数据。</target>
        </trans-unit>
        <trans-unit id="7ebbab529e9a4820968d3b93810887172271b741" translate="yes" xml:space="preserve">
          <source>And you&amp;rsquo;d call it like so:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以这样称呼它：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67c377687d3900d9ca07b9ce4951a6e91f755ee8" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not material here. The key issue is the use of completion handler to specify the block of code to be run when the asynchronous request is done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但这在这里并不重要。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键问题是使用完成处理程序来指定异步请求完成后要运行的代码块。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="154376a656eb7c75db283f478a773723f9e32779" translate="yes" xml:space="preserve">
          <source>Closures/Completion handler</source>
          <target state="translated">关闭完成处理程序</target>
        </trans-unit>
        <trans-unit id="7dcccba4f8856a9df41efcf1d5ea4f2cfd327cec" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegates</target>
        </trans-unit>
        <trans-unit id="f9bdfe712ac0a387c156acf24c7385e968fd6f97" translate="yes" xml:space="preserve">
          <source>For async Request-Response you can use completion handler. See below I have modified the solution with completion handle paradigm.</source>
          <target state="translated">对于Async Request-Response,你可以使用 completion handler。请看下面我用完成处理程序范式修改了解决方案。</target>
        </trans-unit>
        <trans-unit id="4342310e3ebcfb54bffb8ea8cecbe88a2d6082f6" translate="yes" xml:space="preserve">
          <source>For example, in the forthcoming Swift 5, you&amp;rsquo;d use &lt;code&gt;Result&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，在即将发布的Swift 5中，您将使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377ea4eb3ce60143f054182667aa0740de1f96a3" translate="yes" xml:space="preserve">
          <source>Hopefully will expand to a full Scala-style Promise eventually (I may write it myself at some point; I'm sure other PRs would be welcome; it's not that difficult with Future already in place).</source>
          <target state="translated">希望最终会扩展到一个完整的Scala风格的Promise(我可能会在某个时候自己写,我相信其他的PR会很受欢迎,因为Future已经有了,这并不难)。</target>
        </trans-unit>
        <trans-unit id="5a5285ec992e236e3e4c7bcc18b2ff2534c226cf" translate="yes" xml:space="preserve">
          <source>I do not recommend prefixing functions with &lt;code&gt;get&lt;/code&gt; in Swift. It will break certain kinds of interoperability with ObjC.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不建议&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Swift中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;get&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;前缀函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它将破坏与ObjC的某些互操作性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb97f7bf2cc0145e0d62c3441b05976a5078b82b" translate="yes" xml:space="preserve">
          <source>I have created a utility class in my Swift project that handles all the REST requests and responses. I have built a simple REST API so I can test my code. I have created a class method that needs to return an NSArray but because the API call is async I need to return from the method inside the async call. The problem is the async returns void.
If I were doing this in Node I would use JS promises but I can't figure out a solution that works in Swift.</source>
          <target state="translated">我在我的Swift项目中创建了一个实用类来处理所有的REST请求和响应。我建立了一个简单的REST API,这样我可以测试我的代码。我创建了一个需要返回一个NSArray的类方法,但由于API调用是异步调用,我需要在异步调用里面的方法返回。问题是Async返回的是void。如果我在Node中做这个,我会使用JS承诺,但我无法找到一个在Swift中工作的解决方案。</target>
        </trans-unit>
        <trans-unit id="4cab216081c44e467ea042d3bea6f1cf0163e308" translate="yes" xml:space="preserve">
          <source>I hope you're not still stuck on this, but the short answer is that you can't do this in Swift.</source>
          <target state="translated">希望你不要还在这个问题上纠结,简单的回答是,在Swift中你不能这样做。</target>
        </trans-unit>
        <trans-unit id="a85d34eee2c0dc7f329c3645e89473d576581cdc" translate="yes" xml:space="preserve">
          <source>I recommend parsing all the way down to a &lt;code&gt;Book&lt;/code&gt; object before returning your results as a &lt;code&gt;Future&lt;/code&gt;. There are several ways this system can fail, and it's much more convenient if you check for all of those things before wrapping them up into a &lt;code&gt;Future&lt;/code&gt;. Getting to &lt;code&gt;[Book]&lt;/code&gt; is much better for the rest of your Swift code than handing around an &lt;code&gt;NSArray&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我建议&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在将结果作为&lt;/font&gt; &lt;code&gt;Future&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回之前，先将其&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解析到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Book&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该系统可能会以多种方式发生故障，如果在将所有这些事情包装成&lt;/font&gt; &lt;code&gt;Future&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前检查所有这些事情，它会更加方便&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于Swift代码的其余部分，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进入&lt;/font&gt; &lt;code&gt;[Book]&lt;/code&gt; &lt;code&gt;NSArray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;要好得多&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f50b663530b96f939105fe7522c566d07248099" translate="yes" xml:space="preserve">
          <source>In your particular case, I would probably create a &lt;code&gt;Result&amp;lt;[Book]&amp;gt;&lt;/code&gt; (based on &lt;a href=&quot;http://nomothetis.svbtle.com/error-handling-in-swift-part-ii&quot;&gt;Alexandros Salazar's version of &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;). Then your method signature would be:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在您的特定情况下，我可能会创建一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Result&amp;lt;[Book]&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（基于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://nomothetis.svbtle.com/error-handling-in-swift-part-ii&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Alexandros Salazar的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;版本&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么您的方法签名将是：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="471af9c19515d20dd8b3e4e60b03f0f10772228b" translate="yes" xml:space="preserve">
          <source>Note, above I retired the use of &lt;code&gt;NSArray&lt;/code&gt; (we don&amp;rsquo;t use &lt;a href=&quot;https://developer.apple.com/documentation/foundation/object_runtime/classes_bridged_to_swift_standard_library_value_types&quot;&gt;those bridged Objective-C types&lt;/a&gt; any more). I assume that we had a &lt;code&gt;Genre&lt;/code&gt; type and we presumably used &lt;code&gt;JSONDecoder&lt;/code&gt;, rather than &lt;code&gt;JSONSerialization&lt;/code&gt;, to decode it. But this question didn&amp;rsquo;t have enough information about the underlying JSON to get into the details here, so I omitted that to avoid clouding the core issue, the use of closures as completion handlers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，以上我&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不再使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NSArray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（我们不再使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/object_runtime/classes_bridged_to_swift_standard_library_value_types&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那些桥接的Objective-C类型&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我假设我们具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Genre&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型，并且大概使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JSONDecoder&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JSONSerialization&lt;/code&gt; 对其&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行解码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是此问题没有足够的有关底层JSON的信息以在此处进行详细介绍，因此我为避免混淆核心问题（将闭包用作完成处理程序）而将其省略。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2498b7932a662e153f66faf7f57580fcc196795" translate="yes" xml:space="preserve">
          <source>Note, above I&amp;rsquo;m dispatching the completion handler back to the main queue to simplify model and UI updates. Some developers take exception to this practice and either use whatever queue &lt;code&gt;URLSession&lt;/code&gt; used or use their own queue (requiring the caller to manually synchronize the results themselves).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意，上面我将完成处理程序分派回主队列，以简化模型和UI更新。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一些开发人员对此做法表示例外，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;URLSession&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用的任何队列，也可以使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自己的队列（要求调用者自己手动同步结果）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="753a22b2eb617204efee4644795034b8ace1ee14" translate="yes" xml:space="preserve">
          <source>Notifications</source>
          <target state="translated">Notifications</target>
        </trans-unit>
        <trans-unit id="c3c7ca7344ce10210a898c17cb8bf8c0c6345900" translate="yes" xml:space="preserve">
          <source>Now Please check complete api structure</source>
          <target state="translated">现在,请检查完整的API结构</target>
        </trans-unit>
        <trans-unit id="ca2d425cef83128ec0a20ed97a298c67c80a9045" translate="yes" xml:space="preserve">
          <source>Observers can also be used to get notified once the async task has been completed.</source>
          <target state="translated">观察者也可以在异步任务完成后用来获得通知。</target>
        </trans-unit>
        <trans-unit id="95ea2250a94be92b9b5c99f8db93d804ceabeb6d" translate="yes" xml:space="preserve">
          <source>Returning data from async call in Swift function</source>
          <target state="translated">从Swift函数中的Async调用返回数据</target>
        </trans-unit>
        <trans-unit id="9ed518514a3cbea72d715d1d9c28704e12c8bc90" translate="yes" xml:space="preserve">
          <source>Swift 3 version of @Alexey Globchastyy's answer:</source>
          <target state="translated">Swift 3版本的@Alexey Globchastyy的回答。</target>
        </trans-unit>
        <trans-unit id="51cd39f7d75342cd8ca5614506b3faa58c351053" translate="yes" xml:space="preserve">
          <source>Swiftz already offers Future, which is the basic building block of a Promise. A Future is a Promise that cannot fail (all terms here are based on the Scala interpretation, &lt;a href=&quot;https://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala?rq=1&quot;&gt;where a Promise is a Monad&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Swiftz已经提供了Future，这是Promise的基本组成部分。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未来是一个不能失败的承诺（此处所有术语均基于Scala的解释，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala?rq=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其中Promise是Monad&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac1f9ef245a3b10e54a68e4a4bcce32858364623" translate="yes" xml:space="preserve">
          <source>The basic pattern is to use completion handlers closure.</source>
          <target state="translated">基本的模式是使用完成处理程序封闭。</target>
        </trans-unit>
        <trans-unit id="51fca48045be018843010b6a4c2c218f7615ed4d" translate="yes" xml:space="preserve">
          <source>The main thread is the UI thread, whenever you make an async task and you want to update the UI you must do all the UI changes on the UI thread</source>
          <target state="translated">主线程是UI线程,每当你做一个异步任务,想要更新UI时,你必须在UI线程上做所有的UI修改。</target>
        </trans-unit>
        <trans-unit id="0dccee69ee40909c637c9d01dee6680b7d63bdb6" translate="yes" xml:space="preserve">
          <source>The older, Swift 4 pattern is:</source>
          <target state="translated">老的,Swift 4的模式是。</target>
        </trans-unit>
        <trans-unit id="7e41ac91e7836703978c1c85deffd0fd393929f9" translate="yes" xml:space="preserve">
          <source>There are 3 ways of creating call back functions namely:
1. Completion handler
2. Notification
3. Delegates</source>
          <target state="translated">创建回调函数的方法有3种,即。1.完成处理程序 2.通知 3.委托处理程序</target>
        </trans-unit>
        <trans-unit id="4ef1f4651b9e21d01aa91ff891682983bbd68b47" translate="yes" xml:space="preserve">
          <source>There are mainly 3 ways of achieving callback in swift</source>
          <target state="translated">swift的回调主要有3种实现方式。</target>
        </trans-unit>
        <trans-unit id="c8cfd31c5f2fa380e4e81d4e1997fbf3ba87ba8c" translate="yes" xml:space="preserve">
          <source>There are some very generic requirements that would like every good API Manager to satisfy:
will implement a &lt;strong&gt;protocol-oriented API Client.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个优秀的API管理器都希望满足一些非常通用的要求：将实现&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;面向协议的API客户端。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6edf876e1dd16ba30ab1e7bb46d6abf5e4cadf9a" translate="yes" xml:space="preserve">
          <source>This is a small use case that might be helpful:-</source>
          <target state="translated">这是个小的用例,可能会有帮助:----</target>
        </trans-unit>
        <trans-unit id="6d93327a494f273f8373e66a922af984d7fa9ac9" translate="yes" xml:space="preserve">
          <source>Use completion blocks and activate then on the main thread.</source>
          <target state="translated">使用完成块,然后在主线程上激活。</target>
        </trans-unit>
        <trans-unit id="b107e7fde341f7c746ab2a50be30f16df2888d85" translate="yes" xml:space="preserve">
          <source>While calling the function:-</source>
          <target state="translated">当调用函数:-</target>
        </trans-unit>
        <trans-unit id="492600fc20952c19d7d564917a54861be600573c" translate="yes" xml:space="preserve">
          <source>You can call this function as below:</source>
          <target state="translated">你可以按照下面的方法调用这个函数。</target>
        </trans-unit>
        <trans-unit id="5f6fb05957878828dd52a0141b964038cd5da62a" translate="yes" xml:space="preserve">
          <source>You can pass callback, and call callback inside async call</source>
          <target state="translated">你可以通过回调,在Async call里面调用回调。</target>
        </trans-unit>
        <trans-unit id="ed2e7ade7b8198c94d3afc330e61c9876d6f2e31" translate="yes" xml:space="preserve">
          <source>and then call this method:</source>
          <target state="translated">然后调用这个方法。</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="1bc3878c5b1eaee17acdf12033cb2803a770ad3f" translate="yes" xml:space="preserve">
          <source>something like:</source>
          <target state="translated">诸如:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
