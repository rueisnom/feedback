<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/25203556">
    <body>
      <group id="25203556">
        <trans-unit id="c510d2e3eb78822e59de418242697b0036a06cff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;APIClient Initial Interface&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;APIClient Начальный интерфейс&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fbc4cfbb8ed3c2e9e2e87bc959f96f26da6f10a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Completion Handler&lt;/strong&gt;
Inside set of block is executed and returned when source is available, Handler will wait until response comes so that UI can be updated after.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обработчик завершения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Внутри набора блоков выполняется и возвращается, когда источник доступен, Обработчик будет ожидать ответа, чтобы после этого пользовательский интерфейс мог быть обновлен.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="96be8c32566abc60744917724e7efde3788f70b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Delegates&lt;/strong&gt;
Set of methods will get triggered when delegate is been called, Source must be provided via methods itself</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Делегаты&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Набор методов будет запущен при вызове делегата, источник должен быть предоставлен через сами методы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a52349be59d2dc0787abf428431179d1c994582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notification&lt;/strong&gt;
Bunch of information is triggered over all the app, Listner can retrieve n make use of that info. Async way of getting info through out the project.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Уведомление&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Куча информации запускается по всему приложению, Listner может извлечь и использовать эту информацию. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Асинхронный способ получения информации через проект.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30e598d68bea586c7b116fd407356708bc4f521f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Swift 4.0&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Swift 4.0&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f61d88d5c22ed9179275db42ae2b2a5f30ba3e95" translate="yes" xml:space="preserve">
          <source>An alternative approach would be to return a callback that will provide the data you need as soon as it is ready.</source>
          <target state="translated">Альтернативный подход заключается в возвращении обратного вызова,который предоставит необходимые данные,как только они будут готовы.</target>
        </trans-unit>
        <trans-unit id="7ebbab529e9a4820968d3b93810887172271b741" translate="yes" xml:space="preserve">
          <source>And you&amp;rsquo;d call it like so:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И вы бы назвали это так:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67c377687d3900d9ca07b9ce4951a6e91f755ee8" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not material here. The key issue is the use of completion handler to specify the block of code to be run when the asynchronous request is done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но это не материал здесь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ключевой вопрос заключается в использовании обработчика завершения для указания блока кода, который будет выполняться при выполнении асинхронного запроса.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="154376a656eb7c75db283f478a773723f9e32779" translate="yes" xml:space="preserve">
          <source>Closures/Completion handler</source>
          <target state="translated">ЗакрытияКомплексный обработчик</target>
        </trans-unit>
        <trans-unit id="7dcccba4f8856a9df41efcf1d5ea4f2cfd327cec" translate="yes" xml:space="preserve">
          <source>Delegates</source>
          <target state="translated">Delegates</target>
        </trans-unit>
        <trans-unit id="f9bdfe712ac0a387c156acf24c7385e968fd6f97" translate="yes" xml:space="preserve">
          <source>For async Request-Response you can use completion handler. See below I have modified the solution with completion handle paradigm.</source>
          <target state="translated">Для асинхронной реакции на запросы можно использовать обработчик завершения.Смотрите ниже,я модифицировал решение с парадигмой completion handle.</target>
        </trans-unit>
        <trans-unit id="4342310e3ebcfb54bffb8ea8cecbe88a2d6082f6" translate="yes" xml:space="preserve">
          <source>For example, in the forthcoming Swift 5, you&amp;rsquo;d use &lt;code&gt;Result&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, в предстоящем Swift 5 вы будете использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Result&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377ea4eb3ce60143f054182667aa0740de1f96a3" translate="yes" xml:space="preserve">
          <source>Hopefully will expand to a full Scala-style Promise eventually (I may write it myself at some point; I'm sure other PRs would be welcome; it's not that difficult with Future already in place).</source>
          <target state="translated">Надеюсь,что в конце концов оно распространится на полное Обещание в стиле Скала (я могу написать его сам в какой-то момент;я уверен,что другие PR будут приветствоваться;это не так уж и сложно,учитывая,что Будущее уже на месте).</target>
        </trans-unit>
        <trans-unit id="5a5285ec992e236e3e4c7bcc18b2ff2534c226cf" translate="yes" xml:space="preserve">
          <source>I do not recommend prefixing functions with &lt;code&gt;get&lt;/code&gt; in Swift. It will break certain kinds of interoperability with ObjC.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я не рекомендую префиксировать функции с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;get&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в Swift. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это нарушит определенные виды взаимодействия с ObjC.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb97f7bf2cc0145e0d62c3441b05976a5078b82b" translate="yes" xml:space="preserve">
          <source>I have created a utility class in my Swift project that handles all the REST requests and responses. I have built a simple REST API so I can test my code. I have created a class method that needs to return an NSArray but because the API call is async I need to return from the method inside the async call. The problem is the async returns void.
If I were doing this in Node I would use JS promises but I can't figure out a solution that works in Swift.</source>
          <target state="translated">В моем проекте Swift я создал утилиту-класс,которая обрабатывает все REST-запросы и ответы.Я создал простое API для REST,чтобы проверить свой код.Я создал метод класса,который должен возвращать NSArray,но так как вызов API является асинхронным,мне нужно возвращаться из метода внутри вызова async.Проблема заключается в том,что асинхронный вызов возвращается пустым.Если бы я делал это в Node,я бы использовал JS обещания,но не могу придумать решение,которое бы работало в Swift.</target>
        </trans-unit>
        <trans-unit id="4cab216081c44e467ea042d3bea6f1cf0163e308" translate="yes" xml:space="preserve">
          <source>I hope you're not still stuck on this, but the short answer is that you can't do this in Swift.</source>
          <target state="translated">Надеюсь,ты все еще не застрял на этом,но короткий ответ-ты не можешь сделать это в Свифте.</target>
        </trans-unit>
        <trans-unit id="a85d34eee2c0dc7f329c3645e89473d576581cdc" translate="yes" xml:space="preserve">
          <source>I recommend parsing all the way down to a &lt;code&gt;Book&lt;/code&gt; object before returning your results as a &lt;code&gt;Future&lt;/code&gt;. There are several ways this system can fail, and it's much more convenient if you check for all of those things before wrapping them up into a &lt;code&gt;Future&lt;/code&gt;. Getting to &lt;code&gt;[Book]&lt;/code&gt; is much better for the rest of your Swift code than handing around an &lt;code&gt;NSArray&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я рекомендую выполнить синтаксический анализ вплоть до &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;объекта &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Book&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; прежде чем возвращать результаты в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Future&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть несколько способов, которыми эта система может выйти из строя, и гораздо удобнее, если вы проверите все эти вещи, прежде чем свернуть их в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Future&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Добраться до &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[Book]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; гораздо лучше для остального кода Swift, чем использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NSArray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f50b663530b96f939105fe7522c566d07248099" translate="yes" xml:space="preserve">
          <source>In your particular case, I would probably create a &lt;code&gt;Result&amp;lt;[Book]&amp;gt;&lt;/code&gt; (based on &lt;a href=&quot;http://nomothetis.svbtle.com/error-handling-in-swift-part-ii&quot;&gt;Alexandros Salazar's version of &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;). Then your method signature would be:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В вашем конкретном случае я бы, вероятно, создал &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Result&amp;lt;[Book]&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (основываясь на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://nomothetis.svbtle.com/error-handling-in-swift-part-ii&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;версии &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Александроса Салазара&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тогда ваша подпись метода будет:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="471af9c19515d20dd8b3e4e60b03f0f10772228b" translate="yes" xml:space="preserve">
          <source>Note, above I retired the use of &lt;code&gt;NSArray&lt;/code&gt; (we don&amp;rsquo;t use &lt;a href=&quot;https://developer.apple.com/documentation/foundation/object_runtime/classes_bridged_to_swift_standard_library_value_types&quot;&gt;those bridged Objective-C types&lt;/a&gt; any more). I assume that we had a &lt;code&gt;Genre&lt;/code&gt; type and we presumably used &lt;code&gt;JSONDecoder&lt;/code&gt;, rather than &lt;code&gt;JSONSerialization&lt;/code&gt;, to decode it. But this question didn&amp;rsquo;t have enough information about the underlying JSON to get into the details here, so I omitted that to avoid clouding the core issue, the use of closures as completion handlers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что выше я &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NSArray&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; использование &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;NSArray&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (мы больше не используем &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://developer.apple.com/documentation/foundation/object_runtime/classes_bridged_to_swift_standard_library_value_types&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;эти соединенные типы Objective-C&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я предполагаю, что у нас был &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;тип &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Genre&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и мы предположительно использовали &lt;/font&gt;&lt;/font&gt; &lt;code&gt;JSONDecoder&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а не &lt;/font&gt;&lt;/font&gt; &lt;code&gt;JSONSerialization&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , чтобы декодировать его. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но у этого вопроса не было достаточно информации о базовом JSON, чтобы вдаваться в подробности, поэтому я пропустил это, чтобы не затуманивать основную проблему - использование замыканий в качестве обработчиков завершения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2498b7932a662e153f66faf7f57580fcc196795" translate="yes" xml:space="preserve">
          <source>Note, above I&amp;rsquo;m dispatching the completion handler back to the main queue to simplify model and UI updates. Some developers take exception to this practice and either use whatever queue &lt;code&gt;URLSession&lt;/code&gt; used or use their own queue (requiring the caller to manually synchronize the results themselves).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что выше я отправляю обработчик завершения обратно в основную очередь, чтобы упростить обновления модели и пользовательского интерфейса. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Некоторые разработчики &lt;/font&gt;&lt;/font&gt; &lt;code&gt;URLSession&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; против этой практики и используют либо используемую очередь &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;URLSession,&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; либо используют свою собственную очередь (что требует от вызывающей стороны самостоятельно синхронизировать результаты).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="753a22b2eb617204efee4644795034b8ace1ee14" translate="yes" xml:space="preserve">
          <source>Notifications</source>
          <target state="translated">Notifications</target>
        </trans-unit>
        <trans-unit id="c3c7ca7344ce10210a898c17cb8bf8c0c6345900" translate="yes" xml:space="preserve">
          <source>Now Please check complete api structure</source>
          <target state="translated">Теперь,пожалуйста,проверьте полную api структуру</target>
        </trans-unit>
        <trans-unit id="ca2d425cef83128ec0a20ed97a298c67c80a9045" translate="yes" xml:space="preserve">
          <source>Observers can also be used to get notified once the async task has been completed.</source>
          <target state="translated">Наблюдатели также могут быть использованы для получения уведомлений после завершения задачи асинхронизации.</target>
        </trans-unit>
        <trans-unit id="95ea2250a94be92b9b5c99f8db93d804ceabeb6d" translate="yes" xml:space="preserve">
          <source>Returning data from async call in Swift function</source>
          <target state="translated">Возврат данных из асинхронного вызова в функции Swift</target>
        </trans-unit>
        <trans-unit id="9ed518514a3cbea72d715d1d9c28704e12c8bc90" translate="yes" xml:space="preserve">
          <source>Swift 3 version of @Alexey Globchastyy's answer:</source>
          <target state="translated">Свифт 3 версия ответа Алексея Глобчастого:</target>
        </trans-unit>
        <trans-unit id="51cd39f7d75342cd8ca5614506b3faa58c351053" translate="yes" xml:space="preserve">
          <source>Swiftz already offers Future, which is the basic building block of a Promise. A Future is a Promise that cannot fail (all terms here are based on the Scala interpretation, &lt;a href=&quot;https://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala?rq=1&quot;&gt;where a Promise is a Monad&lt;/a&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Swiftz уже предлагает Future, который является основным строительным блоком Promise. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Будущее - это Обещание, которое не может не исполниться (все термины здесь основаны на интерпретации Scala, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala?rq=1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;где Обещание - это Монада&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac1f9ef245a3b10e54a68e4a4bcce32858364623" translate="yes" xml:space="preserve">
          <source>The basic pattern is to use completion handlers closure.</source>
          <target state="translated">Основной схемой является использование закрытия обработчиков завершения.</target>
        </trans-unit>
        <trans-unit id="51fca48045be018843010b6a4c2c218f7615ed4d" translate="yes" xml:space="preserve">
          <source>The main thread is the UI thread, whenever you make an async task and you want to update the UI you must do all the UI changes on the UI thread</source>
          <target state="translated">Основной поток-это поток пользовательского интерфейса,всякий раз,когда вы делаете асинхронную задачу и хотите обновить пользовательский интерфейс,вы должны делать все изменения пользовательского интерфейса в потоке пользовательского интерфейса</target>
        </trans-unit>
        <trans-unit id="0dccee69ee40909c637c9d01dee6680b7d63bdb6" translate="yes" xml:space="preserve">
          <source>The older, Swift 4 pattern is:</source>
          <target state="translated">Старший,Свифт 4:</target>
        </trans-unit>
        <trans-unit id="7e41ac91e7836703978c1c85deffd0fd393929f9" translate="yes" xml:space="preserve">
          <source>There are 3 ways of creating call back functions namely:
1. Completion handler
2. Notification
3. Delegates</source>
          <target state="translated">Существует 3 способа создания функций обратного вызова,а именно:1.Обработчик завершения 2.Уведомление 3.Делегаты</target>
        </trans-unit>
        <trans-unit id="4ef1f4651b9e21d01aa91ff891682983bbd68b47" translate="yes" xml:space="preserve">
          <source>There are mainly 3 ways of achieving callback in swift</source>
          <target state="translated">Существует в основном 3 способа быстрого обратного вызова.</target>
        </trans-unit>
        <trans-unit id="c8cfd31c5f2fa380e4e81d4e1997fbf3ba87ba8c" translate="yes" xml:space="preserve">
          <source>There are some very generic requirements that would like every good API Manager to satisfy:
will implement a &lt;strong&gt;protocol-oriented API Client.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Есть несколько очень общих требований, которые должны удовлетворять все хорошие API-менеджеры: внедрить &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;API-клиент, ориентированный&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;протокол.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6edf876e1dd16ba30ab1e7bb46d6abf5e4cadf9a" translate="yes" xml:space="preserve">
          <source>This is a small use case that might be helpful:-</source>
          <target state="translated">Это небольшой вариант использования,который может быть полезен:-</target>
        </trans-unit>
        <trans-unit id="6d93327a494f273f8373e66a922af984d7fa9ac9" translate="yes" xml:space="preserve">
          <source>Use completion blocks and activate then on the main thread.</source>
          <target state="translated">Используйте блоки завершения и активируйте затем на главном потоке.</target>
        </trans-unit>
        <trans-unit id="b107e7fde341f7c746ab2a50be30f16df2888d85" translate="yes" xml:space="preserve">
          <source>While calling the function:-</source>
          <target state="translated">При вызове функции:-</target>
        </trans-unit>
        <trans-unit id="492600fc20952c19d7d564917a54861be600573c" translate="yes" xml:space="preserve">
          <source>You can call this function as below:</source>
          <target state="translated">Вы можете вызвать эту функцию,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="5f6fb05957878828dd52a0141b964038cd5da62a" translate="yes" xml:space="preserve">
          <source>You can pass callback, and call callback inside async call</source>
          <target state="translated">Вы можете пройти обратный вызов и позвонить внутри асинхронного вызова.</target>
        </trans-unit>
        <trans-unit id="ed2e7ade7b8198c94d3afc330e61c9876d6f2e31" translate="yes" xml:space="preserve">
          <source>and then call this method:</source>
          <target state="translated">а затем вызовите этот метод:</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="1bc3878c5b1eaee17acdf12033cb2803a770ad3f" translate="yes" xml:space="preserve">
          <source>something like:</source>
          <target state="translated">что-то вроде:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
