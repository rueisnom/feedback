<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2587345">
    <body>
      <group id="2587345">
        <trans-unit id="0c7e8e540151253a4c9da94e55fcb821d298968a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Converts from UTC to Local time before printing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Преобразует из UTC в Местное время перед печатью&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f059597f5f1fa300f1037881986242ca28ef0de2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Prints the stored UTC time directly&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Печатает сохраненное время UTC напрямую&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cb2c614a7e6d70e7f901e243a922149538a5f253" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; the format &quot;yyyy/mm/dd&quot; solves the usual problems. 
He says: &quot;Stick to &quot;YYYY/MM/DD&quot; for your date strings whenever possible. It's universally supported and unambiguous. With this format, all times are local.&quot;
I've set tests: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt;
This format: 
 + avoids the day and month order ambiguity by using y m d ordering and a 4-digit year
 + avoids the UTC vs. local issue not complying with ISO format by using slashes
 + danvk, the &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; guy, says that this format is good in all browsers.</source>
          <target state="translated">Согласно &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; формат &quot;гггг / мм / дд&quot; решает обычные проблемы. Он говорит: &amp;laquo;Придерживайтесь&amp;laquo; ГГГГ / ММ / ДД &amp;raquo;для ваших строк дат, когда это возможно. Это универсально поддерживается и однозначно. С этим форматом все времена локальные&amp;raquo;. Я установил тесты: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt; Этот формат: + позволяет избежать двусмысленности порядка дня и месяца, используя порядок ymd и год из 4 цифр + избегает UTC по сравнению с локальной проблемой, а не соблюдение формата ISO с помощью slashes + danvk, парень &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; , говорит, что этот формат хорош во всех браузерах.</target>
        </trans-unit>
        <trans-unit id="a6336241eb2f70e9b3891297c4ab9c1d2f8717cc" translate="yes" xml:space="preserve">
          <source>All implementations store their date values internally as 64-bit numbers that represent the number of milliseconds (ms) since 1970-01-01 UTC (GMT is the same thing as UTC). This date is the ECMAScript epoch that is also used by other languages such as Java and POSIX systems such as UNIX. Dates occurring after the epoch are positive numbers and dates prior are negative.</source>
          <target state="translated">Все реализации внутренне хранят свои значения даты в виде 64-битных чисел,которые представляют собой количество миллисекунд (мс),начиная с 1970-01-01 UTC (GMT то же самое,что и UTC).Эта дата является эпохой ECMAScript,которая также используется в других языках,таких как Java и POSIX систем,таких как UNIX.Даты,возникающие после эпохи,являются положительными числами,а предыдущие-отрицательными.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="3f985930aa901a1d9c35ccb7e96c02b267cfb49d" translate="yes" xml:space="preserve">
          <source>And formatting back to string (you will notice both cases give exactly the same result):</source>
          <target state="translated">И форматирование обратно в строку (вы заметите,что оба случая дают один и тот же результат):</target>
        </trans-unit>
        <trans-unit id="90ec0217d9d7eed8ae005f5bb921308ea40b3f6a" translate="yes" xml:space="preserve">
          <source>Another solution is to build an associative array with date format and then reformat data.</source>
          <target state="translated">Другим решением является создание ассоциативного массива с форматом даты и последующее переформатирование данных.</target>
        </trans-unit>
        <trans-unit id="f8242ef969808a0a3455e3a7f614860267b947c9" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2017 (edition 8), implementations were required to parse their output for &lt;em&gt;Date#toString&lt;/em&gt; and &lt;em&gt;Date#toUTCString&lt;/em&gt;, but the format of those strings was not specified.</source>
          <target state="translated">Начиная с ECMAScript 2017 (редакция 8), реализации должны были анализировать свои выходные данные для &lt;em&gt;Date # toString&lt;/em&gt; и &lt;em&gt;Date # toUTCString&lt;/em&gt; , но формат этих строк не был указан.</target>
        </trans-unit>
        <trans-unit id="111ce656eb8f6ad6c1d696a512bf12f7be113eb8" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2019 (edition 9) the format for &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date#toString&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date#toUTCString&lt;/em&gt;&lt;/a&gt;, have been specified as (respectively):</source>
          <target state="translated">Начиная с ECMAScript 2019 (издание 9) формат для &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date # toString&lt;/em&gt;&lt;/a&gt; и &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date # toUTCString&lt;/em&gt;&lt;/a&gt; , был определен как (соответственно):</target>
        </trans-unit>
        <trans-unit id="d325ccf2d171ea2eb390c34b0d77dd7659093fbe" translate="yes" xml:space="preserve">
          <source>Both are correct, but they are being interpreted as dates with two different timezones. So you compared apples and oranges:</source>
          <target state="translated">Оба они верны,но интерпретируются как даты с двумя разными часовыми поясами.Итак,вы сравнили яблоки и апельсины:</target>
        </trans-unit>
        <trans-unit id="5c14087dc81e8df1775a715b953512bb2a9be63d" translate="yes" xml:space="preserve">
          <source>But I still strongly recommend &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; which is as &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;simple yet powerful&lt;/a&gt;:</source>
          <target state="translated">Но я все еще настоятельно рекомендую &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js,&lt;/a&gt; который так же &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;прост, но мощный&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a264e7734e248a8ae1aa2c98f35907f8b28c5d4d" translate="yes" xml:space="preserve">
          <source>But it gets worse. A quirk of ECMA-262 is that the ISO 8601 date&amp;ndash;only format (YYYY-MM-DD) is required to be parsed as UTC, whereas ISO 8601 requires it to be parsed as local. Here is the output from FF with the long and short ISO date formats with no time zone specifier.</source>
          <target state="translated">Но это становится хуже. Причудой ECMA-262 является то, что формат ISO 8601 только для даты (YYYY-MM-DD) должен быть проанализирован как UTC, в то время как ISO 8601 требует, чтобы он был проанализирован как локальный. Вот вывод из FF с длинными и короткими форматами даты ISO без указания часового пояса.</target>
        </trans-unit>
        <trans-unit id="833d0d480c692e50e5abaaea33ace37c993601e4" translate="yes" xml:space="preserve">
          <source>But, even for ISO 8601 format strings, some implementations get it wrong. Here is a comparison output of Chrome and Firefox when this answer was originally written for 1/1/1970 (the epoch) on my machine using ISO 8601 format strings that &lt;em&gt;should&lt;/em&gt; be parsed to exactly the same value in all implementations:</source>
          <target state="translated">Но даже для строк формата ISO 8601 некоторые реализации ошибаются. Вот сравнительный вывод Chrome и Firefox, когда этот ответ был изначально написан для моей машины 01.01.1970 (эпоха), используя строки формата ISO 8601, которые &lt;em&gt;должны&lt;/em&gt; быть проанализированы с одинаковым значением во всех реализациях:</target>
        </trans-unit>
        <trans-unit id="0a472dfd7a343b45d8c75ad7ad8c041502d3cfd4" translate="yes" xml:space="preserve">
          <source>Case One:</source>
          <target state="translated">Дело первое:</target>
        </trans-unit>
        <trans-unit id="5753210b49df9aaa277109952ec6a3536cc7dc7f" translate="yes" xml:space="preserve">
          <source>Case Two:</source>
          <target state="translated">Дело 2:</target>
        </trans-unit>
        <trans-unit id="85b3107f884ec20fdd3a4e1d0a919b470ef6b022" translate="yes" xml:space="preserve">
          <source>During recent experience writing a JS interpreter I wrestled plenty with the inner workings of ECMA/JS dates. So, I figure I'll throw in my 2 cents here. Hopefully sharing this stuff will help others with any questions about the differences among browsers in how they handle dates.</source>
          <target state="translated">Во время недавнего опыта написания JS переводчика я много боролся с внутренними работами ECMAJS даты.Так что,я решил,что брошу сюда свои 2 цента.Надеюсь,что обмен этими вещами поможет другим в любых вопросах о различиях между браузерами в том,как они обращаются с датами.</target>
        </trans-unit>
        <trans-unit id="3e6c3e988227ecbd67ecc191709a05d2041e8216" translate="yes" xml:space="preserve">
          <source>E.g. in moment.js you might write:</source>
          <target state="translated">Например,в мгновение ока.Ты можешь написать:</target>
        </trans-unit>
        <trans-unit id="6d76ff5990e57aeaf2947b419cafe10b430dc062" translate="yes" xml:space="preserve">
          <source>Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</source>
          <target state="translated">Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="b860ddc534bad45183fb140bb7bda595ebc89a57" translate="yes" xml:space="preserve">
          <source>Here is a short, flexible snippet to convert a datetime-string in a cross-browser-safe fashion as nicel detailed by @drankin2112.</source>
          <target state="translated">Вот короткий,гибкий фрагмент для конвертации строки даты в кросс-броузер-безопасную моды,как никель,подробно описанную @drankin2112.</target>
        </trans-unit>
        <trans-unit id="5148957378cc6f74e6c58f8d974a7f47c586b639" translate="yes" xml:space="preserve">
          <source>However, since parsing of even the formats specified in ECMA-262 is not consistent, it is recommended to never rely on the built&amp;ndash;in parser and to always manually parse strings, say using a library and provide the format to the parser.</source>
          <target state="translated">Однако, поскольку синтаксический анализ даже форматов, указанных в ECMA-262, не является согласованным, рекомендуется никогда не полагаться на встроенный синтаксический анализатор и всегда анализировать строки вручную, например, используя библиотеку, и предоставлять формат анализатору.</target>
        </trans-unit>
        <trans-unit id="f5dddceed7bb7c480aa13cc2f6b535772c5a9e56" translate="yes" xml:space="preserve">
          <source>However, the ISO 8601 format is different. It's one of only two formats outlined in ECMAScript 2015 (ed 6) specifically that must be parsed the same way by all implementations (the other is the format specified for &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt;).</source>
          <target state="translated">Однако формат ISO 8601 отличается. Это один из двух форматов, специально описанных в ECMAScript 2015 (ред. 6), который должен быть проанализирован одинаково во всех реализациях (другой - формат, указанный для &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2c8986ea1508fe0b2bf3ec0adb301fe747206ce" translate="yes" xml:space="preserve">
          <source>I hope this answer was helpful.</source>
          <target state="translated">Надеюсь,этот ответ был полезен.</target>
        </trans-unit>
        <trans-unit id="f8afc645c997911f63f4d970041f5f084c856a2e" translate="yes" xml:space="preserve">
          <source>I normally don't use the ISO format for string input. The only time that using that format is beneficial to me is when dates need to be sorted as strings. The ISO format is sortable as-is while the others are not. If you have to have cross-browser compatibility, either specify the timezone or use a compatible string format.</source>
          <target state="translated">Обычно я не использую ISO-формат для ввода строк.Единственное время,когда я использую этот формат,это время,когда даты должны быть отсортированы как строки.Формат ИСО сортируется как есть,в то время как другие нет.Если вам нужна кросс-браузерная совместимость,либо укажите часовой пояс,либо используйте совместимый строковый формат.</target>
        </trans-unit>
        <trans-unit id="eafbac2a62b0c25aa5d5017705a03cbb0f84561f" translate="yes" xml:space="preserve">
          <source>I removed the &lt;code&gt;Date.parse()&lt;/code&gt; call since it's used automatically on a string argument. I also compared the dates using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601 format&lt;/a&gt; so you could visually compare the dates between your local dates and the UTC dates. The times are 7 hours apart, which is the timezone difference and why your tests showed two different dates.</source>
          <target state="translated">Я удалил &lt;code&gt;Date.parse()&lt;/code&gt; так как он автоматически используется в строковом аргументе. Я также сравнил даты, используя &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;формат ISO8601,&lt;/a&gt; чтобы вы могли визуально сравнить даты между вашими локальными датами и датами UTC. Время составляет 7 часов, что является разницей в часовых поясах и почему ваши тесты показали две разные даты.</target>
        </trans-unit>
        <trans-unit id="8a5169d9dc407d763d113425d3a0fc4abb7ba0f4" translate="yes" xml:space="preserve">
          <source>I would recommend that date strings are parsed manually and the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date constructor&lt;/a&gt; used with year, month and day arguments to avoid ambiguity:</source>
          <target state="translated">Я бы порекомендовал, чтобы строки даты анализировались вручную, а &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;конструктор Date&lt;/a&gt; использовался с аргументами year, month и day, чтобы избежать двусмысленности:</target>
        </trans-unit>
        <trans-unit id="3e11fac7bc52471c46533893967eff49e1bd6420" translate="yes" xml:space="preserve">
          <source>In my timezone (EST, which is -05:00), the result is 18000000 because that's how many ms are in 5 hours (it's only 4 hours during daylight savings months). The value will be different in different time zones. This behaviour is specified in ECMA-262 so all browsers do it the same way.</source>
          <target state="translated">В моем часовом поясе (EST,что составляет -05:00)результат 18000000,потому что это столько мс за 5 часов (это всего 4 часа в светлые месяцы).Значение будет разным в разных часовых поясах.Такое поведение указано в ECMA-262,поэтому все браузеры делают это одинаково.</target>
        </trans-unit>
        <trans-unit id="908bce4b419c2ccf07c436e83fa2df8fce9cd8a0" translate="yes" xml:space="preserve">
          <source>In the first case, the &quot;Z&quot; specifier indicates that the input is in UTC time so is not offset from the epoch and the result is 0</source>
          <target state="translated">В первом случае спецификатор &quot;Z&quot; указывает,что вход находится в UTC времени,поэтому не смещен от эпохи,а результат равен 0</target>
        </trans-unit>
        <trans-unit id="19a4c64c93ef3b877cdc45684acc21ca75ba2348" translate="yes" xml:space="preserve">
          <source>In the second case, the &quot;-0500&quot; specifier indicates that the input is in GMT-05:00 and both browsers interpret the input as being in the -05:00 timezone. That means that the UTC value is offset from the epoch, which means adding 18000000ms to the date's internal time value.</source>
          <target state="translated">Во втором случае спецификатор &quot;-0500&quot; указывает,что вход находится в GMT-05:00 и оба браузера интерпретируют вход как находящийся во временной зоне -05:00.Это означает,что значение UTC смещено от эпохи,что означает добавление 18000000мс к внутреннему значению даты.</target>
        </trans-unit>
        <trans-unit id="a6ce403299ba40b5af043efffb66015e275fe3aa" translate="yes" xml:space="preserve">
          <source>Most current browsers do treat the other input formats equally, including the frequently used '1/1/1970' (M/D/YYYY) and '1/1/1970 00:00:00 AM' (M/D/YYYY hh:mm:ss ap) formats. All of the following formats (except the last) are treated as local time input in all browsers. The output of this code is the same in all browsers in my timezone. The last one is treated as -05:00 regardless of the host timezone because the offset is set in the timestamp:</source>
          <target state="translated">Большинство современных браузеров одинаково относятся к другим форматам ввода,включая часто используемые форматы '111970' (MDYYY)и '111970 00:00:00 AM' (MDYYYY hh:mm:ss ap).Все следующие форматы (за исключением последнего)рассматриваются во всех браузерах как локальный ввод времени.Вывод этого кода одинаков во всех браузерах в моем часовом поясе.Последний формат обрабатывается как -05:00 независимо от часового пояса хоста,потому что смещение задается в метке времени:</target>
        </trans-unit>
        <trans-unit id="329918f300afe59c9c860ea10b639102790dba71" translate="yes" xml:space="preserve">
          <source>On the output side, all browsers translate time zones the same way but they handle the string formats differently. Here are the &lt;code&gt;toString&lt;/code&gt; functions and what they output. Notice the &lt;code&gt;toUTCString&lt;/code&gt; and &lt;code&gt;toISOString&lt;/code&gt; functions output 5:00 AM on my machine. Also, the timezone name may be an abbreviation and may be different in different implementations.</source>
          <target state="translated">Что касается вывода, все браузеры переводят часовые пояса одинаково, но по-разному обрабатывают строковые форматы. Вот функции &lt;code&gt;toString&lt;/code&gt; и то, что они выводят. Обратите внимание, что функции &lt;code&gt;toUTCString&lt;/code&gt; и &lt;code&gt;toISOString&lt;/code&gt; выводятся на моей машине в 5:00 утра. Кроме того, название часового пояса может быть сокращением и может отличаться в разных реализациях.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="3f4239f15acea77ec47e62826d3d8200b09d40e4" translate="yes" xml:space="preserve">
          <source>Parsing example:</source>
          <target state="translated">Пример разбора:</target>
        </trans-unit>
        <trans-unit id="03ce0a553f16d4afd68bf211c6b807fc0848709a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript and Dates, What a Mess!&lt;/a&gt; for more.</source>
          <target state="translated">Смотрите &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript и даты, что за беспорядок!&lt;/a&gt; для большего.</target>
        </trans-unit>
        <trans-unit id="4d82d6a6e2fae4b9611bc2380519d63c709fa614" translate="yes" xml:space="preserve">
          <source>So the first is parsed as local because it's ISO 8601 date and time with no timezone, and the second is parsed as UTC because it's ISO 8601 date only.</source>
          <target state="translated">Так что первый анализируется как локальный,потому что это ISO 8601 дата и время без часового пояса,а второй-как UTC,потому что это только дата ISO 8601.</target>
        </trans-unit>
        <trans-unit id="e0d77796c9cd5a8d874e6fa53e27915795a4dd04" translate="yes" xml:space="preserve">
          <source>So, to answer the original question directly, &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; is required by ECMA-262 to be interpreted as UTC, while the other is interpreted as local. That's why:</source>
          <target state="translated">Итак, чтобы ответить на исходный вопрос напрямую, ECMA-262 требует, чтобы &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; интерпретировался как UTC, а другой - как локальный. Вот почему:</target>
        </trans-unit>
        <trans-unit id="94975b996ab726eb43afd2e0d1cc3c2a0c51b8fa" translate="yes" xml:space="preserve">
          <source>The 3rd argument determines strict parsing (available as of 2.3.0). Without it moment.js may also give incorrect results.</source>
          <target state="translated">Третий аргумент определяет строгий синтаксический анализ (доступен начиная с версии 2.3.0).Без него moment.js также может давать некорректные результаты.</target>
        </trans-unit>
        <trans-unit id="e9c8520d7d6d203ec8749fd138fac64e8f76cdff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;accepted answer from CMS&lt;/a&gt; is correct, I have just added some features :</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;Принятый ответ от CMS&lt;/a&gt; правильный, я только что добавил некоторые функции:</target>
        </trans-unit>
        <trans-unit id="2a342756f33785e6c85b3adbaed213b9f8122f60" translate="yes" xml:space="preserve">
          <source>The Input Side</source>
          <target state="translated">Входная сторона</target>
        </trans-unit>
        <trans-unit id="9e592f9d7a2c00500d34cfad7648b183ab77f6c9" translate="yes" xml:space="preserve">
          <source>The Output Side</source>
          <target state="translated">Выходная сторона</target>
        </trans-unit>
        <trans-unit id="c40570cdc17820bbf50c2f2e9682a95a5f1d3fa2" translate="yes" xml:space="preserve">
          <source>The bottom line is this for parsing date strings. The ONLY ISO 8601 string that you can safely parse across browsers is the long form &lt;strong&gt;with an offset&lt;/strong&gt; (either &amp;plusmn;HH:mm or &quot;Z&quot;). If you do that you can safely go back and forth between local and UTC time.</source>
          <target state="translated">Суть в том, что это для разбора строк даты. ЕДИНСТВЕННАЯ строка ISO 8601, которую можно безопасно анализировать в разных браузерах, - это длинная форма &lt;strong&gt;со смещением&lt;/strong&gt; (&amp;plusmn; ЧЧ: мм или &amp;laquo;Z&amp;raquo;). Если вы сделаете это, вы можете безопасно переходить между местным и UTC временем.</target>
        </trans-unit>
        <trans-unit id="e3d92e81c30052126018d0b6fe8887d2781e7720" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; goes through the following internal pseudo-transformation:</source>
          <target state="translated">Код &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; проходит через следующее внутреннее псевдопреобразование:</target>
        </trans-unit>
        <trans-unit id="65906fa3e7ce8fad1d8655c65018896ad655268b" translate="yes" xml:space="preserve">
          <source>The following code is interpreted as the same date in all current browsers, but with the local timezone offset:</source>
          <target state="translated">Следующий код интерпретируется как одна и та же дата во всех текущих браузерах,но со смещением локального часового пояса:</target>
        </trans-unit>
        <trans-unit id="d3944e1a1d4b6d4aac17b1a5590040c5041da04b" translate="yes" xml:space="preserve">
          <source>The other way of creating these same local/UTC dates would be:</source>
          <target state="translated">Другим способом создания этих же локальных дат было бы:</target>
        </trans-unit>
        <trans-unit id="5d0497f028deb4dc2146ce1c8c9e6814ca98c636" translate="yes" xml:space="preserve">
          <source>The third case, where there is no specifier, &lt;em&gt;should&lt;/em&gt; be treated as local for the host system. FF correctly treats the input as local time while Chrome treats it as UTC, so producing different time values. For me this creates a 5 hour difference in the stored value, which is problematic. Other systems with different offsets will get different results.</source>
          <target state="translated">Третий случай, когда нет спецификатора, &lt;em&gt;должен&lt;/em&gt; рассматриваться как локальный для хост-системы. FF правильно обрабатывает ввод как местное время, в то время как Chrome обрабатывает его как UTC, таким образом производя различные значения времени Для меня это создает 5-часовую разницу в сохраненном значении, что проблематично. Другие системы с другим смещением получат разные результаты.</target>
        </trans-unit>
        <trans-unit id="394f1354d0dfb6c25e79e0d8b28cdc0bc36394f3" translate="yes" xml:space="preserve">
          <source>There is some method to the madness. As a general rule, if a browser can interpret a date as an ISO-8601, it will. &quot;2005-07-08&quot; falls into this camp, and so it is parsed as UTC. &quot;Jul 8, 2005&quot; cannot, and so it is parsed in the local time.</source>
          <target state="translated">Есть какой-то метод для безумия.Как правило,если браузер может интерпретировать дату как ISO-8601,он это сделает.&quot;2005-07-08&quot; попадает в этот лагерь,и поэтому он разбирается как UTC.&quot;8 июля 2005 года&quot; не может,и поэтому она анализируется по местному времени.</target>
        </trans-unit>
        <trans-unit id="c1cccf6baf164d26a736174ff77efdcce4e566d7" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;light weight date parsing library&lt;/a&gt; should solve all similar problems. I like the library because it is quite easy to extend. It's also possible to i18n it (not very straight forward, but not that hard).</source>
          <target state="translated">Эта &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;легковесная библиотека разбора даты&lt;/a&gt; должна решить все подобные проблемы. Мне нравится библиотека, потому что ее довольно легко расширить. Это также возможно (не очень прямо, но не так сложно).</target>
        </trans-unit>
        <trans-unit id="ccdae7f2697cfbeb00896696c226905929a42c47" translate="yes" xml:space="preserve">
          <source>This difference has been fixed as of 2020, but other quirks exist between browsers when parsing ISO 8601 format strings.</source>
          <target state="translated">Эта разница была исправлена с 2020 года,но при разборе строк формата ISO 8601 между браузерами существуют и другие причуды.</target>
        </trans-unit>
        <trans-unit id="29826c41ae1f24abb8f555f34335d1a7f547f781" translate="yes" xml:space="preserve">
          <source>This does:</source>
          <target state="translated">Так и есть:</target>
        </trans-unit>
        <trans-unit id="d8aa042eeddd4ec553d436c607f47196ee9a2c60" translate="yes" xml:space="preserve">
          <source>This doesn't produce equivalent results:</source>
          <target state="translated">Это не дает эквивалентных результатов:</target>
        </trans-unit>
        <trans-unit id="a34d3bdcbaac98280e75f02293f3f94dbdf16507" translate="yes" xml:space="preserve">
          <source>This method is useful for date formatted in an unussual way.</source>
          <target state="translated">Этот метод полезен при форматировании даты нестандартным образом.</target>
        </trans-unit>
        <trans-unit id="2aff6e8126e34aa3caca466a07d2eaa3e4366184" translate="yes" xml:space="preserve">
          <source>This works across browsers (after IE9):</source>
          <target state="translated">Это работает во всех браузерах (после IE9):</target>
        </trans-unit>
        <trans-unit id="70abab8d661bb8c79da568d773e006d09a13d4c7" translate="yes" xml:space="preserve">
          <source>Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</source>
          <target state="translated">Ту Июль 07 2005 17:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="8484dedd2f01dd09a976d7895bfd07f3c5317194" translate="yes" xml:space="preserve">
          <source>Until the 5th edition spec came out, the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse&lt;/code&gt;&lt;/a&gt; method was completely &lt;em&gt;implementation dependent&lt;/em&gt; (&lt;code&gt;new Date(string)&lt;/code&gt; is equivalent to &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse(string)&lt;/code&gt;&lt;/a&gt; except the latter returns a number rather than a &lt;code&gt;Date&lt;/code&gt;). In the 5th edition spec the requirement was added to support a &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;simplified &lt;em&gt;(and slightly incorrect)&lt;/em&gt; ISO-8601&lt;/a&gt; (also see &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;What are valid Date Time Strings in JavaScript?&lt;/a&gt;). But other than that, there was &lt;em&gt;no&lt;/em&gt; requirement for what &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; should accept other than that they had to accept whatever &lt;em&gt;Date#toString&lt;/em&gt; output (without saying what that was).</source>
          <target state="translated">До выхода спецификации 5-го издания метод &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse&lt;/code&gt; &lt;/a&gt; полностью &lt;em&gt;зависел от реализации&lt;/em&gt; ( &lt;code&gt;new Date(string)&lt;/code&gt; эквивалентна &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse(string)&lt;/code&gt; &lt;/a&gt; за исключением того, что последний возвращает число, а не &lt;code&gt;Date&lt;/code&gt; ). В спецификации 5-го издания было добавлено требование для поддержки &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;упрощенного &lt;em&gt;(и немного некорректного)&lt;/em&gt; ISO-8601&lt;/a&gt; (также см. &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;Что такое допустимые строки даты и времени в JavaScript?&lt;/a&gt; ). Но кроме этого, не было требования для того, что &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; должен принимать, кроме того, что они должны были принимать любой вывод &lt;em&gt;Date # toString&lt;/em&gt; (не говоря, что это было).</target>
        </trans-unit>
        <trans-unit id="2d5bd9fd9174b8eb5a741f9403f6e3110d996178" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; to parse dates:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; для разбора дат:</target>
        </trans-unit>
        <trans-unit id="f756909dd61f67dbd0fa45f2954bffc95d38db8c" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS is correct&lt;/a&gt; that passing strings into the parse method is generally unsafe, the new &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; (aka ES5) specification in section 15.9.4.2 suggests that &lt;code&gt;Date.parse()&lt;/code&gt; actually should handle ISO-formatted dates.  The old specification made no such claim.  Of course, old browsers and some current browsers still do not provide this ES5 functionality.</source>
          <target state="translated">Хотя &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS верна&lt;/a&gt; , передача строк в метод синтаксического анализа, как правило, небезопасна, новая спецификация &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5-го издания&lt;/a&gt; (aka ES5) в разделе 15.9.4.2 предполагает, что &lt;code&gt;Date.parse()&lt;/code&gt; фактически должна обрабатывать даты в формате ISO. Старая спецификация не предъявляла таких требований. Конечно, старые браузеры и некоторые современные браузеры по-прежнему не предоставляют эту функциональность ES5.</target>
        </trans-unit>
        <trans-unit id="000e986495e06d3e141bf3d31e41d73051e8f358" translate="yes" xml:space="preserve">
          <source>While there is some variance in the input string formats that the major browsers will parse as dates, they essentially interpret them the same as far as time zones and daylight saving is concerned even though parsing is largely implementation dependent.</source>
          <target state="translated">Несмотря на то,что существуют некоторые различия в форматах входных строк,которые основные браузеры будут разбирать как даты,они,по сути,интерпретируют их так же,как и часовые пояса и летнее время,даже несмотря на то,что разбор в значительной степени зависит от реализации.</target>
        </trans-unit>
        <trans-unit id="26a2662fc63bb5e525fe443f8b51a5c405da8642" translate="yes" xml:space="preserve">
          <source>Why does Date.parse give incorrect results</source>
          <target state="translated">Почему Date.parse дает неверные результаты.</target>
        </trans-unit>
        <trans-unit id="53bb717b5c32b6955911e011f267562b9a75046e" translate="yes" xml:space="preserve">
          <source>Why is the second parse incorrect?</source>
          <target state="translated">Почему второй разбор неправильный?</target>
        </trans-unit>
        <trans-unit id="a4cce5e2b9dc56c7bfb388bfaf8034052d1ef9f3" translate="yes" xml:space="preserve">
          <source>Your browser should provide the same timestamp result as &lt;code&gt;Date.parse&lt;/code&gt; with:</source>
          <target state="translated">Ваш браузер должен предоставить тот же результат отметки времени, что и &lt;code&gt;Date.parse&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9881a40adae03bee4aa623d90b2f10362dccc465" translate="yes" xml:space="preserve">
          <source>Your second example isn't wrong.  It is the specified date in UTC, as implied by &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt;, but is represented in your local timezone.</source>
          <target state="translated">Ваш второй пример не ошибается. Это указанная дата в UTC, как подразумевается &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt; , но она представлена ​​в вашем местном часовом поясе.</target>
        </trans-unit>
        <trans-unit id="92d7171de3872ec4508067fb2af0dded0ac2d69e" translate="yes" xml:space="preserve">
          <source>ddd MMM DD YYYY HH:mm:ss ZZ [(timezone name)]</source>
          <target state="translated">ddd MMM DD YYYY HH:mm:ss ZZ [(название часового пояса)]</target>
        </trans-unit>
        <trans-unit id="8c6d4efc15654f3eef450f8d913fa875df8b52fb" translate="yes" xml:space="preserve">
          <source>ddd, DD MMM YYYY HH:mm:ss Z</source>
          <target state="translated">ddd,DD MMM YYYY HH:mm:ss Z</target>
        </trans-unit>
        <trans-unit id="5c8513ccc6fc79d319c1df7112d15fb2fb915dc7" translate="yes" xml:space="preserve">
          <source>e.g. Tue 10 Jul 2018 13:09:58 GMT</source>
          <target state="translated">например,Tue 10 Jul 2018 13:09:58 GMT</target>
        </trans-unit>
        <trans-unit id="23434f99a2b3c6f550f6e0a6d9e1ba839b3e8a16" translate="yes" xml:space="preserve">
          <source>e.g. Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</source>
          <target state="translated">например,Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</target>
        </trans-unit>
        <trans-unit id="d1ddeacf52011ebb962433f44ce9822043ddbfb9" translate="yes" xml:space="preserve">
          <source>has default day and time</source>
          <target state="translated">имеет дефолт по умолчанию день и время</target>
        </trans-unit>
        <trans-unit id="e5a84d89b903471848654d119508be450a6f5c9d" translate="yes" xml:space="preserve">
          <source>parse slashes, dashes, colons and spaces</source>
          <target state="translated">слеши,тире,двоеточия и пробелы</target>
        </trans-unit>
        <trans-unit id="f39e41649d7d19e35e8c2fef343daa4bffd355a2" translate="yes" xml:space="preserve">
          <source>providing 2 more formats that &lt;em&gt;Date.parse&lt;/em&gt; should parse reliably in new implementations (noting that support is not ubiquitous and non&amp;ndash;compliant implementations will remain in use for some time).</source>
          <target state="translated">предоставление еще 2 форматов, которые &lt;em&gt;Date.parse&lt;/em&gt; должен надежно анализировать в новых реализациях (отмечая, что поддержка не является повсеместной, и несовместимые реализации будут использоваться в течение некоторого времени).</target>
        </trans-unit>
        <trans-unit id="9be737ab099b587933e866d3ba0b2b0808b2a779" translate="yes" xml:space="preserve">
          <source>trim and clean input spaces</source>
          <target state="translated">чистые и аккуратные входные отверстия</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
