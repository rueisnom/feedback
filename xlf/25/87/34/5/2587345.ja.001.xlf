<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2587345">
    <body>
      <group id="2587345">
        <trans-unit id="0c7e8e540151253a4c9da94e55fcb821d298968a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Converts from UTC to Local time before printing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;印刷前にUTCから現地時間に変換します&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f059597f5f1fa300f1037881986242ca28ef0de2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Prints the stored UTC time directly&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;保存されているUTC時間を直接出力します&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cb2c614a7e6d70e7f901e243a922149538a5f253" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; the format &quot;yyyy/mm/dd&quot; solves the usual problems. 
He says: &quot;Stick to &quot;YYYY/MM/DD&quot; for your date strings whenever possible. It's universally supported and unambiguous. With this format, all times are local.&quot;
I've set tests: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt;
This format: 
 + avoids the day and month order ambiguity by using y m d ordering and a 4-digit year
 + avoids the UTC vs. local issue not complying with ISO format by using slashes
 + danvk, the &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; guy, says that this format is good in all browsers.</source>
          <target state="translated">&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.htmlに&lt;/a&gt;よると、「yyyy / mm / dd」という形式で通常の問題が解決されます。 「可能な限り、日付文字列を「YYYY / MM / DD」に固執してください。これは、普遍的にサポートされており、明確です。この形式では、常にローカルです。」 テストを設定しました： &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/jlanus/ND2Qg/432/この形式：+ ymd順序と4桁の年を使用することで日と月のあいまいさを回避します+ UTCとローカルの問題を回避しませんスラッシュ+ danvk（ &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphsの&lt;/a&gt;男）を使用してISO形式に準拠すると、この形式はすべてのブラウザーで適切であると述べています。</target>
        </trans-unit>
        <trans-unit id="a6336241eb2f70e9b3891297c4ab9c1d2f8717cc" translate="yes" xml:space="preserve">
          <source>All implementations store their date values internally as 64-bit numbers that represent the number of milliseconds (ms) since 1970-01-01 UTC (GMT is the same thing as UTC). This date is the ECMAScript epoch that is also used by other languages such as Java and POSIX systems such as UNIX. Dates occurring after the epoch are positive numbers and dates prior are negative.</source>
          <target state="translated">すべての実装では、1970-01-01 UTC(GMTはUTCと同じ意味です)からのミリ秒(ms)の数を表す64ビットの数値として、日付の値を内部的に保存します。この日付は、Java などの他の言語や UNIX などの POSIX システムでも使用されている ECMAScript のエポックです。このエポックより後に発生した日付は正の数、それより前の日付は負の数になります。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="3f985930aa901a1d9c35ccb7e96c02b267cfb49d" translate="yes" xml:space="preserve">
          <source>And formatting back to string (you will notice both cases give exactly the same result):</source>
          <target state="translated">そして、文字列に戻してフォーマットします(どちらの場合も全く同じ結果が得られることに気づくでしょう)。</target>
        </trans-unit>
        <trans-unit id="90ec0217d9d7eed8ae005f5bb921308ea40b3f6a" translate="yes" xml:space="preserve">
          <source>Another solution is to build an associative array with date format and then reformat data.</source>
          <target state="translated">もうひとつの解決策は、日付形式の連想配列を構築してからデータを再フォーマットすることです。</target>
        </trans-unit>
        <trans-unit id="f8242ef969808a0a3455e3a7f614860267b947c9" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2017 (edition 8), implementations were required to parse their output for &lt;em&gt;Date#toString&lt;/em&gt; and &lt;em&gt;Date#toUTCString&lt;/em&gt;, but the format of those strings was not specified.</source>
          <target state="translated">ECMAScript 2017（エディション8）以降、実装は&lt;em&gt;Date＃toString&lt;/em&gt;および&lt;em&gt;Date＃toUTCStringの&lt;/em&gt;出力を解析する必要がありましたが、これらの文字列の形式は指定されていませんでした。</target>
        </trans-unit>
        <trans-unit id="111ce656eb8f6ad6c1d696a512bf12f7be113eb8" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2019 (edition 9) the format for &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date#toString&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date#toUTCString&lt;/em&gt;&lt;/a&gt;, have been specified as (respectively):</source>
          <target state="translated">ECMAScript 2019（エディション9）以降、 &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date＃toString&lt;/em&gt;&lt;/a&gt;および&lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date＃toUTCString&lt;/em&gt;&lt;/a&gt;の形式は（それぞれ）次のように指定されています。</target>
        </trans-unit>
        <trans-unit id="d325ccf2d171ea2eb390c34b0d77dd7659093fbe" translate="yes" xml:space="preserve">
          <source>Both are correct, but they are being interpreted as dates with two different timezones. So you compared apples and oranges:</source>
          <target state="translated">両方とも正しいですが、彼らは2つの異なる時間帯の日付として解釈されています。リンゴとオレンジを比較したのですね。</target>
        </trans-unit>
        <trans-unit id="5c14087dc81e8df1775a715b953512bb2a9be63d" translate="yes" xml:space="preserve">
          <source>But I still strongly recommend &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; which is as &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;simple yet powerful&lt;/a&gt;:</source>
          <target state="translated">しかし、私はまだ&lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;シンプルで強力な&lt;/a&gt; &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;を強くお勧めします ：</target>
        </trans-unit>
        <trans-unit id="a264e7734e248a8ae1aa2c98f35907f8b28c5d4d" translate="yes" xml:space="preserve">
          <source>But it gets worse. A quirk of ECMA-262 is that the ISO 8601 date&amp;ndash;only format (YYYY-MM-DD) is required to be parsed as UTC, whereas ISO 8601 requires it to be parsed as local. Here is the output from FF with the long and short ISO date formats with no time zone specifier.</source>
          <target state="translated">しかし、それはさらに悪化します。 ECMA-262の奇妙な点は、ISO 8601の日付のみの形式（YYYY-MM-DD）をUTCとして解析する必要があるのに対し、ISO 8601はローカルとして解析する必要があることです。 以下は、タイムゾーン指定子のないISOの長い形式と短い形式のFFからの出力です。</target>
        </trans-unit>
        <trans-unit id="833d0d480c692e50e5abaaea33ace37c993601e4" translate="yes" xml:space="preserve">
          <source>But, even for ISO 8601 format strings, some implementations get it wrong. Here is a comparison output of Chrome and Firefox when this answer was originally written for 1/1/1970 (the epoch) on my machine using ISO 8601 format strings that &lt;em&gt;should&lt;/em&gt; be parsed to exactly the same value in all implementations:</source>
          <target state="translated">しかし、ISO 8601形式の文字列であっても、一部の実装ではそれが間違っています。 すべての実装でまったく同じ値に解析される&lt;em&gt;必要&lt;/em&gt;があるISO 8601形式の文字列を使用して私のマシンで1/1/1970（エポック）に対してこの回答が最初に書かれたときのChromeとFirefoxの比較出力は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0a472dfd7a343b45d8c75ad7ad8c041502d3cfd4" translate="yes" xml:space="preserve">
          <source>Case One:</source>
          <target state="translated">ケース・ワン</target>
        </trans-unit>
        <trans-unit id="5753210b49df9aaa277109952ec6a3536cc7dc7f" translate="yes" xml:space="preserve">
          <source>Case Two:</source>
          <target state="translated">ケース・ツー</target>
        </trans-unit>
        <trans-unit id="85b3107f884ec20fdd3a4e1d0a919b470ef6b022" translate="yes" xml:space="preserve">
          <source>During recent experience writing a JS interpreter I wrestled plenty with the inner workings of ECMA/JS dates. So, I figure I'll throw in my 2 cents here. Hopefully sharing this stuff will help others with any questions about the differences among browsers in how they handle dates.</source>
          <target state="translated">最近、JSインタープリターを書いていた時に、ECMAJSの日付の内側の仕組みと格闘したことがあります。そこで、私の2セントをここに投じることにしました。願わくば、この内容を共有することで、ブラウザ間での日付の扱い方の違いについての疑問が、他の人の助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="3e6c3e988227ecbd67ecc191709a05d2041e8216" translate="yes" xml:space="preserve">
          <source>E.g. in moment.js you might write:</source>
          <target state="translated">例えば、moment.jsでは以下のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="6d76ff5990e57aeaf2947b419cafe10b430dc062" translate="yes" xml:space="preserve">
          <source>Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</source>
          <target state="translated">2005年7月8日(金)00:00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="b860ddc534bad45183fb140bb7bda595ebc89a57" translate="yes" xml:space="preserve">
          <source>Here is a short, flexible snippet to convert a datetime-string in a cross-browser-safe fashion as nicel detailed by @drankin2112.</source>
          <target state="translated">ここでは、@drankin2112さんが詳しく説明しているように、クロスブラウザセーフな方法で日付の文字列を変換するための、短くて柔軟なスニペットを紹介します。</target>
        </trans-unit>
        <trans-unit id="5148957378cc6f74e6c58f8d974a7f47c586b639" translate="yes" xml:space="preserve">
          <source>However, since parsing of even the formats specified in ECMA-262 is not consistent, it is recommended to never rely on the built&amp;ndash;in parser and to always manually parse strings, say using a library and provide the format to the parser.</source>
          <target state="translated">ただし、ECMA-262で指定された形式の解析でも一貫性がないため、組み込みパーサーに依存せず、常にライブラリを使用して文字列を手動で解析し、形式をパーサーに提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f5dddceed7bb7c480aa13cc2f6b535772c5a9e56" translate="yes" xml:space="preserve">
          <source>However, the ISO 8601 format is different. It's one of only two formats outlined in ECMAScript 2015 (ed 6) specifically that must be parsed the same way by all implementations (the other is the format specified for &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt;).</source>
          <target state="translated">ただし、ISO 8601形式は異なります。 これは、ECMAScript 2015（ed 6）で概説されている2つの形式のうちの1つであり、すべての実装で同じ方法で解析する必要があります（もう1つは&lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toStringに&lt;/a&gt;指定された形式です）。</target>
        </trans-unit>
        <trans-unit id="e2c8986ea1508fe0b2bf3ec0adb301fe747206ce" translate="yes" xml:space="preserve">
          <source>I hope this answer was helpful.</source>
          <target state="translated">この回答が参考になれば幸いです。</target>
        </trans-unit>
        <trans-unit id="f8afc645c997911f63f4d970041f5f084c856a2e" translate="yes" xml:space="preserve">
          <source>I normally don't use the ISO format for string input. The only time that using that format is beneficial to me is when dates need to be sorted as strings. The ISO format is sortable as-is while the others are not. If you have to have cross-browser compatibility, either specify the timezone or use a compatible string format.</source>
          <target state="translated">私は通常、文字列入力にISOフォーマットを使用しません。そのフォーマットを使うことが私にとって有益なのは、日付を文字列としてソートする必要があるときだけです。ISO フォーマットはそのままソートできますが、他のフォーマットはそうではありません。クロスブラウザの互換性が必要な場合は、タイムゾーンを指定するか、互換性のある文字列フォーマットを使用してください。</target>
        </trans-unit>
        <trans-unit id="eafbac2a62b0c25aa5d5017705a03cbb0f84561f" translate="yes" xml:space="preserve">
          <source>I removed the &lt;code&gt;Date.parse()&lt;/code&gt; call since it's used automatically on a string argument. I also compared the dates using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601 format&lt;/a&gt; so you could visually compare the dates between your local dates and the UTC dates. The times are 7 hours apart, which is the timezone difference and why your tests showed two different dates.</source>
          <target state="translated">&lt;code&gt;Date.parse()&lt;/code&gt; 呼び出しは文字列引数で自動的に使用されるため、削除しました。 また、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601形式&lt;/a&gt;を使用して日付を比較したので、ローカルの日付とUTC日付の日付を視覚的に比較できます。 時間は7時間離れています。これはタイムゾーンの違いであり、テストで2つの異なる日付が表示された理由です。</target>
        </trans-unit>
        <trans-unit id="8a5169d9dc407d763d113425d3a0fc4abb7ba0f4" translate="yes" xml:space="preserve">
          <source>I would recommend that date strings are parsed manually and the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date constructor&lt;/a&gt; used with year, month and day arguments to avoid ambiguity:</source>
          <target state="translated">あいまいさを避けるために、日付文字列を手動で解析し、 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Dateコンストラクター&lt;/a&gt;を年、月、日の引数と共に使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3e11fac7bc52471c46533893967eff49e1bd6420" translate="yes" xml:space="preserve">
          <source>In my timezone (EST, which is -05:00), the result is 18000000 because that's how many ms are in 5 hours (it's only 4 hours during daylight savings months). The value will be different in different time zones. This behaviour is specified in ECMA-262 so all browsers do it the same way.</source>
          <target state="translated">私のタイムゾーン(EST、つまり-05:00)では、5時間で何ミリ秒になるかということで、結果は18000000になります(サマータイムの期間中は4時間です)。この値はタイムゾーンによって異なります。この動作はECMA-262で指定されているので、すべてのブラウザが同じ方法で行います。</target>
        </trans-unit>
        <trans-unit id="908bce4b419c2ccf07c436e83fa2df8fce9cd8a0" translate="yes" xml:space="preserve">
          <source>In the first case, the &quot;Z&quot; specifier indicates that the input is in UTC time so is not offset from the epoch and the result is 0</source>
          <target state="translated">最初のケースでは、&quot;Z &quot;指定子は入力がUTC時間であるためエポックからオフセットされていないことを示し、結果は0である。</target>
        </trans-unit>
        <trans-unit id="19a4c64c93ef3b877cdc45684acc21ca75ba2348" translate="yes" xml:space="preserve">
          <source>In the second case, the &quot;-0500&quot; specifier indicates that the input is in GMT-05:00 and both browsers interpret the input as being in the -05:00 timezone. That means that the UTC value is offset from the epoch, which means adding 18000000ms to the date's internal time value.</source>
          <target state="translated">2番目のケースでは、&quot;-0500 &quot;指定子は入力がGMT-05:00であることを示し、両方のブラウザは入力を-05:00タイムゾーンにあると解釈します。これは、UTC値がエポックからオフセットされていることを意味し、日付の内部時間値に18000000msが加算されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="a6ce403299ba40b5af043efffb66015e275fe3aa" translate="yes" xml:space="preserve">
          <source>Most current browsers do treat the other input formats equally, including the frequently used '1/1/1970' (M/D/YYYY) and '1/1/1970 00:00:00 AM' (M/D/YYYY hh:mm:ss ap) formats. All of the following formats (except the last) are treated as local time input in all browsers. The output of this code is the same in all browsers in my timezone. The last one is treated as -05:00 regardless of the host timezone because the offset is set in the timestamp:</source>
          <target state="translated">現在のほとんどのブラウザでは、よく使われる '111970' (MDYYYY)と '111970 00:00:00:00 AM' (MDYYYY hh:mm:ss ap)フォーマットを含めて、他の入力フォーマットも同じように扱われます。以下のフォーマット(最後のものを除く)はすべてのブラウザでローカルタイムの入力として扱われます。このコードの出力は、私のタイムゾーンのすべてのブラウザで同じです。最後のものは、タイムスタンプにオフセットが設定されているため、ホストのタイムゾーンに関係なく-05:00として扱われます。</target>
        </trans-unit>
        <trans-unit id="329918f300afe59c9c860ea10b639102790dba71" translate="yes" xml:space="preserve">
          <source>On the output side, all browsers translate time zones the same way but they handle the string formats differently. Here are the &lt;code&gt;toString&lt;/code&gt; functions and what they output. Notice the &lt;code&gt;toUTCString&lt;/code&gt; and &lt;code&gt;toISOString&lt;/code&gt; functions output 5:00 AM on my machine. Also, the timezone name may be an abbreviation and may be different in different implementations.</source>
          <target state="translated">出力側では、すべてのブラウザーが同じ方法でタイムゾーンを変換しますが、文字列形式の処理は異なります。 次に &lt;code&gt;toString&lt;/code&gt; 関数とその出力を示します。 私のマシンでは &lt;code&gt;toISOString&lt;/code&gt; 関数とtoISOString関数が5:00 AMを出力することに注意して &lt;code&gt;toUTCString&lt;/code&gt; 。 また、タイムゾーン名は略語であり、実装によって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="3f4239f15acea77ec47e62826d3d8200b09d40e4" translate="yes" xml:space="preserve">
          <source>Parsing example:</source>
          <target state="translated">構文解析の例。</target>
        </trans-unit>
        <trans-unit id="03ce0a553f16d4afd68bf211c6b807fc0848709a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript and Dates, What a Mess!&lt;/a&gt; for more.</source>
          <target state="translated">&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScriptと日付を&lt;/a&gt;参照してください。 多くのための。</target>
        </trans-unit>
        <trans-unit id="4d82d6a6e2fae4b9611bc2380519d63c709fa614" translate="yes" xml:space="preserve">
          <source>So the first is parsed as local because it's ISO 8601 date and time with no timezone, and the second is parsed as UTC because it's ISO 8601 date only.</source>
          <target state="translated">つまり、1つ目はISO 8601の日付と時刻でタイムゾーンがないのでローカルとして解析され、2つ目はISO 8601の日付のみなのでUTCとして解析されます。</target>
        </trans-unit>
        <trans-unit id="e0d77796c9cd5a8d874e6fa53e27915795a4dd04" translate="yes" xml:space="preserve">
          <source>So, to answer the original question directly, &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; is required by ECMA-262 to be interpreted as UTC, while the other is interpreted as local. That's why:</source>
          <target state="translated">したがって、元の質問に直接回答するには、ECMA-262で &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; をUTCとして解釈する必要があり、もう1つはローカルとして解釈される必要があります。 それが理由です：</target>
        </trans-unit>
        <trans-unit id="94975b996ab726eb43afd2e0d1cc3c2a0c51b8fa" translate="yes" xml:space="preserve">
          <source>The 3rd argument determines strict parsing (available as of 2.3.0). Without it moment.js may also give incorrect results.</source>
          <target state="translated">3番目の引数は厳密なパースを決定します(2.3.0で利用可能)。これがないと、moment.jsも正しくない結果になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e9c8520d7d6d203ec8749fd138fac64e8f76cdff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;accepted answer from CMS&lt;/a&gt; is correct, I have just added some features :</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;CMSから&lt;/a&gt;の受け入れられた答えは正しいです、私はちょうどいくつかの機能を追加しました：</target>
        </trans-unit>
        <trans-unit id="2a342756f33785e6c85b3adbaed213b9f8122f60" translate="yes" xml:space="preserve">
          <source>The Input Side</source>
          <target state="translated">入力側</target>
        </trans-unit>
        <trans-unit id="9e592f9d7a2c00500d34cfad7648b183ab77f6c9" translate="yes" xml:space="preserve">
          <source>The Output Side</source>
          <target state="translated">出力側</target>
        </trans-unit>
        <trans-unit id="c40570cdc17820bbf50c2f2e9682a95a5f1d3fa2" translate="yes" xml:space="preserve">
          <source>The bottom line is this for parsing date strings. The ONLY ISO 8601 string that you can safely parse across browsers is the long form &lt;strong&gt;with an offset&lt;/strong&gt; (either &amp;plusmn;HH:mm or &quot;Z&quot;). If you do that you can safely go back and forth between local and UTC time.</source>
          <target state="translated">一番下の行は、日付文字列を解析するためのこれです。 ブラウザ間で安全に解析できる唯一のISO 8601文字列は、 &lt;strong&gt;オフセット付き&lt;/strong&gt;の長い形式（&amp;plusmn;HH：mmまたは &quot;Z&quot;）です。 これを行うと、現地時間とUTC時間の間を安全に行き来できます。</target>
        </trans-unit>
        <trans-unit id="e3d92e81c30052126018d0b6fe8887d2781e7720" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; goes through the following internal pseudo-transformation:</source>
          <target state="translated">コード &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; は、次の内部疑似変換を行います。</target>
        </trans-unit>
        <trans-unit id="65906fa3e7ce8fad1d8655c65018896ad655268b" translate="yes" xml:space="preserve">
          <source>The following code is interpreted as the same date in all current browsers, but with the local timezone offset:</source>
          <target state="translated">以下のコードは、現在のすべてのブラウザで同じ日付として解釈されますが、ローカルタイムゾーンのオフセットを使用しています。</target>
        </trans-unit>
        <trans-unit id="d3944e1a1d4b6d4aac17b1a5590040c5041da04b" translate="yes" xml:space="preserve">
          <source>The other way of creating these same local/UTC dates would be:</source>
          <target state="translated">これらの同じlocalUTCの日付を作成する他の方法は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="5d0497f028deb4dc2146ce1c8c9e6814ca98c636" translate="yes" xml:space="preserve">
          <source>The third case, where there is no specifier, &lt;em&gt;should&lt;/em&gt; be treated as local for the host system. FF correctly treats the input as local time while Chrome treats it as UTC, so producing different time values. For me this creates a 5 hour difference in the stored value, which is problematic. Other systems with different offsets will get different results.</source>
          <target state="translated">指定子がない3番目のケースは、ホストシステムのローカルとして扱う&lt;em&gt;必要&lt;/em&gt;があります。 FFは入力を現地時間として正しく処理しますが、Chromeは入力をUTCとして処理するため、異なる時間値が生成されます。 私にとっては、これにより、保存された値に5時間の差が生じ、問題が生じます。 オフセットが異なる他のシステムでは、異なる結果が得られます。</target>
        </trans-unit>
        <trans-unit id="394f1354d0dfb6c25e79e0d8b28cdc0bc36394f3" translate="yes" xml:space="preserve">
          <source>There is some method to the madness. As a general rule, if a browser can interpret a date as an ISO-8601, it will. &quot;2005-07-08&quot; falls into this camp, and so it is parsed as UTC. &quot;Jul 8, 2005&quot; cannot, and so it is parsed in the local time.</source>
          <target state="translated">狂気にはいくつかの方法があります。一般的なルールとして、ブラウザが日付を ISO-8601 として解釈できるならば、そうします。&quot;2005-07-08&quot; はこのキャンプに該当し、UTC として解析されます。&quot;July 8,2005&quot; は解釈できないので、ローカルタイムで解析されます。</target>
        </trans-unit>
        <trans-unit id="c1cccf6baf164d26a736174ff77efdcce4e566d7" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;light weight date parsing library&lt;/a&gt; should solve all similar problems. I like the library because it is quite easy to extend. It's also possible to i18n it (not very straight forward, but not that hard).</source>
          <target state="translated">この&lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;軽量の日付解析ライブラリ&lt;/a&gt;は、同様の問題をすべて解決するはずです。 拡張が非常に簡単なので、ライブラリが好きです。 i18nにすることも可能です（それほど単純ではありませんが、それほど難しくありません）。</target>
        </trans-unit>
        <trans-unit id="ccdae7f2697cfbeb00896696c226905929a42c47" translate="yes" xml:space="preserve">
          <source>This difference has been fixed as of 2020, but other quirks exist between browsers when parsing ISO 8601 format strings.</source>
          <target state="translated">この違いは2020年現在では修正されていますが、ISO 8601形式の文字列を解析する際には、ブラウザ間で他のクセが存在します。</target>
        </trans-unit>
        <trans-unit id="29826c41ae1f24abb8f555f34335d1a7f547f781" translate="yes" xml:space="preserve">
          <source>This does:</source>
          <target state="translated">これはそうです。</target>
        </trans-unit>
        <trans-unit id="d8aa042eeddd4ec553d436c607f47196ee9a2c60" translate="yes" xml:space="preserve">
          <source>This doesn't produce equivalent results:</source>
          <target state="translated">これでは同等の結果は得られません。</target>
        </trans-unit>
        <trans-unit id="a34d3bdcbaac98280e75f02293f3f94dbdf16507" translate="yes" xml:space="preserve">
          <source>This method is useful for date formatted in an unussual way.</source>
          <target state="translated">この方法は、日付が不自然な形でフォーマットされている場合に便利です。</target>
        </trans-unit>
        <trans-unit id="2aff6e8126e34aa3caca466a07d2eaa3e4366184" translate="yes" xml:space="preserve">
          <source>This works across browsers (after IE9):</source>
          <target state="translated">これは、ブラウザ全体(IE9以降)で動作します。</target>
        </trans-unit>
        <trans-unit id="70abab8d661bb8c79da568d773e006d09a13d4c7" translate="yes" xml:space="preserve">
          <source>Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</source>
          <target state="translated">Thu Jul 07 2005 17:00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="8484dedd2f01dd09a976d7895bfd07f3c5317194" translate="yes" xml:space="preserve">
          <source>Until the 5th edition spec came out, the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse&lt;/code&gt;&lt;/a&gt; method was completely &lt;em&gt;implementation dependent&lt;/em&gt; (&lt;code&gt;new Date(string)&lt;/code&gt; is equivalent to &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse(string)&lt;/code&gt;&lt;/a&gt; except the latter returns a number rather than a &lt;code&gt;Date&lt;/code&gt;). In the 5th edition spec the requirement was added to support a &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;simplified &lt;em&gt;(and slightly incorrect)&lt;/em&gt; ISO-8601&lt;/a&gt; (also see &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;What are valid Date Time Strings in JavaScript?&lt;/a&gt;). But other than that, there was &lt;em&gt;no&lt;/em&gt; requirement for what &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; should accept other than that they had to accept whatever &lt;em&gt;Date#toString&lt;/em&gt; output (without saying what that was).</source>
          <target state="translated">第5版の仕様が発表されるまで、 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse&lt;/code&gt; &lt;/a&gt;メソッドは完全に&lt;em&gt;実装に依存していました&lt;/em&gt; （ &lt;code&gt;new Date(string)&lt;/code&gt; は、 &lt;code&gt;Date&lt;/code&gt; ではなく数値を返すことを除いて、 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse(string)&lt;/code&gt; &lt;/a&gt;と同等です）。 第5版の仕様では、 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;簡略化された&lt;em&gt;（わずかに正しくない）&lt;/em&gt; ISO-8601&lt;/a&gt;をサポートするための要件が​​追加されました&lt;em&gt;（&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;JavaScriptで有効な日時文字列とは何ですか？&lt;/a&gt; ） しかし、それ以外は、 &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; が何を受け入れる必要があるか&lt;em&gt;という&lt;/em&gt;要件はあり&lt;em&gt;ません&lt;/em&gt;でした。</target>
        </trans-unit>
        <trans-unit id="2d5bd9fd9174b8eb5a741f9403f6e3110d996178" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; to parse dates:</source>
          <target state="translated">&lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt;を使用して日付を解析します。</target>
        </trans-unit>
        <trans-unit id="f756909dd61f67dbd0fa45f2954bffc95d38db8c" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS is correct&lt;/a&gt; that passing strings into the parse method is generally unsafe, the new &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; (aka ES5) specification in section 15.9.4.2 suggests that &lt;code&gt;Date.parse()&lt;/code&gt; actually should handle ISO-formatted dates.  The old specification made no such claim.  Of course, old browsers and some current browsers still do not provide this ES5 functionality.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMSは正しい&lt;/a&gt;ので、解析メソッドに文字列を渡すことは一般的に安全ではありませんが、セクション15.9.4.2の新しい&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; （別名ES5）仕様では、 &lt;code&gt;Date.parse()&lt;/code&gt; が実際にISO形式の日付を処理する必要があることを示唆しています。 古い仕様ではそのような主張はありませんでした。 もちろん、古いブラウザと一部の現在のブラウザは、このES5機能をまだ提供していません。</target>
        </trans-unit>
        <trans-unit id="000e986495e06d3e141bf3d31e41d73051e8f358" translate="yes" xml:space="preserve">
          <source>While there is some variance in the input string formats that the major browsers will parse as dates, they essentially interpret them the same as far as time zones and daylight saving is concerned even though parsing is largely implementation dependent.</source>
          <target state="translated">主要なブラウザが日付としてパースする入力文字列の形式には多少の違いがありますが、タイムゾーンやサマータイムに関しては、基本的には同じように解釈されます。</target>
        </trans-unit>
        <trans-unit id="26a2662fc63bb5e525fe443f8b51a5c405da8642" translate="yes" xml:space="preserve">
          <source>Why does Date.parse give incorrect results</source>
          <target state="translated">Date.parse が正しくない結果を出すのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="53bb717b5c32b6955911e011f267562b9a75046e" translate="yes" xml:space="preserve">
          <source>Why is the second parse incorrect?</source>
          <target state="translated">2番目の構文が間違っているのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="a4cce5e2b9dc56c7bfb388bfaf8034052d1ef9f3" translate="yes" xml:space="preserve">
          <source>Your browser should provide the same timestamp result as &lt;code&gt;Date.parse&lt;/code&gt; with:</source>
          <target state="translated">ブラウザは、 &lt;code&gt;Date.parse&lt;/code&gt; と同じタイムスタンプの結果を次のように提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="9881a40adae03bee4aa623d90b2f10362dccc465" translate="yes" xml:space="preserve">
          <source>Your second example isn't wrong.  It is the specified date in UTC, as implied by &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt;, but is represented in your local timezone.</source>
          <target state="translated">2番目の例は間違っていません。 これは、 &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt; で暗黙的に示されるUTCでの指定日付ですが、ローカルタイムゾーンで表されます。</target>
        </trans-unit>
        <trans-unit id="92d7171de3872ec4508067fb2af0dded0ac2d69e" translate="yes" xml:space="preserve">
          <source>ddd MMM DD YYYY HH:mm:ss ZZ [(timezone name)]</source>
          <target state="translated">ddd MMM DD YYYY HH:mm:ss ZZ [(タイムゾーン名)]</target>
        </trans-unit>
        <trans-unit id="8c6d4efc15654f3eef450f8d913fa875df8b52fb" translate="yes" xml:space="preserve">
          <source>ddd, DD MMM YYYY HH:mm:ss Z</source>
          <target state="translated">ddd,DD MMM YYYY HH:mm:ss Z</target>
        </trans-unit>
        <trans-unit id="5c8513ccc6fc79d319c1df7112d15fb2fb915dc7" translate="yes" xml:space="preserve">
          <source>e.g. Tue 10 Jul 2018 13:09:58 GMT</source>
          <target state="translated">例)2018年7月10日(火)13:09:58 GMT</target>
        </trans-unit>
        <trans-unit id="23434f99a2b3c6f550f6e0a6d9e1ba839b3e8a16" translate="yes" xml:space="preserve">
          <source>e.g. Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</source>
          <target state="translated">例:Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</target>
        </trans-unit>
        <trans-unit id="d1ddeacf52011ebb962433f44ce9822043ddbfb9" translate="yes" xml:space="preserve">
          <source>has default day and time</source>
          <target state="translated">にはデフォルトの曜日と時間があります。</target>
        </trans-unit>
        <trans-unit id="e5a84d89b903471848654d119508be450a6f5c9d" translate="yes" xml:space="preserve">
          <source>parse slashes, dashes, colons and spaces</source>
          <target state="translated">スラッシュ、ダッシュ、コロン、スペースを解析します。</target>
        </trans-unit>
        <trans-unit id="f39e41649d7d19e35e8c2fef343daa4bffd355a2" translate="yes" xml:space="preserve">
          <source>providing 2 more formats that &lt;em&gt;Date.parse&lt;/em&gt; should parse reliably in new implementations (noting that support is not ubiquitous and non&amp;ndash;compliant implementations will remain in use for some time).</source>
          <target state="translated">&lt;em&gt;Date.parse&lt;/em&gt;が新しい実装で確実に解析する必要のある2つの追加フォーマットを提供します（サポートはユビキタスではなく、非準拠の実装はしばらく使用され続けることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="9be737ab099b587933e866d3ba0b2b0808b2a779" translate="yes" xml:space="preserve">
          <source>trim and clean input spaces</source>
          <target state="translated">トリムアンドクリーン入力スペース</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
