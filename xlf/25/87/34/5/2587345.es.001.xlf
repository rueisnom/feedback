<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2587345">
    <body>
      <group id="2587345">
        <trans-unit id="0c7e8e540151253a4c9da94e55fcb821d298968a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Converts from UTC to Local time before printing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Convierte de UTC a hora local antes de imprimir&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f059597f5f1fa300f1037881986242ca28ef0de2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Prints the stored UTC time directly&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Imprime la hora UTC almacenada directamente&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cb2c614a7e6d70e7f901e243a922149538a5f253" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; the format &quot;yyyy/mm/dd&quot; solves the usual problems. 
He says: &quot;Stick to &quot;YYYY/MM/DD&quot; for your date strings whenever possible. It's universally supported and unambiguous. With this format, all times are local.&quot;
I've set tests: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt;
This format: 
 + avoids the day and month order ambiguity by using y m d ordering and a 4-digit year
 + avoids the UTC vs. local issue not complying with ISO format by using slashes
 + danvk, the &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; guy, says that this format is good in all browsers.</source>
          <target state="translated">De acuerdo con &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html,&lt;/a&gt; el formato &quot;aaaa / mm / dd&quot; resuelve los problemas habituales. &amp;Eacute;l dice: &quot;Adhi&amp;eacute;rase a&quot; AAAA / MM / DD &quot;para sus cadenas de fecha siempre que sea posible. Es universalmente compatible y sin ambig&amp;uuml;edades. Con este formato, todos los horarios son locales&quot;. He establecido pruebas: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt; Este formato: + evita la ambig&amp;uuml;edad del pedido de d&amp;iacute;a y mes mediante el uso de pedidos ymd y un a&amp;ntilde;o de 4 d&amp;iacute;gitos + evita el problema UTC vs. local no cumplir con el formato ISO mediante el uso de barras inclinadas + danvk, el tipo de &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;gr&amp;aacute;ficos&lt;/a&gt; , dice que este formato es bueno en todos los navegadores.</target>
        </trans-unit>
        <trans-unit id="a6336241eb2f70e9b3891297c4ab9c1d2f8717cc" translate="yes" xml:space="preserve">
          <source>All implementations store their date values internally as 64-bit numbers that represent the number of milliseconds (ms) since 1970-01-01 UTC (GMT is the same thing as UTC). This date is the ECMAScript epoch that is also used by other languages such as Java and POSIX systems such as UNIX. Dates occurring after the epoch are positive numbers and dates prior are negative.</source>
          <target state="translated">Todas las implementaciones almacenan sus valores de fecha internamente como números de 64 bits que representan el número de milisegundos (ms)desde 1970-01-01 UTC (GMT es lo mismo que UTC).Esta fecha es la época de ECMAScript que también es utilizada por otros lenguajes como Java y sistemas POSIX como UNIX.Las fechas posteriores a la época son números positivos y las anteriores son negativas.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="3f985930aa901a1d9c35ccb7e96c02b267cfb49d" translate="yes" xml:space="preserve">
          <source>And formatting back to string (you will notice both cases give exactly the same result):</source>
          <target state="translated">Y volviendo a dar formato a la cadena (notará que ambos casos dan exactamente el mismo resultado):</target>
        </trans-unit>
        <trans-unit id="90ec0217d9d7eed8ae005f5bb921308ea40b3f6a" translate="yes" xml:space="preserve">
          <source>Another solution is to build an associative array with date format and then reformat data.</source>
          <target state="translated">Otra solución es construir un conjunto asociativo con formato de fecha y luego reformatear los datos.</target>
        </trans-unit>
        <trans-unit id="f8242ef969808a0a3455e3a7f614860267b947c9" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2017 (edition 8), implementations were required to parse their output for &lt;em&gt;Date#toString&lt;/em&gt; and &lt;em&gt;Date#toUTCString&lt;/em&gt;, but the format of those strings was not specified.</source>
          <target state="translated">A partir de ECMAScript 2017 (edici&amp;oacute;n 8), se requiri&amp;oacute; que las implementaciones analizaran su salida para &lt;em&gt;Date # toString&lt;/em&gt; y &lt;em&gt;Date # toUTCString&lt;/em&gt; , pero no se especific&amp;oacute; el formato de esas cadenas.</target>
        </trans-unit>
        <trans-unit id="111ce656eb8f6ad6c1d696a512bf12f7be113eb8" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2019 (edition 9) the format for &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date#toString&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date#toUTCString&lt;/em&gt;&lt;/a&gt;, have been specified as (respectively):</source>
          <target state="translated">A partir de ECMAScript 2019 (edici&amp;oacute;n 9), el formato para &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date # toString&lt;/em&gt;&lt;/a&gt; y &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date # toUTCString&lt;/em&gt;&lt;/a&gt; , se ha especificado como (respectivamente):</target>
        </trans-unit>
        <trans-unit id="d325ccf2d171ea2eb390c34b0d77dd7659093fbe" translate="yes" xml:space="preserve">
          <source>Both are correct, but they are being interpreted as dates with two different timezones. So you compared apples and oranges:</source>
          <target state="translated">Ambas son correctas,pero están siendo interpretadas como fechas con dos zonas horarias diferentes.Así que comparaste manzanas y naranjas:</target>
        </trans-unit>
        <trans-unit id="5c14087dc81e8df1775a715b953512bb2a9be63d" translate="yes" xml:space="preserve">
          <source>But I still strongly recommend &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; which is as &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;simple yet powerful&lt;/a&gt;:</source>
          <target state="translated">Pero todav&amp;iacute;a recomiendo &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js,&lt;/a&gt; que es tan &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;simple pero potente&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a264e7734e248a8ae1aa2c98f35907f8b28c5d4d" translate="yes" xml:space="preserve">
          <source>But it gets worse. A quirk of ECMA-262 is that the ISO 8601 date&amp;ndash;only format (YYYY-MM-DD) is required to be parsed as UTC, whereas ISO 8601 requires it to be parsed as local. Here is the output from FF with the long and short ISO date formats with no time zone specifier.</source>
          <target state="translated">Pero se pone peor. Una peculiaridad de ECMA-262 es que se requiere que el formato de fecha ISO 8601 (AAAA-MM-DD) se analice como UTC, mientras que ISO 8601 requiere que se analice como local. Aqu&amp;iacute; est&amp;aacute; la salida de FF con los formatos de fecha ISO largos y cortos sin especificador de zona horaria.</target>
        </trans-unit>
        <trans-unit id="833d0d480c692e50e5abaaea33ace37c993601e4" translate="yes" xml:space="preserve">
          <source>But, even for ISO 8601 format strings, some implementations get it wrong. Here is a comparison output of Chrome and Firefox when this answer was originally written for 1/1/1970 (the epoch) on my machine using ISO 8601 format strings that &lt;em&gt;should&lt;/em&gt; be parsed to exactly the same value in all implementations:</source>
          <target state="translated">Pero, incluso para las cadenas de formato ISO 8601, algunas implementaciones se equivocan. Aqu&amp;iacute; hay una salida de comparaci&amp;oacute;n de Chrome y Firefox cuando esta respuesta se escribi&amp;oacute; originalmente para el 1/1/1970 (la &amp;eacute;poca) en mi m&amp;aacute;quina usando cadenas de formato ISO 8601 que &lt;em&gt;deber&amp;iacute;an&lt;/em&gt; analizarse exactamente con el mismo valor en todas las implementaciones:</target>
        </trans-unit>
        <trans-unit id="0a472dfd7a343b45d8c75ad7ad8c041502d3cfd4" translate="yes" xml:space="preserve">
          <source>Case One:</source>
          <target state="translated">Caso uno:</target>
        </trans-unit>
        <trans-unit id="5753210b49df9aaa277109952ec6a3536cc7dc7f" translate="yes" xml:space="preserve">
          <source>Case Two:</source>
          <target state="translated">Caso dos:</target>
        </trans-unit>
        <trans-unit id="85b3107f884ec20fdd3a4e1d0a919b470ef6b022" translate="yes" xml:space="preserve">
          <source>During recent experience writing a JS interpreter I wrestled plenty with the inner workings of ECMA/JS dates. So, I figure I'll throw in my 2 cents here. Hopefully sharing this stuff will help others with any questions about the differences among browsers in how they handle dates.</source>
          <target state="translated">Durante la reciente experiencia de escribir un intérprete JS luché mucho con el funcionamiento interno de las fechas del ECMAJS.Así que,me imagino que voy a tirar mis dos centavos aquí.Espero que compartir estas cosas ayude a otros con cualquier pregunta sobre las diferencias entre los navegadores en el manejo de las fechas.</target>
        </trans-unit>
        <trans-unit id="3e6c3e988227ecbd67ecc191709a05d2041e8216" translate="yes" xml:space="preserve">
          <source>E.g. in moment.js you might write:</source>
          <target state="translated">Por ejemplo,en moment.js podrías escribir:</target>
        </trans-unit>
        <trans-unit id="6d76ff5990e57aeaf2947b419cafe10b430dc062" translate="yes" xml:space="preserve">
          <source>Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</source>
          <target state="translated">Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="b860ddc534bad45183fb140bb7bda595ebc89a57" translate="yes" xml:space="preserve">
          <source>Here is a short, flexible snippet to convert a datetime-string in a cross-browser-safe fashion as nicel detailed by @drankin2112.</source>
          <target state="translated">Aquí hay un fragmento corto y flexible para convertir una cadena de fecha y hora en una forma segura para el navegador,como se detalla en @drankin2112.</target>
        </trans-unit>
        <trans-unit id="5148957378cc6f74e6c58f8d974a7f47c586b639" translate="yes" xml:space="preserve">
          <source>However, since parsing of even the formats specified in ECMA-262 is not consistent, it is recommended to never rely on the built&amp;ndash;in parser and to always manually parse strings, say using a library and provide the format to the parser.</source>
          <target state="translated">Sin embargo, dado que el an&amp;aacute;lisis de incluso los formatos especificados en ECMA-262 no es coherente, se recomienda no confiar nunca en el analizador incorporado y analizar siempre manualmente las cadenas, digamos usando una biblioteca y proporcionar el formato al analizador.</target>
        </trans-unit>
        <trans-unit id="f5dddceed7bb7c480aa13cc2f6b535772c5a9e56" translate="yes" xml:space="preserve">
          <source>However, the ISO 8601 format is different. It's one of only two formats outlined in ECMAScript 2015 (ed 6) specifically that must be parsed the same way by all implementations (the other is the format specified for &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt;).</source>
          <target state="translated">Sin embargo, el formato ISO 8601 es diferente. Es uno de los dos &amp;uacute;nicos formatos descritos en ECMAScript 2015 (ed. 6) espec&amp;iacute;ficamente que todas las implementaciones deben analizar de la misma manera (el otro es el formato especificado para &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2c8986ea1508fe0b2bf3ec0adb301fe747206ce" translate="yes" xml:space="preserve">
          <source>I hope this answer was helpful.</source>
          <target state="translated">Espero que esta respuesta haya sido útil.</target>
        </trans-unit>
        <trans-unit id="f8afc645c997911f63f4d970041f5f084c856a2e" translate="yes" xml:space="preserve">
          <source>I normally don't use the ISO format for string input. The only time that using that format is beneficial to me is when dates need to be sorted as strings. The ISO format is sortable as-is while the others are not. If you have to have cross-browser compatibility, either specify the timezone or use a compatible string format.</source>
          <target state="translated">Normalmente no uso el formato ISO para la entrada de cadenas.La única vez que el uso de ese formato es beneficioso para mí es cuando las fechas necesitan ser ordenadas como cadenas.El formato ISO es clasificable tal cual,mientras que los otros no lo son.Si tienes que tener compatibilidad con los navegadores,especifica la zona horaria o usa un formato de cadena compatible.</target>
        </trans-unit>
        <trans-unit id="eafbac2a62b0c25aa5d5017705a03cbb0f84561f" translate="yes" xml:space="preserve">
          <source>I removed the &lt;code&gt;Date.parse()&lt;/code&gt; call since it's used automatically on a string argument. I also compared the dates using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601 format&lt;/a&gt; so you could visually compare the dates between your local dates and the UTC dates. The times are 7 hours apart, which is the timezone difference and why your tests showed two different dates.</source>
          <target state="translated">&lt;code&gt;Date.parse()&lt;/code&gt; llamada Date.parse () ya que se usa autom&amp;aacute;ticamente en un argumento de cadena. Tambi&amp;eacute;n &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;compar&amp;eacute;&lt;/a&gt; las fechas con el formato ISO8601 para que pueda comparar visualmente las fechas entre sus fechas locales y las fechas UTC. Los tiempos est&amp;aacute;n separados por 7 horas, que es la diferencia de zona horaria y por qu&amp;eacute; sus pruebas mostraron dos fechas diferentes.</target>
        </trans-unit>
        <trans-unit id="8a5169d9dc407d763d113425d3a0fc4abb7ba0f4" translate="yes" xml:space="preserve">
          <source>I would recommend that date strings are parsed manually and the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date constructor&lt;/a&gt; used with year, month and day arguments to avoid ambiguity:</source>
          <target state="translated">Recomendar&amp;iacute;a que las cadenas de fecha se analicen manualmente y el &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;constructor de fecha se&lt;/a&gt; use con argumentos de a&amp;ntilde;o, mes y d&amp;iacute;a para evitar la ambig&amp;uuml;edad:</target>
        </trans-unit>
        <trans-unit id="3e11fac7bc52471c46533893967eff49e1bd6420" translate="yes" xml:space="preserve">
          <source>In my timezone (EST, which is -05:00), the result is 18000000 because that's how many ms are in 5 hours (it's only 4 hours during daylight savings months). The value will be different in different time zones. This behaviour is specified in ECMA-262 so all browsers do it the same way.</source>
          <target state="translated">En mi zona horaria (EST,que es -05:00),el resultado es 18000000 porque así son los ms en 5 horas (son sólo 4 horas durante los meses de ahorro de luz diurna).El valor será diferente en diferentes zonas horarias.Este comportamiento está especificado en el ECMA-262,así que todos los navegadores lo hacen de la misma manera.</target>
        </trans-unit>
        <trans-unit id="908bce4b419c2ccf07c436e83fa2df8fce9cd8a0" translate="yes" xml:space="preserve">
          <source>In the first case, the &quot;Z&quot; specifier indicates that the input is in UTC time so is not offset from the epoch and the result is 0</source>
          <target state="translated">En el primer caso,el especificador &quot;Z&quot; indica que la entrada está en la hora UTC,por lo que no está desfasada de la época y el resultado es 0</target>
        </trans-unit>
        <trans-unit id="19a4c64c93ef3b877cdc45684acc21ca75ba2348" translate="yes" xml:space="preserve">
          <source>In the second case, the &quot;-0500&quot; specifier indicates that the input is in GMT-05:00 and both browsers interpret the input as being in the -05:00 timezone. That means that the UTC value is offset from the epoch, which means adding 18000000ms to the date's internal time value.</source>
          <target state="translated">En el segundo caso,el especificador &quot;-0500&quot; indica que la entrada está en GMT-05:00 y ambos navegadores interpretan que la entrada está en la zona horaria de -05:00.Eso significa que el valor UTC está desfasado de la época,lo que significa que se añade 18000000ms al valor de la hora interna de la fecha.</target>
        </trans-unit>
        <trans-unit id="a6ce403299ba40b5af043efffb66015e275fe3aa" translate="yes" xml:space="preserve">
          <source>Most current browsers do treat the other input formats equally, including the frequently used '1/1/1970' (M/D/YYYY) and '1/1/1970 00:00:00 AM' (M/D/YYYY hh:mm:ss ap) formats. All of the following formats (except the last) are treated as local time input in all browsers. The output of this code is the same in all browsers in my timezone. The last one is treated as -05:00 regardless of the host timezone because the offset is set in the timestamp:</source>
          <target state="translated">La mayoría de los navegadores actuales tratan los otros formatos de entrada de igual manera,incluyendo los formatos frecuentemente usados &quot;111970&quot; (MDYYY)y &quot;111970 00:00:00 AM&quot; (MDYYY hh:mm:ss ap).Todos los siguientes formatos (excepto el último)se tratan como entrada de hora local en todos los navegadores.La salida de este código es la misma en todos los navegadores de mi zona horaria.El último se trata como -05:00 sin importar la zona horaria del host porque el desplazamiento se establece en la marca de tiempo:</target>
        </trans-unit>
        <trans-unit id="329918f300afe59c9c860ea10b639102790dba71" translate="yes" xml:space="preserve">
          <source>On the output side, all browsers translate time zones the same way but they handle the string formats differently. Here are the &lt;code&gt;toString&lt;/code&gt; functions and what they output. Notice the &lt;code&gt;toUTCString&lt;/code&gt; and &lt;code&gt;toISOString&lt;/code&gt; functions output 5:00 AM on my machine. Also, the timezone name may be an abbreviation and may be different in different implementations.</source>
          <target state="translated">En el lado de salida, todos los navegadores traducen las zonas horarias de la misma manera, pero manejan los formatos de cadena de manera diferente. Estas son las funciones de &lt;code&gt;toString&lt;/code&gt; y lo que generan. Observe que las funciones &lt;code&gt;toUTCString&lt;/code&gt; y &lt;code&gt;toISOString&lt;/code&gt; salen a las 5:00 AM en mi m&amp;aacute;quina. Adem&amp;aacute;s, el nombre de la zona horaria puede ser una abreviatura y puede ser diferente en diferentes implementaciones.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="3f4239f15acea77ec47e62826d3d8200b09d40e4" translate="yes" xml:space="preserve">
          <source>Parsing example:</source>
          <target state="translated">Ejemplo de análisis:</target>
        </trans-unit>
        <trans-unit id="03ce0a553f16d4afd68bf211c6b807fc0848709a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript and Dates, What a Mess!&lt;/a&gt; for more.</source>
          <target state="translated">Ver &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript y fechas, &amp;iexcl;qu&amp;eacute; desastre!&lt;/a&gt; para m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="4d82d6a6e2fae4b9611bc2380519d63c709fa614" translate="yes" xml:space="preserve">
          <source>So the first is parsed as local because it's ISO 8601 date and time with no timezone, and the second is parsed as UTC because it's ISO 8601 date only.</source>
          <target state="translated">Así que el primero se analiza como local porque es la fecha y la hora ISO 8601 sin zona horaria,y el segundo se analiza como UTC porque es sólo la fecha ISO 8601.</target>
        </trans-unit>
        <trans-unit id="e0d77796c9cd5a8d874e6fa53e27915795a4dd04" translate="yes" xml:space="preserve">
          <source>So, to answer the original question directly, &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; is required by ECMA-262 to be interpreted as UTC, while the other is interpreted as local. That's why:</source>
          <target state="translated">Entonces, para responder directamente a la pregunta original, ECMA-262 requiere que &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; se interprete como UTC, mientras que el otro se interpreta como local. Es por eso:</target>
        </trans-unit>
        <trans-unit id="94975b996ab726eb43afd2e0d1cc3c2a0c51b8fa" translate="yes" xml:space="preserve">
          <source>The 3rd argument determines strict parsing (available as of 2.3.0). Without it moment.js may also give incorrect results.</source>
          <target state="translated">El tercer argumento determina el análisis sintáctico estricto (disponible a partir de 2.3.0).Sin él moment.js también puede dar resultados incorrectos.</target>
        </trans-unit>
        <trans-unit id="e9c8520d7d6d203ec8749fd138fac64e8f76cdff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;accepted answer from CMS&lt;/a&gt; is correct, I have just added some features :</source>
          <target state="translated">La &lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;respuesta aceptada de CMS&lt;/a&gt; es correcta, acabo de agregar algunas caracter&amp;iacute;sticas:</target>
        </trans-unit>
        <trans-unit id="2a342756f33785e6c85b3adbaed213b9f8122f60" translate="yes" xml:space="preserve">
          <source>The Input Side</source>
          <target state="translated">El lado de la entrada</target>
        </trans-unit>
        <trans-unit id="9e592f9d7a2c00500d34cfad7648b183ab77f6c9" translate="yes" xml:space="preserve">
          <source>The Output Side</source>
          <target state="translated">El lado de salida</target>
        </trans-unit>
        <trans-unit id="c40570cdc17820bbf50c2f2e9682a95a5f1d3fa2" translate="yes" xml:space="preserve">
          <source>The bottom line is this for parsing date strings. The ONLY ISO 8601 string that you can safely parse across browsers is the long form &lt;strong&gt;with an offset&lt;/strong&gt; (either &amp;plusmn;HH:mm or &quot;Z&quot;). If you do that you can safely go back and forth between local and UTC time.</source>
          <target state="translated">La conclusi&amp;oacute;n es esto para analizar cadenas de fechas. La &amp;Uacute;NICA cadena ISO 8601 que puede analizar de forma segura en los navegadores es la forma larga &lt;strong&gt;con un desplazamiento&lt;/strong&gt; (&amp;plusmn; HH: mm o &quot;Z&quot;). Si lo hace, puede ir y venir con seguridad entre la hora local y la hora UTC.</target>
        </trans-unit>
        <trans-unit id="e3d92e81c30052126018d0b6fe8887d2781e7720" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; goes through the following internal pseudo-transformation:</source>
          <target state="translated">El c&amp;oacute;digo &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; pasa por la siguiente pseudo-transformaci&amp;oacute;n interna:</target>
        </trans-unit>
        <trans-unit id="65906fa3e7ce8fad1d8655c65018896ad655268b" translate="yes" xml:space="preserve">
          <source>The following code is interpreted as the same date in all current browsers, but with the local timezone offset:</source>
          <target state="translated">El siguiente código se interpreta como la misma fecha en todos los navegadores actuales,pero con el desplazamiento de la zona horaria local:</target>
        </trans-unit>
        <trans-unit id="d3944e1a1d4b6d4aac17b1a5590040c5041da04b" translate="yes" xml:space="preserve">
          <source>The other way of creating these same local/UTC dates would be:</source>
          <target state="translated">La otra forma de crear estas mismas fechas UTC locales sería:</target>
        </trans-unit>
        <trans-unit id="5d0497f028deb4dc2146ce1c8c9e6814ca98c636" translate="yes" xml:space="preserve">
          <source>The third case, where there is no specifier, &lt;em&gt;should&lt;/em&gt; be treated as local for the host system. FF correctly treats the input as local time while Chrome treats it as UTC, so producing different time values. For me this creates a 5 hour difference in the stored value, which is problematic. Other systems with different offsets will get different results.</source>
          <target state="translated">El tercer caso, donde no hay especificador, &lt;em&gt;debe&lt;/em&gt; tratarse como local para el sistema host. FF trata correctamente la entrada como hora local, mientras que Chrome la trata como UTC, por lo que produce diferentes valores de hora. Para m&amp;iacute;, esto crea una diferencia de 5 horas en el valor almacenado, lo cual es problem&amp;aacute;tico. Otros sistemas con diferentes compensaciones obtendr&amp;aacute;n diferentes resultados.</target>
        </trans-unit>
        <trans-unit id="394f1354d0dfb6c25e79e0d8b28cdc0bc36394f3" translate="yes" xml:space="preserve">
          <source>There is some method to the madness. As a general rule, if a browser can interpret a date as an ISO-8601, it will. &quot;2005-07-08&quot; falls into this camp, and so it is parsed as UTC. &quot;Jul 8, 2005&quot; cannot, and so it is parsed in the local time.</source>
          <target state="translated">Hay algún método para la locura.Como regla general,si un navegador puede interpretar una fecha como un ISO-8601,lo hará.&quot;2005-07-08&quot; cae en este campo,y por lo tanto se analiza como UTC.&quot;8 de Julio de 2005&quot; no puede,y por lo tanto se analiza en la hora local.</target>
        </trans-unit>
        <trans-unit id="c1cccf6baf164d26a736174ff77efdcce4e566d7" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;light weight date parsing library&lt;/a&gt; should solve all similar problems. I like the library because it is quite easy to extend. It's also possible to i18n it (not very straight forward, but not that hard).</source>
          <target state="translated">Esta &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;biblioteca de an&amp;aacute;lisis de fechas de peso ligero&lt;/a&gt; deber&amp;iacute;a resolver todos los problemas similares. Me gusta la biblioteca porque es bastante f&amp;aacute;cil de extender. Tambi&amp;eacute;n es posible hacerlo (no muy sencillo, pero no tan dif&amp;iacute;cil).</target>
        </trans-unit>
        <trans-unit id="ccdae7f2697cfbeb00896696c226905929a42c47" translate="yes" xml:space="preserve">
          <source>This difference has been fixed as of 2020, but other quirks exist between browsers when parsing ISO 8601 format strings.</source>
          <target state="translated">Esta diferencia se ha fijado a partir de 2020,pero existen otras peculiaridades entre los navegadores al analizar las cadenas del formato ISO 8601.</target>
        </trans-unit>
        <trans-unit id="29826c41ae1f24abb8f555f34335d1a7f547f781" translate="yes" xml:space="preserve">
          <source>This does:</source>
          <target state="translated">Esto lo hace:</target>
        </trans-unit>
        <trans-unit id="d8aa042eeddd4ec553d436c607f47196ee9a2c60" translate="yes" xml:space="preserve">
          <source>This doesn't produce equivalent results:</source>
          <target state="translated">Esto no produce resultados equivalentes:</target>
        </trans-unit>
        <trans-unit id="a34d3bdcbaac98280e75f02293f3f94dbdf16507" translate="yes" xml:space="preserve">
          <source>This method is useful for date formatted in an unussual way.</source>
          <target state="translated">Este método es útil para la fecha formateada de manera no habitual.</target>
        </trans-unit>
        <trans-unit id="2aff6e8126e34aa3caca466a07d2eaa3e4366184" translate="yes" xml:space="preserve">
          <source>This works across browsers (after IE9):</source>
          <target state="translated">Esto funciona en todos los navegadores (después de IE9):</target>
        </trans-unit>
        <trans-unit id="70abab8d661bb8c79da568d773e006d09a13d4c7" translate="yes" xml:space="preserve">
          <source>Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</source>
          <target state="translated">Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="8484dedd2f01dd09a976d7895bfd07f3c5317194" translate="yes" xml:space="preserve">
          <source>Until the 5th edition spec came out, the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse&lt;/code&gt;&lt;/a&gt; method was completely &lt;em&gt;implementation dependent&lt;/em&gt; (&lt;code&gt;new Date(string)&lt;/code&gt; is equivalent to &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse(string)&lt;/code&gt;&lt;/a&gt; except the latter returns a number rather than a &lt;code&gt;Date&lt;/code&gt;). In the 5th edition spec the requirement was added to support a &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;simplified &lt;em&gt;(and slightly incorrect)&lt;/em&gt; ISO-8601&lt;/a&gt; (also see &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;What are valid Date Time Strings in JavaScript?&lt;/a&gt;). But other than that, there was &lt;em&gt;no&lt;/em&gt; requirement for what &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; should accept other than that they had to accept whatever &lt;em&gt;Date#toString&lt;/em&gt; output (without saying what that was).</source>
          <target state="translated">Hasta que sali&amp;oacute; la especificaci&amp;oacute;n de la quinta edici&amp;oacute;n, el m&amp;eacute;todo &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse&lt;/code&gt; &lt;/a&gt; era completamente &lt;em&gt;dependiente de la implementaci&amp;oacute;n&lt;/em&gt; (la &lt;code&gt;new Date(string)&lt;/code&gt; es equivalente a &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse(string)&lt;/code&gt; &lt;/a&gt; excepto que esta &amp;uacute;ltima devuelve un n&amp;uacute;mero en lugar de una &lt;code&gt;Date&lt;/code&gt; ). En la especificaci&amp;oacute;n de la quinta edici&amp;oacute;n, el requisito se agreg&amp;oacute; para admitir un &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;ISO-8601 simplificado &lt;em&gt;(y ligeramente incorrecto)&lt;/em&gt;&lt;/a&gt; (tambi&amp;eacute;n vea &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;&amp;iquest;Qu&amp;eacute; son las cadenas de fecha y hora v&amp;aacute;lidas en JavaScript?&lt;/a&gt; ). Pero aparte de eso, no hab&amp;iacute;a &lt;em&gt;ning&amp;uacute;n&lt;/em&gt; requisito para lo que &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; deber&amp;iacute;a aceptar, aparte de eso, ten&amp;iacute;an que aceptar cualquier salida de &lt;em&gt;Date # toString&lt;/em&gt; (sin decir lo que era).</target>
        </trans-unit>
        <trans-unit id="2d5bd9fd9174b8eb5a741f9403f6e3110d996178" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; to parse dates:</source>
          <target state="translated">Use &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; para analizar fechas:</target>
        </trans-unit>
        <trans-unit id="f756909dd61f67dbd0fa45f2954bffc95d38db8c" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS is correct&lt;/a&gt; that passing strings into the parse method is generally unsafe, the new &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; (aka ES5) specification in section 15.9.4.2 suggests that &lt;code&gt;Date.parse()&lt;/code&gt; actually should handle ISO-formatted dates.  The old specification made no such claim.  Of course, old browsers and some current browsers still do not provide this ES5 functionality.</source>
          <target state="translated">Si bien &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS tiene raz&amp;oacute;n en&lt;/a&gt; que pasar cadenas al m&amp;eacute;todo de an&amp;aacute;lisis generalmente no es seguro, la nueva &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;especificaci&amp;oacute;n ECMA-262 5th Edition&lt;/a&gt; (tambi&amp;eacute;n conocida como ES5) en la secci&amp;oacute;n 15.9.4.2 sugiere que &lt;code&gt;Date.parse()&lt;/code&gt; realidad deber&amp;iacute;a manejar fechas con formato ISO. La antigua especificaci&amp;oacute;n no hizo tal afirmaci&amp;oacute;n. Por supuesto, los navegadores antiguos y algunos navegadores actuales a&amp;uacute;n no ofrecen esta funcionalidad ES5.</target>
        </trans-unit>
        <trans-unit id="000e986495e06d3e141bf3d31e41d73051e8f358" translate="yes" xml:space="preserve">
          <source>While there is some variance in the input string formats that the major browsers will parse as dates, they essentially interpret them the same as far as time zones and daylight saving is concerned even though parsing is largely implementation dependent.</source>
          <target state="translated">Si bien hay cierta variación en los formatos de las cadenas de entrada que los principales navegadores analizarán como fechas,esencialmente las interpretan de la misma manera en lo que respecta a las zonas horarias y el ahorro de luz diurna,aunque el análisis sintáctico depende en gran medida de la aplicación.</target>
        </trans-unit>
        <trans-unit id="26a2662fc63bb5e525fe443f8b51a5c405da8642" translate="yes" xml:space="preserve">
          <source>Why does Date.parse give incorrect results</source>
          <target state="translated">¿Por qué Date.parse da resultados incorrectos</target>
        </trans-unit>
        <trans-unit id="53bb717b5c32b6955911e011f267562b9a75046e" translate="yes" xml:space="preserve">
          <source>Why is the second parse incorrect?</source>
          <target state="translated">¿Por qué el segundo análisis es incorrecto?</target>
        </trans-unit>
        <trans-unit id="a4cce5e2b9dc56c7bfb388bfaf8034052d1ef9f3" translate="yes" xml:space="preserve">
          <source>Your browser should provide the same timestamp result as &lt;code&gt;Date.parse&lt;/code&gt; with:</source>
          <target state="translated">Su navegador debe proporcionar el mismo resultado de marca de tiempo que &lt;code&gt;Date.parse&lt;/code&gt; con:</target>
        </trans-unit>
        <trans-unit id="9881a40adae03bee4aa623d90b2f10362dccc465" translate="yes" xml:space="preserve">
          <source>Your second example isn't wrong.  It is the specified date in UTC, as implied by &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt;, but is represented in your local timezone.</source>
          <target state="translated">Tu segundo ejemplo no est&amp;aacute; mal. Es la fecha especificada en UTC, como lo implica &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt; , pero est&amp;aacute; representada en su zona horaria local.</target>
        </trans-unit>
        <trans-unit id="92d7171de3872ec4508067fb2af0dded0ac2d69e" translate="yes" xml:space="preserve">
          <source>ddd MMM DD YYYY HH:mm:ss ZZ [(timezone name)]</source>
          <target state="translated">ddd MMM DD YYYY HH:mm:ss ZZ [(nombre de la zona horaria)]</target>
        </trans-unit>
        <trans-unit id="8c6d4efc15654f3eef450f8d913fa875df8b52fb" translate="yes" xml:space="preserve">
          <source>ddd, DD MMM YYYY HH:mm:ss Z</source>
          <target state="translated">ddd,DD MMM YYYY HH:mm:ss Z</target>
        </trans-unit>
        <trans-unit id="5c8513ccc6fc79d319c1df7112d15fb2fb915dc7" translate="yes" xml:space="preserve">
          <source>e.g. Tue 10 Jul 2018 13:09:58 GMT</source>
          <target state="translated">por ejemplo,mar 10 de julio de 2018 13:09:58 GMT</target>
        </trans-unit>
        <trans-unit id="23434f99a2b3c6f550f6e0a6d9e1ba839b3e8a16" translate="yes" xml:space="preserve">
          <source>e.g. Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</source>
          <target state="translated">por ejemplo,mar 10 de julio de 2018 18:39:58 GMT+0530 (IST)</target>
        </trans-unit>
        <trans-unit id="d1ddeacf52011ebb962433f44ce9822043ddbfb9" translate="yes" xml:space="preserve">
          <source>has default day and time</source>
          <target state="translated">tiene un día y una hora predeterminados</target>
        </trans-unit>
        <trans-unit id="e5a84d89b903471848654d119508be450a6f5c9d" translate="yes" xml:space="preserve">
          <source>parse slashes, dashes, colons and spaces</source>
          <target state="translated">analizar barras,guiones,dos puntos y espacios</target>
        </trans-unit>
        <trans-unit id="f39e41649d7d19e35e8c2fef343daa4bffd355a2" translate="yes" xml:space="preserve">
          <source>providing 2 more formats that &lt;em&gt;Date.parse&lt;/em&gt; should parse reliably in new implementations (noting that support is not ubiquitous and non&amp;ndash;compliant implementations will remain in use for some time).</source>
          <target state="translated">proporcionando 2 formatos m&amp;aacute;s que &lt;em&gt;Date.parse&lt;/em&gt; deber&amp;iacute;a analizar de manera confiable en nuevas implementaciones (se&amp;ntilde;alando que el soporte no es ubicuo y las implementaciones no conformes seguir&amp;aacute;n en uso durante alg&amp;uacute;n tiempo).</target>
        </trans-unit>
        <trans-unit id="9be737ab099b587933e866d3ba0b2b0808b2a779" translate="yes" xml:space="preserve">
          <source>trim and clean input spaces</source>
          <target state="translated">recortar y limpiar los espacios de entrada</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
