<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2587345">
    <body>
      <group id="2587345">
        <trans-unit id="0c7e8e540151253a4c9da94e55fcb821d298968a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Converts from UTC to Local time before printing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;在打印之前从UTC转换为本地时间&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f059597f5f1fa300f1037881986242ca28ef0de2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Prints the stored UTC time directly&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;直接打印存储的UTC时间&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cb2c614a7e6d70e7f901e243a922149538a5f253" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; the format &quot;yyyy/mm/dd&quot; solves the usual problems. 
He says: &quot;Stick to &quot;YYYY/MM/DD&quot; for your date strings whenever possible. It's universally supported and unambiguous. With this format, all times are local.&quot;
I've set tests: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt;
This format: 
 + avoids the day and month order ambiguity by using y m d ordering and a 4-digit year
 + avoids the UTC vs. local issue not complying with ISO format by using slashes
 + danvk, the &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; guy, says that this format is good in all browsers.</source>
          <target state="translated">根据&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt;的格式，&amp;ldquo; yyyy / mm / dd&amp;rdquo;解决了常见问题。 他说：&amp;ldquo;请尽可能将日期字符串粘贴到&amp;ldquo; YYYY / MM / DD&amp;rdquo;。它被普遍支持且明确。使用这种格式，所有时间都在本地。 我已经设置了测试： &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/jlanus/ND2Qg/432/这种格式：+通过使用ymd排序和4位数字的年份避免了日和月顺序的歧义+避免了UTC与本地问题的冲突&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt;家伙通过使用斜线+ danvk来符合ISO格式，他说这种格式在所有浏览器中都很好。</target>
        </trans-unit>
        <trans-unit id="a6336241eb2f70e9b3891297c4ab9c1d2f8717cc" translate="yes" xml:space="preserve">
          <source>All implementations store their date values internally as 64-bit numbers that represent the number of milliseconds (ms) since 1970-01-01 UTC (GMT is the same thing as UTC). This date is the ECMAScript epoch that is also used by other languages such as Java and POSIX systems such as UNIX. Dates occurring after the epoch are positive numbers and dates prior are negative.</source>
          <target state="translated">所有的实现都将其日期值在内部存储为64位的数字,代表自1970-01-01-01 UTC以来的毫秒数(GMT与UTC相同)。这个日期是ECMAScript的纪元,其他语言(如Java和POSIX系统(如UNIX)也使用这个纪元。在这个纪元之后发生的日期是正数,之前的日期是负数。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="3f985930aa901a1d9c35ccb7e96c02b267cfb49d" translate="yes" xml:space="preserve">
          <source>And formatting back to string (you will notice both cases give exactly the same result):</source>
          <target state="translated">和格式化回字符串(你会发现这两种情况下给出的结果完全一样)。</target>
        </trans-unit>
        <trans-unit id="90ec0217d9d7eed8ae005f5bb921308ea40b3f6a" translate="yes" xml:space="preserve">
          <source>Another solution is to build an associative array with date format and then reformat data.</source>
          <target state="translated">另一个解决方案是建立一个带有日期格式的关联数组,然后重新格式化数据。</target>
        </trans-unit>
        <trans-unit id="f8242ef969808a0a3455e3a7f614860267b947c9" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2017 (edition 8), implementations were required to parse their output for &lt;em&gt;Date#toString&lt;/em&gt; and &lt;em&gt;Date#toUTCString&lt;/em&gt;, but the format of those strings was not specified.</source>
          <target state="translated">从ECMAScript 2017（版本8）开始，要求实现解析&lt;em&gt;Date＃toString&lt;/em&gt;和&lt;em&gt;Date＃toUTCString的输出&lt;/em&gt; ，但未指定这些字符串的格式。</target>
        </trans-unit>
        <trans-unit id="111ce656eb8f6ad6c1d696a512bf12f7be113eb8" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2019 (edition 9) the format for &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date#toString&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date#toUTCString&lt;/em&gt;&lt;/a&gt;, have been specified as (respectively):</source>
          <target state="translated">从ECMAScript 2019（版本9）开始， &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date＃toString&lt;/em&gt;&lt;/a&gt;和&lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date＃toUTCString&lt;/em&gt;&lt;/a&gt;的格式分别指定为：</target>
        </trans-unit>
        <trans-unit id="d325ccf2d171ea2eb390c34b0d77dd7659093fbe" translate="yes" xml:space="preserve">
          <source>Both are correct, but they are being interpreted as dates with two different timezones. So you compared apples and oranges:</source>
          <target state="translated">两者都是正确的,但都被解释为两个不同时间段的日期。所以你把苹果和橘子做了比较。</target>
        </trans-unit>
        <trans-unit id="5c14087dc81e8df1775a715b953512bb2a9be63d" translate="yes" xml:space="preserve">
          <source>But I still strongly recommend &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; which is as &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;simple yet powerful&lt;/a&gt;:</source>
          <target state="translated">但是我仍然强烈推荐&lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; ， 它既 &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;简单又强大&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="a264e7734e248a8ae1aa2c98f35907f8b28c5d4d" translate="yes" xml:space="preserve">
          <source>But it gets worse. A quirk of ECMA-262 is that the ISO 8601 date&amp;ndash;only format (YYYY-MM-DD) is required to be parsed as UTC, whereas ISO 8601 requires it to be parsed as local. Here is the output from FF with the long and short ISO date formats with no time zone specifier.</source>
          <target state="translated">但情况变得更糟。 ECMA-262的一个怪癖是要求将ISO 8601仅限日期格式（YYYY-MM-DD）解析为UTC，而ISO 8601则要求将其解析为本地。 这是FF的输出，带有长和短ISO日期格式，没有时区说明符。</target>
        </trans-unit>
        <trans-unit id="833d0d480c692e50e5abaaea33ace37c993601e4" translate="yes" xml:space="preserve">
          <source>But, even for ISO 8601 format strings, some implementations get it wrong. Here is a comparison output of Chrome and Firefox when this answer was originally written for 1/1/1970 (the epoch) on my machine using ISO 8601 format strings that &lt;em&gt;should&lt;/em&gt; be parsed to exactly the same value in all implementations:</source>
          <target state="translated">但是，即使对于ISO 8601格式的字符串，某些实现也会弄错它。 这是Chrome和Firefox的比较输出，当此答案最初是在我的计算机上使用1970年1月1日（纪元）时使用ISO 8601格式的字符串编写的， &lt;em&gt;应该&lt;/em&gt;在所有实现中将其解析为完全相同的值：</target>
        </trans-unit>
        <trans-unit id="0a472dfd7a343b45d8c75ad7ad8c041502d3cfd4" translate="yes" xml:space="preserve">
          <source>Case One:</source>
          <target state="translated">案例一:</target>
        </trans-unit>
        <trans-unit id="5753210b49df9aaa277109952ec6a3536cc7dc7f" translate="yes" xml:space="preserve">
          <source>Case Two:</source>
          <target state="translated">情况二:</target>
        </trans-unit>
        <trans-unit id="85b3107f884ec20fdd3a4e1d0a919b470ef6b022" translate="yes" xml:space="preserve">
          <source>During recent experience writing a JS interpreter I wrestled plenty with the inner workings of ECMA/JS dates. So, I figure I'll throw in my 2 cents here. Hopefully sharing this stuff will help others with any questions about the differences among browsers in how they handle dates.</source>
          <target state="translated">在最近写JS翻译器的过程中,我在ECMAJS日期的内涵上纠结了很多。所以,我想在这里抛出我的2分钱。希望分享这些东西能帮助到其他的人,让他们了解到浏览器之间在处理日期方面的差异。</target>
        </trans-unit>
        <trans-unit id="3e6c3e988227ecbd67ecc191709a05d2041e8216" translate="yes" xml:space="preserve">
          <source>E.g. in moment.js you might write:</source>
          <target state="translated">例如,在moment.js中,你可以写出:</target>
        </trans-unit>
        <trans-unit id="6d76ff5990e57aeaf2947b419cafe10b430dc062" translate="yes" xml:space="preserve">
          <source>Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</source>
          <target state="translated">Fri Jul 08 2005 00:00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="b860ddc534bad45183fb140bb7bda595ebc89a57" translate="yes" xml:space="preserve">
          <source>Here is a short, flexible snippet to convert a datetime-string in a cross-browser-safe fashion as nicel detailed by @drankin2112.</source>
          <target state="translated">下面是一个简短灵活的片段,可以将日期时间字符串转换为跨浏览器安全的方式,就像@drankin2112所描述的那样。</target>
        </trans-unit>
        <trans-unit id="5148957378cc6f74e6c58f8d974a7f47c586b639" translate="yes" xml:space="preserve">
          <source>However, since parsing of even the formats specified in ECMA-262 is not consistent, it is recommended to never rely on the built&amp;ndash;in parser and to always manually parse strings, say using a library and provide the format to the parser.</source>
          <target state="translated">但是，由于即使对ECMA-262中指定的格式进行的解析也不是一致的，因此建议不要使用内置的解析器，而应始终手动解析字符串（例如使用库并将其提供给解析器）。</target>
        </trans-unit>
        <trans-unit id="f5dddceed7bb7c480aa13cc2f6b535772c5a9e56" translate="yes" xml:space="preserve">
          <source>However, the ISO 8601 format is different. It's one of only two formats outlined in ECMAScript 2015 (ed 6) specifically that must be parsed the same way by all implementations (the other is the format specified for &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt;).</source>
          <target state="translated">但是，ISO 8601格式不同。 它是ECMAScript 2015（第6版）中概述的仅有的两种格式之一，所有实现必须以相同的方式进行解析（另一种是为&lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt;指定的格式）。</target>
        </trans-unit>
        <trans-unit id="e2c8986ea1508fe0b2bf3ec0adb301fe747206ce" translate="yes" xml:space="preserve">
          <source>I hope this answer was helpful.</source>
          <target state="translated">希望这个回答对你有帮助。</target>
        </trans-unit>
        <trans-unit id="f8afc645c997911f63f4d970041f5f084c856a2e" translate="yes" xml:space="preserve">
          <source>I normally don't use the ISO format for string input. The only time that using that format is beneficial to me is when dates need to be sorted as strings. The ISO format is sortable as-is while the others are not. If you have to have cross-browser compatibility, either specify the timezone or use a compatible string format.</source>
          <target state="translated">我通常不使用ISO格式来输入字符串。唯一一次使用这种格式对我有好处的是,当日期需要作为字符串排序时。ISO格式是可以分类的,而其他格式则不能。如果你必须要有跨浏览器的兼容性,要么指定时区,要么使用兼容的字符串格式。</target>
        </trans-unit>
        <trans-unit id="eafbac2a62b0c25aa5d5017705a03cbb0f84561f" translate="yes" xml:space="preserve">
          <source>I removed the &lt;code&gt;Date.parse()&lt;/code&gt; call since it's used automatically on a string argument. I also compared the dates using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601 format&lt;/a&gt; so you could visually compare the dates between your local dates and the UTC dates. The times are 7 hours apart, which is the timezone difference and why your tests showed two different dates.</source>
          <target state="translated">我删除了 &lt;code&gt;Date.parse()&lt;/code&gt; 调用，因为它自动用于字符串参数。 我还使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601格式&lt;/a&gt;比较了日期，因此您可以直观地比较本地日期和UTC日期之间的日期。 时间相隔7个小时，这是时区差异，也是为什么测试显示两个不同的日期。</target>
        </trans-unit>
        <trans-unit id="8a5169d9dc407d763d113425d3a0fc4abb7ba0f4" translate="yes" xml:space="preserve">
          <source>I would recommend that date strings are parsed manually and the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date constructor&lt;/a&gt; used with year, month and day arguments to avoid ambiguity:</source>
          <target state="translated">我建议手动解析日期字符串，并将&lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date构造函数&lt;/a&gt;与年，月和日参数一起使用，以避免产生歧义：</target>
        </trans-unit>
        <trans-unit id="3e11fac7bc52471c46533893967eff49e1bd6420" translate="yes" xml:space="preserve">
          <source>In my timezone (EST, which is -05:00), the result is 18000000 because that's how many ms are in 5 hours (it's only 4 hours during daylight savings months). The value will be different in different time zones. This behaviour is specified in ECMA-262 so all browsers do it the same way.</source>
          <target state="translated">在我所在的时区(美国东部时间,也就是-05:00),结果是18000000,因为这就是5个小时内有多少毫秒(在夏令时节只有4个小时)。在不同的时区中,这个值会有不同的表现。这个行为是在ECMA-262中指定的,所以所有的浏览器都是这样做的。</target>
        </trans-unit>
        <trans-unit id="908bce4b419c2ccf07c436e83fa2df8fce9cd8a0" translate="yes" xml:space="preserve">
          <source>In the first case, the &quot;Z&quot; specifier indicates that the input is in UTC time so is not offset from the epoch and the result is 0</source>
          <target state="translated">在第一种情况下,&quot;Z &quot;指定器表示输入的时间是UTC时间,所以不偏移,结果是0</target>
        </trans-unit>
        <trans-unit id="19a4c64c93ef3b877cdc45684acc21ca75ba2348" translate="yes" xml:space="preserve">
          <source>In the second case, the &quot;-0500&quot; specifier indicates that the input is in GMT-05:00 and both browsers interpret the input as being in the -05:00 timezone. That means that the UTC value is offset from the epoch, which means adding 18000000ms to the date's internal time value.</source>
          <target state="translated">在第二种情况下,&quot;-0500 &quot;表示输入的时间是GMT-05:00,两个浏览器都将输入的时间解释为-05:00时区。这意味着UTC值与时区偏移了,这意味着在日期的内部时间值上增加了18000000ms。</target>
        </trans-unit>
        <trans-unit id="a6ce403299ba40b5af043efffb66015e275fe3aa" translate="yes" xml:space="preserve">
          <source>Most current browsers do treat the other input formats equally, including the frequently used '1/1/1970' (M/D/YYYY) and '1/1/1970 00:00:00 AM' (M/D/YYYY hh:mm:ss ap) formats. All of the following formats (except the last) are treated as local time input in all browsers. The output of this code is the same in all browsers in my timezone. The last one is treated as -05:00 regardless of the host timezone because the offset is set in the timestamp:</source>
          <target state="translated">目前大多数浏览器对其他输入格式都是一视同仁,包括常用的 &quot;111970&quot;(MDYYYYYY)和 &quot;111970 00:00:00:00:00 AM&quot;(MDYYYY hh:mm:ss ap)格式。以下所有的格式(除了最后一种)在所有浏览器中都被视为本地时间输入。这个代码的输出在我所在的时区的所有浏览器中都是一样的。最后一个是-05:00,因为时间戳中设置了偏移量,所以无论主机时区如何,最后一个都会被处理为-05:00。</target>
        </trans-unit>
        <trans-unit id="329918f300afe59c9c860ea10b639102790dba71" translate="yes" xml:space="preserve">
          <source>On the output side, all browsers translate time zones the same way but they handle the string formats differently. Here are the &lt;code&gt;toString&lt;/code&gt; functions and what they output. Notice the &lt;code&gt;toUTCString&lt;/code&gt; and &lt;code&gt;toISOString&lt;/code&gt; functions output 5:00 AM on my machine. Also, the timezone name may be an abbreviation and may be different in different implementations.</source>
          <target state="translated">在输出端，所有浏览器都以相同的方式转换时区，但是它们对字符串格式的处理方式不同。 这是 &lt;code&gt;toString&lt;/code&gt; 函数及其输出。 请注意，我的机器上凌晨5:00输出的 &lt;code&gt;toUTCString&lt;/code&gt; 和 &lt;code&gt;toISOString&lt;/code&gt; 函数。 另外，时区名称可能是缩写，在不同的实现中可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="3f4239f15acea77ec47e62826d3d8200b09d40e4" translate="yes" xml:space="preserve">
          <source>Parsing example:</source>
          <target state="translated">解析示例:</target>
        </trans-unit>
        <trans-unit id="03ce0a553f16d4afd68bf211c6b807fc0848709a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript and Dates, What a Mess!&lt;/a&gt; for more.</source>
          <target state="translated">看到&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript和日期，真是麻烦！&lt;/a&gt; 更多。</target>
        </trans-unit>
        <trans-unit id="4d82d6a6e2fae4b9611bc2380519d63c709fa614" translate="yes" xml:space="preserve">
          <source>So the first is parsed as local because it's ISO 8601 date and time with no timezone, and the second is parsed as UTC because it's ISO 8601 date only.</source>
          <target state="translated">所以第一个被解析为本地,因为它是ISO 8601的日期和时间,没有时区,第二个被解析为UTC,因为它是ISO 8601的日期。</target>
        </trans-unit>
        <trans-unit id="e0d77796c9cd5a8d874e6fa53e27915795a4dd04" translate="yes" xml:space="preserve">
          <source>So, to answer the original question directly, &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; is required by ECMA-262 to be interpreted as UTC, while the other is interpreted as local. That's why:</source>
          <target state="translated">因此，为了直接回答原始问题，ECMA-262要求将 &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; 解释为UTC，而将另一个解释为本地。 这就是为什么：</target>
        </trans-unit>
        <trans-unit id="94975b996ab726eb43afd2e0d1cc3c2a0c51b8fa" translate="yes" xml:space="preserve">
          <source>The 3rd argument determines strict parsing (available as of 2.3.0). Without it moment.js may also give incorrect results.</source>
          <target state="translated">第3个参数决定了严格的解析(从2.3.0起可用)。如果没有它,moment.js也可能会给出不正确的结果。</target>
        </trans-unit>
        <trans-unit id="e9c8520d7d6d203ec8749fd138fac64e8f76cdff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;accepted answer from CMS&lt;/a&gt; is correct, I have just added some features :</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;CMS接受的答案&lt;/a&gt;是正确的，我刚刚添加了一些功能：</target>
        </trans-unit>
        <trans-unit id="2a342756f33785e6c85b3adbaed213b9f8122f60" translate="yes" xml:space="preserve">
          <source>The Input Side</source>
          <target state="translated">输入端</target>
        </trans-unit>
        <trans-unit id="9e592f9d7a2c00500d34cfad7648b183ab77f6c9" translate="yes" xml:space="preserve">
          <source>The Output Side</source>
          <target state="translated">输出端</target>
        </trans-unit>
        <trans-unit id="c40570cdc17820bbf50c2f2e9682a95a5f1d3fa2" translate="yes" xml:space="preserve">
          <source>The bottom line is this for parsing date strings. The ONLY ISO 8601 string that you can safely parse across browsers is the long form &lt;strong&gt;with an offset&lt;/strong&gt; (either &amp;plusmn;HH:mm or &quot;Z&quot;). If you do that you can safely go back and forth between local and UTC time.</source>
          <target state="translated">底线是用于解析日期字符串的。 您可以在浏览器中安全解析的唯一ISO 8601字符串是&lt;strong&gt;带偏移量&lt;/strong&gt;的长格式（&amp;plusmn;HH：mm或&amp;ldquo; Z&amp;rdquo;）。 如果这样做，您可以安全地在本地时间和UTC时间之间来回切换。</target>
        </trans-unit>
        <trans-unit id="e3d92e81c30052126018d0b6fe8887d2781e7720" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; goes through the following internal pseudo-transformation:</source>
          <target state="translated">代码 &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; 经过以下内部伪转换：</target>
        </trans-unit>
        <trans-unit id="65906fa3e7ce8fad1d8655c65018896ad655268b" translate="yes" xml:space="preserve">
          <source>The following code is interpreted as the same date in all current browsers, but with the local timezone offset:</source>
          <target state="translated">下面的代码在所有的浏览器中都被解释为相同的日期,但在当地时区偏移。</target>
        </trans-unit>
        <trans-unit id="d3944e1a1d4b6d4aac17b1a5590040c5041da04b" translate="yes" xml:space="preserve">
          <source>The other way of creating these same local/UTC dates would be:</source>
          <target state="translated">创建这些相同的地方性的UTC日期的另一种方式是:</target>
        </trans-unit>
        <trans-unit id="5d0497f028deb4dc2146ce1c8c9e6814ca98c636" translate="yes" xml:space="preserve">
          <source>The third case, where there is no specifier, &lt;em&gt;should&lt;/em&gt; be treated as local for the host system. FF correctly treats the input as local time while Chrome treats it as UTC, so producing different time values. For me this creates a 5 hour difference in the stored value, which is problematic. Other systems with different offsets will get different results.</source>
          <target state="translated">第三种情况，没有说明符， &lt;em&gt;应&lt;/em&gt;视为主机系统的本地情况。 FF正确地将输入视为本地时间，而Chrome将其视为UTC，因此会产生不同的时间值。 对我来说，这会造成5个小时的储值差异，这是有问题的。 具有不同偏移量的其他系统将获得不同的结果。</target>
        </trans-unit>
        <trans-unit id="394f1354d0dfb6c25e79e0d8b28cdc0bc36394f3" translate="yes" xml:space="preserve">
          <source>There is some method to the madness. As a general rule, if a browser can interpret a date as an ISO-8601, it will. &quot;2005-07-08&quot; falls into this camp, and so it is parsed as UTC. &quot;Jul 8, 2005&quot; cannot, and so it is parsed in the local time.</source>
          <target state="translated">乱七八糟的事情是有一定方法的。一般来说,如果浏览器能将日期解释为ISO-8601,它就会解释为ISO-8601。&quot;2005-07-08 &quot;属于这个阵营,所以它被解析为UTC。&quot;2005年7月8日 &quot;不能,所以它被解析为当地时间。</target>
        </trans-unit>
        <trans-unit id="c1cccf6baf164d26a736174ff77efdcce4e566d7" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;light weight date parsing library&lt;/a&gt; should solve all similar problems. I like the library because it is quite easy to extend. It's also possible to i18n it (not very straight forward, but not that hard).</source>
          <target state="translated">这个&lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;轻量级的日期解析库&lt;/a&gt;应该解决所有类似的问题。 我喜欢该库，因为它很容易扩展。 也有可能（不是很简单，但是就不那么难了）。</target>
        </trans-unit>
        <trans-unit id="ccdae7f2697cfbeb00896696c226905929a42c47" translate="yes" xml:space="preserve">
          <source>This difference has been fixed as of 2020, but other quirks exist between browsers when parsing ISO 8601 format strings.</source>
          <target state="translated">从2020年起,这种差异已被修复,但在解析ISO 8601格式字符串时,浏览器之间还存在其他怪癖。</target>
        </trans-unit>
        <trans-unit id="29826c41ae1f24abb8f555f34335d1a7f547f781" translate="yes" xml:space="preserve">
          <source>This does:</source>
          <target state="translated">这样做。</target>
        </trans-unit>
        <trans-unit id="d8aa042eeddd4ec553d436c607f47196ee9a2c60" translate="yes" xml:space="preserve">
          <source>This doesn't produce equivalent results:</source>
          <target state="translated">这并不能产生同等的结果。</target>
        </trans-unit>
        <trans-unit id="a34d3bdcbaac98280e75f02293f3f94dbdf16507" translate="yes" xml:space="preserve">
          <source>This method is useful for date formatted in an unussual way.</source>
          <target state="translated">这种方法对日期格式化的方法很有用。</target>
        </trans-unit>
        <trans-unit id="2aff6e8126e34aa3caca466a07d2eaa3e4366184" translate="yes" xml:space="preserve">
          <source>This works across browsers (after IE9):</source>
          <target state="translated">这在各个浏览器中都能使用(IE9之后)。</target>
        </trans-unit>
        <trans-unit id="70abab8d661bb8c79da568d773e006d09a13d4c7" translate="yes" xml:space="preserve">
          <source>Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</source>
          <target state="translated">Thu Jul 07 2005 17:00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="8484dedd2f01dd09a976d7895bfd07f3c5317194" translate="yes" xml:space="preserve">
          <source>Until the 5th edition spec came out, the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse&lt;/code&gt;&lt;/a&gt; method was completely &lt;em&gt;implementation dependent&lt;/em&gt; (&lt;code&gt;new Date(string)&lt;/code&gt; is equivalent to &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse(string)&lt;/code&gt;&lt;/a&gt; except the latter returns a number rather than a &lt;code&gt;Date&lt;/code&gt;). In the 5th edition spec the requirement was added to support a &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;simplified &lt;em&gt;(and slightly incorrect)&lt;/em&gt; ISO-8601&lt;/a&gt; (also see &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;What are valid Date Time Strings in JavaScript?&lt;/a&gt;). But other than that, there was &lt;em&gt;no&lt;/em&gt; requirement for what &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; should accept other than that they had to accept whatever &lt;em&gt;Date#toString&lt;/em&gt; output (without saying what that was).</source>
          <target state="translated">在第5版规范发布之前， &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse&lt;/code&gt; &lt;/a&gt;方法完全&lt;em&gt;依赖&lt;/em&gt;于&lt;em&gt;实现&lt;/em&gt; （ &lt;code&gt;new Date(string)&lt;/code&gt; 等效于&lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse(string)&lt;/code&gt; ,&lt;/a&gt;但后者返回一个数字而不是 &lt;code&gt;Date&lt;/code&gt; ）。 在第5版规范中，添加了该要求以支持&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;简化的&lt;em&gt;（并且略有错误）&lt;/em&gt; ISO-8601&lt;/a&gt; （另请参见&lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;JavaScript中有效的日期时间字符串是什么？&lt;/a&gt; ）。 但是除此之外，除了必须接受任何&lt;em&gt;Date＃toString&lt;/em&gt;输出（不说那是什么）之外， &lt;em&gt;没有&lt;/em&gt;要求 &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; 应该接受什么。</target>
        </trans-unit>
        <trans-unit id="2d5bd9fd9174b8eb5a741f9403f6e3110d996178" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; to parse dates:</source>
          <target state="translated">使用&lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt;解析日期：</target>
        </trans-unit>
        <trans-unit id="f756909dd61f67dbd0fa45f2954bffc95d38db8c" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS is correct&lt;/a&gt; that passing strings into the parse method is generally unsafe, the new &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; (aka ES5) specification in section 15.9.4.2 suggests that &lt;code&gt;Date.parse()&lt;/code&gt; actually should handle ISO-formatted dates.  The old specification made no such claim.  Of course, old browsers and some current browsers still do not provide this ES5 functionality.</source>
          <target state="translated">尽管&lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS是正确的&lt;/a&gt; ，通常将字符串传递到parse方法是不安全的，但15.9.4.2节中的新&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262第5版&lt;/a&gt; （aka ES5）规范建议 &lt;code&gt;Date.parse()&lt;/code&gt; 实际上应处理ISO格式的日期。 旧的规范没有这样的要求。 当然，旧的浏览器和某些当前的浏览器仍然不提供此ES5功能。</target>
        </trans-unit>
        <trans-unit id="000e986495e06d3e141bf3d31e41d73051e8f358" translate="yes" xml:space="preserve">
          <source>While there is some variance in the input string formats that the major browsers will parse as dates, they essentially interpret them the same as far as time zones and daylight saving is concerned even though parsing is largely implementation dependent.</source>
          <target state="translated">虽然主要的浏览器会将输入的字符串格式解析为日期,但就时区和夏令时而言,它们的解释基本上是一样的,尽管解析方式主要取决于实现。</target>
        </trans-unit>
        <trans-unit id="26a2662fc63bb5e525fe443f8b51a5c405da8642" translate="yes" xml:space="preserve">
          <source>Why does Date.parse give incorrect results</source>
          <target state="translated">为什么Date.parse会给出不正确的结果?</target>
        </trans-unit>
        <trans-unit id="53bb717b5c32b6955911e011f267562b9a75046e" translate="yes" xml:space="preserve">
          <source>Why is the second parse incorrect?</source>
          <target state="translated">为什么第二种解析不正确?</target>
        </trans-unit>
        <trans-unit id="a4cce5e2b9dc56c7bfb388bfaf8034052d1ef9f3" translate="yes" xml:space="preserve">
          <source>Your browser should provide the same timestamp result as &lt;code&gt;Date.parse&lt;/code&gt; with:</source>
          <target state="translated">您的浏览器应提供与 &lt;code&gt;Date.parse&lt;/code&gt; 相同的时间戳结果， 并带有：</target>
        </trans-unit>
        <trans-unit id="9881a40adae03bee4aa623d90b2f10362dccc465" translate="yes" xml:space="preserve">
          <source>Your second example isn't wrong.  It is the specified date in UTC, as implied by &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt;, but is represented in your local timezone.</source>
          <target state="translated">您的第二个示例没有错。 它是UTC中指定的日期，如 &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt; 所示 ，但以您当地的时区表示。</target>
        </trans-unit>
        <trans-unit id="92d7171de3872ec4508067fb2af0dded0ac2d69e" translate="yes" xml:space="preserve">
          <source>ddd MMM DD YYYY HH:mm:ss ZZ [(timezone name)]</source>
          <target state="translated">ddd MMM DD YYYY HH:mm:ss ZZ [(时区名称)]</target>
        </trans-unit>
        <trans-unit id="8c6d4efc15654f3eef450f8d913fa875df8b52fb" translate="yes" xml:space="preserve">
          <source>ddd, DD MMM YYYY HH:mm:ss Z</source>
          <target state="translated">ddd,DD MMM YYYY HH:mm:ss Z</target>
        </trans-unit>
        <trans-unit id="5c8513ccc6fc79d319c1df7112d15fb2fb915dc7" translate="yes" xml:space="preserve">
          <source>e.g. Tue 10 Jul 2018 13:09:58 GMT</source>
          <target state="translated">例如:Tue 10 Jul 2018 13:09:58 GMT</target>
        </trans-unit>
        <trans-unit id="23434f99a2b3c6f550f6e0a6d9e1ba839b3e8a16" translate="yes" xml:space="preserve">
          <source>e.g. Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</source>
          <target state="translated">例如:Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</target>
        </trans-unit>
        <trans-unit id="d1ddeacf52011ebb962433f44ce9822043ddbfb9" translate="yes" xml:space="preserve">
          <source>has default day and time</source>
          <target state="translated">有默认的日期和时间</target>
        </trans-unit>
        <trans-unit id="e5a84d89b903471848654d119508be450a6f5c9d" translate="yes" xml:space="preserve">
          <source>parse slashes, dashes, colons and spaces</source>
          <target state="translated">斜线、破折号、冒号和空格解析</target>
        </trans-unit>
        <trans-unit id="f39e41649d7d19e35e8c2fef343daa4bffd355a2" translate="yes" xml:space="preserve">
          <source>providing 2 more formats that &lt;em&gt;Date.parse&lt;/em&gt; should parse reliably in new implementations (noting that support is not ubiquitous and non&amp;ndash;compliant implementations will remain in use for some time).</source>
          <target state="translated">提供了&lt;em&gt;Date.parse&lt;/em&gt;应该在新的实现中可靠地解析的另外2种格式（请注意，支持并不普遍，并且不兼容的实现将在一段时间内继续使用）。</target>
        </trans-unit>
        <trans-unit id="9be737ab099b587933e866d3ba0b2b0808b2a779" translate="yes" xml:space="preserve">
          <source>trim and clean input spaces</source>
          <target state="translated">裁剪和清洁的输入空间</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
