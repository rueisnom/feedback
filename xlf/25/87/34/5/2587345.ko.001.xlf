<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2587345">
    <body>
      <group id="2587345">
        <trans-unit id="0c7e8e540151253a4c9da94e55fcb821d298968a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Converts from UTC to Local time before printing&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;인쇄하기 전에 UTC에서 현지 시간으로 변환&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f059597f5f1fa300f1037881986242ca28ef0de2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Prints the stored UTC time directly&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;저장된 UTC 시간을 직접 인쇄합니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cb2c614a7e6d70e7f901e243a922149538a5f253" translate="yes" xml:space="preserve">
          <source>According to &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; the format &quot;yyyy/mm/dd&quot; solves the usual problems. 
He says: &quot;Stick to &quot;YYYY/MM/DD&quot; for your date strings whenever possible. It's universally supported and unambiguous. With this format, all times are local.&quot;
I've set tests: &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt;
This format: 
 + avoids the day and month order ambiguity by using y m d ordering and a 4-digit year
 + avoids the UTC vs. local issue not complying with ISO format by using slashes
 + danvk, the &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; guy, says that this format is good in all browsers.</source>
          <target state="translated">&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&lt;/a&gt; 에 따르면 &quot;yyyy / mm / dd&quot;형식은 일반적인 문제를 해결합니다. &quot;언제나 가능하면 날짜 문자열을&quot;YYYY / MM / DD &quot;로 고정하십시오. 보편적으로 지원되며 모호하지 않습니다.이 형식으로 모든 시간은 현지 시간입니다.&quot; 테스트를 설정했습니다 : &lt;a href=&quot;http://jsfiddle.net/jlanus/ND2Qg/432/&quot;&gt;http://jsfiddle.net/jlanus/ND2Qg/432/&lt;/a&gt; 이 형식 : +는 ymd 순서를 사용하여 일 및 월 순서 모호성을 피하고 4 자리 연도 + UTC 대 로컬 문제를 피합니다 &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;dygraphs&lt;/a&gt; guy 인 슬래시 + danvk를 사용하여 ISO 형식을 준수하면이 형식이 모든 브라우저에서 적합하다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="a6336241eb2f70e9b3891297c4ab9c1d2f8717cc" translate="yes" xml:space="preserve">
          <source>All implementations store their date values internally as 64-bit numbers that represent the number of milliseconds (ms) since 1970-01-01 UTC (GMT is the same thing as UTC). This date is the ECMAScript epoch that is also used by other languages such as Java and POSIX systems such as UNIX. Dates occurring after the epoch are positive numbers and dates prior are negative.</source>
          <target state="translated">모든 구현은 1970-01-01 UTC (GMT는 UTC와 동일 함) 이후 밀리 초 (ms) 수를 나타내는 64 비트 숫자로 내부적으로 날짜 값을 저장합니다. 이 날짜는 ECMAScript 시대이며 Java와 같은 다른 언어와 UNIX와 같은 POSIX 시스템에서도 사용됩니다. 신기원 이후에 발생한 날짜는 양수이고 이전 날짜는 음수입니다.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3f985930aa901a1d9c35ccb7e96c02b267cfb49d" translate="yes" xml:space="preserve">
          <source>And formatting back to string (you will notice both cases give exactly the same result):</source>
          <target state="translated">그리고 문자열로 다시 서식을 지정하면 두 경우 모두 정확히 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ec0217d9d7eed8ae005f5bb921308ea40b3f6a" translate="yes" xml:space="preserve">
          <source>Another solution is to build an associative array with date format and then reformat data.</source>
          <target state="translated">다른 해결책은 날짜 형식으로 연관 배열을 작성한 다음 데이터를 다시 형식화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8242ef969808a0a3455e3a7f614860267b947c9" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2017 (edition 8), implementations were required to parse their output for &lt;em&gt;Date#toString&lt;/em&gt; and &lt;em&gt;Date#toUTCString&lt;/em&gt;, but the format of those strings was not specified.</source>
          <target state="translated">ECMAScript 2017 (버전 8)부터 구현은 &lt;em&gt;Date # toString&lt;/em&gt; 및 &lt;em&gt;Date # toUTCString에&lt;/em&gt; 대한 출력을 구문 분석해야하지만 해당 문자열의 형식은 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="111ce656eb8f6ad6c1d696a512bf12f7be113eb8" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2019 (edition 9) the format for &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date#toString&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date#toUTCString&lt;/em&gt;&lt;/a&gt;, have been specified as (respectively):</source>
          <target state="translated">ECMAScript 2019 (9 버전)부터 &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.tostring&quot;&gt;&lt;em&gt;Date # toString&lt;/em&gt;&lt;/a&gt; 및 &lt;a href=&quot;http://ecma-international.org/ecma-262/9.0/#sec-date.prototype.toutcstring&quot;&gt;&lt;em&gt;Date # toUTCString&lt;/em&gt;&lt;/a&gt; 형식은 (각각) 다음과 같이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="d325ccf2d171ea2eb390c34b0d77dd7659093fbe" translate="yes" xml:space="preserve">
          <source>Both are correct, but they are being interpreted as dates with two different timezones. So you compared apples and oranges:</source>
          <target state="translated">둘 다 정확하지만 두 시간대가 다른 날짜로 해석되고 있습니다. 따라서 사과와 오렌지를 비교했습니다.</target>
        </trans-unit>
        <trans-unit id="5c14087dc81e8df1775a715b953512bb2a9be63d" translate="yes" xml:space="preserve">
          <source>But I still strongly recommend &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; which is as &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;simple yet powerful&lt;/a&gt;:</source>
          <target state="translated">그러나 나는 여전히 &lt;a href=&quot;http://momentjs.com/docs/#/parsing/&quot;&gt;간단하지만 강력한&lt;/a&gt; &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; 를 강력히 추천합니다.</target>
        </trans-unit>
        <trans-unit id="a264e7734e248a8ae1aa2c98f35907f8b28c5d4d" translate="yes" xml:space="preserve">
          <source>But it gets worse. A quirk of ECMA-262 is that the ISO 8601 date&amp;ndash;only format (YYYY-MM-DD) is required to be parsed as UTC, whereas ISO 8601 requires it to be parsed as local. Here is the output from FF with the long and short ISO date formats with no time zone specifier.</source>
          <target state="translated">그러나 악화됩니다. ECMA-262의 단점은 ISO 8601 날짜 전용 형식 (YYYY-MM-DD)을 UTC로 구문 분석해야하는 반면 ISO 8601은 로컬 형식으로 구문 분석해야한다는 것입니다. 다음은 시간대 지정자가없는 길고 짧은 ISO 날짜 형식의 FF 출력입니다.</target>
        </trans-unit>
        <trans-unit id="833d0d480c692e50e5abaaea33ace37c993601e4" translate="yes" xml:space="preserve">
          <source>But, even for ISO 8601 format strings, some implementations get it wrong. Here is a comparison output of Chrome and Firefox when this answer was originally written for 1/1/1970 (the epoch) on my machine using ISO 8601 format strings that &lt;em&gt;should&lt;/em&gt; be parsed to exactly the same value in all implementations:</source>
          <target state="translated">그러나 ISO 8601 형식 문자열의 경우에도 일부 구현에서는 잘못 구현됩니다. 다음은이 답변이 모든 구현에서 정확히 동일한 값으로 구문 분석 &lt;em&gt;해야하는&lt;/em&gt; ISO 8601 형식 문자열을 사용하여 내 컴퓨터에서 1/1/1970 (에포크)로 작성된 경우 Chrome과 Firefox의 비교 출력입니다.</target>
        </trans-unit>
        <trans-unit id="0a472dfd7a343b45d8c75ad7ad8c041502d3cfd4" translate="yes" xml:space="preserve">
          <source>Case One:</source>
          <target state="translated">사례 하나 :</target>
        </trans-unit>
        <trans-unit id="5753210b49df9aaa277109952ec6a3536cc7dc7f" translate="yes" xml:space="preserve">
          <source>Case Two:</source>
          <target state="translated">사례 2 :</target>
        </trans-unit>
        <trans-unit id="85b3107f884ec20fdd3a4e1d0a919b470ef6b022" translate="yes" xml:space="preserve">
          <source>During recent experience writing a JS interpreter I wrestled plenty with the inner workings of ECMA/JS dates. So, I figure I'll throw in my 2 cents here. Hopefully sharing this stuff will help others with any questions about the differences among browsers in how they handle dates.</source>
          <target state="translated">최근 JS 통역사를 쓴 경험을 통해 ECMA / JS 날짜의 내부 작업에 많은 어려움을 겪었습니다. 그래서 여기에 2 센트를 넣을 것이라고 생각합니다. 이 자료를 공유하면 브라우저가 날짜를 처리하는 방식의 차이점에 대한 질문에 다른 사람들이 도움이 될 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="3e6c3e988227ecbd67ecc191709a05d2041e8216" translate="yes" xml:space="preserve">
          <source>E.g. in moment.js you might write:</source>
          <target state="translated">예를 들어 moment.js에서는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d76ff5990e57aeaf2947b419cafe10b430dc062" translate="yes" xml:space="preserve">
          <source>Fri Jul 08 2005 00:00:00 GMT-0700 (PST)</source>
          <target state="translated">2005 년 7 월 08 일 00:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="b860ddc534bad45183fb140bb7bda595ebc89a57" translate="yes" xml:space="preserve">
          <source>Here is a short, flexible snippet to convert a datetime-string in a cross-browser-safe fashion as nicel detailed by @drankin2112.</source>
          <target state="translated">다음은 @ drankin2112에 의해 자세히 설명 된대로 브라우저 간 안전한 방식으로 날짜 시간 문자열을 변환하는 짧고 유연한 스 니펫입니다.</target>
        </trans-unit>
        <trans-unit id="5148957378cc6f74e6c58f8d974a7f47c586b639" translate="yes" xml:space="preserve">
          <source>However, since parsing of even the formats specified in ECMA-262 is not consistent, it is recommended to never rely on the built&amp;ndash;in parser and to always manually parse strings, say using a library and provide the format to the parser.</source>
          <target state="translated">그러나 ECMA-262에 지정된 형식의 구문 분석도 일관되지 않으므로 내장 구문 분석기에 의존하지 말고 라이브러리를 사용하여 구문 분석기에 형식을 제공하는 등 항상 문자열을 수동으로 구문 분석하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f5dddceed7bb7c480aa13cc2f6b535772c5a9e56" translate="yes" xml:space="preserve">
          <source>However, the ISO 8601 format is different. It's one of only two formats outlined in ECMAScript 2015 (ed 6) specifically that must be parsed the same way by all implementations (the other is the format specified for &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString&lt;/a&gt;).</source>
          <target state="translated">그러나 ISO 8601 형식이 다릅니다. ECMAScript 2015 (ed 6)에 요약 된 두 가지 형식 중 하나이며 특히 모든 구현에서 동일한 방식으로 구문 분석해야합니다 (다른 형식은 &lt;a href=&quot;http://ecma-international.org/ecma-262/6.0/index.html#sec-date.prototype.tostring&quot;&gt;Date.prototype.toString에&lt;/a&gt; 지정된 형식 임 ).</target>
        </trans-unit>
        <trans-unit id="e2c8986ea1508fe0b2bf3ec0adb301fe747206ce" translate="yes" xml:space="preserve">
          <source>I hope this answer was helpful.</source>
          <target state="translated">이 답변이 도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="f8afc645c997911f63f4d970041f5f084c856a2e" translate="yes" xml:space="preserve">
          <source>I normally don't use the ISO format for string input. The only time that using that format is beneficial to me is when dates need to be sorted as strings. The ISO format is sortable as-is while the others are not. If you have to have cross-browser compatibility, either specify the timezone or use a compatible string format.</source>
          <target state="translated">나는 일반적으로 문자열 입력에 ISO 형식을 사용하지 않습니다. 해당 형식을 사용하는 것이 유익한 유일한 날짜는 날짜를 문자열로 정렬해야 할 때입니다. ISO 형식은있는 그대로 정렬 할 수 있지만 다른 형식은 정렬 할 수 없습니다. 브라우저 간 호환성이 필요한 경우 시간대를 지정하거나 호환 가능한 문자열 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eafbac2a62b0c25aa5d5017705a03cbb0f84561f" translate="yes" xml:space="preserve">
          <source>I removed the &lt;code&gt;Date.parse()&lt;/code&gt; call since it's used automatically on a string argument. I also compared the dates using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601 format&lt;/a&gt; so you could visually compare the dates between your local dates and the UTC dates. The times are 7 hours apart, which is the timezone difference and why your tests showed two different dates.</source>
          <target state="translated">&lt;code&gt;Date.parse()&lt;/code&gt; 호출은 문자열 인수에서 자동으로 사용되므로 제거했습니다. 또한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;ISO8601 형식을&lt;/a&gt; 사용하여 날짜를 비교하여 현지 날짜와 UTC 날짜 사이의 날짜를 시각적으로 비교할 수 있습니다. 시간은 7 시간 간격이며, 이는 시간대 차이이며 테스트에서 두 가지 다른 날짜가 표시된 이유입니다.</target>
        </trans-unit>
        <trans-unit id="8a5169d9dc407d763d113425d3a0fc4abb7ba0f4" translate="yes" xml:space="preserve">
          <source>I would recommend that date strings are parsed manually and the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date constructor&lt;/a&gt; used with year, month and day arguments to avoid ambiguity:</source>
          <target state="translated">모호성을 피하기 위해 날짜 문자열을 수동으로 구문 분석하고 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.3.1&quot;&gt;Date 생성자&lt;/a&gt; 를 연도, 월 및 일 인수와 함께 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e11fac7bc52471c46533893967eff49e1bd6420" translate="yes" xml:space="preserve">
          <source>In my timezone (EST, which is -05:00), the result is 18000000 because that's how many ms are in 5 hours (it's only 4 hours during daylight savings months). The value will be different in different time zones. This behaviour is specified in ECMA-262 so all browsers do it the same way.</source>
          <target state="translated">내 시간대 (EST, -05 : 00)에서 결과는 18000000입니다. 이는 5 시간 동안의 ms 수 (일광 절약 시간 동안 4 시간에 불과)이기 때문입니다. 시간대에 따라 값이 달라집니다. 이 동작은 ECMA-262에 지정되어 있으므로 모든 브라우저가 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="908bce4b419c2ccf07c436e83fa2df8fce9cd8a0" translate="yes" xml:space="preserve">
          <source>In the first case, the &quot;Z&quot; specifier indicates that the input is in UTC time so is not offset from the epoch and the result is 0</source>
          <target state="translated">첫 번째 경우 &quot;Z&quot;지정자는 입력이 UTC 시간이므로 에포크에서 오프셋되지 않고 결과가 0임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="19a4c64c93ef3b877cdc45684acc21ca75ba2348" translate="yes" xml:space="preserve">
          <source>In the second case, the &quot;-0500&quot; specifier indicates that the input is in GMT-05:00 and both browsers interpret the input as being in the -05:00 timezone. That means that the UTC value is offset from the epoch, which means adding 18000000ms to the date's internal time value.</source>
          <target state="translated">두 번째 경우 &quot;-0500&quot;지정자는 입력이 GMT-05 : 00에 있고 두 브라우저 모두 입력이 -05 : 00 시간대에있는 것으로 해석합니다. 이는 UTC 값이 에포크 (epoch)에서 오프셋됨을 의미하며, 이는 날짜의 내부 시간 값에 18000000ms를 추가 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a6ce403299ba40b5af043efffb66015e275fe3aa" translate="yes" xml:space="preserve">
          <source>Most current browsers do treat the other input formats equally, including the frequently used '1/1/1970' (M/D/YYYY) and '1/1/1970 00:00:00 AM' (M/D/YYYY hh:mm:ss ap) formats. All of the following formats (except the last) are treated as local time input in all browsers. The output of this code is the same in all browsers in my timezone. The last one is treated as -05:00 regardless of the host timezone because the offset is set in the timestamp:</source>
          <target state="translated">대부분의 최신 브라우저는 자주 사용되는 '1/1/1970'(M / D / YYYY) 및 '1/1/1970 00:00:00 AM'(M / D / YYYY hh)을 포함하여 다른 입력 형식을 동일하게 취급합니다. : mm : ss ap) 형식입니다. 다음 형식 (마지막 제외)은 모두 모든 브라우저에서 현지 시간 입력으로 처리됩니다. 이 코드의 출력은 내 시간대의 모든 브라우저에서 동일합니다. 오프셋은 타임 스탬프에서 설정되므로 마지막 시간대는 호스트 시간대와 상관없이 -05 : 00으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="329918f300afe59c9c860ea10b639102790dba71" translate="yes" xml:space="preserve">
          <source>On the output side, all browsers translate time zones the same way but they handle the string formats differently. Here are the &lt;code&gt;toString&lt;/code&gt; functions and what they output. Notice the &lt;code&gt;toUTCString&lt;/code&gt; and &lt;code&gt;toISOString&lt;/code&gt; functions output 5:00 AM on my machine. Also, the timezone name may be an abbreviation and may be different in different implementations.</source>
          <target state="translated">출력 측에서 모든 브라우저는 시간대를 동일한 방식으로 변환하지만 문자열 형식을 다르게 처리합니다. 다음은 &lt;code&gt;toString&lt;/code&gt; 함수와 출력 내용입니다. 내 컴퓨터에서 &lt;code&gt;toUTCString&lt;/code&gt; 및 &lt;code&gt;toISOString&lt;/code&gt; 함수 출력 오전 5시를 확인하십시오. 또한 시간대 이름은 약어 일 수 있으며 구현에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="3f4239f15acea77ec47e62826d3d8200b09d40e4" translate="yes" xml:space="preserve">
          <source>Parsing example:</source>
          <target state="translated">구문 분석 예 :</target>
        </trans-unit>
        <trans-unit id="03ce0a553f16d4afd68bf211c6b807fc0848709a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript and Dates, What a Mess!&lt;/a&gt; for more.</source>
          <target state="translated">&lt;a href=&quot;http://blog.dygraphs.com/2012/03/javascript-and-dates-what-mess.html&quot;&gt;JavaScript와 날짜, 엉망인 것을보십시오!&lt;/a&gt; 이상.</target>
        </trans-unit>
        <trans-unit id="4d82d6a6e2fae4b9611bc2380519d63c709fa614" translate="yes" xml:space="preserve">
          <source>So the first is parsed as local because it's ISO 8601 date and time with no timezone, and the second is parsed as UTC because it's ISO 8601 date only.</source>
          <target state="translated">따라서 첫 번째는 표준 시간대가없는 ISO 8601 날짜 및 시간이므로 로컬로 구문 분석되고 두 번째는 ISO 8601 날짜이므로 UTC로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="e0d77796c9cd5a8d874e6fa53e27915795a4dd04" translate="yes" xml:space="preserve">
          <source>So, to answer the original question directly, &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; is required by ECMA-262 to be interpreted as UTC, while the other is interpreted as local. That's why:</source>
          <target state="translated">따라서 원래 질문에 직접 대답하려면 ECMA-262에서 &lt;code&gt;&quot;YYYY-MM-DD&quot;&lt;/code&gt; 를 UTC로 해석하고 다른 하나를 로컬로 해석해야합니다. 그 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94975b996ab726eb43afd2e0d1cc3c2a0c51b8fa" translate="yes" xml:space="preserve">
          <source>The 3rd argument determines strict parsing (available as of 2.3.0). Without it moment.js may also give incorrect results.</source>
          <target state="translated">세 번째 인수는 엄격한 구문 분석을 결정합니다 (2.3.0부터 사용 가능). 그것없이 moment.js는 또한 잘못된 결과를 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c8520d7d6d203ec8749fd138fac64e8f76cdff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;accepted answer from CMS&lt;/a&gt; is correct, I have just added some features :</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2587398/6695569&quot;&gt;CMS의 대답&lt;/a&gt; 은 정확합니다. 방금 몇 가지 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="2a342756f33785e6c85b3adbaed213b9f8122f60" translate="yes" xml:space="preserve">
          <source>The Input Side</source>
          <target state="translated">입력측</target>
        </trans-unit>
        <trans-unit id="9e592f9d7a2c00500d34cfad7648b183ab77f6c9" translate="yes" xml:space="preserve">
          <source>The Output Side</source>
          <target state="translated">출력측</target>
        </trans-unit>
        <trans-unit id="c40570cdc17820bbf50c2f2e9682a95a5f1d3fa2" translate="yes" xml:space="preserve">
          <source>The bottom line is this for parsing date strings. The ONLY ISO 8601 string that you can safely parse across browsers is the long form &lt;strong&gt;with an offset&lt;/strong&gt; (either &amp;plusmn;HH:mm or &quot;Z&quot;). If you do that you can safely go back and forth between local and UTC time.</source>
          <target state="translated">결론은 날짜 문자열을 구문 분석하는 것입니다. 브라우저에서 안전하게 구문 분석 할 수있는 유일한 ISO 8601 문자열 &lt;strong&gt;은 오프셋&lt;/strong&gt; 이있는 긴 형식 (&amp;plusmn; HH : mm 또는 &quot;Z&quot;)입니다. 그렇게하면 현지 시간과 UTC 시간 사이를 안전하게 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d92e81c30052126018d0b6fe8887d2781e7720" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; goes through the following internal pseudo-transformation:</source>
          <target state="translated">&lt;code&gt;new Date('12/4/2013').toString()&lt;/code&gt; 는 다음과 같은 내부 의사 변환을 거칩니다.</target>
        </trans-unit>
        <trans-unit id="65906fa3e7ce8fad1d8655c65018896ad655268b" translate="yes" xml:space="preserve">
          <source>The following code is interpreted as the same date in all current browsers, but with the local timezone offset:</source>
          <target state="translated">다음 코드는 모든 현재 브라우저에서 동일한 날짜로 해석되지만 현지 시간대 오프셋이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d3944e1a1d4b6d4aac17b1a5590040c5041da04b" translate="yes" xml:space="preserve">
          <source>The other way of creating these same local/UTC dates would be:</source>
          <target state="translated">동일한 현지 / UTC 날짜를 만드는 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d0497f028deb4dc2146ce1c8c9e6814ca98c636" translate="yes" xml:space="preserve">
          <source>The third case, where there is no specifier, &lt;em&gt;should&lt;/em&gt; be treated as local for the host system. FF correctly treats the input as local time while Chrome treats it as UTC, so producing different time values. For me this creates a 5 hour difference in the stored value, which is problematic. Other systems with different offsets will get different results.</source>
          <target state="translated">지정자가없는 세 번째 경우는 호스트 시스템의 로컬로 처리 &lt;em&gt;해야&lt;/em&gt; 합니다. FF는 입력을 현지 시간으로 올바르게 처리하는 반면 Chrome은 입력을 UTC로 처리하므로 다른 시간 값을 생성합니다. 나에게 이것은 저장된 값에서 5 시간의 차이를 생성하는데 문제가 있습니다. 오프셋이 다른 다른 시스템은 다른 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="394f1354d0dfb6c25e79e0d8b28cdc0bc36394f3" translate="yes" xml:space="preserve">
          <source>There is some method to the madness. As a general rule, if a browser can interpret a date as an ISO-8601, it will. &quot;2005-07-08&quot; falls into this camp, and so it is parsed as UTC. &quot;Jul 8, 2005&quot; cannot, and so it is parsed in the local time.</source>
          <target state="translated">광기에 대한 몇 가지 방법이 있습니다. 일반적으로 브라우저가 날짜를 ISO-8601로 해석 할 수 있다면 그렇게됩니다. &quot;2005-07-08&quot;이이 캠프에 속하므로 UTC로 구문 분석됩니다. &quot;2005 년 7 월 8 일&quot;은 현지 시간으로 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1cccf6baf164d26a736174ff77efdcce4e566d7" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;light weight date parsing library&lt;/a&gt; should solve all similar problems. I like the library because it is quite easy to extend. It's also possible to i18n it (not very straight forward, but not that hard).</source>
          <target state="translated">이 &lt;a href=&quot;https://code.google.com/p/flexible-js-formatting/&quot;&gt;간단한 날짜 구문 분석 라이브러리&lt;/a&gt; 는 모든 유사한 문제를 해결해야합니다. 확장하기가 쉽기 때문에 라이브러리가 마음에 듭니다. i18n으로 할 수도 있습니다 (매우 간단하지는 않지만 그렇게 어렵지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="ccdae7f2697cfbeb00896696c226905929a42c47" translate="yes" xml:space="preserve">
          <source>This difference has been fixed as of 2020, but other quirks exist between browsers when parsing ISO 8601 format strings.</source>
          <target state="translated">이 차이는 2020 년부터 수정되었지만 ISO 8601 형식 문자열을 구문 분석 할 때 브라우저간에 다른 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="29826c41ae1f24abb8f555f34335d1a7f547f781" translate="yes" xml:space="preserve">
          <source>This does:</source>
          <target state="translated">이것은 :</target>
        </trans-unit>
        <trans-unit id="d8aa042eeddd4ec553d436c607f47196ee9a2c60" translate="yes" xml:space="preserve">
          <source>This doesn't produce equivalent results:</source>
          <target state="translated">이것은 동등한 결과를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a34d3bdcbaac98280e75f02293f3f94dbdf16507" translate="yes" xml:space="preserve">
          <source>This method is useful for date formatted in an unussual way.</source>
          <target state="translated">이 방법은 날짜가 비정상적인 방식으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2aff6e8126e34aa3caca466a07d2eaa3e4366184" translate="yes" xml:space="preserve">
          <source>This works across browsers (after IE9):</source>
          <target state="translated">이것은 IE9 이후의 브라우저에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="70abab8d661bb8c79da568d773e006d09a13d4c7" translate="yes" xml:space="preserve">
          <source>Thu Jul 07 2005 17:00:00 GMT-0700 (PST)</source>
          <target state="translated">2005 년 7 월 7 일 목요일 17:00:00 GMT-0700 (PST)</target>
        </trans-unit>
        <trans-unit id="8484dedd2f01dd09a976d7895bfd07f3c5317194" translate="yes" xml:space="preserve">
          <source>Until the 5th edition spec came out, the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse&lt;/code&gt;&lt;/a&gt; method was completely &lt;em&gt;implementation dependent&lt;/em&gt; (&lt;code&gt;new Date(string)&lt;/code&gt; is equivalent to &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt;&lt;code&gt;Date.parse(string)&lt;/code&gt;&lt;/a&gt; except the latter returns a number rather than a &lt;code&gt;Date&lt;/code&gt;). In the 5th edition spec the requirement was added to support a &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;simplified &lt;em&gt;(and slightly incorrect)&lt;/em&gt; ISO-8601&lt;/a&gt; (also see &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;What are valid Date Time Strings in JavaScript?&lt;/a&gt;). But other than that, there was &lt;em&gt;no&lt;/em&gt; requirement for what &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; should accept other than that they had to accept whatever &lt;em&gt;Date#toString&lt;/em&gt; output (without saying what that was).</source>
          <target state="translated">5 판이 나올 때까지 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;em&gt;구현에 따라&lt;/em&gt; 완전히 &lt;em&gt;다릅니다&lt;/em&gt; ( &lt;code&gt;new Date(string)&lt;/code&gt; 은 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-15.9.4.2&quot;&gt; &lt;code&gt;Date.parse(string)&lt;/code&gt; &lt;/a&gt; 동일하지만 후자는 &lt;code&gt;Date&lt;/code&gt; 가 아닌 숫자를 반환합니다). 5 판 개정판에서는 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15&quot;&gt;단순화 된 &lt;em&gt;(약간 틀린)&lt;/em&gt; ISO-8601&lt;/a&gt; 을 지원하기 위해 요구 사항이 추가되었습니다 ( &lt;a href=&quot;https://stackoverflow.com/questions/51715259/what-are-valid-date-time-strings-in-javascript/&quot;&gt;JavaScript에서 유효한 날짜 시간 문자열이란 무엇입니까? 참조&lt;/a&gt; ). 그러나 그 외에는 &lt;code&gt;Date.parse&lt;/code&gt; / &lt;code&gt;new Date(string)&lt;/code&gt; 가 &lt;em&gt;Date # toString&lt;/em&gt; 출력 (무엇을 말하지 않고 ) 을 수락 해야하는 것 외에는 어떤 것을 수락 해야하는지에 &lt;em&gt;대한&lt;/em&gt; 요구 사항이 &lt;em&gt;없었&lt;/em&gt; 습니다.</target>
        </trans-unit>
        <trans-unit id="2d5bd9fd9174b8eb5a741f9403f6e3110d996178" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; to parse dates:</source>
          <target state="translated">&lt;a href=&quot;https://momentjs.com/docs/#/parsing/string-format/&quot;&gt;moment.js&lt;/a&gt; 를 사용하여 날짜를 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="f756909dd61f67dbd0fa45f2954bffc95d38db8c" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS is correct&lt;/a&gt; that passing strings into the parse method is generally unsafe, the new &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; (aka ES5) specification in section 15.9.4.2 suggests that &lt;code&gt;Date.parse()&lt;/code&gt; actually should handle ISO-formatted dates.  The old specification made no such claim.  Of course, old browsers and some current browsers still do not provide this ES5 functionality.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/2587398&quot;&gt;CMS가&lt;/a&gt; 문자열을 구문 분석 방법으로 전달하는 것이 일반적으로 안전하지 않은 것은 맞지만 15.9.4.2 섹션의 새로운 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf&quot;&gt;ECMA-262 5th Edition&lt;/a&gt; (일명 ES5) 사양에서는 &lt;code&gt;Date.parse()&lt;/code&gt; 실제로 ISO 형식의 날짜를 처리해야한다고 제안합니다. 구 사양은 그런 주장을하지 않았다. 물론 이전 브라우저와 일부 최신 브라우저는 여전히이 ES5 기능을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="000e986495e06d3e141bf3d31e41d73051e8f358" translate="yes" xml:space="preserve">
          <source>While there is some variance in the input string formats that the major browsers will parse as dates, they essentially interpret them the same as far as time zones and daylight saving is concerned even though parsing is largely implementation dependent.</source>
          <target state="translated">주요 브라우저가 날짜로 구문 분석하는 입력 문자열 형식에는 약간의 차이가 있지만, 구문 분석이 구현에 크게 의존하더라도 시간대와 일광 절약에 관한 한 기본적으로 동일하게 해석합니다.</target>
        </trans-unit>
        <trans-unit id="26a2662fc63bb5e525fe443f8b51a5c405da8642" translate="yes" xml:space="preserve">
          <source>Why does Date.parse give incorrect results</source>
          <target state="translated">Date.parse가 왜 잘못된 결과를 제공합니까?</target>
        </trans-unit>
        <trans-unit id="53bb717b5c32b6955911e011f267562b9a75046e" translate="yes" xml:space="preserve">
          <source>Why is the second parse incorrect?</source>
          <target state="translated">두 번째 구문 분석이 왜 올바르지 않습니까?</target>
        </trans-unit>
        <trans-unit id="a4cce5e2b9dc56c7bfb388bfaf8034052d1ef9f3" translate="yes" xml:space="preserve">
          <source>Your browser should provide the same timestamp result as &lt;code&gt;Date.parse&lt;/code&gt; with:</source>
          <target state="translated">브라우저는 다음과 함께 &lt;code&gt;Date.parse&lt;/code&gt; 와 동일한 타임 스탬프 결과를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9881a40adae03bee4aa623d90b2f10362dccc465" translate="yes" xml:space="preserve">
          <source>Your second example isn't wrong.  It is the specified date in UTC, as implied by &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt;, but is represented in your local timezone.</source>
          <target state="translated">두 번째 예는 틀리지 않습니다. &lt;code&gt;Date.prototype.toISOString()&lt;/code&gt; 의해 암시 된대로 UTC로 지정된 날짜이지만 현지 시간대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="92d7171de3872ec4508067fb2af0dded0ac2d69e" translate="yes" xml:space="preserve">
          <source>ddd MMM DD YYYY HH:mm:ss ZZ [(timezone name)]</source>
          <target state="translated">ddd MMM DD YYYY HH : mm : ss ZZ [(시간대 이름)]</target>
        </trans-unit>
        <trans-unit id="8c6d4efc15654f3eef450f8d913fa875df8b52fb" translate="yes" xml:space="preserve">
          <source>ddd, DD MMM YYYY HH:mm:ss Z</source>
          <target state="translated">ddd, DD MMM YYYY HH : mm : ss Z</target>
        </trans-unit>
        <trans-unit id="5c8513ccc6fc79d319c1df7112d15fb2fb915dc7" translate="yes" xml:space="preserve">
          <source>e.g. Tue 10 Jul 2018 13:09:58 GMT</source>
          <target state="translated">예 : 화요일 10 Jul 2018 13:09:58 GMT</target>
        </trans-unit>
        <trans-unit id="23434f99a2b3c6f550f6e0a6d9e1ba839b3e8a16" translate="yes" xml:space="preserve">
          <source>e.g. Tue Jul 10 2018 18:39:58 GMT+0530 (IST)</source>
          <target state="translated">예 : 2018 년 7 월 10 일 화요일 18:39:58 GMT + 0530 (IST)</target>
        </trans-unit>
        <trans-unit id="d1ddeacf52011ebb962433f44ce9822043ddbfb9" translate="yes" xml:space="preserve">
          <source>has default day and time</source>
          <target state="translated">기본 날짜와 시간이 있습니다</target>
        </trans-unit>
        <trans-unit id="e5a84d89b903471848654d119508be450a6f5c9d" translate="yes" xml:space="preserve">
          <source>parse slashes, dashes, colons and spaces</source>
          <target state="translated">슬래시, 대시, 콜론 및 공백 구문 분석</target>
        </trans-unit>
        <trans-unit id="f39e41649d7d19e35e8c2fef343daa4bffd355a2" translate="yes" xml:space="preserve">
          <source>providing 2 more formats that &lt;em&gt;Date.parse&lt;/em&gt; should parse reliably in new implementations (noting that support is not ubiquitous and non&amp;ndash;compliant implementations will remain in use for some time).</source>
          <target state="translated">&lt;em&gt;Date.parse&lt;/em&gt; 가 새로운 구현에서 안정적으로 구문 분석해야하는 2 가지 형식을 추가로 제공합니다 (지원이 어디에서나 사용되지 않으며 비준수 구현은 얼마 동안 계속 사용됨).</target>
        </trans-unit>
        <trans-unit id="9be737ab099b587933e866d3ba0b2b0808b2a779" translate="yes" xml:space="preserve">
          <source>trim and clean input spaces</source>
          <target state="translated">입력 공간 정리 및 청소</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
