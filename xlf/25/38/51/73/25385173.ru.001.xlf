<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/25385173">
    <body>
      <group id="25385173">
        <trans-unit id="5f69ef7078b27c4474ee99ff65f422379bf72b90" translate="yes" xml:space="preserve">
          <source>A debugger is a program that can examine the state of your program while your program is running. The &lt;a href=&quot;https://stackoverflow.com/questions/216819/how-does-a-debugger-work&quot;&gt;technical means it uses for doing this&lt;/a&gt; are not important for understanding the basics of how to use a debugger. You can use a debugger to halt the execution of your program when it reaches a particular place in your code, then examine the values of the variables in the program. You can use a debugger to run your program very slowly, one line of code at a time (called &lt;em&gt;single stepping&lt;/em&gt;), while you examine the values of its variables.</source>
          <target state="translated">Отладчик - это программа, которая может проверять состояние вашей программы во время ее работы. &lt;a href=&quot;https://stackoverflow.com/questions/216819/how-does-a-debugger-work&quot;&gt;Технические средства, которые он использует для этого&lt;/a&gt; , не важны для понимания основ использования отладчика. Вы можете использовать отладчик, чтобы остановить выполнение вашей программы, когда оно достигнет определенного места в вашем коде, а затем проверить значения переменных в программе. Вы можете использовать отладчик для очень медленного запуска вашей программы, по одной строке кода за раз (так называемый &lt;em&gt;пошаговый переход&lt;/em&gt; ), в то время как вы проверяете значения ее переменных.</target>
        </trans-unit>
        <trans-unit id="6e018c35cc220755b7a04fa0475268287db8bf4c" translate="yes" xml:space="preserve">
          <source>A debugger is a very powerful tool for helping diagnose problems with programs.  And debuggers are available for all practical programming languages. Therefore being able to use a debugger is considered a &lt;strong&gt;basic skill&lt;/strong&gt; of any professional or enthusiast programmer. And using a debugger &lt;em&gt;yourself&lt;/em&gt;  is considered &lt;strong&gt;basic work&lt;/strong&gt; you should do &lt;em&gt;yourself&lt;/em&gt; before asking others for help. As this site is for professional and enthusiast programmers, and not a helpdesk or mentoring site, if you have a question about a problem with a specific program, but have not used a debugger, your question is very likely to be closed and downvoted. If you persist with questions like that, you will eventually be blocked from posting more.</source>
          <target state="translated">Отладчик - очень мощный инструмент для диагностики проблем с программами. И отладчики доступны для всех практических языков программирования. Поэтому возможность использования отладчика считается &lt;strong&gt;базовым навыком&lt;/strong&gt; любого профессионального программиста или программиста-энтузиаста. А использование &lt;em&gt;самого&lt;/em&gt; отладчика считается &lt;strong&gt;основной работой, которую&lt;/strong&gt; вы должны выполнить &lt;em&gt;самостоятельно,&lt;/em&gt; прежде чем просить других о помощи. Так как этот сайт предназначен для профессиональных программистов и энтузиастов, а не для сайта службы поддержки или наставничества, если у вас есть вопрос о проблеме с конкретной программой, но вы не использовали отладчик, ваш вопрос, скорее всего, будет закрыт и отклонен. Если вы продолжите задавать подобные вопросы, вам в конечном итоге будет отказано в публикации новых сообщений.</target>
        </trans-unit>
        <trans-unit id="b35f6135c776dab42b1e067f67a94a571242079c" translate="yes" xml:space="preserve">
          <source>Assertions can be used to trap incorrect values as they occur, rather than once they have a visible effect to the end user. The quicker you catch an incorrect value, the closer you are to the line that produced it.</source>
          <target state="translated">Утверждения могут быть использованы,чтобы поймать в ловушку неверные значения по мере их появления,а не после того,как они окажут видимый эффект на конечного пользователя.Чем быстрее вы поймаете некорректное значение,тем ближе вы находитесь к строке,которая его создала.</target>
        </trans-unit>
        <trans-unit id="476f3ccc8db71ae5789e361542fbed5211ce7306" translate="yes" xml:space="preserve">
          <source>By using a debugger  you can discover whether a variable has the wrong value, and where in your program its value changed to the wrong value.</source>
          <target state="translated">С помощью отладчика вы можете определить,имеет ли переменная неверное значение и где в вашей программе его значение изменилось на неверное.</target>
        </trans-unit>
        <trans-unit id="d9a81caeb68a068dc7c4d3981dcf5e3f68ad634a" translate="yes" xml:space="preserve">
          <source>Example markdown: &lt;code&gt;[What is a debugger and how can it help me diagnose problems?](https://stackoverflow.com/q/25385173)&lt;/code&gt;</source>
          <target state="translated">Пример уценки: &lt;code&gt;[What is a debugger and how can it help me diagnose problems?](https://stackoverflow.com/q/25385173)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dac53d9920a5cefff69f5b44bd3dd26c07e0d837" translate="yes" xml:space="preserve">
          <source>General notes on using a debugger</source>
          <target state="translated">Общие примечания по использованию отладчика</target>
        </trans-unit>
        <trans-unit id="35d81ad9a2d1d250a49b8763e25f523915145fda" translate="yes" xml:space="preserve">
          <source>How a debugger can help you</source>
          <target state="translated">Как отладчик может помочь вам</target>
        </trans-unit>
        <trans-unit id="e65758af1bcb0f30c4a0a43a8bbb8fd2e5f5fc23" translate="yes" xml:space="preserve">
          <source>I want to add that a debugger isn't always the perfect solution, and shouldn't always be the go-to solution to debugging. Here are a few cases where a debugger might not work for you:</source>
          <target state="translated">Хочу добавить,что отладчик не всегда является идеальным решением,и не всегда должен быть отладочным решением.Вот несколько случаев,когда отладчик может не работать на вас:</target>
        </trans-unit>
        <trans-unit id="ee4ad88e14d5c3ab22281f68119e6b85800f009c" translate="yes" xml:space="preserve">
          <source>In all of these cases, either having your program stop abruptly could cause the end results to differ, or stepping through manually in search of the one line where the bug is caused is too much of a hassle. This can equally happen whether your bug is incorrect behavior, or a crash. For instance, if memory corruption causes a crash, by the time the crash happens, it's too far from where the memory corruption first occurred, and no useful information is left.</source>
          <target state="translated">Во всех этих случаях,либо резкая остановка вашей программы может привести к тому,что конечные результаты будут отличаться,либо ручной переход в поисках одной строки,в которой вызвана ошибка,-это слишком большая проблема.Это в равной степени может произойти и в случае некорректного поведения,и в случае аварийного завершения работы программы.Например,если повреждение памяти приводит к аварийному завершению работы,то к моменту аварийного завершения работы это происходит слишком далеко от того места,где повреждение памяти произошло впервые,и никакой полезной информации не остается.</target>
        </trans-unit>
        <trans-unit id="a338c62ab23f15aaec89a72d247ffbe4985f1d02" translate="yes" xml:space="preserve">
          <source>In case of memory leaks or memory stomping, use appropriate tools which are able to analyze and detect these at runtime. Being able to detect where the actual corruption occurs is the first step. After this, you can use logs to work your way back to where incorrect values were introduced.</source>
          <target state="translated">В случае утечки памяти или топотовки памяти используйте соответствующие инструменты,которые способны анализировать и обнаруживать их во время выполнения.Способность определить,где действительно происходит повреждение,является первым шагом.После этого,вы можете использовать журналы для работы обратно к тому месту,где были введены некорректные значения.</target>
        </trans-unit>
        <trans-unit id="32b83cd5b35e63e0288dc2dda08e7f1561b7457b" translate="yes" xml:space="preserve">
          <source>In practice it is often easier to  run your program under the control of a debugger from the very start.</source>
          <target state="translated">На практике часто проще запускать программу под управлением отладчика с самого начала.</target>
        </trans-unit>
        <trans-unit id="2fa82613d6dc16314e47d0ef35347e6c187f5e0a" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;https://stackoverflow.com/a/426586/545127&quot;&gt;modern debuggers are part of an IDE&lt;/a&gt; and provide you with a convenient GUI for examining the source code and variables of your program, with a point-and-click interface for setting breakpoints, running your program and single stepping it.</source>
          <target state="translated">Большинство &lt;a href=&quot;https://stackoverflow.com/a/426586/545127&quot;&gt;современных отладчиков являются частью IDE&lt;/a&gt; и предоставляют вам удобный графический интерфейс для изучения исходного кода и переменных вашей программы, а также интерфейс &amp;laquo;укажи и щелкни&amp;raquo; для установки точек останова, запуска программы и пошагового ее выполнения.</target>
        </trans-unit>
        <trans-unit id="c272bc7b5d1faf3b5ac046f446162bfc7579d7ca" translate="yes" xml:space="preserve">
          <source>Refactor and unit test. If your program is too big, it might be worthwhile to test it one class or one function at a time. Give it inputs, and look at the outputs, and see which are not as you're expecting. Being able to narrow down a bug from an entire program to a single function can make a huge difference in debugging time.</source>
          <target state="translated">Рефракторные и единичные испытания.Если Ваша программа слишком большая,возможно,имеет смысл тестировать ее по одному классу или по одной функции за раз.Дайте ей входы,посмотрите на выходы и посмотрите,какие из них не такие,как вы ожидаете.Способность сузить ошибку от целой программы до одной функции может сильно повлиять на время отладки.</target>
        </trans-unit>
        <trans-unit id="cfea533fc55110066831cc9a113752f303aa158f" translate="yes" xml:space="preserve">
          <source>Remember that debugging is a process going backwards. You have the end result - a bug - and find the cause, which preceded it. It's about working your way backwards and, unfortunately, debuggers only step forwards. This is where good logging and postmortem analysis can give you much better results.</source>
          <target state="translated">Помните,что отладка-это процесс,идущий в обратном направлении.У вас есть конечный результат-ошибка-и найдите причину,которая предшествовала ей.Речь идет о том,чтобы работать в обратном направлении и,к сожалению,отладчики только шагают вперёд.Именно здесь хороший логгинг и посмертный анализ могут дать гораздо лучшие результаты.</target>
        </trans-unit>
        <trans-unit id="68a3d0db4761dfac59bdfef0acdc7d355621a5cd" translate="yes" xml:space="preserve">
          <source>Simplest is simply logging and assertions. Add logs to your program at various points, and compare what you get with what you're expecting. For instance, see if the function where you think there's a bug is even called in the first place. See if the variables at a start of a method are what you think they are. Unlike breakpoints, it's okay for there to be many log lines in which nothing special happens. You can simply search through the log afterwards. Once you hit a log line that's different from what you're expecting, add more in the same area. Narrow it down farther and farther, until it's small enough to be able to log every line in the bugged area.</source>
          <target state="translated">Самое простое-это просто протоколирование и утверждения.Добавьте журналы в свою программу в различных точках,и сравните то,что вы получите с тем,что вы ожидаете.Например,посмотрите,вызывается ли вообще функция,в которой,по вашему мнению,есть ошибка.Проверьте,не являются ли переменные в начале метода тем,что вы думаете.В отличие от точек останова,нормально,что в логах много строк,в которых ничего особенного не происходит.После этого вы можете просто искать в лог-журнале.Как только вы попали в строку журнала,которая отличается от той,что вы ожидаете,добавьте больше в той же области.Сужьте его все дальше и дальше,пока он не станет достаточно маленьким,чтобы иметь возможность просматривать каждую строку в прослушанной области.</target>
        </trans-unit>
        <trans-unit id="11af1f5e4a737d4646ee0deef9b7797bdb5baf23" translate="yes" xml:space="preserve">
          <source>So, what are the alternatives?</source>
          <target state="translated">Итак,какие есть альтернативы?</target>
        </trans-unit>
        <trans-unit id="8db71d409c1383bc4dea16cad514b565f96d3c83" translate="yes" xml:space="preserve">
          <source>The code that has the bug in it runs many times before it bugs out. This can be particularly problematic in main loops, or worse yet, in physics engines, where the problem could be numerical. Even setting a breakpoint, in this case, would simply have you hitting it many times, with the bug not appearing.</source>
          <target state="translated">Код,в котором есть ошибка,запускается много раз,прежде чем он выйдет из строя.Это может быть особенно проблематично в основном цикле или,что еще хуже,в физическом движке,где проблема может быть числовой.Даже установка точки останова,в данном случае,просто приведет к тому,что вы будете нажимать на неё много раз,при этом ошибка не появится.</target>
        </trans-unit>
        <trans-unit id="11e64b63167eaba5daad013db47bfe5af9956dc0" translate="yes" xml:space="preserve">
          <source>The part of your program which fails is really large (poor modularization, perhaps?) and you're not exactly sure where to start stepping through the code. Stepping through all of it might be too time consuming.</source>
          <target state="translated">Часть вашей программы,которая терпит неудачу,действительно большая (возможно,плохая модуляризация?),и вы не совсем уверены,с чего начать перебирать код.Прохождение через все это может занять слишком много времени.</target>
        </trans-unit>
        <trans-unit id="0fe06a3d38eb67781158d1b6de356c30215cb125" translate="yes" xml:space="preserve">
          <source>The specifics of using a debugger depend on the debugger and, to a lesser degree, the programming language you are using.</source>
          <target state="translated">Специфика использования отладчика зависит от отладчика и,в меньшей степени,от используемого языка программирования.</target>
        </trans-unit>
        <trans-unit id="f5ad5b8430e85c61bfe851f89842b9b5e6fd30da" translate="yes" xml:space="preserve">
          <source>This is intended to be a general purpose question to assist new programmers who have a problem with a program, but do not know how to use a debugger to diagnose the cause of the problem.</source>
          <target state="translated">Это вопрос общего назначения,чтобы помочь новым программистам,которые имеют проблемы с программой,но не знают,как использовать отладчик для диагностики причины проблемы.</target>
        </trans-unit>
        <trans-unit id="317a81e5612bede9ef0ebf356b49a815d401cb81" translate="yes" xml:space="preserve">
          <source>This question covers three classes of more specific question:</source>
          <target state="translated">Этот вопрос охватывает три класса более конкретных вопросов:</target>
        </trans-unit>
        <trans-unit id="d402cbbb81d8dd60aa13040027a9a9b28f4267dd" translate="yes" xml:space="preserve">
          <source>Using a debugger can be very difficult unless your program executable or bytecode files  include debugging &lt;em&gt;symbol information&lt;/em&gt; and cross references to your source-code. You might have to &lt;a href=&quot;https://stackoverflow.com/questions/89603/how-does-the-debugging-option-g-change-the-binary-executable&quot;&gt;compile (or recompile) your program slightly differently&lt;/a&gt; to ensure that information is present. If the compiler performs extensive optimizations, those cross references can become confusing. You might therefore have to &lt;a href=&quot;https://stackoverflow.com/a/7857696/545127&quot;&gt;recompile your program with optimizations turned off&lt;/a&gt;.</source>
          <target state="translated">Использование отладчика может быть очень трудным, если исполняемый файл вашей программы или файлы байт-кода не содержат &lt;em&gt;информацию об&lt;/em&gt; отладочных &lt;em&gt;символах&lt;/em&gt; и перекрестные ссылки на ваш исходный код. Возможно, вам придется &lt;a href=&quot;https://stackoverflow.com/questions/89603/how-does-the-debugging-option-g-change-the-binary-executable&quot;&gt;скомпилировать (или перекомпилировать) вашу программу немного по-другому,&lt;/a&gt; чтобы обеспечить наличие информации. Если компилятор выполняет обширные оптимизации, эти перекрестные ссылки могут привести к путанице. Поэтому вам, возможно, придется &lt;a href=&quot;https://stackoverflow.com/a/7857696/545127&quot;&gt;перекомпилировать вашу программу с отключенными оптимизациями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cf49b12a749436a9ef554222db7bab809eb274" translate="yes" xml:space="preserve">
          <source>Using a debugger is an expected basic skill</source>
          <target state="translated">Использование отладчика является ожидаемым базовым навыком.</target>
        </trans-unit>
        <trans-unit id="3e279e4ed2ae68ef124cd2d91bc59889848b5935" translate="yes" xml:space="preserve">
          <source>Using single stepping you can also discover whether the control flow is as you expect. For example, whether an &lt;code&gt;if&lt;/code&gt; branch executed when you expect it ought to be.</source>
          <target state="translated">Используя один шаг, вы также можете определить, соответствует ли поток управления ожиданиям. Например, должна &lt;code&gt;if&lt;/code&gt; выполняться ветвь if, когда вы ожидаете, что она должна быть.</target>
        </trans-unit>
        <trans-unit id="01283b82b512012e10c02769d68c8090ddc60c84" translate="yes" xml:space="preserve">
          <source>What is a debugger and how can it help me diagnose problems</source>
          <target state="translated">Что такое отладчик и как он может помочь мне диагностировать проблемы.</target>
        </trans-unit>
        <trans-unit id="bb0345f67d917d6883f66311548fb70b5de97da9" translate="yes" xml:space="preserve">
          <source>When I run my program, it crashes and gives me a stack trace. I have &lt;a href=&quot;https://stackoverflow.com/questions/3988788/what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors&quot;&gt;examined the stack trace&lt;/a&gt;, but I still do not know the cause of the problem because the stack trace does not provide me with enough information.</source>
          <target state="translated">Когда я запускаю свою программу, она падает и дает мне трассировку стека. Я &lt;a href=&quot;https://stackoverflow.com/questions/3988788/what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors&quot;&gt;изучил трассировку стека&lt;/a&gt; , но до сих пор не знаю причину проблемы, потому что трассировка стека не дает мне достаточно информации.</target>
        </trans-unit>
        <trans-unit id="21d75a40a11cab8c9bd1000513184a5edb68b004" translate="yes" xml:space="preserve">
          <source>When I run my program, it crashes because of a segmentation fault (SEGV).</source>
          <target state="translated">Когда я запускаю свою программу,она ломается из-за ошибки сегментации (SEGV).</target>
        </trans-unit>
        <trans-unit id="362b817e599fe88871572e82a0a7459085492df9" translate="yes" xml:space="preserve">
          <source>When I run my program, it does not produce the output I expect for the input I gave it.</source>
          <target state="translated">Когда я запускаю свою программу,она не производит того вывода,который я ожидаю для входа,который я ей дал.</target>
        </trans-unit>
        <trans-unit id="bba0c0b6c3d8bfbe7dacab2b87da00e4bc4a5f02" translate="yes" xml:space="preserve">
          <source>You can &lt;em&gt;attach&lt;/em&gt; a debugger to a process already running your program. You  might do if your program is stuck.</source>
          <target state="translated">Вы можете &lt;em&gt;прикрепить&lt;/em&gt; отладчик к процессу, уже выполняющему вашу программу. Вы можете сделать, если ваша программа застряла.</target>
        </trans-unit>
        <trans-unit id="3a05e0a9c5c99e4bb417913c643133e002238ba1" translate="yes" xml:space="preserve">
          <source>You can tell that your bug is caused by incorrect values arriving at function X, but you don't know where these values come from. Having to run through the program, again and again, setting breakpoints farther and farther back, can be a huge hassle. Especially if function X is called from many places throughout the program.</source>
          <target state="translated">Вы можете сказать,что ваша ошибка вызвана неправильными значениями,поступающими в функцию X,но вы не знаете,откуда эти значения.Приходиться снова и снова запускать программу,устанавливая точки останова всё дальше и дальше назад,может быть огромной проблемой.Особенно,если функция X вызывается из многих мест в программе.</target>
        </trans-unit>
        <trans-unit id="fba390354c53382829fca30a0664e9c72d72f969" translate="yes" xml:space="preserve">
          <source>You indicate &lt;em&gt;where&lt;/em&gt; your program should stop executing by indicating the source-code file and line number of the line at which execution should stop, or by indicating the name of the method/function at which the program should stop (if you want to stop as soon as execution enters the method). The technical means that the debugger uses to cause your program to stop is called a &lt;em&gt;breakpoint&lt;/em&gt; and this process is called &lt;em&gt;setting a breakpoint&lt;/em&gt;.</source>
          <target state="translated">Вы указываете, &lt;em&gt;где&lt;/em&gt; ваша программа должна прекратить выполнение, указав файл исходного кода и номер строки, на которой должно быть остановлено выполнение, или указав имя метода / функции, на котором программа должна остановиться (если вы хотите остановить как как только исполнение входит в метод). Технические средства, используемые отладчиком для остановки вашей программы, называются &lt;em&gt;точкой останова,&lt;/em&gt; а этот процесс называется &lt;em&gt;установкой точки останова&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36a877db5fba4c1c71b6a6dc4aee4eaf879d1f64" translate="yes" xml:space="preserve">
          <source>Your program is multi-threaded. Or even worse, your problem is caused by a race condition.</source>
          <target state="translated">Ваша программа многопоточная.Или,что еще хуже,ваша проблема вызвана гоночным состоянием.</target>
        </trans-unit>
        <trans-unit id="ef19f674fef2005af2ff2b50f2cab28caf87470e" translate="yes" xml:space="preserve">
          <source>Your program must run in real time. This is a big issue for programs that connect to the network. If you set up a breakpoint in your network code, the other end isn't going to wait for you to step through, it's simply going to time out. Programs which rely on the system clock, e.g. games with frame skip, aren't much better off either.</source>
          <target state="translated">Ваша программа должна работать в режиме реального времени.Это большая проблема для программ,которые подключаются к сети.Если вы установите точку останова в коде вашей сети,то другой конец не будет ждать,пока вы сделаете шаг вперед,а просто перейдет по таймауту.Программы,которые полагаются на системные часы,например,игры с пропуском кадров,тоже не намного лучше.</target>
        </trans-unit>
        <trans-unit id="00fa062298e582b7d61242405c699fc9a9bf07dd" translate="yes" xml:space="preserve">
          <source>Your program performs some form of destructive actions, like writing to files or sending e-mails, and you'd like to limit the number of times you need to run through it.</source>
          <target state="translated">Ваша программа выполняет какие-то деструктивные действия,например,записывает в файлы или отправляет электронную почту,и вы хотели бы ограничить количество раз,которое вам нужно прогнать через нее.</target>
        </trans-unit>
        <trans-unit id="eaadc1ee03032694703d617ad9e3871bdbd49308" translate="yes" xml:space="preserve">
          <source>Your program uses a lot of callbacks and other non-linear flow control methods, which makes the debugger confused when you step through it.</source>
          <target state="translated">Ваша программа использует множество обратных вызовов и других нелинейных методов управления потоком,что приводит отладчика в замешательство,когда вы проходите через нее.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
