<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/25385173">
    <body>
      <group id="25385173">
        <trans-unit id="5f69ef7078b27c4474ee99ff65f422379bf72b90" translate="yes" xml:space="preserve">
          <source>A debugger is a program that can examine the state of your program while your program is running. The &lt;a href=&quot;https://stackoverflow.com/questions/216819/how-does-a-debugger-work&quot;&gt;technical means it uses for doing this&lt;/a&gt; are not important for understanding the basics of how to use a debugger. You can use a debugger to halt the execution of your program when it reaches a particular place in your code, then examine the values of the variables in the program. You can use a debugger to run your program very slowly, one line of code at a time (called &lt;em&gt;single stepping&lt;/em&gt;), while you examine the values of its variables.</source>
          <target state="translated">调试器是可以在程序运行时检查程序状态的程序。 &lt;a href=&quot;https://stackoverflow.com/questions/216819/how-does-a-debugger-work&quot;&gt;它用于执行此操作&lt;/a&gt;的技术手段对于理解如何使用调试器的基础并不重要。 您可以使用调试器在程序到达代码中的特定位置时暂停程序的执行，然后检查程序中变量的值。 在检查其变量的值时，可以使用调试器非常缓慢地运行程序，一次运行一行代码（称为&lt;em&gt;单步执行&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6e018c35cc220755b7a04fa0475268287db8bf4c" translate="yes" xml:space="preserve">
          <source>A debugger is a very powerful tool for helping diagnose problems with programs.  And debuggers are available for all practical programming languages. Therefore being able to use a debugger is considered a &lt;strong&gt;basic skill&lt;/strong&gt; of any professional or enthusiast programmer. And using a debugger &lt;em&gt;yourself&lt;/em&gt;  is considered &lt;strong&gt;basic work&lt;/strong&gt; you should do &lt;em&gt;yourself&lt;/em&gt; before asking others for help. As this site is for professional and enthusiast programmers, and not a helpdesk or mentoring site, if you have a question about a problem with a specific program, but have not used a debugger, your question is very likely to be closed and downvoted. If you persist with questions like that, you will eventually be blocked from posting more.</source>
          <target state="translated">调试器是一种非常强大的工具，可帮助诊断程序问题。 调试器可用于所有实用的编程语言。 因此，能够使用调试器被认为是任何专业或发烧级程序员的&lt;strong&gt;基本技能&lt;/strong&gt; 。 &lt;em&gt;自己&lt;/em&gt;使用调试器被认为是&lt;strong&gt;基础工作，&lt;/strong&gt;您应先寻求他人的帮助。 由于此站点是针对专业和发烧级程序员的站点，而不是帮助台或指导站点，因此，如果您对特定程序的问题有疑问，但没有使用调试器，那么很可能会关闭并拒绝您的问题。 如果您仍然遇到类似的问题，最终将阻止您发布更多信息。</target>
        </trans-unit>
        <trans-unit id="b35f6135c776dab42b1e067f67a94a571242079c" translate="yes" xml:space="preserve">
          <source>Assertions can be used to trap incorrect values as they occur, rather than once they have a visible effect to the end user. The quicker you catch an incorrect value, the closer you are to the line that produced it.</source>
          <target state="translated">断言可以在错误值发生时被用来捕捉错误值,而不是一旦错误值对最终用户产生了明显的影响。捕捉错误值的速度越快,你就越接近产生错误值的那条线。</target>
        </trans-unit>
        <trans-unit id="476f3ccc8db71ae5789e361542fbed5211ce7306" translate="yes" xml:space="preserve">
          <source>By using a debugger  you can discover whether a variable has the wrong value, and where in your program its value changed to the wrong value.</source>
          <target state="translated">通过使用调试器,你可以发现一个变量是否有错误的值,以及它的值在你的程序中的哪个地方改变为错误的值。</target>
        </trans-unit>
        <trans-unit id="d9a81caeb68a068dc7c4d3981dcf5e3f68ad634a" translate="yes" xml:space="preserve">
          <source>Example markdown: &lt;code&gt;[What is a debugger and how can it help me diagnose problems?](https://stackoverflow.com/q/25385173)&lt;/code&gt;</source>
          <target state="translated">减价示例： &lt;code&gt;[What is a debugger and how can it help me diagnose problems?](https://stackoverflow.com/q/25385173)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dac53d9920a5cefff69f5b44bd3dd26c07e0d837" translate="yes" xml:space="preserve">
          <source>General notes on using a debugger</source>
          <target state="translated">关于使用调试器的一般注意事项</target>
        </trans-unit>
        <trans-unit id="35d81ad9a2d1d250a49b8763e25f523915145fda" translate="yes" xml:space="preserve">
          <source>How a debugger can help you</source>
          <target state="translated">调试器如何帮助你</target>
        </trans-unit>
        <trans-unit id="e65758af1bcb0f30c4a0a43a8bbb8fd2e5f5fc23" translate="yes" xml:space="preserve">
          <source>I want to add that a debugger isn't always the perfect solution, and shouldn't always be the go-to solution to debugging. Here are a few cases where a debugger might not work for you:</source>
          <target state="translated">我想补充的是,调试器并不总是完美的解决方案,也不应该永远是调试的首选解决方案。以下是一些调试器可能不适合你的情况。</target>
        </trans-unit>
        <trans-unit id="ee4ad88e14d5c3ab22281f68119e6b85800f009c" translate="yes" xml:space="preserve">
          <source>In all of these cases, either having your program stop abruptly could cause the end results to differ, or stepping through manually in search of the one line where the bug is caused is too much of a hassle. This can equally happen whether your bug is incorrect behavior, or a crash. For instance, if memory corruption causes a crash, by the time the crash happens, it's too far from where the memory corruption first occurred, and no useful information is left.</source>
          <target state="translated">在所有这些情况下,要么让你的程序突然停止,导致最终的结果不一样,要么就是手动通过手动步入寻找导致bug的那一行,太麻烦了。无论你的bug是错误的行为,还是崩溃,这种情况同样可能发生。比如说,如果内存损坏导致崩溃,当崩溃发生时,已经离内存损坏的地方太远了,没有留下任何有用的信息。</target>
        </trans-unit>
        <trans-unit id="a338c62ab23f15aaec89a72d247ffbe4985f1d02" translate="yes" xml:space="preserve">
          <source>In case of memory leaks or memory stomping, use appropriate tools which are able to analyze and detect these at runtime. Being able to detect where the actual corruption occurs is the first step. After this, you can use logs to work your way back to where incorrect values were introduced.</source>
          <target state="translated">如果发生内存泄漏或内存踩踏,请使用适当的工具,在运行时能够分析和检测到这些情况。能够检测出实际损坏的地方是第一步。在这之后,你可以使用日志来回溯到不正确的值是在哪里引入的。</target>
        </trans-unit>
        <trans-unit id="32b83cd5b35e63e0288dc2dda08e7f1561b7457b" translate="yes" xml:space="preserve">
          <source>In practice it is often easier to  run your program under the control of a debugger from the very start.</source>
          <target state="translated">在实际操作中,往往从一开始就在调试器的控制下运行程序比较容易。</target>
        </trans-unit>
        <trans-unit id="2fa82613d6dc16314e47d0ef35347e6c187f5e0a" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;https://stackoverflow.com/a/426586/545127&quot;&gt;modern debuggers are part of an IDE&lt;/a&gt; and provide you with a convenient GUI for examining the source code and variables of your program, with a point-and-click interface for setting breakpoints, running your program and single stepping it.</source>
          <target state="translated">大多数&lt;a href=&quot;https://stackoverflow.com/a/426586/545127&quot;&gt;现代调试器都是IDE的一部分，&lt;/a&gt;并为您提供了一个方便的GUI，用于检查程序的源代码和变量，并带有单击界面，用于设置断点，运行程序并单步执行。</target>
        </trans-unit>
        <trans-unit id="c272bc7b5d1faf3b5ac046f446162bfc7579d7ca" translate="yes" xml:space="preserve">
          <source>Refactor and unit test. If your program is too big, it might be worthwhile to test it one class or one function at a time. Give it inputs, and look at the outputs, and see which are not as you're expecting. Being able to narrow down a bug from an entire program to a single function can make a huge difference in debugging time.</source>
          <target state="translated">重构器和单元测试。如果你的程序太大,可能值得一次测试一个类或一个函数。给它输入,然后看看输出,看看哪些地方和你的预期不一样。能够将整个程序的bug缩小到单个函数,可以在调试时间上有很大的不同。</target>
        </trans-unit>
        <trans-unit id="cfea533fc55110066831cc9a113752f303aa158f" translate="yes" xml:space="preserve">
          <source>Remember that debugging is a process going backwards. You have the end result - a bug - and find the cause, which preceded it. It's about working your way backwards and, unfortunately, debuggers only step forwards. This is where good logging and postmortem analysis can give you much better results.</source>
          <target state="translated">请记住,调试是一个倒退的过程。你有了最终的结果--bug,然后找到原因,而原因就在它之前。它是在向后退一步,不幸的是,调试器只能向后退一步。这就是好的日志记录和事后分析可以给你带来更好的结果。</target>
        </trans-unit>
        <trans-unit id="68a3d0db4761dfac59bdfef0acdc7d355621a5cd" translate="yes" xml:space="preserve">
          <source>Simplest is simply logging and assertions. Add logs to your program at various points, and compare what you get with what you're expecting. For instance, see if the function where you think there's a bug is even called in the first place. See if the variables at a start of a method are what you think they are. Unlike breakpoints, it's okay for there to be many log lines in which nothing special happens. You can simply search through the log afterwards. Once you hit a log line that's different from what you're expecting, add more in the same area. Narrow it down farther and farther, until it's small enough to be able to log every line in the bugged area.</source>
          <target state="translated">最简单的就是简单的日志和断言。在你的程序中加入日志,在不同的点上添加日志,对比一下你得到的结果和你所期望的结果。比如说,看看你认为有bug的地方的函数是否一开始就被调用了。看看方法开始时的变量是否和你认为的一样。和断点不同,有很多日志行,没有什么特别的事情发生也没关系。你可以简单地在之后的日志中搜索一下。一旦你碰到与你所期望的不同的日志线,就在同一区域内增加更多的日志线。把它越放越远,直到它的范围缩小到足够小,能够记录到每一行都是在有问题的区域。</target>
        </trans-unit>
        <trans-unit id="11af1f5e4a737d4646ee0deef9b7797bdb5baf23" translate="yes" xml:space="preserve">
          <source>So, what are the alternatives?</source>
          <target state="translated">那么,有哪些选择呢?</target>
        </trans-unit>
        <trans-unit id="8db71d409c1383bc4dea16cad514b565f96d3c83" translate="yes" xml:space="preserve">
          <source>The code that has the bug in it runs many times before it bugs out. This can be particularly problematic in main loops, or worse yet, in physics engines, where the problem could be numerical. Even setting a breakpoint, in this case, would simply have you hitting it many times, with the bug not appearing.</source>
          <target state="translated">有这个bug的代码运行了很多次才会出问题。这在主循环中特别有问题,或者更糟糕的是,在物理引擎中,问题可能是数值问题。即使是设置一个断点,在这种情况下,也只是让你打了很多次,bug没有出现。</target>
        </trans-unit>
        <trans-unit id="11e64b63167eaba5daad013db47bfe5af9956dc0" translate="yes" xml:space="preserve">
          <source>The part of your program which fails is really large (poor modularization, perhaps?) and you're not exactly sure where to start stepping through the code. Stepping through all of it might be too time consuming.</source>
          <target state="translated">你的程序中失败的部分真的很大(可能是模块化做得不好?踏遍所有的代码可能太耗费时间了。</target>
        </trans-unit>
        <trans-unit id="0fe06a3d38eb67781158d1b6de356c30215cb125" translate="yes" xml:space="preserve">
          <source>The specifics of using a debugger depend on the debugger and, to a lesser degree, the programming language you are using.</source>
          <target state="translated">使用调试器的具体内容取决于调试器,其次是你所使用的编程语言。</target>
        </trans-unit>
        <trans-unit id="f5ad5b8430e85c61bfe851f89842b9b5e6fd30da" translate="yes" xml:space="preserve">
          <source>This is intended to be a general purpose question to assist new programmers who have a problem with a program, but do not know how to use a debugger to diagnose the cause of the problem.</source>
          <target state="translated">这个问题的目的是为了帮助新手程序员在程序中遇到问题,但不知道如何使用调试器来诊断问题的原因,所以想通过这个问题来帮助新手程序员。</target>
        </trans-unit>
        <trans-unit id="317a81e5612bede9ef0ebf356b49a815d401cb81" translate="yes" xml:space="preserve">
          <source>This question covers three classes of more specific question:</source>
          <target state="translated">本题涉及三类比较具体的问题。</target>
        </trans-unit>
        <trans-unit id="d402cbbb81d8dd60aa13040027a9a9b28f4267dd" translate="yes" xml:space="preserve">
          <source>Using a debugger can be very difficult unless your program executable or bytecode files  include debugging &lt;em&gt;symbol information&lt;/em&gt; and cross references to your source-code. You might have to &lt;a href=&quot;https://stackoverflow.com/questions/89603/how-does-the-debugging-option-g-change-the-binary-executable&quot;&gt;compile (or recompile) your program slightly differently&lt;/a&gt; to ensure that information is present. If the compiler performs extensive optimizations, those cross references can become confusing. You might therefore have to &lt;a href=&quot;https://stackoverflow.com/a/7857696/545127&quot;&gt;recompile your program with optimizations turned off&lt;/a&gt;.</source>
          <target state="translated">除非程序可执行文件或字节码文件包含调试&lt;em&gt;符号信息&lt;/em&gt;和对源代码的交叉引用，否则使用调试器可能非常困难。 您可能必须&lt;a href=&quot;https://stackoverflow.com/questions/89603/how-does-the-debugging-option-g-change-the-binary-executable&quot;&gt;稍微不同&lt;/a&gt;地编译（或重新编译）程序，以确保存在信息。 如果编译器执行了广泛的优化，则这些交叉引用可能会造成混淆。 因此，您可能不得不在&lt;a href=&quot;https://stackoverflow.com/a/7857696/545127&quot;&gt;关闭优化的情况下重新编译程序&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7cf49b12a749436a9ef554222db7bab809eb274" translate="yes" xml:space="preserve">
          <source>Using a debugger is an expected basic skill</source>
          <target state="translated">使用调试器是一项基本技能。</target>
        </trans-unit>
        <trans-unit id="3e279e4ed2ae68ef124cd2d91bc59889848b5935" translate="yes" xml:space="preserve">
          <source>Using single stepping you can also discover whether the control flow is as you expect. For example, whether an &lt;code&gt;if&lt;/code&gt; branch executed when you expect it ought to be.</source>
          <target state="translated">使用单步执行，您还可以发现控制流是否符合您的期望。 例如，是否应按预期执行 &lt;code&gt;if&lt;/code&gt; 分支。</target>
        </trans-unit>
        <trans-unit id="01283b82b512012e10c02769d68c8090ddc60c84" translate="yes" xml:space="preserve">
          <source>What is a debugger and how can it help me diagnose problems</source>
          <target state="translated">什么是调试器,如何帮助我诊断问题?</target>
        </trans-unit>
        <trans-unit id="bb0345f67d917d6883f66311548fb70b5de97da9" translate="yes" xml:space="preserve">
          <source>When I run my program, it crashes and gives me a stack trace. I have &lt;a href=&quot;https://stackoverflow.com/questions/3988788/what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors&quot;&gt;examined the stack trace&lt;/a&gt;, but I still do not know the cause of the problem because the stack trace does not provide me with enough information.</source>
          <target state="translated">当我运行程序时，它崩溃并给了我堆栈跟踪。 我已经&lt;a href=&quot;https://stackoverflow.com/questions/3988788/what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors&quot;&gt;检查了堆栈跟踪&lt;/a&gt; ，但是我仍然不知道问题的原因，因为堆栈跟踪没有为我提供足够的信息。</target>
        </trans-unit>
        <trans-unit id="21d75a40a11cab8c9bd1000513184a5edb68b004" translate="yes" xml:space="preserve">
          <source>When I run my program, it crashes because of a segmentation fault (SEGV).</source>
          <target state="translated">当我运行我的程序时,它因为分段故障(SEGV)而崩溃。</target>
        </trans-unit>
        <trans-unit id="362b817e599fe88871572e82a0a7459085492df9" translate="yes" xml:space="preserve">
          <source>When I run my program, it does not produce the output I expect for the input I gave it.</source>
          <target state="translated">当我运行我的程序时,它并没有按照我给它的输入产生我期望的输出。</target>
        </trans-unit>
        <trans-unit id="bba0c0b6c3d8bfbe7dacab2b87da00e4bc4a5f02" translate="yes" xml:space="preserve">
          <source>You can &lt;em&gt;attach&lt;/em&gt; a debugger to a process already running your program. You  might do if your program is stuck.</source>
          <target state="translated">您可以&lt;em&gt;将&lt;/em&gt;调试器&lt;em&gt;附加&lt;/em&gt;到已经在运行程序的进程中。 如果程序卡住，您可能会这样做。</target>
        </trans-unit>
        <trans-unit id="3a05e0a9c5c99e4bb417913c643133e002238ba1" translate="yes" xml:space="preserve">
          <source>You can tell that your bug is caused by incorrect values arriving at function X, but you don't know where these values come from. Having to run through the program, again and again, setting breakpoints farther and farther back, can be a huge hassle. Especially if function X is called from many places throughout the program.</source>
          <target state="translated">你可以判断出你的bug是由函数X到达的值不正确引起的,但你不知道这些值是从哪里来的。必须一次又一次地运行程序,把断点设置得越来越远,这可能是一个巨大的麻烦。尤其是当函数X在整个程序中的许多地方被调用时,更是如此。</target>
        </trans-unit>
        <trans-unit id="fba390354c53382829fca30a0664e9c72d72f969" translate="yes" xml:space="preserve">
          <source>You indicate &lt;em&gt;where&lt;/em&gt; your program should stop executing by indicating the source-code file and line number of the line at which execution should stop, or by indicating the name of the method/function at which the program should stop (if you want to stop as soon as execution enters the method). The technical means that the debugger uses to cause your program to stop is called a &lt;em&gt;breakpoint&lt;/em&gt; and this process is called &lt;em&gt;setting a breakpoint&lt;/em&gt;.</source>
          <target state="translated">您可以通过指示源代码文件和应该停止执行的行的行号，或者通过指示程序应该停止执行的方法/函数的名称，来指示程序应该停止执行的位置（如果要停止为执行立即进入方法）。 调试器用来导致​​程序停止的技术手段称为&lt;em&gt;断点，&lt;/em&gt;而此过程称为&lt;em&gt;设置断点&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="36a877db5fba4c1c71b6a6dc4aee4eaf879d1f64" translate="yes" xml:space="preserve">
          <source>Your program is multi-threaded. Or even worse, your problem is caused by a race condition.</source>
          <target state="translated">你的程序是多线程的。或者更糟糕的是,你的问题是由种族状况造成的。</target>
        </trans-unit>
        <trans-unit id="ef19f674fef2005af2ff2b50f2cab28caf87470e" translate="yes" xml:space="preserve">
          <source>Your program must run in real time. This is a big issue for programs that connect to the network. If you set up a breakpoint in your network code, the other end isn't going to wait for you to step through, it's simply going to time out. Programs which rely on the system clock, e.g. games with frame skip, aren't much better off either.</source>
          <target state="translated">你的程序必须实时运行。这对于连接到网络的程序来说是个大问题。如果你在网络代码中设置了一个断点,那么另一端就不会等着你跨过,而是直接超时。那些依赖系统时钟的程序,比如说游戏中的跳帧,也没有什么好的办法。</target>
        </trans-unit>
        <trans-unit id="00fa062298e582b7d61242405c699fc9a9bf07dd" translate="yes" xml:space="preserve">
          <source>Your program performs some form of destructive actions, like writing to files or sending e-mails, and you'd like to limit the number of times you need to run through it.</source>
          <target state="translated">你的程序会执行某种形式的破坏性操作,比如写入文件或发送电子邮件,而你想限制你需要运行的次数。</target>
        </trans-unit>
        <trans-unit id="eaadc1ee03032694703d617ad9e3871bdbd49308" translate="yes" xml:space="preserve">
          <source>Your program uses a lot of callbacks and other non-linear flow control methods, which makes the debugger confused when you step through it.</source>
          <target state="translated">你的程序使用了大量的回调和其他非线性流控方法,这让你的程序在步入调试器的时候很混乱。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
