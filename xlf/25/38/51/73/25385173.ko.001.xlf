<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/25385173">
    <body>
      <group id="25385173">
        <trans-unit id="5f69ef7078b27c4474ee99ff65f422379bf72b90" translate="yes" xml:space="preserve">
          <source>A debugger is a program that can examine the state of your program while your program is running. The &lt;a href=&quot;https://stackoverflow.com/questions/216819/how-does-a-debugger-work&quot;&gt;technical means it uses for doing this&lt;/a&gt; are not important for understanding the basics of how to use a debugger. You can use a debugger to halt the execution of your program when it reaches a particular place in your code, then examine the values of the variables in the program. You can use a debugger to run your program very slowly, one line of code at a time (called &lt;em&gt;single stepping&lt;/em&gt;), while you examine the values of its variables.</source>
          <target state="translated">디버거는 프로그램이 실행되는 동안 프로그램의 상태를 검사 할 수있는 프로그램입니다. 디버거 사용 방법의 기본 사항을 이해하는 데 사용하는 &lt;a href=&quot;https://stackoverflow.com/questions/216819/how-does-a-debugger-work&quot;&gt;기술적 인 의미&lt;/a&gt; 는 중요하지 않습니다. 디버거를 사용하여 코드의 특정 위치에 도달하면 프로그램 실행을 중단 한 다음 프로그램의 변수 값을 검사 할 수 있습니다. 변수 값을 검사하는 동안 디버거를 사용하여 한 번에 한 줄의 코드 ( &lt;em&gt;단일 스테핑&lt;/em&gt; 이라고 함)로 프로그램을 매우 느리게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e018c35cc220755b7a04fa0475268287db8bf4c" translate="yes" xml:space="preserve">
          <source>A debugger is a very powerful tool for helping diagnose problems with programs.  And debuggers are available for all practical programming languages. Therefore being able to use a debugger is considered a &lt;strong&gt;basic skill&lt;/strong&gt; of any professional or enthusiast programmer. And using a debugger &lt;em&gt;yourself&lt;/em&gt;  is considered &lt;strong&gt;basic work&lt;/strong&gt; you should do &lt;em&gt;yourself&lt;/em&gt; before asking others for help. As this site is for professional and enthusiast programmers, and not a helpdesk or mentoring site, if you have a question about a problem with a specific program, but have not used a debugger, your question is very likely to be closed and downvoted. If you persist with questions like that, you will eventually be blocked from posting more.</source>
          <target state="translated">디버거는 프로그램 문제를 진단하는 데 유용한 강력한 도구입니다. 또한 모든 실제 프로그래밍 언어에 대해 디버거를 사용할 수 있습니다. 따라서 디버거를 사용할 수 있다는 것은 모든 전문가 또는 애호가 프로그래머의 &lt;strong&gt;기본 기술&lt;/strong&gt; 로 간주됩니다. 디버거를 &lt;em&gt;직접&lt;/em&gt; 사용하는 것은 다른 사람에게 도움을 요청하기 전에 &lt;em&gt;스스로&lt;/em&gt; 해야하는 &lt;strong&gt;기본 작업&lt;/strong&gt; 으로 간주됩니다. 이 사이트는 헬프 데스크 나 멘토링 사이트가 아닌 전문적이고 열성적인 프로그래머를위한 것이므로 특정 프로그램에 대한 문제에 대해 질문이 있지만 디버거를 사용하지 않은 경우, 귀하의 질문은 닫히고 하향 조정될 가능성이 높습니다. 그런 질문이 계속되면 결국 더 많은 글을 올리지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="b35f6135c776dab42b1e067f67a94a571242079c" translate="yes" xml:space="preserve">
          <source>Assertions can be used to trap incorrect values as they occur, rather than once they have a visible effect to the end user. The quicker you catch an incorrect value, the closer you are to the line that produced it.</source>
          <target state="translated">어설 션을 사용하면 최종 사용자에게 가시적 인 영향을주는 것이 아니라 잘못된 값이 발생할 때이를 트랩 할 수 있습니다. 잘못된 값을 빨리 찾을수록 값을 생성 한 선에 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="476f3ccc8db71ae5789e361542fbed5211ce7306" translate="yes" xml:space="preserve">
          <source>By using a debugger  you can discover whether a variable has the wrong value, and where in your program its value changed to the wrong value.</source>
          <target state="translated">디버거를 사용하면 변수에 잘못된 값이 있는지 여부와 프로그램에서 해당 값이 잘못된 값으로 변경된 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9a81caeb68a068dc7c4d3981dcf5e3f68ad634a" translate="yes" xml:space="preserve">
          <source>Example markdown: &lt;code&gt;[What is a debugger and how can it help me diagnose problems?](https://stackoverflow.com/q/25385173)&lt;/code&gt;</source>
          <target state="translated">마크 다운 예 : &lt;code&gt;[What is a debugger and how can it help me diagnose problems?](https://stackoverflow.com/q/25385173)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dac53d9920a5cefff69f5b44bd3dd26c07e0d837" translate="yes" xml:space="preserve">
          <source>General notes on using a debugger</source>
          <target state="translated">디버거 사용에 대한 일반 정보</target>
        </trans-unit>
        <trans-unit id="35d81ad9a2d1d250a49b8763e25f523915145fda" translate="yes" xml:space="preserve">
          <source>How a debugger can help you</source>
          <target state="translated">디버거가 당신을 도울 수있는 방법</target>
        </trans-unit>
        <trans-unit id="e65758af1bcb0f30c4a0a43a8bbb8fd2e5f5fc23" translate="yes" xml:space="preserve">
          <source>I want to add that a debugger isn't always the perfect solution, and shouldn't always be the go-to solution to debugging. Here are a few cases where a debugger might not work for you:</source>
          <target state="translated">디버거가 항상 완벽한 솔루션은 아니며 항상 디버깅을위한 솔루션이되어서는 안된다고 덧붙이고 싶습니다. 디버거가 작동하지 않는 몇 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee4ad88e14d5c3ab22281f68119e6b85800f009c" translate="yes" xml:space="preserve">
          <source>In all of these cases, either having your program stop abruptly could cause the end results to differ, or stepping through manually in search of the one line where the bug is caused is too much of a hassle. This can equally happen whether your bug is incorrect behavior, or a crash. For instance, if memory corruption causes a crash, by the time the crash happens, it's too far from where the memory corruption first occurred, and no useful information is left.</source>
          <target state="translated">이 모든 경우에 프로그램이 갑자기 중지되면 최종 결과가 달라 지거나 버그가 발생한 한 줄을 수동으로 검색하는 것이 너무 번거 롭습니다. 이것은 버그가 잘못 작동하거나 충돌하는 경우에도 동일하게 발생할 수 있습니다. 예를 들어, 메모리 손상으로 인해 충돌이 발생하면 충돌이 발생할 때까지 메모리 손상이 처음 발생한 위치와 너무 멀어 유용한 정보가 남지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a338c62ab23f15aaec89a72d247ffbe4985f1d02" translate="yes" xml:space="preserve">
          <source>In case of memory leaks or memory stomping, use appropriate tools which are able to analyze and detect these at runtime. Being able to detect where the actual corruption occurs is the first step. After this, you can use logs to work your way back to where incorrect values were introduced.</source>
          <target state="translated">메모리 누수 또는 메모리 스톰 핑의 경우 런타임시이를 분석하고 감지 할 수있는 적절한 도구를 사용하십시오. 실제 손상이 발생한 위치를 감지하는 것이 첫 번째 단계입니다. 그런 다음 로그를 사용하여 잘못된 값이 도입 된 위치로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32b83cd5b35e63e0288dc2dda08e7f1561b7457b" translate="yes" xml:space="preserve">
          <source>In practice it is often easier to  run your program under the control of a debugger from the very start.</source>
          <target state="translated">실제로 처음부터 디버거의 제어하에 프로그램을 실행하는 것이 더 쉬운 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="2fa82613d6dc16314e47d0ef35347e6c187f5e0a" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;https://stackoverflow.com/a/426586/545127&quot;&gt;modern debuggers are part of an IDE&lt;/a&gt; and provide you with a convenient GUI for examining the source code and variables of your program, with a point-and-click interface for setting breakpoints, running your program and single stepping it.</source>
          <target state="translated">대부분의 &lt;a href=&quot;https://stackoverflow.com/a/426586/545127&quot;&gt;최신 디버거는 IDE의 일부이며&lt;/a&gt; 중단 점 설정, 프로그램 실행 및 단일 스테핑을위한 포인트 앤 클릭 인터페이스를 통해 프로그램의 소스 코드 및 변수를 검사 할 수있는 편리한 GUI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c272bc7b5d1faf3b5ac046f446162bfc7579d7ca" translate="yes" xml:space="preserve">
          <source>Refactor and unit test. If your program is too big, it might be worthwhile to test it one class or one function at a time. Give it inputs, and look at the outputs, and see which are not as you're expecting. Being able to narrow down a bug from an entire program to a single function can make a huge difference in debugging time.</source>
          <target state="translated">리 팩터 및 단위 테스트. 프로그램이 너무 큰 경우 한 번에 하나의 클래스 또는 하나의 함수를 테스트하는 것이 좋습니다. 입력을주고 출력을보고 예상하지 않은 것을 확인하십시오. 전체 프로그램에서 단일 기능으로 버그를 좁힐 수 있으면 디버깅 시간이 크게 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfea533fc55110066831cc9a113752f303aa158f" translate="yes" xml:space="preserve">
          <source>Remember that debugging is a process going backwards. You have the end result - a bug - and find the cause, which preceded it. It's about working your way backwards and, unfortunately, debuggers only step forwards. This is where good logging and postmortem analysis can give you much better results.</source>
          <target state="translated">디버깅은 거꾸로 진행되는 프로세스입니다. 최종 결과-버그-가 있으며 그 원인을 찾습니다. 그것은 거꾸로 일하는 것에 관한 것이며 불행히도 디버거는 앞으로 나아갑니다. 좋은 로깅 및 사후 분석으로 훨씬 나은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a3d0db4761dfac59bdfef0acdc7d355621a5cd" translate="yes" xml:space="preserve">
          <source>Simplest is simply logging and assertions. Add logs to your program at various points, and compare what you get with what you're expecting. For instance, see if the function where you think there's a bug is even called in the first place. See if the variables at a start of a method are what you think they are. Unlike breakpoints, it's okay for there to be many log lines in which nothing special happens. You can simply search through the log afterwards. Once you hit a log line that's different from what you're expecting, add more in the same area. Narrow it down farther and farther, until it's small enough to be able to log every line in the bugged area.</source>
          <target state="translated">가장 간단한 방법은 단순히 로깅 및 어설 션입니다. 다양한 지점에서 프로그램에 로그를 추가하고 예상 한 내용과 비교하십시오. 예를 들어, 버그가 있다고 생각되는 함수가 처음부터 호출되는지 확인하십시오. 메소드 시작시 변수가 자신이 생각하는 것인지 확인하십시오. 중단 점과는 달리 특별한 일이 발생하지 않는 많은 로그 줄이있는 것이 좋습니다. 나중에 로그를 간단하게 검색 할 수 있습니다. 예상 한 것과 다른 로그 라인에 도달하면 같은 영역에 더 추가하십시오. 버그가있는 영역의 모든 줄을 기록 할 수있을 정도로 작아 질 때까지 더 좁히십시오.</target>
        </trans-unit>
        <trans-unit id="11af1f5e4a737d4646ee0deef9b7797bdb5baf23" translate="yes" xml:space="preserve">
          <source>So, what are the alternatives?</source>
          <target state="translated">그렇다면 대안은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8db71d409c1383bc4dea16cad514b565f96d3c83" translate="yes" xml:space="preserve">
          <source>The code that has the bug in it runs many times before it bugs out. This can be particularly problematic in main loops, or worse yet, in physics engines, where the problem could be numerical. Even setting a breakpoint, in this case, would simply have you hitting it many times, with the bug not appearing.</source>
          <target state="translated">버그가있는 코드는 버그가 발생하기 전에 여러 번 실행됩니다. 이것은 문제가 수치적일 수있는 물리 엔진에서는 특히 메인 루프에서 문제가 될 수 있습니다. 이 경우 중단 점을 설정하더라도 버그가 나타나지 않고 여러 번 누르는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11e64b63167eaba5daad013db47bfe5af9956dc0" translate="yes" xml:space="preserve">
          <source>The part of your program which fails is really large (poor modularization, perhaps?) and you're not exactly sure where to start stepping through the code. Stepping through all of it might be too time consuming.</source>
          <target state="translated">실패한 프로그램의 부분은 실제로 크기가 크며 (모듈화가 잘못 되었습니까?) 코드를 단계별로 시작하는 위치를 정확히 모릅니다. 모든 것을 단계별로 실행하면 시간이 너무 많이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe06a3d38eb67781158d1b6de356c30215cb125" translate="yes" xml:space="preserve">
          <source>The specifics of using a debugger depend on the debugger and, to a lesser degree, the programming language you are using.</source>
          <target state="translated">디버거 사용에 대한 세부 사항은 디버거 및 사용중인 프로그래밍 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f5ad5b8430e85c61bfe851f89842b9b5e6fd30da" translate="yes" xml:space="preserve">
          <source>This is intended to be a general purpose question to assist new programmers who have a problem with a program, but do not know how to use a debugger to diagnose the cause of the problem.</source>
          <target state="translated">이것은 프로그램에 문제가있는 새로운 프로그래머를 돕기위한 일반적인 질문이지만, 디버거를 사용하여 문제의 원인을 진단하는 방법을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="317a81e5612bede9ef0ebf356b49a815d401cb81" translate="yes" xml:space="preserve">
          <source>This question covers three classes of more specific question:</source>
          <target state="translated">이 질문은 세 가지 더 구체적인 질문으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d402cbbb81d8dd60aa13040027a9a9b28f4267dd" translate="yes" xml:space="preserve">
          <source>Using a debugger can be very difficult unless your program executable or bytecode files  include debugging &lt;em&gt;symbol information&lt;/em&gt; and cross references to your source-code. You might have to &lt;a href=&quot;https://stackoverflow.com/questions/89603/how-does-the-debugging-option-g-change-the-binary-executable&quot;&gt;compile (or recompile) your program slightly differently&lt;/a&gt; to ensure that information is present. If the compiler performs extensive optimizations, those cross references can become confusing. You might therefore have to &lt;a href=&quot;https://stackoverflow.com/a/7857696/545127&quot;&gt;recompile your program with optimizations turned off&lt;/a&gt;.</source>
          <target state="translated">프로그램 실행 파일이나 바이트 코드 파일에 디버깅 &lt;em&gt;기호 정보&lt;/em&gt; 와 소스 코드에 대한 상호 참조가 포함되어 있지 않으면 디버거를 사용하는 것이 매우 어려울 수 있습니다. 정보가 존재하도록 &lt;a href=&quot;https://stackoverflow.com/questions/89603/how-does-the-debugging-option-g-change-the-binary-executable&quot;&gt;프로그램을 약간 다르게 컴파일 (또는 재 컴파일)해야&lt;/a&gt; 할 수도 있습니다. 컴파일러가 광범위한 최적화를 수행하면 이러한 상호 참조가 혼동 될 수 있습니다. 따라서 &lt;a href=&quot;https://stackoverflow.com/a/7857696/545127&quot;&gt;최적화를 끈 상태에서 프로그램&lt;/a&gt; 을 다시 컴파일해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7cf49b12a749436a9ef554222db7bab809eb274" translate="yes" xml:space="preserve">
          <source>Using a debugger is an expected basic skill</source>
          <target state="translated">디버거 사용은 예상되는 기본 기술입니다.</target>
        </trans-unit>
        <trans-unit id="3e279e4ed2ae68ef124cd2d91bc59889848b5935" translate="yes" xml:space="preserve">
          <source>Using single stepping you can also discover whether the control flow is as you expect. For example, whether an &lt;code&gt;if&lt;/code&gt; branch executed when you expect it ought to be.</source>
          <target state="translated">단일 스테핑을 사용하면 제어 흐름이 예상 한 것과 같은지 여부도 알 수 있습니다. 예를 들어 &lt;code&gt;if&lt;/code&gt; 브랜치가 필요할 때 실행되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="01283b82b512012e10c02769d68c8090ddc60c84" translate="yes" xml:space="preserve">
          <source>What is a debugger and how can it help me diagnose problems</source>
          <target state="translated">디버거 란 무엇이며 문제 진단에 도움이되는 방법</target>
        </trans-unit>
        <trans-unit id="bb0345f67d917d6883f66311548fb70b5de97da9" translate="yes" xml:space="preserve">
          <source>When I run my program, it crashes and gives me a stack trace. I have &lt;a href=&quot;https://stackoverflow.com/questions/3988788/what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors&quot;&gt;examined the stack trace&lt;/a&gt;, but I still do not know the cause of the problem because the stack trace does not provide me with enough information.</source>
          <target state="translated">프로그램을 실행할 때 충돌이 발생하여 스택 추적이 발생합니다. &lt;a href=&quot;https://stackoverflow.com/questions/3988788/what-is-a-stack-trace-and-how-can-i-use-it-to-debug-my-application-errors&quot;&gt;스택 추적&lt;/a&gt; 을 조사 했지만 스택 추적으로 충분한 정보를 제공하지 않기 때문에 여전히 문제의 원인을 모릅니다.</target>
        </trans-unit>
        <trans-unit id="21d75a40a11cab8c9bd1000513184a5edb68b004" translate="yes" xml:space="preserve">
          <source>When I run my program, it crashes because of a segmentation fault (SEGV).</source>
          <target state="translated">프로그램을 실행하면 세그먼트 오류 (SEGV)로 인해 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="362b817e599fe88871572e82a0a7459085492df9" translate="yes" xml:space="preserve">
          <source>When I run my program, it does not produce the output I expect for the input I gave it.</source>
          <target state="translated">프로그램을 실행할 때 입력 한 내용에 대해 예상되는 출력을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bba0c0b6c3d8bfbe7dacab2b87da00e4bc4a5f02" translate="yes" xml:space="preserve">
          <source>You can &lt;em&gt;attach&lt;/em&gt; a debugger to a process already running your program. You  might do if your program is stuck.</source>
          <target state="translated">이미 프로그램을 실행중인 프로세스에 디버거를 &lt;em&gt;연결할&lt;/em&gt; 수 있습니다. 프로그램이 멈췄다면 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a05e0a9c5c99e4bb417913c643133e002238ba1" translate="yes" xml:space="preserve">
          <source>You can tell that your bug is caused by incorrect values arriving at function X, but you don't know where these values come from. Having to run through the program, again and again, setting breakpoints farther and farther back, can be a huge hassle. Especially if function X is called from many places throughout the program.</source>
          <target state="translated">함수 X에 잘못된 값이 도착하여 버그가 발생했음을 알 수 있지만 이러한 값의 출처는 모릅니다. 중단 점을 더 멀리 그리고 더 멀리 설정하여 프로그램을 반복해서 실행해야하는 것은 큰 번거 로움이 될 수 있습니다. 특히 함수 X가 프로그램의 여러 곳에서 호출되는 경우.</target>
        </trans-unit>
        <trans-unit id="fba390354c53382829fca30a0664e9c72d72f969" translate="yes" xml:space="preserve">
          <source>You indicate &lt;em&gt;where&lt;/em&gt; your program should stop executing by indicating the source-code file and line number of the line at which execution should stop, or by indicating the name of the method/function at which the program should stop (if you want to stop as soon as execution enters the method). The technical means that the debugger uses to cause your program to stop is called a &lt;em&gt;breakpoint&lt;/em&gt; and this process is called &lt;em&gt;setting a breakpoint&lt;/em&gt;.</source>
          <target state="translated">소스 코드 파일과 실행을 중지해야하는 행의 행 번호를 표시하거나 프로그램을 중지해야하는 메소드 / 기능의 이름을 표시하여 프로그램 실행을 중지해야하는 위치를 표시합니다 ( 실행이 메소드에 들어가 자마자). 기술적으로 디버거가 프로그램을 중지시키는 데 사용하는 것을 &lt;em&gt;중단 점&lt;/em&gt; 이라고 &lt;em&gt;하며이&lt;/em&gt; 프로세스를 &lt;em&gt;중단 점 설정&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36a877db5fba4c1c71b6a6dc4aee4eaf879d1f64" translate="yes" xml:space="preserve">
          <source>Your program is multi-threaded. Or even worse, your problem is caused by a race condition.</source>
          <target state="translated">프로그램이 멀티 스레드입니다. 또는 더 나쁜 것은, 당신의 문제는 경쟁 조건 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ef19f674fef2005af2ff2b50f2cab28caf87470e" translate="yes" xml:space="preserve">
          <source>Your program must run in real time. This is a big issue for programs that connect to the network. If you set up a breakpoint in your network code, the other end isn't going to wait for you to step through, it's simply going to time out. Programs which rely on the system clock, e.g. games with frame skip, aren't much better off either.</source>
          <target state="translated">프로그램은 실시간으로 실행되어야합니다. 네트워크에 연결되는 프로그램의 경우 큰 문제입니다. 네트워크 코드에 중단 점을 설정하면 다른 쪽 끝은 사용자가 단계별로 기다리지 않고 단순히 시간 초과됩니다. 시스템 클럭에 의존하는 프로그램 (예 : 프레임 스킵이있는 게임)은 그다지 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00fa062298e582b7d61242405c699fc9a9bf07dd" translate="yes" xml:space="preserve">
          <source>Your program performs some form of destructive actions, like writing to files or sending e-mails, and you'd like to limit the number of times you need to run through it.</source>
          <target state="translated">프로그램은 파일 쓰기 또는 전자 메일 보내기와 같은 일부 형태의 파괴적인 작업을 수행하며이를 통해 실행해야하는 횟수를 제한하려고합니다.</target>
        </trans-unit>
        <trans-unit id="eaadc1ee03032694703d617ad9e3871bdbd49308" translate="yes" xml:space="preserve">
          <source>Your program uses a lot of callbacks and other non-linear flow control methods, which makes the debugger confused when you step through it.</source>
          <target state="translated">프로그램은 많은 콜백 및 기타 비선형 흐름 제어 방법을 사용하므로 디버거가 단계별로 혼란 스러울 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
