<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2591098">
    <body>
      <group id="2591098">
        <trans-unit id="ea65c5c96e1eac1d9c4435b5e12b399ffced32c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://code.google.com/p/quick-json/&quot;&gt;quick-json parser&lt;/a&gt; is very straightforward, flexible, very fast and customizable. Try it</source>
          <target state="translated">&lt;a href=&quot;https://code.google.com/p/quick-json/&quot;&gt;quick-json 파서&lt;/a&gt; 는 매우 간단하고 유연하며 매우 빠르고 사용자 정의가 가능합니다. 시도 해봐</target>
        </trans-unit>
        <trans-unit id="581c985eea09e3d23ece6c4273d96320b7a256bd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/FasterXML/jackson-databind/&quot;&gt;Jackson&lt;/a&gt; (&lt;a href=&quot;http://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind&quot;&gt;Maven&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/FasterXML/jackson-databind/&quot;&gt;잭슨&lt;/a&gt; ( &lt;a href=&quot;http://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind&quot;&gt;메이븐&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="54b860be7eb1706dd022135cab0fcf7ba4e7faf3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/google/gson&quot;&gt;Google GSON&lt;/a&gt; (&lt;a href=&quot;http://mvnrepository.com/artifact/com.google.code.gson/gson&quot;&gt;Maven&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/google/gson&quot;&gt;Google GSON&lt;/a&gt; ( &lt;a href=&quot;http://mvnrepository.com/artifact/com.google.code.gson/gson&quot;&gt;Maven&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3ee7e3039883c031f4cdb591853c88b660863b1d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/stleary/JSON-java&quot;&gt;Org.JSON&lt;/a&gt; (&lt;a href=&quot;http://mvnrepository.com/artifact/org.json/json&quot;&gt;Maven&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/stleary/JSON-java&quot;&gt;조직 JSON&lt;/a&gt; ( &lt;a href=&quot;http://mvnrepository.com/artifact/org.json/json&quot;&gt;Maven&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="05f76f0d55a1a802b770e68d6fdf7db04a914eee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jsoniter&lt;/code&gt; (jsoniterator) is a relatively new and simple json library, designed to be simple and fast. All you need to do to deserialize json data is</source>
          <target state="translated">&lt;code&gt;jsoniter&lt;/code&gt; (jsoniterator)는 비교적 새롭고 간단한 json 라이브러리이며 간단하고 빠르도록 설계되었습니다. JSON 데이터를 직렬화 해제하기 위해해야 ​​할 일은</target>
        </trans-unit>
        <trans-unit id="03610e46c3979f79023144c6bf30ea1d6e343100" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;fromJson()&lt;/em&gt;&lt;/strong&gt; &amp;ndash; Convert JSON into Java object</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;fromJson ()&lt;/em&gt;&lt;/strong&gt; &amp;ndash; JSON을 Java 객체로 변환</target>
        </trans-unit>
        <trans-unit id="705c755a5250c8b1f571cf8890ad4135858b182f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;toJson()&lt;/em&gt;&lt;/strong&gt; &amp;ndash; Convert Java object to JSON format</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;toJson ()&lt;/em&gt;&lt;/strong&gt; &amp;ndash; Java 객체를 JSON 형식으로 변환</target>
        </trans-unit>
        <trans-unit id="fb8f9c8b1988dbf445e49cc72e660540c1cce355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code for converting this JSON to a Java class.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 JSON을 Java 클래스로 변환하기위한 코드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f561f0a28a73c1cfb924e851f87e5d54afde91ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DSM is very good for complex json and xml.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DSM은 복잡한 json 및 xml에 매우 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9251863320abe2fea319e96654ab3025da8e313e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Gson&lt;/strong&gt; is easy to learn and implement, what we need to know are following two methods</source>
          <target state="translated">&lt;strong&gt;Gson&lt;/strong&gt; 은 배우고 구현하기 쉽고 두 가지 방법을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="ff1a5ff658b0821446261c49fa429c9c5086a950" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I have JSON like this:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;나는 이와 같은 JSON을 가지고있다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab280e1e06c703b1cad8b270301293d1d14cc3ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Jackson&lt;/strong&gt; takes 6.5~7 seconds</source>
          <target state="translated">&lt;strong&gt;잭슨&lt;/strong&gt; 은 6.5 ~ 7 초 걸립니다</target>
        </trans-unit>
        <trans-unit id="e7af3e9da3894854740bb7458fbfd889afae67ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java class&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자바 클래스&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f1f5f742f9fbb132d6357c0198a1f1c2c4ef5414" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Maven&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Maven&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1129c7696d19cfbf06a0a0f1333da3bff9e773b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Page&lt;/strong&gt; Class, a composite of &lt;strong&gt;PageInfo&lt;/strong&gt; Class and array of &lt;strong&gt;Post&lt;/strong&gt; Instances</source>
          <target state="translated">&lt;strong&gt;PageInfo&lt;/strong&gt; 클래스, &lt;strong&gt;PageInfo&lt;/strong&gt; 클래스 및 &lt;strong&gt;Post&lt;/strong&gt; 인스턴스 배열의 합성</target>
        </trans-unit>
        <trans-unit id="0dc53093af6d0bc6129a4b99c67b4821d7476c6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PageInfo&lt;/strong&gt; Class</source>
          <target state="translated">&lt;strong&gt;PageInfo&lt;/strong&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="5bdf7aae131dcf748c7b9ace65a6cbcede925cd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance comparison&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;성능 비교&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b1137c7cde8f7f4f635ccde6b622d5a38018762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Posts&lt;/strong&gt; Class</source>
          <target state="translated">&lt;strong&gt;게시물&lt;/strong&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="43f038c62b45a67bf440ca6fe8caa39490287184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solution&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1886539a537103abdbc2deba551ee10fab14bc0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 1&lt;/strong&gt;: Add the jayway JSON path dependency in your class path using Maven or download the JAR file and manually add it.</source>
          <target state="translated">&lt;strong&gt;1 단계&lt;/strong&gt; : Maven을 사용하여 클래스 경로에 jayway JSON 경로 종속성을 추가하거나 JAR 파일을 다운로드하여 수동으로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2fbd052391bb5db3b551a01917005442e6578fba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 2&lt;/strong&gt;: Please save your input JSON as a file for this example. In my case I saved your JSON as sampleJson.txt. Note you missed a comma between pageInfo and posts.</source>
          <target state="translated">&lt;strong&gt;2 단계&lt;/strong&gt; : 입력 JSON을이 예제의 파일로 저장하십시오. 제 경우에는 JSON을 sampleJson.txt로 저장했습니다. pageInfo와 게시물 사이에 쉼표가 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="048e0b165aae8387f19fb8f66135b22372f11de4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 3&lt;/strong&gt;: Read the JSON contents from the above file using bufferedReader and save it as String.</source>
          <target state="translated">&lt;strong&gt;3 단계&lt;/strong&gt; : bufferedReader를 사용하여 위 파일에서 JSON 컨텐츠를 읽고 문자열로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="84f862c1d56afbc5d00599cfbabc74c958688a25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 4&lt;/strong&gt;: Parse your JSON string using jayway JSON parser.</source>
          <target state="translated">&lt;strong&gt;4 단계&lt;/strong&gt; : jayway JSON 파서를 사용하여 JSON 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="cc327bb753d6694e6d587e28b624df3fd2decf43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Step 5&lt;/strong&gt;: Read the details like below.</source>
          <target state="translated">&lt;strong&gt;5 단계&lt;/strong&gt; : 아래와 같은 세부 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b913191ee8246154e8264c165558cedbc926ca35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The output will be&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;출력은 다음과&lt;/strong&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f25f3e28c57eff39cd3e2e6eadedc301de5413fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jackson-annotations-2.5.0.jar&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jackson-annotations-2.5.0.jar&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86d8a75250ca1708ac4c4b1ec45987048798776d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jackson-core-2.5.1.jar&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jackson-core-2.5.1.jar&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6feda883de2fd3be3de89dd9b83fc93c7213d6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jackson-databind-2.5.1.jar&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jackson-databind-2.5.1.jar&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="12743475bf50fb900579f074c47e0df51b6d05c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;org.json&lt;/strong&gt; takes 20~21 seconds</source>
          <target state="translated">&lt;strong&gt;org.json&lt;/strong&gt; 은 20 ~ 21 초 걸립니다</target>
        </trans-unit>
        <trans-unit id="fb28eb98a5cc6cac6edaa0094b2e5918a1aad2ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;page&lt;/strong&gt; variable serialized to json:</source>
          <target state="translated">&lt;strong&gt;페이지&lt;/strong&gt; 변수가 json으로 직렬화되었습니다.</target>
        </trans-unit>
        <trans-unit id="d810459f3180bff7e2a7a6af2c59c8c67e8fa178" translate="yes" xml:space="preserve">
          <source>A - Explanation</source>
          <target state="translated">A-설명</target>
        </trans-unit>
        <trans-unit id="b67ce5d5635f015e9f01c6db5b0c651824b1cb5b" translate="yes" xml:space="preserve">
          <source>Almost all the answers given requires a full deserialization of the JSON into a Java object before accessing the value in the property of interest. Another alternative, which does not go this route is to use &lt;a href=&quot;http://goessner.net/articles/JsonPath/&quot;&gt;JsonPATH&lt;/a&gt; which is like XPath for JSON and allows traversing of JSON objects.</source>
          <target state="translated">주어진 거의 모든 답변은 관심있는 속성의 값에 액세스하기 전에 JSON을 Java 객체로 완전히 직렬화 해제해야합니다. 이 경로를 따르지 않는 또 다른 대안은 JSON의 XPath와 같은 &lt;a href=&quot;http://goessner.net/articles/JsonPath/&quot;&gt;JsonPATH&lt;/a&gt; 를 사용하고 JSON 객체의 통과를 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="af8d410d429ad57fab9c29adda1ef85707482ce8" translate="yes" xml:space="preserve">
          <source>And &lt;strong&gt;to help you decide&lt;/strong&gt;... I found this article as well:</source>
          <target state="translated">그리고 &lt;strong&gt;당신이 결정하는 것을 돕기 위해&lt;/strong&gt; ... 나는이 기사를 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="663653cb78ef87e0bb6480289ada2bfff8942b72" translate="yes" xml:space="preserve">
          <source>Automatic model generation</source>
          <target state="translated">자동 모델 생성</target>
        </trans-unit>
        <trans-unit id="b738ee3e56540b60fee89056a48118c59804bed7" translate="yes" xml:space="preserve">
          <source>B - Main POJO Class : Page</source>
          <target state="translated">B-주요 POJO 클래스 : 페이지</target>
        </trans-unit>
        <trans-unit id="d66d5132e915f27b988bbcb532fd4097e0995031" translate="yes" xml:space="preserve">
          <source>But if one just want to parse a JSON string and get some values, (OR create a JSON string from scratch to send over wire) just use JaveEE jar which contains JsonReader, JsonArray, JsonObject etc. You may want to download the implementation of that spec like javax.json. With these two jars I am able to parse the json and use the values.</source>
          <target state="translated">그러나 JSON 문자열을 구문 분석하고 값을 얻으려면 (또는 JSON 문자열을 처음부터 작성하여 와이어를 통해 보내려면) JsonReader, JsonArray, JsonObject 등이 포함 된 JaveEE jar을 사용하십시오. 그 구현을 다운로드 할 수 있습니다 javax.json과 같은 스펙. 이 두 항아리로 json을 구문 분석하고 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76ff8126da6f93d5ee3697f05578f8cbc37e3819" translate="yes" xml:space="preserve">
          <source>C - Child POJO Class : PageInfo</source>
          <target state="translated">C-자식 POJO 클래스 : PageInfo</target>
        </trans-unit>
        <trans-unit id="8a2dc4ac0a59e84b96d9e4e2011a1d324b5615a6" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;http://jsoniter.com/&quot;&gt;official website&lt;/a&gt;
for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://jsoniter.com/&quot;&gt;공식 웹 사이트&lt;/a&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5d412e7449d9e26d0c1415515ac836426e5d9116" translate="yes" xml:space="preserve">
          <source>Check the JsonPath specification page for more information on the other ways to transverse JSON.</source>
          <target state="translated">JSON을 가로 지르는 다른 방법에 대한 자세한 정보는 JsonPath 스펙 페이지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5f16c172ef732329922fe4de767f371ef0e8a14c" translate="yes" xml:space="preserve">
          <source>Compliant with JSON specification (RFC4627)</source>
          <target state="translated">JSON 사양 준수 (RFC4627)</target>
        </trans-unit>
        <trans-unit id="69c7ed2e68fc1c1c410d3a15220f49b10f78ddc3" translate="yes" xml:space="preserve">
          <source>Configurable validation of key/value pairs of any JSON Hierarchy</source>
          <target state="translated">모든 JSON 계층의 키 / 값 쌍에 대한 구성 가능한 검증</target>
        </trans-unit>
        <trans-unit id="b43f50ee8ee18a4adf5d2723ee8fe73aa7a2fa98" translate="yes" xml:space="preserve">
          <source>Create Java object from JSON</source>
          <target state="translated">JSON에서 Java 객체 생성</target>
        </trans-unit>
        <trans-unit id="bfe5f0fdd4ad15aa4bcd6cf27f41fdb5fa152040" translate="yes" xml:space="preserve">
          <source>Create a yaml Mapping file.</source>
          <target state="translated">yaml 매핑 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5a1f8dfe343d664415ddc94739883a4753af831f" translate="yes" xml:space="preserve">
          <source>Creating JSON:</source>
          <target state="translated">JSON 만들기 :</target>
        </trans-unit>
        <trans-unit id="ba357fa573625c18a64c4a5ec0aa47fe1deb81cf" translate="yes" xml:space="preserve">
          <source>D - Child POJO Class : Post</source>
          <target state="translated">D-아동 POJO 수업 : Post</target>
        </trans-unit>
        <trans-unit id="1555271c54fe56903d1f72ec8246497a843bcfc1" translate="yes" xml:space="preserve">
          <source>Done. &lt;em&gt;Drops microphone&lt;/em&gt;.
This works with &lt;code&gt;JSONObjects&lt;/code&gt; as well. After that, you can just look through your hierarchy of &lt;code&gt;Objects&lt;/code&gt; using the &lt;code&gt;get()&lt;/code&gt; methods on your objects.</source>
          <target state="translated">끝난. &lt;em&gt;마이크를 떨어 뜨&lt;/em&gt; 립니다. 이것은 &lt;code&gt;JSONObjects&lt;/code&gt; 에서도 작동합니다. 그런 다음 &lt;code&gt;Objects&lt;/code&gt; 의 &lt;code&gt;get()&lt;/code&gt; 메소드를 사용하여 객체 의 계층 구조를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab13932a6db4b8954dec2f6bc4eb7836527a70a7" translate="yes" xml:space="preserve">
          <source>Downloadable jar:  &lt;a href=&quot;http://mvnrepository.com/artifact/org.json/json&quot;&gt;http://mvnrepository.com/artifact/org.json/json&lt;/a&gt;</source>
          <target state="translated">다운로드 가능한 jar : &lt;a href=&quot;http://mvnrepository.com/artifact/org.json/json&quot;&gt;http://mvnrepository.com/artifact/org.json/json&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b4d50543ce7975d4b13d9a5652eeb5444ad618b" translate="yes" xml:space="preserve">
          <source>E - Sample JSON File : sampleJSONFile.json</source>
          <target state="translated">E-샘플 JSON 파일 : sampleJSONFile.json</target>
        </trans-unit>
        <trans-unit id="00feb5912c0950d28a766de9161106eb61bf7ec1" translate="yes" xml:space="preserve">
          <source>Ease of use (code is simple to write and legible) - that goes with features.</source>
          <target state="translated">사용 편의성 (코드 작성이 쉽고 읽기 쉬운 기능)-기능과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ce370a5c966639d991d2edbcf30aa43459931fb1" translate="yes" xml:space="preserve">
          <source>Easy to use # Very small footprint</source>
          <target state="translated">사용하기 쉬운 # 매우 작은 설치 공간</target>
        </trans-unit>
        <trans-unit id="1203b487908e8c8120e99871d562a439ab5dac96" translate="yes" xml:space="preserve">
          <source>F - Demo Code</source>
          <target state="translated">F-데모 코드</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="4fd018f9b4541f8c7b5f7b837295fec5fbe165f9" translate="yes" xml:space="preserve">
          <source>First you need to select an &lt;strong&gt;implementation library&lt;/strong&gt; to do that.</source>
          <target state="translated">먼저 &lt;strong&gt;구현 라이브러리&lt;/strong&gt; 를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fab5b640e16bedd65b12cef9e96c7aa9b3dc83b" translate="yes" xml:space="preserve">
          <source>For 1, see this benchmark: &lt;a href=&quot;https://github.com/fabienrenaud/java-json-benchmark&quot;&gt;https://github.com/fabienrenaud/java-json-benchmark&lt;/a&gt; I did using &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; which compares (jackson, gson, genson, fastjson, org.json, jsonp) performance of serializers and deserializers using stream and databind APIs.
For 2, you can find numerous examples on the Internet. The benchmark above can also be used as a source of examples...</source>
          <target state="translated">1의 경우이 벤치 마크를 참조하십시오 : &lt;a href=&quot;https://github.com/fabienrenaud/java-json-benchmark&quot;&gt;https://github.com/fabienrenaud/java-json-benchmark&lt;/a&gt; 나는 &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; 를 사용하여 스트림을 사용하여 직렬화 기와 직렬화 해제 기의 직렬화 기와 직렬화 해제 기의 성능 (jackson, gson, genson, fastjson, org.json, jsonp)을 비교했습니다. 및 데이터 바인드 API. 2의 경우 인터넷에서 수많은 예를 찾을 수 있습니다. 위의 벤치 마크는 예제 소스로도 사용할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="2f0a74d7dfe882b3c0628193b58ea62013cab0bc" translate="yes" xml:space="preserve">
          <source>For further reference you can refer to the following &lt;a href=&quot;http://javahai.blogspot.in/2016/03/create-java-object-from-json-string.html&quot;&gt;link&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 다음 &lt;a href=&quot;http://javahai.blogspot.in/2016/03/create-java-object-from-json-string.html&quot;&gt;링크를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc0b99d1a4fc0b06d6dcf2ceb23a820e9c3d979e" translate="yes" xml:space="preserve">
          <source>For mobile apps: dependency/jar size</source>
          <target state="translated">모바일 앱의 경우 : 종속성 / jar 크기</target>
        </trans-unit>
        <trans-unit id="e5e03d0772320e98ed4376b556afec9cf1112698" translate="yes" xml:space="preserve">
          <source>For the sake of the example lets assume you have a class &lt;strong&gt;&lt;code&gt;Person&lt;/code&gt;&lt;/strong&gt; with just a &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">예제를 위해 &lt;code&gt;name&lt;/code&gt; &lt;strong&gt; &lt;code&gt;Person&lt;/code&gt; &lt;/strong&gt; 클래스 만 있다고 가정하자.</target>
        </trans-unit>
        <trans-unit id="2885f44578c0f825368033cb53176134ed3d590b" translate="yes" xml:space="preserve">
          <source>For your particular example, the following code decodes your json with jackson:</source>
          <target state="translated">특정 예제의 경우 다음 코드는 json을 jackson으로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="46bef7454065eebd2a67f75cdc30df17dc513844" translate="yes" xml:space="preserve">
          <source>From your example:</source>
          <target state="translated">귀하의 예에서 :</target>
        </trans-unit>
        <trans-unit id="a69798c76d0a5628b350f29769d994d62ecbe059" translate="yes" xml:space="preserve">
          <source>G - Demo Output</source>
          <target state="translated">G-데모 출력</target>
        </trans-unit>
        <trans-unit id="9adca0a1f8e9c23815dd4bc100592ef7dd2c16b1" translate="yes" xml:space="preserve">
          <source>Gradle import</source>
          <target state="translated">Gradle 가져 오기</target>
        </trans-unit>
        <trans-unit id="5a3edd9462d95d94e4c206a206631620177058b8" translate="yes" xml:space="preserve">
          <source>Here is the required code;</source>
          <target state="translated">필요한 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb1d161d6ba6dfb003d26634a915d135c72556ab" translate="yes" xml:space="preserve">
          <source>Here you can find a &lt;strong&gt;list of implementations&lt;/strong&gt; of JSR 353:</source>
          <target state="translated">다음은 JSR 353 &lt;strong&gt;구현 목록입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ea240118c4bf850ae6636a1a53c032f94886def1" translate="yes" xml:space="preserve">
          <source>High-Performance JSON parser</source>
          <target state="translated">고성능 JSON 파서</target>
        </trans-unit>
        <trans-unit id="e91c5dffba99be277021da86df113a93045c9b6d" translate="yes" xml:space="preserve">
          <source>Hope it helps!</source>
          <target state="translated">그것이 도움이되기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="68df6e851d85c7d09297b9204c8a83b835f72f14" translate="yes" xml:space="preserve">
          <source>How to parse JSON in Java</source>
          <target state="translated">Java에서 JSON을 구문 분석하는 방법</target>
        </trans-unit>
        <trans-unit id="7cce87c2a84ffcdb1ce79866d0ce75d3a7b725e5" translate="yes" xml:space="preserve">
          <source>I believe the best practice should be to go through the official &lt;a href=&quot;http://json-processing-spec.java.net/&quot;&gt;Java JSON API&lt;/a&gt; which are still work in progress.</source>
          <target state="translated">모범 사례는 여전히 진행중인 공식 &lt;a href=&quot;http://json-processing-spec.java.net/&quot;&gt;Java JSON API&lt;/a&gt; 를 거치는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f9613b87bf96a3f80b384dbf2950b16ecee7d47" translate="yes" xml:space="preserve">
          <source>I have the following JSON text. How can I parse it to get the values of &lt;code&gt;pageName&lt;/code&gt;, &lt;code&gt;pagePic&lt;/code&gt;, &lt;code&gt;post_id&lt;/code&gt;, etc.?</source>
          <target state="translated">다음 JSON 텍스트가 있습니다. &lt;code&gt;pageName&lt;/code&gt; , &lt;code&gt;pagePic&lt;/code&gt; , &lt;code&gt;post_id&lt;/code&gt; 등의 값을 얻기 위해 구문 분석하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d8f0c4e0c9f55071e5234777e393a4c7be6419e6" translate="yes" xml:space="preserve">
          <source>I want to retrieve the value of &quot;translatedText&quot; attribute e.g. &quot;Arbeit&quot; using Google's Gson.</source>
          <target state="translated">Google의 Gson을 사용하여 &quot;translatedText&quot;속성의 값 (예 : &quot;Arbeit&quot;)을 검색하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d5f6b48ca5241e591de492e8026eabcfac5704ca" translate="yes" xml:space="preserve">
          <source>I wrote JSON content containing three arrays of respectively 20, 20 and 100 elements. I only want to get the 100 elements from the third array. I use the following JavaScript function to parse and get my entries.</source>
          <target state="translated">각각 20, 20 및 100 요소로 구성된 3 개의 배열을 포함하는 JSON 내용을 작성했습니다. 세 번째 배열에서 100 개의 요소 만 가져오고 싶습니다. 다음 JavaScript 함수를 사용하여 항목을 구문 분석하고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bc670ce71e17cb364032562f9990059824ae23de" translate="yes" xml:space="preserve">
          <source>I've just copied your JSON sample into this file and put it under the project folder.</source>
          <target state="translated">방금 JSON 샘플을이 파일로 복사하여 프로젝트 폴더에 넣었습니다.</target>
        </trans-unit>
        <trans-unit id="ceb2cc12a904bbb5d45b6e59986a3aafd5b680bb" translate="yes" xml:space="preserve">
          <source>If one wants to create Java object from JSON and vice versa, use GSON or JACKSON third party jars etc.</source>
          <target state="translated">JSON에서 Java 객체를 생성하거나 그 반대의 경우 GSON 또는 JACKSON 타사 항아리 등을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c35a7233c9b98527537ebaf8214644c098990138" translate="yes" xml:space="preserve">
          <source>If you don't need object de-serialisation but to simply get an attribute, you can try org.json (&lt;strong&gt;or look GSON example above!&lt;/strong&gt;)</source>
          <target state="translated">객체 역 직렬화가 필요하지 않지만 단순히 속성을 얻으려면 org.json을 시도하십시오 ( &lt;strong&gt;또는 위의 GSON 예제를&lt;/strong&gt; 보십시오 &lt;strong&gt;!&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="86de2921b10bc48cdd2792ee251a69936f29851b" translate="yes" xml:space="preserve">
          <source>If you go for Jackson, here is a good article about conversion between JSON to/from Java using Jackson: &lt;a href=&quot;https://www.mkyong.com/java/how-to-convert-java-object-to-from-json-jackson/&quot;&gt;https://www.mkyong.com/java/how-to-convert-java-object-to-from-json-jackson/&lt;/a&gt;</source>
          <target state="translated">Jackson을 원한다면 Jackson을 사용하여 JSON을 Java로 또는 Java에서 Java로 변환하는 방법에 대한 좋은 기사가 &lt;a href=&quot;https://www.mkyong.com/java/how-to-convert-java-object-to-from-json-jackson/&quot;&gt;있습니다. 잭슨 /&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3a718b5da6f863dd650d28b31b7f39126c939b8" translate="yes" xml:space="preserve">
          <source>If you have some Java class(say Message) representing the JSON string(jsonString), you can use &lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;Jackson&lt;/a&gt;  JSON library with:</source>
          <target state="translated">JSON 문자열 (jsonString)을 나타내는 Java 클래스 (예 : Message)가있는 경우 &lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;Jackson&lt;/a&gt; JSON 라이브러리를 다음과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6b38e774913e413531ed50fe8f99c268dc10e0" translate="yes" xml:space="preserve">
          <source>If you want to get a single attribute out you can do it easily with the Google library as well:</source>
          <target state="translated">단일 속성을 얻으려면 Google 라이브러리에서도 쉽게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8db7127b046e469b834e6462fa961384b7d6965" translate="yes" xml:space="preserve">
          <source>In addition to other answers, I recomend this online opensource service &lt;a href=&quot;http://www.jsonschema2pojo.org/&quot;&gt;jsonschema2pojo.org&lt;/a&gt; for quick generating Java classes from json or json schema for GSON, Jackson 1.x or Jackson 2.x. For example, if you have:</source>
          <target state="translated">다른 답변 외에도 GSON, Jackson 1.x 또는 Jackson 2.x의 json 또는 json 스키마에서 Java 클래스를 빠르게 생성하기 위해이 온라인 오픈 소스 서비스 &lt;a href=&quot;http://www.jsonschema2pojo.org/&quot;&gt;jsonschema2pojo.org&lt;/a&gt; 를 권장합니다. 예를 들어 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="2c59ace1ec6d4b3f2c5104567e4ac03a2a140852" translate="yes" xml:space="preserve">
          <source>In this case Jackson performs better than Nashorn, which performs much better than org.json.
Nashorn API is harder to use than org.json's or Jackson's. Depending on your requirements Jackson and Nashorn both can be viable solutions.</source>
          <target state="translated">이 경우 Jackson은 Nashorn보다 성능이 좋으며 org.json보다 성능이 훨씬 우수합니다. Nashorn API는 org.json 또는 Jackson보다 사용하기가 어렵습니다. 요구 사항에 따라 Jackson과 Nashorn은 모두 실용적인 솔루션이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee9922191e0c50a3726173d2d2a5807b35d614f" translate="yes" xml:space="preserve">
          <source>In your JSON object, which is actually a &lt;strong&gt;composite&lt;/strong&gt; object, the main object consists o two sub-objects. So, our POJO classes should have the same hierarchy. I'll call the whole JSON Object as &lt;strong&gt;Page&lt;/strong&gt; object. &lt;strong&gt;Page&lt;/strong&gt; object consist of a &lt;strong&gt;PageInfo&lt;/strong&gt; object, and a &lt;strong&gt;Post&lt;/strong&gt; object array.</source>
          <target state="translated">실제로 &lt;strong&gt;복합&lt;/strong&gt; 객체 인 JSON 객체에서 주 객체는 두 개의 하위 객체로 구성됩니다. 따라서 POJO 클래스는 동일한 계층 구조를 가져야합니다. 전체 JSON 객체를 &lt;strong&gt;Page&lt;/strong&gt; 객체로 호출합니다. &lt;strong&gt;Page&lt;/strong&gt; 개체는 &lt;strong&gt;PageInfo&lt;/strong&gt; 개체와 &lt;strong&gt;Post&lt;/strong&gt; 개체 배열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7957cdd685e55b0659e0f881b1501d7538cec20a" translate="yes" xml:space="preserve">
          <source>It can be used like this:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b8a08f56b44c2d87e99bd4f90e6ce3b988da05f1" translate="yes" xml:space="preserve">
          <source>It is a specification and the good folks at JayWay have created a Java implementation for the specification which you can find here: &lt;a href=&quot;https://github.com/jayway/JsonPath&quot;&gt;https://github.com/jayway/JsonPath&lt;/a&gt;</source>
          <target state="translated">JayWay의 사양이며 좋은 사람들은 사양에 대한 Java 구현을 만들었습니다. &lt;a href=&quot;https://github.com/jayway/JsonPath&quot;&gt;https://github.com/jayway/JsonPath&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="53caf5fac63a362f1b42f0a9bf30b0d1429744ca" translate="yes" xml:space="preserve">
          <source>Let me know if you have any questions.</source>
          <target state="translated">궁금한 점이 있으면 알려주세요.</target>
        </trans-unit>
        <trans-unit id="eb7d999e07b1970c76f70121da876b6c2277edcc" translate="yes" xml:space="preserve">
          <source>Let's say we have &lt;strong&gt;Page&lt;/strong&gt; class to deserialize given json data.</source>
          <target state="translated">주어진 json 데이터를 직렬화 해제하는 &lt;strong&gt;Page&lt;/strong&gt; 클래스가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="3d575f5e4334f1ec638628bfc8458d0aaaae4399" translate="yes" xml:space="preserve">
          <source>Maven:</source>
          <target state="translated">Maven:</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="cf9db3cb2277b774f7e804d9f63363f022644951" translate="yes" xml:space="preserve">
          <source>My personal favourite as to the great JSON serialisation / de-serialisation of objects.</source>
          <target state="translated">객체의 JSON 직렬화 / 역 직렬화에 대한 개인적 선호.</target>
        </trans-unit>
        <trans-unit id="bce347b8b84e91a762a886a1d5505fcc68cb0f69" translate="yes" xml:space="preserve">
          <source>No dependency on external libraries</source>
          <target state="translated">외부 라이브러리에 의존하지 않습니다</target>
        </trans-unit>
        <trans-unit id="fd5a170699b9eb4b30561cd70cabb9b28942c677" translate="yes" xml:space="preserve">
          <source>Now you can parse using Gson library:</source>
          <target state="translated">이제 Gson 라이브러리를 사용하여 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a484f9dc3e0f6afa1adeb91f3dbdf89f99016e46" translate="yes" xml:space="preserve">
          <source>Now, before anyone goes and downvotes this answer because it doesn't use GSON, org.json, Jackson, or any of the other 3rd party frameworks available, it's an example of &quot;required code&quot; per the question to parse the provided text.  I am well aware that &lt;a href=&quot;http://openjdk.java.net/jeps/198&quot;&gt;adherence to the current standard JSR 353 was not being considered for JDK 9&lt;/a&gt; and as such the &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=353&quot;&gt;JSR 353 spec&lt;/a&gt; should be treated the same as any other 3rd party JSON handling implementation.</source>
          <target state="translated">이제이 답변이 GSON, org.json, Jackson 또는 사용 가능한 다른 타사 프레임 워크를 사용하지 않기 때문에이 답을 내려 가기 전에 제공된 텍스트를 구문 분석하기 위해 질문마다 &quot;필수 코드&quot;의 예입니다. &lt;a href=&quot;http://openjdk.java.net/jeps/198&quot;&gt;현재 표준 JSR 353 준수는 JDK 9에서 고려되지 않았으므로&lt;/a&gt; &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=353&quot;&gt;JSR 353 사양&lt;/a&gt; 은 다른 타사 JSON 처리 구현과 동일하게 취급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9bf41a6d92f4678e2f2e1714e549e74448f091ce" translate="yes" xml:space="preserve">
          <source>Now, use this object to get your values:</source>
          <target state="translated">이제이 객체를 사용하여 값을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="7e2ce87913736a80d592df235669758288745cc1" translate="yes" xml:space="preserve">
          <source>One can use &lt;a href=&quot;https://github.com/apache/incubator-netbeans-html4j&quot;&gt;Apache @Model annotation&lt;/a&gt; to create &lt;strong&gt;Java&lt;/strong&gt; model classes representing structure of &lt;strong&gt;JSON&lt;/strong&gt; files and use them to access various elements in the &lt;strong&gt;JSON&lt;/strong&gt; tree. Unlike other solutions this one &lt;em&gt;works completely without reflection&lt;/em&gt; and is thus suitable for environments where reflection is impossible or comes with significant overhead.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apache/incubator-netbeans-html4j&quot;&gt;Apache @Model 어노테이션&lt;/a&gt; 을 사용하여 &lt;strong&gt;JSON&lt;/strong&gt; 파일의 구조를 나타내는 &lt;strong&gt;Java&lt;/strong&gt; 모델 클래스를 작성하고이를 사용하여 &lt;strong&gt;JSON&lt;/strong&gt; 트리의 다양한 요소에 액세스 할 수 있습니다. 다른 솔루션과 달리이 솔루션은 &lt;em&gt;반사없이 완벽하게 작동&lt;/em&gt; 하므로 반사가 불가능하거나 상당한 오버 헤드가 발생하는 환경에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="dff366f935f687805e17e00bde34355d9df3edef" translate="yes" xml:space="preserve">
          <source>Page class</source>
          <target state="translated">페이지 클래스</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="33e92b6b98157a0b3e332d3aff1d2cdddbdcc5a2" translate="yes" xml:space="preserve">
          <source>Parsing:</source>
          <target state="translated">Parsing:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="78567b320dd5ce717616b908847878e0a7b0a67c" translate="yes" xml:space="preserve">
          <source>Please do something like this:</source>
          <target state="translated">다음과 같이하십시오 :</target>
        </trans-unit>
        <trans-unit id="2e3e17743adee6ed5daa287a499018808e01b737" translate="yes" xml:space="preserve">
          <source>Please follow the below steps.</source>
          <target state="translated">아래 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="06a02c250ba2e9a5ec6d861f17aa8cad8565b535" translate="yes" xml:space="preserve">
          <source>Pluggable Custom Validation support - Keys/Values can be validated by configuring custom validators as and when encountered</source>
          <target state="translated">플러그 형 사용자 정의 유효성 검사 지원-발생시 및 사용자 정의 유효성 검사기를 구성하여 키 / 값을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f53753a64b29e001d0ac82c818162cc4fdeacc" translate="yes" xml:space="preserve">
          <source>Quick takeaway of the benchmark: &lt;strong&gt;Jackson&lt;/strong&gt; performs 5 to 6 times better than org.json and more than twice better than GSON.</source>
          <target state="translated">벤치 마크의 빠른 채택 : &lt;strong&gt;Jackson&lt;/strong&gt; 은 org.json보다 5-6 배, GSON보다 2 배 더 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="5196b11c8315c8990c058efb8fc0fb14bee4e072" translate="yes" xml:space="preserve">
          <source>Raises developer friendly and easy to trace exceptions</source>
          <target state="translated">개발자에게 친숙하고 예외를 추적하기 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a7b6bb6b6a7622460165f03ea7d746ba932816dd" translate="yes" xml:space="preserve">
          <source>Read the following blog post, &lt;a href=&quot;http://javahai.blogspot.in/2016/03/create-java-object-from-json-string.html&quot;&gt;JSON in Java&lt;/a&gt;.</source>
          <target state="translated">다음 블로그 게시물 인 &lt;a href=&quot;http://javahai.blogspot.in/2016/03/create-java-object-from-json-string.html&quot;&gt;Java의 JSON을&lt;/a&gt; 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="9ba33b97f81c7d33f86a74e8b5ced42856b9b058" translate="yes" xml:space="preserve">
          <source>Remember to import the library in the app Gradle file</source>
          <target state="translated">앱 Gradle 파일에서 라이브러리를 가져와야 함</target>
        </trans-unit>
        <trans-unit id="8f09413ed3181ec583f8fe8a75d11dd2246abc05" translate="yes" xml:space="preserve">
          <source>Requires JDK 1.5</source>
          <target state="translated">JDK 1.5 필요</target>
        </trans-unit>
        <trans-unit id="aeac71ea0fd2ec62ec82e35cfa2b5656823dc3f1" translate="yes" xml:space="preserve">
          <source>Retrieve just one needed attribute</source>
          <target state="translated">필요한 속성 하나만 검색</target>
        </trans-unit>
        <trans-unit id="747797349181f1717cb1e6154cba08113cc22a2d" translate="yes" xml:space="preserve">
          <source>Running the call a million times using &lt;strong&gt;Nashorn&lt;/strong&gt; takes 7.5~7.8 seconds</source>
          <target state="translated">&lt;strong&gt;Nashorn을&lt;/strong&gt; 사용하여 백만 번 전화를 걸려면 7.5 ~ 7.8 초 소요</target>
        </trans-unit>
        <trans-unit id="6d5f28546a36aa1ca02116c9ecd7d308a81aec26" translate="yes" xml:space="preserve">
          <source>Sample data:</source>
          <target state="translated">샘플 데이터 :</target>
        </trans-unit>
        <trans-unit id="f984f1b22f545290ce43e2c70ffa6a52b1e2353c" translate="yes" xml:space="preserve">
          <source>Since nobody mentioned it yet, here is a beginning of a solution using &lt;a href=&quot;http://openjdk.java.net/projects/nashorn/&quot;&gt;Nashorn&lt;/a&gt; (JavaScript runtime part of Java 8, but deprecated in Java 11).</source>
          <target state="translated">아무도 그것을 언급하지 않았으므로 다음은 &lt;a href=&quot;http://openjdk.java.net/projects/nashorn/&quot;&gt;Nashorn&lt;/a&gt; (Java 8의 JavaScript 런타임 부분이지만 Java 11에서는 더 이상 사용되지 않음)을 사용하는 솔루션의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="65201ee692e303421c8629f7432b4ea90f8187bb" translate="yes" xml:space="preserve">
          <source>So basically to use it, add it to your project, eg:</source>
          <target state="translated">기본적으로 사용하려면 프로젝트에 다음과 같이 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fa4cda1b6f05e89b3e0fb913778da8d50fea28cf" translate="yes" xml:space="preserve">
          <source>So this is the JSON returned by Google Translate API:</source>
          <target state="translated">Google 번역 API에서 반환 한 JSON입니다.</target>
        </trans-unit>
        <trans-unit id="61b0bb62aebfcdd9ea3216424e2be71fc16d3f18" translate="yes" xml:space="preserve">
          <source>So we have to create three different POJO classes;</source>
          <target state="translated">따라서 우리는 세 가지 POJO 클래스를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b15f607ce4802b8168dc099d186021a765ea7ae" translate="yes" xml:space="preserve">
          <source>Specifically for JSON libraries (and any serialization/deserialization libs), databinding is also usually of interest as it removes the need of writing boiler-plate code to pack/unpack the data.</source>
          <target state="translated">특히 JSON 라이브러리 (및 모든 직렬화 / 직렬화 라이브러리)의 경우 데이터 바인딩은 데이터를 포장 / 포장 풀기 위해 보일러 플레이트 코드를 작성할 필요가 없으므로 일반적으로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c4a8ec5fbf826704a452d2ff8dc55a69f8d01117" translate="yes" xml:space="preserve">
          <source>Step 1: Create a POJO class of your data.</source>
          <target state="translated">1 단계 : 데이터의 POJO 클래스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f256c7c1bed808e53ff3cb16960966d3aaf1e80d" translate="yes" xml:space="preserve">
          <source>Step 2: Now create a object using JSON.</source>
          <target state="translated">2 단계 : 이제 JSON을 사용하여 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f0fcfae11fa1883d14c0d9809e80909475c86ff6" translate="yes" xml:space="preserve">
          <source>Support for JSON Generation through object serialisation</source>
          <target state="translated">객체 직렬화를 통한 JSON 생성 지원</target>
        </trans-unit>
        <trans-unit id="7eb03cadb2fc7eb966c242ad99350591d8b0f6d8" translate="yes" xml:space="preserve">
          <source>Support for collection type selection during parsing process</source>
          <target state="translated">파싱 ​​과정에서 수집 유형 선택 지원</target>
        </trans-unit>
        <trans-unit id="afac24cd0f87a58c47d5ce59dda54327482583d2" translate="yes" xml:space="preserve">
          <source>Support for two types of configuration (JSON/XML) for using quick-JSON validating parser</source>
          <target state="translated">quick-JSON 유효성 검증 파서를 사용하기위한 두 가지 유형의 구성 (JSON / XML) 지원</target>
        </trans-unit>
        <trans-unit id="d83e899da1f3b82cb28cd3141bdeff7abe873c2c" translate="yes" xml:space="preserve">
          <source>Supports Flexible/Configurable parsing approach</source>
          <target state="translated">유연하고 구성 가능한 구문 분석 방식 지원</target>
        </trans-unit>
        <trans-unit id="50a6c9deb20f64043205b5e165c63d8709b1e139" translate="yes" xml:space="preserve">
          <source>That is it! In addition to that here is a &lt;a href=&quot;http://dew.apidesign.org/dew/#7138581&quot;&gt;live gist&lt;/a&gt; showing similar example together with asynchronous network communication.</source>
          <target state="translated">그게 다야! 그 외에도 비동기 네트워크 통신과 함께 유사한 예를 보여주는 &lt;a href=&quot;http://dew.apidesign.org/dew/#7138581&quot;&gt;라이브 요지&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e948eed3f7c58d6a508c2ea8ef03c2e28ca93572" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.jsonschema2pojo.org/&quot;&gt;jsonschema2pojo.org&lt;/a&gt; for GSON generated:</source>
          <target state="translated">GSON 용 &lt;a href=&quot;http://www.jsonschema2pojo.org/&quot;&gt;jsonschema2pojo.org는 다음&lt;/a&gt; 을 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="e2c1a81b0b1db4f644b2eaf11f5657efbdc2422c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/stleary/JSON-java&quot;&gt;org.json&lt;/a&gt; library is easy to use. Example code below:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/stleary/JSON-java&quot;&gt;org.json&lt;/a&gt; 라이브러리는 사용하기 쉽습니다. 아래 예제 코드 :</target>
        </trans-unit>
        <trans-unit id="a4a83b11267f4452d16f9ed523cdf2d6db64dafa" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Java API for JSON Processing (JSR 353)&lt;/strong&gt; provides portable APIs to parse, generate, transform, and query JSON using object model and streaming APIs.</source>
          <target state="translated">&lt;strong&gt;JSON 처리 용 Java API (JSR 353)&lt;/strong&gt; 는 객체 모델 및 스트리밍 API를 사용하여 JSON을 구문 분석, 생성, 변환 및 쿼리 할 수있는 이식 가능한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7952a2393450285e76fd98aa15897de2bc703396" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;reference implementation&lt;/strong&gt; is here: &lt;a href=&quot;https://jsonp.java.net/&quot;&gt;https://jsonp.java.net/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참조 구현&lt;/strong&gt; 은 다음과 같습니다. &lt;a href=&quot;https://jsonp.java.net/&quot;&gt;https://jsonp.java.net/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5728e0be6d0ee1ae0d0ddf88386b3d07df6e2a14" translate="yes" xml:space="preserve">
          <source>The below example shows how to read the text in the question, represented as the &quot;jsonText&quot; variable.  This solution uses the Java EE7 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/json/package-summary.html&quot;&gt;javax.json&lt;/a&gt; API (which is mentioned in some of the other answers).  The reason I've added it as a separate answer is that the following code shows how to &lt;em&gt;actually&lt;/em&gt; access some of the values shown in the question.  An &lt;a href=&quot;https://jsonp.java.net/download.html&quot;&gt;implementation of the javax.json API&lt;/a&gt; would be required to make this code run.  The full package for each of the classes required was included as I didn't want to declare &quot;import&quot; statements.</source>
          <target state="translated">아래 예제는 &quot;jsonText&quot;변수로 표시되는 질문의 텍스트를 읽는 방법을 보여줍니다. 이 솔루션은 Java EE7 &lt;a href=&quot;http://docs.oracle.com/javaee/7/api/javax/json/package-summary.html&quot;&gt;javax.json&lt;/a&gt; API (다른 답변 중 일부에서 언급)를 사용합니다. 별도의 답변으로 추가 한 이유는 다음 코드는 질문에 표시된 일부 값에 &lt;em&gt;실제로&lt;/em&gt; 액세스하는 방법을 보여주기 때문입니다. 이 코드를 실행 &lt;a href=&quot;https://jsonp.java.net/download.html&quot;&gt;하려면 javax.json API를 구현&lt;/a&gt; 해야합니다. &quot;import&quot;문을 선언하고 싶지 않기 때문에 필요한 각 클래스에 대한 전체 패키지가 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="f5634c0efba44765ff890cad41d8be7ab547400a" translate="yes" xml:space="preserve">
          <source>The most notorious ones are: Jackson, GSON, Genson, FastJson and org.json.</source>
          <target state="translated">가장 악명 높은 것은 Jackson, GSON, Genson, FastJson 및 org.json입니다.</target>
        </trans-unit>
        <trans-unit id="23fffe987d93f66048ec9ac769e5dd36c834f920" translate="yes" xml:space="preserve">
          <source>The only package I've used is Jackson ObjectMapper, what we do is binding data;</source>
          <target state="translated">내가 사용한 유일한 패키지는 Jackson ObjectMapper입니다. 우리가하는 일은 데이터 바인딩입니다.</target>
        </trans-unit>
        <trans-unit id="808091f429ed669a8665cfed3ed98b2d4c2f6f6e" translate="yes" xml:space="preserve">
          <source>The required dependencies, the jar files is listed below;</source>
          <target state="translated">필수 종속성 인 jar 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fe5f9a38a375f6340eae1fa099d8dd1c4d26367" translate="yes" xml:space="preserve">
          <source>There are many JSON libraries available in Java.</source>
          <target state="translated">Java에는 많은 JSON 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7f393468d8ac71394cdc687baab38627b89b2c" translate="yes" xml:space="preserve">
          <source>There are many open source libraries present to parse JSON content to an object or just to read JSON values. Your requirement is just to read values and parsing it to custom object. So org.json library is enough in your case.</source>
          <target state="translated">JSON 컨텐츠를 오브젝트로 구문 분석하거나 JSON 값을 읽기 위해 존재하는 많은 오픈 소스 라이브러리가 있습니다. 요구 사항은 값을 읽고 사용자 정의 객체로 파싱하는 것입니다. 따라서 귀하의 경우 org.json 라이브러리로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="3beded183424f6ed0877466312d0466c173e267a" translate="yes" xml:space="preserve">
          <source>There are typically three things one should look at for choosing any library:</source>
          <target state="translated">일반적으로 라이브러리를 선택하기 위해 살펴 봐야 할 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ccd26c78ba65de44475356a712b29bac1c5371b" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;https://github.com/JaroslavTulach/incubator-netbeans-html4j/blob/examples/examples/jsonparse/README.md&quot;&gt;sample Maven project&lt;/a&gt; showing the usage. First of all it defines the structure:</source>
          <target state="translated">사용법을 보여주는 &lt;a href=&quot;https://github.com/JaroslavTulach/incubator-netbeans-html4j/blob/examples/examples/jsonparse/README.md&quot;&gt;샘플 Maven 프로젝트&lt;/a&gt; 가 있습니다. 우선 구조를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a84dada52a2d88cfaf4879a9ebff060f7ba639b3" translate="yes" xml:space="preserve">
          <source>These APIs actually follow the DOM/SAX parsing model of XML.</source>
          <target state="translated">이러한 API는 실제로 XML의 DOM / SAX 구문 분석 모델을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f283c6a2c2d8218ba8199b2fc76c55313954c0ec" translate="yes" xml:space="preserve">
          <source>This blew my mind with how easy it was. You can just pass a &lt;code&gt;String&lt;/code&gt; holding your JSON to the constructor of a JSONObject in the default org.json package.</source>
          <target state="translated">이것이 얼마나 쉬운 지 내 마음을 사로 잡았습니다. 기본 org.json 패키지에서 JSON을 보유한 &lt;code&gt;String&lt;/code&gt; 을 JSONObject의 생성자로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5993f0df1bb4be49ad42ceb63ecf7fd4d774f862" translate="yes" xml:space="preserve">
          <source>This post is a little bit old, but still I want to answer you question.</source>
          <target state="translated">이 게시물은 약간 낡았지만 여전히 질문에 대답하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="1744e31c7b17d23ecbea63ae91f72b82d93a03ec" translate="yes" xml:space="preserve">
          <source>Top answers on this page use too simple examples like object with one property (e.g. {name: value}). I think that still simple but real life example can help someone.</source>
          <target state="translated">이 페이지의 인기 답변은 하나의 속성을 가진 객체 (예 : {name : value})와 같은 너무 간단한 예제를 사용합니다. 나는 여전히 단순하지만 실제 사례가 누군가를 도울 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="e08928c6100c5f26a6c10dcf288c804025b48e95" translate="yes" xml:space="preserve">
          <source>Two possible approaches:</source>
          <target state="translated">두 가지 가능한 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="cc14179c743382808f9e74d4e9ec10a570710306" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/ralfstx/minimal-json&quot;&gt;minimal-json&lt;/a&gt; which is very fast and easy to use.
You can parse from String obj and Stream.</source>
          <target state="translated">매우 빠르고 사용하기 쉬운 &lt;a href=&quot;https://github.com/ralfstx/minimal-json&quot;&gt;minimal-json&lt;/a&gt; 을 사용하십시오. String obj 및 Stream에서 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4a7774e7a2a8f2cd9dd46a13350306f9b613c0" translate="yes" xml:space="preserve">
          <source>Use DSM to extract fields.</source>
          <target state="translated">DSM을 사용하여 필드를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="de80861d34aeb2ec7058638972e4a0316739e902" translate="yes" xml:space="preserve">
          <source>Use org.json library to parse it and create JsonObject:</source>
          <target state="translated">org.json 라이브러리를 사용하여 구문 분석하고 JsonObject를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d5ecf0ed037efb9183e2f08bdb08774b7852d7dc" translate="yes" xml:space="preserve">
          <source>Using this library you only need to create a model with the same JSON structure. Then the model is automatically filled in. You have to call your variables as your JSON keys, or use &lt;a href=&quot;https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/annotations/SerializedName.html&quot;&gt;&lt;code&gt;@SerializedName&lt;/code&gt;&lt;/a&gt; if you want to use different names.</source>
          <target state="translated">이 라이브러리를 사용하면 동일한 JSON 구조로 모델 만 작성하면됩니다. 그런 다음 모델이 자동으로 채워집니다. 변수를 JSON 키로 호출하거나 다른 이름을 사용하려면 &lt;a href=&quot;https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/annotations/SerializedName.html&quot;&gt; &lt;code&gt;@SerializedName&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce452f49a22173c844854192c968edd7b0ab91dd" translate="yes" xml:space="preserve">
          <source>Validating and Non-Validating parser support</source>
          <target state="translated">유효성 검사 및 유효성 검사가 아닌 파서 지원</target>
        </trans-unit>
        <trans-unit id="f56c314abd8f309e656f2b1afa4819e8b22a6b2a" translate="yes" xml:space="preserve">
          <source>We can use the JSONObject class to convert a JSON string to a JSON object,
and to iterate over the JSON object. Use the following code.</source>
          <target state="translated">JSONObject 클래스를 사용하여 JSON 문자열을 JSON 객체로 변환하고 JSON 객체를 반복 할 수 있습니다. 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d39e447fecdad1f90b83cab9cdabcd361a315fcd" translate="yes" xml:space="preserve">
          <source>What are the API that does implement JSR-353 (JSON)</source>
          <target state="translated">JSR-353 (JSON)을 구현하는 API 란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="494e0a51f1cb85162e2e1d6c23583e1a1c2940ad" translate="yes" xml:space="preserve">
          <source>You can also loop through the &quot;posts&quot; array as so:</source>
          <target state="translated">다음과 같이 &quot;posts&quot;배열을 반복 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2286851d16c9f677feb653c1051894fb28e1f3ee" translate="yes" xml:space="preserve">
          <source>You can generate model from JSON automatically using online tools like &lt;a href=&quot;http://www.jsonschema2pojo.org/&quot;&gt;this&lt;/a&gt;.</source>
          <target state="translated">이와 같은 온라인 도구를 사용하여 JSON에서 자동으로 모델을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22b2364e92a604b636eb1af775cc217bf949a8b" translate="yes" xml:space="preserve">
          <source>You can see a complete example here:</source>
          <target state="translated">여기에서 완전한 예를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3871d2c5232d22375b0eeb6345c2e283ed7f4bcb" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://mfatihercik.github.io/dsm&quot;&gt;DSM&lt;/a&gt; stream parsing library for parsing complex json and XML document. DSM parse data only once and not load all data into memory.</source>
          <target state="translated">복잡한 json 및 XML 문서를 구문 분석하기 위해 &lt;a href=&quot;https://mfatihercik.github.io/dsm&quot;&gt;DSM&lt;/a&gt; 스트림 구문 분석 라이브러리를 사용할 수 있습니다. DSM은 데이터를 한 번만 구문 분석하고 모든 데이터를 메모리에로드하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="51dae0bf3fc8f570a97d4e9a63b4e622ad88275b" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;JsonNode&lt;/code&gt; for a structured tree representation of your JSON string. It's part of the rock solid &lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;&lt;em&gt;jackson&lt;/em&gt; library&lt;/a&gt; which is omnipresent.</source>
          <target state="translated">JSON 문자열의 구조화 된 트리 표현에 &lt;code&gt;JsonNode&lt;/code&gt; 를 사용할 수 있습니다. 그것은 &lt;a href=&quot;https://github.com/FasterXML/jackson&quot;&gt;&lt;em&gt;전적으로&lt;/em&gt;&lt;/a&gt; 존재하는 견고한 &lt;em&gt;잭슨&lt;/em&gt; 라이브러리 의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="1739b37566f3eb9d69fdcaeff614eee0838dd678" translate="yes" xml:space="preserve">
          <source>You can use &lt;strong&gt;Jackson&lt;/strong&gt; libraries, for binding JSON String into &lt;strong&gt;POJO&lt;/strong&gt; (&lt;strong&gt;&lt;em&gt;Plain Old Java Object&lt;/em&gt;&lt;/strong&gt;) instances. POJO is simply a class with only private fields and public getter/setter methods. Jackson is going to traverse the methods (using &lt;strong&gt;reflection&lt;/strong&gt;), and maps the JSON object into the POJO instance as the field names of the class fits to the field names of the JSON object.</source>
          <target state="translated">JSON 문자열을 &lt;strong&gt;POJO&lt;/strong&gt; ( &lt;strong&gt;&lt;em&gt;Plain Old Java Object&lt;/em&gt;&lt;/strong&gt; ) 인스턴스에 바인딩하기 위해 &lt;strong&gt;Jackson&lt;/strong&gt; 라이브러리를 사용할 수 있습니다. POJO는 단순히 개인 필드와 공용 getter / setter 메소드 만있는 클래스입니다. Jackson은 &lt;strong&gt;리플렉션을&lt;/strong&gt; 사용하여 메소드를 탐색하고 클래스의 필드 이름이 JSON 오브젝트의 필드 이름에 맞으면 JSON 오브젝트를 POJO 인스턴스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="1833a7fcec164db264b95fc3f2c7116552f703f3" translate="yes" xml:space="preserve">
          <source>You can use &lt;strong&gt;Jayway JsonPath&lt;/strong&gt;. Below is a GitHub link with source code, pom details and good documentation.</source>
          <target state="translated">&lt;strong&gt;Jayway JsonPath&lt;/strong&gt; 를 사용할 수 있습니다. 아래는 소스 코드, pom 세부 정보 및 유용한 문서가 포함 된 GitHub 링크입니다.</target>
        </trans-unit>
        <trans-unit id="27feb53b95d6cc0a8e5dbfe7c29a6b57cd36577c" translate="yes" xml:space="preserve">
          <source>You can use the Gson Library to parse the JSON string.</source>
          <target state="translated">Gson Library를 사용하여 JSON 문자열을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829d83a3ff692e4b324b2503fa7e9625db4df88a" translate="yes" xml:space="preserve">
          <source>You could use &lt;a href=&quot;https://github.com/google/gson&quot;&gt;Google Gson&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/google/gson&quot;&gt;Google Gson을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f0351dcd2f2cc886942c22f5380be9b3d6b2ad" translate="yes" xml:space="preserve">
          <source>You may find more examples from: &lt;a href=&quot;http://theoryapp.com/parse-json-in-java/&quot;&gt;Parse JSON in Java&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://theoryapp.com/parse-json-in-java/&quot;&gt;Java에서 JSON 구문 분석&lt;/a&gt; 에서 더 많은 예제를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e15bb5c01e7dd56499e37c634cf791d3a519aee" translate="yes" xml:space="preserve">
          <source>`</source>
          <target state="translated">`</target>
        </trans-unit>
        <trans-unit id="c4c7bfd2eb4f931d7799bfe2622f04431fafc657" translate="yes" xml:space="preserve">
          <source>and from message object you can fetch any of its attribute.</source>
          <target state="translated">메시지 객체에서 속성을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf207c66af7e6aad1158ac914cd0992bc4f2b6bf" translate="yes" xml:space="preserve">
          <source>and then it uses the generated RepositoryInfo and Owner classes to parse the provided input stream and pick certain information up while doing that:</source>
          <target state="translated">그런 다음 생성 된 RepositoryInfo 및 Owner 클래스를 사용하여 제공된 입력 스트림을 구문 분석하고이를 수행하는 동안 특정 정보를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8e3d482d85fad29be0fda23ab59f7468fbda5329" translate="yes" xml:space="preserve">
          <source>and to use:</source>
          <target state="translated">그리고 사용하기 :</target>
        </trans-unit>
        <trans-unit id="5e9b496a0935b15e72709835275b0a4dd4c2a1c6" translate="yes" xml:space="preserve">
          <source>etc...</source>
          <target state="translated">etc...</target>
        </trans-unit>
        <trans-unit id="161f626fb46e32dc28bb28ba0e99d92b77a220a5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;jsonData&lt;/code&gt; is a string of json data.</source>
          <target state="translated">여기서 &lt;code&gt;jsonData&lt;/code&gt; 는 json 데이터의 문자열입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
