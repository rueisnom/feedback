<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2594829">
    <body>
      <group id="2594829">
        <trans-unit id="1c6a5257d744e2420b2921c8bcfebe68d4d2820c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/10894820/27535&quot;&gt;GROUP BY lname ORDER BY showing wrong results&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/10894820/27535&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GROUP BY lname ORDER BY показывает неправильные результаты&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0238f8b56573de09dc82c15d60bad12db85f2749" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/6060241/which-is-the-least-expensive-aggregate-function-in-the-absence-of-any/6060414#6060414&quot;&gt;Which is the least expensive aggregate function in the absence of ANY()&lt;/a&gt; (see comments in accepted answer).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6060241/which-is-the-least-expensive-aggregate-function-in-the-absence-of-any/6060414#6060414&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Какая самая дешевая агрегатная функция при отсутствии ЛЮБОЙ ()&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (см. Комментарии в принятом ответе).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e9ce3614e4d4e4551d397b5bc4c9de9d8367ddc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Be aware of larger amounts of records, it can cause performance problems.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Помните о большем количестве записей, это может вызвать проблемы с производительностью.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13db3828e4af3aeff81d8e952c517fa58f8b307c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;To delete records whose names are duplicate&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Удалить записи, имена которых повторяются&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="570a1ed4908a4a1c9cdd190860329fb9bbfddfdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By Using CTE also we can find duplicate value like this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используя CTE, мы также можем найти двойное значение&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c5f5adfe3919456393ad72929b72a73d08366f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The only issue is that you have to execute the request until there is no rows deleted, since you delete only 1 of each duplicate each time</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Единственная проблема заключается в том, что вам нужно выполнить запрос, пока не будет удалено ни одной строки, поскольку каждый раз удаляется только 1 из каждого дубликата.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7b5fe3a6ad95659c742298d48161ff7aa539f7c" translate="yes" xml:space="preserve">
          <source>A little late to the party but I found a really cool workaround to finding all duplicate IDs:</source>
          <target state="translated">Немного поздновато для вечеринки,но я нашел действительно классный обходной путь,чтобы найти все дубликаты удостоверений личности:</target>
        </trans-unit>
        <trans-unit id="4b430d0f0454771bb7d933922c67e014494f6d46" translate="yes" xml:space="preserve">
          <source>And so to delete:</source>
          <target state="translated">И так,чтобы удалить:</target>
        </trans-unit>
        <trans-unit id="3aa6bdcb7b7c3981c486c552a73308c7bf54ebd3" translate="yes" xml:space="preserve">
          <source>Delete duplicates:</source>
          <target state="translated">Удалить дубликаты:</target>
        </trans-unit>
        <trans-unit id="3906fee90884268405b4ca4c5b44cfba4dbdf866" translate="yes" xml:space="preserve">
          <source>Especially good in your case If you search for duplicates who have some kind of prefix or general change like e.g.  new domain in mail. then you can use replace() at these columns</source>
          <target state="translated">Особенно хорошо в вашем случае,если вы ищете дубликаты,которые имеют какой-то префикс или общие изменения,как,например,новый домен в почте.тогда вы можете использовать replace()в этих столбцах</target>
        </trans-unit>
        <trans-unit id="5981cfb0e4a79ef06e307a857eface8d304cc4d6" translate="yes" xml:space="preserve">
          <source>Finding duplicate values in a SQL table</source>
          <target state="translated">Поиск дублирующих значений в таблице SQL</target>
        </trans-unit>
        <trans-unit id="0be482890002d4bc76c54671d7c966d69b79e35c" translate="yes" xml:space="preserve">
          <source>Here as two fields id_account and data are used with Count(*). So, it will give all the records which has more than one times same values in both columns.</source>
          <target state="translated">Здесь в качестве двух полей для Count(*)используются id_account и данные.Таким образом,он выдаст все записи,которые имеют более чем в один раз одинаковые значения в обоих столбцах.</target>
        </trans-unit>
        <trans-unit id="af9cbf623831c21dc2b4273e9c743ca01005ae21" translate="yes" xml:space="preserve">
          <source>Here we have taken all the distinct records of the orignal table and deleted the records of original table. Again we inserted all the distinct values from new table to the original table and then deleted new table.</source>
          <target state="translated">Здесь мы взяли все отдельные записи исходной таблицы и удалили записи исходной таблицы.Опять же мы вставили все отдельные значения из новой таблицы в исходную,а затем удалили новую таблицу.</target>
        </trans-unit>
        <trans-unit id="e2a7e5ab611eb85f5989aef3a3f23ae16ed24a88" translate="yes" xml:space="preserve">
          <source>How to get duplicate record in table</source>
          <target state="translated">Как получить дубликат записи в таблице</target>
        </trans-unit>
        <trans-unit id="83b895861c8acb25751dc227067e64455958cf16" translate="yes" xml:space="preserve">
          <source>How we can count the duplicated values??
either it is repeated 2 times or greater than 2.
just count them, not group wise.</source>
          <target state="translated">Как мы можем считать дублирующиеся значения?? Повторяется 2 раза или больше 2.Просто считай их,а не групповой мудростью.</target>
        </trans-unit>
        <trans-unit id="65fd299f3dc90f6eaa8e5f70e0a5c003e96aa1a0" translate="yes" xml:space="preserve">
          <source>However, what I want is to get duplicates with the same &lt;code&gt;email&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако я хочу получить дубликаты с тем же &lt;/font&gt;&lt;/font&gt; &lt;code&gt;email&lt;/code&gt; &lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0091c066cdee44ffeb95662adeead680c29540fa" translate="yes" xml:space="preserve">
          <source>I think this will work properly to search repeated values in a particular column.</source>
          <target state="translated">Я думаю,что это сработает правильно для поиска повторяющихся значений в конкретной колонке.</target>
        </trans-unit>
        <trans-unit id="7625c3bfcbe319380c25a3a06c4260c32e5c0977" translate="yes" xml:space="preserve">
          <source>If you want to delete the duplicates, here's a much simpler way to do it than having to find even/odd rows into a triple sub-select:</source>
          <target state="translated">Если вы хотите удалить дубликаты,то вот гораздо более простой способ сделать это,чем находить четные строки в тройном подвыборе:</target>
        </trans-unit>
        <trans-unit id="c8cf2b66ef3e9c8d50d8faa7c9299b1aeaf523ad" translate="yes" xml:space="preserve">
          <source>If you want to find duplicate data (by one or several criterias) and select the actual rows.</source>
          <target state="translated">Если Вы хотите найти дубликаты данных (по одной или нескольким критериям)и выбрать актуальные строки.</target>
        </trans-unit>
        <trans-unit id="9cfd22f5e6b4c3374b413fd4bb1c3acd06929f1b" translate="yes" xml:space="preserve">
          <source>If you wish to see if there is any duplicate rows in your table, I used below Query:</source>
          <target state="translated">Если вы хотите посмотреть,есть ли в вашей таблице дубликаты строк,я использовал ниже Запрос:</target>
        </trans-unit>
        <trans-unit id="d1a624a982a9eb83b785ef645d1d71ca13361fd1" translate="yes" xml:space="preserve">
          <source>In case you work with Oracle, this way would be preferable:</source>
          <target state="translated">В случае,если вы работаете с Oracle,этот способ был бы предпочтительнее:</target>
        </trans-unit>
        <trans-unit id="23b0e0cf495e92c3524d9d4f01c5961ecb7429eb" translate="yes" xml:space="preserve">
          <source>In relational database theory, a functional dependency is a constraint between two sets of attributes in a relation from a database. In other words, functional dependency is a constraint that describes the relationship between attributes in a relation.</source>
          <target state="translated">В реляционной теории БД функциональная зависимость-это ограничение между двумя наборами атрибутов в соотношении от БД.Другими словами,функциональная зависимость-это ограничение,описывающее связь между атрибутами в соотношении.</target>
        </trans-unit>
        <trans-unit id="0a1c658846d0a3407c25bc061848777626844f9c" translate="yes" xml:space="preserve">
          <source>In the latter case you would use:</source>
          <target state="translated">В последнем случае вы бы использовали:</target>
        </trans-unit>
        <trans-unit id="c9e57fd70c36dee822217daeed989c4ab3bcb8b2" translate="yes" xml:space="preserve">
          <source>It's easy to find duplicates with one field:</source>
          <target state="translated">Легко найти дубликаты с одним полем:</target>
        </trans-unit>
        <trans-unit id="25fca9d70ffb940b7caba5182e1f9183cf456a9f" translate="yes" xml:space="preserve">
          <source>Much more easier to read and understand IMHO</source>
          <target state="translated">Гораздо легче читать и понимать ИМХО</target>
        </trans-unit>
        <trans-unit id="58186c85aba05734a940a8e5decb95377fbda2e9" translate="yes" xml:space="preserve">
          <source>MySQL is unpredictable and you need &lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL непредсказуем, и вам нужно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1b90964c12aab0c57b994118084fd915a7698f8" translate="yes" xml:space="preserve">
          <source>Note: the older ANSI standard is to have all non-aggregated columns in the GROUP BY but this has changed with the idea of &lt;a href=&quot;https://blog.jooq.org/2015/12/10/sql-group-by-and-functional-dependencies-a-very-useful-feature/&quot;&gt;&quot;functional dependency&quot;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание: более старый стандарт ANSI должен иметь все неагрегированные столбцы в GROUP BY, но это изменилось с идеей &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blog.jooq.org/2015/12/10/sql-group-by-and-functional-dependencies-a-very-useful-feature/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;функциональной зависимости&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0a7d98a17c7e3d1315cdf1e4024b71e84be895" translate="yes" xml:space="preserve">
          <source>OUTPUT:</source>
          <target state="translated">OUTPUT:</target>
        </trans-unit>
        <trans-unit id="c643ba8ada420a6ec8fc78cf14b248ecf163f73a" translate="yes" xml:space="preserve">
          <source>Oracle isn't mainstream enough (warning: humour, I don't know about Oracle).</source>
          <target state="translated">Оракул недостаточно распространен (предупреждение:юмор,я не знаю об Оракуле).</target>
        </trans-unit>
        <trans-unit id="6ad8a89242a82251234ae10f39281bd0ff16a9b4" translate="yes" xml:space="preserve">
          <source>Recent PostgreSQL &lt;a href=&quot;https://www.postgresql.org/docs/current/static/sql-select.html#SQL-GROUPBY&quot;&gt;supports it&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Недавние PostgreSQL &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/static/sql-select.html#SQL-GROUPBY&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поддерживают это&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5036313ab8db114c5af9161e52a891869bdc1ae" translate="yes" xml:space="preserve">
          <source>SQL Server (as at SQL Server 2017) still requires all non-aggregated columns in the GROUP BY.</source>
          <target state="translated">SQL Server (как и на SQL Server 2017)по-прежнему требует наличия всех не дезагрегированных столбцов в GROUP BY.</target>
        </trans-unit>
        <trans-unit id="3ad231b064b86a139e73e3838ca4c9f9c548cefc" translate="yes" xml:space="preserve">
          <source>Select duplicates:</source>
          <target state="translated">Выберите дубликаты:</target>
        </trans-unit>
        <trans-unit id="557f054a10806c8c4576cb3f0f0718b7136d722b" translate="yes" xml:space="preserve">
          <source>Simply group on both of the columns.</source>
          <target state="translated">Просто сгруппируйтесь по обеим колонкам.</target>
        </trans-unit>
        <trans-unit id="ee993e268a474e69cf34af320a29d1399a24603a" translate="yes" xml:space="preserve">
          <source>So if we have a table</source>
          <target state="translated">Так что,если у нас есть столик</target>
        </trans-unit>
        <trans-unit id="c3c4213aacace63da77cde08a2a83c8805a26750" translate="yes" xml:space="preserve">
          <source>Support is not consistent:</source>
          <target state="translated">Поддержка не последовательна:</target>
        </trans-unit>
        <trans-unit id="104764e68bf3e4a3b929296848cd6c0cab29e52d" translate="yes" xml:space="preserve">
          <source>That is, I want to get &quot;Tom&quot;, &quot;Tom&quot;.</source>
          <target state="translated">То есть,я хочу получить &quot;Том&quot;,&quot;Том&quot;.</target>
        </trans-unit>
        <trans-unit id="f19616c0d92c1a3ac0a9d563833b7f961e80e06f" translate="yes" xml:space="preserve">
          <source>The exact code would differ depending on whether you want to find duplicate rows as well or only different ids with the same email and name. If id is a primary key or otherwise has a unique constraint this distinction does not exist, but the question does not specify this. In the former case you can use code given in several other answers:</source>
          <target state="translated">Точный код будет отличаться в зависимости от того,хотите ли вы найти дубликаты строк или только разные идентификаторы с одним и тем же электронным адресом и именем.Если идентификатор является первичным ключом или иным образом имеет уникальное ограничение,то такого различия не существует,но в вопросе это не уточняется.В первом случае можно использовать код,приведенный в нескольких других ответах:</target>
        </trans-unit>
        <trans-unit id="5b6a0e5d262d613602661c93c43792ebe98fb342" translate="yes" xml:space="preserve">
          <source>The reason I need this: I made a mistake, and allowed to insert duplicate &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; values. Now I need to remove/change the duplicates, so I need to &lt;em&gt;find&lt;/em&gt; them first.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Причина, по которой мне это нужно: я допустил ошибку и позволил вставить дубликаты &lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;email&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь мне нужно удалить / изменить дубликаты, поэтому мне нужно &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сначала &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;найти&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; их.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ea31861b4d48aede781db6806820ecc99328424" translate="yes" xml:space="preserve">
          <source>This example finds all students with duplicate name and dob.  The fields you want to check for duplication go in the OVER clause.  You can include any other fields you want in the projection.</source>
          <target state="translated">В этом примере найдены все ученики с дублирующимися именами и добром.Поля,которые вы хотите проверить на дублирование,идут в пункте OVER.Вы можете включить в проекцию любые другие поля.</target>
        </trans-unit>
        <trans-unit id="17d15f999d0cb00550a560028471e2703c146662" translate="yes" xml:space="preserve">
          <source>This is the easy thing I've come up with.  It uses a common table expression (CTE) and a partition window (I think these features are in SQL 2008 and later).</source>
          <target state="translated">Это самая простая вещь,которую я придумал.Он использует общее табличное выражение (CTE)и окно раздела (думаю,эти возможности есть в SQL 2008 и более поздних версиях).</target>
        </trans-unit>
        <trans-unit id="6ac431721684a4e14dbd6c86e71ded4286d4ba74" translate="yes" xml:space="preserve">
          <source>This query will give us John, Sam, Tom, Tom because they all have the same &lt;code&gt;email&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот запрос даст нам Джон, Сэм, Том, Том, потому что у них всех одинаковый &lt;/font&gt;&lt;/font&gt; &lt;code&gt;email&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f853357b14c2d5243bbbec650ec1b811b7cf2dfd" translate="yes" xml:space="preserve">
          <source>This selects/deletes all duplicate records except one record from each group of duplicates. So, the delete leaves all unique records + one record from each group of the duplicates.</source>
          <target state="translated">При этом выбираются все дубликаты записей,за исключением одной записи из каждой группы дубликатов.Таким образом,удаляются все уникальные записи+одна запись из каждой группы дубликатов.</target>
        </trans-unit>
        <trans-unit id="e65245a3c779a504e1de335ddaa3bf1e6b69afe2" translate="yes" xml:space="preserve">
          <source>This should also work, maybe give it try.</source>
          <target state="translated">Это тоже должно сработать,может,попробовать.</target>
        </trans-unit>
        <trans-unit id="bfc6b51ed567a3a8facb8ed523fc0a7a2b243284" translate="yes" xml:space="preserve">
          <source>To Check From duplicate Record in a table.</source>
          <target state="translated">Чтобы установить флажок &quot;Из дубликата записи в таблице&quot;.</target>
        </trans-unit>
        <trans-unit id="c952fd0a06bd6e3ab4cb95dfaa1d52be7a10ea44" translate="yes" xml:space="preserve">
          <source>To Delete the duplicate record in a table.</source>
          <target state="translated">Удалить дубликат записи в таблице.</target>
        </trans-unit>
        <trans-unit id="4510f5867cf6eaea1ba0c494802f5d3ab46f343e" translate="yes" xml:space="preserve">
          <source>Try the following:</source>
          <target state="translated">Попробуйте следующее:</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">Попробуй это:</target>
        </trans-unit>
        <trans-unit id="5f9268ec5dce45e6c8c7817a882ad9895532e389" translate="yes" xml:space="preserve">
          <source>We can use having here which work on aggregate functions as shown below</source>
          <target state="translated">Мы можем использовать,имея здесь,которые работают на агрегатных функциях,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="0f76725438b711edfaaf751d7899d75eca40c6ab" translate="yes" xml:space="preserve">
          <source>We some reason mistakely we had missed to add any constraints in SQL server table and the records has been inserted duplicate in all columns with front-end application. Then we can use below query to delete duplicate query from table.</source>
          <target state="translated">Мы по какой-то причине по ошибке пропустили добавление каких-либо ограничений в таблицу SQL-сервера,и записи были вставлены дубликатом во все столбцы с внешним приложением.Тогда мы можем использовать нижеприведенный запрос для удаления дубликата из таблицы.</target>
        </trans-unit>
        <trans-unit id="fc0e54c3e91f8ea2fbcd8fb339c9358928cbd82f" translate="yes" xml:space="preserve">
          <source>You can use the SELECT DISTINCT keyword to get rid of duplicates. You can also filter by name and get everyone with that name on a table.</source>
          <target state="translated">Вы можете использовать ключевое слово SELECT DISTINCT,чтобы избавиться от дубликатов.Вы также можете отфильтровать по имени и получить всех,у кого есть это имя на столе.</target>
        </trans-unit>
        <trans-unit id="11c1360fc0d0c9562ba8030225025163aa2587bf" translate="yes" xml:space="preserve">
          <source>You may want to try this</source>
          <target state="translated">Возможно,вы захотите попробовать</target>
        </trans-unit>
        <trans-unit id="f49f79beaf7e0f7d8e61f921a8deeddcfabaf792" translate="yes" xml:space="preserve">
          <source>as simple as</source>
          <target state="translated">простодушный</target>
        </trans-unit>
        <trans-unit id="17e2cc32ba8d2147e1e6dd0b12f8f5e854ef8830" translate="yes" xml:space="preserve">
          <source>if you want the IDs of the dups use this:</source>
          <target state="translated">если ты хочешь,чтобы идентификаторы дупов использовали это:</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="82a89a7452323716b3c7503208a513b218a8fa7c" translate="yes" xml:space="preserve">
          <source>to delete the duplicates try:</source>
          <target state="translated">чтобы удалить дубликаты,попробуйте:</target>
        </trans-unit>
        <trans-unit id="17165e628cc7ca6fba83c95203bbff81806c798b" translate="yes" xml:space="preserve">
          <source>try this code</source>
          <target state="translated">пробовать этот код</target>
        </trans-unit>
        <trans-unit id="ebd2ac596898afb00e2eed332592daffeeae55e5" translate="yes" xml:space="preserve">
          <source>try this:</source>
          <target state="translated">Попробуй это:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
