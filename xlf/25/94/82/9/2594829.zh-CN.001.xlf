<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2594829">
    <body>
      <group id="2594829">
        <trans-unit id="1c6a5257d744e2420b2921c8bcfebe68d4d2820c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/10894820/27535&quot;&gt;GROUP BY lname ORDER BY showing wrong results&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/10894820/27535&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GROUP BY lname ORDER BY显示错误的结果&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0238f8b56573de09dc82c15d60bad12db85f2749" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/questions/6060241/which-is-the-least-expensive-aggregate-function-in-the-absence-of-any/6060414#6060414&quot;&gt;Which is the least expensive aggregate function in the absence of ANY()&lt;/a&gt; (see comments in accepted answer).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/6060241/which-is-the-least-expensive-aggregate-function-in-the-absence-of-any/6060414#6060414&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在没有ANY（）的情况下，这是最便宜的聚合函数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（请参见接受的答案中的注释）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e9ce3614e4d4e4551d397b5bc4c9de9d8367ddc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Be aware of larger amounts of records, it can cause performance problems.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意大量的记录，这可能会导致性能问题。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13db3828e4af3aeff81d8e952c517fa58f8b307c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;To delete records whose names are duplicate&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;删除名称重复的记录&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="570a1ed4908a4a1c9cdd190860329fb9bbfddfdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By Using CTE also we can find duplicate value like this&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过使用CTE，我们也可以找到类似的重复值&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c5f5adfe3919456393ad72929b72a73d08366f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The only issue is that you have to execute the request until there is no rows deleted, since you delete only 1 of each duplicate each time</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一的问题是您必须执行请求，直到没有删除的行为止，因为每次都只删除每个重复项中的1个&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7b5fe3a6ad95659c742298d48161ff7aa539f7c" translate="yes" xml:space="preserve">
          <source>A little late to the party but I found a really cool workaround to finding all duplicate IDs:</source>
          <target state="translated">有点晚了,但我找到了一个很酷的工作方法,可以找到所有重复的ID。</target>
        </trans-unit>
        <trans-unit id="4b430d0f0454771bb7d933922c67e014494f6d46" translate="yes" xml:space="preserve">
          <source>And so to delete:</source>
          <target state="translated">等到删除。</target>
        </trans-unit>
        <trans-unit id="3aa6bdcb7b7c3981c486c552a73308c7bf54ebd3" translate="yes" xml:space="preserve">
          <source>Delete duplicates:</source>
          <target state="translated">删除重复的内容。</target>
        </trans-unit>
        <trans-unit id="3906fee90884268405b4ca4c5b44cfba4dbdf866" translate="yes" xml:space="preserve">
          <source>Especially good in your case If you search for duplicates who have some kind of prefix or general change like e.g.  new domain in mail. then you can use replace() at these columns</source>
          <target state="translated">特别是在你的情况下,如果你搜索的是有前缀或一般变化的重复域名,如邮件中的新域名,那么你可以在这些列中使用替换()。</target>
        </trans-unit>
        <trans-unit id="5981cfb0e4a79ef06e307a857eface8d304cc4d6" translate="yes" xml:space="preserve">
          <source>Finding duplicate values in a SQL table</source>
          <target state="translated">在SQL表中寻找重复值</target>
        </trans-unit>
        <trans-unit id="0be482890002d4bc76c54671d7c966d69b79e35c" translate="yes" xml:space="preserve">
          <source>Here as two fields id_account and data are used with Count(*). So, it will give all the records which has more than one times same values in both columns.</source>
          <target state="translated">这里的id_account和data两个字段是用Count(*)来表示的。因此,它将给出所有在两个列中具有1倍以上相同值的记录。</target>
        </trans-unit>
        <trans-unit id="af9cbf623831c21dc2b4273e9c743ca01005ae21" translate="yes" xml:space="preserve">
          <source>Here we have taken all the distinct records of the orignal table and deleted the records of original table. Again we inserted all the distinct values from new table to the original table and then deleted new table.</source>
          <target state="translated">这里,我们把原表的所有不同记录都取了出来,然后删除了原表的记录。我们再次将新表中的所有不同值插入到原表中,然后删除新表。</target>
        </trans-unit>
        <trans-unit id="e2a7e5ab611eb85f5989aef3a3f23ae16ed24a88" translate="yes" xml:space="preserve">
          <source>How to get duplicate record in table</source>
          <target state="translated">如何获取表中的重复记录</target>
        </trans-unit>
        <trans-unit id="83b895861c8acb25751dc227067e64455958cf16" translate="yes" xml:space="preserve">
          <source>How we can count the duplicated values??
either it is repeated 2 times or greater than 2.
just count them, not group wise.</source>
          <target state="translated">重复的值怎么算呢,不是重复2次就是大于2次,只要算一下就可以了,不分组。</target>
        </trans-unit>
        <trans-unit id="65fd299f3dc90f6eaa8e5f70e0a5c003e96aa1a0" translate="yes" xml:space="preserve">
          <source>However, what I want is to get duplicates with the same &lt;code&gt;email&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt;&lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，我想要的是使用相同的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;email&lt;/code&gt; &lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获得重复项&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0091c066cdee44ffeb95662adeead680c29540fa" translate="yes" xml:space="preserve">
          <source>I think this will work properly to search repeated values in a particular column.</source>
          <target state="translated">我认为这样做可以适当地在某一列中搜索重复值。</target>
        </trans-unit>
        <trans-unit id="7625c3bfcbe319380c25a3a06c4260c32e5c0977" translate="yes" xml:space="preserve">
          <source>If you want to delete the duplicates, here's a much simpler way to do it than having to find even/odd rows into a triple sub-select:</source>
          <target state="translated">如果你想删除重复的行,这里有一个更简单的方法,比起在一个三重子选项中找双数行来的方法要简单得多。</target>
        </trans-unit>
        <trans-unit id="c8cf2b66ef3e9c8d50d8faa7c9299b1aeaf523ad" translate="yes" xml:space="preserve">
          <source>If you want to find duplicate data (by one or several criterias) and select the actual rows.</source>
          <target state="translated">如果你想找到重复的数据(通过一个或几个标准)并选择实际的行。</target>
        </trans-unit>
        <trans-unit id="9cfd22f5e6b4c3374b413fd4bb1c3acd06929f1b" translate="yes" xml:space="preserve">
          <source>If you wish to see if there is any duplicate rows in your table, I used below Query:</source>
          <target state="translated">如果你想看看你的表中是否有重复行,我用了下面的Query。</target>
        </trans-unit>
        <trans-unit id="d1a624a982a9eb83b785ef645d1d71ca13361fd1" translate="yes" xml:space="preserve">
          <source>In case you work with Oracle, this way would be preferable:</source>
          <target state="translated">如果你与甲骨文公司合作,这种方式比较好。</target>
        </trans-unit>
        <trans-unit id="23b0e0cf495e92c3524d9d4f01c5961ecb7429eb" translate="yes" xml:space="preserve">
          <source>In relational database theory, a functional dependency is a constraint between two sets of attributes in a relation from a database. In other words, functional dependency is a constraint that describes the relationship between attributes in a relation.</source>
          <target state="translated">在关系数据库理论中,功能依赖性是指数据库中的关系中的两组属性之间的约束。换句话说,功能依赖性是描述关系中属性之间的关系的约束。</target>
        </trans-unit>
        <trans-unit id="0a1c658846d0a3407c25bc061848777626844f9c" translate="yes" xml:space="preserve">
          <source>In the latter case you would use:</source>
          <target state="translated">在后一种情况下,你将使用:</target>
        </trans-unit>
        <trans-unit id="c9e57fd70c36dee822217daeed989c4ab3bcb8b2" translate="yes" xml:space="preserve">
          <source>It's easy to find duplicates with one field:</source>
          <target state="translated">用一个字段找重复的东西很容易。</target>
        </trans-unit>
        <trans-unit id="25fca9d70ffb940b7caba5182e1f9183cf456a9f" translate="yes" xml:space="preserve">
          <source>Much more easier to read and understand IMHO</source>
          <target state="translated">IMHO更容易阅读和理解</target>
        </trans-unit>
        <trans-unit id="58186c85aba05734a940a8e5decb95377fbda2e9" translate="yes" xml:space="preserve">
          <source>MySQL is unpredictable and you need &lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MySQL无法预测，您需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1b90964c12aab0c57b994118084fd915a7698f8" translate="yes" xml:space="preserve">
          <source>Note: the older ANSI standard is to have all non-aggregated columns in the GROUP BY but this has changed with the idea of &lt;a href=&quot;https://blog.jooq.org/2015/12/10/sql-group-by-and-functional-dependencies-a-very-useful-feature/&quot;&gt;&quot;functional dependency&quot;&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：较早的ANSI标准将在GROUP BY中包含所有非聚合的列，但是随着&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://blog.jooq.org/2015/12/10/sql-group-by-and-functional-dependencies-a-very-useful-feature/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;功能依赖&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的思想而改变了&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0a7d98a17c7e3d1315cdf1e4024b71e84be895" translate="yes" xml:space="preserve">
          <source>OUTPUT:</source>
          <target state="translated">OUTPUT:</target>
        </trans-unit>
        <trans-unit id="c643ba8ada420a6ec8fc78cf14b248ecf163f73a" translate="yes" xml:space="preserve">
          <source>Oracle isn't mainstream enough (warning: humour, I don't know about Oracle).</source>
          <target state="translated">甲骨文不够主流(警告:幽默,我不知道甲骨文)。</target>
        </trans-unit>
        <trans-unit id="6ad8a89242a82251234ae10f39281bd0ff16a9b4" translate="yes" xml:space="preserve">
          <source>Recent PostgreSQL &lt;a href=&quot;https://www.postgresql.org/docs/current/static/sql-select.html#SQL-GROUPBY&quot;&gt;supports it&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最近的PostgreSQL &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.postgresql.org/docs/current/static/sql-select.html#SQL-GROUPBY&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;支持它&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5036313ab8db114c5af9161e52a891869bdc1ae" translate="yes" xml:space="preserve">
          <source>SQL Server (as at SQL Server 2017) still requires all non-aggregated columns in the GROUP BY.</source>
          <target state="translated">SQL Server(截至SQL Server 2017年)仍然要求GROUP BY中的所有非汇总列。</target>
        </trans-unit>
        <trans-unit id="3ad231b064b86a139e73e3838ca4c9f9c548cefc" translate="yes" xml:space="preserve">
          <source>Select duplicates:</source>
          <target state="translated">选择复制。</target>
        </trans-unit>
        <trans-unit id="557f054a10806c8c4576cb3f0f0718b7136d722b" translate="yes" xml:space="preserve">
          <source>Simply group on both of the columns.</source>
          <target state="translated">只需在两列上进行分组即可。</target>
        </trans-unit>
        <trans-unit id="ee993e268a474e69cf34af320a29d1399a24603a" translate="yes" xml:space="preserve">
          <source>So if we have a table</source>
          <target state="translated">所以,如果我们有一个表</target>
        </trans-unit>
        <trans-unit id="c3c4213aacace63da77cde08a2a83c8805a26750" translate="yes" xml:space="preserve">
          <source>Support is not consistent:</source>
          <target state="translated">支持是不一致的。</target>
        </trans-unit>
        <trans-unit id="104764e68bf3e4a3b929296848cd6c0cab29e52d" translate="yes" xml:space="preserve">
          <source>That is, I want to get &quot;Tom&quot;, &quot;Tom&quot;.</source>
          <target state="translated">也就是说,我想得到 &quot;汤姆&quot;,&quot;汤姆&quot;。</target>
        </trans-unit>
        <trans-unit id="f19616c0d92c1a3ac0a9d563833b7f961e80e06f" translate="yes" xml:space="preserve">
          <source>The exact code would differ depending on whether you want to find duplicate rows as well or only different ids with the same email and name. If id is a primary key or otherwise has a unique constraint this distinction does not exist, but the question does not specify this. In the former case you can use code given in several other answers:</source>
          <target state="translated">确切的代码将取决于你是想找到重复的记录,还是只找到具有相同的电子邮件和姓名的不同id。如果id是一个主键或其他方面有一个唯一性的约束,那么这个区别就不存在,但问题中并没有指定。在前一种情况下,你可以使用其他几个答案中给出的代码。</target>
        </trans-unit>
        <trans-unit id="5b6a0e5d262d613602661c93c43792ebe98fb342" translate="yes" xml:space="preserve">
          <source>The reason I need this: I made a mistake, and allowed to insert duplicate &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; values. Now I need to remove/change the duplicates, so I need to &lt;em&gt;find&lt;/em&gt; them first.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我需要这个的原因：我犯了一个错误，并允许插入重复的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;email&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，我需要删除/更改重复项，因此需要首先&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;找到&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ea31861b4d48aede781db6806820ecc99328424" translate="yes" xml:space="preserve">
          <source>This example finds all students with duplicate name and dob.  The fields you want to check for duplication go in the OVER clause.  You can include any other fields you want in the projection.</source>
          <target state="translated">这个例子可以找到所有名字和学籍重复的学生。你想检查重复的字段在over子句中。你可以在投影中包含任何其他你想要的字段。</target>
        </trans-unit>
        <trans-unit id="17d15f999d0cb00550a560028471e2703c146662" translate="yes" xml:space="preserve">
          <source>This is the easy thing I've come up with.  It uses a common table expression (CTE) and a partition window (I think these features are in SQL 2008 and later).</source>
          <target state="translated">这是我想出的一个简单的东西。它使用了一个常用的表表达式(CTE)和一个分区窗口(我想这些功能都是在SQL 2008及以后的版本中)。</target>
        </trans-unit>
        <trans-unit id="6ac431721684a4e14dbd6c86e71ded4286d4ba74" translate="yes" xml:space="preserve">
          <source>This query will give us John, Sam, Tom, Tom because they all have the same &lt;code&gt;email&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该查询将为我们提供John，Sam，Tom，Tom，因为它们都具有相同的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;email&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f853357b14c2d5243bbbec650ec1b811b7cf2dfd" translate="yes" xml:space="preserve">
          <source>This selects/deletes all duplicate records except one record from each group of duplicates. So, the delete leaves all unique records + one record from each group of the duplicates.</source>
          <target state="translated">这个选择删除除了每组重复记录中的一条记录外,其他所有的重复记录都会被删除。所以,删除后,每组重复记录中的所有唯一记录+每组重复记录中的一条记录。</target>
        </trans-unit>
        <trans-unit id="e65245a3c779a504e1de335ddaa3bf1e6b69afe2" translate="yes" xml:space="preserve">
          <source>This should also work, maybe give it try.</source>
          <target state="translated">这个应该也可以,也许可以试试。</target>
        </trans-unit>
        <trans-unit id="bfc6b51ed567a3a8facb8ed523fc0a7a2b243284" translate="yes" xml:space="preserve">
          <source>To Check From duplicate Record in a table.</source>
          <target state="translated">要检查从表中的重复记录。</target>
        </trans-unit>
        <trans-unit id="c952fd0a06bd6e3ab4cb95dfaa1d52be7a10ea44" translate="yes" xml:space="preserve">
          <source>To Delete the duplicate record in a table.</source>
          <target state="translated">要删除表中的重复记录。</target>
        </trans-unit>
        <trans-unit id="4510f5867cf6eaea1ba0c494802f5d3ab46f343e" translate="yes" xml:space="preserve">
          <source>Try the following:</source>
          <target state="translated">试试下面的方法:</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
        <trans-unit id="5f9268ec5dce45e6c8c7817a882ad9895532e389" translate="yes" xml:space="preserve">
          <source>We can use having here which work on aggregate functions as shown below</source>
          <target state="translated">我们可以使用如下图所示的聚合函数的工作原理</target>
        </trans-unit>
        <trans-unit id="0f76725438b711edfaaf751d7899d75eca40c6ab" translate="yes" xml:space="preserve">
          <source>We some reason mistakely we had missed to add any constraints in SQL server table and the records has been inserted duplicate in all columns with front-end application. Then we can use below query to delete duplicate query from table.</source>
          <target state="translated">我们由于某种原因,我们在SQL服务器表中错过了添加任何约束条件,并且在前端程序中所有的记录都被重复插入了。那么我们可以用下面的查询来删除表中的重复查询。</target>
        </trans-unit>
        <trans-unit id="fc0e54c3e91f8ea2fbcd8fb339c9358928cbd82f" translate="yes" xml:space="preserve">
          <source>You can use the SELECT DISTINCT keyword to get rid of duplicates. You can also filter by name and get everyone with that name on a table.</source>
          <target state="translated">你可以使用SELECT DISTINCT关键字来删除重复的内容。你也可以通过名字来过滤,得到表上有这个名字的所有人。</target>
        </trans-unit>
        <trans-unit id="11c1360fc0d0c9562ba8030225025163aa2587bf" translate="yes" xml:space="preserve">
          <source>You may want to try this</source>
          <target state="translated">你可能想试试这个</target>
        </trans-unit>
        <trans-unit id="f49f79beaf7e0f7d8e61f921a8deeddcfabaf792" translate="yes" xml:space="preserve">
          <source>as simple as</source>
          <target state="translated">如同</target>
        </trans-unit>
        <trans-unit id="17e2cc32ba8d2147e1e6dd0b12f8f5e854ef8830" translate="yes" xml:space="preserve">
          <source>if you want the IDs of the dups use this:</source>
          <target state="translated">如果你想用这个ID来显示dups的ID。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="82a89a7452323716b3c7503208a513b218a8fa7c" translate="yes" xml:space="preserve">
          <source>to delete the duplicates try:</source>
          <target state="translated">要删除重复的内容,请尝试。</target>
        </trans-unit>
        <trans-unit id="17165e628cc7ca6fba83c95203bbff81806c798b" translate="yes" xml:space="preserve">
          <source>try this code</source>
          <target state="translated">试试这个代码</target>
        </trans-unit>
        <trans-unit id="ebd2ac596898afb00e2eed332592daffeeae55e5" translate="yes" xml:space="preserve">
          <source>try this:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
