<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/762011">
    <body>
      <group id="762011">
        <trans-unit id="fafcd2951a6c9ab9c6c43e67c5a38264f0cdd84a" translate="yes" xml:space="preserve">
          <source>... the loop unexpectedly outputs &quot;i is 5&quot; five times:</source>
          <target state="translated">...循环出人意料地输出 &quot;i是5&quot;5次。</target>
        </trans-unit>
        <trans-unit id="6d871bd011c025ac22e1d36c547f25316c14c79d" translate="yes" xml:space="preserve">
          <source>... the output remains unchanged as long as we stick with &lt;code&gt;let&lt;/code&gt;.  In contrast, if we had used &lt;code&gt;var i&lt;/code&gt; instead:</source>
          <target state="translated">...只要我们坚持 &lt;code&gt;let&lt;/code&gt; ，输出将保持不变。 相反，如果我们改用 &lt;code&gt;var i&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="43c75a7895bae9f2274a20daccd9c56125f42242" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;This table&lt;/a&gt; on Wikipedia shows which browsers support Javascript 1.7.</source>
          <target state="translated">维基百科上的&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;此表&lt;/a&gt;显示了哪些浏览器支持Javascript 1.7。</target>
        </trans-unit>
        <trans-unit id="0191d36331a7f5a9e5755b19f3d7de9c667f7b49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;My value: 3&lt;/code&gt; was output to console each time &lt;code&gt;funcs[j]();&lt;/code&gt; was invoked since anonymous functions were bound to the same variable.</source>
          <target state="translated">&lt;code&gt;My value: 3&lt;/code&gt; 每次 &lt;code&gt;funcs[j]();&lt;/code&gt; 都会输出3到控制台。 由于匿名函数绑定到同一变量，因此被调用。</target>
        </trans-unit>
        <trans-unit id="ccc17ff02fbc922f367c8a5b47195617bb23fb48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is a signal that the identifier won&amp;rsquo;t be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 是一个信号，它将不重新分配标识符。</target>
        </trans-unit>
        <trans-unit id="3308d036748c8401176277b68520b6bab4436169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is quite similar to &lt;code&gt;let&lt;/code&gt;&amp;mdash;it's block-scoped and has TDZ. There are, however, two things which are different.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 与 &lt;code&gt;let&lt;/code&gt; 非常相似，它具有块作用域并具有TDZ。 但是，有两件事是不同的。</target>
        </trans-unit>
        <trans-unit id="893fb0337fbc6374457738790cc8786afc01cbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is block scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 是块作用域。</target>
        </trans-unit>
        <trans-unit id="0935015189555bca81712e46368bff07cdd2ad82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 也可以用来避免关闭问题。 它将绑定新的值，而不是保留旧的参考，如下面的示例所示。</target>
        </trans-unit>
        <trans-unit id="7da55d0ae5cba83af8d9bcddc15fbe75a305d540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; in the loop can &lt;strong&gt;re-binds it&lt;/strong&gt; to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; in the loop可以&lt;strong&gt;将其重新绑定&lt;/strong&gt;到循环的每个迭代中，并确保从上一个循环迭代结束时重新为其分配值。 考虑，</target>
        </trans-unit>
        <trans-unit id="898943cc10dae9aa57654db408d0e9820a07b17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is interesting, because it allows us to do something like this:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 很有趣，因为它允许我们执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b00d42e90d9ff28c2ca17f2066eab4ca296f8fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are &lt;em&gt;easy to use&lt;/em&gt; with closures (they do not cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;race conditions&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 变量&lt;em&gt;易于&lt;/em&gt;与闭包&lt;em&gt;一起使用&lt;/em&gt; （它们不会引起&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;竞争条件&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0af3806742f2c2f6ebb22613b4d0219aa7071dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a &lt;code&gt;ReferenceError&lt;/code&gt;. Variable said to be in &quot;temporal dead zone&quot; from the start of the block until the initialization is processed.</source>
          <target state="translated">在评估其定义之前，不初始化 &lt;code&gt;let&lt;/code&gt; 变量。 在初始化之前访问它们会导致 &lt;code&gt;ReferenceError&lt;/code&gt; 。 从块的开始直到初始化处理之前，变量都处于&amp;ldquo;临时死区&amp;rdquo;中。</target>
        </trans-unit>
        <trans-unit id="65ff7d9e010e2ad54c26d0e0600b56ceeb93776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only usable in lines of code that occur &lt;em&gt;after&lt;/em&gt; the variable is declared (even though &lt;a href=&quot;/questions/33198849&quot;&gt;they are hoisted&lt;/a&gt;!).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 变量仅在声明该变量&lt;em&gt;后&lt;/em&gt;发生的代码行中可用（即使&lt;a href=&quot;/questions/33198849&quot;&gt;它们已吊起&lt;/a&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="3ec2a907ce0b2eb98081f72a00f994a218703a4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only visible in their &lt;em&gt;nearest enclosing&lt;/em&gt; block (&lt;code&gt;{ ... }&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 变量仅在其&lt;em&gt;最近的封闭&lt;/em&gt;块（ &lt;code&gt;{ ... }&lt;/code&gt; ）中可见。</target>
        </trans-unit>
        <trans-unit id="93fc717aea1571de33197157899b7efda524d39d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables cannot be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 变量无法在 &lt;code&gt;window&lt;/code&gt; 对象中访问，因为它们无法全局访问。</target>
        </trans-unit>
        <trans-unit id="5c36689eca346124e71af49608677b1a82b86f74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables don't get hoisted:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 变量不被悬挂：</target>
        </trans-unit>
        <trans-unit id="ca400981a08e8a909a0c3b4d1745acd5f90a1658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables may not be redeclared by a subsequent &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 变量不能由后续的 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="f5bdfd10726565f7599def5824126d5b88cbe29b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; works very much like &lt;code&gt;var&lt;/code&gt;. The main difference is that the scope of a &lt;code&gt;var&lt;/code&gt; variable is the entire enclosing function</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 工作非常像 &lt;code&gt;var&lt;/code&gt; 。 主要区别在于 &lt;code&gt;var&lt;/code&gt; 变量的范围是整个封闭函数</target>
        </trans-unit>
        <trans-unit id="4a7e5a7da596e5ed599f94db730395d7fcdafdec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, is a signal that the variable may be reassigned, such as a
  counter in a loop, or a value swap in an algorithm. It also signals
  that the variable will be used only in the block it&amp;rsquo;s defined in,
  which is not always the entire containing function.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 是信号，表明可以重新分配变量，例如循环中的计数器或算法中的值交换。 它还表示该变量将仅在其定义的块中使用，而该块并不总是整个包含函数。</target>
        </trans-unit>
        <trans-unit id="d7ac1ca1e5aa7a427f93aec2df1994a143404d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.</source>
          <target state="translated">ES5中的 &lt;code&gt;var&lt;/code&gt; 和variables在函数中具有作用域，这意味着变量在函数内部有效，而在函数本身外部无效。</target>
        </trans-unit>
        <trans-unit id="948a7ff5506461094cf4291aab6e19dc898ba6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is global scope (hoist-able) variable.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 是全局范围（可提升）变量。</target>
        </trans-unit>
        <trans-unit id="5cfeb8565d205ecaa6279727ad54117c2209b10f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is now the weakest signal available when you define a variable
  in JavaScript. The variable may or may not be reassigned, and the
  variable may or may not be used for an entire function, or just for
  the purpose of a block or loop.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 现在是您在JavaScript中定义变量时可用的最弱信号。 可能会或可能不会重新分配该变量，并且该变量可能会或可能不会用于整个功能，或仅出于块或循环的目的。</target>
        </trans-unit>
        <trans-unit id="fbca8b19e8de6aba37b90ff0fc91b6e4429a273d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of &lt;code&gt;var&lt;/code&gt; for exports may be supplanted if &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; migrates out of transpiler space and into the core language.</source>
          <target state="translated">如果您确定要在循环中使用闭包（＃5）或在代码中声明外部可见的全局变量（＃4）时希望使用单绑定效果，则 &lt;code&gt;var&lt;/code&gt; 可能仍然有用。 如果&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt;移出转译器空间并转移到核心语言中，则可以替换使用 &lt;code&gt;var&lt;/code&gt; 进行出口。</target>
        </trans-unit>
        <trans-unit id="0e636d2a81e1a762020c4f5c3744c8e65bfdd0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; variables can be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">可以在 &lt;code&gt;window&lt;/code&gt; 对象中访问 &lt;code&gt;var&lt;/code&gt; 变量，因为它们不能全局访问。</target>
        </trans-unit>
        <trans-unit id="f7b28054bd2387937ff823de5e92e8d087509275" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;let&lt;/code&gt; will &lt;strong&gt;not hoist&lt;/strong&gt; to the entire scope of the block they appear in. By contrast, &lt;code&gt;var&lt;/code&gt; could hoist as below.&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;不会提升&lt;/strong&gt;它们出现在其中的块的整个范围。相反， &lt;code&gt;var&lt;/code&gt; 可以如下提升。 &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="8e5e8a4029ba67276f8775f560d25040ee366e1d" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;strong&gt;Variable Not Hoisting&lt;/strong&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;strong&gt;可变不吊装&lt;/strong&gt; &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;（*）因为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;提升了&lt;/strong&gt;&lt;/a&gt; JavaScript变量，所以可以在声明全局和功能范围的变量之前对其进行初始化和使用。&lt;/em&gt; 这意味着声明始终在作用域的顶部。</target>
        </trans-unit>
        <trans-unit id="b8a45f3633696567dffb096c46db365f09dc340f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(**) Block scoped variables are not hoisted&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（**）不提升块范围的变量&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a92f025526fcf6fd0e31e3883a2c0ce413ea45b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. No use outside nearest enclosing block:&lt;/strong&gt;
This block of code will throw a reference error because the second use of &lt;code&gt;x&lt;/code&gt; occurs outside of the block where it is declared with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;1.在最接近的封闭块外不使用：&lt;/strong&gt;该代码块将引发引用错误，因为 &lt;code&gt;x&lt;/code&gt; 的第二次使用发生在用 &lt;code&gt;let&lt;/code&gt; 声明的块外：</target>
        </trans-unit>
        <trans-unit id="a1a3f78207be8aa46a711328247e402fe16ff7e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. No use before declaration:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.声明前不得使用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ebde23d0d3b7756808c6cc91ba63eefcda7c222" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. No redeclaration:&lt;/strong&gt;
The following code demonstrates that a variable declared with &lt;code&gt;let&lt;/code&gt; may not be redeclared later:</source>
          <target state="translated">&lt;strong&gt;3.不重新声明：&lt;/strong&gt;以下代码演示了用 &lt;code&gt;let&lt;/code&gt; 声明的变量以后可能不会重新声明：</target>
        </trans-unit>
        <trans-unit id="3452dda34e6fe8760767335a5682fa96d4f633dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Globals not attached to &lt;code&gt;window&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.未连接到 &lt;code&gt;window&lt;/code&gt; 全局变量：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="117009c83c2e98d0a5ff10f1606e8d479850f1f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. Easy use with closures:&lt;/strong&gt;
Variables declared with &lt;code&gt;var&lt;/code&gt; do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable &lt;code&gt;i&lt;/code&gt; has at different points in time:</source>
          <target state="translated">&lt;strong&gt;5.闭包易于使用：&lt;/strong&gt;用 &lt;code&gt;var&lt;/code&gt; 声明的变量在循环内的闭包中不能很好地工作。 这是一个简单的循环，输出变量 &lt;code&gt;i&lt;/code&gt; 在不同时间点具有的值序列：</target>
        </trans-unit>
        <trans-unit id="335cb1cc283f4951de3aa9563124b1b1306cd973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;let&lt;/code&gt; loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; 循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0320f62c5e659472d8791116df2b4f5d9063ed90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db7c704eb200ce249efd68f6671cae57bf115cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example2:&lt;/strong&gt;
In my second example  instead of using &lt;code&gt;var&lt;/code&gt; keyword in my conditional block I declare &lt;code&gt;myvar&lt;/code&gt; using &lt;code&gt;let&lt;/code&gt; keyword . Now when I call &lt;code&gt;myfunc&lt;/code&gt;  I get two different outputs: &lt;code&gt;myvar=20&lt;/code&gt; and &lt;code&gt;myvar=10&lt;/code&gt;.</source>
          <target state="translated">示例2 &lt;strong&gt;：&lt;/strong&gt;在第二个示例中，我没有在条件块中使用 &lt;code&gt;var&lt;/code&gt; 关键字， &lt;code&gt;myvar&lt;/code&gt; 使用 &lt;code&gt;let&lt;/code&gt; 关键字声明了myvar 。 现在，当我调用 &lt;code&gt;myfunc&lt;/code&gt; 时 ，会得到两个不同的输出： &lt;code&gt;myvar=20&lt;/code&gt; 和 &lt;code&gt;myvar=10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58d9ac26bea11358be0d1cbdd9e321d3ba6df33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Garbage Collection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;垃圾收集&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a1048de1a3b6080b858a1b2bef0918699edce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you want to know more continue reading below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您想了解更多，请继续阅读下面的内容&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9c088750dbff02fab5817dc280550e5285cea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is a teaching example intended to demonstrate the &lt;code&gt;var&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这是一个教学示例，旨在演示循环中的 &lt;code&gt;var&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; 行为以及具有易于理解的函数闭包。 这将是添加数字的糟糕方法。 但是在其他上下文中，在现实世界中可能会遇到在匿名函数闭包中捕获数据的通用技术。 YMMV。</target>
        </trans-unit>
        <trans-unit id="9e6852a37a94e37e3dd905af9505c512854ba77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;当使用 &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fafd358dad99127a17812d83d6ef193969ca8ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;var&lt;/code&gt; 时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd31b31858145616de45d3f80da7fc9d141990c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么时候应该在 &lt;code&gt;var&lt;/code&gt; 上使用？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48515bd6359d686dcff1143b76e99f026ba355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;let&lt;/code&gt; 时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bff2ad0c04ac8dd4df0359c5f2b7c4f5886e344c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;var&lt;/code&gt; 时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="227b64041df706bf182aba5ae5ebd33a97ed7e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;let&lt;/strong&gt; allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the &lt;strong&gt;var&lt;/strong&gt; keyword, which defines a variable globally, or locally to an entire function regardless of block scope.</source>
          <target state="translated">&lt;strong&gt;let&lt;/strong&gt;允许您声明范围仅限于使用它的块，语句或表达式的变量。 这与&lt;strong&gt;var&lt;/strong&gt;关键字不同， &lt;strong&gt;var&lt;/strong&gt;关键字在全局范围内或整个函数本地定义变量，而与块范围无关。</target>
        </trans-unit>
        <trans-unit id="fab33e848b5ad8bcc20091c62c722cbb817e51ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var variables are global&lt;/strong&gt; and can be accessed basically everywhere, while &lt;strong&gt;let variables are not global&lt;/strong&gt; and only exist until a closing parenthesis kills them.</source>
          <target state="translated">&lt;strong&gt;var变量是全局变量，&lt;/strong&gt;基本上可以在任何地方访问，而&lt;strong&gt;let变量不是全局变量&lt;/strong&gt; ，仅在右括号将其杀死之前存在。</target>
        </trans-unit>
        <trans-unit id="db1da9a09bc08d7f8e50d60ea6a55e8863b78c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;let&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; 的变量：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29624d341db7c739c0aa200fbd55251cca369e02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;var&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;带有 &lt;code&gt;var&lt;/code&gt; 的变量：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2946b23215e7bb86a85f078731e677392102c35a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Tested in Chrome and Firefox 50)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;（在Chrome和Firefox 50中测试）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="aac30eb1359108b02f390fbbab8124c9183cc1f9" translate="yes" xml:space="preserve">
          <source>A general workaround is to wrap this in an anonymous function and pass &lt;code&gt;i&lt;/code&gt; as an argument. Such issues can also be avoided now by using &lt;code&gt;let&lt;/code&gt; instead &lt;code&gt;var&lt;/code&gt; as shown in the code below.</source>
          <target state="translated">一般的解决方法是将其包装在匿名函数中，然后将 &lt;code&gt;i&lt;/code&gt; 作为参数传递。 现在也可以通过使用 &lt;code&gt;let&lt;/code&gt; 代替 &lt;code&gt;var&lt;/code&gt; 来避免此类问题，如下面的代码所示。</target>
        </trans-unit>
        <trans-unit id="170078ca21bcbd02b1a827e5fbf53f3ea80c3232" translate="yes" xml:space="preserve">
          <source>A variable declared with &lt;code&gt;let&lt;/code&gt; in the global scope (which is code that is not in a function) doesn't get added as a property on the global &lt;code&gt;window&lt;/code&gt; object. For example (this code is in global scope):</source>
          <target state="translated">在全局范围内用 &lt;code&gt;let&lt;/code&gt; 声明的变量（该代码不在函数中）不会作为属性添加到全局 &lt;code&gt;window&lt;/code&gt; 对象上。 例如（此代码在全局范围内）：</target>
        </trans-unit>
        <trans-unit id="5f3e410272543a521cf9f1d7d1742e67dea8dc1b" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;let&lt;/code&gt; statement is only known in &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;the block&lt;/strong&gt;&lt;/a&gt; it is defined in, from the moment it is defined onward. &lt;em&gt;(**)&lt;/em&gt;</source>
          <target state="translated">从 &lt;code&gt;let&lt;/code&gt; 语句开始定义的那一刻起，仅在其定义&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;的块中&lt;/strong&gt;&lt;/a&gt;才知道使用let语句定义的变量。 &lt;em&gt;（**）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09c9ab8e2032dd446f087702839d7b2ed4396ea6" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;var&lt;/code&gt; statement is known throughout &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; it is defined in, from the start of the function. &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">从函数开始，在整个&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/a&gt;定义中都知道使用 &lt;code&gt;var&lt;/code&gt; 语句定义的变量。 &lt;em&gt;（*）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab370464f56e00eeb5cfc62076a9464592135e2" translate="yes" xml:space="preserve">
          <source>Actually, Per @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;Both &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; are hoisted&lt;/a&gt;.</source>
          <target state="translated">实际上，Per @Bergi， &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt; &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 都被吊起&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c89fecc35a8d73707d226f6f0b6a82d6dab14eb" translate="yes" xml:space="preserve">
          <source>Also don't forget it's ECMA6 feature, so it's not fully supported yet, so it's better always transpiles it to ECMA5 using Babel etc... for more info about visit &lt;a href=&quot;https://babeljs.io&quot;&gt;babel website&lt;/a&gt;</source>
          <target state="translated">另外，别忘了它的ECMA6功能，因此尚未得到完全支持，因此最好始终使用Babel等将其转换为ECMA5。有关访问&lt;a href=&quot;https://babeljs.io&quot;&gt;babel网站的&lt;/a&gt;更多信息</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">另外,要考虑到块范围变量在声明之前是不知道的,因为块范围变量是不被挂起的。你也不允许在同一个区块内重新声明同一个区块范围内的变量。这使得块范围化变量比全局或函数范围化变量更不容易出错,因为全局或函数范围化变量是被挂起的,在多次声明的情况下不会产生任何错误。</target>
        </trans-unit>
        <trans-unit id="1c17b26bc3e4c8d3adc5ae1acfc117828aa6be96" translate="yes" xml:space="preserve">
          <source>And, finally, when it comes to the Execution Context, variables defined with var will be attached to the 'this' object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.</source>
          <target state="translated">最后,当谈到执行上下文时,用var定义的变量将被附加到 &quot;this &quot;对象上。在全局执行上下文中,这将是浏览器中的窗口对象。而let或const的情况就不一样了。</target>
        </trans-unit>
        <trans-unit id="71e68652a5ed74f047c3ac12095f037358e5e5ec" translate="yes" xml:space="preserve">
          <source>Another difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is variables with declared with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't get hoisted&lt;/strong&gt;. An example is the best way to illustrate this behavior:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 之间的另一个区别是，用 &lt;code&gt;let&lt;/code&gt; 声明的变量&lt;strong&gt;不被提升&lt;/strong&gt; 。 一个示例是说明此行为的最佳方法：</target>
        </trans-unit>
        <trans-unit id="35c52610045a80e7c59b43f1379714d89e0d6bc4" translate="yes" xml:space="preserve">
          <source>As mentioned above:</source>
          <target state="translated">如上所述。</target>
        </trans-unit>
        <trans-unit id="249700b45578552db048d92af8fa978c2eefd5b3" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;code&gt;var j&lt;/code&gt; variable is still having a value outside of the for loop scope (Block Scope), but the &lt;code&gt;let i&lt;/code&gt; variable is undefined outside of the for loop scope.</source>
          <target state="translated">如您所见， &lt;code&gt;var j&lt;/code&gt; 变量的值仍在for循环范围（Block Scope）之外，但在for循环范围之外， &lt;code&gt;let i&lt;/code&gt; 变量未定义。</target>
        </trans-unit>
        <trans-unit id="d7def6645f985de2714bbee9073b7e35ce60ba9a" translate="yes" xml:space="preserve">
          <source>At the top level (outside of a function)</source>
          <target state="translated">在顶层(功能外)</target>
        </trans-unit>
        <trans-unit id="d2da2ac1a0c2449a02f42f9a07db9b2ad3e838df" translate="yes" xml:space="preserve">
          <source>At the top level of programs and functions, &lt;strong&gt;let&lt;/strong&gt;, unlike &lt;strong&gt;var&lt;/strong&gt;, does not create a property on the global object. For example:</source>
          <target state="translated">在程序和函数的顶层， &lt;strong&gt;let&lt;/strong&gt;与&lt;strong&gt;var&lt;/strong&gt;不同，不会在全局对象上创建属性。 例如：</target>
        </trans-unit>
        <trans-unit id="71df1ae66b61d0ab2fcbac24f66a246ff268b703" translate="yes" xml:space="preserve">
          <source>At the top level, &lt;code&gt;let&lt;/code&gt;, unlike &lt;code&gt;var&lt;/code&gt;, does not create a property on the global object:</source>
          <target state="translated">在顶层， &lt;code&gt;let&lt;/code&gt; 与 &lt;code&gt;var&lt;/code&gt; 不同，不会在全局对象上创建属性：</target>
        </trans-unit>
        <trans-unit id="eeb6d3d38965924988affed9792df84c51af2547" translate="yes" xml:space="preserve">
          <source>At the top level, variables declared using &lt;code&gt;let&lt;/code&gt; don't create properties on the global object.</source>
          <target state="translated">在顶层，使用 &lt;code&gt;let&lt;/code&gt; 声明的变量不会在全局对象上创建属性。</target>
        </trans-unit>
        <trans-unit id="515fa9e7c373ec2c33005604de0e7089c2d08190" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;let&lt;/code&gt; create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">因为 &lt;code&gt;let&lt;/code&gt; 用a）初始化程序表达式b）每次迭代（以前是对增量表达式求值）的名称创建一个新的词法环境，所以&lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;这里有&lt;/a&gt;更多详细信息。</target>
        </trans-unit>
        <trans-unit id="45b1a72deb4126ce6786cb6bf76705a80fcbb65a" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;the temporal dead zone&lt;/a&gt;, variables declared using &lt;code&gt;let&lt;/code&gt; can't be accessed before they are declared. Attempting to do so throws an error.</source>
          <target state="translated">由于存在&lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;临时死区&lt;/a&gt; ，因此在声明之前无法访问使用 &lt;code&gt;let&lt;/code&gt; 声明的变量。 尝试这样做会引发错误。</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">块范围</target>
        </trans-unit>
        <trans-unit id="e40b499735af8fc0820476d34a1c0c219c1fd209" translate="yes" xml:space="preserve">
          <source>Block scope of &lt;code&gt;let&lt;/code&gt; is useful relates to closures and garbage collection to reclaim memory. Consider,</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 的块范围与关闭和垃圾回收有关，可以回收内存。 考虑，</target>
        </trans-unit>
        <trans-unit id="6f29a62d2c8cafbe524c685a3421672ea1015266" translate="yes" xml:space="preserve">
          <source>Code above demonstrates a classic JavaScript closure problem. Reference to the &lt;code&gt;i&lt;/code&gt; variable is being stored in the click handler closure, rather than the actual value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">上面的代码演示了经典的JavaScript关闭问题。 对 &lt;code&gt;i&lt;/code&gt; 变量的引用存储在单击处理程序闭包中，而不是 &lt;code&gt;i&lt;/code&gt; 的实际值中。</target>
        </trans-unit>
        <trans-unit id="9e5c12eac220cda3fddead583cc6b0243277fa9e" translate="yes" xml:space="preserve">
          <source>Consequently, &lt;code&gt;let&lt;/code&gt; variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.</source>
          <target state="translated">因此，当在大型程序中使用或以新的出乎意料的方式组合独立开发的框架时， &lt;code&gt;let&lt;/code&gt; 变量不太可能引起问题。</target>
        </trans-unit>
        <trans-unit id="f7261ea8dc8387f9126baa8bab22723bda98c65e" translate="yes" xml:space="preserve">
          <source>Creating global object property</source>
          <target state="translated">创建全局对象属性</target>
        </trans-unit>
        <trans-unit id="a994290f95e1773d69448109bc715c0ac56c270d" translate="yes" xml:space="preserve">
          <source>Don't let this happen to you. Use a linter.</source>
          <target state="translated">不要让这种事发生在你身上。用打火机。</target>
        </trans-unit>
        <trans-unit id="bff237a3f67a2949d7f6e1f89d92205c1c43fd88" translate="yes" xml:space="preserve">
          <source>During the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised.</source>
          <target state="translated">在Execution Context的创建阶段,var、let和const仍然会在给定的Execution Context的Variable Environment中以未定义的值在内存中存储其变量。区别在于执行阶段。如果你在给var定义的变量赋值之前使用引用,它将只是未定义。不会产生异常。</target>
        </trans-unit>
        <trans-unit id="2b7177a34d2d0cacb674f1aac574068a765ae834" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;the &lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 6引入&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;了 &lt;code&gt;let&lt;/code&gt; 语句&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cf86ea0199cf2cb7ab1e4b859d6da9f7e8d3b80" translate="yes" xml:space="preserve">
          <source>ES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.</source>
          <target state="translated">ES6还引入了const关键字来声明变量,const也是块范围化的。let和const的区别在于,const变量需要使用初始化器进行声明,否则会产生错误。</target>
        </trans-unit>
        <trans-unit id="15fdc50ddc49f97069f55a0d0f0fb021296b8c98" translate="yes" xml:space="preserve">
          <source>ES6 introduced two new keyword(&lt;strong&gt;let&lt;/strong&gt; and &lt;strong&gt;const&lt;/strong&gt;) alternate to &lt;strong&gt;var&lt;/strong&gt;.</source>
          <target state="translated">ES6引入了两个新的关键字（ &lt;strong&gt;let&lt;/strong&gt;和&lt;strong&gt;const&lt;/strong&gt; ）替代&lt;strong&gt;var&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe55c1d6e2b8dc0fe7f0925eac13a3c7b9627f4c" translate="yes" xml:space="preserve">
          <source>Every single click handler will refer to the same object because there&amp;rsquo;s only one counter object which holds 6 so you get six on each click.</source>
          <target state="translated">每个单击处理程序都将引用相同的对象，因为只有一个计数器对象包含6个，因此每次单击将获得6个。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">有关在阅读此答案时哪些浏览器支持 &lt;code&gt;let&lt;/code&gt; 语句的最新概述，请参见&lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt; &lt;code&gt;Can I Use&lt;/code&gt; 页面&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2bcc0766379cd75d853f8179072c502df585067" translate="yes" xml:space="preserve">
          <source>Function VS block scope:</source>
          <target state="translated">函数VS块范围。</target>
        </trans-unit>
        <trans-unit id="44d7d3e4ae1a64d1cd2bf70aad9d679aa794df08" translate="yes" xml:space="preserve">
          <source>Getter and setter with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">用 &lt;code&gt;let&lt;/code&gt; 的 getter和setter：</target>
        </trans-unit>
        <trans-unit id="8ba873db511f120d8b04390f9365a000776baab4" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; doesn't get attached to &lt;code&gt;window&lt;/code&gt;:</source>
          <target state="translated">全局 &lt;code&gt;let&lt;/code&gt; 不会附加到 &lt;code&gt;window&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f8c6d41af972292b69739e49d1923eaf7ba5d69" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; variables are not added to the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">全局 &lt;code&gt;let&lt;/code&gt; 变量不会添加到全局 &lt;code&gt;window&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="50ef81d10d2ac6892f207cc0aa959a31a393eb97" translate="yes" xml:space="preserve">
          <source>Here is an example for the difference between the two (support just started for chrome):</source>
          <target state="translated">下面是一个例子来说明两者之间的区别(刚刚开始支持chrome)。</target>
        </trans-unit>
        <trans-unit id="e80f82c5146fe3bdfce30d25078c548bf9fd7946" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;explanation of the &lt;code&gt;let&lt;/code&gt; keyword&lt;/a&gt; with some examples.</source>
          <target state="translated">下面是一些示例&lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;的 &lt;code&gt;let&lt;/code&gt; 关键字&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="baf1aac8fe97893d9e8a5cc925df180108e841e0" translate="yes" xml:space="preserve">
          <source>Here's an example to add on to what others have already written. Suppose you want to make an array of functions, &lt;code&gt;adderFunctions&lt;/code&gt;, where each function takes a single Number argument and returns the sum of the argument and the function's index in the array. Trying to generate &lt;code&gt;adderFunctions&lt;/code&gt; with a loop using the &lt;code&gt;var&lt;/code&gt; keyword won't work the way someone might na&amp;iuml;vely expect:</source>
          <target state="translated">这是一个示例，可以补充其他人已经写的内容。 假设您要创建一个函数数组 &lt;code&gt;adderFunctions&lt;/code&gt; ，其中每个函数都使用一个Number参数，并返回参数和该函数在数组中的索引的和。 尝试使用 &lt;code&gt;var&lt;/code&gt; 关键字通过循环生成 &lt;code&gt;adderFunctions&lt;/code&gt; 不能像某些人天真的期望的那样起作用：</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">在这里，我们可以看到我们的变量 &lt;code&gt;j&lt;/code&gt; 仅在第一个for循环中已知，而在之前和之后都不知道。 但是，我们的变量 &lt;code&gt;i&lt;/code&gt; 在整个函数中是已知的。</target>
        </trans-unit>
        <trans-unit id="7bcaf634e9dbfa99922f815d7eb0b950882fbc2c" translate="yes" xml:space="preserve">
          <source>Hoisting</source>
          <target state="translated">Hoisting</target>
        </trans-unit>
        <trans-unit id="a4b770c91602cb7a14569eb1fadf17b154c46e1d" translate="yes" xml:space="preserve">
          <source>Hoisting is not supported using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;let&lt;/code&gt; 不支持吊装。</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">如何跟踪浏览器的支持情况</target>
        </trans-unit>
        <trans-unit id="02950dbbb2895580e2f47482bfdc271d60612939" translate="yes" xml:space="preserve">
          <source>However it's worth noting that &lt;code&gt;let&lt;/code&gt; is only a part of newer Javascript implementations and has varying degrees of &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;browser support&lt;/a&gt;.</source>
          <target state="translated">但是，值得注意的是， &lt;code&gt;let&lt;/code&gt; 只是较新的Javascript实现的一部分，并且具有不同程度的&lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;浏览器支持&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a64dc9831d45af781fdad2758e3129f38608db33" translate="yes" xml:space="preserve">
          <source>However, replace &lt;code&gt;var&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">但是，用 &lt;code&gt;let&lt;/code&gt; 替换 &lt;code&gt;var&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1942516de816b1215bfb3f885b92dce215fe8c87" translate="yes" xml:space="preserve">
          <source>However, the block scope can make this huge data structure to garbage collected.</source>
          <target state="translated">但是,块的范围可以让这个庞大的数据结构变成垃圾收集。</target>
        </trans-unit>
        <trans-unit id="210d598d2aa5b2252eb617a5677124f67bcfd03e" translate="yes" xml:space="preserve">
          <source>However, we can try again using the &lt;code&gt;let&lt;/code&gt; keyword:</source>
          <target state="translated">但是，我们可以使用 &lt;code&gt;let&lt;/code&gt; 关键字再试一次：</target>
        </trans-unit>
        <trans-unit id="1a13c0910c0809caa265aa5d59b7303182a3e913" translate="yes" xml:space="preserve">
          <source>However, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:</source>
          <target state="translated">但是,在声明之前,你不能引用用let或const声明的变量。如果你试图在声明之前使用它,那么在执行上下文的执行阶段就会出现异常。现在,这个变量仍然会在内存中,因为在执行上下文的创建阶段,但引擎将不允许你使用它。</target>
        </trans-unit>
        <trans-unit id="73b04d7e63d97817ad43a04a297f8ccd6b791760" translate="yes" xml:space="preserve">
          <source>I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.</source>
          <target state="translated">我想以后人们会在这里开始使用let,这样他们就会像其他语言一样,在JavaScript中也会有类似于Java、C#等语言的scoping。</target>
        </trans-unit>
        <trans-unit id="60ed5394ff0a30a2c778db05382fc4f19f7dea8c" translate="yes" xml:space="preserve">
          <source>I think the terms and most of the examples are a bit overwhelming,
The main issue i had personally with the difference is understanding what a &quot;Block&quot; is.
At some point i realized, a block would be any curly brackets except for &lt;code&gt;IF&lt;/code&gt; statement.
an opening bracket &lt;code&gt;{&lt;/code&gt; of a function or loop will define a new block, anything defined with &lt;code&gt;let&lt;/code&gt; within it, will not be available after the closing bracket &lt;code&gt;}&lt;/code&gt; of the same thing (function or loop);
With that in mind, it was easier to understand:</source>
          <target state="translated">我认为术语和大多数示例有点让人不知所措。我个人与之不同的主要问题是了解什么是&amp;ldquo;阻止&amp;rdquo;。 在某种程度上，我意识到，一个块将是除 &lt;code&gt;IF&lt;/code&gt; 语句外的任何花括号。 函数或循环的右括号 &lt;code&gt;{&lt;/code&gt; 将定义一个新块，其中用 &lt;code&gt;let&lt;/code&gt; 定义的任何内容，在同一事物（函数或循环）的右括号之后将不可用； 考虑到这一点，更容易理解：</target>
        </trans-unit>
        <trans-unit id="652bcdb1cb95ff704c8f7f92231e2c819a6a619e" translate="yes" xml:space="preserve">
          <source>I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment).</source>
          <target state="translated">我想把这些关键词和执行上下文联系起来,因为执行上下文在这一切中很重要。Execution Context有两个阶段:创建阶段和执行阶段。此外,每个执行上下文都有一个变量环境和外部环境(它的词法环境)。</target>
        </trans-unit>
        <trans-unit id="347c3b7704d41b142c7558f9df8c366aaa5c3ca9" translate="yes" xml:space="preserve">
          <source>I've heard it that it's described as a &quot;local&quot; variable, but I'm still not quite sure how it behaves differently than the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">我听说它被描述为&amp;ldquo;局部&amp;rdquo;变量，但是我仍然不太确定它的行为与 &lt;code&gt;var&lt;/code&gt; 关键字有何不同。</target>
        </trans-unit>
        <trans-unit id="a64f2d3dd931f8ac221f076d6aee461fa2e268f7" translate="yes" xml:space="preserve">
          <source>If I read the specs right then &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;thankfully&lt;/strong&gt; can also be leveraged to avoid &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;self invoking functions&lt;/a&gt; used to simulate private only members - &lt;em&gt;a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone's desire for semantics, so stop using it. /rant&lt;/em&gt;</source>
          <target state="translated">如果我没看错规范，那么&lt;strong&gt;值得庆幸的&lt;/strong&gt;是，也可以利用它来避免用于模拟仅私有成员的&lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;自调用函数&lt;/a&gt; - &lt;em&gt;一种流行的设计模式，它降低了代码的可读性，使调试复杂化，没有增加任何实际的代码保护或其他好处-也许令人满意某人对语义的渴望，因此请停止使用它。&lt;/em&gt; &lt;em&gt;/ rant&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efbed4ca5ff07a30fe5d1a50e4502bdb347bc1c0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.</source>
          <target state="translated">如果在循环中使用 &lt;code&gt;let&lt;/code&gt; 而不是 &lt;code&gt;var&lt;/code&gt; ，则每次迭代都会获得一个新变量。 这意味着您可以安全地在循环内使用闭包。</target>
        </trans-unit>
        <trans-unit id="17145a9a9f46d1b105d7a4debb8d941ee248c402" translate="yes" xml:space="preserve">
          <source>If you want to have an immutable object, you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;&lt;code&gt;Object.freeze()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果要拥有一个不变的对象，则应使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt; &lt;code&gt;Object.freeze()&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">如果你正在编写客户端的JavaScript代码,并且没有使用转码器,你需要考虑浏览器的支持。</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">如果您正在编写客户端JavaScript代码并使用基于Node的编译器（例如&lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell脚本&lt;/strong&gt;&lt;/a&gt;或&lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; ），则可以安全地使用 &lt;code&gt;let&lt;/code&gt; 语句。 并且由于您的浏览器仅会了解已转译的代码，因此应限制性能方面的弊端。</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">如果您正在编写客户端JavaScript代码并使用基于浏览器的编译器（例如&lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt;或&lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; ），则可以安全地使用 &lt;code&gt;let&lt;/code&gt; 语句，但是就性能而言，代码可能不是最佳选择。</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">如果要编写服务器端JavaScript代码（ &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ），则可以安全地使用 &lt;code&gt;let&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="cfc03d4531fe0bd76ba607e1e4e7d663c32df226" translate="yes" xml:space="preserve">
          <source>In JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">在JavaScript中，我们通常在比创建变量晚得多的时间使用变量。 当我们通过传递给 &lt;code&gt;setTimeout&lt;/code&gt; 的闭包来延迟输出来证明这一点时：</target>
        </trans-unit>
        <trans-unit id="7c9021c4e7876355e1fc36b9e227cb4de4425b66" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; parses and runs without throwing any exceptions.</source>
          <target state="translated">相反，具有 &lt;code&gt;var&lt;/code&gt; 的同一示例在不引发任何异常的情况下进行分析和运行。</target>
        </trans-unit>
        <trans-unit id="177519e8851b8c0bb348adf315a0cf3831599c1d" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; works.</source>
          <target state="translated">相反，使用 &lt;code&gt;var&lt;/code&gt; 的相同示例起作用。</target>
        </trans-unit>
        <trans-unit id="dc8dcbdd636f8cb50991ca75851fcac1be59e3c5" translate="yes" xml:space="preserve">
          <source>In my both examples I have a function &lt;code&gt;myfunc&lt;/code&gt;. &lt;code&gt;myfunc&lt;/code&gt; contains a variable &lt;code&gt;myvar&lt;/code&gt; equals to 10. 
In my first example  I check   if &lt;code&gt;myvar&lt;/code&gt; equals to 10 (&lt;code&gt;myvar==10&lt;/code&gt;) . If yes, I agian declare  a variable  &lt;code&gt;myvar&lt;/code&gt; (now I have two myvar variables)using &lt;code&gt;var&lt;/code&gt; keyword and assign it a new value (20). In next line I  print its value on my console.  After the conditional block I again print the value of &lt;code&gt;myvar&lt;/code&gt; on my console. If you look at the output of &lt;code&gt;myfunc&lt;/code&gt;,   &lt;code&gt;myvar&lt;/code&gt; has value equals to 20.</source>
          <target state="translated">在我的两个示例中，我都有一个函数 &lt;code&gt;myfunc&lt;/code&gt; 。 &lt;code&gt;myfunc&lt;/code&gt; 包含变量 &lt;code&gt;myvar&lt;/code&gt; 等于10。在第一个示例中，我检查 &lt;code&gt;myvar&lt;/code&gt; 是否等于10（ &lt;code&gt;myvar==10&lt;/code&gt; ）。 如果是，我会使用 &lt;code&gt;var&lt;/code&gt; 关键字声明一个变量 &lt;code&gt;myvar&lt;/code&gt; （现在有两个myvar变量），并为其分配一个新值（20）。 在下一行中，我在控制台上打印其值。 在条件块之后，我再次在控制台上打印 &lt;code&gt;myvar&lt;/code&gt; 的值。 如果查看 &lt;code&gt;myfunc&lt;/code&gt; 的输出，则 &lt;code&gt;myvar&lt;/code&gt; 的值等于20。</target>
        </trans-unit>
        <trans-unit id="d3eb240300b8d3cf3894acb662d9d55b4c3eeb9c" translate="yes" xml:space="preserve">
          <source>In practice, there are a number of useful consequences of the difference in scope:</source>
          <target state="translated">在实践中,范围的不同会带来一些有用的后果。</target>
        </trans-unit>
        <trans-unit id="041cfe51d16fc06e7a90d0fdd25ff09d8de80054" translate="yes" xml:space="preserve">
          <source>In strict mode, &lt;code&gt;var&lt;/code&gt; will let you re-declare the same variable in the same scope while &lt;code&gt;let&lt;/code&gt; raises a SyntaxError.</source>
          <target state="translated">在严格模式下， &lt;code&gt;var&lt;/code&gt; 使您可以在同一范围内重新声明相同的变量，而 &lt;code&gt;let&lt;/code&gt; 则引发SyntaxError。</target>
        </trans-unit>
        <trans-unit id="deb3d336c8ca38ed2c8a72be4787d1e826efc9a7" translate="yes" xml:space="preserve">
          <source>Initializer is required</source>
          <target state="translated">需要使用初始化器</target>
        </trans-unit>
        <trans-unit id="6d007cc06c89e6bed5f7c97dc75f829442633823" translate="yes" xml:space="preserve">
          <source>Inside a block</source>
          <target state="translated">在一个街区内</target>
        </trans-unit>
        <trans-unit id="d187aaa9dbe696be70ed4733de46de8f53018d1e" translate="yes" xml:space="preserve">
          <source>Inside a function</source>
          <target state="translated">内部功能</target>
        </trans-unit>
        <trans-unit id="6a19a43ce4368f97cd87fe72619ae5cd48410ed3" translate="yes" xml:space="preserve">
          <source>Inside a function (but outside of a block), &lt;code&gt;let&lt;/code&gt; has the same scope as &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">在函数内部（但在块外部）， &lt;code&gt;let&lt;/code&gt; 具有与 &lt;code&gt;var&lt;/code&gt; 相同的作用域。</target>
        </trans-unit>
        <trans-unit id="b31aad9d36743f490f94cc21d201edada256344c" translate="yes" xml:space="preserve">
          <source>Inside a loop</source>
          <target state="translated">循环内</target>
        </trans-unit>
        <trans-unit id="5f706b419d5afb2010d5c584c5073222be04bf3b" translate="yes" xml:space="preserve">
          <source>Is it safe to use &lt;code&gt;let&lt;/code&gt; today?</source>
          <target state="translated">今天使用 &lt;code&gt;let&lt;/code&gt; 安全吗？</target>
        </trans-unit>
        <trans-unit id="2efd347d2f42601723d5af3a50c4b497df93e4c1" translate="yes" xml:space="preserve">
          <source>It also appears that, at least in Visual Studio 2015, TypeScript 1.5, &quot;var&quot; allows multiple declarations of the same variable name in a block, and &quot;let&quot; doesn't.</source>
          <target state="translated">看来,至少在Visual Studio 2015、TypeScript 1.5中,&quot;var &quot;也允许在一个块中对同一个变量名进行多次声明,而 &quot;let &quot;不允许。</target>
        </trans-unit>
        <trans-unit id="5baa9813fadf06ec260f1610e850a5668ce5695e" translate="yes" xml:space="preserve">
          <source>Loops with closures</source>
          <target state="translated">带封闭装置的环路</target>
        </trans-unit>
        <trans-unit id="c0b7662f52c683b4a21a90043d995802030c5bd1" translate="yes" xml:space="preserve">
          <source>Main difference is scoping rules. Variables declared by &lt;code&gt;var&lt;/code&gt; keyword are scoped to the immediate function body (hence the function scope) while &lt;code&gt;let&lt;/code&gt; variables are scoped to the immediate &lt;em&gt;enclosing&lt;/em&gt; block denoted by &lt;code&gt;{ }&lt;/code&gt; (hence the block scope).</source>
          <target state="translated">主要区别是作用域规则。 &lt;code&gt;var&lt;/code&gt; 关键字声明的变量的作用域范围是立即函数主体（因此作用域），而 &lt;code&gt;let&lt;/code&gt; 变量的作用域范围由 &lt;code&gt;{ }&lt;/code&gt; 表示的直接&lt;em&gt;封闭&lt;/em&gt;块（因此块作用域）。</target>
        </trans-unit>
        <trans-unit id="99fbe1720bf011da269b2cac5512d7c3963a6968" translate="yes" xml:space="preserve">
          <source>May the following two functions show the difference:</source>
          <target state="translated">愿以下两种功能的区别。</target>
        </trans-unit>
        <trans-unit id="63a3dc65c2f80ebaced4b3a1a62910c1da24fc2b" translate="yes" xml:space="preserve">
          <source>No re-assigning</source>
          <target state="translated">没有重新分配</target>
        </trans-unit>
        <trans-unit id="39c7b7a1ef0ba49851ad5dfe7bd9144cb18d52c7" translate="yes" xml:space="preserve">
          <source>No re-declaring</source>
          <target state="translated">不需重新申报</target>
        </trans-unit>
        <trans-unit id="39c9178c32e097fcac397a91d250592e73365258" translate="yes" xml:space="preserve">
          <source>Note that it doesn't mean that the value is immutable. Its properties still can be changed.</source>
          <target state="translated">注意,这并不意味着这个值是不可更改的。它的属性仍然是可以改变的。</target>
        </trans-unit>
        <trans-unit id="f3a83e225fb411474c8b9361c4b05f98a38f3643" translate="yes" xml:space="preserve">
          <source>Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don't.</source>
          <target state="translated">注意,只有Mozilla和Chrome浏览器支持它。IE、Safari和其他浏览器可能不支持。</target>
        </trans-unit>
        <trans-unit id="96df0ec4b6def0a95acbbc1f79135059a56fd9f0" translate="yes" xml:space="preserve">
          <source>Now I think there is better scoping of variables to a block of statements using &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">现在，我认为使用 &lt;code&gt;let&lt;/code&gt; 更好地将变量的作用域范围限定为语句块：</target>
        </trans-unit>
        <trans-unit id="39076c4b7441e59ed2d91b8abe7ca8c4659cb0d2" translate="yes" xml:space="preserve">
          <source>Now, image mixing the two behaviors and you'll probably see why it's not recommended to mix the newer &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; with the older &lt;code&gt;var&lt;/code&gt; in the same script. Doing so can result is some spectacularly confusing code.</source>
          <target state="translated">现在，对两种行为进行图像混合，您可能会明白为什么不建议在同一脚本中将较新的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 与较旧的 &lt;code&gt;var&lt;/code&gt; 混合使用。 这样做可能会导致一些令人困惑的代码。</target>
        </trans-unit>
        <trans-unit id="8c2795ed8b2631b7e1915cc52073b53be8af53e9" translate="yes" xml:space="preserve">
          <source>Only counts [0, 1].</source>
          <target state="translated">只算[0,1]。</target>
        </trans-unit>
        <trans-unit id="efcf7de8b6bfc89725e070a6351b838be2c76f1b" translate="yes" xml:space="preserve">
          <source>People had to create immediately invoked functions to capture correct value from the loops but that was also hairy.</source>
          <target state="translated">人们不得不创建立即调用的函数来捕获循环中的正确值,但这也是毛毛的。</target>
        </trans-unit>
        <trans-unit id="2f5f2be0ca83a657f2ffc3bfa218814a5981da32" translate="yes" xml:space="preserve">
          <source>People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.</source>
          <target state="translated">对JavaScript中的Scoping不甚了解的人,以前都会犯这样的错误。</target>
        </trans-unit>
        <trans-unit id="285dc513fb5c7a7fc0e6eb93a0290e0641276542" translate="yes" xml:space="preserve">
          <source>Previously there were only two scopes in JavaScript, i.e. functional and global. With '&lt;code&gt;let&lt;/code&gt;' keyword JavaScript has now introduced &lt;code&gt;block-level&lt;/code&gt; variables.</source>
          <target state="translated">以前，JavaScript中只有两个作用域，即功能性和全局性。 现在，使用' &lt;code&gt;let&lt;/code&gt; '关键字，JavaScript引入了 &lt;code&gt;block-level&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="25b58933661327228329508e8c2cf1090c0253a0" translate="yes" xml:space="preserve">
          <source>Refer to &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth: let and const&lt;/a&gt;&lt;/em&gt; to understand it better.</source>
          <target state="translated">请参阅&lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6深度：let和const&lt;/a&gt;&lt;/em&gt;可以更好地理解它。</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">范围界定规则</target>
        </trans-unit>
        <trans-unit id="382bd8420b6d01443a65704ab49145af79643941" translate="yes" xml:space="preserve">
          <source>See '&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Emulating private interfaces&lt;/a&gt;'</source>
          <target state="translated">请参阅&amp;ldquo; &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;模拟专用接口&lt;/a&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9199fa6dee3c3db69201fd546b73324ee92bb5fc" translate="yes" xml:space="preserve">
          <source>See my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.</source>
          <target state="translated">请看我下面的例子,注意lion (let)变量在两个console.log中的作用是如何不同的,它在第二个console.log中变得不在范围内。</target>
        </trans-unit>
        <trans-unit id="ce14680b0e5afa36020ec40b287ff3cdba706e04" translate="yes" xml:space="preserve">
          <source>So the difference is very simple i.e its scope.</source>
          <target state="translated">所以区别很简单,就是它的范围。</target>
        </trans-unit>
        <trans-unit id="38c778b9cbefb5fbaad00a515fa6b89ce13a738d" translate="yes" xml:space="preserve">
          <source>Some hacks with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 的一些技巧：</target>
        </trans-unit>
        <trans-unit id="789fd33b37de1fced25ba88ee426bb6b49dcd4f3" translate="yes" xml:space="preserve">
          <source>Some people would argue that in the future we'll ONLY use let statements and that var statements will become obsolete. JavaScript guru &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Kyle Simpson&lt;/strong&gt;&lt;/a&gt; wrote &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;a very elaborate article on why he believes that won't be the case&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">有人会说，将来我们只会使用let语句，而var语句将变得过时。 JavaScript专家&lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;凯尔&amp;bull;辛普森&lt;/strong&gt;&lt;/a&gt; （ &lt;strong&gt;Kyle Simpson）&lt;/strong&gt;写&lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;了一篇非常详细的文章，阐述了为什么他认为情况并非如此&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="33a132a545bee29b8dcb5ddcc302b7c8534a609b" translate="yes" xml:space="preserve">
          <source>Specifically, this outputs:</source>
          <target state="translated">具体来说,这种输出。</target>
        </trans-unit>
        <trans-unit id="c20042f3ec22b168b4441982da162a8418abc98a" translate="yes" xml:space="preserve">
          <source>Take a look at this example from &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;another stackoverflow question&lt;/a&gt;:</source>
          <target state="translated">看一下&lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;另一个stackoverflow问题的&lt;/a&gt;示例：</target>
        </trans-unit>
        <trans-unit id="d2a5704984a4447527354be4a00cc8b22ced40f5" translate="yes" xml:space="preserve">
          <source>Temporal dead zone</source>
          <target state="translated">时空死亡区</target>
        </trans-unit>
        <trans-unit id="a6c1c3dc63d914749b6854d3ab11a3b569eada69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;click&lt;/code&gt; handler callback does not need the &lt;code&gt;hugeData&lt;/code&gt; variable at all. Theoretically, after &lt;code&gt;process(..)&lt;/code&gt; runs, the huge data structure &lt;code&gt;hugeData&lt;/code&gt; could be garbage collected. However, it's possible that some JS engine will still have to keep this huge structure, since the &lt;code&gt;click&lt;/code&gt; function has a closure over the entire scope.</source>
          <target state="translated">&lt;code&gt;click&lt;/code&gt; 处理程序回调完全不需要 &lt;code&gt;hugeData&lt;/code&gt; 变量。 从理论上讲，在 &lt;code&gt;process(..)&lt;/code&gt; 运行之后，可以对巨大的数据结构 &lt;code&gt;hugeData&lt;/code&gt; 进行垃圾回收。 但是，某些JS引擎仍可能必须保留这种庞大的结构，因为 &lt;code&gt;click&lt;/code&gt; 函数在整个作用域内都是封闭的。</target>
        </trans-unit>
        <trans-unit id="264885cd88282bf28a8225c70ff7599f6d3df455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gfoo&lt;/code&gt;, defined by &lt;code&gt;let&lt;/code&gt; initially is in the &lt;strong&gt;global scope&lt;/strong&gt;, and when we declare &lt;code&gt;gfoo&lt;/code&gt; again inside the &lt;code&gt;if clause&lt;/code&gt; its &lt;strong&gt;&lt;em&gt;scope changed&lt;/em&gt;&lt;/strong&gt; and when a new value is assigned to the variable inside that scope it &lt;strong&gt;does not affect&lt;/strong&gt; the global scope.</source>
          <target state="translated">由 &lt;code&gt;let&lt;/code&gt; 定义的 &lt;code&gt;gfoo&lt;/code&gt; 最初位于&lt;strong&gt;全局范围内&lt;/strong&gt; ，当我们在 &lt;code&gt;if clause&lt;/code&gt; 再次声明 &lt;code&gt;gfoo&lt;/code&gt; 时，其&lt;strong&gt;&lt;em&gt;范围已更改，&lt;/em&gt;&lt;/strong&gt;并且向该范围内的变量分配了新值时，它&lt;strong&gt;不会影响&lt;/strong&gt;全局范围。</target>
        </trans-unit>
        <trans-unit id="87b7ba6b84d1c61150fc37bf6a8f3727f5c2d5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword attaches the variable declaration to the scope of whatever block (commonly a &lt;code&gt;{ .. }&lt;/code&gt; pair) it's contained in. In other words,&lt;code&gt;let&lt;/code&gt; implicitly hijacks any block's scope for its variable declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 关键字将变量声明附加到它所包含的任何块（通常是一对 &lt;code&gt;{ .. }&lt;/code&gt; 对）的范围。换句话说， &lt;code&gt;let&lt;/code&gt; 隐式劫持了任何块的变量声明范围。</target>
        </trans-unit>
        <trans-unit id="78af92108bc96e8a42084047aaf363842f3b377a" translate="yes" xml:space="preserve">
          <source>The accepted answer is missing a point:</source>
          <target state="translated">接受的答案是缺少一个点。</target>
        </trans-unit>
        <trans-unit id="073b339db7edb1c2e2e81ea60ac755f69153f037" translate="yes" xml:space="preserve">
          <source>The below shows how 'let' and 'var' are different in the scope:</source>
          <target state="translated">下图显示了 &quot;let &quot;和 &quot;var &quot;在范围中的区别。</target>
        </trans-unit>
        <trans-unit id="4d9ba873fd7a30468256474a7c4d6e16988d829d" translate="yes" xml:space="preserve">
          <source>The below table summarize the difference between var, let and const</source>
          <target state="translated">下表总结了var、let和const之间的区别。</target>
        </trans-unit>
        <trans-unit id="00a031e0941465964589ed342dbcebaa59ee6085" translate="yes" xml:space="preserve">
          <source>The difference is in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;scope&lt;/a&gt; of the variables declared with each.</source>
          <target state="translated">不同之处在于每个变量声明的变量的&lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;范围&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="58bbbdd4908ae3e2d249c1fbdc5b3f5b43c376b1" translate="yes" xml:space="preserve">
          <source>The difference is scoping. &lt;code&gt;var&lt;/code&gt; is scoped to the nearest &lt;strong&gt;function
  block&lt;/strong&gt; and &lt;code&gt;let&lt;/code&gt; is scoped to the &lt;strong&gt;nearest enclosing block&lt;/strong&gt;, which
  can be smaller than a function block. Both are global if outside any
  block.Lets see an example:</source>
          <target state="translated">区别在于范围。 &lt;code&gt;var&lt;/code&gt; 的作用域是最近的&lt;strong&gt;功能块，&lt;/strong&gt;而 &lt;code&gt;let&lt;/code&gt; 的作用域是&lt;strong&gt;最近的封闭块&lt;/strong&gt; ，它可以小于功能块。 如果在任何块之外，两者都是全局的。让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="a2047a53cae852bc9bd4d5726d86bf1abdab5907" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is that variables declared with &lt;code&gt;var&lt;/code&gt; are &lt;strong&gt;function scoped&lt;/strong&gt;. Whereas functions declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt;. For example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 之间的主要区别在于，用 &lt;code&gt;var&lt;/code&gt; 声明的变量是&lt;strong&gt;函数范围的&lt;/strong&gt; 。 而用 &lt;code&gt;let&lt;/code&gt; 声明的函数是&lt;strong&gt;块作用域的&lt;/strong&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="8d162e4b209b454c9dcdb65956e1046635e203a9" translate="yes" xml:space="preserve">
          <source>The main difference is the &lt;strong&gt;scope&lt;/strong&gt; difference, while &lt;strong&gt;let&lt;/strong&gt; can be only available inside the &lt;strong&gt;scope&lt;/strong&gt; it's declared, like in for loop, &lt;strong&gt;var&lt;/strong&gt; can be accessed outside the loop for example. From the documentation in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (examples also from MDN):</source>
          <target state="translated">主要的区别是&lt;strong&gt;范围的&lt;/strong&gt;区别，而&lt;strong&gt;let&lt;/strong&gt;只能在声明的&lt;strong&gt;范围&lt;/strong&gt;内使用，例如在for循环中，例如&lt;strong&gt;var&lt;/strong&gt;可以在循环外部访问。 从&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN中&lt;/a&gt;的文档中（也有MDN的示例）：</target>
        </trans-unit>
        <trans-unit id="9f7f9f1e0a48709104afca6e8067da28df678148" translate="yes" xml:space="preserve">
          <source>The process above doesn't generate the desired array of functions because &lt;code&gt;i&lt;/code&gt;'s scope extends beyond the iteration of the &lt;code&gt;for&lt;/code&gt; block in which each function was created. Instead, at the end of the loop, the &lt;code&gt;i&lt;/code&gt; in each function's closure refers to &lt;code&gt;i&lt;/code&gt;'s value at the end of the loop (1000) for every anonymous function in &lt;code&gt;adderFunctions&lt;/code&gt;. This isn't what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of &lt;code&gt;i&lt;/code&gt;, the mutation will affect all the &lt;code&gt;adderFunctions&lt;/code&gt;.</source>
          <target state="translated">上面的过程无法生成所需的函数数组，因为 &lt;code&gt;i&lt;/code&gt; 的范围超出了在其中创建每个函数的 &lt;code&gt;for&lt;/code&gt; 块的迭代范围。 相反，在循环结束时，每个函数闭包中的 &lt;code&gt;i&lt;/code&gt; &lt;code&gt;adderFunctions&lt;/code&gt; 每个匿名函数在循环结束时i的值（1000）。 这根本不是我们想要的：我们现在在内存中拥有1000个不同功能的数组，它们的行为完全相同。 并且如果我们随后更新 &lt;code&gt;i&lt;/code&gt; 的值，突变将影响所有 &lt;code&gt;adderFunctions&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3451295aef647a9eb92f4f38d933a0e2d080e7e1" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;let&lt;/code&gt; keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.</source>
          <target state="translated">将 &lt;code&gt;let&lt;/code&gt; 关键字引入语言的原因是函数范围令人困惑，并且是JavaScript中错误的主要来源之一。</target>
        </trans-unit>
        <trans-unit id="11b109d5b87133e7c9f78aaa1557423809cb31f7" translate="yes" xml:space="preserve">
          <source>The restrictions imposed by &lt;code&gt;let&lt;/code&gt; reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;reachability&lt;/a&gt;(helping with reclaiming unused memory).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 施加的限制降低了变量的可见性，并增加了提早发现意外的名称冲突的可能性。 这样可以更轻松地跟踪和推理变量，包括变量的&lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;可达性&lt;/a&gt; （帮助回收未使用的内存）。</target>
        </trans-unit>
        <trans-unit id="e0d2bb460f6b296bc8aef7ab3dd6effc0df6f796" translate="yes" xml:space="preserve">
          <source>The second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.</source>
          <target state="translated">let的第二个特点是它引入了块范围。块是由大括号定义的。例如函数块、if块、for块等。当你在块内用let声明一个变量时,这个变量只在块内可用。事实上,每次运行块的时候,比如在for循环中,它都会在内存中创建一个新的变量。</target>
        </trans-unit>
        <trans-unit id="f0009b35b2bce48e37552dc2d483b1c142ec7b1e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences &amp;mdash; &lt;code&gt;let&lt;/code&gt; scoping behaves more like variable scoping does in more or less any other languages.</source>
          <target state="translated">有一些细微的差异-范围界定的行为更像变量范围界定，或多或少与任何其他语言一样。</target>
        </trans-unit>
        <trans-unit id="582e7ce54a6962d9d96e460cfe6b27fdb7eed8a5" translate="yes" xml:space="preserve">
          <source>There are still some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">仍然有一些根本不支持 &lt;code&gt;let&lt;/code&gt; 的浏览器：</target>
        </trans-unit>
        <trans-unit id="4ee4cc384a25d5e3ddde3e6500df25636cdfd4ce" translate="yes" xml:space="preserve">
          <source>This article clearly defines the difference between var, let and const</source>
          <target state="translated">这篇文章明确定义了var、let和const之间的区别</target>
        </trans-unit>
        <trans-unit id="556d5253d7e385c3f1d2c5b84329a06bb16d69f7" translate="yes" xml:space="preserve">
          <source>This block of code will throw a &lt;code&gt;ReferenceError&lt;/code&gt; before the code can be run because &lt;code&gt;x&lt;/code&gt; is used before it is declared:</source>
          <target state="translated">此代码块将在运行代码之前引发 &lt;code&gt;ReferenceError&lt;/code&gt; ，因为在声明 &lt;code&gt;x&lt;/code&gt; 之前使用了x ：</target>
        </trans-unit>
        <trans-unit id="25d7860a8b2663b86949e7ca85dafff841362dba" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;let&lt;/code&gt;, for every loop iteration the variable is scoped and has its own copy.</source>
          <target state="translated">这是因为使用 &lt;code&gt;let&lt;/code&gt; 时 ，对于每次循环迭代，变量都具有作用域并具有自己的副本。</target>
        </trans-unit>
        <trans-unit id="1edd9ce9f172dbb4d4b3887bc51fb5cf6e0bb712" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;var&lt;/code&gt;, for every loop iteration the variable is scoped and has shared copy.</source>
          <target state="translated">这是因为使用 &lt;code&gt;var&lt;/code&gt; 时 ，对于每次循环迭代，变量都具有作用域并具有共享副本。</target>
        </trans-unit>
        <trans-unit id="a216ad59073ea6bd11a79ebc083a96139dca03f7" translate="yes" xml:space="preserve">
          <source>This time, &lt;code&gt;i&lt;/code&gt; is rebound on each iteration of the &lt;code&gt;for&lt;/code&gt; loop. Each function now keeps the value of &lt;code&gt;i&lt;/code&gt; at the time of the function's creation, and &lt;code&gt;adderFunctions&lt;/code&gt; behaves as expected.</source>
          <target state="translated">这次， &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;for&lt;/code&gt; 循环的每次迭代中都反弹。 现在，每个函数在创建函数时都会保留 &lt;code&gt;i&lt;/code&gt; 的值，并且 &lt;code&gt;adderFunctions&lt;/code&gt; 的行为符合预期。</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">这将。</target>
        </trans-unit>
        <trans-unit id="5dd7645a6d40c190e66e82b7ca6d2962889cfe89" translate="yes" xml:space="preserve">
          <source>This won't generate a compile error:</source>
          <target state="translated">这不会产生编译错误。</target>
        </trans-unit>
        <trans-unit id="d36477f33831b971d8bfc3e95c1e4d91bef92cb1" translate="yes" xml:space="preserve">
          <source>To have a complete understanding of the 'let' keyword, &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;
ES6: &amp;lsquo;let&amp;rsquo; keyword to declare variable in JavaScript&lt;/a&gt;&lt;/em&gt; will help.</source>
          <target state="translated">为了全面了解'let'关键字， &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;ES6：'let'关键字在JavaScript中声明变量&lt;/a&gt;&lt;/em&gt;将很有帮助。</target>
        </trans-unit>
        <trans-unit id="798cc826b7c6eca17f20ac9967ed751d475d3bfa" translate="yes" xml:space="preserve">
          <source>To understand the difference, consider the following code:</source>
          <target state="translated">为了理解其中的区别,可以考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="b6b18d3db48c6c605af5cb1ff84864472fd83e2a" translate="yes" xml:space="preserve">
          <source>Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it's safe to use the &lt;code&gt;let&lt;/code&gt; statement. The answer to that question depends on your environment:</source>
          <target state="translated">但是，今天绝对不是这种情况。 实际上，我们实际上需要自问，使用 &lt;code&gt;let&lt;/code&gt; 语句是否安全。 该问题的答案取决于您的环境：</target>
        </trans-unit>
        <trans-unit id="cf0bd12b27a5d6ae801ae06ca45ff4d909c5e11f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. &lt;code&gt;var&lt;/code&gt; can be used when you want a global variable explicitly to be on the &lt;code&gt;window&lt;/code&gt; object (always consider carefully if this is really necessary).</source>
          <target state="translated">尽可能使用 &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; ,因为它的作用域更加具体。 这样可以减少在处理大量变量时可能发生的命名冲突。 当您希望将全局变量显式地放在 &lt;code&gt;window&lt;/code&gt; 对象上时，可以使用 &lt;code&gt;var&lt;/code&gt; （如果确实需要，请务必仔细考虑）。</target>
        </trans-unit>
        <trans-unit id="447b7b7549292e2e8a35c8c418af427a8697661b" translate="yes" xml:space="preserve">
          <source>Variable declared using &lt;code&gt;const&lt;/code&gt; can't be re-assigned.</source>
          <target state="translated">使用 &lt;code&gt;const&lt;/code&gt; 声明的变量无法重新分配。</target>
        </trans-unit>
        <trans-unit id="ea2f7a7e35f707d8856cdb8cb5665c534077fffb" translate="yes" xml:space="preserve">
          <source>Variables declared by &lt;strong&gt;let&lt;/strong&gt; have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, &lt;strong&gt;let&lt;/strong&gt; works very much like &lt;strong&gt;var&lt;/strong&gt;. The main difference is that the scope of a &lt;strong&gt;var&lt;/strong&gt; variable is the entire enclosing function:</source>
          <target state="translated">&lt;strong&gt;let&lt;/strong&gt;声明的变量的范围是定义它们的块以及任何包含的子块。 这样， &lt;strong&gt;让我们的&lt;/strong&gt;工作非常像&lt;strong&gt;var&lt;/strong&gt; 。 主要区别在于&lt;strong&gt;var&lt;/strong&gt;变量的范围是整个封闭函数：</target>
        </trans-unit>
        <trans-unit id="ac8b214aec9424ef9fffbc10e806c9b68d0341c2" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;let&lt;/code&gt; inside a block can't be accessed outside that block.</source>
          <target state="translated">在块内使用 &lt;code&gt;let&lt;/code&gt; 声明的变量不能在该块外访问。</target>
        </trans-unit>
        <trans-unit id="2b32e0f62bb42b1453a0aa34a0c6ccac71e925fd" translate="yes" xml:space="preserve">
          <source>Variables declared using the &lt;code&gt;let&lt;/code&gt; keyword are block-scoped, which means that they are available only in the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;block&lt;/a&gt; in which they were declared.</source>
          <target state="translated">使用 &lt;code&gt;let&lt;/code&gt; 关键字声明的变量是块作用域的，这意味着它们仅在声明它们的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;块&lt;/a&gt;中可用。</target>
        </trans-unit>
        <trans-unit id="86c41ca6962411581269ba19972206be437465f2" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;let&lt;/code&gt; in loops can be referenced only inside that loop.</source>
          <target state="translated">用 &lt;code&gt;let&lt;/code&gt; in循环声明的变量只能在该循环内部引用。</target>
        </trans-unit>
        <trans-unit id="b328fafa53d71ac4b0917bba556f26a497d46ea3" translate="yes" xml:space="preserve">
          <source>What are the differences? When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">有什么区别？ 什么时候应该在 &lt;code&gt;var&lt;/code&gt; 上使用？</target>
        </trans-unit>
        <trans-unit id="62485fc832e025ecfaffbb9e9fa16598e466214c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; 有什么区别？</target>
        </trans-unit>
        <trans-unit id="ba36ff7094458ce1f2d89aff408961ca118f85f3" translate="yes" xml:space="preserve">
          <source>What's the difference between using “let” and “var”</source>
          <target state="translated">使用 &quot;let &quot;和 &quot;var &quot;有什么区别?</target>
        </trans-unit>
        <trans-unit id="b646d47d71c5ed2befdf512e42079703b478e4c5" translate="yes" xml:space="preserve">
          <source>When the first function &lt;code&gt;testVar&lt;/code&gt; gets called the variable foo, declared with &lt;code&gt;var&lt;/code&gt;, is still accessible outside the &lt;code&gt;if&lt;/code&gt; statement. This variable &lt;code&gt;foo&lt;/code&gt; would be available &lt;strong&gt;everywhere&lt;/strong&gt; within the scope of the &lt;code&gt;testVar&lt;/code&gt;&lt;strong&gt;function&lt;/strong&gt;.</source>
          <target state="translated">当第一个函数 &lt;code&gt;testVar&lt;/code&gt; 被调用时，使用 &lt;code&gt;var&lt;/code&gt; 声明的变量foo仍然可以在 &lt;code&gt;if&lt;/code&gt; 语句之外访问。 在 &lt;code&gt;testVar&lt;/code&gt; &lt;strong&gt;函数&lt;/strong&gt;范围内的&lt;strong&gt;任何地方&lt;/strong&gt;都可以使用此变量 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1d1e9bfedfc5565d2a134910beb552ddd3db5af" translate="yes" xml:space="preserve">
          <source>When the second function &lt;code&gt;testLet&lt;/code&gt; gets called the variable bar, declared with &lt;code&gt;let&lt;/code&gt;, is only accessible inside the &lt;code&gt;if&lt;/code&gt; statement. Because variables declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt; (where a block is the code between curly brackets e.g &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt;, &lt;code&gt;function{}&lt;/code&gt;).</source>
          <target state="translated">当第二个函数 &lt;code&gt;testLet&lt;/code&gt; 被调用时，用 &lt;code&gt;let&lt;/code&gt; 声明的变量bar只能在 &lt;code&gt;if&lt;/code&gt; 语句内部访问。 因为用 &lt;code&gt;let&lt;/code&gt; 声明的变量是&lt;strong&gt;块范围的&lt;/strong&gt; （块是大括号之间的代码，例如 &lt;code&gt;if{}&lt;/code&gt; ， &lt;code&gt;for{}&lt;/code&gt; ， &lt;code&gt;function{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="763c20e32aedaf10fa2547617925238345016332" translate="yes" xml:space="preserve">
          <source>When used inside a block, let limits the variable's scope to that block. Note the difference between &lt;strong&gt;var&lt;/strong&gt; whose scope is inside the function where it is declared.</source>
          <target state="translated">在块内使用时，让该变量的作用域限制在该块内。 请注意&lt;strong&gt;var&lt;/strong&gt;之间的区别， &lt;strong&gt;var&lt;/strong&gt;的范围在声明它的函数内部。</target>
        </trans-unit>
        <trans-unit id="61cd92a023d0a31f010a274ec7d86e10c5421fb8" translate="yes" xml:space="preserve">
          <source>When you need a block level deceleration you can go with let and const
  instead of var.</source>
          <target state="translated">当你需要块级减速时,你可以用let和const代替var。</target>
        </trans-unit>
        <trans-unit id="6a368a87210137edc166a614258cbe6102456562" translate="yes" xml:space="preserve">
          <source>Whereas</source>
          <target state="translated">Whereas</target>
        </trans-unit>
        <trans-unit id="0fe1d7ee87c3a04d0ac51238b917cc2c9c89c5d5" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;hfoo&lt;/code&gt;, defined by &lt;code&gt;var&lt;/code&gt; is initially in the &lt;strong&gt;global scope&lt;/strong&gt;, but again when we declare it inside the &lt;code&gt;if clause&lt;/code&gt;, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference.</source>
          <target state="translated">而由 &lt;code&gt;var&lt;/code&gt; 定义的 &lt;code&gt;hfoo&lt;/code&gt; 最初位于&lt;strong&gt;全局范围内&lt;/strong&gt; ，但是当我们在 &lt;code&gt;if clause&lt;/code&gt; 声明它时，它仍然考虑全局范围hfoo，尽管再次使用var声明了它。 当我们重新分配它的值时，我们看到全局范围hfoo也受到了影响。 这是主要区别。</target>
        </trans-unit>
        <trans-unit id="e3e6995ec39780a0e837123289821ba1329d357a" translate="yes" xml:space="preserve">
          <source>Which results in counting [0, 7].</source>
          <target state="translated">其结果是计数[0,7]。</target>
        </trans-unit>
        <trans-unit id="3708d68bf42f4db9fe994838852e9983033235ad" translate="yes" xml:space="preserve">
          <source>While variables declared with &lt;code&gt;var&lt;/code&gt; keyword are &quot;hoisted&quot; to the top of the block which means they are accessible in their enclosing scope even before they are declared:</source>
          <target state="translated">尽管使用 &lt;code&gt;var&lt;/code&gt; 关键字声明的变量被&amp;ldquo;提升&amp;rdquo;到块的顶部，这意味着即使在声明它们之前，也可以在其封闭范围内访问它们：</target>
        </trans-unit>
        <trans-unit id="b0b01fae36659f37d265b081743cc0dc35597443" translate="yes" xml:space="preserve">
          <source>With a variable defined with var, if the Engine cannot find the variable in the current Execution Context's Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment's Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const.</source>
          <target state="translated">对于一个用var定义的变量,如果引擎在当前执行上下文的变量环境中找不到该变量,那么它就会在范围链(外部环境)中寻找该变量。如果在那里找不到,它将继续在范围链中搜索。而let和const的情况就不是这样。</target>
        </trans-unit>
        <trans-unit id="627826fe97bef52b6bbf6053deb38913659b0bdd" translate="yes" xml:space="preserve">
          <source>With this approach errors present in JavaScript are getting removed.</source>
          <target state="translated">通过这种方法,JavaScript中存在的错误会被删除。</target>
        </trans-unit>
        <trans-unit id="c3c2f48f1eb008d449f48eb15990b4f6e424e20b" translate="yes" xml:space="preserve">
          <source>You always must specify a value when declaring a variable using &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;const&lt;/code&gt; 声明变量时，必须始终指定一个值。</target>
        </trans-unit>
        <trans-unit id="0790cbb95ab5ec73d3e6258998a0a7ad3095843b" translate="yes" xml:space="preserve">
          <source>You can't declare the same variable multiple times using &lt;code&gt;let&lt;/code&gt;. You also can't declare a variable using &lt;code&gt;let&lt;/code&gt; with the same identifier as another variable which was declared using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">您不能使用 &lt;code&gt;let&lt;/code&gt; 多次声明相同的变量。 您也不能使用 &lt;code&gt;let&lt;/code&gt; 声明变量，该变量具有与另一个使用 &lt;code&gt;var&lt;/code&gt; 声明的变量相同的标识符。</target>
        </trans-unit>
        <trans-unit id="b2fce063a96f03a5121674374be0af6b8b24bce2" translate="yes" xml:space="preserve">
          <source>e.g. It scopes to the enclosing block, They don't exist before they're declared, etc.</source>
          <target state="translated">例如:它的作用域到包围块,它们在被声明之前是不存在的等等。</target>
        </trans-unit>
        <trans-unit id="d313532c8abb336dd50ad99fcaa46af296c26e1d" translate="yes" xml:space="preserve">
          <source>let is a part of es6. These functions will explain the difference in easy way.</source>
          <target state="translated">let是es6的一部分。这些功能将用简单的方法来解释其区别。</target>
        </trans-unit>
        <trans-unit id="c0ef6b5ab2d1b894e89fcae400b0537fb9a8b5ce" translate="yes" xml:space="preserve">
          <source>let vs var. It's all about &lt;strong&gt;scope&lt;/strong&gt;.</source>
          <target state="translated">让vs var。 这一切都与&lt;strong&gt;范围&lt;/strong&gt;有关。</target>
        </trans-unit>
        <trans-unit id="c278d52dd0385cbf90b767810934740d91018546" translate="yes" xml:space="preserve">
          <source>one of the most famous interview questions on scope also can suffice the exact use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; as below;</source>
          <target state="translated">关于范围的最著名的访谈问题之一也可以满足 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; 的确切用法，如下所示；</target>
        </trans-unit>
        <trans-unit id="2d408aaa5a340d732402a346a7f915ed8a3d8a04" translate="yes" xml:space="preserve">
          <source>test.js</source>
          <target state="translated">test.js</target>
        </trans-unit>
        <trans-unit id="b8ffef03491342b55d430f0b8e5920b4a84fcdb6" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't&lt;/strong&gt; get hoisted:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; &lt;strong&gt;不要&lt;/strong&gt;挂起变量：</target>
        </trans-unit>
        <trans-unit id="c588190991c2844f3923ec38efe295f544b19b2e" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;do&lt;/strong&gt; get hoisted:</source>
          <target state="translated">带有 &lt;code&gt;var&lt;/code&gt; 的变量&lt;strong&gt;确实&lt;/strong&gt;被吊起：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
