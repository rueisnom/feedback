<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/762011">
    <body>
      <group id="762011">
        <trans-unit id="fafcd2951a6c9ab9c6c43e67c5a38264f0cdd84a" translate="yes" xml:space="preserve">
          <source>... the loop unexpectedly outputs &quot;i is 5&quot; five times:</source>
          <target state="translated">...ループは予期せず「iは5」を5回出力してしまう。</target>
        </trans-unit>
        <trans-unit id="6d871bd011c025ac22e1d36c547f25316c14c79d" translate="yes" xml:space="preserve">
          <source>... the output remains unchanged as long as we stick with &lt;code&gt;let&lt;/code&gt;.  In contrast, if we had used &lt;code&gt;var i&lt;/code&gt; instead:</source>
          <target state="translated">... &lt;code&gt;let&lt;/code&gt; を使い続ける限り、出力は変わりません。 対照的に、代わりに &lt;code&gt;var i&lt;/code&gt; を使用した場合：</target>
        </trans-unit>
        <trans-unit id="43c75a7895bae9f2274a20daccd9c56125f42242" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;This table&lt;/a&gt; on Wikipedia shows which browsers support Javascript 1.7.</source>
          <target state="translated">Wikipediaの&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;この表は&lt;/a&gt; 、Javascript 1.7をサポートするブラウザーを示しています。</target>
        </trans-unit>
        <trans-unit id="0191d36331a7f5a9e5755b19f3d7de9c667f7b49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;My value: 3&lt;/code&gt; was output to console each time &lt;code&gt;funcs[j]();&lt;/code&gt; was invoked since anonymous functions were bound to the same variable.</source>
          <target state="translated">&lt;code&gt;My value: 3&lt;/code&gt; &lt;code&gt;funcs[j]();&lt;/code&gt; たびに3がコンソールに出力されました。 匿名関数が同じ変数にバインドされたため、呼び出されました。</target>
        </trans-unit>
        <trans-unit id="ccc17ff02fbc922f367c8a5b47195617bb23fb48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is a signal that the identifier won&amp;rsquo;t be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; は、識別子が再割り当てされないことを示す信号です。</target>
        </trans-unit>
        <trans-unit id="3308d036748c8401176277b68520b6bab4436169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is quite similar to &lt;code&gt;let&lt;/code&gt;&amp;mdash;it's block-scoped and has TDZ. There are, however, two things which are different.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; は &lt;code&gt;let&lt;/code&gt; と非常に似ています&amp;mdash;ブロックスコープで、TDZを持っています。 ただし、異なる点が2つあります。</target>
        </trans-unit>
        <trans-unit id="893fb0337fbc6374457738790cc8786afc01cbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is block scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; はブロックスコープです。</target>
        </trans-unit>
        <trans-unit id="0935015189555bca81712e46368bff07cdd2ad82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; は、クロージャーの問題を回避するためにも使用できます。 以下の例に示すように、古い参照を保持するのではなく、新しい値をバインドします。</target>
        </trans-unit>
        <trans-unit id="7da55d0ae5cba83af8d9bcddc15fbe75a305d540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; in the loop can &lt;strong&gt;re-binds it&lt;/strong&gt; to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,</source>
          <target state="translated">ループに &lt;code&gt;let&lt;/code&gt; て、 &lt;strong&gt;それ&lt;/strong&gt;をループの各反復に&lt;strong&gt;再バインドし&lt;/strong&gt; 、前のループ反復の最後から値を確実に再割り当てできるようにします。 考えて、</target>
        </trans-unit>
        <trans-unit id="898943cc10dae9aa57654db408d0e9820a07b17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is interesting, because it allows us to do something like this:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; は興味深いので、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="b00d42e90d9ff28c2ca17f2066eab4ca296f8fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are &lt;em&gt;easy to use&lt;/em&gt; with closures (they do not cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;race conditions&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 変数はクロージャーで&lt;em&gt;簡単に使用できます&lt;/em&gt; （ &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;競合状態を&lt;/a&gt;引き起こしません）。</target>
        </trans-unit>
        <trans-unit id="0af3806742f2c2f6ebb22613b4d0219aa7071dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a &lt;code&gt;ReferenceError&lt;/code&gt;. Variable said to be in &quot;temporal dead zone&quot; from the start of the block until the initialization is processed.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 変数は、その定義が評価されるまで初期化されません。 初期化の前にそれらにアクセスすると、 &lt;code&gt;ReferenceError&lt;/code&gt; が発生します。 ブロックの開始から初期化が処理されるまでの間、「一時的なデッドゾーン」にあるとされる変数。</target>
        </trans-unit>
        <trans-unit id="65ff7d9e010e2ad54c26d0e0600b56ceeb93776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only usable in lines of code that occur &lt;em&gt;after&lt;/em&gt; the variable is declared (even though &lt;a href=&quot;/questions/33198849&quot;&gt;they are hoisted&lt;/a&gt;!).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 変数は、変数が宣言された&lt;em&gt;後&lt;/em&gt;に発生するコード行でのみ使用できます（ &lt;a href=&quot;/questions/33198849&quot;&gt;それらが巻き上げられている&lt;/a&gt;場合でも！）。</target>
        </trans-unit>
        <trans-unit id="3ec2a907ce0b2eb98081f72a00f994a218703a4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only visible in their &lt;em&gt;nearest enclosing&lt;/em&gt; block (&lt;code&gt;{ ... }&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 変数は、 &lt;em&gt;最も近い囲み&lt;/em&gt;ブロック（ &lt;code&gt;{ ... }&lt;/code&gt; ）でのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="93fc717aea1571de33197157899b7efda524d39d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables cannot be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">変数はグローバルにアクセスできないため、 &lt;code&gt;window&lt;/code&gt; オブジェクトではアクセスできません。</target>
        </trans-unit>
        <trans-unit id="5c36689eca346124e71af49608677b1a82b86f74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables don't get hoisted:</source>
          <target state="translated">変数が巻き上げられないようにします。</target>
        </trans-unit>
        <trans-unit id="ca400981a08e8a909a0c3b4d1745acd5f90a1658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables may not be redeclared by a subsequent &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 変数は、後続の &lt;code&gt;var&lt;/code&gt; または &lt;code&gt;let&lt;/code&gt; で再宣言できません。</target>
        </trans-unit>
        <trans-unit id="f5bdfd10726565f7599def5824126d5b88cbe29b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; works very much like &lt;code&gt;var&lt;/code&gt;. The main difference is that the scope of a &lt;code&gt;var&lt;/code&gt; variable is the entire enclosing function</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; は &lt;code&gt;var&lt;/code&gt; と非常によく似ています。 主な違いは、 &lt;code&gt;var&lt;/code&gt; 変数のスコープが、それを囲む関数全体であることです。</target>
        </trans-unit>
        <trans-unit id="4a7e5a7da596e5ed599f94db730395d7fcdafdec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, is a signal that the variable may be reassigned, such as a
  counter in a loop, or a value swap in an algorithm. It also signals
  that the variable will be used only in the block it&amp;rsquo;s defined in,
  which is not always the entire containing function.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; は、ループ内のカウンターやアルゴリズムの値スワップなど、変数を再割り当てできることを示す信号です。 また、変数がそれが定義されているブロックでのみ使用されることを通知します。これは、必ずしもそれを含む関数全体ではありません。</target>
        </trans-unit>
        <trans-unit id="d7ac1ca1e5aa7a427f93aec2df1994a143404d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.</source>
          <target state="translated">ES5の &lt;code&gt;var&lt;/code&gt; と変数には関数内にスコープがあり、変数は関数内で有効であり、関数自体の外では有効ではありません。</target>
        </trans-unit>
        <trans-unit id="948a7ff5506461094cf4291aab6e19dc898ba6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is global scope (hoist-able) variable.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; はグローバルスコープ（ホイスト可能）変数です。</target>
        </trans-unit>
        <trans-unit id="5cfeb8565d205ecaa6279727ad54117c2209b10f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is now the weakest signal available when you define a variable
  in JavaScript. The variable may or may not be reassigned, and the
  variable may or may not be used for an entire function, or just for
  the purpose of a block or loop.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; は、JavaScriptで変数を定義するときに利用できる最も弱いシグナルになりました。 変数は再割り当てされる場合とされない場合があり、変数は関数全体に使用される場合と使用されない場合があり、ブロックまたはループの目的でのみ使用される場合があります。</target>
        </trans-unit>
        <trans-unit id="fbca8b19e8de6aba37b90ff0fc91b6e4429a273d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of &lt;code&gt;var&lt;/code&gt; for exports may be supplanted if &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; migrates out of transpiler space and into the core language.</source>
          <target state="translated">ループでクロージャーを使用する場合（＃5）、またはコード内で外部から見えるグローバル変数を宣言する場合（＃4）、シングルバインディングエフェクトが必要な場合は、 &lt;code&gt;var&lt;/code&gt; が役立つ場合があります。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt;がトランスパイラースペースからコア言語に移行する場合、 エクスポートに &lt;code&gt;var&lt;/code&gt; を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="0e636d2a81e1a762020c4f5c3744c8e65bfdd0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; variables can be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 変数はグローバルにアクセスできないため、 &lt;code&gt;window&lt;/code&gt; オブジェクト内でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="f7b28054bd2387937ff823de5e92e8d087509275" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;let&lt;/code&gt; will &lt;strong&gt;not hoist&lt;/strong&gt; to the entire scope of the block they appear in. By contrast, &lt;code&gt;var&lt;/code&gt; could hoist as below.&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;code&gt;let&lt;/code&gt; は、出現するブロックのスコープ全体を&lt;strong&gt;巻き上げません&lt;/strong&gt; 。対照的に、 &lt;code&gt;var&lt;/code&gt; は以下のように巻き上げます。 &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="8e5e8a4029ba67276f8775f560d25040ee366e1d" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;strong&gt;Variable Not Hoisting&lt;/strong&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;strong&gt;巻き上げない変数&lt;/strong&gt; &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;（*）JavaScript変数が&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;ホイスト&lt;/strong&gt;&lt;/a&gt;されるため、グローバルおよび機能的にスコープ指定された変数は、宣言される前に初期化して使用できます。&lt;/em&gt; これは、宣言が常にスコープの一番上にあることを意味します。</target>
        </trans-unit>
        <trans-unit id="b8a45f3633696567dffb096c46db365f09dc340f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(**) Block scoped variables are not hoisted&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（**）ブロックスコープの変数は巻き上げられません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a92f025526fcf6fd0e31e3883a2c0ce413ea45b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. No use outside nearest enclosing block:&lt;/strong&gt;
This block of code will throw a reference error because the second use of &lt;code&gt;x&lt;/code&gt; occurs outside of the block where it is declared with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;1.最も近い囲みブロックの外では使用しない：&lt;/strong&gt;このコードブロックは、 &lt;code&gt;x&lt;/code&gt; の2番目の使用が &lt;code&gt;let&lt;/code&gt; で宣言されているブロックの外で発生するため、参照エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="a1a3f78207be8aa46a711328247e402fe16ff7e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. No use before declaration:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.宣言の前に使用しない：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ebde23d0d3b7756808c6cc91ba63eefcda7c222" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. No redeclaration:&lt;/strong&gt;
The following code demonstrates that a variable declared with &lt;code&gt;let&lt;/code&gt; may not be redeclared later:</source>
          <target state="translated">&lt;strong&gt;3.再宣言なし：&lt;/strong&gt;次のコードは、 &lt;code&gt;let&lt;/code&gt; で宣言された変数が後で再宣言されない場合があることを示しています。</target>
        </trans-unit>
        <trans-unit id="3452dda34e6fe8760767335a5682fa96d4f633dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Globals not attached to &lt;code&gt;window&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4. &lt;code&gt;window&lt;/code&gt; アタッチされていないグローバル：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="117009c83c2e98d0a5ff10f1606e8d479850f1f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. Easy use with closures:&lt;/strong&gt;
Variables declared with &lt;code&gt;var&lt;/code&gt; do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable &lt;code&gt;i&lt;/code&gt; has at different points in time:</source>
          <target state="translated">&lt;strong&gt;5.クロージャーでの簡単な使用：&lt;/strong&gt; &lt;code&gt;var&lt;/code&gt; で宣言された変数は、ループ内のクロージャーではうまく機能しません。 以下は、変数 &lt;code&gt;i&lt;/code&gt; がさまざまな時点で持つ一連の値を出力する単純なループです。</target>
        </trans-unit>
        <trans-unit id="335cb1cc283f4951de3aa9563124b1b1306cd973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;let&lt;/code&gt; loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ループをし &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0320f62c5e659472d8791116df2b4f5d9063ed90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db7c704eb200ce249efd68f6671cae57bf115cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example2:&lt;/strong&gt;
In my second example  instead of using &lt;code&gt;var&lt;/code&gt; keyword in my conditional block I declare &lt;code&gt;myvar&lt;/code&gt; using &lt;code&gt;let&lt;/code&gt; keyword . Now when I call &lt;code&gt;myfunc&lt;/code&gt;  I get two different outputs: &lt;code&gt;myvar=20&lt;/code&gt; and &lt;code&gt;myvar=10&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;例&lt;/strong&gt; 2 &lt;strong&gt;：&lt;/strong&gt;条件ブロックで &lt;code&gt;var&lt;/code&gt; キーワードを使用する代わりに2番目の例で、 &lt;code&gt;let&lt;/code&gt; キーワードを使用して &lt;code&gt;myvar&lt;/code&gt; を宣言します。 ここで &lt;code&gt;myfunc&lt;/code&gt; を呼び出すと、2つの異なる出力 &lt;code&gt;myvar=20&lt;/code&gt; と &lt;code&gt;myvar=10&lt;/code&gt; が得られます。</target>
        </trans-unit>
        <trans-unit id="58d9ac26bea11358be0d1cbdd9e321d3ba6df33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Garbage Collection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ガベージコレクション&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a1048de1a3b6080b858a1b2bef0918699edce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you want to know more continue reading below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;もっと知りたい場合は、以下をお読みください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9c088750dbff02fab5817dc280550e5285cea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is a teaching example intended to demonstrate the &lt;code&gt;var&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは、ループでの &lt;code&gt;var&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; の動作と、わかりやすい関数クロージャを使用することを示すことを目的とした指導例です。 これは数字を追加する恐ろしい方法でしょう。 しかし、匿名の関数クロージャでデータをキャプチャする一般的な手法は、他のコンテキストでは現実の世界で遭遇する可能性があります。 YMMV。</target>
        </trans-unit>
        <trans-unit id="9e6852a37a94e37e3dd905af9505c512854ba77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; を使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fafd358dad99127a17812d83d6ef193969ca8ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; を使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd31b31858145616de45d3f80da7fc9d141990c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;いつ &lt;code&gt;var&lt;/code&gt; で使用 &lt;code&gt;let&lt;/code&gt; べきですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48515bd6359d686dcff1143b76e99f026ba355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; を使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bff2ad0c04ac8dd4df0359c5f2b7c4f5886e344c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; を使用する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="227b64041df706bf182aba5ae5ebd33a97ed7e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;let&lt;/strong&gt; allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the &lt;strong&gt;var&lt;/strong&gt; keyword, which defines a variable globally, or locally to an entire function regardless of block scope.</source>
          <target state="translated">&lt;strong&gt;letを&lt;/strong&gt;使用すると、スコープが限定されている変数を、それが使用されているブロック、ステートメント、または式に宣言できます。 これは、変数をグローバルに、またはブロックスコープに関係なく関数全体に対してローカルに定義する&lt;strong&gt;var&lt;/strong&gt;キーワードとは異なります。</target>
        </trans-unit>
        <trans-unit id="fab33e848b5ad8bcc20091c62c722cbb817e51ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var variables are global&lt;/strong&gt; and can be accessed basically everywhere, while &lt;strong&gt;let variables are not global&lt;/strong&gt; and only exist until a closing parenthesis kills them.</source>
          <target state="translated">&lt;strong&gt;var変数はグローバルで&lt;/strong&gt;あり、基本的にどこからでもアクセスでき&lt;strong&gt;ますが&lt;/strong&gt; 、 &lt;strong&gt;let変数はグローバル&lt;/strong&gt;で&lt;strong&gt;はなく&lt;/strong&gt; 、閉じ括弧がそれらを削除するまで存在します。</target>
        </trans-unit>
        <trans-unit id="db1da9a09bc08d7f8e50d60ea6a55e8863b78c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;let&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; を使用した変数：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29624d341db7c739c0aa200fbd55251cca369e02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;var&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;var&lt;/code&gt; を含む変数：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2946b23215e7bb86a85f078731e677392102c35a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Tested in Chrome and Firefox 50)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;（ChromeおよびFirefox 50でテスト済み）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="aac30eb1359108b02f390fbbab8124c9183cc1f9" translate="yes" xml:space="preserve">
          <source>A general workaround is to wrap this in an anonymous function and pass &lt;code&gt;i&lt;/code&gt; as an argument. Such issues can also be avoided now by using &lt;code&gt;let&lt;/code&gt; instead &lt;code&gt;var&lt;/code&gt; as shown in the code below.</source>
          <target state="translated">一般的な回避策は、これを無名関数でラップし、引数として &lt;code&gt;i&lt;/code&gt; を渡すことです。 このような問題は、以下のコードに示すように、 &lt;code&gt;var&lt;/code&gt; の代わりに &lt;code&gt;let&lt;/code&gt; を使用することでも回避できます。</target>
        </trans-unit>
        <trans-unit id="170078ca21bcbd02b1a827e5fbf53f3ea80c3232" translate="yes" xml:space="preserve">
          <source>A variable declared with &lt;code&gt;let&lt;/code&gt; in the global scope (which is code that is not in a function) doesn't get added as a property on the global &lt;code&gt;window&lt;/code&gt; object. For example (this code is in global scope):</source>
          <target state="translated">グローバルスコープ（関数にないコード）で &lt;code&gt;let&lt;/code&gt; を使用して宣言された変数は、グローバル &lt;code&gt;window&lt;/code&gt; オブジェクトのプロパティとして追加されません。 例（このコードはグローバルスコープにあります）：</target>
        </trans-unit>
        <trans-unit id="5f3e410272543a521cf9f1d7d1742e67dea8dc1b" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;let&lt;/code&gt; statement is only known in &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;the block&lt;/strong&gt;&lt;/a&gt; it is defined in, from the moment it is defined onward. &lt;em&gt;(**)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; ステートメントを使用して定義された変数は&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;/a&gt;それが定義された瞬間から、それが定義されて&lt;strong&gt;いるブロック&lt;/strong&gt;でのみ認識されます。 &lt;em&gt;（**）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09c9ab8e2032dd446f087702839d7b2ed4396ea6" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;var&lt;/code&gt; statement is known throughout &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; it is defined in, from the start of the function. &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; ステートメントを使用して定義された変数は、関数の開始時から、それが定義されて&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;いる関数&lt;/strong&gt;&lt;/a&gt;全体で認識されます。 &lt;em&gt;（*）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab370464f56e00eeb5cfc62076a9464592135e2" translate="yes" xml:space="preserve">
          <source>Actually, Per @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;Both &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; are hoisted&lt;/a&gt;.</source>
          <target state="translated">実際、@ Bergiによると、 &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt; &lt;code&gt;var&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt; の両方が巻き上げられ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8c89fecc35a8d73707d226f6f0b6a82d6dab14eb" translate="yes" xml:space="preserve">
          <source>Also don't forget it's ECMA6 feature, so it's not fully supported yet, so it's better always transpiles it to ECMA5 using Babel etc... for more info about visit &lt;a href=&quot;https://babeljs.io&quot;&gt;babel website&lt;/a&gt;</source>
          <target state="translated">ECMA6機能であることも忘れないでください。まだ完全にはサポートされていません。BabelWeb &lt;a href=&quot;https://babeljs.io&quot;&gt;サイトに&lt;/a&gt;アクセスする方法の詳細については、常にBabelなどを使用してECMA5にトランスパイルすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">また、ブロックスコープされた変数はホイストされていないので、宣言される前にはわからないと考えてください。また、同じブロック内で同じブロックスコープ変数を再宣言することもできません。これにより、ブロックスコープされた変数は、グローバルスコープされた変数や関数的にスコープされた変数よりもエラーが発生しにくくなり、 ホイストされ、複数の宣言をしてもエラーが発生しません。</target>
        </trans-unit>
        <trans-unit id="1c17b26bc3e4c8d3adc5ae1acfc117828aa6be96" translate="yes" xml:space="preserve">
          <source>And, finally, when it comes to the Execution Context, variables defined with var will be attached to the 'this' object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.</source>
          <target state="translated">そして最後に、実行コンテキストに関しては、var で定義された変数は 'this' オブジェクトにアタッチされます。グローバルな実行コンテキストでは、ブラウザのウィンドウオブジェクトになります。let や const の場合はそうではありません。</target>
        </trans-unit>
        <trans-unit id="71e68652a5ed74f047c3ac12095f037358e5e5ec" translate="yes" xml:space="preserve">
          <source>Another difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is variables with declared with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't get hoisted&lt;/strong&gt;. An example is the best way to illustrate this behavior:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt; のもう1つの違いは、 letで宣言された変数&lt;strong&gt;が巻き上げられないこと&lt;/strong&gt;です。 例は、この動作を説明する最良の方法です。</target>
        </trans-unit>
        <trans-unit id="35c52610045a80e7c59b43f1379714d89e0d6bc4" translate="yes" xml:space="preserve">
          <source>As mentioned above:</source>
          <target state="translated">前述したように</target>
        </trans-unit>
        <trans-unit id="249700b45578552db048d92af8fa978c2eefd5b3" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;code&gt;var j&lt;/code&gt; variable is still having a value outside of the for loop scope (Block Scope), but the &lt;code&gt;let i&lt;/code&gt; variable is undefined outside of the for loop scope.</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;var j&lt;/code&gt; 変数はforループスコープ（ブロックスコープ）の外に値を持っていますが、 &lt;code&gt;let i&lt;/code&gt; 変数はforループスコープの外では未定義です。</target>
        </trans-unit>
        <trans-unit id="d7def6645f985de2714bbee9073b7e35ce60ba9a" translate="yes" xml:space="preserve">
          <source>At the top level (outside of a function)</source>
          <target state="translated">トップレベル(機能の外側)で</target>
        </trans-unit>
        <trans-unit id="d2da2ac1a0c2449a02f42f9a07db9b2ad3e838df" translate="yes" xml:space="preserve">
          <source>At the top level of programs and functions, &lt;strong&gt;let&lt;/strong&gt;, unlike &lt;strong&gt;var&lt;/strong&gt;, does not create a property on the global object. For example:</source>
          <target state="translated">プログラムと関数のトップレベルでは、 &lt;strong&gt;let&lt;/strong&gt;は、 &lt;strong&gt;var&lt;/strong&gt;とは異なり、グローバルオブジェクトにプロパティを作成しません。 例えば：</target>
        </trans-unit>
        <trans-unit id="71df1ae66b61d0ab2fcbac24f66a246ff268b703" translate="yes" xml:space="preserve">
          <source>At the top level, &lt;code&gt;let&lt;/code&gt;, unlike &lt;code&gt;var&lt;/code&gt;, does not create a property on the global object:</source>
          <target state="translated">トップレベルで &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;var&lt;/code&gt; とは異なり、 letはグローバルオブジェクトにプロパティを作成しません。</target>
        </trans-unit>
        <trans-unit id="eeb6d3d38965924988affed9792df84c51af2547" translate="yes" xml:space="preserve">
          <source>At the top level, variables declared using &lt;code&gt;let&lt;/code&gt; don't create properties on the global object.</source>
          <target state="translated">トップレベルでは、 &lt;code&gt;let&lt;/code&gt; を使用して宣言された変数は、グローバルオブジェクトにプロパティを作成しません。</target>
        </trans-unit>
        <trans-unit id="515fa9e7c373ec2c33005604de0e7089c2d08190" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;let&lt;/code&gt; create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">a）イニシャライザ式b）各反復（以前はインクリメント式を評価するため）の名前で新しい字句環境を作成するため、詳細は&lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;ここにあります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="45b1a72deb4126ce6786cb6bf76705a80fcbb65a" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;the temporal dead zone&lt;/a&gt;, variables declared using &lt;code&gt;let&lt;/code&gt; can't be accessed before they are declared. Attempting to do so throws an error.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;一時的なデッドゾーン&lt;/a&gt;があるため、 &lt;code&gt;let&lt;/code&gt; を使用して宣言された変数は、宣言されるまでアクセスできません。 そうしようとすると、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">ブロックスコープ</target>
        </trans-unit>
        <trans-unit id="e40b499735af8fc0820476d34a1c0c219c1fd209" translate="yes" xml:space="preserve">
          <source>Block scope of &lt;code&gt;let&lt;/code&gt; is useful relates to closures and garbage collection to reclaim memory. Consider,</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; のブロックスコープは、メモリを再利用するためのクロージャーとガベージコレクションに関連しています。 考えて、</target>
        </trans-unit>
        <trans-unit id="6f29a62d2c8cafbe524c685a3421672ea1015266" translate="yes" xml:space="preserve">
          <source>Code above demonstrates a classic JavaScript closure problem. Reference to the &lt;code&gt;i&lt;/code&gt; variable is being stored in the click handler closure, rather than the actual value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">上記のコードは、古典的なJavaScriptクロージャの問題を示しています。 &lt;code&gt;i&lt;/code&gt; 変数への参照は、 iの実際の値ではなく、クリックハンドラークロージャーに格納されています。</target>
        </trans-unit>
        <trans-unit id="9e5c12eac220cda3fddead583cc6b0243277fa9e" translate="yes" xml:space="preserve">
          <source>Consequently, &lt;code&gt;let&lt;/code&gt; variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.</source>
          <target state="translated">したがって、変数を大きなプログラムで使用したり、独自に開発したフレームワークを予期しない方法で組み合わせたりすると、問題が発生する可能性が低くなります。</target>
        </trans-unit>
        <trans-unit id="f7261ea8dc8387f9126baa8bab22723bda98c65e" translate="yes" xml:space="preserve">
          <source>Creating global object property</source>
          <target state="translated">グローバルオブジェクトプロパティの作成</target>
        </trans-unit>
        <trans-unit id="a994290f95e1773d69448109bc715c0ac56c270d" translate="yes" xml:space="preserve">
          <source>Don't let this happen to you. Use a linter.</source>
          <target state="translated">こんなことにならないように リンターを使いましょう。</target>
        </trans-unit>
        <trans-unit id="bff237a3f67a2949d7f6e1f89d92205c1c43fd88" translate="yes" xml:space="preserve">
          <source>During the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised.</source>
          <target state="translated">実行コンテキストの作成フェーズでは、var,let,const は、与えられた実行コンテキストの変数環境に未定義の値を持つ変数をメモリに格納したままになります。違いは実行フェーズにあります。var で定義された変数に値が代入される前に参照を使用した場合、その変数は未定義のままになります。例外は発生しません。</target>
        </trans-unit>
        <trans-unit id="2b7177a34d2d0cacb674f1aac574068a765ae834" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;the &lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;は &lt;code&gt;let&lt;/code&gt; ステートメントを&lt;/a&gt;導入しました 。</target>
        </trans-unit>
        <trans-unit id="5cf86ea0199cf2cb7ab1e4b859d6da9f7e8d3b80" translate="yes" xml:space="preserve">
          <source>ES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.</source>
          <target state="translated">ES6 では、変数を宣言するための const キーワードも導入されています。letとconstの違いは、const変数はイニシャライザを使って宣言する必要があり、そうしないとエラーが発生することです。</target>
        </trans-unit>
        <trans-unit id="15fdc50ddc49f97069f55a0d0f0fb021296b8c98" translate="yes" xml:space="preserve">
          <source>ES6 introduced two new keyword(&lt;strong&gt;let&lt;/strong&gt; and &lt;strong&gt;const&lt;/strong&gt;) alternate to &lt;strong&gt;var&lt;/strong&gt;.</source>
          <target state="translated">ES6では、 &lt;strong&gt;varの&lt;/strong&gt;代わりに2つの新しいキーワード（ &lt;strong&gt;let&lt;/strong&gt;および&lt;strong&gt;const&lt;/strong&gt; ）が導入されました。</target>
        </trans-unit>
        <trans-unit id="fe55c1d6e2b8dc0fe7f0925eac13a3c7b9627f4c" translate="yes" xml:space="preserve">
          <source>Every single click handler will refer to the same object because there&amp;rsquo;s only one counter object which holds 6 so you get six on each click.</source>
          <target state="translated">6を保持するカウンターオブジェクトが1つしかないため、各クリックハンドラーは同じオブジェクトを参照するため、各クリックで6になります。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">この回答を読んだ時点で、どのブラウザが &lt;code&gt;let&lt;/code&gt; ステートメントをサポートしているかについての最新の概要については、 &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;この &lt;code&gt;Can I Use&lt;/code&gt; ページを参照してください&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2bcc0766379cd75d853f8179072c502df585067" translate="yes" xml:space="preserve">
          <source>Function VS block scope:</source>
          <target state="translated">関数VSブロックスコープ。</target>
        </trans-unit>
        <trans-unit id="44d7d3e4ae1a64d1cd2bf70aad9d679aa794df08" translate="yes" xml:space="preserve">
          <source>Getter and setter with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; を使用したゲッターとセッター：</target>
        </trans-unit>
        <trans-unit id="8ba873db511f120d8b04390f9365a000776baab4" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; doesn't get attached to &lt;code&gt;window&lt;/code&gt;:</source>
          <target state="translated">グローバル &lt;code&gt;let&lt;/code&gt; は &lt;code&gt;window&lt;/code&gt; にアタッチされません：</target>
        </trans-unit>
        <trans-unit id="1f8c6d41af972292b69739e49d1923eaf7ba5d69" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; variables are not added to the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">グローバル &lt;code&gt;let&lt;/code&gt; 変数はグローバル &lt;code&gt;window&lt;/code&gt; オブジェクトに追加されません。</target>
        </trans-unit>
        <trans-unit id="50ef81d10d2ac6892f207cc0aa959a31a393eb97" translate="yes" xml:space="preserve">
          <source>Here is an example for the difference between the two (support just started for chrome):</source>
          <target state="translated">ここでは、両者の違いを例に挙げてみます(クロームではサポートが始まったばかりです)。</target>
        </trans-unit>
        <trans-unit id="e80f82c5146fe3bdfce30d25078c548bf9fd7946" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;explanation of the &lt;code&gt;let&lt;/code&gt; keyword&lt;/a&gt; with some examples.</source>
          <target state="translated">以下に、いくつかの例を示し&lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;た &lt;code&gt;let&lt;/code&gt; キーワードの説明を&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="baf1aac8fe97893d9e8a5cc925df180108e841e0" translate="yes" xml:space="preserve">
          <source>Here's an example to add on to what others have already written. Suppose you want to make an array of functions, &lt;code&gt;adderFunctions&lt;/code&gt;, where each function takes a single Number argument and returns the sum of the argument and the function's index in the array. Trying to generate &lt;code&gt;adderFunctions&lt;/code&gt; with a loop using the &lt;code&gt;var&lt;/code&gt; keyword won't work the way someone might na&amp;iuml;vely expect:</source>
          <target state="translated">これは、他の人がすでに書いたものに追加する例です。 関数の配列 &lt;code&gt;adderFunctions&lt;/code&gt; を作成するとします。各関数は1つのNumber引数を取り、引数と関数のインデックスの配列の合計を返します。 &lt;code&gt;var&lt;/code&gt; キーワードを使用してループで &lt;code&gt;adderFunctions&lt;/code&gt; を生成しようとしても、誰かが単純に期待するようには機能しません。</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">ここで、変数 &lt;code&gt;j&lt;/code&gt; は最初のforループでのみ認識され、前後では認識されないことがわかります。 しかし、変数 &lt;code&gt;i&lt;/code&gt; は関数全体で知られています。</target>
        </trans-unit>
        <trans-unit id="7bcaf634e9dbfa99922f815d7eb0b950882fbc2c" translate="yes" xml:space="preserve">
          <source>Hoisting</source>
          <target state="translated">Hoisting</target>
        </trans-unit>
        <trans-unit id="a4b770c91602cb7a14569eb1fadf17b154c46e1d" translate="yes" xml:space="preserve">
          <source>Hoisting is not supported using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">巻き上げは &lt;code&gt;let&lt;/code&gt; を使用してサポートされていません。</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">ブラウザの対応状況を把握する方法</target>
        </trans-unit>
        <trans-unit id="02950dbbb2895580e2f47482bfdc271d60612939" translate="yes" xml:space="preserve">
          <source>However it's worth noting that &lt;code&gt;let&lt;/code&gt; is only a part of newer Javascript implementations and has varying degrees of &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;browser support&lt;/a&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;let&lt;/code&gt; は新しいJavascript実装の一部にすぎず、 &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;ブラウザのサポートの&lt;/a&gt;度合いがさまざまであることは注目に値します。</target>
        </trans-unit>
        <trans-unit id="a64dc9831d45af781fdad2758e3129f38608db33" translate="yes" xml:space="preserve">
          <source>However, replace &lt;code&gt;var&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">ただし、 &lt;code&gt;var&lt;/code&gt; を &lt;code&gt;let&lt;/code&gt; に置き換えます</target>
        </trans-unit>
        <trans-unit id="1942516de816b1215bfb3f885b92dce215fe8c87" translate="yes" xml:space="preserve">
          <source>However, the block scope can make this huge data structure to garbage collected.</source>
          <target state="translated">しかし、ブロックスコープは、この巨大なデータ構造をガベージコレクションにすることができます。</target>
        </trans-unit>
        <trans-unit id="210d598d2aa5b2252eb617a5677124f67bcfd03e" translate="yes" xml:space="preserve">
          <source>However, we can try again using the &lt;code&gt;let&lt;/code&gt; keyword:</source>
          <target state="translated">ただし、 &lt;code&gt;let&lt;/code&gt; キーワードを使用して再試行できます。</target>
        </trans-unit>
        <trans-unit id="1a13c0910c0809caa265aa5d59b7303182a3e913" translate="yes" xml:space="preserve">
          <source>However, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:</source>
          <target state="translated">ただし、let や const で宣言された変数が宣言されるまでは参照することはできません。宣言される前に使用しようとすると、実行コンテキストの実行フェーズで例外が発生します。これで、実行コンテキストの作成フェーズのおかげで変数はメモリ内に残りますが、エンジンはそれを使用することを許可しません。</target>
        </trans-unit>
        <trans-unit id="73b04d7e63d97817ad43a04a297f8ccd6b791760" translate="yes" xml:space="preserve">
          <source>I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.</source>
          <target state="translated">他の言語、Java、C#などのように、JavaScriptでも同じようなスコープを持つように、人々はここでletを使い始めると思います。</target>
        </trans-unit>
        <trans-unit id="60ed5394ff0a30a2c778db05382fc4f19f7dea8c" translate="yes" xml:space="preserve">
          <source>I think the terms and most of the examples are a bit overwhelming,
The main issue i had personally with the difference is understanding what a &quot;Block&quot; is.
At some point i realized, a block would be any curly brackets except for &lt;code&gt;IF&lt;/code&gt; statement.
an opening bracket &lt;code&gt;{&lt;/code&gt; of a function or loop will define a new block, anything defined with &lt;code&gt;let&lt;/code&gt; within it, will not be available after the closing bracket &lt;code&gt;}&lt;/code&gt; of the same thing (function or loop);
With that in mind, it was easier to understand:</source>
          <target state="translated">私は用語とほとんどの例は少し圧倒的だと思います、私が個人的に違いを持っ​​ていた主な問題は、「ブロック」が何であるかを理解することです。 ある時点で、 &lt;code&gt;IF&lt;/code&gt; ステートメント以外のブロックは中かっこになります。 &lt;code&gt;{&lt;/code&gt; 関数またはループの開始ブラケット{は、新しいブロックを定義します。その中で &lt;code&gt;let&lt;/code&gt; を使用して定義されたものはすべて、同じもの（関数またはループ）の終了ブラケット &lt;code&gt;}&lt;/code&gt; の後には使用できません。 これを念頭に置くと、理解しやすくなりました。</target>
        </trans-unit>
        <trans-unit id="652bcdb1cb95ff704c8f7f92231e2c819a6a619e" translate="yes" xml:space="preserve">
          <source>I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment).</source>
          <target state="translated">これらのキーワードを実行コンテキストにリンクさせたいと思います。実行コンテキストには、作成フェーズと実行フェーズの2つのフェーズがあります。また、各実行コンテキストには、変数環境と外部環境(そのレキシカル環境)があります。</target>
        </trans-unit>
        <trans-unit id="347c3b7704d41b142c7558f9df8c366aaa5c3ca9" translate="yes" xml:space="preserve">
          <source>I've heard it that it's described as a &quot;local&quot; variable, but I'm still not quite sure how it behaves differently than the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">「ローカル」変数として記述されていると聞きましたが、それが &lt;code&gt;var&lt;/code&gt; キーワードとどのように異なる動作をするのかはまだよくわかりません。</target>
        </trans-unit>
        <trans-unit id="a64f2d3dd931f8ac221f076d6aee461fa2e268f7" translate="yes" xml:space="preserve">
          <source>If I read the specs right then &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;thankfully&lt;/strong&gt; can also be leveraged to avoid &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;self invoking functions&lt;/a&gt; used to simulate private only members - &lt;em&gt;a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone's desire for semantics, so stop using it. /rant&lt;/em&gt;</source>
          <target state="translated">仕様を正しく読んだ場合は &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;ありがたい&lt;/strong&gt;ことに、プライベートのみのメンバーをシミュレートするために使用される&lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;自己呼び出し機能&lt;/a&gt;を回避するために活用することもできます。 &lt;em&gt;意味論に対する誰かの欲望なので、それの使用をやめてください。&lt;/em&gt; &lt;em&gt;/ rant&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efbed4ca5ff07a30fe5d1a50e4502bdb347bc1c0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.</source>
          <target state="translated">ループで &lt;code&gt;var&lt;/code&gt; の代わりに &lt;code&gt;let&lt;/code&gt; を使用すると、反復ごとに新しい変数が取得されます。 つまり、ループ内でクロージャを安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="17145a9a9f46d1b105d7a4debb8d941ee248c402" translate="yes" xml:space="preserve">
          <source>If you want to have an immutable object, you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;&lt;code&gt;Object.freeze()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不変オブジェクトが必要な場合は、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt; &lt;code&gt;Object.freeze()&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">クライアントサイドの JavaScript コードを書いていて、トランスパイラを使用していない場合は、ブラウザのサポートを考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">クライアント側のJavaScriptコードを記述していて、ノードベースのトランスパイラー（ &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceurシェルスクリプト&lt;/strong&gt;&lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babelなど&lt;/strong&gt;&lt;/a&gt; ）を使用している場合は、 &lt;code&gt;let&lt;/code&gt; ステートメントを安全に使用できます。 また、ブラウザーはトランスパイルされたコードのみを認識するため、パフォーマンスの低下は制限されます。</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">クライアント側のJavaScriptコードを記述していて、ブラウザーベースのトランスパイラー（ &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt;や&lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standaloneなど&lt;/strong&gt;&lt;/a&gt; ）を使用している場合は、 &lt;code&gt;let&lt;/code&gt; ステートメントを安全に使用できますが、コードはパフォーマンスに関して最適ではない可能性があります。</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">サーバーサイドJavaScriptコード（ &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ）を記述している場合は、 &lt;code&gt;let&lt;/code&gt; ステートメントを安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="cfc03d4531fe0bd76ba607e1e4e7d663c32df226" translate="yes" xml:space="preserve">
          <source>In JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">JavaScriptでは、多くの場合、変数が作成されたときよりもかなり遅い時間に変数を使用します。 &lt;code&gt;setTimeout&lt;/code&gt; に渡されたクロージャーで出力を遅らせることでこれを実証すると：</target>
        </trans-unit>
        <trans-unit id="7c9021c4e7876355e1fc36b9e227cb4de4425b66" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; parses and runs without throwing any exceptions.</source>
          <target state="translated">対照的に、 &lt;code&gt;var&lt;/code&gt; を使用した同じ例は、例外をスローせずに解析および実行されます。</target>
        </trans-unit>
        <trans-unit id="177519e8851b8c0bb348adf315a0cf3831599c1d" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; works.</source>
          <target state="translated">対照的に、 &lt;code&gt;var&lt;/code&gt; を使用した同じ例は機能します。</target>
        </trans-unit>
        <trans-unit id="dc8dcbdd636f8cb50991ca75851fcac1be59e3c5" translate="yes" xml:space="preserve">
          <source>In my both examples I have a function &lt;code&gt;myfunc&lt;/code&gt;. &lt;code&gt;myfunc&lt;/code&gt; contains a variable &lt;code&gt;myvar&lt;/code&gt; equals to 10. 
In my first example  I check   if &lt;code&gt;myvar&lt;/code&gt; equals to 10 (&lt;code&gt;myvar==10&lt;/code&gt;) . If yes, I agian declare  a variable  &lt;code&gt;myvar&lt;/code&gt; (now I have two myvar variables)using &lt;code&gt;var&lt;/code&gt; keyword and assign it a new value (20). In next line I  print its value on my console.  After the conditional block I again print the value of &lt;code&gt;myvar&lt;/code&gt; on my console. If you look at the output of &lt;code&gt;myfunc&lt;/code&gt;,   &lt;code&gt;myvar&lt;/code&gt; has value equals to 20.</source>
          <target state="translated">私の両方の例では、関数 &lt;code&gt;myfunc&lt;/code&gt; があります。 &lt;code&gt;myfunc&lt;/code&gt; には、 &lt;code&gt;myvar&lt;/code&gt; が10に等しい変数が含まれています。最初の例では、 &lt;code&gt;myvar&lt;/code&gt; が10（ &lt;code&gt;myvar==10&lt;/code&gt; ）に等しいかどうかを確認します。 はいの場合、アギアンは &lt;code&gt;var&lt;/code&gt; キーワードを使用して変数 &lt;code&gt;myvar&lt;/code&gt; （現在は2つのmyvar変数を持っています）を宣言し、 それに新しい値（20）を割り当てます。 次の行で、その値をコンソールに出力します。 条件付きブロックの後、再び &lt;code&gt;myvar&lt;/code&gt; の値をコンソールに出力します。 &lt;code&gt;myfunc&lt;/code&gt; の出力を見ると 、 &lt;code&gt;myvar&lt;/code&gt; の値は20です。</target>
        </trans-unit>
        <trans-unit id="d3eb240300b8d3cf3894acb662d9d55b4c3eeb9c" translate="yes" xml:space="preserve">
          <source>In practice, there are a number of useful consequences of the difference in scope:</source>
          <target state="translated">実際には、範囲の違いによる有用な結果がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="041cfe51d16fc06e7a90d0fdd25ff09d8de80054" translate="yes" xml:space="preserve">
          <source>In strict mode, &lt;code&gt;var&lt;/code&gt; will let you re-declare the same variable in the same scope while &lt;code&gt;let&lt;/code&gt; raises a SyntaxError.</source>
          <target state="translated">strictモードでは、 &lt;code&gt;var&lt;/code&gt; を使用すると、同じスコープ内で同じ変数を再宣言できますが、 &lt;code&gt;let&lt;/code&gt; はSyntaxErrorを発生させます。</target>
        </trans-unit>
        <trans-unit id="deb3d336c8ca38ed2c8a72be4787d1e826efc9a7" translate="yes" xml:space="preserve">
          <source>Initializer is required</source>
          <target state="translated">イニシャライザが必要</target>
        </trans-unit>
        <trans-unit id="6d007cc06c89e6bed5f7c97dc75f829442633823" translate="yes" xml:space="preserve">
          <source>Inside a block</source>
          <target state="translated">ブロックの中</target>
        </trans-unit>
        <trans-unit id="d187aaa9dbe696be70ed4733de46de8f53018d1e" translate="yes" xml:space="preserve">
          <source>Inside a function</source>
          <target state="translated">機能の内部</target>
        </trans-unit>
        <trans-unit id="6a19a43ce4368f97cd87fe72619ae5cd48410ed3" translate="yes" xml:space="preserve">
          <source>Inside a function (but outside of a block), &lt;code&gt;let&lt;/code&gt; has the same scope as &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">関数の内部（ただしブロックの外部）では、 &lt;code&gt;let&lt;/code&gt; のスコープは &lt;code&gt;var&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="b31aad9d36743f490f94cc21d201edada256344c" translate="yes" xml:space="preserve">
          <source>Inside a loop</source>
          <target state="translated">ループ内</target>
        </trans-unit>
        <trans-unit id="5f706b419d5afb2010d5c584c5073222be04bf3b" translate="yes" xml:space="preserve">
          <source>Is it safe to use &lt;code&gt;let&lt;/code&gt; today?</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; を今日使用しても安全ですか？</target>
        </trans-unit>
        <trans-unit id="2efd347d2f42601723d5af3a50c4b497df93e4c1" translate="yes" xml:space="preserve">
          <source>It also appears that, at least in Visual Studio 2015, TypeScript 1.5, &quot;var&quot; allows multiple declarations of the same variable name in a block, and &quot;let&quot; doesn't.</source>
          <target state="translated">また、少なくともVisual Studio 2015,TypeScript 1.5では、&quot;var &quot;はブロック内の同じ変数名の複数宣言を許可し、&quot;let &quot;は許可しないようです。</target>
        </trans-unit>
        <trans-unit id="5baa9813fadf06ec260f1610e850a5668ce5695e" translate="yes" xml:space="preserve">
          <source>Loops with closures</source>
          <target state="translated">クローズアップされたループ</target>
        </trans-unit>
        <trans-unit id="c0b7662f52c683b4a21a90043d995802030c5bd1" translate="yes" xml:space="preserve">
          <source>Main difference is scoping rules. Variables declared by &lt;code&gt;var&lt;/code&gt; keyword are scoped to the immediate function body (hence the function scope) while &lt;code&gt;let&lt;/code&gt; variables are scoped to the immediate &lt;em&gt;enclosing&lt;/em&gt; block denoted by &lt;code&gt;{ }&lt;/code&gt; (hence the block scope).</source>
          <target state="translated">主な違いはスコーピングルールです。 &lt;code&gt;var&lt;/code&gt; キーワードで宣言された変数のスコープは、直接の関数本体（つまり、関数スコープ）ですが &lt;code&gt;let&lt;/code&gt; 変数のスコープは、 &lt;code&gt;{ }&lt;/code&gt; 示される直接の&lt;em&gt;囲み&lt;/em&gt;ブロック（つまり、ブロックスコープ）です。</target>
        </trans-unit>
        <trans-unit id="99fbe1720bf011da269b2cac5512d7c3963a6968" translate="yes" xml:space="preserve">
          <source>May the following two functions show the difference:</source>
          <target state="translated">次の2つの関数で違いがわかりますように。</target>
        </trans-unit>
        <trans-unit id="63a3dc65c2f80ebaced4b3a1a62910c1da24fc2b" translate="yes" xml:space="preserve">
          <source>No re-assigning</source>
          <target state="translated">再指定なし</target>
        </trans-unit>
        <trans-unit id="39c7b7a1ef0ba49851ad5dfe7bd9144cb18d52c7" translate="yes" xml:space="preserve">
          <source>No re-declaring</source>
          <target state="translated">再宣言なし</target>
        </trans-unit>
        <trans-unit id="39c9178c32e097fcac397a91d250592e73365258" translate="yes" xml:space="preserve">
          <source>Note that it doesn't mean that the value is immutable. Its properties still can be changed.</source>
          <target state="translated">値が不変という意味ではないことに注意してください。そのプロパティはまだ変更可能です。</target>
        </trans-unit>
        <trans-unit id="f3a83e225fb411474c8b9361c4b05f98a38f3643" translate="yes" xml:space="preserve">
          <source>Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don't.</source>
          <target state="translated">MozillaとChromeブラウザだけがサポートしていることに注意してください。IE、Safari、および潜在的に他のブラウザは対応していません。</target>
        </trans-unit>
        <trans-unit id="96df0ec4b6def0a95acbbc1f79135059a56fd9f0" translate="yes" xml:space="preserve">
          <source>Now I think there is better scoping of variables to a block of statements using &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">今私は &lt;code&gt;let&lt;/code&gt; を使用してステートメントのブロックに変数のより良いスコープがあると思います：</target>
        </trans-unit>
        <trans-unit id="39076c4b7441e59ed2d91b8abe7ca8c4659cb0d2" translate="yes" xml:space="preserve">
          <source>Now, image mixing the two behaviors and you'll probably see why it's not recommended to mix the newer &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; with the older &lt;code&gt;var&lt;/code&gt; in the same script. Doing so can result is some spectacularly confusing code.</source>
          <target state="translated">ここで、2つの動作を混在させた画像を見ると、同じスクリプトで新しい &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; を古い変数と混在させることが推奨されない理由がわかるでしょう。 これを行うと、コードが非常に混乱する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8c2795ed8b2631b7e1915cc52073b53be8af53e9" translate="yes" xml:space="preserve">
          <source>Only counts [0, 1].</source>
          <target state="translated">0,1]のみをカウントします。</target>
        </trans-unit>
        <trans-unit id="efcf7de8b6bfc89725e070a6351b838be2c76f1b" translate="yes" xml:space="preserve">
          <source>People had to create immediately invoked functions to capture correct value from the loops but that was also hairy.</source>
          <target state="translated">人々はループから正しい値を取り込むために、すぐに呼び出される関数を作らなければなりませんでしたが、それもまた毛むくじゃらでした。</target>
        </trans-unit>
        <trans-unit id="2f5f2be0ca83a657f2ffc3bfa218814a5981da32" translate="yes" xml:space="preserve">
          <source>People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.</source>
          <target state="translated">JavaScriptのscopingをよく理解していない人は、先ほどの間違いを利用していました。</target>
        </trans-unit>
        <trans-unit id="285dc513fb5c7a7fc0e6eb93a0290e0641276542" translate="yes" xml:space="preserve">
          <source>Previously there were only two scopes in JavaScript, i.e. functional and global. With '&lt;code&gt;let&lt;/code&gt;' keyword JavaScript has now introduced &lt;code&gt;block-level&lt;/code&gt; variables.</source>
          <target state="translated">以前は、JavaScriptにはスコープが2つしかありませんでした。 ' &lt;code&gt;let&lt;/code&gt; 'キーワードを使用すると、JavaScriptに &lt;code&gt;block-level&lt;/code&gt; 変数が導入されました。</target>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="25b58933661327228329508e8c2cf1090c0253a0" translate="yes" xml:space="preserve">
          <source>Refer to &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth: let and const&lt;/a&gt;&lt;/em&gt; to understand it better.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6の&lt;/a&gt;&lt;/em&gt;詳細&lt;em&gt;：letとconst&lt;/em&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">スコーピングルール</target>
        </trans-unit>
        <trans-unit id="382bd8420b6d01443a65704ab49145af79643941" translate="yes" xml:space="preserve">
          <source>See '&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Emulating private interfaces&lt;/a&gt;'</source>
          <target state="translated">「 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;プライベートインターフェイス&lt;/a&gt;のエミュレート 」を参照してください</target>
        </trans-unit>
        <trans-unit id="9199fa6dee3c3db69201fd546b73324ee92bb5fc" translate="yes" xml:space="preserve">
          <source>See my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.</source>
          <target state="translated">以下の私の例を見てください。そして、lion (let)変数が 2 つの console.log でどのように異なる動作をしているかに注意してください。</target>
        </trans-unit>
        <trans-unit id="ce14680b0e5afa36020ec40b287ff3cdba706e04" translate="yes" xml:space="preserve">
          <source>So the difference is very simple i.e its scope.</source>
          <target state="translated">だから、違いは非常に単純なすなわちその範囲です。</target>
        </trans-unit>
        <trans-unit id="38c778b9cbefb5fbaad00a515fa6b89ce13a738d" translate="yes" xml:space="preserve">
          <source>Some hacks with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; を使ったハック：</target>
        </trans-unit>
        <trans-unit id="789fd33b37de1fced25ba88ee426bb6b49dcd4f3" translate="yes" xml:space="preserve">
          <source>Some people would argue that in the future we'll ONLY use let statements and that var statements will become obsolete. JavaScript guru &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Kyle Simpson&lt;/strong&gt;&lt;/a&gt; wrote &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;a very elaborate article on why he believes that won't be the case&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">一部の人々は、将来的にはletステートメントのみを使用し、varステートメントは廃止されると主張するでしょう。 JavaScriptの第一人者である&lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;カイル・シンプソン&lt;/strong&gt;&lt;/a&gt;は&lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;、彼がそうではないと信じる理由について非常に精巧な記事を&lt;/strong&gt;&lt;/a&gt;書きまし&lt;strong&gt;た&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="33a132a545bee29b8dcb5ddcc302b7c8534a609b" translate="yes" xml:space="preserve">
          <source>Specifically, this outputs:</source>
          <target state="translated">具体的には、これを出力します。</target>
        </trans-unit>
        <trans-unit id="c20042f3ec22b168b4441982da162a8418abc98a" translate="yes" xml:space="preserve">
          <source>Take a look at this example from &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;another stackoverflow question&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;別のstackoverflowの質問&lt;/a&gt;からこの例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="d2a5704984a4447527354be4a00cc8b22ced40f5" translate="yes" xml:space="preserve">
          <source>Temporal dead zone</source>
          <target state="translated">時間的不感帯</target>
        </trans-unit>
        <trans-unit id="a6c1c3dc63d914749b6854d3ab11a3b569eada69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;click&lt;/code&gt; handler callback does not need the &lt;code&gt;hugeData&lt;/code&gt; variable at all. Theoretically, after &lt;code&gt;process(..)&lt;/code&gt; runs, the huge data structure &lt;code&gt;hugeData&lt;/code&gt; could be garbage collected. However, it's possible that some JS engine will still have to keep this huge structure, since the &lt;code&gt;click&lt;/code&gt; function has a closure over the entire scope.</source>
          <target state="translated">&lt;code&gt;click&lt;/code&gt; ハンドラーコールバックは &lt;code&gt;hugeData&lt;/code&gt; 変数をまったく必要としません。 理論的には、 &lt;code&gt;process(..)&lt;/code&gt; 実行後、巨大なデータ構造 &lt;code&gt;hugeData&lt;/code&gt; がガベージコレクションされる可能性があります。 ただし、 &lt;code&gt;click&lt;/code&gt; 関数はスコープ全体にクロージャを持っているため、一部のJSエンジンはこの巨大な構造を維持する必要がある可能性があります 。</target>
        </trans-unit>
        <trans-unit id="264885cd88282bf28a8225c70ff7599f6d3df455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gfoo&lt;/code&gt;, defined by &lt;code&gt;let&lt;/code&gt; initially is in the &lt;strong&gt;global scope&lt;/strong&gt;, and when we declare &lt;code&gt;gfoo&lt;/code&gt; again inside the &lt;code&gt;if clause&lt;/code&gt; its &lt;strong&gt;&lt;em&gt;scope changed&lt;/em&gt;&lt;/strong&gt; and when a new value is assigned to the variable inside that scope it &lt;strong&gt;does not affect&lt;/strong&gt; the global scope.</source>
          <target state="translated">最初に &lt;code&gt;let&lt;/code&gt; によって定義された &lt;code&gt;gfoo&lt;/code&gt; は&lt;strong&gt;グローバルスコープ&lt;/strong&gt;にあり、 &lt;code&gt;if clause&lt;/code&gt; 内で &lt;code&gt;gfoo&lt;/code&gt; を再び宣言すると、 &lt;strong&gt;&lt;em&gt;スコープが変更され&lt;/em&gt;&lt;/strong&gt; 、その&lt;strong&gt;&lt;em&gt;スコープ&lt;/em&gt;&lt;/strong&gt;内の変数に新しい値が割り当てられても、グローバルスコープに&lt;strong&gt;は影響しません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="87b7ba6b84d1c61150fc37bf6a8f3727f5c2d5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword attaches the variable declaration to the scope of whatever block (commonly a &lt;code&gt;{ .. }&lt;/code&gt; pair) it's contained in. In other words,&lt;code&gt;let&lt;/code&gt; implicitly hijacks any block's scope for its variable declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; キーワードは、変数宣言を、それが含まれているブロック（通常は &lt;code&gt;{ .. }&lt;/code&gt; ペア）のスコープにアタッチします。つまり、 &lt;code&gt;let&lt;/code&gt; は、変数宣言のためにブロックのスコープを暗黙的にハイジャックします。</target>
        </trans-unit>
        <trans-unit id="78af92108bc96e8a42084047aaf363842f3b377a" translate="yes" xml:space="preserve">
          <source>The accepted answer is missing a point:</source>
          <target state="translated">受け入れられた答えは、ポイントが抜けている。</target>
        </trans-unit>
        <trans-unit id="073b339db7edb1c2e2e81ea60ac755f69153f037" translate="yes" xml:space="preserve">
          <source>The below shows how 'let' and 'var' are different in the scope:</source>
          <target state="translated">let'と'var'がスコープの中でどのように違うのかを示しています。</target>
        </trans-unit>
        <trans-unit id="4d9ba873fd7a30468256474a7c4d6e16988d829d" translate="yes" xml:space="preserve">
          <source>The below table summarize the difference between var, let and const</source>
          <target state="translated">以下の表は var,let と const の違いをまとめたものです。</target>
        </trans-unit>
        <trans-unit id="00a031e0941465964589ed342dbcebaa59ee6085" translate="yes" xml:space="preserve">
          <source>The difference is in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;scope&lt;/a&gt; of the variables declared with each.</source>
          <target state="translated">違いは、それぞれで宣言された変数の&lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;スコープ&lt;/a&gt;にあります。</target>
        </trans-unit>
        <trans-unit id="58bbbdd4908ae3e2d249c1fbdc5b3f5b43c376b1" translate="yes" xml:space="preserve">
          <source>The difference is scoping. &lt;code&gt;var&lt;/code&gt; is scoped to the nearest &lt;strong&gt;function
  block&lt;/strong&gt; and &lt;code&gt;let&lt;/code&gt; is scoped to the &lt;strong&gt;nearest enclosing block&lt;/strong&gt;, which
  can be smaller than a function block. Both are global if outside any
  block.Lets see an example:</source>
          <target state="translated">違いはスコープです。 &lt;code&gt;var&lt;/code&gt; のスコープは最も近い&lt;strong&gt;関数ブロックで&lt;/strong&gt; 、 &lt;code&gt;let&lt;/code&gt; のスコープは&lt;strong&gt;最も近い囲みブロックです&lt;/strong&gt; 。これは関数ブロックよりも小さい場合があります。 いずれかのブロックの外側にある場合、どちらもグローバルです。例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a2047a53cae852bc9bd4d5726d86bf1abdab5907" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is that variables declared with &lt;code&gt;var&lt;/code&gt; are &lt;strong&gt;function scoped&lt;/strong&gt;. Whereas functions declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt;. For example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt; の主な違いは、 varで宣言された変数が&lt;strong&gt;関数スコープであること&lt;/strong&gt;です。 一方、 &lt;code&gt;let&lt;/code&gt; で宣言された関数は&lt;strong&gt;ブロックスコープ&lt;/strong&gt;です。 例えば：</target>
        </trans-unit>
        <trans-unit id="8d162e4b209b454c9dcdb65956e1046635e203a9" translate="yes" xml:space="preserve">
          <source>The main difference is the &lt;strong&gt;scope&lt;/strong&gt; difference, while &lt;strong&gt;let&lt;/strong&gt; can be only available inside the &lt;strong&gt;scope&lt;/strong&gt; it's declared, like in for loop, &lt;strong&gt;var&lt;/strong&gt; can be accessed outside the loop for example. From the documentation in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (examples also from MDN):</source>
          <target state="translated">主な違いは&lt;strong&gt;スコープの&lt;/strong&gt;違いですが、 &lt;strong&gt;let&lt;/strong&gt;は宣言された&lt;strong&gt;スコープ&lt;/strong&gt;内でのみ使用できますが、forループの場合と同様に、たとえば&lt;strong&gt;var&lt;/strong&gt;はループの外側からアクセスできます。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt;のドキュメントから（ MDNの例も）：</target>
        </trans-unit>
        <trans-unit id="9f7f9f1e0a48709104afca6e8067da28df678148" translate="yes" xml:space="preserve">
          <source>The process above doesn't generate the desired array of functions because &lt;code&gt;i&lt;/code&gt;'s scope extends beyond the iteration of the &lt;code&gt;for&lt;/code&gt; block in which each function was created. Instead, at the end of the loop, the &lt;code&gt;i&lt;/code&gt; in each function's closure refers to &lt;code&gt;i&lt;/code&gt;'s value at the end of the loop (1000) for every anonymous function in &lt;code&gt;adderFunctions&lt;/code&gt;. This isn't what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of &lt;code&gt;i&lt;/code&gt;, the mutation will affect all the &lt;code&gt;adderFunctions&lt;/code&gt;.</source>
          <target state="translated">上記のプロセスは、 &lt;code&gt;i&lt;/code&gt; のスコープが各関数が作成された &lt;code&gt;for&lt;/code&gt; ブロックの反復を超えているため、目的の関数の配列を生成しません。 代わりに、ループの終わりで、各関数のクロージャーの &lt;code&gt;i&lt;/code&gt; は、 &lt;code&gt;adderFunctions&lt;/code&gt; のすべての匿名関数のループの終わり（1000）でのiの値を参照します。 これは私たちが望んでいたことではありません。まったく同じ動作をするメモリ内に1000の異なる関数の配列があります。 その後、 &lt;code&gt;i&lt;/code&gt; の値を更新すると、変更はすべての &lt;code&gt;adderFunctions&lt;/code&gt; に影響します。</target>
        </trans-unit>
        <trans-unit id="3451295aef647a9eb92f4f38d933a0e2d080e7e1" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;let&lt;/code&gt; keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; キーワードが言語に導入された理由は関数のスコープであり、JavaScriptのバグの主な原因の1つでした。</target>
        </trans-unit>
        <trans-unit id="11b109d5b87133e7c9f78aaa1557423809cb31f7" translate="yes" xml:space="preserve">
          <source>The restrictions imposed by &lt;code&gt;let&lt;/code&gt; reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;reachability&lt;/a&gt;(helping with reclaiming unused memory).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; によって課せられる制限により、変数の可視性が低下し、予期しない名前の衝突が早期に発見される可能性が高くなります。 これにより、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;到達可能性&lt;/a&gt;を含む変数の追跡と推論が容易になります（未使用のメモリの再利用に役立ちます）。</target>
        </trans-unit>
        <trans-unit id="e0d2bb460f6b296bc8aef7ab3dd6effc0df6f796" translate="yes" xml:space="preserve">
          <source>The second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.</source>
          <target state="translated">letの2つ目の特徴は、ブロックスコープを導入したことです。ブロックは中括弧で定義されます。例としては、関数ブロック、ifブロック、forブロックなどがあります。ブロック内で let を使って変数を宣言した場合、その変数はブロック内でのみ利用可能です。実際には、forループ内など、ブロックが実行されるたびに、メモリ内に新しい変数が作成されます。</target>
        </trans-unit>
        <trans-unit id="f0009b35b2bce48e37552dc2d483b1c142ec7b1e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences &amp;mdash; &lt;code&gt;let&lt;/code&gt; scoping behaves more like variable scoping does in more or less any other languages.</source>
          <target state="translated">微妙な違いがいくつかあります。スコーピングの動作を、他の言語での変数スコーピングの動作と同じようにします。</target>
        </trans-unit>
        <trans-unit id="582e7ce54a6962d9d96e460cfe6b27fdb7eed8a5" translate="yes" xml:space="preserve">
          <source>There are still some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; をまったくサポートしていないブラウザがまだいくつかあります：</target>
        </trans-unit>
        <trans-unit id="4ee4cc384a25d5e3ddde3e6500df25636cdfd4ce" translate="yes" xml:space="preserve">
          <source>This article clearly defines the difference between var, let and const</source>
          <target state="translated">この記事では、var、let、const の違いを明確に定義しています。</target>
        </trans-unit>
        <trans-unit id="556d5253d7e385c3f1d2c5b84329a06bb16d69f7" translate="yes" xml:space="preserve">
          <source>This block of code will throw a &lt;code&gt;ReferenceError&lt;/code&gt; before the code can be run because &lt;code&gt;x&lt;/code&gt; is used before it is declared:</source>
          <target state="translated">このコードブロックは、 &lt;code&gt;x&lt;/code&gt; が宣言される前にxが使用されるため、コードを実行する前に &lt;code&gt;ReferenceError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="25d7860a8b2663b86949e7ca85dafff841362dba" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;let&lt;/code&gt;, for every loop iteration the variable is scoped and has its own copy.</source>
          <target state="translated">これは、 &lt;code&gt;let&lt;/code&gt; を使用すると 、ループの反復ごとに変数がスコープされ、独自のコピーを持つためです。</target>
        </trans-unit>
        <trans-unit id="1edd9ce9f172dbb4d4b3887bc51fb5cf6e0bb712" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;var&lt;/code&gt;, for every loop iteration the variable is scoped and has shared copy.</source>
          <target state="translated">これは、 &lt;code&gt;var&lt;/code&gt; を使用すると、ループの反復ごとに変数のスコープが設定され、コピーが共有されるためです。</target>
        </trans-unit>
        <trans-unit id="a216ad59073ea6bd11a79ebc083a96139dca03f7" translate="yes" xml:space="preserve">
          <source>This time, &lt;code&gt;i&lt;/code&gt; is rebound on each iteration of the &lt;code&gt;for&lt;/code&gt; loop. Each function now keeps the value of &lt;code&gt;i&lt;/code&gt; at the time of the function's creation, and &lt;code&gt;adderFunctions&lt;/code&gt; behaves as expected.</source>
          <target state="translated">今回は、 &lt;code&gt;for&lt;/code&gt; ループの反復ごとにリバウンドします。 各関数は、関数の作成時に &lt;code&gt;i&lt;/code&gt; の値を保持し、 &lt;code&gt;adderFunctions&lt;/code&gt; は期待どおりに動作します。</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">これは、そうなるだろう。</target>
        </trans-unit>
        <trans-unit id="5dd7645a6d40c190e66e82b7ca6d2962889cfe89" translate="yes" xml:space="preserve">
          <source>This won't generate a compile error:</source>
          <target state="translated">これではコンパイルエラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="d36477f33831b971d8bfc3e95c1e4d91bef92cb1" translate="yes" xml:space="preserve">
          <source>To have a complete understanding of the 'let' keyword, &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;
ES6: &amp;lsquo;let&amp;rsquo; keyword to declare variable in JavaScript&lt;/a&gt;&lt;/em&gt; will help.</source>
          <target state="translated">「let」キーワードを完全に理解するには、 &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;ES6：JavaScriptで変数を宣言する「let」キーワード&lt;/a&gt;&lt;/em&gt;が役立ちます。</target>
        </trans-unit>
        <trans-unit id="798cc826b7c6eca17f20ac9967ed751d475d3bfa" translate="yes" xml:space="preserve">
          <source>To understand the difference, consider the following code:</source>
          <target state="translated">この違いを理解するために、次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="b6b18d3db48c6c605af5cb1ff84864472fd83e2a" translate="yes" xml:space="preserve">
          <source>Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it's safe to use the &lt;code&gt;let&lt;/code&gt; statement. The answer to that question depends on your environment:</source>
          <target state="translated">しかし、今日はそうではありません。 実際、 &lt;code&gt;let&lt;/code&gt; ステートメントを使用しても安全かどうかを自問する必要があります。 その質問に対する答えは、環境によって異なります。</target>
        </trans-unit>
        <trans-unit id="cf0bd12b27a5d6ae801ae06ca45ff4d909c5e11f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. &lt;code&gt;var&lt;/code&gt; can be used when you want a global variable explicitly to be on the &lt;code&gt;window&lt;/code&gt; object (always consider carefully if this is really necessary).</source>
          <target state="translated">単にスコープがより具体的であるため、可能な場合は常に &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; を使用してください。 これにより、多数の変数を処理するときに発生する可能性のある、名前の競合の可能性が減少します。 &lt;code&gt;var&lt;/code&gt; は、グローバル変数を明示的に &lt;code&gt;window&lt;/code&gt; オブジェクトに配置する場合に使用できます（これが本当に必要な場合は常に注意深く検討してください）。</target>
        </trans-unit>
        <trans-unit id="447b7b7549292e2e8a35c8c418af427a8697661b" translate="yes" xml:space="preserve">
          <source>Variable declared using &lt;code&gt;const&lt;/code&gt; can't be re-assigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; を使用して宣言された変数は再割り当てできません。</target>
        </trans-unit>
        <trans-unit id="ea2f7a7e35f707d8856cdb8cb5665c534077fffb" translate="yes" xml:space="preserve">
          <source>Variables declared by &lt;strong&gt;let&lt;/strong&gt; have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, &lt;strong&gt;let&lt;/strong&gt; works very much like &lt;strong&gt;var&lt;/strong&gt;. The main difference is that the scope of a &lt;strong&gt;var&lt;/strong&gt; variable is the entire enclosing function:</source>
          <target state="translated">&lt;strong&gt;let&lt;/strong&gt;によって宣言された変数は、そのスコープとして、それらが定義されているブロックと、それに含まれているサブブロックを持っています。 このように、 &lt;strong&gt;let&lt;/strong&gt;は&lt;strong&gt;varと&lt;/strong&gt;非常によく似ています。 主な違いは、 &lt;strong&gt;var&lt;/strong&gt;変数のスコープがそれを囲む関数全体であることです。</target>
        </trans-unit>
        <trans-unit id="ac8b214aec9424ef9fffbc10e806c9b68d0341c2" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;let&lt;/code&gt; inside a block can't be accessed outside that block.</source>
          <target state="translated">ブロック内で &lt;code&gt;let&lt;/code&gt; を使用して宣言された変数は、そのブロック外ではアクセスできません。</target>
        </trans-unit>
        <trans-unit id="2b32e0f62bb42b1453a0aa34a0c6ccac71e925fd" translate="yes" xml:space="preserve">
          <source>Variables declared using the &lt;code&gt;let&lt;/code&gt; keyword are block-scoped, which means that they are available only in the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;block&lt;/a&gt; in which they were declared.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; キーワードを使用して宣言された変数はブロックスコープです。つまり、変数は宣言された&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;ブロック&lt;/a&gt;でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="86c41ca6962411581269ba19972206be437465f2" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;let&lt;/code&gt; in loops can be referenced only inside that loop.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; inループで宣言された変数は、そのループ内でのみ参照できます。</target>
        </trans-unit>
        <trans-unit id="b328fafa53d71ac4b0917bba556f26a497d46ea3" translate="yes" xml:space="preserve">
          <source>What are the differences? When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">違いは何ですか？ いつ &lt;code&gt;var&lt;/code&gt; で使用 &lt;code&gt;let&lt;/code&gt; べきですか？</target>
        </trans-unit>
        <trans-unit id="62485fc832e025ecfaffbb9e9fa16598e466214c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; と &lt;code&gt;var&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="ba36ff7094458ce1f2d89aff408961ca118f85f3" translate="yes" xml:space="preserve">
          <source>What's the difference between using “let” and “var”</source>
          <target state="translated">let &quot;と &quot;var &quot;の違いは?</target>
        </trans-unit>
        <trans-unit id="b646d47d71c5ed2befdf512e42079703b478e4c5" translate="yes" xml:space="preserve">
          <source>When the first function &lt;code&gt;testVar&lt;/code&gt; gets called the variable foo, declared with &lt;code&gt;var&lt;/code&gt;, is still accessible outside the &lt;code&gt;if&lt;/code&gt; statement. This variable &lt;code&gt;foo&lt;/code&gt; would be available &lt;strong&gt;everywhere&lt;/strong&gt; within the scope of the &lt;code&gt;testVar&lt;/code&gt;&lt;strong&gt;function&lt;/strong&gt;.</source>
          <target state="translated">最初の関数 &lt;code&gt;testVar&lt;/code&gt; が呼び出されたときに、 &lt;code&gt;var&lt;/code&gt; で宣言された変数fooは、 &lt;code&gt;if&lt;/code&gt; ステートメントの外部から引き続きアクセスできます。 この変数 &lt;code&gt;foo&lt;/code&gt; は、 &lt;code&gt;testVar&lt;/code&gt; &lt;strong&gt;関数の&lt;/strong&gt;スコープ内の&lt;strong&gt;どこでも&lt;/strong&gt;使用でき&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1d1e9bfedfc5565d2a134910beb552ddd3db5af" translate="yes" xml:space="preserve">
          <source>When the second function &lt;code&gt;testLet&lt;/code&gt; gets called the variable bar, declared with &lt;code&gt;let&lt;/code&gt;, is only accessible inside the &lt;code&gt;if&lt;/code&gt; statement. Because variables declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt; (where a block is the code between curly brackets e.g &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt;, &lt;code&gt;function{}&lt;/code&gt;).</source>
          <target state="translated">2番目の関数 &lt;code&gt;testLet&lt;/code&gt; が呼び出されたとき、 &lt;code&gt;let&lt;/code&gt; で宣言された変数barは &lt;code&gt;if&lt;/code&gt; ステートメント内でのみアクセスできます。 &lt;code&gt;let&lt;/code&gt; で宣言された変数は&lt;strong&gt;ブロックスコープ&lt;/strong&gt; （ブロックは中括弧の間のコードです。たとえば &lt;code&gt;if{}&lt;/code&gt; 、 &lt;code&gt;for{}&lt;/code&gt; 、 &lt;code&gt;function{}&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="763c20e32aedaf10fa2547617925238345016332" translate="yes" xml:space="preserve">
          <source>When used inside a block, let limits the variable's scope to that block. Note the difference between &lt;strong&gt;var&lt;/strong&gt; whose scope is inside the function where it is declared.</source>
          <target state="translated">ブロック内で使用する場合、変数のスコープをそのブロックに制限します。 スコープが宣言されている関数内にある&lt;strong&gt;var&lt;/strong&gt;の違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="61cd92a023d0a31f010a274ec7d86e10c5421fb8" translate="yes" xml:space="preserve">
          <source>When you need a block level deceleration you can go with let and const
  instead of var.</source>
          <target state="translated">ブロックレベルの減速が必要な場合は、var の代わりに let や const を使うことができます。</target>
        </trans-unit>
        <trans-unit id="6a368a87210137edc166a614258cbe6102456562" translate="yes" xml:space="preserve">
          <source>Whereas</source>
          <target state="translated">Whereas</target>
        </trans-unit>
        <trans-unit id="0fe1d7ee87c3a04d0ac51238b917cc2c9c89c5d5" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;hfoo&lt;/code&gt;, defined by &lt;code&gt;var&lt;/code&gt; is initially in the &lt;strong&gt;global scope&lt;/strong&gt;, but again when we declare it inside the &lt;code&gt;if clause&lt;/code&gt;, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; で定義された &lt;code&gt;hfoo&lt;/code&gt; は最初は&lt;strong&gt;グローバルスコープ&lt;/strong&gt;にありますが、 &lt;code&gt;if clause&lt;/code&gt; 内で宣言すると、varを使用して宣言されていますが、グローバルスコープhfooが考慮されます。 そして、その値を再割り当てすると、グローバルスコープhfooも影響を受けることがわかります。 これが主な違いです。</target>
        </trans-unit>
        <trans-unit id="e3e6995ec39780a0e837123289821ba1329d357a" translate="yes" xml:space="preserve">
          <source>Which results in counting [0, 7].</source>
          <target state="translated">その結果、[0,7]を数えることになります。</target>
        </trans-unit>
        <trans-unit id="3708d68bf42f4db9fe994838852e9983033235ad" translate="yes" xml:space="preserve">
          <source>While variables declared with &lt;code&gt;var&lt;/code&gt; keyword are &quot;hoisted&quot; to the top of the block which means they are accessible in their enclosing scope even before they are declared:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; キーワードで宣言された変数はブロックの先頭に「巻き上げ」られますが、宣言される前であっても、それらの囲みスコープでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b0b01fae36659f37d265b081743cc0dc35597443" translate="yes" xml:space="preserve">
          <source>With a variable defined with var, if the Engine cannot find the variable in the current Execution Context's Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment's Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const.</source>
          <target state="translated">var で定義された変数で、現在の実行コンテキストの変数環境でその変数が見つからない場合、エンジンはスコープ チェーン (外部環境)をさかのぼり、外部環境の変数環境でその変数をチェックします。もしそこに変数が見つからなければ、スコープチェーンの検索を続けます。これは let や const の場合とは異なります。</target>
        </trans-unit>
        <trans-unit id="627826fe97bef52b6bbf6053deb38913659b0bdd" translate="yes" xml:space="preserve">
          <source>With this approach errors present in JavaScript are getting removed.</source>
          <target state="translated">この方法では、JavaScriptに存在するエラーを除去しています。</target>
        </trans-unit>
        <trans-unit id="c3c2f48f1eb008d449f48eb15990b4f6e424e20b" translate="yes" xml:space="preserve">
          <source>You always must specify a value when declaring a variable using &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; を使用して変数を宣言するときは、常に値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="0790cbb95ab5ec73d3e6258998a0a7ad3095843b" translate="yes" xml:space="preserve">
          <source>You can't declare the same variable multiple times using &lt;code&gt;let&lt;/code&gt;. You also can't declare a variable using &lt;code&gt;let&lt;/code&gt; with the same identifier as another variable which was declared using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; を使用して同じ変数を複数回宣言することはできません。 また、変数を &lt;code&gt;let&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; を使用して宣言された別の変数と同じ識別子でletを使用して宣言することもできません。</target>
        </trans-unit>
        <trans-unit id="b2fce063a96f03a5121674374be0af6b8b24bce2" translate="yes" xml:space="preserve">
          <source>e.g. It scopes to the enclosing block, They don't exist before they're declared, etc.</source>
          <target state="translated">例:囲んでいるブロックにスコープする、宣言される前には存在しない、など。</target>
        </trans-unit>
        <trans-unit id="d313532c8abb336dd50ad99fcaa46af296c26e1d" translate="yes" xml:space="preserve">
          <source>let is a part of es6. These functions will explain the difference in easy way.</source>
          <target state="translated">let は es6 の一部です。これらの関数の違いを簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="c0ef6b5ab2d1b894e89fcae400b0537fb9a8b5ce" translate="yes" xml:space="preserve">
          <source>let vs var. It's all about &lt;strong&gt;scope&lt;/strong&gt;.</source>
          <target state="translated">対変数をしましょう。 すべては&lt;strong&gt;スコープ&lt;/strong&gt;についてです。</target>
        </trans-unit>
        <trans-unit id="c278d52dd0385cbf90b767810934740d91018546" translate="yes" xml:space="preserve">
          <source>one of the most famous interview questions on scope also can suffice the exact use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; as below;</source>
          <target state="translated">スコープに関する最も有名なインタビューの質問の1つでも、以下のように &lt;code&gt;let&lt;/code&gt; と &lt;code&gt;var&lt;/code&gt; を正確に使用できます。</target>
        </trans-unit>
        <trans-unit id="2d408aaa5a340d732402a346a7f915ed8a3d8a04" translate="yes" xml:space="preserve">
          <source>test.js</source>
          <target state="translated">test.js</target>
        </trans-unit>
        <trans-unit id="b8ffef03491342b55d430f0b8e5920b4a84fcdb6" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't&lt;/strong&gt; get hoisted:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; を使用 &lt;strong&gt;した&lt;/strong&gt;変数は巻き上げられ&lt;strong&gt;ません&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c588190991c2844f3923ec38efe295f544b19b2e" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;do&lt;/strong&gt; get hoisted:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; を持つ変数は巻き上げられます：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
