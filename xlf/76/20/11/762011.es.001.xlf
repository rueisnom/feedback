<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/762011">
    <body>
      <group id="762011">
        <trans-unit id="fafcd2951a6c9ab9c6c43e67c5a38264f0cdd84a" translate="yes" xml:space="preserve">
          <source>... the loop unexpectedly outputs &quot;i is 5&quot; five times:</source>
          <target state="translated">...el bucle inesperadamente produce &quot;i es 5&quot; cinco veces:</target>
        </trans-unit>
        <trans-unit id="6d871bd011c025ac22e1d36c547f25316c14c79d" translate="yes" xml:space="preserve">
          <source>... the output remains unchanged as long as we stick with &lt;code&gt;let&lt;/code&gt;.  In contrast, if we had used &lt;code&gt;var i&lt;/code&gt; instead:</source>
          <target state="translated">... la salida permanece sin cambios mientras nos quedemos con &lt;code&gt;let&lt;/code&gt; . Por el contrario, si hubi&amp;eacute;ramos usado &lt;code&gt;var i&lt;/code&gt; en su lugar:</target>
        </trans-unit>
        <trans-unit id="43c75a7895bae9f2274a20daccd9c56125f42242" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;This table&lt;/a&gt; on Wikipedia shows which browsers support Javascript 1.7.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript#Version_history&quot;&gt;Esta tabla&lt;/a&gt; en Wikipedia muestra qu&amp;eacute; navegadores admiten Javascript 1.7.</target>
        </trans-unit>
        <trans-unit id="0191d36331a7f5a9e5755b19f3d7de9c667f7b49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;My value: 3&lt;/code&gt; was output to console each time &lt;code&gt;funcs[j]();&lt;/code&gt; was invoked since anonymous functions were bound to the same variable.</source>
          <target state="translated">&lt;code&gt;My value: 3&lt;/code&gt; sali&amp;oacute; a la consola cada vez que &lt;code&gt;funcs[j]();&lt;/code&gt; fue invocado ya que las funciones an&amp;oacute;nimas estaban vinculadas a la misma variable.</target>
        </trans-unit>
        <trans-unit id="ccc17ff02fbc922f367c8a5b47195617bb23fb48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is a signal that the identifier won&amp;rsquo;t be reassigned.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; es una se&amp;ntilde;al de que el identificador no ser&amp;aacute; reasignado.</target>
        </trans-unit>
        <trans-unit id="3308d036748c8401176277b68520b6bab4436169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is quite similar to &lt;code&gt;let&lt;/code&gt;&amp;mdash;it's block-scoped and has TDZ. There are, however, two things which are different.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; es bastante similar a &lt;code&gt;let&lt;/code&gt; : tiene un alcance de bloque y tiene TDZ. Sin embargo, hay dos cosas que son diferentes.</target>
        </trans-unit>
        <trans-unit id="893fb0337fbc6374457738790cc8786afc01cbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is block scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; es el alcance del bloque.</target>
        </trans-unit>
        <trans-unit id="0935015189555bca81712e46368bff07cdd2ad82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; can also be used to avoid problems with closures. It binds fresh value rather than keeping an old reference as shown in examples below.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; tambi&amp;eacute;n se puede usar para evitar problemas con los cierres. Vincula un valor nuevo en lugar de mantener una referencia antigua como se muestra en los ejemplos a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7da55d0ae5cba83af8d9bcddc15fbe75a305d540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; in the loop can &lt;strong&gt;re-binds it&lt;/strong&gt; to each iteration of the loop, making sure to re-assign it the value from the end of the previous loop iteration. Consider,</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; in the loop puede &lt;strong&gt;volver a vincularlo&lt;/strong&gt; a cada iteraci&amp;oacute;n del loop, asegur&amp;aacute;ndose de reasignarle el valor desde el final de la iteraci&amp;oacute;n del bucle anterior. Considerar,</target>
        </trans-unit>
        <trans-unit id="898943cc10dae9aa57654db408d0e9820a07b17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is interesting, because it allows us to do something like this:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; es interesante, porque nos permite hacer algo como esto:</target>
        </trans-unit>
        <trans-unit id="b00d42e90d9ff28c2ca17f2066eab4ca296f8fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are &lt;em&gt;easy to use&lt;/em&gt; with closures (they do not cause &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;race conditions&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; variables let son &lt;em&gt;f&amp;aacute;ciles de usar&lt;/em&gt; con los cierres (no causan &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition#Software&quot;&gt;condiciones de carrera&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0af3806742f2c2f6ebb22613b4d0219aa7071dc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are not initialized until their definition is evaluated. Accessing them before the initialization results in a &lt;code&gt;ReferenceError&lt;/code&gt;. Variable said to be in &quot;temporal dead zone&quot; from the start of the block until the initialization is processed.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; variables no se inicialicen hasta que se eval&amp;uacute;e su definici&amp;oacute;n. Acceder a ellos antes de la inicializaci&amp;oacute;n da como resultado un &lt;code&gt;ReferenceError&lt;/code&gt; . Se dice que la variable est&amp;aacute; en &quot;zona muerta temporal&quot; desde el inicio del bloque hasta que se procesa la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="65ff7d9e010e2ad54c26d0e0600b56ceeb93776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only usable in lines of code that occur &lt;em&gt;after&lt;/em&gt; the variable is declared (even though &lt;a href=&quot;/questions/33198849&quot;&gt;they are hoisted&lt;/a&gt;!).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; variables solo se puedan usar en l&amp;iacute;neas de c&amp;oacute;digo que se producen &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; que se declara la variable (&amp;iexcl;aunque &lt;a href=&quot;/questions/33198849&quot;&gt;se hayan izado&lt;/a&gt; !).</target>
        </trans-unit>
        <trans-unit id="3ec2a907ce0b2eb98081f72a00f994a218703a4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables are only visible in their &lt;em&gt;nearest enclosing&lt;/em&gt; block (&lt;code&gt;{ ... }&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; variables let solo son visibles en su bloque de &lt;em&gt;cierre m&amp;aacute;s cercano&lt;/em&gt; ( &lt;code&gt;{ ... }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="93fc717aea1571de33197157899b7efda524d39d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables cannot be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">No se puede acceder a las variables &lt;code&gt;let&lt;/code&gt; en el objeto de &lt;code&gt;window&lt;/code&gt; porque no se puede acceder globalmente.</target>
        </trans-unit>
        <trans-unit id="5c36689eca346124e71af49608677b1a82b86f74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables don't get hoisted:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; variables no se levanten:</target>
        </trans-unit>
        <trans-unit id="ca400981a08e8a909a0c3b4d1745acd5f90a1658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; variables may not be redeclared by a subsequent &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; variables let no pueden ser redeclaradas por una &lt;code&gt;var&lt;/code&gt; o &lt;code&gt;let&lt;/code&gt; posterior.</target>
        </trans-unit>
        <trans-unit id="f5bdfd10726565f7599def5824126d5b88cbe29b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; works very much like &lt;code&gt;var&lt;/code&gt;. The main difference is that the scope of a &lt;code&gt;var&lt;/code&gt; variable is the entire enclosing function</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; funciona mucho como &lt;code&gt;var&lt;/code&gt; . La principal diferencia es que el alcance de una variable &lt;code&gt;var&lt;/code&gt; es la funci&amp;oacute;n de cierre completa</target>
        </trans-unit>
        <trans-unit id="4a7e5a7da596e5ed599f94db730395d7fcdafdec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, is a signal that the variable may be reassigned, such as a
  counter in a loop, or a value swap in an algorithm. It also signals
  that the variable will be used only in the block it&amp;rsquo;s defined in,
  which is not always the entire containing function.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; , es una se&amp;ntilde;al de que la variable puede reasignarse, como un contador en un bucle o un intercambio de valores en un algoritmo. Tambi&amp;eacute;n indica que la variable se usar&amp;aacute; solo en el bloque en el que est&amp;aacute; definida, que no siempre es la funci&amp;oacute;n que contiene todo.</target>
        </trans-unit>
        <trans-unit id="d7ac1ca1e5aa7a427f93aec2df1994a143404d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; and variables in ES5 has scopes in functions meaning the variables are valid within the function and not outside the function itself.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; y variables en ES5 tienen &amp;aacute;mbitos en las funciones, lo que significa que las variables son v&amp;aacute;lidas dentro de la funci&amp;oacute;n y no fuera de la funci&amp;oacute;n misma.</target>
        </trans-unit>
        <trans-unit id="948a7ff5506461094cf4291aab6e19dc898ba6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is global scope (hoist-able) variable.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; es una variable de alcance global (con capacidad de elevaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="5cfeb8565d205ecaa6279727ad54117c2209b10f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; is now the weakest signal available when you define a variable
  in JavaScript. The variable may or may not be reassigned, and the
  variable may or may not be used for an entire function, or just for
  the purpose of a block or loop.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; es ahora la se&amp;ntilde;al m&amp;aacute;s d&amp;eacute;bil disponible cuando define una variable en JavaScript. La variable se puede reasignar o no, y la variable se puede usar o no para una funci&amp;oacute;n completa, o solo con el prop&amp;oacute;sito de un bloque o bucle.</target>
        </trans-unit>
        <trans-unit id="fbca8b19e8de6aba37b90ff0fc91b6e4429a273d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; may still be useful if you are sure you want the single-binding effect when using a closure in a loop (#5) or for declaring externally-visible global variables in your code (#4).  Use of &lt;code&gt;var&lt;/code&gt; for exports may be supplanted if &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; migrates out of transpiler space and into the core language.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; a&amp;uacute;n puede ser &amp;uacute;til si est&amp;aacute; seguro de que desea el efecto de enlace &amp;uacute;nico al usar un cierre en un bucle (# 5) o para declarar variables globales visibles externamente en su c&amp;oacute;digo (# 4). El uso de &lt;code&gt;var&lt;/code&gt; para las exportaciones puede suplantarse si la &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export&quot;&gt; &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n&lt;/a&gt; migra fuera del espacio del transpilador al lenguaje central.</target>
        </trans-unit>
        <trans-unit id="0e636d2a81e1a762020c4f5c3744c8e65bfdd0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; variables can be accessed in the &lt;code&gt;window&lt;/code&gt; object because they cannot be globally accessed.</source>
          <target state="translated">Se puede acceder a las variables &lt;code&gt;var&lt;/code&gt; en el objeto de &lt;code&gt;window&lt;/code&gt; porque no se puede acceder globalmente.</target>
        </trans-unit>
        <trans-unit id="f7b28054bd2387937ff823de5e92e8d087509275" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;let&lt;/code&gt; will &lt;strong&gt;not hoist&lt;/strong&gt; to the entire scope of the block they appear in. By contrast, &lt;code&gt;var&lt;/code&gt; could hoist as below.&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;no se&lt;/strong&gt; elevar&amp;aacute; a todo el alcance del bloque en el que aparecen. Por el contrario, &lt;code&gt;var&lt;/code&gt; podr&amp;iacute;a elevarse como se muestra a continuaci&amp;oacute;n. &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="8e5e8a4029ba67276f8775f560d25040ee366e1d" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;strong&gt;Variable Not Hoisting&lt;/strong&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt; &lt;strong&gt;Variable sin elevaci&amp;oacute;n&lt;/strong&gt; &lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;(*) Las variables de &amp;aacute;mbito global y funcional pueden inicializarse y utilizarse antes de declararse porque las variables de JavaScript est&amp;aacute;n &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;izadas&lt;/strong&gt;&lt;/a&gt; .&lt;/em&gt; Esto significa que las declaraciones siempre est&amp;aacute;n en lo m&amp;aacute;s alto del alcance.</target>
        </trans-unit>
        <trans-unit id="b8a45f3633696567dffb096c46db365f09dc340f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(**) Block scoped variables are not hoisted&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(**) Las variables de &amp;aacute;mbito de bloque no se izan&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a92f025526fcf6fd0e31e3883a2c0ce413ea45b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. No use outside nearest enclosing block:&lt;/strong&gt;
This block of code will throw a reference error because the second use of &lt;code&gt;x&lt;/code&gt; occurs outside of the block where it is declared with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;1. No usar fuera del bloque de cierre m&amp;aacute;s cercano:&lt;/strong&gt; este bloque de c&amp;oacute;digo arrojar&amp;aacute; un error de referencia porque el segundo uso de &lt;code&gt;x&lt;/code&gt; ocurre fuera del bloque donde se declara con &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1a3f78207be8aa46a711328247e402fe16ff7e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. No use before declaration:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Sin uso antes de la declaraci&amp;oacute;n:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ebde23d0d3b7756808c6cc91ba63eefcda7c222" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. No redeclaration:&lt;/strong&gt;
The following code demonstrates that a variable declared with &lt;code&gt;let&lt;/code&gt; may not be redeclared later:</source>
          <target state="translated">&lt;strong&gt;3. Sin redeclaraci&amp;oacute;n:&lt;/strong&gt; el siguiente c&amp;oacute;digo demuestra que una variable declarada con &lt;code&gt;let&lt;/code&gt; no se puede volver a declarar m&amp;aacute;s tarde:</target>
        </trans-unit>
        <trans-unit id="3452dda34e6fe8760767335a5682fa96d4f633dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Globals not attached to &lt;code&gt;window&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4. Globales no unidos a la &lt;code&gt;window&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="117009c83c2e98d0a5ff10f1606e8d479850f1f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5. Easy use with closures:&lt;/strong&gt;
Variables declared with &lt;code&gt;var&lt;/code&gt; do not work well with closures inside loops.  Here is a simple loop that outputs the sequence of values that the variable &lt;code&gt;i&lt;/code&gt; has at different points in time:</source>
          <target state="translated">&lt;strong&gt;5. Uso f&amp;aacute;cil con cierres: las&lt;/strong&gt; variables declaradas con &lt;code&gt;var&lt;/code&gt; no funcionan bien con los cierres dentro de los bucles. Aqu&amp;iacute; hay un bucle simple que genera la secuencia de valores que la variable &lt;code&gt;i&lt;/code&gt; tiene en diferentes momentos:</target>
        </trans-unit>
        <trans-unit id="335cb1cc283f4951de3aa9563124b1b1306cd973" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;let&lt;/code&gt; loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;let&lt;/code&gt; bucles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0320f62c5e659472d8791116df2b4f5d9063ed90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db7c704eb200ce249efd68f6671cae57bf115cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example2:&lt;/strong&gt;
In my second example  instead of using &lt;code&gt;var&lt;/code&gt; keyword in my conditional block I declare &lt;code&gt;myvar&lt;/code&gt; using &lt;code&gt;let&lt;/code&gt; keyword . Now when I call &lt;code&gt;myfunc&lt;/code&gt;  I get two different outputs: &lt;code&gt;myvar=20&lt;/code&gt; and &lt;code&gt;myvar=10&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Ejemplo2:&lt;/strong&gt; en mi segundo ejemplo, en lugar de usar la palabra clave &lt;code&gt;var&lt;/code&gt; en mi bloque condicional, declaro &lt;code&gt;myvar&lt;/code&gt; usando la palabra clave &lt;code&gt;let&lt;/code&gt; . Ahora cuando llamo a &lt;code&gt;myfunc&lt;/code&gt; obtengo dos salidas diferentes: &lt;code&gt;myvar=20&lt;/code&gt; y &lt;code&gt;myvar=10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d9ac26bea11358be0d1cbdd9e321d3ba6df33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Garbage Collection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Recolecci&amp;oacute;n de basura&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d8a1048de1a3b6080b858a1b2bef0918699edce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you want to know more continue reading below&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Si quieres saber m&amp;aacute;s sigue leyendo a continuaci&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9c088750dbff02fab5817dc280550e5285cea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is a teaching example intended to demonstrate the &lt;code&gt;var&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt; behavior in loops and with function closures that would also be easy to understand. This would be a terrible way to add numbers. But the general technique of capturing data in anonymous function closures might be encountered in the real world in other contexts. YMMV.</source>
          <target state="translated">&lt;strong&gt;NOTA:&lt;/strong&gt; Este es un ejemplo de ense&amp;ntilde;anza destinado a demostrar el comportamiento &lt;code&gt;var&lt;/code&gt; / &lt;code&gt;let&lt;/code&gt; en bucles y con cierres de funciones que tambi&amp;eacute;n ser&amp;iacute;an f&amp;aacute;ciles de entender. Esta ser&amp;iacute;a una forma terrible de sumar n&amp;uacute;meros. Pero la t&amp;eacute;cnica general de captura de datos en el cierre de funciones an&amp;oacute;nimas podr&amp;iacute;a encontrarse en el mundo real en otros contextos. YMMV.</target>
        </trans-unit>
        <trans-unit id="9e6852a37a94e37e3dd905af9505c512854ba77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Al usar &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fafd358dad99127a17812d83d6ef193969ca8ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When Using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cuando se usa &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd31b31858145616de45d3f80da7fc9d141990c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Cu&amp;aacute;ndo deber&amp;iacute;a &lt;code&gt;let&lt;/code&gt; usar sobre &lt;code&gt;var&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48515bd6359d686dcff1143b76e99f026ba355" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;let&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cuando use &lt;code&gt;let&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bff2ad0c04ac8dd4df0359c5f2b7c4f5886e344c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using &lt;code&gt;var&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cuando se usa &lt;code&gt;var&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="227b64041df706bf182aba5ae5ebd33a97ed7e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;let&lt;/strong&gt; allows you to declare variables that are limited in scope to the block, statement, or expression on which it is used. This is unlike the &lt;strong&gt;var&lt;/strong&gt; keyword, which defines a variable globally, or locally to an entire function regardless of block scope.</source>
          <target state="translated">&lt;strong&gt;let le&lt;/strong&gt; permite declarar variables que tienen un alcance limitado al bloque, declaraci&amp;oacute;n o expresi&amp;oacute;n en la que se usa. Esto es diferente a la palabra clave &lt;strong&gt;var&lt;/strong&gt; , que define una variable globalmente o localmente para una funci&amp;oacute;n completa, independientemente del alcance del bloque.</target>
        </trans-unit>
        <trans-unit id="fab33e848b5ad8bcc20091c62c722cbb817e51ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var variables are global&lt;/strong&gt; and can be accessed basically everywhere, while &lt;strong&gt;let variables are not global&lt;/strong&gt; and only exist until a closing parenthesis kills them.</source>
          <target state="translated">&lt;strong&gt;Las variables var son globales&lt;/strong&gt; y se puede acceder b&amp;aacute;sicamente a todas partes, mientras &lt;strong&gt;que las variables let no son globales&lt;/strong&gt; y solo existen hasta que un par&amp;eacute;ntesis de cierre las mata.</target>
        </trans-unit>
        <trans-unit id="db1da9a09bc08d7f8e50d60ea6a55e8863b78c6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;let&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;variables con &lt;code&gt;let&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29624d341db7c739c0aa200fbd55251cca369e02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variables with &lt;code&gt;var&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;variables con &lt;code&gt;var&lt;/code&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2946b23215e7bb86a85f078731e677392102c35a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Tested in Chrome and Firefox 50)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Probado en Chrome y Firefox 50)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="aac30eb1359108b02f390fbbab8124c9183cc1f9" translate="yes" xml:space="preserve">
          <source>A general workaround is to wrap this in an anonymous function and pass &lt;code&gt;i&lt;/code&gt; as an argument. Such issues can also be avoided now by using &lt;code&gt;let&lt;/code&gt; instead &lt;code&gt;var&lt;/code&gt; as shown in the code below.</source>
          <target state="translated">Una soluci&amp;oacute;n general es envolver esto en una funci&amp;oacute;n an&amp;oacute;nima y pasar &lt;code&gt;i&lt;/code&gt; como argumento. Tales problemas tambi&amp;eacute;n se pueden evitar ahora usando &lt;code&gt;let&lt;/code&gt; en su lugar &lt;code&gt;var&lt;/code&gt; como se muestra en el c&amp;oacute;digo a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="170078ca21bcbd02b1a827e5fbf53f3ea80c3232" translate="yes" xml:space="preserve">
          <source>A variable declared with &lt;code&gt;let&lt;/code&gt; in the global scope (which is code that is not in a function) doesn't get added as a property on the global &lt;code&gt;window&lt;/code&gt; object. For example (this code is in global scope):</source>
          <target state="translated">Una variable declarada con &lt;code&gt;let&lt;/code&gt; en el &amp;aacute;mbito global (que es un c&amp;oacute;digo que no est&amp;aacute; en una funci&amp;oacute;n) no se agrega como una propiedad en el objeto de la &lt;code&gt;window&lt;/code&gt; global. Por ejemplo (este c&amp;oacute;digo est&amp;aacute; en alcance global):</target>
        </trans-unit>
        <trans-unit id="5f3e410272543a521cf9f1d7d1742e67dea8dc1b" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;let&lt;/code&gt; statement is only known in &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;the block&lt;/strong&gt;&lt;/a&gt; it is defined in, from the moment it is defined onward. &lt;em&gt;(**)&lt;/em&gt;</source>
          <target state="translated">Una variable definida usando una declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; solo se conoce en &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;&lt;strong&gt;el bloque&lt;/strong&gt;&lt;/a&gt; en &lt;strong&gt;el&lt;/strong&gt; que se define, desde el momento en que se define en adelante. &lt;em&gt;(**)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09c9ab8e2032dd446f087702839d7b2ed4396ea6" translate="yes" xml:space="preserve">
          <source>A variable defined using a &lt;code&gt;var&lt;/code&gt; statement is known throughout &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; it is defined in, from the start of the function. &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">Una variable definida usando una instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; es conocida en toda &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;la funci&amp;oacute;n en la&lt;/strong&gt;&lt;/a&gt; que est&amp;aacute; definida, desde el inicio de la funci&amp;oacute;n. &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab370464f56e00eeb5cfc62076a9464592135e2" translate="yes" xml:space="preserve">
          <source>Actually, Per @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;Both &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; are hoisted&lt;/a&gt;.</source>
          <target state="translated">En realidad, por @Bergi, &lt;a href=&quot;https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6&quot;&gt;tanto &lt;code&gt;var&lt;/code&gt; como &lt;code&gt;let&lt;/code&gt; son izados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c89fecc35a8d73707d226f6f0b6a82d6dab14eb" translate="yes" xml:space="preserve">
          <source>Also don't forget it's ECMA6 feature, so it's not fully supported yet, so it's better always transpiles it to ECMA5 using Babel etc... for more info about visit &lt;a href=&quot;https://babeljs.io&quot;&gt;babel website&lt;/a&gt;</source>
          <target state="translated">Adem&amp;aacute;s, no olvide que es la funci&amp;oacute;n ECMA6, por lo que a&amp;uacute;n no es totalmente compatible, por lo que es mejor que siempre lo transpile a ECMA5 usando Babel, etc. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el &lt;a href=&quot;https://babeljs.io&quot;&gt;sitio web de Babel&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">Además,considere que las variables de ámbito de bloque no se conocen antes de ser declaradas porque no se izan.Tampoco se permite redeclarar la misma variable de ámbito de bloque dentro del mismo bloque.Esto hace que las variables de ámbito de bloque sean menos propensas a errores que las variables de ámbito global o funcional,que se elevan y que no producen ningún error en caso de declaraciones múltiples.</target>
        </trans-unit>
        <trans-unit id="1c17b26bc3e4c8d3adc5ae1acfc117828aa6be96" translate="yes" xml:space="preserve">
          <source>And, finally, when it comes to the Execution Context, variables defined with var will be attached to the 'this' object. In the global Execution Context, that will be the window object in browsers. This is not the case for let or const.</source>
          <target state="translated">Y,finalmente,cuando se trata del Contexto de Ejecución,las variables definidas con var se adjuntarán al objeto &quot;este&quot;.En el Contexto de Ejecución global,ese será el objeto ventana en los navegadores.Este no es el caso de let o const.</target>
        </trans-unit>
        <trans-unit id="71e68652a5ed74f047c3ac12095f037358e5e5ec" translate="yes" xml:space="preserve">
          <source>Another difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is variables with declared with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't get hoisted&lt;/strong&gt;. An example is the best way to illustrate this behavior:</source>
          <target state="translated">Otra diferencia entre &lt;code&gt;var&lt;/code&gt; y &lt;code&gt;let&lt;/code&gt; es que las variables declaradas con &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;no se izan&lt;/strong&gt; . Un ejemplo es la mejor manera de ilustrar este comportamiento:</target>
        </trans-unit>
        <trans-unit id="35c52610045a80e7c59b43f1379714d89e0d6bc4" translate="yes" xml:space="preserve">
          <source>As mentioned above:</source>
          <target state="translated">Como ya se ha mencionado:</target>
        </trans-unit>
        <trans-unit id="249700b45578552db048d92af8fa978c2eefd5b3" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;code&gt;var j&lt;/code&gt; variable is still having a value outside of the for loop scope (Block Scope), but the &lt;code&gt;let i&lt;/code&gt; variable is undefined outside of the for loop scope.</source>
          <target state="translated">Como puede ver, la variable &lt;code&gt;var j&lt;/code&gt; todav&amp;iacute;a tiene un valor fuera del alcance del bucle for (Alcance del bloque), pero la variable &lt;code&gt;let i&lt;/code&gt; no est&amp;aacute; definida fuera del alcance del bucle for.</target>
        </trans-unit>
        <trans-unit id="d7def6645f985de2714bbee9073b7e35ce60ba9a" translate="yes" xml:space="preserve">
          <source>At the top level (outside of a function)</source>
          <target state="translated">En el nivel superior (fuera de una función)</target>
        </trans-unit>
        <trans-unit id="d2da2ac1a0c2449a02f42f9a07db9b2ad3e838df" translate="yes" xml:space="preserve">
          <source>At the top level of programs and functions, &lt;strong&gt;let&lt;/strong&gt;, unlike &lt;strong&gt;var&lt;/strong&gt;, does not create a property on the global object. For example:</source>
          <target state="translated">En el nivel superior de programas y funciones, &lt;strong&gt;let&lt;/strong&gt; , a diferencia de &lt;strong&gt;var&lt;/strong&gt; , no crea una propiedad en el objeto global. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="71df1ae66b61d0ab2fcbac24f66a246ff268b703" translate="yes" xml:space="preserve">
          <source>At the top level, &lt;code&gt;let&lt;/code&gt;, unlike &lt;code&gt;var&lt;/code&gt;, does not create a property on the global object:</source>
          <target state="translated">En el nivel superior, &lt;code&gt;let&lt;/code&gt; , a diferencia de &lt;code&gt;var&lt;/code&gt; , no crea una propiedad en el objeto global:</target>
        </trans-unit>
        <trans-unit id="eeb6d3d38965924988affed9792df84c51af2547" translate="yes" xml:space="preserve">
          <source>At the top level, variables declared using &lt;code&gt;let&lt;/code&gt; don't create properties on the global object.</source>
          <target state="translated">En el nivel superior, las variables declaradas con &lt;code&gt;let&lt;/code&gt; no crean propiedades en el objeto global.</target>
        </trans-unit>
        <trans-unit id="515fa9e7c373ec2c33005604de0e7089c2d08190" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;let&lt;/code&gt; create a new lexical environment with those names for a) the initialiser expression b) each iteration (previosly to evaluating the increment expression), more details are &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Debido a &lt;code&gt;let&lt;/code&gt; creemos un nuevo entorno l&amp;eacute;xico con esos nombres para a) la expresi&amp;oacute;n inicializadora b) cada iteraci&amp;oacute;n (antes de evaluar la expresi&amp;oacute;n de incremento), hay m&amp;aacute;s detalles &lt;a href=&quot;https://stackoverflow.com/a/30900289/3011380&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45b1a72deb4126ce6786cb6bf76705a80fcbb65a" translate="yes" xml:space="preserve">
          <source>Because of &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;the temporal dead zone&lt;/a&gt;, variables declared using &lt;code&gt;let&lt;/code&gt; can't be accessed before they are declared. Attempting to do so throws an error.</source>
          <target state="translated">Debido a &lt;a href=&quot;https://stackoverflow.com/q/33198849/3853934&quot;&gt;la zona muerta temporal&lt;/a&gt; , no se puede acceder a las variables declaradas usando &lt;code&gt;let&lt;/code&gt; antes de que se declaren. Intentar hacerlo arroja un error.</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Bloquear el alcance</target>
        </trans-unit>
        <trans-unit id="e40b499735af8fc0820476d34a1c0c219c1fd209" translate="yes" xml:space="preserve">
          <source>Block scope of &lt;code&gt;let&lt;/code&gt; is useful relates to closures and garbage collection to reclaim memory. Consider,</source>
          <target state="translated">El alcance de bloque de &lt;code&gt;let&lt;/code&gt; es &amp;uacute;til en relaci&amp;oacute;n con los cierres y la recolecci&amp;oacute;n de basura para recuperar memoria. Considerar,</target>
        </trans-unit>
        <trans-unit id="6f29a62d2c8cafbe524c685a3421672ea1015266" translate="yes" xml:space="preserve">
          <source>Code above demonstrates a classic JavaScript closure problem. Reference to the &lt;code&gt;i&lt;/code&gt; variable is being stored in the click handler closure, rather than the actual value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">El c&amp;oacute;digo anterior muestra un problema cl&amp;aacute;sico de cierre de JavaScript. La referencia a la variable &lt;code&gt;i&lt;/code&gt; se almacena en el cierre del controlador de clics, en lugar del valor real de &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5c12eac220cda3fddead583cc6b0243277fa9e" translate="yes" xml:space="preserve">
          <source>Consequently, &lt;code&gt;let&lt;/code&gt; variables are less likely to cause problems when used in large programs or when independently-developed frameworks are combined in new and unexpected ways.</source>
          <target state="translated">En consecuencia, es menos probable &lt;code&gt;let&lt;/code&gt; variables causen problemas cuando se usan en programas grandes o cuando los marcos desarrollados independientemente se combinan de formas nuevas e inesperadas.</target>
        </trans-unit>
        <trans-unit id="f7261ea8dc8387f9126baa8bab22723bda98c65e" translate="yes" xml:space="preserve">
          <source>Creating global object property</source>
          <target state="translated">Creación de la propiedad del objeto global</target>
        </trans-unit>
        <trans-unit id="a994290f95e1773d69448109bc715c0ac56c270d" translate="yes" xml:space="preserve">
          <source>Don't let this happen to you. Use a linter.</source>
          <target state="translated">No dejes que esto te pase a ti.Usa un forro.</target>
        </trans-unit>
        <trans-unit id="bff237a3f67a2949d7f6e1f89d92205c1c43fd88" translate="yes" xml:space="preserve">
          <source>During the Creation Phase of an Execution Context, var, let and const will still store its variable in memory with an undefined value in the Variable Environment of the given Execution Context. The difference is in the Execution Phase. If you use reference a variable defined with var before it is assigned a value, it will just be undefined. No exception will be raised.</source>
          <target state="translated">Durante la fase de creación de un contexto de ejecución,var,let y const seguirán almacenando su variable en la memoria con un valor indefinido en el entorno variable del contexto de ejecución dado.La diferencia está en la Fase de Ejecución.Si usas como referencia una variable definida con var antes de que se le asigne un valor,simplemente será indefinida.No se planteará ninguna excepción.</target>
        </trans-unit>
        <trans-unit id="2b7177a34d2d0cacb674f1aac574068a765ae834" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;the &lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 6 introdujo &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cf86ea0199cf2cb7ab1e4b859d6da9f7e8d3b80" translate="yes" xml:space="preserve">
          <source>ES6 also introduces the const keyword for declaring variables. const is also block scoped. The difference between let and const is that const variables need to be declared using an initializer, or it will generate an error.</source>
          <target state="translated">ES6 también introduce la palabra clave const para declarar las variables.const también tiene un alcance de bloque.La diferencia entre let y const es que las variables const necesitan ser declaradas usando un inicializador,o se generará un error.</target>
        </trans-unit>
        <trans-unit id="15fdc50ddc49f97069f55a0d0f0fb021296b8c98" translate="yes" xml:space="preserve">
          <source>ES6 introduced two new keyword(&lt;strong&gt;let&lt;/strong&gt; and &lt;strong&gt;const&lt;/strong&gt;) alternate to &lt;strong&gt;var&lt;/strong&gt;.</source>
          <target state="translated">ES6 introdujo dos nuevas palabras clave ( &lt;strong&gt;let&lt;/strong&gt; y &lt;strong&gt;const&lt;/strong&gt; ) alternativas a &lt;strong&gt;var&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fe55c1d6e2b8dc0fe7f0925eac13a3c7b9627f4c" translate="yes" xml:space="preserve">
          <source>Every single click handler will refer to the same object because there&amp;rsquo;s only one counter object which holds 6 so you get six on each click.</source>
          <target state="translated">Cada controlador de un solo clic se referir&amp;aacute; al mismo objeto porque solo hay un objeto de contador que contiene 6, por lo que obtienes seis en cada clic.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener una descripci&amp;oacute;n actualizada de los navegadores que admiten la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; al momento de leer esta respuesta, consulte &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;esta p&amp;aacute;gina &lt;code&gt;Can I Use&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="c2bcc0766379cd75d853f8179072c502df585067" translate="yes" xml:space="preserve">
          <source>Function VS block scope:</source>
          <target state="translated">Función VS bloquear el alcance:</target>
        </trans-unit>
        <trans-unit id="44d7d3e4ae1a64d1cd2bf70aad9d679aa794df08" translate="yes" xml:space="preserve">
          <source>Getter and setter with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">Getter y setter con &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ba873db511f120d8b04390f9365a000776baab4" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; doesn't get attached to &lt;code&gt;window&lt;/code&gt;:</source>
          <target state="translated">Let global no se adjunta a la &lt;code&gt;window&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f8c6d41af972292b69739e49d1923eaf7ba5d69" translate="yes" xml:space="preserve">
          <source>Global &lt;code&gt;let&lt;/code&gt; variables are not added to the global &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">Las variables globales &lt;code&gt;let&lt;/code&gt; no se agregan al objeto de &lt;code&gt;window&lt;/code&gt; global.</target>
        </trans-unit>
        <trans-unit id="50ef81d10d2ac6892f207cc0aa959a31a393eb97" translate="yes" xml:space="preserve">
          <source>Here is an example for the difference between the two (support just started for chrome):</source>
          <target state="translated">Aquí hay un ejemplo de la diferencia entre ambos (el soporte acaba de empezar para el cromo):</target>
        </trans-unit>
        <trans-unit id="e80f82c5146fe3bdfce30d25078c548bf9fd7946" translate="yes" xml:space="preserve">
          <source>Here's an &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;explanation of the &lt;code&gt;let&lt;/code&gt; keyword&lt;/a&gt; with some examples.</source>
          <target state="translated">Aqu&amp;iacute; hay una &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#Block_scope_with_let&quot;&gt;explicaci&amp;oacute;n de la palabra clave &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; con algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="baf1aac8fe97893d9e8a5cc925df180108e841e0" translate="yes" xml:space="preserve">
          <source>Here's an example to add on to what others have already written. Suppose you want to make an array of functions, &lt;code&gt;adderFunctions&lt;/code&gt;, where each function takes a single Number argument and returns the sum of the argument and the function's index in the array. Trying to generate &lt;code&gt;adderFunctions&lt;/code&gt; with a loop using the &lt;code&gt;var&lt;/code&gt; keyword won't work the way someone might na&amp;iuml;vely expect:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo para agregar a lo que otros ya han escrito. Suponga que desea hacer una matriz de funciones, &lt;code&gt;adderFunctions&lt;/code&gt; , donde cada funci&amp;oacute;n toma un solo argumento de N&amp;uacute;mero y devuelve la suma del argumento y el &amp;iacute;ndice de la funci&amp;oacute;n en la matriz. Intentar generar &lt;code&gt;adderFunctions&lt;/code&gt; con un bucle usando la palabra clave &lt;code&gt;var&lt;/code&gt; no funcionar&amp;aacute; de la manera que alguien podr&amp;iacute;a esperar ingenuamente:</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">Aqu&amp;iacute;, podemos ver que nuestra variable &lt;code&gt;j&lt;/code&gt; solo se conoce en el primer bucle for, pero no antes y despu&amp;eacute;s. Sin embargo, nuestra variable &lt;code&gt;i&lt;/code&gt; es conocida en toda la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7bcaf634e9dbfa99922f815d7eb0b950882fbc2c" translate="yes" xml:space="preserve">
          <source>Hoisting</source>
          <target state="translated">Hoisting</target>
        </trans-unit>
        <trans-unit id="a4b770c91602cb7a14569eb1fadf17b154c46e1d" translate="yes" xml:space="preserve">
          <source>Hoisting is not supported using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">La elevaci&amp;oacute;n no es compatible con &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">Cómo hacer un seguimiento del soporte de los navegadores</target>
        </trans-unit>
        <trans-unit id="02950dbbb2895580e2f47482bfdc271d60612939" translate="yes" xml:space="preserve">
          <source>However it's worth noting that &lt;code&gt;let&lt;/code&gt; is only a part of newer Javascript implementations and has varying degrees of &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;browser support&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, vale la pena se&amp;ntilde;alar que &lt;code&gt;let&lt;/code&gt; es solo una parte de las nuevas implementaciones de Javascript y tiene diferentes grados de &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;compatibilidad con el navegador&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a64dc9831d45af781fdad2758e3129f38608db33" translate="yes" xml:space="preserve">
          <source>However, replace &lt;code&gt;var&lt;/code&gt; with &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Sin embargo, reemplace &lt;code&gt;var&lt;/code&gt; con &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1942516de816b1215bfb3f885b92dce215fe8c87" translate="yes" xml:space="preserve">
          <source>However, the block scope can make this huge data structure to garbage collected.</source>
          <target state="translated">Sin embargo,el alcance del bloque puede convertir esta enorme estructura de datos en basura recolectada.</target>
        </trans-unit>
        <trans-unit id="210d598d2aa5b2252eb617a5677124f67bcfd03e" translate="yes" xml:space="preserve">
          <source>However, we can try again using the &lt;code&gt;let&lt;/code&gt; keyword:</source>
          <target state="translated">Sin embargo, podemos intentarlo nuevamente usando la palabra clave &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a13c0910c0809caa265aa5d59b7303182a3e913" translate="yes" xml:space="preserve">
          <source>However, you cannot reference the variable declared with let or const until it is declared. If you try to use it before it is declared, then an exception will be raised during the Execution Phase of the Execution Context. Now the variable will still be in memory, courtesy of the Creation Phase of the Execution Context, but the Engine will not allow you to use it:</source>
          <target state="translated">Sin embargo,no se puede hacer referencia a la variable declarada con let o const hasta que sea declarada.Si intentas usarla antes de que sea declarada,entonces se planteará una excepción durante la fase de ejecución del contexto de ejecución.Ahora la variable seguirá en la memoria,cortesía de la Fase de Creación del Contexto de Ejecución,pero la Máquina no le permitirá usarla:</target>
        </trans-unit>
        <trans-unit id="73b04d7e63d97817ad43a04a297f8ccd6b791760" translate="yes" xml:space="preserve">
          <source>I think people will start using let here after so that they will have similar scoping in JavaScript like other languages, Java, C#, etc.</source>
          <target state="translated">Creo que la gente comenzará a usar let here after para tener un alcance similar en JavaScript como otros lenguajes,Java,C#,etc.</target>
        </trans-unit>
        <trans-unit id="60ed5394ff0a30a2c778db05382fc4f19f7dea8c" translate="yes" xml:space="preserve">
          <source>I think the terms and most of the examples are a bit overwhelming,
The main issue i had personally with the difference is understanding what a &quot;Block&quot; is.
At some point i realized, a block would be any curly brackets except for &lt;code&gt;IF&lt;/code&gt; statement.
an opening bracket &lt;code&gt;{&lt;/code&gt; of a function or loop will define a new block, anything defined with &lt;code&gt;let&lt;/code&gt; within it, will not be available after the closing bracket &lt;code&gt;}&lt;/code&gt; of the same thing (function or loop);
With that in mind, it was easier to understand:</source>
          <target state="translated">Creo que los t&amp;eacute;rminos y la mayor&amp;iacute;a de los ejemplos son un poco abrumadores. El problema principal que tuve personalmente con la diferencia es entender qu&amp;eacute; es un &quot;Bloque&quot;. En alg&amp;uacute;n momento me di cuenta de que un bloque ser&amp;iacute;a cualquier llave, excepto la declaraci&amp;oacute;n &lt;code&gt;IF&lt;/code&gt; . un par&amp;eacute;ntesis de apertura &lt;code&gt;{&lt;/code&gt; de una funci&amp;oacute;n o bucle definir&amp;aacute; un nuevo bloque, cualquier cosa definida con &lt;code&gt;let&lt;/code&gt; dentro de &amp;eacute;l, no estar&amp;aacute; disponible despu&amp;eacute;s del corchete de cierre &lt;code&gt;}&lt;/code&gt; de la misma cosa (funci&amp;oacute;n o bucle); Con eso en mente, fue m&amp;aacute;s f&amp;aacute;cil de entender:</target>
        </trans-unit>
        <trans-unit id="652bcdb1cb95ff704c8f7f92231e2c819a6a619e" translate="yes" xml:space="preserve">
          <source>I want to link these keywords to the Execution Context, because the Execution Context is important in all of this. The Execution Context has two phases: a Creation Phase and Execution Phase. In addition, each Execution Context has a Variable Environment and Outer Environment (its Lexical Environment).</source>
          <target state="translated">Quiero vincular estas palabras clave al Contexto de Ejecución,porque el Contexto de Ejecución es importante en todo esto.El Contexto de Ejecución tiene dos fases:una fase de creación y una fase de ejecución.Además,cada Contexto de Ejecución tiene un Entorno Variable y un Entorno Exterior (su Entorno Lógico).</target>
        </trans-unit>
        <trans-unit id="347c3b7704d41b142c7558f9df8c366aaa5c3ca9" translate="yes" xml:space="preserve">
          <source>I've heard it that it's described as a &quot;local&quot; variable, but I'm still not quite sure how it behaves differently than the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">He o&amp;iacute;do que se describe como una variable &quot;local&quot;, pero todav&amp;iacute;a no estoy muy seguro de c&amp;oacute;mo se comporta de manera diferente a la palabra clave &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a64f2d3dd931f8ac221f076d6aee461fa2e268f7" translate="yes" xml:space="preserve">
          <source>If I read the specs right then &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;thankfully&lt;/strong&gt; can also be leveraged to avoid &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;self invoking functions&lt;/a&gt; used to simulate private only members - &lt;em&gt;a popular design pattern that decreases code readability, complicates debugging, that adds no real code protection or other benefit - except maybe satisfying someone's desire for semantics, so stop using it. /rant&lt;/em&gt;</source>
          <target state="translated">Si leo las especificaciones correctamente, &lt;strong&gt;afortunadamente&lt;/strong&gt; tambi&amp;eacute;n se puede aprovechar para evitar &lt;a href=&quot;https://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript#592414&quot;&gt;las funciones de invocaci&amp;oacute;n autom&amp;aacute;tica que se&lt;/a&gt; utilizan para simular solo miembros privados: &lt;em&gt;un patr&amp;oacute;n de dise&amp;ntilde;o popular que disminuye la legibilidad del c&amp;oacute;digo, complica la depuraci&amp;oacute;n, que no agrega protecci&amp;oacute;n de c&amp;oacute;digo real u otro beneficio, excepto que tal vez sea satisfactorio el deseo de alguien por la sem&amp;aacute;ntica, as&amp;iacute; que deja de usarlo.&lt;/em&gt; &lt;em&gt;/despotricar&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efbed4ca5ff07a30fe5d1a50e4502bdb347bc1c0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; in a loop, with each iteration you get a new variable. That means that you can safely use a closure inside a loop.</source>
          <target state="translated">Si usa &lt;code&gt;let&lt;/code&gt; en lugar de &lt;code&gt;var&lt;/code&gt; en un bucle, con cada iteraci&amp;oacute;n obtendr&amp;aacute; una nueva variable. Eso significa que puede usar un cierre de forma segura dentro de un bucle.</target>
        </trans-unit>
        <trans-unit id="17145a9a9f46d1b105d7a4debb8d941ee248c402" translate="yes" xml:space="preserve">
          <source>If you want to have an immutable object, you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;&lt;code&gt;Object.freeze()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea tener un objeto inmutable, debe usar &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt; &lt;code&gt;Object.freeze()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">Si estás escribiendo código JavaScript del lado del cliente y no usas un transpilador,debes considerar el soporte del navegador.</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">Si est&amp;aacute; escribiendo c&amp;oacute;digo JavaScript del lado del cliente y usa un transpilador basado en Nodo (como el &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;script de shell traceur&lt;/strong&gt;&lt;/a&gt; o &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; ), puede usar de manera segura la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; . Y debido a que su navegador solo sabr&amp;aacute; sobre el c&amp;oacute;digo transpilado, los inconvenientes de rendimiento deben ser limitados.</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">Si est&amp;aacute; escribiendo c&amp;oacute;digo JavaScript del lado del cliente y usa un transpilador basado en navegador (como &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; o &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; ), puede usar de manera segura la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , sin embargo, es probable que su c&amp;oacute;digo sea todo menos &amp;oacute;ptimo con respecto al rendimiento.</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">Si est&amp;aacute; escribiendo c&amp;oacute;digo JavaScript del lado del servidor ( &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ), puede usar de manera segura la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfc03d4531fe0bd76ba607e1e4e7d663c32df226" translate="yes" xml:space="preserve">
          <source>In JavaScript we often use variables at a significantly later time than when they are created.  When we demonstrate this by delaying the output with a closure passed to &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">En JavaScript, a menudo utilizamos variables en un tiempo significativamente m&amp;aacute;s tarde que cuando se crean. Cuando demostramos esto retrasando la salida con un cierre pasado a &lt;code&gt;setTimeout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7c9021c4e7876355e1fc36b9e227cb4de4425b66" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; parses and runs without throwing any exceptions.</source>
          <target state="translated">Por el contrario, el mismo ejemplo con &lt;code&gt;var&lt;/code&gt; analiza y se ejecuta sin lanzar ninguna excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="177519e8851b8c0bb348adf315a0cf3831599c1d" translate="yes" xml:space="preserve">
          <source>In contrast, the same example with &lt;code&gt;var&lt;/code&gt; works.</source>
          <target state="translated">En contraste, el mismo ejemplo con &lt;code&gt;var&lt;/code&gt; funciona.</target>
        </trans-unit>
        <trans-unit id="dc8dcbdd636f8cb50991ca75851fcac1be59e3c5" translate="yes" xml:space="preserve">
          <source>In my both examples I have a function &lt;code&gt;myfunc&lt;/code&gt;. &lt;code&gt;myfunc&lt;/code&gt; contains a variable &lt;code&gt;myvar&lt;/code&gt; equals to 10. 
In my first example  I check   if &lt;code&gt;myvar&lt;/code&gt; equals to 10 (&lt;code&gt;myvar==10&lt;/code&gt;) . If yes, I agian declare  a variable  &lt;code&gt;myvar&lt;/code&gt; (now I have two myvar variables)using &lt;code&gt;var&lt;/code&gt; keyword and assign it a new value (20). In next line I  print its value on my console.  After the conditional block I again print the value of &lt;code&gt;myvar&lt;/code&gt; on my console. If you look at the output of &lt;code&gt;myfunc&lt;/code&gt;,   &lt;code&gt;myvar&lt;/code&gt; has value equals to 20.</source>
          <target state="translated">En mis dos ejemplos tengo una funci&amp;oacute;n &lt;code&gt;myfunc&lt;/code&gt; . &lt;code&gt;myfunc&lt;/code&gt; contiene una variable &lt;code&gt;myvar&lt;/code&gt; igual a 10. En mi primer ejemplo &lt;code&gt;myvar&lt;/code&gt; si myvar es igual a 10 ( &lt;code&gt;myvar==10&lt;/code&gt; ). En caso afirmativo, declaro una variable &lt;code&gt;myvar&lt;/code&gt; (ahora tengo dos variables myvar) usando la palabra clave &lt;code&gt;var&lt;/code&gt; y le asigno un nuevo valor (20). En la siguiente l&amp;iacute;nea imprimo su valor en mi consola. Despu&amp;eacute;s del bloque condicional, &lt;code&gt;myvar&lt;/code&gt; nuevamente el valor de myvar en mi consola. Si observa la salida de &lt;code&gt;myfunc&lt;/code&gt; , &lt;code&gt;myvar&lt;/code&gt; tiene un valor igual a 20.</target>
        </trans-unit>
        <trans-unit id="d3eb240300b8d3cf3894acb662d9d55b4c3eeb9c" translate="yes" xml:space="preserve">
          <source>In practice, there are a number of useful consequences of the difference in scope:</source>
          <target state="translated">En la práctica,la diferencia de alcance tiene varias consecuencias útiles:</target>
        </trans-unit>
        <trans-unit id="041cfe51d16fc06e7a90d0fdd25ff09d8de80054" translate="yes" xml:space="preserve">
          <source>In strict mode, &lt;code&gt;var&lt;/code&gt; will let you re-declare the same variable in the same scope while &lt;code&gt;let&lt;/code&gt; raises a SyntaxError.</source>
          <target state="translated">En modo estricto, &lt;code&gt;var&lt;/code&gt; le permitir&amp;aacute; volver a declarar la misma variable en el mismo &amp;aacute;mbito, mientras que &lt;code&gt;let&lt;/code&gt; generar un SyntaxError.</target>
        </trans-unit>
        <trans-unit id="deb3d336c8ca38ed2c8a72be4787d1e826efc9a7" translate="yes" xml:space="preserve">
          <source>Initializer is required</source>
          <target state="translated">Se requiere un inicializador</target>
        </trans-unit>
        <trans-unit id="6d007cc06c89e6bed5f7c97dc75f829442633823" translate="yes" xml:space="preserve">
          <source>Inside a block</source>
          <target state="translated">Dentro de un bloque</target>
        </trans-unit>
        <trans-unit id="d187aaa9dbe696be70ed4733de46de8f53018d1e" translate="yes" xml:space="preserve">
          <source>Inside a function</source>
          <target state="translated">Dentro de una función</target>
        </trans-unit>
        <trans-unit id="6a19a43ce4368f97cd87fe72619ae5cd48410ed3" translate="yes" xml:space="preserve">
          <source>Inside a function (but outside of a block), &lt;code&gt;let&lt;/code&gt; has the same scope as &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Dentro de una funci&amp;oacute;n (pero fuera de un bloque), &lt;code&gt;let&lt;/code&gt; tiene el mismo alcance que &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31aad9d36743f490f94cc21d201edada256344c" translate="yes" xml:space="preserve">
          <source>Inside a loop</source>
          <target state="translated">Dentro de un bucle</target>
        </trans-unit>
        <trans-unit id="5f706b419d5afb2010d5c584c5073222be04bf3b" translate="yes" xml:space="preserve">
          <source>Is it safe to use &lt;code&gt;let&lt;/code&gt; today?</source>
          <target state="translated">&amp;iquest;Es seguro usar &lt;code&gt;let&lt;/code&gt; hoy?</target>
        </trans-unit>
        <trans-unit id="2efd347d2f42601723d5af3a50c4b497df93e4c1" translate="yes" xml:space="preserve">
          <source>It also appears that, at least in Visual Studio 2015, TypeScript 1.5, &quot;var&quot; allows multiple declarations of the same variable name in a block, and &quot;let&quot; doesn't.</source>
          <target state="translated">También parece que,al menos en Visual Studio 2015,TypeScript 1.5,&quot;var&quot; permite múltiples declaraciones del mismo nombre de la variable en un bloque,y &quot;let&quot; no.</target>
        </trans-unit>
        <trans-unit id="5baa9813fadf06ec260f1610e850a5668ce5695e" translate="yes" xml:space="preserve">
          <source>Loops with closures</source>
          <target state="translated">Lazos con cierres</target>
        </trans-unit>
        <trans-unit id="c0b7662f52c683b4a21a90043d995802030c5bd1" translate="yes" xml:space="preserve">
          <source>Main difference is scoping rules. Variables declared by &lt;code&gt;var&lt;/code&gt; keyword are scoped to the immediate function body (hence the function scope) while &lt;code&gt;let&lt;/code&gt; variables are scoped to the immediate &lt;em&gt;enclosing&lt;/em&gt; block denoted by &lt;code&gt;{ }&lt;/code&gt; (hence the block scope).</source>
          <target state="translated">La principal diferencia son las reglas de alcance. Las variables declaradas por la palabra clave &lt;code&gt;var&lt;/code&gt; tienen un alcance en el cuerpo de la funci&amp;oacute;n inmediata (de ah&amp;iacute; el alcance de la funci&amp;oacute;n) mientras &lt;code&gt;let&lt;/code&gt; variables tienen un alcance en el bloque de &lt;em&gt;cierre&lt;/em&gt; inmediato denotado por &lt;code&gt;{ }&lt;/code&gt; (de ah&amp;iacute; el alcance del bloque).</target>
        </trans-unit>
        <trans-unit id="99fbe1720bf011da269b2cac5512d7c3963a6968" translate="yes" xml:space="preserve">
          <source>May the following two functions show the difference:</source>
          <target state="translated">Que las siguientes dos funciones muestren la diferencia:</target>
        </trans-unit>
        <trans-unit id="63a3dc65c2f80ebaced4b3a1a62910c1da24fc2b" translate="yes" xml:space="preserve">
          <source>No re-assigning</source>
          <target state="translated">No hay reasignación</target>
        </trans-unit>
        <trans-unit id="39c7b7a1ef0ba49851ad5dfe7bd9144cb18d52c7" translate="yes" xml:space="preserve">
          <source>No re-declaring</source>
          <target state="translated">No hay que volver a declarar</target>
        </trans-unit>
        <trans-unit id="39c9178c32e097fcac397a91d250592e73365258" translate="yes" xml:space="preserve">
          <source>Note that it doesn't mean that the value is immutable. Its properties still can be changed.</source>
          <target state="translated">Tengan en cuenta que eso no significa que el valor sea inmutable.Sus propiedades aún pueden ser cambiadas.</target>
        </trans-unit>
        <trans-unit id="f3a83e225fb411474c8b9361c4b05f98a38f3643" translate="yes" xml:space="preserve">
          <source>Note that only Mozilla and Chrome browsers support it. IE, Safari, and potentially others don't.</source>
          <target state="translated">Ten en cuenta que sólo los navegadores Mozilla y Chrome lo soportan.IE,Safari y potencialmente otros no lo hacen.</target>
        </trans-unit>
        <trans-unit id="96df0ec4b6def0a95acbbc1f79135059a56fd9f0" translate="yes" xml:space="preserve">
          <source>Now I think there is better scoping of variables to a block of statements using &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">Ahora creo que hay un mejor alcance de las variables para un bloque de declaraciones usando &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39076c4b7441e59ed2d91b8abe7ca8c4659cb0d2" translate="yes" xml:space="preserve">
          <source>Now, image mixing the two behaviors and you'll probably see why it's not recommended to mix the newer &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; with the older &lt;code&gt;var&lt;/code&gt; in the same script. Doing so can result is some spectacularly confusing code.</source>
          <target state="translated">Ahora, mezcla im&amp;aacute;genes de los dos comportamientos y probablemente ver&amp;aacute;s por qu&amp;eacute; no se recomienda mezclar el &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; m&amp;aacute;s nuevo con el &lt;code&gt;var&lt;/code&gt; m&amp;aacute;s antiguo en el mismo script. Hacerlo puede resultar en un c&amp;oacute;digo espectacularmente confuso.</target>
        </trans-unit>
        <trans-unit id="8c2795ed8b2631b7e1915cc52073b53be8af53e9" translate="yes" xml:space="preserve">
          <source>Only counts [0, 1].</source>
          <target state="translated">Sólo cuenta [0,1].</target>
        </trans-unit>
        <trans-unit id="efcf7de8b6bfc89725e070a6351b838be2c76f1b" translate="yes" xml:space="preserve">
          <source>People had to create immediately invoked functions to capture correct value from the loops but that was also hairy.</source>
          <target state="translated">La gente tenía que crear inmediatamente funciones invocadas para capturar el valor correcto de los bucles,pero eso también era peliagudo.</target>
        </trans-unit>
        <trans-unit id="2f5f2be0ca83a657f2ffc3bfa218814a5981da32" translate="yes" xml:space="preserve">
          <source>People with not a clear understanding about scoping in JavaScript used to make the mistake earlier.</source>
          <target state="translated">La gente que no tiene una comprensión clara del alcance en JavaScript solía cometer el error antes.</target>
        </trans-unit>
        <trans-unit id="285dc513fb5c7a7fc0e6eb93a0290e0641276542" translate="yes" xml:space="preserve">
          <source>Previously there were only two scopes in JavaScript, i.e. functional and global. With '&lt;code&gt;let&lt;/code&gt;' keyword JavaScript has now introduced &lt;code&gt;block-level&lt;/code&gt; variables.</source>
          <target state="translated">Anteriormente solo hab&amp;iacute;a dos &amp;aacute;mbitos en JavaScript, es decir, funcional y global. Con la palabra clave ' &lt;code&gt;let&lt;/code&gt; ', JavaScript ahora ha introducido variables a &lt;code&gt;block-level&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3e4988d8656dd123e2bdf39a4fa12ece71639a" translate="yes" xml:space="preserve">
          <source>Redeclaration</source>
          <target state="translated">Redeclaration</target>
        </trans-unit>
        <trans-unit id="25b58933661327228329508e8c2cf1090c0253a0" translate="yes" xml:space="preserve">
          <source>Refer to &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 In Depth: let and const&lt;/a&gt;&lt;/em&gt; to understand it better.</source>
          <target state="translated">Consulte &lt;em&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/&quot;&gt;ES6 en profundidad: let y const&lt;/a&gt;&lt;/em&gt; para comprenderlo mejor.</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">Reglas de alcance</target>
        </trans-unit>
        <trans-unit id="382bd8420b6d01443a65704ab49145af79643941" translate="yes" xml:space="preserve">
          <source>See '&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Emulating private interfaces&lt;/a&gt;'</source>
          <target state="translated">Consulte ' &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let#Emulating_private_interfaces&quot;&gt;Emulaci&amp;oacute;n de interfaces privadas&lt;/a&gt; '</target>
        </trans-unit>
        <trans-unit id="9199fa6dee3c3db69201fd546b73324ee92bb5fc" translate="yes" xml:space="preserve">
          <source>See my example below, and note how the lion (let) variable acts differently in the two console.logs; it becomes out of scope in the 2nd console.log.</source>
          <target state="translated">Vea mi ejemplo a continuación,y observe cómo la variable león (let)actúa de forma diferente en los dos console.logs;queda fuera de alcance en el 2º console.log.</target>
        </trans-unit>
        <trans-unit id="ce14680b0e5afa36020ec40b287ff3cdba706e04" translate="yes" xml:space="preserve">
          <source>So the difference is very simple i.e its scope.</source>
          <target state="translated">Así que la diferencia es muy simple,es decir,su alcance.</target>
        </trans-unit>
        <trans-unit id="38c778b9cbefb5fbaad00a515fa6b89ce13a738d" translate="yes" xml:space="preserve">
          <source>Some hacks with &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">Algunos hacks con &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="789fd33b37de1fced25ba88ee426bb6b49dcd4f3" translate="yes" xml:space="preserve">
          <source>Some people would argue that in the future we'll ONLY use let statements and that var statements will become obsolete. JavaScript guru &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Kyle Simpson&lt;/strong&gt;&lt;/a&gt; wrote &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;a very elaborate article on why he believes that won't be the case&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Algunas personas argumentan que en el futuro SOLO usaremos declaraciones let y que las declaraciones var se volver&amp;aacute;n obsoletas. El gur&amp;uacute; de JavaScript &lt;a href=&quot;https://twitter.com/getify&quot;&gt;&lt;strong&gt;Kyle Simpson&lt;/strong&gt;&lt;/a&gt; escribi&amp;oacute; &lt;a href=&quot;https://davidwalsh.name/for-and-against-let&quot;&gt;&lt;strong&gt;un art&amp;iacute;culo muy elaborado sobre por qu&amp;eacute; cree que ese no ser&amp;aacute; el caso&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33a132a545bee29b8dcb5ddcc302b7c8534a609b" translate="yes" xml:space="preserve">
          <source>Specifically, this outputs:</source>
          <target state="translated">Específicamente,esto produce:</target>
        </trans-unit>
        <trans-unit id="c20042f3ec22b168b4441982da162a8418abc98a" translate="yes" xml:space="preserve">
          <source>Take a look at this example from &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;another stackoverflow question&lt;/a&gt;:</source>
          <target state="translated">Eche un vistazo a este ejemplo de &lt;a href=&quot;https://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example&quot;&gt;otra pregunta de stackoverflow&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d2a5704984a4447527354be4a00cc8b22ced40f5" translate="yes" xml:space="preserve">
          <source>Temporal dead zone</source>
          <target state="translated">Zona muerta temporal</target>
        </trans-unit>
        <trans-unit id="a6c1c3dc63d914749b6854d3ab11a3b569eada69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;click&lt;/code&gt; handler callback does not need the &lt;code&gt;hugeData&lt;/code&gt; variable at all. Theoretically, after &lt;code&gt;process(..)&lt;/code&gt; runs, the huge data structure &lt;code&gt;hugeData&lt;/code&gt; could be garbage collected. However, it's possible that some JS engine will still have to keep this huge structure, since the &lt;code&gt;click&lt;/code&gt; function has a closure over the entire scope.</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada del controlador de &lt;code&gt;click&lt;/code&gt; no necesita la variable &lt;code&gt;hugeData&lt;/code&gt; en absoluto. Te&amp;oacute;ricamente, despu&amp;eacute;s de que &lt;code&gt;process(..)&lt;/code&gt; ejecuta el proceso (..) , la gran estructura de datos &lt;code&gt;hugeData&lt;/code&gt; podr&amp;iacute;a ser recogida de basura. Sin embargo, es posible que algunos motores JS a&amp;uacute;n tengan que mantener esta enorme estructura, ya que la funci&amp;oacute;n de &lt;code&gt;click&lt;/code&gt; tiene un cierre en todo el alcance.</target>
        </trans-unit>
        <trans-unit id="264885cd88282bf28a8225c70ff7599f6d3df455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gfoo&lt;/code&gt;, defined by &lt;code&gt;let&lt;/code&gt; initially is in the &lt;strong&gt;global scope&lt;/strong&gt;, and when we declare &lt;code&gt;gfoo&lt;/code&gt; again inside the &lt;code&gt;if clause&lt;/code&gt; its &lt;strong&gt;&lt;em&gt;scope changed&lt;/em&gt;&lt;/strong&gt; and when a new value is assigned to the variable inside that scope it &lt;strong&gt;does not affect&lt;/strong&gt; the global scope.</source>
          <target state="translated">El &lt;code&gt;gfoo&lt;/code&gt; , definido por &lt;code&gt;let&lt;/code&gt; inicialmente est&amp;aacute; en el &lt;strong&gt;alcance global&lt;/strong&gt; , y cuando declaramos &lt;code&gt;gfoo&lt;/code&gt; nuevamente dentro de la &lt;code&gt;if clause&lt;/code&gt; su &lt;strong&gt;&lt;em&gt;alcance cambi&amp;oacute;&lt;/em&gt;&lt;/strong&gt; y cuando se asigna un nuevo valor a la variable dentro de ese alcance, &lt;strong&gt;no afecta&lt;/strong&gt; el alcance global.</target>
        </trans-unit>
        <trans-unit id="87b7ba6b84d1c61150fc37bf6a8f3727f5c2d5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword attaches the variable declaration to the scope of whatever block (commonly a &lt;code&gt;{ .. }&lt;/code&gt; pair) it's contained in. In other words,&lt;code&gt;let&lt;/code&gt; implicitly hijacks any block's scope for its variable declaration.</source>
          <target state="translated">La palabra clave &lt;code&gt;let&lt;/code&gt; adjunta la declaraci&amp;oacute;n de variable al alcance de cualquier bloque (com&amp;uacute;nmente un par &lt;code&gt;{ .. }&lt;/code&gt; ) en el que se encuentra. En otras palabras, &lt;code&gt;let&lt;/code&gt; secuestra impl&amp;iacute;citamente el alcance de cualquier bloque para su declaraci&amp;oacute;n de variable.</target>
        </trans-unit>
        <trans-unit id="78af92108bc96e8a42084047aaf363842f3b377a" translate="yes" xml:space="preserve">
          <source>The accepted answer is missing a point:</source>
          <target state="translated">La respuesta aceptada no tiene sentido:</target>
        </trans-unit>
        <trans-unit id="073b339db7edb1c2e2e81ea60ac755f69153f037" translate="yes" xml:space="preserve">
          <source>The below shows how 'let' and 'var' are different in the scope:</source>
          <target state="translated">A continuación se muestra cómo &quot;dejar&quot; y &quot;var&quot; son diferentes en el ámbito:</target>
        </trans-unit>
        <trans-unit id="4d9ba873fd7a30468256474a7c4d6e16988d829d" translate="yes" xml:space="preserve">
          <source>The below table summarize the difference between var, let and const</source>
          <target state="translated">En el siguiente cuadro se resume la diferencia entre var,let y const</target>
        </trans-unit>
        <trans-unit id="00a031e0941465964589ed342dbcebaa59ee6085" translate="yes" xml:space="preserve">
          <source>The difference is in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;scope&lt;/a&gt; of the variables declared with each.</source>
          <target state="translated">La diferencia est&amp;aacute; en el &lt;a href=&quot;https://en.wikipedia.org/wiki/Variable_(computer_science)#Scope_and_extent&quot;&gt;alcance&lt;/a&gt; de las variables declaradas con cada uno.</target>
        </trans-unit>
        <trans-unit id="58bbbdd4908ae3e2d249c1fbdc5b3f5b43c376b1" translate="yes" xml:space="preserve">
          <source>The difference is scoping. &lt;code&gt;var&lt;/code&gt; is scoped to the nearest &lt;strong&gt;function
  block&lt;/strong&gt; and &lt;code&gt;let&lt;/code&gt; is scoped to the &lt;strong&gt;nearest enclosing block&lt;/strong&gt;, which
  can be smaller than a function block. Both are global if outside any
  block.Lets see an example:</source>
          <target state="translated">La diferencia es el alcance. &lt;code&gt;var&lt;/code&gt; se limita al &lt;strong&gt;bloque de funciones&lt;/strong&gt; m&amp;aacute;s cercano y &lt;code&gt;let&lt;/code&gt; se limita al &lt;strong&gt;bloque de cierre m&amp;aacute;s cercano&lt;/strong&gt; , que puede ser m&amp;aacute;s peque&amp;ntilde;o que un bloque de funciones. Ambos son globales si est&amp;aacute;n fuera de cualquier bloque. Veamos un ejemplo:</target>
        </trans-unit>
        <trans-unit id="a2047a53cae852bc9bd4d5726d86bf1abdab5907" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; is that variables declared with &lt;code&gt;var&lt;/code&gt; are &lt;strong&gt;function scoped&lt;/strong&gt;. Whereas functions declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt;. For example:</source>
          <target state="translated">La principal diferencia entre &lt;code&gt;var&lt;/code&gt; y &lt;code&gt;let&lt;/code&gt; es que las variables declaradas con &lt;code&gt;var&lt;/code&gt; tienen un &lt;strong&gt;alcance de funci&amp;oacute;n&lt;/strong&gt; . Mientras que las funciones declaradas con &lt;code&gt;let&lt;/code&gt; tienen &lt;strong&gt;un alcance de bloque&lt;/strong&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8d162e4b209b454c9dcdb65956e1046635e203a9" translate="yes" xml:space="preserve">
          <source>The main difference is the &lt;strong&gt;scope&lt;/strong&gt; difference, while &lt;strong&gt;let&lt;/strong&gt; can be only available inside the &lt;strong&gt;scope&lt;/strong&gt; it's declared, like in for loop, &lt;strong&gt;var&lt;/strong&gt; can be accessed outside the loop for example. From the documentation in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (examples also from MDN):</source>
          <target state="translated">La principal diferencia es la diferencia de &lt;strong&gt;alcance&lt;/strong&gt; , mientras que &lt;strong&gt;let&lt;/strong&gt; solo puede estar disponible dentro del &lt;strong&gt;alcance&lt;/strong&gt; que se declara, como en for loop, se puede acceder a &lt;strong&gt;var&lt;/strong&gt; fuera del bucle, por ejemplo. De la documentaci&amp;oacute;n en &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN&lt;/a&gt; (ejemplos tambi&amp;eacute;n de MDN):</target>
        </trans-unit>
        <trans-unit id="9f7f9f1e0a48709104afca6e8067da28df678148" translate="yes" xml:space="preserve">
          <source>The process above doesn't generate the desired array of functions because &lt;code&gt;i&lt;/code&gt;'s scope extends beyond the iteration of the &lt;code&gt;for&lt;/code&gt; block in which each function was created. Instead, at the end of the loop, the &lt;code&gt;i&lt;/code&gt; in each function's closure refers to &lt;code&gt;i&lt;/code&gt;'s value at the end of the loop (1000) for every anonymous function in &lt;code&gt;adderFunctions&lt;/code&gt;. This isn't what we wanted at all: we now have an array of 1000 different functions in memory with exactly the same behavior. And if we subsequently update the value of &lt;code&gt;i&lt;/code&gt;, the mutation will affect all the &lt;code&gt;adderFunctions&lt;/code&gt;.</source>
          <target state="translated">El proceso anterior no genera la matriz de funciones deseada porque el alcance de &lt;code&gt;i&lt;/code&gt; se extiende m&amp;aacute;s all&amp;aacute; de la iteraci&amp;oacute;n del bloque &lt;code&gt;for&lt;/code&gt; en el que se cre&amp;oacute; cada funci&amp;oacute;n. En cambio, al final del ciclo, la &lt;code&gt;i&lt;/code&gt; en el cierre de cada funci&amp;oacute;n se refiere al valor de &lt;code&gt;i&lt;/code&gt; al final del ciclo (1000) para cada funci&amp;oacute;n an&amp;oacute;nima en &lt;code&gt;adderFunctions&lt;/code&gt; . Esto no es lo que quer&amp;iacute;amos en absoluto: ahora tenemos una matriz de 1000 funciones diferentes en la memoria con exactamente el mismo comportamiento. Y si posteriormente actualizamos el valor de &lt;code&gt;i&lt;/code&gt; , la mutaci&amp;oacute;n afectar&amp;aacute; a todas las &lt;code&gt;adderFunctions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3451295aef647a9eb92f4f38d933a0e2d080e7e1" translate="yes" xml:space="preserve">
          <source>The reason why &lt;code&gt;let&lt;/code&gt; keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript.</source>
          <target state="translated">La raz&amp;oacute;n por la &lt;code&gt;let&lt;/code&gt; se introdujo la palabra clave en el lenguaje fue que el alcance de la funci&amp;oacute;n es confuso y fue una de las principales fuentes de errores en JavaScript.</target>
        </trans-unit>
        <trans-unit id="11b109d5b87133e7c9f78aaa1557423809cb31f7" translate="yes" xml:space="preserve">
          <source>The restrictions imposed by &lt;code&gt;let&lt;/code&gt; reduce the visibility of the variables and increase the likelihood that unexpected name collisions will be found early.  This makes it easier to track and reason about variables, including their &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;reachability&lt;/a&gt;(helping with reclaiming unused memory).</source>
          <target state="translated">Las restricciones impuestas por &lt;code&gt;let&lt;/code&gt; reducen la visibilidad de las variables y aumentan la probabilidad de que se encuentren pronto colisiones inesperadas de nombres. Esto hace que sea m&amp;aacute;s f&amp;aacute;cil rastrear y razonar sobre las variables, incluida su &lt;a href=&quot;https://en.wikipedia.org/wiki/Unreachable_memory&quot;&gt;accesibilidad&lt;/a&gt; (lo que ayuda a recuperar la memoria no utilizada).</target>
        </trans-unit>
        <trans-unit id="e0d2bb460f6b296bc8aef7ab3dd6effc0df6f796" translate="yes" xml:space="preserve">
          <source>The second feature of let is it introduces block scope. Blocks are defined by curly braces. Examples include function blocks, if blocks, for blocks, etc. When you declare a variable with let inside of a block, the variable is only available inside of the block. In fact, each time the block is run, such as within a for loop, it will create a new variable in memory.</source>
          <target state="translated">La segunda característica de let es que introduce el bloqueo de la visión.Los bloques están definidos por llaves rizadas.Los ejemplos incluyen bloques de función,si son bloques,para bloques,etc.Cuando se declara una variable con let dentro de un bloque,la variable sólo está disponible dentro del bloque.De hecho,cada vez que se ejecuta el bloque,como dentro de un bucle de for,se creará una nueva variable en la memoria.</target>
        </trans-unit>
        <trans-unit id="f0009b35b2bce48e37552dc2d483b1c142ec7b1e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences &amp;mdash; &lt;code&gt;let&lt;/code&gt; scoping behaves more like variable scoping does in more or less any other languages.</source>
          <target state="translated">Existen algunas diferencias sutiles: &lt;code&gt;let&lt;/code&gt; alcance se comporte m&amp;aacute;s como el alcance variable en m&amp;aacute;s o menos cualquier otro idioma.</target>
        </trans-unit>
        <trans-unit id="582e7ce54a6962d9d96e460cfe6b27fdb7eed8a5" translate="yes" xml:space="preserve">
          <source>There are still some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">Todav&amp;iacute;a hay algunos navegadores que no admiten &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4ee4cc384a25d5e3ddde3e6500df25636cdfd4ce" translate="yes" xml:space="preserve">
          <source>This article clearly defines the difference between var, let and const</source>
          <target state="translated">Este artículo define claramente la diferencia entre var,let y const</target>
        </trans-unit>
        <trans-unit id="556d5253d7e385c3f1d2c5b84329a06bb16d69f7" translate="yes" xml:space="preserve">
          <source>This block of code will throw a &lt;code&gt;ReferenceError&lt;/code&gt; before the code can be run because &lt;code&gt;x&lt;/code&gt; is used before it is declared:</source>
          <target state="translated">Este bloque de c&amp;oacute;digo arrojar&amp;aacute; un &lt;code&gt;ReferenceError&lt;/code&gt; antes de que se pueda ejecutar el c&amp;oacute;digo porque &lt;code&gt;x&lt;/code&gt; se usa antes de que se declare:</target>
        </trans-unit>
        <trans-unit id="25d7860a8b2663b86949e7ca85dafff841362dba" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;let&lt;/code&gt;, for every loop iteration the variable is scoped and has its own copy.</source>
          <target state="translated">Esto se debe a que cuando se usa &lt;code&gt;let&lt;/code&gt; , para cada iteraci&amp;oacute;n de bucle, la variable tiene un alcance y tiene su propia copia.</target>
        </trans-unit>
        <trans-unit id="1edd9ce9f172dbb4d4b3887bc51fb5cf6e0bb712" translate="yes" xml:space="preserve">
          <source>This is because when using &lt;code&gt;var&lt;/code&gt;, for every loop iteration the variable is scoped and has shared copy.</source>
          <target state="translated">Esto se debe a que cuando se usa &lt;code&gt;var&lt;/code&gt; , para cada iteraci&amp;oacute;n del bucle, la variable tiene un alcance y una copia compartida.</target>
        </trans-unit>
        <trans-unit id="a216ad59073ea6bd11a79ebc083a96139dca03f7" translate="yes" xml:space="preserve">
          <source>This time, &lt;code&gt;i&lt;/code&gt; is rebound on each iteration of the &lt;code&gt;for&lt;/code&gt; loop. Each function now keeps the value of &lt;code&gt;i&lt;/code&gt; at the time of the function's creation, and &lt;code&gt;adderFunctions&lt;/code&gt; behaves as expected.</source>
          <target state="translated">Esta vez, se recupera en cada iteraci&amp;oacute;n del bucle &lt;code&gt;for&lt;/code&gt; . Cada funci&amp;oacute;n ahora mantiene el valor de &lt;code&gt;i&lt;/code&gt; en el momento de la creaci&amp;oacute;n de la funci&amp;oacute;n, y &lt;code&gt;adderFunctions&lt;/code&gt; se comporta como se esperaba.</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">Esto lo hará:</target>
        </trans-unit>
        <trans-unit id="5dd7645a6d40c190e66e82b7ca6d2962889cfe89" translate="yes" xml:space="preserve">
          <source>This won't generate a compile error:</source>
          <target state="translated">Esto no generará un error de compilación:</target>
        </trans-unit>
        <trans-unit id="d36477f33831b971d8bfc3e95c1e4d91bef92cb1" translate="yes" xml:space="preserve">
          <source>To have a complete understanding of the 'let' keyword, &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;
ES6: &amp;lsquo;let&amp;rsquo; keyword to declare variable in JavaScript&lt;/a&gt;&lt;/em&gt; will help.</source>
          <target state="translated">Para tener una comprensi&amp;oacute;n completa de la palabra clave 'let', &lt;em&gt;&lt;a href=&quot;http://www.codingeek.com/tutorials/javascript/es6-let-keyword-to-declare-variable-in-javascript/&quot;&gt;ES6: la palabra clave 'let' para declarar variable en JavaScript&lt;/a&gt;&lt;/em&gt; ayudar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="798cc826b7c6eca17f20ac9967ed751d475d3bfa" translate="yes" xml:space="preserve">
          <source>To understand the difference, consider the following code:</source>
          <target state="translated">Para entender la diferencia,considere el siguiente código:</target>
        </trans-unit>
        <trans-unit id="b6b18d3db48c6c605af5cb1ff84864472fd83e2a" translate="yes" xml:space="preserve">
          <source>Today, however, that is definitely not the case. In fact, we need actually to ask ourselves whether it's safe to use the &lt;code&gt;let&lt;/code&gt; statement. The answer to that question depends on your environment:</source>
          <target state="translated">Hoy, sin embargo, ese definitivamente no es el caso. De hecho, debemos preguntarnos si es seguro usar la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; . La respuesta a esa pregunta depende de su entorno:</target>
        </trans-unit>
        <trans-unit id="cf0bd12b27a5d6ae801ae06ca45ff4d909c5e11f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; whenever you can because it is simply scoped more specific. This reduces potential naming conflicts which can occur when dealing with a large number of variables. &lt;code&gt;var&lt;/code&gt; can be used when you want a global variable explicitly to be on the &lt;code&gt;window&lt;/code&gt; object (always consider carefully if this is really necessary).</source>
          <target state="translated">Use &lt;code&gt;let&lt;/code&gt; over &lt;code&gt;var&lt;/code&gt; siempre que pueda porque simplemente tiene un alcance m&amp;aacute;s espec&amp;iacute;fico. Esto reduce los posibles conflictos de nombres que pueden ocurrir cuando se trata con una gran cantidad de variables. &lt;code&gt;var&lt;/code&gt; se puede usar cuando desea que una variable global est&amp;eacute; expl&amp;iacute;citamente en el objeto de la &lt;code&gt;window&lt;/code&gt; (siempre considere cuidadosamente si esto es realmente necesario).</target>
        </trans-unit>
        <trans-unit id="447b7b7549292e2e8a35c8c418af427a8697661b" translate="yes" xml:space="preserve">
          <source>Variable declared using &lt;code&gt;const&lt;/code&gt; can't be re-assigned.</source>
          <target state="translated">La variable declarada con &lt;code&gt;const&lt;/code&gt; no se puede reasignar.</target>
        </trans-unit>
        <trans-unit id="ea2f7a7e35f707d8856cdb8cb5665c534077fffb" translate="yes" xml:space="preserve">
          <source>Variables declared by &lt;strong&gt;let&lt;/strong&gt; have as their scope the block in which they are defined, as well as in any contained sub-blocks. In this way, &lt;strong&gt;let&lt;/strong&gt; works very much like &lt;strong&gt;var&lt;/strong&gt;. The main difference is that the scope of a &lt;strong&gt;var&lt;/strong&gt; variable is the entire enclosing function:</source>
          <target state="translated">Las variables declaradas por &lt;strong&gt;let&lt;/strong&gt; tienen como alcance el bloque en el que est&amp;aacute;n definidas, as&amp;iacute; como en cualquier subbloque contenido. De esta manera, &lt;strong&gt;deja que&lt;/strong&gt; funcione de manera muy similar a la &lt;strong&gt;var&lt;/strong&gt; . La principal diferencia es que el alcance de una variable &lt;strong&gt;var&lt;/strong&gt; es toda la funci&amp;oacute;n de cierre:</target>
        </trans-unit>
        <trans-unit id="ac8b214aec9424ef9fffbc10e806c9b68d0341c2" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;let&lt;/code&gt; inside a block can't be accessed outside that block.</source>
          <target state="translated">No se puede acceder a las variables declaradas usando &lt;code&gt;let&lt;/code&gt; dentro de un bloque fuera de ese bloque.</target>
        </trans-unit>
        <trans-unit id="2b32e0f62bb42b1453a0aa34a0c6ccac71e925fd" translate="yes" xml:space="preserve">
          <source>Variables declared using the &lt;code&gt;let&lt;/code&gt; keyword are block-scoped, which means that they are available only in the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;block&lt;/a&gt; in which they were declared.</source>
          <target state="translated">Las variables declaradas con la palabra clave &lt;code&gt;let&lt;/code&gt; tienen un alcance de bloque, lo que significa que solo est&amp;aacute;n disponibles en el &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/block&quot;&gt;bloque&lt;/a&gt; en el que se declararon.</target>
        </trans-unit>
        <trans-unit id="86c41ca6962411581269ba19972206be437465f2" translate="yes" xml:space="preserve">
          <source>Variables declared with &lt;code&gt;let&lt;/code&gt; in loops can be referenced only inside that loop.</source>
          <target state="translated">Las variables declaradas con bucles &lt;code&gt;let&lt;/code&gt; in solo se pueden referenciar dentro de ese bucle.</target>
        </trans-unit>
        <trans-unit id="b328fafa53d71ac4b0917bba556f26a497d46ea3" translate="yes" xml:space="preserve">
          <source>What are the differences? When should &lt;code&gt;let&lt;/code&gt; be used over &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;les son las diferencias? &amp;iquest;Cu&amp;aacute;ndo deber&amp;iacute;a &lt;code&gt;let&lt;/code&gt; usar sobre &lt;code&gt;var&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="62485fc832e025ecfaffbb9e9fa16598e466214c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la diferencia entre &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;var&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="ba36ff7094458ce1f2d89aff408961ca118f85f3" translate="yes" xml:space="preserve">
          <source>What's the difference between using “let” and “var”</source>
          <target state="translated">¿Cuál es la diferencia entre usar &quot;let&quot; y &quot;var&quot;</target>
        </trans-unit>
        <trans-unit id="b646d47d71c5ed2befdf512e42079703b478e4c5" translate="yes" xml:space="preserve">
          <source>When the first function &lt;code&gt;testVar&lt;/code&gt; gets called the variable foo, declared with &lt;code&gt;var&lt;/code&gt;, is still accessible outside the &lt;code&gt;if&lt;/code&gt; statement. This variable &lt;code&gt;foo&lt;/code&gt; would be available &lt;strong&gt;everywhere&lt;/strong&gt; within the scope of the &lt;code&gt;testVar&lt;/code&gt;&lt;strong&gt;function&lt;/strong&gt;.</source>
          <target state="translated">Cuando se llama a la primera funci&amp;oacute;n &lt;code&gt;testVar&lt;/code&gt; , la variable foo, declarada con &lt;code&gt;var&lt;/code&gt; , todav&amp;iacute;a es accesible fuera de la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; . Esta variable &lt;code&gt;foo&lt;/code&gt; estar&amp;iacute;a disponible en &lt;strong&gt;todas partes&lt;/strong&gt; dentro del alcance de la &lt;strong&gt;funci&amp;oacute;n&lt;/strong&gt; &lt;code&gt;testVar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d1e9bfedfc5565d2a134910beb552ddd3db5af" translate="yes" xml:space="preserve">
          <source>When the second function &lt;code&gt;testLet&lt;/code&gt; gets called the variable bar, declared with &lt;code&gt;let&lt;/code&gt;, is only accessible inside the &lt;code&gt;if&lt;/code&gt; statement. Because variables declared with &lt;code&gt;let&lt;/code&gt; are &lt;strong&gt;block scoped&lt;/strong&gt; (where a block is the code between curly brackets e.g &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt;, &lt;code&gt;function{}&lt;/code&gt;).</source>
          <target state="translated">Cuando la segunda funci&amp;oacute;n &lt;code&gt;testLet&lt;/code&gt; se llama barra variable, declarada con &lt;code&gt;let&lt;/code&gt; , solo es accesible dentro de la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; . Debido a que las variables declaradas con &lt;code&gt;let&lt;/code&gt; tienen &lt;strong&gt;un alcance de bloque&lt;/strong&gt; (donde un bloque es el c&amp;oacute;digo entre llaves, por ejemplo, &lt;code&gt;if{}&lt;/code&gt; , &lt;code&gt;for{}&lt;/code&gt; , &lt;code&gt;function{}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763c20e32aedaf10fa2547617925238345016332" translate="yes" xml:space="preserve">
          <source>When used inside a block, let limits the variable's scope to that block. Note the difference between &lt;strong&gt;var&lt;/strong&gt; whose scope is inside the function where it is declared.</source>
          <target state="translated">Cuando se usa dentro de un bloque, permite limitar el alcance de la variable a ese bloque. Tenga en cuenta la diferencia entre &lt;strong&gt;var&lt;/strong&gt; cuyo &amp;aacute;mbito est&amp;aacute; dentro de la funci&amp;oacute;n donde se declara.</target>
        </trans-unit>
        <trans-unit id="61cd92a023d0a31f010a274ec7d86e10c5421fb8" translate="yes" xml:space="preserve">
          <source>When you need a block level deceleration you can go with let and const
  instead of var.</source>
          <target state="translated">Cuando necesites una desaceleración a nivel de bloque puedes ir con let and const en lugar de var.</target>
        </trans-unit>
        <trans-unit id="6a368a87210137edc166a614258cbe6102456562" translate="yes" xml:space="preserve">
          <source>Whereas</source>
          <target state="translated">Whereas</target>
        </trans-unit>
        <trans-unit id="0fe1d7ee87c3a04d0ac51238b917cc2c9c89c5d5" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;hfoo&lt;/code&gt;, defined by &lt;code&gt;var&lt;/code&gt; is initially in the &lt;strong&gt;global scope&lt;/strong&gt;, but again when we declare it inside the &lt;code&gt;if clause&lt;/code&gt;, it considers the global scope hfoo, although var has been used again to declare it. And when we re-assign its value we see that the global scope hfoo is also affected. This is the primary difference.</source>
          <target state="translated">Mientras que &lt;code&gt;hfoo&lt;/code&gt; , definido por &lt;code&gt;var&lt;/code&gt; est&amp;aacute; inicialmente en el &lt;strong&gt;alcance global&lt;/strong&gt; , pero nuevamente cuando lo declaramos dentro de la &lt;code&gt;if clause&lt;/code&gt; , considera el alcance global hfoo, aunque var se ha utilizado nuevamente para declararlo. Y cuando reasignamos su valor, vemos que el alcance global hfoo tambi&amp;eacute;n se ve afectado. Esta es la principal diferencia.</target>
        </trans-unit>
        <trans-unit id="e3e6995ec39780a0e837123289821ba1329d357a" translate="yes" xml:space="preserve">
          <source>Which results in counting [0, 7].</source>
          <target state="translated">Lo que resulta en el conteo [0,7].</target>
        </trans-unit>
        <trans-unit id="3708d68bf42f4db9fe994838852e9983033235ad" translate="yes" xml:space="preserve">
          <source>While variables declared with &lt;code&gt;var&lt;/code&gt; keyword are &quot;hoisted&quot; to the top of the block which means they are accessible in their enclosing scope even before they are declared:</source>
          <target state="translated">Si bien las variables declaradas con la palabra clave &lt;code&gt;var&lt;/code&gt; se &quot;alzan&quot; en la parte superior del bloque, lo que significa que son accesibles en su alcance incluso antes de que se declaren:</target>
        </trans-unit>
        <trans-unit id="b0b01fae36659f37d265b081743cc0dc35597443" translate="yes" xml:space="preserve">
          <source>With a variable defined with var, if the Engine cannot find the variable in the current Execution Context's Variable Environment, then it will go up the scope chain (the Outer Environment) and check the Outer Environment's Variable Environment for the variable. If it cannot find it there, it will continue searching the Scope Chain. This is not the case with let and const.</source>
          <target state="translated">Con una variable definida con var,si la Máquina no puede encontrar la variable en el Entorno Variable del Contexto de Ejecución actual,entonces subirá por la cadena de alcance (el Entorno Exterior)y buscará la variable en el Entorno Variable del Entorno Exterior.Si no la encuentra allí,continuará buscando en la cadena de alcance.Este no es el caso de let and const.</target>
        </trans-unit>
        <trans-unit id="627826fe97bef52b6bbf6053deb38913659b0bdd" translate="yes" xml:space="preserve">
          <source>With this approach errors present in JavaScript are getting removed.</source>
          <target state="translated">Con este enfoque se eliminan los errores presentes en JavaScript.</target>
        </trans-unit>
        <trans-unit id="c3c2f48f1eb008d449f48eb15990b4f6e424e20b" translate="yes" xml:space="preserve">
          <source>You always must specify a value when declaring a variable using &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">Siempre debe especificar un valor al declarar una variable usando &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0790cbb95ab5ec73d3e6258998a0a7ad3095843b" translate="yes" xml:space="preserve">
          <source>You can't declare the same variable multiple times using &lt;code&gt;let&lt;/code&gt;. You also can't declare a variable using &lt;code&gt;let&lt;/code&gt; with the same identifier as another variable which was declared using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">No puede declarar la misma variable varias veces usando &lt;code&gt;let&lt;/code&gt; . Tampoco puede declarar una variable usando &lt;code&gt;let&lt;/code&gt; con el mismo identificador que otra variable que se declar&amp;oacute; usando &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2fce063a96f03a5121674374be0af6b8b24bce2" translate="yes" xml:space="preserve">
          <source>e.g. It scopes to the enclosing block, They don't exist before they're declared, etc.</source>
          <target state="translated">p.ej.Alcanza el bloque de cierre,no existen antes de ser declarados,etc.</target>
        </trans-unit>
        <trans-unit id="d313532c8abb336dd50ad99fcaa46af296c26e1d" translate="yes" xml:space="preserve">
          <source>let is a part of es6. These functions will explain the difference in easy way.</source>
          <target state="translated">Vamos a ser parte de ESO.Estas funciones explicarán la diferencia de manera fácil.</target>
        </trans-unit>
        <trans-unit id="c0ef6b5ab2d1b894e89fcae400b0537fb9a8b5ce" translate="yes" xml:space="preserve">
          <source>let vs var. It's all about &lt;strong&gt;scope&lt;/strong&gt;.</source>
          <target state="translated">let vs var. Se trata de &lt;strong&gt;alcance&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c278d52dd0385cbf90b767810934740d91018546" translate="yes" xml:space="preserve">
          <source>one of the most famous interview questions on scope also can suffice the exact use of &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; as below;</source>
          <target state="translated">Una de las preguntas de entrevista m&amp;aacute;s famosas sobre el alcance tambi&amp;eacute;n puede ser suficiente para el uso exacto de &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;var&lt;/code&gt; como se muestra a continuaci&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="2d408aaa5a340d732402a346a7f915ed8a3d8a04" translate="yes" xml:space="preserve">
          <source>test.js</source>
          <target state="translated">test.js</target>
        </trans-unit>
        <trans-unit id="b8ffef03491342b55d430f0b8e5920b4a84fcdb6" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;let&lt;/code&gt;&lt;strong&gt;don't&lt;/strong&gt; get hoisted:</source>
          <target state="translated">Las variables con &lt;code&gt;let&lt;/code&gt; &lt;strong&gt;no&lt;/strong&gt; se izan:</target>
        </trans-unit>
        <trans-unit id="c588190991c2844f3923ec38efe295f544b19b2e" translate="yes" xml:space="preserve">
          <source>variables with &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;do&lt;/strong&gt; get hoisted:</source>
          <target state="translated">las variables con &lt;code&gt;var&lt;/code&gt; se alzan:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
